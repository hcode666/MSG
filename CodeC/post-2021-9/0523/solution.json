["def presufop():\n    for t in range(int(input())):\n        n = int(input())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        (op1, op2) = (b[0] - a[0], 0)\n        (res1, res2) = (0, 0)\n        for i in range(n):\n            if op1 + op2 < b[i] - a[i]:\n                op2 += b[i] - a[i] - op1 - op2\n            elif op1 + op2 > b[i] - a[i]:\n                op1 -= op1 + op2 - (b[i] - a[i])\n            if op1 < 0 or op2 > b[n - 1] - a[n - 1]:\n                res1 = -1\n                res2 = 0\n                break\n            res1 = max(res1, op1)\n            res2 = max(res2, op2)\n        print(res1 + res2)\npresufop()", "def presufop():\n    for t in range(int(input())):\n        n = int(input())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        (op1, op2) = (b[0] - a[0], 0)\n        (res1, res2) = (0, 0)\n        for i in range(n):\n            if op1 + op2 < b[i] - a[i]:\n                op2 += b[i] - a[i] - op1 - op2\n            elif op1 + op2 > b[i] - a[i]:\n                op1 -= op1 + op2 - (b[i] - a[i])\n            if op1 < 0 or op2 > b[n - 1] - a[n - 1]:\n                res1 = -1\n                res2 = 0\n                break\n            res1 = max(res1, op1)\n            res2 = max(res2, op2)\n        print(res1 + res2)\npresufop()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    if a == b:\n        print(0)\n    elif any((a[i] > b[i] for i in range(n))):\n        print(-1)\n    else:\n        (ans, suff_sum, pref_add) = (0, 0, 0)\n        for i in range(n):\n            if i == 0:\n                ans += b[0] - a[0]\n                pref_add = ans\n            else:\n                diff = b[i] - a[i] - suff_sum\n                if diff < 0:\n                    ans = -1\n                    break\n                if diff >= pref_add:\n                    suff_sum += diff - pref_add\n                else:\n                    pref_add = diff\n            if i == n - 1:\n                ans += suff_sum\n        print(ans)", "from sys import stdin, stdout\nfrom collections import Counter, defaultdict, deque\nfrom math import sqrt, factorial, ceil\nimport heapq\ninf = float('inf')\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    poss = True\n    diff = [0 for j in range(n)]\n    for j in range(n):\n        if a[j] > b[j]:\n            poss = False\n            break\n        else:\n            diff[j] = b[j] - a[j]\n    if poss:\n        ans = 0\n        leftsum = diff[0]\n        rightsum = 0\n        prevval = diff[0]\n        for j in diff:\n            cval = j - rightsum\n            if cval < 0:\n                ans = -1\n                break\n            elif cval < prevval:\n                prevval = cval\n            cright = cval - prevval\n            rightsum += cright\n            ans += cright\n        if ans == -1:\n            leftsum = 0\n        print(ans + leftsum)\n    else:\n        print(-1)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    f = b[0] - a[0]\n    s = 0\n    x = y = 0\n    for i in range(n):\n        if f + s < b[i] - a[i]:\n            s += b[i] - a[i] - f - s\n        elif f + s > b[i] - a[i]:\n            f -= f + s - (b[i] - a[i])\n        if f < 0 or s > b[n - 1] - a[n - 1]:\n            x = -1\n            y = 0\n            break\n        x = max(x, f)\n        y = max(y, s)\n    print(x + y)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    first = b[0] - a[0]\n    second = 0\n    x = y = 0\n    for i in range(n):\n        if first + second < b[i] - a[i]:\n            second += b[i] - a[i] - first - second\n        elif first + second > b[i] - a[i]:\n            first -= first + second - (b[i] - a[i])\n        if first < 0 or second > b[n - 1] - a[n - 1]:\n            x = -1\n            y = 0\n            break\n        x = max(x, first)\n        y = max(y, second)\n    print(x + y)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    aa = b[0] - a[0]\n    bb = 0\n    ans1 = 0\n    ans2 = 0\n    for i in range(n):\n        if aa + bb < b[i] - a[i]:\n            bb += b[i] - a[i] - aa - bb\n        elif aa + bb > b[i] - a[i]:\n            aa -= aa + bb - (b[i] - a[i])\n        if aa < 0 or bb > b[n - 1] - a[n - 1]:\n            ans1 = -1\n            ans2 = 0\n            break\n        ans1 = max(ans1, aa)\n        ans2 = max(ans2, bb)\n    ans = ans1 + ans2\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    aa = b[0] - a[0]\n    bb = 0\n    ans1 = 0\n    ans2 = 0\n    for i in range(n):\n        if aa + bb < b[i] - a[i]:\n            bb += b[i] - a[i] - aa - bb\n        elif aa + bb > b[i] - a[i]:\n            aa -= aa + bb - (b[i] - a[i])\n        if aa < 0 or bb > b[n - 1] - a[n - 1]:\n            ans1 = -1\n            ans2 = 0\n            break\n        ans1 = max(ans1, aa)\n        ans2 = max(ans2, bb)\n    ans = ans1 + ans2\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    ans = 0\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    a = [b[i] - a[i] for i in range(n)]\n    for i in range(n - 1):\n        if a[i + 1] < a[i]:\n            ans += a[i] - a[i + 1]\n    if ans > a[0]:\n        print(-1)\n        continue\n    an = 0\n    for i in range(1, n):\n        if a[i] < a[i - 1]:\n            an += abs(a[i] - a[i - 1])\n    an += a[-1]\n    print(an)", "from math import ceil, gcd, factorial, sqrt, log, log2\nimport queue\nfrom itertools import permutations, combinations, accumulate, product\nfrom collections import Counter, deque\nfrom sys import stdin, stdout\nfrom bisect import bisect, insort, bisect_left, insort_left\ninput = stdin.readline\n\ndef sieve(n):\n    prime = [True] * (n + 1)\n    p = 2\n    prime[0] = False\n    prime[1] = False\n    for p in range(2, int(n ** 0.5) + 1):\n        if prime[p] == True:\n            for l1 in range(p * p, n + 1, p):\n                prime[l1] = False\n    return prime\n\ndef simplesieve(n):\n    prime = [2]\n    mak = [False] * (n + 1)\n    for p in range(3, n + 1, 2):\n        if mak[p] == False:\n            prime.append(p)\n            if p * p <= n:\n                for l1 in range(p * p, n + 1, 2 * p):\n                    mak[l1] = True\n    return prime\n\ndef segementedsieve(low, high):\n    primes = simplesieve(int(high ** 0.5))\n    prime = [True] * (high - low + 1)\n    for i in primes:\n        lower = low // i * i\n        if lower < low:\n            lower += i\n        for j in range(lower, high + 1, i):\n            if j != i:\n                prime[j - low] = False\n    ans = []\n    for i in range(low, high + 1):\n        if prime[i - low]:\n            ans.append(i)\n    return ans\n\ndef isprime(n):\n    if n == 2:\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    for l1 in range(3, int(n ** 0.5) + 1, 2):\n        if n % l1 == 0:\n            return False\n    return True\n\ndef binpow(a, b, m):\n    r2 = 1\n    a = a % m\n    while b > 0:\n        if b & 1:\n            r2 = r2 * a % m\n        a = a * a % m\n        b >>= 1\n    return r2\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\n\ndef gcdExtended(a, b):\n    if b == 0:\n        return (a, 1, 0)\n    (g, x1, y1) = gcdExtended(b, a % b)\n    (x1, y1) = (y1, x1 - a // b * y1)\n    return (g, x1, y1)\n\ndef binseach(a, l, r, key):\n    while r - l > 1:\n        m = l + (r - l) // 2\n        if a[m] <= key:\n            l = m\n        else:\n            r = m\n    if a[l] == key:\n        return l\n    if a[r] == key:\n        return r\n    return -1\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef inorder(root):\n    (res, stack) = ([], [])\n    current = root\n    while True:\n        while current:\n            stack.append(current)\n            current = current.left\n        if len(stack) == 0:\n            return res\n        node = stack[-1]\n        stack.pop(len(stack) - 1)\n        if node.data != None:\n            res.append(node.data)\n        current = node.right\n    return res\n\ndef dfs(graph, s, v, ans):\n    v[s] = 1\n    ans.append(s)\n    for i in graph[s]:\n        if v[i] == 0:\n            dfs(graph, i, v, ans)\n\ndef bfs(graph, n, x, dest):\n    v = [0] * (1 + n)\n    d = [0] * (1 + n)\n    d[x] = 0\n    v[x] = 1\n    q = queue.Queue()\n    q.put(x)\n    while not q.empty():\n        z = q.get()\n        for s in graph[z]:\n            if v[s] == 0:\n                v[s] = 1\n                d[s] = d[z] + 1\n                q.put(s)\n    return d[dest]\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    k = b[0] - a[0]\n    c = 0\n    r1 = r2 = 0\n    for i in range(n):\n        if k + c < b[i] - a[i]:\n            c = b[i] - a[i] - k\n        elif k + c > b[i] - a[i]:\n            k -= k + c - (b[i] - a[i])\n        if k < 0 or c > b[n - 1] - a[n - 1]:\n            r1 = -1\n            r2 = 0\n            break\n        r1 = max(r1, k)\n        r2 = max(r2, c)\n    print(r1 + r2)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ans1 = b[0] - a[0]\n    ans2 = 0\n    rem1 = rem2 = 0\n    for i in range(n):\n        if ans1 + ans2 < b[i] - a[i]:\n            ans2 += b[i] - a[i] - ans1 - ans2\n        elif ans1 + ans2 > b[i] - a[i]:\n            ans1 -= ans1 + ans2 - (b[i] - a[i])\n        if ans1 < 0 or ans2 > b[-1] - a[-1]:\n            rem1 = -1\n            rem2 = 0\n            break\n        rem1 = max(rem1, ans1)\n        rem2 = max(rem2, ans2)\n    out = rem1 + rem2\n    print(out)", "def findForSlope(A):\n    ret = [0]\n    for i in range(len(A) - 1):\n        ret.append(A[i + 1] - A[i])\n    return ret\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n    sB = findForSlope(B)\n    sA = findForSlope(A)\n    rn = []\n    imp = False\n    for i in range(n):\n        diff = B[i] - A[i]\n        if diff < 0:\n            imp = True\n        rn.append(diff)\n    if imp:\n        print('-1')\n        continue\n    if n == 1:\n        print(rn[0])\n        continue\n    minranr = [0] * n\n    minranr[n - 1] = rn[n - 1]\n    minranl = [0] * n\n    minranl[0] = rn[0]\n    for i in range(1, n, 1):\n        minranl[i] = min(rn[i], minranl[i - 1])\n    for i in range(n - 2, -1, -1):\n        minranr[i] = min(rn[i], minranr[i + 1])\n    smA = sum(A)\n    smB = sum(B)\n    smadd = 0\n    ans = 0\n    lf = 10 ** 20\n    rf = 0\n    for i in range(n):\n        diff = sB[i] - sA[i]\n        if diff < 0:\n            lff = min(lf, minranl[i - 1])\n            if lff < abs(diff):\n                imp = True\n                break\n            ans += abs(diff)\n            smadd += abs(diff) * i\n            lf = lff - abs(diff)\n        if diff > 0:\n            rff = minranr[i] - rf\n            if rff < diff:\n                imp = True\n                break\n            ans += diff\n            rf = rf + abs(diff)\n            smadd += diff * (n - i)\n    if imp:\n        print('-1')\n        continue\n    ans += int((smB - smA - smadd) / n)\n    print(ans)", "from bisect import bisect_left\nimport os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n    n = inp()\n    a = li()\n    b = li()\n    mi = INF\n    diff = [b[i] - a[i] for i in range(n)]\n    for i in range(n):\n        if diff[i] < 0:\n            pr(-1)\n            return\n        if i:\n            if diff[i - 1] > diff[i]:\n                pr(-1)\n                return\n            mi = min(mi, diff[i] - diff[i - 1])\n        else:\n            mi = min(mi, diff[i])\n        diff[i] -= mi\n    pr(b[0] - a[0] + diff[-1])\nfor _ in range(inp()):\n    solve()"]