["import heapq\nimport math\n\ndef get_distances(adjacencies, root):\n    min_dist = len(adjacencies) * [math.inf]\n    to_visit = [(0, root)]\n    while len(to_visit) != 0:\n        (dist, i) = heapq.heappop(to_visit)\n        if dist < min_dist[i]:\n            assert min_dist[i] == math.inf\n            min_dist[i] = dist\n            for new_i in adjacencies[i]:\n                heapq.heappush(to_visit, (dist + 1, new_i))\n    return min_dist\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    adjacencies = []\n    for i in range(n):\n        adjacencies.append([])\n    k = int(input())\n    for __ in range(k):\n        (u, v) = (int(x) for x in input().split())\n        adjacencies[u - 1].append(v - 1)\n        adjacencies[v - 1].append(u - 1)\n    dists_0 = get_distances(adjacencies, 0)\n    max_dist = max(dists_0)\n    if max_dist == 1:\n        print(1)\n        print('1 ' * n)\n        print(1)\n        continue\n    assert max_dist >= 2 and max_dist <= 3\n    assigned_department = n * [None]\n    num_depts = 0\n    for i in range(n):\n        if dists_0[i] == max_dist and assigned_department[i] is None:\n            assigned_department[i] = num_depts\n            for j in adjacencies[i]:\n                assigned_department[j] = num_depts\n            num_depts += 1\n    for i in range(n):\n        if assigned_department[i] is None:\n            assigned_department[i] = num_depts\n    num_depts += 1\n    heads = num_depts * [None]\n    for i in range(n):\n        if any((assigned_department[j] != assigned_department[i] for j in adjacencies[i])):\n            heads[assigned_department[i]] = i\n    print(num_depts)\n    for x in assigned_department:\n        print(x + 1, end=' ')\n    print()\n    for x in heads:\n        print(x + 1, end=' ')\n    print()", "import heapq\nimport math\n\ndef get_distances(adjacencies, root):\n    min_dist = len(adjacencies) * [math.inf]\n    to_visit = [(0, root)]\n    while len(to_visit) != 0:\n        (dist, i) = heapq.heappop(to_visit)\n        if dist < min_dist[i]:\n            assert min_dist[i] == math.inf\n            min_dist[i] = dist\n            for new_i in adjacencies[i]:\n                heapq.heappush(to_visit, (dist + 1, new_i))\n    return min_dist\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    adjacencies = []\n    for i in range(n):\n        adjacencies.append([])\n    k = int(input())\n    for __ in range(k):\n        (u, v) = (int(x) for x in input().split())\n        adjacencies[u - 1].append(v - 1)\n        adjacencies[v - 1].append(u - 1)\n    dists_0 = get_distances(adjacencies, 0)\n    max_dist = max(dists_0)\n    if max_dist == 1:\n        print(1)\n        print('1 ' * n)\n        print(1)\n        continue\n    assert max_dist >= 2 and max_dist <= 3\n    assigned_department = n * [None]\n    num_depts = 0\n    for i in range(n):\n        if dists_0[i] == max_dist and assigned_department[i] is None:\n            assigned_department[i] = num_depts\n            for j in adjacencies[i]:\n                assigned_department[j] = num_depts\n            num_depts += 1\n    for i in range(n):\n        if assigned_department[i] is None:\n            assigned_department[i] = num_depts\n    num_depts += 1\n    heads = num_depts * [None]\n    for i in range(n):\n        if any((assigned_department[j] != assigned_department[i] for j in adjacencies[i])):\n            heads[assigned_department[i]] = i\n    print(num_depts)\n    for x in assigned_department:\n        print(x + 1, end=' ')\n    print()\n    for x in heads:\n        print(x + 1, end=' ')\n    print()", "import heapq\nimport math\n\ndef get_distances(adjacencies, root):\n    min_dist = len(adjacencies) * [math.inf]\n    to_visit = [(0, root)]\n    while len(to_visit) != 0:\n        (dist, i) = heapq.heappop(to_visit)\n        if dist < min_dist[i]:\n            assert min_dist[i] == math.inf\n            min_dist[i] = dist\n            for new_i in adjacencies[i]:\n                heapq.heappush(to_visit, (dist + 1, new_i))\n    return min_dist\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    adjacencies = []\n    for i in range(n):\n        adjacencies.append([])\n    k = int(input())\n    for __ in range(k):\n        (u, v) = (int(x) for x in input().split())\n        adjacencies[u - 1].append(v - 1)\n        adjacencies[v - 1].append(u - 1)\n    dists_0 = get_distances(adjacencies, 0)\n    max_dist = max(dists_0)\n    if max_dist == 1:\n        print(1)\n        print('1 ' * n)\n        print(1)\n        continue\n    assert max_dist >= 2 and max_dist <= 3\n    assigned_department = n * [None]\n    num_depts = 0\n    for i in range(n):\n        if dists_0[i] == max_dist and assigned_department[i] is None:\n            assigned_department[i] = num_depts\n            for j in adjacencies[i]:\n                assigned_department[j] = num_depts\n            num_depts += 1\n    for i in range(n):\n        if assigned_department[i] is None:\n            assigned_department[i] = num_depts\n    num_depts += 1\n    heads = num_depts * [None]\n    for i in range(n):\n        if any((assigned_department[j] != assigned_department[i] for j in adjacencies[i])):\n            heads[assigned_department[i]] = i\n    print(num_depts)\n    for x in assigned_department:\n        print(x + 1, end=' ')\n    print()\n    for x in heads:\n        print(x + 1, end=' ')\n    print()", "t = int(input())\n\ndef Intersection(lst1, lst2):\n    return set(lst1).intersection(lst2)\nfor _ in range(t):\n    n = int(input())\n    pair = int(input())\n    d = {}\n    for value in range(pair):\n        (a, b) = map(int, input().split())\n        if a in d:\n            d[a].append(b)\n        else:\n            d[a] = [b]\n        if b in d:\n            d[b].append(a)\n        else:\n            d[b] = [a]\n    d = dict(sorted(d.items(), key=lambda item: len(item[1])))\n    if n == 2:\n        print(1)\n        print(1, 1)\n        print(1)\n        continue\n    for (key, value) in d.items():\n        smallestKey = key\n        break\n    values = []\n    values = d[smallestKey]\n    totalValues = values.copy()\n    totalValues.append(smallestKey)\n    manager = []\n    managerDict = {}\n    for i in values:\n        for j in d[i]:\n            if j in totalValues:\n                continue\n            else:\n                manager.append(j)\n                manager.append(i)\n    for (key, value) in d.items():\n        if manager in value:\n            manager.append(key)\n    managerSet = set(manager.copy())\n    manager = list(managerSet)\n    for i in range(len(manager)):\n        managerDict[manager[i]] = i + 1\n    print(len(managerSet))\n    ans = []\n    for i in range(n):\n        if i + 1 in manager:\n            ans.append(managerDict[i + 1])\n            continue\n        common = Intersection(d[i + 1], manager).pop()\n        ans.append(managerDict[common])\n    print(*ans)\n    print(*managerSet)", "from collections import *\nfor _ in range(int(input())):\n    n = int(input())\n    d = [0] * (n + 1)\n    arr = []\n    q = int(input())\n    gr = [[] for i in range(n + 1)]\n    for i in range(q):\n        arr.append(list(map(int, input().split())))\n        d[arr[i][0]] += 1\n        d[arr[i][1]] += 1\n        gr[arr[i][0]].append(arr[i][1])\n        gr[arr[i][1]].append(arr[i][0])\n    new = []\n    for i in range(1, n + 1):\n        new.append([i, d[i]])\n    new.sort(key=lambda x: x[-1], reverse=True)\n    root = new[0][0]\n    d = deque()\n    d.append(root)\n    par = [-1] * (n + 1)\n    par[root] = root\n    v = set()\n    v.add(root)\n    while d:\n        x = d.popleft()\n        for i in gr[x]:\n            if i not in v:\n                par[i] = x\n                v.add(i)\n                d.append(i)\n    s = set()\n    for i in range(1, n + 1):\n        s.add(par[i])\n    if -1 in s:\n        s.remove(-1)\n    print(len(s))\n    he = sorted(list(s))\n    d = defaultdict(lambda : 0)\n    for i in range(len(he)):\n        d[he[i]] = i + 1\n        par[he[i]] = he[i]\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = d[par[i]]\n    print(*ans[1:])\n    print(*he)", "t = int(input())\n\ndef Intersection(lst1, lst2):\n    return set(lst1).intersection(lst2)\nfor _ in range(t):\n    n = int(input())\n    pair = int(input())\n    d = {}\n    for value in range(pair):\n        (a, b) = map(int, input().split())\n        if a in d:\n            d[a].append(b)\n        else:\n            d[a] = [b]\n        if b in d:\n            d[b].append(a)\n        else:\n            d[b] = [a]\n    d = dict(sorted(d.items(), key=lambda item: len(item[1])))\n    if n == 2:\n        print(1)\n        print(1, 1)\n        print(1)\n        continue\n    for (key, value) in d.items():\n        smallestKey = key\n        break\n    values = []\n    values = d[smallestKey]\n    totalValues = values.copy()\n    totalValues.append(smallestKey)\n    manager = []\n    managerDict = {}\n    for i in values:\n        for j in d[i]:\n            if j in totalValues:\n                continue\n            else:\n                manager.append(j)\n                manager.append(i)\n    for (key, value) in d.items():\n        if manager in value:\n            manager.append(key)\n    managerSet = set(manager.copy())\n    manager = list(managerSet)\n    for i in range(len(manager)):\n        managerDict[manager[i]] = i + 1\n    print(len(managerSet))\n    ans = []\n    for i in range(n):\n        if i + 1 in manager:\n            ans.append(managerDict[i + 1])\n            continue\n        common = Intersection(d[i + 1], manager).pop()\n        ans.append(managerDict[common])\n    print(*ans)\n    print(*managerSet)", "t = int(input())\n\ndef Intersection(lst1, lst2):\n    return set(lst1).intersection(lst2)\nfor _ in range(t):\n    n = int(input())\n    pair = int(input())\n    d = {}\n    for value in range(pair):\n        (a, b) = map(int, input().split())\n        if a in d:\n            d[a].append(b)\n        else:\n            d[a] = [b]\n        if b in d:\n            d[b].append(a)\n        else:\n            d[b] = [a]\n    d = dict(sorted(d.items(), key=lambda item: len(item[1])))\n    if n == 2:\n        print(1)\n        print(1, 1)\n        print(1)\n        continue\n    for (key, value) in d.items():\n        smallestKey = key\n        break\n    values = []\n    values = d[smallestKey]\n    totalValues = values.copy()\n    totalValues.append(smallestKey)\n    manager = []\n    managerDict = {}\n    for i in values:\n        for j in d[i]:\n            if j in totalValues:\n                continue\n            else:\n                manager.append(j)\n                manager.append(i)\n    for (key, value) in d.items():\n        if manager in value:\n            manager.append(key)\n    managerSet = set(manager.copy())\n    manager = list(managerSet)\n    for i in range(len(manager)):\n        managerDict[manager[i]] = i + 1\n    print(len(managerSet))\n    ans = []\n    for i in range(n):\n        if i + 1 in manager:\n            ans.append(managerDict[i + 1])\n            continue\n        common = Intersection(d[i + 1], manager).pop()\n        ans.append(managerDict[common])\n    print(*ans)\n    print(*managerSet)", "t = int(input())\n\ndef Intersection(lst1, lst2):\n    return set(lst1).intersection(lst2)\nfor _ in range(t):\n    n = int(input())\n    pair = int(input())\n    d = {}\n    for value in range(pair):\n        (a, b) = map(int, input().split())\n        if a in d:\n            d[a].append(b)\n        else:\n            d[a] = [b]\n        if b in d:\n            d[b].append(a)\n        else:\n            d[b] = [a]\n    d = dict(sorted(d.items(), key=lambda item: len(item[1])))\n    if n == 2:\n        print(1)\n        print(1, 1)\n        print(1)\n        continue\n    for (key, value) in d.items():\n        smallestKey = key\n        break\n    values = []\n    values = d[smallestKey]\n    totalValues = values.copy()\n    totalValues.append(smallestKey)\n    manager = []\n    managerDict = {}\n    for i in values:\n        for j in d[i]:\n            if j in totalValues:\n                continue\n            else:\n                manager.append(j)\n                manager.append(i)\n    for (key, value) in d.items():\n        if manager in value:\n            manager.append(key)\n    managerSet = set(manager.copy())\n    manager = list(managerSet)\n    for i in range(len(manager)):\n        managerDict[manager[i]] = i + 1\n    print(len(managerSet))\n    ans = []\n    for i in range(n):\n        if i + 1 in manager:\n            ans.append(managerDict[i + 1])\n            continue\n        common = Intersection(d[i + 1], manager).pop()\n        ans.append(managerDict[common])\n    print(*ans)\n    print(*managerSet)", "t = int(input())\n\ndef Intersection(lst1, lst2):\n    return set(lst1).intersection(lst2)\nfor _ in range(t):\n    n = int(input())\n    pair = int(input())\n    d = {}\n    for value in range(pair):\n        (a, b) = map(int, input().split())\n        if a in d:\n            d[a].append(b)\n        else:\n            d[a] = [b]\n        if b in d:\n            d[b].append(a)\n        else:\n            d[b] = [a]\n    d = dict(sorted(d.items(), key=lambda item: len(item[1])))\n    if n == 2:\n        print(1)\n        print(1, 1)\n        print(1)\n        continue\n    for (key, value) in d.items():\n        smallestKey = key\n        break\n    values = []\n    values = d[smallestKey]\n    totalValues = values.copy()\n    totalValues.append(smallestKey)\n    manager = []\n    managerDict = {}\n    for i in values:\n        for j in d[i]:\n            if j in totalValues:\n                continue\n            else:\n                manager.append(j)\n                manager.append(i)\n    for (key, value) in d.items():\n        if manager in value:\n            manager.append(key)\n    managerSet = set(manager.copy())\n    manager = list(managerSet)\n    for i in range(len(manager)):\n        managerDict[manager[i]] = i + 1\n    print(len(managerSet))\n    ans = []\n    for i in range(n):\n        if i + 1 in manager:\n            ans.append(managerDict[i + 1])\n            continue\n        common = Intersection(d[i + 1], manager).pop()\n        ans.append(managerDict[common])\n    print(*ans)\n    print(*managerSet)", "t = int(input())\n\ndef Intersection(lst1, lst2):\n    return set(lst1).intersection(lst2)\nfor _ in range(t):\n    n = int(input())\n    pair = int(input())\n    d = {}\n    for value in range(pair):\n        (a, b) = map(int, input().split())\n        if a in d:\n            d[a].append(b)\n        else:\n            d[a] = [b]\n        if b in d:\n            d[b].append(a)\n        else:\n            d[b] = [a]\n    d = dict(sorted(d.items(), key=lambda item: len(item[1])))\n    if n == 2:\n        print(1)\n        print(1, 1)\n        print(1)\n        continue\n    for (key, value) in d.items():\n        smallestKey = key\n        break\n    values = []\n    values = d[smallestKey]\n    totalValues = values.copy()\n    totalValues.append(smallestKey)\n    manager = []\n    managerDict = {}\n    for i in values:\n        for j in d[i]:\n            if j in totalValues:\n                continue\n            else:\n                manager.append(j)\n                manager.append(i)\n    for (key, value) in d.items():\n        if manager in value:\n            manager.append(key)\n    managerSet = set(manager.copy())\n    manager = list(managerSet)\n    for i in range(len(manager)):\n        managerDict[manager[i]] = i + 1\n    print(len(managerSet))\n    ans = []\n    for i in range(n):\n        if i + 1 in manager:\n            ans.append(managerDict[i + 1])\n            continue\n        common = Intersection(d[i + 1], manager).pop()\n        ans.append(managerDict[common])\n    print(*ans)\n    print(*managerSet)", "y = lambda : map(int, input().split())\n(t,) = y()\nfor _ in range(t):\n    (n,) = y()\n    (k,) = y()\n    g = [[] for _ in range(n)]\n    for _ in range(k):\n        (u, v) = y()\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    a = (*map(len, g),)\n    u = a.index(min(a))\n    r = [None] * n\n    r[u] = 1\n    for v in g[u]:\n        r[v] = 1\n        if a[v] > a[u]:\n            u = v\n    h = []\n    for v in g[u]:\n        if r[v] is None:\n            h.append(v + 1)\n            r[v] = len(h) + 1\n    for v in h:\n        for w in g[v - 1]:\n            if r[w] is None:\n                r[w] = r[v - 1]\n    print(len(h) + 1)\n    print(*r)\n    print(u + 1, *h)", "R = lambda : map(int, input().split())\n(t,) = R()\nfor _ in range(t):\n    (n,) = R()\n    (k,) = R()\n    g = [[] for _ in range(n)]\n    for _ in range(k):\n        (u, v) = R()\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    a = (*map(len, g),)\n    u = a.index(min(a))\n    r = [None] * n\n    r[u] = 1\n    for v in g[u]:\n        r[v] = 1\n        if a[v] > a[u]:\n            u = v\n    h = []\n    for v in g[u]:\n        if r[v] is None:\n            h.append(v + 1)\n            r[v] = len(h) + 1\n    for v in h:\n        for w in g[v - 1]:\n            if r[w] is None:\n                r[w] = r[v - 1]\n    print(len(h) + 1)\n    print(*r)\n    print(u + 1, *h)", "from collections import defaultdict\nt = int(input())\n\ndef find_manager(degrees, adj, idx):\n    for neigh in adj[idx]:\n        if degrees[neigh] > degrees[idx]:\n            return neigh\n    return None\n\ndef make_all_neighbours_of_non_manager_as_non_manager(adj, degrees, managers, idx, l):\n    manager = find_manager(degrees, adj, idx)\n    for neigh in adj[idx]:\n        managers[neigh] = l\n    managers[idx] = l\n    return manager\n\ndef print_solution(managers, all_managers):\n    print(len(all_managers))\n    print(' '.join(list(map(str, managers[1:]))))\n    print(' '.join(list(map(str, all_managers))))\n\ndef find_min_index(N, degrees, managers):\n    min_val = N\n    min_idx = -1\n    for i in range(1, N + 1):\n        if managers[i] == -1 and min_val > degrees[i]:\n            min_val = degrees[i]\n            min_idx = i\n    return min_idx\n\ndef solution(N, adj, degrees, managers):\n    all_managers = []\n    while True:\n        min_idx = find_min_index(N, degrees, managers)\n        if min_idx == -1:\n            print_solution(managers, all_managers)\n            return\n        manager = find_manager(degrees, adj, min_idx)\n        all_managers.append(manager)\n        make_all_neighbours_of_non_manager_as_non_manager(adj, degrees, managers, min_idx, len(all_managers))\n\ndef check_if_one_manager(mat, N):\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if mat[i][j] == False:\n                return False\n    return True\n\ndef print_solution_for_single_manager(N):\n    print(1)\n    print(' '.join(list(map(str, [1] * N))))\n    print(1)\n\ndef solve(N, C):\n    adj = defaultdict(lambda : [])\n    mat = [[False for _ in range(N + 1)] for _ in range(N + 1)]\n    for (f, t) in C:\n        adj[f].append(t)\n        adj[t].append(f)\n        mat[f][t] = True\n        mat[t][f] = True\n    if check_if_one_manager(mat, N):\n        print_solution_for_single_manager(N)\n        return\n    degrees = [0 for _ in range(N + 1)]\n    managers = [-1 for _ in range(N + 1)]\n    for i in range(N + 1):\n        degrees[i] = len(adj[i])\n    solution(N, adj, degrees, managers)\nfor _ in range(t):\n    N = int(input())\n    K = int(input())\n    C = []\n    for _ in range(K):\n        C.append(tuple(map(int, input().split())))\n    solve(N, C)", "from collections import defaultdict\nfrom collections import defaultdict, deque, Counter\nfrom itertools import groupby, accumulate, cycle, chain\nfrom bisect import bisect_left, bisect_right\nfrom math import inf\nfrom string import ascii_lowercase, ascii_uppercase\nfrom copy import deepcopy\nfrom heapq import heapify, heappush, heappop\nfrom functools import lru_cache\nimport re\nT = int(input())\nvt = lambda t: [t(num) for num in input().split()]\nit = lambda : vt(int)[0]\nst = lambda a: a.sort()\n\ndef run_tc():\n    n = it()\n    e = it()\n    ind = defaultdict(int)\n    adj = defaultdict(list)\n    for _ in range(e):\n        (u, v) = vt(int)\n        ind[u] += 1\n        ind[v] += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    S = sorted(ind.items(), key=lambda x: x[1])\n    u = S[0][0]\n    m = None\n    for v in adj[u]:\n        if ind[v] > ind[u]:\n            m = v\n            break\n    if m is not None:\n        mgr = [x for x in adj[m] if ind[x] != ind[u]]\n        mgr += [m]\n        mgr.sort()\n        ans = [0] * n\n        D = 1\n        seen = set(mgr)\n        for y in mgr:\n            ans[y - 1] = D\n            for v in adj[y]:\n                if v not in seen:\n                    ans[v - 1] = D\n                    seen.add(v)\n            D += 1\n        print(len(mgr))\n        print(*ans)\n        print(*mgr)\n    else:\n        print(1)\n        print(*[1] * n)\n        print(1)\nfor _ in range(T):\n    run_tc()", "R = lambda : map(int, input().split())\n(t,) = R()\nfor _ in range(t):\n    (n,) = R()\n    (k,) = R()\n    g = [[] for _ in range(n)]\n    for _ in range(k):\n        (u, v) = R()\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    r = [None] * n\n    h = []\n    for (l, u) in sorted(((len(x), i) for (i, x) in enumerate(g))):\n        if r[u] is None:\n            h.append(u + 1)\n            r[u] = len(h)\n            for v in g[u]:\n                r[v] = r[u]\n                if len(g[v]) > l:\n                    h[-1] = v + 1\n    print(len(h))\n    print(*r)\n    print(*h)", "R = lambda : map(int, input().split())\n(t,) = R()\nfor _ in range(t):\n    (n,) = R()\n    (k,) = R()\n    g = [[] for _ in range(n)]\n    for _ in range(k):\n        (u, v) = R()\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    r = [None] * n\n    h = []\n    for (l, u) in sorted(((len(x), i) for (i, x) in enumerate(g))):\n        if r[u] is None:\n            h.append(u + 1)\n            r[u] = len(h)\n            for v in g[u]:\n                r[v] = r[u]\n                if len(g[v]) > l:\n                    h[-1] = v + 1\n    print(len(h))\n    print(*r)\n    print(*h)", "R = lambda : map(int, input().split())\n(t,) = R()\nfor _ in range(t):\n    (n,) = R()\n    (k,) = R()\n    g = [[] for _ in range(n)]\n    for _ in range(k):\n        (u, v) = R()\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    r = [None] * n\n    h = []\n    for (l, u) in sorted(((len(x), i) for (i, x) in enumerate(g))):\n        if r[u] is None:\n            h.append(u + 1)\n            r[u] = len(h)\n            for v in g[u]:\n                r[v] = r[u]\n                if len(g[v]) > l:\n                    h[-1] = v + 1\n    print(len(h))\n    print(*r)\n    print(*h)", "R = lambda : map(int, input().split())\n(t,) = R()\nfor _ in range(t):\n    (n,) = R()\n    (k,) = R()\n    g = [[] for _ in range(n)]\n    for _ in range(k):\n        (u, v) = R()\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    r = [None] * n\n    h = []\n    for (l, u) in sorted(((len(x), i) for (i, x) in enumerate(g))):\n        if r[u] is None:\n            h.append(u + 1)\n            r[u] = len(h)\n            for v in g[u]:\n                r[v] = len(h)\n                if len(g[v]) > l:\n                    h[-1] = v + 1\n    print(len(h))\n    print(*r)\n    print(*h)", "R = lambda : map(int, input().split())\n(t,) = R()\nfor _ in range(t):\n    (n,) = R()\n    (k,) = R()\n    g = [[] for _ in range(n)]\n    for _ in range(k):\n        (u, v) = R()\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    a = (*map(len, g),)\n    u = a.index(min(a))\n    r = [None] * n\n    r[u] = 1\n    for v in g[u]:\n        r[v] = 1\n        if a[v] > a[u]:\n            u = v\n    h = []\n    for v in g[u]:\n        if r[v] is None:\n            h.append(v + 1)\n            r[v] = len(h) + 1\n    for v in h:\n        for w in g[v - 1]:\n            if r[w] is None:\n                r[w] = r[v - 1]\n    print(len(h) + 1)\n    print(*r)\n    print(u + 1, *h)", "import math\nfrom bisect import bisect, bisect_left, bisect_right\nimport heapq\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as ddc\nfrom collections import Counter\n\ndef intin():\n    return int(input())\n\ndef mapin():\n    return map(int, input().split())\n\ndef strin():\n    return input().split()\nINF = 10 ** 20\nmod = 1000000007\n\ndef LIS(arr, n):\n    dp = [10 ** 9] * (n + 1)\n    for ele in arr:\n        dp[bisect_left(dp, ele)] = ele\n    return bisect_left(dp, 10 ** 9)\n\ndef exponentiation(bas, exp, mod=1000000007):\n    t = 1\n    while exp > 0:\n        if exp % 2 != 0:\n            t = t * bas % mod\n        bas = bas * bas % mod\n        exp //= 2\n    return t % mod\n\ndef MOD(p, q=1, mod=1000000007):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\nyes = 'YES'\nno = 'NO'\neven = 'EVEN'\nodd = 'ODD'\n\ndef process(graph, n, k):\n    ans = [0] * n\n    m = 1\n    heads = set()\n    head = ddc(int)\n    for i in range(n):\n        for v in graph[i]:\n            if len(graph[i]) > len(graph[v]):\n                heads.add(i)\n                head[m] = i + 1\n                ans[i] = m\n                m += 1\n                break\n    if not heads:\n        for i in range(n):\n            ans[i] = m\n        head[m] = 1\n        m += 1\n    else:\n        for w in heads:\n            for ww in heads:\n                if w != ww:\n                    graph[w].discard(ww)\n            for v in graph[w]:\n                ans[v] = ans[w]\n    print(m - 1)\n    print(*ans)\n    print(*[head[i] for i in range(1, m)])\n\ndef main():\n    for _ in range(int(input())):\n        n = intin()\n        k = intin()\n        graph = ddc(set)\n        for i in range(k):\n            (u, v) = mapin()\n            graph[u - 1].add(v - 1)\n            graph[v - 1].add(u - 1)\n        process(graph, n, k)\nmain()", "R = lambda : map(int, input().split())\n(t,) = R()\nfor _ in range(t):\n    (n,) = R()\n    (k,) = R()\n    g = [[] for _ in range(n)]\n    for _ in range(k):\n        (u, v) = R()\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    r = [None] * n\n    h = []\n    m = 0\n    for (l, u) in sorted(((len(x), i) for (i, x) in enumerate(g))):\n        if r[u] is None:\n            m += 1\n            r[u] = m\n            for v in g[u]:\n                r[v] = m\n                if len(g[v]) > l:\n                    h.append(v + 1)\n    print(m)\n    print(*r)\n    print(*(h or [1]))", "for _ in range(int(input())):\n    N = int(input())\n    K = int(input())\n    graph_data = {x: [] for x in range(1, N + 1)}\n    graph_degree = {x: 0 for x in range(1, N + 1)}\n    for i in range(K):\n        (u, v) = map(int, input().split())\n        graph_data[u].append(v)\n        graph_degree[u] += 1\n        graph_data[v].append(u)\n        graph_degree[v] += 1\n    min_degree_node = min(graph_degree, key=graph_degree.get)\n    min_degree = graph_degree[min_degree_node]\n    head = 0\n    visited = []\n    visited.append(min_degree_node)\n    if K == N * (N - 1) / 2:\n        print(1)\n        print('1 ' * N)\n        print(1)\n    else:\n        for neighbour in graph_data[min_degree_node]:\n            neighbour_degree = graph_degree[neighbour]\n            if neighbour_degree > min_degree:\n                head = neighbour\n            visited.append(neighbour)\n        visited.remove(head)\n        head_list = []\n        head_list.append(head)\n        for neighbour in graph_data[head]:\n            if neighbour not in visited:\n                head_list.append(neighbour)\n        head_list.sort()\n        res = [0 for x in range(N)]\n        l = 1\n        for i in head_list:\n            res[i - 1] = l\n            for j in graph_data[i]:\n                if j not in head_list:\n                    res[j - 1] = l\n            l += 1\n        print(len(head_list))\n        print(*res)\n        print(*head_list)", "for _ in range(int(input())):\n    N = int(input())\n    K = int(input())\n    graph_data = {x: [] for x in range(1, N + 1)}\n    graph_degree = {x: 0 for x in range(1, N + 1)}\n    for i in range(K):\n        (u, v) = map(int, input().split())\n        graph_data[u].append(v)\n        graph_degree[u] += 1\n        graph_data[v].append(u)\n        graph_degree[v] += 1\n    min_degree_node = min(graph_degree, key=graph_degree.get)\n    min_degree = graph_degree[min_degree_node]\n    head = 0\n    visited = []\n    visited.append(min_degree_node)\n    if K == N * (N - 1) / 2:\n        print(1)\n        print('1 ' * N)\n        print(1)\n    else:\n        for neighbour in graph_data[min_degree_node]:\n            neighbour_degree = graph_degree[neighbour]\n            if neighbour_degree > min_degree:\n                head = neighbour\n            visited.append(neighbour)\n        visited.remove(head)\n        head_list = []\n        head_list.append(head)\n        for neighbour in graph_data[head]:\n            if neighbour not in visited:\n                head_list.append(neighbour)\n        head_list.sort()\n        res = [0 for x in range(N)]\n        l = 1\n        for i in head_list:\n            res[i - 1] = l\n            for j in graph_data[i]:\n                if j not in head_list:\n                    res[j - 1] = l\n            l += 1\n        print(len(head_list))\n        print(*res)\n        print(*head_list)", "t = int(input())\nfor _ in range(t):\n    N = int(input())\n    K = int(input())\n    edges = []\n    graph = {}\n    for _ in range(K):\n        edges.append(tuple(map(int, input().split())))\n    for (x, y) in edges:\n        try:\n            graph[x].append(y)\n        except:\n            graph[x] = [y]\n        try:\n            graph[y].append(x)\n        except:\n            graph[y] = [x]\n    managers = set()\n    maxi = 0\n    md = -1\n    for i in graph:\n        if len(graph[i]) > maxi:\n            maxi = len(graph[i])\n            md = i\n    managers.add(md)\n    s = set(graph[md])\n    s.add(md)\n\n    def bfs(s, no):\n        s1 = set(graph[graph[no][0]])\n        s2 = set()\n        s1.add(graph[no][0])\n        for i in graph[no]:\n            s2 = set(graph[i])\n            s2.add(i)\n            if s1 != s2:\n                break\n        for i in s1:\n            if i not in s:\n                break\n        else:\n            for i in s2:\n                if i in s:\n                    managers.add(i)\n            return\n        for i in s1:\n            if i in s:\n                managers.add(i)\n    bfs(s, md)\n    if managers == s:\n        print('1')\n        print('1 ' * N)\n        print('1')\n    else:\n        print(len(managers))\n        s = ['0'] * N\n        c = 1\n        man = ''\n        for i in managers:\n            s[i - 1] = str(c)\n            man += str(i) + ' '\n            for j in graph[i]:\n                if j not in managers:\n                    s[j - 1] = str(c)\n            c += 1\n        print(' '.join(s))\n        print(man)", "T = int(input())\nfor i in range(T):\n    N = int(input())\n    K = int(input())\n    rel = {}\n    deg = {}\n    for j in range(K):\n        (a, b) = list(map(int, input().strip().split(' ')))\n        if a in rel:\n            rel[a].append(b)\n            deg[a] += 1\n        else:\n            rel[a] = [b]\n            deg[a] = 1\n        if b in rel:\n            rel[b].append(a)\n            deg[b] += 1\n        else:\n            rel[b] = [a]\n            deg[b] = 1\n    if K == N * (N - 1) // 2:\n        print(1)\n        print(('1 ' * N).strip())\n        print(1)\n    else:\n        min_deg = N + 1\n        min_deg_person = None\n        for person in deg:\n            if deg[person] < min_deg:\n                min_deg = deg[person]\n                min_deg_person = person\n        M = []\n        for frnd in rel[min_deg_person]:\n            if deg[frnd] != deg[min_deg_person]:\n                manager = frnd\n                manager_grp = set(rel[frnd])\n                manager_grp.add(frnd)\n                employee_grp = set(rel[min_deg_person])\n                employee_grp.add(min_deg_person)\n                employee_grp.remove(frnd)\n                M = list(manager_grp - employee_grp)\n                break\n        M.sort()\n        ans = []\n        for i in range(1, N + 1):\n            if i in M:\n                ans.append(M.index(i) + 1)\n            else:\n                man = list(set(M).intersection(set(rel[i])))\n                ans.append(M.index(man[0]) + 1)\n        print(len(M))\n        gr = [str(w) for w in ans]\n        gr = ' '.join(gr)\n        ma = [str(w) for w in M]\n        ma = ' '.join(ma)\n        print(gr)\n        print(ma)", "from collections import Counter\nimport numpy as np\n\ndef inparr():\n    tmparr = [int(i) for i in input().split()]\n    return tmparr\nfor _ in range(int(input())):\n    N = int(input())\n    K = int(input())\n    arr = np.zeros((N + 1, N + 1))\n    for i in range(K):\n        (x, y) = inparr()\n        arr[y][x] = 1\n        arr[x][y] = 1\n    if N == 2:\n        print('1\\n1 1\\n1\\n')\n        continue\n    d1 = Counter()\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if arr[i][j]:\n                d1[i] += 1\n                d1[j] += 1\n    minv = min(d1.values())\n    minnode = 1\n    dept1 = []\n    for i in d1:\n        if d1[i] == minv:\n            dept1.append(i)\n            break\n    minnode = dept1[0]\n    for i in range(1, N + 1):\n        if arr[i][minnode]:\n            dept1.append(i)\n    headc = d1[minnode]\n    head1 = 'na'\n    for i in dept1:\n        if d1[i] > headc:\n            head1 = i\n    d2 = Counter()\n    dheads = [head1]\n    for i in range(1, N + 1):\n        if arr[i][head1]:\n            if i not in dept1:\n                dheads.append(i)\n    office = [dept1]\n    for i in dheads[1:]:\n        tdept = [i]\n        for j in range(1, N + 1):\n            if arr[j][i] and j not in dheads:\n                tdept.append(j)\n        office.append(tdept)\n    print(len(dheads))\n    for i in range(len(dheads)):\n        for j in office[i]:\n            d2[j] = i + 1\n    for i in range(1, N + 1):\n        print(d2[i], end=' ')\n    print()\n    for i in dheads:\n        print(i, end=' ')\n    print()", "from functools import cmp_to_key\nfrom collections import Counter, deque, defaultdict, OrderedDict\nimport math\nfrom bisect import bisect, bisect_left\nimport sys\nimport re\nMOD = 10 ** 9 + 7\nMAX = -sys.maxsize\nMIN = sys.maxsize\n\nclass get:\n\n    def int():\n        return list(map(int, input().split()))\n\n    def str():\n        return input().split()\n\n    def float():\n        return list(map(float, input().split()))\n\n    def map():\n        return map(int, input().split())\n\ndef sqrt(x):\n    return int(math.sqrt(x)) + 1\n\ndef gcd(*args):\n    result = args[0]\n    for item in args:\n        result = math.gcd(result, item)\n    return result\n\ndef LCM(a, b):\n    return a * b // math.gcd(a, b)\n\ndef isPrime(n):\n    if n == 1:\n        return False\n    for i in range(2, sqrt(n)):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve():\n    n = int(input())\n    k = int(input())\n    edge = defaultdict(set)\n    (m, max_) = (0, 0)\n    for _ in range(k):\n        (a, b) = get.map()\n        edge[a].add(b)\n        edge[b].add(a)\n        if len(edge[a]) > max_:\n            max_ = len(edge[a])\n            m = a\n        if len(edge[b]) > max_:\n            max_ = len(edge[b])\n            m = b\n    if k == n * (n - 1) // 2:\n        print(1)\n        print(*[1 for i in range(n)])\n        print(1)\n        return\n    dep = {m: [1, [m]]}\n    visited = set()\n    visited.add(m)\n    heads = deque([m])\n    j = 1\n    while len(heads) > 0:\n        curr_head = heads.popleft()\n        curr_dep = dep[curr_head][0]\n        child_of_head = edge[curr_head]\n        for item in child_of_head:\n            if item not in visited:\n                visited.add(item)\n                child_of_item = edge[item]\n                ss = child_of_item.intersection(child_of_head)\n                ss.add(curr_head)\n                if child_of_item == ss:\n                    dep[curr_head][1].append(item)\n                else:\n                    dep[item] = [j + 1, [item]]\n                    j += 1\n                    heads.append(item)\n    print(len(dep))\n    emp = [0] * n\n    heads = []\n    for (a, b) in dep.items():\n        heads.append(a)\n        for item in b[1]:\n            emp[item - 1] = b[0]\n    print(*emp)\n    print(*heads)\nt = int(input())\nfor tt in range(t):\n    solve()", "import time\nimport sys\nimport math\n(mod, infi) = (1000000007, sys.maxsize)\nfrom collections import deque, Counter, defaultdict as dd\nfrom itertools import accumulate\nfrom functools import lru_cache, reduce\nfrom operator import mul, add, sub, truediv, floordiv, lt, le, eq, ne, gt, xor, concat, getitem, pow, lshift\ninty = lambda : int(input())\nstringy = lambda : input().strip()\nmappy = lambda : map(int, input().strip().split())\nfmappy = lambda : map(float, input().strip().split())\nlisty = lambda : list(map(int, input().strip().split()))\nsys.setrecursionlimit(10 ** 6)\ntick = lambda : time.perf_counter()\nlogg = lambda a, b: math.log2(a) / math.log2(b)\nacc = lambda x: list(accumulate(x))\nsign = lambda x, y: x >= 0 and y >= 0 or (x < 0 and y < 0)\nT = inty()\nfor _ in range(T):\n    n = inty()\n    k = inty()\n    graph = dd(set)\n    for _ in range(k):\n        (u, v) = mappy()\n        graph[u].add(v)\n        graph[v].add(u)\n    mini = infi\n    start = 0\n    for node in graph:\n        if len(graph[node]) < mini:\n            mini = len(graph[node])\n            start = node\n    head = set()\n    for node in graph[start]:\n        if len(graph[node]) > mini:\n            head |= graph[node] - graph[start]\n            head |= {node}\n            head -= {start}\n    if not head:\n        head |= {1}\n    z = [0] * n\n    r = 1\n    for node in head:\n        for nnode in graph[node]:\n            if nnode not in head:\n                z[nnode - 1] = r\n        z[node - 1] = r\n        r += 1\n    print(len(head))\n    print(*z)\n    print(*head)", "from collections import *\nfor _ in range(int(input())):\n    n = int(input())\n    d = [0] * (n + 1)\n    arr = []\n    q = int(input())\n    gr = [[] for i in range(n + 1)]\n    for i in range(q):\n        arr.append(list(map(int, input().split())))\n        d[arr[i][0]] += 1\n        d[arr[i][1]] += 1\n        gr[arr[i][0]].append(arr[i][1])\n        gr[arr[i][1]].append(arr[i][0])\n    new = []\n    for i in range(1, n + 1):\n        new.append([i, d[i]])\n    new.sort(key=lambda x: x[-1], reverse=True)\n    root = new[0][0]\n    d = deque()\n    d.append(root)\n    par = [-1] * (n + 1)\n    par[root] = root\n    v = set()\n    v.add(root)\n    while d:\n        x = d.popleft()\n        for i in gr[x]:\n            if i not in v:\n                par[i] = x\n                v.add(i)\n                d.append(i)\n    s = set()\n    for i in range(1, n + 1):\n        s.add(par[i])\n    if -1 in s:\n        s.remove(-1)\n    print(len(s))\n    he = sorted(list(s))\n    d = defaultdict(lambda : 0)\n    for i in range(len(he)):\n        d[he[i]] = i + 1\n        par[he[i]] = he[i]\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = d[par[i]]\n    print(*ans[1:])\n    print(*he)", "for _ in range(int(input())):\n    n = int(input())\n    k = int(input())\n    head = [[] for i in range(n + 1)]\n    child = []\n    nor = [{i} for i in range(n + 1)]\n    final = [0] * (n + 1)\n    fnlhead = []\n    if n == 2:\n        (a, b) = map(int, input().split())\n        print(1)\n        print(*[1, 1])\n        print(a)\n    else:\n        for i in range(k):\n            (a, b) = map(int, input().split())\n            nor[a].add(b)\n            nor[b].add(a)\n        for i in range(1, n + 1):\n            for j in nor[i]:\n                if nor[i] < nor[j]:\n                    head[j].append(i)\n        grp = 1\n        for i in range(n + 1):\n            if len(head[i]) != 0:\n                final[i] = grp\n                fnlhead.append(i)\n                for j in head[i]:\n                    final[j] = grp\n                grp += 1\n        print(len(fnlhead))\n        print(*final[1:])\n        print(*fnlhead)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    k = int(input())\n    gp = defaultdict(list)\n    vis = [False for i in range(n + 1)]\n    dep = 1\n    grp = {}\n    head = []\n    visits = 0\n    for i in range(k):\n        (x, y) = [int(j) for j in input().split()]\n        gp[x].append(y)\n        gp[y].append(x)\n    hd = 1\n    for i in range(1, n + 1):\n        if len(gp[i]) > len(gp[hd]):\n            hd = i\n    vis[hd] = True\n    grp[hd] = dep\n    for j in gp[hd]:\n        vis[j] = True\n        grp[j] = dep\n    head.append(hd)\n    for i in range(1, n + 1):\n        if not vis[i]:\n            dep += 1\n            vis[i] = True\n            grp[i] = dep\n            for j in gp[i]:\n                grp[j] = dep\n                if vis[j]:\n                    head.append(j)\n                vis[j] = True\n    print(dep)\n    for i in range(1, n + 1):\n        print(grp[i], end=' ')\n    print()\n    for i in head:\n        print(i, end=' ')\n    print()", "for _ in range(int(input())):\n    n = int(input())\n    k = int(input())\n    nag = {}\n    rels = [[] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        nag[i] = 0\n    for i in range(k):\n        tupi = list(map(int, input().split()))\n        nag[tupi[0]] += 1\n        nag[tupi[1]] += 1\n        rels[tupi[0]].append(tupi[1])\n        rels[tupi[1]].append(tupi[0])\n    minv = min(nag, key=nag.get)\n    neib = set()\n    neib.add(minv)\n    leader = minv\n    for i in rels[minv]:\n        if nag[i] == nag[minv]:\n            neib.add(i)\n        else:\n            leader = i\n    answer = [-1 for i in range(n)]\n    leaders = [leader]\n    for i in rels[leader]:\n        if i not in neib:\n            leaders.append(i)\n    for (i, j) in enumerate(leaders):\n        answer[j - 1] = i + 1\n        for yo in rels[j]:\n            if yo not in set(leaders):\n                answer[yo - 1] = i + 1\n    print(len(leaders))\n    print(*answer)\n    print(*leaders)", "m = int(input())\nfor i in range(m):\n    n = int(input())\n    k = int(input())\n    d = {}\n    l = [0 for j in range(n)]\n    h = []\n    if n == 2:\n        l = [1, 1]\n        h = [1]\n    for j in range(k):\n        z = input().split()\n        if int(z[0]) in d:\n            d[int(z[0])] += [int(z[1])]\n        else:\n            d[int(z[0])] = [int(z[1])]\n        if int(z[1]) in d:\n            d[int(z[1])] += [int(z[0])]\n        else:\n            d[int(z[1])] = [int(z[0])]\n    b = 1\n    for j in range(1, n + 1):\n        if l[j - 1] == 0:\n            t = d[j]\n            p = 0\n            for k in range(len(t)):\n                if len(d[t[k]]) < len(t):\n                    p = 1\n                    y = t[k]\n            if p != 1:\n                l[j - 1] = b\n                for k in range(len(t)):\n                    if len(d[t[k]]) > len(t):\n                        l[t[k] - 1] = b\n                        h += [t[k]]\n                    else:\n                        l[t[k] - 1] = b\n                b += 1\n    print(len(h))\n    print(' '.join(map(str, l)))\n    print(' '.join(map(str, h)))", "n = int(input())\nfor i in range(n):\n    e = int(input())\n    c = int(input())\n    d = {}\n    for j in range(1, e + 1):\n        d[j] = []\n        d[j].append(j)\n    for j in range(c):\n        (x, y) = map(int, input().split())\n        d[x].append(y)\n        d[y].append(x)\n    m = 1\n    for j in range(1, e + 1):\n        d[j].sort()\n        if len(d[m]) < len(d[j]):\n            m = j\n    h = []\n    h.append(m)\n    for j in d[m]:\n        f = 0\n        for k in d[j]:\n            if k in d[m]:\n                pass\n            else:\n                f = 1\n        if f == 1:\n            h.append(j)\n    print(len(h))\n    l = []\n    for j in range(1, e + 1):\n        f = 0\n        for k in range(len(h)):\n            if j in d[h[k]] and j not in h:\n                l.append(k + 1)\n                break\n        if j in h:\n            l.append(h.index(j) + 1)\n    print(*l)\n    print(*h)", "testcase = int(input())\nfor _ in range(testcase):\n    n = int(input())\n    k = int(input())\n    graph = [set() for _ in range(n + 1)]\n    for _ in range(k):\n        (a, b) = [int(num) for num in input().split()]\n        graph[a].add(b)\n        graph[b].add(a)\n    seen = set()\n    arr = []\n    deps = []\n    for i in range(1, n + 1):\n        arr.append((len(graph[i]), i))\n    arr.sort(reverse=True)\n    while arr:\n        (t, i) = arr.pop()\n        if i in seen:\n            continue\n        seen.add(i)\n        dep = [i]\n        for emp in graph[i]:\n            if len(graph[emp]) == t:\n                dep.append(emp)\n            else:\n                dep.insert(0, emp)\n            seen.add(emp)\n        deps.append(dep)\n    ans1 = [0] * n\n    for (ind, dep) in enumerate(deps):\n        for emp in dep:\n            ans1[emp - 1] = ind + 1\n    ans2 = [dep[0] for dep in deps]\n    print(len(deps))\n    print(*ans1)\n    print(*ans2)", "for _ in range(int(input())):\n    n = int(input())\n    k = int(input())\n    a = [[x] for x in range(n)]\n    for i in range(k):\n        (temp1, temp2) = map(int, input().split())\n        a[temp1 - 1].append(temp2 - 1)\n        a[temp2 - 1].append(temp1 - 1)\n    big = -1\n    pos = -1\n    for i in range(n):\n        if len(a[i]) > big:\n            pos = i\n            big = len(a[i])\n    head = []\n    for i in a[pos]:\n        if set(a[i]).issubset(set(a[pos])):\n            pass\n        else:\n            head.append(i)\n    head.insert(0, pos)\n    departs = [0 for x in range(len(head))]\n    for i in range(len(departs)):\n        departs[i] = list(set(a[head[i]]) - set(head))\n        departs[i].append(head[i])\n    emp_depart = [0 for x in range(n)]\n    for i in range(len(head)):\n        for j in departs[i]:\n            emp_depart[j] = i + 1\n        emp_depart[head[i]] = i + 1\n    print(len(departs))\n    print(*emp_depart)\n    print(*[x + 1 for x in head])", "from collections import *\n\ndef findNew(new, d):\n    for i in range(1, n + 1):\n        new.append([i, d[i]])\n    new.sort(key=lambda x: x[-1], reverse=True)\n    return new\n\ndef bfs(new, graph):\n    root = new[0][0]\n    d = deque()\n    d.append(root)\n    par = [-1] * (n + 1)\n    par[root] = root\n    v = set()\n    v.add(root)\n    while d:\n        x = d.popleft()\n        for i in graph[x]:\n            if i not in v:\n                par[i] = x\n                v.add(i)\n                d.append(i)\n    s = set()\n    for i in range(1, n + 1):\n        s.add(par[i])\n    if -1 in s:\n        s.remove(-1)\n    print(len(s))\n    he = sorted(list(s))\n    d = defaultdict(lambda : 0)\n    for i in range(len(he)):\n        d[he[i]] = i + 1\n        par[he[i]] = he[i]\n    return (d, par, he)\nfor _ in range(int(input())):\n    n = int(input())\n    d = [0] * (n + 1)\n    arr = []\n    q = int(input())\n    graph = [[] for i in range(n + 1)]\n\n    def makegraph():\n        for i in range(q):\n            arr.append(list(map(int, input().split())))\n            d[arr[i][0]] += 1\n            d[arr[i][1]] += 1\n            graph[arr[i][0]].append(arr[i][1])\n            graph[arr[i][1]].append(arr[i][0])\n    makegraph()\n    neww = findNew([], d)\n    (d, par, he) = bfs(neww, graph)\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = d[par[i]]\n    print(*ans[1:])\n    print(*he)", "m = int(input())\nfor i in range(m):\n    n = int(input())\n    k = int(input())\n    d = {}\n    l = [0 for j in range(n)]\n    h = []\n    if n == 2:\n        l = [1, 1]\n        h = [1]\n    for j in range(k):\n        z = input().split()\n        if int(z[0]) in d:\n            d[int(z[0])] += [int(z[1])]\n        else:\n            d[int(z[0])] = [int(z[1])]\n        if int(z[1]) in d:\n            d[int(z[1])] += [int(z[0])]\n        else:\n            d[int(z[1])] = [int(z[0])]\n    b = 1\n    for j in range(1, n + 1):\n        if l[j - 1] == 0:\n            t = d[j]\n            p = 0\n            for k in range(len(t)):\n                if len(d[t[k]]) < len(t):\n                    p = 1\n                    y = t[k]\n            if p != 1:\n                l[j - 1] = b\n                for k in range(len(t)):\n                    if len(d[t[k]]) > len(t):\n                        l[t[k] - 1] = b\n                        h += [t[k]]\n                    else:\n                        l[t[k] - 1] = b\n                b += 1\n    print(len(h))\n    print(' '.join(map(str, l)))\n    print(' '.join(map(str, h)))", "from functools import cmp_to_key\nfrom collections import Counter, deque, defaultdict, OrderedDict\nimport math\nfrom bisect import bisect, bisect_left\nimport sys\nimport re\nMOD = 10 ** 9 + 7\nMAX = -sys.maxsize\nMIN = sys.maxsize\n\nclass get:\n\n    def int():\n        return list(map(int, input().split()))\n\n    def str():\n        return input().split()\n\n    def float():\n        return list(map(float, input().split()))\n\n    def map():\n        return map(int, input().split())\n\ndef sqrt(x):\n    return int(math.sqrt(x)) + 1\n\ndef gcd(*args):\n    result = args[0]\n    for item in args:\n        result = math.gcd(result, item)\n    return result\n\ndef LCM(a, b):\n    return a * b // math.gcd(a, b)\n\ndef isPrime(n):\n    if n == 1:\n        return False\n    for i in range(2, sqrt(n)):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve():\n    n = int(input())\n    k = int(input())\n    edge = defaultdict(set)\n    (m, max_) = (0, 0)\n    for _ in range(k):\n        (a, b) = get.map()\n        edge[a].add(b)\n        edge[b].add(a)\n        if len(edge[a]) > max_:\n            max_ = len(edge[a])\n            m = a\n        if len(edge[b]) > max_:\n            max_ = len(edge[b])\n            m = b\n    if m == n * (n - 1) // 2:\n        print(1)\n        print(*[1 for i in range(n)])\n        print(1)\n        return\n    dep = {m: [1, [m]]}\n    visited = set()\n    visited.add(m)\n    heads = deque([m])\n    j = 1\n    while len(heads) > 0:\n        curr_head = heads.popleft()\n        curr_dep = dep[curr_head][0]\n        child_of_head = edge[curr_head]\n        for item in child_of_head:\n            if item not in visited:\n                visited.add(item)\n                child_of_item = edge[item]\n                ss = child_of_item.intersection(child_of_head)\n                ss.add(curr_head)\n                if child_of_item == ss:\n                    dep[curr_head][1].append(item)\n                else:\n                    dep[item] = [j + 1, [item]]\n                    j += 1\n                    heads.append(item)\n    print(len(dep))\n    emp = [0] * n\n    heads = []\n    for (a, b) in dep.items():\n        heads.append(a)\n        for item in b[1]:\n            emp[item - 1] = b[0]\n    print(*emp)\n    print(*heads)\nt = int(input())\nfor tt in range(t):\n    solve()", "from collections import *\nfor _ in range(int(input())):\n    n = int(input())\n    d = [0] * (n + 1)\n    arr = []\n    q = int(input())\n    gr = [[] for i in range(n + 1)]\n    for i in range(q):\n        arr.append(list(map(int, input().split())))\n        d[arr[i][0]] += 1\n        d[arr[i][1]] += 1\n        gr[arr[i][0]].append(arr[i][1])\n        gr[arr[i][1]].append(arr[i][0])\n    new = []\n    for i in range(1, n + 1):\n        new.append([i, d[i]])\n    new.sort(key=lambda x: x[-1], reverse=True)\n    root = new[0][0]\n    d = deque()\n    d.append(root)\n    par = [-1] * (n + 1)\n    par[root] = root\n    v = set()\n    v.add(root)\n    while d:\n        x = d.popleft()\n        for i in gr[x]:\n            if i not in v:\n                par[i] = x\n                v.add(i)\n                d.append(i)\n    s = set()\n    for i in range(1, n + 1):\n        s.add(par[i])\n    if -1 in s:\n        s.remove(-1)\n    print(len(s))\n    he = sorted(list(s))\n    d = defaultdict(lambda : 0)\n    for i in range(len(he)):\n        d[he[i]] = i + 1\n        par[he[i]] = he[i]\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = d[par[i]]\n    print(*ans[1:])\n    print(*he)", "from math import *\nimport sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    n = int(input())\n    k = int(input())\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = []\n    degree = [0 for i in range(n + 1)]\n    dept = [0 for i in range(n)]\n    pair_l = []\n    for i in range(k):\n        (u, v) = list(map(int, input().split()))\n        graph[u].append(v)\n        graph[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n    for i in range(1, n + 1):\n        pair_l.append((degree[i], i))\n    (deg, emp) = min(pair_l)\n    heads = []\n    count = 1\n    dept[emp - 1] = count\n    head1 = -1\n    for i in graph[emp]:\n        if degree[i] != degree[emp]:\n            head1 = i\n            heads.append(head1)\n        dept[i - 1] = count\n    if head1 == -1:\n        head1 = emp\n        heads.append(head1)\n    count = 2\n    for i in graph[head1]:\n        if dept[i - 1] == 0:\n            heads.append(i)\n            dept[i - 1] = count\n            count += 1\n    for j in heads:\n        for k in graph[j]:\n            if dept[k - 1] == 0:\n                dept[k - 1] = dept[j - 1]\n    print(len(heads))\n    print(*dept)\n    print(*heads)", "for _ in range(int(input())):\n    n = int(input())\n    k = int(input())\n    adj_list = {}\n    dept = {}\n    for i in range(1, n + 1):\n        adj_list[i] = []\n        dept[i] = 0\n    for _ in range(k):\n        (u, v) = map(int, input().split())\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    dept_heads = []\n    dept_count = 0\n    remaining = True\n    next_vertex = 1\n    while remaining:\n        ngbrs_count = len(adj_list[next_vertex])\n        curr_vertex = next_vertex\n        curr_vertices = [next_vertex]\n        while True:\n            for u in adj_list[curr_vertices[-1]]:\n                if len(adj_list[u]) < ngbrs_count and dept[u] == 0:\n                    ngbrs_count = len(adj_list[u])\n                    curr_vertex = u\n            curr_vertices.append(curr_vertex)\n            ngbrs_count = len(adj_list[curr_vertex])\n            if curr_vertices[-1] == curr_vertices[-2]:\n                break\n        dept_count += 1\n        dept[curr_vertex] = dept_count\n        for u in adj_list[curr_vertex]:\n            dept[u] = dept_count\n            if len(adj_list[u]) > len(adj_list[curr_vertex]):\n                dept_heads.append(u)\n        for i in range(1, n + 1):\n            if dept[i] == 0:\n                next_vertex = i\n                break\n        else:\n            remaining = False\n    print(dept_count)\n    for i in range(1, n + 1):\n        print(dept[i], end=' ')\n    print()\n    if dept_heads == []:\n        print(1)\n    else:\n        for x in dept_heads:\n            print(x, end=' ')\n        print()", "import sys, math, heapq, bisect\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 5)\nints = lambda : list(map(int, input().split()))\n\ndef gprint(t, ans=''):\n    print(f'Case #{t + 1}:', ans)\np = 10 ** 9 + 7\ninf = 10 ** 20 + 7\n\ndef check(node):\n    store = set(graph[node])\n    store.add(node)\n    par = [node]\n    for i in graph[node]:\n        v = 1\n        for j in graph[i]:\n            if j not in store:\n                v = 0\n                break\n        if v == 0:\n            par.append(i)\n    print(len(par))\n    done = set(par)\n    ans = [-1] * n\n    c = 1\n    for i in par:\n        ans[i - 1] = c\n        for j in graph[i]:\n            if j not in done:\n                ans[j - 1] = c\n        c += 1\n    print(*ans)\n    print(*par)\nfor t in range(int(input())):\n    n = int(input())\n    m = int(input())\n    graph = [[] for i in range(n + 1)]\n    for i in range(m):\n        (x, y) = ints()\n        graph[x].append(y)\n        graph[y].append(x)\n    a = [[len(graph[i]), i] for i in range(1, n + 1)]\n    a.sort()\n    x = a.pop()[1]\n    check(x)", "import random\nimport math\nfrom collections import defaultdict, Counter, deque, OrderedDict\nfrom functools import lru_cache\nimport bisect\nimport heapq\nimport sys\ninput = sys.stdin.readline\n\nclass SegmentTree:\n\n    def __init__(self, nums):\n        self._size = len(nums)\n        self._tree = [0] * (4 * self._size)\n        self.build(nums)\n\n    def build(self, a, v=1, lo=0, hi=None):\n        if hi is None:\n            hi = self._size - 1\n        if lo == hi:\n            self._tree[v] = a[lo]\n        else:\n            mi = (lo + hi) // 2\n            self.build(a, 2 * v, lo, mi)\n            self.build(a, 2 * v + 1, mi + 1, hi)\n            self._tree[v] = self._tree[2 * v] + self._tree[2 * v + 1]\n\n    def update(self, pos, val, v=1, lo=0, hi=None):\n        if hi is None:\n            hi = self._size - 1\n        if lo == hi:\n            self._tree[v] = val\n        else:\n            mi = (lo + hi) // 2\n            if pos <= mi:\n                self.update(pos, val, 2 * v, lo, mi)\n            else:\n                self.update(pos, val, 2 * v + 1, mi + 1, hi)\n            self._tree[v] = self._tree[2 * v] + self._tree[2 * v + 1]\n\n    def query(self, l, h, v=1, lo=0, hi=None):\n        if hi is None:\n            hi = self._size - 1\n        if l > h:\n            return 0\n        elif l == lo and h == hi:\n            return self._tree[v]\n        else:\n            mi = (lo + hi) // 2\n            return self.query(l, min(mi, h), 2 * v, lo, mi) + self.query(max(mi + 1, l), h, 2 * v + 1, mi + 1, hi)\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = list(range(n))\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            self.parents[x] = y\ndire = [0, 1, 0, -1, 0]\n\ndef is_prime(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef case(t):\n    print('Case #{}:'.format(t), end=' ')\nRANDOM = random.randrange(2 ** 62)\n\ndef Wrapper(x):\n    return x ^ RANDOM\n\ndef solve():\n    n = int(input())\n    p = int(input())\n    mapp = defaultdict(set)\n    for i in range(p):\n        (a, b) = map(int, input().split())\n        mapp[a].add(b)\n        mapp[b].add(a)\n    heads = set()\n    for i in range(1, n + 1):\n        tobreak = False\n        for j in mapp[i]:\n            allexist = True\n            for k in mapp[j]:\n                if k not in mapp[i] and k != i:\n                    allexist = False\n                    break\n            if allexist and len(mapp[i]) > len(mapp[j]):\n                heads.add(i)\n                for k in mapp[i]:\n                    if k not in mapp[j] and k != j:\n                        heads.add(k)\n                tobreak = True\n                break\n        if tobreak:\n            break\n    if len(heads) == 0:\n        print(1)\n        print(*[1] * n)\n        print(1)\n        return\n    heads = list(heads)\n    headmap = {}\n    for i in range(len(heads)):\n        headmap[heads[i]] = i + 1\n    print(len(heads))\n    for i in range(1, n + 1):\n        if i in heads:\n            print(headmap[i], end=' ')\n        else:\n            for j in mapp[i]:\n                if j in heads:\n                    print(headmap[j], end=' ')\n    print()\n    print(*heads)\nfor t in range(int(input())):\n    solve()", "for tc in range(int(input())):\n    m = int(input())\n    k = int(input())\n    d = dict.fromkeys(range(1, m + 1), None)\n    a = dict.fromkeys(range(1, m + 1), None)\n    for i in range(1, k + 1):\n        (p1, p2) = map(int, input().split())\n        if d[p1] is None:\n            d[p1] = set()\n        if d[p2] is None:\n            d[p2] = set()\n        d[p1].add(p2)\n        d[p2].add(p1)\n    h = list()\n    c = 1\n    for i in range(1, m + 1):\n        if a[i] is not None:\n            continue\n        p1 = d[i]\n        not_lead = False\n        if len(p1) == 1:\n            not_lead = True\n        else:\n            for j in p1:\n                p2 = d[j]\n                if len(p1 ^ p2) == 2:\n                    not_lead = True\n        if not_lead:\n            a[i] = c\n            for j in p1:\n                a[j] = c\n                if len(d[j]) > len(p1):\n                    h.append(j)\n            if len(h) < c:\n                h.append(i)\n            c += 1\n    print(c - 1)\n    print(' '.join((str(x) for x in a.values())))\n    print(' '.join((str(x) for x in h)))", "from collections import defaultdict\nimport math\nimport sys\nmod = 10 ** 9 + 7\n\ndef facto(n):\n    ans = 1\n    while n:\n        ans = ans * 2 % mod\n    return ans\n\nclass Solve:\n\n    def __init__(self, n, k):\n        self.n = n\n        self.k = k\n        self.st = set()\n\n    def dp(self, ones, zeroes):\n        if ones < 0 or zeroes < 0:\n            return\n        if ones in self.st:\n            return\n        self.st.add(ones)\n        for i in range(zeroes + 1):\n            if ones >= self.k - i:\n                self.dp(ones + i - (self.k - i), zeroes - i + (self.k - i))\n        for i in range(ones + 1):\n            if zeroes >= self.k - i:\n                self.dp(ones - i + (self.k - i), zeroes + i - (self.k - i))\n\ndef solve():\n    n = int(input())\n    k = int(input())\n    hs = defaultdict(lambda : set())\n    queries = []\n    for _ in range(k):\n        (alpha, beta) = map(int, input().split())\n        queries.append((alpha, beta))\n        hs[alpha].add(beta)\n        hs[beta].add(alpha)\n    groups = []\n    managers = set()\n    ans = defaultdict(int)\n    unique = 0\n    for q in queries:\n        (a, b) = q\n        if len(hs[a]) > len(hs[b]):\n            if len(hs[b].difference(hs[a].union({a}))) == 0:\n                managers.add(a)\n        elif len(hs[b]) > len(hs[a]):\n            if len(hs[a].difference(hs[b].union({b}))) == 0:\n                managers.add(b)\n        else:\n            pass\n    ans = defaultdict(int)\n    ansb = []\n    for (i, x) in enumerate(managers):\n        ansb.append(x)\n        ans[x] = i + 1\n        for y in hs[x]:\n            if y not in managers:\n                ans[y] = i + 1\n    if len(ansb) == 0:\n        print(1)\n        print(' '.join(['1' for x in range(n)]))\n        print(1)\n    else:\n        print(len(ansb))\n        print(' '.join([str(ans[x + 1]) for x in range(n)]))\n        print(' '.join([str(x) for x in ansb]))\nfor _ in range(int(input())):\n    solve()", "mod = 10 ** 9 + 7\nt = int(input())\nfor t0 in range(t):\n    n = int(input())\n    k = int(input())\n    pairs = []\n    adjacent = {}\n    for i in range(k):\n        pair = list(map(int, input().split()))\n        if not adjacent.__contains__(pair[0]):\n            adjacent[pair[0]] = set()\n        if not adjacent.__contains__(pair[1]):\n            adjacent[pair[1]] = set()\n        adjacent[pair[0]].add(pair[1])\n        adjacent[pair[1]].add(pair[0])\n        pairs.append(pair)\n    heads = set()\n    for pair in pairs:\n        if len(adjacent[pair[0]]) > len(adjacent[pair[1]]):\n            heads.add(pair[0])\n        if len(adjacent[pair[1]]) > len(adjacent[pair[0]]):\n            heads.add(pair[1])\n    if len(heads) == 0:\n        print(1)\n        print(' '.join([str(item) for item in [1] * n]))\n        print(1)\n        continue\n    if len(heads) == 1:\n        a = set()\n        b = set()\n        good_head = list(heads)[0]\n        reminded_nodes = list(adjacent[good_head])\n        a_cap = reminded_nodes[0]\n        a.add(a_cap)\n        for i in range(1, len(reminded_nodes)):\n            node = reminded_nodes[i]\n            if adjacent[node].__contains__(a_cap):\n                a.add(node)\n            else:\n                b.add(node)\n        dep_num = {good_head: 1}\n        counter = 2\n        for head in a:\n            dep_num[head] = counter\n            counter += 1\n        for node in b:\n            dep_num[node] = 1\n        print(2)\n        print(' '.join([str(dep_num[node]) for node in range(1, n + 1)]))\n        all_heads = list(a)\n        all_heads.append(good_head)\n        print(' '.join([str(head) for head in all_heads]))\n        continue\n    head_of_node = {}\n    for node in range(1, n + 1):\n        if heads.__contains__(node):\n            continue\n        for adj in adjacent[node]:\n            if heads.__contains__(adj):\n                if head_of_node.__contains__(node):\n                    del head_of_node[node]\n                    heads.add(node)\n                    break\n                else:\n                    head_of_node[node] = adj\n    dep_num = {}\n    counter = 1\n    for head in heads:\n        dep_num[head] = counter\n        counter += 1\n    print(len(heads))\n    line2 = []\n    for node in range(1, n + 1):\n        if heads.__contains__(node):\n            head = node\n        else:\n            head = head_of_node[node]\n        line2.append(str(dep_num[head]))\n    print(' '.join(line2))\n    print(' '.join([str(head) for head in heads]))", "from collections import *\nfor _ in range(int(input())):\n    n = int(input())\n    k = int(input())\n    q = defaultdict(set)\n    for i in range(k):\n        (x, y) = map(int, input().split())\n        q[x].add(y)\n        q[y].add(x)\n    o = 100000\n    x = 1\n    for i in q:\n        if len(q[i]) < o:\n            o = len(q[i])\n            x = i\n    head = set()\n    for j in q[x]:\n        if len(q[j]) > o:\n            head |= q[j] - q[x]\n            head |= {j}\n            head -= {x}\n            break\n    if not head:\n        head |= {1}\n    z = [0] * n\n    r = 1\n    for i in head:\n        for j in q[i]:\n            if j not in head:\n                z[j - 1] = r\n        z[i - 1] = r\n        r += 1\n    print(len(head))\n    print(*z)\n    print(*head)", "tc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    k = int(input())\n    adjl = [set() for _ in range(n)]\n    for i in range(k):\n        (u, v) = map(int, input().split())\n        adjl[u - 1].add(v - 1)\n        adjl[v - 1].add(u - 1)\n    maxd = 0\n    md = -1\n    for i in range(n):\n        if len(adjl[i]) > maxd:\n            maxd = len(adjl[i])\n            md = i\n    p = set(adjl[md])\n    start = p.pop()\n    p = set(adjl[start])\n    p.remove(md)\n    p.add(start)\n    if len(p.difference(adjl[md])) == 0:\n        managers = adjl[md].difference(p)\n    else:\n        managers = adjl[md].intersection(p)\n    managers.add(md)\n    m = len(managers)\n    print(m)\n    d = [0 for i in range(n)]\n    k = 1\n    manx = list(managers)\n    for tm in manx:\n        d[tm] = k\n        for v in adjl[tm]:\n            if not v in managers:\n                d[v] = k\n        k += 1\n    print(*d)\n    print(*[t + 1 for t in manx])"]