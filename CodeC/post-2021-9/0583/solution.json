["import math\n(x, y) = map(int, input().split())\nn = x * y\nans = 1\nfor i in range(2, int(math.sqrt(n)) + 2):\n    if i > math.sqrt(n) + 1:\n        break\n    if n % i == 0:\n        count = 0\n        while n % i == 0:\n            n = n // i\n            count += 1\n        ans *= count + 1\nif n > 1:\n    ans *= 2\nprint(ans)", "import math\n(x, y) = map(int, input().split())\nn = x * y\nans = 1\nfor i in range(2, int(math.sqrt(n)) + 2):\n    if i > math.sqrt(n) + 1:\n        break\n    if n % i == 0:\n        count = 0\n        while n % i == 0:\n            n = n // i\n            count += 1\n        ans *= count + 1\nif n > 1:\n    ans *= 2\nprint(ans)", "import math\n(x, y) = map(int, input().split())\nn = x * y\nans = 1\nfor i in range(2, int(math.sqrt(n)) + 2):\n    if i > math.sqrt(n) + 1:\n        break\n    if n % i == 0:\n        count = 0\n        while n % i == 0:\n            n = n // i\n            count += 1\n        ans *= count + 1\nif n > 1:\n    ans *= 2\nprint(ans)", "import math\n\ndef printDivisors(n):\n    l = []\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                l.append(i)\n            else:\n                l.append(i)\n                l.append(int(n / i))\n        i = i + 1\n    return l\n(X, Y) = input().split()\nX = int(X)\nY = int(Y)\na = printDivisors(X)\nb = printDivisors(Y)\nD = {}\nfor i in b:\n    for j in a:\n        if i / j not in D:\n            D[i / j] = 1\nprint(len(D))", "from math import gcd, sqrt\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n(X, Y) = list(map(int, input().split()))\ndiv_X = list(divisorGenerator(X))\ndiv_Y = list(divisorGenerator(Y))\nanswer = 0\nfor p in div_Y:\n    for q in div_X:\n        if gcd(p, q) == 1:\n            answer += 1\nprint(answer)", "import math\n(M, M1) = (1000000007, 998244353)\n\ndef factors(x):\n    ans = set()\n    for i in range(1, int(math.sqrt(x)) + 2):\n        if x % i == 0:\n            ans.add(i)\n            ans.add(x // i)\n    ans = list(ans)\n    return ans\n\ndef main():\n    (x, y) = input().split()\n    res = set()\n    facx = factors(int(x))\n    facy = factors(int(y))\n    for i in facx:\n        for j in facy:\n            res.add(i / j)\n    print(len(res))\nmain()", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random, threading\nfrom functools import lru_cache\nfrom itertools import *\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n(M, M1) = (1000000007, 998244353)\n\ndef factors(x):\n    ans = set()\n    for i in range(1, int(math.sqrt(x)) + 2):\n        if x % i == 0:\n            ans.add(i)\n            ans.add(x // i)\n    ans = list(ans)\n    return ans\n\ndef main():\n    how_much_noob_I_am = 1\n    for _ in range(how_much_noob_I_am):\n        (x, y) = sep()\n        res = set()\n        facx = factors(x)\n        facy = factors(y)\n        for i in facx:\n            for j in facy:\n                res.add(i / j)\n        print(len(res))\nmain()", "import math\n(x, y) = map(int, input().split())\nn = x * y\nans = 1\nfor i in range(2, int(math.sqrt(n)) + 2):\n    if i > math.sqrt(n) + 1:\n        break\n    if n % i == 0:\n        count = 0\n        while n % i == 0:\n            n = n // i\n            count += 1\n        ans *= count + 1\nif n > 1:\n    ans *= 2\nprint(ans)", "import math\n(x, y) = map(int, input().split())\nn = x * y\nans = 1\nfor i in range(2, int(math.sqrt(n)) + 2):\n    if i > math.sqrt(n) + 1:\n        break\n    if n % i == 0:\n        count = 0\n        while n % i == 0:\n            n = n // i\n            count += 1\n        ans *= count + 1\nif n > 1:\n    ans *= 2\nprint(ans)", "def pr(n, dt):\n    n1 = n\n    if n % 2 == 0:\n        while n % 2 == 0:\n            dt[2] = dt.get(2, 0) + 1\n            n //= 2\n    for i in range(3, int(n1 ** 0.5) + 2, 2):\n        if n % i == 0:\n            while n % i == 0:\n                dt[i] = dt.get(i, 0) + 1\n                n //= i\n    if n != 1:\n        dt[n] = dt.get(n, 0) + 1\n    return dt\n(x, y) = map(int, input().split())\nd = {}\nd = pr(x, d)\nd = pr(y, d)\nans = 1\nfor ele in d:\n    ans *= d[ele] + 1\nprint(ans)", "def pr(n, dt):\n    n1 = n\n    if n % 2 == 0:\n        while n % 2 == 0:\n            dt[2] = dt.get(2, 0) + 1\n            n //= 2\n    for i in range(3, int(n1 ** 0.5) + 2, 2):\n        if n % i == 0:\n            while n % i == 0:\n                dt[i] = dt.get(i, 0) + 1\n                n //= i\n    if n != 1:\n        d[n] = d.get(n, 0) + 1\n    return dt\n(x, y) = map(int, input().split())\nd = {}\nd = pr(x, d)\nd = pr(y, d)\nans = 1\nfor ele in d:\n    ans *= d[ele] + 1\nprint(ans)", "from collections import defaultdict\nfrom math import sqrt\n(x, y) = map(int, input().split())\nmp = defaultdict(int)\nfor i in range(2, int(sqrt(x)) + 1):\n    while x % i == 0:\n        mp[i] += 1\n        x //= i\nif x > 1:\n    mp[x] += 1\nx = y\nfor i in range(2, int(sqrt(x)) + 1):\n    while x % i == 0:\n        mp[i] += 1\n        x //= i\nif x > 1:\n    mp[x] += 1\nans = 1\nfor el in mp:\n    ans *= mp[el] + 1\nprint(ans)", "d = dict()\n\ndef cal(n):\n    i = 2\n    while n > 1:\n        if n % i == 0:\n            if i in d.keys():\n                d[i] += 1\n            else:\n                d[i] = 1\n            n //= i\n        elif i == 2:\n            i += 1\n        else:\n            i += 2\n        if i > 1000003:\n            if n > 1000003:\n                if n in d.keys():\n                    d[n] += 1\n                else:\n                    d[n] = 1\n            break\n(x, y) = map(int, input().split())\ncal(x)\ncal(y)\nans = 1\nfor (x, y) in d.items():\n    ans *= y + 1\nprint(ans)", "from collections import defaultdict\nfrom functools import reduce\nfrom operator import mul\npe = defaultdict(int)\nfor xy in map(int, input().split()):\n    p = 2\n    while p * p <= xy:\n        while xy % p == 0:\n            pe[p] += 1\n            xy //= p\n        p += 1\n    if xy > 1:\n        pe[xy] += 1\nprint(reduce(mul, [e + 1 for (p, e) in pe.items()], 1))", "from collections import defaultdict\npe = defaultdict(int)\nfor xy in map(int, input().split()):\n    p = 2\n    while p * p <= xy:\n        while xy % p == 0:\n            pe[p] += 1\n            xy //= p\n        p += 1\n    if xy > 1:\n        pe[xy] += 1\nans = 1\nfor (p, e) in pe.items():\n    ans *= e + 1\nprint(ans)", "from collections import defaultdict\npe = defaultdict(int)\n\ndef factorize(x):\n    p = 2\n    while p * p <= x:\n        while x % p == 0:\n            pe[p] += 1\n            x //= p\n        p += 1\n    if x > 1:\n        pe[x] += 1\n(x, y) = map(int, input().split())\nfactorize(x)\nfactorize(y)\nans = 1\nfor (p, e) in pe.items():\n    ans *= e + 1\nprint(ans)", "(X, Y) = map(int, input().split())\np = X * Y\nx = 2\nans = 1\nwhile x * x <= p:\n    if p % x == 0:\n        q = 1\n        while True:\n            p //= x\n            q += 1\n            if p % x != 0:\n                break\n        ans *= q\n    x += 1\nif p > 1:\n    ans *= 2\nprint(ans)", "from collections import Counter\nfrom math import gcd\n\ndef pollard_rho(n):\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n    s = (n - 1 & 1 - n).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = p * p % n\n            if p == 1:\n                return gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                (x, y) = (i, (i * i + 1) % n)\n                f = gcd(abs(x - y), n)\n                while f == 1:\n                    (x, y) = ((x * x + 1) % n, (y * y + 1) % n)\n                    y = (y * y + 1) % n\n                    f = gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n\ndef prime_factors(n):\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n(x, y) = map(int, input().split())\ncnt = prime_factors(x * y)\nnum = 1\nfor val in cnt.values():\n    num *= val + 1\nprint(num)", "from collections import Counter\n\ndef factorize(x):\n    factors = Counter()\n    p = 2\n    while p * p <= x:\n        if x % p == 0:\n            while x % p == 0:\n                factors[p] += 1\n                x //= p\n        p += 1\n    if x > 1:\n        factors[x] = 1\n    return factors\n(x, y) = map(int, input().split())\nc = factorize(x) + factorize(y)\nans = 1\nfor (k, v) in c.items():\n    ans *= v + 1\nprint(ans)", "from math import sqrt\nfrom sys import stdin\ninput = stdin.readline\n\ndef factors(n):\n    f = set()\n    step = 2 if n % 2 else 1\n    for x in range(1, int(sqrt(n)) + 1, step):\n        (q, r) = divmod(n, x)\n        if r == 0:\n            f.add(x)\n            f.add(q)\n    return sorted(list(f))\n\ndef solve(X, Y):\n    A = factors(X)\n    B = factors(Y)\n    fractions = set()\n    for p in A:\n        for q in B:\n            fractions.add(p / q)\n    return len(fractions)\n(X, Y) = [int(x) for x in input().strip().split()]\nprint(solve(X, Y))", "def factors(x):\n    result = []\n    i = 1\n    while i * i <= x:\n        if x % i == 0:\n            result.append(i)\n            if x // i != i:\n                result.append(x // i)\n        i += 1\n    return result\n(x, y) = map(int, input().split())\nf = x * y\nf1 = factors(x)\nf2 = factors(y)\nlst2 = []\nfor j in f1:\n    for k in f2:\n        lst2.append(j * k)\n        lst2.append(j)\n        lst2.append(k)\nlst2 = list(set(lst2))\nc = 0\nlst1 = []\nele = y / x\nfor j in lst2:\n    if -(y / j) <= ele:\n        c += 1\nprint(c)", "from math import sqrt\nfrom sys import stdin\ninput = stdin.readline\n\ndef factors(n):\n    f = set()\n    step = 2 if n % 2 else 1\n    for x in range(1, int(sqrt(n)) + 1, step):\n        (q, r) = divmod(n, x)\n        if r == 0:\n            f.add(x)\n            f.add(q)\n    return sorted(list(f))\n\ndef solve(X, Y):\n    A = factors(X)\n    B = factors(Y)\n    fractions = set()\n    for p in A:\n        for q in B:\n            fractions.add(p / q)\n    return len(fractions)\n(X, Y) = [int(x) for x in input().strip().split()]\nprint(solve(X, Y))"]