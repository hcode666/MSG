["mod = 10 ** 9 + 7\n\ndef find_SCC(graph):\n    (SCC, S, P) = ([], [], [])\n    depth = [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            d = depth[~node] - 1\n            if P[-1] > d:\n                SCC.append(S[d:])\n                del S[d:], P[-1]\n                for node in SCC[-1]:\n                    depth[node] = -1\n        elif depth[node] > 0:\n            while P[-1] > depth[node]:\n                P.pop()\n        elif depth[node] == 0:\n            S.append(node)\n            P.append(len(S))\n            depth[node] = len(S)\n            stack.append(~node)\n            stack += graph[node]\n    return SCC[::-1]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [[] for _ in range(m)]\n    for i in range(n):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n    SCC = find_SCC(graph)\n    component = [-1] * m\n    ans = 1\n    for i in range(len(SCC)):\n        sink = 1\n        for u in SCC[i]:\n            component[u] = i\n        for u in SCC[i]:\n            for v in graph[u]:\n                if component[v] != component[u]:\n                    sink = 0\n        ans *= pow(2, len(SCC[i]), mod) - sink\n        ans %= mod\n    print(ans)", "mod = 10 ** 9 + 7\n\ndef find_SCC(graph):\n    (SCC, S, P) = ([], [], [])\n    depth = [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            d = depth[~node] - 1\n            if P[-1] > d:\n                SCC.append(S[d:])\n                del S[d:], P[-1]\n                for node in SCC[-1]:\n                    depth[node] = -1\n        elif depth[node] > 0:\n            while P[-1] > depth[node]:\n                P.pop()\n        elif depth[node] == 0:\n            S.append(node)\n            P.append(len(S))\n            depth[node] = len(S)\n            stack.append(~node)\n            stack += graph[node]\n    return SCC[::-1]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [[] for _ in range(m)]\n    for i in range(n):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n    SCC = find_SCC(graph)\n    component = [-1] * m\n    ans = 1\n    for i in range(len(SCC)):\n        sink = 1\n        for u in SCC[i]:\n            component[u] = i\n        for u in SCC[i]:\n            for v in graph[u]:\n                if component[v] != component[u]:\n                    sink = 0\n        ans *= pow(2, len(SCC[i]), mod) - sink\n        ans %= mod\n    print(ans)", "mod = 10 ** 9 + 7\n\ndef find_SCC(graph):\n    (SCC, S, P) = ([], [], [])\n    depth = [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            d = depth[~node] - 1\n            if P[-1] > d:\n                SCC.append(S[d:])\n                del S[d:], P[-1]\n                for node in SCC[-1]:\n                    depth[node] = -1\n        elif depth[node] > 0:\n            while P[-1] > depth[node]:\n                P.pop()\n        elif depth[node] == 0:\n            S.append(node)\n            P.append(len(S))\n            depth[node] = len(S)\n            stack.append(~node)\n            stack += graph[node]\n    return SCC[::-1]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [[] for _ in range(m)]\n    for i in range(n):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n    SCC = find_SCC(graph)\n    component = [-1] * m\n    ans = 1\n    for i in range(len(SCC)):\n        sink = 1\n        for u in SCC[i]:\n            component[u] = i\n        for u in SCC[i]:\n            for v in graph[u]:\n                if component[v] != component[u]:\n                    sink = 0\n        ans *= pow(2, len(SCC[i]), mod) - sink\n        ans %= mod\n    print(ans)"]