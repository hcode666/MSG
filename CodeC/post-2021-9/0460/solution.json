["mod = 998244353\n\ndef counts(m, i):\n    count = m >> i + 1 << i\n    if m >> i & 1:\n        count += m & (1 << i) - 1\n    return count\n\ndef solve(n, m):\n    ans = 0\n    for i in range(32):\n        count = counts(m + 1, i)\n        if count:\n            ans = (ans + pow(count, n, mod) * pow(2, i, mod) % mod) % mod\n        else:\n            break\n    return ans\nfor _ in range(int(input())):\n    print(solve(*map(int, input().split())))", "mod = 998244353\n\ndef counts(m, i):\n    count = m >> i + 1 << i\n    if m >> i & 1:\n        count += m & (1 << i) - 1\n    return count\n\ndef solve(n, m):\n    ans = 0\n    for i in range(32):\n        count = counts(m + 1, i)\n        if count:\n            ans = (ans + pow(count, n, mod) * pow(2, i, mod) % mod) % mod\n        else:\n            break\n    return ans\nfor _ in range(int(input())):\n    print(solve(*map(int, input().split())))", "t = int(input())\nmod = 998244353\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(31):\n        k = m // (2 << bit) * (1 << bit) + max(0, m % (2 << bit) - (1 << bit) + 1)\n        ct = pow(k, n, mod)\n        ans = (ans + ct * (1 << bit)) % mod\n    print(ans)", "mod = 998244353\n\ndef arrctr(n, m):\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    return ans % mod\nt = int(input())\nfor _ in range(t):\n    (n, m) = [int(x) for x in input().split()]\n    print(arrctr(n, m))", "def solve(n, m):\n    m += 1\n    ans = 0\n    mod = 998244353\n    for bit in range(30):\n        cnt = m // (2 << bit)\n        cnt = cnt * (1 << bit)\n        cnt += max(0, m % (2 << bit) - (1 << bit))\n        ans += pow(cnt, n, mod) * (1 << bit)\n    print(ans % mod)\ntestCase = int(input())\nfor _ in range(testCase):\n    (n, limit) = map(int, input().split())\n    solve(n, limit)", "t = int(input())\nmod = 998244353\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for j in range(50):\n        k = m // (2 << j) * (1 << j) + max(0, m % (2 << j) - (1 << j) + 1)\n        ct = pow(k, n, mod)\n        ans = (ans + ct * (1 << j)) % mod\n    print(ans)", "mod = 998244353\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    print(ans % mod)", "mod = 998244353\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    print(ans % mod)", "def councoun(iikm, jjkm):\n    return (iikm // (1 << jjkm + 1) << jjkm) + max(0, iikm % (1 << jjkm + 1) - (1 << jjkm) + 1)\n\ndef powepowe(bbkm, nnkm):\n    s = 1\n    while nnkm:\n        if nnkm % 2 == 1:\n            s = s * bbkm % 998244353\n        bbkm = bbkm * bbkm % 998244353\n        nnkm = nnkm // 2\n    return s\nfor t in range(int(input())):\n    (nnkm, mmkm) = map(int, input().split())\n    s = 0\n    for jjkm in range(31):\n        s = (s + (powepowe(councoun(mmkm, jjkm), nnkm) << jjkm) % 998244353) % 998244353\n    print(s)", "def councoun(iikm, jjkm):\n    return (iikm // (1 << jjkm + 1) << jjkm) + max(0, iikm % (1 << jjkm + 1) - (1 << jjkm) + 1)\n\ndef powepowe(bbkm, nnkm):\n    s = 1\n    while nnkm:\n        if nnkm % 2 == 1:\n            s = s * bbkm % 998244353\n        bbkm = bbkm * bbkm % 998244353\n        nnkm = nnkm // 2\n    return s\nfor t in range(int(input())):\n    (nnkm, mmkm) = map(int, input().split())\n    s = 0\n    for jjkm in range(31):\n        s = (s + (powepowe(councoun(mmkm, jjkm), nnkm) << jjkm) % 998244353) % 998244353\n    print(s)", "def solve(n, m):\n    m += 1\n    ans = 0\n    mod = 998244353\n    for bit in range(30):\n        cnt = m // (2 << bit)\n        cnt = cnt * (1 << bit)\n        cnt += max(0, m % (2 << bit) - (1 << bit))\n        ans += pow(cnt, n, mod) * (1 << bit)\n    print(ans % mod)\ntestCase = int(input())\nfor _ in range(testCase):\n    (n, limit) = map(int, input().split())\n    solve(n, limit)", "MOD = 998244353\nfor _ in range(int(input())):\n    (n, m) = [int(s) for s in input().split()]\n    m += 1\n    ans = 0\n    cur = 1\n    while cur <= m:\n        cur = cur << 1\n        w = m // cur * (cur // 2) + max(0, m % cur - cur // 2)\n        ans = (ans + cur // 2 * pow(w, n, MOD) % MOD) % MOD\n    print(ans)", "def mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\nmod = 998244353\nfor _ in range(ni()):\n    (n, m) = mi()\n    res = 0\n    for bit in range(31):\n        b2 = 2 << bit\n        count = m // b2 * (b2 >> 1) + max(0, m % b2 - (b2 >> 1) + 1)\n        res += pow(count, n, mod) << bit\n    print(res % mod)", "t = int(input())\nmod = 998244353\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(31):\n        k = m // (2 << bit) * (1 << bit) + max(0, m % (2 << bit) - (1 << bit) + 1)\n        ct = pow(k, n, mod)\n        ans = (ans + ct * (1 << bit)) % mod\n    print(ans)", "t = int(input())\nmod = 998244353\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(31):\n        k = m // (2 << bit) * (1 << bit) + max(0, m % (2 << bit) - (1 << bit) + 1)\n        ct = pow(k, n, mod)\n        ans = (ans + ct * (1 << bit)) % mod\n    print(ans)", "t = int(input())\nmod = 998244353\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(31):\n        k = m // (2 << bit) * (1 << bit) + max(0, m % (2 << bit) - (1 << bit) + 1)\n        ct = pow(k, n, mod)\n        ans = (ans + ct * (1 << bit)) % mod\n    print(ans)", "mod = 998244353\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    mult = 1\n    for k in range(31):\n        block = m // (2 * mult)\n        cnt = block * mult\n        cnt += max(0, m % (2 * mult) - mult + 1)\n        ans += pow(cnt, n, mod) * mult\n        ans %= mod\n        mult *= 2\n    print(ans)", "mod = 998244353\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    mult = 1\n    for k in range(31):\n        block = m // (2 * mult)\n        cnt = block * mult\n        cnt += max(0, m % (2 * mult) - mult + 1)\n        ans += pow(cnt, n, mod) * mult\n        ans %= mod\n        mult *= 2\n    print(ans)", "mod = 998244353\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    res = 0\n    for bit in range(31):\n        b2 = 2 << bit\n        count = m // b2 * (b2 >> 1) + max(0, m % b2 - (b2 >> 1) + 1)\n        res += pow(count, n, mod) << bit\n    print(res % mod)", "mod = 998244353\n\ndef arr_ctr(n, m):\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    return ans % mod\nt = int(input())\nfor _ in range(t):\n    (n, m) = [int(x) for x in input().split()]\n    print(arr_ctr(n, m))", "mod = 998244353\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    res = 0\n    for bit in range(31):\n        b2 = 2 << bit\n        count = m // b2 * (b2 >> 1) + max(0, m % b2 - (b2 >> 1) + 1)\n        res += pow(count, n, mod) << bit\n    print(res % mod)", "mod = 998244353\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    res = 0\n    for bit in range(31):\n        b2 = 2 << bit\n        count = m // b2 * (b2 >> 1) + max(0, m % b2 - (b2 >> 1) + 1)\n        res += pow(count, n, mod) << bit\n    print(res % mod)", "mod = 998244353\n\ndef arr_ctr(n, m):\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    return ans % mod\nt = int(input())\nfor _ in range(t):\n    (n, m) = [int(x) for x in input().split()]\n    print(arr_ctr(n, m))", "import math\nfrom functools import reduce\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef read(func=str, sep=None):\n    return list(map(func, input().split(sep)))\n\ndef read_ints(sep=None):\n    return read(func=int, sep=sep)\n\ndef read_int():\n    return int(input())\n\ndef print_array(arr, sep=' '):\n    print(sep.join(map(str, arr)))\n\ndef bitcount(num):\n    bits = 0\n    while num:\n        if num & 1:\n            bits += 1\n        num >>= 1\n    return bits\n\ndef highest_bit(n):\n    count = 0\n    while n != 0:\n        count += 1\n        n >>= 1\n    return count - 1\n\ndef modpow(num, pow, mod):\n    if pow == 0:\n        return 1\n    c = modpow(num, pow // 2, mod)\n    if pow & 1:\n        return c ** 2 % mod * num % mod\n    else:\n        return c ** 2 % mod\ntest_cases = read_int()\nmod = 998244353\nfor _ in range(test_cases):\n\n    def has_bit_set(num, bit):\n        high = highest_bit(num)\n        if high < bit:\n            return 0\n        if high == bit:\n            return num - 2 ** high + 1\n        return (1 << high - 1) + has_bit_set(num - (1 << high), bit)\n\n    def get_count(num, room, index):\n        return modpow(has_bit_set(num, index), room, mod)\n    (n, m) = read_ints()\n    sum = 0\n    for i in range(highest_bit(m) + 1):\n        sum += get_count(m, n, i) * (1 << i)\n        sum %= mod\n    print(sum)", "import math\nfrom functools import reduce\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef read(func=str, sep=None):\n    return list(map(func, input().split(sep)))\n\ndef read_ints(sep=None):\n    return read(func=int, sep=sep)\n\ndef read_int():\n    return int(input())\n\ndef print_array(arr, sep=' '):\n    print(sep.join(map(str, arr)))\n\ndef bitcount(num):\n    bits = 0\n    while num:\n        if num & 1:\n            bits += 1\n        num >>= 1\n    return bits\n\ndef highest_bit(n):\n    count = 0\n    while n != 0:\n        count += 1\n        n >>= 1\n    return count - 1\n\ndef modpow(num, pow, mod):\n    if pow == 0:\n        return 1\n    c = modpow(num, pow // 2, mod)\n    if pow & 1:\n        return c ** 2 % mod * num % mod\n    else:\n        return c ** 2 % mod\ntest_cases = read_int()\nmod = 998244353\nfor _ in range(test_cases):\n\n    def has_bit_set(num, bit):\n        high = highest_bit(num)\n        if high < bit:\n            return 0\n        if high == bit:\n            return num - 2 ** high + 1\n        return (1 << high - 1) + has_bit_set(num - (1 << high), bit)\n\n    def get_count(num, room, index):\n        return modpow(has_bit_set(num, index), room, mod)\n    (n, m) = read_ints()\n    sum = 0\n    for i in range(highest_bit(m) + 1):\n        sum += get_count(m, n, i) * (1 << i)\n        sum %= mod\n    print(sum)", "import math\nfrom functools import reduce\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef read(func=str, sep=None):\n    return list(map(func, input().split(sep)))\n\ndef read_ints(sep=None):\n    return read(func=int, sep=sep)\n\ndef read_int():\n    return int(input())\n\ndef print_array(arr, sep=' '):\n    print(sep.join(map(str, arr)))\n\ndef bitcount(num):\n    bits = 0\n    while num:\n        if num & 1:\n            bits += 1\n        num >>= 1\n    return bits\n\ndef highest_bit(n):\n    count = 0\n    while n != 0:\n        count += 1\n        n >>= 1\n    return count - 1\n\ndef modpow(num, pow, mod):\n    if pow == 0:\n        return 1\n    c = modpow(num, pow // 2, mod)\n    if pow & 1:\n        return c ** 2 % mod * num % mod\n    else:\n        return c ** 2 % mod\ntest_cases = read_int()\nmod = 998244353\nfor _ in range(test_cases):\n\n    def has_bit_set(num, bit):\n        high = highest_bit(num)\n        if high < bit:\n            return 0\n        if high == bit:\n            return num - 2 ** high + 1\n        return (1 << high - 1) + has_bit_set(num - (1 << high), bit)\n\n    def get_count(num, room, index):\n        return modpow(has_bit_set(num, index), room, mod)\n    (n, m) = read_ints()\n    sum = 0\n    for i in range(highest_bit(m) + 1):\n        sum += get_count(m, n, i) * (1 << i)\n        sum %= mod\n    print(sum)", "mod = 998244353\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    print(ans % mod)", "mod = 998244353\n\ndef arr_ctr(n, m):\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    return ans % mod\nt = int(input())\nfor _ in range(t):\n    (n, m) = [int(x) for x in input().split()]\n    print(arr_ctr(n, m))", "import time\nimport sys\nimport math\n\ndef get_primes(n):\n    sieve = [True] * n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if sieve[i]:\n            sieve[i * i::2 * i] = [False] * ((n - i * i - 1) // (2 * i) + 1)\n    return [2] + [i for i in range(3, n, 2) if sieve[i]]\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom functools import reduce\n\ndef factors(n):\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\ninput = sys.stdin.readline\n(mod, infi) = (998244353, sys.maxsize)\nfrom collections import deque, Counter, defaultdict as dd\nfrom heapq import heappop, heappush, heapify\nfrom itertools import accumulate, combinations, combinations_with_replacement, permutations\nfrom functools import lru_cache, reduce\nfrom operator import mul, add, sub, truediv, floordiv, lt, le, eq, ne, gt, xor, concat, getitem, lshift\ninty = lambda : int(input())\nstringy = lambda : input().strip()\nnormal = lambda : input().split()\nmappy = lambda : map(int, input().strip().split())\nfmappy = lambda : map(float, input().strip().split())\nlisty = lambda : list(map(int, input().strip().split()))\ntick = lambda : time.perf_counter()\nlogg = lambda a, b: math.log2(a) / math.log2(b)\nacc = lambda x: list(accumulate(x))\nsign = lambda x, y: x >= 0 and y >= 0 or (x < 0 and y < 0)\n\ndef solve(n, m):\n    res = 0\n    for bit in range(30):\n        lc = m // (2 << bit) * (1 << bit)\n        lc += max(0, m % (2 << bit) - (1 << bit) + 1)\n        res += pow(lc, n, mod) << bit\n    return res % mod\nT = inty()\nfor _ in range(T):\n    (n, m) = mappy()\n    print(solve(n, m))", "mod = 998244353\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    print(ans % mod)", "mod = 998244353\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    print(ans % mod)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    sums = 0\n    for i in range(31):\n        sums += pow((m // (1 << i + 1) << i) + max(0, m % (1 << i + 1) - (1 << i) + 1), n, 998244353) << i\n    print(sums % 998244353)", "def c(m, i):\n    return (m // (1 << i + 1) << i) + max(0, m % (1 << i + 1) - (1 << i) + 1)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    sums = 0\n    for i in range(31):\n        sums += pow(c(m, i), n, 998244353) << i\n    print(sums % 998244353)", "P = 998244353\n\ndef max_set_bit(n: int):\n    k = 0\n    while n:\n        n >>= 1\n        k += 1\n    return k - 1\n\ndef numbers_with_kth_bit_set(M: int, k: int):\n    M += 1\n    b = 1 << k\n    n = M // b\n    return n // 2 * b + M % b * (n % 2)\n\ndef mod_pow(b, e, p):\n    ans = 1\n    while e > 0:\n        if e % 2:\n            ans = ans * b % p\n        e //= 2\n        b = b * b\n    return ans\n\ndef mod_pow(b, e, p):\n    if e == 0:\n        return 1\n    ans = mod_pow(b, e // 2, p)\n    ans = ans * ans % p\n    if e % 2:\n        ans = ans * b % p\n    return ans\nt = int(input())\nfor _ in range(t):\n    (N, M) = list(map(int, input().split()))\n    answer = 0\n    base = 1\n    for k in range(31):\n        m = numbers_with_kth_bit_set(M, k)\n        counts = mod_pow(m, N, P)\n        answer = (answer + base * counts) % P\n        base = base * 2 % P\n        k += 1\n        if m == 0:\n            break\n    print(answer)", "P = 998244353\n\ndef max_set_bit(n: int):\n    k = 0\n    while n:\n        n >>= 1\n        k += 1\n    return k - 1\n\ndef numbers_with_kth_bit_set(M: int, k: int):\n    M += 1\n    b = 1 << k\n    n = M // b\n    return n // 2 * b + M % b * (n % 2)\n\ndef mod_pow(b, e, p):\n    ans = 1\n    while e > 0:\n        if e % 2:\n            ans = ans * b % p\n        e //= 2\n        b = b * b\n    return ans\n\ndef mod_pow(b, e, p):\n    if e == 0:\n        return 1\n    ans = mod_pow(b, e // 2, p)\n    ans = ans * ans % p\n    if e % 2:\n        ans = ans * b % p\n    return ans\nt = int(input())\nfor _ in range(t):\n    (N, M) = list(map(int, input().split()))\n    answer = 0\n    base = 1\n    K = max_set_bit(M)\n    for k in range(K + 1):\n        m = numbers_with_kth_bit_set(M, k)\n        counts = mod_pow(m, N, P)\n        answer = (answer + base * counts) % P\n        base = base * 2 % P\n        k += 1\n        if m == 0:\n            break\n    print(answer)", "P = 998244353\n\ndef max_set_bit(n: int):\n    k = 0\n    while n:\n        n >>= 1\n        k += 1\n    return k - 1\n\ndef check_bit(n: int, k: int):\n    return n >> k & 1\n\ndef numbers_with_kth_bit_set(M: int, k: int):\n    M += 1\n    b = 1 << k\n    n = M // b\n    if n % 2 == 0:\n        return n // 2 * b\n    return n // 2 * b + M % b\n\ndef mod_pow(b, e, p):\n    if e == 0:\n        return 1\n    ans = mod_pow(b, e // 2, p)\n    ans = ans * ans % p\n    if e % 2:\n        ans = ans * b % p\n    return ans\nt = int(input())\nfor _ in range(t):\n    (N, M) = list(map(int, input().split()))\n    K = max_set_bit(M)\n    answer = 0\n    total_counts = mod_pow(M, N, P)\n    for k in range(K, -1, -1):\n        m = numbers_with_kth_bit_set(M, k)\n        counts = mod_pow(m, N, P)\n        base = mod_pow(2, k, P)\n        answer += base * counts % P\n        answer %= P\n    print(answer)", "mod = 998244353\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    print(ans % mod)", "mod = 998244353\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    print(ans % mod)", "mod = 998244353\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    print(ans % mod)", "mod = 998244353\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for bit in range(30):\n        ct = m // (2 << bit) * (1 << bit)\n        ct += max(0, m % (2 << bit) - (1 << bit) + 1)\n        ans += pow(ct, n, mod) << bit\n    print(ans % mod)", "MOD = 998244353\n\ndef power(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % MOD\n        b = b * b % MOD\n        n //= 2\n    return s\n\ndef count(i, j):\n    return (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = 0\n    for i in range(31):\n        s = (s + (power(count(m, i), n) << i) % MOD) % MOD\n    print(s)", "from math import log2\np = 998244353\n\ndef razn(x, y):\n    return (x - y) % p\n\ndef slog(x, y):\n    return (x + y) % p\n\ndef mult(x, y):\n    return x * y % p\n\ndef pow(x, y):\n    s = x\n    res = 1\n    while y > 0:\n        a = y % 2\n        if a:\n            res = mult(res, s)\n        s = mult(s, s)\n        y = y // 2\n    return res\n\ndef delen(x, y):\n    return mult(x, pow(y, p - 2))\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    q = int(log2(m)) + 1\n    W = [0] * q\n    m1 = m\n    s = []\n    while m1 > 0:\n        s.append(m1 % 2)\n        m1 = m1 // 2\n    for x in range(len(s)):\n        W[x] = s[x]\n    s.reverse()\n    zap = []\n    for x in range(len(s)):\n        if s[x]:\n            for y in range(len(s) - 1 - x):\n                W[y] += 2 ** (len(s) - x - 2)\n            for y in zap:\n                W[y] += 2 ** (len(s) - x - 1)\n            zap.append(len(s) - 1 - x)\n    res = 0\n    e = 1\n    for x in range(q):\n        u = W[x]\n        res = slog(res, mult(pow(W[x], n), e))\n        e = mult(e, 2)\n    print(res)", "def councoun(iikm, jjkm):\n    return (iikm // (1 << jjkm + 1) << jjkm) + max(0, iikm % (1 << jjkm + 1) - (1 << jjkm) + 1)\n\ndef powepowe(bbkm, nnkm):\n    s = 1\n    while nnkm:\n        if nnkm % 2 == 1:\n            s = s * bbkm % 998244353\n        bbkm = bbkm * bbkm % 998244353\n        nnkm = nnkm // 2\n    return s\nt = int(input())\nfor h in range(t):\n    (nnkm, mmkm) = map(int, input().split())\n    s = 0\n    for jjkm in range(31):\n        s = (s + (powepowe(councoun(mmkm, jjkm), nnkm) << jjkm) % 998244353) % 998244353\n    print(s)", "mod = 998244353\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y //= 2\n        x = x * x % p\n    return res\n\ndef power_ka_function(a, b):\n    return a // 2 ** (b + 1) * 2 ** b\n\ndef rem_ka_function(a, b):\n    res = a % 2 ** (b + 1) - 2 ** b + 1\n    if res < 0:\n        return 0\n    return res\n\ndef solve():\n    (size, limit) = map(int, input().split())\n    ans = 0\n    for i in range(32):\n        var = power_ka_function(limit, i) + rem_ka_function(limit, i)\n        var = power(var, size, mod)\n        var %= mod\n        var *= 2 ** i\n        ans += var\n        ans %= mod\n    print(ans % mod)\nt = int(input())\nfor _ in range(t):\n    solve()", "def Sets(n: int, m: int):\n    if m == 1:\n        return [[n]]\n    ans = []\n    for i in range(n + 1):\n        ans += [[i] + e for e in Sets(n - i, m - 1)]\n    return ans\n\ndef lpow(e: int, i: int):\n    if i == 0:\n        return 2 ** 31 - 1\n    return e\n\ndef relu(x):\n    return max(0, x)\n\ndef nCr2(n: int, r: int):\n    ans = 1\n    for i in range(r):\n        ans *= n - i\n        ans //= i + 1\n    return ans\n\ndef nCr(n: int, r: list):\n    ans = 1\n    for i in range(len(r)):\n        ans *= nCr2(n, r[i])\n        n -= r[i]\n    return ans\n\ndef fc(a, b):\n    t1 = a % (1 << b + 1) - (1 << b) + 1\n    t2 = a // (1 << b + 1)\n    ret = relu(t1) + (t2 << b)\n    return ret\n\ndef binpow(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % 998244353\n        a = a * a % 998244353\n        b >>= 1\n    return res\n\ndef f(n: int, m):\n    ans = 0\n    for e in Sets(n, m):\n        term = 2 ** 31 - 1\n        p = 1\n        for i in e:\n            term &= lpow(p, i)\n            p += 1\n        ans += term * nCr(n, e) % 998244353\n    return ans % 998244353\n\ndef f2(n, m):\n    ans = 0\n    for i in range(20 + 11):\n        ans += binpow(fc(m, i), n) << i\n    return ans % 998244353\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    print(f2(n, m))", "for _ in range(int(input())):\n    (x, y) = map(int, input().split())\n\n    def solve(arr, n):\n        c = 1\n        while n:\n            if n % 2 == 1:\n                c *= arr % 998244353\n            arr = arr * arr % 998244353\n            n = n // 2\n        return c\n\n    def solve1(m, l):\n        return (m // (1 << l + 1) << l) + max(0, m % (1 << l + 1) - (1 << l) + 1)\n\n    def result():\n        ans = 0\n        for j in range(31):\n            ans = (ans + (solve(solve1(y, j), x) << j) % 998244353) % 998244353\n        return ans\n    print(result())", "def councoun(iik, jjk):\n    return (iik // (1 << jjk + 1) << jjk) + max(0, iik % (1 << jjk + 1) - (1 << jjk) + 1)\n\ndef powepowe(bbk, nnk):\n    s = 1\n    while nnk:\n        if nnk % 2 == 1:\n            s = s * bbk % 998244353\n        bbk = bbk * bbk % 998244353\n        nnk = nnk // 2\n    return s\nt = int(input())\nfor h in range(t):\n    (nnk, mmk) = map(int, input().split())\n    s = 0\n    for jjk in range(31):\n        s = (s + (powepowe(councoun(mmk, jjk), nnk) << jjk) % 998244353) % 998244353\n    print(s)", "from math import log2\nmod = 998244353\npo2 = [pow(2, i) for i in range(32)]\n\ndef solve(n, m):\n    s = 0\n    for i in range(int(log2(m)) + 1):\n        k = m - m % po2[i + 1]\n        t = k // 2 + max(0, m - k - po2[i] + 1)\n        if not t:\n            break\n        s += pow(t, n, mod) * po2[i] % mod\n        s %= mod\n    return s\nfor _ in range(int(input())):\n    (a, b) = map(int, input().strip().split())\n    print(solve(a, b))", "MOD = 998244353\n\ndef calculatePower(i, j):\n    sums = 1\n    while j:\n        if j % 2 == 1:\n            sums = sums * i % MOD\n        i = i * i % MOD\n        j //= 2\n    return sums\n\ndef countCheck(i, j):\n    return (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\nT = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    sums = 0\n    for i in range(31):\n        sums = (sums + (calculatePower(countCheck(M, i), N) << i) % MOD) % MOD\n    print(sums)", "def councoun(iiii, jjjj):\n    return (iiii // (1 << jjjj + 1) << jjjj) + max(0, iiii % (1 << jjjj + 1) - (1 << jjjj) + 1)\n\ndef powepowe(bbbb, nnnn):\n    s = 1\n    while nnnn:\n        if nnnn % 2 == 1:\n            s = s * bbbb % 998244353\n        bbbb = bbbb * bbbb % 998244353\n        nnnn = nnnn // 2\n    return s\nt = int(input())\nfor h in range(t):\n    (nnnn, mmmm) = map(int, input().split())\n    s = 0\n    for jjjj in range(31):\n        s = (s + (powepowe(councoun(mmmm, jjjj), nnnn) << jjjj) % 998244353) % 998244353\n    print(s)", "def councoun(iii, jjj):\n    return (iii // (1 << jjj + 1) << jjj) + max(0, iii % (1 << jjj + 1) - (1 << jjj) + 1)\n\ndef powepowe(bbb, nnn):\n    s = 1\n    while nnn:\n        if nnn % 2 == 1:\n            s = s * bbb % 998244353\n        bbb = bbb * bbb % 998244353\n        nnn = nnn // 2\n    return s\nt = int(input())\nfor h in range(t):\n    (nnn, mmm) = map(int, input().split())\n    s = 0\n    for jjj in range(31):\n        s = (s + (powepowe(councoun(mmm, jjj), nnn) << jjj) % 998244353) % 998244353\n    print(s)", "def fast_mod_exp(n, exp, mod):\n    if exp == 0:\n        return 1 % mod\n    b = binary(exp, 0)\n    res = 1\n    current = n\n    for i in range(len(b)):\n        if b[len(b) - i - 1] == 1:\n            res *= current\n            res %= mod\n        current *= current\n        current %= mod\n    return res\n\ndef binary(n, min_size):\n    if n == 0:\n        return [0]\n    res = []\n    while n > 0 or len(res) < min_size:\n        res.append(n % 2)\n        n //= 2\n    return list(reversed(res))\n\ndef get_count(p, limit, mod):\n    bl = binary(limit, 32)\n    res = 0\n    e = 1\n    for (i, el) in enumerate(bl):\n        current_p = len(bl) - i - 1\n        if p == current_p:\n            if el == 0:\n                break\n            else:\n                e = 0\n                continue\n        if len(bl) - i - (1 + e) < 0:\n            break\n        if el == 0:\n            continue\n        res += 2 ** (len(bl) - i - (1 + e))\n        res %= mod\n    return res\n\ndef f(n, limit, mod):\n    res = 0\n    p = 0\n    while 2 ** p <= limit:\n        count = get_count(p, limit, mod)\n        count = fast_mod_exp(count, n, mod)\n        res += count * 2 ** p\n        res %= mod\n        p += 1\n    return res\nt = int(input())\nfor i in range(t):\n    (n, m) = [int(el) for el in input().split(' ')]\n    print(f(n, m + 1, 998244353))", "def councoun(ii, jj):\n    return (ii // (1 << jj + 1) << jj) + max(0, ii % (1 << jj + 1) - (1 << jj) + 1)\n\ndef powepowe(bb, nn):\n    s = 1\n    while nn:\n        if nn % 2 == 1:\n            s = s * bb % 998244353\n        bb = bb * bb % 998244353\n        nn = nn // 2\n    return s\nt = int(input())\nfor h in range(t):\n    (nn, mm) = map(int, input().split())\n    s = 0\n    for jj in range(31):\n        s = (s + (powepowe(councoun(mm, jj), nn) << jj) % 998244353) % 998244353\n    print(s)", "for _1 in range(int(input())):\n    (n, m) = map(int, input().split())\n\n    def ans(a, b):\n        return (a // (1 << b + 1) << b) + max(0, a % (1 << b + 1) - (1 << b) + 1)\n\n    def list1(c, d):\n        cou = 1\n        while d:\n            if d % 2 == 1:\n                cou = cou * c % 998244353\n            c = c * c % 998244353\n            d = d // 2\n        return cou\n    v = 0\n    for l in range(31):\n        v = (v + (list1(ans(m, l), n) << l) % 998244353) % 998244353\n    print(v)", "def conu(i, j):\n    return (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\n\ndef pwoe(a, b):\n    s = 1\n    while b:\n        if b % 2 == 1:\n            s = s * a % 998244353\n        a = a * a % 998244353\n        b = b // 2\n    return s\nc = int(input())\nfor h in range(c):\n    (y, u) = map(int, input().split())\n    s = 0\n    for j in range(31):\n        s = (s + (pwoe(conu(u, j), y) << j) % 998244353) % 998244353\n    print(s)", "def get_possibilities(M):\n    result = [0] * M.bit_length()\n    bits = [b for b in f'{M:b}']\n    for (i, b) in enumerate(bits):\n        if b == '1':\n            result[i] += 1\n            if i == M.bit_length():\n                break\n            factor = 1 << M.bit_length() - i - 1\n            resid = M % factor\n            result[i] += resid\n            for j in range(i + 1, len(result)):\n                result[j] += factor // 2\n    return result[::-1]\nT = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split(' '))\n    possibilities = get_possibilities(M)\n    result = 0\n    modulo = 998244353\n    for (i, p) in enumerate(possibilities):\n        result += pow(2, i, modulo) * pow(p, N, modulo)\n        result %= modulo\n    print(result)", "def coun(i, j):\n    return (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\n\ndef powe(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % 998244353\n        b = b * b % 998244353\n        n = n // 2\n    return s\nt = int(input())\nfor h in range(t):\n    (n, m) = map(int, input().split())\n    s = 0\n    for j in range(31):\n        s = (s + (powe(coun(m, j), n) << j) % 998244353) % 998244353\n    print(s)", "for i in range(int(input())):\n    (n, m) = map(int, input().split())\n\n    def array(a, n):\n        c = 1\n        while n:\n            if n % 2 == 1:\n                c = c * a % 998244353\n            a = a * a % 998244353\n            n = n // 2\n        return c\n\n    def sol(q, w):\n        return (q // (1 << w + 1) << w) + max(0, q % (1 << w + 1) - (1 << w) + 1)\n\n    def res():\n        v = 0\n        for j in range(31):\n            v = (v + (array(sol(m, j), n) << j) % 998244353) % 998244353\n        return v\n    print(res())", "import io, os, sys\n\ndef print(*args, sep=' ', end='\\n'):\n    string = sep.join(map(str, args)) + end\n    sys.stdout.write(string)\n\ndef debug(*args, sep=' ', end='\\n'):\n    string = 'Debug: ' + sep.join(map(str, args)) + end\n    sys.stderr.write(string)\nMOD = 998244353\n\ndef pos(M, i):\n    sub = 1 << i\n    if M < sub:\n        return 0\n    if M & sub:\n        smol = 1 + (M & sub - 1)\n    else:\n        smol = 0\n    parts = M >> i + 1\n    result = parts * sub + smol\n    return result % MOD\n\ndef solve(N, M):\n    total = 0\n    for i in range(30):\n        res = (1 << i) % MOD\n        total += res * pow(pos(M, i), N, MOD)\n        total %= MOD\n    return total\nT = int(input())\nfor case in range(1, T + 1):\n    (N, M) = map(int, input().split())\n    print(solve(N, M))", "def increase(a, t):\n    r = 1\n    while t:\n        if t % 2 == 1:\n            r = r * a % 998244353\n        a = a * a % 998244353\n        t //= 2\n    return r\n\ndef counter(i, j):\n    res = (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\n    return res\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = 0\n    for i in range(0, 31, 1):\n        s = (s + (increase(counter(m, i), n) << i) % 998244353) % 998244353\n    print(s)", "def power(c, n):\n    sums = 1\n    while n > 0:\n        if n % 2 == 1:\n            sums *= c % 998244353\n        c *= c % 998244353\n        n //= 2\n    return sums\n\ndef c(m, i):\n    return (m // (1 << i + 1) << i) + max(0, m % (1 << i + 1) - (1 << i) + 1)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    sums = 0\n    for i in range(31):\n        sums += (power(c(m, i), n) << i) % 998244353\n    print(sums % 998244353)", "def p(a, nu):\n    c = 1\n    while nu:\n        if nu % 2 == 1:\n            c = c * a % 998244353\n        a = a * a % 998244353\n        nu //= 2\n    return c\n\ndef c(ar1, ar2):\n    return (ar1 // (1 << ar2 + 1) << ar2) + max(0, ar1 % (1 << ar2 + 1) - (1 << ar2) + 1)\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = 0\n    for i in range(0, 31):\n        s = (s + (p(c(m, i), n) << i) % 998244353) % 998244353\n    print(s)", "def p(a, nu):\n    c = 1\n    while nu:\n        if nu % 2 == 1:\n            c = c * a % 998244353\n        a = a * a % 998244353\n        nu //= 2\n    return c\n\ndef c(ar1, ar2):\n    return (ar1 // (1 << ar2 + 1) << ar2) + max(0, ar1 % (1 << ar2 + 1) - (1 << ar2) + 1)\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = 0\n    for i in range(0, 31):\n        s = (s + (p(c(m, i), n) << i) % 998244353) % 998244353\n    print(s)", "def p(a, nu):\n    c = 1\n    while nu:\n        if nu % 2 == 1:\n            c = c * a % 998244353\n        a = a * a % 998244353\n        nu //= 2\n    return c\n\ndef c(ar1, ar2):\n    return (ar1 // (1 << ar2 + 1) << ar2) + max(0, ar1 % (1 << ar2 + 1) - (1 << ar2) + 1)\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = 0\n    for i in range(0, 31):\n        s = (s + (p(c(m, i), n) << i) % 998244353) % 998244353\n    print(s)", "def p(bd, nu):\n    c = 1\n    while nu:\n        if nu % 2 == 1:\n            c = c * bd % 998244353\n        bd = bd * bd % 998244353\n        nu //= 2\n    return c\n\ndef c(ar1, ar2):\n    return (ar1 // (1 << ar2 + 1) << ar2) + max(0, ar1 % (1 << ar2 + 1) - (1 << ar2) + 1)\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = 0\n    for i in range(0, 31):\n        s = (s + (p(c(m, i), n) << i) % 998244353) % 998244353\n    print(s)", "def p(bd, nu):\n    c = 1\n    while nu:\n        if nu % 2 == 1:\n            c = c * bd % 998244353\n        bd = bd * bd % 998244353\n        nu //= 2\n    return c\n\ndef c(ar1, ar2):\n    return (ar1 // (1 << ar2 + 1) << ar2) + max(0, ar1 % (1 << ar2 + 1) - (1 << ar2) + 1)\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = 0\n    for i in range(0, 31):\n        s = (s + (p(c(m, i), n) << i) % 998244353) % 998244353\n    print(s)", "def pow(bg, num):\n    count = 1\n    while num:\n        if num % 2 == 1:\n            count = count * bg % 998244353\n        bg = bg * bg % 998244353\n        num //= 2\n    return count\n\ndef coun(arg1, arg2):\n    return (arg1 // (1 << arg2 + 1) << arg2) + max(0, arg1 % (1 << arg2 + 1) - (1 << arg2) + 1)\nfor trie in range(int(input())):\n    (n, m) = map(int, input().split())\n    out_put = 0\n    for i in range(0, 31):\n        out_put = (out_put + (pow(coun(m, i), n) << i) % 998244353) % 998244353\n    print(out_put)", "import math\n\ndef count(i, j):\n    return (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\n\ndef power(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % 998244353\n        b = b * b % 998244353\n        n //= 2\n    return s\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = 0\n    for i in range(31):\n        s = (s + (power(count(m, i), n) << i) % 998244353) % 998244353\n    print(s)", "def getcount(n, k):\n    res = n >> k + 1 << k\n    if n >> k & 1:\n        res += n & (1 << k) - 1\n    return res\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    mod = 998244353\n    new = [0] * 32\n    for i in range(31):\n        new[i] = getcount(m + 1, i)\n    for i in range(32):\n        ans = (ans + (1 << i) * pow(new[i], n, mod) % mod) % mod\n    print(ans)", "import sys\nmod = 998244353\n\ndef power(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % mod\n        b = b * b % mod\n        n //= 2\n    return s\n\ndef count(i, j):\n    return (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\nt = int(input())\nwhile t != 0:\n    (n, m) = map(int, input().split(' '))\n    s = 0\n    for i in range(31):\n        s = (s + (power(count(m, i), n) << i) % mod) % mod\n    print(s)\n    t -= 1", "MODULE = 998244353\nfor _ in range(int(input())):\n    (N, M) = list(map(int, input().split()))\n    ans = 0\n    for i in range(M.bit_length()):\n        suma = M // 2 ** (i + 1) * 2 ** i + max(M % 2 ** (i + 1) - 2 ** i + 1, 0)\n        ans += 2 ** i * pow(suma, N, MODULE)\n    print(ans % MODULE)", "for k in range(int(input())):\n    (n, i) = list(map(int, input().split()))\n    s = 0\n    for j in range(0, 32):\n        q = (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\n        s += pow(q, n, 998244353) << j\n    print(s % 998244353)", "for i in range(int(input())):\n    (n, m) = map(int, input().split())\n    m1 = m\n    c = 1\n    xx = 1\n    while 1:\n        if m1 < xx:\n            c -= 1\n            break\n        elif m1 == xx:\n            break\n        c += 1\n        xx *= 2\n    ans = 0\n    p = 1\n    k = {}\n    h = 2\n    for y in range(0, c):\n        if (m + 1) % h == 0:\n            l = (m + 1) // h\n            l = l * (h // 2)\n            k[y] = l\n        else:\n            l = (m + 1) // h\n            l = l * (h // 2)\n            r = (m + 1) % h\n            if r <= h // 2:\n                r = 0\n            else:\n                r = r - h // 2\n            k[y] = l + r\n        h *= 2\n    f = {}\n    n1 = n\n    z = 998244353\n    for q in range(c):\n        n1 = n\n        t = 1\n        kk = k[q]\n        while n1:\n            if n1 & 1 == 1:\n                t = t * kk % z\n            n1 = n1 >> 1\n            kk = kk * kk % z\n        ans = ans + t * p\n        p *= 2\n    print(ans % z)", "def coun(i, j):\n    return (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\n\ndef powe(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % 998244353\n        b = b * b % 998244353\n        n = n // 2\n    return s\nt = int(input())\nfor h in range(t):\n    (n, m) = map(int, input().split())\n    s = 0\n    for j in range(31):\n        s = (s + (powe(coun(m, j), n) << j) % 998244353) % 998244353\n    print(s)", "import math\nbeeg = 998244353\n\ndef beegPow(base, exponent):\n    return pow(base, exponent, beeg)\nfor tea in range(int(input())):\n    ans = 0\n    (n, m) = [int(aaa) for aaa in input().split()]\n    for i in range(math.floor(math.log2(m)) + 1):\n        lawl = 2 ** i\n        daNum = m // (2 * lawl) * lawl + max(0, m % (2 * lawl) - lawl + 1)\n        ans = (ans + beegPow(daNum, n) * lawl) % beeg\n    print(ans)", "for k in range(int(input())):\n    (n, i) = list(map(int, input().split()))\n    s = 0\n    for j in range(0, 32):\n        q = (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\n        s += pow(q, n, 998244353) << j\n    print(s % 998244353)", "md = 998244353\nt = int(input())\nfor _ in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    ans = 0\n    for i in range(0, 32):\n        ans += pow((m // pow(2, i + 1) << i) + max(0, m % pow(2, i + 1) - pow(2, i) + 1), n, md) << i\n    print(ans % md)", "mod = 998244353\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    l = [0 for i in range(31)]\n    bi = str(bin(m))[2:][::-1]\n    l1 = []\n    for i in range(len(bi)):\n        x = m >> i + 1\n        x = x << i\n        if bi[i] == '1':\n            x = x + (m - (m >> i << i) + 1)\n        l1.append(x)\n    ans = 0\n    c = 0\n    for i in l1:\n        ans += pow(i, n, mod) * pow(2, c, mod)\n        c += 1\n        ans = ans % mod\n    print(ans)", "import numpy as np\nimport math\n\ndef fgx(n):\n    length = len(bin(n)[2:])\n    array = [0] * length\n    power = 2\n    for i in range(0, length):\n        array[i] = math.floor((n + 1) / power) * (power / 2) + max((n + 1) % power - power / 2, 0)\n        power = power * 2\n    return array\n\ndef calculate(n, m):\n    array = np.array(fgx(n))\n    mod = 998244353\n    count = 0\n    power = 1\n    for x in array:\n        count += power * pow(int(x), m, mod) % mod\n        power = power * 2 % mod\n    return count % mod\nn = int(input())\nfor _ in range(0, n):\n    array = list(map(int, input().split()))\n    print(calculate(array[1], array[0]))", "MOD = 998244353\n\ndef getex(till, exp):\n    ex = till >> exp + 1 << exp\n    powxp = 1 << exp\n    if till & powxp:\n        ex += till % powxp\n    return ex\n\ndef main(N, M):\n    summation = 0\n    for exp in range(M.bit_length()):\n        expenses = getex(M + 1, exp)\n        expbitsum = (pow(expenses, N, MOD) << exp) % MOD\n        summation = (summation + expbitsum) % MOD\n    return summation\nT = int(input())\nfor i in range(T):\n    (N, M) = map(int, input().split())\n    print(main(N, M))", "for _ in range(int(input())):\n    (n1, m) = map(int, input().split())\n    sum = 0\n    p = 1\n    for i in range(31):\n        n = n1\n        z = max(m % (1 << i + 1) - (1 << i) + 1, 0) + (m // (1 << i + 1) << i)\n        p = 1\n        while n:\n            if n % 2:\n                p = p * z % 998244353\n            z = z * z % 998244353\n            n //= 2\n        sum = (sum + (p << i)) % 998244353 % 998244353\n    print(sum)", "for i in range(int(input())):\n    (n, m) = map(int, input().split())\n    m1 = m\n    c = 1\n    xx = 1\n    while 1:\n        if m1 < xx:\n            c -= 1\n            break\n        elif m1 == xx:\n            break\n        c += 1\n        xx *= 2\n    ans = 0\n    p = 1\n    k = {}\n    h = 2\n    for y in range(0, c):\n        if (m + 1) % h == 0:\n            l = (m + 1) // h\n            l = l * (h // 2)\n            k[y] = l\n        else:\n            l = (m + 1) // h\n            l = l * (h // 2)\n            r = (m + 1) % h\n            if r <= h // 2:\n                r = 0\n            else:\n                r = r - h // 2\n            k[y] = l + r\n        h *= 2\n    f = {}\n    n1 = n\n    z = 998244353\n    for q in range(c):\n        n1 = n\n        t = 1\n        kk = k[q]\n        while n1:\n            if n1 & 1 == 1:\n                t = t * kk % z\n            n1 = n1 >> 1\n            kk = kk * kk % z\n        ans = ans + t * p\n        p *= 2\n    print(ans % z)", "def mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\n\ndef find(m, k):\n    sk = 1 << k\n    c1 = m >> k + 1 << k\n    c0 = c1 << 1\n    return c1 + max(0, m + 1 - c0 - sk)\nfor t in range(int(input())):\n    (n, m) = mi()\n    ans = 0\n    mod = 998244353\n    for i in range(32):\n        curr = find(m, i)\n        if curr > 0:\n            ans += (1 << i) * pow(curr, n, mod)\n            ans %= mod\n    print(ans)", "def power(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % 998244353\n        b = b * b % 998244353\n        n //= 2\n    return s\n\ndef count(i, j):\n    return (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\n\ndef solve():\n    (n, m) = map(int, input().split())\n    s = 0\n    for i in range(31):\n        s = (s + (power(count(m, i), n) << i) % 998244353) % 998244353\n    print(s)\nt = int(input())\nfor _ in range(t):\n    solve()", "inf = 998244353\n\ndef an(n, a):\n    z = 1\n    while n:\n        if n % 2:\n            z = z * a % inf\n        a = a * a % inf\n        n //= 2\n    return z\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for i in range(31):\n        c = (m // (1 << i + 1) << i) + max(0, m % (1 << i + 1) - (1 << i) + 1)\n        ans = (ans + (an(n, c) << i) % 998244353) % 998244353\n    print(ans)", "inf = 998244353\n\ndef an(n, a):\n    z = 1\n    while n:\n        if n % 2:\n            z = z * a % inf\n        a = a * a % inf\n        n //= 2\n    return z\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    for i in range(31):\n        c = (m // (1 << i + 1) << i) + max(0, m % (1 << i + 1) - (1 << i) + 1)\n        ans = (ans + (an(n, c) << i) % 998244353) % 998244353\n    print(ans)", "MOD = 998244353\n\ndef modpow(base, exp, mod):\n    result = 1\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef cardinalBitX1toM(M, bit):\n    if M < bit:\n        return 0\n    elif M < bit << 1:\n        return M - bit + 1\n    return bit * (M // (bit << 1)) + cardinalBitX1toM(M % (bit << 1), bit)\n\ndef main(N, M):\n    ANS = 0\n    for i in range(30):\n        ANS += (1 << i) * modpow(cardinalBitX1toM(M, 1 << i), N, MOD)\n        ANS %= MOD\n    return ANS\nT = int(input().strip())\nfor _ in range(T):\n    (N, M) = [int(x) for x in input().strip().split()[:2]]\n    print(main(N, M))", "def count(i, j):\n    return (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\nfor _ in range(int(input())):\n    (sa, me) = list(map(int, input().split()))\n    sh = 0\n    for i in range(0, 32):\n        sh += pow(count(me, i), sa, 998244353) << i\n    print(sh % 998244353)", "mod = 998244353\n\ndef power(x, y):\n    a = 1\n    while y:\n        if y & 1:\n            a = a * x % mod\n        x = x * x % mod\n        y >>= 1\n    return a\n\ndef func(m, j):\n    upper = m >> j + 1\n    ans = upper * 2 ** j\n    if m & 1 << j:\n        ans += m - (upper << j + 1) - 2 ** j + 1\n    return ans\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    ans = 0\n    for j in range(30):\n        ans += power(func(m, j), n) * 2 ** j % mod\n    print(ans % mod)", "from itertools import product\noutput = []\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split(' '))\n    ways = 0\n    two_power = 1\n    while two_power <= M:\n        c = M // (two_power << 1) * two_power\n        r = (M & (two_power << 1) - 1) - (two_power - 1)\n        if r > 0:\n            c += r\n        ways += pow(c, N, 998244353) * two_power % 998244353\n        two_power <<= 1\n    output.append(ways % 998244353)\nprint('\\n'.join(map(str, output)))", "def count(i, j):\n    return (i // (1 << j + 1) << j) + max(0, i % (1 << j + 1) - (1 << j) + 1)\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    s = 0\n    for i in range(0, 32):\n        s += pow(count(m, i), n, 998244353) << i\n    print(s % 998244353)", "import math\n\ndef pos(n):\n    if n < 0:\n        return 0\n    return n\nt = int(input())\nbreh = 998244353\nfor i in range(t):\n    (n, m) = [int(a) for a in input().split()]\n    s = int(math.log2(m + 1)) + 1\n    array = [0] * s\n    for i in range(s):\n        array[i] = m // 2 ** (i + 1) * 2 ** i % breh + pos(m % 2 ** (i + 1) - 2 ** i + 1)\n    f = 0\n    for l in range(s):\n        f = (f + pow(array[l], n, breh) * pow(2, l, breh)) % breh\n    print(f)", "MOD = 998244353\n\ndef K(m, i):\n    nai = 2 ** i\n    naii = nai * 2\n    return m // naii * nai + max(0, m % naii - (nai - 1))\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    result = 0\n    for i in range(32):\n        result += pow(K(m, i), n, MOD) * 2 ** i\n        result %= MOD\n    print(result)"]