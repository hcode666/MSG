["import sys\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nfor t in range(int(input())):\n    n = int(input())\n    s = input()\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        if s[u - 1] == 'R' and s[v - 1] == 'G' or (s[u - 1] == 'G' and s[v - 1] == 'R'):\n            continue\n        graph[u].append(v)\n        graph[v].append(u)\n    visit = set()\n\n    def dfs(u, count):\n        visit.add(u)\n        if s[u - 1] == 'B':\n            count[0] += 1\n        if count[0] > 1:\n            return False\n        for v in graph[u]:\n            if v not in visit:\n                if not dfs(v, count):\n                    return False\n        return True\n    flag = False\n    for i in range(1, n + 1):\n        if i not in visit:\n            if not dfs(i, [0]):\n                flag = True\n                break\n    if flag:\n        print('No')\n    else:\n        print('Yes')", "import math, sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfrom collections import deque\nfor _ in range(I()):\n    n = I()\n    c = S()\n    adj = [[] for i in range(n)]\n    f = 1\n    v = [0] * n\n    for i in range(n - 1):\n        (a, b) = M()\n        a -= 1\n        b -= 1\n        if c[a] == 'R' and c[b] == 'G' or (c[a] == 'G' and c[b] == 'R'):\n            continue\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def bfs(i):\n        q = deque()\n        b = 0\n        q.append(i)\n        v[i] = 1\n        b += c[i] == 'B'\n        while q:\n            r = q.popleft()\n            for j in adj[r]:\n                if v[j] == 0:\n                    b += c[j] == 'B'\n                    q.append(j)\n                    v[j] = 1\n        return b\n    for i in range(n):\n        if v[i] == 0:\n            b = bfs(i)\n            if b > 1:\n                f = 0\n                break\n    print('Yes' if f else 'No')", "import sys\nint1 = lambda x: int(x) - 1\npDB = lambda *x: print(*x, end='\\n', file=sys.stderr)\np2D = lambda x: print(*x, sep='\\n', end='\\n\\n', file=sys.stderr)\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef LI1():\n    return list(map(int1, sys.stdin.readline().split()))\n\ndef LLI1(rows_number):\n    return [LI1() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline().rstrip()\ndij = [(0, 1), (-1, 0), (0, -1), (1, 0)]\ninf = 18446744073709551615\nmd = 10 ** 9 + 7\n\ndef solve():\n    n = II()\n    cc = SI()\n    to = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = LI1()\n        to[u].append(v)\n        to[v].append(u)\n    root = 0\n    e = lambda : [inf, inf]\n\n    def op(a, b):\n        return [min(a[0], b[0]), min(a[1], b[1])]\n\n    def trans_up(u):\n        if cc[u] == 'B':\n            dp[u] = [0, 0]\n        if dp[u][0] == inf:\n            return\n        if cc[u] == 'R':\n            dp[u][0] = 1\n        if cc[u] == 'G':\n            dp[u][1] = 1\n        return\n\n    def trans_down(u):\n        p = par[u]\n        if cc[p] == 'B':\n            rdp[u] = [0, 0]\n        if cc[p] == 'R':\n            rdp[u][0] = 1\n        if cc[p] == 'G':\n            rdp[u][1] = 1\n        return\n    uu = []\n    stack = [root]\n    par = [-1] * n\n    while stack:\n        u = stack.pop()\n        uu.append(u)\n        vv = []\n        for v in to[u]:\n            if v == par[u]:\n                continue\n            vv.append(v)\n            par[v] = u\n            stack.append(v)\n        to[u] = vv\n    dp = [e() for _ in range(n)]\n    rdp = [e() for _ in range(n)]\n    for u in uu[::-1]:\n        p = par[u]\n        if p != -1:\n            trans_up(u)\n            dp[p] = op(dp[p], dp[u])\n    for u in uu:\n        cs = e()\n        for v in to[u]:\n            rdp[v] = cs\n            cs = op(cs, dp[v])\n        cs = op(e(), rdp[u])\n        for v in to[u][::-1]:\n            rdp[v] = op(rdp[v], cs)\n            trans_down(v)\n            cs = op(cs, dp[v])\n        dp[u] = cs\n    for u in range(n):\n        if cc[u] == 'B' and min(dp[u]) == 0:\n            print('No')\n            return\n    print('Yes')\nfor _ in range(II()):\n    solve()", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\n\ndef dfs(p, prev):\n    count = 0\n    for i in child[p]:\n        if i == prev:\n            continue\n        count += dfs(i, p)\n    return count + (a[p - 1] == 'B')\n\ndef answer():\n    for i in range(1, n + 1):\n        count = dfs(i, -1)\n        if count > 1:\n            return 'No'\n    return 'Yes'\nfor T in range(int(input())):\n    n = int(input())\n    a = input().strip()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        if a[u - 1] == 'R' and a[v - 1] == 'G':\n            continue\n        if a[u - 1] == 'G' and a[v - 1] == 'R':\n            continue\n        child[u].append(v)\n        child[v].append(u)\n    print(answer())", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\n\ndef dfs(p, prev):\n    count = 0\n    for i in child[p]:\n        if i == prev:\n            continue\n        count += dfs(i, p)\n    return count + (a[p - 1] == 'B')\n\ndef answer():\n    global count\n    for i in range(1, n + 1):\n        count = dfs(i, -1)\n        if count > 1:\n            return 'No'\n    return 'Yes'\nfor T in range(int(input())):\n    n = int(input())\n    a = input().strip()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        if a[u - 1] == 'R' and a[v - 1] == 'G':\n            continue\n        if a[u - 1] == 'G' and a[v - 1] == 'R':\n            continue\n        child[u].append(v)\n        child[v].append(u)\n    count = 0\n    print(answer())", "import sys\nint1 = lambda x: int(x) - 1\npDB = lambda *x: print(*x, end='\\n', file=sys.stderr)\np2D = lambda x: print(*x, sep='\\n', end='\\n\\n', file=sys.stderr)\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef LI1():\n    return list(map(int1, sys.stdin.readline().split()))\n\ndef LLI1(rows_number):\n    return [LI1() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline().rstrip()\ndij = [(0, 1), (-1, 0), (0, -1), (1, 0)]\ninf = 18446744073709551615\nmd = 10 ** 9 + 7\n\ndef solve():\n    n = II()\n    cc = SI()\n    to = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = LI1()\n        to[u].append(v)\n        to[v].append(u)\n    root = 0\n    e = lambda : [inf, inf]\n\n    def op(a, b):\n        return [min(a[0], b[0]), min(a[1], b[1])]\n\n    def trans_up(u):\n        if cc[u] == 'B':\n            dp[u] = [0, 0]\n        if dp[u][0] == inf:\n            return\n        if cc[u] == 'R':\n            dp[u][0] = 1\n        if cc[u] == 'G':\n            dp[u][1] = 1\n        return\n\n    def trans_down(u):\n        p = par[u]\n        if cc[p] == 'B':\n            rdp[u] = [0, 0]\n        if cc[p] == 'R':\n            rdp[u][0] = 1\n        if cc[p] == 'G':\n            rdp[u][1] = 1\n        return\n    uu = []\n    stack = [root]\n    par = [-1] * n\n    while stack:\n        u = stack.pop()\n        uu.append(u)\n        vv = []\n        for v in to[u]:\n            if v == par[u]:\n                continue\n            vv.append(v)\n            par[v] = u\n            stack.append(v)\n        to[u] = vv\n    dp = [e() for _ in range(n)]\n    rdp = [e() for _ in range(n)]\n    for u in uu[::-1]:\n        p = par[u]\n        if p != -1:\n            trans_up(u)\n            dp[p] = op(dp[p], dp[u])\n    for u in uu:\n        cs = e()\n        for v in to[u]:\n            rdp[v] = cs\n            cs = op(cs, dp[v])\n        cs = op(e(), rdp[u])\n        for v in to[u][::-1]:\n            rdp[v] = op(rdp[v], cs)\n            trans_down(v)\n            cs = op(cs, dp[v])\n        dp[u] = cs\n    for u in range(n):\n        if cc[u] == 'B' and min(dp[u]) == 0:\n            print('No')\n            return\n    print('Yes')\nfor _ in range(II()):\n    solve()"]