["import math, bisect, heapq, random, sys, itertools\nsys.setrecursionlimit(2 * 10 ** 5)\ninput = sys.stdin.readline\n\ndef slope(x1, y1, x2, y2):\n    if x2 - x1 == 0:\n        return 'inf'\n    return float(y2 - y1) / (x2 - x1)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    x = []\n    y = []\n    c = 0\n    for k in range(n):\n        s = [int(j) for j in input().split()]\n        x.append(s[0])\n        y.append(s[1])\n    for j in range(0, n):\n        m = {}\n        for k in range(0, n):\n            if k == j:\n                continue\n            if slope(x[j], y[j], x[k], y[k]) in m:\n                m[slope(x[j], y[j], x[k], y[k])] += 1\n                continue\n            m[slope(x[j], y[j], x[k], y[k])] = 1\n        for k in m:\n            if k == 'inf':\n                if 0 in m:\n                    c += m[0] * m[k]\n                continue\n            if k == 0:\n                if 'inf' in m:\n                    c += m['inf'] * m[k]\n                continue\n            if 1 / k * -1 in m:\n                c += m[1 / k * -1] * m[k]\n    print(c // 2)", "import math, bisect, heapq, random, sys, itertools\nsys.setrecursionlimit(2 * 10 ** 5)\ninput = sys.stdin.readline\n\ndef slope(x1, y1, x2, y2):\n    if x2 - x1 == 0:\n        return 'inf'\n    return float(y2 - y1) / (x2 - x1)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    x = []\n    y = []\n    c = 0\n    for k in range(n):\n        s = [int(j) for j in input().split()]\n        x.append(s[0])\n        y.append(s[1])\n    for j in range(0, n):\n        m = {}\n        for k in range(0, n):\n            if k == j:\n                continue\n            if slope(x[j], y[j], x[k], y[k]) in m:\n                m[slope(x[j], y[j], x[k], y[k])] += 1\n                continue\n            m[slope(x[j], y[j], x[k], y[k])] = 1\n        for k in m:\n            if k == 'inf':\n                if 0 in m:\n                    c += m[0] * m[k]\n                continue\n            if k == 0:\n                if 'inf' in m:\n                    c += m['inf'] * m[k]\n                continue\n            if 1 / k * -1 in m:\n                c += m[1 / k * -1] * m[k]\n    print(c // 2)", "import math, bisect, heapq, random, sys, itertools\nsys.setrecursionlimit(2 * 10 ** 5)\ninput = sys.stdin.readline\n\ndef slope(x1, y1, x2, y2):\n    if x2 - x1 == 0:\n        return 'inf'\n    return float(y2 - y1) / (x2 - x1)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    x = []\n    y = []\n    c = 0\n    for k in range(n):\n        s = [int(j) for j in input().split()]\n        x.append(s[0])\n        y.append(s[1])\n    for j in range(0, n):\n        m = {}\n        for k in range(0, n):\n            if k == j:\n                continue\n            if slope(x[j], y[j], x[k], y[k]) in m:\n                m[slope(x[j], y[j], x[k], y[k])] += 1\n                continue\n            m[slope(x[j], y[j], x[k], y[k])] = 1\n        for k in m:\n            if k == 'inf':\n                if 0 in m:\n                    c += m[0] * m[k]\n                continue\n            if k == 0:\n                if 'inf' in m:\n                    c += m['inf'] * m[k]\n                continue\n            if 1 / k * -1 in m:\n                c += m[1 / k * -1] * m[k]\n    print(c // 2)", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    c = []\n    for _ in range(N):\n        lis = [int(x) for x in input().split(' ')]\n        c.append(lis)\n    count = 0\n    dic = {}\n    for i in range(N - 1):\n        for j in range(i, N):\n            if i != j:\n                (x1, y1) = c[i]\n                (x2, y2) = c[j]\n                if x1 == x2:\n                    if (0, i) in dic:\n                        count += dic[0, i]\n                    if (0, j) in dic:\n                        count += dic[0, j]\n                    if ('inf', i) in dic:\n                        dic['inf', i] += 1\n                    else:\n                        dic['inf', i] = 1\n                    if ('inf', j) in dic:\n                        dic['inf', j] += 1\n                    else:\n                        dic['inf', j] = 1\n                else:\n                    m = (y2 - y1) / (x2 - x1)\n                    if m == 0:\n                        if ('inf', i) in dic:\n                            count += dic['inf', i]\n                        if ('inf', j) in dic:\n                            count += dic['inf', j]\n                    else:\n                        if (-1 / m, i) in dic:\n                            count += dic[-1 / m, i]\n                        if (-1 / m, j) in dic:\n                            count += dic[-1 / m, j]\n                    if (m, i) in dic:\n                        dic[m, i] += 1\n                    else:\n                        dic[m, i] = 1\n                    if (m, j) in dic:\n                        dic[m, j] += 1\n                    else:\n                        dic[m, j] = 1\n    print(count)", "import math\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    l = []\n    for j in range(n):\n        rows = list(map(int, input().split(' ')))\n        l.append(rows)\n    ans = 0\n    for j in range(n):\n        zero = 0\n        inf = 0\n        po = 0\n        mo = 0\n        ht1 = {}\n        ht2 = {}\n        for k in range(n):\n            if k == j:\n                continue\n            x = l[k][0] - l[j][0]\n            y = l[k][1] - l[j][1]\n            if x != 0 and y != 0:\n                m = y / x\n            else:\n                if x == 0:\n                    inf += 1\n                if y == 0:\n                    zero += 1\n                continue\n            if m == 1:\n                po += 1\n            if m == -1:\n                mo += 1\n            if abs(m) < 1:\n                if m in ht1:\n                    ht1[m] += 1\n                else:\n                    ht1[m] = 1\n            elif m != 1:\n                if m in ht2:\n                    ht2[1 / m] += 1\n                else:\n                    ht2[1 / m] = 1\n        ll = list(ht1.keys())\n        for k in range(len(ll)):\n            if -ll[k] in ht2:\n                ans += ht1[ll[k]] * ht2[-ll[k]]\n        ans += zero * inf + po * mo\n    print(ans)", "import math\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    l = []\n    for j in range(n):\n        rows = list(map(int, input().split(' ')))\n        l.append(rows)\n    ans = 0\n    for j in range(n):\n        zero = 0\n        inf = 0\n        po = 0\n        mo = 0\n        ht1 = {}\n        ht2 = {}\n        for k in range(n):\n            if k == j:\n                continue\n            x = l[k][0] - l[j][0]\n            y = l[k][1] - l[j][1]\n            if x != 0 and y != 0:\n                m = y / x\n            else:\n                if x == 0:\n                    inf += 1\n                if y == 0:\n                    zero += 1\n                continue\n            if m == 1:\n                po += 1\n            if m == -1:\n                mo += 1\n            if abs(m) < 1:\n                if m in ht1:\n                    ht1[m] += 1\n                else:\n                    ht1[m] = 1\n            elif m != 1:\n                if m in ht2:\n                    ht2[1 / m] += 1\n                else:\n                    ht2[1 / m] = 1\n        ll = list(ht1.keys())\n        for k in range(len(ll)):\n            if -ll[k] in ht2:\n                ans += ht1[ll[k]] * ht2[-ll[k]]\n        ans += zero * inf + po * mo\n    print(ans)", "import math\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    l = []\n    for j in range(n):\n        rows = list(map(int, input().split(' ')))\n        l.append(rows)\n    ans = 0\n    for j in range(n):\n        zero = 0\n        inf = 0\n        po = 0\n        mo = 0\n        ht1 = {}\n        ht2 = {}\n        for k in range(n):\n            if k == j:\n                continue\n            x = l[k][0] - l[j][0]\n            y = l[k][1] - l[j][1]\n            if x != 0 and y != 0:\n                m = y / x\n            else:\n                if x == 0:\n                    inf += 1\n                if y == 0:\n                    zero += 1\n                continue\n            if m == 1:\n                po += 1\n            if m == -1:\n                mo += 1\n            if abs(m) < 1:\n                if m in ht1:\n                    ht1[m] += 1\n                else:\n                    ht1[m] = 1\n            elif m != 1:\n                if m in ht2:\n                    ht2[1 / m] += 1\n                else:\n                    ht2[1 / m] = 1\n        ll = list(ht1.keys())\n        for k in range(len(ll)):\n            if -ll[k] in ht2:\n                ans += ht1[ll[k]] * ht2[-ll[k]]\n        ans += zero * inf + po * mo\n    print(ans)", "from collections import defaultdict as dd\nfrom math import gcd\n\ndef hasOppSign(a, b):\n    return a > 0 and b < 0 or (a < 0 and b > 0)\n\ndef getPairSlope(x1, y1):\n    if x1 < 0:\n        return (y1, abs(x1))\n    return (-y1, x1)\n\ndef countTangentSlopes(slopes):\n    done = dd(bool)\n    totalTangentPairs = 0\n    for (m1, f1) in slopes.items():\n        if m1 in done:\n            continue\n        m2 = getPairSlope(*m1)\n        if m2 in slopes:\n            totalTangentPairs += f1 * slopes[m2]\n            done[m1] = True\n            done[m2] = True\n    return totalTangentPairs\n\ndef getSlope(Points, i, j):\n    (x1, y1) = Points[i]\n    (x2, y2) = Points[j]\n    num = y2 - y1\n    den = x2 - x1\n    if den == 0:\n        return (1, 0)\n    mul = 1\n    if hasOppSign(num, den):\n        mul = -1\n    (num, den) = (abs(num), abs(den))\n    d = gcd(num, den)\n    (num, den) = (num // d, den // d)\n    return (mul * num, den)\n\ndef solve(Points, N):\n    holyTriplets = 0\n    for i in range(N - 2):\n        slopes = dd(int)\n        for ind in range(i + 1, N):\n            slopes[getSlope(Points, i, ind)] += 1\n        holyTriplets += countTangentSlopes(slopes)\n    for j in range(1, N - 1):\n        slopes = dd(int)\n        for i in range(j):\n            slopes[getSlope(Points, i, j)] += 1\n        for k in range(j + 1, N):\n            m2 = getSlope(Points, j, k)\n            m1 = getPairSlope(*m2)\n            holyTriplets += slopes[m1]\n    for k in range(2, N):\n        slopes = dd(int)\n        for ind in range(k):\n            slopes[getSlope(Points, k, ind)] += 1\n        holyTriplets += countTangentSlopes(slopes)\n    return holyTriplets\nfor case in range(int(input())):\n    N = int(input())\n    Points = []\n    for i in range(N):\n        Points.append(list(map(int, input().split())))\n    print(solve(Points, N))", "from collections import defaultdict as dd\nfrom math import gcd\n\ndef hasOppSign(a, b):\n    return a > 0 and b < 0 or (a < 0 and b > 0)\n\ndef getPairSlope(x1, y1):\n    if x1 < 0:\n        return (y1, abs(x1))\n    return (-y1, x1)\n\ndef countTangentSlopes(slopes):\n    done = dd(bool)\n    totalTangentPairs = 0\n    for (m1, f1) in slopes.items():\n        if m1 in done:\n            continue\n        m2 = getPairSlope(*m1)\n        if m2 in slopes:\n            totalTangentPairs += f1 * slopes[m2]\n            done[m1] = True\n            done[m2] = True\n    return totalTangentPairs\n\ndef getSlope(Points, i, j):\n    (x1, y1) = Points[i]\n    (x2, y2) = Points[j]\n    num = y2 - y1\n    den = x2 - x1\n    if den == 0:\n        return (1, 0)\n    mul = 1\n    if hasOppSign(num, den):\n        mul = -1\n    (num, den) = (abs(num), abs(den))\n    d = gcd(num, den)\n    (num, den) = (num // d, den // d)\n    return (mul * num, den)\n\ndef solve(Points, N):\n    holyTriplets = 0\n    for i in range(N - 2):\n        slopes = dd(int)\n        for ind in range(i + 1, N):\n            slopes[getSlope(Points, i, ind)] += 1\n        holyTriplets += countTangentSlopes(slopes)\n    for j in range(1, N - 1):\n        slopes = dd(int)\n        for i in range(j):\n            slopes[getSlope(Points, i, j)] += 1\n        for k in range(j + 1, N):\n            m2 = getSlope(Points, j, k)\n            m1 = getPairSlope(*m2)\n            holyTriplets += slopes[m1]\n    for k in range(2, N):\n        slopes = dd(int)\n        for ind in range(k):\n            slopes[getSlope(Points, k, ind)] += 1\n        holyTriplets += countTangentSlopes(slopes)\n    return holyTriplets\nfor case in range(int(input())):\n    N = int(input())\n    Points = []\n    for i in range(N):\n        Points.append(list(map(int, input().split())))\n    print(solve(Points, N))", "from collections import defaultdict\nfrom math import trunc\nfor _ in range(int(input())):\n    n = int(input())\n    arr = []\n    for _ in range(n):\n        (a, b) = map(int, input().split())\n        arr.append([a, b])\n\n    def slope(a, b):\n        if arr[a][0] == arr[b][0]:\n            return 'c' if arr[a][1] > arr[b][1] else 'd'\n        return (arr[b][1] - arr[a][1]) / (arr[b][0] - arr[a][0])\n    ans = 0\n    for i in range(n):\n        temp = defaultdict(int)\n        for j in range(n):\n            if i != j:\n                s = slope(i, j)\n                temp[s] += 1\n        for v in list(temp.keys()):\n            if v != 0 and v != 'c' and (v != 'd') and (-1 / v in temp):\n                ans += temp[-1 / v] * temp[v]\n            elif v == 'c':\n                ans += temp['c'] * temp[0]\n            elif v == 'd':\n                ans += temp['d'] * temp[0]\n            elif v == 0:\n                ans += temp['d'] * temp[0] + temp['c'] * temp[0]\n    print(ans // 2)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for _ in range(n):\n        p.append(tuple(map(int, input().split())))\n    ans = 0\n    for i in range(n):\n        d = {}\n        for j in range(n):\n            if j == i:\n                continue\n            if p[i][0] - p[j][0] != 0:\n                m = (p[i][1] - p[j][1]) / (p[i][0] - p[j][0])\n            else:\n                m = 10000000000.0\n            if m not in d:\n                d[m] = 0\n            d[m] += 1\n            if m == 0:\n                m = 10000000000.0\n            elif m == 10000000000.0:\n                m = 0\n            else:\n                m = -1 / m\n            if m in d:\n                ans += d[m]\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for _ in range(n):\n        p.append(tuple(map(int, input().split())))\n    ans = 0\n    for i in range(n):\n        d = {}\n        for j in range(n):\n            if j == i:\n                continue\n            if p[i][0] - p[j][0] != 0:\n                m = (p[i][1] - p[j][1]) / (p[i][0] - p[j][0])\n            else:\n                m = 10000000000.0\n            if m not in d:\n                d[m] = 0\n            d[m] += 1\n            if m == 0:\n                m = 10000000000.0\n            elif m == 10000000000.0:\n                m = 0\n            else:\n                m = -1 / m\n            if m in d:\n                ans += d[m]\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for _ in range(n):\n        p.append(tuple(map(int, input().split())))\n    ans = 0\n    for i in range(n):\n        d = {}\n        for j in range(n):\n            if j == i:\n                continue\n            if p[i][0] - p[j][0] != 0:\n                m = (p[i][1] - p[j][1]) / (p[i][0] - p[j][0])\n            else:\n                m = 10000000000.0\n            if m not in d:\n                d[m] = 0\n            d[m] += 1\n            if m == 0:\n                m = 10000000000.0\n            elif m == 10000000000.0:\n                m = 0\n            else:\n                m = -1 / m\n            if m in d:\n                ans += d[m]\n    print(ans)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    l = list()\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        l.append([x, y])\n    ans = 0\n    for i in range(n):\n        d = dict()\n        for j in range(n):\n            if i != j:\n                temp1 = l[i][0] - l[j][0]\n                temp2 = l[i][1] - l[j][1]\n                a1 = 0\n                a2 = 0\n                if temp1 == 0:\n                    a1 = 90\n                    if temp2 < 0:\n                        a1 = -90\n                    a2 = 0\n                elif temp2 == 0:\n                    a1 = 0\n                    a2 = -90\n                    if temp1 < 0:\n                        a2 = 90\n                else:\n                    a1 = math.atan(temp2 / temp1) * (180 / 3.14159265)\n                    a2 = math.atan(-temp1 / temp2) * (180 / 3.14159265)\n                if a1 not in d.keys():\n                    d[a1] = 1\n                else:\n                    d[a1] += 1\n                if a2 in d.keys():\n                    ans += d[a2]\n    print(ans)", "t = int(input())\n\ndef slope(y1, y2, x1, x2):\n    if x2 - x1 == 0:\n        return 'inf'\n    return (y2 - y1) / (x2 - x1)\nfor _ in range(t):\n    res = 0\n    n = int(input())\n    (x, y) = ([], [])\n    for _ in range(n):\n        (a, b) = map(int, input().split())\n        x.append(a)\n        y.append(b)\n    for i in range(n):\n        m = {}\n        for j in range(n):\n            if i == j:\n                continue\n            if slope(y[i], y[j], x[i], x[j]) in m:\n                m[slope(y[i], y[j], x[i], x[j])] += 1\n                continue\n            m[slope(y[i], y[j], x[i], x[j])] = 1\n        for k in m:\n            if k == 'inf':\n                if 0.0 in m:\n                    res += m[0.0] * m[k]\n                continue\n            if k == 0.0:\n                if 'inf' in m:\n                    res += m['inf'] * m[k]\n                continue\n            if 1 / k * -1 in m:\n                res += m[1 / k * -1] * m[k]\n    print(res // 2)", "def slope(x1, y1, x2, y2):\n    if x2 - x1 == 0:\n        return 'inf'\n    return float(y2 - y1) / (x2 - x1)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    x = []\n    y = []\n    c = 0\n    for k in range(n):\n        s = [int(j) for j in input().split()]\n        x.append(s[0])\n        y.append(s[1])\n    for j in range(0, n):\n        m = {}\n        for k in range(0, n):\n            if k == j:\n                continue\n            if slope(x[j], y[j], x[k], y[k]) in m:\n                m[slope(x[j], y[j], x[k], y[k])] += 1\n                continue\n            m[slope(x[j], y[j], x[k], y[k])] = 1\n        for k in m:\n            if k == 'inf':\n                if 0 in m:\n                    c += m[0] * m[k]\n                continue\n            if k == 0:\n                if 'inf' in m:\n                    c += m['inf'] * m[k]\n                continue\n            if 1 / k * -1 in m:\n                c += m[1 / k * -1] * m[k]\n    print(c // 2)", "import sys\nimport math\nfrom collections import defaultdict, Counter, deque\nfrom bisect import *\nfrom string import ascii_lowercase\nfrom heapq import *\n\ndef readInts():\n    x = list(map(int, sys.stdin.readline().rstrip().split()))\n    return x[0] if len(x) == 1 else x\n\ndef readList(type=int):\n    x = sys.stdin.readline()\n    x = list(map(type, x.rstrip('\\n\\r').split()))\n    return x\n\ndef readStr():\n    x = sys.stdin.readline().rstrip('\\r\\n')\n    return x\nwrite = sys.stdout.write\nread = sys.stdin.readline\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef mergeSort(arr, check=lambda a, b: a < b, reverse=False):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        mergeSort(L, check, reverse)\n        mergeSort(R, check, reverse)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if check(L[i], R[j]):\n                if not reverse:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n            elif not reverse:\n                arr[k] = R[j]\n                j += 1\n            else:\n                arr[k] = L[i]\n                i += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\ndef maxSum(arr):\n    max_sum = float('-inf')\n    max_cur = 0\n    for num in ar:\n        max_cur = max(max_cur + num, num)\n        if max_cur > max_sum:\n            max_sum = max_cur\n    return max_sum\n\ndef hcf(a, b):\n    if b == 0:\n        return a\n    else:\n        return hcf(b, b % a)\n\ndef get_power(n, m):\n    i = 1\n    p = -1\n    while i <= n:\n        i = i * m\n        p += 1\n    return p\n\ndef fact(n):\n    f = 1\n    for i in range(2, n + 1):\n        f *= i\n    return f\n\ndef find_closest(num, ar):\n    min_d = float('inf')\n    for num2 in ar:\n        d = abs(num2 - num)\n        if d < min_d:\n            min_d = d\n    return min_d\n\ndef solve(t):\n    n = readInts()\n    ar = []\n    for _ in range(n):\n        ar.append(list(readInts()))\n    res = 0\n    for i in range(n):\n        x1 = ar[i][0]\n        y1 = ar[i][1]\n        m = {}\n        for j in range(n):\n            if i != j:\n                x2 = ar[j][0]\n                y2 = ar[j][1]\n                tmp = 0\n                if x1 != x2:\n                    tmp = (y2 - y1) / (x2 - x1)\n                    if tmp == -0:\n                        tmp = 0\n                else:\n                    tmp = float('inf')\n                req = 0\n                if tmp == float('inf'):\n                    req = 0\n                elif tmp == 0:\n                    req = float('inf')\n                else:\n                    req = -(x2 - x1) / (y2 - y1)\n                if req in m:\n                    res += m[req]\n                if tmp in m:\n                    m[tmp] += 1\n                else:\n                    m[tmp] = 1\n        m.clear()\n    print(res)\n\ndef main():\n    t = 1\n    sys.setrecursionlimit(12000)\n    t = readInts()\n    for i in range(t):\n        solve(i + 1)\nmain()", "import sys\nimport math\nfrom collections import defaultdict, Counter, deque\nfrom bisect import *\nfrom string import ascii_lowercase\nfrom heapq import *\n\ndef readInts():\n    x = list(map(int, sys.stdin.readline().rstrip().split()))\n    return x[0] if len(x) == 1 else x\n\ndef readList(type=int):\n    x = sys.stdin.readline()\n    x = list(map(type, x.rstrip('\\n\\r').split()))\n    return x\n\ndef readStr():\n    x = sys.stdin.readline().rstrip('\\r\\n')\n    return x\nwrite = sys.stdout.write\nread = sys.stdin.readline\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef mergeSort(arr, check=lambda a, b: a < b, reverse=False):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        mergeSort(L, check, reverse)\n        mergeSort(R, check, reverse)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if check(L[i], R[j]):\n                if not reverse:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n            elif not reverse:\n                arr[k] = R[j]\n                j += 1\n            else:\n                arr[k] = L[i]\n                i += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\ndef maxSum(arr):\n    max_sum = float('-inf')\n    max_cur = 0\n    for num in ar:\n        max_cur = max(max_cur + num, num)\n        if max_cur > max_sum:\n            max_sum = max_cur\n    return max_sum\n\ndef hcf(a, b):\n    if b == 0:\n        return a\n    else:\n        return hcf(b, b % a)\n\ndef get_power(n, m):\n    i = 1\n    p = -1\n    while i <= n:\n        i = i * m\n        p += 1\n    return p\n\ndef fact(n):\n    f = 1\n    for i in range(2, n + 1):\n        f *= i\n    return f\n\ndef find_closest(num, ar):\n    min_d = float('inf')\n    for num2 in ar:\n        d = abs(num2 - num)\n        if d < min_d:\n            min_d = d\n    return min_d\n\ndef solve(t):\n    n = readInts()\n    ar = []\n    for _ in range(n):\n        ar.append(list(readInts()))\n    res = 0\n    for i in range(n):\n        x1 = ar[i][0]\n        y1 = ar[i][1]\n        m = {}\n        for j in range(n):\n            if i != j:\n                x2 = ar[j][0]\n                y2 = ar[j][1]\n                tmp = 0\n                if x1 != x2:\n                    tmp = (y2 - y1) / (x2 - x1)\n                    if tmp == -0:\n                        tmp = 0\n                else:\n                    tmp = float('inf')\n                req = 0\n                if tmp == float('inf'):\n                    req = 0\n                elif tmp == 0:\n                    req = float('inf')\n                else:\n                    req = -(x2 - x1) / (y2 - y1)\n                if req in m:\n                    res += m[req]\n                if tmp in m:\n                    m[tmp] += 1\n                else:\n                    m[tmp] = 1\n        m.clear()\n    print(res)\n\ndef main():\n    t = 1\n    sys.setrecursionlimit(12000)\n    t = readInts()\n    for i in range(t):\n        solve(i + 1)\nmain()", "def slope(a1, a2, b1, b2):\n    if a1 - b1 == 0:\n        return 'inf'\n    return float(a2 - b2) / (a1 - b1)\nfor n in range(int(input())):\n    k = int(input())\n    li = []\n    for i in range(k):\n        li.append(list(map(int, input().split())))\n    ans = 0\n    sl = []\n    for i in range(k):\n        dici = {}\n        for j in range(k):\n            if i == j:\n                continue\n            if slope(li[i][0], li[i][1], li[j][0], li[j][1]) in dici:\n                dici[slope(li[i][0], li[i][1], li[j][0], li[j][1])] += 1\n            else:\n                dici[slope(li[i][0], li[i][1], li[j][0], li[j][1])] = 1\n        for i in dici.keys():\n            if i == 'inf':\n                if 0 in dici:\n                    ans += dici[i] * dici[0]\n            elif i == 0:\n                if 'inf' in dici:\n                    ans += dici[i] * dici['inf']\n            elif -1 / i in dici:\n                ans += dici[-1 / i] * dici[i]\n    print(ans // 2)", "def slope(x1, y1, x2, y2):\n    if x2 - x1 == 0:\n        return 'inf'\n    return float(y2 - y1) / (x2 - x1)\nfor i in range(int(input())):\n    n = int(input())\n    x = []\n    y = []\n    c = 0\n    for k in range(n):\n        s = [int(j) for j in input().split()]\n        x.append(s[0])\n        y.append(s[1])\n    for j in range(0, n):\n        m = {}\n        for k in range(0, n):\n            if k == j:\n                continue\n            if slope(x[j], y[j], x[k], y[k]) in m:\n                m[slope(x[j], y[j], x[k], y[k])] += 1\n                continue\n            m[slope(x[j], y[j], x[k], y[k])] = 1\n        for k in m:\n            if k == 'inf':\n                if 0 in m:\n                    c += m[0] * m[k]\n                continue\n            if k == 0:\n                if 'inf' in m:\n                    c += m['inf'] * m[k]\n                continue\n            if 1 / k * -1 in m:\n                c += m[1 / k * -1] * m[k]\n    print(c // 2)", "def slope(x1, y1, x2, y2):\n    if x2 - x1 == 0:\n        return 'inf'\n    return float(y2 - y1) / (x2 - x1)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    x = []\n    y = []\n    c = 0\n    for k in range(n):\n        (x1, y1) = map(int, input().split())\n        x.append(x1)\n        y.append(y1)\n    for j in range(0, n):\n        m = {}\n        for k in range(0, n):\n            if k == j:\n                continue\n            if slope(x[j], y[j], x[k], y[k]) in m:\n                m[slope(x[j], y[j], x[k], y[k])] += 1\n                continue\n            m[slope(x[j], y[j], x[k], y[k])] = 1\n        for k in m:\n            if k == 'inf':\n                if 0 in m:\n                    c += m[0] * m[k]\n                continue\n            if k == 0:\n                if 'inf' in m:\n                    c += m['inf'] * m[k]\n                continue\n            if 1 / k * -1 in m:\n                c += m[1 / k * -1] * m[k]\n    print(c // 2)", "def slope(x1, y1, x2, y2):\n    if x2 - x1 == 0:\n        return 'inf'\n    return float(y2 - y1) / (x2 - x1)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    x = []\n    y = []\n    c = 0\n    for k in range(n):\n        s = [int(j) for j in input().split()]\n        x.append(s[0])\n        y.append(s[1])\n    for j in range(0, n):\n        m = {}\n        for k in range(0, n):\n            if k == j:\n                continue\n            if slope(x[j], y[j], x[k], y[k]) in m:\n                m[slope(x[j], y[j], x[k], y[k])] += 1\n                continue\n            m[slope(x[j], y[j], x[k], y[k])] = 1\n        for k in m:\n            if k == 'inf':\n                if 0 in m:\n                    c += m[0] * m[k]\n                continue\n            if k == 0:\n                if 'inf' in m:\n                    c += m['inf'] * m[k]\n                continue\n            if 1 / k * -1 in m:\n                c += m[1 / k * -1] * m[k]\n    print(c // 2)", "from sys import stdin\ninput = stdin.readline\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef answer():\n    ans = 0\n    for i in range(n):\n        d = dict()\n        for j in range(n):\n            if i == j:\n                continue\n            (x1, x2) = (coor[i][0], coor[j][0])\n            (y1, y2) = (coor[i][1], coor[j][1])\n            g = gcd(x1 - x2, y1 - y2)\n            (num, den) = ((x1 - x2) // g, (y1 - y2) // g)\n            ans += d.get((-num, den), 0)\n            ans += d.get((num, -den), 0)\n            d[den, num] = d.get((den, num), 0) + 1\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    coor = []\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        coor.append([x, y])\n    print(answer())", "def slope(x1, y1, x2, y2):\n    if x2 - x1 == 0:\n        return 'inf'\n    return float(y2 - y1) / (x2 - x1)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    x = []\n    y = []\n    c = 0\n    for k in range(n):\n        s = [int(j) for j in input().split()]\n        x.append(s[0])\n        y.append(s[1])\n    for j in range(0, n):\n        m = {}\n        for k in range(0, n):\n            if k == j:\n                continue\n            if slope(x[j], y[j], x[k], y[k]) in m:\n                m[slope(x[j], y[j], x[k], y[k])] += 1\n                continue\n            m[slope(x[j], y[j], x[k], y[k])] = 1\n        for k in m:\n            if k == 'inf':\n                if 0 in m:\n                    c += m[0] * m[k]\n                continue\n            if k == 0:\n                if 'inf' in m:\n                    c += m['inf'] * m[k]\n                continue\n            if 1 / k * -1 in m:\n                c += m[1 / k * -1] * m[k]\n    print(c // 2)", "for _ in range(int(input())):\n    n = int(input())\n    points = []\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        points.append([x, y])\n    dit = {}\n    ans = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if points[i] != points[j]:\n                (x1, y1) = points[i]\n                (x2, y2) = points[j]\n                if x1 == x2:\n                    if (0, i) in dit:\n                        ans += dit[0, i]\n                    if (0, j) in dit:\n                        ans += dit[0, j]\n                    if ('inf', i) in dit:\n                        dit['inf', i] += 1\n                    else:\n                        dit['inf', i] = 1\n                    if ('inf', j) in dit:\n                        dit['inf', j] += 1\n                    else:\n                        dit['inf', j] = 1\n                else:\n                    m = (y2 - y1) / (x2 - x1)\n                    if m == 0:\n                        if ('inf', i) in dit:\n                            ans += dit['inf', i]\n                        if ('inf', j) in dit:\n                            ans += dit['inf', j]\n                    else:\n                        if (-1 / m, i) in dit:\n                            ans += dit[-1 / m, i]\n                        if (-1 / m, j) in dit:\n                            ans += dit[-1 / m, j]\n                    if (m, i) in dit:\n                        dit[m, i] += 1\n                    else:\n                        dit[m, i] = 1\n                    if (m, j) in dit:\n                        dit[m, j] += 1\n                    else:\n                        dit[m, j] = 1\n    print(ans)", "from math import inf\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [0] * n\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        a[i] = (x, y)\n    memo1 = [0] * n\n    for (i, (x1, y1)) in enumerate(a):\n        memo1[i] = {}\n        for (x2, y2) in a:\n            if x1 == x2 and y1 == y2:\n                continue\n            if not x2 - x1:\n                slope = inf\n            else:\n                slope = (y2 - y1) / (x2 - x1)\n            memo1[i][slope] = memo1[i].get(slope, 0) + 1\n    memo2 = [0] * n\n    for (i, (x1, y1)) in enumerate(a):\n        memo2[i] = {}\n        for (x2, y2) in a:\n            if x1 == x2 and y1 == y2:\n                continue\n            if not y2 - y1:\n                slope = inf\n            else:\n                slope = (x1 - x2) / (y2 - y1)\n            memo2[i][slope] = memo2[i].get(slope, 0) + 1\n    sumi = 0\n    for (dt1, dt2) in zip(memo1, memo2):\n        for slope in dt1:\n            sumi += dt1[slope] * dt2.get(slope, 0)\n    print(sumi // 2)", "from math import inf\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [0] * n\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        a[i] = (x, y)\n    memo1 = [0] * n\n    for (i, (x1, y1)) in enumerate(a):\n        memo1[i] = {}\n        for (x2, y2) in a:\n            if x1 == x2 and y1 == y2:\n                continue\n            if not x2 - x1:\n                slope = inf\n            else:\n                slope = (y2 - y1) / (x2 - x1)\n            memo1[i][slope] = memo1[i].get(slope, 0) + 1\n    memo2 = [0] * n\n    for (i, (x1, y1)) in enumerate(a):\n        memo2[i] = {}\n        for (x2, y2) in a:\n            if x1 == x2 and y1 == y2:\n                continue\n            if not y2 - y1:\n                slope = inf\n            else:\n                slope = (x1 - x2) / (y2 - y1)\n            memo2[i][slope] = memo2[i].get(slope, 0) + 1\n    sumi = 0\n    for (dt1, dt2) in zip(memo1, memo2):\n        for slope in dt1:\n            sumi += dt1[slope] * dt2.get(slope, 0)\n    print(sumi // 2)", "from math import gcd\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    xs = []\n    ys = []\n    for _ in range(n):\n        (x, y) = map(int, input().split())\n        xs.append(x)\n        ys.append(y)\n    tot = 0\n    for i in range(n):\n        d = dict()\n        posr = set()\n        zs = 0\n        infs = 0\n        for j in range(n):\n            if i == j:\n                continue\n            dx = xs[j] - xs[i]\n            dy = ys[j] - ys[i]\n            if dx == 0:\n                infs += 1\n            elif dy == 0:\n                zs += 1\n            else:\n                g = gcd(dx, dy)\n                dx //= g\n                dy //= g\n                if dy < 0:\n                    dx = -dx\n                    dy = -dy\n                k = (dx, dy)\n                if dx > 0:\n                    posr.add(k)\n                if k not in d.keys():\n                    d[k] = 0\n                d[k] += 1\n        tot += zs * infs\n        for k in posr:\n            np = (-k[1], k[0])\n            if np in d.keys():\n                tot += d[k] * d[np]\n    print(tot)", "from collections import defaultdict\nfrom math import gcd\nfrom sys import stdin\ninput = stdin.readline\nfor test in range(int(input())):\n    n = int(input())\n    points = []\n    for i in range(n):\n        points.append(list(map(int, input().split())))\n    slopes = [defaultdict(int) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            p1 = points[i]\n            p2 = points[j]\n            dx = p1[0] - p2[0]\n            dy = p1[1] - p2[1]\n            sign = 1\n            if dx * dy < 0:\n                sign = -1\n            dx = abs(dx)\n            dy = abs(dy)\n            g = gcd(dx, dy)\n            dx //= g\n            dy //= g\n            slope = (sign * dy, dx)\n            if slope[1] == 0:\n                slope = (1, 0)\n            elif slope[0] == 0:\n                slope = (0, 1)\n            slopes[i][slope] += 1\n            slopes[j][slope] += 1\n    ans = 0\n    for i in range(n):\n        for item in slopes[i]:\n            slope = item\n            wanted = (-slope[1], slope[0])\n            sign = 1\n            if wanted[0] * wanted[1] < 0:\n                sign = -1\n            wanted = (sign * abs(wanted[0]), abs(wanted[1]))\n            if slope[0] == 0:\n                wanted = (1, 0)\n            elif slope[1] == 0:\n                wanted = (0, 1)\n            if wanted in slopes[i]:\n                ans += slopes[i][slope] * slopes[i][wanted]\n    print(ans // 2)", "import math\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = []\n    for i in range(0, n):\n        (x, y) = input().split()\n        x = int(x)\n        y = int(y)\n        a.append([x, y])\n    dist = []\n    c = 0\n    for i in range(0, n):\n        (x, y) = (a[i][0], a[i][1])\n        has = {}\n        for j in range(0, n):\n            (x1, y1) = (a[j][0], a[j][1])\n            if x1 == x and y1 == y:\n                continue\n            p = x1 - x\n            q = y1 - y\n            r = math.gcd(abs(p), abs(q))\n            p /= r\n            q /= r\n            if (q, -p) in has.keys():\n                c += has[q, -p]\n            if (-q, p) in has.keys():\n                c += has[-q, p]\n            if (p, q) in has.keys():\n                has[p, q] += 1\n            else:\n                has[p, q] = 1\n    print(c)", "from math import atan2, degrees\nfrom bisect import bisect_left, bisect_right\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        (x, y) = list(map(int, input().split()))\n        P.append((x, y))\n    answer = 0\n    for k in range(N):\n        deg = []\n        for i in range(N):\n            if i != k:\n                y = P[i][1] - P[k][1]\n                x = P[i][0] - P[k][0]\n                deg.append(degrees(atan2(y, x)))\n        deg.sort()\n        min_deg = deg[0]\n        new_deg = []\n        for d in deg:\n            new_deg.append(d - min_deg)\n        deg = new_deg\n        for angle in deg:\n            val_1 = angle + 90.0\n            j = bisect_left(deg, val_1)\n            k = bisect_right(deg, val_1)\n            answer += k - j\n            val_2 = angle + 270.0\n            j = bisect_left(deg, val_2)\n            k = bisect_right(deg, val_2)\n            answer += k - j\n    print(answer)", "def getSlope(x1, y1, x2, y2):\n    if x1 == x2:\n        return 'INF'\n    return (y2 - y1) / (x2 - x1)\n\ndef invSlope(slope):\n    if not slope:\n        return 'INF'\n    if slope == 'INF':\n        return 0\n    return -1 / slope\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    P = []\n    ans = 0\n    for i in range(N):\n        P.append(list(map(int, input().split())))\n    A = [{} for _ in range(N)]\n    for i in range(N):\n        for j in range(i + 1, N):\n            slopeVal = getSlope(P[i][0], P[i][1], P[j][0], P[j][1])\n            count = A[i].get(invSlope(slopeVal), 0) + A[j].get(invSlope(slopeVal), 0)\n            if count:\n                ans += count\n            A[i][slopeVal] = A[i].get(slopeVal, 0) + 1\n            A[j][slopeVal] = A[j].get(slopeVal, 0) + 1\n    print(ans)", "from collections import defaultdict\nfrom math import gcd\nfor tcase in range(int(input())):\n    n = int(input())\n    (x, y) = ([0] * n, [0] * n)\n    for i in range(n):\n        (x[i], y[i]) = map(int, input().split())\n    ans = 0\n    for i in range(n):\n        points = defaultdict(int)\n        for j in range(n):\n            if j != i:\n                dx = x[j] - x[i]\n                dy = y[j] - y[i]\n                g = gcd(dx, dy)\n                dx //= g\n                dy //= g\n                points[dx, dy] += 1\n        for (dx, dy) in points.keys():\n            if (-dy, dx) in points:\n                ans += points[dx, dy] * points[-dy, dx]\n    print(ans)", "from collections import defaultdict\nfrom math import gcd\nfor tcase in range(int(input())):\n    n = int(input())\n    (x, y) = ([0] * n, [0] * n)\n    for i in range(n):\n        (x[i], y[i]) = map(int, input().split())\n    ans = 0\n    points = defaultdict(int)\n    for i in range(n):\n        points.clear()\n        for j in range(n):\n            if j != i:\n                dx = x[j] - x[i]\n                dy = y[j] - y[i]\n                g = gcd(dx, dy)\n                dx //= g\n                dy //= g\n                points[dx, dy] += 1\n        for (dx, dy) in points.keys():\n            if (-dy, dx) in points:\n                ans += points[dx, dy] * points[-dy, dx]\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for _ in range(n):\n        p.append(tuple(map(int, input().split())))\n    ans = 0\n    for i in range(n):\n        d = {}\n        for j in range(n):\n            if j == i:\n                continue\n            if p[i][0] - p[j][0] != 0:\n                m = (p[i][1] - p[j][1]) / (p[i][0] - p[j][0])\n            else:\n                m = 10000000000.0\n            if m not in d:\n                d[m] = 0\n            d[m] += 1\n            if m == 0:\n                m = 10000000000.0\n            elif m == 10000000000.0:\n                m = 0\n            else:\n                m = -1 / m\n            if m in d:\n                ans += d[m]\n    print(ans)", "T = int(input())\nfor t in range(T):\n    N = int(input())\n    X = [-1] * N\n    Y = [-1] * N\n    for i in range(N):\n        (X[i], Y[i]) = map(int, input().split(' '))\n    lines = dict()\n    for i in range(N):\n        for j in range(i + 1, N):\n            if X[i] != X[j]:\n                tg = (Y[i] - Y[j]) / (X[i] - X[j])\n            else:\n                tg = 'inf'\n            if tg not in lines.keys():\n                lines[tg] = dict()\n            if (X[i], Y[i]) not in lines[tg].keys():\n                lines[tg][X[i], Y[i]] = 1\n            else:\n                lines[tg][X[i], Y[i]] += 1\n            if (X[j], Y[j]) not in lines[tg].keys():\n                lines[tg][X[j], Y[j]] = 1\n            else:\n                lines[tg][X[j], Y[j]] += 1\n    triplets = 0\n    for key in lines.keys():\n        if key == 'inf' and 0.0 in lines.keys():\n            for dots in lines['inf']:\n                if dots in lines[0.0]:\n                    triplets += 2 * lines['inf'][dots] * lines[0.0][dots]\n        elif key != 'inf' and key != 0 and (-1 / key in lines.keys()):\n            for dots in lines[key]:\n                if dots in lines[-1 / key]:\n                    triplets += lines[key][dots] * lines[-1 / key][dots]\n    print(triplets // 2)", "from math import gcd\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    pts = []\n    for _ in range(n):\n        (x, y) = map(int, input().split())\n        pts.append((x, y))\n    ans = 0\n    for i in range(n):\n        lk = {}\n        count_y = 0\n        count_x = 0\n        for j in range(n):\n            if i == j:\n                continue\n            cx = pts[j][0] - pts[i][0]\n            cy = pts[j][1] - pts[i][1]\n            d = gcd(cx, cy)\n            cx = cx // d\n            cy = cy // d\n            if cx * cy > 0:\n                cx = abs(cx)\n                cy = abs(cy)\n            elif cy < 0:\n                cx = -cx\n                cy = -cy\n            if cx * cy == 0:\n                if cx == 0:\n                    ans += count_y\n                    count_x += 1\n                else:\n                    ans += count_x\n                    count_y += 1\n                if (x, y) in lk:\n                    lk[x, y] += 1\n                else:\n                    lk[x, y] = 1\n            else:\n                nx = -cy\n                ny = cx\n                if nx * ny > 0:\n                    nx = abs(nx)\n                    ny = abs(ny)\n                elif ny < 0:\n                    nx = -nx\n                    ny = -ny\n                if (nx, ny) in lk:\n                    ans += lk[nx, ny]\n                if (cx, cy) in lk:\n                    lk[cx, cy] += 1\n                else:\n                    lk[cx, cy] = 1\n    print(ans)"]