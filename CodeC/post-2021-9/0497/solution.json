["def mod_pow(a, b, m):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a % m\n    tmp = mod_pow(a, b // 2, m)\n    tmp = tmp * tmp % m\n    if b % 2 == 1:\n        tmp = tmp * a % m\n    return tmp\n\ndef ncr(n, a, m, fact):\n    first = mod_pow(fact[a], m - 2, m)\n    second = mod_pow(fact[n - a], m - 2, m)\n    res = fact[n] * first * second % m\n    return res\nmod = 10 ** 9 + 7\nfact = [1]\nfor i in range(1, 10 ** 6 + 1):\n    fact.append(fact[-1] * i % mod)\nt = int(input())\nfor _ in range(t):\n    (n, l, r) = map(int, input().split())\n    ans = []\n    for x in range(l, r + 1):\n        if (x + n) % 2 != 0 or (n - x) % 2 != 0:\n            ans.append(0)\n        else:\n            a = (n + x) // 2\n            b = (n - x) // 2\n            ans.append(ncr(n, a, mod, fact))\n    print(*ans)", "def mod_pow(a, b, m):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a % m\n    tmp = mod_pow(a, b // 2, m)\n    tmp = tmp * tmp % m\n    if b % 2 == 1:\n        tmp = tmp * a % m\n    return tmp\n\ndef ncr(n, a, m, fact):\n    first = mod_pow(fact[a], m - 2, m)\n    second = mod_pow(fact[n - a], m - 2, m)\n    res = fact[n] * first * second % m\n    return res\nmod = 10 ** 9 + 7\nfact = [1]\nfor i in range(1, 10 ** 6 + 1):\n    fact.append(fact[-1] * i % mod)\nt = int(input())\nfor _ in range(t):\n    (n, l, r) = map(int, input().split())\n    ans = []\n    for x in range(l, r + 1):\n        if (x + n) % 2 != 0 or (n - x) % 2 != 0:\n            ans.append(0)\n        else:\n            a = (n + x) // 2\n            b = (n - x) // 2\n            ans.append(ncr(n, a, mod, fact))\n    print(*ans)", "def mod_pow(a, b, m):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a % m\n    tmp = mod_pow(a, b // 2, m)\n    tmp = tmp * tmp % m\n    if b % 2 == 1:\n        tmp = tmp * a % m\n    return tmp\n\ndef ncr(n, a, m, fact):\n    first = mod_pow(fact[a], m - 2, m)\n    second = mod_pow(fact[n - a], m - 2, m)\n    res = fact[n] * first * second % m\n    return res\nmod = 10 ** 9 + 7\nfact = [1]\nfor i in range(1, 10 ** 6 + 1):\n    fact.append(fact[-1] * i % mod)\nt = int(input())\nfor _ in range(t):\n    (n, l, r) = map(int, input().split())\n    ans = []\n    for x in range(l, r + 1):\n        if (x + n) % 2 != 0 or (n - x) % 2 != 0:\n            ans.append(0)\n        else:\n            a = (n + x) // 2\n            b = (n - x) // 2\n            ans.append(ncr(n, a, mod, fact))\n    print(*ans)", "import sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nmod = 10 ** 9 + 7\nmax_n = 10 ** 6\nfact = [1, 1]\nfor i in range(2, 1 + max_n):\n    fact.append(fact[-1] * i % mod)\n\ndef inv_mod(n):\n    return pow(n, mod - 2, mod)\n\ndef ncr(a, b):\n    return fact[a] * inv_mod(fact[b]) * inv_mod(fact[a - b]) % mod\nfor _ in range(int(input())):\n    (n, l, r) = list(map(int, input().split()))\n    for i in range(l, r + 1):\n        if n % 2 == i % 2 and -n <= i <= n:\n            print(ncr(n, (n - abs(i)) // 2), end=' ')\n        else:\n            print(0, end=' ')\n    print()", "def fermat_compute(n, p):\n    facts = [0] * n\n    invfacts = [0] * n\n    facts[0] = 1\n    invfacts[0] = 1\n    for i in range(1, n):\n        facts[i] = facts[i - 1] * i % p\n        invfacts[i] = pow(facts[i], p - 2, p)\n    return (facts, invfacts)\n\ndef binomial_pre_computed(facts, invfacts, n, k, p):\n    return facts[n] * (invfacts[k] * invfacts[n - k] % p) % p\nfor _ in range(int(input())):\n    ans = ''\n    (n, l, r) = map(int, input().split())\n    (facts, invfacts) = fermat_compute(n + 1, 10 ** 9 + 7)\n    for x in range(l, r + 1):\n        idx = abs(x)\n        ans += '0' if (n ^ idx) & 1 else str(binomial_pre_computed(facts, invfacts, n, (n - idx) // 2, 10 ** 9 + 7))\n        ans += ' '\n    print(ans)", "import sys\nmsg = sys.stdin.readlines()\nmod = 10 ** 9 + 7\nfor inp in msg[1:]:\n    row = [1]\n    last = 1\n    (a, b, c) = list(map(int, inp.split()))\n    for i in range(1, a + 1):\n        now = last * (a + 1 - i) % mod\n        inv_k = pow(i, mod - 2, mod)\n        now = now * inv_k % mod\n        row.append(0)\n        row.append(now)\n        last = now\n    b = a + b\n    c = a + 1 + c\n    for i in row[b:c]:\n        print(i, end=' ')\n    print()", "import math\nN = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nt = int(input())\nwhile t:\n    (n, lb, rb) = map(int, input().split())\n    ans = ''\n    if n % 2 == 0:\n        r = n // 2 + lb // 2\n        while lb <= rb:\n            if lb % 2:\n                ans += '0 '\n            else:\n                val = Binomial(n, r, p)\n                ans += str(val) + ' '\n            lb += 1\n            r = n // 2 + lb // 2\n    else:\n        r = n // 2 + lb // 2 + 1\n        while lb <= rb:\n            if lb % 2:\n                val = Binomial(n, r, p)\n                ans += str(val) + ' '\n            else:\n                ans += '0 '\n            lb += 1\n            r = n // 2 + lb // 2 + 1\n    print(ans)\n    t -= 1", "x = int(1000000000.0 + 7)\nfactorial = [1]\nfor i in range(1, 1000001):\n    factorial.append(factorial[-1] * i % x)\nT = int(input())\nfor _ in range(T):\n    (N, L, R) = map(int, input().split())\n    while L <= R:\n        if (L + N) % 2 == 0:\n            c = (L + N) // 2\n            val = factorial[N] * pow(factorial[c], x - 2, x) * pow(factorial[N - c], x - 2, x)\n            print(val % x, end=' ')\n        else:\n            print(0, end=' ')\n        L += 1\n    print()", "x = int(1000000000.0 + 7)\nfactorial = [1]\nfor i in range(1, 1000001):\n    factorial.append(factorial[-1] * i % x)\nfor _ in range(int(input())):\n    (n, l, r) = map(int, input().split())\n    while l <= r:\n        if (l + n) % 2 == 0:\n            c = (l + n) // 2\n            val = factorial[n] * pow(factorial[c], x - 2, x) * pow(factorial[n - c], x - 2, x)\n            print(val % x, end=' ')\n        else:\n            print(0, end=' ')\n        l += 1\n    print()", "p = 1000000007\nfactorials = [1]\nfor i in range(1, 1000001):\n    factorials.append(factorials[-1] * i % p)\nfor T in range(int(input())):\n    (N, L, R) = map(int, input().split())\n    for coordinate in range(L, R + 1):\n        index_float = (N + coordinate) / 2\n        index = int(index_float)\n        if index != index_float:\n            print(0, end=' ')\n        else:\n            print(factorials[N] * pow(factorials[index], p - 2, p) * pow(factorials[N - index], p - 2, p) % p, end=' ')\n    print()", "N = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nt = int(input())\nwhile t > 0:\n    (n, l, r) = map(int, input().split())\n    a = []\n    for i in range(n + 1):\n        x = Binomial(n, i, p)\n        a.append(x)\n        a.append(0)\n    subarray = a[n + l:n + r + 1]\n    for i in range(r - l + 1):\n        print(subarray[i], end=' ')\n    print(end='\\n')\n    t = t - 1", "N = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nt = int(input())\nwhile t > 0:\n    (n, l, r) = map(int, input().split())\n    arr = []\n    for i in range(n + 1):\n        x = Binomial(n, i, p)\n        arr.append(x)\n        arr.append(0)\n    j = arr[n + l:n + r + 1]\n    for i in range(r - l + 1):\n        print(j[i], end=' ')\n    print(end='\\n')\n    t = t - 1", "import functools\nfrom math import factorial\n\ndef mod_exp(b, e, mod):\n    r = 1\n    while e > 0:\n        if e & 1 == 1:\n            r = r * b % mod\n        b = b * b % mod\n        e >>= 1\n    return r\n\ndef fact_exp(n, p):\n    e = 0\n    u = p\n    t = n\n    while u <= t:\n        e += t // u\n        u *= p\n    return e\n\ndef get_base_digits(n, b):\n    d = []\n    while n > 0:\n        d.append(n % b)\n        n = n // b\n    return d\n\ndef fermat_binom_advanced(n, k, p):\n    num_degree = fact_exp(n, p) - fact_exp(n - k, p)\n    den_degree = fact_exp(k, p)\n    if num_degree > den_degree:\n        return 0\n    if k > n:\n        return 0\n    num = 1\n    for i in range(n, n - k, -1):\n        cur = i\n        while cur % p == 0:\n            cur //= p\n        num = num * cur % p\n    denom = 1\n    for i in range(1, k + 1):\n        cur = i\n        while cur % p == 0:\n            cur //= p\n        denom = denom * cur % p\n    return num * mod_exp(denom, p - 2, p) % p\n\ndef lucas_binom(n, k, p):\n    np = get_base_digits(n, p)\n    kp = get_base_digits(k, p)\n    binom = 1\n    for i in range(len(np) - 1, -1, -1):\n        ni = np[i]\n        ki = 0\n        if i < len(kp):\n            ki = kp[i]\n        binom = binom * fermat_binom_advanced(ni, ki, p) % p\n    return binom\nMOD = 10 ** 9 + 7\nfact = [1]\ninvFact = [0] * (10 ** 6 + 1)\ninvFact[0] = invFact[1] = 1\nfor i in range(1, 10 ** 6 + 1):\n    temp2 = fact[i - 1] * i\n    temp2 %= MOD\n    fact.append(temp2)\nfor i in range(2, 10 ** 6 + 1):\n    invFact[i] = (MOD - MOD // i) * invFact[MOD % i] % MOD\nfor i in range(1, 10 ** 6 + 1):\n    invFact[i] = invFact[i - 1] * invFact[i] % MOD\n\ndef ncr(n, r):\n    return fact[n] * invFact[r] % MOD * invFact[n - r] % MOD\n\ndef solve(N, L, R):\n    ans = []\n    for index in range(L, R + 1):\n        v = 0\n        if N % 2 == 0:\n            if abs(index) % 2 == 0:\n                k = N // 2 + index // 2\n                v = ncr(N, k)\n        elif abs(index) % 2 == 1:\n            k = N // 2 + (index + 1) // 2\n            v = ncr(N, k)\n        ans.append(str(v))\n    print(' '.join(ans))\nfor T in range(int(input())):\n    (N, L, R) = list(map(int, input().split()))\n    solve(N, L, R)", "def readInt():\n    return int(input())\n\ndef readInts():\n    return [int(x) for x in input().split()]\n\ndef readString():\n    return input().rstrip()\n\ndef readStrings():\n    return input().split()\nprime = 1000000007\nfactorials = [1]\nfor n in range(1, 1000001):\n    factorials.append(factorials[-1] * n % prime)\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n    return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    return x % m\n\ndef readCase():\n    (n, l, r) = readInts()\n    return (n, l, r)\n\ndef binomial(n, k):\n    ans = factorials[n] * modinv(factorials[n - k], prime) * modinv(factorials[k], prime)\n    return ans % prime\n\ndef solve(n, l, r):\n    start = -n\n    result = []\n    if (l - start) % 2 != 0:\n        result.append(0)\n    k_start = (l - start + 1) // 2\n    k_end = (r - start) // 2\n    for k in range(k_start, k_end + 1):\n        result.append(binomial(n, k))\n        result.append(0)\n    if (r - start) % 2 == 0:\n        result.pop()\n    print(' '.join((str(x) for x in result)))\ncases = readInt()\nfor case in range(cases):\n    solve(*readCase())", "dp = [0 for i in range(10 ** 6 + 1)]\nm = 10 ** 9 + 7\n\ndef inverse():\n    dp[0] = dp[1] = 1\n    for i in range(2, 10 ** 6 + 1):\n        dp[i] = dp[m % i] * (m - m // i) % m\n\ndef combs(n, r):\n    a = b = 1\n    for i in range(r):\n        a = a * (n - i) % m\n        b = b * (i + 1) % m\n    return a * pow(b, m - 2, m) % m\n\ndef calc(n, s, a, b):\n    l = [s]\n    for i in range(a, b):\n        l.append(l[i - a] * (n - i) * dp[i + 1] % m)\n    return l\ninverse()\nt = int(input())\nfor _ in range(t):\n    (n, l, r) = [int(i) for i in input().split()]\n    (a, b) = ((l + n) // 2, (r + n) // 2)\n    lst = calc(n, combs(n, a), a, b)\n    if n % 2 == 0:\n        strt = 0\n        if l & 1 == 1 and r & 1 == 1 and (l == r):\n            print(0)\n        else:\n            if l & 1 == 1:\n                print(0, end=' ')\n                strt = 1\n            print(*lst[strt:], sep=' 0 ', end=' ')\n            if r & 1 == 1:\n                print(0, end=' ')\n            print()\n    else:\n        strt = 0\n        if l & 1 == 0 and r & 1 == 0 and (l == r):\n            print(0)\n        else:\n            if l & 1 == 0:\n                print(0, end=' ')\n                strt = 1\n            print(*lst[strt:], sep=' 0 ', end=' ')\n            if r & 1 == 0:\n                print(0, end=' ')\n            print()", "import math\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef mod(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    return inv * a % m\n\ndef binomial(n, r):\n    if r > n:\n        return 0\n    m = 1000000007\n    inv = [0 for i in range(r + 1)]\n    inv[0] = 1\n    if r + 1 >= 2:\n        inv[1] = 1\n    for i in range(2, r + 1):\n        inv[i] = m - m // i * inv[m % i] % m\n    ans = 1\n    for i in range(2, r + 1):\n        ans = ans % m * (inv[i] % m) % m\n    for i in range(n, n - r, -1):\n        ans = ans % m * (i % m) % m\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, l, r) = map(int, input().split())\n    m = 1000000007\n    if (n + l) % 2 == 0:\n        x = binomial(n, (n + l) // 2)\n    else:\n        x = binomial(n, (n + l + 1) // 2)\n    for i in range(l + n, r + n + 1):\n        if i % 2 == 0:\n            print(x, end=' ')\n            x = mod(x * (n - i // 2), i // 2 + 1, m)\n        else:\n            print(0, end=' ')\n    print('\\n', end='')", "m = 1000000007\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\nfor _ in range(int(input())):\n    (n, l, r) = map(int, input().split())\n    dp = [1] * (n + 1)\n    for i in range(1, n // 2 + 1):\n        dp[i] = dp[i - 1] * (n - i + 1) % m * modinv(i, m)\n        dp[n - i] = dp[i]\n    ax = []\n    for i in range(l, r + 1):\n        if i < 0 and n & 1 == i & 1:\n            ax.append(dp[(n + i) // 2] % m)\n        elif i >= 0 and n & 1 == i & 1:\n            ax.append(dp[(n - i) // 2] % m)\n        else:\n            ax.append(0)\n    print(*ax)", "MOD = 10 ** 9 + 7\nLIM = 10 ** 6 + 1\nfact = [1] * LIM\nfor i in range(1, LIM):\n    fact[i] = fact[i - 1] * i % MOD\n\ndef C(n, r):\n    den = fact[r] * fact[n - r] % MOD\n    den = pow(den, MOD - 2, MOD)\n    ans = fact[n] * den % MOD\n    return ans\n\ndef Good(N, I):\n    return N % 2 == I % 2\n\ndef fixR(n, i):\n    return n // 2 - abs(i) // 2\n\ndef solve(N, L, R):\n    li = []\n    for i in range(L, R + 1):\n        if not Good(N, i):\n            li.append(0)\n            continue\n        r = fixR(N, i)\n        li.append(C(N, r))\n    print(*li)\nfor case in range(int(input())):\n    (N, L, R) = map(int, input().split())\n    solve(N, L, R)", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef compute_row(n, mod):\n    res = [1]\n    for i in range(1, n + 1):\n        x = res[-1] * ((n - i + 1) / i)\n        x = round(x % mod)\n        res.append(x)\n    return res\nmod = 10 ** 9 + 7\nfactorials = [1]\ninv = []\ninv.append(modInverse(factorials[-1], mod))\nfor i in range(10 ** 6):\n    factorials.append(factorials[-1] * (i + 1) % mod)\n    inv.append(modInverse(factorials[-1], mod))\nfor _ in range(int(input())):\n    (n, l, r) = [int(x) for x in input().split()]\n    top = [1]\n    for i in range(n):\n        top.append(top[-1] * (n - i) % mod)\n    row = [1]\n    for i in range(1, n + 1):\n        row.append(top[i] * inv[i] % mod)\n    ans = []\n    for i in range(l, r + 1):\n        if (n + i) % 2:\n            ans.append('0')\n        else:\n            ans.append(str(row[(n + i) // 2]))\n    print(' '.join(ans))", "mod = 10 ** 9 + 7\n\ndef fun(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = fun(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = fun(a, m)\n    return x % m\nfor _ in range(int(input())):\n    (n, left, right) = map(int, input().split())\n    arr = []\n    i = 0\n    curr = 1\n    r = 0\n    while r <= n // 2:\n        arr.append(curr)\n        curr = curr * (n - r) % mod * modinv(r + 1, mod) % mod\n        r += 1\n        arr.append(0)\n    if left >= 0:\n        if n & 1:\n            arr = arr[::-1]\n        else:\n            arr = arr[::-1][1:]\n        print(*arr[left:right + 1])\n    else:\n        if n & 1:\n            arr = arr + arr[::-1][1:]\n        else:\n            arr = arr + arr[::-1][3:]\n        print(*arr[left + n:right + 1 + n])", "mod = 1000000007\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nfor _ in range(int(input())):\n    (n, l, r) = map(int, input().split())\n    dp = [1] * (n + 1)\n    for i in range(1, n // 2 + 1):\n        dp[i] = dp[i - 1] * (n - i + 1) % mod * modinv(i, mod)\n        dp[n - i] = dp[i]\n    axis = []\n    for i in range(l, r + 1):\n        if i < 0 and n & 1 == i & 1:\n            axis.append(dp[(n + i) // 2] % mod)\n        elif i >= 0 and n & 1 == i & 1:\n            axis.append(dp[(n - i) // 2] % mod)\n        else:\n            axis.append(0)\n    print(*axis)", "try:\n    from debug import debug, timer\nexcept ImportError:\n    pass\nfrom sys import stdin\ninput = stdin.readline\n\ndef rii():\n    return range(int(input().strip()))\n\ndef ii():\n    return int(input().strip())\n\ndef mii():\n    return map(int, input().strip().split(' '))\n\ndef lmii():\n    return list(map(int, input().strip().split(' ')))\n\ndef si():\n    return str(input().strip())\n\ndef getvals():\n    while True:\n        yield from input().split()\n\ndef tri(n):\n    return n * (n + 1) // 2\n\ndef smallest_first(m, n):\n    return (min(m, n), max(m, n))\nmodulus = 10 ** 9 + 7\n\ndef p_to_k(n, p):\n    return -1 if n - p & 1 else (n + p) // 2\n\ndef mod_exp(b, e, mod):\n    return pow(b, e, mod)\n\ndef fermat_binom(n, k, p):\n    if k > n:\n        return 0\n    num = 1\n    for i in range(n, n - k, -1):\n        num = num * i % p\n    denom = 1\n    for i in range(1, k + 1):\n        denom = denom * i % p\n    return num * mod_exp(denom, p - 2, p) % p\n\ndef fermat_compute(n, p):\n    facts = [0 for _ in range(n + 1)]\n    invfacts = [0 for _ in range(n + 1)]\n    facts[0] = 1\n    invfacts[0] = 1\n    for i in range(1, n + 1):\n        facts[i] = facts[i - 1] * i % p\n        invfacts[i] = mod_exp(facts[i], p - 2, p)\n    return (facts, invfacts)\n\ndef binom_pre_computed(facts, invfacts, n, k, p):\n    return facts[n] * (invfacts[k] * invfacts[n - k] % p) % p\n\ndef solve(*args):\n    (n, l, r) = args\n    ans = list()\n    (facts, invfacts) = fermat_compute(n, modulus)\n    for idx in range(l, r + 1):\n        pp = p_to_k(n, idx)\n        if pp == -1:\n            ans.append(0)\n        else:\n            ans.append(binom_pre_computed(facts, invfacts, n, pp, modulus))\n    return ' '.join([str(x) for x in ans])\n\ndef do_codechef():\n    for t in rii():\n        (n, l, r) = mii()\n        print(solve(n, l, r))\ndo_codechef()\nexit()", "import math\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    return inv * a % m\nt = int(input())\nmod = 1000000007\nwhile t > 0:\n    ls = list(map(int, input().split(' ')))\n    mx = max(abs(ls[1]), abs(ls[2]))\n    com = [1]\n    for i in range(1, ls[0] // 2 + 1):\n        res = com[i - 1] * (ls[0] - i + 1)\n        com.append(modDivide(res, i, mod))\n    if ls[0] % 2 == 0:\n        for i in range(ls[1], ls[2] + 1):\n            if abs(i) % 2 == 1 or abs(i) // 2 >= len(com):\n                print(0, end=' ')\n            elif i == 0:\n                print(com[-1], end=' ')\n            else:\n                print(com[len(com) - abs(i) // 2 - 1], end=' ')\n    else:\n        for i in range(ls[1], ls[2] + 1):\n            if abs(i) % 2 == 0 or abs(i) // 2 >= len(com):\n                print(0, end=' ')\n            elif abs(i) == 1:\n                print(com[-1], end=' ')\n            else:\n                print(com[len(com) - abs(i) // 2 - 1], end=' ')\n    print()\n    t -= 1", "import math\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    return inv * a % m\nt = int(input())\nmod = 1000000007\nwhile t > 0:\n    ls = list(map(int, input().split(' ')))\n    mx = max(abs(ls[1]), abs(ls[2]))\n    com = [1]\n    for i in range(1, ls[0] // 2 + 1):\n        res = com[i - 1] * (ls[0] - i + 1)\n        com.append(modDivide(res, i, mod))\n    if ls[0] % 2 == 0:\n        for i in range(ls[1], ls[2] + 1):\n            if abs(i) % 2 == 1 or abs(i) // 2 >= len(com):\n                print(0, end=' ')\n            elif i == 0:\n                print(com[-1], end=' ')\n            else:\n                print(com[len(com) - abs(i) // 2 - 1], end=' ')\n    else:\n        for i in range(ls[1], ls[2] + 1):\n            if abs(i) % 2 == 0 or abs(i) // 2 >= len(com):\n                print(0, end=' ')\n            elif abs(i) == 1:\n                print(com[-1], end=' ')\n            else:\n                print(com[len(com) - abs(i) // 2 - 1], end=' ')\n    print()\n    t -= 1", "inv = [0 for i in range(1000000 + 1)]\ninv[0] = 1\ninv[1] = 1\nm = 1000000007\nfor i in range(2, 1000001):\n    inv[i] = m - m // i * inv[m % i] % m\nfor i in range(2, 1000001):\n    inv[i] = inv[i - 1] % m * (inv[i] % m) % m\n\ndef nth(n):\n    ans = 1\n    r = n + 1\n    arr = []\n    arr.extend([1, 0])\n    for i in range(n, 0, -1):\n        ans = ans % m * (i % m) % m\n        x = inv[r - i] % m * (ans % m) % m\n        arr.extend([x, 0])\n    return arr\nfor _ in range(int(input())):\n    (n, l, r) = map(int, input().split())\n    pascal = nth(n)\n    for i in range(abs(-n - l), abs(-r - n) + 1):\n        print(pascal[i], end=' ')\n    print()", "m = 1000000007\nN = 1000000\nf = [1] * (N + 1)\nfor i in range(2, N + 1):\n    f[i] = f[i - 1] * i % m\n\ndef ncr(n, r):\n    if r == 0:\n        return 1\n    return f[n] * pow(f[r], m - 2, m) * pow(f[n - r], m - 2, m) % m\nfor _ in range(int(input())):\n    arr = list(map(int, input().split()))\n    n = arr[0]\n    l = arr[1]\n    r = arr[2]\n    for i in range(l, r + 1):\n        if i % 2 != n % 2:\n            print('0', end=' ')\n            continue\n        print(ncr(n, (n - abs(i)) // 2), end=' ')\n    print()", "p = 1000000007\n\ndef fermat_compute(n):\n    facts = [0] * n\n    invfacts = [0] * n\n    facts[0] = 1\n    invfacts[0] = 1\n    for i in range(1, n):\n        facts[i] = facts[i - 1] * i % p\n        invfacts[i] = pow(facts[i], p - 2, p)\n    return (facts, invfacts)\n\ndef binom_pre_computed(facts, invfacts, n, k):\n    return facts[n - 1] * (invfacts[k - 1] * invfacts[n - k] % p) % p\n\ndef isEven(n):\n    if n % 2 == 0:\n        return True\n    return False\nfor _ in range(int(input())):\n    (n, l, r) = map(int, input().split())\n    size = r - l + 1\n    ans = [0 for _ in range(size)]\n    (facts, invfacts) = fermat_compute(n + 1)\n    i = 0\n    while l < r + 1:\n        if isEven(l + n):\n            a = (l + n) // 2\n            ans[i] = binom_pre_computed(facts, invfacts, n + 1, a + 1)\n        i += 1\n        l += 1\n    print(' '.join(map(str, ans)))", "import math\np = 10 ** 9 + 7\n\ndef nCr(n, r):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef modInverse(b):\n    g = math.gcd(b, p)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, p - 2, p)\n\ndef modDivide(a, b):\n    a = a % p\n    inv = modInverse(b)\n    if inv == -1:\n        return 0\n    else:\n        return inv * a % p\nT = int(input())\nfor i in range(T):\n    (N, L, R) = [int(x) for x in input().split()]\n    if N % 2 == 0:\n        for i in range(L, min(R + 1, L + 2)):\n            if i % 2 == 0:\n                r = (N - abs(i)) // 2\n                x = nCr(N, r)\n                print(x, end=' ')\n            else:\n                print(0, end=' ')\n        for i in range(L + 2, R + 1):\n            if i % 2 == 0 and i <= 0:\n                r = (N - abs(i)) // 2\n                y = x * ((N - r + 1) % p) % p\n                x = modDivide(y, r)\n                print(x, end=' ')\n            elif i % 2 == 0 and i > 0:\n                r = (N - abs(i)) // 2\n                y = x * ((r + 1) % p) % p\n                x = modDivide(y, N - r)\n                print(x, end=' ')\n            else:\n                print(0, end=' ')\n    else:\n        for i in range(L, min(R + 1, L + 2)):\n            if i % 2 != 0:\n                r = (N - abs(i)) // 2\n                x = nCr(N, r)\n                print(x, end=' ')\n            else:\n                print(0, end=' ')\n        for i in range(L + 2, R + 1):\n            if i % 2 != 0 and i <= 0:\n                r = (N - abs(i)) // 2\n                y = x * ((N - r + 1) % p) % p\n                x = modDivide(y, r)\n                print(x, end=' ')\n            elif i % 2 != 0 and i > 0:\n                r = (N - abs(i)) // 2\n                y = x * ((r + 1) % p) % p\n                x = modDivide(y, N - r)\n                print(x, end=' ')\n            else:\n                print(0, end=' ')\n    print()", "import sys\nimport math\ninput = sys.stdin.readline\nMAXN = 10 ** 6\nMOD = 10 ** 9 + 7\nfact = [1]\nfor i in range(1, MAXN + 1):\n    fact.append(fact[-1] * i % MOD)\n\ndef multinv(n, m):\n    if m == 1:\n        return 0\n    (m0, y, x) = (m, 0, 1)\n    while n > 1:\n        (y, x) = (x - n // m * y, y)\n        (m, n) = (n % m, m)\n    return x + m0 if x < 0 else x\n\ndef choose(n, k, m):\n    return fact[n] * multinv(fact[n - k] * fact[k] % m, m) % m\n\ndef fs(n, i):\n    if n % 2 == 0 and abs(i) % 2 == 1:\n        return 0\n    if n % 2 == 1 and abs(i) % 2 == 0:\n        return 0\n    if n % 2 == 0:\n        return choose(n, n // 2 + math.ceil(abs(i) / 2), MOD)\n    if n % 2 == 1:\n        return choose(n, n // 2 + math.ceil(abs(i) / 2), MOD)\nT = int(input())\nfor j in range(T):\n    (n, l, r) = map(int, input().split())\n    res = [fs(n, abs(i)) for i in range(l, r + 1)]\n    print(*res)", "M = 1000000007\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef getNCR(n, r):\n    if r > n:\n        print(0)\n    else:\n        res = 1\n        for i in range(r):\n            res = res % M * ((n - i) % M) % M * modInverse(i + 1, M) % M\n    return res\nfor _ in range(int(input())):\n    (N, L, R) = map(int, input().split())\n    n = N\n    diff = R - L + 1\n    l = []\n    flag = 0\n    for i in range(L, R + 1):\n        if (i + N) % 2 == 0:\n            if flag == 1:\n                res = res % M * ((N - r) % M) % M * modInverse(r + 1, M) % M\n                l.append(res)\n                r = (i + N) // 2\n            else:\n                r = (i + N) // 2\n                res = getNCR(N, r)\n                l.append(res)\n                flag = 1\n        else:\n            l.append(0)\n    for i in range(len(l)):\n        print(l[i], end=' ')\n    print('\\n')", "t = int(input())\nfor _ in range(t):\n    (n, l, r) = list(map(int, input().split()))\n    row = [1]\n    prev = 1\n    m = 10 ** 9 + 7\n    for i in range(1, n + 1):\n        curr = prev * (n + 1 - i) % m\n        inv_i = pow(i, m - 2, m)\n        curr = curr * inv_i % m\n        row.append(0)\n        row.append(curr)\n        prev = curr\n    l = n + l\n    r = n + r\n    r += 1\n    for i in row[l:r]:\n        print(i, end=' ')\n    print()", "import sys\nMYPC = False\nif MYPC:\n    sys.stdin = open('in.txt', 'r')\n    sys.stdout = open('out.txt', 'w')\ninput = lambda : sys.stdin.readline().strip('\\r\\n')\nmod = 1000000007\n\ndef gcd_tuple(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = gcd_tuple(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef inv_mod(a, m=mod):\n    (g, x, y) = gcd_tuple(a, m)\n    if g != 1:\n        return -1\n    return x % m\n\ndef solve():\n    (n, l, r) = map(int, input().split())\n    l += n\n    r += n\n    (coeff, R) = (1, 0)\n    coeffs = [0] * (2 * n + 1)\n    for i in range(0, 2 * n + 1, 2):\n        coeffs[i] = coeff\n        R += 1\n        factor = (n - R + 1) * inv_mod(R)\n        factor %= mod\n        coeff *= factor\n        coeff %= mod\n    print(*[coeffs[i] for i in range(2 * n + 1) if l <= i <= r])\n\ndef main() -> None:\n    for _ in range(int(input())):\n        solve()\nmain()", "import math\nmaxN = 10 ** 6 + 1\nfacNumInv = [None] * (maxN + 1)\nNumInv = [None] * (maxN + 1)\nfac = [None] * (maxN + 1)\n\ndef InvofNum(p):\n    NumInv[0] = 1\n    NumInv[1] = 1\n    for i in range(2, maxN + 1, 1):\n        NumInv[i] = NumInv[p % i] * (p - int(p / i)) % p\n\ndef InvofFac(p):\n    facNumInv[0] = 1\n    facNumInv[1] = 1\n    for i in range(2, maxN + 1, 1):\n        facNumInv[i] = NumInv[i] * facNumInv[i - 1] % p\n\ndef factorial(p):\n    fac[0] = 1\n    for i in range(1, maxN + 1):\n        fac[i] = fac[i - 1] * i % p\n\ndef nCrmodp(n, r, p):\n    ans = fac[n] * facNumInv[r] % p * facNumInv[n - r] % p\n    return ans\np_ = 10 ** 9 + 7\nInvofNum(p_)\nInvofFac(p_)\nfactorial(p_)\nT = int(input())\nfor i in range(T):\n    (N, L, R) = map(int, input().split())\n    A = list(range(N + L, N + R + 1))\n    a = []\n    for j in A:\n        if j % 2 == 0 and j >= 0 and (j <= 2 * N):\n            a.append(nCrmodp(N, int(j / 2), p_))\n        else:\n            a.append(0)\n    print(*a, sep=' ')", "mod = 1000000007\n\ndef modinv(a):\n    (x, y) = (1, 0)\n    m = mod\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x += mod\n        x %= mod\n    return x\n\ndef mulmod(a, b):\n    return a * b % mod\n\ndef cal(ncr, n):\n    for i in range(1, n // 2 + 1):\n        ncr[i] = mulmod(ncr[i - 1], n - i + 1)\n        ncr[i] = mulmod(ncr[i], modinv(i))\nfor _ in range(int(input())):\n    (n, l, r) = map(int, input().split())\n    ncr = [1 for i in range(n)]\n    cal(ncr, n)\n    res = list()\n    temp = n // 2\n    if n % 2 == 1:\n        temp += 1\n    for i in range(0, temp):\n        res.append(ncr[i])\n        res.append(0)\n    for i in range(n // 2, -1, -1):\n        res.append(ncr[i])\n        res.append(0)\n    if n == 1:\n        print(*[1, 0, 1][l + 1:r + 2])\n    else:\n        print(*res[l + n:r + n + 1])", "m = 10 ** 9 + 7\nfact = [1, 1]\nfor i in range(2, 10 ** 6):\n    v = i * fact[i - 1]\n    fact.append(v % m)\n\ndef com(n, i):\n    no = fact[n]\n    de = fact[i] * fact[n - i]\n    de = pow(de, m - 2, m)\n    return no * de % m\nfor i in range(int(input())):\n    (n, l, r) = map(int, input().split())\n    for i in range(l + n, r + n + 1):\n        if i % 2 == 0:\n            print(com(n, i // 2), end=' ')\n        else:\n            print(0, end=' ')\n    print()"]