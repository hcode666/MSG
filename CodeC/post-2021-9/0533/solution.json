["import sys\ninput = sys.stdin.readline\n\ndef I():\n    return input().strip()\n\ndef II():\n    return int(input().strip())\n\ndef LI():\n    return [*map(int, input().strip().split())]\nimport copy, string, math, time, functools, fractions\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right\nfrom collections import deque, defaultdict, Counter, OrderedDict\nfrom itertools import permutations, chain, combinations, groupby\nfrom operator import itemgetter\nfrom types import GeneratorType\nfrom typing import Iterable, TypeVar, Union\nfor _ in range(II()):\n    (n, m, k) = LI()\n    c = LI()\n    t = LI()\n    d = defaultdict(list)\n    for i in range(n):\n        d[c[i]].append(t[i])\n    arr = []\n    for l in d.values():\n        l.sort()\n        arr.append(l[0])\n        s = len(l)\n        for i in range(1, s, 2):\n            if i + 1 < s:\n                arr.append(l[i] + l[i + 1])\n    arr.sort()\n    s = 0\n    ans = 0\n    for i in range(len(arr)):\n        if s + arr[i] <= k:\n            s += arr[i]\n            ans += 1\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\ndef I():\n    return input().strip()\n\ndef II():\n    return int(input().strip())\n\ndef LI():\n    return [*map(int, input().strip().split())]\nimport copy, string, math, time, functools, fractions\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right\nfrom collections import deque, defaultdict, Counter, OrderedDict\nfrom itertools import permutations, chain, combinations, groupby\nfrom operator import itemgetter\nfrom types import GeneratorType\nfrom typing import Iterable, TypeVar, Union\nfor _ in range(II()):\n    (n, m, k) = LI()\n    c = LI()\n    t = LI()\n    d = defaultdict(list)\n    for i in range(n):\n        d[c[i]].append(t[i])\n    arr = []\n    for l in d.values():\n        l.sort()\n        arr.append(l[0])\n        s = len(l)\n        for i in range(1, s, 2):\n            if i + 1 < s:\n                arr.append(l[i] + l[i + 1])\n    arr.sort()\n    s = 0\n    ans = 0\n    for i in range(len(arr)):\n        if s + arr[i] <= k:\n            s += arr[i]\n            ans += 1\n    print(ans)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    d = dict()\n    l = dict()\n    for i in c:\n        d[i] = []\n        l[i] = 0\n    for i in range(n):\n        d[c[i]].append(t[i])\n        l[c[i]] += 1\n    lis = []\n    le = []\n    for i in d:\n        d[i].sort()\n        lis.append(d[i])\n        le.append(l[i])\n    s = len(le)\n    final = []\n    for i in range(s):\n        final.append(lis[i][0])\n        for j in range(1, le[i] - 1, 2):\n            final.append(lis[i][j] + lis[i][j + 1])\n    final.sort()\n    ans = 0\n    for i in final:\n        if i <= k:\n            ans += 1\n            k -= i\n    print(ans)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    l = [[0] for i in range(m)]\n    l1 = []\n    for i in range(n):\n        l[c[i] - 1].append(t[i])\n    for i in range(len(l)):\n        l[i].sort()\n        for j in range(0, len(l[i]), 2):\n            try:\n                l1.append(l[i][j] + l[i][j + 1])\n            except:\n                pass\n    l1.sort()\n    s = k\n    count = 0\n    for i in l1:\n        if s < i:\n            break\n        count += 1\n        s -= i\n    print(count)", "import sys\nimport math\nimport heapq\nfrom collections import defaultdict as dd\nfrom collections import OrderedDict as od\nfrom collections import deque\nfrom itertools import permutations as pp\nfrom itertools import combinations as cc\nfrom sys import stdin\nfrom functools import cmp_to_key as ctk\nfrom functools import lru_cache\nfrom bisect import bisect_left as bs_l\nfrom bisect import bisect_right as bs_r\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(2 * 10 ** 5 + 1)\n\ndef comparator(x, y):\n    if x[0] == y[0]:\n        return x[1] - y[1]\n    return True\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fc[n] * pow(fc[r] * fc[n - r] % mod, mod - 2, mod) % mod\nT = int(input())\nfor _ in range(T):\n    (n, m, k) = map(int, input().split())\n    job = list(map(int, input().split()))\n    time = list(map(int, input().split()))\n    d = dd(list)\n    for i in range(n):\n        d[job[i]].append(time[i])\n    hp = []\n    for i in d:\n        st = sorted(d[i])\n        ll = deque(st)\n        top = ll.popleft()\n        heapq.heappush(hp, [top, ll, i])\n    ss = set()\n    ans = dd(int)\n    while len(hp):\n        ll = heapq.heappop(hp)\n        (time, lis, jid) = (ll[0], ll[1], ll[2])\n        if jid in ss:\n            if time > 10 ** 9:\n                actual = time - 10 ** 9\n                if actual <= k:\n                    ans[jid] += 1\n                    k -= actual\n                else:\n                    break\n            elif time <= k:\n                ans[jid] += 2\n                k -= time\n                try:\n                    x = lis.popleft()\n                except:\n                    x = None\n                try:\n                    y = lis.popleft()\n                except:\n                    y = None\n                if x:\n                    if y:\n                        heapq.heappush(hp, [x + y, lis, jid])\n                    else:\n                        heapq.heappush(hp, [x + 10 ** 9, lis, jid])\n            else:\n                break\n        elif time <= k:\n            ans[jid] += 1\n            k -= time\n            ss.add(jid)\n            try:\n                x = lis.popleft()\n            except:\n                x = None\n            try:\n                y = lis.popleft()\n            except:\n                y = None\n            if x:\n                if y:\n                    heapq.heappush(hp, [x + y, lis, jid])\n                else:\n                    heapq.heappush(hp, [x + 10 ** 9, lis, jid])\n        else:\n            break\n    res = 0\n    for i in ans:\n        res += (ans[i] + 1) // 2\n    print(res)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = [int(i) for i in input().split()]\n    t = [int(i) for i in input().split()]\n    dict1 = dict()\n    for i in c:\n        dict1[i] = []\n    for i in range(n):\n        dict1[c[i]].append(t[i])\n    for i in dict1:\n        dict1[i].sort()\n    list1 = []\n    for i in dict1:\n        list1.append(dict1[i][0])\n        for j in range(1, len(dict1[i]) - 1, 2):\n            list1.append(dict1[i][j] + dict1[i][j + 1])\n    sum = 0\n    list1.sort()\n    for i in range(len(list1)):\n        if list1[i] <= k:\n            sum += 1\n            k -= list1[i]\n    print(sum)", "import heapq as hq\nfor _ in range(int(input())):\n    cnt = 0\n    (n, m, k) = map(int, input().split())\n    c = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    l = [[] for _ in range(m + 1)]\n    for i in range(n):\n        l[c[i]].append([t[i], c[i]])\n    temp = []\n    hq.heapify(temp)\n    for i in range(1, m + 1):\n        if len(l[i]) != 0:\n            hq.heapify(l[i])\n            hq.heappush(temp, hq.heappop(l[i]))\n    while k > 0 and len(temp) != 0:\n        t = hq.heappop(temp)\n        if k >= t[0]:\n            cnt = cnt + 1\n            k = k - t[0]\n            if len(l[t[1]]) > 1:\n                a = hq.heappop(l[t[1]])\n                b = hq.heappop(l[t[1]])\n                hq.heappush(temp, [a[0] + b[0], b[1]])\n        else:\n            break\n    print(cnt)", "inf = float('inf')\nimport sys\nimport pprint\nimport logging\nfrom logging import getLogger\nimport array\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef maps():\n    return [int(i) for i in input().split()]\nlogging.basicConfig(format='%(message)s', level=logging.WARNING)\nlogger = getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\ndef debug(msg, *args):\n    logger.info(f'{msg}={pprint.pformat(args)}')\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict\n\ndef solve():\n    (n, m, k) = maps()\n    a = [*maps()]\n    b = [*maps()]\n    (d, e) = (defaultdict(list), [])\n    for i in range(n):\n        d[a[i]].append(b[i])\n    for i in d:\n        if len(d[i]) == 1:\n            e.append(d[i][0])\n            continue\n        d[i].sort()\n        t = [d[i][0]]\n        if len(d[i]) % 2:\n            for j in range(1, len(d[i]), 2):\n                t.append(d[i][j] + d[i][j + 1])\n        else:\n            for j in range(1, len(d[i]), 2):\n                if j + 1 < len(d[i]):\n                    t.append(d[i][j] + d[i][j + 1])\n        e.extend(t)\n    e.sort()\n    (tot, num) = (0, 0)\n    for i in e:\n        num += 1\n        tot += i\n        if tot > k:\n            num -= 1\n            break\n    print(num)\n(t,) = maps()\nwhile t:\n    t -= 1\n    solve()", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    d = dict()\n    l = dict()\n    for i in c:\n        d[i] = []\n        l[i] = 0\n    for i in range(n):\n        d[c[i]].append(t[i])\n        l[c[i]] += 1\n    lis = []\n    le = []\n    for i in d:\n        d[i].sort()\n        lis.append(d[i])\n        le.append(l[i])\n    s = len(le)\n    final = []\n    for i in range(s):\n        final.append(lis[i][0])\n        for j in range(1, le[i] - 1, 2):\n            final.append(lis[i][j] + lis[i][j + 1])\n    final.sort()\n    ans = 0\n    for i in final:\n        if i <= k:\n            ans += 1\n            k -= i\n    print(ans)", "import math\nfor t in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    sub = list(map(int, input().split()))\n    time = list(map(int, input().split()))\n    d = dict()\n    for s in range(1, m + 1):\n        d[s] = []\n    for i in range(len(sub)):\n        d[sub[i]] += [time[i]]\n    for i in range(1, m + 1):\n        d[i].sort()\n    times = []\n    for i in range(1, m + 1):\n        ar = d[i]\n        if len(ar) == 0:\n            continue\n        times += [ar[0]]\n        for j in range(1, len(ar) - 1, 2):\n            times += [ar[j] + ar[j + 1]]\n    times.sort()\n    sc = 0\n    tot = 0\n    for tt in range(len(times)):\n        if tot + times[tt] <= k:\n            tot += times[tt]\n            sc += 1\n    print(sc)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    L = dict()\n    l = dict()\n    for i in c:\n        L[i] = []\n        l[i] = 0\n    for i in range(n):\n        L[c[i]].append(t[i])\n        l[c[i]] += 1\n    L1 = []\n    l1 = []\n    for i in L:\n        L[i].sort()\n        L1.append(L[i])\n        l1.append(l[i])\n    final = []\n    for i in range(len(l1)):\n        final.append(L1[i][0])\n        for j in range(1, len(L1[i]) - 1, 2):\n            final.append(L1[i][j] + L1[i][j + 1])\n    final.sort()\n    ans = 0\n    for i in final:\n        if i <= k:\n            ans += 1\n            k -= i\n    print(ans)", "from collections import defaultdict\n\ndef TaskTimes():\n    T = int(input())\n    for _ in range(T):\n        (num_topics, num_subjects, budget) = [int(x) for x in input().split()]\n        subjects = [int(x) for x in input().split()]\n        costs = [int(x) for x in input().split()]\n        costs_to_study_subject = defaultdict(list)\n        for (subject, cost) in zip(subjects, costs):\n            costs_to_study_subject[subject] += [cost]\n        cost_to_get_a_point = []\n        for subject in costs_to_study_subject:\n            cost_arr = sorted(costs_to_study_subject[subject])\n            cost_to_get_a_point += [cost_arr[0]]\n            if not len(cost_arr) & 1:\n                cost_arr.pop()\n            for i in range(1, len(cost_arr), 2):\n                cost_to_get_a_point += [sum(cost_arr[i:i + 2])]\n        cost_to_get_a_point.sort()\n        ans = 0\n        i = 0\n        while budget > 0 and i < len(cost_to_get_a_point):\n            budget -= cost_to_get_a_point[i]\n            ans += 1\n            i += 1\n        if budget < 0:\n            ans -= 1\n        print(ans)\n    return\nTaskTimes()", "from collections import defaultdict\n\ndef TaskTimes():\n    T = int(input())\n    for _ in range(T):\n        (num_topics, num_subjects, budget) = [int(x) for x in input().split()]\n        subjects = [int(x) for x in input().split()]\n        costs = [int(x) for x in input().split()]\n        costs_to_study_subject = defaultdict(list)\n        for (subject, cost) in zip(subjects, costs):\n            costs_to_study_subject[subject] += [cost]\n        cost_to_get_a_point = []\n        for subject in costs_to_study_subject:\n            cost_arr = sorted(costs_to_study_subject[subject])\n            cost_to_get_a_point += [cost_arr[0]]\n            if not len(cost_arr) & 1:\n                cost_arr.pop()\n            for i in range(1, len(cost_arr), 2):\n                cost_to_get_a_point += [sum(cost_arr[i:i + 2])]\n        cost_to_get_a_point.sort()\n        ans = 0\n        i = 0\n        while budget > 0 and i < len(cost_to_get_a_point):\n            budget -= cost_to_get_a_point[i]\n            ans += 1\n            i += 1\n        if budget < 0:\n            ans -= 1\n        print(ans)\n    return\nTaskTimes()", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = list(map(int, input().split()))\n    q = list(map(int, input().split()))\n    arr = [[] for i in range(m + 1)]\n    for i in range(n):\n        arr[c[i]].append(q[i])\n    v = []\n    for i in range(1, m + 1):\n        arr[i] = sorted(arr[i])\n        if len(arr[i]) > 0:\n            v.append(arr[i][0])\n        for j in range(1, len(arr[i]), 2):\n            if j + 1 != len(arr[i]):\n                v.append(arr[i][j] + arr[i][j + 1])\n    ans = 0\n    v = sorted(v)\n    for i in range(len(v)):\n        if k >= v[i]:\n            k -= v[i]\n            ans += 1\n    print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = [[] for i in range(m)]\n    for i in range(n):\n        l[a[i] - 1].append(b[i])\n    for i in range(m):\n        l[i].sort()\n    new = []\n    for i in range(m):\n        c = 0\n        for j in l[i]:\n            c += 1\n            if c == 1:\n                new.append((j, i))\n            elif c % 2 == 1:\n                new.append((j + x, i))\n            else:\n                x = j\n    new.sort()\n    d = defaultdict(lambda : 0)\n    for i in range(len(new)):\n        if k < new[i][0]:\n            break\n        else:\n            d[i] += 1\n            k -= new[i][0]\n    print(sum(d.values()))", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = [[] for i in range(m)]\n    for i in range(n):\n        l[a[i] - 1].append(b[i])\n    for i in range(m):\n        l[i].sort()\n    new = []\n    for i in range(m):\n        c = 0\n        for j in l[i]:\n            c += 1\n            if c == 1:\n                new.append((j, i))\n            elif c % 2 == 1:\n                new.append((j + x, i))\n            else:\n                x = j\n    new.sort()\n    d = defaultdict(lambda : 0)\n    for i in range(len(new)):\n        if k < new[i][0]:\n            break\n        else:\n            d[i] += 1\n            k -= new[i][0]\n    print(sum(d.values()))", "from collections import *\nfor u in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    d = [[0] for i in range(m)]\n    for i in range(n):\n        d[a[i] - 1].append(b[i])\n    l = []\n    for i in range(m):\n        d[i].sort()\n        for j in range(0, len(d[i]) - 1, 2):\n            l.append(d[i][j] + d[i][j + 1])\n    l.sort()\n    c = 0\n    for i in range(len(l)):\n        if l[i] <= k:\n            k -= l[i]\n            c += 1\n        else:\n            break\n    print(c)", "t = int(input())\nfor i in range(t):\n    (a, b, c) = map(int, input().split())\n    k = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    s1 = [[0] for i in range(b)]\n    for i in range(a):\n        s1[k[i] - 1].append(l[i])\n    s2 = []\n    for i in range(b):\n        s1[i].sort()\n        for j in range(len(s1[i]) // 2):\n            s2.append(s1[i][2 * j] + s1[i][2 * j + 1])\n    s2.sort()\n    i = 0\n    j = 0\n    while i < len(s2) and j + s2[i] <= c:\n        j += s2[i]\n        i += 1\n    print(i)", "for _ in range(int(input())):\n    (N, M, K) = map(int, input().split())\n    C = list(map(int, input().split()))\n    T = [(int(j), i) for (i, j) in enumerate(input().split())]\n    T.sort()\n    F = [[] for i in range(M)]\n    Q = []\n    for (t, i) in T:\n        s = C[i] - 1\n        if len(F[s]) & 1 == 0:\n            c = t + (F[s][-1] if len(F[s]) != 0 else 0)\n            Q.append(c)\n        F[s].append(t)\n    Q.sort()\n    ans = 0\n    i = 0\n    while i < len(Q) and Q[i] <= K:\n        K -= Q[i]\n        ans += 1\n        i += 1\n    print(ans)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    d = dict()\n    l = dict()\n    for i in c:\n        d[i] = []\n        l[i] = 0\n    for i in range(n):\n        d[c[i]].append(t[i])\n        l[c[i]] += 1\n    lis = []\n    le = []\n    for i in d:\n        d[i].sort()\n        lis.append(d[i])\n        le.append(l[i])\n    s = len(le)\n    final = []\n    for i in range(s):\n        final.append(lis[i][0])\n        for j in range(1, le[i] - 1, 2):\n            final.append(lis[i][j] + lis[i][j + 1])\n    final.sort()\n    ans = 0\n    for i in final:\n        if i <= k:\n            ans += 1\n            k -= i\n    print(ans)", "from bisect import *\nfrom collections import *\nfrom sys import stdin, stdout\nfrom queue import *\nfrom itertools import *\nfrom heapq import *\nfrom random import *\nfrom statistics import *\nfrom math import *\nfrom re import *\nimport array\nimport operator\nfrom copy import *\nlines = stdin.readlines()\nout = stdout.write\nlines.reverse()\n\ndef input():\n    return lines.pop().strip('\\n')\n\ndef readIntList():\n    return list(map(int, input().split()))\n\ndef readStrList():\n    return list(map(str, input().split()))\nfor i in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = readIntList()\n    t = readIntList()\n    arr = []\n    mp = defaultdict(int)\n    wp = defaultdict(int)\n    for i in range(n):\n        arr.append((t[i], c[i]))\n    arr.sort()\n    brr = []\n    for i in range(n):\n        if mp[arr[i][1]] % 2 != 0:\n            wp[arr[i][1]] = arr[i][0]\n        else:\n            brr.append((arr[i][0] + wp[arr[i][1]], arr[i][1]))\n        mp[arr[i][1]] += 1\n    brr.sort()\n    d = defaultdict(list)\n    ans = 0\n    left = k\n    for i in range(len(brr)):\n        if left < brr[i][0]:\n            break\n        ans += 1\n        left -= brr[i][0]\n    print(ans)", "from bisect import *\nfrom collections import *\nfrom sys import stdin, stdout\nfrom queue import *\nfrom itertools import *\nfrom heapq import *\nfrom random import *\nfrom statistics import *\nfrom math import *\nfrom re import *\nimport array\nimport operator\nfrom copy import *\nlines = stdin.readlines()\nout = stdout.write\nlines.reverse()\n\ndef input():\n    return lines.pop().strip('\\n')\n\ndef readIntList():\n    return list(map(int, input().split()))\n\ndef readStrList():\n    return list(map(str, input().split()))\nfor i in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = readIntList()\n    t = readIntList()\n    arr = []\n    mp = defaultdict(int)\n    wp = defaultdict(int)\n    for i in range(n):\n        arr.append((t[i], c[i]))\n    arr.sort()\n    brr = []\n    for i in range(n):\n        if mp[arr[i][1]] % 2 != 0:\n            wp[arr[i][1]] = arr[i][0]\n        else:\n            brr.append((arr[i][0] + wp[arr[i][1]], arr[i][1]))\n        mp[arr[i][1]] += 1\n    brr.sort()\n    d = defaultdict(list)\n    ans = 0\n    left = k\n    for i in range(len(brr)):\n        if left < brr[i][0]:\n            break\n        ans += 1\n        left -= brr[i][0]\n    print(ans)", "for t in range(int(input())):\n    (N, M, K) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = [[a[i], b[i]] for i in range(N)]\n    arr.sort()\n    vis = [0] * (N + 1)\n    narr = []\n    i = 0\n    while i < N:\n        if vis[arr[i][0]]:\n            if i < N - 1 and arr[i + 1][0] == arr[i][0]:\n                narr.append([arr[i][1] + arr[i + 1][1], arr[i][0]])\n                i += 2\n            else:\n                i += 1\n        else:\n            narr.append([arr[i][1], arr[i][0]])\n            vis[arr[i][0]] = 1\n            i += 1\n    narr.sort()\n    count = [0] * (N + 1)\n    for (i, j) in narr:\n        if i <= K:\n            K -= i\n            if count[j]:\n                count[j] += 2\n            else:\n                count[j] += 1\n        else:\n            break\n    ans = 0\n    for i in count:\n        ans += (i + 1) // 2\n    print(ans)", "from collections import Counter\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = {}\n    for i in range(n):\n        c[a[i]] = []\n    for i in range(n):\n        c[a[i]].append(b[i])\n    e = []\n    for i in c:\n        if len(c[i]) > 1:\n            c[i].sort()\n            if len(c[i]) % 2 == 0:\n                d = [c[i][0]]\n                for j in range(1, len(c[i]), 2):\n                    if j == len(c[i]) - 1:\n                        break\n                    d.append(c[i][j] + c[i][j + 1])\n            else:\n                d = [c[i][0]]\n                for j in range(1, len(c[i]), 2):\n                    d.append(c[i][j] + c[i][j + 1])\n            e.extend(d)\n        else:\n            e.extend(c[i])\n    e.sort()\n    k1 = 0\n    c1 = 0\n    for i in e:\n        c1 += 1\n        k1 += i\n        if k1 > k:\n            c1 -= 1\n            break\n    print(c1)", "for tcase in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    s1 = [[0] for i in range(m)]\n    for i in range(n):\n        s1[c[i] - 1].append(t[i])\n    s2 = []\n    for i in range(m):\n        s1[i].sort()\n        for j in range(len(s1[i]) // 2):\n            s2.append(s1[i][2 * j] + s1[i][2 * j + 1])\n    s2.sort()\n    (i, time) = (0, 0)\n    while i < len(s2) and time + s2[i] <= k:\n        time += s2[i]\n        i += 1\n    print(i)", "import sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef st():\n    return input().rstrip('\\n')\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\nt = inp()\nwhile t:\n    t -= 1\n    (n, m, k) = ma()\n    c = lis()\n    tt = lis()\n    ind = {}\n    for i in range(n):\n        try:\n            ind[c[i]].append(tt[i])\n        except:\n            ind[c[i]] = [tt[i]]\n    for i in ind.keys():\n        ind[i].sort(reverse=True)\n    tot = []\n    res = 0\n    for i in ind.keys():\n        x = ind[i].pop()\n        tot.append([1, x])\n        while len(ind[i]) > 1:\n            x = ind[i].pop()\n            y = ind[i].pop()\n            tot.append([1, x + y])\n    tot.sort()\n    for i in tot:\n        k -= i[1]\n        if k < 0:\n            break\n        res += 1\n    print(res)", "import math\nfor t in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    sub = list(map(int, input().split()))\n    time = list(map(int, input().split()))\n    d = dict()\n    for s in range(1, m + 1):\n        d[s] = []\n    for i in range(len(sub)):\n        d[sub[i]] += [time[i]]\n    for i in range(1, m + 1):\n        d[i].sort()\n    times = []\n    for i in range(1, m + 1):\n        ar = d[i]\n        if len(ar) == 0:\n            continue\n        times += [ar[0]]\n        for j in range(1, len(ar) - 1, 2):\n            times += [ar[j] + ar[j + 1]]\n    times.sort()\n    sc = 0\n    tot = 0\n    for tt in range(len(times)):\n        if tot + times[tt] <= k:\n            tot += times[tt]\n            sc += 1\n    print(sc)", "import heapq, math\nfrom collections import deque\ntc = int(input())\nfor _ in range(tc):\n    (n, m, k) = list(map(int, input().split()))\n    subject = list(map(int, input().split()))\n    hours = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append([hours[i], subject[i], 1])\n    heapq.heapify(l)\n    taken = [0 for _ in range(m + 1)]\n    totake = [[] for _ in range(m + 1)]\n    while k > 0 and len(l) > 0:\n        (hour, subj, count) = heapq.heappop(l)\n        totcount = taken[subj] + count\n        if totcount % 2 == 1:\n            if hour <= k:\n                taken[subj] = totcount\n                k -= hour\n        elif len(totake[subj]) == 0:\n            totake[subj].append(hour)\n        else:\n            c1 = totake[subj].pop()\n            totalhour = c1 + hour\n            heapq.heappush(l, [totalhour, subj, 2])\n    ans = 0\n    for i in taken:\n        ans += math.ceil(i / 2)\n    print(ans)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    l = [[] for _ in range(m)]\n    for i in range(n):\n        l[c[i] - 1].append(t[i])\n    new = []\n    for i in range(m):\n        if not l[i]:\n            continue\n        l[i].sort()\n        nl = [l[i][0]]\n        try:\n            for j in range(1, len(l[i]), 2):\n                nl.append(l[i][j] + l[i][j + 1])\n        except:\n            pass\n        new += nl\n    new.sort()\n    c = 0\n    for i in new:\n        if k - i >= 0:\n            k -= i\n        else:\n            break\n        c += 1\n    print(c)", "from heapq import heapify, heappop, heappush\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    c = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    z = [[] for _ in range(m)]\n    for i in range(n):\n        heappush(z[c[i] - 1], t[i])\n    l = []\n    for i in range(m):\n        if z[i]:\n            heappush(l, (heappop(z[i]), i))\n    ans = 0\n    while k and l:\n        (time, g) = heappop(l)\n        if k - time >= 0:\n            k -= time\n            ans += 1\n            if len(z[g]) >= 2:\n                heappush(l, (heappop(z[g]) + heappop(z[g]), g))\n    print(ans)", "def main():\n    (n, m, k) = map(int, input().split())\n    subjects = list(map(int, input().split()))\n    times = list(map(int, input().split()))\n    dic = {}\n    for i in range(n):\n        (s, t) = (subjects[i], times[i])\n        if s in dic:\n            dic[s].append(t)\n        else:\n            dic[s] = [t]\n    for s in dic:\n        dic[s].sort()\n    anotherDic = {}\n    for s in dic:\n        anotherDic[s] = [dic[s][0]]\n        arr = dic[s]\n        for i in range(2, len(arr), 2):\n            anotherDic[s].append(arr[i] + arr[i - 1])\n    arr = []\n    for s in anotherDic:\n        arr.extend(anotherDic[s])\n    arr.sort()\n    ans = 0\n    count = 0\n    for num in arr:\n        if ans + num <= k:\n            count += 1\n            ans += num\n        else:\n            break\n    print(count)\nt = int(input())\nfor _ in range(t):\n    main()", "import sys\ninput = sys.stdin.readline\n\ndef I():\n    return input().strip()\n\ndef II():\n    return int(input().strip())\n\ndef LI():\n    return [*map(int, input().strip().split())]\nimport copy, string, math, time, functools, fractions\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right\nfrom collections import deque, defaultdict, Counter, OrderedDict\nfrom itertools import permutations, chain, combinations, groupby\nfrom operator import itemgetter\nfrom types import GeneratorType\nfrom typing import Iterable, TypeVar, Union\nfor _ in range(II()):\n    (n, m, k) = LI()\n    c = LI()\n    t = LI()\n    d = defaultdict(list)\n    for i in range(n):\n        d[c[i]].append(t[i])\n    arr = []\n    for l in d.values():\n        l.sort()\n        arr.append(l[0])\n        s = len(l)\n        for i in range(1, s, 2):\n            if i + 1 < s:\n                arr.append(l[i] + l[i + 1])\n    arr.sort()\n    s = 0\n    ans = 0\n    for i in range(len(arr)):\n        if s + arr[i] <= k:\n            s += arr[i]\n            ans += 1\n    print(ans)"]