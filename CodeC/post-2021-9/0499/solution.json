["from sys import stdin, stdout, setrecursionlimit\nsetrecursionlimit(10 ** 7)\nnmbr = lambda : int(input())\nlst = lambda : list(map(int, input().split()))\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef fn(cnt):\n    if cnt == 0:\n        return False\n    ans = False\n    if cnt >= 1:\n        if fn(cnt - 1) == False:\n            ans = True\n    if not ans and cnt >= 2:\n        if fn(cnt - 2) == False:\n            ans = True\n    return ans\nfor _ in range(nmbr()):\n    n = nmbr()\n    s = input()\n    cnt = sum((int(ch1 == ch2) for (ch1, ch2) in zip(s, s[1:])))\n    if fn(cnt):\n        print('JJ')\n    else:\n        print('Uttu')", "from sys import stdin, stdout, setrecursionlimit\nsetrecursionlimit(10 ** 7)\nnmbr = lambda : int(input())\nlst = lambda : list(map(int, input().split()))\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef fn(cnt):\n    if cnt == 0:\n        return False\n    ans = False\n    if cnt >= 1:\n        if fn(cnt - 1) == False:\n            ans = True\n    if not ans and cnt >= 2:\n        if fn(cnt - 2) == False:\n            ans = True\n    return ans\nfor _ in range(nmbr()):\n    n = nmbr()\n    s = input()\n    cnt = sum((int(ch1 == ch2) for (ch1, ch2) in zip(s, s[1:])))\n    if fn(cnt):\n        print('JJ')\n    else:\n        print('Uttu')", "for i in range(int(input())):\n    n = int(input())\n    s = input()\n    a = [int(x) for x in s]\n    l = []\n    for i in range(1, n):\n        l.append(abs(a[i] - a[i - 1]))\n    z = 0\n    for i in range(n - 1):\n        if l[i] == 0:\n            z += 1\n    if z % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    ans = 0\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            ans += 1\n    if ans % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    c = 0\n    for j in range(n - 1):\n        if s[j] == s[j + 1]:\n            c += 1\n    print('JJ' if c % 3 else 'Uttu')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    seq = input()\n    c = 0\n    for i in range(n - 1):\n        if seq[i] == seq[i + 1]:\n            c += 1\n    print('JJ' if c % 3 else 'Uttu')", "for _ in range(int(input())):\n    n = int(input())\n    string = input()\n    c = 0\n    for i in range(n - 1):\n        if string[i] == string[i + 1]:\n            c += 1\n    if c % 3 != 0:\n        print('JJ')\n    else:\n        print('Uttu')", "for _ in range(int(input())):\n    n = int(input())\n    bs = input()\n    cnt = 0\n    for i in range(1, n):\n        if bs[i] == bs[i - 1]:\n            cnt += 1\n    if cnt % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    l = input()\n    c = 0\n    for k in range(1, n):\n        if l[k] == l[k - 1]:\n            c += 1\n    if c % 3 != 0:\n        print('JJ')\n    else:\n        print('Uttu')", "def cc(n, s):\n    cnt = 0\n    for i in range(1, n):\n        if int(s[i]) - int(s[i - 1]) == 0:\n            cnt += 1\n    if cnt % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    cc(n, s)", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().strip()))\n    d = []\n    for i in range(1, n):\n        d.append(abs(l[i] - l[i - 1]))\n    rem = n - 1 - sum(d)\n    if rem % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "for i in range(int(input())):\n    n = int(input())\n    s = str(input())\n    a = 0\n    for j in range(n - 1):\n        if s[j] == s[j + 1]:\n            a += 1\n    if a % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    a = 0\n    b = 0\n    one = 1\n    prev = -2\n    first = -1\n    for i in range(n):\n        if one:\n            if s[i] == '1':\n                one = 0\n            else:\n                if i - prev != 1:\n                    if first == -1:\n                        first = i\n                    a = a + 1\n                prev = i\n                one = 0\n        elif s[i] == '0':\n            one = 1\n        else:\n            if i - prev != 1:\n                if first == -1:\n                    first = i\n                a = a + 1\n            prev = i\n            one = 1\n    if first == 0:\n        if prev == n - 1:\n            b = a - 1\n        else:\n            b = a\n    elif prev == n - 1:\n        b = a\n    else:\n        b = a + 1\n    dp = [[0, 0] for i in range(min(a, b) + 1)]\n    dp[0][0] = -1\n    dp[0][1] = 0\n    for i in range(1, min(a, b) + 1):\n        dp[i][0] = not (dp[i - 1][0] and dp[i - 1][1])\n        dp[i][1] = not (dp[i][0] and dp[i - 1][1])\n    if dp[min(a, b)][max(a, b) - min(a, b)]:\n        print('JJ')\n    else:\n        print('Uttu')", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    change = n - 1\n    for i in range(n - 1):\n        if s[i + 1] != s[i]:\n            change -= 1\n    print('JJ' if change % 3 else 'Uttu')", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    s = list(map(int, list(input())))\n    f = 0\n    for i in range(n - 1):\n        f += abs(s[i] - s[i + 1])\n    n -= 1\n    if (n - f) % 3:\n        print('JJ')\n    else:\n        print('Uttu')", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    r = s.count('01') + s.count('10')\n    r = n - 1 - r\n    if r % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "def solve():\n    n = int(input())\n    s = input()\n    c = 0\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            c += 1\n    if c % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')\nT = int(input())\nfor i in range(T):\n    solve()", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = input()\n    d = []\n    for j in range(n - 1):\n        if a[j] == a[j + 1]:\n            d.append(0)\n        else:\n            d.append(1)\n    c = d.count(0)\n    if c % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = input()\n    d = []\n    if n == 1:\n        print('Uttu')\n        continue\n    for j in range(n - 1):\n        if a[j] == a[j + 1]:\n            d.append(0)\n        else:\n            d.append(1)\n    c = d.count(0)\n    if c % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    st = input()\n    s = 0\n    for i in range(n - 1):\n        s += abs(ord(st[i + 1]) - ord(st[i]))\n    rem = n - 1 - s\n    if rem % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    l = []\n    for i in range(n - 1):\n        l.append(abs(int(s[i + 1]) - int(s[i])))\n    x = l.count(0)\n    if x % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "for _ in range(int(input())):\n    n = int(input())\n    b = input()\n    L = b[0]\n    for i in range(1, n):\n        if b[i] != L[-1]:\n            L += b[i]\n    t = n - len(L)\n    if t % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    S = input()\n    dif = 0\n    for i in range(1, len(S)):\n        dif += abs(int(S[i]) - int(S[i - 1]))\n    dif = n - 1 - dif\n    if dif % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    cnt = sum((1 for i in range(n - 1) if s[i] == s[i + 1]))\n    print('Uttu' if not cnt % 3 else 'JJ')", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    c = 0\n    for i in range(1, n):\n        if s[i - 1] == s[i]:\n            c += 1\n    print('JJ' if c % 3 != 0 else 'Uttu')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    c = 0\n    for i in range(n - 1):\n        if s[i] != s[i + 1]:\n            c += 1\n    ans = n - 1 - c\n    if ans % 3 != 0:\n        print('JJ')\n    else:\n        print('Uttu')", "def main():\n    n = int(input())\n    bich = input()\n    LOL = bich[0]\n    for i in range(1, n):\n        if bich[i] != LOL[-1]:\n            LOL += bich[i]\n    fft = n - len(LOL)\n    if fft % 3 == 0:\n        return 'Uttu'\n    return 'JJ'\nfor _ in range(int(input())):\n    print(main())", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    S = input()\n    dif = 0\n    for i in range(1, len(S)):\n        dif += abs(int(S[i]) - int(S[i - 1]))\n    dif = n - 1 - dif\n    if dif % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "def fS(bins):\n    tot = 0\n    for i in range(0, len(bins) - 2):\n        tot += abs(int(bins[i + 1]) - int(bins[i]))\n    return tot\n\ndef isStop(bins):\n    for i in range(0, n - 1):\n        if bins[i] == bins[i + 1]:\n            return True\n    return False\nfor _ in range(int(input())):\n    n = int(input())\n    bin = input()\n    mcnt0 = 0\n    mcnt1 = 0\n    cnt0 = 0\n    cnt1 = 0\n    if bin[0] == '0':\n        cnt0 += 1\n    else:\n        cnt1 += 1\n    val = 0\n    c = bin[0]\n    for i in range(1, len(bin)):\n        val += abs(int(bin[i]) - int(bin[i - 1]))\n        if bin[i] == c:\n            if c == '0':\n                cnt0 += 1\n            else:\n                cnt1 += 1\n        else:\n            mcnt1 = max(mcnt1, cnt1)\n            mcnt0 = max(mcnt0, cnt0)\n            c = bin[i]\n            cnt0 = 0\n            cnt1 = 0\n            if c == '0':\n                cnt0 += 1\n            else:\n                cnt1 += 1\n    mcnt1 = max(mcnt1, cnt1)\n    mcnt0 = max(mcnt0, cnt0)\n    val = n - 1 - val\n    if val % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    S = input()\n    dif = 0\n    for i in range(1, len(S)):\n        dif += abs(int(S[i]) - int(S[i - 1]))\n    dif = n - 1 - dif\n    if dif % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "def f(count, t):\n    if count == 0:\n        return 0\n    elif L[count][t] != -1:\n        return L[count][t]\n    x = 0\n    if count >= 1:\n        x = x or not f(count - 1, not t)\n    if count >= 2:\n        x = x or not f(count - 2, not t)\n    L[count][t] = x\n    return x\nT = int(input())\nfor tc in range(T):\n    n = int(input())\n    s = input()\n    count = 0\n    for i in range(n - 1):\n        if s[i + 1] == s[i]:\n            count += 1\n    L = [[-1, -1] for i in range(n)]\n    if f(count, 0) == 1:\n        print('JJ')\n    else:\n        print('Uttu')", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nsys.setrecursionlimit(100000)\n\ndef solve():\n\n    def helper(a, b):\n        if not a:\n            return False\n        if dp[a][b] != -1:\n            return dp[a][b]\n        cur = not helper(a - 1, (b + 1) % 2)\n        if a >= 2:\n            cur = cur or not helper(a - 2, (b + 1) % 2)\n        dp[a][b] = cur\n        return cur\n    n = inp()\n    s = st()\n    dp = [[-1, -1] for i in range(n + 1)]\n    val = 0\n    for i in range(1, n):\n        val += s[i] == s[i - 1]\n    pr('JJ' if helper(val, 0) else 'Uttu')\nfor _ in range(inp()):\n    solve()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef fun(d, i, j):\n    if i <= 0:\n        return False\n    if d[i][j] != -1:\n        return d[i][j]\n    ans = False\n    if i >= 2:\n        ans |= not fun(d, i - 2, not j)\n    if i >= 1:\n        ans |= not fun(d, i - 1, not j)\n    d[i][j] = ans\n    return d[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    ans = 0\n    d = [[-1, -1] for i in range(n + 5)]\n    for i in range(n - 1):\n        if s[i + 1] == s[i]:\n            ans += 1\n    x = fun(d, ans, 0)\n    if x == True:\n        print('JJ')\n    else:\n        print('Uttu')", "def solve(val, flag, dp):\n    if val == 0:\n        return False\n    if dp[val][flag] != -1:\n        return dp[val][flag]\n    res = False\n    if val >= 1:\n        res = res or not solve(val - 1, not flag, dp)\n    if val >= 2:\n        res = res or not solve(val - 2, not flag, dp)\n    dp[val][flag] = res\n    return dp[val][flag]\nfor t in range(int(input())):\n    n = int(input())\n    s = input()\n    dp = [[-1 for i in range(2)] for j in range(n + 1)]\n    count = 0\n    for i in range(n - 1):\n        count += s[i] == s[i + 1]\n    if solve(count, 0, dp):\n        print('JJ')\n    else:\n        print('Uttu')", "def fn(v, p):\n    if v == 0:\n        return False\n    if d[v][p] != -1:\n        return d[v][p]\n    ans = False\n    if v >= 1:\n        ans = ans or not fn(v - 1, not p)\n    if v >= 2:\n        ans = ans or not fn(v - 2, not p)\n    d[v][p] = ans\n    return ans\nfor i in range(int(input())):\n    n = int(input())\n    s = input()\n    ans = 0\n    d = [[-1 for i in range(2)] for i in range(n)]\n    for i in range(n):\n        d[i][0] = d[i][1] = -1\n    for i in range(n - 1):\n        ans += s[i] == s[i + 1]\n    if fn(ans, 0):\n        print('JJ')\n    else:\n        print('Uttu')", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    a = s.count('10') + s.count('01')\n    r = n - 1 - a\n    if r % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    st = input().strip()\n    s = 0\n    for j in range(1, n):\n        if st[j] != st[j - 1]:\n            s += 1\n    if (n - 1 - s) % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    curr_sum = 0\n    prev = s[0]\n    for i in s[1:]:\n        if i != prev:\n            curr_sum += 1\n        prev = i\n    if (n - 1 - curr_sum) % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "T = int(input())\nfor i in range(T):\n    count = 0\n    N = int(input())\n    input_string = input()\n    for i in range(N - 1):\n        if input_string[i] + input_string[i + 1] == '00' or input_string[i] + input_string[i + 1] == '11':\n            count = count + 1\n    if count % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "def main():\n    n = int(input())\n    bich = input()\n    LOL = bich[0]\n    for i in range(1, n):\n        if bich[i] != LOL[-1]:\n            LOL += bich[i]\n    fft = n - len(LOL)\n    if fft % 3 == 0:\n        return 'Uttu'\n    return 'JJ'\nfor _ in range(int(input())):\n    print(main())", "def main():\n    n = int(input())\n    bich = input()\n    LOL = bich[0]\n    for i in range(1, n):\n        if bich[i] != LOL[-1]:\n            LOL += bich[i]\n    fft = n - len(LOL)\n    if fft % 3 == 0:\n        return 'Uttu'\n    return 'JJ'\nfor _ in range(int(input())):\n    print(main())", "import math\n\ndef swaps(data):\n    result = 0\n    for i in range(1, len(data)):\n        if data[i] != data[i - 1]:\n            result += 1\n    return result\n\ndef test(data):\n    max_swaps = len(data) - 1\n    cur_swaps = swaps(data)\n    available = max_swaps - cur_swaps\n    return available\nfor _ in range(int(input())):\n    _ = input()\n    data = input()\n    moves = test(data)\n    if moves % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "def main():\n    n = int(input())\n    s = input()\n    aux = s[0]\n    for i in range(1, n):\n        if s[i] != aux[-1]:\n            aux += s[i]\n    final = n - len(aux)\n    if final % 3 == 0:\n        return 'Uttu'\n    return 'JJ'\nfor _ in range(int(input())):\n    print(main())", "def main():\n    n = int(input())\n    s = input()\n    aux = s[0]\n    for i in range(1, n):\n        if s[i] != aux[-1]:\n            aux += s[i]\n    final = n - len(aux)\n    if final % 3 == 0:\n        return 'Uttu'\n    return 'JJ'\nfor _ in range(int(input())):\n    print(main())", "for _ in range(int(input())):\n    N = int(input())\n    B = list(map(int, input()))\n    f = sum([int(L != R) for (L, R) in zip(B[:-1], B[1:])])\n    pts_to_go = N - 1 - f\n    print({0: 'Uttu', 1: 'JJ', 2: 'JJ'}[pts_to_go % 3])", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    N = int(input())\n    A = input().strip()\n    count = 0\n    for i in range(1, len(A)):\n        if A[i] == A[i - 1]:\n            count += 1\n    print('Uttu' if count % 3 == 0 else 'JJ')", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    s = input().strip()\n    c = 0\n    for i in range(n - 1):\n        if s[i] != s[i + 1]:\n            c += 1\n    c = n - 1 - c\n    if c % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')\n    t -= 1", "T = int(input())\nfor i in range(T):\n    N = int(input())\n    S = list(str(input()))\n    flips = 0\n    cur = S[0]\n    for theta in range(1, N):\n        if S[theta] != cur:\n            flips += 1\n        cur = S[theta]\n    potential = N - 1 - flips\n    if potential % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "def divisors(M):\n    d = []\n    i = 1\n    while M >= i ** 2:\n        if M % i == 0:\n            d.append(i)\n            if i ** 2 != M:\n                d.append(M // i)\n        i = i + 1\n    return d\n\ndef popcount(x):\n    x = x - (x >> 1 & 1431655765)\n    x = (x & 858993459) + (x >> 2 & 858993459)\n    x = x + (x >> 4) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\n\ndef eratosthenes(n):\n    res = [0 for i in range(n + 1)]\n    prime = set([])\n    for i in range(2, n + 1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1, n // i + 1):\n                res[i * j] = 1\n    return prime\n\ndef factorization(n):\n    res = []\n    for p in prime:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            res.append(p)\n    if n != 1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2, n + 1):\n        if x ** 2 > n:\n            break\n        if n % x == 0:\n            res = res // x * (x - 1)\n            while n % x == 0:\n                n //= x\n    if n != 1:\n        res = res // n * (n - 1)\n    return res\n\ndef ind(b, n):\n    res = 0\n    while n % b == 0:\n        res += 1\n        n //= b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1:\n            continue\n        while y != n - 1:\n            y = y * y % n\n            if y == 1 or t == n - 1:\n                return 0\n            t <<= 1\n    return 1\n\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        (y, r, q, g) = (2, 1, 1, 1)\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g):\n                return g\n            elif isPrimeMR(n // g):\n                return n // g\n            return findFactorRho(g)\n\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i * i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k:\n            ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    (ret[n], n) = (1, 1)\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n    if n > 1:\n        ret[n] = 1\n    if rhoFlg:\n        ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p] + 1):\n                newres.append(d * p ** j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num == 0:\n        return 0\n    elif num == 1:\n        return 1\n    elif num == 2:\n        return 3\n    elif num == 3:\n        return 0\n    else:\n        x = baseorder(num)\n        return 2 ** x * ((num - 2 ** x + 1) % 2) + function(num - 2 ** x)\n\ndef xorconv(n, X, Y):\n    if n == 0:\n        res = [X[0] * Y[0] % mod]\n        return res\n    x = [X[i] + X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n    y = [Y[i] + Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n    z = [X[i] - X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n    w = [Y[i] - Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n    res1 = xorconv(n - 1, x, y)\n    res2 = xorconv(n - 1, z, w)\n    former = [(res1[i] + res2[i]) * inv for i in range(2 ** (n - 1))]\n    latter = [(res1[i] - res2[i]) * inv for i in range(2 ** (n - 1))]\n    former = list(map(lambda x: x % mod, former))\n    latter = list(map(lambda x: x % mod, latter))\n    return former + latter\n\ndef merge_sort(A, B):\n    (pos_A, pos_B) = (0, 0)\n    (n, m) = (len(A), len(B))\n    res = []\n    while pos_A < n and pos_B < m:\n        (a, b) = (A[pos_A], B[pos_B])\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize:\n\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x:\n            return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]] != stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy:\n            return\n        self.group -= 1\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind:\n\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self, v, pv):\n        stack = [(v, pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            (v, pv) = stack.pop()\n            self.parent[v] = new_parent\n            for (nv, w) in self.edge[v]:\n                if nv != pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv, v))\n\n    def unite(self, x, y, w):\n        if not self.flag:\n            return\n        if self.parent[x] == self.parent[y]:\n            self.flag = self.val[x] - self.val[y] == w\n            return\n        if self.size[self.parent[x]] > self.size[self.parent[y]]:\n            self.edge[x].append((y, -w))\n            self.edge[y].append((x, w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y, x)\n        else:\n            self.edge[x].append((y, -w))\n            self.edge[y].append((x, w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x, y)\n\nclass Dijkstra:\n\n    class Edge:\n\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10 ** 15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n        while len(que) != 0:\n            (cost, v) = heapq.heappop(que)\n            if d[v] < cost:\n                continue\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0] * N\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i + j < N and s[j] == s[i + j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i + k < N and k + Z_alg[k] < j:\n            Z_alg[i + k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT:\n\n    def __init__(self, n, mod=0):\n        self.BIT = [0] * (n + 1)\n        self.num = n\n        self.mod = mod\n\n    def query(self, idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx & -idx\n        return res_sum\n\n    def update(self, idx, x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx & -idx\n        return\n\nclass dancinglink:\n\n    def __init__(self, n, debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i - 1 for i in range(n)]\n        self._right = [i + 1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self, k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L != -1:\n            if R != self.n:\n                (self._right[L], self._left[R]) = (R, L)\n            else:\n                self._right[L] = self.n\n        elif R != self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self, idx, k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res == -1:\n                break\n            k -= 1\n        return res\n\n    def right(self, idx, k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res == self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable:\n\n    def __init__(self, A, merge_func, ide_ele):\n        N = len(A)\n        self.merge_func = merge_func\n        self.lg = [0] * (N + 1)\n        for i in range(2, N + 1):\n            self.lg[i] = self.lg[i >> 1] + 1\n        self.pow_2 = [pow(2, i) for i in range(20)]\n        self.table = [None] * (self.lg[N] + 1)\n        st0 = self.table[0] = [a for a in A]\n        b = 1\n        for i in range(self.lg[N]):\n            st0 = self.table[i + 1] = [self.merge_func(u, v) for (u, v) in zip(st0, st0[b:])]\n            b <<= 1\n\n    def query(self, s, t):\n        b = t - s + 1\n        m = self.lg[b]\n        return self.merge_func(self.table[m][s], self.table[m][t - self.pow_2[m] + 1])\n\nclass BinaryTrie:\n\n    class node:\n\n        def __init__(self, val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10 ** 15)\n\n    def append(self, key, val):\n        pos = self.root\n        for i in range(29, -1, -1):\n            pos.max = max(pos.max, val)\n            if key >> i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            elif pos.left is None:\n                pos.left = self.node(val)\n                pos = pos.left\n            else:\n                pos = pos.left\n        pos.max = max(pos.max, val)\n\n    def search(self, M, xor):\n        res = -10 ** 15\n        pos = self.root\n        for i in range(29, -1, -1):\n            if pos is None:\n                break\n            if M >> i & 1:\n                if xor >> i & 1:\n                    if pos.right:\n                        res = max(res, pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res, pos.left.max)\n                    pos = pos.right\n            elif xor >> i & 1:\n                pos = pos.right\n            else:\n                pos = pos.left\n        if pos:\n            res = max(res, pos.max)\n        return res\n\ndef solveequation(edge, ans, n, m):\n\n    def dfs(v):\n        used[v] = True\n        r = ans[v]\n        for (to, dire, id) in edge[v]:\n            if used[to]:\n                continue\n            y = dfs(to)\n            if dire == -1:\n                x[id] = y\n            else:\n                x[id] = -y\n            r += y\n        return r\n    x = [0] * m\n    used = [False] * n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y != 0:\n            return False\n    return x\n\nclass slope_trick:\n\n    def __init__(self):\n        self.L = [10 ** 17]\n        self.R = [10 ** 17]\n        self.min_f = 0\n        self.x_left = 0\n        self.x_right = 0\n\n    def add_right(self, a):\n        a -= self.x_left\n        l0 = -self.L[0]\n        self.min_f = self.min_f + max(0, l0 - a)\n        if l0 <= a:\n            a += self.x_left\n            a -= self.x_right\n            heappush(self.R, a)\n        else:\n            heappush(self.L, -a)\n            a = -heappop(self.L)\n            a += self.x_left\n            a -= self.x_right\n            heappush(self.R, a)\n\n    def add_left(self, a):\n        a -= self.x_right\n        r0 = self.R[0]\n        self.min_f = self.min_f + max(0, a - r0)\n        if a <= r0:\n            a += self.x_right\n            a -= self.x_left\n            heappush(self.L, -a)\n        else:\n            heappush(self.R, a)\n            a = heappop(self.R)\n            a += self.x_right\n            a -= self.x_left\n            heappush(self.L, -a)\n\n    def add_abs(self, a):\n        self.add_left(a)\n        self.add_right(a)\n\n    def change_min_slide(self, a, b):\n        self.x_left += a\n        self.x_right += b\n\n    def get_val(self, x):\n        L = [-l + self.x_left for l in self.L]\n        L.sort()\n        R = [r + self.x_right for r in self.R]\n        R.sort()\n        res = self.min_f\n        if 0 < L[-1]:\n            L = L[::-1]\n            n = len(L)\n            for i in range(n):\n                c0 = L[i]\n                c1 = L[i + 1]\n                if c1 <= x <= c0:\n                    res += (i + 1) * (c0 - x)\n                    break\n                else:\n                    res += (i + 1) * (c0 - c1)\n            return res\n        elif L[-1] <= x <= R[0]:\n            return res\n        else:\n            n = len(R)\n            for i in range(n):\n                c0 = R[i]\n                c1 = R[i + 1]\n                if c0 <= x <= c1:\n                    res += (i + 1) * (x - c0)\n                    break\n                else:\n                    res += (i + 1) * (c1 - c0)\n            return res\n\nclass SegmentTree:\n\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        self.size = n\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            k >>= 1\n            self.tree[k] = self.segfunc(self.tree[2 * k], self.tree[2 * k + 1])\n\n    def query(self, l, r):\n        if r == self.size:\n            r = self.num\n        res = self.ide_ele\n        l += self.num\n        r += self.num\n        right = []\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                right.append(self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        for e in right[::-1]:\n            res = self.segfunc(res, e)\n        return res\n\n    def bisect_l(self, l, r, x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l < r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin == -1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r - 1] <= x:\n                    Rmin = r - 1\n            l >>= 1\n            r >>= 1\n        if Lmin != -1:\n            pos = Lmin\n            while pos < self.num:\n                if self.tree[2 * pos] <= x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos + 1\n            return pos - self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos < self.num:\n                if self.tree[2 * pos] <= x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos + 1\n            return pos - self.num\n        else:\n            return -1\nimport sys, random, bisect\nfrom collections import deque, defaultdict\nfrom heapq import heapify, heappop, heappush\nfrom itertools import permutations\nfrom math import gcd, log\ninput = lambda : sys.stdin.readline().rstrip()\nmi = lambda : map(int, input().split())\nli = lambda : list(mi())\nori = '01' * 1000\nfor _ in range(int(input())):\n    N = int(input())\n    S = input()\n    A = [S[i] == ori[i] for i in range(N)]\n    k = 0\n    s = A[0]\n    for i in range(1, N):\n        if s == A[i]:\n            continue\n        else:\n            k += 1\n            s = A[i]\n    k += 1\n    if k % 3 == 1:\n        print('Uttu')\n    else:\n        print('JJ')", "for i in range(int(input())):\n    N = int(input())\n    s = str(input())\n    count = 0\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count = count + 1\n    if count % 3 == 0:\n        print('Uttu')\n    else:\n        print('JJ')", "tt = 1\ntt = int(input())\nfor _ in range(tt):\n    n = int(input())\n    s = input()\n    c = 0\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            c += 1\n    if c % 3:\n        print('JJ')\n    else:\n        print('Uttu')"]