["T = int(input())\nfor i in range(T):\n    (n, k) = map(int, input().split())\n    w = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    c = 0\n    s = []\n    for i in range(n):\n        s.append(w[i] + t[i])\n    s.sort()\n    for i in range(n):\n        if s[i] > k:\n            break\n        k -= s[i]\n        c += 1\n    if c != n:\n        for j in range(n):\n            if w[j] <= k:\n                if k + t[j] >= s[i] or w[j] + t[j] >= s[i]:\n                    c += 1\n                    break\n    print(c)", "t = int(input())\nwhile t:\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    T = list()\n    for i in range(0, N):\n        T.append((A[i] + B[i], i))\n    T.sort()\n    ans = 0\n    maxs = 0\n    for i in range(0, N):\n        if T[i][0] > K:\n            break\n        ans += 1\n        K -= T[i][0]\n    if ans != N:\n        for j in range(N):\n            if A[j] <= K and (B[j] + A[j] >= T[i][0] or K + B[j] >= T[i][0]):\n                ans += 1\n                break\n    print(ans)\n    t = t - 1", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    s = list()\n    for i in range(n):\n        s.append(A[i] + B[i])\n    s.sort()\n    m_p = 0\n    r = k\n    for i in range(n):\n        if s[i] > r:\n            break\n        r -= s[i]\n        m_p += 1\n    if m_p == n:\n        ans = m_p\n    else:\n        for j in range(n):\n            if A[j] <= r:\n                if A[j] + B[j] >= s[i] or r + B[j] - s[i] >= 0:\n                    m_p += 1\n                    break\n    print(m_p)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = []\n    for i in range(n):\n        c.append(a[i] + b[i])\n    c1 = c\n    c.sort()\n    count = 0\n    for i in range(n):\n        if c[i] > k:\n            break\n        k -= c[i]\n        count += 1\n    if count == n:\n        print(count)\n        continue\n    for j in range(n):\n        if a[j] <= k:\n            if a[j] + b[j] >= c[i] or k + b[j] - c[i] >= 0:\n                count += 1\n                break\n    print(count)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().split()))\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline()\nstdint = lambda : int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nmod = 1000000007\n\ndef solve(n, k, nums1, nums2):\n    new = [nums1[i] + nums2[i] for i in range(n)]\n    new.sort()\n    count = 0\n    for i in range(n):\n        if new[i] > k:\n            break\n        else:\n            count += 1\n            k -= new[i]\n    if count == n:\n        ans = count\n    else:\n        for j in range(len(nums1)):\n            if nums1[j] <= k and (nums1[j] + nums2[j] >= new[i] or k + nums2[j] >= new[i]):\n                count += 1\n                break\n    return count\ntried = int(input())\nfor _ in range(tried):\n    (n, k) = mul()\n    nums1 = seq()\n    nums2 = seq()\n    print(solve(n, k, nums1, nums2))", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().split()))\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline()\nstdint = lambda : int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nmod = 1000000007\n\ndef solve(n, k, nums1, nums2):\n    new = [nums1[i] + nums2[i] for i in range(n)]\n    new.sort()\n    count = 0\n    for i in range(n):\n        if new[i] > k:\n            break\n        else:\n            count += 1\n            k -= new[i]\n    if count == n:\n        ans = count\n    else:\n        for j in range(len(nums1)):\n            if nums1[j] <= k and (nums1[j] + nums2[j] >= new[i] or k + nums2[j] >= new[i]):\n                count += 1\n                break\n    return count\ntried = int(input())\nfor _ in range(tried):\n    (n, k) = mul()\n    nums1 = seq()\n    nums2 = seq()\n    print(solve(n, k, nums1, nums2))", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    s = list()\n    for i in range(n):\n        s.append(A[i] + B[i])\n    s.sort()\n    m_p = 0\n    r = k\n    for i in range(n):\n        if s[i] > r:\n            break\n        r -= s[i]\n        m_p += 1\n    if m_p == n:\n        ans = m_p\n    else:\n        for j in range(n):\n            if A[j] <= r:\n                if A[j] + B[j] >= s[i] or r + B[j] - s[i] >= 0:\n                    m_p += 1\n                    break\n    print(m_p)", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    c = []\n    for i in range(n):\n        c.append(x[i] + y[i])\n    c.sort()\n    cnt = 0\n    for j in range(n):\n        if c[j] <= k:\n            k -= c[j]\n            cnt += 1\n        else:\n            break\n    if cnt == n:\n        pass\n    else:\n        for e in range(n):\n            if x[e] <= k:\n                if x[e] + y[e] >= c[j] or y[e] + k >= c[j]:\n                    cnt += 1\n                    break\n    print(cnt)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    (A, B) = (list(t) for t in zip(*sorted(zip(A, B), key=lambda x: x[0] + x[1])))\n    (time, ans, maxB) = (0, 0, 0)\n    for i in range(N):\n        if time + A[i] <= K:\n            time += A[i] + B[i]\n            maxB = max(maxB, B[i])\n            ans += 1\n    if ans != N and time <= K and (time - maxB + A[ans] + B[ans] <= K):\n        ans += 1\n    print(ans)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    (A, B) = (list(t) for t in zip(*sorted(zip(A, B), key=lambda x: x[0] + x[1])))\n    (time, ans, maxB) = (0, 0, 0)\n    for i in range(N):\n        if time + A[i] <= K:\n            time += A[i] + B[i]\n            maxB = max(maxB, B[i])\n            ans += 1\n    if ans != N and time <= K and (time - maxB + A[ans] + B[ans] <= K):\n        ans += 1\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    s = list()\n    for i in range(n):\n        s.append(A[i] + B[i])\n    s.sort()\n    m_p = 0\n    r = k\n    for i in range(n):\n        if s[i] > r:\n            break\n        r -= s[i]\n        m_p += 1\n    if m_p == n:\n        ans = m_p\n    else:\n        for j in range(n):\n            if A[j] <= r:\n                if A[j] + B[j] >= s[i] or r + B[j] - s[i] >= 0:\n                    m_p += 1\n                    break\n    print(m_p)", "t = int(input())\nfor i in range(t):\n    (n, s) = map(int, input().split(' '))\n    a = input().split(' ')\n    b = input().split(' ')\n    c = []\n    for j in range(n):\n        c.append((int(a[j]), int(b[j]), int(a[j]) + int(b[j])))\n    c1 = sorted(c, key=lambda l: l[2])\n    add = True\n    k = 0\n    sum = 0\n    while add and k < n:\n        if sum + c1[k][2] <= s:\n            sum += c1[k][2]\n            k += 1\n        else:\n            add = False\n    if k == n:\n        print(n)\n    elif not add:\n        asm = sorted(c1[k:], key=lambda l: l[0])[0]\n        if asm[0] + sum <= s:\n            print(k + 1)\n        else:\n            for k1 in range(k):\n                if c1[k1][0] + sum - c1[k1][2] + c1[k][2] <= s:\n                    print(k + 1)\n                    break\n            else:\n                print(k)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = []\n    for i in range(n):\n        c.append(a[i] + b[i])\n    c.sort()\n    d = 0\n    for i in range(n):\n        if k < c[i]:\n            break\n        k -= c[i]\n        d += 1\n    if d != n:\n        for j in range(n):\n            if a[j] <= k and (a[j] + b[j] >= c[i] or k + b[j] >= c[i]):\n                d += 1\n                break\n    print(d)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = [x + y for (x, y) in zip(a, b)]\n    c.sort()\n    count = 0\n    for i in range(n):\n        if k < c[i]:\n            break\n        count += 1\n        k -= c[i]\n    if count == n:\n        pass\n    else:\n        for j in range(n):\n            if a[j] <= k:\n                if a[j] + b[j] >= c[i] or k + b[j] - c[i] >= 0:\n                    count += 1\n                    break\n    print(count)", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    s = list()\n    for i in range(n):\n        s.append(A[i] + B[i])\n    s.sort()\n    m_p = 0\n    r = k\n    for i in range(n):\n        if s[i] > r:\n            break\n        r -= s[i]\n        m_p += 1\n    if m_p == n:\n        ans = m_p\n    else:\n        for j in range(n):\n            if A[j] <= r:\n                if A[j] + B[j] >= s[i] or r + B[j] - s[i] >= 0:\n                    m_p += 1\n                    break\n    print(m_p)", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    s = list()\n    for i in range(n):\n        s.append(A[i] + B[i])\n    s.sort()\n    m_p = 0\n    r = k\n    for i in range(n):\n        if s[i] > r:\n            break\n        r -= s[i]\n        m_p += 1\n    if m_p == n:\n        ans = m_p\n    else:\n        for j in range(n):\n            if A[j] <= r:\n                if A[j] + B[j] >= s[i] or r + B[j] - s[i] >= 0:\n                    m_p += 1\n                    break\n    print(m_p)", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    s = list()\n    for i in range(n):\n        s.append(A[i] + B[i])\n    s.sort()\n    m_p = 0\n    r = k\n    for i in range(n):\n        if s[i] > r:\n            break\n        r -= s[i]\n        m_p += 1\n    if m_p == n:\n        ans = m_p\n    else:\n        for j in range(n):\n            if A[j] <= r:\n                if A[j] + B[j] >= s[i] or r + B[j] - s[i] >= 0:\n                    m_p += 1\n                    break\n    print(m_p)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    (A, B) = (list(t) for t in zip(*sorted(zip(A, B), key=lambda x: x[0] + x[1])))\n    (time, ans, maxB) = (0, 0, 0)\n    for i in range(N):\n        if time + A[i] <= K:\n            time += A[i] + B[i]\n            maxB = max(maxB, B[i])\n            ans += 1\n    if ans != N and time <= K and (time - maxB + A[ans] + B[ans] <= K):\n        ans += 1\n    print(ans)", "import queue\nimport math\ncase = int(input())\nfor _ in range(case):\n    (n, k) = map(int, input().split(' '))\n    arr = list(map(int, input().split(' ')))\n    brr = list(map(int, input().split(' ')))\n    nrr = []\n    for i in range(n):\n        nrr.append((arr[i] + brr[i], arr[i], brr[i]))\n    nrr.sort(key=lambda x: x[0])\n    res = 0\n    mx = 0\n    for i in range(n):\n        if k - nrr[i][0] >= 0:\n            res += 1\n            k -= nrr[i][0]\n            mx = max(mx, nrr[i][2])\n        else:\n            break\n    ans = res\n    if k == 0 or res == n:\n        print(res)\n        continue\n    else:\n        mini = math.inf\n        if nrr[i][0] <= k + mx:\n            ans += 1\n        while i < n:\n            mini = min(mini, nrr[i][1])\n            i += 1\n        if mini <= k:\n            res += 1\n        print(max(res, ans))\n        continue", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    (A, B) = (list(t) for t in zip(*sorted(zip(A, B), key=lambda x: x[0] + x[1])))\n    (time, ans, maxB) = (0, 0, 0)\n    for i in range(N):\n        if time + A[i] <= K:\n            time += A[i] + B[i]\n            maxB = max(maxB, B[i])\n            ans += 1\n    if ans != N and time <= K and (time - maxB + A[ans] + B[ans] <= K):\n        ans += 1\n    print(ans)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    (A, B) = (list(t) for t in zip(*sorted(zip(A, B), key=lambda x: x[0] + x[1])))\n    (time, ans, maxB) = (0, 0, 0)\n    for i in range(N):\n        if time + A[i] <= K:\n            time += A[i] + B[i]\n            maxB = max(maxB, B[i])\n            ans += 1\n    if ans != N and time <= K and (time - maxB + A[ans] + B[ans] <= K):\n        ans += 1\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    s = list()\n    for i in range(n):\n        s.append(A[i] + B[i])\n    s.sort()\n    m_p = 0\n    r = k\n    for i in range(n):\n        if s[i] > r:\n            break\n        r -= s[i]\n        m_p += 1\n    if m_p == n:\n        ans = m_p\n    else:\n        for j in range(n):\n            if A[j] <= r:\n                if r + B[j] - s[i] >= 0:\n                    m_p += 1\n                    break\n    print(m_p)", "import bisect\nimport math\nfor _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    assert len(a) == n\n    assert len(b) == n\n    c = [(x + y, x, y) for (x, y) in zip(a, b)]\n    c.sort()\n    tot_time = 0\n    num_max = 0\n    time_used = 0\n    done = False\n    over = False\n    for (z, x, y) in c:\n        if not over:\n            tot_time += z\n        if tot_time > k:\n            over = True\n            if time_used + x <= k:\n                print(num_max + 1)\n                done = True\n                break\n        else:\n            num_max += 1\n            time_used = tot_time\n    if done:\n        continue\n    if not over:\n        print(num_max)\n        continue\n    for (_, _, y) in c[:num_max]:\n        if tot_time - y <= k:\n            print(num_max + 1)\n            done = True\n            break\n    if not done:\n        print(num_max)\n    continue", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    s = list()\n    for i in range(n):\n        s.append(A[i] + B[i])\n    s.sort()\n    m_p = 0\n    r = k\n    for i in range(n):\n        if s[i] > r:\n            break\n        r -= s[i]\n        m_p += 1\n    if m_p == n:\n        ans = m_p\n    else:\n        for j in range(n):\n            if A[j] <= r:\n                if r + B[j] - s[i] >= 0:\n                    m_p += 1\n                    break\n    print(m_p)", "import sys, threading\nimport math\nfrom os import path\nfrom collections import deque, defaultdict, Counter\nfrom bisect import *\nfrom string import ascii_lowercase\nfrom functools import cmp_to_key\nfrom random import randint\nfrom heapq import *\nfrom array import array\nfrom types import GeneratorType\n\ndef readInts():\n    x = list(map(int, sys.stdin.readline().rstrip().split()))\n    return x[0] if len(x) == 1 else x\n\ndef readList(type=int):\n    x = sys.stdin.readline()\n    x = list(map(type, x.rstrip('\\n\\r').split()))\n    return x\n\ndef readStr():\n    x = sys.stdin.readline().rstrip('\\r\\n')\n    return x\nwrite = sys.stdout.write\nread = sys.stdin.readline\nMAXN = 1123456\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\nclass mydict:\n\n    def __init__(self, func=lambda : 0):\n        self.random = randint(0, 1 << 32)\n        self.default = func\n        self.dict = {}\n\n    def __getitem__(self, key):\n        mykey = self.random ^ key\n        if mykey not in self.dict:\n            self.dict[mykey] = self.default()\n        return self.dict[mykey]\n\n    def get(self, key, default):\n        mykey = self.random ^ key\n        if mykey not in self.dict:\n            return default\n        return self.dict[mykey]\n\n    def __setitem__(self, key, item):\n        mykey = self.random ^ key\n        self.dict[mykey] = item\n\n    def getkeys(self):\n        return [self.random ^ i for i in self.dict]\n\n    def __str__(self):\n        return f'{[(self.random ^ i, self.dict[i]) for i in self.dict]}'\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\ndef mod(n):\n    return n % 1000000007\n\ndef lower_bound(a, num):\n    l = 0\n    r = len(a) - 1\n    ans = -1\n    while l <= r:\n        mid = (l + r) // 2\n        if a[mid] <= num:\n            ans = mid\n            l = mid + 1\n        else:\n            r = mid - 1\n    return ans\n\ndef solve(t):\n    (n, k) = readInts()\n    ar = readList()\n    br = readList()\n    sar = []\n    for i in range(n):\n        sar.append((ar[i] + br[i], i))\n    sar.sort()\n    pref = []\n    sm = 0\n    for (num, ind) in sar:\n        sm += num\n        pref.append(sm)\n    ans = 0\n    for i in range(n):\n        taken = sar[i][1]\n        if ar[taken] > k:\n            continue\n        li = lower_bound(pref, k - ar[taken])\n        cur = 1\n        if li == -1:\n            ans = max(ans, cur)\n            continue\n        cur += li + 1\n        if i <= li:\n            cur -= 1\n            if li < len(sar) - 1 and pref[li] - sar[i][0] + sar[li + 1][0] <= k - ar[taken]:\n                cur += 1\n        ans = max(ans, cur)\n    print(ans)\n\ndef main():\n    t = 1\n    if path.exists('/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/input.txt'):\n        sys.stdin = open('/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/input.txt', 'r')\n        sys.stdout = open('/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/output.txt', 'w')\n    t = readInts()\n    for i in range(t):\n        solve(i + 1)\nmain()", "for i in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = []\n    for i in range(N):\n        C.append(A[i] + B[i])\n    C.sort()\n    count = 0\n    r = K\n    for i in range(N):\n        if C[i] > r:\n            break\n        r -= C[i]\n        count += 1\n    if count == N:\n        print(count)\n    else:\n        for j in range(N):\n            if A[j] <= r:\n                if A[j] + B[j] >= C[i] or r + B[j] - C[i] >= 0:\n                    count += 1\n                    break\n        print(count)", "import bisect\nimport math\nfor _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    assert len(a) == n\n    assert len(b) == n\n    c = [x + y for (x, y) in zip(a, b)]\n    c.sort()\n    tot_time = 0\n    prob_time = c[0]\n    d = [(tot_time, prob_time, 0)]\n    for i in range(n):\n        if c[i] != prob_time:\n            assert c[i] > prob_time\n            d.append((tot_time, c[i], i))\n            prob_time = c[i]\n        tot_time += prob_time\n    d.append((tot_time, math.inf, n))\n    max_probs = 0\n    for (aa, bb) in zip(a, b):\n        t0 = k - aa\n        if t0 < 0:\n            continue\n        t1 = k + bb\n        i0 = bisect.bisect_right(d, (t0, math.inf, math.inf))\n        i0 -= 1\n        assert i0 >= 0\n        if aa + bb >= d[i0][1]:\n            num_probs = d[i0][2] + (t0 - d[i0][0]) // d[i0][1] + 1\n        else:\n            i1 = bisect.bisect_right(d, (t1, math.inf, math.inf))\n            i1 -= 1\n            assert aa + bb < d[i1][1]\n            if d[i1][1] == math.inf:\n                num_probs = n\n            else:\n                num_probs = d[i1][2] + (t1 - d[i1][0]) // d[i1][1]\n        if num_probs > max_probs:\n            max_probs = num_probs\n    print(max_probs)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    s = []\n    for i in range(n):\n        s.append(a[i] + b[i])\n    s.sort()\n    count = 0\n    r = k\n    for i in range(n):\n        if s[i] > r:\n            break\n        r -= s[i]\n        count += 1\n    if count == n:\n        print(count)\n    else:\n        for j in range(n):\n            if a[j] <= r:\n                if a[j] + b[j] >= s[i] or r + b[j] - s[i] >= 0:\n                    count += 1\n                    break\n        print(count)", "t = int(input())\nfor _ in range(t):\n    (q, t) = map(int, input().split())\n    questions = [int(i) for i in input().split()]\n    time = [int(i) for i in input().split()]\n    d = {}\n    for j in range(len(questions)):\n        d[j] = [questions[j], time[j], questions[j] + time[j]]\n    d = dict(sorted(d.items(), key=lambda x: x[1][2]))\n    qs = 0\n    summ = 0\n    f = True\n    mn = float('inf')\n    mx_b = 0\n    key = 0\n    for (k, v) in d.items():\n        summ += v[2]\n        mx_b = max(mx_b, v[1])\n        if summ - mx_b <= t:\n            qs += 1\n        else:\n            summ -= v[2]\n    print(qs)", "t = int(input())\nfor _ in range(t):\n    (q, t) = map(int, input().split())\n    questions = [int(i) for i in input().split()]\n    time = [int(i) for i in input().split()]\n    d = {}\n    for j in range(len(questions)):\n        d[j] = [questions[j], time[j], questions[j] + time[j]]\n    d = dict(sorted(d.items(), key=lambda x: x[1][2]))\n    qs = 0\n    summ = 0\n    f = True\n    mn = float('inf')\n    mx_b = 0\n    key = 0\n    if len(questions) == 1:\n        if questions[0] <= t:\n            print(1)\n        else:\n            print(0)\n    else:\n        for (k, v) in d.items():\n            if f:\n                if summ + v[2] > t:\n                    f = False\n                    mn = min(mn, v[0])\n                    key = k\n                    continue\n                summ += v[2]\n                mx_b = max(mx_b, v[1])\n                qs += 1\n            else:\n                mn = min(mn, v[0])\n        if qs < q and (summ + mn <= t or summ - mx_b + d[key][2] <= t):\n            print(qs + 1)\n        else:\n            print(qs)", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    s = list()\n    for i in range(n):\n        s.append(A[i] + B[i])\n    s.sort()\n    m_p = 0\n    r = k\n    for i in range(n):\n        if s[i] > r:\n            break\n        r -= s[i]\n        m_p += 1\n    if m_p == n:\n        ans = m_p\n    else:\n        for j in range(n):\n            if A[j] <= r:\n                if A[j] + B[j] >= s[i] or r + B[j] - s[i] >= 0:\n                    m_p += 1\n                    break\n    print(m_p)", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    s = list()\n    for i in range(n):\n        s.append(A[i] + B[i])\n    s.sort()\n    m_p = 0\n    r = k\n    for i in range(n):\n        if s[i] > r:\n            break\n        r -= s[i]\n        m_p += 1\n    if m_p == n:\n        ans = m_p\n    else:\n        for j in range(n):\n            if A[j] <= r:\n                if A[j] + B[j] >= s[i]:\n                    m_p += 1\n                    break\n                elif r + B[j] - s[i] >= 0:\n                    m_p += 1\n                    break\n    print(m_p)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    v = [[i, j] for (i, j) in zip(a, b)]\n    v.sort(key=lambda x: (x[0] + x[1], -x[0]))\n    mb = 0\n    cur = 0\n    ans = 0\n    for i in range(n):\n        if cur + v[i][0] <= k:\n            ans += 1\n            cur += sum(v[i])\n            mb = max(mb, v[i][1])\n    if ans != n and cur <= k and (cur - mb + sum(v[ans]) <= k):\n        ans += 1\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    v = [[i, j] for (i, j) in zip(a, b)]\n    v.sort(key=lambda x: (x[0] + x[1], -x[0], -x[1]))\n    mb = 0\n    cur = 0\n    ans = 0\n    for i in range(n):\n        if cur + v[i][0] <= k:\n            ans += 1\n            cur += sum(v[i])\n            mb = max(mb, v[i][1])\n    if ans != n and cur <= k and (cur - mb + sum(v[ans]) <= k):\n        ans += 1\n    print(ans)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    (A, B) = (list(t) for t in zip(*sorted(zip(A, B), key=lambda x: x[0] + x[1])))\n    (time, ans, maxB) = (0, 0, 0)\n    for i in range(N):\n        if time + A[i] <= K:\n            time += A[i] + B[i]\n            maxB = max(maxB, B[i])\n            ans += 1\n    if ans != N and time <= K and (time - maxB + A[ans] + B[ans] <= K):\n        ans += 1\n    print(ans)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    (A, B) = (list(t) for t in zip(*sorted(zip(A, B), key=lambda x: x[0] + x[1])))\n    (time, ans, maxB) = (0, 0, 0)\n    for i in range(N):\n        if time + A[i] <= K:\n            time += A[i] + B[i]\n            maxB = max(maxB, B[i])\n            ans += 1\n    if ans != N and time <= K and (time - maxB + A[ans] + B[ans] <= K):\n        ans += 1\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    (a, b) = (list(t) for t in zip(*sorted(zip(a, b), key=lambda x: x[0] + x[1])))\n    (summ, count, maxb) = (0, 0, 0)\n    for i in range(n):\n        if summ + a[i] <= k:\n            summ += a[i] + b[i]\n            maxb = max(maxb, b[i])\n            count += 1\n    if count != n and summ <= k and (summ - maxb + a[count] + b[count] <= k):\n        count += 1\n    print(count)", "from queue import PriorityQueue\nfrom collections import Counter\nimport math\nimport bisect as bs\nfrom collections import deque\nop = int(input())\nfor _ in range(op):\n    n = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = []\n    for i in range(len(a)):\n        c.append([a[i] + b[i], a[i], b[i]])\n    c.sort()\n    co = 0\n    y = -1\n    k = n[1]\n    maxi = 0\n    d = Counter(a)\n    for i in range(len(c)):\n        if c[i][0] <= k:\n            co += 1\n            k -= c[i][0]\n            d[c[i][1]] -= 1\n            maxi = max(maxi, c[i][2])\n            if d[c[i][1]] == 0:\n                d.pop(c[i][1])\n        else:\n            y = i\n            break\n    if y == -1:\n        print(co)\n    else:\n        u = False\n        maxi += k\n        if c[y][0] <= maxi:\n            u = True\n            co += 1\n            d[c[y][1]] -= 1\n            if d[c[y][1]] == 0:\n                d.pop(c[y][1])\n            maxi -= c[y][0]\n            print(co)\n        if u == False:\n            w = 10 ** 18\n            for i in d:\n                w = min(w, i)\n            if w <= k:\n                print(co + 1)\n            else:\n                print(co)", "def fun(a):\n    return a[0] + a[1]\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    (a, b) = (list(t) for t in zip(*sorted(zip(a, b), key=fun)))\n    (cur_sum, c, mxb) = (0, 0, 0)\n    for i in range(n):\n        if cur_sum + a[i] <= k:\n            cur_sum += a[i] + b[i]\n            mxb = max(mxb, b[i])\n            c += 1\n    if c != n and cur_sum <= k and (cur_sum - mxb + a[c] + b[c] <= k):\n        c += 1\n    print(c)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    c = [(ai + bi, bi) for (ai, bi) in zip(a, b)]\n    c.sort()\n    (t, m, ans) = (0, 0, 0)\n    for i in range(n):\n        (t1, m1) = (t + c[i][0], max([m, c[i][1]]))\n        if t1 <= k + m1:\n            (t, m) = (t1, m1)\n            ans += 1\n    print(ans)", "for tcase in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ab = [(ai + bi, ai, bi) for (ai, bi) in zip(a, b)]\n    ab.sort()\n    (t0, m0, i, ans) = (0, 0, 0, 0)\n    for i in range(n):\n        (t1, m1) = (t0 + ab[i][0], max(m0, ab[i][2]))\n        if t1 <= k + m1:\n            (t0, m0) = (t1, m1)\n            ans += 1\n    print(ans)", "for tcase in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ab = [(ai + bi, ai, bi) for (ai, bi) in zip(a, b)]\n    ab.sort()\n    t = 0\n    m = 0\n    i = 0\n    ans = 0\n    for i in range(n):\n        if t + ab[i][0] <= k + max(m, ab[i][2]):\n            t += ab[i][0]\n            m = max(m, ab[i][2])\n            ans += 1\n    print(ans)", "def fun(a):\n    return a[0] + a[1]\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    (a, b) = (list(t) for t in zip(*sorted(zip(a, b), key=fun)))\n    (cur_sum, c, mxb) = (0, 0, 0)\n    for i in range(n):\n        if cur_sum + a[i] <= k:\n            cur_sum += a[i] + b[i]\n            mxb = max(mxb, b[i])\n            c += 1\n    if c != n and cur_sum <= k and (cur_sum - mxb + a[c] + b[c] <= k):\n        c += 1\n    print(c)", "T = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = [(A[i], B[i]) for i in range(N)]\n    C.sort(key=sum)\n    ans = 0\n    for i in range(N):\n        if sum(C[i]) <= K:\n            ans += 1\n            K -= sum(C[i])\n        else:\n            break\n    else:\n        print(ans)\n        continue\n    if min((x[0] for x in C[i:])) <= K:\n        ans += 1\n    elif i > 0:\n        m = min((sum(x) for x in C[i:]))\n        n = max((x[1] for x in C[:i]))\n        if n >= m - K:\n            ans += 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    xx = list()\n    for i in range(n):\n        xx.append([a[i] + b[i], a[i], b[i]])\n    xx = sorted(xx, key=lambda i: i[0])\n    mmax = 0\n    num = 0\n    for i in xx:\n        mmax = max(mmax, i[2])\n        if i[0] <= x:\n            x -= i[0]\n            num += 1\n        elif i[0] <= x + mmax:\n            num += 1\n            break\n    print(num)", "import math\nfrom collections import Counter\nfrom heapq import *\n\ndef li():\n    return list(map(int, input().split()))\n\ndef nt():\n    return int(input())\n\ndef st():\n    return input()\nyes = 'YES'\nno = 'NO'\neven = 'EVEN'\nodd = 'ODD'\nmod = 998244353\n\ndef prefix(L):\n    size = len(L)\n    for i in range(size - 1):\n        L[i + 1] = L[i] + L[i + 1]\n    return L\n\ndef exponentiation(bas, exp, mod):\n    t = 1\n    while exp > 0:\n        if exp % 2 != 0:\n            t = t * bas % mod\n        bas = bas * bas % mod\n        exp //= 2\n    return t % mod\n\ndef binlist(x):\n    L = [0] * 21\n    temp = bin(x)\n    temp = temp[2:]\n    x = len(temp)\n    indexL = []\n    for i in range(x - 1, -1, -1):\n        if temp[i] == '1':\n            L[x - i] = 1\n            indexL.append(x - i)\n    return L\n\ndef binlisttoint(L):\n    x = 0\n    for i in range(1, 21):\n        if L[i] == '1':\n            x += 2 ** (i - 1)\n    return x\nfor _ in range(int(input())):\n    (n, k) = li()\n    A = li()\n    B = li()\n    new = [[a + b, a, b] for (b, a) in zip(B, A)]\n    new.sort()\n    Q = []\n    ans = 0\n    res = 0\n    for (c, a, b) in new:\n        if c > k:\n            if a <= k:\n                res = max(res, ans + 1)\n                break\n            elif Q and k - Q[0] >= c:\n                res = max(res, ans + 1)\n                break\n        else:\n            ans += 1\n            heappush(Q, -b)\n            k -= c\n    print(max(ans, res))", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = []\n    for f in range(n):\n        l.append([a[f], b[f]])\n    l.sort(key=lambda x: (sum(x), x[0]))\n    mx = 0\n    su = 0\n    i = 0\n    while i < n:\n        if l[i][0] + l[i][1] + su <= m:\n            su += l[i][0] + l[i][1]\n            mx = max(mx, l[i][1])\n            i += 1\n        else:\n            break\n    x = [0] * n\n    for j in range(n - 1, -1, -1):\n        if j == n - 1:\n            x[j] = l[j][0]\n        else:\n            x[j] = min(x[j + 1], l[j][0])\n    ans = i\n    if i < n:\n        rem = m - su\n        if x[i] <= rem:\n            ans += 1\n        elif rem + mx >= l[i][0] + l[i][1]:\n            ans += 1\n    print(ans)", "import string\nfrom functools import lru_cache\nimport atexit, io\nimport sys\nfrom math import log2\nimport math\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right, insort\nfrom math import gcd\nfrom math import sqrt\nfrom collections import Counter, defaultdict\nfrom heapq import heappush, heappop, heapify\nimport heapq\n\nclass FenwickTree:\n\n    def __init__(self, n):\n        self.farr = [0] * (n + 1)\n\n    def prefixSum(self, idx):\n        s = 0\n        while idx > 0:\n            s += self.farr[idx]\n            idx -= idx & -idx\n        return s\n\n    def update(self, idx, val):\n        while idx < len(self.farr):\n            self.farr[idx] += val\n            idx += idx & -idx\n\n    def find(self, k):\n        curr = 0\n        ans = 0\n        prevSum = 0\n        for i in range(log2(n), -1, -1):\n            if self.farr[curr + (i << i)] + prevSum < k:\n                curr += 1 << i\n                prevSum += self.farr[curr]\n        return curr + 1\n\nclass Trie(object):\n\n    def __init__(self):\n        self.trie = {}\n\n    def insert(self, word):\n        t = self.trie\n        for c in word:\n            if c not in t:\n                t[c] = {}\n            t = t[c]\n        t['-'] = True\n\n    def search(self, word):\n        t = self.trie\n        for c in word:\n            if c not in t:\n                return False\n            t = t[c]\n        return '-' in t\n\n    def startsWith(self, prefix):\n        t = self.trie\n        for c in prefix:\n            if c not in t:\n                return False\n            t = t[c]\n        return True\n\n    def query(self, word):\n        ans = 0\n        t = self.trie\n        for i in word:\n            if i not in t:\n                break\n            ans += 1\n            t = t[i]\n        return ans\n\nclass FenvTree:\n\n    def __init__(self, arr):\n        arr.insert(0, 0)\n        self.farr = [0]\n        prefix = [0]\n        for i in arr[1:]:\n            prefix.append(prefix[-1] + i)\n        for i in range(1, len(arr)):\n            idash = i - (i & -i)\n            self.farr.append(prefix[i] - prefix[idash])\n\n    def query(self, l, r):\n        return self.prefixSum(r) - self.prefixSum(l - 1)\n\n    def prefixSum(self, idx):\n        s = 0\n        while idx > 0:\n            s += self.farr[idx]\n            idx -= idx & -idx\n        return s\n\n    def update(self, idx, val):\n        while idx < len(self.farr):\n            self.farr[idx] += val\n            idx += idx & -idx\n\nclass DSU:\n\n    def __init__(self, n):\n        self.parent = []\n        self.size = []\n        for i in range(n + 1):\n            self.parent.append(i)\n            self.size.append(1)\n\n    def union(self, u, v):\n        pu = self.findPar(u)\n        pv = self.findPar(v)\n        if pu == pv:\n            return\n        if self.size[pu] < self.size[pv]:\n            self.parent[pu] = pv\n            self.size[pv] += self.size[pu]\n        else:\n            self.parent[pv] = pu\n            self.size[pu] += self.size[pv]\n\n    def unionByRank(self, u, v):\n        pu = self.findPar(u)\n        pv = self.findPar(v)\n        if pu == pv:\n            return\n        if self.rank[pu] < self.rank[pv]:\n            self.parent[pu] = pv\n        elif self.rank[pv] < self.rank[pu]:\n            self.parent[pv] = pu\n        else:\n            self.parent[pu] = pv\n            self.rank[pv] += 1\n\n    def findPar(self, node):\n        if self.parent[node] == node:\n            return node\n        self.parent[node] = self.findPar(self.parent[node])\n        return self.parent[node]\n\nclass info:\n\n    def __init__(self, _open=0, _close=0, _full=0):\n        self.open = _open\n        self.close = _close\n        self.full = _full\n\nclass SGTree:\n\n    def __init__(self, n):\n        self.seg = [0 for _ in range(4 * n)]\n\n    def build(self, ind, low, high, arr):\n        if low == high:\n            self.seg[ind] = arr[low]\n            return\n        mid = (low + high) // 2\n        self.build(2 * ind + 1, low, mid, arr)\n        self.build(2 * ind + 2, mid + 1, high, arr)\n        self.seg[ind] = min(self.seg[2 * ind + 1], self.seg[2 * ind + 2])\n\n    def query(self, ind, low, high, l, r):\n        if r < low or l > high:\n            return sys.maxsize\n        if low <= l and r >= high:\n            return self.seg[ind]\n        mid = low + high >> 1\n        left = self.query(2 * ind + 1, 0, mid, l, r)\n        right = self.query(2 * ind + 2, mid + 1, high, l, r)\n        return min(left, right)\n\n    def update(self, ind, low, high, i, val):\n        if low == high:\n            self.seg = val\n            return\n        mid = low + high >> 1\n        if i <= mid:\n            self.update(2 * ind + 1, low, mid, i, val)\n        else:\n            self.update(2 * ind + 1, mid + 1, high, i, val)\n        self.seg[ind] = min(self.seg[2 * ind + 1], self.seg[2 * ind + 2])\n\ndef isPalindrome(s):\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef IntList():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef getInts():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef getStrs():\n    return sys.stdin.readline().strip()\n\ndef StrList():\n    list(sys.stdin.readline().strip())\n\ndef FloatList():\n    lis = input().split()\n    lis = list(map(float, lis))\n    return lis\n\ndef SieveOfEratosthenes(n, isPrime):\n    isPrime[0] = isPrime[1] = False\n    for i in range(2, n + 1):\n        isPrime[i] = True\n    p = 2\n    while p * p <= n:\n        if isPrime[p]:\n            i = p * p\n            while i <= n:\n                isPrime[i] = False\n                i += p\n        p += 1\n\ndef findPrimePair(n):\n    isPrime = [0] * (n + 1)\n    SieveOfEratosthenes(n, isPrime)\n    for i in range(0, n):\n        if isPrime[i] and isPrime[n - i]:\n            print(i, n - i)\n            return\n\ndef query(ind, low, high, l, r, seg):\n    if r < low or l > high:\n        return info()\n    if low <= l and r >= high:\n        return self.seg[ind]\n    mid = low + high >> 1\n    left = self.query(2 * ind + 1, 0, mid, l, r, seg)\n    right = self.query(2 * ind + 2, mid + 1, high, l, r, seg)\n    return merge(left, right)\n\ndef merge(left, right):\n    ans = info()\n    ans.full = left.full + right.full + min(left.open, right.close)\n    ans.open = left.open + right.open + min(left.open, right.close)\n    ans.close = left.close + right.close + min(left.open, right.close)\n    return ans\n\ndef build(ind, low, high, s, seg):\n    if low == high:\n        seg[ind] = info(s[low] == '(', s[low] == ')', 0)\n        return\n    mid = (low + high) // 2\n    build(2 * ind + 1, low, mid, s, seg)\n    build(2 * ind + 2, mid + 1, high, s, seg)\n    seg[ind] = merge(seg[2 * ind + 1], seg[2 * ind + 2])\n\ndef countN(lis):\n    ans = 0\n    cnt = 0\n    for i in range(len(lis) - 1, -1, -1):\n        if lis[i] == 0:\n            cnt += 1\n        else:\n            ans += cnt\n    return ans\n\nclass Pair:\n\n    def __init__(self, x, y, gcd):\n        self.x = x\n        self.y = y\n        self.gcd = gcd\n\ndef Euclidean(a, b):\n    if b == 0:\n        return Pair(1, 0, a)\n    dash = Euclidean(b, a % b)\n    return Pair(dash.y, dash.x - a // b * dash.y, dash.gcd)\n\ndef chineseRemainder(a1, n1, a2, n2):\n    p = Euclidean(n1, n2)\n    x = p.x\n    gcd = p.gcd\n    if (a1 - a2) % gcd:\n        return -1\n    k = (a1 - a2) // gcd\n    a = a1 - n1 * (k * x % n2 // gcd)\n    lcm = n1 * n2 // gcd\n    if a < 0:\n        a += lcm\n    return a\nmdd = 998244353\n\ndef ncr(n, k, md):\n    mod = 998244353\n    tab = [[0 for _ in range(k + 1)] for i in range(n + 1)]\n    for i in range(1, len(tab)):\n        tab[i][0] = 1\n    for i in range(1, len(tab)):\n        for j in range(1, min(i + 1, len(tab[0]))):\n            if i == 1 and j == 1:\n                tab[i][j] = 1\n            else:\n                tab[i][j] = (tab[i - 1][j] + tab[i - 1][j - 1]) % mod\n    return tab\n\ndef repeat(i, j, arr):\n    if i > j:\n        return\n    cnt1 = i\n    cnt2 = j\n    while cnt1 < cnt2:\n        (arr[cnt1], arr[cnt2]) = (arr[cnt2], arr[cnt1])\n        cnt1 += 1\n        cnt2 -= 1\n    if i - 1 >= 0:\n        ele = arr[i - 1]\n        if ele > 0:\n            s = int(sqrt(ele - 1)) + 1\n            first = s * s - ele\n            repeat(first, i - 1, arr)\n    return\nspf = []\n\ndef makeSeive(n):\n    for i in range(n + 1):\n        spf.append(i)\n\ndef seive(n):\n    s = int(sqrt(n + 1))\n    for i in range(2, s + 1):\n        if spf[i] == i:\n            for j in range(i * i, n + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = set()\n    while x != 1:\n        ret.add(spf[x])\n        x = x // spf[x]\n    return ret\n\ndef zFunc(patt, txt):\n    st = patt + '#' + txt\n    zArray = [0 for _ in range(len(st))]\n    l = 0\n    r = 0\n    for i in range(1, len(st)):\n        if r >= i:\n            zArray[i] = min(r - i + 1, zArray[i - l])\n        while i + zArray[i] < len(st) and st[zArray[i]] == st[zArray[i] + i]:\n            zArray[i] += 1\n        if zArray[i] + i - 1 > r:\n            l = i\n            r = i + zArray[i] - 1\n    return zArray.count(len(patt))\n\ndef kmp(txt, patt):\n    newString = patt + '#' + txt\n    freqCount = 0\n    freqArray = [0 for _ in range(len(newString))]\n    i = 1\n    length = 0\n    while i < len(newString):\n        if newString[i] == newString[length]:\n            length += 1\n            freqArray[i] = length\n            i += 1\n        elif length > 0:\n            length = freqArray[length - 1]\n        else:\n            freqArray[i] = 0\n            i += 1\n    for i in freqArray:\n        if i == len(patt):\n            freqCount += 1\n    return freqCount\n\ndef getLPS(s):\n    st = '@#' + '#'.join(s) + '#&'\n    c = 0\n    r = 0\n    lps = [0] * len(st)\n    for i in range(1, len(st) - 1):\n        mirror = c - (i - c)\n        if i < r and mirror >= 0:\n            lps[i] = min(lps[mirror], r - i)\n        while st[i + lps[i] + 1] == st[i - lps[i] - 1]:\n            lps[i] += 1\n        if i + lps[i] > r:\n            r = i + lps[i]\n            c = i\n    return max(lps)\nfact = [1 for _ in range(100002)]\nmod = 10 ** 9 + 7\n\ndef getFact(n):\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n\ndef getInv(word):\n    num = math.factorial(len(word))\n    for v in Counter(word).values():\n        num = num * pow(math.factorial(v), mod - 2, mod) % mod\n    return int(num) % (10 ** 9 + 7)\n\ndef subarrayXor(arr, n, m):\n    HashTable = defaultdict(bool)\n    HashTable[0] = 1\n    count = 0\n    curSum = 0\n    for i in arr:\n        curSum ^= i\n        if HashTable[curSum ^ m]:\n            count += HashTable[curSum ^ m]\n        HashTable[curSum] += 1\n    return count\n\ndef get2dPrefixSum(matrix, mid=0):\n    n = len(matrix)\n    m = len(matrix[0])\n    prefix = [[0 for _ in range(m + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n    return prefix\n\ndef get2dPrefixSumCnt(matrix, mid=0):\n    n = len(matrix)\n    m = len(matrix[0])\n    prefix = [[0 for _ in range(m + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n    return prefix\n\ndef getSumRange(r1, c1, r2, c2, prefix):\n    cnt = prefix[r2][c2] - prefix[r2][c1 - 1] - prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1]\n    return cnt\n\ndef getPrefix(arr):\n    prefix = [0]\n    for i in arr:\n        prefix.append(prefix[-1] + i)\n    return prefix\n\ndef getInv(arr):\n    cnt = 0\n    ans = []\n    for i in arr:\n        ind = bisect_right(ans, i)\n        cnt += len(ans) - ind\n        insort(ans, i)\n    return cnt\nM = 10 ** 5\n\ndef getFactors(x):\n    temp = []\n    k = 1\n    while k * k <= x:\n        if x % k == 0:\n            temp.append(k)\n            if k * k != x:\n                temp.append(x // k)\n        k += 1\n    return temp\n\ndef grayCode(n):\n    if not n:\n        return [0]\n    res = [0, 1]\n    for i in range(2, n + 1):\n        for j in range(len(res) - 1, -1, -1):\n            res.append(res[j] | 1 << i - 1)\n    return res\n\ndef threeSum(nums, target):\n    ans = -1\n    d = dict()\n    for (i, j) in enumerate(nums):\n        d[j] = i + 1\n    nums.sort()\n    for i in range(len(nums) - 2):\n        low = i + 1\n        high = len(nums) - 1\n        while low < high:\n            s = nums[i] + nums[low] + nums[high]\n            if s == target:\n                print(d[nums[low]], d[nums[high]], d[nums[i]])\n                return\n                low += 1\n                high -= 1\n            elif s < 0:\n                low = low + 1\n            else:\n                high -= 1\n    print('IMPOSSIBLE')\n    return\n\ndef FuckCF():\n    (n, k) = getInts()\n    lis1 = IntList()\n    lis2 = IntList()\n    temp = [[lis1[i], lis2[i]] for i in range(n)]\n    temp.sort(key=lambda x: (x[0] + x[1], x[0]))\n    cnt = 0\n    i = 0\n    s = 0\n    mx = 0\n    while i < n:\n        if temp[i][0] + temp[i][1] + s <= k:\n            s += temp[i][0] + temp[i][1]\n            mx = max(mx, temp[i][1])\n            i += 1\n        else:\n            break\n    mn = [0] * n\n    for j in range(n - 1, -1, -1):\n        if j == n - 1:\n            mn[j] = temp[j][0]\n        else:\n            mn[j] = min(mn[j + 1], temp[j][0])\n    ans = i\n    if i < n:\n        rem = k - s\n        if mn[i] <= rem:\n            ans += 1\n        elif rem + mx >= temp[i][0] + temp[i][1]:\n            ans += 1\n    print(ans)\nt = 1\nt = int(input())\nfor i in range(t):\n    FuckCF()", "t = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    xx = list()\n    for i in range(n):\n        xx.append([a[i] + b[i], a[i], b[i]])\n    xx = sorted(xx, key=lambda i: i[0])\n    mmax = 0\n    num = 0\n    for i in xx:\n        mmax = max(mmax, i[2])\n        if i[0] <= x:\n            x -= i[0]\n            num += 1\n        elif i[0] <= x + mmax:\n            num += 1\n            break\n    print(num)", "def cmp(a, b):\n    if a[0] + a[1] == b[0] + b[1]:\n        return a[0] < b[0]\n    else:\n        return a[0] + a[1] < b[0] + b[1]\n\ndef solve():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    m = [[a[i], b[i]] for i in range(n)]\n    m.sort(key=lambda x: (x[0] + x[1], x[0]))\n    mx = 0\n    sm = 0\n    i = 0\n    while i < n and m[i][0] + m[i][1] + sm <= k:\n        sm += m[i][0] + m[i][1]\n        mx = max(mx, m[i][1])\n        i += 1\n    mn = [0] * n\n    for j in range(n - 1, -1, -1):\n        if j == n - 1:\n            mn[j] = m[j][0]\n        else:\n            mn[j] = min(mn[j + 1], m[j][0])\n    ans = i\n    if i < n:\n        rem = k - sm\n        if mn[i] <= rem:\n            ans += 1\n        elif rem + mx >= m[i][0] + m[i][1]:\n            ans += 1\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    solve()", "def cmp(a, b):\n    if a[0] + a[1] == b[0] + b[1]:\n        return a[0] < b[0]\n    else:\n        return a[0] + a[1] < b[0] + b[1]\n\ndef solve():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    m = [[a[i], b[i]] for i in range(n)]\n    m.sort(key=lambda x: (x[0] + x[1], x[0]))\n    mx = 0\n    sm = 0\n    i = 0\n    while i < n:\n        if m[i][0] + m[i][1] + sm <= k:\n            sm += m[i][0] + m[i][1]\n            mx = max(mx, m[i][1])\n            i += 1\n        else:\n            break\n    mn = [0] * n\n    for j in range(n - 1, -1, -1):\n        if j == n - 1:\n            mn[j] = m[j][0]\n        else:\n            mn[j] = min(mn[j + 1], m[j][0])\n    ans = i\n    if i < n:\n        rem = k - sm\n        if mn[i] <= rem:\n            ans += 1\n        elif rem + mx >= m[i][0] + m[i][1]:\n            ans += 1\n    print(ans)\nt = int(input())\nfor i in range(t):\n    solve()", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ans = []\n    for i in range(n):\n        ans.append([a[i] + b[i], a[i]])\n    ans.sort()\n    res = 0\n    i = 0\n    last = -1\n    while i < n:\n        if ans[i][0] <= k:\n            res += 1\n            k -= ans[i][0]\n        else:\n            last = i\n            break\n        i += 1\n    aagya = 0\n    while i < n:\n        if ans[i][1] <= k:\n            k -= ans[i][1]\n            res += 1\n            aagya = 1\n            break\n        i += 1\n    if aagya == 0 and last != -1:\n        k -= ans[last][0]\n        for j in range(last - 1, -1, -1):\n            if k + ans[j][0] - ans[j][1] >= 0:\n                res += 1\n                break\n    print(res)", "def getSolution(n, k, a):\n    mx = 0\n    sum = 0\n    i = 0\n    while i < n:\n        if a[i][0] + a[i][1] + sum >= k:\n            break\n        else:\n            sum += a[i][0] + a[i][1]\n            mx = max(mx, a[i][1])\n            i += 1\n    temp = [0] * n\n    kk = n - 1\n    while kk >= 0:\n        if kk == n - 1:\n            temp[kk] = a[kk][0]\n        else:\n            temp[kk] = temp[kk + 1] if temp[kk + 1] <= a[kk][0] else a[kk][0]\n        kk -= 1\n    ans = i\n    if i < n:\n        rem = k - sum\n        if temp[i] <= rem:\n            ans += 1\n        elif rem + mx >= a[i][0] + a[i][1]:\n            ans += 1\n    return ans\n\ndef compare(a, b):\n    if a[0] + a[1] == b[0] + b[1]:\n        return a[0] < b[0]\n    return a[0] + a[1] < b[0] + b[1]\n\ndef c_p_c():\n    t = int(input())\n    for _ in range(t):\n        (n, k) = map(int, input().split())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        arr = [(a[i], b[i]) for i in range(n)]\n        arr.sort(key=lambda x: (x[0] + x[1], x[0]))\n        print(getSolution(n, k, arr))\nc_p_c()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    m = [[a[i], b[i]] for i in range(n)]\n    m.sort(key=lambda x: (x[0] + x[1], x[0]))\n    (mx, ans, total_sum, i) = (0, 0, 0, 0)\n    while i < n:\n        if m[i][0] + m[i][1] + total_sum <= k:\n            total_sum += m[i][0] + m[i][1]\n            mx = max(mx, m[i][1])\n            i += 1\n        else:\n            break\n    mn = [0] * n\n    for j in range(n - 1, -1, -1):\n        if j == n - 1:\n            mn[j] = m[j][0]\n        else:\n            mn[j] = min(mn[j + 1], m[j][0])\n    ans = i\n    if i < n:\n        rem = k - total_sum\n        if mn[i] <= rem:\n            ans += 1\n        elif rem + mx >= m[i][0] + m[i][1]:\n            ans += 1\n    print(ans)\n\ndef cmp(a, b):\n    if a[0] + a[1] != b[0] + b[1]:\n        return a[0] + a[1] < b[0] + b[1]\n    else:\n        return a[0] < b[0]", "def solve():\n    m = []\n    for i in range(n):\n        m.append([a[i], b[i]])\n    m.sort(key=lambda x: x[0] + x[1])\n    mx = 0\n    sum = 0\n    i = 0\n    while i < n:\n        if m[i][0] + m[i][1] + sum <= k:\n            sum += m[i][0] + m[i][1]\n            mx = max(mx, m[i][1])\n            i += 1\n        else:\n            break\n    ans = i\n    if i < n:\n        rem = k - sum\n        mn = float('inf')\n        for j in range(i, n):\n            mn = min(mn, m[j][0])\n        if mn <= rem:\n            ans += 1\n        elif rem + mx >= m[i][0] + m[i][1]:\n            ans += 1\n    return ans\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(solve())", "def solve_case():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    m = [[a[i], b[i]] for i in range(n)]\n\n    def key_func(x):\n        return (x[0] + x[1], x[0])\n    m.sort(key=key_func)\n    max_val = 0\n    sum_val = 0\n    index = 0\n    while index < n:\n        if m[index][0] + m[index][1] + sum_val <= k:\n            sum_val += m[index][0] + m[index][1]\n            max_val = max(max_val, m[index][1])\n            index += 1\n        else:\n            break\n    min_vals = [0] * n\n    for i in range(n - 1, -1, -1):\n        if i == n - 1:\n            min_vals[i] = m[i][0]\n        else:\n            min_vals[i] = min(min_vals[i + 1], m[i][0])\n    ans = index\n    if index < n:\n        rem = k - sum_val\n        if min_vals[index] <= rem:\n            ans += 1\n        elif rem + max_val >= m[index][0] + m[index][1]:\n            ans += 1\n    print(ans)\nt = int(input())\nfor case in range(t):\n    solve_case()", "def compare(a, b):\n    if a[0] + a[1] == b[0] + b[1]:\n        return a[0] < b[0]\n    else:\n        return a[0] + a[1] < b[0] + b[1]\n\ndef solve():\n    (n, k) = map(int, input().split())\n    first_list = list(map(int, input().split()))\n    second_list = list(map(int, input().split()))\n    list_of_lists = [[first_list[i], second_list[i]] for i in range(n)]\n    list_of_lists.sort(key=lambda x: (x[0] + x[1], x[0]))\n    (mx, sm, i) = (0, 0, 0)\n    while i < n:\n        if list_of_lists[i][0] + list_of_lists[i][1] + sm <= k:\n            sm += list_of_lists[i][0] + list_of_lists[i][1]\n            mx = max(mx, list_of_lists[i][1])\n            i += 1\n        else:\n            break\n    mn = [0] * n\n    for j in range(n - 1, -1, -1):\n        if j == n - 1:\n            mn[j] = list_of_lists[j][0]\n        else:\n            mn[j] = min(mn[j + 1], list_of_lists[j][0])\n    ans = i\n    if i < n:\n        rem = k - sm\n        if mn[i] <= rem:\n            ans += 1\n        elif rem + mx >= list_of_lists[i][0] + list_of_lists[i][1]:\n            ans += 1\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    solve()", "t = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    xx = list()\n    for i in range(n):\n        xx.append([a[i] + b[i], a[i], b[i]])\n    xx = sorted(xx, key=lambda i: i[0])\n    mmax = 0\n    num = 0\n    for i in xx:\n        mmax = max(mmax, i[2])\n        if i[0] <= x:\n            x -= i[0]\n            num += 1\n        elif i[0] <= x + mmax:\n            num += 1\n            break\n    print(num)", "import sys\nimport math\nimport heapq\n\ndef cmp(x, y):\n    if x[0] + x[1] == y[0] + y[1]:\n        return x[0] < y[0]\n    else:\n        return x[0] + x[1] < y[0] + y[1]\n\ndef solve():\n    (number, kon) = map(int, input().split())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    moon = []\n    for i in range(number):\n        moon.append([x[i], y[i]])\n    moon.sort(key=lambda h: (h[0] + h[1], h[0]))\n    mxxxx = 0\n    sour = 0\n    i = 0\n    while i < number and moon[i][0] + moon[i][1] + sour <= kon:\n        sour += moon[i][0] + moon[i][1]\n        mxxxx = max(mxxxx, moon[i][1])\n        i += 1\n    mnnnn = [0] * number\n    for j in range(number - 1, -1, -1):\n        if j == number - 1:\n            mnnnn[j] = moon[j][0]\n        else:\n            mnnnn[j] = min(mnnnn[j + 1], moon[j][0])\n    store = i\n    if i < number:\n        rem = kon - sour\n        if mnnnn[i] <= rem:\n            store += 1\n        elif rem + mxxxx >= moon[i][0] + moon[i][1]:\n            store += 1\n    print(store)\ntest = int(input())\nfor i in range(test):\n    solve()", "for _ in range(int(input())):\n    (n, t) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = [[a[i], b[i], a[i] + b[i]] for i in range(len(a))]\n    c.sort(key=lambda x: x[2])\n    i = 0\n    aux = []\n    while i < len(c) and t >= c[i][2]:\n        t -= c[i][2]\n        aux.append(c[i])\n        i += 1\n    aux.sort(key=lambda x: x[1])\n    j = len(aux) - 1\n    ans = i\n    while i < len(c):\n        if j >= 0:\n            if aux[j][0] + c[i][2] <= aux[j][2] + c[i][0]:\n                if t - (c[i][2] - aux[j][1]) >= 0:\n                    ans += 1\n                    t -= c[i][2] - aux[j][1]\n                    break\n                elif t >= c[i][0]:\n                    ans += 1\n                    break\n            elif t >= c[i][0]:\n                ans += 1\n                break\n        elif t >= c[i][0]:\n            ans += 1\n            break\n        i += 1\n    print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    tot = [[a[i] + b[i], a[i]] for i in range(n)]\n    s = set()\n    tot.sort()\n    ans = 0\n    fg = False\n    for i in range(n):\n        if tot[i][0] > k:\n            fg = True\n            break\n        ans += 1\n        k -= tot[i][0]\n        s.add(tot[i][0] - tot[i][1])\n    if k > 0 and fg:\n        mx = max(s) if len(s) else 0\n        for j in range(i, n):\n            if tot[j][1] <= k or tot[i][0] - k <= mx:\n                ans += 1\n                break\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    problems = list(map(int, input().split()))\n    breaks = list(map(int, input().split()))\n    mixed = sorted(zip(problems, breaks), key=lambda x: (x[0] + x[1], x[0]))\n    maxa = 0\n    suma = 0\n    i = 0\n    while i < n and suma + mixed[i][0] + mixed[i][1] <= k:\n        suma += mixed[i][0] + mixed[i][1]\n        maxa = max(maxa, mixed[i][1])\n        i += 1\n    mina = [0] * n\n    for j in range(n - 1, -1, -1):\n        if j == n - 1:\n            mina[j] = mixed[j][0]\n        else:\n            mina[j] = min(mina[j + 1], mixed[j][0])\n    questions = i\n    if i < n:\n        remains = k - suma\n        if mina[i] <= remains:\n            questions += 1\n        elif remains + maxa >= mixed[i][0] + mixed[i][1]:\n            questions += 1\n    print(questions)", "from bisect import bisect\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = []\n    pref = [0]\n    for i in range(n):\n        arr.append((a[i] + b[i], a[i]))\n    arr.sort(key=lambda x: (x[0], x[1]))\n    pref = [0]\n    idx = 0\n    ans = 0\n    anstmp = 0\n    for i in range(len(arr)):\n        pref.append(pref[-1] + arr[i][0])\n    for i in range(n):\n        lft = k - arr[i][1]\n        if lft >= 0:\n            ans = max(ans, 1)\n        idx = bisect(pref, lft) - 1\n        if idx - 1 >= i:\n            idx = bisect(pref, lft + arr[i][0]) - 1\n            idx -= 1\n            ans = max(ans, idx + 1)\n        else:\n            ans = max(ans, idx + 1)\n    for i in range(len(arr)):\n        if k - arr[i][0] < 0:\n            idx = i\n            break\n        else:\n            k -= arr[i][0]\n            anstmp += 1\n    ans = max(ans, anstmp)\n    print(ans)", "from sys import stdin, stdout\ninput = stdin.readline\nr_int = lambda : int(input())\nm_int = lambda : map(int, input().split())\nl_int = lambda : list(map(int, input().split()))\n\ndef solve():\n    (n, k) = m_int()\n    a = l_int()\n    b = l_int()\n    l = [(x + y, x, y) for (x, y) in zip(a, b)]\n    l.sort()\n    acc = 0\n    n_ex = 0\n    while n_ex < n and acc + l[n_ex][0] <= k:\n        acc += l[n_ex][0]\n        n_ex += 1\n    if n_ex == n:\n        print(n)\n        return\n    if acc + min((l[i][1] for i in range(n_ex, n))) <= k:\n        print(n_ex + 1)\n        return\n    if n_ex == 0:\n        print(0)\n        return\n    if acc + l[n_ex][0] - max((l[i][2] for i in range(n_ex))) <= k:\n        print(n_ex + 1)\n    else:\n        print(n_ex)\n\ndef main():\n    n_cases = r_int()\n    for _ in range(n_cases):\n        solve()\nmain()", "from sys import stdin\ninput = stdin.readline\n\ndef solve(N, K, A, B):\n    problem = sorted([(a + b, b, i) for (i, (a, b)) in enumerate(zip(A, B))])\n    seen = set()\n    answer = 0\n    count = 0\n    maxwait = 0\n    while answer < N:\n        if count + problem[answer][0] <= K:\n            count += problem[answer][0]\n            maxwait = max(maxwait, problem[answer][1])\n            seen.add(problem[answer][2])\n            answer += 1\n        else:\n            break\n    for i in range(N):\n        if i not in seen and (count + A[i] <= K or count + A[i] + B[i] - maxwait <= K):\n            answer += 1\n            break\n    return answer\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    (N, K) = [int(x) for x in input().strip().split()]\n    A = [int(x) for x in input().strip().split()]\n    B = [int(x) for x in input().strip().split()]\n    print(solve(N, K, A, B))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    A = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n    arr = [(A[x] + B[x], A[x]) for x in range(n)]\n    arr.sort()\n    ans = 0\n    pre = [0] * n\n    for i in range(n):\n        pre[i] = arr[i][0] + (pre[i - 1] if i > 0 else 0)\n        if pre[i] <= k:\n            ans = i + 1\n        if arr[i][1] <= k:\n            ans = max(ans, 1)\n    for i in range(n):\n        t = k - arr[i][1]\n        (l, h) = (i + 1, n - 1)\n        left = False\n        if i + 1 == n or pre[i + 1] - arr[i][0] > t:\n            (l, h) = (0, i - 1)\n            left = True\n        while l <= h:\n            mid = l + h >> 1\n            if left:\n                if pre[mid] <= t:\n                    ans = max(ans, mid + 2)\n                    l = mid + 1\n                else:\n                    h = mid - 1\n            elif pre[mid] - arr[i][0] <= t:\n                ans = max(ans, mid + 1)\n                l = mid + 1\n            else:\n                h = mid - 1\n    print(ans)", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = []\n    for i in range(n):\n        c.append((a[i] + b[i], a[i], b[i]))\n    c.sort()\n    ans = 0\n    pre = 0\n    from math import inf\n    maxf = 0\n    for i in range(n):\n        if pre + c[i][0] < k:\n            pre += c[i][0]\n            maxf = max(maxf, c[i][2])\n            ans = int(i + 1)\n        else:\n            temp = max(int(maxf), c[i][2])\n            if pre + c[i][0] - temp <= k:\n                ans += 1\n                break\n    print(ans)"]