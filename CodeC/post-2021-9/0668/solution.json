["from collections import Counter, defaultdict, deque\nimport itertools\nimport re\nimport math\nfrom functools import reduce\nimport operator\nimport bisect\nfrom heapq import *\nimport functools\nmod = 998244353\nimport sys\ninput = sys.stdin.readline\nimport typing\n\nclass SegTree:\n\n    def __init__(self, op: typing.Callable[[typing.Any, typing.Any], typing.Any], e: typing.Any, v: typing.Union[int, typing.List[typing.Any]]) -> None:\n        self._op = op\n        self._e = e\n        if isinstance(v, int):\n            v = [e] * v\n        self._n = len(v)\n        self._log = self._n.bit_length()\n        self._size = 1 << self._log\n        self._d = [e] * (2 * self._size)\n        for i in range(self._n):\n            self._d[self._size + i] = v[i]\n        for i in range(self._size - 1, 0, -1):\n            self._update(i)\n\n    def set(self, p: int, x: typing.Any) -> None:\n        assert 0 <= p < self._n\n        p += self._size\n        self._d[p] = x\n        for i in range(1, self._log + 1):\n            self._update(p >> i)\n\n    def get(self, p: int) -> typing.Any:\n        assert 0 <= p < self._n\n        return self._d[p + self._size]\n\n    def prod(self, left: int, right: int) -> typing.Any:\n        assert 0 <= left <= right <= self._n\n        sml = self._e\n        smr = self._e\n        left += self._size\n        right += self._size\n        while left < right:\n            if left & 1:\n                sml = self._op(sml, self._d[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                smr = self._op(self._d[right], smr)\n            left >>= 1\n            right >>= 1\n        return self._op(sml, smr)\n\n    def all_prod(self) -> typing.Any:\n        return self._d[1]\n\n    def max_right(self, left: int, f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= left <= self._n\n        assert f(self._e)\n        if left == self._n:\n            return self._n\n        left += self._size\n        sm = self._e\n        first = True\n        while first or left & -left != left:\n            first = False\n            while left % 2 == 0:\n                left >>= 1\n            if not f(self._op(sm, self._d[left])):\n                while left < self._size:\n                    left *= 2\n                    if f(self._op(sm, self._d[left])):\n                        sm = self._op(sm, self._d[left])\n                        left += 1\n                return left - self._size\n            sm = self._op(sm, self._d[left])\n            left += 1\n        return self._n\n\n    def min_left(self, right: int, f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= right <= self._n\n        assert f(self._e)\n        if right == 0:\n            return 0\n        right += self._size\n        sm = self._e\n        first = True\n        while first or right & -right != right:\n            first = False\n            right -= 1\n            while right > 1 and right % 2:\n                right >>= 1\n            if not f(self._op(self._d[right], sm)):\n                while right < self._size:\n                    right = 2 * right + 1\n                    if f(self._op(self._d[right], sm)):\n                        sm = self._op(self._d[right], sm)\n                        right -= 1\n                return right + 1 - self._size\n            sm = self._op(self._d[right], sm)\n        return 0\n\n    def _update(self, k: int) -> None:\n        self._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])\n\nclass SparseTable:\n\n    def __init__(self, v, op, e):\n        self.N = len(v)\n        self.op = op\n        self.e = e\n        self.lg = [self.e] * (self.N + 1)\n        for i in range(2, self.N + 1):\n            self.lg[i] = self.lg[i >> 1] + 1\n        self.pow_2 = [pow(2, i) for i in range(20)]\n        self.table = [None] * (self.lg[self.N] + 1)\n        st0 = self.table[0] = [a for a in v]\n        b = 1\n        for i in range(self.lg[self.N]):\n            st0 = self.table[i + 1] = [self.op(x, y) for (x, y) in zip(st0, st0[b:])]\n            b <<= 1\n\n    def prod(self, s, t):\n        if s == t:\n            return self.e\n        b = t - s\n        m = self.lg[b]\n        return self.op(self.table[m][s], self.table[m][t - self.pow_2[m]])\n\ndef op(x, y):\n    return math.gcd(x, y)\nfrom bisect import bisect_left, bisect_right, insort\nfrom typing import Generic, Iterable, Iterator, TypeVar, Union, List\nT = TypeVar('T')\n\nclass SortedMultiset(Generic[T]):\n    BUCKET_RATIO = 50\n    REBUILD_RATIO = 170\n\n    def _build(self, a=None) -> None:\n        if a is None:\n            a = list(self)\n        size = self.size = len(a)\n        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))\n        self.a = [a[size * i // bucket_size:size * (i + 1) // bucket_size] for i in range(bucket_size)]\n\n    def __init__(self, a: Iterable[T]=[]) -> None:\n        a = list(a)\n        if not all((a[i] <= a[i + 1] for i in range(len(a) - 1))):\n            a = sorted(a)\n        self._build(a)\n\n    def __iter__(self) -> Iterator[T]:\n        for i in self.a:\n            for j in i:\n                yield j\n\n    def __reversed__(self) -> Iterator[T]:\n        for i in reversed(self.a):\n            for j in reversed(i):\n                yield j\n\n    def __len__(self) -> int:\n        return self.size\n\n    def __repr__(self) -> str:\n        return 'SortedMultiset' + str(self.a)\n\n    def __str__(self) -> str:\n        s = str(list(self))\n        return '{' + s[1:len(s) - 1] + '}'\n\n    def _find_bucket(self, x: T) -> List[T]:\n        for a in self.a:\n            if x <= a[-1]:\n                return a\n        return a\n\n    def __contains__(self, x: T) -> bool:\n        if self.size == 0:\n            return False\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        return i != len(a) and a[i] == x\n\n    def count(self, x: T) -> int:\n        return self.index_right(x) - self.index(x)\n\n    def add(self, x: T) -> None:\n        if self.size == 0:\n            self.a = [[x]]\n            self.size = 1\n            return\n        a = self._find_bucket(x)\n        insort(a, x)\n        self.size += 1\n        if len(a) > len(self.a) * self.REBUILD_RATIO:\n            self._build()\n\n    def discard(self, x: T) -> bool:\n        if self.size == 0:\n            return False\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        if i == len(a) or a[i] != x:\n            return False\n        a.pop(i)\n        self.size -= 1\n        if len(a) == 0:\n            self._build()\n        return True\n\n    def lt(self, x: T) -> Union[T, None]:\n        for a in reversed(self.a):\n            if a[0] < x:\n                return a[bisect_left(a, x) - 1]\n\n    def le(self, x: T) -> Union[T, None]:\n        for a in reversed(self.a):\n            if a[0] <= x:\n                return a[bisect_right(a, x) - 1]\n\n    def gt(self, x: T) -> Union[T, None]:\n        for a in self.a:\n            if a[-1] > x:\n                return a[bisect_right(a, x)]\n\n    def ge(self, x: T) -> Union[T, None]:\n        for a in self.a:\n            if a[-1] >= x:\n                return a[bisect_left(a, x)]\n\n    def __getitem__(self, x: int) -> T:\n        if x < 0:\n            x += self.size\n        if x < 0:\n            raise IndexError\n        for a in self.a:\n            if x < len(a):\n                return a[x]\n            x -= len(a)\n        raise IndexError\n\n    def index(self, x: T) -> int:\n        ans = 0\n        for a in self.a:\n            if a[-1] >= x:\n                return ans + bisect_left(a, x)\n            ans += len(a)\n        return ans\n\n    def index_right(self, x: T) -> int:\n        ans = 0\n        for a in self.a:\n            if a[-1] > x:\n                return ans + bisect_right(a, x)\n            ans += len(a)\n        return ans\nINF = 1 << 31\nt = int(input())\n\ndef is_ok(x):\n    ms = SortedMultiset([(a[i] << 30) + i for i in range(x - 1)])\n    for i in range(n - x + 1):\n        ms.add((a[i + x - 1] << 30) + (i + x - 1))\n        (m1, mid1) = divmod(ms[-1], 1 << 30)\n        if m1 - math.gcd(st.prod(i, mid1), st.prod(mid1 + 1, i + x)) >= k:\n            return True\n        (m2, mid2) = divmod(ms[-2], 1 << 30)\n        if m2 - math.gcd(st.prod(i, mid2), st.prod(mid2 + 1, i + x)) >= k:\n            return True\n        ms.discard((a[i] << 30) + i)\n    return False\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    st = SparseTable(a, op, 0)\n    flg = 0\n    for i in range(n):\n        if a[i] - math.gcd(st.prod(0, i), st.prod(i + 1, n)) >= k:\n            flg = 1\n            break\n    if not flg:\n        print(-1)\n        continue\n    ok = n\n    ng = 1\n    while abs(ng - ok) > 1:\n        mid = (ng + ok) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    print(ok)", "from collections import Counter, defaultdict, deque\nimport itertools\nimport re\nimport math\nfrom functools import reduce\nimport operator\nimport bisect\nfrom heapq import *\nimport functools\nmod = 998244353\nimport sys\ninput = sys.stdin.readline\nimport typing\n\nclass SegTree:\n\n    def __init__(self, op: typing.Callable[[typing.Any, typing.Any], typing.Any], e: typing.Any, v: typing.Union[int, typing.List[typing.Any]]) -> None:\n        self._op = op\n        self._e = e\n        if isinstance(v, int):\n            v = [e] * v\n        self._n = len(v)\n        self._log = self._n.bit_length()\n        self._size = 1 << self._log\n        self._d = [e] * (2 * self._size)\n        for i in range(self._n):\n            self._d[self._size + i] = v[i]\n        for i in range(self._size - 1, 0, -1):\n            self._update(i)\n\n    def set(self, p: int, x: typing.Any) -> None:\n        assert 0 <= p < self._n\n        p += self._size\n        self._d[p] = x\n        for i in range(1, self._log + 1):\n            self._update(p >> i)\n\n    def get(self, p: int) -> typing.Any:\n        assert 0 <= p < self._n\n        return self._d[p + self._size]\n\n    def prod(self, left: int, right: int) -> typing.Any:\n        assert 0 <= left <= right <= self._n\n        sml = self._e\n        smr = self._e\n        left += self._size\n        right += self._size\n        while left < right:\n            if left & 1:\n                sml = self._op(sml, self._d[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                smr = self._op(self._d[right], smr)\n            left >>= 1\n            right >>= 1\n        return self._op(sml, smr)\n\n    def all_prod(self) -> typing.Any:\n        return self._d[1]\n\n    def max_right(self, left: int, f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= left <= self._n\n        assert f(self._e)\n        if left == self._n:\n            return self._n\n        left += self._size\n        sm = self._e\n        first = True\n        while first or left & -left != left:\n            first = False\n            while left % 2 == 0:\n                left >>= 1\n            if not f(self._op(sm, self._d[left])):\n                while left < self._size:\n                    left *= 2\n                    if f(self._op(sm, self._d[left])):\n                        sm = self._op(sm, self._d[left])\n                        left += 1\n                return left - self._size\n            sm = self._op(sm, self._d[left])\n            left += 1\n        return self._n\n\n    def min_left(self, right: int, f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= right <= self._n\n        assert f(self._e)\n        if right == 0:\n            return 0\n        right += self._size\n        sm = self._e\n        first = True\n        while first or right & -right != right:\n            first = False\n            right -= 1\n            while right > 1 and right % 2:\n                right >>= 1\n            if not f(self._op(self._d[right], sm)):\n                while right < self._size:\n                    right = 2 * right + 1\n                    if f(self._op(self._d[right], sm)):\n                        sm = self._op(self._d[right], sm)\n                        right -= 1\n                return right + 1 - self._size\n            sm = self._op(self._d[right], sm)\n        return 0\n\n    def _update(self, k: int) -> None:\n        self._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])\n\nclass SparseTable:\n\n    def __init__(self, v, op, e):\n        self.N = len(v)\n        self.op = op\n        self.e = e\n        self.lg = [self.e] * (self.N + 1)\n        for i in range(2, self.N + 1):\n            self.lg[i] = self.lg[i >> 1] + 1\n        self.pow_2 = [pow(2, i) for i in range(20)]\n        self.table = [None] * (self.lg[self.N] + 1)\n        st0 = self.table[0] = [a for a in v]\n        b = 1\n        for i in range(self.lg[self.N]):\n            st0 = self.table[i + 1] = [self.op(x, y) for (x, y) in zip(st0, st0[b:])]\n            b <<= 1\n\n    def prod(self, s, t):\n        if s == t:\n            return self.e\n        b = t - s\n        m = self.lg[b]\n        return self.op(self.table[m][s], self.table[m][t - self.pow_2[m]])\n\ndef op(x, y):\n    return math.gcd(x, y)\nfrom bisect import bisect_left, bisect_right, insort\nfrom typing import Generic, Iterable, Iterator, TypeVar, Union, List\nT = TypeVar('T')\n\nclass SortedMultiset(Generic[T]):\n    BUCKET_RATIO = 50\n    REBUILD_RATIO = 170\n\n    def _build(self, a=None) -> None:\n        if a is None:\n            a = list(self)\n        size = self.size = len(a)\n        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))\n        self.a = [a[size * i // bucket_size:size * (i + 1) // bucket_size] for i in range(bucket_size)]\n\n    def __init__(self, a: Iterable[T]=[]) -> None:\n        a = list(a)\n        if not all((a[i] <= a[i + 1] for i in range(len(a) - 1))):\n            a = sorted(a)\n        self._build(a)\n\n    def __iter__(self) -> Iterator[T]:\n        for i in self.a:\n            for j in i:\n                yield j\n\n    def __reversed__(self) -> Iterator[T]:\n        for i in reversed(self.a):\n            for j in reversed(i):\n                yield j\n\n    def __len__(self) -> int:\n        return self.size\n\n    def __repr__(self) -> str:\n        return 'SortedMultiset' + str(self.a)\n\n    def __str__(self) -> str:\n        s = str(list(self))\n        return '{' + s[1:len(s) - 1] + '}'\n\n    def _find_bucket(self, x: T) -> List[T]:\n        for a in self.a:\n            if x <= a[-1]:\n                return a\n        return a\n\n    def __contains__(self, x: T) -> bool:\n        if self.size == 0:\n            return False\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        return i != len(a) and a[i] == x\n\n    def count(self, x: T) -> int:\n        return self.index_right(x) - self.index(x)\n\n    def add(self, x: T) -> None:\n        if self.size == 0:\n            self.a = [[x]]\n            self.size = 1\n            return\n        a = self._find_bucket(x)\n        insort(a, x)\n        self.size += 1\n        if len(a) > len(self.a) * self.REBUILD_RATIO:\n            self._build()\n\n    def discard(self, x: T) -> bool:\n        if self.size == 0:\n            return False\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        if i == len(a) or a[i] != x:\n            return False\n        a.pop(i)\n        self.size -= 1\n        if len(a) == 0:\n            self._build()\n        return True\n\n    def lt(self, x: T) -> Union[T, None]:\n        for a in reversed(self.a):\n            if a[0] < x:\n                return a[bisect_left(a, x) - 1]\n\n    def le(self, x: T) -> Union[T, None]:\n        for a in reversed(self.a):\n            if a[0] <= x:\n                return a[bisect_right(a, x) - 1]\n\n    def gt(self, x: T) -> Union[T, None]:\n        for a in self.a:\n            if a[-1] > x:\n                return a[bisect_right(a, x)]\n\n    def ge(self, x: T) -> Union[T, None]:\n        for a in self.a:\n            if a[-1] >= x:\n                return a[bisect_left(a, x)]\n\n    def __getitem__(self, x: int) -> T:\n        if x < 0:\n            x += self.size\n        if x < 0:\n            raise IndexError\n        for a in self.a:\n            if x < len(a):\n                return a[x]\n            x -= len(a)\n        raise IndexError\n\n    def index(self, x: T) -> int:\n        ans = 0\n        for a in self.a:\n            if a[-1] >= x:\n                return ans + bisect_left(a, x)\n            ans += len(a)\n        return ans\n\n    def index_right(self, x: T) -> int:\n        ans = 0\n        for a in self.a:\n            if a[-1] > x:\n                return ans + bisect_right(a, x)\n            ans += len(a)\n        return ans\nINF = 1 << 31\nt = int(input())\n\ndef is_ok(x):\n    ms = SortedMultiset([(a[i] << 30) + i for i in range(x - 1)])\n    for i in range(n - x + 1):\n        ms.add((a[i + x - 1] << 30) + (i + x - 1))\n        (m1, mid1) = divmod(ms[-1], 1 << 30)\n        if m1 - math.gcd(st.prod(i, mid1), st.prod(mid1 + 1, i + x)) >= k:\n            return True\n        (m2, mid2) = divmod(ms[-2], 1 << 30)\n        if m2 - math.gcd(st.prod(i, mid2), st.prod(mid2 + 1, i + x)) >= k:\n            return True\n        ms.discard((a[i] << 30) + i)\n    return False\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    st = SparseTable(a, op, 0)\n    flg = 0\n    for i in range(n):\n        if a[i] - math.gcd(st.prod(0, i), st.prod(i + 1, n)) >= k:\n            flg = 1\n            break\n    if not flg:\n        print(-1)\n        continue\n    ok = n\n    ng = 1\n    while abs(ng - ok) > 1:\n        mid = (ng + ok) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    print(ok)", "from collections import Counter, defaultdict, deque\nimport itertools\nimport re\nimport math\nfrom functools import reduce\nimport operator\nimport bisect\nfrom heapq import *\nimport functools\nmod = 998244353\nimport sys\ninput = sys.stdin.readline\nimport typing\n\nclass SegTree:\n\n    def __init__(self, op: typing.Callable[[typing.Any, typing.Any], typing.Any], e: typing.Any, v: typing.Union[int, typing.List[typing.Any]]) -> None:\n        self._op = op\n        self._e = e\n        if isinstance(v, int):\n            v = [e] * v\n        self._n = len(v)\n        self._log = self._n.bit_length()\n        self._size = 1 << self._log\n        self._d = [e] * (2 * self._size)\n        for i in range(self._n):\n            self._d[self._size + i] = v[i]\n        for i in range(self._size - 1, 0, -1):\n            self._update(i)\n\n    def set(self, p: int, x: typing.Any) -> None:\n        assert 0 <= p < self._n\n        p += self._size\n        self._d[p] = x\n        for i in range(1, self._log + 1):\n            self._update(p >> i)\n\n    def get(self, p: int) -> typing.Any:\n        assert 0 <= p < self._n\n        return self._d[p + self._size]\n\n    def prod(self, left: int, right: int) -> typing.Any:\n        assert 0 <= left <= right <= self._n\n        sml = self._e\n        smr = self._e\n        left += self._size\n        right += self._size\n        while left < right:\n            if left & 1:\n                sml = self._op(sml, self._d[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                smr = self._op(self._d[right], smr)\n            left >>= 1\n            right >>= 1\n        return self._op(sml, smr)\n\n    def all_prod(self) -> typing.Any:\n        return self._d[1]\n\n    def max_right(self, left: int, f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= left <= self._n\n        assert f(self._e)\n        if left == self._n:\n            return self._n\n        left += self._size\n        sm = self._e\n        first = True\n        while first or left & -left != left:\n            first = False\n            while left % 2 == 0:\n                left >>= 1\n            if not f(self._op(sm, self._d[left])):\n                while left < self._size:\n                    left *= 2\n                    if f(self._op(sm, self._d[left])):\n                        sm = self._op(sm, self._d[left])\n                        left += 1\n                return left - self._size\n            sm = self._op(sm, self._d[left])\n            left += 1\n        return self._n\n\n    def min_left(self, right: int, f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= right <= self._n\n        assert f(self._e)\n        if right == 0:\n            return 0\n        right += self._size\n        sm = self._e\n        first = True\n        while first or right & -right != right:\n            first = False\n            right -= 1\n            while right > 1 and right % 2:\n                right >>= 1\n            if not f(self._op(self._d[right], sm)):\n                while right < self._size:\n                    right = 2 * right + 1\n                    if f(self._op(self._d[right], sm)):\n                        sm = self._op(self._d[right], sm)\n                        right -= 1\n                return right + 1 - self._size\n            sm = self._op(self._d[right], sm)\n        return 0\n\n    def _update(self, k: int) -> None:\n        self._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])\n\nclass SparseTable:\n\n    def __init__(self, v, op, e):\n        self.N = len(v)\n        self.op = op\n        self.e = e\n        self.lg = [self.e] * (self.N + 1)\n        for i in range(2, self.N + 1):\n            self.lg[i] = self.lg[i >> 1] + 1\n        self.pow_2 = [pow(2, i) for i in range(20)]\n        self.table = [None] * (self.lg[self.N] + 1)\n        st0 = self.table[0] = [a for a in v]\n        b = 1\n        for i in range(self.lg[self.N]):\n            st0 = self.table[i + 1] = [self.op(x, y) for (x, y) in zip(st0, st0[b:])]\n            b <<= 1\n\n    def prod(self, s, t):\n        if s == t:\n            return self.e\n        b = t - s\n        m = self.lg[b]\n        return self.op(self.table[m][s], self.table[m][t - self.pow_2[m]])\n\ndef op(x, y):\n    return math.gcd(x, y)\nfrom bisect import bisect_left, bisect_right, insort\nfrom typing import Generic, Iterable, Iterator, TypeVar, Union, List\nT = TypeVar('T')\n\nclass SortedMultiset(Generic[T]):\n    BUCKET_RATIO = 50\n    REBUILD_RATIO = 170\n\n    def _build(self, a=None) -> None:\n        if a is None:\n            a = list(self)\n        size = self.size = len(a)\n        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))\n        self.a = [a[size * i // bucket_size:size * (i + 1) // bucket_size] for i in range(bucket_size)]\n\n    def __init__(self, a: Iterable[T]=[]) -> None:\n        a = list(a)\n        if not all((a[i] <= a[i + 1] for i in range(len(a) - 1))):\n            a = sorted(a)\n        self._build(a)\n\n    def __iter__(self) -> Iterator[T]:\n        for i in self.a:\n            for j in i:\n                yield j\n\n    def __reversed__(self) -> Iterator[T]:\n        for i in reversed(self.a):\n            for j in reversed(i):\n                yield j\n\n    def __len__(self) -> int:\n        return self.size\n\n    def __repr__(self) -> str:\n        return 'SortedMultiset' + str(self.a)\n\n    def __str__(self) -> str:\n        s = str(list(self))\n        return '{' + s[1:len(s) - 1] + '}'\n\n    def _find_bucket(self, x: T) -> List[T]:\n        for a in self.a:\n            if x <= a[-1]:\n                return a\n        return a\n\n    def __contains__(self, x: T) -> bool:\n        if self.size == 0:\n            return False\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        return i != len(a) and a[i] == x\n\n    def count(self, x: T) -> int:\n        return self.index_right(x) - self.index(x)\n\n    def add(self, x: T) -> None:\n        if self.size == 0:\n            self.a = [[x]]\n            self.size = 1\n            return\n        a = self._find_bucket(x)\n        insort(a, x)\n        self.size += 1\n        if len(a) > len(self.a) * self.REBUILD_RATIO:\n            self._build()\n\n    def discard(self, x: T) -> bool:\n        if self.size == 0:\n            return False\n        a = self._find_bucket(x)\n        i = bisect_left(a, x)\n        if i == len(a) or a[i] != x:\n            return False\n        a.pop(i)\n        self.size -= 1\n        if len(a) == 0:\n            self._build()\n        return True\n\n    def lt(self, x: T) -> Union[T, None]:\n        for a in reversed(self.a):\n            if a[0] < x:\n                return a[bisect_left(a, x) - 1]\n\n    def le(self, x: T) -> Union[T, None]:\n        for a in reversed(self.a):\n            if a[0] <= x:\n                return a[bisect_right(a, x) - 1]\n\n    def gt(self, x: T) -> Union[T, None]:\n        for a in self.a:\n            if a[-1] > x:\n                return a[bisect_right(a, x)]\n\n    def ge(self, x: T) -> Union[T, None]:\n        for a in self.a:\n            if a[-1] >= x:\n                return a[bisect_left(a, x)]\n\n    def __getitem__(self, x: int) -> T:\n        if x < 0:\n            x += self.size\n        if x < 0:\n            raise IndexError\n        for a in self.a:\n            if x < len(a):\n                return a[x]\n            x -= len(a)\n        raise IndexError\n\n    def index(self, x: T) -> int:\n        ans = 0\n        for a in self.a:\n            if a[-1] >= x:\n                return ans + bisect_left(a, x)\n            ans += len(a)\n        return ans\n\n    def index_right(self, x: T) -> int:\n        ans = 0\n        for a in self.a:\n            if a[-1] > x:\n                return ans + bisect_right(a, x)\n            ans += len(a)\n        return ans\nINF = 1 << 31\nt = int(input())\n\ndef is_ok(x):\n    ms = SortedMultiset([(a[i] << 30) + i for i in range(x - 1)])\n    for i in range(n - x + 1):\n        ms.add((a[i + x - 1] << 30) + (i + x - 1))\n        (m1, mid1) = divmod(ms[-1], 1 << 30)\n        if m1 - math.gcd(st.prod(i, mid1), st.prod(mid1 + 1, i + x)) >= k:\n            return True\n        (m2, mid2) = divmod(ms[-2], 1 << 30)\n        if m2 - math.gcd(st.prod(i, mid2), st.prod(mid2 + 1, i + x)) >= k:\n            return True\n        ms.discard((a[i] << 30) + i)\n    return False\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    st = SparseTable(a, op, 0)\n    flg = 0\n    for i in range(n):\n        if a[i] - math.gcd(st.prod(0, i), st.prod(i + 1, n)) >= k:\n            flg = 1\n            break\n    if not flg:\n        print(-1)\n        continue\n    ok = n\n    ng = 1\n    while abs(ng - ok) > 1:\n        mid = (ng + ok) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    print(ok)"]