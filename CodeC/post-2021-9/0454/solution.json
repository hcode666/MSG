["cons = 1000000007\nT = int(input())\nfor i in range(T):\n\n    def p1(y, z, cons):\n        ans = 1\n        while z:\n            if z % 2 == 1:\n                ans = ans * y % cons\n            y = y * y % cons\n            z //= 2\n        return ans\n\n    def p2(x, y):\n        if y >= 30:\n            return p1(x, p1(2, y, cons - 1) + cons - 1, cons)\n        return p1(x, 1 << y, cons)\n        return int(' ')\n\n    def calc(a, x, b):\n        return (p1(p2(a, b), x, cons) - p1(a, x - 1, cons) + cons) % cons * a % cons * p1(a - 1, cons - 2, cons) % cons\n    (a, b) = map(int, input().split())\n    Sum = 1\n    for j in range(2, a):\n        if j * j > a:\n            break\n        c = 0\n        while a % j == 0:\n            c += 1\n            a //= j\n        if c != 0:\n            Sum = Sum * calc(j, c, b) % cons\n    if a != 1:\n        Sum = Sum * calc(a, 1, b) % 1000000007\n    print(Sum)", "cons = 1000000007\nT = int(input())\nfor i in range(T):\n\n    def p1(y, z, cons):\n        ans = 1\n        while z:\n            if z % 2 == 1:\n                ans = ans * y % cons\n            y = y * y % cons\n            z //= 2\n        return ans\n\n    def p2(x, y):\n        if y >= 30:\n            return p1(x, p1(2, y, cons - 1) + cons - 1, cons)\n        return p1(x, 1 << y, cons)\n        return int(' ')\n\n    def calc(a, x, b):\n        return (p1(p2(a, b), x, cons) - p1(a, x - 1, cons) + cons) % cons * a % cons * p1(a - 1, cons - 2, cons) % cons\n    (a, b) = map(int, input().split())\n    Sum = 1\n    for j in range(2, a):\n        if j * j > a:\n            break\n        c = 0\n        while a % j == 0:\n            c += 1\n            a //= j\n        if c != 0:\n            Sum = Sum * calc(j, c, b) % cons\n    if a != 1:\n        Sum = Sum * calc(a, 1, b) % 1000000007\n    print(Sum)", "import math\nPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989]\nlen_p = len(Primes)\nT = int(input())\nfor tc in range(T):\n    (N, K) = map(int, input().split(' '))\n    N_Kopie = N\n    if N == 1:\n        print(1)\n    else:\n        divid = [0 for _ in range(len_p)]\n        i = 0\n        while N > 1 and i < len_p:\n            if N % Primes[i] == 0:\n                divid[i] += 1\n                N = N // Primes[i]\n            else:\n                i += 1\n        primes_n = []\n        primes_factor = []\n        for i in range(len_p):\n            if divid[i] > 0:\n                primes_n.append(Primes[i])\n                primes_factor.append(divid[i])\n        if N > 1:\n            primes_n.append(N)\n            primes_factor.append(1)\n        total = 0\n        end_track = 0\n        total = N_Kopie\n        for track in range(len(primes_n)):\n            subc = pow(2, K, 10 ** 9 + 6)\n            subcbis = (primes_factor[track] * subc - primes_factor[track] + 1) % (10 ** 9 + 6)\n            reduced_f = pow(primes_n[track], subcbis, 10 ** 9 + 7)\n            upper = (reduced_f - 1) % (10 ** 9 + 7)\n            lower = pow(primes_n[track] - 1, 10 ** 9 + 5, 10 ** 9 + 7)\n            sum_power = upper * lower % (10 ** 9 + 7)\n            total *= sum_power\n            total = total % (10 ** 9 + 7)\n        print(total)", "import math\nPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989]\nlen_p = len(Primes)\nT = int(input())\nfor tc in range(T):\n    (N, K) = map(int, input().split(' '))\n    N_Kopie = N\n    if N == 1:\n        print(1)\n    else:\n        divid = [0 for _ in range(len_p)]\n        i = 0\n        while N > 1 and i < len_p:\n            if N % Primes[i] == 0:\n                divid[i] += 1\n                N = N // Primes[i]\n            else:\n                i += 1\n        primes_n = []\n        primes_factor = []\n        for i in range(len_p):\n            if divid[i] > 0:\n                primes_n.append(Primes[i])\n                primes_factor.append(divid[i])\n        if N > 1:\n            primes_n.append(N)\n            primes_factor.append(1)\n        total = 0\n        end_track = 0\n        total = N_Kopie\n        for track in range(len(primes_n)):\n            subc = pow(2, K, 10 ** 9 + 6)\n            subcbis = (primes_factor[track] * subc - primes_factor[track] + 1) % (10 ** 9 + 6)\n            reduced_f = pow(primes_n[track], subcbis, 10 ** 9 + 7)\n            upper = (reduced_f - 1) % (10 ** 9 + 7)\n            lower = pow(primes_n[track] - 1, 10 ** 9 + 5, 10 ** 9 + 7)\n            sum_power = upper * lower % (10 ** 9 + 7)\n            total *= sum_power\n            total = total % (10 ** 9 + 7)\n        print(total)", "import math\nPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989]\nlen_p = len(Primes)\nT = int(input())\nfor tc in range(T):\n    (N, K) = map(int, input().split(' '))\n    N_Kopie = N\n    if N == 1:\n        print(1)\n    else:\n        divid = [0 for _ in range(len_p)]\n        i = 0\n        while N > 1 and i < len_p:\n            if N % Primes[i] == 0:\n                divid[i] += 1\n                N = N // Primes[i]\n            else:\n                i += 1\n        primes_n = []\n        primes_factor = []\n        for i in range(len_p):\n            if divid[i] > 0:\n                primes_n.append(Primes[i])\n                primes_factor.append(divid[i])\n        if N > 1:\n            primes_n.append(N)\n            primes_factor.append(1)\n        total = 0\n        end_track = 0\n        total = N_Kopie\n        for track in range(len(primes_n)):\n            subc = pow(2, K, 10 ** 9 + 6)\n            subcbis = (primes_factor[track] * subc - primes_factor[track] + 1) % (10 ** 9 + 6)\n            reduced_f = pow(primes_n[track], subcbis, 10 ** 9 + 7)\n            upper = (reduced_f - 1) % (10 ** 9 + 7)\n            lower = pow(primes_n[track] - 1, 10 ** 9 + 5, 10 ** 9 + 7)\n            sum_power = upper * lower % (10 ** 9 + 7)\n            total *= sum_power\n            total = total % (10 ** 9 + 7)\n        print(total)", "import math\nPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989]\nlen_p = len(Primes)\nT = int(input())\nfor tc in range(T):\n    (N, K) = map(int, input().split(' '))\n    N_Kopie = N\n    if N == 1:\n        print(1)\n    else:\n        divid = [0 for _ in range(len_p)]\n        i = 0\n        while N > 1 and i < len_p:\n            if N % Primes[i] == 0:\n                divid[i] += 1\n                N = N // Primes[i]\n            else:\n                i += 1\n        primes_n = []\n        primes_factor = []\n        for i in range(len_p):\n            if divid[i] > 0:\n                primes_n.append(Primes[i])\n                primes_factor.append(divid[i])\n        if N > 1:\n            primes_n.append(N)\n            primes_factor.append(1)\n        total = 0\n        end_track = 0\n        total = N_Kopie\n        for track in range(len(primes_n)):\n            subc = pow(2, K, 10 ** 9 + 6)\n            subcbis = (primes_factor[track] * subc - primes_factor[track] + 1) % (10 ** 9 + 6)\n            reduced_f = pow(primes_n[track], subcbis, 10 ** 9 + 7)\n            upper = (reduced_f - 1) % (10 ** 9 + 7)\n            lower = pow(primes_n[track] - 1, 10 ** 9 + 5, 10 ** 9 + 7)\n            sum_power = upper * lower % (10 ** 9 + 7)\n            total *= sum_power\n            total = total % (10 ** 9 + 7)\n        print(total)", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    ans = 1\n    (n, k) = map(int, input().split())\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    ans = 1\n    (n, k) = map(int, input().split())\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    mod = int(1000000000.0 + 7)\n    ans = 1\n\n    def solve(p, a, k):\n        first = pow(p, a, mod)\n        ratio = p\n        terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n        res = first * (pow(ratio, terms, mod) - 1) % mod\n        res *= pow(ratio - 1, mod - 2, mod)\n        return res % mod\n    for i in range(2, N + 1):\n        if i ** 2 > N:\n            break\n        if N % i != 0:\n            continue\n        ct = 0\n        while N % i == 0:\n            N //= i\n            ct += 1\n        ans *= solve(i, ct, K)\n        ans %= mod\n    if N > 1:\n        ans *= solve(N, 1, K)\n        ans %= mod\n    print(ans)", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 1\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 1\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 1\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    ans = 1\n    (n, k) = map(int, input().split())\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    mod = int(1000000000.0 + 7)\n    ans = 1\n\n    def solve(p, a, k):\n        first = pow(p, a, mod)\n        ratio = p\n        terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n        res = first * (pow(ratio, terms, mod) - 1) % mod\n        res *= pow(ratio - 1, mod - 2, mod)\n        return res % mod\n    for i in range(2, N + 1):\n        if i ** 2 > N:\n            break\n        if N % i != 0:\n            continue\n        ct = 0\n        while N % i == 0:\n            N //= i\n            ct += 1\n        ans *= solve(i, ct, K)\n        ans %= mod\n    if N > 1:\n        ans *= solve(N, 1, K)\n        ans %= mod\n    print(ans)", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    ans = 1\n    (n, k) = map(int, input().split())\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    ans = 1\n    (n, k) = map(int, input().split())\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    ans = 1\n    (n, k) = map(int, input().split())\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "MOD = 10 ** 9 + 7\n\ndef solve(p, a, k):\n    first = pow(p, a, MOD)\n    terms = (pow(2, k, MOD - 1) * a - a + 1) % (MOD - 1)\n    res = first * (pow(p, terms, MOD) - 1) % MOD\n    res = res * pow(p - 1, MOD - 2, MOD) % MOD\n    return res\nfor t in range(int(input())):\n    ans = 1\n    (N, K) = map(int, input().split())\n    for i in range(2, N + 1):\n        if i * i > N:\n            break\n        if N % i != 0:\n            continue\n        cnt = 0\n        while N % i == 0:\n            N //= i\n            cnt += 1\n        ans = ans * solve(i, cnt, K) % MOD\n    if N > 1:\n        ans = ans * solve(N, 1, K) % MOD\n    print(ans)", "MOD = 10 ** 9 + 7\n\ndef solve(p, a, k):\n    first = pow(p, a, MOD)\n    terms = (pow(2, k, MOD - 1) * a - a + 1) % (MOD - 1)\n    res = first * (pow(p, terms, MOD) - 1) % MOD\n    res = res * pow(p - 1, MOD - 2, MOD) % MOD\n    return res\nfor t in range(int(input())):\n    ans = 1\n    (N, K) = map(int, input().split())\n    for i in range(2, N + 1):\n        if i * i > N:\n            break\n        if N % i != 0:\n            continue\n        cnt = 0\n        while N % i == 0:\n            N //= i\n            cnt += 1\n        ans = ans * solve(i, cnt, K) % MOD\n    if N > 1:\n        ans = ans * solve(N, 1, K) % MOD\n    print(ans)", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    ans = 1\n    (n, k) = map(int, input().split())\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "from collections import Counter\n\ndef U(n, p):\n    x = 0\n    while n % p == 0:\n        n = int(n / p)\n        x += 1\n    return x\n\ndef T(N):\n    d = 2\n    A = []\n    while N > 1:\n        while N % d == 0:\n            A.append(d)\n            N /= d\n        d += 1\n        if d * d > N:\n            if N > 1:\n                A.append(N)\n            break\n    return A\na = int(input())\nfor i in range(a):\n    (N, K) = map(int, input().split())\n    n = int(10 ** 9 + 7)\n    B = Counter(T(N))\n    x = 1\n    for p in B.keys():\n        y = pow(int(p), int(B[p]), n)\n        g = (int(B[p]) * pow(2, K, n - 1) - int(B[p]) + n) % (n - 1)\n        z = (pow(int(p), g, n) - 1 + n) * pow(int(p) - 1, n - 2, n) % n\n        m = y * z % n\n        x *= m\n        x %= n\n    print(int(x))", "from collections import Counter\n\ndef U(n, p):\n    x = 0\n    while n % p == 0:\n        n = int(n / p)\n        x += 1\n    return x\n\ndef T(N):\n    d = 2\n    A = []\n    while N > 1:\n        while N % d == 0:\n            A.append(d)\n            N /= d\n        d += 1\n        if d * d > N:\n            if N > 1:\n                A.append(N)\n            break\n    return A\na = int(input())\nfor i in range(a):\n    (N, K) = map(int, input().split())\n    n = int(10 ** 9 + 7)\n    B = Counter(T(N))\n    x = 1\n    for p in B.keys():\n        y = pow(int(p), int(B[p]), n)\n        g = (int(B[p]) * pow(2, K, n - 1) - int(B[p]) + n) % (n - 1)\n        z = (pow(int(p), g, n) - 1 + n) * pow(int(p) - 1, n - 2, n) % n\n        m = y * z % n\n        x *= m\n        x %= n\n    print(int(x))", "from collections import Counter\n\ndef U(n, p):\n    x = 0\n    while n % p == 0:\n        n = int(n / p)\n        x += 1\n    return x\n\ndef T(N):\n    d = 2\n    A = []\n    while N > 1:\n        while N % d == 0:\n            A.append(d)\n            N /= d\n        d += 1\n        if d * d > N:\n            if N > 1:\n                A.append(N)\n            break\n    return A\na = int(input())\nfor i in range(a):\n    (N, K) = map(int, input().split())\n    n = int(10 ** 9 + 7)\n    B = Counter(T(N))\n    x = 1\n    for p in B.keys():\n        y = pow(int(p), int(B[p]), n)\n        g = (int(B[p]) * pow(2, K, n - 1) - int(B[p]) + n) % (n - 1)\n        z = (pow(int(p), g, n) - 1 + n) * pow(int(p) - 1, n - 2, n) % n\n        m = y * z % n\n        x *= m\n        x %= n\n    print(int(x))", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    ans = 1\n    (n, k) = map(int, input().split())\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "mod = int(10 ** 9 + 7)\n\ndef solve(p, a, k):\n    first = pow(p, a, mod)\n    ratio = p\n    terms = (pow(2, k, mod - 1) * a - a + 1) % (mod - 1)\n    res = first * (pow(ratio, terms, mod) - 1) % mod\n    res *= pow(ratio - 1, mod - 2, mod)\n    return res % mod\nfor _ in range(int(input())):\n    ans = 1\n    (n, k) = map(int, input().split())\n    for i in range(2, n + 1):\n        if i * i > n:\n            break\n        if n % i != 0:\n            continue\n        ct = 0\n        while n % i == 0:\n            n //= i\n            ct += 1\n        ans *= solve(i, ct, k)\n        ans %= mod\n    if n > 1:\n        ans *= solve(n, 1, k)\n        ans %= mod\n    print(ans)", "md1 = 1000000007\nfor i in range(int(input())):\n\n    def powr1(l1, q1, md1):\n        z1 = 1\n        while q1:\n            if q1 % 2 == 1:\n                z1 = z1 * l1 % md1\n            l1 = l1 * l1 % md1\n            q1 //= 2\n        return z1\n\n    def apop11(a1, l1):\n        if l1 >= 30:\n            return powr1(a1, powr1(2, l1, md1 - 1) + md1 - 1, md1)\n        return powr1(a1, 1 << l1, md1)\n        return int(' ')\n\n    def calci1(q1, p1, k1):\n        return (powr1(apop11(q1, k1), p1, md1) - powr1(q1, p1 - 1, md1) + md1) % md1 * q1 % md1 * powr1(q1 - 1, md1 - 2, md1) % md1\n    (q1, y1) = map(int, input().split())\n    apstj1 = 1\n    for i in range(2, q1):\n        if i * i > q1:\n            break\n        s1 = 0\n        while q1 % i == 0:\n            s1 += 1\n            q1 //= i\n        if s1 != 0:\n            apstj1 = apstj1 * calci1(i, s1, y1) % md1\n    if q1 != 1:\n        apstj1 = apstj1 * calci1(q1, 1, y1) % md1\n    print(apstj1)", "x = 1000000007\n\ndef power(b, n, m):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % m\n        b = b * b % m\n        n = int(n / 2)\n    return s\n\ndef apower(a, b):\n    if b >= 30:\n        return power(a, power(2, b, x - 1) + x - 1, x)\n    return power(a, 1 << b, x)\n\ndef cal(n, p, k):\n    return (power(apower(n, k), p, x) - power(n, p - 1, x) + x) % x * n % x * power(n - 1, x - 2, x) % x\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 1\n    i = 2\n    while i * i <= n:\n        s = 0\n        while n % i == 0:\n            s += 1\n            n = int(n / i)\n        if s != 0:\n            ans = ans * cal(i, s, k) % x\n        i += 1\n    if n != 1:\n        ans = ans * cal(n, 1, k) % x\n    print(ans)", "mod = 1000000007\n\ndef power(a, n, MOD):\n    p = 1\n    while n:\n        if n % 2 == 1:\n            p = p * a % MOD\n        a = a * a % MOD\n        n //= 2\n    return p\n\ndef powerT(a, b):\n    x = power(2, b, mod - 1)\n    if b >= 30:\n        return power(a, x + mod - 1, mod)\n    return power(a, 1 << b, mod)\n\ndef ans(n, p, k):\n    x = powerT(n, k)\n    y = power(n, p - 1, mod)\n    z = power(n - 1, mod - 2, mod)\n    result = power(x, p, mod)\n    return (result - y + mod) % mod * n % mod * z % mod\nfor l in range(int(input())):\n    (n, k) = map(int, input().split())\n    finalAns = 1\n    i = 2\n    while i * i <= n:\n        p = 0\n        while n % i == 0:\n            p += 1\n            n //= i\n        if p != 0:\n            finalAns = finalAns * ans(i, p, k) % mod\n        i += 1\n    if n != 1:\n        finalAns = finalAns * ans(n, 1, k) % mod\n    print(finalAns)", "mod = 1000000007\n\ndef power(a, n, MOD):\n    p = 1\n    while n:\n        if n % 2 == 1:\n            p = p * a % MOD\n        a = a * a % MOD\n        n //= 2\n    return p\n\ndef powerT(a, b):\n    x = power(2, b, mod - 1)\n    if b >= 30:\n        return power(a, x + mod - 1, mod)\n    return power(a, 1 << b, mod)\n\ndef ans(n, p, k):\n    x = powerT(n, k)\n    y = power(n, p - 1, mod)\n    z = power(n - 1, mod - 2, mod)\n    result = power(x, p, mod)\n    return (result - y + mod) % mod * n % mod * z % mod\nfor l in range(int(input())):\n    (n, k) = map(int, input().split())\n    finalAns = 1\n    i = 2\n    while i * i <= n:\n        p = 0\n        while n % i == 0:\n            p += 1\n            n //= i\n        if p != 0:\n            finalAns = finalAns * ans(i, p, k) % mod\n        i += 1\n    if n != 1:\n        finalAns = finalAns * ans(n, 1, k) % mod\n    print(finalAns)", "mod = 1000000007\n\ndef power(App, Num, MOD):\n    P = 1\n    while Num:\n        if Num % 2 == 1:\n            P = P * App % MOD\n        App = App * App % MOD\n        Num = Num // 2\n    return P\n\ndef powerT(CA, CB):\n    xon = power(2, CB, mod - 1)\n    if CB >= 30:\n        return power(CA, xon + mod - 1, mod)\n    return power(CA, 1 << CB, mod)\n\ndef ans(N, p, kil):\n    CX = powerT(N, kil)\n    CY = power(N, p - 1, mod)\n    CZ = power(N - 1, mod - 2, mod)\n    result = power(CX, p, mod)\n    return (result - CY + mod) % mod * N % mod * CZ % mod\n\ndef solve():\n    (gn, gk) = list(map(int, input().split()))\n    finalanswer = 1\n    for i in range(2, gn, 1):\n        if i * i > gn:\n            break\n        p = 0\n        while gn % i == 0:\n            p += 1\n            gn = gn // i\n        if p != 0:\n            finalanswer = finalanswer * ans(i, p, gk) % mod\n    if gn != 1:\n        finalanswer = finalanswer * ans(gn, 1, gk) % mod\n    print(finalanswer)\ntestcases = int(input())\nwhile testcases:\n    solve()\n    testcases -= 1", "mod = 1000000007\n\ndef func(v1, n, MOD):\n    sum = 1\n    while n > 0:\n        if n % 2 == 1:\n            sum = sum * v1 % MOD\n        v1 = v1 * v1 % MOD\n        n //= 2\n    return sum\n\ndef func2(a, v1):\n    if v1 >= 30:\n        return func(a, func(2, v1, mod - 1) + mod - 1, mod)\n    return func(a, 1 << v1, mod)\n    return int(' ')\n\ndef findres(n, p, k):\n    return (func(func2(n, k), p, mod) - func(n, p - 1, mod) + mod) % mod * n % mod * func(n - 1, mod - 2, mod) % mod\nfor tt in range(int(input())):\n    res = 1\n    (n, k) = [int(i) for i in input().split()]\n    i = 2\n    while i * i <= n:\n        sum = 0\n        while n % i == 0:\n            sum += 1\n            n //= i\n        if sum != 0:\n            res = res * findres(i, sum, k) % mod\n        i += 1\n    if n != 1:\n        res = res * findres(n, 1, k) % mod\n    print(int(res))", "MOD = 10 ** 9 + 7\n\ndef mod_inverse_fast(a, m):\n    g = gcd(a, m)\n    if g != 1:\n        return -1\n    else:\n        return power(a, m - 2, m)\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef get_prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef calculate(A, B, C, M):\n    res = power(B, C, M - 1)\n    ans = power(A, res, M)\n    return ans\n\ndef mod_inverse(a, m):\n    for x in range(1, m):\n        if a % m * (x % m) % m == 1:\n            return x\n    return -1\n\ndef mod_subtract(a, b, m):\n    return (a % m - b % m + m) % m\n\ndef mod_multiply(a, b, m):\n    return a % m * (b % m) % m\n\ndef mod_divide(a, b, m):\n    return a % m * mod_inverse_fast(b, m) % m\n\ndef sum_of_series(n, k, value):\n    one = calculate(n, 2, k, MOD)\n    one_plus = power(one, value, MOD)\n    two = mod_subtract(one_plus, 1, MOD)\n    three = mod_multiply(n, two, MOD)\n    four = mod_divide(three, n - 1, MOD)\n    return four\n\ndef plain_sum_of_series(n, k):\n    one = power(n, k, MOD)\n    two = mod_subtract(one, 1, MOD)\n    three = mod_multiply(n, two, MOD)\n    four = mod_divide(three, n - 1, MOD)\n    return four\nT = int(input())\nfor _ in range(T):\n    (n, k) = [int(x) for x in input().split()]\n    prime_factors = get_prime_factors(n)\n    if n == 1:\n        print(1)\n        continue\n    prime_groups = {}\n    for prime_factor in prime_factors:\n        if prime_factor in prime_groups:\n            prime_groups[prime_factor] += 1\n        else:\n            prime_groups[prime_factor] = 1\n    prime_solutions = {}\n    for (key, value) in prime_groups.items():\n        one = sum_of_series(key, k, value)\n        two = plain_sum_of_series(key, value - 1)\n        three = one - two\n        prime_solutions[key] = three\n    current_value = 1\n    for (key, value) in prime_solutions.items():\n        current_value = mod_multiply(current_value, value, MOD)\n    print(current_value)", "mod = 1000000007\n\ndef power(a, n, MOD):\n    p = 1\n    while n:\n        if n % 2 == 1:\n            p = p * a % MOD\n        a = a * a % MOD\n        n = n // 2\n    return p\n\ndef powerT(a, b):\n    x = power(2, b, mod - 1)\n    if b >= 30:\n        return power(a, x + mod - 1, mod)\n    return power(a, 1 << b, mod)\n\ndef ans(n, p, k):\n    x = powerT(n, k)\n    y = power(n, p - 1, mod)\n    z = power(n - 1, mod - 2, mod)\n    result = power(x, p, mod)\n    return (result - y + mod) % mod * n % mod * z % mod\n\ndef solve():\n    (n, k) = map(int, input().split())\n    finalanswer = 1\n    for i in range(2, n, 1):\n        if i * i > n:\n            break\n        p = 0\n        while n % i == 0:\n            p += 1\n            n = n // i\n        if p != 0:\n            finalanswer = finalanswer * ans(i, p, k) % mod\n    if n != 1:\n        finalanswer = finalanswer * ans(n, 1, k) % mod\n    print(finalanswer)\nt = int(input())\nwhile t:\n    solve()\n    t -= 1", "import math as M_T\nMx_Number = 10000002\nSpc_F = [0 for i in range(Mx_Number)]\n\ndef Siev_Erit():\n    Spc_F[1] = 1\n    for i in range(2, Mx_Number):\n        Spc_F[i] = i\n    for i in range(4, Mx_Number, 2):\n        Spc_F[i] = 2\n    for i in range(3, M_T.ceil(M_T.sqrt(Mx_Number))):\n        if Spc_F[i] == i:\n            for j in range(i * i, Mx_Number, i):\n                if Spc_F[j] == j:\n                    Spc_F[j] = i\n\ndef getFactor(x):\n    Ret_N = list()\n    while x != 1:\n        Ret_N.append(Spc_F[x])\n        x = x // Spc_F[x]\n    return Ret_N\nSiev_Erit()\nfor i in range(int(input())):\n    a = list(map(int, input().strip().split()))\n    pfa = getFactor(a[0])\n    dpfa = {}\n    Temp_1 = a[0]\n    for i in pfa:\n        while Temp_1 % i == 0:\n            Temp_1 //= i\n            if i in dpfa:\n                dpfa[i] += 1\n            else:\n                dpfa[i] = 1\n    answer = 1\n    for i in dpfa:\n        a1 = pow(2, a[1], 1000000006)\n        answer *= (pow(i, dpfa[i] * a1 + 1, 1000000007) - pow(i, dpfa[i])) * pow(i - 1, 1000000005, 1000000007)\n        anser = answer % 1000000007\n    print(answer % 1000000007)", "mod = 1000000007\n\ndef power(a, n, MOD):\n    p = 1\n    while n:\n        if n % 2 == 1:\n            p = p * a % MOD\n        a = a * a % MOD\n        n = n // 2\n    return p\n\ndef powerT(a, b):\n    x = power(2, b, mod - 1)\n    if b >= 30:\n        return power(a, x + mod - 1, mod)\n    c = 1 << b\n    return power(a, c, mod)\n\ndef ans(n, p, k):\n    x = powerT(n, k)\n    y = power(n, p - 1, mod)\n    z = power(n - 1, mod - 2, mod)\n    result = power(x, p, mod)\n    return (result - y + mod) % mod * n % mod * z % mod\n\ndef solve():\n    (n, k) = map(int, input().split())\n    finalAnswer = 1\n    i = 2\n    while i * i <= n:\n        p = 0\n        while n % i == 0:\n            p += 1\n            n //= i\n        if p != 0:\n            finalAnswer = finalAnswer * ans(i, p, k) % mod\n        i += 1\n    if n != 1:\n        finalAnswer = finalAnswer * ans(n, 1, k) % mod\n    print(finalAnswer)\n\ndef main():\n    testcases = int(input())\n    for i in range(testcases):\n        solve()\nmain()", "mod = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    suy = [int(i) for i in input().split()]\n    n = suy[0]\n    k = suy[1]\n\n    def poo(a, b, c):\n        cnt = 1\n        while b:\n            if b % 2:\n                cnt = cnt * a % c\n            a = a * a % c\n            b = b // 2\n        return cnt\n    res = poo(2, k, mod - 1)\n    ans = 1\n    i = 2\n    while i * i <= n:\n        tillnow = 0\n        while n % i == 0:\n            tillnow += 1\n            n = n // i\n        if tillnow != 0:\n            if k >= 30:\n                x = poo(i, res + mod - 1, mod)\n            else:\n                x = poo(i, 1 << k, mod)\n            (a, b, c) = (poo(x + mod, tillnow, mod), poo(i, tillnow - 1, mod), poo(i - 1, mod - 2, mod))\n            ans = ans * (a - b + mod) % mod * i % mod * c % mod % mod\n        i = i + 1\n    if n != 1:\n        if k >= 30:\n            x = poo(n, res + mod - 1, mod)\n        else:\n            x = poo(n, 1 << k, mod)\n        (a, b, c) = (poo(x, 1, mod), poo(n, 0, mod), poo(n - 1, mod - 2, mod))\n        ans = ans * (a - b + mod) % mod * n % mod * c % mod\n    print(ans % mod)", "def mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\nimport math\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    if inv == -1:\n        return None\n    else:\n        return inv * a % m\nfrom collections import Counter\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef memodict(f):\n\n    class memodict(dict):\n\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n    return memodict().__getitem__\n\ndef pollard_rho(n):\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n    s = (n - 1 & 1 - n).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = p * p % n\n            if p == 1:\n                return gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                (x, y) = (i, (i * i + 1) % n)\n                f = gcd(abs(x - y), n)\n                while f == 1:\n                    (x, y) = ((x * x + 1) % n, (y * y + 1) % n)\n                    y = (y * y + 1) % n\n                    f = gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n\n@memodict\ndef prime_factors(n):\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n\ndef distinct_factors(n):\n    factors = [1]\n    for (p, exp) in prime_factors(n).items():\n        factors += [p ** i * factor for factor in factors for i in range(1, exp + 1)]\n    return factors\n\ndef all_factors(n):\n    (small, large) = ([], [])\n    for i in range(1, int(n ** 0.5) + 1, 2 if n & 1 else 1):\n        if not n % i:\n            small.append(i)\n            large.append(n // i)\n    if small[-1] == large[-1]:\n        large.pop()\n    large.reverse()\n    small.extend(large)\n    return small\nmod = 1000000007\nfor t in range(int(input())):\n    (n, k) = mi()\n    f = dict(prime_factors(n))\n    ans = int(n)\n    for i in f:\n        if f[i] == 1:\n            temp = pow(i, f[i] * pow(2, k, mod - 1) % (mod - 1), mod) - 1\n        else:\n            temp = pow(i, (f[i] * pow(2, k, mod - 1) - f[i] + 1) % (mod - 1), mod) - 1\n        temp %= mod\n        curr = modDivide(temp, i - 1, mod)\n        ans *= curr\n        ans %= mod\n    print(ans)", "md = 1000000007\nfor i in range(int(input())):\n\n    def powr(l, q, md):\n        z = 1\n        while q:\n            if q % 2 == 1:\n                z = z * l % md\n            l = l * l % md\n            q //= 2\n        return z\n\n    def apop(a, l):\n        if l >= 30:\n            return powr(a, powr(2, l, md - 1) + md - 1, md)\n        return powr(a, 1 << l, md)\n        return int(' ')\n\n    def calci(q, p, k):\n        return (powr(apop(q, k), p, md) - powr(q, p - 1, md) + md) % md * q % md * powr(q - 1, md - 2, md) % md\n    (q, y) = map(int, input().split())\n    apstj = 1\n    for i in range(2, q):\n        if i * i > q:\n            break\n        s = 0\n        while q % i == 0:\n            s += 1\n            q //= i\n        if s != 0:\n            apstj = apstj * calci(i, s, y) % md\n    if q != 1:\n        apstj = apstj * calci(q, 1, y) % md\n    print(apstj)", "from collections import Counter\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef memodict(f):\n\n    class memodict(dict):\n\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n    return memodict().__getitem__\n\ndef pollard_rho(n):\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n    s = (n - 1 & 1 - n).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = p * p % n\n            if p == 1:\n                return gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                (x, y) = (i, (i * i + 1) % n)\n                f = gcd(abs(x - y), n)\n                while f == 1:\n                    (x, y) = ((x * x + 1) % n, (y * y + 1) % n)\n                    y = (y * y + 1) % n\n                    f = gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n\n@memodict\ndef prime_factors(n):\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n\ndef distinct_factors(n):\n    factors = [1]\n    for (p, exp) in prime_factors(n).items():\n        factors += [p ** i * factor for factor in factors for i in range(1, exp + 1)]\n    return factors\n\ndef all_factors(n):\n    (small, large) = ([], [])\n    for i in range(1, int(n ** 0.5) + 1, 2 if n & 1 else 1):\n        if not n % i:\n            small.append(i)\n            large.append(n // i)\n    if small[-1] == large[-1]:\n        large.pop()\n    large.reverse()\n    small.extend(large)\n    return small\nimport math\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    return inv * a % m\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    org = int(n)\n    if n == 1:\n        print(1)\n        continue\n    f = prime_factors(n)\n    ans = int(n)\n    mod = 1000000007\n    for i in f:\n        if f[i] > 1:\n            num = (pow(i, (f[i] * pow(2, k, mod - 1) - f[i] + 1) % (mod - 1), mod) - 1) % mod\n        else:\n            num = (pow(i, f[i] * pow(2, k, mod - 1) % (mod - 1), mod) - 1) % mod\n        den = i - 1\n        curr = modDivide(num, den, mod)\n        ans *= curr\n        ans %= mod\n    print(ans)", "mod = 1000000007\n\ndef power(b, n, mo):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % mo\n        b = b * b % mo\n        n = n // 2\n    return s\n\ndef Apow(a, b):\n    if b >= 30:\n        return power(a, power(2, b, mod - 1) + mod - 1, mod)\n    return power(a, 1 << b, mod)\n\ndef cal(n, p, k):\n    return (power(Apow(n, k), p, mod) - power(n, p - 1, mod) + mod) % mod * n % mod * power(n - 1, mod - 2, mod) % mod\nfor _ in range(int(input())):\n    ans = 1\n    (n, k) = list(map(int, input().split(' ')))\n    i = 2\n    while i * i <= n:\n        s = 0\n        while n % i == 0:\n            s += 1\n            n = n // i\n        if s != 0:\n            ans = ans * cal(i, s, k) % mod\n        i += 1\n    if n != 1:\n        ans = ans * cal(n, 1, k) % mod\n    print(ans)", "def mkpowmod(MOD):\n\n    def pm(x, n):\n        if 0 == n:\n            return 1\n        if 1 == n:\n            return x\n        ans = pm(x, n // 2)\n        ans = ans * ans\n        if n % 2 > 0:\n            ans *= x\n        return ans % MOD\n    return pm\n\ndef primefact(n):\n\n    def onep(n, p):\n        (a, pa) = (0, 1)\n        while n % p == 0:\n            n //= p\n            pa *= p\n            a += 1\n        return (a, pa, n)\n    ret = []\n    (a, pa, n) = onep(n, 2)\n    if a > 0:\n        ret = [*ret, (2, a, pa)]\n    (a, pa, n) = onep(n, 3)\n    if a > 0:\n        ret = [*ret, (3, a, pa)]\n    delta = 2\n    p = 5\n    while p * p <= n:\n        (a, pa, n) = onep(n, p)\n        if a > 0:\n            ret = [*ret, (p, a, pa)]\n        p += delta\n        delta = 6 - delta\n    if n > 1:\n        ret = [*ret, (n, 1, n)]\n    return ret\nQ = 10 ** 9 + 7\npmQ = mkpowmod(Q)\npmQ1 = mkpowmod(Q - 1)\nT = int(input())\nwhile T > 0:\n    T -= 1\n    (N, K) = [int(s) for s in input().split()]\n    ret = 1\n    if N > 1:\n        rK = pmQ1(2, K)\n        for (p, a, pa) in primefact(N):\n            t = (p * pmQ(pa, rK) + Q - pa) % Q\n            if p > 2:\n                t = t * pmQ(p - 1, Q - 2) % Q\n            ret = ret * t % Q\n    print(ret)", "m = 1000000007\n\ndef power(b, n, m):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % m\n        b = b * b % m\n        n //= 2\n    return s\n\ndef calc_power(a, b):\n    if b >= 30:\n        return power(a, power(2, b, m - 1) + m - 1, m)\n    return power(a, 1 << b, m)\n    return int(' ')\n\ndef distinct(n, p, k):\n    return (power(calc_power(n, k), p, m) - power(n, p - 1, m) + m) % m * n % m * power(n - 1, m - 2, m) % m\n\ndef solve():\n    (n, k) = map(int, input().split())\n    i = 2\n    ans = 1\n    while i * i <= n:\n        s = 0\n        while n % i == 0:\n            s += 1\n            n //= i\n        if s != 0:\n            ans = ans * distinct(i, s, k) % m\n        i += 1\n    if n != 1:\n        ans = ans * distinct(n, 1, k) % m\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    solve()", "def power(a, n, MOD):\n    p = 1\n    while n:\n        if n % 2 == 1:\n            p = p * a % MOD\n        a = a * a % MOD\n        n = n // 2\n    return p\n\ndef powerT(a, b):\n    x = power(2, b, MOD - 1)\n    if b >= 30:\n        return power(a, x + MOD - 1, MOD)\n    return power(a, 1 << b, MOD)\n\ndef ans(n, p, k):\n    x = powerT(n, k)\n    y = power(n, p - 1, MOD)\n    z = power(n - 1, MOD - 2, MOD)\n    res = power(x, p, MOD)\n    return (res - y + MOD) % MOD * n % MOD * z % MOD\nMOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    fanswer = 1\n    i = 2\n    while i * i <= n:\n        p = 0\n        while n % i == 0:\n            p += 1\n            n = n // i\n        if p != 0:\n            fanswer = fanswer * ans(i, p, k) % MOD\n        i += 1\n    if n != 1:\n        fanswer = fanswer * ans(n, 1, k) % MOD\n    print(fanswer)", "mod = 1000000007\n\ndef power(b, n, mod):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % mod\n        b = b * b % mod\n        n = n // 2\n    return s\n\ndef apo(a, b):\n    if b >= 30:\n        return power(a, power(2, b, mod - 1) + mod - 1, mod)\n    return power(a, 1 << b, mod)\n\ndef calc(n, p, k):\n    return (power(apo(n, k), p, mod) - power(n, p - 1, mod) + mod) % mod * n % mod * power(n - 1, mod - 2, mod) % mod\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 1\n    i = 2\n    while i * i <= n:\n        s = 0\n        while n % i == 0:\n            s += 1\n            n = n // i\n        if s != 0:\n            ans = ans * calc(i, s, k) % mod\n        i += 1\n    if n != 1:\n        ans = ans * calc(n, 1, k) % mod\n    print(ans)", "import math\n\ndef sieve(limit=10 ** 7):\n    isprime = [False] + [True] * limit\n    isprime[1] = False\n    for i in range(4, limit + 1, 2):\n        isprime[i] = False\n    i = 3\n    while i * i <= limit:\n        if isprime[i]:\n            for j in range(i * i, limit + 1, 2 * i):\n                isprime[j] = False\n        i += 2\n    return [p for p in range(limit + 1) if isprime[p]]\nPRIMES = sieve()\n\ndef decomp(N):\n    ANS = {}\n    if N >= 2:\n        for P in PRIMES:\n            while N % P == 0:\n                ANS[P] = ANS.get(P, 0) + 1\n                N //= P\n            if N == 1:\n                break\n            if P > math.sqrt(N):\n                ANS[N] = 1\n                break\n    return ANS\n\ndef modpow(base, exp, mod):\n    result = 1\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\nMOD = 10 ** 9 + 7\n\ndef main(N, K):\n    prod = N\n    for (p, a) in decomp(N).items():\n        x = modpow(2, K, MOD - 1)\n        x = ((x - 1) * a + 1) % (MOD - 1)\n        x = modpow(p, x, MOD)\n        x = (x - 1) % MOD\n        y = modpow(p - 1, MOD - 2, MOD)\n        prod = prod * x * y % MOD\n    return prod\nT = int(input().strip())\nfor _ in range(T):\n    (N, K) = [int(x) for x in input().strip().split()[:2]]\n    print(main(N, K))", "var = 7 + 10 ** 9\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n\n    def power(p, q, r):\n        count = 1\n        while q:\n            if q % 2:\n                count = count * p % r\n            p = p * p % r\n            q = q // 2\n        return count\n    t = power(2, k, var - 1)\n    ans = 1\n    i = 2\n    while i * i <= n:\n        total = 0\n        while n % i == 0:\n            total = total + 1\n            n = n // i\n        if total != 0:\n            if k >= 30:\n                x = power(i, t + var - 1, var)\n            else:\n                x = power(i, 1 << k, var)\n            a = power(x + var, total, var)\n            b = power(i, total - 1, var)\n            c = power(i - 1, var - 2, var)\n            ans = ans * (a - b + var) % var * i % var * c % var % var\n        i = i + 1\n    if n != 1:\n        if k >= 30:\n            x = power(n, t + var - 1, var)\n        else:\n            x = power(n, 1 << k, var)\n        a = power(x, 1, var)\n        b = power(n, 0, var)\n        c = power(n - 1, var - 2, var)\n        ans = ans * (a - b + var) % var * n % var * c % var\n    print(ans % var)", "import math\nmod = 10 ** 9 + 7\nconst = 10 ** 7 + 5\nallZeros = [0 for i in range(const)]\n\ndef helper():\n    allZeros[1] = 1\n    for i in range(2, const):\n        allZeros[i] = i\n    for i in range(4, const, 2):\n        allZeros[i] = 2\n    for i in range(3, math.ceil(math.sqrt(const))):\n        if allZeros[i] == i:\n            for j in range(i * i, const, i):\n                if allZeros[j] == j:\n                    allZeros[j] = i\n\ndef factors(num):\n    arr = []\n    while num != 1:\n        arr.append(allZeros[num])\n        num = num // allZeros[num]\n    return arr\nhelper()\nfor i in range(int(input())):\n    arr = [int(x) for x in input().split()]\n    arr1 = factors(arr[0])\n    ddict = dict()\n    temp = arr[0]\n    for i in arr1:\n        while temp % i == 0:\n            temp = temp // i\n            if i in ddict:\n                ddict[i] += 1\n            else:\n                ddict[i] = 1\n    res = 1\n    for i in ddict:\n        power = pow(2, arr[1], mod - 1)\n        res *= (pow(i, ddict[i] * power + 1, mod) - pow(i, ddict[i])) * pow(i - 1, mod - 2, mod)\n        res = res % mod\n    print(res % mod)", "def power(b, n, MOD):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % MOD\n        b = b * b % MOD\n        n = n // 2\n    return s\n\ndef apower(a, b):\n    if b >= 30:\n        return power(a, power(2, b, 1000000007 - 1) + 1000000007 - 1, 1000000007)\n    return power(a, 1 << b, 1000000007)\n\ndef calc(n, p, k):\n    return (power(apower(n, k), p, 1000000007) - power(n, p - 1, 1000000007) + 1000000007) % 1000000007 * n % 1000000007 * power(n - 1, 1000000007 - 2, 1000000007) % 1000000007\nt = int(input())\nfor x in range(t):\n    (n, k) = map(int, input().split())\n    answer = 1\n    i = 2\n    while i * i <= n:\n        s = 0\n        while n % i == 0:\n            s = s + 1\n            n = n // i\n        if s != 0:\n            answer = answer * calc(i, s, k) % 1000000007\n        i = i + 1\n    if n != 1:\n        answer = answer * calc(n, 1, k) % 1000000007\n    print(answer)", "mod = 1000000007\n\ndef power(b, n, mo):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % mo\n        b = b * b % mo\n        n = n // 2\n    return s\n\ndef Apower(a, b):\n    if b >= 30:\n        return power(a, power(2, b, mod - 1) + mod - 1, mod)\n    return power(a, 1 << b, mod)\n\ndef calc(n, p, k):\n    return (power(Apower(n, k), p, mod) - power(n, p - 1, mod) + mod) % mod * n % mod * power(n - 1, mod - 2, mod) % mod\n\ndef solve():\n    answer = 1\n    (n, k) = list(map(int, input().split(' ')))\n    i = 2\n    while i * i <= n:\n        s = 0\n        while n % i == 0:\n            s += 1\n            n = n // i\n        if s != 0:\n            answer = answer * calc(i, s, k) % mod\n        i += 1\n    if n != 1:\n        answer = answer * calc(n, 1, k) % mod\n    print(answer)\nfor _ in range(int(input())):\n    solve()", "import math as Mat\nMAX_Num = 10000002\nspf = [0 for i in range(MAX_Num)]\n\ndef sieve_E():\n    spf[1] = 1\n    for i in range(2, MAX_Num):\n        spf[i] = i\n    for i in range(4, MAX_Num, 2):\n        spf[i] = 2\n    for i in range(3, Mat.ceil(Mat.sqrt(MAX_Num))):\n        if spf[i] == i:\n            for j in range(i * i, MAX_Num, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef get_Factorization(x):\n    ret = list()\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\nsieve_E()\nfor i in range(int(input())):\n    a = list(map(int, input().strip().split()))\n    pfa = get_Factorization(a[0])\n    dpfa = {}\n    tempa = a[0]\n    for i in pfa:\n        while tempa % i == 0:\n            tempa //= i\n            if i in dpfa:\n                dpfa[i] += 1\n            else:\n                dpfa[i] = 1\n    ans = 1\n    for i in dpfa:\n        a1 = pow(2, a[1], 1000000006)\n        ans *= (pow(i, dpfa[i] * a1 + 1, 1000000007) - pow(i, dpfa[i])) * pow(i - 1, 1000000005, 1000000007)\n        ans = ans % 1000000007\n    print(ans % 1000000007)", "mod = 1000000007\nfor i in range(int(input())):\n\n    def po(l, q, mod):\n        s = 1\n        while q:\n            if q % 2 == 1:\n                s = s * l % mod\n            l = l * l % mod\n            q //= 2\n        return s\n\n    def ap(a, l):\n        if l >= 30:\n            return po(a, po(2, l, mod - 1) + mod - 1, mod)\n        return po(a, 1 << l, mod)\n        return int(' ')\n\n    def calci(q, p, k):\n        return (po(ap(q, k), p, mod) - po(q, p - 1, mod) + mod) % mod * q % mod * po(q - 1, mod - 2, mod) % mod\n    (q, k) = map(int, input().split())\n    aps = 1\n    for i in range(2, q):\n        if i * i > q:\n            break\n        s = 0\n        while q % i == 0:\n            s += 1\n            q //= i\n        if s != 0:\n            aps = aps * calci(i, s, k) % mod\n    if q != 1:\n        aps = aps * calci(q, 1, k) % mod\n    print(aps)", "import math as mt\nMAXN = 10000002\nspf = [0 for i in range(MAXN)]\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = list()\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\nsieve()\nfor i in range(int(input())):\n    a = list(map(int, input().strip().split()))\n    pfa = getFactorization(a[0])\n    dpfa = {}\n    tempa = a[0]\n    for i in pfa:\n        while tempa % i == 0:\n            tempa //= i\n            if i in dpfa:\n                dpfa[i] += 1\n            else:\n                dpfa[i] = 1\n    ans = 1\n    for i in dpfa:\n        a1 = pow(2, a[1], 1000000006)\n        ans *= (pow(i, dpfa[i] * a1 + 1, 1000000007) - pow(i, dpfa[i])) * pow(i - 1, 1000000005, 1000000007)\n        ans = ans % 1000000007\n    print(ans % 1000000007)", "cons = 1000000007\nT = int(input())\nfor i in range(T):\n\n    def p1(y, z, cons):\n        ans = 1\n        while z:\n            if z % 2 == 1:\n                ans = ans * y % cons\n            y = y * y % cons\n            z //= 2\n        return ans\n\n    def p2(x, y):\n        if y >= 30:\n            return p1(x, p1(2, y, cons - 1) + cons - 1, cons)\n        return p1(x, 1 << y, cons)\n        return int(' ')\n\n    def calc(a, x, b):\n        return (p1(p2(a, b), x, cons) - p1(a, x - 1, cons) + cons) % cons * a % cons * p1(a - 1, cons - 2, cons) % cons\n    (a, b) = map(int, input().split())\n    Sum = 1\n    for j in range(2, a):\n        if j * j > a:\n            break\n        c = 0\n        while a % j == 0:\n            c += 1\n            a //= j\n        if c != 0:\n            Sum = Sum * calc(j, c, b) % cons\n    if a != 1:\n        Sum = Sum * calc(a, 1, b) % 1000000007\n    print(Sum)", "MOD = 1000000007\nfor i in range(int(input())):\n\n    def power(b, n, MOD):\n        s = 1\n        while n:\n            if n % 2 == 1:\n                s = s * b % MOD\n            b = b * b % MOD\n            n //= 2\n        return s\n\n    def Apower(a, b):\n        if b >= 30:\n            return power(a, power(2, b, MOD - 1) + MOD - 1, MOD)\n        return power(a, 1 << b, MOD)\n        return int(' ')\n\n    def calc(n, p, k):\n        return (power(Apower(n, k), p, MOD) - power(n, p - 1, MOD) + MOD) % MOD * n % MOD * power(n - 1, MOD - 2, MOD) % MOD\n    (n, k) = map(int, input().split())\n    answer = 1\n    for i in range(2, n):\n        if i * i > n:\n            break\n        s = 0\n        while n % i == 0:\n            s += 1\n            n //= i\n        if s != 0:\n            answer = answer * calc(i, s, k) % MOD\n    if n != 1:\n        answer = answer * calc(n, 1, k) % MOD\n    print(answer)", "MOD = 10 ** 9 + 7\nimport sys\nsys.setrecursionlimit(10000000)\nimport random\nfrom functools import lru_cache\n\ndef primesbelow(N):\n    correction = N % 6 > 1\n    N = {0: N, 1: N - 1, 2: N + 4, 3: N + 3, 4: N + 2, 5: N + 1}[N % 6]\n    sieve = [True] * (N // 3)\n    sieve[0] = False\n    for i in range(int(N ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((N // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i % 2)) // 3::2 * k] = [False] * ((N // 6 - (k * k + 4 * k - 2 * k * (i % 2)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, N // 3 - correction) if sieve[i]]\nsmallprimeset = set(primesbelow(100000))\n_smallprimeset = 100000\n\ndef isprime(n, precision=7):\n    if n < 1:\n        raise ValueError('Out of bounds, first argument must be > 0')\n    elif n <= 3:\n        return n >= 2\n    elif n % 2 == 0:\n        return False\n    elif n < _smallprimeset:\n        return n in smallprimeset\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n    for repeat in range(precision):\n        a = random.randrange(2, n - 2)\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for r in range(s - 1):\n            x = pow(x, 2, n)\n            if x == 1:\n                return False\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n\ndef pollard_brent(n):\n    if n % 2 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n    (y, c, m) = (random.randint(1, n - 1), random.randint(1, n - 1), random.randint(1, n - 1))\n    (g, r, q) = (1, 1, 1)\n    while g == 1:\n        x = y\n        for i in range(r):\n            y = (pow(y, 2, n) + c) % n\n        k = 0\n        while k < r and g == 1:\n            ys = y\n            for i in range(min(m, r - k)):\n                y = (pow(y, 2, n) + c) % n\n                q = q * abs(x - y) % n\n            g = gcd(q, n)\n            k += m\n        r *= 2\n    if g == n:\n        while True:\n            ys = (pow(ys, 2, n) + c) % n\n            g = gcd(abs(x - ys), n)\n            if g > 1:\n                break\n    return g\nsmallprimes = primesbelow(1000)\n\ndef primefactors(n, sort=False):\n    factors = []\n    for checker in smallprimes:\n        while n % checker == 0:\n            factors.append(checker)\n            n //= checker\n        if checker > n:\n            break\n    if n < 2:\n        return factors\n    while n > 1:\n        if isprime(n):\n            factors.append(n)\n            break\n        factor = pollard_brent(n)\n        factors.extend(primefactors(factor))\n        n //= factor\n    if sort:\n        factors.sort()\n    return factors\n\ndef factorization(n):\n    factors = {}\n    for p1 in primefactors(n):\n        try:\n            factors[p1] += 1\n        except KeyError:\n            factors[p1] = 1\n    return factors\ntotients = {}\n\ndef totient(n):\n    if n == 0:\n        return 1\n    try:\n        return totients[n]\n    except KeyError:\n        pass\n    tot = 1\n    for (p, exp) in factorization(n).items():\n        tot *= (p - 1) * p ** (exp - 1)\n    totients[n] = tot\n    return tot\n\ndef gcd(a, b):\n    if a == b:\n        return a\n    while b > 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    return abs(a // gcd(a, b) * b)\nimport math\n\n@lru_cache(None)\ndef modInverse(b, m=MOD):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m=MOD):\n    a = a % m\n    inv = modInverse(b, m)\n    return inv * a % m\nfrom functools import lru_cache\n\ndef gcp_sum(n, power):\n    a = pow(n, power + 1, MOD) - 1\n    b = n - 1\n    res = modDivide(a, b, MOD)\n    return res % MOD\n\ndef calculate(A, B, C, M):\n    res = pow(B, C, M - 1)\n    ans = pow(A, res, M)\n    return ans\n\ndef gcp_sum_big(n, k, power):\n    a = pow(calculate(n, 2, k, MOD), power, MOD)\n    a = a * n - 1\n    b = n - 1\n    res = modDivide(a, b, MOD)\n    return res % MOD\n\ndef solve(n, k):\n    factors = factorization(n)\n    res = 1\n    for (n, power) in factors.items():\n        (n, power) = (n % MOD, power % MOD)\n        r = gcp_sum_big(n, k, power) - gcp_sum(n, power - 1)\n        res = res * r % MOD\n    return res\nt = int(input())\nfor _ in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    print(solve(n, k))"]