["T = int(input())\nfor t in range(T):\n    (n, k) = input().split(' ')\n    n = int(n)\n    k = int(k)\n    s = input()\n    arr = []\n    for i in range(n):\n        arr.append(s[i])\n    prefarr = [0 for i in range(n)]\n    c = 0\n    a = n - k + 1\n    for i in range(n - k + 1):\n        if arr[i] == '0' and (c + prefarr[i]) % 2 == 0:\n            c += prefarr[i]\n            continue\n        elif arr[i] == '1' and (c + prefarr[i]) % 2 != 0:\n            c += prefarr[i]\n            continue\n        else:\n            prefarr[i] += 1\n            if i + k < n:\n                prefarr[i + k] -= 1\n            c += prefarr[i]\n            a -= 1\n        if a == 0:\n            break\n    for i in range(1, len(prefarr)):\n        prefarr[i] += prefarr[i - 1]\n    ans = ''\n    for i in range(len(prefarr)):\n        if arr[i] == '0' and prefarr[i] % 2 == 0 or (arr[i] == '1' and prefarr[i] % 2 != 0):\n            ans += '0'\n        else:\n            ans += '1'\n    print(ans)\n    print('')", "def solve(n, k, s):\n    arr = [i for i in s]\n    pre = [0 for i in range(n + 1)]\n    if arr[0] == '1':\n        arr[0] = '0'\n        pre[0] += 1\n        pre[0 + k] -= 1\n    for i in range(1, n):\n        pre[i] += pre[i - 1]\n        if pre[i] % 2 == 1:\n            if arr[i] == '0':\n                arr[i] = '1'\n            else:\n                arr[i] = '0'\n        if i + k <= n:\n            if arr[i] == '1':\n                arr[i] = '0'\n                pre[i] += 1\n                pre[i + k] -= 1\n    p = ''\n    for i in arr:\n        p += i\n    return p\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, k) = map(int, input().split())\n    s = str(input())\n    print(solve(n, k, s))", "def solve(n, k, s):\n    arr = [i for i in s]\n    pre = [0 for i in range(n + 1)]\n    if arr[0] == '1':\n        arr[0] = '0'\n        pre[0] += 1\n        pre[0 + k] -= 1\n    for i in range(1, n):\n        pre[i] += pre[i - 1]\n        if pre[i] % 2 == 1:\n            if arr[i] == '0':\n                arr[i] = '1'\n            else:\n                arr[i] = '0'\n        if i + k <= n:\n            if arr[i] == '1':\n                arr[i] = '0'\n                pre[i] += 1\n                pre[i + k] -= 1\n    p = ''\n    for i in arr:\n        p += i\n    return p\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, k) = map(int, input().split())\n    s = str(input())\n    print(solve(n, k, s))", "def solve(n, k, s):\n    arr = [i for i in s]\n    pre = [0 for i in range(n + 1)]\n    if arr[0] == '1':\n        arr[0] = '0'\n        pre[0] += 1\n        pre[0 + k] -= 1\n    for i in range(1, n):\n        pre[i] += pre[i - 1]\n        if pre[i] % 2 == 1:\n            if arr[i] == '0':\n                arr[i] = '1'\n            else:\n                arr[i] = '0'\n        if i + k <= n:\n            if arr[i] == '1':\n                arr[i] = '0'\n                pre[i] += 1\n                pre[i + k] -= 1\n    p = ''\n    for i in arr:\n        p += i\n    return p\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, k) = map(int, input().split())\n    s = str(input())\n    print(solve(n, k, s))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    inds = [0] * (n + 1)\n    if s[0] == '1':\n        inds[0] = 1\n        inds[k] = -1\n    for i in range(1, n):\n        inds[i] += inds[i - 1]\n        if i <= n - k and int(s[i]) ^ inds[i] % 2:\n            inds[i] += 1\n            inds[i + k] -= 1\n    res = ''\n    for i in range(n):\n        res += str(int(s[i]) ^ inds[i] % 2)\n    print(res)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    inds = [0] * (n + 1)\n    if s[0] == '1':\n        inds[0] = 1\n        inds[k] = -1\n    for i in range(1, n):\n        inds[i] += inds[i - 1]\n        if i <= n - k and int(s[i]) ^ inds[i] % 2:\n            inds[i] += 1\n            inds[i + k] -= 1\n    res = ''\n    for i in range(n):\n        res += str(int(s[i]) ^ inds[i] % 2)\n    print(res)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = [int(x) for x in input()]\n    s = 0\n    pre = [0] * n\n    for i in range(n):\n        if i - k >= 0:\n            s -= pre[i - k]\n        if i < n - k + 1:\n            if s % 2 == 0 and arr[i] == 1:\n                s += 1\n                pre[i] = 1\n            elif s % 2 != 0 and arr[i] == 0:\n                s += 1\n                pre[i] = 1\n            print(0, end='')\n        elif s % 2 == 0:\n            print(arr[i], end='')\n        else:\n            print(arr[i] ^ 1, end='')\n    print()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = [int(x) for x in input()]\n    s = 0\n    pre = [0] * n\n    for i in range(n):\n        if i - k >= 0:\n            s -= pre[i - k]\n        if i < n - k + 1:\n            if s % 2 == 0 and arr[i] == 1:\n                s += 1\n                pre[i] = 1\n            elif s % 2 != 0 and arr[i] == 0:\n                s += 1\n                pre[i] = 1\n            print(0, end='')\n        elif s % 2 == 0:\n            print(arr[i], end='')\n        else:\n            print(arr[i] ^ 1, end='')\n    print()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    ans = []\n    moves = []\n    ptr = 0\n    for i in range(n):\n        while ptr < len(moves):\n            if moves[ptr] + k <= i:\n                ptr += 1\n            else:\n                break\n        cur = 0 if s[i] == '0' else 1\n        changes = len(moves) - ptr\n        cur ^= changes % 2\n        if i + k > n:\n            ans.append(cur)\n        else:\n            ans.append(0)\n            if cur == 1:\n                moves.append(i)\n    print(''.join((str(x) for x in ans)))", "T = int(input())\nfor i in range(T):\n    (N, K) = input().split()\n    (N, K) = (int(N), int(K))\n    string = input()\n    arr = [0 for i in range(len(string))]\n    j = 0\n    new_string = ''\n    sum = 0\n    while j < len(string) - K + 1:\n        if j >= K:\n            sum -= arr[j - K]\n        if sum % 2 == 0 and string[j] == '1':\n            arr[j] = 1\n            sum += 1\n        elif sum % 2 == 1 and string[j] == '0':\n            arr[j] = 1\n            sum += 1\n        new_string += '0'\n        j += 1\n    while j < len(string):\n        if j >= K:\n            sum -= arr[j - K]\n        if sum % 2 == 0 and string[j] == '1':\n            arr[j] = 1\n            new_string += '1'\n        elif sum % 2 == 1 and string[j] == '0':\n            arr[j] = 1\n            new_string += '1'\n        else:\n            new_string += '0'\n        j += 1\n    print(new_string)", "T = int(input())\nfor i in range(T):\n    (N, K) = input().split()\n    (N, K) = (int(N), int(K))\n    string = input()\n    arr = [0 for i in range(len(string))]\n    j = 0\n    new_string = ''\n    sum = 0\n    while j < len(string) - K + 1:\n        if j >= K:\n            sum -= arr[j - K]\n        if sum % 2 == 0 and string[j] == '1':\n            arr[j] = 1\n            sum += 1\n        elif sum % 2 == 1 and string[j] == '0':\n            arr[j] = 1\n            sum += 1\n        new_string += '0'\n        j += 1\n    while j < len(string):\n        if j >= K:\n            sum -= arr[j - K]\n        if sum % 2 == 0 and string[j] == '1':\n            arr[j] = 1\n            new_string += '1'\n        elif sum % 2 == 1 and string[j] == '0':\n            arr[j] = 1\n            new_string += '1'\n        else:\n            new_string += '0'\n        j += 1\n    print(new_string)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    ans = []\n    moves = []\n    ptr = 0\n    for i in range(n):\n        while ptr < len(moves):\n            if moves[ptr] + k <= i:\n                ptr += 1\n            else:\n                break\n        cur = 0 if s[i] == '0' else 1\n        changes = len(moves) - ptr\n        cur ^= changes % 2\n        if i + k > n:\n            ans.append(cur)\n        else:\n            ans.append(0)\n            if cur == 1:\n                moves.append(i)\n    print(''.join((str(x) for x in ans)))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    ans = []\n    moves = []\n    ptr = 0\n    for i in range(n):\n        while ptr < len(moves):\n            if moves[ptr] + k <= i:\n                ptr += 1\n            else:\n                break\n        cur = 0 if s[i] == '0' else 1\n        changes = len(moves) - ptr\n        cur ^= changes % 2\n        if i + k > n:\n            ans.append(cur)\n        else:\n            ans.append(0)\n            if cur == 1:\n                moves.append(i)\n    print(''.join((str(x) for x in ans)))", "T = int(input())\nfor i in range(T):\n    (N, K) = input().split()\n    (N, K) = (int(N), int(K))\n    string = input()\n    arr = [0 for i in range(len(string))]\n    j = 0\n    new_string = ''\n    sum = 0\n    while j < len(string) - K + 1:\n        if j >= K:\n            sum -= arr[j - K]\n        if sum % 2 == 0 and string[j] == '1':\n            arr[j] = 1\n            sum += 1\n        elif sum % 2 == 1 and string[j] == '0':\n            arr[j] = 1\n            sum += 1\n        new_string += '0'\n        j += 1\n    while j < len(string):\n        if j >= K:\n            sum -= arr[j - K]\n        if sum % 2 == 0 and string[j] == '1':\n            arr[j] = 1\n            new_string += '1'\n        elif sum % 2 == 1 and string[j] == '0':\n            arr[j] = 1\n            new_string += '1'\n        else:\n            new_string += '0'\n        j += 1\n    print(new_string)", "def f(s, k):\n    n = len(s)\n    arr = list(s)\n    negatives = set()\n    m = 0\n    for i in range(n):\n        if i in negatives:\n            m -= 1\n        if (int(arr[i]) + m) % 2 == 0:\n            arr[i] = '0'\n            continue\n        if i >= n - k + 1:\n            arr[i] = '1'\n            continue\n        m += 1\n        negatives.add(i + k)\n        arr[i] = '0'\n    return ''.join(arr)\nt = int(input())\nfor i in range(t):\n    (n, k) = [int(el) for el in input().split(' ')]\n    s = input()\n    print(f(s, k))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    ans = []\n    moves = []\n    ptr = 0\n    for i in range(n):\n        while ptr < len(moves):\n            if moves[ptr] + k <= i:\n                ptr += 1\n            else:\n                break\n        cur = 0 if s[i] == '0' else 1\n        changes = len(moves) - ptr\n        cur ^= changes % 2\n        if i + k > n:\n            ans.append(cur)\n        else:\n            ans.append(0)\n            if cur == 1:\n                moves.append(i)\n    print(''.join((str(x) for x in ans)))", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    s = input()\n    i = 0\n    queue = deque()\n    ans = ''\n    while i < n:\n        while queue and queue[0] < i - k + 1:\n            queue.popleft()\n        if i + k <= n:\n            if len(queue) % 2 == 0 and s[i] == '1' or (len(queue) % 2 and s[i] == '0'):\n                queue.append(i)\n            ans += '0'\n        elif len(queue) % 2 == 0 and s[i] == '1' or (len(queue) % 2 and s[i] == '0'):\n            ans += '1'\n        else:\n            ans += '0'\n        i += 1\n    print(ans)", "q = int(input())\nfor _ in range(q):\n    (n, k) = map(int, input().split())\n    s = input().strip()\n    s = list(s)\n    count = 0\n    flips = {}\n    for i in range(n - k + 1):\n        if (int(s[i]) + count) % 2 == 0:\n            s[i] = '0'\n        else:\n            s[i] = '0'\n            count += 1\n            flips[i + k - 1] = 1\n        if flips.get(i):\n            count -= 1\n    for i in range(n - k + 1, n):\n        if (int(s[i]) + count) % 2 == 0:\n            s[i] = '0'\n        else:\n            s[i] = '1'\n        if flips.get(i):\n            count -= 1\n    print(''.join(s))", "q = int(input())\nfor _ in range(q):\n    (n, k) = map(int, input().split())\n    s = input().strip()\n    s = list(s)\n    count = 0\n    flips = {}\n    for i in range(n - k + 1):\n        if (int(s[i]) + count) % 2 == 0:\n            s[i] = '0'\n        else:\n            s[i] = '0'\n            count += 1\n            flips[i + k - 1] = 1\n        if flips.get(i):\n            count -= 1\n    for i in range(n - k + 1, n):\n        if (int(s[i]) + count) % 2 == 0:\n            s[i] = '0'\n        else:\n            s[i] = '1'\n        if flips.get(i):\n            count -= 1\n    print(''.join(s))", "test = int(input())\nfor _ in range(test):\n    (n, k) = map(int, input().split())\n    s = input().strip()\n    s = list(s)\n    count = 0\n    flips = {}\n    for i in range(n - k + 1):\n        if (int(s[i]) + count) % 2 == 0:\n            s[i] = '0'\n        else:\n            s[i] = '0'\n            count += 1\n            flips[i + k - 1] = 1\n        if flips.get(i):\n            count -= 1\n    for i in range(n - k + 1, n):\n        if (int(s[i]) + count) % 2 == 0:\n            s[i] = '0'\n        else:\n            s[i] = '1'\n        if flips.get(i):\n            count -= 1\n    print(''.join(s))", "from sys import stdin\ninput = stdin.readline\ntest = int(input())\nfor _ in range(test):\n    (n, k) = map(int, input().split())\n    s = input().strip()\n    a = list(s)\n    c = 0\n    d = {}\n    for i in range(n - k + 1):\n        if (int(a[i]) + c) % 2 == 0:\n            a[i] = '0'\n        else:\n            a[i] = '0'\n            c += 1\n            d[i + k - 1] = 1\n        if d.get(i):\n            c -= 1\n    for i in range(n - k + 1, n):\n        if (int(a[i]) + c) % 2 == 0:\n            a[i] = '0'\n        else:\n            a[i] = '1'\n        if d.get(i):\n            c -= 1\n    ans = ''.join(a)\n    print(ans)", "for testcase in range(int(input())):\n    (n, k) = map(int, input().split())\n    string = input()\n    arr = [0] * n\n    rstring = ''\n    for (idx, i) in enumerate(string):\n        if idx == 0:\n            if i == '1':\n                arr[idx] = 1\n                if idx + k <= n - 1:\n                    arr[idx + k] = -1\n            rstring += '0'\n            continue\n        el = ((arr[idx - 1] + arr[idx]) % 2 + int(i)) % 2\n        arr[idx] = arr[idx - 1] + arr[idx]\n        if el == 1:\n            if idx + k <= n:\n                arr[idx] += 1\n            if idx + k < n:\n                arr[idx + k] = -1\n        if arr[idx] % 2:\n            rstring += '1' if i == '0' else '0'\n        else:\n            rstring += i\n    print(rstring)", "T = int(input())\nfor _ in range(T):\n    (n, k) = list(map(int, input().split()))\n    s = input()\n    s = list(s)\n    i = 1\n    pref = [0 for j in range(n + 1)]\n    if s[0] == '1':\n        pref[0] = 1\n        pref[k] = -1\n        s[0] = '0'\n    while i < len(s):\n        pref[i] += pref[i - 1]\n        if pref[i] % 2 == 1:\n            s[i] = str(int(s[i]) ^ 1)\n        if i + k - 1 < len(s):\n            if s[i] == '1':\n                pref[i] += 1\n                s[i] = '0'\n                pref[i + k] -= 1\n        i += 1\n    print(''.join(s))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    ans = []\n    moves = []\n    ptr = 0\n    for i in range(n):\n        while ptr < len(moves):\n            if moves[ptr] + k <= i:\n                ptr += 1\n            else:\n                break\n        cur = 0 if s[i] == '0' else 1\n        changes = len(moves) - ptr\n        cur ^= changes % 2\n        if i + k > n:\n            ans.append(cur)\n        else:\n            ans.append(0)\n            if cur == 1:\n                moves.append(i)\n    print(''.join((str(x) for x in ans)))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    ans = []\n    moves = []\n    ptr = 0\n    for i in range(n):\n        while ptr < len(moves):\n            if moves[ptr] + k <= i:\n                ptr += 1\n            else:\n                break\n        cur = 0 if s[i] == '0' else 1\n        changes = len(moves) - ptr\n        cur ^= changes % 2\n        if i + k > n:\n            ans.append(cur)\n        else:\n            ans.append(0)\n            if cur == 1:\n                moves.append(i)\n    print(''.join((str(x) for x in ans)))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    ans = []\n    moves = []\n    ptr = 0\n    for i in range(n):\n        while ptr < len(moves):\n            if moves[ptr] + k <= i:\n                ptr += 1\n            else:\n                break\n        cur = 0 if s[i] == '0' else 1\n        changes = len(moves) - ptr\n        cur ^= changes % 2\n        if i + k > n:\n            ans.append(cur)\n        else:\n            ans.append(0)\n            if cur == 1:\n                moves.append(i)\n    print(''.join((str(x) for x in ans)))", "t = int(input())\nfor i in range(t):\n    [N, K] = [int(i) for i in input().split()]\n    s = input()\n    fliparr = [-1] * N\n    length = 0\n    flip = 0\n    for i in range(N - K + 1):\n        if i == 0:\n            if s[i] == '1':\n                flip += 1\n                fliparr[i] = flip\n            else:\n                fliparr[i] = flip\n        else:\n            if max(0, i - K + 1) == 0:\n                if fliparr[0] == 1:\n                    val = fliparr[i - 1] - fliparr[0] + 1\n                else:\n                    val = fliparr[i - 1] - fliparr[0]\n            elif fliparr[i - K + 1] == fliparr[i - K]:\n                val = fliparr[i - 1] - fliparr[i - K + 1]\n            else:\n                val = fliparr[i - 1] - fliparr[i - K + 1] + 1\n            if s[i] == '1' and val % 2 == 0:\n                flip += 1\n                fliparr[i] = flip\n            if s[i] == '0' and val % 2 == 1:\n                flip += 1\n                fliparr[i] = flip\n            if s[i] == '1' and val % 2 == 1:\n                fliparr[i] = flip\n            if s[i] == '0' and val % 2 == 0:\n                fliparr[i] = flip\n    if N == 1:\n        print(0)\n    elif N > K:\n        for i in range(N - K + 1, N):\n            if max(0, i - K + 1) == 0:\n                if fliparr[0] == 1:\n                    val = fliparr[N - K]\n                else:\n                    val = fliparr[N - K]\n            elif max(0, i - K + 1) == i - K + 1:\n                if fliparr[i - K] == fliparr[i - K + 1]:\n                    val = fliparr[N - K] - fliparr[i - K + 1]\n                else:\n                    val = fliparr[N - K] - fliparr[i - K + 1] + 1\n            if val % 2 == 0:\n                if s[i] == '0':\n                    fliparr[i] = 0\n                else:\n                    fliparr[i] = 1\n            elif s[i] == '0':\n                fliparr[i] = 1\n            else:\n                fliparr[i] = 0\n        ans = [0] * (N - K + 1)\n        for i in range(N - K + 1, N):\n            ans.append(fliparr[i])\n        for i in ans:\n            print(i, end='')\n        print()\n    elif N == K:\n        ans = [0]\n        if s[0] == '0':\n            for i in range(1, N):\n                ans.append(int(s[i]))\n        else:\n            for i in range(1, N):\n                if int(s[i]) == 0:\n                    ans.append(1)\n                else:\n                    ans.append(0)\n        for i in ans:\n            print(i, end='')\n        print()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    ans = []\n    moves = []\n    ptr = 0\n    for i in range(n):\n        while ptr < len(moves):\n            if moves[ptr] + k <= i:\n                ptr += 1\n            else:\n                break\n        cur = 0 if s[i] == '0' else 1\n        changes = len(moves) - ptr\n        cur ^= changes % 2\n        if i + k > n:\n            ans.append(cur)\n        else:\n            ans.append(0)\n            if cur == 1:\n                moves.append(i)\n    print(''.join((str(x) for x in ans)))", "def func1():\n    (N, K) = map(int, input().split())\n    s = list(input())\n    flipped = [0 for i in range(N)]\n    limit = N + K - 1\n    flipct = 0\n    ct = 0\n    for i in range(N):\n        if i >= K and flipped[i - K]:\n            flipct -= 1\n        if flipct & 1:\n            if s[i] == '0':\n                s[i] = '1'\n            else:\n                s[i] = '0'\n        if s[i] == '1' and ct < limit and (i <= N - K):\n            flipped[i] = '1'\n            flipct += 1\n            s[i] = '0'\n            ct += 1\n    print(''.join(s))\nfor _ in range(int(input())):\n    func1()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = list(input())\n    flip = [0] * (n + 1)\n    if s[0] == '1':\n        flip[0] = 1\n        flip[k - 1] = -1\n        s[0] = '0'\n    sm = flip[0]\n    for i in range(1, n - k + 1):\n        if sm % 2:\n            if s[i] == '0':\n                flip[i] += 1\n                flip[i + k - 1] -= 1\n            else:\n                s[i] = '0'\n        elif s[i] == '1':\n            s[i] = '0'\n            flip[i] += 1\n            flip[i + k - 1] -= 1\n        sm += flip[i]\n    for i in range(n - k + 1, n):\n        if sm % 2:\n            if s[i] == '1':\n                s[i] = '0'\n            else:\n                s[i] = '1'\n        sm += flip[i]\n    print(''.join(s))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = list(input())\n    flip = [0] * (n + 1)\n    if s[0] == '1':\n        flip[0] = 1\n        flip[k - 1] = -1\n        s[0] = '0'\n    sm = flip[0]\n    for i in range(1, n - k + 1):\n        if sm % 2:\n            if s[i] == '0':\n                flip[i] += 1\n                flip[i + k - 1] -= 1\n            else:\n                s[i] = '0'\n        elif s[i] == '1':\n            s[i] = '0'\n            flip[i] += 1\n            flip[i + k - 1] -= 1\n        sm += flip[i]\n    for i in range(n - k + 1, n):\n        if sm % 2:\n            if s[i] == '1':\n                s[i] = '0'\n            else:\n                s[i] = '1'\n        sm += flip[i]\n    print(''.join(s))", "import collections as clts\nimport math\nimport heapq\n\ndef gcd(x, y):\n    if y == 0:\n        return x\n    else:\n        return gcd(y, x % y)\n\ndef lcm(x, y):\n    return int(x / gcd(x, y) * y)\nfor _ in range(int(input())):\n    (N, K) = list(map(int, input().split()))\n    S = input()\n    opQ = clts.deque()\n    opt = []\n    i = 0\n    j = 0\n    while i <= N - K + 1 and j <= N - 1:\n        bit = S[j]\n        while len(opQ) != 0:\n            e = opQ.popleft()\n            if e >= j - K + 1:\n                opQ.appendleft(e)\n                break\n        if len(opQ) % 2 == 1 and bit == '1':\n            bit = '0'\n        elif len(opQ) % 2 == 0 and bit == '1':\n            if j + K <= N:\n                bit = '0'\n                opQ.append(j)\n                i += 1\n        elif len(opQ) % 2 == 1 and bit == '0':\n            bit = '1'\n            if j + K <= N:\n                bit = '0'\n                opQ.append(j)\n                i += 1\n        else:\n            bit = bit\n        opt.append(bit)\n        j += 1\n    if j < N - 1:\n        for i in range(j, N):\n            opt.append(S[i])\n    print(''.join(opt))", "from collections import deque\n\ndef solve(word, n, k):\n    ans = ''\n    dq = deque()\n    for i in range(n - k + 1):\n        while len(dq) > 0 and dq[0] < i - k + 1:\n            _ = dq.popleft()\n        cnt = len(dq)\n        if cnt % 2 == 0:\n            if word[i] == '1':\n                dq.append(i)\n        elif word[i] == '0':\n            dq.append(i)\n        ans += '0'\n    for i in range(n - k + 1, n):\n        while len(dq) > 0 and dq[0] < i - k + 1:\n            _ = dq.popleft()\n        cnt = len(dq)\n        if cnt % 2 == 0:\n            ans += word[i]\n        elif word[i] == '1':\n            ans += '0'\n        else:\n            ans += '1'\n    return ans\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    word = list(input())\n    print(solve(word, n, k))", "from collections import deque\n\ndef solve(word, n, k):\n    ans = ''\n    dq = deque()\n    for i in range(n - k + 1):\n        while len(dq) > 0 and dq[0] < i - k + 1:\n            _ = dq.popleft()\n        cnt = len(dq)\n        if cnt % 2 == 0:\n            if word[i] == '1':\n                dq.append(i)\n        elif word[i] == '0':\n            dq.append(i)\n        ans += '0'\n    for i in range(n - k + 1, n):\n        while len(dq) > 0 and dq[0] < i - k + 1:\n            _ = dq.popleft()\n        cnt = len(dq)\n        if cnt % 2 == 0:\n            ans += word[i]\n        elif word[i] == '1':\n            ans += '0'\n        else:\n            ans += '1'\n    return ans\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    word = list(input())\n    print(solve(word, n, k))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    ans = '0' * (n - k + 1)\n    lc = []\n    count = 0\n    for i in range(n - k + 1):\n        if i >= k:\n            count -= lc[i - k]\n        if s[i] == '1' and count % 2 == 0:\n            lc.append(1)\n            count += 1\n        elif s[i] == '0' and count % 2 == 1:\n            lc.append(1)\n            count += 1\n        else:\n            lc.append(0)\n    for i in range(n - k + 1, n):\n        if i >= k:\n            count -= lc[i - k]\n        if count % 2 == 0:\n            ans += s[i]\n        elif s[i] == '1':\n            ans += '0'\n        else:\n            ans += '1'\n    print(ans)", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    s = input()\n    q = deque()\n    i = 0\n    j = k - 1\n    count = 0\n    res = 0\n    ans = []\n    while j < n and count < n - k + 1:\n        if i > k - 1:\n            res -= q.popleft()\n        if s[i] == '0':\n            if res % 2:\n                ans.append('0')\n                res += 1\n                q.append(1)\n            else:\n                ans.append('0')\n                q.append(0)\n        elif res % 2:\n            ans.append('0')\n            q.append(0)\n        else:\n            ans.append('0')\n            q.append(1)\n            res += 1\n        i += 1\n        j += 1\n        count += 1\n    while i < j:\n        if i > k - 1:\n            res -= q.popleft()\n        if s[i] == '0':\n            if res % 2:\n                ans.append('1')\n            else:\n                ans.append('0')\n        elif res % 2:\n            ans.append('0')\n        else:\n            ans.append('1')\n        i += 1\n    for i in range(len(ans), n):\n        ans.append(s[i])\n    print(''.join(ans))", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    s = input()\n    q = deque()\n    i = 0\n    j = k - 1\n    count = 0\n    res = 0\n    ans = []\n    while j < n and count < n - k + 1:\n        if i > k - 1:\n            res -= q.popleft()\n        if s[i] == '0':\n            if res % 2:\n                ans.append('0')\n                res += 1\n                q.append(1)\n            else:\n                ans.append('0')\n                q.append(0)\n        elif res % 2:\n            ans.append('0')\n            q.append(0)\n        else:\n            ans.append('0')\n            q.append(1)\n            res += 1\n        i += 1\n        j += 1\n        count += 1\n    while i < j:\n        if i > k - 1:\n            res -= q.popleft()\n        if s[i] == '0':\n            if res % 2:\n                ans.append('1')\n            else:\n                ans.append('0')\n        elif res % 2:\n            ans.append('0')\n        else:\n            ans.append('1')\n        i += 1\n    for i in range(len(ans), n):\n        ans.append(s[i])\n    print(''.join(ans))", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    s = input()\n    q = deque()\n    i = 0\n    j = k - 1\n    count = 0\n    res = 0\n    ans = []\n    while j < n and count < n - k + 1:\n        if i > k - 1:\n            res -= q.popleft()\n        if s[i] == '0':\n            if res % 2:\n                ans.append('0')\n                res += 1\n                q.append(1)\n            else:\n                ans.append('0')\n                q.append(0)\n        elif res % 2:\n            ans.append('0')\n            q.append(0)\n        else:\n            ans.append('0')\n            q.append(1)\n            res += 1\n        i += 1\n        j += 1\n        count += 1\n    while i < j:\n        if i > k - 1:\n            res -= q.popleft()\n        if s[i] == '0':\n            if res % 2:\n                ans.append('1')\n            else:\n                ans.append('0')\n        elif res % 2:\n            ans.append('0')\n        else:\n            ans.append('1')\n        i += 1\n    for i in range(len(ans), n):\n        ans.append(s[i])\n    print(''.join(ans))", "for _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    s = list(input())\n    flipped = [0 for i in range(n)]\n    flipcount = 0\n    count = 0\n    limit = n - k + 1\n    for i in range(n):\n        if i >= k and flipped[i - k]:\n            flipcount -= 1\n        if flipcount % 2 != 0:\n            if s[i] == '1':\n                s[i] = '0'\n            else:\n                s[i] = '1'\n        if s[i] == '1' and count <= limit and (i <= n - k):\n            flipped[i] = 1\n            flipcount += 1\n            count += 1\n            s[i] = '0'\n    print(''.join(s))", "from collections import defaultdict\nimport math as m\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    fliped = [0] * n\n    s = list(input())\n    cnt = 0\n    flipcnt = 0\n    limit = n - k + 1\n    for i in range(n):\n        if i >= k and fliped[i - k]:\n            flipcnt -= 1\n        if flipcnt & 1:\n            if s[i] == '1':\n                s[i] = '0'\n            else:\n                s[i] = '1'\n        if s[i] == '1' and cnt < limit and (i <= n - k):\n            fliped[i] = 1\n            flipcnt += 1\n            s[i] = '0'\n            cnt += 1\n    print(''.join(s))", "for j in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    s = list(s)\n    fliped = [0] * n\n    flipcount = 0\n    count = 0\n    limit = n - k + 1\n    for i in range(n):\n        if i >= k and fliped[i - k]:\n            flipcount -= 1\n        if flipcount & 1:\n            if s[i] == '0':\n                s[i] = '1'\n            else:\n                s[i] = '0'\n        if s[i] == '1' and count < limit and (i <= n - k):\n            fliped[i] = 1\n            flipcount += 1\n            s[i] = '0'\n            count += 1\n    print(''.join(s))", "t = int(input())\nfor _ in range(0, t):\n    temp = input().split()\n    (n, k) = (int(temp[0]), int(temp[1]))\n    s = list(input())\n    queue = []\n    for i in range(n):\n        s[i] = int(s[i])\n        while len(queue) > 0:\n            if queue[0] < i:\n                queue.pop(0)\n            else:\n                break\n        s[i] = (s[i] + len(queue)) % 2\n        if s[i] == 0:\n            continue\n        if i < n - k + 1:\n            s[i] = 1 - s[i]\n            queue.append(i + k - 1)\n    print(''.join(map(str, s)))", "from operator import xor\nimport random\nimport math\nfrom collections import defaultdict, Counter\nfrom functools import lru_cache\nimport bisect\nimport heapq\n\nclass SegmentTree:\n\n    def __init__(self, nums):\n        self._size = len(nums)\n        self._tree = [0] * (4 * self._size)\n        self.build(nums)\n\n    def build(self, a, v=1, lo=0, hi=None):\n        if hi is None:\n            hi = self._size - 1\n        if lo == hi:\n            self._tree[v] = a[lo]\n        else:\n            mi = (lo + hi) // 2\n            self.build(a, 2 * v, lo, mi)\n            self.build(a, 2 * v + 1, mi + 1, hi)\n            self._tree[v] = self._tree[2 * v] + self._tree[2 * v + 1]\n\n    def update(self, pos, val, v=1, lo=0, hi=None):\n        if hi is None:\n            hi = self._size - 1\n        if lo == hi:\n            self._tree[v] = val\n        else:\n            mi = (lo + hi) // 2\n            if pos <= mi:\n                self.update(pos, val, 2 * v, lo, mi)\n            else:\n                self.update(pos, val, 2 * v + 1, mi + 1, hi)\n            self._tree[v] = self._tree[2 * v] + self._tree[2 * v + 1]\n\n    def query(self, l, h, v=1, lo=0, hi=None):\n        if hi is None:\n            hi = self._size - 1\n        if l > h:\n            return 0\n        elif l == lo and h == hi:\n            return self._tree[v]\n        else:\n            mi = (lo + hi) // 2\n            return self.query(l, min(mi, h), 2 * v, lo, mi) + self.query(max(mi + 1, l), h, 2 * v + 1, mi + 1, hi)\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = list(range(n))\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            self.parents[x] = y\ndire = [0, 1, 0, -1, 0]\n\ndef is_prime(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef google(t):\n    print('Case #{}:'.format(t), end=' ')\nRANDOM = random.randrange(2 ** 62)\n\ndef Wrapper(x):\n    return x ^ RANDOM\n\ndef solve():\n    (n, k) = map(int, input().split())\n    b = input()\n    dp = [0] * (n + 1)\n    for i in range(n + 1):\n        dp[i] += dp[i - 1]\n        if i <= n - k and (b[i] == '1') ^ dp[i] % 2:\n            dp[i] += 1\n            dp[i + k] -= 1\n        dp[i] = dp[i] % 2\n    ans = ''\n    for i in range(n):\n        if dp[i] == 1:\n            ans += '1' if b[i] == '0' else '0'\n        else:\n            ans += b[i]\n    print(ans)\nfor t in range(int(input())):\n    solve()", "import numpy as np\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, list(input())))\n    b = np.array(a)\n    for i in range(n - k + 1):\n        if b[i] == 1:\n            b[i:i + k] = 1 - b[i:i + k]\n    q = list(map(str, b))\n    print(*q, sep='')", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    B = list(input())\n    flipCount = 0\n    fliped = [0] * N\n    for i in range(N):\n        if i - K >= 0 and fliped[i - K]:\n            flipCount -= 1\n        if flipCount % 2:\n            if B[i] == '0':\n                B[i] = '1'\n            else:\n                B[i] = '0'\n        if B[i] == '1' and i < N - K + 1:\n            fliped[i] = 1\n            flipCount += 1\n            B[i] = '0'\n    print(''.join(B))", "def sol():\n    [n, k] = map(int, input().split(' '))\n    sk = input()\n    s = int(sk, 2)\n    kn = '1' * k\n    kn = int(kn, 2)\n    tkn = kn\n    kn = kn << n - k\n    while tkn != kn:\n        if s ^ kn < s:\n            s = s ^ kn\n        kn = kn >> 1\n    if s ^ kn < s:\n        s = s ^ kn\n    ans = ''\n    for i in range(n):\n        if s & 1 == 1:\n            ans = ans + '1'\n        else:\n            ans = ans + '0'\n        s = s >> 1\n    print(ans[::-1])\nt = int(input())\nwhile t:\n    sol()\n    t = t - 1", "import numpy as np\n\ndef func(string, N, K):\n    for i in range(N - K + 1):\n        if string[i] == 1:\n            string[i:i + K] = 1 - string[i:i + K]\n    string = list(map(str, string))\n    return ''.join(string)\nt = int(input())\nfor _ in range(t):\n    (N, K) = list(map(int, input().split()))\n    string = list(map(int, list(input())))\n    string = np.array(string)\n    print(func(string, N, K))", "import numpy as np\n\ndef func(string, N, K):\n    for i in range(N - K + 1):\n        if string[i] == 1:\n            string[i:i + K] = 1 - string[i:i + K]\n    string = list(map(str, string))\n    return ''.join(string)\nt = int(input())\nfor _ in range(t):\n    (N, K) = list(map(int, input().split()))\n    string = list(map(int, list(input())))\n    string = np.array(string)\n    print(func(string, N, K))", "import heapq\nt = int(input())\nwhile t:\n    s = input().split()\n    (n, k) = map(int, s)\n    s = input()\n    dp = [0 for i in range(n)]\n    ans = ''\n    flipCount = 0\n    for i in range(n - k + 1):\n        see = s[i]\n        if flipCount % 2 == 0:\n            act = see\n        else:\n            act = '1' if see == '0' else '0'\n        if act == '1':\n            dp[i] = 1\n            flipCount += 1\n        ans += '0'\n        if i - k + 1 >= 0:\n            flipCount -= dp[i - k + 1]\n    for i in range(n - k + 1, n):\n        see = s[i]\n        if flipCount % 2 == 0:\n            act = see\n        else:\n            act = '1' if see == '0' else '0'\n        ans += act\n        if i - k + 1 >= 0:\n            flipCount -= dp[i - k + 1]\n    print(ans)\n    t -= 1", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = list(input())\n    flip = [0] * (n + 1)\n    if s[0] == '1':\n        flip[0] = 1\n        flip[k - 1] = -1\n        s[0] = '0'\n    sm = flip[0]\n    for i in range(1, n - k + 1):\n        if sm % 2:\n            if s[i] == '0':\n                flip[i] += 1\n                flip[i + k - 1] -= 1\n            else:\n                s[i] = '0'\n        elif s[i] == '1':\n            s[i] = '0'\n            flip[i] += 1\n            flip[i + k - 1] -= 1\n        sm += flip[i]\n    for i in range(n - k + 1, n):\n        if sm % 2:\n            if s[i] == '1':\n                s[i] = '0'\n            else:\n                s[i] = '1'\n        sm += flip[i]\n    print(''.join(s))", "from sys import stdin, stdout\nt = stdin.readline()\nfor _ in range(int(t)):\n    (n, k) = [int(x) for x in stdin.readline().split()]\n    b = list(map(int, *stdin.readline().split()))\n    d = 0\n    q = []\n    while d <= n - k + 1:\n        for i in range(n):\n            for a in q:\n                if a < i - k + 1:\n                    q.remove(a)\n                else:\n                    break\n            if len(q) % 2 == 0:\n                if b[i] == 1:\n                    if i <= n - k:\n                        b[i] = 0\n                        q.append(i)\n                        d += 1\n            elif b[i] == 0:\n                if i <= n - k:\n                    q.append(i)\n                    d += 1\n                else:\n                    b[i] = 1\n            else:\n                b[i] = 0\n        break\n    print(''.join(map(str, b)))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    ans = []\n    moves = []\n    ptr = 0\n    for i in range(n):\n        while ptr < len(moves):\n            if moves[ptr] + k <= i:\n                ptr += 1\n            else:\n                break\n        cur = 0 if s[i] == '0' else 1\n        changes = len(moves) - ptr\n        cur ^= changes % 2\n        if i + k > n:\n            ans.append(cur)\n        else:\n            ans.append(0)\n            if cur == 1:\n                moves.append(i)\n    print(''.join((str(x) for x in ans)))", "t = int(input())\nfor k in range(t):\n    (n, k) = map(int, input().split())\n    s = list(input())\n    s.insert(0, 0)\n    a = [0] * (2 * n + 1)\n    t = 0\n    for i in range(1, n - k + 2):\n        if (int(s[i]) + t) % 2 == 1:\n            t += 1\n            a[i + k - 1] = 1\n        t -= a[i]\n        s[i] = 0\n    for i in range(n - k + 2, n + 1):\n        s[i] = (int(s[i]) + t) % 2\n        t -= a[i]\n    for i in range(1, n + 1):\n        print(s[i], end='')\n    print()", "t = int(input())\nfor k in range(t):\n    (n, k) = map(int, input().split())\n    s = list(input())\n    s.insert(0, 0)\n    a = [0] * (2 * n + 1)\n    t = 0\n    for i in range(1, n - k + 2):\n        if (int(s[i]) + t) % 2 == 1:\n            t += 1\n            a[i + k - 1] = 1\n        t -= a[i]\n        s[i] = 0\n    for i in range(n - k + 2, n + 1):\n        s[i] = (int(s[i]) + t) % 2\n        t -= a[i]\n    for i in range(1, n + 1):\n        print(s[i], end='')\n    print()", "t = int(input())\nfor k in range(t):\n    (n, k) = map(int, input().split())\n    s = list(input())\n    s.insert(0, 0)\n    a = [0] * (2 * n + 1)\n    t = 0\n    for i in range(1, n - k + 2):\n        if (int(s[i]) + t) % 2 == 1:\n            t += 1\n            a[i + k - 1] = 1\n        t -= a[i]\n        s[i] = 0\n    for i in range(n - k + 2, n + 1):\n        s[i] = 5 + (int(s[i]) + t) % 2\n        t -= a[i]\n    for i in range(1, n + 1):\n        print(s[i] % 5, end='')\n    print()", "import math, sys\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappush, heappop\nfrom bisect import bisect_left\nINF = float('inf')\n\ndef solve():\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input()))\n    s = []\n    for i in range(n - k + 1):\n        j = len(s) - bisect_left(s, i - k + 1)\n        if j % 2 == 1:\n            arr[i] ^= 1\n        if arr[i]:\n            arr[i] = 0\n            s.append(i)\n    for i in range(n - k + 1, n):\n        j = len(s) - bisect_left(s, i - k + 1)\n        if j % 2 == 1:\n            arr[i] ^= 1\n    print(*arr, sep='')\n\ndef input():\n    return sys.stdin.readline().rstrip('\\n').strip()\n\ndef print(*args, sep=' ', end='\\n'):\n    first = True\n    for arg in args:\n        if not first:\n            sys.stdout.write(sep)\n        sys.stdout.write(str(arg))\n        first = False\n    sys.stdout.write(end)\nts = 1\nts = int(input())\nfor t in range(1, ts + 1):\n    solve()", "import math\nt = int(input())\nwhile t:\n    (n, k) = map(int, input().split())\n    l = list(input())\n    ans = []\n    flips = 0\n    for i in range(n):\n        if i >= k - 1 and i < n - k + 1:\n            ans.append(flips)\n            if l[i] == '1' and (flips - ans[i - k + 1]) % 2 == 0 or (l[i] == '0' and (flips - ans[i - k + 1]) % 2 != 0):\n                l[i] = '0'\n                flips += 1\n            else:\n                l[i] = '0'\n        elif i < min(k - 1, n - k + 1):\n            ans.append(flips)\n            if l[i] == '1' and flips % 2 == 0 or (l[i] == '0' and flips % 2 != 0):\n                l[i] = '0'\n                flips += 1\n            else:\n                l[i] = '0'\n        elif i - k + 1 >= 0:\n            if (flips - ans[i - k + 1]) % 2 != 0:\n                if l[i] == '1':\n                    l[i] = '0'\n                else:\n                    l[i] = '1'\n        elif flips % 2 != 0:\n            if l[i] == '1':\n                l[i] = '0'\n            else:\n                l[i] = '1'\n    print(''.join(l))\n    t -= 1", "import bisect\nfor _ in range(int(input())):\n    (str_len, flip_len) = [int(num) for num in input().split()]\n    binary_str = input()\n    flips = []\n    result = []\n    for i in range(str_len):\n        first_flip_idx = bisect.bisect_right(flips, i - flip_len)\n        last_flip_idx = bisect.bisect_left(flips, i)\n        flips_num = last_flip_idx - first_flip_idx\n        flip_possible = i <= str_len - flip_len\n        flip_required = int(binary_str[i]) and flips_num % 2 == 0 or (not int(binary_str[i]) and flips_num % 2 != 0)\n        if flip_possible and flip_required:\n            flips.append(i)\n            flips_num += 1\n        if int(binary_str[i]) and flips_num % 2 != 0 or (not int(binary_str[i]) and flips_num % 2 == 0):\n            result.append('0')\n        else:\n            result.append('1')\n    print(''.join(result))", "from sys import stdin\ninput = stdin.readline\nl = int(input())\nfor _ in range(l):\n    (o, k) = map(int, input().split())\n    s = input().strip()\n    q = list(s)\n    count = 0\n    t = {}\n    for i in range(o - k + 1):\n        if (int(q[i]) + count) % 2 == 0:\n            q[i] = '0'\n        else:\n            q[i] = '0'\n            count += 1\n            t[i + k - 1] = 1\n        if t.get(i):\n            count -= 1\n    for i in range(o - k + 1, o):\n        if (int(q[i]) + count) % 2 == 0:\n            q[i] = '0'\n        else:\n            q[i] = '1'\n        if t.get(i):\n            count -= 1\n    answer = ''.join(q)\n    print(answer)", "from sys import stdin\ninput = stdin.readline\ntest = int(input())\nfor _ in range(test):\n    (n, k) = map(int, input().split())\n    s = input().strip()\n    a = list(s)\n    c = 0\n    d = {}\n    for i in range(n - k + 1):\n        if (int(a[i]) + c) % 2 == 0:\n            a[i] = '0'\n        else:\n            a[i] = '0'\n            c += 1\n            d[i + k - 1] = 1\n        if d.get(i):\n            c -= 1\n    for i in range(n - k + 1, n):\n        if (int(a[i]) + c) % 2 == 0:\n            a[i] = '0'\n        else:\n            a[i] = '1'\n        if d.get(i):\n            c -= 1\n    ans = ''.join(a)\n    print(ans)\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def DFSUtil(self, v, visited):\n        visited.add(v)\n        print(v, end=' ')\n        for neighbour in self.graph[v]:\n            if neighbour not in visited:\n                self.DFSUtil(neighbour, visited)", "import bisect\nfor _ in range(int(input())):\n    (str_len, flip_len) = [int(num) for num in input().split()]\n    binary_str = input()\n    flips = []\n    result = []\n    for i in range(str_len):\n        first_flip_idx = bisect.bisect_right(flips, i - flip_len)\n        last_flip_idx = bisect.bisect_left(flips, i)\n        flips_num = last_flip_idx - first_flip_idx\n        flip_possible = i <= str_len - flip_len\n        flip_required = int(binary_str[i]) and flips_num % 2 == 0 or (not int(binary_str[i]) and flips_num % 2 != 0)\n        if flip_possible and flip_required:\n            flips.append(i)\n            flips_num += 1\n        if int(binary_str[i]) and flips_num % 2 != 0 or (not int(binary_str[i]) and flips_num % 2 == 0):\n            result.append('0')\n        else:\n            result.append('1')\n    print(''.join(result))", "from sys import stdin\ninput = stdin.readline\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    s = input().strip()\n    a = list(s)\n    count = 0\n    d = {}\n    for i in range(n - k + 1):\n        if (int(a[i]) + count) % 2 == 0:\n            a[i] = '0'\n        else:\n            a[i] = '0'\n            count += 1\n            d[i + k - 1] = 1\n        if d.get(i):\n            count -= 1\n    for i in range(n - k + 1, n):\n        if (int(a[i]) + count) % 2 == 0:\n            a[i] = '0'\n        else:\n            a[i] = '1'\n        if d.get(i):\n            count -= 1\n    ans = ''.join(a)\n    print(ans)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input()))\n    t = 0\n    a = [0] * 2 * N\n    for i in range(0, N - K + 1):\n        if (A[i] + t) % 2 == 1:\n            t += 1\n            a[i + K - 1] = 1\n        t -= a[i]\n        A[i] = 0\n    for j in range(N - K + 1, N):\n        A[j] = (A[j] + t) % 2\n        t -= a[j]\n    for i in range(0, N):\n        print(A[i], end='')\n    print()", "T = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    S = list(input())\n    A = [0] * (2 * N + 1)\n    X = 0\n    for i in range(N - K + 1):\n        if (int(S[i]) + X) % 2 == 1:\n            X += 1\n            A[i + K - 1] = 1\n        X -= A[i]\n        S[i] = 0\n    i = N - K + 2\n    res = []\n    for i in range(N - K + 1, N):\n        S[i] = (int(S[i]) + X) % 2\n        X -= A[i]\n    for i in range(N):\n        res.append(str(S[i]))\n    print(''.join(res))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    q = input()\n    s = list(q)\n    for i in range(len(q)):\n        s[i] = int(s[i])\n    a = [0] * (2 * n)\n    t = 0\n    for i in range(n - k + 1):\n        if (s[i] + t) % 2 == 1:\n            t += 1\n            a[i + k - 1] = 1\n        t -= a[i]\n        s[i] = 0\n    for i in range(n - k + 1, n):\n        s[i] = 0 + (s[i] + t) % 2\n        t -= a[i]\n    for i in range(len(s)):\n        s[i] = str(s[i])\n    print(''.join(s))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = list(input())\n    flip = [0] * (n + 1)\n    if s[0] == '1':\n        flip[0] = 1\n        flip[k - 1] = -1\n        s[0] = '0'\n    sm = flip[0]\n    for i in range(1, n - k + 1):\n        if sm % 2:\n            if s[i] == '0':\n                flip[i] += 1\n                flip[i + k - 1] -= 1\n            else:\n                s[i] = '0'\n        elif s[i] == '1':\n            s[i] = '0'\n            flip[i] += 1\n            flip[i + k - 1] -= 1\n        sm += flip[i]\n    for i in range(n - k + 1, n):\n        if sm % 2:\n            if s[i] == '1':\n                s[i] = '0'\n            else:\n                s[i] = '1'\n        sm += flip[i]\n    print(''.join(s))", "import numpy as np\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    a = np.zeros((n,), dtype=int)\n    one = np.ones((n,), dtype=int)\n    for (i, v) in enumerate(s):\n        a[i] = int(v)\n    for i in np.arange(n - k + 1):\n        if a[i] == 1:\n            a[i:i + k] = a[i:i + k] ^ one[i:i + k]\n    for i in a:\n        print(i, end='')\n    print()", "for _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    s = input()\n    pre = 0\n    ans = ''\n    a = [0] * (n + 1)\n    for i in range(n):\n        pre += a[i]\n        pre %= 2\n        cur = ord(s[i]) - ord('0')\n        if i < n - k + 1:\n            ans += '0'\n            a[i + k] -= pre ^ cur\n            pre += pre ^ cur\n            pre %= 2\n        else:\n            ans += str(pre ^ cur)\n    print(ans)", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    sr = input()\n    s = []\n    for i in sr:\n        s.append(int(i))\n    A = [0] * (2 * n)\n    a = 0\n    for i in range(1, n - k + 2):\n        if (int(s[i - 1]) + a) % 2 == 1:\n            a += 1\n            A[i + k - 1] = 1\n        a -= A[i]\n        s[i - 1] = 48\n    for i in range(n - k + 2, n + 1):\n        s[i - 1] = 48 + (s[i - 1] + a) % 2\n        a -= A[i]\n    l = ''\n    for i in s:\n        l += str(i - 48)\n    print(l)", "T = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    S = input()\n    s = []\n    flag = 0\n    marker = 0\n    maxi = 9999\n    mini = -9999\n    bool = True\n    for i in S:\n        flag += 1\n        s.append(int(i))\n        maxi -= flag\n        mini += flag\n    t = 0\n    Bool = False\n    check = 1\n    a = []\n    for i in range(0, 2 * N):\n        check += maxi\n        bool = True\n        a.append(0)\n    checker = -1\n    marker -= check\n    for i in range(0, N - K + 1):\n        Bool = True\n        if (int(s[i]) + t) % 2 == 1:\n            marker -= 1\n            t += 1\n            flag += mini\n            maxi -= marker\n            a[i + K - 1] = 1\n            marker += check\n        t -= a[i]\n        check += 1\n        s[i] = 0\n        marker += check\n    for i in range(N - K + 1, N):\n        check -= 1\n        marker += maxi\n        mini += maxi\n        s[i] = (int(s[i]) + t) % 2\n        t -= a[i]\n        marker -= 99\n    ans = ''\n    rest = 'api'\n    for i in range(N):\n        check += 1\n        Bool = False\n        bool = True\n        ans += str(s[i])\n        marker -= flag\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    s1 = list(map(int, input()))\n    s = [None] + s1\n    x = 0\n    a = [0] * (2 * n + 1)\n    for i in range(1, n - k + 2):\n        if (s[i] + x) % 2 == 1:\n            x += 1\n            a[i + k - 1] = 1\n        x -= a[i]\n        s[i] = 48\n    for i in range(n - k + 2, n + 1):\n        s[i] = (48 + s[i] + x) % 2\n        x -= a[i]\n    for i in range(1, n + 1):\n        print(s[i] % 2, end='')\n    print()", "from collections import Counter\nimport math\n\ndef solve():\n    (n, k) = map(int, input().split(' '))\n    lst = list(map(int, list(input())))\n    smLst = []\n    for i in range(n):\n        smLst.append(0)\n    temp = 0\n    for i in range(n - k + 1):\n        if (lst[i] + temp) % 2 == 1:\n            smLst[i + k - 1] = 1\n            temp += 1\n        temp -= smLst[i]\n        lst[i] = 12\n    for i in range(n - k + 1, n):\n        lst[i] = 12 + (lst[i] + temp) % 2\n        temp -= smLst[i]\n    for i in range(n):\n        lst[i] -= 12\n    lst = list(map(str, lst))\n    s = ''.join(lst)\n    print(s)\nt = int(input())\nfor _ in range(t):\n    solve()", "import os.path\nfrom math import gcd, floor, ceil, log2\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nfor _ in range(int(input())):\n    (n, k) = mp()\n    s = list(input())\n    t = 0\n    a = [0] * (2 * n + 1)\n    for i in range(n - k + 1):\n        if (int(s[i]) + t) % 2 == 1:\n            t += 1\n            a[i + k - 1] = 1\n        t -= a[i]\n        s[i] = chr(48)\n    for i in range(n - k + 1, n):\n        s[i] = chr(48 + (int(s[i]) + t) % 2)\n        t -= a[i]\n    p = ''\n    for i in s:\n        p += i\n    print(p)", "t = int(input())\nfor _ in range(t):\n    (a, b) = map(int, input().strip().split(' '))\n    s = input()\n    ans = ''\n    c = 0\n    li = [0 for i in range(a + 1)]\n    for i in range(a):\n        c = c + li[i]\n        if i + b <= a:\n            if s[i] == '1' and c % 2 == 0 or (s[i] == '0' and c % 2 == 1):\n                c = c + 1\n                li[i + b] = li[i + b] - 1\n            ans = ans + '0'\n        elif c % 2 == 0:\n            ans = ans + s[i]\n        elif s[i] == '0':\n            ans = ans + '1'\n        else:\n            ans = ans + '0'\n    print(ans)", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random, threading\nfrom functools import lru_cache\nfrom itertools import *\nimport sys\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n(M, M1) = (1000000007, 998244353)\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for _ in range(how_much_noob_I_am):\n        (n, k) = sep()\n        s = list(inp())\n        res = []\n        for i in range(len(s)):\n            ind = bisect.bisect_left(res, i - k + 1)\n            tot = len(res) - ind\n            if tot % 2 != 0:\n                s[i] = str(int(s[i]) ^ 1)\n            if i + k - 1 < n:\n                if s[i] == '1':\n                    s[i] = '0'\n                    res.append(i)\n        print(''.join(s))\nmain()", "iter = int(input())\nfor z in range(iter):\n    (n, k) = list(map(int, input().split(' ')))\n    s = input()\n    pre = [0] * n\n    cum = 0\n    ans = '0' * (n - k + 1)\n    for i in range(n - k + 1):\n        if cum == 0 and s[i] == '1' or (cum == 1 and s[i] == '0'):\n            pre[i] ^= 1\n            pre[i + k - 1] ^= 1\n        cum ^= pre[i]\n    for i in range(n - k + 1, n):\n        if cum == 1:\n            if s[i] == '1':\n                ans += '0'\n            else:\n                ans += '1'\n        else:\n            ans += s[i]\n        cum ^= pre[i]\n    print(ans)", "t = int(input())\nfor i in range(t):\n    [N, K] = [int(i) for i in input().split()]\n    s = input()\n    fliparr = [-1] * N\n    length = 0\n    flip = 0\n    for i in range(N - K + 1):\n        if i == 0:\n            if s[i] == '1':\n                flip += 1\n                fliparr[i] = flip\n            else:\n                fliparr[i] = flip\n        else:\n            if max(0, i - K + 1) == 0:\n                if fliparr[0] == 1:\n                    val = fliparr[i - 1] - fliparr[0] + 1\n                else:\n                    val = fliparr[i - 1] - fliparr[0]\n            elif fliparr[i - K + 1] == fliparr[i - K]:\n                val = fliparr[i - 1] - fliparr[i - K + 1]\n            else:\n                val = fliparr[i - 1] - fliparr[i - K + 1] + 1\n            if s[i] == '1' and val % 2 == 0:\n                flip += 1\n                fliparr[i] = flip\n            if s[i] == '0' and val % 2 == 1:\n                flip += 1\n                fliparr[i] = flip\n            if s[i] == '1' and val % 2 == 1:\n                fliparr[i] = flip\n            if s[i] == '0' and val % 2 == 0:\n                fliparr[i] = flip\n    if N == 1:\n        print(0)\n    elif N > K:\n        for i in range(N - K + 1, N):\n            if max(0, i - K + 1) == 0:\n                if fliparr[0] == 1:\n                    val = fliparr[N - K]\n                else:\n                    val = fliparr[N - K]\n            elif max(0, i - K + 1) == i - K + 1:\n                if fliparr[i - K] == fliparr[i - K + 1]:\n                    val = fliparr[N - K] - fliparr[i - K + 1]\n                else:\n                    val = fliparr[N - K] - fliparr[i - K + 1] + 1\n            if val % 2 == 0:\n                if s[i] == '0':\n                    fliparr[i] = 0\n                else:\n                    fliparr[i] = 1\n            elif s[i] == '0':\n                fliparr[i] = 1\n            else:\n                fliparr[i] = 0\n        ans = [0] * (N - K + 1)\n        for i in range(N - K + 1, N):\n            ans.append(fliparr[i])\n        for i in ans:\n            print(i, end='')\n        print()\n    elif N == K:\n        ans = [0]\n        if s[0] == '0':\n            for i in range(1, N):\n                ans.append(int(s[i]))\n        else:\n            for i in range(1, N):\n                if int(s[i]) == 0:\n                    ans.append(1)\n                else:\n                    ans.append(0)\n        for i in ans:\n            print(i, end='')\n        print()", "from collections import deque\nT = int(input())\n\ndef solve(lst, N, K):\n    f = 0\n    Q = deque()\n    for i in range(N - K + 1):\n        if Q and Q[0] < i:\n            Q.popleft()\n        if len(Q) % 2 == 1:\n            num = 1 - lst[i]\n        else:\n            num = lst[i]\n        if num == 1:\n            lst[i] = 0\n            Q.append(i + K - 1)\n        else:\n            lst[i] = num\n    for i in range(N - K + 1, N):\n        if Q and Q[0] < i:\n            Q.popleft()\n        if len(Q) % 2 == 1:\n            lst[i] = 1 - lst[i]\n    return ''.join([str(x) for x in lst])\n    return ''.join([str(x) for x in lst])\nfor _ in range(T):\n    (N, K) = [int(x) for x in input().split()]\n    st = [int(x) for x in list(input())]\n    print(solve(st, N, K))", "def display(arr):\n    for i in arr:\n        print(i, end='')\n    print()\n\ndef k_flip():\n    (n, k) = map(int, input().split())\n    string = list(input())\n    temp = 0\n    zeroes = list(map(int, list('0' * (2 * n + 1))))\n    for i in range(n - k + 1):\n        if (int(string[i]) + temp) % 2 == 1:\n            temp += 1\n            zeroes[i + k - 1] = 1\n        temp -= zeroes[i]\n        string[i] = 0\n    for i in range(n - k + 1, n):\n        string[i] = (int(string[i]) + temp) % 2\n        temp -= zeroes[i]\n    display(string)\nfor _ in range(int(input())):\n    k_flip()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    opp = n - k + 1\n    s = [0] * 100001\n    a = [0] * 200001\n    t = 0\n    string = input()\n    for i in range(1, n + 1):\n        s[i] = int(string[i - 1])\n    for i in range(1, n - k + 2):\n        if (s[i] + t) % 2 == 1:\n            t += 1\n            a[i + k - 1] = 1\n        t -= a[i]\n        s[i] = 32\n    for i in range(n - k + 2, n + 1):\n        s[i] = 32 + (s[i] + t) % 2\n        t -= a[i]\n    ans = ''\n    for i in range(1, n + 1):\n        ans += str(s[i] % 32)\n    print(ans)", "from collections import deque\nT = int(input())\nfor i in range(T):\n    (N, K) = [int(z) for z in input().strip().split()]\n    string = list(input())\n    queue = deque()\n    for i in range(N - K + 1):\n        if len(queue) > 0:\n            ele = queue.popleft()\n            if i - ele < K:\n                queue.appendleft(ele)\n        if len(queue) % 2 == 0 and string[i] == '1':\n            string[i] = '0'\n            queue.append(i)\n        elif len(queue) % 2 == 1 and string[i] == '0':\n            queue.append(i)\n        elif len(queue) % 2 == 1 and string[i] == '1':\n            string[i] = '0'\n    for i in range(N - K + 1, N):\n        if len(queue) > 0:\n            ele = queue.popleft()\n            if i - ele < K:\n                queue.appendleft(ele)\n        if len(queue) % 2 == 1:\n            string[i] = str(1 - int(string[i]))\n    print(''.join(string))", "def sol():\n    (n, k) = map(int, input().split())\n    st = input()\n    s = []\n    for i in st:\n        s.append(ord(i))\n    a = [None] * 200001\n    t = 0\n    for i in range(0, 2 * n + 1):\n        a[i] = 0\n    for i in range(0, n - k + 1):\n        if (s[i] + t) % 2 == 1:\n            t += 1\n            a[i + k - 1] = 1\n        t -= a[i]\n        s[i] = 48\n    for i in range(n - k + 1, n):\n        s[i] = 48 + (s[i] + t) % 2\n        t -= a[i]\n    for i in s:\n        print(chr(i), end='')\n    print()\nT = int(input())\nfor t in range(T):\n    sol()", "t = int(input())\nfor k in range(t):\n    (n, k) = map(int, input().split())\n    s = list(input())\n    s.insert(0, 0)\n    a = [0] * (2 * n + 1)\n    t = 0\n    for i in range(1, n - k + 2):\n        if (int(s[i]) + t) % 2 == 1:\n            t += 1\n            a[i + k - 1] = 1\n        t -= a[i]\n        s[i] = 5\n    for i in range(n - k + 2, n + 1):\n        s[i] = 5 + (int(s[i]) + t) % 2\n        t -= a[i]\n    for i in range(1, n + 1):\n        print(s[i] % 5, end='')\n    print()", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    (p, s) = (input(), [0] * (n + 1))\n    for i in range(1, n + 1):\n        s[i] = int(p[i - 1])\n    (t, x) = (0, [0] * (2 * n + 1))\n    for i in range(n - k + 2):\n        if (t + s[i]) % 2:\n            (x[i + k - 1], t) = (1, t + 1)\n        t -= x[i]\n        s[i] = 48\n    for i in range(n - k + 2, n + 1):\n        s[i] = (t + s[i]) % 2 + 48\n        t -= x[i]\n    for i in range(1, n + 1):\n        print(chr(s[i]), end='')\n    print()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    l = [val for val in s]\n    arr = [0 for i in range(n + 1)]\n    for i in range(n):\n        if i <= n - k:\n            if i == 0:\n                if s[i] == '1':\n                    arr[i] += 1\n                    arr[i + k] -= 1\n                    l[i] = '0'\n            else:\n                arr[i] += arr[i - 1]\n                if s[i] == '1':\n                    if arr[i] % 2:\n                        l[i] = '0'\n                    else:\n                        arr[i] += 1\n                        arr[i + k] -= 1\n                        l[i] = '0'\n                elif arr[i] % 2:\n                    arr[i] += 1\n                    arr[i + k] -= 1\n                    l[i] = '0'\n                else:\n                    l[i] = '0'\n        else:\n            arr[i] += arr[i - 1]\n            if s[i] == '1' and arr[i] % 2:\n                l[i] = '0'\n            elif s[i] == '0' and arr[i] % 2:\n                l[i] = '1'\n    ans = ''\n    for val in l:\n        ans += val\n    print(ans)", "import numpy as np\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    a = np.zeros((n,), dtype=int)\n    one = np.ones((n,), dtype=int)\n    for (i, v) in enumerate(s):\n        a[i] = int(v)\n    for i in np.arange(n - k + 1):\n        if a[i] == 1:\n            a[i:i + k] = a[i:i + k] ^ one[i:i + k]\n    for i in a:\n        print(i, end='')\n    print()", "t = int(input())\nwhile t:\n    (p, q) = map(int, input().split())\n    s = input()\n    (s, j) = ([*s], 2 * p + 1)\n    (m, check, h) = ([0] * j, 0, 1)\n    while h < p - q + 2:\n        if (check + int(s[h - 1])) % 2 == 1:\n            check = check + 1\n            m[q + h - 1] = 1\n        check = check - m[h]\n        s[h - 1] = 48\n        h += 1\n    h = p - q + 2\n    while h < p + 1:\n        s[h - 1] = (check + int(s[h - 1])) % 2 + 48\n        check = check - m[h]\n        h += 1\n    print(''.join((chr(i) for i in s)))\n    t -= 1", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    ans = []\n    arr = [0] * (n + 1)\n    c = 0\n    op = 0\n    for i in range(n - k + 1):\n        op += 1\n        f = 0\n        if s[i] == '1':\n            if (c - arr[i]) % 2 == 0:\n                ans.append('0')\n                c += 1\n                f = 1\n            else:\n                ans.append('0')\n        elif (c - arr[i]) % 2 == 1:\n            ans.append('0')\n            c += 1\n            f = 1\n        else:\n            ans.append('0')\n        arr[i + k] = c\n    for i in range(n - k + 1, n):\n        if s[i] == '1':\n            if abs(arr[i] - c) % 2 == 1:\n                ans.append('0')\n            else:\n                ans.append('1')\n        elif abs(arr[i] - c) % 2 == 0:\n            ans.append('0')\n        else:\n            ans.append('1')\n    print(''.join(ans))", "I = lambda : list(map(int, input().split()))\nimport bisect as bi\ninv = lambda x: '1' if x == '0' else '0'\n(t,) = I()\nfor i in range(t):\n    (n, k) = I()\n    s = input().strip()\n    ops = []\n    an = ''\n    for i in range(n):\n        flip = len(ops) - bi.bisect_right(ops, i - k)\n        if i + k <= n:\n            cur = ord(s[i]) - ord('0') ^ (flip % 2 != 0)\n            if cur:\n                ops.append(i)\n            an += '0'\n        else:\n            an += inv(s[i]) if flip % 2 else s[i]\n    print(an)", "ri = lambda : int(input())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\nt = ri()\nfor test in range(t):\n    (n, k) = rl()\n    s = list(rs())\n    mx = n - k + 1\n    pre = [0] * (n + 1)\n    i = 0\n    p = 0\n    while i < n:\n        pre[i] += p\n        if s[i] == '0' and pre[i] % 2 or (s[i] == '1' and pre[i] % 2 == 0):\n            if mx > 0 and i + k <= n:\n                pre[i] += 1\n                pre[i + k] -= 1\n                mx -= 1\n        p = pre[i]\n        i += 1\n    for i in range(n):\n        if s[i] == '0' and pre[i] % 2:\n            s[i] = '1'\n        elif s[i] == '1' and pre[i] % 2:\n            s[i] = '0'\n    print(''.join(s))", "t = int(input())\nfor i in range(t):\n    [n, k] = list(map(int, input().split(' ')))\n    arr = list(input())\n    d = []\n    for j in range(0, n):\n        if len(d) and d[0] < j:\n            d.pop(0)\n            p = 0\n            while True:\n                if p == len(d):\n                    break\n                if d[p] >= j:\n                    break\n                else:\n                    d.pop(0)\n        ch = len(d)\n        if ch != 0:\n            if ch % 2 != 0:\n                arr[j] = str(int(not int(arr[j])))\n        if j < n - k + 1:\n            if arr[j] == '1':\n                arr[j] = str(int(not int(arr[j])))\n                d.append(j + k - 1)\n    print(''.join(arr))", "T = int(input())\nfor i in range(T):\n    (N, K) = [int(x) for x in input().split()]\n    S = [0]\n    tempo = input()\n    for i in tempo:\n        if i == '1':\n            S.append(1)\n        else:\n            S.append(0)\n    a = [0] * (2 * N)\n    temp = 0\n    for i in range(1, N - K + 2):\n        if (S[i] + temp) % 2 == 1:\n            temp += 1\n            a[i + K - 1] = 1\n        temp -= a[i]\n        S[i] = 48\n    for i in range(N - K + 2, N + 1):\n        S[i] = (48 + S[i] + temp) % 2\n        temp -= a[i]\n    print('0' * (N - K + 1), end='')\n    for i in S[N - K + 2:]:\n        print(i, end='')\n    print()", "t = int(input())\nwhile t:\n    (n, k) = map(int, input().split())\n    s = input()\n    s = list('b' + s)\n    a = [0] * (2 * n)\n    c = 0\n    for i in range(1, n - k + 2):\n        if (int(s[i]) + c) % 2 == 1:\n            c += 1\n            a[i + k - 1] = 1\n        c -= a[i]\n        s[i] = 0\n    for i in range(n - k + 2, n + 1):\n        s[i] = 0 + (int(s[i]) + c) % 2\n        c -= a[i]\n    for i in range(1, n + 1):\n        print(f'{s[i]}', end='', sep='')\n    print()\n    t -= 1", "for i in range(int(input())):\n    (n, k) = [int(j) for j in input().split()]\n    s = [int(j) for j in input()]\n    out = []\n    flip = False\n    next_flip = [False for j in range(n + 1)]\n    for j in range(n - k + 1):\n        if next_flip[j] == True:\n            flip = not flip\n        if not flip and s[j] == 1 or (flip and s[j] == 0):\n            out.append(0)\n            flip = not flip\n            next_flip[j + k] = not next_flip[j + k]\n        else:\n            out.append(0)\n    for j in range(n - k + 1, n):\n        if next_flip[j] == True:\n            flip = not flip\n        if flip:\n            if s[j] == 0:\n                out.append(1)\n            else:\n                out.append(0)\n        else:\n            out.append(s[j])\n    print(''.join([str(j) for j in out]))", "def Solution(C, B):\n    (N, K) = C\n    S = [B[i] for i in range(N)]\n    ans = ''\n    L = [0 for x in range(N + 1)]\n    v = 0\n    for i in range(N):\n        v += L[i]\n        if v % 2 == 0:\n            if S[i] == '0':\n                ans += '0'\n            elif S[i] == '1':\n                if i < N - K + 1:\n                    ans += '0'\n                    v += 1\n                    L[i + K] += -1\n                else:\n                    ans += '1'\n        elif S[i] == '0':\n            if i < N - K + 1:\n                ans += '0'\n                v += 1\n                L[i + K] += -1\n            else:\n                ans += '1'\n        elif S[i] == '1':\n            ans += '0'\n    return ans\nfor T in range(int(input())):\n    C = map(int, input().split())\n    B = input()\n    ans = Solution(C, B)\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = [i for i in input()]\n    arr = [0 for _ in range(n)]\n    pre = 0\n    for i in range(n - k + 1):\n        if i >= k:\n            pre -= arr[i - k]\n        if s[i] == '1' and pre % 2 == 0 or (s[i] == '0' and pre % 2 == 1):\n            arr[i] = 1\n            pre += 1\n    s[:n - k + 1] = ['0' for _ in range(n - k + 1)]\n    for i in range(n - k + 1, n):\n        if i >= k:\n            pre -= arr[i - k]\n        if pre % 2 == 1:\n            if s[i] == '0':\n                s[i] = '1'\n            else:\n                s[i] = '0'\n    print(*s, sep='')", "n_tests = int(input())\nfor _ in range(n_tests):\n    (n, k) = map(int, input().split())\n    S = int(input(), 2)\n    k1 = int('1' * k, 2)\n    for i in range(n - 1, k - 2, -1):\n        if S >> i:\n            S ^= k1 << i - k + 1\n    end = bin(S)[2:]\n    print('0' * (n - len(end)) + end)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    l = [int(i) for i in s]\n    ob = [0 for i in range(len(l))]\n    count = 0\n    flips = 0\n    for i in range(len(l) - k + 1):\n        if i > 0:\n            ob[i] += ob[i - 1]\n        if l[i] == 1 and (flips - ob[i]) % 2 == 0 or (l[i] == 0 and (flips - ob[i]) % 2 != 0):\n            flips += 1\n            if i + k != len(l):\n                ob[i + k] += 1\n            count += 1\n        l[i] = 0\n        if count == n - k + 1:\n            break\n    if i == len(l) - k + 1:\n        i -= 1\n    for j in range(i + 1, len(l)):\n        if j > 0:\n            ob[j] += ob[j - 1]\n        if l[j] == 1 and (flips - ob[j]) % 2 != 0:\n            l[j] = 0\n        elif l[j] == 0 and (flips - ob[j]) % 2 != 0:\n            l[j] = 1\n    ans = ''\n    for i in l:\n        ans += str(i)\n    print(ans)"]