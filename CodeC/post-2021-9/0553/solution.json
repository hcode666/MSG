["from collections import defaultdict as dd\nfrom sys import stdin, stdout, setrecursionlimit\n(readline, writeline) = (stdin.readline, stdout.write)\nsetrecursionlimit(100005)\n\ndef dfs(x, visited, lst):\n    lst.append(x)\n    visited.add(x)\n    for i in graph[x]:\n        if i not in visited:\n            dfs(i, visited, lst)\nfor _ in range(int(readline())):\n    (n, m) = map(int, readline().split())\n    deg = [0] * (n + 1)\n    graph = dd(list)\n    for i in range(m):\n        (u, v) = map(int, readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n    visited = set()\n    (ans, cnt) = (0, 0)\n    for i in range(1, n + 1):\n        if i not in visited:\n            lst = []\n            dfs(i, visited, lst)\n            visited.add(i)\n            l = len(lst)\n            flag = 1\n            for j in lst:\n                if deg[j] != l - 1:\n                    flag = 0\n                    break\n            if flag:\n                ans += 1\n            cnt += 1\n    if cnt == 1:\n        ans = 0\n    print(ans)", "from collections import defaultdict as dd\nfrom sys import stdin, stdout, setrecursionlimit\n(readline, writeline) = (stdin.readline, stdout.write)\nsetrecursionlimit(100005)\n\ndef dfs(x, visited, lst):\n    lst.append(x)\n    visited.add(x)\n    for i in graph[x]:\n        if i not in visited:\n            dfs(i, visited, lst)\nfor _ in range(int(readline())):\n    (n, m) = map(int, readline().split())\n    deg = [0] * (n + 1)\n    graph = dd(list)\n    for i in range(m):\n        (u, v) = map(int, readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n    visited = set()\n    (ans, cnt) = (0, 0)\n    for i in range(1, n + 1):\n        if i not in visited:\n            lst = []\n            dfs(i, visited, lst)\n            visited.add(i)\n            l = len(lst)\n            flag = 1\n            for j in lst:\n                if deg[j] != l - 1:\n                    flag = 0\n                    break\n            if flag:\n                ans += 1\n            cnt += 1\n    if cnt == 1:\n        ans = 0\n    print(ans)", "from collections import defaultdict as dd\nfrom sys import stdin, stdout, setrecursionlimit\n(readline, writeline) = (stdin.readline, stdout.write)\nsetrecursionlimit(100005)\n\ndef dfs(graph, x, visited, lst):\n    lst.append(x)\n    visited.add(x)\n    for i in graph[x]:\n        if i not in visited:\n            dfs(graph, i, visited, lst)\nfor _ in range(int(readline())):\n    (n, m) = map(int, readline().split())\n    deg = [0] * (n + 1)\n    graph = dd(list)\n    for i in range(m):\n        (u, v) = map(int, readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n    visited = set()\n    (ans, ctr) = (0, 0)\n    for i in range(1, n + 1):\n        if i not in visited:\n            lst = []\n            dfs(graph, i, visited, lst)\n            l = len(lst)\n            flag = 1\n            for j in lst:\n                if deg[j] != l - 1:\n                    flag = 0\n                    break\n            if flag:\n                ans += 1\n            ctr += 1\n    if ctr == 1:\n        ans = 0\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef dfs(ver, comp):\n    vis[ver] = True\n    comp.append(ver)\n    for ngh in adj[ver]:\n        if not vis[ngh]:\n            dfs(ngh, comp)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    vis = [False] * (n + 1)\n    aux = []\n    for i in range(1, n + 1):\n        if not vis[i]:\n            c = []\n            dfs(i, c)\n            aux.append(c)\n    ans = 0\n    for com in aux:\n        ne = 0\n        for i in com:\n            ne += len(adj[i])\n        if ne == len(com) * (len(com) - 1):\n            ans += 1\n    if m == n * (n - 1) // 2:\n        ans = 0\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(ver, comp):\n    vis[ver] = True\n    comp.append(ver)\n    for ngh in adj[ver]:\n        if not vis[ngh]:\n            dfs(ngh, comp)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    vis = [False] * (n + 1)\n    aux = []\n    for i in range(1, n + 1):\n        if not vis[i]:\n            c = []\n            dfs(i, c)\n            aux.append(c)\n    ans = 0\n    for com in aux:\n        ne = 0\n        for i in com:\n            ne += len(adj[i])\n        if ne == len(com) * (len(com) - 1):\n            ans += 1\n    if m == n * (n - 1) // 2:\n        ans = 0\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(ver, comp):\n    vis[ver] = True\n    comp.append(ver)\n    for ngh in adj[ver]:\n        if not vis[ngh]:\n            dfs(ngh, comp)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n    vis = [False] * (n + 1)\n    aux = []\n    for i in range(1, n + 1):\n        if not vis[i]:\n            c = []\n            dfs(i, c)\n            aux.append(c)\n    ans = 0\n    for com in aux:\n        ok = True\n        for i in com:\n            ok = ok & (deg[i] == len(com) - 1)\n        ans += 1 if ok else 0\n    if m == n * (n - 1) // 2:\n        ans = 0\n    print(ans)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [[i] for i in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    mp = {}\n    for item in graph:\n        mp[tuple(sorted(item))] = 0\n    for item in graph:\n        mp[tuple(sorted(item))] += 1\n    cnt = 0\n    for item in mp:\n        if mp[item] == len(item) and len(item) != n:\n            cnt += 1\n    print(cnt - 1)", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\ndef Union(a, b):\n    founder_a = Find(a)\n    founder_b = Find(b)\n    if founder_a == founder_b:\n        num_edges_in_group[founder_a] += 1\n        return\n    founder[founder_b] = founder_a\n    num_nodes_in_group[founder_a] += num_nodes_in_group[founder_b]\n    num_edges_in_group[founder_a] += num_edges_in_group[founder_b] + 1\n    return\n\ndef Find(node):\n    if founder[node] == node:\n        return node\n    founder[node] = Find(founder[node])\n    return founder[node]\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    (num_nodes, num_destroyed_edges) = [int(x) for x in input().split()]\n    founder = {n: n for n in range(1, num_nodes + 1)}\n    num_nodes_in_group = defaultdict(lambda : 1)\n    num_edges_in_group = defaultdict(int)\n    for i in range(num_destroyed_edges):\n        (u, v) = [int(x) for x in input().split()]\n        Union(u, v)\n    ans = 0\n    founders = {Find(node) for node in range(1, num_nodes + 1)}\n    for n in founders:\n        if num_nodes_in_group[n] < num_nodes and num_edges_in_group[n] == num_nodes_in_group[n] * (num_nodes_in_group[n] - 1) // 2:\n            ans += 1\n    print(ans)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom collections import Counter\nfrom collections import defaultdict as dd\nsys.setrecursionlimit(100000)\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline()\nstdint = lambda : int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nstdmap = lambda : map(int, stdstr().split())\nstdarr = lambda : list(map(int, stdstr().split()))\nmod = 1000000007\n\ndef DFS(node, graph, comp, visited):\n    visited[node] = True\n    comp.append(node)\n    for i in graph[node]:\n        if not visited[i]:\n            DFS(i, graph, comp, visited)\nfor _ in range(stdint()):\n    (n, m) = stdmap()\n    if m == 0:\n        print(n)\n        continue\n    graph = dd(list)\n    deg = Counter()\n    for i in range(m):\n        (a, b) = stdmap()\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    comps = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            comp = []\n            DFS(i, graph, comp, visited)\n            comps.append(comp)\n    res = 0\n    for i in comps:\n        pos = True\n        for j in i:\n            if deg[j] != len(i) - 1:\n                pos = False\n                break\n        if pos:\n            res += 1\n    if len(comps) == 1 and res == 1:\n        res -= 1\n    print(res)", "import sys\n\ndef get_int():\n    return map(int, sys.stdin.readline().strip().split())\nT = int(input())\nfor i in range(T):\n    yesval = 'yes'\n    total = 0\n    (N, M) = get_int()\n    graphc = [[] for kappa in range(N)]\n    for theta in range(M):\n        (u, v) = get_int()\n        graphc[u - 1].append(v - 1)\n        graphc[v - 1].append(u - 1)\n    for alpha in range(N):\n        if len(graphc[alpha]) == N - 1:\n            yesval = 'no'\n        graphc[alpha].sort()\n    marked = [False for delta in range(N)]\n    counter = 0\n    while counter < N:\n        if marked[counter]:\n            counter += 1\n        else:\n            temp_arr = graphc[counter]\n            marked[counter] = True\n            for beta in temp_arr:\n                marked[beta] = True\n            l = len(temp_arr)\n            works = 'yes'\n            for gamma in range(l):\n                val = temp_arr[gamma]\n                del temp_arr[gamma]\n                del graphc[val][0]\n                if temp_arr != graphc[val]:\n                    works = 'no'\n                graphc[val].insert(0, counter)\n                temp_arr.insert(gamma, val)\n            if works == 'yes':\n                total += 1\n    if yesval == 'no':\n        sys.stdout.write(str(0) + '\\n')\n    else:\n        sys.stdout.write(str(total) + '\\n')", "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    v = [False] * (n + 1)\n    ans = 0\n    for i in range(1, n + 1):\n        if v[i]:\n            continue\n        v[i] = True\n        add = 1\n        for j in adj[i]:\n            if len(adj[j]) != len(adj[i]):\n                add = 0\n            count = 0\n            for k in adj[j]:\n                if k not in adj[i]:\n                    count += 1\n            if count > 1:\n                add = 0\n            v[j] = True\n        ans += add\n    return ans\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        continue\n    adj = [set() for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        adj[u].add(v)\n        adj[v].add(u)\n    d = dict()\n    for i in range(1, n + 1):\n        x = tuple(sorted(list(adj[i])))\n        d[x] = d.get(x, 0) + 1\n    yes = True\n    for x in d.keys():\n        if len(x) + d[x] == n:\n            yes = False\n            break\n    if yes == False:\n        print(0)\n    else:\n        print(answer())", "def solve():\n    (n, m) = inl()\n    arr = [[i] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = inl()\n        arr[u].append(v)\n        arr[v].append(u)\n    mp = {}\n    for item in arr:\n        mp[tuple(sorted(item))] = 0\n    for item in arr:\n        mp[tuple(sorted(item))] += 1\n    cnt = 0\n    for item in mp:\n        if mp[item] == len(item) and len(item) != n:\n            cnt += 1\n    print(cnt - 1)\n\ndef inl():\n    return [int(i) for i in input().split()]\n\ndef inp():\n    return int(input())\nt = 1\nt = inp()\nwhile t:\n    solve()\n    t -= 1", "import sys\n\ndef is_complete(src):\n    for node in g[src]:\n        v[node] = True\n    for i in g[src]:\n        if len(g[i]) != len(g[src]):\n            return False\n        for j in g[src]:\n            if i not in g[j]:\n                return False\n    return True\nfor test in range(int(input())):\n    (n, m) = map(int, sys.stdin.readline().split())\n    g = [{i} for i in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, sys.stdin.readline().split())\n        g[u].add(v)\n        g[v].add(u)\n    if m == n * (n - 1) // 2:\n        print(0)\n        continue\n    cnt = 0\n    v = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not v[i]:\n            if is_complete(i):\n                cnt += 1\n    print(cnt)"]