["md = 998244353\nfact = [1]\nprod = 1\nfor i in range(1, 2000):\n    prod = prod * i % md\n    fact.append(prod)\n\ndef binom(a, b):\n    rv = 1\n    while b != 0:\n        rv = rv * pow(b, -1, md) % md\n        b -= 1\n        rv = rv * (a - b) % md\n    return rv\nfor _ in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    if (m + n) % 2 == 0:\n        print(0)\n        continue\n    ans = binom(m + n - 1, (m + n - 1) // 2)\n    ans = ans * binom(m + n - 2, m - 1) % md\n    ans = ans * pow(2, (m - 1) * (n - 1), md) % md\n    print(ans)", "md = 998244353\nfact = [1]\nprod = 1\nfor i in range(1, 2000):\n    prod = prod * i % md\n    fact.append(prod)\n\ndef binom(a, b):\n    rv = 1\n    while b != 0:\n        rv = rv * pow(b, -1, md) % md\n        b -= 1\n        rv = rv * (a - b) % md\n    return rv\nfor _ in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    if (m + n) % 2 == 0:\n        print(0)\n        continue\n    ans = binom(m + n - 1, (m + n - 1) // 2)\n    ans = ans * binom(m + n - 2, m - 1) % md\n    ans = ans * pow(2, (m - 1) * (n - 1), md) % md\n    print(ans)", "import math\nt = int(input())\nfor _ in range(t):\n    (m, n) = list(map(int, input().split()))\n    mod = 998244353\n    if (m + n - 1) % 2:\n        print(0)\n    else:\n        print(2 ** (n * m - (n + m - 1)) * math.comb(m + n - 1, (m + n - 1) // 2) * math.comb(m + n - 2, n - 1) % mod)", "from math import comb\n\ndef colorgrid(N, M):\n    if (N + M - 1) % 2 != 0:\n        return 0\n    else:\n        return 2 ** (N * M - (N + M - 1)) * comb(N + M - 1, (N + M - 1) // 2) * comb(N + M - 2, N - 1)\nt = int(input())\nwhile t:\n    (N, M) = list(map(int, input().split(' ')))\n    res = colorgrid(N, M) % 998244353\n    print(res)\n    t = t - 1", "from math import comb\n\ndef colorgrid(N, M):\n    if (N + M - 1) % 2 != 0:\n        return 0\n    else:\n        return 2 ** (N * M - (N + M - 1)) * comb(N + M - 1, (N + M - 1) // 2) * comb(N + M - 2, N - 1)\nt = int(input())\nwhile t:\n    (N, M) = list(map(int, input().split(' ')))\n    res = colorgrid(N, M) % 998244353\n    print(res)\n    t = t - 1", "from math import comb\n\ndef colorgrid(N, M):\n    if (N + M - 1) % 2 != 0:\n        return 0\n    else:\n        return 2 ** (N * M - (N + M - 1)) * comb(N + M - 1, (N + M - 1) // 2) * comb(N + M - 2, N - 1)\nt = int(input())\nwhile t:\n    (N, M) = map(int, input().split(' '))\n    res = colorgrid(N, M) % 998244353\n    print(res)\n    t -= 1", "import math\nt = int(input())\nfor _ in range(t):\n    (m, n) = list(map(int, input().split()))\n    mod = 998244353\n    if (m + n - 1) % 2:\n        print(0)\n    else:\n        print(2 ** (n * m - (n + m - 1)) * math.comb(m + n - 1, (m + n - 1) // 2) * math.comb(m + n - 2, n - 1) % mod)", "import math\nt = int(input())\nfor _ in range(t):\n    (m, n) = list(map(int, input().split()))\n    mod = 998244353\n    if (m + n - 1) % 2:\n        print(0)\n    else:\n        print(2 ** (n * m - (n + m - 1)) * math.comb(m + n - 1, (m + n - 1) // 2) * math.comb(m + n - 2, n - 1) % mod)", "import math\nt = int(input())\nfor _ in range(t):\n    (m, n) = list(map(int, input().split()))\n    mod = 998244353\n    print(0) if (m + n - 1) % 2 else print(2 ** (n * m - (n + m - 1)) * math.comb(m + n - 1, (m + n - 1) // 2) * math.comb(m + n - 2, n - 1) % mod)", "import math\nt = int(input())\nfor _ in range(t):\n    (m, n) = list(map(int, input().split()))\n    mod = 998244353\n    print(0) if (m + n - 1) % 2 else print(2 ** (n * m - (n + m - 1)) * math.comb(m + n - 1, (m + n - 1) // 2) * math.comb(m + n - 2, n - 1) % mod)", "from math import comb\nmod = 998244353\ntest = int(input())\nwhile test:\n    (n, m) = map(int, input().split())\n    if (m + n - 1) % 2:\n        print(0)\n    else:\n        print(2 ** (n * m - (n + m - 1)) * comb(m + n - 1, (m + n - 1) // 2) * comb(m + n - 2, n - 1) % mod)\n    test -= 1", "def fact(n):\n    if n == 0:\n        return 1\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n    return ans\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    if (N + M - 1) % 2:\n        print(0)\n    else:\n        paths = fact(N + M - 2) // (fact(N - 1) * fact(M - 1))\n        total = N + M - 1\n        ways = fact(total) // (fact(total // 2) * fact(total - total // 2))\n        ans = paths * ways * 2 ** (N * M - total) % 998244353\n        print(ans)", "from math import comb\nmod = 998244353\ntest = int(input())\nwhile test:\n    (n, m) = map(int, input().split())\n    print(0) if (m + n - 1) % 2 else print(2 ** (n * m - (n + m - 1)) * comb(m + n - 1, (m + n - 1) // 2) * comb(m + n - 2, n - 1) % mod)\n    test -= 1", "def fact(n):\n    if n == 0:\n        return 1\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n    return ans\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    if (N + M - 1) % 2:\n        print(0)\n    else:\n        paths = fact(N + M - 2) // (fact(N - 1) * fact(M - 1))\n        total = N + M - 1\n        ways = fact(total) // (fact(total // 2) * fact(total - total // 2))\n        ans = paths * ways * 2 ** (N * M - total) % 998244353\n        print(ans)", "mod = 998244353\nn = 2005\nc = [[0 for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    c[i][0] = 1\nfor i in range(1, n):\n    for j in range(1, i + 1):\n        c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    len = n + m - 1\n    ans = c[n + m - 2][m - 1] * c[len][len // 2] * pow(2, n * m - len, mod)\n    if len % 2 == 1:\n        ans = 0\n    print(ans % mod)", "mod = 998244353\nn = 2005\nc = [[0 for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    c[i][0] = 1\nfor i in range(1, n):\n    for j in range(1, i + 1):\n        c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    len = n + m - 1\n    ans = c[n + m - 2][m - 1] * c[len][len // 2] * pow(2, n * m - len, mod)\n    if len % 2 == 1:\n        ans = 0\n    print(ans % mod)", "mod = 998244353\nn = 2005\nc = [[0 for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    c[i][0] = 1\nfor i in range(1, n):\n    for j in range(1, i + 1):\n        c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    len = n + m - 1\n    ans = c[n + m - 2][m - 1] * c[len][len // 2] * pow(2, n * m - len, mod)\n    if len % 2 == 1:\n        ans = 0\n    print(ans % mod)", "mod = 998244353\nN = 2005\nC = [[0 for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    C[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, i + 1):\n        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    len = n + m - 1\n    ans = C[n + m - 2][m - 1] * C[len][len // 2] * pow(2, n * m - len, mod)\n    if len % 2 == 1:\n        ans = 0\n    print(ans % mod)", "def arrangement(n, m):\n    a = min(m, n)\n    b = max(m, n)\n    t = m + n\n    num = 1\n    for i in range(b + 1, t + 1):\n        num *= i\n    den = 1\n    for i in range(2, a + 1):\n        den *= i\n    return num // den\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    if (n + m) % 2 == 0:\n        print(0)\n    else:\n        w = arrangement(n - 1, m - 1)\n        t = 2 ** (m * n - (m + n - 1))\n        b = arrangement((m + n - 1) // 2, (m + n - 1) // 2)\n        total = w * t * b\n        print(total % 998244353)", "N = 2050\nM = 998244353\nf = [[0] * N for i in range(N)]\nfor i in range(1, N):\n    f[i][i] = 1\n    f[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, i):\n        f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % M\ng = [1] * (N * N)\nfor i in range(1, N * N):\n    g[i] = 2 * g[i - 1] % M\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    if (n + m) % 2 == 0:\n        print(0)\n        continue\n    k = n + m - 1\n    ans = f[n + m - 2][n - 1]\n    ans = ans * f[k][k // 2] % M\n    ans = ans * g[n * m - k] % M\n    print(ans)", "mod = 998244353\nN = 2005\nC = [[0 for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    C[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, i + 1):\n        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    len = n + m - 1\n    ans = C[n + m - 2][m - 1] * C[len][len // 2] * pow(2, n * m - len, mod)\n    if len % 2 == 1:\n        ans = 0\n    print(ans % mod)", "def fact(n):\n    if n == 0:\n        return 1\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n    return ans\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    if (N + M - 1) % 2:\n        print(0)\n    else:\n        paths = fact(N + M - 2) // (fact(N - 1) * fact(M - 1))\n        total = N + M - 1\n        ways = fact(total) // (fact(total // 2) * fact(total - total // 2))\n        ans = paths * ways * 2 ** (N * M - total) % 998244353\n        print(ans)", "import sys\ninput = sys.stdin.readline\n\ndef print(*args, end='\\n', sep=' ') -> None:\n    sys.stdout.write(sep.join(map(str, args)) + end)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    modulo = 998244353\n    facts = [1]\n    for i in range(1, 2001):\n        facts.append(facts[-1] * i)\n    steps = n + m - 1\n    if steps % 2 != 0:\n        print(0)\n    else:\n        ans = facts[steps] // facts[steps // 2] ** 2 * 2 ** (n * m - steps) * (facts[n + m - 2] // (facts[n - 1] * facts[m - 1]))\n        print(ans % modulo)", "def fact(n):\n    if n == 0:\n        return 1\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n    return ans\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    if (N + M - 1) % 2:\n        print(0)\n    else:\n        paths = fact(N + M - 2) // (fact(N - 1) * fact(M - 1))\n        total = N + M - 1\n        ways = fact(total) // (fact(total // 2) * fact(total - total // 2))\n        ans = paths * ways * 2 ** (N * M - total) % 998244353\n        print(ans)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nmod = 998244353\nls = [[0 for i in range(1001)] for j in range(1001)]\nfor i in range(1001):\n    ls[i][0] = 1\n    ls[0][i] = 1\nfor i in range(1, 1001):\n    for j in range(1, 1001):\n        ls[i][j] = ls[i - 1][j] + ls[i][j - 1]\n        ls[i][j] %= mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    if (n + m) % 2 == 0:\n        print(0)\n    else:\n        ans = ls[n - 1][m - 1] * 2 ** (n * m - n - m + 1)\n        ans %= mod\n        ans *= ncr(n + m - 1, (n + m - 1) // 2, mod)\n        print(ans % mod)", "import math\nt = int(input())\nK = 998244353\nfor i in range(t):\n    (N, M) = map(int, input().split())\n    if (N + M) % 2 == 0:\n        print(0)\n    else:\n        a = math.comb(M + N - 2, M - 1)\n        b = math.comb(M + N - 1, (M + N - 1) // 2)\n        c = 2 ** (M * N - (M + N - 1))\n        ans = a * b * c\n        print(ans % K)", "import math\n\ndef back(r1, c1):\n    a = {c1 - 1: 1}\n    b = {}\n    for i in range(r1 - 1, -1, -1):\n        for j in range(c1 - 1, -1, -1):\n            if i == r1 - 1 and j == c1 - 1:\n                continue\n            a[j] = a.get(j + 1, 0) + b.get(j, 0)\n        (a, b) = ({}, a)\n    return b[0]\nfor _ in range(int(input())):\n    (row, col) = list(map(int, input().split()))\n    if (row + col - 1) % 2 or row == col == 1:\n        print(0)\n    else:\n        ans = math.comb(row + col - 2, row - 1) * pow(2, row * col - (row + col - 1), 998244353) * math.comb(row + col - 1, (row + col - 1) // 2)\n        print(ans % 998244353)", "import math\n\ndef back(r1, c1):\n    a = {c1 - 1: 1}\n    b = {}\n    for i in range(r1 - 1, -1, -1):\n        for j in range(c1 - 1, -1, -1):\n            if i == r1 - 1 and j == c1 - 1:\n                continue\n            a[j] = a.get(j + 1, 0) + b.get(j, 0)\n        (a, b) = ({}, a)\n    return b[0]\nfor _ in range(int(input())):\n    (row, col) = list(map(int, input().split()))\n    if (row + col - 1) % 2 or row == col == 1:\n        print(0)\n    else:\n        ans = math.comb(row + col - 2, row - 1) * pow(2, row * col - (row + col - 1), 998244353) * math.comb(row + col - 1, (row + col - 1) // 2)\n        print(ans % 998244353)", "facts = []\nmodinv = []\nmodn = 998244353\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y % 2 == 1:\n            res = res * x % p\n        y = int(y / 2)\n        x = x * x % p\n    return res\n\ndef modInverse(n, p):\n    return power(n, p - 2, modn)\n\ndef nCrModPFermat(n, r, p):\n    if n < r:\n        return 0\n    elif r == 0:\n        return 1\n    else:\n        return facts[n] * modinv[r] % modn * modinv[n - r] % modn\nfacts.append(1)\nfor i in range(1, 2002):\n    k = facts[i - 1] * i\n    facts.append(k % modn)\nmodinv.append(1)\nfor i in range(1, 2000):\n    modinv.append(modInverse(facts[i], modn))\nT = int(input())\nfor t in range(T):\n    (N, M) = map(int, input().split())\n    L = N + M - 1\n    if L % 2 == 1:\n        print(0)\n    else:\n        answ = nCrModPFermat(N + M - 2, M - 1, modn)\n        answ = answ * nCrModPFermat(L, int(L / 2), modn) % modn\n        answ = answ * power(2, N * M - L, modn) % modn\n        print(answ)", "import math\nBASE = 998244353\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    steps = n + m - 2\n    if steps % 2 == 0:\n        print(0)\n    else:\n        num_of_paths = math.comb(steps, n - 1) % BASE\n        valid_paths = math.comb(steps + 1, (steps + 1) // 2) % BASE\n        rest_grid_coloring = pow(2, n * m - steps - 1, BASE)\n        print(num_of_paths * valid_paths * rest_grid_coloring % BASE)", "import math\nBASE = 998244353\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    steps = n + m - 2\n    if steps % 2 == 0:\n        print(0)\n    else:\n        num_of_paths = math.comb(steps, n - 1) % BASE\n        valid_paths = math.comb(steps + 1, (steps + 1) // 2) % BASE\n        rest_grid_coloring = 2 ** (n * m - (steps + 1)) % BASE\n        print(num_of_paths * valid_paths * rest_grid_coloring % BASE)", "import math\nmod = 998244353\nfor t in range(int(input())):\n    (n, m) = (int(i) for i in input().split())\n    if (n + m - 1) % 2 == 0:\n        ans = math.comb(n + m - 2, n - 1) % mod * (math.comb(n + m - 1, (n + m - 1) // 2) % mod) * pow(2, n * m - (n + m - 1), mod) % mod\n        print(ans)\n    else:\n        print(0)", "import math\nmod = 998244353\nfor t in range(int(input())):\n    (n, m) = (int(i) for i in input().split())\n    if (n + m - 1) % 2 == 0:\n        ans = math.comb(n + m - 2, n - 1) % mod * (math.comb(n + m - 1, (n + m - 1) // 2) % mod) * pow(2, n * m - (n + m - 1), mod) % mod\n        print(ans)\n    else:\n        print(0)", "from math import comb\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    if n % 2 == 0 and m % 2 == 0:\n        print(0)\n    elif n % 2 == 1 and m % 2 == 1:\n        print(0)\n    else:\n        path = comb(m + n - 2, n - 1) % 998244353\n        color = comb(m + n - 1, (m + n - 1) // 2) % 998244353\n        nr = n * m - (m + n - 1)\n        rest = 2 ** nr % 998244353\n        p_c = path * color % 998244353\n        p_c_r = p_c * rest % 998244353\n        print(p_c_r)", "from math import *\nmod = 998244353\n\ndef fact(n, r):\n    p = 1\n    k = 1\n    if n - r < r:\n        r = n - r\n    if r != 0:\n        while r:\n            p *= n\n            k *= r\n            m = gcd(p, k)\n            p //= m\n            k //= m\n            n -= 1\n            r -= 1\n    else:\n        p = 1\n    return p % mod\n\ndef powr(n):\n    mod = 998244353\n    ans = 1\n    for i in range(n):\n        ans = ans * 2 % mod\n    return ans\nfor _ in range(int(input())):\n    l = list(map(int, input().split()))\n    n = l[0]\n    m = l[1]\n    mod = 998244353\n    if (n + m) % 2 == 1:\n        ans = fact(n + m - 2, n - 1) * fact(n + m - 1, (n + m - 1) // 2) % mod * 2 ** (n * m - (n + m - 1)) % mod % mod\n        print(ans)\n    else:\n        print(0)", "import math\nmod = 998244353\n(n, m) = (1001, 1001)\ndp = [[0 for _ in range(m)] for _ in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if i == 0 and j == 0:\n            dp[i][j] = 1\n        elif i == 0:\n            dp[i][j] = dp[i][j - 1]\n        elif j == 0:\n            dp[i][j] = dp[i - 1][j]\n        else:\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    if (n + m) % 2 == 0:\n        print(0)\n        continue\n    pathLen = m + n - 1\n\n    def comb(x):\n        return math.comb(x, x // 2)\n    res = dp[n - 1][m - 1] * comb(pathLen) % mod\n    po = n * m - n - m + 1\n    res = res * pow(2, po, mod) % mod\n    print(res)", "import sys\nimport math\nfrom collections import defaultdict, Counter\nfrom itertools import permutations\nfrom collections import deque\n\ndef sin():\n    return int(sys.stdin.readline())\n\ndef array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef two():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef multiple():\n    return [int(x) for x in sys.stdin.readline().split()]\n\ndef string():\n    return sys.stdin.readline().strip()\n\ndef sqrt(x):\n    (low, high) = (0, x)\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid <= x < (mid + 1) * (mid + 1):\n            return mid\n        elif x < mid * mid:\n            high = mid - 1\n        else:\n            low = mid + 1\nimport sys\nimport bisect\nimport math\nfrom collections import defaultdict, Counter\nfrom itertools import permutations\nfrom collections import deque\n\ndef sin():\n    return int(sys.stdin.readline())\n\ndef array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef two():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef multiple():\n    return [int(x) for x in sys.stdin.readline().split()]\n\ndef string():\n    return sys.stdin.readline().strip()\n\ndef sqrt(x):\n    (low, high) = (0, x)\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid <= x < (mid + 1) * (mid + 1):\n            return mid\n        elif x < mid * mid:\n            high = mid - 1\n        else:\n            low = mid + 1\nmod = 998244353\n\ndef modpow(a, b):\n    ans = 1\n    while b > 0:\n        if b % 2:\n            ans = ans * a % mod\n        b = b // 2\n        a = a % mod * (a % mod) % mod\n    return ans\nfact = [1] * 100001\nfor i in range(1, 100001):\n    fact[i] = i * fact[i - 1]\n    fact[i] %= mod\nt = sin()\nfor _ in range(t):\n    (n, m) = multiple()\n    x = n + m - 1\n    if x % 2:\n        print(0)\n    else:\n        a = fact[x]\n        b = modpow(fact[x // 2], mod - 2)\n        c = modpow(fact[x - x // 2], mod - 2)\n        way = 1\n        way *= a\n        way %= mod\n        way *= b\n        way %= mod\n        way *= c\n        way %= mod\n        tot = n * m\n        left = tot - x\n        left_way = pow(2, left, mod)\n        a = fact[n + m - 2]\n        b = modpow(fact[m - 1], mod - 2)\n        c = modpow(fact[n + m - 2 - (m - 1)], mod - 2)\n        tot_way = 1\n        tot_way *= a\n        tot_way %= mod\n        tot_way *= b\n        tot_way %= mod\n        tot_way *= c\n        tot_way %= mod\n        print(way * tot_way * left_way % mod)", "import sys\nimport math\nfrom collections import defaultdict, Counter\nfrom itertools import permutations\nfrom collections import deque\n\ndef sin():\n    return int(sys.stdin.readline())\n\ndef array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef two():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef multiple():\n    return [int(x) for x in sys.stdin.readline().split()]\n\ndef string():\n    return sys.stdin.readline().strip()\n\ndef sqrt(x):\n    (low, high) = (0, x)\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid <= x < (mid + 1) * (mid + 1):\n            return mid\n        elif x < mid * mid:\n            high = mid - 1\n        else:\n            low = mid + 1\nimport sys\nimport bisect\nimport math\nfrom collections import defaultdict, Counter\nfrom itertools import permutations\nfrom collections import deque\n\ndef sin():\n    return int(sys.stdin.readline())\n\ndef array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef two():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef multiple():\n    return [int(x) for x in sys.stdin.readline().split()]\n\ndef string():\n    return sys.stdin.readline().strip()\n\ndef sqrt(x):\n    (low, high) = (0, x)\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid <= x < (mid + 1) * (mid + 1):\n            return mid\n        elif x < mid * mid:\n            high = mid - 1\n        else:\n            low = mid + 1\nmod = 998244353\n\ndef modpow(a, b):\n    ans = 1\n    while b > 0:\n        if b % 2:\n            ans = ans * a % mod\n        b = b // 2\n        a = a % mod * (a % mod) % mod\n    return ans\nfact = [1] * 1001\nfor i in range(1, 1001):\n    fact[i] = i * fact[i - 1]\n    fact[i] %= mod\nt = sin()\nfor _ in range(t):\n    (n, m) = multiple()\n    x = n + m - 1\n    left = n * m - x\n    if x % 2:\n        print(0)\n    else:\n        way = math.comb(x, x // 2)\n        left_way = pow(2, left, mod)\n        tot_way = math.comb(n + m - 2, n - 1)\n        print(way * tot_way * left_way % mod)", "MOD = 998244353\nfact = [1, 1]\nfor i in range(2, 2005):\n    fact.append(fact[i - 1] * i % MOD)\n\ndef solve(a, b):\n    l = a + b - 1\n    if l % 2 == 1:\n        print(0)\n        return\n    res = fact[l - 1]\n    res *= pow(fact[a - 1], MOD - 2, MOD)\n    res *= pow(fact[b - 1], MOD - 2, MOD)\n    res *= pow(2, a * b - l, MOD)\n    res *= fact[l]\n    res *= pow(fact[l // 2], MOD - 2, MOD)\n    res *= pow(fact[l // 2], MOD - 2, MOD)\n    print(res % MOD)\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    solve(a, b)", "MOD = 998244353\nfact = [1, 1]\nfor i in range(2, 2005):\n    fact.append(fact[i - 1] * i % MOD)\n\ndef solve(a, b):\n    l = a + b - 1\n    if l % 2 == 1:\n        print(0)\n        return\n    res = fact[l - 1]\n    res *= pow(fact[a - 1], MOD - 2, MOD)\n    res *= pow(fact[b - 1], MOD - 2, MOD)\n    res *= pow(2, a * b - l, MOD)\n    res *= fact[l]\n    res *= pow(fact[l // 2], MOD - 2, MOD)\n    res *= pow(fact[l // 2], MOD - 2, MOD)\n    print(res % MOD)\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    solve(a, b)", "from math import factorial as f\n\ndef red_green_path(m, n):\n    if (m + n - 1) % 2 != 0:\n        return 0\n    paths = f(m + n - 2) // (f(m - 1) * f(n - 1))\n    path_colorings = f(m + n - 1) // f((m + n - 1) // 2) ** 2\n    coloring_occurrences = 2 ** (m * n - (m + n - 1))\n    return paths * path_colorings * coloring_occurrences % 998244353\nfor _ in range(int(input())):\n    (m, n) = map(int, input().split())\n    r = red_green_path(m, n)\n    print(r)", "import math\ntests = int(input())\nfor i in range(tests):\n    (n, m) = map(int, input().split())\n    minimum = min(n, m)\n    path_length = n + m - 1\n    if path_length % 2 == 0:\n        possiblities = math.comb(path_length, path_length // 2)\n        others = n * m - path_length\n        others_val = pow(2, others, 998244353)\n        y = math.comb(n + m - 2, n - 1)\n        print(y * possiblities * others_val % 998244353)\n    else:\n        print(0)", "tests = int(input())\nfacorial_arr = [1]\nimport math\nfor i in range(tests):\n    (n, m) = map(int, input().split())\n    minimum = min(n, m)\n    path_length = n + m - 1\n    if path_length % 2 == 0:\n        possiblities = math.comb(path_length, path_length // 2)\n        others = n * m - path_length\n        others_val = pow(2, others, 998244353)\n        y = math.comb(n + m - 2, n - 1)\n        print(y * possiblities * others_val % 998244353)\n    else:\n        print(0)", "tests = int(input())\nfacorial_arr = [1]\nimport math\nfor i in range(tests):\n    (n, m) = map(int, input().split())\n    minimum = min(n, m)\n    path_length = n + m - 1\n    if path_length % 2 == 0:\n        possiblities = math.comb(path_length, path_length // 2)\n        others = n * m - path_length\n        others_val = pow(2, others)\n        y = math.comb(n + m - 2, n - 1)\n        print(y * possiblities * others_val % 998244353)\n    else:\n        print(0)", "import math\n\ndef checkpowee(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef findyuvi(mans1, nifgiwugf):\n    return math.comb(mans1 + nifgiwugf - 2, mans1 - 1)\nfor _ in range(int(input())):\n    (a, b) = list(map(int, input().split()))\n    flag = a + b - 1\n    if flag % 2 == 1:\n        print(0)\n        continue\n    MOD = 998244353\n    (var, var22) = (1, 1)\n    ans = findyuvi(a, b) % MOD\n    yuvii = b * a - flag\n    yuvii = checkpowee(2, yuvii, MOD)\n    for j in range(1, flag + 1):\n        if j <= flag // 2:\n            var *= j\n        else:\n            var22 *= j\n    print(var22 // var % MOD * ans % MOD * yuvii % MOD)", "def nCr(n, r):\n    ans = 1\n    for i in range(1, r + 1):\n        ans = ans * (n - i + 1) // i\n    return ans\nfor _ in range(int(input())):\n    s = input().split()\n    (n, m) = map(int, s)\n    if (n + m) % 2 == 0:\n        ans = 0\n    else:\n        paths = nCr(n + m - 2, n - 1)\n        pathLength = nCr(n + m - 1, (n + m - 1) // 2)\n        ans = paths * pathLength * 2 ** (n * m - (n + m - 1)) % 998244353\n    print(ans)", "def findCom(n, r):\n    res = 1\n    r = min(r, n - r)\n    for i in range(1, r + 1):\n        res = res * n // i\n        n -= 1\n    return res\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    mod = 998244353\n    totalCells = n * m\n    pathLength = n + m - 1\n    if pathLength % 2 != 0:\n        print(0)\n        continue\n    ans = 0\n    paths = findCom(pathLength - 1, n - 1) % mod\n    remainingCells = totalCells - pathLength\n    a = findCom(pathLength, pathLength // 2) % mod\n    b = pow(2, remainingCells, 998244353)\n    print(paths * a * b % mod)", "import math\nfrom operator import mod\nimport pathlib\nt = int(input())\n\ndef powers(cells):\n    batches = cells // 100\n    rem = cells % 100\n    ans = 1\n    for i in range(batches):\n        ans = ans * int(math.pow(2, 100)) % 998244353\n    ans = ans * int(math.pow(2, rem)) % 998244353\n    return ans\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    pathLen = m + n - 1\n    if not pathLen % 2:\n        paths = int(math.comb(pathLen - 1, n - 1)) % 998244353\n        greens = pathLen // 2\n        pathCombo = int(math.comb(pathLen, greens)) % 998244353\n        cells = n * m - pathLen\n        gridCombo = powers(cells)\n        ans = paths * gridCombo * pathCombo % 998244353\n        print(ans)\n    else:\n        print(0)", "import sys\nimport math\nimport collections\nimport random\nfrom heapq import heappush, heappop\nfrom functools import reduce\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nints = lambda : list(map(int, input().split()))\nMOD = 998244353\n\ndef solve() -> None:\n    (n, m) = map(int, input().split())\n    k = n + m - 1\n    if k & 1:\n        print(0)\n        return\n\n    def comb(n: int, k: int, m=1) -> int:\n        res = 1\n        for i in range(1, k + 1):\n            res = res * (n - i + 1) // i\n        return res\n    ans = comb(k, k // 2, MOD)\n    ans *= pow(2, n * m - k, MOD)\n    ans %= MOD\n    k = min(n - 1, m - 1)\n    ans *= comb(n + m - 2, k, MOD)\n    ans %= MOD\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    solve()", "import math\nfrom operator import mod\nimport pathlib\nt = int(input())\n\ndef powers(cells):\n    batches = cells // 100\n    rem = cells % 100\n    ans = 1\n    for i in range(batches):\n        ans = ans * int(math.pow(2, 100)) % 998244353\n    ans = ans * int(math.pow(2, rem)) % 998244353\n    return ans\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    pathLen = m + n - 1\n    if not pathLen % 2:\n        paths = int(math.comb(pathLen - 1, n - 1)) % 998244353\n        greens = pathLen // 2\n        pathCombo = int(math.comb(pathLen, greens)) % 998244353\n        cells = n * m - pathLen\n        gridCombo = powers(cells)\n        ans = paths * gridCombo * pathCombo % 998244353\n        print(ans)\n    else:\n        print(0)", "from math import *\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    M = 998244353\n    print(comb(n + m - 2, n - 1) * comb(n + m - 1, (n + m - 1) // 2) * 2 ** (n * m - (n + m - 1)) * bool((n + m - 1) % 2 == 0) % M)", "import math\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = n + m - 1\n    b = n * m - a\n    s = 0\n    if (n + m) % 2 != 0:\n        p = math.comb(n + m - 2, n - 1)\n        c = math.comb(a, a // 2)\n        r = 2 ** b\n        s = p * c * r % 998244353\n    print(s)", "mod = 998244353\na = [[0 for i in range(2001)] for i in range(2001)]\nfor i in range(2001):\n    a[i][0] = 1\nfor i in range(1, 2001):\n    for j in range(1, i + 1):\n        a[i][j] = (a[i - 1][j] + a[i - 1][j - 1]) % mod\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = n + m - 1\n    if l % 2:\n        print(0)\n    else:\n        print(int(a[n + m - 2][m - 1] * a[l][l // 2] * 2 ** (n * m - l) % mod) % mod)", "mod = 998244353\na = [[0 for i in range(2001)] for i in range(2001)]\nfor i in range(2001):\n    a[i][0] = 1\nfor i in range(1, 2001):\n    for j in range(1, i + 1):\n        a[i][j] = (a[i - 1][j] + a[i - 1][j - 1]) % mod\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = n + m - 1\n    if l % 2:\n        print(0)\n    else:\n        print(int(a[n + m - 2][m - 1] * a[l][l // 2] * 2 ** (n * m - l) % mod) % mod)", "mod = 998244353\nN = 2005\nC = [[0 for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    C[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, i + 1):\n        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    len = n + m - 1\n    ans = C[n + m - 2][m - 1] * C[len][len // 2] * pow(2, n * m - len, mod)\n    if len % 2 == 1:\n        ans = 0\n    print(ans % mod)", "import math\nt = int(input())\nwhile t > 0:\n    (n, m) = list(map(int, input().split()))\n    x = 0\n    a = n + m - 1\n    b = n * m - a\n    if (n + m) % 2 != 0:\n        x = math.comb(a, int(a / 2))\n        y = math.comb(a - 1, n - 1)\n        z = pow(2, b)\n        x = x * y * z\n        x = x % 998244353\n    print(x)\n    t = t - 1", "import math\nt = int(input())\nwhile t > 0:\n    (n, m) = list(map(int, input().split()))\n    x = 0\n    a = n + m - 1\n    b = n * m - a\n    if (n + m) % 2 != 0:\n        x = math.comb(a, int(a / 2))\n        y = math.comb(a - 1, n - 1)\n        z = pow(2, b)\n        x = x * y * z\n        x = x % 998244353\n    print(x)\n    t = t - 1", "mod = 998244353\nN = 2005\nC = [[0 for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    C[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, i + 1):\n        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    len = n + m - 1\n    ans = C[n + m - 2][m - 1] * C[len][len // 2] * pow(2, n * m - len, mod)\n    if len % 2 == 1:\n        ans = 0\n    print(ans % mod)", "import math\nt = int(input())\nwhile t > 0:\n    (n, m) = list(map(int, input().split()))\n    x = 0\n    a = n + m - 1\n    b = n * m - a\n    if (n + m) % 2 != 0:\n        x = math.comb(a, int(a / 2))\n        y = math.comb(a - 1, n - 1)\n        z = pow(2, b)\n        x = x * y * z\n        x = x % 998244353\n    print(x)\n    t = t - 1", "import math\nt = int(input())\nwhile t > 0:\n    (n, m) = list(map(int, input().split()))\n    x = 0\n    a = n + m - 1\n    b = n * m - a\n    if (n + m) % 2 != 0:\n        x = math.comb(a, int(a / 2))\n        y = math.comb(a - 1, n - 1)\n        z = pow(2, b)\n        x = x * y * z\n        x = x % 998244353\n    print(x)\n    t = t - 1", "dp = [[0] * 2005 for i in range(2005)]\nMOD = 998244353\nfor i in range(2005):\n    dp[i][0] = 1\nfor i in range(1, 2005):\n    for j in range(1, i + 1):\n        dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = dp[n + m - 2][n - 1] * dp[n + m - 1][(n + m - 1) // 2] * pow(2, n * m - n - m + 1, MOD) % MOD\n    if (n + m - 1) % 2 != 0:\n        ans = 0\n    print(ans)", "from math import comb\nfor _ in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    print(comb(n + m - 2, n - 1) * comb(n + m - 1, (n + m - 1) // 2) * 2 ** (n * m - (n + m - 1)) * bool((n + m - 1) % 2 == 0) % 998244353)", "mod = 998244353\nN = 2005\nC = [[0 for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    C[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, i + 1):\n        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    len = n + m - 1\n    ans = C[n + m - 2][m - 1] * C[len][len // 2] * pow(2, n * m - len, mod)\n    if len % 2 == 1:\n        ans = 0\n    print(ans % mod)", "import math\nfor _ in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    if (n + m - 1) % 2 == 1:\n        print(0)\n        continue\n    print(math.comb(n + m - 2, n - 1) * math.comb(n + m - 1, (n + m - 1) // 2) * 2 ** (n * m - (n + m - 1)) % 998244353)", "import time\nimport sys\nimport math\n\ndef get_primes(n):\n    sieve = [True] * n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if sieve[i]:\n            sieve[i * i::2 * i] = [False] * ((n - i * i - 1) // (2 * i) + 1)\n    return [2] + [i for i in range(3, n, 2) if sieve[i]]\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom functools import reduce\n\ndef factors(n):\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\ninput = sys.stdin.readline\n(mod, infi) = (998244353, sys.maxsize)\nfrom collections import deque, Counter, defaultdict as dd\nfrom heapq import heappop, heappush, heapify\nfrom itertools import accumulate\nfrom functools import lru_cache, reduce\nfrom operator import mul, add, sub, truediv, floordiv, lt, le, eq, ne, gt, xor, concat, getitem, lshift\ninty = lambda : int(input())\nstringy = lambda : input().strip()\nnormal = lambda : input().split()\nmappy = lambda : map(int, input().strip().split())\nfmappy = lambda : map(float, input().strip().split())\nlisty = lambda : list(map(int, input().strip().split()))\ntick = lambda : time.perf_counter()\nlogg = lambda a, b: math.log2(a) / math.log2(b)\nacc = lambda x: list(accumulate(x))\nsign = lambda x, y: x >= 0 and y >= 0 or (x < 0 and y < 0)\n\ndef solve(n, m):\n    no_of_paths = math.comb(m + n - 2, m - 1)\n    l = n + m - 1\n    res = math.comb(l, l >> 1)\n    return no_of_paths * res * pow(2, n * m - l, mod) % mod\nT = inty()\nfor _ in range(T):\n    (n, m) = mappy()\n    if n + m - 1 & 1:\n        print(0)\n        continue\n    print(solve(n, m))", "import math\nfor T in range(int(input())):\n    (n, m) = [eval(i) for i in input().split()]\n    ans = 0\n    l = int(m + n - 1)\n    if l % 2 != 0:\n        print(0)\n        continue\n    if l % 2 == 0 and m > 1:\n        ans = ans + math.comb(n + m - 2, m - 1) * math.comb(l, int(l / 2)) * pow(2, n * m - l, 998244353)\n    if l % 2 == 0 and m == 1:\n        ans = ans + math.comb(n + m - 2, n - 1) * math.comb(l, int(l / 2)) * pow(2, n * m - l, 998244353)\n    print(ans % 998244353)", "mod = 998244353\nN = 2005\nC = [[0 for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    C[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, i + 1):\n        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    len = n + m - 1\n    ans = C[n + m - 2][m - 1] * C[len][len // 2] * pow(2, n * m - len, mod)\n    if len % 2 == 1:\n        ans = 0\n    print(ans % mod)", "import math\nfor q in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    l = int(m + n - 1)\n    if l % 2 != 0:\n        print(0)\n        continue\n    if l % 2 == 0 and m > 1:\n        ans = ans + math.comb(n + m - 2, m - 1) * math.comb(l, int(l / 2)) * pow(2, n * m - l, 998244353)\n    if l % 2 == 0 and m == 1:\n        ans = ans + math.comb(n + m - 2, n - 1) * math.comb(l, int(l / 2)) * pow(2, n * m - l, 998244353)\n    print(ans % 998244353)", "mod = 998244353\nN = 2005\nC = [[0 for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    C[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, i + 1):\n        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    len = n + m - 1\n    ans = C[n + m - 2][m - 1] * C[len][len // 2] * pow(2, n * m - len, mod)\n    if len % 2 == 1:\n        ans = 0\n    print(ans % mod)", "import math\n\ndef numberOfPaths(m, n):\n    path = 1\n    for i in range(n, m + n - 1):\n        path *= i\n        path //= i - n + 1\n    return path\nfor _ in range(int(input())):\n    a = list(map(int, input().strip().split()))\n    if (a[1] + a[0]) % 2 == 0:\n        print(0)\n    else:\n        b = numberOfPaths(a[0], a[1])\n        x = a[0] * a[1] - (a[0] + a[1] - 1)\n        ans = pow(2, x, 998244353)\n        ans *= math.comb(a[0] + a[1] - 1, (a[0] + a[1] - 1) // 2)\n        print(ans * b % 998244353)", "from math import comb\ntest = int(input())\nwhile test:\n    (row, col) = map(int, input().split())\n    print(0) if (row + col - 1) % 2 else print(2 ** (row * col - (row + col - 1)) % 998244353 * (comb(row + col - 1, (row + col - 1) // 2) % 998244353) * (comb(row + col - 2, row - 1) % 998244353) % 998244353)\n    test -= 1", "import math\nfor _ in range(int(input())):\n    a = list(map(int, input().strip().split()))\n    if (a[1] + a[0]) % 2 == 0:\n        print(0)\n    else:\n        x = a[0] * a[1] - (a[0] + a[1] - 1)\n        ans = pow(2, x, 998244353) * math.comb(a[0] + a[1] - 2, a[1] - 1)\n        ans *= math.comb(a[0] + a[1] - 1, (a[0] + a[1] - 1) // 2)\n        print(ans % 998244353)", "mod = 998244353\n\ndef nPaths(n, m):\n    return mult2(m + n - 2) * (pow(mult2(n - 1), mod - 2, mod) * pow(mult2(m - 1), mod - 2, mod) % mod) % mod\n\ndef mult1(n):\n    ans = 1\n    for i in range(n, n // 2, -1):\n        ans = ans * i % mod\n    return ans\n\ndef mult2(n):\n    ans = 1\n    for i in range(n, 0, -1):\n        ans = ans * i % mod\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    N = n + m - 1\n    if N & 1:\n        ans = 0\n    else:\n        numPaths = nPaths(n, m)\n        ans = pow(2, n * m - N, mod) * (numPaths * (mult1(N) * pow(mult2(N // 2), mod - 2, mod)) % mod) % mod % mod\n    print(ans)", "from math import *\nM = 998244353\n\ndef printNcR(n, r):\n    p = 1\n    k = 1\n    if n - r < r:\n        r = n - r\n    if r != 0:\n        while r:\n            p *= n\n            k *= r\n            m = gcd(p, k)\n            p //= m\n            k //= m\n            n -= 1\n            r -= 1\n    else:\n        p = 1\n    return p\n\ndef solve(n, m):\n    l = n + m - 1\n    if l % 2 != 0:\n        return 0\n    value1 = printNcR(m + n - 2, m - 1)\n    value2 = printNcR(m + n - 1, (m + n - 1) // 2)\n    value3 = 2 ** ((m - 1) * (n - 1))\n    return value1 * value2 * value3 % M\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    print(solve(n, m))", "def mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\nN = 1000000\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\np = 998244353\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nimport sys\nsys.setrecursionlimit(1000000)\nn = 1005\nm = 1005\ncount = [[0 for x in range(n)] for y in range(m)]\nfor i in range(m):\n    count[i][0] = 1\nfor j in range(n):\n    count[0][j] = 1\nfor i in range(1, m):\n    for j in range(1, n):\n        count[i][j] = (count[i - 1][j] + count[i][j - 1]) % 998244353\n\ndef permu(n, r, p):\n    global fact\n    return Binomial(n, r, p) * fact[r] % 998244353\nfor _ in range(int(input())):\n    (n, m) = mi()\n    if (n + m - 1) % 2 == 1:\n        print(0)\n        continue\n    d = n + m - 1\n    total = n * m\n    ans = count[n - 1][m - 1] * Binomial(d, d // 2, p) % 998244353 * pow(2, total - d, p)\n    print(ans % 998244353)", "from math import *\nM = 998244353\n\ndef printNcR(n, r):\n    p = 1\n    k = 1\n    if n - r < r:\n        r = n - r\n    if r != 0:\n        while r:\n            p *= n\n            k *= r\n            m = gcd(p, k)\n            p //= m\n            k //= m\n            n -= 1\n            r -= 1\n    else:\n        p = 1\n    return p\n\ndef solve(n, m):\n    l = n + m - 1\n    if l % 2 != 0:\n        return 0\n    value1 = printNcR(m + n - 2, m - 1)\n    value2 = printNcR(m + n - 1, (m + n - 1) // 2)\n    value3 = 2 ** ((m - 1) * (n - 1))\n    return value1 * value2 * value3 % M\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    print(solve(n, m))", "def mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\nN = 1000000\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\np = 998244353\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nimport sys\nsys.setrecursionlimit(1000000)\nn = 1005\nm = 1005\ncount = [[0 for x in range(n)] for y in range(m)]\nfor i in range(m):\n    count[i][0] = 1\nfor j in range(n):\n    count[0][j] = 1\nfor i in range(1, m):\n    for j in range(1, n):\n        count[i][j] = (count[i - 1][j] + count[i][j - 1]) % 998244353\n\ndef permu(n, r, p):\n    global fact\n    return Binomial(n, r, p) * fact[r] % 998244353\nfor _ in range(int(input())):\n    (n, m) = mi()\n    if (n + m - 1) % 2 == 1:\n        print(0)\n        continue\n    d = n + m - 1\n    total = n * m\n    ans = count[n - 1][m - 1] * Binomial(d, d // 2, p) % 998244353 * pow(2, total - d, p)\n    print(ans % 998244353)", "mod = 998244353\nN = 2005\nC = [[0 for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    C[i][0] = 1\nfor i in range(1, N):\n    for j in range(1, i + 1):\n        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    len = n + m - 1\n    ans = C[n + m - 2][m - 1] * C[len][len // 2] * pow(2, n * m - len, mod)\n    if len % 2 == 1:\n        ans = 0\n    print(ans % mod)", "import sys\ninput = sys.stdin.readline\n\ndef print(*args, end='\\n', sep=' ') -> None:\n    sys.stdout.write(sep.join(map(str, args)) + end)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    modulo = 998244353\n    facts = [1]\n    for i in range(1, 2001):\n        facts.append(facts[-1] * i)\n    steps = n + m - 1\n    if steps % 2 != 0:\n        print(0)\n    else:\n        ans = facts[steps] // facts[steps // 2] ** 2 * 2 ** (n * m - steps) * (facts[n + m - 2] // (facts[n - 1] * facts[m - 1]))\n        print(ans % modulo)", "import math\n\ndef checkpowee(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef findyuvi(mans1, nifgiwugf):\n    return math.comb(mans1 + nifgiwugf - 2, mans1 - 1)\nfor _ in range(int(input())):\n    (a, b) = list(map(int, input().split()))\n    flag = a + b - 1\n    if flag % 2 == 1:\n        print(0)\n        continue\n    MOD = 998244353\n    (var, var22) = (1, 1)\n    ans = findyuvi(a, b) % MOD\n    yuvii = b * a - flag\n    yuvii = checkpowee(2, yuvii, MOD)\n    for j in range(1, flag + 1):\n        if j <= flag // 2:\n            var *= j\n        else:\n            var22 *= j\n    print(var22 // var % MOD * ans % MOD * yuvii % MOD)", "def modInverse(A, M):\n    g = gcd(A, M)\n    if g != 1:\n        print(\"Inverse doesn't exist\")\n    else:\n        return power(A, M - 2, M)\n\ndef power(x, y, M):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, M) % M\n    p = p * p % M\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % M\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef uniquePaths(m, n):\n    path = 1\n    for i in range(n, m + n - 1):\n        path *= i\n        path //= i - n + 1\n    return path\nfrom math import comb\ntest = int(input())\nfor k in range(test):\n    (n, m) = map(int, input().split())\n    val = uniquePaths(m, n)\n    num = n + m - 1\n    if num % 2 != 0:\n        print(0)\n        continue\n    result = 1\n    div = 1\n    mid = int(num / 2)\n    for i in range(1, num + 1):\n        if i <= mid:\n            div *= i\n            div %= 998244353\n        else:\n            result *= i\n            result %= 998244353\n    result *= modInverse(div, 998244353)\n    result %= 998244353\n    mul = m * n - num\n    nmul = power(2, mul, 998244353)\n    result *= nmul\n    result %= 998244353\n    result *= val\n    result %= 998244353\n    print(result)", "from math import comb\nmod = 998244353\ntest = int(input())\nwhile test:\n    (n, m) = map(int, input().split())\n    print(0) if (m + n - 1) % 2 else print(2 ** (n * m - (n + m - 1)) * comb(m + n - 1, (m + n - 1) // 2) * comb(m + n - 2, n - 1) % mod)\n    test -= 1", "def power(x, y, p):\n    res = 1\n    while y > 0:\n        if y & 1 != 0:\n            res = res * x\n        y = y >> 1\n        x = x * x\n    return res % p\n\ndef fun(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor z in range(0, t):\n    p = 998244353\n    (n, m) = map(int, input().split())\n    if (n + m - 1) % 2 == 1:\n        print(0)\n    else:\n        path = fun(n + m - 2, n - 1, p)\n        matrix = fun(n + m - 1, (n + m - 1) // 2, p)\n        res = power(2, n * m - (n + m - 1), p)\n        ans = path * matrix * res % p\n        print(ans)", "import math\n\ndef uniquePaths(m, n):\n    return math.comb(m + n - 2, m - 1)\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    check = m + n - 1\n    if check % 2 == 1:\n        print(0)\n        continue\n    M = 998244353\n    path = uniquePaths(n, m) % M\n    rem = m * n - check\n    rem = power(2, rem, M)\n    (temp1, temp2) = (1, 1)\n    for i in range(1, check + 1):\n        if i <= check // 2:\n            temp1 *= i\n        else:\n            temp2 *= i\n    print(temp2 // temp1 % M * path % M * rem % M)", "from math import comb\nmod = 998244353\ntest = int(input())\nwhile test:\n    (n, m) = map(int, input().split())\n    if (m + n - 1) % 2:\n        print(0)\n    else:\n        print(2 ** (n * m - (n + m - 1)) * comb(m + n - 1, (m + n - 1) // 2) * comb(m + n - 2, n - 1) % mod)\n    test -= 1", "import math\n\ndef bpow(a, n):\n    res = 1\n    while n:\n        if n % 2 == 1:\n            res = res * a\n            n -= 1\n        else:\n            a = a * a\n            n = n // 2\n    return res\nt = int(input())\nfor t in range(t):\n    (n, m) = map(int, input().split())\n    if (n + m) % 2 == 0:\n        print(0)\n    else:\n        print(math.comb(n + m - 2, n - 1) * bpow(2, n * m - (n + m - 1)) * math.comb(n + m - 1, (n + m - 1) // 2) % 998244353)", "from math import *\nmod = 998244353\n\ndef ncr(n, r):\n    p = 1\n    k = 1\n    if n - r < r:\n        r = n - r\n    if r != 0:\n        while r:\n            p *= n\n            k *= r\n            m = gcd(p, k)\n            p = p // m % mod\n            k //= m\n            n -= 1\n            r -= 1\n    else:\n        p = 1\n    return p\ntest = int(input())\nwhile test:\n    (n, m) = map(int, input().split())\n    if (m + n - 1) % 2:\n        print(0)\n    else:\n        print(2 ** (n * m - (n + m - 1)) * ncr(m + n - 1, (m + n - 1) // 2) * ncr(m + n - 2, n - 1) % mod)\n    test -= 1", "N = 1000\nM = 1000\nmod = 998244353\n\ndef binomialCoeff(n, r):\n    m = 998244353\n    inv = [0 for _ in range(r + 1)]\n    inv[0] = 1\n    if r + 1 >= 2:\n        inv[1] = 1\n    for i in range(2, r + 1):\n        inv[i] = m - m // i * inv[m % i] % m\n    ans = 1\n    for i in range(2, r + 1):\n        ans = ans % m * (inv[i] % m) % m\n    for i in range(n, n - r, -1):\n        ans = ans % m * (i % m) % m\n    return ans\ndp = [[0 for _ in range(M)] for _ in range(N)]\nfor i in range(N):\n    for j in range(M):\n        if i == 0 or j == 0:\n            dp[i][j] = 1\n        else:\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n            dp[i][j] %= mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    if (n + m - 1) % 2:\n        print(0)\n        continue\n    k = n * m - (n + m - 1)\n    left = pow(2, k, mod)\n    ways = dp[n - 1][m - 1]\n    colors = binomialCoeff(n + m - 1, (n + m - 1) // 2)\n    print(left * ways * colors % mod)", "f = {0: 1, 1: 1}\n\ndef factorial(n):\n    if n in f:\n        return f[n]\n    x = n\n    for i in range(n - 1, 0, -1):\n        if i in f:\n            x = x * f[i]\n            break\n        else:\n            x = x * i\n    f[n] = x\n    return f[n]\nfor _ in range(int(input())):\n    (n, m) = (int(i) for i in input().split())\n    if (n + m - 1) % 2 == 1:\n        print(0)\n    else:\n        a = factorial(n + m - 2) // (factorial(n - 1) * factorial(m - 1))\n        b = factorial(n + m - 1) // (factorial((n + m - 1) // 2) * factorial((n + m - 1) // 2))\n        c = 2 ** (n * m - n - m + 1)\n        print(a * b * c % 998244353)", "import math\n\ndef fpw(a, n, r):\n    if n == 0:\n        return 1\n    x = fpw(a, n // 2, r) % r\n    x = x * x % r\n    if n % 2 == 1:\n        x = x * a % r\n    return x\nt = int(input())\nwhile t > 0:\n    [n, m] = [int(x) for x in input().split()]\n    if (n + m - 1) % 2 == 0:\n        a = fpw(2, n * m - n - m + 1, 998244353)\n        b = int(math.comb(n + m - 1, (n + m - 1) // 2)) % 998244353\n        c = int(math.comb(n + m - 2, n - 1)) % 998244353\n        ans = a * b % 998244353\n        ans = ans * c % 998244353\n        print(ans % 998244353)\n    else:\n        print(0)\n    t = t - 1", "from math import comb, factorial\nfor i in range(int(input())):\n    (n, m) = map(int, input().split(' '))\n    mod = 998244353\n    x = (n + m - 1) % mod\n    if x % 2 == 0:\n        val = comb((m + n - 2) % mod, (n - 1) % mod) % mod\n        poww = 2 ** (n * m % mod - x) % mod % mod\n        com = comb(x, x // 2) % mod\n        res = val * poww % mod * com % mod\n        print(res)\n    else:\n        print(0)", "from math import factorial as fact\nfor a0 in range(int(input())):\n    (n, m) = map(int, input().split())\n    mod = 998244353\n    a1 = fact(n + m - 2) // (fact(n - 1) * fact(m - 1))\n    z = n + m\n    if z % 2:\n        a2 = fact(z - 1) // pow(fact((z - 1) // 2), 2)\n        print(a1 * a2 * pow(2, n * m - (n + m - 1)) % mod)\n    else:\n        print(0)", "from math import comb\nn1 = int(input())\nfor i in range(n1):\n    x = [int(a) for a in input().split()]\n    n = x[0]\n    m = x[1]\n    if (n + m - 1) % 2 == 1:\n        print(0)\n    else:\n        a1 = comb(n + m - 1, (n + m - 1) // 2)\n        a2 = pow(2, n * m - n - m + 1)\n        a3 = comb(n + m - 2, n - 1)\n        print(int(a1 * a2 * a3) % 998244353)", "mod_ = 10 ** 9 + 7\nmod_ = 998244353\na = [1] * 2010\nfor i in range(2, 2010):\n    a[i] = i * a[i - 1]\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    x = n + m - 1\n    if n == 1 and m == 1:\n        print(0)\n        continue\n    if x % 2:\n        print(0)\n        continue\n    ways = pow(2, m * n - x, mod_)\n    x //= 2\n    comb = a[2 * x] // (a[x] * a[x]) % mod_\n    paths = a[n + m - 2] // (a[n - 1] * a[m - 1]) % mod_\n    count = ways * comb * paths % mod_\n    print(count)", "import sys\ninput = sys.stdin.readline\nfrom math import sqrt\nfrom collections import defaultdict\n\ndef I():\n    return list(map(int, input().split()))\nmod = 998244353\nlim = 2 * 10 ** 3 + 10\nnumberOfPaths = [[1] * lim for i in range(lim)]\nfor i in range(1, lim):\n    for j in range(1, lim):\n        numberOfPaths[i][j] = numberOfPaths[i - 1][j] + numberOfPaths[i][j - 1]\n        numberOfPaths[i][j] %= mod\nf = [1] * lim\ninv_f = [1] * lim\nfor i in range(2, lim):\n    f[i] = f[i - 1] * i\n    f[i] %= mod\n    inv_f[i] = pow(f[i], mod - 2, mod)\nfor _ in range(int(input())):\n    (n, m) = I()\n    l = n + m - 1\n    if l % 2:\n        print(0)\n        continue\n    tp = numberOfPaths[n - 1][m - 1]\n    path_comb = f[l] * inv_f[l // 2] * inv_f[l // 2]\n    path_comb %= mod\n    out_l = n * m - l\n    out_comb = 1\n    if out_l != 0:\n        out_comb = pow(2, out_l, mod)\n    print(tp * path_comb * out_comb % mod)", "import math\nmodulo = 998244353\nfac_buffer = [math.factorial(i) % modulo for i in range(2000)]\n\ndef factorial(x):\n    return fac_buffer[x]\n\ndef readline():\n    return list(map(int, input().split()))\n\ndef get_permutation(p, k):\n    assert p >= k\n    result = factorial(p) * pow(factorial(k), -1, modulo) * pow(factorial(p - k), -1, modulo)\n    return result % modulo\nfor _ in range(int(input())):\n    (N, M) = readline()\n    path_len = N + M - 1\n    if path_len % 2 == 1:\n        print(0)\n        continue\n    path_arrangements = get_permutation(path_len, path_len // 2)\n    leftover_spaces = N * M - path_len\n    leftover_arrangements = pow(2, leftover_spaces, modulo)\n    shape_size = N + M - 2\n    shape_arrangements = get_permutation(shape_size, N - 1)\n    result = 1\n    arrangements = [path_arrangements, leftover_arrangements, shape_arrangements]\n    for i in arrangements:\n        result *= i\n        result %= modulo\n    print(result)", "import math\nfrom functools import reduce\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef read(func=str, sep=None):\n    return list(map(func, input().split(sep)))\n\ndef read_ints(sep=None):\n    return read(func=int, sep=sep)\n\ndef read_int():\n    return int(input())\n\ndef print_array(arr, sep=' '):\n    print(sep.join(map(str, arr)))\n\ndef bitcount(num):\n    bits = 0\n    while num:\n        if num & 1:\n            bits += 1\n        num >>= 1\n    return bits\n\ndef highest_bit(n):\n    count = 0\n    while n != 0:\n        count += 1\n        n >= 1\n    return count - 1\n\ndef modpow(num, pow, mod):\n    if pow == 0:\n        return 1\n    c = modpow(num, pow // 2, mod)\n    if pow & 1:\n        return c ** 2 % mod * num % mod\n    else:\n        return c ** 2 % mod\ntest_cases = read_int()\nmod = 998244353\nncr_memo = {}\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    if r == 0:\n        return 1\n    if n == 1:\n        return 1\n    if r == 1:\n        return n\n    if (n, r) in ncr_memo:\n        return ncr_memo[n, r]\n    ncr_memo[n, r] = ncr(n - 1, r) + ncr(n - 1, r - 1)\n    return ncr_memo[n, r]\n\ndef modpow(n, pow, mod):\n    if pow == 0:\n        return 1\n    if pow == 1:\n        return n % mod\n    x = modpow(n, pow // 2, mod)\n    if pow & 1:\n        return x * x % mod * n % mod\n    else:\n        return x * x % mod\nmemo = {}\nfor _ in range(test_cases):\n    (n, m) = read_ints()\n    x = n + m - 1\n    comb = ncr(x, x // 2) * modpow(2, n * m - x, mod) % mod\n\n    def dp(i, j):\n        if i < 1 or j < 1:\n            return 0\n        if i == 1 and j == 1:\n            return 1\n        if (i, j) in memo:\n            return memo[i, j]\n        out = dp(i - 1, j) % mod + dp(i, j - 1) % mod\n        out %= mod\n        memo[i, j] = out\n        return out\n    if n + m - 1 & 1:\n        print(0)\n    else:\n        print(dp(n, m) * comb % mod)", "def fact(n):\n    if n == 0:\n        return 1\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n    return ans\nt = int(input())\nwhile t:\n    t -= 1\n    (a, b) = map(int, input().split())\n    if (a + b - 1) % 2:\n        print(0)\n    else:\n        valid = fact(a + b - 2) // (fact(a - 1) * fact(b - 1))\n        n = a + b - 1\n        m = a * b - n\n        n = fact(n) // (fact(n // 2) * fact(n - n // 2))\n        ans = valid * n * 2 ** m % 998244353\n        print(ans)", "from math import comb\n\ndef solve(a, b, mod=998244353):\n    l = a + b - 1\n    if l % 2:\n        return 0\n    return pow(2, a * b - l, mod) * comb(l, l // 2) * comb(l - 1, a - 1) % mod\nfor _ in range(int(input())):\n    (a, b) = map(int, input().strip().split())\n    print(solve(a, b))", "import sys\nsys.setrecursionlimit(10 ** 8)\nN = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef moduloExponentiation(x, n, mod):\n    ans = 1\n    while n > 0:\n        if n % 2 == 1:\n            ans = ans * x % mod\n        x = x * x % mod\n        n = n // 2\n    return ans\np = 998244353\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nfor dkfkdhfkhiehfdihfuksdk in range(int(input())):\n    (n, m) = map(int, input().split())\n    steps = n + m - 1\n    mod = 998244353\n    if steps % 2 == 1:\n        print(0)\n        continue\n    else:\n        pathValues = Binomial(steps, steps // 2, mod) % mod\n        numOfTimes = moduloExponentiation(2, n * m - steps, mod) % mod\n        numOfPath = Binomial(n - 1 + (m - 1), n - 1, mod) % mod\n        ans = pathValues * numOfTimes % mod * numOfPath % mod\n        print(ans)"]