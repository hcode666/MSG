["def dp(n, k, a, b):\n    dp = [[-1 for _ in range(1601)] for __ in range(k + 1)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(k - 1, -1, -1):\n            for s in range(1601):\n                if dp[j][s] != -1:\n                    dp[j + 1][s + a[i]] = max(dp[j][s] + b[i], dp[j + 1][s + a[i]])\n    ans = 0\n    for s in range(0, 1601):\n        ans = max(ans, min(s, dp[k][s]))\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    print(dp(n, k, a, b))", "def dp(n, k, a, b):\n    dp = [[-1 for _ in range(1601)] for __ in range(k + 1)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(k - 1, -1, -1):\n            for s in range(1601):\n                if dp[j][s] != -1:\n                    dp[j + 1][s + a[i]] = max(dp[j][s] + b[i], dp[j + 1][s + a[i]])\n    ans = 0\n    for s in range(0, 1601):\n        ans = max(ans, min(s, dp[k][s]))\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    print(dp(n, k, a, b))", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    M = max(sum(A), sum(B)) + 1\n    dp = [[-1 for s in range(M)] for i in range(K + 1)]\n    dp[0][0] = 0\n    for i in range(N):\n        for j in range(K - 1, -1, -1):\n            for s in range(M):\n                s1 = s + A[i]\n                if dp[j][s] != -1:\n                    dp[j + 1][s1] = max(dp[j + 1][s1], B[i] + dp[j][s])\n    minmax = 0\n    for s in range(M):\n        minmax = max(minmax, min(s, dp[K][s]))\n    print(minmax)", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\ngp = []\nans = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\n\ndef flip(a, l, r):\n    for i in range(l, r):\n        a[i] = '0' if a[i] == '1' else '1'\n    return\n\ndef hnbhai(tc):\n    (n, k) = sd()\n    a = sd()\n    b = sd()\n    mx = sum(a) + 5\n    dp = [[0 for i in range(mx)] for j in range(k + 1)]\n    for i in range(n):\n        for j in range(k, 0, -1):\n            for s in range(mx - 1, 0, -1):\n                if s - a[i] < 0:\n                    continue\n                if j - 1 == 0 and s - a[i] == 0 or dp[j - 1][s - a[i]] != 0:\n                    dp[j][s] = max(dp[j][s], dp[j - 1][s - a[i]] + b[i])\n    ans = 0\n    for i in range(mx):\n        ans = max(ans, min(i, dp[k][i]))\n    print(ans)\nfor _ in range(sb()):\n    hnbhai(_ + 1)"]