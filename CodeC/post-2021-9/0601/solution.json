["from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nt = int(input())\n\ndef solve():\n    N = int(input())\n    A = [int(x) for x in input().split(' ')]\n    B = [int(x) for x in input().split(' ')]\n    d = defaultdict(list)\n    for _ in range(N - 1):\n        (x, y) = [int(x) for x in input().split(' ')]\n        d[x].append(y)\n        d[y].append(x)\n    ans = 0\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    print(go(1, None, A[0], False))\nwhile t:\n    solve()\n    t -= 1", "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nt = int(input())\n\ndef solve():\n    N = int(input())\n    A = [int(x) for x in input().split(' ')]\n    B = [int(x) for x in input().split(' ')]\n    d = defaultdict(list)\n    for _ in range(N - 1):\n        (x, y) = [int(x) for x in input().split(' ')]\n        d[x].append(y)\n        d[y].append(x)\n    ans = 0\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    print(go(1, None, A[0], False))\nwhile t:\n    solve()\n    t -= 1", "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nt = int(input())\n\ndef solve():\n    N = int(input())\n    A = [int(x) for x in input().split(' ')]\n    B = [int(x) for x in input().split(' ')]\n    d = defaultdict(list)\n    for _ in range(N - 1):\n        (x, y) = [int(x) for x in input().split(' ')]\n        d[x].append(y)\n        d[y].append(x)\n    ans = 0\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    print(go(1, None, A[0], False))\nwhile t:\n    solve()\n    t -= 1", "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nt = int(input())\n\ndef solve():\n    N = int(input())\n    A = [int(x) for x in input().split(' ')]\n    B = [int(x) for x in input().split(' ')]\n    d = defaultdict(list)\n    for _ in range(N - 1):\n        (x, y) = [int(x) for x in input().split(' ')]\n        d[x].append(y)\n        d[y].append(x)\n    ans = 0\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    print(go(1, None, A[0], False))\nwhile t:\n    solve()\n    t -= 1", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(5 * 10 ** 5)\nadj = []\narra = []\narrb = []\ndp = []\n\ndef treeinput(n):\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef dfs(root, color, parent):\n    if dp[root][color] != -1:\n        return dp[root][color]\n    ans = 0\n    if color == -1:\n        if arra[root] == arrb[root]:\n            (res1, res2) = (0, 0)\n            for node in adj[root]:\n                if node != parent:\n                    res1 += dfs(node, arrb[root], root)\n                    res2 += dfs(node, -1, root)\n            ans = min(res1 + 1, res2)\n        else:\n            for node in adj[root]:\n                if node != parent:\n                    ans += dfs(node, arrb[root], root)\n            ans += 1\n    elif color == arrb[root]:\n        for node in adj[root]:\n            if node != parent:\n                ans += dfs(node, color, root)\n    else:\n        for node in adj[root]:\n            if node != parent:\n                ans += dfs(node, arrb[root], root)\n        ans += 1\n    dp[root][color] = ans\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    arra = list(map(int, input().split()))\n    arrb = list(map(int, input().split()))\n    arra = [-1] + arra\n    arrb = [-1] + arrb\n    dp = [[-1, -1, -1] for i in range(n + 1)]\n    adj = treeinput(n)\n    print(dfs(1, -1, -1))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(5 * 10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev, what):\n    if dp[p][what] != -1:\n        return dp[p][what]\n    ans = 0\n    if what == 2:\n        if a[p - 1] == b[p - 1]:\n            (x, y) = (0, 0)\n            for i in child[p]:\n                if i == prev:\n                    continue\n                x += dfs(i, p, 2)\n                y += dfs(i, p, b[p - 1])\n            ans = min(x, y + 1)\n        else:\n            for i in child[p]:\n                if i == prev:\n                    continue\n                ans += dfs(i, p, b[p - 1])\n            ans += 1\n    elif what == b[p - 1]:\n        for i in child[p]:\n            if i == prev:\n                continue\n            ans += dfs(i, p, what)\n    else:\n        for i in child[p]:\n            if i == prev:\n                continue\n            ans += dfs(i, p, b[p - 1])\n        ans += 1\n    dp[p][what] = ans\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    a = inp()\n    b = inp()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    dp = [[-1, -1, -1] for i in range(n + 1)]\n    ans = dfs(1, -1, 2)\n    print(ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(5 * 10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev, what):\n    if dp[p][what] != -1:\n        return dp[p][what]\n    ans = 0\n    if what == 2:\n        if a[p - 1] == b[p - 1]:\n            (x, y) = (0, 0)\n            for i in child[p]:\n                if i == prev:\n                    continue\n                x += dfs(i, p, 2)\n                y += dfs(i, p, b[p - 1])\n            ans = min(x, y + 1)\n        else:\n            for i in child[p]:\n                if i == prev:\n                    continue\n                ans += dfs(i, p, b[p - 1])\n            ans += 1\n    elif what == b[p - 1]:\n        for i in child[p]:\n            if i == prev:\n                continue\n            ans += dfs(i, p, what)\n    else:\n        for i in child[p]:\n            if i == prev:\n                continue\n            ans += dfs(i, p, b[p - 1])\n        ans += 1\n    dp[p][what] = ans\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    a = inp()\n    b = inp()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    dp = [[-1, -1, -1] for i in range(n + 1)]\n    ans = dfs(1, -1, 2)\n    print(ans)", "import sys\nimport random\nfrom collections import defaultdict\n\nclass DefaultDict:\n\n    def __init__(self, default=None):\n        self.default = default\n        self.x = random.randrange(1, 1 << 31)\n        self.dd = defaultdict(default)\n\n    def __repr__(self):\n        return '{' + ', '.join((f'{k ^ self.x}: {v}' for (k, v) in self.dd.items())) + '}'\n\n    def __eq__(self, other):\n        for k in set(self) | set(other):\n            if self[k] != other[k]:\n                return False\n        return True\n\n    def __or__(self, other):\n        res = DefaultDict(self.default)\n        for (k, v) in self.dd:\n            res[k] = v\n        for (k, v) in other.dd:\n            res[k] = v\n        return res\n\n    def __len__(self):\n        return len(self.dd)\n\n    def __getitem__(self, item):\n        return self.dd[item ^ self.x]\n\n    def __setitem__(self, key, value):\n        self.dd[key ^ self.x] = value\n\n    def __delitem__(self, key):\n        del self.dd[key ^ self.x]\n\n    def __contains__(self, item):\n        return item ^ self.x in self.dd\n\n    def items(self):\n        for (k, v) in self.dd.items():\n            yield (k ^ self.x, v)\n\n    def keys(self):\n        for k in self.dd:\n            yield (k ^ self.x)\n\n    def values(self):\n        for v in self.dd.values():\n            yield v\n\n    def __iter__(self):\n        for k in self.dd:\n            yield (k ^ self.x)\n\nclass Counter(DefaultDict):\n\n    def __init__(self, aa=[]):\n        super().__init__(int)\n        for a in aa:\n            self.dd[a ^ self.x] += 1\n\n    def __add__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = self[k] + other[k]\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __sub__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = self[k] - other[k]\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __and__(self, other):\n        res = Counter()\n        for k in self:\n            v = min(self[k], other[k])\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __or__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = max(self[k], other[k])\n            if v > 0:\n                res[k] = v\n        return res\n\nclass Set:\n\n    def __init__(self, aa=[]):\n        self.x = random.randrange(1, 1 << 31)\n        self.st = set()\n        for a in aa:\n            self.st.add(a ^ self.x)\n\n    def __repr__(self):\n        return '{' + ', '.join((str(k ^ self.x) for k in self.st)) + '}'\n\n    def __len__(self):\n        return len(self.st)\n\n    def add(self, item):\n        self.st.add(item ^ self.x)\n\n    def discard(self, item):\n        self.st.discard(item ^ self.x)\n\n    def __contains__(self, item):\n        return item ^ self.x in self.st\n\n    def __iter__(self):\n        for k in self.st:\n            yield (k ^ self.x)\n\n    def pop(self):\n        return self.st.pop() ^ self.x\n\n    def __or__(self, other):\n        res = Set(self)\n        for a in other:\n            res.add(a)\n        return res\n\n    def __and__(self, other):\n        res = Set()\n        for a in self:\n            if a in other:\n                res.add(a)\n        for a in other:\n            if a in self:\n                res.add(a)\n        return res\nsys.setrecursionlimit(300005)\nint1 = lambda x: int(x) - 1\npDB = lambda *x: print(*x, end='\\n', file=sys.stderr)\np2D = lambda x: print(*x, sep='\\n', end='\\n\\n', file=sys.stderr)\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef LI1():\n    return list(map(int1, sys.stdin.readline().split()))\n\ndef LLI1(rows_number):\n    return [LI1() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline().rstrip()\ndij = [(0, 1), (-1, 0), (0, -1), (1, 0)]\ninf = (1 << 63) - 1\nmd = 10 ** 9 + 7\n\ndef solve():\n    n = II()\n    aa = LI()\n    bb = LI()\n    to = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = LI1()\n        to[u].append(v)\n        to[v].append(u)\n    if n == 1:\n        print(1 - (aa[0] == bb[0]))\n        return\n    memo = {}\n\n    def dfs(u, par, s):\n        t = (u, par, s)\n        if t in memo:\n            return memo[t]\n        res = 1\n        for v in to[u]:\n            if v == par:\n                continue\n            res += dfs(v, u, bb[u])\n        if s == 2 and aa[u] == bb[u]:\n            cur = 0\n            for v in to[u]:\n                if v == par:\n                    continue\n                cur += dfs(v, u, 2)\n            res = min(res, cur)\n        if s == bb[u]:\n            cur = 0\n            for v in to[u]:\n                if v == par:\n                    continue\n                cur += dfs(v, u, s)\n            res = min(res, cur)\n        memo[t] = res\n        return res\n    ans = dfs(0, -1, 2)\n    print(ans)\ntestnumber = II()\nfor testcase in range(testnumber):\n    solve()"]