["import math\n\ndef search(k, a):\n    lt = 0\n    rt = len(a) - 1\n    ans = -1\n    while lt <= rt:\n        mid = lt + (rt - lt) // 2\n        if a[mid] > k:\n            rt = mid - 1\n        if a[mid] <= k:\n            lt = mid + 1\n            ans = mid\n    return ans\n\ndef primes(n):\n    l = set()\n    while n % 2 == 0:\n        l.add(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.add(i)\n            n = n / i\n    if n > 2:\n        l.add(n)\n    return l\nfor _ in range(int(input())):\n    n = int(input())\n    m = [int(i) for i in input().split()]\n    pfs = {}\n    for (ix, i) in enumerate(m):\n        pf = primes(i)\n        for p in pf:\n            if p in pfs:\n                pfs[p][0].append(i)\n                pfs[p][1].append(ix)\n            else:\n                pfs[p] = [[i], [ix]]\n    for pf in pfs:\n        ps = pfs[pf][0].copy()\n        ps.sort(reverse=True)\n        for i in range(1, len(ps)):\n            pfs[pf][0][i] = pfs[pf][0][i - 1] + pfs[pf][0][i]\n            ps[i] = ps[i] + ps[i - 1]\n        pfs[pf].append(ps)\n    sm = m.copy()\n    for i in range(1, n):\n        sm[i] = sm[i] + sm[i - 1]\n    q = int(input())\n    for _ in range(q):\n        (p, k) = [int(i) for i in input().split()]\n        if p not in pfs:\n            print(sm[k - 1])\n        else:\n            pt = search(k - 1, pfs[p][1])\n            if pt == -1:\n                ad = 0\n                df = 0\n            else:\n                ad = pfs[p][2][pt]\n                df = pfs[p][0][pt]\n            print(sm[k - 1] - df + ad)", "import math\n\ndef search(k, a):\n    lt = 0\n    rt = len(a) - 1\n    ans = -1\n    while lt <= rt:\n        mid = lt + (rt - lt) // 2\n        if a[mid] > k:\n            rt = mid - 1\n        if a[mid] <= k:\n            lt = mid + 1\n            ans = mid\n    return ans\n\ndef primes(n):\n    l = set()\n    while n % 2 == 0:\n        l.add(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.add(i)\n            n = n / i\n    if n > 2:\n        l.add(n)\n    return l\nfor _ in range(int(input())):\n    n = int(input())\n    m = [int(i) for i in input().split()]\n    pfs = {}\n    for (ix, i) in enumerate(m):\n        pf = primes(i)\n        for p in pf:\n            if p in pfs:\n                pfs[p][0].append(i)\n                pfs[p][1].append(ix)\n            else:\n                pfs[p] = [[i], [ix]]\n    for pf in pfs:\n        ps = pfs[pf][0].copy()\n        ps.sort(reverse=True)\n        for i in range(1, len(ps)):\n            pfs[pf][0][i] = pfs[pf][0][i - 1] + pfs[pf][0][i]\n            ps[i] = ps[i] + ps[i - 1]\n        pfs[pf].append(ps)\n    sm = m.copy()\n    for i in range(1, n):\n        sm[i] = sm[i] + sm[i - 1]\n    q = int(input())\n    for _ in range(q):\n        (p, k) = [int(i) for i in input().split()]\n        if p not in pfs:\n            print(sm[k - 1])\n        else:\n            pt = search(k - 1, pfs[p][1])\n            if pt == -1:\n                ad = 0\n                df = 0\n            else:\n                ad = pfs[p][2][pt]\n                df = pfs[p][0][pt]\n            print(sm[k - 1] - df + ad)", "import numpy as np\nT = int(input())\nfor t in range(T):\n    dishes = int(input())\n    menu = list(map(int, input().split(' ')))\n    querries = int(input())\n    ans_q = [0 for _ in range(querries)]\n    Q = np.zeros((querries, 3))\n    for q in range(querries):\n        (p, k) = map(int, input().split(' '))\n        Q[q] = [q, p, k]\n    ind = np.lexsort((Q[:, 2], Q[:, 1]))\n    prime = -1\n    for i in range(querries):\n        ele = Q[ind[i], :]\n        if int(ele[1]) != prime:\n            k = int(ele[2])\n            prime = int(ele[1])\n            multiple = [m for m in menu if m % prime == 0]\n            multiple_s = np.sort(multiple)\n            count_flv = 0\n            count_extra = 0\n            for j in range(k):\n                if menu[j] % prime == 0:\n                    count_extra += 1\n                else:\n                    count_flv += menu[j]\n            for c in range(count_extra):\n                count_flv += multiple_s[-(1 + c)]\n            ans_q[int(ele[0])] = count_flv\n        else:\n            k_new = int(ele[2])\n            extra_new = 0\n            for j in range(k, k_new):\n                if menu[j] % prime == 0:\n                    extra_new += 1\n                else:\n                    count_flv += menu[j]\n            for c in range(extra_new):\n                count_flv += multiple_s[-(1 + count_extra + c)]\n            ans_q[int(ele[0])] = count_flv\n            count_extra = extra_new + count_extra\n            k = k_new\n    for a in range(querries):\n        print(ans_q[a])", "import numpy as np\nT = int(input())\nfor t in range(T):\n    dishes = int(input())\n    menu = list(map(int, input().split(' ')))\n    querries = int(input())\n    ans_q = [0 for _ in range(querries)]\n    Q = np.zeros((querries, 3))\n    for q in range(querries):\n        (p, k) = map(int, input().split(' '))\n        Q[q] = [q, p, k]\n    ind = np.lexsort((Q[:, 2], Q[:, 1]))\n    prime = -1\n    for i in range(querries):\n        ele = Q[ind[i], :]\n        if int(ele[1]) != prime:\n            k = int(ele[2])\n            prime = int(ele[1])\n            multiple = [m for m in menu if m % prime == 0]\n            multiple_s = np.sort(multiple)\n            count_flv = 0\n            count_extra = 0\n            for j in range(k):\n                if menu[j] % prime == 0:\n                    count_extra += 1\n                else:\n                    count_flv += menu[j]\n            for c in range(count_extra):\n                count_flv += multiple_s[-(1 + c)]\n            ans_q[int(ele[0])] = count_flv\n        else:\n            k_new = int(ele[2])\n            extra_new = 0\n            for j in range(k, k_new):\n                if menu[j] % prime == 0:\n                    extra_new += 1\n                else:\n                    count_flv += menu[j]\n            for c in range(extra_new):\n                count_flv += multiple_s[-(1 + count_extra + c)]\n            ans_q[int(ele[0])] = count_flv\n            count_extra = extra_new + count_extra\n            k = k_new\n    for a in range(querries):\n        print(ans_q[a])", "def get_factors(n):\n    arr = [[i, []] for i in range(1, n + 1)]\n    for j in range(1, len(arr)):\n        (k, factors) = arr[j]\n        if len(factors) > 0:\n            continue\n        for z in range(j, len(arr), k):\n            arr[z][1].append(k)\n    return arr\nlimit = 100000\nfactors = get_factors(limit)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    values = [int(el) for el in input().split(' ')]\n    num_queries = int(input())\n    original_queries = []\n    for query in range(num_queries):\n        (p, k) = [int(el) for el in input().split(' ')]\n        original_queries.append((p, k))\n    sorted_values = sorted(values)\n    primes = {}\n    for n in sorted_values:\n        ps = factors[n - 1][1]\n        for p in ps:\n            if p in primes:\n                primes[p].append(primes[p][-1] + n)\n            else:\n                primes[p] = [n]\n    zq = enumerate(original_queries)\n    queries = [(i, p, k) for (i, (p, k)) in zq]\n    queries.sort(key=lambda t: t[2])\n    q = 0\n    visited_primes = {}\n    total = 0\n    res = [0] * len(queries)\n    for (i, v) in enumerate(values):\n        total += v\n        fs = factors[v - 1][1]\n        for f in fs:\n            if f in visited_primes:\n                visited_primes[f][0] += 1\n                visited_primes[f][1] += v\n            else:\n                visited_primes[f] = [1, v]\n        while q < len(queries) and queries[q][2] == i + 1:\n            (original_index, p, k) = queries[q]\n            q += 1\n            if p not in visited_primes or visited_primes[p][0] == len(primes[p]):\n                res[original_index] = total\n            else:\n                res[original_index] = total - visited_primes[p][1] + primes[p][-1] - primes[p][len(primes[p]) - visited_primes[p][0] - 1]\n    for r in res:\n        print(r)", "def prfx_sum(mn):\n    l = [0]\n    for m in mn:\n        l.append(m + l[-1])\n    return l\nT = int(input())\nfor i in range(T):\n    input()\n    mn = list(map(int, input().split()))\n    Q = int(input())\n    prefixs = prfx_sum(mn)\n    dp = {}\n    biggest = {}\n    replaced = {}\n    for i in range(Q):\n        (p, k) = map(int, input().split())\n        if p not in dp:\n            dp[p] = prfx_sum([m % p == 0 for m in mn])\n            mult = [m for m in mn if m % p == 0]\n            replaced[p] = prfx_sum(mult)\n            biggest[p] = prfx_sum(sorted(mult)[::-1])\n        n = dp[p][k]\n        res = prefixs[k]\n        if n != 0:\n            res += biggest[p][n] - replaced[p][n]\n        print(res)", "def prefix_sum(arr):\n    res = [0]\n    for i in arr:\n        res.append(res[-1] + i)\n    return res\nfor _ in range(int(input())):\n    input()\n    arr = list(map(int, input().split()))\n    q = int(input())\n    pre_sum = prefix_sum(arr)\n    dp = {}\n    biggest = {}\n    replaced = {}\n    for x in range(q):\n        (p, k) = map(int, input().split())\n        if p not in dp:\n            dp[p] = prefix_sum([i % p == 0 for i in arr])\n            multiples = [i for i in arr if i % p == 0]\n            replaced[p] = prefix_sum(multiples)\n            biggest[p] = prefix_sum(sorted(multiples, reverse=True))\n        cur = dp[p][k]\n        res = pre_sum[k]\n        if cur != 0:\n            res += biggest[p][cur] - replaced[p][cur]\n        print(res)", "def prefix_sum(arr):\n    res = [0]\n    for i in arr:\n        res.append(res[-1] + i)\n    return res\nfor _ in range(int(input())):\n    input()\n    arr = list(map(int, input().split()))\n    q = int(input())\n    pre_sum = prefix_sum(arr)\n    dp = {}\n    biggest = {}\n    replaced = {}\n    for x in range(q):\n        (p, k) = map(int, input().split())\n        if p not in dp:\n            dp[p] = prefix_sum([i % p == 0 for i in arr])\n            multiples = [i for i in arr if i % p == 0]\n            replaced[p] = prefix_sum(multiples)\n            biggest[p] = prefix_sum(sorted(multiples, reverse=True))\n        cur = dp[p][k]\n        res = pre_sum[k]\n        if cur != 0:\n            res += biggest[p][cur] - replaced[p][cur]\n        print(res)", "def prefix_sum(ms):\n    l = [0]\n    for m in ms:\n        l.append(m + l[-1])\n    return l\nfor _ in range(int(input())):\n    input()\n    ms = list(map(int, input().split()))\n    q = int(input())\n    prefixes = prefix_sum(ms)\n    memo_n = {}\n    memo_prefix = {}\n    memo_biggest = {}\n    for _ in range(q):\n        (p, k) = map(int, input().split())\n        if p not in memo_n:\n            memo_n[p] = prefix_sum([m % p == 0 for m in ms])\n            multiples = [m for m in ms if m % p == 0]\n            memo_prefix[p] = prefix_sum(multiples)\n            memo_biggest[p] = prefix_sum(sorted(multiples)[::-1])\n        n = memo_n[p][k]\n        result = prefixes[k]\n        if n != 0:\n            result += -memo_prefix[p][n] + memo_biggest[p][n]\n        print(result)", "for T in range(int(input())):\n    n = int(input())\n    menu = list(map(int, input().split()))\n    tmp = {}\n    for Q in range(int(input())):\n        (p, k) = map(int, input().split())\n        L = []\n        if p not in tmp:\n            for (i, num) in enumerate(menu):\n                if num % p == 0:\n                    L.append(num)\n            L.sort()\n            sumL = []\n            sum = 0\n            for i in range(n):\n                if menu[i] % p != 0:\n                    sum += menu[i]\n                else:\n                    sum += L.pop()\n                sumL.append(sum)\n            tmp[p] = sumL\n        print(tmp[p][k - 1])", "import math\n\ndef search(k, a):\n    lt = 0\n    rt = len(a) - 1\n    ans = -1\n    while lt <= rt:\n        mid = lt + (rt - lt) // 2\n        if a[mid] > k:\n            rt = mid - 1\n        if a[mid] <= k:\n            lt = mid + 1\n            ans = mid\n    return ans\n\ndef primes(n):\n    l = set()\n    while n % 2 == 0:\n        l.add(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.add(i)\n            n = n / i\n    if n > 2:\n        l.add(n)\n    return l\nfor _ in range(int(input())):\n    n = int(input())\n    m = [int(i) for i in input().split()]\n    pfs = {}\n    for (ix, i) in enumerate(m):\n        pf = primes(i)\n        for p in pf:\n            if p in pfs:\n                pfs[p][0].append(i)\n                pfs[p][1].append(ix)\n            else:\n                pfs[p] = [[i], [ix]]\n    for pf in pfs:\n        ps = pfs[pf][0].copy()\n        ps.sort(reverse=True)\n        for i in range(1, len(ps)):\n            pfs[pf][0][i] = pfs[pf][0][i - 1] + pfs[pf][0][i]\n            ps[i] = ps[i] + ps[i - 1]\n        pfs[pf].append(ps)\n    sm = m.copy()\n    for i in range(1, n):\n        sm[i] = sm[i] + sm[i - 1]\n    q = int(input())\n    for _ in range(q):\n        (p, k) = [int(i) for i in input().split()]\n        if p not in pfs:\n            print(sm[k - 1])\n        else:\n            pt = search(k - 1, pfs[p][1])\n            if pt == -1:\n                ad = 0\n                df = 0\n            else:\n                ad = pfs[p][2][pt]\n                df = pfs[p][0][pt]\n            print(sm[k - 1] - df + ad)", "t = int(input())\nans = []\nfor _ in range(t):\n    n = int(input())\n    m = list(map(int, input().split()))\n    q = int(input())\n    has = {}\n    for i in range(q):\n        (p, k) = map(int, input().split())\n        stk = []\n        if p not in has:\n            for (i, num) in enumerate(m):\n                if num % p == 0:\n                    stk.append(num)\n            stk = sorted(stk)\n            sumtilj = []\n            sum = 0\n            for j in range(n):\n                if m[j] % p != 0:\n                    sum += m[j]\n                else:\n                    sum += stk.pop()\n                sumtilj.append(sum)\n            has[p] = sumtilj\n        ans.append(has[p][k - 1])\nfor an in ans:\n    print(an)", "for _ in range(int(input())):\n    n = int(input())\n    m = list(map(int, input().split()))\n    sorted_m = m[:]\n    sorted_m.sort(key=lambda x: -x)\n    cached_answers = {}\n    q = int(input())\n    for _ in range(q):\n        (p, k) = map(int, input().split())\n        if cached_answers.get(p, None) is None:\n            ms = filter(lambda x: x % p == 0, sorted_m)\n            s = [0]\n            for i in m:\n                if i % p == 0:\n                    s.append(next(ms) + s[len(s) - 1])\n                else:\n                    s.append(i + s[len(s) - 1])\n            cached_answers[p] = s\n        print(cached_answers[p][k])", "t = int(input())\nans = []\nfor _ in range(t):\n    n = int(input())\n    m = list(map(int, input().split()))\n    q = int(input())\n    has = {}\n    for i in range(q):\n        (p, k) = map(int, input().split())\n        stk = []\n        if p not in has:\n            for (i, num) in enumerate(m):\n                if num % p == 0:\n                    stk.append(num)\n            stk = sorted(stk)\n            sumtilj = []\n            sum = 0\n            for j in range(n):\n                if m[j] % p != 0:\n                    sum += m[j]\n                else:\n                    sum += stk.pop()\n                sumtilj.append(sum)\n            has[p] = sumtilj\n        ans.append(has[p][k - 1])\nfor an in ans:\n    print(an)", "for _ in range(int(input())):\n    n = int(input())\n    m = list(map(int, input().split()))\n    sorted_m = m[:]\n    sorted_m.sort(key=lambda x: -x)\n    cached_answers = {}\n    q = int(input())\n    for _ in range(q):\n        (p, k) = map(int, input().split())\n        if cached_answers.get(p, None) is None:\n            ms = filter(lambda x: x % p == 0, sorted_m)\n            s = [0]\n            for i in m:\n                if i % p == 0:\n                    s.append(next(ms) + s[len(s) - 1])\n                else:\n                    s.append(i + s[len(s) - 1])\n            cached_answers[p] = s\n        print(cached_answers[p][k])", "from bisect import bisect\nfor tcase in range(int(input())):\n    n = int(input())\n    m = list(map(int, input().split()))\n    s = [0]\n    for mi in m:\n        s.append(s[-1] + mi)\n    (di, dm, ds, dt) = (dict(), dict(), dict(), dict())\n    for qi in range(int(input())):\n        (p, k) = map(int, input().split())\n        ans = s[k]\n        if p not in di:\n            di[p] = []\n            dm[p] = []\n            ds[p] = [0]\n            dt[p] = [0]\n            for (i, mi) in enumerate(m):\n                if mi % p == 0:\n                    di[p].append(i + 1)\n                    dm[p].append(mi)\n                    ds[p].append(ds[p][-1] + mi)\n            dm[p].sort(reverse=True)\n            for mi in dm[p]:\n                dt[p].append(dt[p][-1] + mi)\n        i = bisect(di[p], k)\n        ans -= ds[p][i]\n        ans += dt[p][i]\n        print(ans)", "from bisect import bisect\nfor tcase in range(int(input())):\n    n = int(input())\n    m = list(map(int, input().split()))\n    s = [0]\n    for mi in m:\n        s.append(s[-1] + mi)\n    (di, dm, ds) = (dict(), dict(), dict())\n    for qi in range(int(input())):\n        (p, k) = map(int, input().split())\n        ans = s[k]\n        if p not in di:\n            di[p] = []\n            dm[p] = []\n            ds[p] = [0]\n            for (i, mi) in enumerate(m):\n                if mi % p == 0:\n                    di[p].append(i + 1)\n                    dm[p].append(mi)\n                    ds[p].append(ds[p][-1] + mi)\n            dm[p].sort(reverse=True)\n        i = bisect(di[p], k)\n        ans -= ds[p][i]\n        ans += sum(dm[p][:i])\n        print(ans)", "t = int(input())\nans = []\nfor _ in range(t):\n    n = int(input())\n    m = list(map(int, input().split()))\n    q = int(input())\n    has = {}\n    for i in range(q):\n        (p, k) = map(int, input().split())\n        stk = []\n        if p not in has:\n            for (i, num) in enumerate(m):\n                if num % p == 0:\n                    stk.append(num)\n            stk = sorted(stk)\n            sumtilj = []\n            sum = 0\n            for j in range(n):\n                if m[j] % p != 0:\n                    sum += m[j]\n                else:\n                    sum += stk.pop()\n                sumtilj.append(sum)\n            has[p] = sumtilj\n        ans.append(has[p][k - 1])\nfor an in ans:\n    print(an)", "import math\n\ndef search(k, a):\n    lt = 0\n    rt = len(a) - 1\n    ans = -1\n    while lt <= rt:\n        mid = lt + (rt - lt) // 2\n        if a[mid] > k:\n            rt = mid - 1\n        if a[mid] <= k:\n            lt = mid + 1\n            ans = mid\n    return ans\n\ndef primes(n):\n    l = set()\n    while n % 2 == 0:\n        l.add(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.add(i)\n            n = n / i\n    if n > 2:\n        l.add(n)\n    return l\nfor _ in range(int(input())):\n    n = int(input())\n    m = [int(i) for i in input().split()]\n    pfs = {}\n    for (ix, i) in enumerate(m):\n        pf = primes(i)\n        for p in pf:\n            if p in pfs:\n                pfs[p][0].append(i)\n                pfs[p][1].append(ix)\n            else:\n                pfs[p] = [[i], [ix]]\n    for pf in pfs:\n        ps = pfs[pf][0].copy()\n        ps.sort(reverse=True)\n        for i in range(1, len(ps)):\n            pfs[pf][0][i] = pfs[pf][0][i - 1] + pfs[pf][0][i]\n            ps[i] = ps[i] + ps[i - 1]\n        pfs[pf].append(ps)\n    sm = m.copy()\n    for i in range(1, n):\n        sm[i] = sm[i] + sm[i - 1]\n    q = int(input())\n    for _ in range(q):\n        (p, k) = [int(i) for i in input().split()]\n        if p not in pfs:\n            print(sm[k - 1])\n        else:\n            pt = search(k - 1, pfs[p][1])\n            if pt == -1:\n                ad = 0\n                df = 0\n            else:\n                ad = pfs[p][2][pt]\n                df = pfs[p][0][pt]\n            print(sm[k - 1] - df + ad)", "import bisect\nt = int(input())\nfor _ in range(t):\n    N = int(input())\n    M = list(map(int, input().split()))\n    Q = int(input())\n    h = {}\n    for i in range(Q):\n        (p, k) = map(int, input().split())\n        if p not in h:\n            res = 0\n            l = []\n            for (idd, j) in enumerate(M):\n                if j % p == 0:\n                    l.append(j)\n            l.sort(reverse=True)\n            z = 0\n            ki = []\n            for g in range(N):\n                if M[g] % p != 0:\n                    res += M[g]\n                else:\n                    res += l[z]\n                    z += 1\n                ki.append(res)\n            h[p] = ki\n        print(h[p][k - 1])", "import collections\nA = 200000\nsieve = [0] * (A + 1)\nfor j in range(2, A + 1, 2):\n    sieve[j] = 2\nfor j in range(3, A + 1, 2):\n    if not sieve[j]:\n        for k in range(j * j, A + 1, 2 * j):\n            sieve[k] = j\n        sieve[j] = j\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    m = list(map(int, input().split()))\n    mp = collections.defaultdict(list)\n    for x in m:\n        (done, c) = (set(), x)\n        while x != 1:\n            if sieve[x] not in done:\n                mp[sieve[x]].append(c)\n                done.add(sieve[x])\n            x //= sieve[x]\n    for (x, y) in mp.items():\n        y.sort(reverse=True)\n        for j in range(1, len(y)):\n            y[j] += y[j - 1]\n    qs = [[] for _ in range(n)]\n    q = int(input())\n    for j in range(q):\n        (p, k) = map(int, input().split())\n        qs[k - 1].append((j, p))\n    (ps, psum, pno) = (0, collections.defaultdict(int), collections.defaultdict(int))\n    ans = [0] * q\n    for j in range(n):\n        x = m[j]\n        ps += x\n        done = set()\n        while x != 1:\n            if sieve[x] not in done:\n                psum[sieve[x]] += m[j]\n                pno[sieve[x]] += 1\n                done.add(sieve[x])\n            x //= sieve[x]\n        for (x, y) in qs[j]:\n            if not pno[y]:\n                ans[x] = ps\n            else:\n                ans[x] = ps - psum[y] + mp[y][pno[y] - 1]\n    for x in ans:\n        print(x)"]