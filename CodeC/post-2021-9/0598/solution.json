["for _ in range(int(input())):\n    list1 = list(map(int, input().split()))\n    (N, x) = (list1[0], list1[1])\n    A = list(map(int, input().split()))\n    flag = True\n    for i in range(1, N):\n        if A[i] != A[i - 1]:\n            flag = False\n            break\n    if flag:\n        print(N * (N + 1) // 2)\n        continue\n    else:\n        count = 0\n        for i in range(N):\n            product = A[i] / x\n            if product == 1:\n                count += 1\n            for j in range(i + 1, N):\n                product = product * A[j] / x\n                if product == 1:\n                    count += 1\n        print(count)", "for _ in range(int(input())):\n    list1 = list(map(int, input().split()))\n    (N, x) = (list1[0], list1[1])\n    A = list(map(int, input().split()))\n    flag = True\n    for i in range(1, N):\n        if A[i] != A[i - 1]:\n            flag = False\n            break\n    if flag:\n        print(N * (N + 1) // 2)\n        continue\n    else:\n        count = 0\n        for i in range(N):\n            product = A[i] / x\n            if product == 1:\n                count += 1\n            for j in range(i + 1, N):\n                product = product * A[j] / x\n                if product == 1:\n                    count += 1\n        print(count)", "for _ in range(int(input())):\n    list1 = list(map(int, input().split()))\n    (N, x) = (list1[0], list1[1])\n    A = list(map(int, input().split()))\n    flag = True\n    for i in range(1, N):\n        if A[i] != A[i - 1]:\n            flag = False\n            break\n    if flag:\n        print(N * (N + 1) // 2)\n        continue\n    else:\n        count = 0\n        for i in range(N):\n            product = A[i] / x\n            if product == 1:\n                count += 1\n            for j in range(i + 1, N):\n                product = product * A[j] / x\n                if product == 1:\n                    count += 1\n        print(count)", "for _ in range(int(input())):\n    list1 = list(map(int, input().split()))\n    (N, x) = (list1[0], list1[1])\n    A = list(map(int, input().split()))\n    flag = True\n    for i in range(1, N):\n        if A[i] != A[i - 1]:\n            flag = False\n            break\n    if flag:\n        print(N * (N + 1) // 2)\n        continue\n    else:\n        count = 0\n        for i in range(N):\n            product = A[i] / x\n            if product == 1:\n                count += 1\n            for j in range(i + 1, N):\n                product = product * A[j] / x\n                if product == 1:\n                    count += 1\n        print(count)", "import numpy\n\ndef gcd(n, d):\n    while d != 0:\n        t = d\n        d = n % d\n        n = t\n    return n\n\ndef reduce(n, d):\n    greatest = gcd(n, d)\n    n /= greatest\n    d /= greatest\n    return (int(n), int(d))\nT = int(input())\nfor numTests in range(T):\n    (N, X) = map(int, input().split(' '))\n    A = list(map(int, input().split(' ')))\n    A = numpy.array(A, dtype=float)\n    data = numpy.log(A / X)\n    data = numpy.cumsum(data)\n    data = data.round(decimals=10)\n    t = numpy.unique(data)\n    total = 0\n    for i in range(len(t)):\n        tmp = numpy.where(data == t[i])[0]\n        if t[i] == 0:\n            total += len(tmp) * (len(tmp) + 1) // 2\n        else:\n            total += len(tmp) * (len(tmp) - 1) // 2\n    print(total)", "import numpy\n\ndef gcd(n, d):\n    while d != 0:\n        t = d\n        d = n % d\n        n = t\n    return n\n\ndef reduce(n, d):\n    greatest = gcd(n, d)\n    n /= greatest\n    d /= greatest\n    return (int(n), int(d))\nT = int(input())\nfor numTests in range(T):\n    (N, X) = map(int, input().split(' '))\n    A = list(map(int, input().split(' ')))\n    A = numpy.array(A, dtype=float)\n    data = numpy.log(A / X)\n    data = numpy.cumsum(data)\n    data = data.round(decimals=10)\n    t = numpy.unique(data)\n    total = 0\n    for i in range(len(t)):\n        tmp = numpy.where(data == t[i])[0]\n        if t[i] == 0:\n            total += len(tmp) * (len(tmp) + 1) // 2\n        else:\n            total += len(tmp) * (len(tmp) - 1) // 2\n    print(total)", "import numpy\n\ndef gcd(n, d):\n    while d != 0:\n        t = d\n        d = n % d\n        n = t\n    return n\n\ndef reduce(n, d):\n    greatest = gcd(n, d)\n    n /= greatest\n    d /= greatest\n    return (int(n), int(d))\nT = int(input())\nfor numTests in range(T):\n    (N, X) = map(int, input().split(' '))\n    A = list(map(int, input().split(' ')))\n    A = numpy.array(A, dtype=float)\n    data = numpy.log(A / X)\n    data = numpy.cumsum(data)\n    data = data.round(decimals=10)\n    t = numpy.unique(data)\n    total = 0\n    for i in range(len(t)):\n        tmp = numpy.where(data == t[i])[0]\n        if t[i] == 0:\n            total += len(tmp) * (len(tmp) + 1) // 2\n        else:\n            total += len(tmp) * (len(tmp) - 1) // 2\n    print(total)", "mod = 998244353\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\n\ndef final(A, N, X):\n    new = []\n    for i in range(N):\n        new.append([A[i], X])\n    pre = [[1, 1]]\n    for i in new:\n        temp = [pre[-1][0] * i[0], pre[-1][1] * i[1]]\n        curr = gcd(temp[0], temp[1])\n        temp[0] //= curr\n        temp[1] //= curr\n        pre.append(temp)\n    ct = dict()\n    for i in pre:\n        i = tuple(i)\n        if i not in ct:\n            ct[i] = 0\n        ct[i] += 1\n    ans = 0\n    for i in ct:\n        temp = ct.get(i) - 1\n        ans += temp * (temp + 1) // 2\n    return ans\nfor t in range(int(input())):\n    from collections import Counter\n\n    def gcd(x, y):\n        while y:\n            (x, y) = (y, x % y)\n        return x\n\n    def memodict(f):\n\n        class memodict(dict):\n\n            def __missing__(self, key):\n                ret = self[key] = f(key)\n                return ret\n        return memodict().__getitem__\n\n    def pollard_rho(n):\n        if n & 1 == 0:\n            return 2\n        if n % 3 == 0:\n            return 3\n        s = (n - 1 & 1 - n).bit_length() - 1\n        d = n >> s\n        for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n            p = pow(a, d, n)\n            if p == 1 or p == n - 1 or a % n == 0:\n                continue\n            for _ in range(s):\n                prev = p\n                p = p * p % n\n                if p == 1:\n                    return gcd(prev - 1, n)\n                if p == n - 1:\n                    break\n            else:\n                for i in range(2, n):\n                    (x, y) = (i, (i * i + 1) % n)\n                    f = gcd(abs(x - y), n)\n                    while f == 1:\n                        (x, y) = ((x * x + 1) % n, (y * y + 1) % n)\n                        y = (y * y + 1) % n\n                        f = gcd(abs(x - y), n)\n                    if f != n:\n                        return f\n        return n\n\n    @memodict\n    def prime_factors(n):\n        if n <= 1:\n            return Counter()\n        f = pollard_rho(n)\n        return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n\n    def distinct_factors(n):\n        factors = [1]\n        for (p, exp) in prime_factors(n).items():\n            factors += [p ** i * factor for factor in factors for i in range(1, exp + 1)]\n        return factors\n\n    def all_factors(n):\n        (small, large) = ([], [])\n        for i in range(1, int(n ** 0.5) + 1, 2 if n & 1 else 1):\n            if not n % i:\n                small.append(i)\n                large.append(n // i)\n        if small[-1] == large[-1]:\n            large.pop()\n        large.reverse()\n        small.extend(large)\n        return small\n\n    def dv(c, d):\n        (a, b) = (int(c), int(d))\n        while a % b == 0:\n            a //= b\n        return a == 1 and c >= d\n\n    def solve(S, X):\n        count = 0\n        rem = []\n        pre = 0\n        for i in range(len(S)):\n            if dv(S[i], X):\n                rem.append(S[pre:i])\n                pre = i + 1\n                count += 1\n        for i in rem:\n            temp = 1\n            for j in i:\n                temp *= j\n            if dv(temp, X):\n                count += 1\n        return count\n\n    def check(e, f):\n        for i in f:\n            while e % i == 0:\n                e = e // i\n        return e == 1\n    (N, X) = mi()\n    A = li()\n    f = dict(prime_factors(X))\n    f = list(f.keys())\n    new = []\n    i = 0\n    while i < N:\n        if check(A[i], f):\n            j = i + 1\n            while j < N and check(A[j], f):\n                j += 1\n            new.append(A[i:j])\n            i = int(j)\n        else:\n            i += 1\n    ans = 0\n    for i in new:\n        tmp = final(i, len(i), X)\n        ans += tmp\n    print(ans)", "mod = 998244353\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\n\ndef final(A, N, X):\n    new = []\n    for i in range(N):\n        new.append([A[i], X])\n    pre = [[1, 1]]\n    for i in new:\n        temp = [pre[-1][0] * i[0], pre[-1][1] * i[1]]\n        curr = gcd(temp[0], temp[1])\n        temp[0] //= curr\n        temp[1] //= curr\n        pre.append(temp)\n    ct = dict()\n    for i in pre:\n        i = tuple(i)\n        if i not in ct:\n            ct[i] = 0\n        ct[i] += 1\n    ans = 0\n    for i in ct:\n        temp = ct.get(i) - 1\n        ans += temp * (temp + 1) // 2\n    return ans\nfor t in range(int(input())):\n    from collections import Counter\n\n    def gcd(x, y):\n        while y:\n            (x, y) = (y, x % y)\n        return x\n\n    def memodict(f):\n\n        class memodict(dict):\n\n            def __missing__(self, key):\n                ret = self[key] = f(key)\n                return ret\n        return memodict().__getitem__\n\n    def pollard_rho(n):\n        if n & 1 == 0:\n            return 2\n        if n % 3 == 0:\n            return 3\n        s = (n - 1 & 1 - n).bit_length() - 1\n        d = n >> s\n        for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n            p = pow(a, d, n)\n            if p == 1 or p == n - 1 or a % n == 0:\n                continue\n            for _ in range(s):\n                prev = p\n                p = p * p % n\n                if p == 1:\n                    return gcd(prev - 1, n)\n                if p == n - 1:\n                    break\n            else:\n                for i in range(2, n):\n                    (x, y) = (i, (i * i + 1) % n)\n                    f = gcd(abs(x - y), n)\n                    while f == 1:\n                        (x, y) = ((x * x + 1) % n, (y * y + 1) % n)\n                        y = (y * y + 1) % n\n                        f = gcd(abs(x - y), n)\n                    if f != n:\n                        return f\n        return n\n\n    @memodict\n    def prime_factors(n):\n        if n <= 1:\n            return Counter()\n        f = pollard_rho(n)\n        return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n\n    def distinct_factors(n):\n        factors = [1]\n        for (p, exp) in prime_factors(n).items():\n            factors += [p ** i * factor for factor in factors for i in range(1, exp + 1)]\n        return factors\n\n    def all_factors(n):\n        (small, large) = ([], [])\n        for i in range(1, int(n ** 0.5) + 1, 2 if n & 1 else 1):\n            if not n % i:\n                small.append(i)\n                large.append(n // i)\n        if small[-1] == large[-1]:\n            large.pop()\n        large.reverse()\n        small.extend(large)\n        return small\n\n    def dv(c, d):\n        (a, b) = (int(c), int(d))\n        while a % b == 0:\n            a //= b\n        return a == 1 and c >= d\n\n    def solve(S, X):\n        count = 0\n        rem = []\n        pre = 0\n        for i in range(len(S)):\n            if dv(S[i], X):\n                rem.append(S[pre:i])\n                pre = i + 1\n                count += 1\n        for i in rem:\n            temp = 1\n            for j in i:\n                temp *= j\n            if dv(temp, X):\n                count += 1\n        return count\n\n    def check(e, f):\n        for i in f:\n            while e % i == 0:\n                e = e // i\n        return e == 1\n    (N, X) = mi()\n    A = li()\n    f = dict(prime_factors(X))\n    f = list(f.keys())\n    new = []\n    i = 0\n    while i < N:\n        if check(A[i], f):\n            j = i + 1\n            while j < N and check(A[j], f):\n                j += 1\n            new.append(A[i:j])\n            i = int(j)\n        else:\n            i += 1\n    ans = 0\n    for i in new:\n        tmp = final(i, len(i), X)\n        ans += tmp\n    print(ans)", "mod = 998244353\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\n\ndef final(A, N, X):\n    new = []\n    for i in range(N):\n        new.append([A[i], X])\n    pre = [[1, 1]]\n    for i in new:\n        temp = [pre[-1][0] * i[0], pre[-1][1] * i[1]]\n        curr = gcd(temp[0], temp[1])\n        temp[0] //= curr\n        temp[1] //= curr\n        pre.append(temp)\n    ct = dict()\n    for i in pre:\n        i = tuple(i)\n        if i not in ct:\n            ct[i] = 0\n        ct[i] += 1\n    ans = 0\n    for i in ct:\n        temp = ct.get(i) - 1\n        ans += temp * (temp + 1) // 2\n    return ans\nfor t in range(int(input())):\n    from collections import Counter\n\n    def gcd(x, y):\n        while y:\n            (x, y) = (y, x % y)\n        return x\n\n    def memodict(f):\n\n        class memodict(dict):\n\n            def __missing__(self, key):\n                ret = self[key] = f(key)\n                return ret\n        return memodict().__getitem__\n\n    def pollard_rho(n):\n        if n & 1 == 0:\n            return 2\n        if n % 3 == 0:\n            return 3\n        s = (n - 1 & 1 - n).bit_length() - 1\n        d = n >> s\n        for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n            p = pow(a, d, n)\n            if p == 1 or p == n - 1 or a % n == 0:\n                continue\n            for _ in range(s):\n                prev = p\n                p = p * p % n\n                if p == 1:\n                    return gcd(prev - 1, n)\n                if p == n - 1:\n                    break\n            else:\n                for i in range(2, n):\n                    (x, y) = (i, (i * i + 1) % n)\n                    f = gcd(abs(x - y), n)\n                    while f == 1:\n                        (x, y) = ((x * x + 1) % n, (y * y + 1) % n)\n                        y = (y * y + 1) % n\n                        f = gcd(abs(x - y), n)\n                    if f != n:\n                        return f\n        return n\n\n    @memodict\n    def prime_factors(n):\n        if n <= 1:\n            return Counter()\n        f = pollard_rho(n)\n        return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n\n    def distinct_factors(n):\n        factors = [1]\n        for (p, exp) in prime_factors(n).items():\n            factors += [p ** i * factor for factor in factors for i in range(1, exp + 1)]\n        return factors\n\n    def all_factors(n):\n        (small, large) = ([], [])\n        for i in range(1, int(n ** 0.5) + 1, 2 if n & 1 else 1):\n            if not n % i:\n                small.append(i)\n                large.append(n // i)\n        if small[-1] == large[-1]:\n            large.pop()\n        large.reverse()\n        small.extend(large)\n        return small\n\n    def dv(c, d):\n        (a, b) = (int(c), int(d))\n        while a % b == 0:\n            a //= b\n        return a == 1 and c >= d\n\n    def solve(S, X):\n        count = 0\n        rem = []\n        pre = 0\n        for i in range(len(S)):\n            if dv(S[i], X):\n                rem.append(S[pre:i])\n                pre = i + 1\n                count += 1\n        for i in rem:\n            temp = 1\n            for j in i:\n                temp *= j\n            if dv(temp, X):\n                count += 1\n        return count\n\n    def check(e, f):\n        for i in f:\n            while e % i == 0:\n                e = e // i\n        return e == 1\n    (N, X) = mi()\n    A = li()\n    f = dict(prime_factors(X))\n    f = list(f.keys())\n    new = []\n    i = 0\n    while i < N:\n        if check(A[i], f):\n            j = i + 1\n            while j < N and check(A[j], f):\n                j += 1\n            new.append(A[i:j])\n            i = int(j)\n        else:\n            i += 1\n    ans = 0\n    for i in new:\n        tmp = final(i, len(i), X)\n        ans += tmp\n    print(ans)", "from sys import stdin\ninput = stdin.readline\nPRIME = 1000000007\n\ndef solve(N, X, A):\n    count = 0\n    visited = set()\n    for i in range(N):\n        if i not in visited:\n            product = 1\n            power = 1\n            n = 1\n            for j in range(i, N):\n                product = product * A[j] % PRIME\n                power = power * X % PRIME\n                if product == power:\n                    count += n\n                    n += 1\n                    visited.add(j + 1)\n    return count\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    (N, X) = [int(x) for x in input().strip().split()]\n    A = [int(x) for x in input().strip().split()]\n    print(solve(N, X, A))", "import numpy\n\ndef gcd(n, d):\n    while d != 0:\n        t = d\n        d = n % d\n        n = t\n    return n\n\ndef reduce(n, d):\n    greatest = gcd(n, d)\n    n /= greatest\n    d /= greatest\n    return (int(n), int(d))\nT = int(input())\nfor numTests in range(T):\n    (N, X) = map(int, input().split(' '))\n    A = list(map(int, input().split(' ')))\n    A = numpy.array(A, dtype=float)\n    data = numpy.log(A / X)\n    data = numpy.cumsum(data)\n    data = data.round(decimals=10)\n    t = numpy.unique(data)\n    total = 0\n    for i in range(len(t)):\n        tmp = numpy.where(data == t[i])[0]\n        if t[i] == 0:\n            total += len(tmp) * (len(tmp) + 1) // 2\n        else:\n            total += len(tmp) * (len(tmp) - 1) // 2\n    print(total)", "from collections import defaultdict\nfrom math import sqrt\n\ndef compute(eps, n, k):\n    mp = defaultdict(int)\n    sm = [0 for i in range(k)]\n    mp[tuple(sm)] = 1\n    ans = 0\n    for i in range(n):\n        for j in range(k):\n            sm[j] += eps[i][j]\n        kk = tuple(sm)\n        if kk in mp:\n            ans += mp[kk]\n        mp[kk] += 1\n    return ans\n\ndef prime_factors(n):\n    p_factors = []\n    exps = []\n    ct = 0\n    if n % 2 == 0:\n        p_factors.append(2)\n        exps.append(0)\n        while n % 2 == 0:\n            exps[ct] += 1\n            n //= 2\n        ct += 1\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if n % i == 0:\n            p_factors.append(i)\n            exps.append(0)\n            while n % i == 0:\n                n //= i\n                exps[ct] += 1\n            ct += 1\n    if n != 1:\n        p_factors.append(n)\n        exps.append(1)\n        ct += 1\n    return (p_factors, exps, ct)\nfor _ in range(int(input())):\n    (N, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    if x == 1:\n        if 1 not in a:\n            print(0)\n            continue\n        prod = 0\n        l = 0\n        r = 0\n        while r < N:\n            if a[r] != 1:\n                l = r\n                r += 1\n            else:\n                l = r\n                while r < N and a[r] == 1:\n                    r += 1\n                prod += (r - l) * (r - l + 1) // 2\n        print(prod)\n        continue\n    (pf, exp, k) = prime_factors(x)\n    eps = [[0] * k for i in range(N)]\n    for i in range(N):\n        prod = 1\n        for j in range(k):\n            p = pf[j]\n            e = 0\n            val = a[i]\n            while val % p == 0:\n                val //= p\n                e += 1\n            eps[i][j] = e - exp[j]\n            prod *= p ** e\n        if a[i] // prod > 1:\n            for j in range(k):\n                eps[i][j] = -int(100000000.0)\n    print(compute(eps, N, k))"]