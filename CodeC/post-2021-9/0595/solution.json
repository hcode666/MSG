["from sys import stdin, stdout\ninput = stdin.readline\n\ndef merge(p1, p2):\n    if p1[-1] == -1:\n        return p2\n    if p2[2] == -1:\n        return p1\n    if p1[-1] == p2[2]:\n        interval = (0, float('inf'))\n    elif p1[-1] < p2[2]:\n        interval = (0, (p1[-1] + p2[2]) // 2)\n    else:\n        interval = ((p1[-1] + p2[2]) // 2 + (p1[-1] + p2[2]) % 2, float('inf'))\n    return (max(p1[0], p2[0], interval[0]), min(p1[1], p2[1], interval[1]), p1[2], p2[-1])\n\nclass SegmentTree:\n\n    def __init__(self, data, default=(0, float('inf'), -1, -1), func=merge):\n        data = [default] + data\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        stop += 1\n        start += self._size\n        stop += self._size\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return 'SegmentTree({0})'.format(self.data)\nt = 1\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = [int(x) for x in input().split()]\n    ST = SegmentTree([(0, float('inf'), arr[l], arr[l]) for l in range(n)])\n    for M in range(m):\n        (a, b, c) = map(int, input().split())\n        if a == 1:\n            ST.__setitem__(b, (0, float('inf'), c, c))\n        else:\n            (l, r, x, y) = ST.query(b, c)\n            if l > r:\n                l = -1\n            print(l)", "from sys import stdin, stdout\ninput = stdin.readline\n\ndef merge(p1, p2):\n    if p1[-1] == p2[2] or p1[-1] == -1 or p2[2] == -1:\n        interval = (0, float('inf'))\n    elif p1[-1] < p2[2]:\n        interval = (0, (p1[-1] + p2[2]) // 2)\n    else:\n        interval = ((p1[-1] + p2[2]) // 2 + (p1[-1] + p2[2]) % 2, float('inf'))\n    return (max(p1[0], p2[0], interval[0]), min(p1[1], p2[1], interval[1]), p1[2], p2[-1])\n\nclass SegmentTree:\n\n    def __init__(self, data, default=(0, float('inf'), -1, -1), func=merge):\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        start += self._size\n        stop += self._size\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return 'SegmentTree({0})'.format(self.data)\nt = 1\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = [int(x) for x in input().split()]\n    data = [(0, float('inf'), -1, -1)] + [(0, float('inf'), arr[l], arr[l]) for l in range(n)]\n    ST = SegmentTree(data)\n    for M in range(m):\n        (a, b, c) = map(int, input().split())\n        if a == 1:\n            ST.__setitem__(b, (0, float('inf'), c, c))\n        else:\n            (l, r, x, y) = ST.query(b, c + 1)\n            if l > r:\n                l = -1\n            print(l)", "from sys import stdin, stdout\ninput = stdin.readline\n\ndef merge(p1, p2):\n    if p1[-1] == -1:\n        return p2\n    if p2[2] == -1:\n        return p1\n    if p1[-1] == p2[2]:\n        interval = (0, float('inf'))\n    elif p1[-1] < p2[2]:\n        interval = (0, (p1[-1] + p2[2]) // 2)\n    else:\n        interval = ((p1[-1] + p2[2]) // 2 + (p1[-1] + p2[2]) % 2, float('inf'))\n    return (max(p1[0], p2[0], interval[0]), min(p1[1], p2[1], interval[1]), p1[2], p2[-1])\n\nclass SegmentTree:\n\n    def __init__(self, data, default=(0, float('inf'), -1, -1), func=merge):\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        start += self._size\n        stop += self._size\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return 'SegmentTree({0})'.format(self.data)\nt = 1\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = [int(x) for x in input().split()]\n    data = [(0, float('inf'), -1, -1)] + [(0, float('inf'), arr[l], arr[l]) for l in range(n)]\n    ST = SegmentTree(data)\n    for M in range(m):\n        (a, b, c) = map(int, input().split())\n        if a == 1:\n            ST.__setitem__(b, (0, float('inf'), c, c))\n        else:\n            (l, r, x, y) = ST.query(b, c + 1)\n            if l > r:\n                l = -1\n            print(l)", "from sys import stdin, stdout\ninput = stdin.readline\n\ndef merge(p1, p2):\n    if p1[-1] == -1:\n        return p2\n    if p2[2] == -1:\n        return p1\n    if p1[-1] == p2[2]:\n        interval = (0, float('inf'))\n    elif p1[-1] < p2[2]:\n        interval = (0, (p1[-1] + p2[2]) // 2)\n    else:\n        interval = ((p1[-1] + p2[2]) // 2 + (p1[-1] + p2[2]) % 2, float('inf'))\n    return (max(p1[0], p2[0], interval[0]), min(p1[1], p2[1], interval[1]), p1[2], p2[-1])\n\ndef build(ST, pos, l, r):\n    if l == r:\n        ST[pos] = (0, float('inf'), arr[l], arr[l])\n        return ST[pos]\n    mid = (l + r) // 2\n    ST[pos] = merge(build(ST, 2 * pos + 1, l, mid), build(ST, 2 * pos + 2, mid + 1, r))\n    return ST[pos]\n\ndef update(ST, pos, l, r, ind, val):\n    if l == r:\n        assert l == ind\n        arr[l] = val\n        ST[pos] = (0, float('inf'), arr[l], arr[l])\n        return\n    mid = (l + r) // 2\n    if ind <= mid:\n        update(ST, 2 * pos + 1, l, mid, ind, val)\n    else:\n        update(ST, 2 * pos + 2, mid + 1, r, ind, val)\n    ST[pos] = merge(ST[2 * pos + 1], ST[2 * pos + 2])\n\ndef query(ST, pos, l, r, ql, qr):\n    if ql <= l and r <= qr:\n        return ST[pos]\n    if r < ql or qr < l:\n        return (0, float('inf'), -1, -1)\n    mid = (l + r) // 2\n    return merge(query(ST, 2 * pos + 1, l, mid, ql, qr), query(ST, 2 * pos + 2, mid + 1, r, ql, qr))\nt = 1\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = [int(x) for x in input().split()]\n    ST = [(float('inf'), 0) for i in range(4 * n)]\n    build(ST, 0, 0, n - 1)\n    for M in range(m):\n        (a, b, c) = map(int, input().split())\n        if a == 1:\n            b -= 1\n            update(ST, 0, 0, n - 1, b, c)\n        else:\n            b -= 1\n            c -= 1\n            (l, r, x, y) = query(ST, 0, 0, n - 1, b, c)\n            if l > r:\n                l = -1\n            print(l)", "from sys import stdin, stdout\ninput = stdin.readline\n\ndef merge(p1, p2):\n    if p1[-1] == -1:\n        return p2\n    if p2[2] == -1:\n        return p1\n    if p1[-1] == p2[2]:\n        interval = (0, float('inf'))\n    elif p1[-1] < p2[2]:\n        interval = (0, (p1[-1] + p2[2]) // 2)\n    else:\n        interval = ((p1[-1] + p2[2]) // 2 + (p1[-1] + p2[2]) % 2, float('inf'))\n    return (max(p1[0], p2[0], interval[0]), min(p1[1], p2[1], interval[1]), p1[2], p2[-1])\n\ndef build(ST, pos, l, r):\n    if l == r:\n        ST[pos] = (0, float('inf'), arr[l], arr[l])\n        return ST[pos]\n    mid = (l + r) // 2\n    ST[pos] = merge(build(ST, 2 * pos + 1, l, mid), build(ST, 2 * pos + 2, mid + 1, r))\n    return ST[pos]\n\ndef update(ST, pos, l, r, ind, val):\n    if l == r:\n        assert l == ind\n        arr[l] = val\n        ST[pos] = (0, float('inf'), arr[l], arr[l])\n        return\n    mid = (l + r) // 2\n    if ind <= mid:\n        update(ST, 2 * pos + 1, l, mid, ind, val)\n    else:\n        update(ST, 2 * pos + 2, mid + 1, r, ind, val)\n    ST[pos] = merge(ST[2 * pos + 1], ST[2 * pos + 2])\n\ndef query(ST, pos, l, r, ql, qr):\n    if ql <= l and r <= qr:\n        return ST[pos]\n    if r < ql or qr < l:\n        return (0, float('inf'), -1, -1)\n    mid = (l + r) // 2\n    return merge(query(ST, 2 * pos + 1, l, mid, ql, qr), query(ST, 2 * pos + 2, mid + 1, r, ql, qr))\nt = 1\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = [int(x) for x in input().split()]\n    ST = [(float('inf'), 0) for i in range(4 * n)]\n    build(ST, 0, 0, n - 1)\n    for M in range(m):\n        (a, b, c) = map(int, input().split())\n        if a == 1:\n            b -= 1\n            update(ST, 0, 0, n - 1, b, c)\n        else:\n            b -= 1\n            c -= 1\n            (l, r, x, y) = query(ST, 0, 0, n - 1, b, c)\n            if l > r:\n                l = -1\n            print(l)"]