["from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev, x):\n    global c\n    subtree = a[p - 1]\n    for i in child[p]:\n        if i == prev:\n            continue\n        subtree ^= dfs(i, p, x)\n    if c != k - 1 and subtree & x == x:\n        c += 1\n        return 0\n    return subtree\n\ndef check(x):\n    global c\n    (c, ans) = (0, 0)\n    last = dfs(1, -1, x)\n    if c == k - 1:\n        if last & x == x:\n            return True\n    return False\n\ndef answer():\n    ans = 0\n    for i in range(30, -1, -1):\n        if check(ans | 1 << i):\n            ans |= 1 << i\n    return ans\nfor T in range(int(input())):\n    (n, k) = inp()\n    a = inp()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    print(answer())", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev, x):\n    global c\n    subtree = a[p - 1]\n    for i in child[p]:\n        if i == prev:\n            continue\n        subtree ^= dfs(i, p, x)\n    if c != k - 1 and subtree & x == x:\n        c += 1\n        return 0\n    return subtree\n\ndef check(x):\n    global c\n    (c, ans) = (0, 0)\n    last = dfs(1, -1, x)\n    if c == k - 1:\n        if last & x == x:\n            return True\n    return False\n\ndef answer():\n    ans = 0\n    for i in range(30, -1, -1):\n        if check(ans | 1 << i):\n            ans |= 1 << i\n    return ans\nfor T in range(int(input())):\n    (n, k) = inp()\n    a = inp()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    print(answer())", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev, x):\n    global c\n    subtree = a[p - 1]\n    for i in child[p]:\n        if i == prev:\n            continue\n        subtree ^= dfs(i, p, x)\n    if c != k - 1 and subtree & x == x:\n        c += 1\n        return 0\n    return subtree\n\ndef check(x):\n    global c\n    (c, ans) = (0, 0)\n    last = dfs(1, -1, x)\n    if c == k - 1:\n        if last & x == x:\n            return True\n    return False\n\ndef answer():\n    ans = 0\n    for i in range(30, -1, -1):\n        if check(ans | 1 << i):\n            ans |= 1 << i\n    return ans\nfor T in range(int(input())):\n    (n, k) = inp()\n    a = inp()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    print(answer())", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(3 * 10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev, x):\n    global c\n    subtree = a[p - 1]\n    for i in child[p]:\n        if i == prev:\n            continue\n        subtree ^= dfs(i, p, x)\n    if c != k - 1 and subtree & x == x:\n        c += 1\n        return 0\n    return subtree\n\ndef check(x):\n    global c\n    (c, ans) = (0, 0)\n    last = dfs(1, -1, x)\n    if c == k - 1:\n        if last & x == x:\n            return True\n    return False\n\ndef answer():\n    ans = 0\n    for i in range(30, -1, -1):\n        if check(ans | 1 << i):\n            ans |= 1 << i\n    return ans\nfor T in range(int(input())):\n    (n, k) = inp()\n    a = inp()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    print(answer())"]