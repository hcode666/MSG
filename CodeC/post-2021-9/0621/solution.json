["from collections import Counter, defaultdict, deque\nimport itertools\nimport re\nimport math\nfrom functools import reduce\nimport operator\nimport bisect\nfrom heapq import *\nimport functools\nmod = 998244353\nimport sys\ninput = sys.stdin.readline\n\ndef Cartesian_Tree(a):\n    n = len(a)\n    g = [[] for _ in range(n)]\n    p = [-1] * n\n    st = []\n    for i in range(n):\n        prv = -1\n        while st and a[i] > a[st[-1]]:\n            prv = st.pop()\n        if prv != -1:\n            p[prv] = i\n        if st:\n            p[i] = st[-1]\n        st.append(i)\n    root = -1\n    for i in range(n):\n        if p[i] != -1:\n            g[p[i]].append(i)\n        else:\n            root = i\n    return (g, root)\nINF = 1 << 31\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sa = sum(a)\n    x = list(map(int, input().split()))\n    (g, root) = Cartesian_Tree(a)\n    xx = sorted(x)\n    ans = [0] * (q + 1)\n    go = deque([[root, q]])\n    while go:\n        (now, midx) = go.pop()\n        if len(g[now]) == 2:\n            dif = a[now] - max(a[g[now][0]], a[g[now][1]])\n            idx = bisect.bisect_right(xx, dif)\n            if idx > 0:\n                ans[0] -= 2 * a[now]\n                ans[min(midx, idx)] += 2 * a[now]\n            midx = min(midx, idx)\n        elif len(g[now]) == 1:\n            dif = a[now] - a[g[now][0]]\n            idx = bisect.bisect_right(xx, dif)\n            if idx > 0:\n                ans[0] -= 2 * a[now]\n                ans[min(midx, idx)] += 2 * a[now]\n            midx = min(midx, idx)\n        else:\n            ans[0] -= 2 * a[now]\n            ans[midx] += 2 * a[now]\n        for i in g[now]:\n            go.append([i, midx])\n    for i in range(1, q):\n        ans[i] += ans[i - 1]\n    for i in range(q):\n        ans[i] += sa\n    rans = [0] * q\n    for i in range(q):\n        idx = bisect.bisect_right(xx, x[i])\n        rans[i] = ans[idx - 1]\n    print(*rans)", "from collections import Counter, defaultdict, deque\nimport itertools\nimport re\nimport math\nfrom functools import reduce\nimport operator\nimport bisect\nfrom heapq import *\nimport functools\nmod = 998244353\nimport sys\ninput = sys.stdin.readline\n\ndef Cartesian_Tree(a):\n    n = len(a)\n    g = [[] for _ in range(n)]\n    p = [-1] * n\n    st = []\n    for i in range(n):\n        prv = -1\n        while st and a[i] > a[st[-1]]:\n            prv = st.pop()\n        if prv != -1:\n            p[prv] = i\n        if st:\n            p[i] = st[-1]\n        st.append(i)\n    root = -1\n    for i in range(n):\n        if p[i] != -1:\n            g[p[i]].append(i)\n        else:\n            root = i\n    return (g, root)\nINF = 1 << 31\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sa = sum(a)\n    x = list(map(int, input().split()))\n    (g, root) = Cartesian_Tree(a)\n    xx = sorted(x)\n    ans = [0] * (q + 1)\n    go = deque([[root, q]])\n    while go:\n        (now, midx) = go.pop()\n        if len(g[now]) == 2:\n            dif = a[now] - max(a[g[now][0]], a[g[now][1]])\n            idx = bisect.bisect_right(xx, dif)\n            if idx > 0:\n                ans[0] -= 2 * a[now]\n                ans[min(midx, idx)] += 2 * a[now]\n            midx = min(midx, idx)\n        elif len(g[now]) == 1:\n            dif = a[now] - a[g[now][0]]\n            idx = bisect.bisect_right(xx, dif)\n            if idx > 0:\n                ans[0] -= 2 * a[now]\n                ans[min(midx, idx)] += 2 * a[now]\n            midx = min(midx, idx)\n        else:\n            ans[0] -= 2 * a[now]\n            ans[midx] += 2 * a[now]\n        for i in g[now]:\n            go.append([i, midx])\n    for i in range(1, q):\n        ans[i] += ans[i - 1]\n    for i in range(q):\n        ans[i] += sa\n    rans = [0] * q\n    for i in range(q):\n        idx = bisect.bisect_right(xx, x[i])\n        rans[i] = ans[idx - 1]\n    print(*rans)", "from collections import Counter, defaultdict, deque\nimport itertools\nimport re\nimport math\nfrom functools import reduce\nimport operator\nimport bisect\nfrom heapq import *\nimport functools\nmod = 998244353\nimport sys\ninput = sys.stdin.readline\n\ndef Cartesian_Tree(a):\n    n = len(a)\n    g = [[] for _ in range(n)]\n    p = [-1] * n\n    st = []\n    for i in range(n):\n        prv = -1\n        while st and a[i] > a[st[-1]]:\n            prv = st.pop()\n        if prv != -1:\n            p[prv] = i\n        if st:\n            p[i] = st[-1]\n        st.append(i)\n    root = -1\n    for i in range(n):\n        if p[i] != -1:\n            g[p[i]].append(i)\n        else:\n            root = i\n    return (g, root)\nINF = 1 << 31\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sa = sum(a)\n    x = list(map(int, input().split()))\n    (g, root) = Cartesian_Tree(a)\n    xx = sorted(x)\n    ans = [0] * (q + 1)\n    go = deque([[root, q]])\n    while go:\n        (now, midx) = go.pop()\n        if len(g[now]) == 2:\n            dif = a[now] - max(a[g[now][0]], a[g[now][1]])\n            idx = bisect.bisect_right(xx, dif)\n            if idx > 0:\n                ans[0] -= 2 * a[now]\n                ans[min(midx, idx)] += 2 * a[now]\n            midx = min(midx, idx)\n        elif len(g[now]) == 1:\n            dif = a[now] - a[g[now][0]]\n            idx = bisect.bisect_right(xx, dif)\n            if idx > 0:\n                ans[0] -= 2 * a[now]\n                ans[min(midx, idx)] += 2 * a[now]\n            midx = min(midx, idx)\n        else:\n            ans[0] -= 2 * a[now]\n            ans[midx] += 2 * a[now]\n        for i in g[now]:\n            go.append([i, midx])\n    for i in range(1, q):\n        ans[i] += ans[i - 1]\n    for i in range(q):\n        ans[i] += sa\n    rans = [0] * q\n    for i in range(q):\n        idx = bisect.bisect_right(xx, x[i])\n        rans[i] = ans[idx - 1]\n    print(*rans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(5 * 10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\nclass segtree:\n\n    def __init__(self, n, function, bound):\n        self.st = [bound] * (2 * n)\n        self.size = n\n        self.function = function\n        self.bound = bound\n\n    def update(self, x, value):\n        x += self.size\n        self.st[x] = value\n        while x > 1:\n            x >>= 1\n            self.st[x] = self.function(self.st[2 * x], self.st[2 * x + 1])\n\n    def query(self, x, y):\n        x += self.size\n        y += self.size + 1\n        ans = self.bound\n        while x < y:\n            if x & 1:\n                ans = self.function(ans, self.st[x])\n                x += 1\n            if y & 1:\n                y -= 1\n                ans = self.function(ans, self.st[y])\n            x //= 2\n            y //= 2\n        return ans\n\ndef dfs(left, right, mx):\n    if left > right:\n        return\n    if left == right:\n        (l, h) = (0, q - 1)\n        index = 0\n        while l <= h:\n            mid = (l + h) // 2\n            if queries[mid][0] <= mx:\n                index = mid + 1\n                l = mid + 1\n            else:\n                h = mid - 1\n        sub[index] += 2 * a[left]\n        return\n    mval = st.query(left, right)\n    (l, h) = (0, len(key[mval]) - 1)\n    while l <= h:\n        mid = (l + h) // 2\n        if key[mval][mid] < left:\n            l = mid + 1\n            continue\n        if key[mval][mid] > right:\n            h = mid - 1\n            continue\n        ind = key[mval][mid]\n        break\n    smval = max(st.query(left, ind - 1), st.query(ind + 1, right))\n    mx = min(mx, mval - smval)\n    (l, h) = (0, q - 1)\n    index = 0\n    while l <= h:\n        mid = (l + h) // 2\n        if queries[mid][0] <= mx:\n            index = mid + 1\n            l = mid + 1\n        else:\n            h = mid - 1\n    sub[index] += 2 * mval\n    dfs(left, ind - 1, mx)\n    dfs(ind + 1, right, mx)\n\ndef answer():\n    global queries, sub, st, key\n    key = dict()\n    st = segtree(n, max, 0)\n    for i in range(n):\n        st.update(i, a[i])\n        try:\n            key[a[i]].append(i)\n        except:\n            key[a[i]] = [i]\n    queries = [[x[i], i] for i in range(q)]\n    queries.sort()\n    sub = [0 for i in range(q + 1)]\n    dfs(0, n - 1, float('inf'))\n    for i in range(q - 1, 0, -1):\n        sub[i] += sub[i + 1]\n    ans = [-1 for i in range(q)]\n    for i in range(q):\n        ans[queries[i][1]] = total - sub[i + 1]\n    return ans\nfor T in range(int(input())):\n    (n, q) = inp()\n    a = inp()\n    x = inp()\n    total = sum(a)\n    print(*answer())"]