["from math import comb\nmod = int(1000000000.0 + 7)\n\ndef powe(base, exp):\n    ans = 1\n    while exp:\n        if exp & 1:\n            ans = ans * base % mod\n        base = base * base % mod\n        exp //= 2\n    return ans\n\ndef inverse(base):\n    return powe(base, mod - 2)\n\ndef handle0(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return 2\n    elif inte == 1:\n        return 1\n    elif inte == 2:\n        return -1\n    elif inte == 3:\n        return -2\n    elif inte == 4:\n        return -1\n    else:\n        return 1\n\ndef handle1(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return -1\n    elif inte == 1:\n        return 1\n    elif inte == 2:\n        return 2\n    elif inte == 3:\n        return 1\n    elif inte == 4:\n        return -1\n    else:\n        return -2\n\ndef handle2(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return -1\n    elif inte == 1:\n        return -2\n    elif inte == 2:\n        return -1\n    elif inte == 3:\n        return 1\n    elif inte == 4:\n        return 2\n    else:\n        return 1\n\ndef solver(a, b):\n    a0 = (handle0(a) + powe(2, a)) * inverse(3) % mod\n    a1 = (handle1(a) + powe(2, a)) * inverse(3) % mod\n    a2 = (handle2(a) + powe(2, a)) * inverse(3) % mod\n    b0 = (handle0(b) + powe(2, b)) * inverse(3) % mod\n    b1 = (handle1(b) + powe(2, b)) * inverse(3) % mod\n    b2 = (handle2(b) + powe(2, b)) * inverse(3) % mod\n    print(((a0 * b0 + a1 * b1 + a2 * b2) % mod + mod - 1) % mod)\n\ndef main():\n    t = int(input())\n    while t:\n        k = input()\n        k = k.split()\n        solver(int(k[0]), int(k[1]))\n        t -= 1\nmain()", "from math import comb\nmod = int(1000000000.0 + 7)\n\ndef powe(base, exp):\n    ans = 1\n    while exp:\n        if exp & 1:\n            ans = ans * base % mod\n        base = base * base % mod\n        exp //= 2\n    return ans\n\ndef inverse(base):\n    return powe(base, mod - 2)\n\ndef handle0(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return 2\n    elif inte == 1:\n        return 1\n    elif inte == 2:\n        return -1\n    elif inte == 3:\n        return -2\n    elif inte == 4:\n        return -1\n    else:\n        return 1\n\ndef handle1(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return -1\n    elif inte == 1:\n        return 1\n    elif inte == 2:\n        return 2\n    elif inte == 3:\n        return 1\n    elif inte == 4:\n        return -1\n    else:\n        return -2\n\ndef handle2(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return -1\n    elif inte == 1:\n        return -2\n    elif inte == 2:\n        return -1\n    elif inte == 3:\n        return 1\n    elif inte == 4:\n        return 2\n    else:\n        return 1\n\ndef solver(a, b):\n    a0 = (handle0(a) + powe(2, a)) * inverse(3) % mod\n    a1 = (handle1(a) + powe(2, a)) * inverse(3) % mod\n    a2 = (handle2(a) + powe(2, a)) * inverse(3) % mod\n    b0 = (handle0(b) + powe(2, b)) * inverse(3) % mod\n    b1 = (handle1(b) + powe(2, b)) * inverse(3) % mod\n    b2 = (handle2(b) + powe(2, b)) * inverse(3) % mod\n    print(((a0 * b0 + a1 * b1 + a2 * b2) % mod + mod - 1) % mod)\n\ndef main():\n    t = int(input())\n    while t:\n        k = input()\n        k = k.split()\n        solver(int(k[0]), int(k[1]))\n        t -= 1\nmain()", "from math import comb\nmod = int(1000000000.0 + 7)\n\ndef powe(base, exp):\n    ans = 1\n    while exp:\n        if exp & 1:\n            ans = ans * base % mod\n        base = base * base % mod\n        exp //= 2\n    return ans\n\ndef inverse(base):\n    return powe(base, mod - 2)\n\ndef handle0(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return 2\n    elif inte == 1:\n        return 1\n    elif inte == 2:\n        return -1\n    elif inte == 3:\n        return -2\n    elif inte == 4:\n        return -1\n    else:\n        return 1\n\ndef handle1(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return -1\n    elif inte == 1:\n        return 1\n    elif inte == 2:\n        return 2\n    elif inte == 3:\n        return 1\n    elif inte == 4:\n        return -1\n    else:\n        return -2\n\ndef handle2(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return -1\n    elif inte == 1:\n        return -2\n    elif inte == 2:\n        return -1\n    elif inte == 3:\n        return 1\n    elif inte == 4:\n        return 2\n    else:\n        return 1\n\ndef solver(a, b):\n    a0 = (handle0(a) + powe(2, a)) * inverse(3) % mod\n    a1 = (handle1(a) + powe(2, a)) * inverse(3) % mod\n    a2 = (handle2(a) + powe(2, a)) * inverse(3) % mod\n    b0 = (handle0(b) + powe(2, b)) * inverse(3) % mod\n    b1 = (handle1(b) + powe(2, b)) * inverse(3) % mod\n    b2 = (handle2(b) + powe(2, b)) * inverse(3) % mod\n    print(((a0 * b0 + a1 * b1 + a2 * b2) % mod + mod - 1) % mod)\n\ndef main():\n    t = int(input())\n    while t:\n        k = input()\n        k = k.split()\n        solver(int(k[0]), int(k[1]))\n        t -= 1\nmain()", "def power(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % MOD\n        b = b * b % MOD\n        n //= 2\n    return s\n\ndef Inv(x):\n    return power(x, MOD - 2)\nMOD = 1000000007\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [0, 0, 0]\n    b = [0, 0, 0]\n    a[0] = ([2, 1, -1, -2, -1, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n    a[1] = ([-1, 1, 2, 1, -1, -2][n % 6] + power(2, n)) * Inv(3) % MOD\n    a[2] = ([-1, -2, -1, 1, 2, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n    b[0] = ([2, 1, -1, -2, -1, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n    b[1] = ([-1, 1, 2, 1, -1, -2][m % 6] + power(2, m)) * Inv(3) % MOD\n    b[2] = ([-1, -2, -1, 1, 2, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) % MOD + MOD - 1) % MOD)", "mod = 1000000007\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    ans = 0\n    x = [2, 1, -1, -2, -1, 1]\n    y = [-1, 1, 2, 1, -1, -2]\n    a0 = (pow(2, n, mod) + x[n % 6]) * pow(3, mod - 2, mod) % mod\n    a1 = (pow(2, n, mod) + y[n % 6]) * pow(3, mod - 2, mod) % mod\n    a2 = (pow(2, n, mod) - a0 - a1) % mod\n    b0 = (pow(2, m, mod) + x[m % 6]) * pow(3, mod - 2, mod) % mod\n    b1 = (pow(2, m, mod) + y[m % 6]) * pow(3, mod - 2, mod) % mod\n    b2 = (pow(2, m, mod) - b0 - b1) % mod\n    ans = (a0 * b0 + a1 * b1 + a2 * b2 - 1) % mod\n    print(ans)", "mod = 1000000007\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    ans = 0\n    x = [2, 1, -1, -2, -1, 1]\n    y = [-1, 1, 2, 1, -1, -2]\n    a0 = (pow(2, n, mod) + x[n % 6]) * pow(3, mod - 2, mod) % mod\n    a1 = (pow(2, n, mod) + y[n % 6]) * pow(3, mod - 2, mod) % mod\n    a2 = (pow(2, n, mod) - a0 - a1) % mod\n    b0 = (pow(2, m, mod) + x[m % 6]) * pow(3, mod - 2, mod) % mod\n    b1 = (pow(2, m, mod) + y[m % 6]) * pow(3, mod - 2, mod) % mod\n    b2 = (pow(2, m, mod) - b0 - b1) % mod\n    ans = (a0 * b0 + a1 * b1 + a2 * b2 - 1) % mod\n    print(ans)", "mod = 1000000007\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    ans = 0\n    x = [2, 1, -1, -2, -1, 1]\n    y = [-1, 1, 2, 1, -1, -2]\n    a0 = (pow(2, n, mod) + x[n % 6]) * pow(3, mod - 2, mod) % mod\n    a1 = (pow(2, n, mod) + y[n % 6]) * pow(3, mod - 2, mod) % mod\n    a2 = (pow(2, n, mod) - a0 - a1) % mod\n    b0 = (pow(2, m, mod) + x[m % 6]) * pow(3, mod - 2, mod) % mod\n    b1 = (pow(2, m, mod) + y[m % 6]) * pow(3, mod - 2, mod) % mod\n    b2 = (pow(2, m, mod) - b0 - b1) % mod\n    ans = (a0 * b0 + a1 * b1 + a2 * b2 - 1) % mod\n    print(ans)", "mod = 1000000007\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    ans = 0\n    x = [2, 1, -1, -2, -1, 1]\n    y = [-1, 1, 2, 1, -1, -2]\n    a0 = (pow(2, n, mod) + x[n % 6]) * pow(3, mod - 2, mod) % mod\n    a1 = (pow(2, n, mod) + y[n % 6]) * pow(3, mod - 2, mod) % mod\n    a2 = (pow(2, n, mod) - a0 - a1) % mod\n    b0 = (pow(2, m, mod) + x[m % 6]) * pow(3, mod - 2, mod) % mod\n    b1 = (pow(2, m, mod) + y[m % 6]) * pow(3, mod - 2, mod) % mod\n    b2 = (pow(2, m, mod) - b0 - b1) % mod\n    ans = (a0 * b0 + a1 * b1 + a2 * b2 - 1) % mod\n    print(ans)", "mod = 1000000007\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    ans = 0\n    x = [2, 1, -1, -2, -1, 1]\n    y = [-1, 1, 2, 1, -1, -2]\n    a0 = (pow(2, n, mod) + x[n % 6]) * pow(3, mod - 2, mod) % mod\n    a1 = (pow(2, n, mod) + y[n % 6]) * pow(3, mod - 2, mod) % mod\n    a2 = (pow(2, n, mod) - a0 - a1) % mod\n    b0 = (pow(2, m, mod) + x[m % 6]) * pow(3, mod - 2, mod) % mod\n    b1 = (pow(2, m, mod) + y[m % 6]) * pow(3, mod - 2, mod) % mod\n    b2 = (pow(2, m, mod) - b0 - b1) % mod\n    ans = (a0 * b0 + a1 * b1 + a2 * b2 - 1) % mod\n    print(ans)", "def power(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % MOD\n        b = b * b % MOD\n        n //= 2\n    return s\n\ndef Inv(x):\n    return power(x, MOD - 2)\nMOD = 1000000007\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [0, 0, 0]\n    b = [0, 0, 0]\n    a[0] = ([2, 1, -1, -2, -1, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n    a[1] = ([-1, 1, 2, 1, -1, -2][n % 6] + power(2, n)) * Inv(3) % MOD\n    a[2] = ([-1, -2, -1, 1, 2, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n    b[0] = ([2, 1, -1, -2, -1, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n    b[1] = ([-1, 1, 2, 1, -1, -2][m % 6] + power(2, m)) * Inv(3) % MOD\n    b[2] = ([-1, -2, -1, 1, 2, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) % MOD + MOD - 1) % MOD)", "def power(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % MOD\n        b = b * b % MOD\n        n //= 2\n    return s\n\ndef Inv(x):\n    return power(x, MOD - 2)\nMOD = 1000000007\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [0, 0, 0]\n    b = [0, 0, 0]\n    a[0] = ([2, 1, -1, -2, -1, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n    a[1] = ([-1, 1, 2, 1, -1, -2][n % 6] + power(2, n)) * Inv(3) % MOD\n    a[2] = ([-1, -2, -1, 1, 2, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n    b[0] = ([2, 1, -1, -2, -1, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n    b[1] = ([-1, 1, 2, 1, -1, -2][m % 6] + power(2, m)) * Inv(3) % MOD\n    b[2] = ([-1, -2, -1, 1, 2, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) % MOD + MOD - 1) % MOD)", "def power(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % MOD\n        b = b * b % MOD\n        n //= 2\n    return s\n\ndef Inv(x):\n    return power(x, MOD - 2)\nMOD = 1000000007\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [0, 0, 0]\n    b = [0, 0, 0]\n    a[0] = ([2, 1, -1, -2, -1, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n    a[1] = ([-1, 1, 2, 1, -1, -2][n % 6] + power(2, n)) * Inv(3) % MOD\n    a[2] = ([-1, -2, -1, 1, 2, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n    b[0] = ([2, 1, -1, -2, -1, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n    b[1] = ([-1, 1, 2, 1, -1, -2][m % 6] + power(2, m)) * Inv(3) % MOD\n    b[2] = ([-1, -2, -1, 1, 2, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) % MOD + MOD - 1) % MOD)", "for _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    (a, b) = [[[2, 1, -1, -2, -1, 1][n % 6] + pow(2, n, 1000000007), [-1, 1, 2, 1, -1, -2][n % 6] + pow(2, n, 1000000007), [-1, -2, -1, 1, 2, 1][n % 6] + pow(2, n, 1000000007)], [[2, 1, -1, -2, -1, 1][m % 6] + pow(2, m, 1000000007), [-1, 1, 2, 1, -1, -2][m % 6] + pow(2, m, 1000000007), [-1, -2, -1, 1, 2, 1][m % 6] + pow(2, m, 1000000007)]]\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) * 111111112 + 1000000006) % 1000000007)", "for _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    (a, b) = [[[2, 1, -1, -2, -1, 1][n % 6] + pow(2, n, 1000000007), [-1, 1, 2, 1, -1, -2][n % 6] + pow(2, n, 1000000007), [-1, -2, -1, 1, 2, 1][n % 6] + pow(2, n, 1000000007)], [[2, 1, -1, -2, -1, 1][m % 6] + pow(2, m, 1000000007), [-1, 1, 2, 1, -1, -2][m % 6] + pow(2, m, 1000000007), [-1, -2, -1, 1, 2, 1][m % 6] + pow(2, m, 1000000007)]]\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) * 111111112 + 1000000006) % 1000000007)", "for _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    (a, b) = [[[2, 1, -1, -2, -1, 1][n % 6] + pow(2, n, 1000000007), [-1, 1, 2, 1, -1, -2][n % 6] + pow(2, n, 1000000007), [-1, -2, -1, 1, 2, 1][n % 6] + pow(2, n, 1000000007)], [[2, 1, -1, -2, -1, 1][m % 6] + pow(2, m, 1000000007), [-1, 1, 2, 1, -1, -2][m % 6] + pow(2, m, 1000000007), [-1, -2, -1, 1, 2, 1][m % 6] + pow(2, m, 1000000007)]]\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) * 111111112 + 1000000006) % 1000000007)", "for _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    (a, b) = [[[2, 1, -1, -2, -1, 1][n % 6] + pow(2, n, 1000000007), [-1, 1, 2, 1, -1, -2][n % 6] + pow(2, n, 1000000007), [-1, -2, -1, 1, 2, 1][n % 6] + pow(2, n, 1000000007)], [[2, 1, -1, -2, -1, 1][m % 6] + pow(2, m, 1000000007), [-1, 1, 2, 1, -1, -2][m % 6] + pow(2, m, 1000000007), [-1, -2, -1, 1, 2, 1][m % 6] + pow(2, m, 1000000007)]]\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) * 111111112 + 1000000006) % 1000000007)", "def power(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % MOD\n        b = b * b % MOD\n        n //= 2\n    return s\n\ndef Inv(x):\n    return power(x, MOD - 2)\nMOD = 1000000007\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [0, 0, 0]\n    b = [0, 0, 0]\n    a[0] = ([2, 1, -1, -2, -1, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n    a[1] = ([-1, 1, 2, 1, -1, -2][n % 6] + power(2, n)) * Inv(3) % MOD\n    a[2] = ([-1, -2, -1, 1, 2, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n    b[0] = ([2, 1, -1, -2, -1, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n    b[1] = ([-1, 1, 2, 1, -1, -2][m % 6] + power(2, m)) * Inv(3) % MOD\n    b[2] = ([-1, -2, -1, 1, 2, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) % MOD + MOD - 1) % MOD)", "from math import comb\nmod = int(1000000000.0 + 7)\n\ndef powe(base, exp):\n    ans = 1\n    while exp:\n        if exp & 1:\n            ans = ans * base % mod\n        base = base * base % mod\n        exp //= 2\n    return ans\n\ndef inverse(base):\n    return powe(base, mod - 2)\n\ndef handle0(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return 2\n    elif inte == 1:\n        return 1\n    elif inte == 2:\n        return -1\n    elif inte == 3:\n        return -2\n    elif inte == 4:\n        return -1\n    else:\n        return 1\n\ndef handle1(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return -1\n    elif inte == 1:\n        return 1\n    elif inte == 2:\n        return 2\n    elif inte == 3:\n        return 1\n    elif inte == 4:\n        return -1\n    else:\n        return -2\n\ndef handle2(n):\n    inte = n % 6\n    if n % 6 == 0:\n        return -1\n    elif inte == 1:\n        return -2\n    elif inte == 2:\n        return -1\n    elif inte == 3:\n        return 1\n    elif inte == 4:\n        return 2\n    else:\n        return 1\n\ndef solver(a, b):\n    a0 = (handle0(a) + powe(2, a)) * inverse(3) % mod\n    a1 = (handle1(a) + powe(2, a)) * inverse(3) % mod\n    a2 = (handle2(a) + powe(2, a)) * inverse(3) % mod\n    b0 = (handle0(b) + powe(2, b)) * inverse(3) % mod\n    b1 = (handle1(b) + powe(2, b)) * inverse(3) % mod\n    b2 = (handle2(b) + powe(2, b)) * inverse(3) % mod\n    print(((a0 * b0 + a1 * b1 + a2 * b2) % mod + mod - 1) % mod)\n\ndef main():\n    t = int(input())\n    while t:\n        k = input()\n        k = k.split()\n        solver(int(k[0]), int(k[1]))\n        t -= 1\nmain()", "os = [[1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1]]\np = 10 ** 9 + 7\n\ndef razn(x, y):\n    return (x - y) % p\n\ndef slog(x, y):\n    return (x + y) % p\n\ndef mult(x, y):\n    return x * y % p\n\ndef pow(x, y):\n    s = x\n    res = 1\n    while y > 0:\n        a = y % 2\n        if a:\n            res = mult(res, s)\n        s = mult(s, s)\n        y = y // 2\n    return res\n\ndef delen(x, y):\n    return mult(x, pow(y, p - 2))\n\ndef rasp(n):\n    if n % 2:\n        e = 2\n    else:\n        e = 1\n    w = delen(razn(pow(2, n), e), 3)\n    res = [w, w, w]\n    q = os[n % 6]\n    for i in range(3):\n        res[i] += q[i]\n    return res\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = rasp(n)\n    b = rasp(m)\n    otv = 0\n    for x in range(3):\n        otv = slog(otv, mult(a[x], b[x]))\n    otv = razn(otv, 1)\n    print(otv)", "os = [[1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1]]\np = 10 ** 9 + 7\n\ndef razn(x, y):\n    return (x - y) % p\n\ndef slog(x, y):\n    return (x + y) % p\n\ndef mult(x, y):\n    return x * y % p\n\ndef pow(x, y):\n    s = x\n    res = 1\n    while y > 0:\n        a = y % 2\n        if a:\n            res = mult(res, s)\n        s = mult(s, s)\n        y = y // 2\n    return res\n\ndef delen(x, y):\n    return mult(x, pow(y, p - 2))\n\ndef rasp(n):\n    if n % 2:\n        e = 2\n    else:\n        e = 1\n    w = delen(razn(pow(2, n), e), 3)\n    res = [w, w, w]\n    q = os[n % 6]\n    for i in range(3):\n        res[i] += q[i]\n    return res\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = rasp(n)\n    b = rasp(m)\n    otv = 0\n    for x in range(3):\n        otv = slog(otv, mult(a[x], b[x]))\n    otv = razn(otv, 1)\n    print(otv)", "MOD = 10 ** 9 + 7\n\ndef calPower(i, j):\n    sums = 1\n    while j:\n        if j % 2 == 1:\n            sums = sums * i % MOD\n        i = i * i % MOD\n        j //= 2\n    return sums\n\ndef inverse(n):\n    return calPower(n, MOD - 2)\nT = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    arrA = [0 for _ in range(3)]\n    arrB = [0 for _ in range(3)]\n    arrA[0] = ([2, 1, -1, -2, -1, 1][N % 6] + calPower(2, N)) * inverse(3) % MOD\n    arrA[1] = ([-1, 1, 2, 1, -1, -2][N % 6] + calPower(2, N)) * inverse(3) % MOD\n    arrA[2] = ([-1, -2, -1, 1, 2, 1][N % 6] + calPower(2, N)) * inverse(3) % MOD\n    arrB[0] = ([2, 1, -1, -2, -1, 1][M % 6] + calPower(2, M)) * inverse(3) % MOD\n    arrB[1] = ([-1, 1, 2, 1, -1, -2][M % 6] + calPower(2, M)) * inverse(3) % MOD\n    arrB[2] = ([-1, -2, -1, 1, 2, 1][M % 6] + calPower(2, M)) * inverse(3) % MOD\n    print(((arrA[0] * arrB[0] + arrA[1] * arrB[1] + arrA[2] * arrB[2]) % MOD + MOD - 1) % MOD)", "import math\nMOD = 1000000007\n\ndef power(b, n):\n    r = 1\n    while n:\n        if n % 2 == 1:\n            r = r * b % MOD\n        b = b * b % MOD\n        n = n // 2\n    return r\n\ndef Inv(x):\n    return power(x, MOD - 2)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    r = 0\n    a = [0 for _ in range(3)]\n    b = [0 for _ in range(3)]\n    a0 = [2, 1, -1, -2, -1, 1]\n    a1 = [-1, 1, 2, 1, -1, -2]\n    a2 = [-1, -2, -1, 1, 2, 1]\n    b0 = [2, 1, -1, -2, -1, 1]\n    b1 = [-1, 1, 2, 1, -1, -2]\n    b2 = [-1, -2, -1, 1, 2, 1]\n    a[0] = (a0[n % 6] + power(2, n)) * Inv(3) % MOD\n    a[1] = (a1[n % 6] + power(2, n)) * Inv(3) % MOD\n    a[2] = (a2[n % 6] + power(2, n)) * Inv(3) % MOD\n    b[0] = (b0[m % 6] + power(2, m)) * Inv(3) % MOD\n    b[1] = (b1[m % 6] + power(2, m)) * Inv(3) % MOD\n    b[2] = (b2[m % 6] + power(2, m)) * Inv(3) % MOD\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) % MOD + MOD - 1) % MOD)", "for _ in range(int(input())):\n    (N, M) = map(int, input().split(' '))\n    modulo = 10 ** 9 + 7\n    my_sum = pow(2, N + M, modulo)\n    special = 1 if (M - N) % 3 == 0 else 0\n    if (N + M) % 2 == 0:\n        result = (my_sum - 1) * pow(3, -1, modulo) + special - 1\n    else:\n        result = (my_sum + 1) * pow(3, -1, modulo) - special - 1\n    print(result % modulo)", "for _ in range(int(input())):\n    (N, M) = list(map(int, input().split()))\n    mod = 1000000007\n    x = 111111112\n    y = 1000000006\n    (p, q) = [[[2, 1, -1, -2, -1, 1][N % 6] + pow(2, N, mod), [-1, 1, 2, 1, -1, -2][N % 6] + pow(2, N, mod), [-1, -2, -1, 1, 2, 1][N % 6] + pow(2, N, mod)], [[2, 1, -1, -2, -1, 1][M % 6] + pow(2, M, mod), [-1, 1, 2, 1, -1, -2][M % 6] + pow(2, M, mod), [-1, -2, -1, 1, 2, 1][M % 6] + pow(2, M, mod)]]\n    print(((p[0] * q[0] + p[1] * q[1] + p[2] * q[2]) * x + y) % mod)", "def po(b, k):\n    s = 1\n    while k:\n        if k % 2 == 1:\n            s = s * b % 1000000007\n        b = b * b % 1000000007\n        k = k // 2\n    return s\n\ndef iv(x):\n    return po(x, 1000000007 - 2)\n\ndef kar():\n    (n, m) = map(int, input().split())\n    (a, b) = ([], [])\n    a.append(([2, 1, -1, -2, -1, 1][n % 6] + po(2, n)) * iv(3) % 1000000007)\n    a.append(([-1, 1, 2, 1, -1, -2][n % 6] + po(2, n)) * iv(3) % 1000000007)\n    a.append(([-1, -2, -1, 1, 2, 1][n % 6] + po(2, n)) * iv(3) % 1000000007)\n    b.append(([2, 1, -1, -2, -1, 1][m % 6] + po(2, m)) * iv(3) % 1000000007)\n    b.append(([-1, 1, 2, 1, -1, -2][m % 6] + po(2, m)) * iv(3) % 1000000007)\n    b.append(([-1, -2, -1, 1, 2, 1][m % 6] + po(2, m)) * iv(3) % 1000000007)\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) % 1000000007 + 1000000007 - 1) % 1000000007)\nt = int(input())\nfor h in range(t):\n    kar()", "MOD = 10 ** 9 + 7\nthrinv = pow(3, -1, MOD)\n\ndef carve(n, i):\n    sculp = pow(2, n, MOD) - n % 2 - 1\n    if (n + ((i << 2) + 1)) % 6 < 3:\n        sculp += 3\n    return sculp * thrinv % MOD\n\ndef main(N, M):\n    subsets = -1\n    for i in range(3):\n        ns = carve(N, i)\n        ms = carve(M, i)\n        subsets += ns * ms % MOD\n    return subsets % MOD\nT = int(input())\nfor i in range(T):\n    (N, M) = map(int, input().split())\n    print(main(N, M))", "MOD = 1000000007\n\ndef o(a1, a2):\n    t = 1\n    while a2:\n        if a2 % 2 == 1:\n            t = t * a1 % MOD\n        a1 = a1 * a1 % MOD\n        a2 //= 2\n    return t\n\ndef i(x):\n    return o(x, MOD - 2)\nl1 = [0] * 3\nl2 = [0] * 3\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l1[0] = ([2, 1, -1, -2, -1, 1][n % 6] + o(2, n)) * i(3) % MOD\n    l1[1] = ([-1, 1, 2, 1, -1, -2][n % 6] + o(2, n)) * i(3) % MOD\n    l1[2] = ([-1, -2, -1, 1, 2, 1][n % 6] + o(2, n)) * i(3) % MOD\n    l2[0] = ([2, 1, -1, -2, -1, 1][m % 6] + o(2, m)) * i(3) % MOD\n    l2[1] = ([-1, 1, 2, 1, -1, -2][m % 6] + o(2, m)) * i(3) % MOD\n    l2[2] = ([-1, -2, -1, 1, 2, 1][m % 6] + o(2, m)) * i(3) % MOD\n    print(((l1[0] * l2[0] + l1[1] * l2[1] + l1[2] * l2[2]) % MOD + MOD - 1) % MOD)", "MOD = 1000000007\n\ndef o(a1, a2):\n    t = 1\n    while a2:\n        if a2 % 2 == 1:\n            t = t * a1 % MOD\n        a1 = a1 * a1 % MOD\n        a2 //= 2\n    return t\n\ndef i(x):\n    return o(x, MOD - 2)\nl1 = [0] * 3\nl2 = [0] * 3\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l1[0] = ([2, 1, -1, -2, -1, 1][n % 6] + o(2, n)) * i(3) % MOD\n    l1[1] = ([-1, 1, 2, 1, -1, -2][n % 6] + o(2, n)) * i(3) % MOD\n    l1[2] = ([-1, -2, -1, 1, 2, 1][n % 6] + o(2, n)) * i(3) % MOD\n    l2[0] = ([2, 1, -1, -2, -1, 1][m % 6] + o(2, m)) * i(3) % MOD\n    l2[1] = ([-1, 1, 2, 1, -1, -2][m % 6] + o(2, m)) * i(3) % MOD\n    l2[2] = ([-1, -2, -1, 1, 2, 1][m % 6] + o(2, m)) * i(3) % MOD\n    print(((l1[0] * l2[0] + l1[1] * l2[1] + l1[2] * l2[2]) % MOD + MOD - 1) % MOD)", "def raised(b, max_power):\n    s = 1\n    while max_power != 0:\n        if max_power % 2 == 1:\n            s = s * b % mod\n        b = b ** 2 % mod\n        max_power = int(max_power / 2)\n    return s\n\ndef multi(m_arg):\n    return raised(m_arg, mod - 2)\nfor test_loop in range(int(input())):\n    mod = 1000000007\n    (max_power, max_range) = list(map(int, input().split()))\n    arr1 = [0] * 3\n    arr2 = [0] * 3\n    np_value = raised(2, max_power)\n    mp_value = raised(2, max_range)\n    multiplier = multi(3)\n    zeroth = [2, 1, -1, -2, -1, 1]\n    first = [-1, 1, 2, 1, -1, -2]\n    second = [-1, -2, -1, 1, 2, 1]\n    akey = max_power % 6\n    bkey = max_range % 6\n    a0 = zeroth[akey] + np_value\n    a1 = first[akey] + np_value\n    a2 = second[akey] + np_value\n    b0 = zeroth[bkey] + mp_value\n    b1 = first[bkey] + mp_value\n    b2 = second[bkey] + mp_value\n    arr1[0] = a0 * multiplier % mod\n    arr1[1] = a1 * multiplier % mod\n    arr1[2] = a2 * multiplier % mod\n    arr2[0] = b0 * multiplier % mod\n    arr2[1] = b1 * multiplier % mod\n    arr2[2] = b2 * multiplier % mod\n    final_cal = arr1[0] * arr2[0] + arr1[1] * arr2[1] + arr1[2] * arr2[2]\n    t = (final_cal % mod + mod - 1) % mod\n    print(t)", "TENP7 = 1000000007\nTHREE_MODINV_SQ = 111111112\n\ndef rotate(l, n):\n    return l[n:] + l[:n]\ncoeff = [-1, -2, -1, 1, 2, 1]\ncoeff = [coeff, [-x for x in rotate(coeff, 1)], rotate(coeff, 2)]\n\ndef pow(base, exp):\n    base %= TENP7\n    res = 1\n    while exp > 0:\n        if exp & 1:\n            res *= base % TENP7\n        base *= base % TENP7\n        exp >>= 1\n    return res\n\ndef solve():\n    (n, m) = map(int, input().split(' '))\n    ss_count_n = pow(2, n)\n    ss_count_m = pow(2, m)\n    n %= 6\n    m %= 6\n    res = 0\n    for i in range(3):\n        res += (coeff[i][n] + ss_count_n) * (coeff[i][m] + ss_count_m) * THREE_MODINV_SQ % TENP7\n    print(res % TENP7 - 1)\ntt = int(input())\nwhile tt:\n    tt -= 1\n    solve()", "MOD = 1000000007\n\ndef p(a1, a2):\n    t = 1\n    while a2:\n        if a2 % 2 == 1:\n            t = t * a1 % MOD\n        a1 = a1 * a1 % MOD\n        a2 //= 2\n    return t\n\ndef i(x):\n    return p(x, MOD - 2)\nl1 = [0] * 3\nl2 = [0] * 3\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l1[0] = ([2, 1, -1, -2, -1, 1][n % 6] + p(2, n)) * i(3) % MOD\n    l1[1] = ([-1, 1, 2, 1, -1, -2][n % 6] + p(2, n)) * i(3) % MOD\n    l1[2] = ([-1, -2, -1, 1, 2, 1][n % 6] + p(2, n)) * i(3) % MOD\n    l2[0] = ([2, 1, -1, -2, -1, 1][m % 6] + p(2, m)) * i(3) % MOD\n    l2[1] = ([-1, 1, 2, 1, -1, -2][m % 6] + p(2, m)) * i(3) % MOD\n    l2[2] = ([-1, -2, -1, 1, 2, 1][m % 6] + p(2, m)) * i(3) % MOD\n    print(((l1[0] * l2[0] + l1[1] * l2[1] + l1[2] * l2[2]) % MOD + MOD - 1) % MOD)", "MOD = 1000000007\n\ndef pow(arg1, arg2):\n    temp = 1\n    while arg2:\n        if arg2 % 2 == 1:\n            temp = temp * arg1 % MOD\n        arg1 = arg1 * arg1 % MOD\n        arg2 //= 2\n    return temp\n\ndef invt(x):\n    return pow(x, MOD - 2)\nlst1 = [0] * 3\nlst2 = [0] * 3\nfor trie in range(int(input())):\n    (n, m) = map(int, input().split())\n    lst1[0] = ([2, 1, -1, -2, -1, 1][n % 6] + pow(2, n)) * invt(3) % MOD\n    lst1[1] = ([-1, 1, 2, 1, -1, -2][n % 6] + pow(2, n)) * invt(3) % MOD\n    lst1[2] = ([-1, -2, -1, 1, 2, 1][n % 6] + pow(2, n)) * invt(3) % MOD\n    lst2[0] = ([2, 1, -1, -2, -1, 1][m % 6] + pow(2, m)) * invt(3) % MOD\n    lst2[1] = ([-1, 1, 2, 1, -1, -2][m % 6] + pow(2, m)) * invt(3) % MOD\n    lst2[2] = ([-1, -2, -1, 1, 2, 1][m % 6] + pow(2, m)) * invt(3) % MOD\n    print(((lst1[0] * lst2[0] + lst1[1] * lst2[1] + lst1[2] * lst2[2]) % MOD + MOD - 1) % MOD)", "import math\nbeeg = 1000000007\nfor tea in range(int(input())):\n    (n, m) = [int(aaa) for aaa in input().split()]\n    pown = pow(2, n, beeg * 3)\n    ns = [math.floor((pown + 1) // 3), math.floor((pown + 1) // 3), math.floor((pown + 1) // 3)]\n    ns[-n % 3] += (-1) ** n\n    powm = pow(2, m, beeg * 3)\n    ms = [math.floor((powm + 1) // 3), math.floor((powm + 1) // 3), math.floor((powm + 1) // 3)]\n    ms[-m % 3] += (-1) ** m\n    print(math.floor(ns[0] * ms[0] + ns[1] * ms[1] + ns[2] * ms[2] - 1) % beeg)", "def power(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % MOD\n        b = b * b % MOD\n        n //= 2\n    return s\n\ndef Inv(x):\n    return power(x, MOD - 2)\nMOD = 1000000007\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list()\n    b = list()\n    a1 = [2, 1, -1, -2, -1, 1]\n    a2 = [-1, 1, 2, 1, -1, -2]\n    a3 = [-1, -2, -1, 1, 2, 1]\n    b1 = [2, 1, -1, -2, -1, 1]\n    b2 = [-1, 1, 2, 1, -1, -2]\n    b3 = [-1, -2, -1, 1, 2, 1]\n    x1 = (a1[n % 6] + power(2, n)) * Inv(3) % MOD\n    x2 = (a2[n % 6] + power(2, n)) * Inv(3) % MOD\n    x3 = (a3[n % 6] + power(2, n)) * Inv(3) % MOD\n    y1 = (b1[m % 6] + power(2, m)) * Inv(3) % MOD\n    y2 = (b2[m % 6] + power(2, m)) * Inv(3) % MOD\n    y3 = (b3[m % 6] + power(2, m)) * Inv(3) % MOD\n    a.extend([x1, x2, x3])\n    b.extend([y1, y2, y3])\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) % MOD + MOD - 1) % MOD)", "import math\nmod = 10 ** 9 + 7\n\ndef pow(b, n):\n    s = 1\n    while n:\n        if n % 2 == 1:\n            s = s * b % mod\n        b = b * b % mod\n        n //= 2\n    return s\n\ndef fun(x):\n    return pow(x, mod - 2)\nt = int(input())\nwhile t:\n    ans = 0\n    a = [0, 0, 0]\n    b = [0, 0, 0]\n    nm = input().split()\n    n = int(nm[0])\n    m = int(nm[1])\n    a[0] = ([2, 1, -1, -2, -1, 1][n % 6] + pow(2, n)) * fun(3) % mod\n    a[1] = ([-1, 1, 2, 1, -1, -2][n % 6] + pow(2, n)) * fun(3) % mod\n    a[2] = ([-1, -2, -1, 1, 2, 1][n % 6] + pow(2, n)) * fun(3) % mod\n    b[0] = ([2, 1, -1, -2, -1, 1][m % 6] + pow(2, m)) * fun(3) % mod\n    b[1] = ([-1, 1, 2, 1, -1, -2][m % 6] + pow(2, m)) * fun(3) % mod\n    b[2] = ([-1, -2, -1, 1, 2, 1][m % 6] + pow(2, m)) * fun(3) % mod\n    ans = ((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) % mod + mod - 1) % mod\n    print(ans)\n    t -= 1", "import math\nimport cmath\np = pow(10, 9) + 7\n\ndef power(base, exp):\n    if exp == 0:\n        return 1\n    temp = power(base, exp // 2)\n    if exp % 2 == 0:\n        return temp * temp % p\n    else:\n        return base * temp * temp % p\n\ndef power1(base, exp):\n    if exp == 0:\n        return 1\n    temp = power1(base, exp // 2)\n    if exp % 2 == 0:\n        return temp * temp\n    else:\n        return base * temp * temp\nt = int(input())\nwhile t > 0:\n    st = list(map(int, input().split()))\n    pie = math.pi\n    w = complex(math.cos(2 * pie / 3), math.sin(2 * pie / 3))\n    s = 0\n    k1 = int(power(2, st[0]))\n    m1 = power1(-w ** 2, st[0])\n    s += (k1 + round((w * m1 + w ** 2 * power1(-w, st[0])).real)) % p * (power(2, st[1]) + round((w * power1(-w ** 2, st[1]) + w ** 2 * power1(-w, st[1])).real)) % p * 333333336 ** 2 % p\n    s += (k1 + round((w ** 2 * m1 + w ** 4 * power1(-w, st[0])).real)) % p * 333333336 ** 2 * (power(2, st[1]) + round((w ** 2 * power1(-w ** 2, st[1]) + w ** 4 * power1(-w, st[1])).real)) % p % p\n    s += (k1 + round((m1 + power1(-w, st[0])).real)) % p * (power(2, st[1]) + round((power1(-w ** 2, st[1]) + power1(-w, st[1])).real)) % p * 333333336 ** 2 % p\n    print((s - 1) % p)\n    t -= 1", "import math\nMODULE = 10 ** 9 + 7\ndifs = ((1, 0, 0), (1, 1, 0), (0, 1, 0), (0, 1, 1), (0, 0, 1), (1, 0, 1))\nfor _ in range(int(input())):\n    (N, M) = list(map(int, input().split()))\n    sm = [(pow(2, M, MODULE) - sum(difs[M % 6])) * pow(3, -1, MODULE) % MODULE + difs[M % 6][i] for i in range(3)]\n    sn = [(pow(2, N, MODULE) - sum(difs[N % 6])) * pow(3, -1, MODULE) % MODULE + difs[N % 6][i] for i in range(3)]\n    print((sum([sm[i] * sn[i] for i in range(3)]) - 1) % MODULE)", "mod = 10 ** 9 + 7\ninverse = 333333336\n\ndef get_power_1(N):\n    if N == 0:\n        return 1\n    if N == 1:\n        return 2\n    ans = get_power_1(N // 2) % 3\n    ans = ans * ans % 3\n    if N % 2 == 1:\n        ans = ans * 2 % 3\n    return ans\n\ndef get_power_2(N):\n    if N == 0:\n        return 1\n    if N == 1:\n        return 2\n    ans = get_power_2(N // 2) % mod\n    ans = ans * ans % mod\n    if N % 2 == 1:\n        ans = ans * 2 % mod\n    return ans\n\ndef get_terms(N):\n    ans_1 = get_power_1(N)\n    ans_2 = get_power_2(N)\n    if ans_1 % 3 == 2:\n        x0 = (ans_2 + 1) % mod * inverse % mod\n        x1 = x0\n        x2 = (x0 - 1 + mod) % mod\n    elif ans_1 % 3 == 1:\n        x0 = (ans_2 + mod - 1) % mod * inverse % mod\n        x1 = x0\n        x2 = (x0 + 1) % mod\n    if N % 3 == 0:\n        return (x2, x1, x0)\n    if N % 3 == 1:\n        return (x0, x1, x2)\n    return (x0, x2, x1)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    n_terms = get_terms(n)\n    m_terms = get_terms(m)\n    ans = (n_terms[0] % mod * m_terms[0] % mod % mod + n_terms[1] % mod * m_terms[1] % mod % mod + n_terms[2] % mod * m_terms[2] % mod % mod) % mod\n    print((ans - 1 + mod) % mod)", "mod = 10 ** 9 + 7\n\ndef get_power(base, N):\n    ans = 1\n    if N == 0:\n        return 1\n    if N == 1:\n        return base\n    ans = get_power(base, N // 2) % mod\n    ans = ans * ans % mod\n    if N % 2 == 1:\n        ans = ans * base % mod\n    return ans\n\ndef bcl(g):\n    return get_power(g, mod - 2)\n\ndef solution(n, m):\n    coeff = [[2, 1, -1, -2, -1, 1], [-1, 1, 2, 1, -1, -2], [-1, -2, -1, 1, 2, 1]]\n    two_n = get_power(2, n)\n    two_m = get_power(2, m)\n    bcl_3 = bcl(3) % mod\n    arr_1 = [(coeff[0][n % 6] + two_n) * bcl_3, (coeff[1][n % 6] + two_n) * bcl_3, (coeff[2][n % 6] + two_n) * bcl_3]\n    arr_2 = [(coeff[0][m % 6] + two_m) * bcl_3, (coeff[1][m % 6] + two_m) * bcl_3, (coeff[2][m % 6] + two_m) * bcl_3]\n    ans = ((arr_1[0] * arr_2[0] + arr_1[1] * arr_2[1] + arr_1[2] * arr_2[2]) % mod + mod - 1) % mod\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    print(solution(n, m))", "z = 1000000007\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    a2 = [-1, 1, 2, 1, -1, -2]\n    a3 = [-1, -2, -1, 1, 2, 1]\n    b1 = [2, 1, -1, -2, -1, 1]\n    a1 = [2, 1, -1, -2, -1, 1]\n    b2 = [-1, 1, 2, 1, -1, -2]\n    b3 = [-1, -2, -1, 1, 2, 1]\n    kn0 = (a1[n % 6] + pow(2, n, z)) * pow(3, z - 2, z) % z\n    km0 = (b1[m % 6] + pow(2, m, z)) * pow(3, z - 2, z) % z\n    km2 = (b3[m % 6] + pow(2, m, z)) * pow(3, z - 2, z) % z\n    kn1 = (a2[n % 6] + pow(2, n, z)) * pow(3, z - 2, z) % z\n    km1 = (b2[m % 6] + pow(2, m, z)) * pow(3, z - 2, z) % z\n    kn2 = (a3[n % 6] + pow(2, n, z)) * pow(3, z - 2, z) % z\n    ans = kn0 * km0 + kn1 * km1 + km2 * kn2\n    ans -= 1\n    print(ans % z)", "z = 1000000007\n\ndef po(a, b):\n    ze = 1000000007\n    k = 1\n    b1 = b\n    while b1 > 0:\n        if b1 % 2 == 1:\n            k = k * a % ze\n        a = a * a % ze\n        b1 >>= 1\n    return k\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    a2 = [-1, 1, 2, 1, -1, -2]\n    a3 = [-1, -2, -1, 1, 2, 1]\n    b1 = [2, 1, -1, -2, -1, 1]\n    a1 = [2, 1, -1, -2, -1, 1]\n    b2 = [-1, 1, 2, 1, -1, -2]\n    b3 = [-1, -2, -1, 1, 2, 1]\n    kn0 = (a1[n % 6] + po(2, n)) * po(3, z - 2) % z\n    km0 = (b1[m % 6] + po(2, m)) * po(3, z - 2) % z\n    km2 = (b3[m % 6] + po(2, m)) * po(3, z - 2) % z\n    kn1 = (a2[n % 6] + po(2, n)) * po(3, z - 2) % z\n    km1 = (b2[m % 6] + po(2, m)) * po(3, z - 2) % z\n    kn2 = (a3[n % 6] + po(2, n)) * po(3, z - 2) % z\n    ans = kn0 * km0 + kn1 * km1 + km2 * kn2\n    ans = (ans % z + z - 1) % z\n    print(ans % z)", "from cmath import pi\nfrom math import cos\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = 10 ** 9 + 7\n    n2 = pow(2, n, d)\n    m2 = pow(2, m, d)\n    var = pow(9, d - 2, d)\n    s1 = (n2 + round(2 * cos(n * pi / 3))) % d * ((m2 + round(2 * cos(m * pi / 3))) % d) % d\n    s1 *= var\n    s2 = (n2 - round(2 * cos((n + 1) * pi / 3))) % d * ((m2 - round(2 * cos((m + 1) * pi / 3))) % d) % d\n    s2 *= var\n    s3 = (n2 - round(2 * cos((n - 1) * pi / 3))) % d * ((m2 - round(2 * cos((m - 1) * pi / 3))) % d) % d\n    s3 *= var\n    print(int(round(s1 + s2 + s3) - 1) % d)", "from cmath import pi\nfrom math import cos\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = 10 ** 9 + 7\n    n2 = pow(2, n, d)\n    m2 = pow(2, m, d)\n    var = pow(9, d - 2, d)\n    s1 = (n2 + round(2 * cos(n * pi / 3))) % d * ((m2 + round(2 * cos(m * pi / 3))) % d) % d\n    s1 *= var\n    s2 = (n2 - round(2 * cos((n + 1) * pi / 3))) % d * ((m2 - round(2 * cos((m + 1) * pi / 3))) % d) % d\n    s2 *= var\n    s3 = (n2 - round(2 * cos((n - 1) * pi / 3))) % d * ((m2 - round(2 * cos((m - 1) * pi / 3))) % d) % d\n    s3 *= var\n    print(int(round(s1 + s2 + s3) - 1) % d)", "try:\n    t = int(input())\n    MOD = 1000000007\n    while t:\n        (n, m) = map(int, input().split())\n\n        def power(x, y, Q):\n            res = 1\n            while y > 0:\n                if y & 1 != 0:\n                    res = res * x % Q\n                y = y >> 1\n                x = x * x % Q\n            return res % Q\n        ans = 0\n        if abs(n - m) % 6 == 1 or abs(n - m) % 6 == 5:\n            ans = (power(2, n + m, 3 * MOD) + 1) // 3\n        if abs(n - m) % 6 == 2 or abs(n - m) % 6 == 4:\n            ans = (power(2, n + m, 3 * MOD) - 1) // 3\n        if abs(n - m) % 6 == 3:\n            ans = (power(2, n + m, 3 * MOD) - 2) // 3\n        if abs(n - m) % 6 == 0:\n            ans = (power(2, n + m, 3 * MOD) + 2) // 3\n        print((ans - 1) % MOD)\n        t = t - 1\nexcept:\n    pass", "def pow2(n):\n    ans = 1\n    x = 2\n    mod = 1000000007 * 3\n    while n > 0:\n        if n % 2 != 0:\n            ans = ans * x % mod\n        x = x * x % mod\n        n = n >> 1\n    return ans\n\ndef cos2(n):\n    if n % 6 == 0:\n        return 2\n    elif n % 6 == 1:\n        return 1\n    elif n % 6 == 2:\n        return -1\n    elif n % 6 == 3:\n        return -2\n    elif n % 6 == 4:\n        return -1\n    else:\n        return 1\nt = int(input())\nwhile t > 0:\n    (n, m) = [int(i) for i in input().split()]\n    n2 = pow2(n)\n    m2 = pow2(m)\n    ans = (n2 + cos2(n)) // 3 * ((m2 + cos2(m)) // 3) + (n2 + cos2(n + 2)) // 3 * ((m2 + cos2(m + 2)) // 3) + (n2 + cos2(n + 4)) // 3 * ((m2 + cos2(m + 4)) // 3) - 1\n    ans = ans % 1000000007\n    print(ans)\n    t -= 1", "MOD = 10 ** 9 + 7\nINV3 = 333333336\n\ndef modpow(base, exp, mod):\n    result = 1\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef main(N, M):\n    return (modpow(2, N + M, MOD) - [1, 2, 4, 5, 4, 2][(M - N) % 6]) * INV3 % MOD\nT = int(input().strip())\nfor _ in range(T):\n    (N, M) = [int(x) for x in input().strip().split()[:2]]\n    (N, M) = (min(N, M), max(N, M))\n    print(main(N, M))", "import math\n\ndef quick_poly(n):\n    type = [[1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1]]\n    mod = 1000000007\n    sum_p = pow(2, n, 3 * mod)\n    base = int((sum_p - sum_p % 3) / 3)\n    array = type[n % 6]\n    array[0] = int((array[0] + base) % mod)\n    array[1] = int((array[1] + base) % mod)\n    array[2] = int((array[2] + base) % mod)\n    return array\n\ndef count(n, m):\n    mod = 10 ** 9 + 7\n    nside = quick_poly(n)\n    mside = quick_poly(m)\n    count = 0\n    count = nside[0] * mside[0] % mod + nside[1] * mside[1] % mod + nside[2] * mside[2] % mod\n    return (count - 1) % mod\nn = int(input())\nfor _ in range(0, n):\n    array = list(map(int, input().split()))\n    print(count(array[0], array[1]))", "import math\n\ndef power(x, y, p):\n    ans = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            ans = ans * x % p\n        y = y >> 1\n        x = x * x % p\n    return ans\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    divide = 10 ** 9 + 7\n    a = power(2, n, divide)\n    b = power(2, m, divide)\n    n1 = (a + round(2 * math.cos(n * math.pi / 3))) % divide\n    n2 = (a - round(2 * math.cos((n - 1) * math.pi / 3))) % divide\n    n3 = (a - round(2 * math.cos((n + 1) * math.pi / 3))) % divide\n    m1 = (b + round(2 * math.cos(m * math.pi / 3))) % divide\n    m2 = (b - round(2 * math.cos((m - 1) * math.pi / 3))) % divide\n    m3 = (b - round(2 * math.cos((m + 1) * math.pi / 3))) % divide\n    x = (n1 * m1 + n2 * m2 + n3 * m3) % divide\n    y = x * power(9, divide - 2, divide)\n    z = y - 1\n    ans = z % divide\n    print(ans)", "import math\n\ndef power(x, y, p):\n    ans = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            ans = ans * x % p\n        y = y >> 1\n        x = x * x % p\n    return ans\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    divide = 10 ** 9 + 7\n    a = power(2, n, divide)\n    b = power(2, m, divide)\n    n1 = (a + round(2 * math.cos(n * math.pi / 3))) % divide\n    n2 = (a - round(2 * math.cos((n - 1) * math.pi / 3))) % divide\n    n3 = (a - round(2 * math.cos((n + 1) * math.pi / 3))) % divide\n    m1 = (b + round(2 * math.cos(m * math.pi / 3))) % divide\n    m2 = (b - round(2 * math.cos((m - 1) * math.pi / 3))) % divide\n    m3 = (b - round(2 * math.cos((m + 1) * math.pi / 3))) % divide\n    x = (n1 * m1 + n2 * m2 + n3 * m3) % divide\n    y = x * power(9, divide - 2, divide)\n    z = y - 1\n    ans = z % divide\n    print(ans)", "import math\n\ndef power(x, y, p):\n    ans = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            ans = ans * x % p\n        y = y >> 1\n        x = x * x % p\n    return ans\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    divide = 10 ** 9 + 7\n    a = power(2, n, divide)\n    b = power(2, m, divide)\n    if n % 6 == 0:\n        n1 = a + 2\n        n2 = a - 1\n        n3 = a - 1\n    elif n % 6 == 1:\n        n1 = a + 1\n        n2 = a - 2\n        n3 = a + 1\n    elif n % 6 == 2:\n        n1 = a - 1\n        n2 = a - 1\n        n3 = a + 2\n    elif n % 6 == 3:\n        n1 = a - 2\n        n2 = a + 1\n        n3 = a + 1\n    elif n % 6 == 4:\n        n1 = a - 1\n        n2 = a + 2\n        n3 = a - 1\n    elif n % 6 == 5:\n        n1 = a + 1\n        n2 = a + 1\n        n3 = a - 2\n    if m % 6 == 0:\n        m1 = b + 2\n        m2 = b - 1\n        m3 = b - 1\n    elif m % 6 == 1:\n        m1 = b + 1\n        m2 = b - 2\n        m3 = b + 1\n    elif m % 6 == 2:\n        m1 = b - 1\n        m2 = b - 1\n        m3 = b + 2\n    elif m % 6 == 3:\n        m1 = b - 2\n        m2 = b + 1\n        m3 = b + 1\n    elif m % 6 == 4:\n        m1 = b - 1\n        m2 = b + 2\n        m3 = b - 1\n    elif m % 6 == 5:\n        m1 = b + 1\n        m2 = b + 1\n        m3 = b - 2\n    x = (n1 * m1 + n2 * m2 + n3 * m3) % divide\n    y = x * power(9, divide - 2, divide)\n    z = y - 1\n    ans = z % divide\n    print(ans)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    n1 = n\n    n2 = m\n    nz = 1\n    mz = 1\n    p1 = 2\n    p2 = 2\n    while n1:\n        if n1 % 2:\n            nz = nz * p1 % 1000000007\n        p1 = p1 * p1 % 1000000007\n        n1 //= 2\n    while n2:\n        if n2 % 2:\n            mz = mz * p2 % 1000000007\n        p2 = p2 * p2 % 1000000007\n        n2 //= 2\n    l = [-1, 1, 2, 1, -1, -2]\n    ans = (l[m % 6] + mz) * 333333336 * ((l[n % 6] + nz) * 333333336) + (l[(m + 4) % 6] + mz) * 333333336 * ((l[(n + 4) % 6] + nz) * 333333336) + (l[(n + 2) % 6] + nz) * 333333336 * ((l[(m + 2) % 6] + mz) * 333333336) - 1\n    print(ans % 1000000007)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    n1 = n\n    n2 = m\n    nz = 1\n    mz = 1\n    p1 = 2\n    p2 = 2\n    while n1:\n        if n1 % 2:\n            nz = nz * p1 % 1000000007\n        p1 = p1 * p1 % 1000000007\n        n1 //= 2\n    while n2:\n        if n2 % 2:\n            mz = mz * p2 % 1000000007\n        p2 = p2 * p2 % 1000000007\n        n2 //= 2\n    l = [-1, 1, 2, 1, -1, -2]\n    ans = (l[m % 6] + mz) * 333333336 * ((l[n % 6] + nz) * 333333336) + (l[(m + 4) % 6] + mz) * 333333336 * ((l[(n + 4) % 6] + nz) * 333333336) + (l[(n + 2) % 6] + nz) * 333333336 * ((l[(m + 2) % 6] + mz) * 333333336) - 1\n    print(ans % 1000000007)", "inf = 1000000007\n\ndef an(n, a):\n    z = 1\n    while n:\n        if n % 2:\n            z = z * a % inf\n        a = a * a % inf\n        n //= 2\n    return z\nl1 = [2, 1, -1, -2, -1, 1]\n\ndef i0(n, a):\n    return (l1[n % 6] + a) * 333333336 % inf\n\ndef i1(n, a):\n    m = n % 6 + 4\n    return (l1[m % 6] + a) * 333333336 % inf\n\ndef i2(n, a):\n    m = n % 6 + 2\n    return (l1[m % 6] + a) * 333333336 % inf\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = an(n, 2)\n    b = an(m, 2)\n    print((i0(n, a) * i0(m, b) + i1(n, a) * i1(m, b) + i2(n, a) * i2(m, b) - 1) % inf)", "T = int(input())\nB = 3 * (pow(10, 9) + 7)\nfor i in range(T):\n    I = input().split()\n    (N, M) = tuple([int(j) for j in I])\n    if (N - M) % 3 == 0:\n        if (N + M) % 2 == 0:\n            print((pow(2, N + M, B) + 2) // 3 - 1)\n        else:\n            print((pow(2, N + M, B) - 2) % B // 3 - 1)\n    elif (N + M) % 2 == 0:\n        print((pow(2, N + M, B) - 1) // 3 - 1)\n    else:\n        print((pow(2, N + M, B) + 1) // 3 - 1)", "inf = 1000000007\n\ndef an(n, a):\n    z = 1\n    while n:\n        if n % 2:\n            z = z * a % inf\n        a = a * a % inf\n        n //= 2\n    return z\nl1 = [2, 1, -1, -2, -1, 1]\n\ndef i0(n, a):\n    return (l1[n % 6] + a) * 333333336 % inf\n\ndef i1(n, a):\n    m = n % 6 + 4\n    if m < 6:\n        return (l1[m % 6] + a) * 333333336 % inf\n    else:\n        return (l1[(m - 6) % 6] + a) * 333333336 % inf\n\ndef i2(n, a):\n    m = n % 6 + 2\n    if m < 6:\n        return (l1[m % 6] + a) * 333333336 % inf\n    else:\n        return (l1[(m - 6) % 6] + a) * 333333336 % inf\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = an(n, 2)\n    b = an(m, 2)\n    print((i0(n, a) * i0(m, b) + i1(n, a) * i1(m, b) + i2(n, a) * i2(m, b) - 1) % inf)", "for _ in range(int(input())):\n    (sa, me) = list(map(int, input().split()))\n    (er, hi) = [[[2, 1, -1, -2, -1, 1][sa % 6] + pow(2, sa, 1000000007), [-1, 1, 2, 1, -1, -2][sa % 6] + pow(2, sa, 1000000007), [-1, -2, -1, 1, 2, 1][sa % 6] + pow(2, sa, 1000000007)], [[2, 1, -1, -2, -1, 1][me % 6] + pow(2, me, 1000000007), [-1, 1, 2, 1, -1, -2][me % 6] + pow(2, me, 1000000007), [-1, -2, -1, 1, 2, 1][me % 6] + pow(2, me, 1000000007)]]\n    print(((er[0] * hi[0] + er[1] * hi[1] + er[2] * hi[2]) * 111111112 + 1000000006) % 1000000007)", "mod = int(1000000000.0 + 7)\n\ndef newIdentity(n):\n    m = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n    return m\ntemp = newIdentity(3)\n\ndef matmul(c, a, b):\n    for i in range(3):\n        for j in range(3):\n            temp[i][j] = 0\n            for k in range(3):\n                temp[i][j] += a[i][k] * b[k][j]\n            temp[i][j] %= mod\n    for i in range(3):\n        for j in range(3):\n            c[i][j] = temp[i][j]\n\ndef power(x, y):\n    a = newIdentity(3)\n    while y:\n        if y & 1:\n            matmul(a, a, x)\n        matmul(x, x, x)\n        y >>= 1\n    return a\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    print((power([[0 if i == j else 1 for j in range(3)] for i in range(3)], n + m)[0][(n + m + m) % 3] - 1) % mod)", "def power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nt = int(input())\nrem = 1000000007\ninv = power(3, rem - 2, rem)\nfor _ in range(t):\n    (t, z) = map(int, input().split())\n    if t % 3 == 0:\n        tval0 = 2\n        tval1 = -1\n        tval2 = -1\n    elif t % 3 == 1:\n        tval0 = -1\n        tval1 = -1\n        tval2 = 2\n    else:\n        tval0 = -1\n        tval1 = 2\n        tval2 = -1\n    if z % 3 == 0:\n        zval0 = 2\n        zval1 = -1\n        zval2 = -1\n    elif z % 3 == 1:\n        zval0 = -1\n        zval1 = -1\n        zval2 = 2\n    else:\n        zval0 = -1\n        zval1 = 2\n        zval2 = -1\n    if t % 2 == 1:\n        tval0 *= -1\n        tval1 *= -1\n        tval2 *= -1\n    if z % 2 == 1:\n        zval0 *= -1\n        zval1 *= -1\n        zval2 *= -1\n    p1 = power(2, t, rem)\n    p2 = power(2, z, rem)\n    t1 = (p1 + tval1) * inv % rem\n    t2 = (p1 + tval2) * inv % rem\n    t0 = (p1 + tval0) * inv % rem\n    z0 = (p2 + zval0) * inv % rem\n    z1 = (p2 + zval1) * inv % rem\n    z2 = (p2 + zval2) * inv % rem\n    a = t0 * z0\n    b = t1 * z1\n    c = t2 * z2\n    print((a + b + c - 1) % rem)", "def power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nt = int(input())\nrem = 1000000007\ninv = power(3, rem - 2, rem)\nfor _ in range(t):\n    (t, z) = map(int, input().split())\n    if t % 3 == 0:\n        tval0 = 2\n        tval1 = -1\n        tval2 = -1\n    elif t % 3 == 1:\n        tval0 = -1\n        tval1 = -1\n        tval2 = 2\n    else:\n        tval0 = -1\n        tval1 = 2\n        tval2 = -1\n    if z % 3 == 0:\n        zval0 = 2\n        zval1 = -1\n        zval2 = -1\n    elif z % 3 == 1:\n        zval0 = -1\n        zval1 = -1\n        zval2 = 2\n    else:\n        zval0 = -1\n        zval1 = 2\n        zval2 = -1\n    if t % 2 == 1:\n        tval0 *= -1\n        tval1 *= -1\n        tval2 *= -1\n    if z % 2 == 1:\n        zval0 *= -1\n        zval1 *= -1\n        zval2 *= -1\n    p1 = power(2, t, rem)\n    p2 = power(2, z, rem)\n    t1 = (p1 + tval1) * inv % rem\n    t2 = (p1 + tval2) * inv % rem\n    t0 = (p1 + tval0) * inv % rem\n    z0 = (p2 + zval0) * inv % rem\n    z1 = (p2 + zval1) * inv % rem\n    z2 = (p2 + zval2) * inv % rem\n    a = t0 * z0\n    b = t1 * z1\n    c = t2 * z2\n    print((a + b + c - 1) % rem)", "from itertools import product\ndiff = [2, 1, -1, -2, -1, 1]\noutput = []\ninverse_3 = pow(3, -1, 10 ** 9 + 7)\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split(' '))\n    output.append((pow(2, N + M, 10 ** 9 + 7) + diff[(N - M) % 6]) * inverse_3 % (10 ** 9 + 7) - 1)\nprint('\\n'.join(map(str, output)))", "for _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    (a, b) = [[[2, 1, -1, -2, -1, 1][n % 6] + pow(2, n, 1000000007), [-1, 1, 2, 1, -1, -2][n % 6] + pow(2, n, 1000000007), [-1, -2, -1, 1, 2, 1][n % 6] + pow(2, n, 1000000007)], [[2, 1, -1, -2, -1, 1][m % 6] + pow(2, m, 1000000007), [-1, 1, 2, 1, -1, -2][m % 6] + pow(2, m, 1000000007), [-1, -2, -1, 1, 2, 1][m % 6] + pow(2, m, 1000000007)]]\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) * 111111112 + 1000000006) % 1000000007)", "for p in range(int(input())):\n    (q, r) = list(map(int, input().split()))\n    (g, h) = [[[2, 1, -1, -2, -1, 1][q % 6] + pow(2, q, 1000000007), [-1, 1, 2, 1, -1, -2][q % 6] + pow(2, q, 1000000007), [-1, -2, -1, 1, 2, 1][q % 6] + pow(2, q, 1000000007)], [[2, 1, -1, -2, -1, 1][r % 6] + pow(2, r, 1000000007), [-1, 1, 2, 1, -1, -2][r % 6] + pow(2, r, 1000000007), [-1, -2, -1, 1, 2, 1][r % 6] + pow(2, r, 1000000007)]]\n    print(((g[0] * h[0] + g[1] * h[1] + g[2] * h[2]) * 111111112 + 1000000006) % 1000000007)", "for _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    (a, b) = [[[2, 1, -1, -2, -1, 1][n % 6] + pow(2, n, 1000000007), [-1, 1, 2, 1, -1, -2][n % 6] + pow(2, n, 1000000007), [-1, -2, -1, 1, 2, 1][n % 6] + pow(2, n, 1000000007)], [[2, 1, -1, -2, -1, 1][m % 6] + pow(2, m, 1000000007), [-1, 1, 2, 1, -1, -2][m % 6] + pow(2, m, 1000000007), [-1, -2, -1, 1, 2, 1][m % 6] + pow(2, m, 1000000007)]]\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) * 111111112 + 1000000006) % 1000000007)", "for _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    (a, b) = [[[2, 1, -1, -2, -1, 1][n % 6] + pow(2, n, 1000000007), [-1, 1, 2, 1, -1, -2][n % 6] + pow(2, n, 1000000007), [-1, -2, -1, 1, 2, 1][n % 6] + pow(2, n, 1000000007)], [[2, 1, -1, -2, -1, 1][m % 6] + pow(2, m, 1000000007), [-1, 1, 2, 1, -1, -2][m % 6] + pow(2, m, 1000000007), [-1, -2, -1, 1, 2, 1][m % 6] + pow(2, m, 1000000007)]]\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) * 111111112 + 1000000006) % 1000000007)", "for _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    (a, b) = [[[2, 1, -1, -2, -1, 1][n % 6] + pow(2, n, 1000000007), [-1, 1, 2, 1, -1, -2][n % 6] + pow(2, n, 1000000007), [-1, -2, -1, 1, 2, 1][n % 6] + pow(2, n, 1000000007)], [[2, 1, -1, -2, -1, 1][m % 6] + pow(2, m, 1000000007), [-1, 1, 2, 1, -1, -2][m % 6] + pow(2, m, 1000000007), [-1, -2, -1, 1, 2, 1][m % 6] + pow(2, m, 1000000007)]]\n    print(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) * 111111112 + 1000000006) % 1000000007)", "T = int(input())\np = int(1000000000.0 + 7)\nfor i in range(T):\n    s = input()\n    a = s.split()\n    (N, M) = (int(a[0]), int(a[1]))\n    (a, b) = (pow(2, N, 3 * p), pow(2, M, 3 * p))\n    (x, y) = ((-1) ** N, (-1) ** M)\n    if M % 3 == N % 3:\n        print(((a * b + 2 * x * y) // 3 - 1) % p)\n    else:\n        print(((a * b - x * y) // 3 - 1) % p)", "def cos6(n):\n    if n % 6 == 0:\n        return 2\n    if n % 6 == 1:\n        return 1\n    if n % 6 == 2:\n        return -1\n    if n % 6 == 3:\n        return -2\n    if n % 6 == 4:\n        return -1\n    if n % 6 == 5:\n        return 1\nmod = 1000000007\ninv3 = 333333336\n\ndef b3(n, f):\n    return (pow(2, n, mod) + cos6(n + f)) * inv3 % mod\nfor _ in range(int(input())):\n    (n, m) = map(int, input().strip().split())\n    print((b3(m, 0) * b3(n, 0) + b3(n, 2) * b3(m, 2) + b3(n, -2) * b3(m, -2) - 1) % mod)", "t = int(input())\ns = [1, 2, 4, 5, 4, 2]\nk = 1000000007\nfor i in range(t):\n    (n, m) = [int(a) for a in input().split()]\n    num = (pow(2, m + n, k) - s[(m - n) % 6]) * 333333336 % k\n    print(num)", "s = [1, 2, 1, 2, 1, 2]\nmod = 10 ** 9 + 7\ns1 = [[1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 1], [1, 0, 1]]\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\ndef add(a, b):\n    return [a[0] + b[0], a[1] + b[1], a[2] + b[2]]\n\ndef gen(n):\n    if n % 2 == 0:\n        x = 1\n    else:\n        x = 2\n    num = pow(2, n, mod) - x\n    num = num * inv(3)\n    num = num % mod\n    l = [num, num, num]\n    return add(l, s1[n % 6])\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    l1 = gen(n)\n    l2 = gen(m)\n    ans = l1[0] * l2[0] + l1[1] * l2[1] + l1[2] * l2[2]\n    ans = ans % mod\n    ans = ans - 1\n    print(ans % mod)"]