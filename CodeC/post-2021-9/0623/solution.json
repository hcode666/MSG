["from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    ans = float('inf')\n    (o, c, ind) = (0, 0, 0)\n    for i in range(n):\n        req = o - c + 1\n        while dist[-1] < i + 1:\n            dist.pop()\n            ind += 1\n        if n // 2 - ind < req:\n            break\n        cal = prefix[ind + req] - prefix[ind] - req * i - req * (req + 1) // 2\n        ans = min(ans, cal)\n        if a[i] == '(':\n            o += 1\n        else:\n            c += 1\n    return ans\nfor T in range(int(input())):\n    a = input().strip()\n    n = len(a)\n    dist = []\n    for i in range(n):\n        if a[i] == ')':\n            dist.append(i + 1)\n    prefix = [0]\n    for i in range(len(dist)):\n        prefix.append(prefix[-1] + dist[i])\n    dist = dist[::-1]\n    print(answer())", "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    ans = float('inf')\n    (o, c, ind) = (0, 0, 0)\n    for i in range(n):\n        req = o - c + 1\n        while dist[-1] < i + 1:\n            dist.pop()\n            ind += 1\n        if n // 2 - ind < req:\n            break\n        cal = prefix[ind + req] - prefix[ind] - req * i - req * (req + 1) // 2\n        ans = min(ans, cal)\n        if a[i] == '(':\n            o += 1\n        else:\n            c += 1\n    return ans\nfor T in range(int(input())):\n    a = input().strip()\n    n = len(a)\n    dist = []\n    for i in range(n):\n        if a[i] == ')':\n            dist.append(i + 1)\n    prefix = [0]\n    for i in range(len(dist)):\n        prefix.append(prefix[-1] + dist[i])\n    dist = dist[::-1]\n    print(answer())", "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    ans = float('inf')\n    (o, c, ind) = (0, 0, 0)\n    for i in range(n):\n        req = o - c + 1\n        while dist[-1] < i + 1:\n            dist.pop()\n            ind += 1\n        if n // 2 - ind < req:\n            break\n        cal = prefix[ind + req] - prefix[ind] - req * i - req * (req + 1) // 2\n        ans = min(ans, cal)\n        if a[i] == '(':\n            o += 1\n        else:\n            c += 1\n    return ans\nfor T in range(int(input())):\n    a = input().strip()\n    n = len(a)\n    dist = []\n    for i in range(n):\n        if a[i] == ')':\n            dist.append(i + 1)\n    prefix = [0]\n    for i in range(len(dist)):\n        prefix.append(prefix[-1] + dist[i])\n    dist = dist[::-1]\n    print(answer())", "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    ans = float('inf')\n    (o, c, ind) = (0, 0, 0)\n    for i in range(n):\n        req = o - c + 1\n        while dist[-1] < i + 1:\n            dist.pop()\n            ind += 1\n        if n // 2 - ind < req:\n            break\n        cal = prefix[ind + req] - prefix[ind] - req * i - req * (req + 1) // 2\n        ans = min(ans, cal)\n        if a[i] == '(':\n            o += 1\n        else:\n            c += 1\n    return ans\nfor T in range(int(input())):\n    a = input().strip()\n    n = len(a)\n    dist = []\n    for i in range(n):\n        if a[i] == ')':\n            dist.append(i + 1)\n    prefix = [0]\n    for i in range(len(dist)):\n        prefix.append(prefix[-1] + dist[i])\n    dist = dist[::-1]\n    print(answer())", "for _ in range(int(input())):\n    s = input()\n    l = len(s)\n    pos = [0]\n    for i in range(l):\n        if s[i] == ')':\n            pos.append(pos[-1] + i)\n    ans = 10000007\n    (o, c) = (0, 0)\n    for i in range(l):\n        if s[i] == '(':\n            o += 1\n            t = o - c\n            try:\n                temp = pos[o] - pos[c] - i * t - t * (t - 1) // 2\n                ans = min(ans, temp)\n            except:\n                break\n        else:\n            c += 1\n    print(ans)", "t = int(input())\nfor tc in range(t):\n    s = input()\n    positions = [0]\n    l = len(s)\n    for i in range(l):\n        if s[i] == ')':\n            positions.append(positions[-1] + i)\n    ans = 1000000007\n    (o, c) = (0, 0)\n    for i in range(l):\n        if s[i] == '(':\n            o += 1\n            x = o - c\n            try:\n                tmp = positions[o] - positions[c] - i * x - x * (x - 1) // 2\n                ans = min(ans, tmp)\n            except:\n                break\n        else:\n            c += 1\n    print(ans)", "for _ in range(int(input())):\n    s = input()\n    n = len(s)\n    l = [0 for _x in range(n)]\n    l[0] = 1\n    for i in range(1, n):\n        if s[i] == '(':\n            l[i] = l[i - 1] + 1\n        else:\n            l[i] = l[i - 1] - 1\n    temp = [0]\n    ans = float('inf')\n    for i in range(n - 1, -1, -1):\n        if len(temp) > l[i] + 1:\n            t = temp[-1] - temp[-1 * l[i] - 2] - (l[i] + 1) * (l[i] + 2) // 2 - i * (l[i] + 1)\n            ans = min(ans, t)\n        if s[i] == ')':\n            temp.append(temp[-1] + i)\n    ans = min(ans, temp[-1] - temp[-2])\n    print(ans)", "for _ in range(int(input())):\n    s = input()\n    n = len(s)\n    l = [0 for _ in range(n)]\n    l[0] = 1\n    for i in range(1, n):\n        if s[i] == '(':\n            l[i] = l[i - 1] + 1\n        else:\n            l[i] = l[i - 1] - 1\n    temp = [0]\n    ans = float('inf')\n    for i in range(n - 1, -1, -1):\n        if len(temp) > l[i] + 1:\n            t = temp[-1] - temp[-1 * l[i] - 2] - (l[i] + 1) * (l[i] + 2) // 2 - i * (l[i] + 1)\n            ans = min(ans, t)\n        if s[i] == ')':\n            temp.append(temp[-1] + i)\n    ans = min(ans, temp[-1] - temp[-2])\n    print(ans)", "for _ in range(int(input())):\n    s = input()\n    n = len(s)\n    l = [0 for _ in range(n)]\n    l[0] = 1\n    for i in range(1, n):\n        if s[i] == '(':\n            l[i] = l[i - 1] + 1\n        else:\n            l[i] = l[i - 1] - 1\n    temp = [0]\n    ans = float('inf')\n    for i in range(n - 1, -1, -1):\n        if len(temp) > l[i] + 1:\n            t = temp[-1] - temp[-1 * l[i] - 2] - (l[i] + 1) * (l[i] + 2) // 2 - i * (l[i] + 1)\n            ans = min(ans, t)\n        if s[i] == ')':\n            temp.append(temp[-1] + i)\n    ans = min(ans, temp[-1] - temp[-2])\n    print(ans)", "for _ in range(int(input())):\n    s = input().strip()\n    n = len(s)\n    a = [0]\n    for i in range(n):\n        if s[i] == ')':\n            a.append(a[-1] + i)\n    op = 0\n    cl = 0\n    mini = a[1]\n    for i in range(n):\n        if s[i] == '(':\n            op += 1\n            if op >= len(a):\n                break\n            ans = a[op] - a[cl] - i * (op - cl) - (op - cl) * (op - cl - 1) // 2\n            mini = min(mini, ans)\n        else:\n            cl += 1\n    print(mini)", "tt = 1\ntt = int(input())\nfor _ in range(tt):\n    s = input()\n    n = len(s)\n    end = []\n    prefix = [0]\n    ans = n // 2\n    for (i, ch) in enumerate(s):\n        if ch == '(':\n            ans = min(ans, n - i - 1)\n        else:\n            end.append(i)\n            ans = min(ans, i)\n            prefix.append(prefix[-1] + i)\n    end.append(n)\n    current = 0\n    index = 1\n    m = len(end) - 1\n    for (i, ch) in enumerate(s):\n        if ch == '(':\n            current += 1\n        else:\n            current -= 1\n        if end[index] == i:\n            index += 1\n        if index + current < m:\n            d = prefix[index + current + 1] - prefix[index]\n            d -= ((i + current + 1) * (i + current + 2) - i * (i + 1)) // 2\n            ans = min(ans, d)\n    print(ans)", "def divisors(M):\n    d = []\n    i = 1\n    while M >= i ** 2:\n        if M % i == 0:\n            d.append(i)\n            if i ** 2 != M:\n                d.append(M // i)\n        i = i + 1\n    return d\n\ndef popcount(x):\n    x = x - (x >> 1 & 1431655765)\n    x = (x & 858993459) + (x >> 2 & 858993459)\n    x = x + (x >> 4) & 252645135\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    return x & 127\n\ndef eratosthenes(n):\n    res = [0 for i in range(n + 1)]\n    prime = set([])\n    for i in range(2, n + 1):\n        if not res[i]:\n            prime.add(i)\n            for j in range(1, n // i + 1):\n                res[i * j] = 1\n    return prime\n\ndef factorization(n):\n    res = []\n    for p in prime:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            res.append(p)\n    if n != 1:\n        res.append(n)\n    return res\n\ndef euler_phi(n):\n    res = n\n    for x in range(2, n + 1):\n        if x ** 2 > n:\n            break\n        if n % x == 0:\n            res = res // x * (x - 1)\n            while n % x == 0:\n                n //= x\n    if n != 1:\n        res = res // n * (n - 1)\n    return res\n\ndef ind(b, n):\n    res = 0\n    while n % b == 0:\n        res += 1\n        n //= b\n    return res\n\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 3, 5, 7, 11, 13, 17]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1:\n            continue\n        while y != n - 1:\n            y = y * y % n\n            if y == 1 or t == n - 1:\n                return 0\n            t <<= 1\n    return 1\n\ndef findFactorRho(n):\n    from math import gcd\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        (y, r, q, g) = (2, 1, 1, 1)\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g):\n                return g\n            elif isPrimeMR(n // g):\n                return n // g\n            return findFactorRho(g)\n\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i * i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k:\n            ret[i] = k\n        i += 1 + i % 2\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    (ret[n], n) = (1, 1)\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n    if n > 1:\n        ret[n] = 1\n    if rhoFlg:\n        ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(n):\n    res = [1]\n    prime = primeFactor(n)\n    for p in prime:\n        newres = []\n        for d in res:\n            for j in range(prime[p] + 1):\n                newres.append(d * p ** j)\n        res = newres\n    res.sort()\n    return res\n\ndef xorfactorial(num):\n    if num == 0:\n        return 0\n    elif num == 1:\n        return 1\n    elif num == 2:\n        return 3\n    elif num == 3:\n        return 0\n    else:\n        x = baseorder(num)\n        return 2 ** x * ((num - 2 ** x + 1) % 2) + function(num - 2 ** x)\n\ndef xorconv(n, X, Y):\n    if n == 0:\n        res = [X[0] * Y[0] % mod]\n        return res\n    x = [X[i] + X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n    y = [Y[i] + Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n    z = [X[i] - X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n    w = [Y[i] - Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n    res1 = xorconv(n - 1, x, y)\n    res2 = xorconv(n - 1, z, w)\n    former = [(res1[i] + res2[i]) * inv for i in range(2 ** (n - 1))]\n    latter = [(res1[i] - res2[i]) * inv for i in range(2 ** (n - 1))]\n    former = list(map(lambda x: x % mod, former))\n    latter = list(map(lambda x: x % mod, latter))\n    return former + latter\n\ndef merge_sort(A, B):\n    (pos_A, pos_B) = (0, 0)\n    (n, m) = (len(A), len(B))\n    res = []\n    while pos_A < n and pos_B < m:\n        (a, b) = (A[pos_A], B[pos_B])\n        if a < b:\n            res.append(a)\n            pos_A += 1\n        else:\n            res.append(b)\n            pos_B += 1\n    res += A[pos_A:]\n    res += B[pos_B:]\n    return res\n\nclass UnionFindVerSize:\n\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x:\n            return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]] != stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy:\n            return\n        self.group -= 1\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind:\n\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n        self.val = [0 for i in range(N)]\n        self.flag = True\n        self.edge = [[] for i in range(N)]\n\n    def dfs(self, v, pv):\n        stack = [(v, pv)]\n        new_parent = self.parent[pv]\n        while stack:\n            (v, pv) = stack.pop()\n            self.parent[v] = new_parent\n            for (nv, w) in self.edge[v]:\n                if nv != pv:\n                    self.val[nv] = self.val[v] + w\n                    stack.append((nv, v))\n\n    def unite(self, x, y, w):\n        if not self.flag:\n            return\n        if self.parent[x] == self.parent[y]:\n            self.flag = self.val[x] - self.val[y] == w\n            return\n        if self.size[self.parent[x]] > self.size[self.parent[y]]:\n            self.edge[x].append((y, -w))\n            self.edge[y].append((x, w))\n            self.size[x] += self.size[y]\n            self.val[y] = self.val[x] - w\n            self.dfs(y, x)\n        else:\n            self.edge[x].append((y, -w))\n            self.edge[y].append((x, w))\n            self.size[y] += self.size[x]\n            self.val[x] = self.val[y] + w\n            self.dfs(x, y)\n\nclass Dijkstra:\n\n    class Edge:\n\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        self.G = [[] for i in range(V)]\n        self._E = 0\n        self._V = V\n\n    @property\n    def E(self):\n        return self._E\n\n    @property\n    def V(self):\n        return self._V\n\n    def add_edge(self, _from, _to, _cost):\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        import heapq\n        que = []\n        d = [10 ** 15] * self.V\n        d[s] = 0\n        heapq.heappush(que, (0, s))\n        while len(que) != 0:\n            (cost, v) = heapq.heappop(que)\n            if d[v] < cost:\n                continue\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost\n                    heapq.heappush(que, (d[e.to], e.to))\n        return d\n\ndef Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0] * N\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i + j < N and s[j] == s[i + j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i + k < N and k + Z_alg[k] < j:\n            Z_alg[i + k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nclass BIT:\n\n    def __init__(self, n, mod=0):\n        self.BIT = [0] * (n + 1)\n        self.num = n\n        self.mod = mod\n\n    def query(self, idx):\n        res_sum = 0\n        mod = self.mod\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            if mod:\n                res_sum %= mod\n            idx -= idx & -idx\n        return res_sum\n\n    def update(self, idx, x):\n        mod = self.mod\n        while idx <= self.num:\n            self.BIT[idx] += x\n            if mod:\n                self.BIT[idx] %= mod\n            idx += idx & -idx\n        return\n\nclass dancinglink:\n\n    def __init__(self, n, debug=False):\n        self.n = n\n        self.debug = debug\n        self._left = [i - 1 for i in range(n)]\n        self._right = [i + 1 for i in range(n)]\n        self.exist = [True for i in range(n)]\n\n    def pop(self, k):\n        if self.debug:\n            assert self.exist[k]\n        L = self._left[k]\n        R = self._right[k]\n        if L != -1:\n            if R != self.n:\n                (self._right[L], self._left[R]) = (R, L)\n            else:\n                self._right[L] = self.n\n        elif R != self.n:\n            self._left[R] = -1\n        self.exist[k] = False\n\n    def left(self, idx, k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._left[res]\n            if res == -1:\n                break\n            k -= 1\n        return res\n\n    def right(self, idx, k=1):\n        if self.debug:\n            assert self.exist[idx]\n        res = idx\n        while k:\n            res = self._right[res]\n            if res == self.n:\n                break\n            k -= 1\n        return res\n\nclass SparseTable:\n\n    def __init__(self, A, merge_func, ide_ele):\n        N = len(A)\n        self.merge_func = merge_func\n        self.lg = [0] * (N + 1)\n        for i in range(2, N + 1):\n            self.lg[i] = self.lg[i >> 1] + 1\n        self.pow_2 = [pow(2, i) for i in range(20)]\n        self.table = [None] * (self.lg[N] + 1)\n        st0 = self.table[0] = [a for a in A]\n        b = 1\n        for i in range(self.lg[N]):\n            st0 = self.table[i + 1] = [self.merge_func(u, v) for (u, v) in zip(st0, st0[b:])]\n            b <<= 1\n\n    def query(self, s, t):\n        b = t - s + 1\n        m = self.lg[b]\n        return self.merge_func(self.table[m][s], self.table[m][t - self.pow_2[m] + 1])\n\nclass BinaryTrie:\n\n    class node:\n\n        def __init__(self, val):\n            self.left = None\n            self.right = None\n            self.max = val\n\n    def __init__(self):\n        self.root = self.node(-10 ** 15)\n\n    def append(self, key, val):\n        pos = self.root\n        for i in range(29, -1, -1):\n            pos.max = max(pos.max, val)\n            if key >> i & 1:\n                if pos.right is None:\n                    pos.right = self.node(val)\n                    pos = pos.right\n                else:\n                    pos = pos.right\n            elif pos.left is None:\n                pos.left = self.node(val)\n                pos = pos.left\n            else:\n                pos = pos.left\n        pos.max = max(pos.max, val)\n\n    def search(self, M, xor):\n        res = -10 ** 15\n        pos = self.root\n        for i in range(29, -1, -1):\n            if pos is None:\n                break\n            if M >> i & 1:\n                if xor >> i & 1:\n                    if pos.right:\n                        res = max(res, pos.right.max)\n                    pos = pos.left\n                else:\n                    if pos.left:\n                        res = max(res, pos.left.max)\n                    pos = pos.right\n            elif xor >> i & 1:\n                pos = pos.right\n            else:\n                pos = pos.left\n        if pos:\n            res = max(res, pos.max)\n        return res\n\ndef solveequation(edge, ans, n, m):\n\n    def dfs(v):\n        used[v] = True\n        r = ans[v]\n        for (to, dire, id) in edge[v]:\n            if used[to]:\n                continue\n            y = dfs(to)\n            if dire == -1:\n                x[id] = y\n            else:\n                x[id] = -y\n            r += y\n        return r\n    x = [0] * m\n    used = [False] * n\n    for v in range(n):\n        if used[v]:\n            continue\n        y = dfs(v)\n        if y != 0:\n            return False\n    return x\n\nclass slope_trick:\n\n    def __init__(self):\n        self.L = [10 ** 17]\n        self.R = [10 ** 17]\n        self.min_f = 0\n        self.x_left = 0\n        self.x_right = 0\n\n    def add_right(self, a):\n        a -= self.x_left\n        l0 = -self.L[0]\n        self.min_f = self.min_f + max(0, l0 - a)\n        if l0 <= a:\n            a += self.x_left\n            a -= self.x_right\n            heappush(self.R, a)\n        else:\n            heappush(self.L, -a)\n            a = -heappop(self.L)\n            a += self.x_left\n            a -= self.x_right\n            heappush(self.R, a)\n\n    def add_left(self, a):\n        a -= self.x_right\n        r0 = self.R[0]\n        self.min_f = self.min_f + max(0, a - r0)\n        if a <= r0:\n            a += self.x_right\n            a -= self.x_left\n            heappush(self.L, -a)\n        else:\n            heappush(self.R, a)\n            a = heappop(self.R)\n            a += self.x_right\n            a -= self.x_left\n            heappush(self.L, -a)\n\n    def add_abs(self, a):\n        self.add_left(a)\n        self.add_right(a)\n\n    def change_min_slide(self, a, b):\n        self.x_left += a\n        self.x_right += b\n\n    def get_val(self, x):\n        L = [-l + self.x_left for l in self.L]\n        L.sort()\n        R = [r + self.x_right for r in self.R]\n        R.sort()\n        res = self.min_f\n        if 0 < L[-1]:\n            L = L[::-1]\n            n = len(L)\n            for i in range(n):\n                c0 = L[i]\n                c1 = L[i + 1]\n                if c1 <= x <= c0:\n                    res += (i + 1) * (c0 - x)\n                    break\n                else:\n                    res += (i + 1) * (c0 - c1)\n            return res\n        elif L[-1] <= x <= R[0]:\n            return res\n        else:\n            n = len(R)\n            for i in range(n):\n                c0 = R[i]\n                c1 = R[i + 1]\n                if c0 <= x <= c1:\n                    res += (i + 1) * (x - c0)\n                    break\n                else:\n                    res += (i + 1) * (c1 - c0)\n            return res\n\nclass SegmentTree:\n\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        self.size = n\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            k >>= 1\n            self.tree[k] = self.segfunc(self.tree[2 * k], self.tree[2 * k + 1])\n\n    def query(self, l, r):\n        if r == self.size:\n            r = self.num\n        res = self.ide_ele\n        l += self.num\n        r += self.num\n        right = []\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                right.append(self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        for e in right[::-1]:\n            res = self.segfunc(res, e)\n        return res\n\n    def bisect_l(self, l, r, x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l < r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin == -1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r - 1] <= x:\n                    Rmin = r - 1\n            l >>= 1\n            r >>= 1\n        if Lmin != -1:\n            pos = Lmin\n            while pos < self.num:\n                if self.tree[2 * pos] <= x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos + 1\n            return pos - self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos < self.num:\n                if self.tree[2 * pos] <= x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos + 1\n            return pos - self.num\n        else:\n            return -1\nimport sys, random, bisect\nfrom collections import deque, defaultdict\nfrom heapq import heapify, heappop, heappush\nfrom itertools import permutations\nfrom math import gcd, log\ninput = lambda : sys.stdin.readline().rstrip()\nmi = lambda : map(int, input().split())\nli = lambda : list(mi())\nfor _ in range(int(input())):\n    S = input()\n    N = len(S)\n    imos_left = [0 for i in range(N)]\n    imos_right = [0 for i in range(N)]\n    for i in range(N):\n        if S[i] == '(':\n            imos_left[i] += i\n        else:\n            imos_right[i] += i\n        if i != 0:\n            imos_left[i] += imos_left[i - 1]\n            imos_right[i] += imos_right[i - 1]\n    left = []\n    right = [i for i in range(N) if S[i] == ')'][::-1]\n    res = N * 100\n    s = 0\n    for i in range(N):\n        if S[i] == '(':\n            s += 1\n            left.append(i)\n        else:\n            right.pop()\n            s -= 1\n        need = (s + 2) // 2\n        if min(len(left), len(right)) < need:\n            continue\n        tmp = need * i - (imos_left[left[-1]] - imos_left[left[-need]] + left[-need]) + (imos_right[right[-need]] - imos_right[right[-1]] + right[-1]) - need * (i + 1) + need\n        res = min(res, tmp)\n    print(res)"]