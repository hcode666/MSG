["import sys\nimport random\nfrom collections import defaultdict\n\nclass DefaultDict:\n\n    def __init__(self, default=None):\n        self.default = default\n        self.x = random.randrange(1, 1 << 31)\n        self.dd = defaultdict(default)\n\n    def __repr__(self):\n        return '{' + ', '.join((f'{k ^ self.x}: {v}' for (k, v) in self.dd.items())) + '}'\n\n    def __eq__(self, other):\n        for k in set(self) | set(other):\n            if self[k] != other[k]:\n                return False\n        return True\n\n    def __or__(self, other):\n        res = DefaultDict(self.default)\n        for (k, v) in self.dd:\n            res[k] = v\n        for (k, v) in other.dd:\n            res[k] = v\n        return res\n\n    def __len__(self):\n        return len(self.dd)\n\n    def __getitem__(self, item):\n        return self.dd[item ^ self.x]\n\n    def __setitem__(self, key, value):\n        self.dd[key ^ self.x] = value\n\n    def __delitem__(self, key):\n        del self.dd[key ^ self.x]\n\n    def __contains__(self, item):\n        return item ^ self.x in self.dd\n\n    def items(self):\n        for (k, v) in self.dd.items():\n            yield (k ^ self.x, v)\n\n    def keys(self):\n        for k in self.dd:\n            yield (k ^ self.x)\n\n    def values(self):\n        for v in self.dd.values():\n            yield v\n\n    def __iter__(self):\n        for k in self.dd:\n            yield (k ^ self.x)\n\nclass Counter(DefaultDict):\n\n    def __init__(self, aa=[]):\n        super().__init__(int)\n        for a in aa:\n            self.dd[a ^ self.x] += 1\n\n    def __add__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = self[k] + other[k]\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __sub__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = self[k] - other[k]\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __and__(self, other):\n        res = Counter()\n        for k in self:\n            v = min(self[k], other[k])\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __or__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = max(self[k], other[k])\n            if v > 0:\n                res[k] = v\n        return res\n\nclass Set:\n\n    def __init__(self, aa=[]):\n        self.x = random.randrange(1, 1 << 31)\n        self.st = set()\n        for a in aa:\n            self.st.add(a ^ self.x)\n\n    def __repr__(self):\n        return '{' + ', '.join((str(k ^ self.x) for k in self.st)) + '}'\n\n    def __len__(self):\n        return len(self.st)\n\n    def add(self, item):\n        self.st.add(item ^ self.x)\n\n    def discard(self, item):\n        self.st.discard(item ^ self.x)\n\n    def __contains__(self, item):\n        return item ^ self.x in self.st\n\n    def __iter__(self):\n        for k in self.st:\n            yield (k ^ self.x)\n\n    def pop(self):\n        return self.st.pop() ^ self.x\n\n    def __or__(self, other):\n        res = Set(self)\n        for a in other:\n            res.add(a)\n        return res\n\n    def __and__(self, other):\n        res = Set()\n        for a in self:\n            if a in other:\n                res.add(a)\n        for a in other:\n            if a in self:\n                res.add(a)\n        return res\nint1 = lambda x: int(x) - 1\npDB = lambda *x: print(*x, end='\\n', file=sys.stderr)\np2D = lambda x: print(*x, sep='\\n', end='\\n\\n', file=sys.stderr)\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef LI1():\n    return list(map(int1, sys.stdin.readline().split()))\n\ndef LLI1(rows_number):\n    return [LI1() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline().rstrip()\ndij = [(0, 1), (-1, 0), (0, -1), (1, 0)]\ninf = (1 << 63) - 1\nmd = 10 ** 9 + 7\n\nclass Sieve:\n\n    def __init__(self, n):\n        self.plist = [2]\n        min_prime_factor = [2, 0] * (n // 2 + 1)\n        for x in range(3, n + 1, 2):\n            if min_prime_factor[x] == 0:\n                min_prime_factor[x] = x\n                self.plist.append(x)\n                if x ** 2 > n:\n                    continue\n                for y in range(x ** 2, n + 1, 2 * x):\n                    if min_prime_factor[y] == 0:\n                        min_prime_factor[y] = x\n        self.min_prime_factor = min_prime_factor\n\n    def isprime(self, x):\n        return self.min_prime_factor[x] == x\n\n    def pf(self, x):\n        (pp, ee) = ([], [])\n        while x > 1:\n            mpf = self.min_prime_factor[x]\n            if pp and mpf == pp[-1]:\n                ee[-1] += 1\n            else:\n                pp.append(mpf)\n                ee.append(1)\n            x //= mpf\n        return (pp, ee)\n\n    def factor(self, a):\n        ff = [1]\n        (pp, ee) = self.pf(a)\n        for (p, e) in zip(pp, ee):\n            (ff, gg) = ([], ff)\n            w = p\n            for _ in range(e):\n                for f in gg:\n                    ff.append(f * w)\n                w *= p\n            ff += gg\n        return ff\n\ndef nHr(hn, hr):\n    return nCr(hn + hr - 1, hr - 1)\n\ndef nPr(com_n, com_r):\n    if com_r < 0:\n        return 0\n    if com_n < com_r:\n        return 0\n    return fac[com_n] * ifac[com_n - com_r] % md\n\ndef nCr(com_n, com_r):\n    if com_r < 0:\n        return 0\n    if com_n < com_r:\n        return 0\n    return fac[com_n] * ifac[com_r] % md * ifac[com_n - com_r] % md\nn_max = 100005\nfac = [1]\nfor i in range(1, n_max + 1):\n    fac.append(fac[-1] * i % md)\nifac = [1] * (n_max + 1)\nifac[n_max] = pow(fac[n_max], md - 2, md)\nfor i in range(n_max - 1, 1, -1):\n    ifac[i] = ifac[i + 1] * (i + 1) % md\nsv = Sieve(10 ** 7)\n\ndef solve():\n    n = II()\n    aa = LI()\n    ac = Counter(aa)\n    fc = Counter()\n    ans = 0\n    for (a, c) in ac.items():\n        ans += pow(2, c, md) - 1\n        for f in sv.factor(a):\n            fc[f] += c\n            ans -= nCr(c, f)\n            ans %= md\n    for (f, c) in fc.items():\n        if f == 1:\n            continue\n        ans += nCr(c, f)\n        ans %= md\n    print(ans)\ntestnumber = II()\nfor testcase in range(testnumber):\n    solve()", "import sys\nimport random\nfrom collections import defaultdict\n\nclass DefaultDict:\n\n    def __init__(self, default=None):\n        self.default = default\n        self.x = random.randrange(1, 1 << 31)\n        self.dd = defaultdict(default)\n\n    def __repr__(self):\n        return '{' + ', '.join((f'{k ^ self.x}: {v}' for (k, v) in self.dd.items())) + '}'\n\n    def __eq__(self, other):\n        for k in set(self) | set(other):\n            if self[k] != other[k]:\n                return False\n        return True\n\n    def __or__(self, other):\n        res = DefaultDict(self.default)\n        for (k, v) in self.dd:\n            res[k] = v\n        for (k, v) in other.dd:\n            res[k] = v\n        return res\n\n    def __len__(self):\n        return len(self.dd)\n\n    def __getitem__(self, item):\n        return self.dd[item ^ self.x]\n\n    def __setitem__(self, key, value):\n        self.dd[key ^ self.x] = value\n\n    def __delitem__(self, key):\n        del self.dd[key ^ self.x]\n\n    def __contains__(self, item):\n        return item ^ self.x in self.dd\n\n    def items(self):\n        for (k, v) in self.dd.items():\n            yield (k ^ self.x, v)\n\n    def keys(self):\n        for k in self.dd:\n            yield (k ^ self.x)\n\n    def values(self):\n        for v in self.dd.values():\n            yield v\n\n    def __iter__(self):\n        for k in self.dd:\n            yield (k ^ self.x)\n\nclass Counter(DefaultDict):\n\n    def __init__(self, aa=[]):\n        super().__init__(int)\n        for a in aa:\n            self.dd[a ^ self.x] += 1\n\n    def __add__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = self[k] + other[k]\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __sub__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = self[k] - other[k]\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __and__(self, other):\n        res = Counter()\n        for k in self:\n            v = min(self[k], other[k])\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __or__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = max(self[k], other[k])\n            if v > 0:\n                res[k] = v\n        return res\n\nclass Set:\n\n    def __init__(self, aa=[]):\n        self.x = random.randrange(1, 1 << 31)\n        self.st = set()\n        for a in aa:\n            self.st.add(a ^ self.x)\n\n    def __repr__(self):\n        return '{' + ', '.join((str(k ^ self.x) for k in self.st)) + '}'\n\n    def __len__(self):\n        return len(self.st)\n\n    def add(self, item):\n        self.st.add(item ^ self.x)\n\n    def discard(self, item):\n        self.st.discard(item ^ self.x)\n\n    def __contains__(self, item):\n        return item ^ self.x in self.st\n\n    def __iter__(self):\n        for k in self.st:\n            yield (k ^ self.x)\n\n    def pop(self):\n        return self.st.pop() ^ self.x\n\n    def __or__(self, other):\n        res = Set(self)\n        for a in other:\n            res.add(a)\n        return res\n\n    def __and__(self, other):\n        res = Set()\n        for a in self:\n            if a in other:\n                res.add(a)\n        for a in other:\n            if a in self:\n                res.add(a)\n        return res\nint1 = lambda x: int(x) - 1\npDB = lambda *x: print(*x, end='\\n', file=sys.stderr)\np2D = lambda x: print(*x, sep='\\n', end='\\n\\n', file=sys.stderr)\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef LI1():\n    return list(map(int1, sys.stdin.readline().split()))\n\ndef LLI1(rows_number):\n    return [LI1() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline().rstrip()\ndij = [(0, 1), (-1, 0), (0, -1), (1, 0)]\ninf = (1 << 63) - 1\nmd = 10 ** 9 + 7\n\nclass Sieve:\n\n    def __init__(self, n):\n        self.plist = [2]\n        min_prime_factor = [2, 0] * (n // 2 + 1)\n        for x in range(3, n + 1, 2):\n            if min_prime_factor[x] == 0:\n                min_prime_factor[x] = x\n                self.plist.append(x)\n                if x ** 2 > n:\n                    continue\n                for y in range(x ** 2, n + 1, 2 * x):\n                    if min_prime_factor[y] == 0:\n                        min_prime_factor[y] = x\n        self.min_prime_factor = min_prime_factor\n\n    def isprime(self, x):\n        return self.min_prime_factor[x] == x\n\n    def pf(self, x):\n        (pp, ee) = ([], [])\n        while x > 1:\n            mpf = self.min_prime_factor[x]\n            if pp and mpf == pp[-1]:\n                ee[-1] += 1\n            else:\n                pp.append(mpf)\n                ee.append(1)\n            x //= mpf\n        return (pp, ee)\n\n    def factor(self, a):\n        ff = [1]\n        (pp, ee) = self.pf(a)\n        for (p, e) in zip(pp, ee):\n            (ff, gg) = ([], ff)\n            w = p\n            for _ in range(e):\n                for f in gg:\n                    ff.append(f * w)\n                w *= p\n            ff += gg\n        return ff\n\ndef nHr(hn, hr):\n    return nCr(hn + hr - 1, hr - 1)\n\ndef nPr(com_n, com_r):\n    if com_r < 0:\n        return 0\n    if com_n < com_r:\n        return 0\n    return fac[com_n] * ifac[com_n - com_r] % md\n\ndef nCr(com_n, com_r):\n    if com_r < 0:\n        return 0\n    if com_n < com_r:\n        return 0\n    return fac[com_n] * ifac[com_r] % md * ifac[com_n - com_r] % md\nn_max = 100005\nfac = [1]\nfor i in range(1, n_max + 1):\n    fac.append(fac[-1] * i % md)\nifac = [1] * (n_max + 1)\nifac[n_max] = pow(fac[n_max], md - 2, md)\nfor i in range(n_max - 1, 1, -1):\n    ifac[i] = ifac[i + 1] * (i + 1) % md\nsv = Sieve(10 ** 7)\n\ndef solve():\n    n = II()\n    aa = LI()\n    ac = Counter(aa)\n    fc = Counter()\n    ans = 0\n    for (a, c) in ac.items():\n        ans += pow(2, c, md) - 1\n        for f in sv.factor(a):\n            fc[f] += c\n            ans -= nCr(c, f)\n            ans %= md\n    for (f, c) in fc.items():\n        if f == 1:\n            continue\n        ans += nCr(c, f)\n        ans %= md\n    print(ans)\ntestnumber = II()\nfor testcase in range(testnumber):\n    solve()", "import sys\nimport random\nfrom collections import defaultdict\n\nclass DefaultDict:\n\n    def __init__(self, default=None):\n        self.default = default\n        self.x = random.randrange(1, 1 << 31)\n        self.dd = defaultdict(default)\n\n    def __repr__(self):\n        return '{' + ', '.join((f'{k ^ self.x}: {v}' for (k, v) in self.dd.items())) + '}'\n\n    def __eq__(self, other):\n        for k in set(self) | set(other):\n            if self[k] != other[k]:\n                return False\n        return True\n\n    def __or__(self, other):\n        res = DefaultDict(self.default)\n        for (k, v) in self.dd:\n            res[k] = v\n        for (k, v) in other.dd:\n            res[k] = v\n        return res\n\n    def __len__(self):\n        return len(self.dd)\n\n    def __getitem__(self, item):\n        return self.dd[item ^ self.x]\n\n    def __setitem__(self, key, value):\n        self.dd[key ^ self.x] = value\n\n    def __delitem__(self, key):\n        del self.dd[key ^ self.x]\n\n    def __contains__(self, item):\n        return item ^ self.x in self.dd\n\n    def items(self):\n        for (k, v) in self.dd.items():\n            yield (k ^ self.x, v)\n\n    def keys(self):\n        for k in self.dd:\n            yield (k ^ self.x)\n\n    def values(self):\n        for v in self.dd.values():\n            yield v\n\n    def __iter__(self):\n        for k in self.dd:\n            yield (k ^ self.x)\n\nclass Counter(DefaultDict):\n\n    def __init__(self, aa=[]):\n        super().__init__(int)\n        for a in aa:\n            self.dd[a ^ self.x] += 1\n\n    def __add__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = self[k] + other[k]\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __sub__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = self[k] - other[k]\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __and__(self, other):\n        res = Counter()\n        for k in self:\n            v = min(self[k], other[k])\n            if v > 0:\n                res[k] = v\n        return res\n\n    def __or__(self, other):\n        res = Counter()\n        for k in set(self) | set(other):\n            v = max(self[k], other[k])\n            if v > 0:\n                res[k] = v\n        return res\n\nclass Set:\n\n    def __init__(self, aa=[]):\n        self.x = random.randrange(1, 1 << 31)\n        self.st = set()\n        for a in aa:\n            self.st.add(a ^ self.x)\n\n    def __repr__(self):\n        return '{' + ', '.join((str(k ^ self.x) for k in self.st)) + '}'\n\n    def __len__(self):\n        return len(self.st)\n\n    def add(self, item):\n        self.st.add(item ^ self.x)\n\n    def discard(self, item):\n        self.st.discard(item ^ self.x)\n\n    def __contains__(self, item):\n        return item ^ self.x in self.st\n\n    def __iter__(self):\n        for k in self.st:\n            yield (k ^ self.x)\n\n    def pop(self):\n        return self.st.pop() ^ self.x\n\n    def __or__(self, other):\n        res = Set(self)\n        for a in other:\n            res.add(a)\n        return res\n\n    def __and__(self, other):\n        res = Set()\n        for a in self:\n            if a in other:\n                res.add(a)\n        for a in other:\n            if a in self:\n                res.add(a)\n        return res\nint1 = lambda x: int(x) - 1\npDB = lambda *x: print(*x, end='\\n', file=sys.stderr)\np2D = lambda x: print(*x, sep='\\n', end='\\n\\n', file=sys.stderr)\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef LI1():\n    return list(map(int1, sys.stdin.readline().split()))\n\ndef LLI1(rows_number):\n    return [LI1() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline().rstrip()\ndij = [(0, 1), (-1, 0), (0, -1), (1, 0)]\ninf = (1 << 63) - 1\nmd = 10 ** 9 + 7\n\nclass Sieve:\n\n    def __init__(self, n):\n        self.plist = [2]\n        min_prime_factor = [2, 0] * (n // 2 + 1)\n        for x in range(3, n + 1, 2):\n            if min_prime_factor[x] == 0:\n                min_prime_factor[x] = x\n                self.plist.append(x)\n                if x ** 2 > n:\n                    continue\n                for y in range(x ** 2, n + 1, 2 * x):\n                    if min_prime_factor[y] == 0:\n                        min_prime_factor[y] = x\n        self.min_prime_factor = min_prime_factor\n\n    def isprime(self, x):\n        return self.min_prime_factor[x] == x\n\n    def pf(self, x):\n        (pp, ee) = ([], [])\n        while x > 1:\n            mpf = self.min_prime_factor[x]\n            if pp and mpf == pp[-1]:\n                ee[-1] += 1\n            else:\n                pp.append(mpf)\n                ee.append(1)\n            x //= mpf\n        return (pp, ee)\n\n    def factor(self, a):\n        ff = [1]\n        (pp, ee) = self.pf(a)\n        for (p, e) in zip(pp, ee):\n            (ff, gg) = ([], ff)\n            w = p\n            for _ in range(e):\n                for f in gg:\n                    ff.append(f * w)\n                w *= p\n            ff += gg\n        return ff\n\ndef nHr(hn, hr):\n    return nCr(hn + hr - 1, hr - 1)\n\ndef nPr(com_n, com_r):\n    if com_r < 0:\n        return 0\n    if com_n < com_r:\n        return 0\n    return fac[com_n] * ifac[com_n - com_r] % md\n\ndef nCr(com_n, com_r):\n    if com_r < 0:\n        return 0\n    if com_n < com_r:\n        return 0\n    return fac[com_n] * ifac[com_r] % md * ifac[com_n - com_r] % md\nn_max = 100005\nfac = [1]\nfor i in range(1, n_max + 1):\n    fac.append(fac[-1] * i % md)\nifac = [1] * (n_max + 1)\nifac[n_max] = pow(fac[n_max], md - 2, md)\nfor i in range(n_max - 1, 1, -1):\n    ifac[i] = ifac[i + 1] * (i + 1) % md\nsv = Sieve(10 ** 7)\n\ndef solve():\n    n = II()\n    aa = LI()\n    ac = Counter(aa)\n    fc = Counter()\n    ans = 0\n    for (a, c) in ac.items():\n        ans += pow(2, c, md) - 1\n        for f in sv.factor(a):\n            fc[f] += c\n            ans -= nCr(c, f)\n            ans %= md\n    for (f, c) in fc.items():\n        if f == 1:\n            continue\n        ans += nCr(c, f)\n        ans %= md\n    print(ans)\ntestnumber = II()\nfor testcase in range(testnumber):\n    solve()"]