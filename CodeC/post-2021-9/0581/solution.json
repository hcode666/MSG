["z = [0 for _ in range(51)]\nz[1] = 1\nfor i in range(2, 51):\n    z[i] = 2 * z[i - 1] + 2 ** (i - 2)\nb = [0 for i in range(51)]\nfor i in range(1, 51):\n    b[i] = b[i - 1] + z[i]\n\ndef sol1(target, n):\n    value = 1\n    sum1 = 1\n    num1 = 1\n    abnum = 2 ** (n - 1) - 1\n    while value != target:\n        if value + abnum > target:\n            value = value + 1\n            sum1 = sum1 + num1\n            n = n - 1\n            abnum = 2 ** (n - 1) - 1\n        elif value + abnum < target:\n            value = value + abnum + 1\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n            num1 = num1 + 1\n            sum1 = sum1 + num1\n            abnum = 2 ** (n - 1) - 1\n        else:\n            value = value + abnum\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n    return sum1\nw = int(input())\nfor _ in range(w):\n    (n, k) = list(map(int, input().strip().split()))\n    print(sol1(k, n))", "a = [0 for _ in range(51)]\na[1] = 1\nfor i in range(2, 51):\n    a[i] = 2 * a[i - 1] + 2 ** (i - 2)\nb = [0 for i in range(51)]\nfor i in range(1, 51):\n    b[i] = b[i - 1] + a[i]\n\ndef sol1(target, n):\n    value = 1\n    sum1 = 1\n    num1 = 1\n    abnum = 2 ** (n - 1) - 1\n    while value != target:\n        if value + abnum > target:\n            value = value + 1\n            sum1 = sum1 + num1\n            n = n - 1\n            abnum = 2 ** (n - 1) - 1\n        elif value + abnum < target:\n            value = value + abnum + 1\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n            num1 = num1 + 1\n            sum1 = sum1 + num1\n            abnum = 2 ** (n - 1) - 1\n        else:\n            value = value + abnum\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n    return sum1\nw = int(input())\nfor _ in range(w):\n    (n, k) = list(map(int, input().strip().split()))\n    print(sol1(k, n))", "a1 = [0 for _ in range(51)]\na1[1] = 1\nfor i in range(2, 51):\n    a1[i] = 2 * a1[i - 1] + 2 ** (i - 2)\nb = [0 for i in range(51)]\nfor i in range(1, 51):\n    b[i] = b[i - 1] + a1[i]\n\ndef sol1(target, n):\n    value = 1\n    sum1 = 1\n    num1 = 1\n    abnum = 2 ** (n - 1) - 1\n    while value != target:\n        if value + abnum > target:\n            value = value + 1\n            sum1 = sum1 + num1\n            n = n - 1\n            abnum = 2 ** (n - 1) - 1\n        elif value + abnum < target:\n            value = value + abnum + 1\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n            num1 = num1 + 1\n            sum1 = sum1 + num1\n            abnum = 2 ** (n - 1) - 1\n        else:\n            value = value + abnum\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n    return sum1\nw = int(input())\nfor _ in range(w):\n    (n, k) = list(map(int, input().strip().split()))\n    print(sol1(k, n))", "a = [0 for _ in range(51)]\na[1] = 1\nfor i in range(2, 51):\n    a[i] = 2 * a[i - 1] + 2 ** (i - 2)\nb = [0 for i in range(51)]\nfor i in range(1, 51):\n    b[i] = b[i - 1] + a[i]\n\ndef sol1(target, n):\n    value = 1\n    sum1 = 1\n    num1 = 1\n    abnum = 2 ** (n - 1) - 1\n    while value != target:\n        if value + abnum > target:\n            value = value + 1\n            sum1 = sum1 + num1\n            n = n - 1\n            abnum = 2 ** (n - 1) - 1\n        elif value + abnum < target:\n            value = value + abnum + 1\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n            num1 = num1 + 1\n            sum1 = sum1 + num1\n            abnum = 2 ** (n - 1) - 1\n        else:\n            value = value + abnum\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n    return sum1\nw = int(input())\nfor _ in range(w):\n    (n, k) = list(map(int, input().strip().split()))\n    print(sol1(k, n))", "a = [0 for _ in range(51)]\na[1] = 1\nfor i in range(2, 51):\n    a[i] = 2 * a[i - 1] + 2 ** (i - 2)\nb = [0 for i in range(51)]\nfor i in range(1, 51):\n    b[i] = b[i - 1] + a[i]\n\ndef sol1(target, n):\n    value = 1\n    sum1 = 1\n    num1 = 1\n    abnum = 2 ** (n - 1) - 1\n    while value != target:\n        if value + abnum > target:\n            value = value + 1\n            sum1 = sum1 + num1\n            n = n - 1\n            abnum = 2 ** (n - 1) - 1\n        elif value + abnum < target:\n            value = value + abnum + 1\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n            num1 = num1 + 1\n            sum1 = sum1 + num1\n            abnum = 2 ** (n - 1) - 1\n        else:\n            value = value + abnum\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n    return sum1\nw = int(input())\nfor _ in range(w):\n    (n, k) = list(map(int, input().strip().split()))\n    print(sol1(k, n))", "dp = [[0, 0], [2, 1]]\nout = 0\n\ndef count(k, n, s):\n    global out\n    if k <= 0 or n <= 0:\n        return\n    if s:\n        out += k\n    if k == 1:\n        return\n    if k - (1 << n - 1) == 0:\n        out += dp[n - 2][1]\n        return\n    if k - (1 << n - 1) < 0:\n        count(k - 1, n - 1, 0)\n        return\n    out += dp[n - 2][1]\n    count(k - (1 << n - 1), n - 1, 1)\n\ndef solve():\n    global out\n    (n, k) = [int(i) for i in input().split()]\n    while len(dp) < n - 1:\n        x = dp[-1]\n        dp.append([x[0] * 2 + 2, 2 * x[1] + x[0] + 1])\n    out = 0\n    count(k, n, 1)\n    print(out)\nt = int(input())\nfor i in range(t):\n    solve()", "a = [0 for _ in range(51)]\na[1] = 1\nfor i in range(2, 51):\n    a[i] = 2 * a[i - 1] + 2 ** (i - 2)\nb = [0 for i in range(51)]\nfor i in range(1, 51):\n    b[i] = b[i - 1] + a[i]\n\ndef sol(target, n):\n    value = 1\n    sum1 = 1\n    num1 = 1\n    abnum = 2 ** (n - 1) - 1\n    while value != target:\n        if value + abnum > target:\n            value = value + 1\n            sum1 = sum1 + num1\n            n = n - 1\n            abnum = 2 ** (n - 1) - 1\n        elif value + abnum < target:\n            value = value + abnum + 1\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n            num1 = num1 + 1\n            sum1 = sum1 + num1\n            abnum = 2 ** (n - 1) - 1\n        else:\n            value = value + abnum\n            sum1 = sum1 + num1 * abnum\n            n = n - 1\n            for u in range(1, n):\n                sum1 = sum1 + b[u]\n    return sum1\nt = int(input())\nfor _ in range(t):\n    (n, k) = list(map(int, input().strip().split()))\n    print(sol(k, n))", "import sys\nMAX_DEPTH = 50\n\ndef build_lookup_table():\n    table = [0 for _ in range(MAX_DEPTH)]\n    for i in range(1, MAX_DEPTH):\n        table[i] = 2 * table[i - 1] + 2 ** (i - 1)\n    cumulative = [0 for _ in range(MAX_DEPTH)]\n    for i in range(1, MAX_DEPTH):\n        cumulative[i] = cumulative[i - 1] + table[i]\n    return cumulative\n\ndef get_lexico_ordered_bits(n, k):\n    ret = lexico_ordered_bits(n, k)\n    return [1] + ret\n\ndef lexico_ordered_bits(n, k):\n    if k <= 1:\n        return []\n    if k <= 2 ** (n - 1):\n        return [0] + lexico_ordered_bits(n - 1, k - 1)\n    else:\n        return [1] + lexico_ordered_bits(n - 1, k - 2 ** (n - 1))\n\ndef solve(bits, n, i, lookup_table):\n    level = n - len(bits) + (i + 1)\n    if i == 0:\n        if bits[i] == 1:\n            child_count = 1\n            ones_count = 1\n            if level - 1 >= 0:\n                child_count += 2 ** level - 1\n                ones_count += lookup_table[level - 1]\n            return (child_count, ones_count)\n        else:\n            return (1, 0)\n    if bits[i] == 0:\n        (child_count, ones_count) = solve(bits, n, i - 1, lookup_table)\n        return (child_count + 1, ones_count)\n    else:\n        (child_count, ones_count) = solve(bits, n, i - 1, lookup_table)\n        ones_count += child_count + 1\n        child_count += 1\n        if i == len(bits) - 1:\n            return (child_count, ones_count)\n        child_count += 2 ** level - 1\n        if level - 1 >= 0:\n            ones_count += lookup_table[level - 1]\n        return (child_count, ones_count)\nlookup_table = build_lookup_table()\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    (n, k) = map(int, sys.stdin.readline().split())\n    bits_k = get_lexico_ordered_bits(n, k)\n    bits_k.reverse()\n    if k == 1:\n        print(1)\n    else:\n        print(solve(bits_k, n, len(bits_k) - 1, lookup_table)[1])", "def func(n, k, toggle):\n    if k == 2 ** n - 1:\n        return n * 2 ** (n - 1) - (toggle ^ 1) * k * 1\n    if n == 1:\n        return toggle\n    if k <= 2 ** n // 2:\n        return toggle * k * 1 + func(n - 1, k - 1, 0)\n    else:\n        return toggle * k * 1 + func(n - 1, 2 ** (n - 1) - 1, 0) + func(n - 1, k - 2 ** n // 2, 1)\nfor case in range(int(input())):\n    (N, K) = map(int, input().split())\n    print(func(N, K, 1))", "T = int(input())\nfor line in range(T):\n    (N, K) = map(int, input().split())\n    digits = [1]\n    prior = [K - 1]\n    counter = K\n    block = 2 ** N - 1\n    for d in range(1, N):\n        if counter == 1:\n            break\n        counter -= 1\n        block = (block + 1) // 2 - 1\n        if counter <= block:\n            digits.append(0)\n            prior.append(0)\n            continue\n        counter -= block\n        digits.append(1)\n        prior.append(counter - 1)\n    tally = K - 1\n    for i in range(1, min(len(digits), N - 1)):\n        d = digits[i]\n        if d == 1:\n            tally += (N - i - 2) * 2 ** (N - i - 1) + 1\n            tally += prior[i]\n    tally += sum(digits)\n    print(tally)", "from sys import stdin, stdout\nimport math\nmod = 1000000007\nmod9 = 998244353\nfact = []\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef largePower(a, b, MOD):\n    b = str(b)\n    remainderB = 0\n    for i in range(len(b)):\n        remainderB = (remainderB * 10 + ord(b[i]) - 48) % (MOD - 1)\n    return power(a, remainderB, MOD)\n\ndef decimalToBinary(n):\n    return bin(n).replace('0b', '')\n\ndef binaryToDecimal(n):\n    return int(n, 2)\n\ndef buildFact(n, m):\n    fact.append(1)\n    for i in range(1, n + 1):\n        fact.append(fact[-1] * i)\n        fact[-1] %= m\n    return fact\n\ndef buildSieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\ndef findDivisors(n):\n    i = 1\n    arr = []\n    while i * i < n:\n        if n % i == 0:\n            arr.append(i)\n        i += 1\n    m = int(math.sqrt(n))\n    for i in range(m, 0, -1):\n        if n % i == 0:\n            arr.append(n // i)\n\ndef solve():\n    (n, k) = map(int, stdin.readline().split())\n    arr = []\n    if k <= n:\n        print(k)\n        return\n    arr.append([2, 1])\n    for i in range(n - 2):\n        arr.append([2 + 2 * arr[-1][0] + arr[-1][1], 2 * arr[-1][1] + 1])\n    i = 0\n    k -= n\n    ans = n\n    while k >= arr[i][1]:\n        ans += arr[i][0]\n        i += 1\n        k -= arr[i - 1][1]\n        if k == 0:\n            print(ans)\n            return\n    while k > 0:\n        while k - 1 < arr[i][1] // 2:\n            k -= 1\n            ans += 2\n            i -= 1\n            if k == 0:\n                print(ans)\n                return\n        i -= 1\n        ans += arr[i][0]\n        k -= arr[i][1]\n        k -= 1\n        ans += 2\n        ans += k\n    print(ans)\n    return\ntests = int(stdin.readline())\nfor _ in range(tests):\n    solve()", "def value(N, k):\n    if k == 1:\n        return 1\n    elif k <= 2 ** (N - 1):\n        return value(N - 1, k - 1)\n    else:\n        return value(N - 1, k - 2 ** (N - 1)) + 1\n\ndef sumk(N, k):\n    if k == 1:\n        return 1\n    elif k <= 2 ** (N - 1):\n        return 1 + sumk(N - 1, k - 1)\n    else:\n        return 1 + (N - 1) * 2 ** (N - 2) + (k - 2 ** (N - 1)) + sumk(N - 1, k - 2 ** (N - 1))\nT = int(input())\nfor i in range(T):\n    (N, K) = map(int, input().split(' '))\n    print(sumk(N, K))", "def solve(n, k):\n    answer = 0\n    level = 0\n    curr = n\n    while True:\n        if k <= curr:\n            answer += (level + 1) * k\n            return answer\n        answer += (level + 1) * curr\n        k -= curr\n        i = 1\n        while k >= 2 ** i - 1:\n            k -= 2 ** i - 1\n            answer += (level + 1) * (2 ** i - 1) + sol[i]\n            i += 1\n        if k == 0:\n            return answer\n        level += 1\n        curr = i\nsol = [1, 1]\nfor i in range(2, 51):\n    x = i - 1\n    for j in range(len(sol)):\n        x += 2 ** j - 1 + sol[j]\n    sol.append(x)\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    print(solve(n, k))", "import math\nno_test = int(input())\nsol = []\nd = {}\nd[1] = 1\n\ndef dic(k):\n    if k in d:\n        return d[k]\n    else:\n        d[k] = 2 * dic(k - 1) + 1\n        return d[k]\n\ndef fun(e, k):\n    if k <= e:\n        return k\n    a = e\n    s = e\n    n = 0\n    while s + dic(n + 1) <= k:\n        n += 1\n        a += dic(n) + n * 2 ** (n - 1)\n        s += dic(n)\n    if k == s:\n        return a\n    a += k - s + fun(n + 1, k - s)\n    return a\nfor _ in range(0, no_test):\n    (a, b) = [int(x) for x in input().split()]\n    sol.append(fun(a, b))\nfor k in sol:\n    print(k)", "def fullcount(k, n):\n    pow2 = pow(2, n)\n    if k <= 0:\n        return 0\n    if k == 2 * pow2 - 3:\n        return (n - 1) * pow2 + 1\n    if k < pow2 - 1:\n        return fullcount(k - 1, n - 1)\n    if k >= pow2 - 1:\n        return fullcount(k - pow2, n - 1) + (k - pow2 + 2) + (n - 2) * pow2 // 2 + 1\n    return 1 / 0\nt = int(input())\nfor i in range(t):\n    c = input().split()\n    n = int(c[0])\n    k = int(c[1])\n    print(k + fullcount(k - 2, n - 1))"]