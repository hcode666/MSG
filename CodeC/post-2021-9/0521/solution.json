["c = 200000\nmod = 998244353\nst = [0] * (4 * c)\n\ndef update(idx, ss, se, summ, num):\n    if ss == se and ss == num:\n        st[idx] = (st[idx] + summ) % mod\n        return\n    mid = (ss + se) // 2\n    if mid >= num:\n        update(2 * idx + 1, ss, mid, summ, num)\n    else:\n        update(2 * idx + 2, mid + 1, se, summ, num)\n    st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\ndef rangesum(idx, ss, se, rs, re):\n    if rs <= ss and se <= re:\n        return st[idx]\n    elif re < ss or se < rs:\n        return 0\n    else:\n        mid = (ss + se) // 2\n        return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\nn = int(input())\ns = list(map(int, input().split()))\nfor i in range(n):\n    count = 1\n    if s[i] != 1:\n        count = (1 + rangesum(0, 1, 200000, 1, s[i] - 1)) % mod\n    update(0, 1, 200000, count, s[i])\nprint((st[0] + 1) % mod)", "n = int(input())\ns = list(map(int, input().split()))\na = sorted(([s[i], -i] for i in range(n)))\nindex = [-1] * n\nfor i in range(n):\n    index[-a[i][1]] = i\nmod = 998244353\nsize = 1 << n.bit_length() + 1\ntree = [0] * (2 * size + 1)\nres = 0\nfor i in range(n):\n    small_sum = 0\n    j = index[i] + size\n    (l, r) = (size, j - 1)\n    while l < r:\n        if l & 1:\n            small_sum = (small_sum + tree[l]) % mod\n            l += 1\n        if r & 1 == 0:\n            small_sum = (small_sum + tree[r]) % mod\n            r -= 1\n        l //= 2\n        r //= 2\n    small_sum = (small_sum + tree[l]) % mod\n    res = (res + small_sum + 1) % mod\n    tree[j] = (small_sum + 1) % mod\n    while j // 2 > 0:\n        j //= 2\n        tree[j] = (tree[j * 2] + tree[j * 2 + 1]) % mod\nprint((res + 1) % mod)", "MOD = 998244353\nMAX = 1000010\nsz = 400000\nbTree = []\n\ndef summ(index):\n    sum = 0\n    index += 1\n    while index > 0:\n        sum += bTree[index]\n        sum %= MOD\n        index -= index & -index\n    return sum % MOD\n\ndef updateBit(n, idx, v):\n    idx += 1\n    while idx <= n:\n        bTree[idx] += v\n        bTree[idx] %= MOD\n        idx += idx & -idx\nn = int(input())\ns = list(map(int, input().split()))\nbTree = [0 for _ in range(MAX)]\nfor i in range(n):\n    updateBit(sz, s[i], summ(s[i] - 1) + 1)\nprint((summ(sz) + 1) % MOD)", "import os\nimport sys\nimport math\nimport operator\nfrom random import randint, randrange\nfrom collections import defaultdict, Counter, deque\nfrom itertools import count, permutations, combinations\nfrom itertools import groupby, accumulate\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache, reduce\nMOD = 998244353\nPROFILE = False\nMAX = 1000010\nsz = 400000\nbTree = []\n\ndef summ(index):\n    sum = 0\n    index += 1\n    while index > 0:\n        sum += bTree[index]\n        sum %= MOD\n        index -= index & -index\n    return sum % MOD\n\ndef updateBit(n, idx, v):\n    idx += 1\n    while idx <= n:\n        bTree[idx] += v\n        bTree[idx] %= MOD\n        idx += idx & -idx\nn = int(input())\ns = list(map(int, input().split()))\nbTree = [0 for _ in range(MAX)]\nfor i in range(n):\n    updateBit(sz, s[i], summ(s[i] - 1) + 1)\nprint((summ(sz) + 1) % MOD)", "n = int(input())\ns = list(map(int, input().split()))\na = sorted(([s[i], -i] for i in range(n)))\nindex = [-1] * n\nfor i in range(n):\n    index[-a[i][1]] = i\nmod = 998244353\nsize = 1 << n.bit_length() + 1\ntree = [0] * (2 * size + 1)\nres = 0\nfor i in range(n):\n    small_sum = 0\n    j = index[i] + size\n    (l, r) = (size, j - 1)\n    while l < r:\n        if l & 1:\n            small_sum = (small_sum + tree[l]) % mod\n            l += 1\n        if r & 1 == 0:\n            small_sum = (small_sum + tree[r]) % mod\n            r -= 1\n        l //= 2\n        r //= 2\n    small_sum = (small_sum + tree[l]) % mod\n    res = (res + small_sum + 1) % mod\n    tree[j] = (small_sum + 1) % mod\n    while j // 2 > 0:\n        j //= 2\n        tree[j] = (tree[j * 2] + tree[j * 2 + 1]) % mod\nprint((res + 1) % mod)", "n = int(input())\ns = list(map(int, input().split()))\na = sorted(([s[i], -i] for i in range(n)))\nindex = [-1] * n\nfor i in range(n):\n    index[-a[i][1]] = i\nmod = 998244353\nsize = 1 << n.bit_length() + 1\ntree = [0] * (2 * size + 1)\nres = 0\nfor i in range(n):\n    small_sum = 0\n    j = index[i] + size\n    (l, r) = (size, j - 1)\n    while l < r:\n        if l & 1:\n            small_sum = (small_sum + tree[l]) % mod\n            l += 1\n        if r & 1 == 0:\n            small_sum = (small_sum + tree[r]) % mod\n            r -= 1\n        l //= 2\n        r //= 2\n    small_sum = (small_sum + tree[l]) % mod\n    res = (res + small_sum + 1) % mod\n    tree[j] = (small_sum + 1) % mod\n    while j // 2 > 0:\n        j //= 2\n        tree[j] = (tree[j * 2] + tree[j * 2 + 1]) % mod\nprint((res + 1) % mod)"]