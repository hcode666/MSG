["import sys\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\n\ndef ModInverse(n):\n    return pow(n, mod - 2, mod)\n\ndef NChooseK(n, k):\n    return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n(size, cap) = [int(x) for x in input().strip().split()]\narr = [int(x) for x in input().strip().split()]\nif cap < size:\n    print(0)\n    exit()\nFactorial = [1]\nfor n in range(1, cap + 1):\n    Factorial += [Factorial[-1] * n % mod]\nnum_elements_in_bounds = sum((1 for x in arr if x <= cap))\nans = NChooseK(cap, size) * Factorial[size] % mod\nsign = -1\nfor min_num_overlaps in range(1, num_elements_in_bounds + 1):\n    delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(cap - min_num_overlaps, size - min_num_overlaps) * Factorial[size - min_num_overlaps]\n    delta %= mod\n    ans = (ans + sign * delta) % mod\n    sign *= -1\nprint(ans)", "import sys\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\n\ndef ModInverse(n):\n    return pow(n, mod - 2, mod)\n\ndef NChooseK(n, k):\n    return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n(size, cap) = [int(x) for x in input().strip().split()]\narr = [int(x) for x in input().strip().split()]\nif cap < size:\n    print(0)\n    exit()\nFactorial = [1]\nfor n in range(1, cap + 1):\n    Factorial += [Factorial[-1] * n % mod]\nnum_elements_in_bounds = sum((1 for x in arr if x <= cap))\nans = NChooseK(cap, size) * Factorial[size] % mod\nsign = -1\nfor min_num_overlaps in range(1, num_elements_in_bounds + 1):\n    delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(cap - min_num_overlaps, size - min_num_overlaps) * Factorial[size - min_num_overlaps]\n    delta %= mod\n    ans = (ans + sign * delta) % mod\n    sign *= -1\nprint(ans)", "import sys\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom collections import deque\nsys.setrecursionlimit(10 ** 8)\nfrom queue import PriorityQueue as pq\nfrom math import gcd\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nlii = lambda : list(map(int, list(ip())))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\ninv = lambda x: pow(x, mod - 2, mod)\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\nmod = 10 ** 9 + 7\nmod1 = 998244353\nfact = [1]\nfor i in range(1, 4 * 10 ** 5 + 10):\n    fact.append(fact[-1] * i % mod)\ninv = [pow(fact[-1], mod - 2, mod)]\nfor i in range(4 * 10 ** 5 + 9, 0, -1):\n    inv.append(inv[-1] * i % mod)\ninv.reverse()\n\ndef ncr(n, r):\n    return fact[n] * inv[r] * inv[n - r] % mod\nfor _ in range(1):\n    (n, m) = il()\n    a = il()\n    if m < n:\n        print(0)\n        continue\n    t = n\n    x = 0\n    for i in range(n):\n        if a[i] > m:\n            t -= 1\n            x += 1\n    dp = [0 for i in range(t + 1)]\n    y = m - t\n    dp[t] = ncr(y, x) * fact[x] % mod\n    y += 1\n    x += 1\n    for i in range(t - 1, -1, -1):\n        dp[i] = (mod + ncr(y, x) * ncr(t, i) * fact[x] % mod - dp[i + 1]) % mod\n        y += 1\n        x += 1\n    print(dp[0])", "import sys\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\n\ndef ModInverse(n):\n    return pow(n, mod - 2, mod)\n\ndef NChooseK(n, k):\n    return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n(size, cap) = [int(x) for x in input().strip().split()]\narr = [int(x) for x in input().strip().split()]\nif cap < size:\n    print(0)\n    exit()\nFactorial = [1]\nfor n in range(1, cap + 1):\n    Factorial += [Factorial[-1] * n % mod]\nnum_elements_in_bounds = sum((1 for x in arr if x <= cap))\nans = NChooseK(cap, size) * Factorial[size] % mod\nsign = -1\nfor min_num_overlaps in range(1, num_elements_in_bounds + 1):\n    delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(cap - min_num_overlaps, size - min_num_overlaps) * Factorial[size - min_num_overlaps]\n    delta %= mod\n    ans = (ans + sign * delta) % mod\n    sign *= -1\nprint(ans)", "import sys\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\n\ndef ModInverse(n):\n    return pow(n, mod - 2, mod)\n\ndef NChooseK(n, k):\n    return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n(size, cap) = [int(x) for x in input().strip().split()]\narr = [int(x) for x in input().strip().split()]\nif cap < size:\n    print(0)\n    exit()\nFactorial = [1]\nfor n in range(1, cap + 1):\n    Factorial += [Factorial[-1] * n % mod]\nnum_elements_in_bounds = sum((1 for x in arr if x <= cap))\nans = NChooseK(cap, size) * Factorial[size] % mod\nsign = -1\nfor min_num_overlaps in range(1, num_elements_in_bounds + 1):\n    delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(cap - min_num_overlaps, size - min_num_overlaps) * Factorial[size - min_num_overlaps]\n    delta %= mod\n    ans = (ans + sign * delta) % mod\n    sign *= -1\nprint(ans)", "import math, sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfact = [1] * 300005\nfor i in range(1, 300005):\n    fact[i] = i * fact[i - 1] % mod1\n\ndef C(n, r):\n    return fact[n] * pow(fact[r], mod1 - 2, mod1) * pow(fact[n - r], mod1 - 2, mod1) % mod1 if n >= r else 0\n(n, m) = M()\na = L()\np = ans = 0\nfor i in range(n):\n    p += a[i] <= m\nfor i in range(p + 1):\n    ans = (ans + pow(-1, i) * C(p, i) * C(m - i, n - i) * fact[n - i]) % mod1\nprint(ans)", "import sys\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\n\ndef ModInverse(n):\n    return pow(n, mod - 2, mod)\n\ndef NChooseK(n, k):\n    return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n(size, cap) = [int(x) for x in input().strip().split()]\narr = [int(x) for x in input().strip().split()]\nif cap < size:\n    print(0)\n    exit()\nFactorial = [1]\nfor n in range(1, cap + 1):\n    Factorial += [Factorial[-1] * n % mod]\nnum_elements_in_bounds = sum((1 for x in arr if x <= cap))\nans = NChooseK(cap, size) * Factorial[size] % mod\nsign = -1\nfor min_num_overlaps in range(1, num_elements_in_bounds + 1):\n    delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(cap - min_num_overlaps, size - min_num_overlaps) * Factorial[size - min_num_overlaps]\n    delta %= mod\n    ans = (ans + sign * delta) % mod\n    sign *= -1\nprint(ans)", "import sys\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\n\ndef ModInverse(n):\n    return pow(n, mod - 2, mod)\n\ndef NChooseK(n, k):\n    return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n(size, cap) = [int(x) for x in input().strip().split()]\narr = [int(x) for x in input().strip().split()]\nif cap < size:\n    print(0)\nelse:\n    Factorial = [1]\n    for n in range(1, 3 * 10 ** 5 + 1):\n        Factorial += [Factorial[-1] * n % mod]\n    num_elements_in_bounds = sum((1 for x in arr if x <= cap))\n    ans = NChooseK(cap, size) * Factorial[size] % mod\n    sign = -1\n    for num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, num_overlaps) * NChooseK(cap - num_overlaps, size - num_overlaps) * Factorial[size - num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    print(ans)", "class Solution:\n\n    def __init__(self):\n        self.perm = [1] * (3 * 100005)\n        self.inverse = [1] * (3 * 100005)\n        self.mod = 1000000007\n\n    def pre(self):\n        for i in range(2, 3 * 100005):\n            self.perm[i] = self.perm[i - 1] * i % self.mod\n\n    def inversepre(self):\n        for i in range(2, 3 * 100005):\n            self.inverse[i] = pow(self.perm[i], self.mod - 2, self.mod)\n\n    def comb(self, n, c):\n        ans = self.perm[n] * self.inverse[n - c]\n        ans = ans * self.inverse[c]\n        return ans % self.mod\ns = Solution()\ns.pre()\ns.inversepre()\n(n, m) = [int(x) for x in input().split()]\nl = [int(x) for x in input().split()]\nif n > m:\n    print(0)\n    exit()\nans = 0\np = 0\nfor i in l:\n    if i <= m:\n        p += 1\nans += s.comb(m, n) * s.perm[n]\nans = ans % s.mod\nfor i in range(1, p + 1):\n    if i % 2 == 1:\n        ans = ans - s.comb(p, i) * s.comb(m - i, n - i) * s.perm[n - i]\n        ans = ans % s.mod\n    else:\n        ans = ans + s.comb(p, i) * s.comb(m - i, n - i) * s.perm[n - i]\n        ans = ans % s.mod\nprint(ans)", "class Solution:\n\n    def __init__(self):\n        self.perm = [1] * (3 * 100005)\n        self.inverse = [1] * (3 * 100005)\n        self.mod = 1000000007\n\n    def pre(self):\n        for i in range(2, 3 * 100005):\n            self.perm[i] = self.perm[i - 1] * i % self.mod\n\n    def inversepre(self):\n        for i in range(2, 3 * 100005):\n            self.inverse[i] = pow(self.perm[i], self.mod - 2, self.mod)\n\n    def comb(self, n, c):\n        ans = self.perm[n] * self.inverse[n - c]\n        ans = ans * self.inverse[c]\n        return ans % self.mod\ns = Solution()\ns.pre()\ns.inversepre()\n(n, m) = [int(x) for x in input().split()]\nl = [int(x) for x in input().split()]\nif n > m:\n    print(0)\n    exit()\nans = 0\np = 0\nfor i in l:\n    if i <= m:\n        p += 1\nans += s.comb(m, n) * s.perm[n]\nans = ans % s.mod\nfor i in range(1, p + 1):\n    if i % 2 == 1:\n        ans = ans - s.comb(p, i) * s.comb(m - i, n - i) * s.perm[n - i]\n        ans = ans % s.mod\n    else:\n        ans = ans + s.comb(p, i) * s.comb(m - i, n - i) * s.perm[n - i]\n        ans = ans % s.mod\nprint(ans)", "import math, bisect, heapq, random, sys, itertools\nints = lambda : list(map(int, input().split()))\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\np = 10 ** 9 + 7\nfact = [1]\nfor i in range(3 * 10 ** 5 + 100):\n    fact.append(fact[-1] * (i + 1) % p)\ninv = []\nfor i in fact:\n    inv.append(pow(i, p - 2, p))\n\ndef permutate(a, b):\n    return fact[a] * inv[a - b] % p\n\ndef comb(a, b):\n    return fact[a] * inv[a - b] * inv[b] % p\n(n, m) = ints()\na = ints()\nwhile len(a) != n:\n    a += ints()\nif n > m:\n    print(0)\n    quit()\nx = 0\nfor i in a:\n    if i <= m:\n        x += 1\nans = permutate(m, n)\nfor i in range(1, x + 1):\n    a = m - i\n    b = n - i\n    perm = fact[a] * inv[a - b] % p\n    a = x\n    b = i\n    comb = fact[a] * inv[a - b] * inv[b] % p\n    k = perm * comb\n    if i % 2:\n        ans = (ans - k) % p\n    else:\n        ans = (ans + k) % p\nprint(ans % p)", "import sys\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom collections import deque\nsys.setrecursionlimit(10 ** 8)\nfrom queue import PriorityQueue as pq\nfrom math import gcd\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nlii = lambda : list(map(int, list(ip())))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\ninv = lambda x: pow(x, mod - 2, mod)\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\nmod = 10 ** 9 + 7\nmod1 = 998244353\nfact = [1]\nfor i in range(1, 4 * 10 ** 5 + 10):\n    fact.append(fact[-1] * i % mod)\ninv = [pow(fact[-1], mod - 2, mod)]\nfor i in range(4 * 10 ** 5 + 9, 0, -1):\n    inv.append(inv[-1] * i % mod)\ninv.reverse()\n\ndef ncr(n, r):\n    return fact[n] * inv[r] * inv[n - r] % mod\nfor _ in range(1):\n    (n, m) = il()\n    a = il()\n    if m < n:\n        print(0)\n        continue\n    t = n\n    x = 0\n    for i in range(n):\n        if a[i] > m:\n            t -= 1\n            x += 1\n    dp = [0 for i in range(t + 1)]\n    y = m - t\n    dp[t] = ncr(y, x) * fact[x] % mod\n    y += 1\n    x += 1\n    for i in range(t - 1, -1, -1):\n        dp[i] = (mod + ncr(y, x) * ncr(t, i) * fact[x] % mod - dp[i + 1]) % mod\n        y += 1\n        x += 1\n    print(dp[0])", "from sys import stdin\ninput = stdin.readline\nmod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef sub(a, b):\n    return (a - b + mod) % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef ncr(n, r):\n    return mul(fact[n], mul(facti[n - r], facti[r]))\n\ndef div(a, b):\n    return mul(a, pow(b, mod - 2, mod))\n(fact, facti) = ([1], [1])\nsize = 5 * 10 ** 5 + 1\nfor i in range(1, size):\n    fact.append(mul(fact[-1], i))\n    facti.append(pow(fact[-1], mod - 2, mod))\n\ndef answer():\n    if m < n:\n        return 0\n    total = mul(ncr(m, n), fact[n])\n    count = 0\n    for i in range(n):\n        if b[i] <= m:\n            count += 1\n    minus = 0\n    for i in range(1, count + 1):\n        x = mul(ncr(m - i, n - i), fact[n - i])\n        x = mul(x, ncr(count, i))\n        if i & 1:\n            minus = add(minus, x)\n        else:\n            minus = sub(minus, x)\n    ans = sub(total, minus)\n    return ans\nfor T in range(1):\n    (n, m) = map(int, input().split())\n    b = list(map(int, input().split()))\n    print(answer())", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nsys.setrecursionlimit(3 * 10 ** 5)\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\nfact = [0] * (3 * 10 ** 5 + 5)\ninv = [0] * (3 * 10 ** 5 + 5)\nfact[0] = 1\nfact[1] = 1\ninv[0] = 1\ninv[1] = 1\nfor i in range(2, 3 * 10 ** 5 + 4):\n    fact[i] = fact[i - 1] * i % mod\n    inv[i] = pow(fact[i], mod - 2, mod)\n\ndef ncr(n, r):\n    if r > n or n < 0:\n        return 0\n    if n == 0 or r == 0:\n        return 1\n    ans = fact[n] * inv[r] * inv[n - r]\n    ans %= mod\n    return ans\n\ndef hnbhai(tc):\n    (n, m) = sd()\n    b = sd()\n    tot = n\n    for i in b:\n        if i > m:\n            tot -= 1\n    dp = [0] * (tot + 1)\n    left = n - tot\n    dp[tot] = ncr(m - tot, left) * fact[left] % mod\n    for i in range(tot - 1, -1, -1):\n        dp[i] = ncr(m - i, n - i) * ncr(tot, i) * fact[n - i] % mod - dp[i + 1]\n        dp[i] %= mod\n    print(dp[0])\nfor _ in range(1):\n    hnbhai(_ + 1)", "import sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nmod = 10 ** 9 + 7\n\ndef inv(z):\n    return infc[z]\nsz = 4 * 10 ** 5 + 3\nfc = [0] * sz\nfc[0] = 1\nfc[1] = 1\ninfc = [0] * sz\ninfc[0] = 1\ninfc[1] = 1\nfor i in range(2, sz):\n    fc[i] = fc[i - 1] * i % mod\nfor i in range(2, sz):\n    infc[i] = pow(fc[i], mod - 2, mod)\n\ndef fact(x):\n    return fc[x]\n\ndef ncr(a, b):\n    if b > a:\n        return 0\n    else:\n        return fact(a) * inv(a - b) % mod * inv(b) % mod\nfor _ in range(1):\n    (n, m) = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    if m < n:\n        print(0)\n        continue\n    no_r = 0\n    for i in b:\n        if 1 <= i <= m:\n            no_r += 1\n    ans = fact(m) * inv(m - n) % mod\n    for j in range(1, no_r + 1):\n        if j % 2 == 0:\n            ans += ncr(no_r, j) * fact(m - j) * inv(m - n)\n        else:\n            ans -= ncr(no_r, j) * fact(m - j) * inv(m - n)\n    print(ans % mod)"]