["from collections import defaultdict\nfrom collections import Counter\nimport math\nimport bisect\n\nclass dsu:\n\n    def __init__(self):\n        self.parent = defaultdict(int)\n        self.size = [0] * (n + 1)\n\n    def start(self):\n        for i in range(1, n + 1):\n            self.parent[i] = i\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def treeinput(self, m):\n        for i in range(m):\n            (u, v) = map(int, input().split())\n            self.union(u, v)\n\n    def printt(self):\n        print(self.parent)\n\ndef setbit(arr):\n    mask = 1\n    bit = [0] * 32\n    for i in range(32):\n        for k in arr:\n            if k & mask:\n                bit[i] += 1\n        mask <<= 1\n    return bit\n\ndef prefix_sum(nums):\n    prefix = [0]\n    for i in range(len(nums)):\n        prefix.append(prefix[-1] + nums[i])\n    return prefix\n\ndef mx_lensubarray(nums):\n    res = 0\n    j = 0\n    mp = defaultdict(int)\n    prefix = prefixsum(nums)\n    mxSum = 0\n    for i in range(len(nums)):\n        if nums[i] in mp:\n            temp = mp[nums[i]]\n        else:\n            temp = 0\n        j = max(temp, j)\n        mp[nums[i]] = i + 1\n        res = max(res, i - j + 1)\n        mxSum = max(mxSum, prefix[i + 1] - prefix[j])\n    return res\n\ndef lenOfLongSubarr(self, A, N, k):\n    mp = {}\n    sm = 0\n    mxlen = 0\n    for i in range(N):\n        sm += A[i]\n        if sm == k:\n            mxlen = i + 1\n        if sm - k in mp:\n            mxlen = max(mxlen, i - mp[sm - k])\n        if sm not in mp:\n            mp[sm] = i\n    return mxlen\n\ndef no_of_factor(s):\n    cnt = 0\n    x = int(s ** 0.5)\n    for i in range(1, x + 1):\n        if not s % i:\n            cnt = cnt + 1 if s / i == i else cnt + 2\n        i += 1\n    return cnt\n\ndef primes(n):\n    arr = []\n    i = 2\n    while i * i <= n:\n        if not n % i:\n            cnt = 0\n            while not n % i:\n                cnt += 1\n                n //= i\n            arr.append([i, cnt])\n        i += 1\n    if n > 1:\n        arr.append([n, 1])\n    return arr\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    res = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            res.append(i)\n    return res\n\ndef treeinput():\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\ndef dfs_size(node, parent):\n    sum_size[node] = 1\n    for child in adj[node]:\n        if child != parent:\n            dfs_size(child, node)\n            sum_size[node] += sum_size[child]\n\ndef anda(arr):\n    res = arr[0]\n    for i in arr:\n        res &= i\n    return res\n\ndef ora(arr):\n    res = arr[0]\n    for i in arr:\n        res |= i\n    return res\n\ndef xora(arr):\n    res = 0\n    for i in arr:\n        res ^= i\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arrb = list(map(int, input().split()))\n    mx = 0\n    for i in range(n - 1, -1, -1):\n        if arr[i] % 2:\n            mx = max(mx, arrb[i] - mx)\n    print(mx)", "from collections import defaultdict\nfrom collections import Counter\nimport math\nimport bisect\n\nclass dsu:\n\n    def __init__(self):\n        self.parent = defaultdict(int)\n        self.size = [0] * (n + 1)\n\n    def start(self):\n        for i in range(1, n + 1):\n            self.parent[i] = i\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def treeinput(self, m):\n        for i in range(m):\n            (u, v) = map(int, input().split())\n            self.union(u, v)\n\n    def printt(self):\n        print(self.parent)\n\ndef setbit(arr):\n    mask = 1\n    bit = [0] * 32\n    for i in range(32):\n        for k in arr:\n            if k & mask:\n                bit[i] += 1\n        mask <<= 1\n    return bit\n\ndef prefix_sum(nums):\n    prefix = [0]\n    for i in range(len(nums)):\n        prefix.append(prefix[-1] + nums[i])\n    return prefix\n\ndef mx_lensubarray(nums):\n    res = 0\n    j = 0\n    mp = defaultdict(int)\n    prefix = prefixsum(nums)\n    mxSum = 0\n    for i in range(len(nums)):\n        if nums[i] in mp:\n            temp = mp[nums[i]]\n        else:\n            temp = 0\n        j = max(temp, j)\n        mp[nums[i]] = i + 1\n        res = max(res, i - j + 1)\n        mxSum = max(mxSum, prefix[i + 1] - prefix[j])\n    return res\n\ndef lenOfLongSubarr(self, A, N, k):\n    mp = {}\n    sm = 0\n    mxlen = 0\n    for i in range(N):\n        sm += A[i]\n        if sm == k:\n            mxlen = i + 1\n        if sm - k in mp:\n            mxlen = max(mxlen, i - mp[sm - k])\n        if sm not in mp:\n            mp[sm] = i\n    return mxlen\n\ndef no_of_factor(s):\n    cnt = 0\n    x = int(s ** 0.5)\n    for i in range(1, x + 1):\n        if not s % i:\n            cnt = cnt + 1 if s / i == i else cnt + 2\n        i += 1\n    return cnt\n\ndef primes(n):\n    arr = []\n    i = 2\n    while i * i <= n:\n        if not n % i:\n            cnt = 0\n            while not n % i:\n                cnt += 1\n                n //= i\n            arr.append([i, cnt])\n        i += 1\n    if n > 1:\n        arr.append([n, 1])\n    return arr\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    res = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            res.append(i)\n    return res\n\ndef treeinput():\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\ndef dfs_size(node, parent):\n    sum_size[node] = 1\n    for child in adj[node]:\n        if child != parent:\n            dfs_size(child, node)\n            sum_size[node] += sum_size[child]\n\ndef anda(arr):\n    res = arr[0]\n    for i in arr:\n        res &= i\n    return res\n\ndef ora(arr):\n    res = arr[0]\n    for i in arr:\n        res |= i\n    return res\n\ndef xora(arr):\n    res = 0\n    for i in arr:\n        res ^= i\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arrb = list(map(int, input().split()))\n    mx = 0\n    for i in range(n - 1, -1, -1):\n        if arr[i] % 2:\n            mx = max(mx, arrb[i] - mx)\n    print(mx)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    c = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    maxt = 0\n    for i in range(n - 1, -1, -1):\n        if c[i] % 2 == 0:\n            continue\n        maxt = max(maxt, v[i] - maxt)\n    print(maxt)", "from collections import defaultdict\nfrom collections import Counter\nimport math\nimport bisect\n\nclass dsu:\n\n    def __init__(self):\n        self.parent = defaultdict(int)\n        self.size = [0] * (n + 1)\n\n    def start(self):\n        for i in range(1, n + 1):\n            self.parent[i] = i\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def treeinput(self, m):\n        for i in range(m):\n            (u, v) = map(int, input().split())\n            self.union(u, v)\n\n    def printt(self):\n        print(self.parent)\n\ndef setbit(arr):\n    mask = 1\n    bit = [0] * 32\n    for i in range(32):\n        for k in arr:\n            if k & mask:\n                bit[i] += 1\n        mask <<= 1\n    return bit\n\ndef prefix_sum(nums):\n    prefix = [0]\n    for i in range(len(nums)):\n        prefix.append(prefix[-1] + nums[i])\n    return prefix\n\ndef mx_lensubarray(nums):\n    res = 0\n    j = 0\n    mp = defaultdict(int)\n    prefix = prefixsum(nums)\n    mxSum = 0\n    for i in range(len(nums)):\n        if nums[i] in mp:\n            temp = mp[nums[i]]\n        else:\n            temp = 0\n        j = max(temp, j)\n        mp[nums[i]] = i + 1\n        res = max(res, i - j + 1)\n        mxSum = max(mxSum, prefix[i + 1] - prefix[j])\n    return res\n\ndef lenOfLongSubarr(self, A, N, k):\n    mp = {}\n    sm = 0\n    mxlen = 0\n    for i in range(N):\n        sm += A[i]\n        if sm == k:\n            mxlen = i + 1\n        if sm - k in mp:\n            mxlen = max(mxlen, i - mp[sm - k])\n        if sm not in mp:\n            mp[sm] = i\n    return mxlen\n\ndef no_of_factor(s):\n    cnt = 0\n    x = int(s ** 0.5)\n    for i in range(1, x + 1):\n        if not s % i:\n            cnt = cnt + 1 if s / i == i else cnt + 2\n        i += 1\n    return cnt\n\ndef primes(n):\n    arr = []\n    i = 2\n    while i * i <= n:\n        if not n % i:\n            cnt = 0\n            while not n % i:\n                cnt += 1\n                n //= i\n            arr.append([i, cnt])\n        i += 1\n    if n > 1:\n        arr.append([n, 1])\n    return arr\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    res = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            res.append(i)\n    return res\n\ndef treeinput():\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\ndef dfs_size(node, parent):\n    sum_size[node] = 1\n    for child in adj[node]:\n        if child != parent:\n            dfs_size(child, node)\n            sum_size[node] += sum_size[child]\n\ndef anda(arr):\n    res = arr[0]\n    for i in arr:\n        res &= i\n    return res\n\ndef ora(arr):\n    res = arr[0]\n    for i in arr:\n        res |= i\n    return res\n\ndef xora(arr):\n    res = 0\n    for i in arr:\n        res ^= i\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arrb = list(map(int, input().split()))\n    mx = 0\n    for i in range(n - 1, -1, -1):\n        if arr[i] % 2:\n            mx = max(mx, arrb[i] - mx)\n    print(mx)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    c = [int(x) for x in input().split()]\n    v = [int(x) for x in input().split()]\n    F = []\n    for i in range(n):\n        if c[i] % 2 == 1:\n            F += [v[i]]\n    M = len(F)\n    f = 0\n    g = 0\n    for k in range(M - 1, -1, -1):\n        h = max(g + F[k], f)\n        g = min(f - F[k], g)\n        f = h\n    print(f)", "T = int(input())\nfor i in range(T):\n    N = int(input())\n    C = [int(x) for x in input().split()]\n    V = [int(x) for x in input().split()]\n    F = []\n    for i in range(N):\n        if C[i] % 2 == 1:\n            F += [V[i]]\n    M = len(F)\n    f = 0\n    g = 0\n    for i in range(M - 1, -1, -1):\n        h = max(g + F[i], f)\n        g = min(f - F[i], g)\n        f = h\n    print(f)", "import sys\nsys.setrecursionlimit(1000000)\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\n\ndef printyes():\n    print('YES')\n\ndef printno():\n    print('NO')\nfor t in range(int(input())):\n    n = ni()\n    c = li()\n    v = li()\n    c.reverse()\n    v.reverse()\n    ans = [0]\n    maxx = [0]\n    for i in range(n):\n        if c[i] % 2 == 1:\n            curr = v[i] - maxx[-1]\n            ans.append(max(curr, maxx[-1]))\n            maxx.append(max(maxx[-1], ans[-1]))\n    print(ans[-1])", "import math\nfrom bisect import bisect, bisect_left, bisect_right\nimport heapq\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as ddc\nfrom collections import Counter\n\ndef intin():\n    return int(input())\n\ndef mapin():\n    return map(int, input().split())\n\ndef strin():\n    return input().split()\nINF = 10 ** 20\nmod = 1000000007\n\ndef LIS(arr, n):\n    dp = [10 ** 9] * (n + 1)\n    for ele in arr:\n        dp[bisect_left(dp, ele)] = ele\n    return bisect_left(dp, 10 ** 9)\n\ndef exponentiation(bas, exp, mod=1000000007):\n    t = 1\n    while exp > 0:\n        if exp % 2 != 0:\n            t = t * bas % mod\n        bas = bas * bas % mod\n        exp //= 2\n    return t % mod\n\ndef MOD(p, q=1, mod=1000000007):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\nyes = 'YES'\nno = 'NO'\neven = 'EVEN'\nodd = 'ODD'\n\ndef process(arr, n):\n    dp = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        dp[i] = dp[i + 1]\n        if arr[i][0] % 2:\n            dp[i] = max(dp[i], arr[i][1] - dp[i + 1])\n    return dp[0]\n\ndef main():\n    for _ in range(int(input())):\n        n = intin()\n        C = list(mapin())\n        V = list(mapin())\n        arr = []\n        for i in range(n):\n            arr.append([C[i], V[i]])\n        print(process(arr, n))\nmain()", "import sys\nfrom math import sqrt, gcd, factorial, ceil, floor, pi\nfrom collections import deque, Counter, OrderedDict\nfrom heapq import heapify, heappush, heappop\ninput = lambda : sys.stdin.readline()\nI = lambda : int(input())\nS = lambda : input().strip()\nM = lambda : map(int, input().strip().split())\nL = lambda : list(map(int, input().strip().split()))\nmod = 1000000007\nfor _ in range(I()):\n    n = I()\n    c = L()\n    v = L()\n    x = [v[i] for i in range(n) if c[i] % 2]\n    (ans, mx) = (0, 0)\n    for i in range(len(x) - 1, -1, -1):\n        ans = max(ans, x[i] - mx)\n        mx = max(mx, ans)\n    print(ans)", "import sys\nimport math\nfrom collections import defaultdict, Counter, deque\nfrom bisect import *\nfrom string import ascii_lowercase\nfrom heapq import *\n\ndef readInts():\n    x = list(map(int, sys.stdin.readline().rstrip().split()))\n    return x[0] if len(x) == 1 else x\n\ndef readList(type=int):\n    x = sys.stdin.readline()\n    x = list(map(type, x.rstrip('\\n\\r').split()))\n    return x\n\ndef readStr():\n    x = sys.stdin.readline().rstrip('\\r\\n')\n    return x\nwrite = sys.stdout.write\nread = sys.stdin.readline\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef mergeSort(arr, check=lambda a, b: a < b, reverse=False):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        mergeSort(L, check, reverse)\n        mergeSort(R, check, reverse)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if check(L[i], R[j]):\n                if not reverse:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n            elif not reverse:\n                arr[k] = R[j]\n                j += 1\n            else:\n                arr[k] = L[i]\n                i += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\ndef maxSum(arr, k):\n    max_sum = 0\n    max_cur = 0\n    for (i, num) in enumerate(arr):\n        max_cur = max(max_cur + num, num)\n        if max_cur > max_sum:\n            max_sum = max_cur\n    return max_sum\n\ndef hcf(a, b):\n    if b == 0:\n        return a\n    else:\n        return hcf(b, b % a)\n\ndef get_power(n, m):\n    i = 1\n    p = -1\n    while i <= n:\n        i = i * m\n        p += 1\n    return p\n\ndef fact(n):\n    f = 1\n    for i in range(2, n + 1):\n        f *= i\n    return f\n\ndef find_closest(num, ar):\n    min_d = float('inf')\n    for num2 in ar:\n        d = abs(num2 - num)\n        if d < min_d:\n            min_d = d\n    return min_d\n\ndef check_pal(n):\n    s = str(n)\n    j = len(s) - 1\n    i = 0\n    while j > i:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef solve(t):\n    n = readInts()\n    c = readList()\n    v = readList()\n    dp = [0 for _ in range(n + 1)]\n    res = float('-inf')\n    for i in range(n - 1, -1, -1):\n        if c[i] & 1:\n            dp[i] = max(dp[i + 1], v[i] - dp[i + 1])\n        else:\n            dp[i] = max(dp[i], dp[i + 1])\n        res = max(res, dp[i])\n    print(res)\n\ndef main():\n    t = 1\n    sys.setrecursionlimit(1000)\n    t = readInts()\n    for i in range(t):\n        solve(i + 1)\nmain()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef f(arr, val, x, n, dp):\n    if x >= n:\n        return 0\n    if dp[x] != -1:\n        return dp[x]\n    a = 0\n    tm = 0\n    if dp[x + 1] == -1:\n        tm = f(arr, val, x + 1, n, dp)\n        dp[x + 1] = tm\n    else:\n        tm = dp[x + 1]\n    if arr[x] % 2 != 0:\n        a = val[x] - tm\n    b = tm\n    dp[x] = max(a, b)\n    return dp[x]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    val = list(map(int, input().split()))\n    dp = [-1 for i in range(n + 1)]\n    ans = f(arr, val, 0, n, dp)\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef fun(i, n, l, x, c, dp):\n    if i == n:\n        return 0\n    if dp[i][x] != 'a':\n        return dp[i][x]\n    if x == 1:\n        ans = min(fun(i + 1, n, l, 1, c, dp), -l[i] * (c[i] % 2) + fun(i + 1, n, l, 0, c, dp))\n    else:\n        ans = max(fun(i + 1, n, l, 0, c, dp), l[i] * (c[i] % 2) + fun(i + 1, n, l, 1, c, dp))\n    dp[i][x] = ans\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    dp = [['a', 'a', 'a'] for i in range(n + 1)]\n    print(fun(0, n, b, 0, a, dp))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(5 * 10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\ndef solve(i, turn):\n    if i == n:\n        return 0\n    if dp[i][turn] != None:\n        return dp[i][turn]\n    if turn == 0:\n        ans = solve(nind[i], 1) + b[i]\n        ans = max(ans, solve(nind[i], 0))\n    else:\n        ans = solve(nind[i], 0) - b[i]\n        ans = min(ans, solve(nind[i], 1))\n    dp[i][turn] = ans\n    return ans\n\ndef answer():\n    global dp, nind\n    nind = [n for i in range(n)]\n    s = []\n    for i in range(n):\n        while len(s) and a[i] & 1:\n            nind[s.pop()] = i\n        s.append(i)\n    dp = [[None, None] for i in range(n)]\n    start = n\n    for i in range(n):\n        if a[i] & 1:\n            start = i\n            break\n    ans = solve(start, 0)\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    a = inp()\n    b = inp()\n    print(answer())"]