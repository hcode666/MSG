["import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "def find(n):\n    start = 0\n    end = 3000000\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid * mid * mid > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num * num) < x:\n        tmp = num * num\n        cbs = find(tmp)\n        num = x + cbs\n    print(num * num)\nT = int(input())\nfor _ in range(T):\n    solve()", "for _ in range(int(input())):\n    x = int(input())\n    n = x + int(x ** (2 / 3))\n    while n - int(n ** (2 / 3)) != x:\n        n += x - n + int(n ** (2 / 3))\n    if (int(n ** (2 / 3)) + 1) ** 3 == n * n:\n        print((n + 1) ** 2)\n    else:\n        print(n ** 2)", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "mod_ = 10 ** 9 + 7\n\ndef cbrts(n):\n    (i, j) = (0, n)\n    while i < j:\n        x = (i + j) // 2\n        if x * x * x <= n:\n            i = x + 1\n        else:\n            j = x\n    return i - 1\nt = int(input())\nfor _ in range(t):\n    x = int(input())\n    n = x\n    if x == 1:\n        print(4)\n        continue\n    while True:\n        diff = n - cbrts(n * n)\n        if diff >= x:\n            break\n        n += x - diff\n    print(n * n)", "mod_ = 10 ** 9 + 7\n\ndef cbrts(n):\n    (i, j) = (0, n)\n    while i < j:\n        x = (i + j) // 2\n        if x * x * x <= n:\n            i = x + 1\n        else:\n            j = x\n    return i - 1\nt = int(input())\nfor _ in range(t):\n    x = int(input())\n    n = x\n    if x == 1:\n        print(4)\n        continue\n    while True:\n        diff = n - cbrts(n * n)\n        if diff >= x:\n            break\n        n += x - diff\n    print(n * n)", "def cuberoot(num):\n    x = int(num ** (1 / 3))\n    x += 1\n    while x * x * x > num:\n        x -= 1\n    return x\nfor _ in range(int(input())):\n    x = int(input())\n    (lo, hi) = (1, 2 * 10 ** 9)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if mid - cuberoot(mid * mid + 1) >= x:\n            hi = mid\n        else:\n            lo = mid + 1\n    print(lo * lo)", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "def perfectCube(N):\n    cube_root = round(N ** (1 / 3))\n    if cube_root * cube_root * cube_root == N:\n        return True\n    else:\n        return False\nimport math\n\ndef isPerfectSquare(x):\n    if x >= 0:\n        sr = int(math.sqrt(x))\n        return sr * sr == x\nfor t in range(int(input())):\n    x = int(input())\n    l = 0\n    r = 10000000000\n    while r - l > 0:\n        mid = (l + r) // 2\n        if perfectCube(mid ** 2):\n            y = round(pow(mid ** 2, 1 / 3))\n        else:\n            y = int(pow(mid ** 2, 1 / 3))\n        ans = int(mid) - y\n        if ans < x:\n            l = mid + 1\n        else:\n            r = mid\n    print(l ** 2)", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "import math\nfrom numpy import cbrt\na = int(input())\nfor i in range(a):\n    num = int(input())\n    x = num\n    while 1:\n        cu = cbrt(x * x)\n        if math.ceil(cu) * math.ceil(cu) * math.ceil(cu) == x * x:\n            cu = math.ceil(cu)\n        c = int(math.sqrt(x * x)) - int(cu)\n        if c >= num:\n            print(int(x * x))\n            break\n        else:\n            x += num - c", "from bisect import bisect_left\ncubes = [i ** 3 for i in range(1, 1010000)]\nfor _ in range(int(input())):\n    x = int(input())\n    (lo, hi) = (1, 2 * 10 ** 9)\n\n    def g(n):\n        return n - bisect_left(cubes, n * n + 1)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if g(mid) >= x:\n            hi = mid\n        else:\n            lo = mid + 1\n    print(lo * lo)", "import math\n\ndef find(n):\n    (start, end) = (0, int(3000000.0))\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid * mid * mid > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num * num) < x:\n        tmp = num * num\n        cbs = find(tmp)\n        num = x + cbs\n    print(num * num)\nT = int(input())\nfor _ in range(T):\n    solve()", "from bisect import bisect_left\ncubes = [i ** 3 for i in range(1, 1010000)]\nfor _ in range(int(input())):\n    x = int(input())\n    (lo, hi) = (1, 2 * 10 ** 9)\n\n    def g(n):\n        return n - bisect_left(cubes, n * n + 1)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if g(mid) >= x:\n            hi = mid\n        else:\n            lo = mid + 1\n    print(lo * lo)", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "from bisect import bisect_left\ncubes = [i ** 3 for i in range(1, 1010000)]\nfor _ in range(int(input())):\n    x = int(input())\n    (lo, hi) = (1, 2 * 10 ** 9)\n\n    def g(n):\n        return n - bisect_left(cubes, n * n + 1)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if g(mid) >= x:\n            hi = mid\n        else:\n            lo = mid + 1\n    print(lo * lo)", "t = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "import math\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    l = 0\n    r = 10 ** 10\n    ans = -1\n    while r >= l:\n        mid = (r + l) // 2\n        y = mid * mid\n        e = y ** (1 / 3)\n        e = int(e)\n        w = e + 1\n        w = w ** 3\n        if w == y:\n            e += 1\n        if mid - e >= n:\n            ans = mid * mid\n            r = mid - 1\n        else:\n            l = mid + 1\n    print(ans)", "import sys\nfrom os import path\nimport math\nif path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef i():\n    return int(input())\n\ndef s():\n    return str(input())\n\ndef ii():\n    return map(int, input().split())\n\ndef li():\n    return list(input())\n\ndef lii():\n    return list(map(int, input().split()))\n\ndef p(x):\n    print(x)\n\ndef fip(x, s):\n    for i in x:\n        print(i, end=s)\n    print()\nfor _ in range(int(input())):\n    x = i()\n    low = x\n    high = 10 ** 10\n    ans = 10 ** 20\n    while low <= high:\n        mid = (low + high) // 2\n        s = mid ** 2\n        cb = int(s ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == s:\n            cb += 1\n        if mid - cb >= x:\n            ans = min(ans, mid ** 2)\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "t = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "t = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "for _ in range(int(input())):\n    x = int(input())\n    m = 0\n    while True:\n        y = int(m ** (2.0 / 3.0) + 2)\n        while y ** 3 > m ** 2:\n            y -= 1\n        m1 = x + y\n        if m1 == m:\n            break\n        m = m1\n    print(m * m)", "def square(n):\n    val = int(pow(n, 0.5))\n    if (val + 1) ** 2 <= n:\n        return val + 1\n    return val\n\ndef cube(n):\n    val = int(pow(n, 1 / 3))\n    if (val + 1) ** 3 <= n:\n        return val + 1\n    return val\n\ndef F(n):\n    return square(n) - cube(n)\n\ndef solve(x):\n    num = x\n    ans = x ** 2\n    fn = num - cube(ans)\n    while fn < x:\n        diff = x - fn\n        num += diff\n        ans = num ** 2\n        fn = num - cube(ans)\n    return ans\nfor case in range(int(input())):\n    X = int(input())\n    curAns = solve(X)\n    print(curAns)", "t = int(input())\nimport math\nfor i in range(t):\n    x = int(input())\n    l = int(x ** 0.66)\n    r = int(x ** 0.7) + 2\n    while l != r:\n        mi = (l + r) // 2\n        if (mi + 1) ** 1.5 - mi <= x:\n            l = mi + 1\n        else:\n            r = mi\n    print((l + x) ** 2)", "import math\nimport bisect\nimport sys\nsys.setrecursionlimit(10000)\n\ndef binsearch(a, b, x):\n    mid = (a + b) // 2\n    a1 = int((mid ** 2) ** (1 / 3))\n    if (a1 + 1) ** 3 == mid ** 2:\n        a1 += 1\n    if a >= b:\n        return a\n    elif mid - a1 < x:\n        return binsearch(mid + 1, b, x)\n    else:\n        return binsearch(a, mid - 1, x)\nfor _ in range(int(input())):\n    n = int(input())\n    mid = binsearch(0, 3 * n + 100000, n)\n    b = int(mid ** (2 / 3))\n    if (b + 1) ** 3 == mid ** 2:\n        b += 1\n    while mid - b != n:\n        mid += 1\n        b = int(mid ** (2 / 3))\n        if (b + 1) ** 3 == mid ** 2:\n            b += 1\n    print(mid ** 2)", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "from bisect import bisect_left\ncubes = [i ** 3 for i in range(1, 1010000)]\nfor _ in range(int(input())):\n    x = int(input())\n    (lo, hi) = (1, 2 * 10 ** 9)\n\n    def g(n):\n        return n - bisect_left(cubes, n * n + 1)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if g(mid) >= x:\n            hi = mid\n        else:\n            lo = mid + 1\n    print(lo * lo)", "for _ in range(int(input())):\n    X = int(input())\n    x = pow(X, 2)\n    y = int(pow(x, 1 / 3))\n    dif = y\n    z = X\n    while dif > 0:\n        z += dif\n        x = pow(z, 2)\n        y = int(pow(z, 2 / 3))\n        if pow(y + 1, 3) - x < 1:\n            y += 1\n        dif = X - z + y\n    print(x)", "for _ in range(int(input())):\n    X = int(input())\n    x = pow(X, 2)\n    y = int(pow(x, 1 / 3))\n    dif = y\n    z = X\n    while dif > 0:\n        z += dif\n        x = pow(z, 2)\n        y = int(pow(z, 2 / 3))\n        if pow(y + 1, 3) - x < 1:\n            y += 1\n        dif = X - z + y\n    print(x)", "for _ in range(int(input())):\n    X = int(input())\n    x = pow(X, 2)\n    y = int(pow(x, 1 / 3))\n    dif = y\n    z = X\n    while dif > 0:\n        z += dif\n        x = pow(z, 2)\n        y = int(pow(z, 2 / 3))\n        if pow(y + 1, 3) - x < 1:\n            y += 1\n        dif = X - z + y\n    print(x)", "for i in range(int(input())):\n    n = int(input())\n    if n == 1:\n        print(4)\n    else:\n        st = n\n        x = n * n\n        p = 0\n        s = 0\n        while s < 10:\n            i = int(x ** (1 / 3))\n            n = n + i - p\n            x = n * n\n            if i ** 3 < x and x < (i + 1) ** 3:\n                break\n            if i == p:\n                i = i + 1\n                break\n            p = i\n            s += 1\n        print((st + i) ** 2)", "import sys, threading\nimport math\nfrom os import path\nfrom collections import deque, defaultdict, Counter\nfrom bisect import *\nfrom string import ascii_lowercase\nfrom functools import cmp_to_key\nfrom random import randint\nfrom heapq import *\nfrom array import array\nfrom types import GeneratorType\n\ndef readInts():\n    x = list(map(int, sys.stdin.readline().rstrip().split()))\n    return x[0] if len(x) == 1 else x\n\ndef readList(type=int):\n    x = sys.stdin.readline()\n    x = list(map(type, x.rstrip('\\n\\r').split()))\n    return x\n\ndef readStr():\n    x = sys.stdin.readline().rstrip('\\r\\n')\n    return x\nwrite = sys.stdout.write\nread = sys.stdin.readline\nMAXN = 1123456\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\nclass mydict:\n\n    def __init__(self, func=lambda : 0):\n        self.random = randint(0, 1 << 32)\n        self.default = func\n        self.dict = {}\n\n    def __getitem__(self, key):\n        mykey = self.random ^ key\n        if mykey not in self.dict:\n            self.dict[mykey] = self.default()\n        return self.dict[mykey]\n\n    def get(self, key, default):\n        mykey = self.random ^ key\n        if mykey not in self.dict:\n            return default\n        return self.dict[mykey]\n\n    def __setitem__(self, key, item):\n        mykey = self.random ^ key\n        self.dict[mykey] = item\n\n    def getkeys(self):\n        return [self.random ^ i for i in self.dict]\n\n    def __str__(self):\n        return f'{[(self.random ^ i, self.dict[i]) for i in self.dict]}'\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\ndef mod(n):\n    return n % 1000000007\n\ndef upper_bound(a, num):\n    l = 0\n    r = len(a) - 1\n    ans = -1\n    while l <= r:\n        mid = (l + r) // 2\n        if a[mid] >= num:\n            ans = mid\n            r = mid - 1\n        else:\n            l = mid + 1\n    return ans\n\ndef croot(num):\n    l = 0\n    r = num\n    ans = l\n    while l <= r:\n        mid = (l + r) // 2\n        if mid * mid * mid == num:\n            return mid\n        if mid * mid * mid <= num:\n            ans = mid\n            l = mid + 1\n        else:\n            r = mid - 1\n    return ans\n\ndef sqr(num):\n    l = 0\n    r = num\n    ans = l\n    while l <= r:\n        mid = (l + r) // 2\n        if mid * mid <= num:\n            ans = mid\n            l = mid + 1\n        else:\n            r = mid - 1\n    return ans\n\ndef solve(t):\n    x = readInts()\n    l = x\n    r = 2 * x\n    ans = x\n    while l <= r:\n        mid = (l + r) // 2\n        sq = mid * mid\n        cu = int(math.pow(sq, 1 / 3))\n        if (cu + 1) ** 3 == sq:\n            cu += 1\n        dif = mid - cu\n        if dif >= x:\n            r = mid - 1\n            ans = sq\n        else:\n            l = mid + 1\n    print(ans)\n\ndef main():\n    t = 1\n    if path.exists('/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/input.txt'):\n        sys.stdin = open('/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/input.txt', 'r')\n        sys.stdout = open('/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/output.txt', 'w')\n    t = readInts()\n    for i in range(t):\n        solve(i + 1)\nmain()", "for _ in range(int(input())):\n    X = int(input())\n    x = pow(X, 2)\n    y = int(pow(x, 1 / 3))\n    dif = y\n    z = X\n    while dif > 0:\n        z += dif\n        x = pow(z, 2)\n        y = int(pow(z, 2 / 3))\n        if pow(y + 1, 3) - x < 1:\n            y += 1\n        dif = X - z + y\n    print(x)", "import string\nfrom functools import lru_cache\nimport atexit, io\nimport sys\nfrom math import log2\nimport math\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right, insort\nfrom math import gcd\nfrom math import sqrt\nfrom collections import Counter, defaultdict\nfrom heapq import heappush, heappop, heapify\nimport heapq\n\nclass FenwickTree:\n\n    def __init__(self, n):\n        self.farr = [0] * (n + 1)\n\n    def prefixSum(self, idx):\n        s = 0\n        while idx > 0:\n            s += self.farr[idx]\n            idx -= idx & -idx\n        return s\n\n    def update(self, idx, val):\n        while idx < len(self.farr):\n            self.farr[idx] += val\n            idx += idx & -idx\n\n    def find(self, k):\n        curr = 0\n        ans = 0\n        prevSum = 0\n        for i in range(log2(n), -1, -1):\n            if self.farr[curr + (i << i)] + prevSum < k:\n                curr += 1 << i\n                prevSum += self.farr[curr]\n        return curr + 1\n\nclass Trie(object):\n\n    def __init__(self):\n        self.trie = {}\n\n    def insert(self, word):\n        t = self.trie\n        for c in word:\n            if c not in t:\n                t[c] = {}\n            t = t[c]\n        t['-'] = True\n\n    def search(self, word):\n        t = self.trie\n        for c in word:\n            if c not in t:\n                return False\n            t = t[c]\n        return '-' in t\n\n    def startsWith(self, prefix):\n        t = self.trie\n        for c in prefix:\n            if c not in t:\n                return False\n            t = t[c]\n        return True\n\n    def query(self, word):\n        ans = 0\n        t = self.trie\n        for i in word:\n            if i not in t:\n                break\n            ans += 1\n            t = t[i]\n        return ans\n\nclass FenvTree:\n\n    def __init__(self, arr):\n        arr.insert(0, 0)\n        self.farr = [0]\n        prefix = [0]\n        for i in arr[1:]:\n            prefix.append(prefix[-1] + i)\n        for i in range(1, len(arr)):\n            idash = i - (i & -i)\n            self.farr.append(prefix[i] - prefix[idash])\n\n    def query(self, l, r):\n        return self.prefixSum(r) - self.prefixSum(l - 1)\n\n    def prefixSum(self, idx):\n        s = 0\n        while idx > 0:\n            s += self.farr[idx]\n            idx -= idx & -idx\n        return s\n\n    def update(self, idx, val):\n        while idx < len(self.farr):\n            self.farr[idx] += val\n            idx += idx & -idx\n\nclass DSU:\n\n    def __init__(self, n):\n        self.parent = []\n        self.size = []\n        for i in range(n + 1):\n            self.parent.append(i)\n            self.size.append(1)\n\n    def union(self, u, v):\n        pu = self.findPar(u)\n        pv = self.findPar(v)\n        if pu == pv:\n            return\n        if self.size[pu] < self.size[pv]:\n            self.parent[pu] = pv\n            self.size[pv] += self.size[pu]\n        else:\n            self.parent[pv] = pu\n            self.size[pu] += self.size[pv]\n\n    def unionByRank(self, u, v):\n        pu = self.findPar(u)\n        pv = self.findPar(v)\n        if pu == pv:\n            return\n        if self.rank[pu] < self.rank[pv]:\n            self.parent[pu] = pv\n        elif self.rank[pv] < self.rank[pu]:\n            self.parent[pv] = pu\n        else:\n            self.parent[pu] = pv\n            self.rank[pv] += 1\n\n    def findPar(self, node):\n        if self.parent[node] == node:\n            return node\n        self.parent[node] = self.findPar(self.parent[node])\n        return self.parent[node]\n\nclass info:\n\n    def __init__(self, _open=0, _close=0, _full=0):\n        self.open = _open\n        self.close = _close\n        self.full = _full\n\nclass SGTree:\n\n    def __init__(self, n):\n        self.seg = [0 for _ in range(4 * n)]\n\n    def build(self, ind, low, high, arr):\n        if low == high:\n            self.seg[ind] = arr[low]\n            return\n        mid = (low + high) // 2\n        self.build(2 * ind + 1, low, mid, arr)\n        self.build(2 * ind + 2, mid + 1, high, arr)\n        self.seg[ind] = min(self.seg[2 * ind + 1], self.seg[2 * ind + 2])\n\n    def query(self, ind, low, high, l, r):\n        if r < low or l > high:\n            return sys.maxsize\n        if low <= l and r >= high:\n            return self.seg[ind]\n        mid = low + high >> 1\n        left = self.query(2 * ind + 1, 0, mid, l, r)\n        right = self.query(2 * ind + 2, mid + 1, high, l, r)\n        return min(left, right)\n\n    def update(self, ind, low, high, i, val):\n        if low == high:\n            self.seg = val\n            return\n        mid = low + high >> 1\n        if i <= mid:\n            self.update(2 * ind + 1, low, mid, i, val)\n        else:\n            self.update(2 * ind + 1, mid + 1, high, i, val)\n        self.seg[ind] = min(self.seg[2 * ind + 1], self.seg[2 * ind + 2])\n\ndef isPalindrome(s):\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef IntList():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef getInts():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef getStrs():\n    return sys.stdin.readline().strip()\n\ndef StrList():\n    list(sys.stdin.readline().strip())\n\ndef FloatList():\n    lis = input().split()\n    lis = list(map(float, lis))\n    return lis\n\ndef SieveOfEratosthenes(n, isPrime):\n    isPrime[0] = isPrime[1] = False\n    for i in range(2, n + 1):\n        isPrime[i] = True\n    p = 2\n    while p * p <= n:\n        if isPrime[p]:\n            i = p * p\n            while i <= n:\n                isPrime[i] = False\n                i += p\n        p += 1\n\ndef findPrimePair(n):\n    isPrime = [0] * (n + 1)\n    SieveOfEratosthenes(n, isPrime)\n    for i in range(0, n):\n        if isPrime[i] and isPrime[n - i]:\n            print(i, n - i)\n            return\n\ndef query(ind, low, high, l, r, seg):\n    if r < low or l > high:\n        return info()\n    if low <= l and r >= high:\n        return self.seg[ind]\n    mid = low + high >> 1\n    left = self.query(2 * ind + 1, 0, mid, l, r, seg)\n    right = self.query(2 * ind + 2, mid + 1, high, l, r, seg)\n    return merge(left, right)\n\ndef merge(left, right):\n    ans = info()\n    ans.full = left.full + right.full + min(left.open, right.close)\n    ans.open = left.open + right.open + min(left.open, right.close)\n    ans.close = left.close + right.close + min(left.open, right.close)\n    return ans\n\ndef build(ind, low, high, s, seg):\n    if low == high:\n        seg[ind] = info(s[low] == '(', s[low] == ')', 0)\n        return\n    mid = (low + high) // 2\n    build(2 * ind + 1, low, mid, s, seg)\n    build(2 * ind + 2, mid + 1, high, s, seg)\n    seg[ind] = merge(seg[2 * ind + 1], seg[2 * ind + 2])\n\ndef countN(lis):\n    ans = 0\n    cnt = 0\n    for i in range(len(lis) - 1, -1, -1):\n        if lis[i] == 0:\n            cnt += 1\n        else:\n            ans += cnt\n    return ans\n\nclass Pair:\n\n    def __init__(self, x, y, gcd):\n        self.x = x\n        self.y = y\n        self.gcd = gcd\n\ndef Euclidean(a, b):\n    if b == 0:\n        return Pair(1, 0, a)\n    dash = Euclidean(b, a % b)\n    return Pair(dash.y, dash.x - a // b * dash.y, dash.gcd)\n\ndef chineseRemainder(a1, n1, a2, n2):\n    p = Euclidean(n1, n2)\n    x = p.x\n    gcd = p.gcd\n    if (a1 - a2) % gcd:\n        return -1\n    k = (a1 - a2) // gcd\n    a = a1 - n1 * (k * x % n2 // gcd)\n    lcm = n1 * n2 // gcd\n    if a < 0:\n        a += lcm\n    return a\nmdd = 998244353\n\ndef ncr(n, k, md):\n    mod = 998244353\n    tab = [[0 for _ in range(k + 1)] for i in range(n + 1)]\n    for i in range(1, len(tab)):\n        tab[i][0] = 1\n    for i in range(1, len(tab)):\n        for j in range(1, min(i + 1, len(tab[0]))):\n            if i == 1 and j == 1:\n                tab[i][j] = 1\n            else:\n                tab[i][j] = (tab[i - 1][j] + tab[i - 1][j - 1]) % mod\n    return tab\n\ndef repeat(i, j, arr):\n    if i > j:\n        return\n    cnt1 = i\n    cnt2 = j\n    while cnt1 < cnt2:\n        (arr[cnt1], arr[cnt2]) = (arr[cnt2], arr[cnt1])\n        cnt1 += 1\n        cnt2 -= 1\n    if i - 1 >= 0:\n        ele = arr[i - 1]\n        if ele > 0:\n            s = int(sqrt(ele - 1)) + 1\n            first = s * s - ele\n            repeat(first, i - 1, arr)\n    return\nspf = []\n\ndef makeSeive(n):\n    for i in range(n + 1):\n        spf.append(i)\n\ndef seive(n):\n    s = int(sqrt(n + 1))\n    for i in range(2, s + 1):\n        if spf[i] == i:\n            for j in range(i * i, n + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = set()\n    while x != 1:\n        ret.add(spf[x])\n        x = x // spf[x]\n    return ret\n\ndef zFunc(patt, txt):\n    st = patt + '#' + txt\n    zArray = [0 for _ in range(len(st))]\n    l = 0\n    r = 0\n    for i in range(1, len(st)):\n        if r >= i:\n            zArray[i] = min(r - i + 1, zArray[i - l])\n        while i + zArray[i] < len(st) and st[zArray[i]] == st[zArray[i] + i]:\n            zArray[i] += 1\n        if zArray[i] + i - 1 > r:\n            l = i\n            r = i + zArray[i] - 1\n    return zArray.count(len(patt))\n\ndef kmp(txt, patt):\n    newString = patt + '#' + txt\n    freqCount = 0\n    freqArray = [0 for _ in range(len(newString))]\n    i = 1\n    length = 0\n    while i < len(newString):\n        if newString[i] == newString[length]:\n            length += 1\n            freqArray[i] = length\n            i += 1\n        elif length > 0:\n            length = freqArray[length - 1]\n        else:\n            freqArray[i] = 0\n            i += 1\n    for i in freqArray:\n        if i == len(patt):\n            freqCount += 1\n    return freqCount\n\ndef getLPS(s):\n    st = '@#' + '#'.join(s) + '#&'\n    c = 0\n    r = 0\n    lps = [0] * len(st)\n    for i in range(1, len(st) - 1):\n        mirror = c - (i - c)\n        if i < r and mirror >= 0:\n            lps[i] = min(lps[mirror], r - i)\n        while st[i + lps[i] + 1] == st[i - lps[i] - 1]:\n            lps[i] += 1\n        if i + lps[i] > r:\n            r = i + lps[i]\n            c = i\n    return max(lps)\nfact = [1 for _ in range(100002)]\nmod = 10 ** 9 + 7\n\ndef getFact(n):\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n\ndef getInv(word):\n    num = math.factorial(len(word))\n    for v in Counter(word).values():\n        num = num * pow(math.factorial(v), mod - 2, mod) % mod\n    return int(num) % (10 ** 9 + 7)\n\ndef subarrayXor(arr, n, m):\n    HashTable = defaultdict(bool)\n    HashTable[0] = 1\n    count = 0\n    curSum = 0\n    for i in arr:\n        curSum ^= i\n        if HashTable[curSum ^ m]:\n            count += HashTable[curSum ^ m]\n        HashTable[curSum] += 1\n    return count\n\ndef get2dPrefixSum(matrix, mid=0):\n    n = len(matrix)\n    m = len(matrix[0])\n    prefix = [[0 for _ in range(m + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n    return prefix\n\ndef get2dPrefixSumCnt(matrix, mid=0):\n    n = len(matrix)\n    m = len(matrix[0])\n    prefix = [[0 for _ in range(m + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n    return prefix\n\ndef getSumRange(r1, c1, r2, c2, prefix):\n    cnt = prefix[r2][c2] - prefix[r2][c1 - 1] - prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1]\n    return cnt\n\ndef getPrefix(arr):\n    prefix = [0]\n    for i in arr:\n        prefix.append(prefix[-1] + i)\n    return prefix\n\ndef getInv(arr):\n    cnt = 0\n    ans = []\n    for i in arr:\n        ind = bisect_right(ans, i)\n        cnt += len(ans) - ind\n        insort(ans, i)\n    return cnt\nM = 10 ** 5\n\ndef getFactors(x):\n    temp = []\n    k = 1\n    while k * k <= x:\n        if x % k == 0:\n            temp.append(k)\n            if k * k != x:\n                temp.append(x // k)\n        k += 1\n    return temp\n\ndef grayCode(n):\n    if not n:\n        return [0]\n    res = [0, 1]\n    for i in range(2, n + 1):\n        for j in range(len(res) - 1, -1, -1):\n            res.append(res[j] | 1 << i - 1)\n    return res\n\ndef threeSum(nums, target):\n    ans = -1\n    d = dict()\n    for (i, j) in enumerate(nums):\n        d[j] = i + 1\n    nums.sort()\n    for i in range(len(nums) - 2):\n        low = i + 1\n        high = len(nums) - 1\n        while low < high:\n            s = nums[i] + nums[low] + nums[high]\n            if s == target:\n                print(d[nums[low]], d[nums[high]], d[nums[i]])\n                return\n                low += 1\n                high -= 1\n            elif s < 0:\n                low = low + 1\n            else:\n                high -= 1\n    print('IMPOSSIBLE')\n    return\n\ndef FuckCF():\n    n = int(input())\n\n    def solve(x):\n        low = 0\n        high = 10 ** 8\n        while low + 1 < high:\n            mid = (low + high) // 2\n            cube = mid * mid * mid\n            if cube > x:\n                high = mid\n            else:\n                low = mid\n        return low\n    val = n\n    sqr = val * val\n    while val - solve(sqr) < n:\n        sqr = val * val\n        val = n + solve(sqr)\n        sqr = val * val\n    print(val * val)\nt = 1\nt = int(input())\nfor i in range(t):\n    FuckCF()", "for _ in range(int(input())):\n    X = int(input())\n    x = pow(X, 2)\n    y = int(pow(x, 1 / 3))\n    dif = y\n    z = X\n    while dif > 0:\n        z += dif\n        x = pow(z, 2)\n        y = int(pow(z, 2 / 3))\n        if pow(y + 1, 3) - x < 1:\n            y += 1\n        dif = X - z + y\n    print(x)", "def find(n):\n    l = 0\n    r = 3 * 10 ** 6\n    while r - l > 1:\n        mid = (l + r) // 2\n        if mid ** 3 > n:\n            r = mid\n        else:\n            l = mid\n    return l\n\ndef main():\n    x = int(input())\n    n = x\n    while n - find(n ** 2) < x:\n        curr = n ** 2\n        cr = find(curr)\n        n = x + cr\n    return n ** 2\nfor _ in range(int(input())):\n    print(main())", "import math\n\ndef find(n):\n    s = 0\n    e = int(3000000.0)\n    while e - s > 1:\n        mid = (s + e) // 2\n        if mid ** 3 > n:\n            e = mid\n        else:\n            s = mid\n    return s\nfor _ in range(int(input())):\n    x = int(input())\n    n = x\n    while n - find(n * n) < x:\n        square = n * n\n        cube = find(square)\n        n = x + cube\n    print(n * n)", "def find(n):\n    (start, end) = (0, int(3000000.0))\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid * mid * mid > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num * num) < x:\n        tmp = num * num\n        cbs = find(tmp)\n        num = x + cbs\n    print(num * num)\nT = int(input())\nfor _ in range(T):\n    solve()", "import math\n\ndef solution(x):\n    n = x\n    count = x - math.floor(math.pow(n ** 2, 1 / 3))\n    while count < x and count > -2:\n        inc = x - count\n        n += inc\n        cubes = math.ceil(math.pow(n ** 2, 1 / 3))\n        if cubes ** 3 > n ** 2:\n            cubes -= 1\n        count = n - cubes\n    return n ** 2\n\ndef main():\n    cases = int(input())\n    for _ in range(cases):\n        x = int(input())\n        ans = solution(x)\n        print(ans)\nmain()", "def find(n):\n    (start, end) = (0, int(3000000.0))\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid * mid * mid > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num * num) < x:\n        tmp = num * num\n        cbs = find(tmp)\n        num = x + cbs\n    print(num * num)\nT = int(input())\nfor _ in range(T):\n    solve()", "import math\n\ndef countCubes(n):\n    l = 1\n    r = 1000000000\n    while r > l + 1:\n        mid = (l + r) // 2\n        val = mid * mid * mid\n        if val > n:\n            r = mid\n        else:\n            l = mid\n    return l\n\ndef CountSquares(a, b):\n    return math.floor(math.sqrt(b)) - math.ceil(math.sqrt(a)) + 1\nfor _ in range(int(input())):\n    n = int(input())\n    c = n\n    while c - countCubes(c * c) < n:\n        val = c * c\n        c = n + countCubes(val)\n    print(c * c)", "import math\n\ndef find(n):\n    (start, end) = (0, int(3000000.0))\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid * mid * mid > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num * num) < x:\n        tmp = num * num\n        cbs = find(tmp)\n        num = x + cbs\n    print(num * num)\nT = int(input())\nfor _ in range(T):\n    solve()", "def check(k, x):\n    return (k - x + 1) ** 3 > k ** 2\n\ndef solve():\n    l = 0\n    r = 100000000000\n    x = int(input())\n    while l < r:\n        m = (l + r) // 2\n        if check(m, x):\n            r = m\n        else:\n            l = m + 1\n    print(l * l)\nT = int(input())\nfor t in range(0, T):\n    solve()", "def find(n):\n    (start, end) = (0, 3000000)\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid ** 3 > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num ** 2) < x:\n        tmp = num ** 2\n        cbs = find(tmp)\n        num = x + cbs\n    print(num ** 2)\nT = int(input())\nfor _ in range(T):\n    solve()", "def find(n):\n    (start, end) = (0, int(3000000.0))\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid * mid * mid > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num * num) < x:\n        tmp = num * num\n        cbs = find(tmp)\n        num = x + cbs\n    print(num * num)\nT = int(input())\nfor i in range(T):\n    solve()", "import math\n\ndef find(n):\n    (start, end) = (0, int(3000000.0))\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid * mid * mid > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num * num) < x:\n        tmp = num * num\n        cbs = find(tmp)\n        num = x + cbs\n    print(num * num)\nT = int(input())\nfor _ in range(T):\n    solve()", "def find_largest_y(n):\n    (lower_bound, upper_bound) = (0, int(3000000.0))\n    while upper_bound - lower_bound > 1:\n        middle = (lower_bound + upper_bound) // 2\n        if middle * middle * middle > n:\n            upper_bound = middle\n        else:\n            lower_bound = middle\n    return lower_bound\n\ndef solve_problem():\n    input_num = int(input())\n    current_num = input_num\n    while current_num - find_largest_y(current_num * current_num) < input_num:\n        current_squared = current_num * current_num\n        current_best_y = find_largest_y(current_squared)\n        current_num = input_num + current_best_y\n    print(current_num * current_num)\nnum_test_cases = int(input())\nfor i in range(num_test_cases):\n    solve_problem()", "from math import isqrt\n\ndef find(n):\n    (s, e) = (0, 3000000)\n    while e - s > 1:\n        mm = (s + e) // 2\n        if mm * mm * mm > n:\n            e = mm\n        else:\n            s = mm\n    return s\n\ndef solve():\n    x = int(input())\n    nn = x\n    while nn - find(nn * nn) < x:\n        tmp = nn * nn\n        cbs = find(tmp)\n        nn = x + cbs\n    print(nn * nn)\nT = int(input())\nfor _ in range(T):\n    solve()", "import math\nimport random\nimport statistics\nimport operator\nimport itertools\nimport sys\nimport copy\nfrom collections import defaultdict, Counter, deque, OrderedDict\nfrom heapq import heapify, heappush, heappop\nfrom functools import lru_cache, reduce\nfrom bisect import bisect_left, bisect_right\nKPMOD1 = 1000000007\nKPMOD2 = 998244353\n\ndef modinverse(a, mod):\n    return binpow(a, mod - 2)\n\ndef mult(a, b):\n    return a % KPMOD1 * (b % KPMOD1) % KPMOD1\n\ndef add(a, b):\n    return (a % KPMOD1 + b % KPMOD1) % KPMOD1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    res = binpow(a, b // 2) % KPMOD1\n    if b % 2:\n        return res * res * a % KPMOD1\n    else:\n        return res * res % KPMOD1\n\ndef fact(a):\n    if a == 0 or a == 1:\n        return 1\n    return a * (fact(a) % KPMOD1) % KPMOD1\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef isPrime(n):\n    if n == 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\nMAX = 100\nfact = [1] * MAX\ninvfact = [1] * MAX\nfor i in range(1, MAX):\n    fact[i] = fact[i - 1] * i % KPMOD1\n    invfact[i] = invfact[i - 1] * modinverse(i, KPMOD1) % KPMOD1\n\ndef factors(n):\n    if n == 0:\n        return set()\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\ndef findans(val):\n    (KPS, KPE) = (0, 3000000)\n    while KPE - KPS > 1:\n        KPM = (KPS + KPE) // 2\n        if KPM * KPM * KPM > val:\n            KPE = KPM\n        else:\n            KPS = KPM\n    return KPS\nfor _ in range(int(input())):\n    KPN = int(input())\n    KPX = KPN\n    while KPX - findans(KPX * KPX) < KPN:\n        KPT = KPX * KPX\n        KPC = findans(KPT)\n        KPX = KPN + KPC\n    print(KPX * KPX)", "def find(n):\n    (start, end) = (0, int(3000000.0))\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid * mid * mid > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num * num) < x:\n        tmp = num * num\n        cbs = find(tmp)\n        num = x + cbs\n    print(num * num)\nT = int(input())\nfor _ in range(T):\n    solve()", "import math\nt = int(input())\nfor i in range(0, t):\n    n = int(input())\n    res = n\n    num = res - int(1e-07 + math.pow(res, 2 / 3))\n    l = 1000\n    while num != n and l > 0:\n        l -= 1\n        num = res - int(1e-07 + math.pow(res, 2 / 3))\n        if num < n:\n            res += n - num\n        elif num > n:\n            res -= n - num\n    while res - 1 - int(1e-07 + math.pow(res - 1, 2 / 3)) == n:\n        res -= 1\n    print(res ** 2)", "import math\n\ndef find(n):\n    (start, end) = (0, int(3000000.0))\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid ** 3 > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num ** 2) < x:\n        tmp = num ** 2\n        cbs = find(tmp)\n        num = x + cbs\n    print(num ** 2)\nT = int(input())\nfor _ in range(T):\n    solve()", "from typing import List\n\ndef find(n: int) -> int:\n    start = 0\n    end = 3000000\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid * mid * mid > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve() -> None:\n    x = int(input())\n    num = x\n    while num - find(num * num) < x:\n        tmp = num * num\n        cbs = find(tmp)\n        num = x + cbs\n    print(num * num)\nT = int(input())\nwhile T > 0:\n    solve()\n    T -= 1", "import math\n\ndef binarytemp(n):\n    l = 0\n    r = 3 * 10 ** 6\n    while r - l > 1:\n        mid = (r + l) // 2\n        if mid ** 3 <= n:\n            l = mid\n        else:\n            r = mid\n    return l\n\ndef s1():\n    n = int(input())\n    a = list(range(1, n // 2 + 1))[::-1]\n    b = list(range(n // 2 + 1, n + 1))\n    a.extend(b)\n    print(*a)\n\ndef haikuru():\n    (n, m, q) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    for ele in arr:\n        stringfortester = ''\n        listerposter = []\n        parsertomorrow = 0\n        while parsertomorrow < n:\n            if ele > parsertomorrow:\n                ele -= parsertomorrow + 1\n            else:\n                break\n            parsertomorrow += 1\n        print(1, parsertomorrow)\n        while parsertomorrow >= 1:\n            listerposter.append(min(ele // parsertomorrow, m - 1))\n            ele -= listerposter[-1] * parsertomorrow\n            parsertomorrow -= 1\n        for i in listerposter[::-1]:\n            stringfortester += str(i + 1) + ' '\n        print(stringfortester)\ntres = int(input())\nfor _ in range(tres):\n    x = int(input())\n    n = x\n    while n - binarytemp(n ** 2) < x:\n        heck = binarytemp(n ** 2)\n        n = x + heck\n    print(n ** 2)", "from bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nfrom math import floor\nimport time\ncub = []\nfor x in range(1, 1100000):\n    cub.append(x ** 3)\nfun = lambda x: x - bisect_right(cub, x * x)\nfor cc in range(int(input())):\n    x = int(input())\n    (left, right) = (1, 10 ** 10)\n    while left < right:\n        mid = (left + right) // 2\n        if x <= fun(mid):\n            right = mid\n        else:\n            left = mid + 1\n    print(left * left)", "def find_cube_root(n):\n    a = 0\n    b = 3 * 10 ** 6\n    while b - a > 1:\n        m = (a + b) // 2\n        if m ** 3 > n:\n            b = m\n        else:\n            a = m\n    return a\nnum_tests = int(input())\nfor i in range(num_tests):\n    x = int(input())\n    num = x\n    while num - find_cube_root(num * num) < x:\n        tmp = num * num\n        cbrt = find_cube_root(tmp)\n        num = x + cbrt\n    print(num * num)", "import math\nt = int(input())\nwhile t > 0:\n    x = int(input())\n    start = x\n    end = 10 ** 10\n    mid = (start + end) // 2\n    ans = 10 ** 20\n    while start <= end:\n        sq = mid\n        zz = mid * mid\n        cb = int(zz ** (1 / 3))\n        val = cb + 1\n        val = val ** 3\n        if val == zz:\n            cb += 1\n        dif = sq - cb\n        if dif >= x:\n            ans = min(ans, zz)\n            end = mid - 1\n            mid = (start + end) // 2\n        else:\n            start = mid + 1\n            mid = (start + end) // 2\n    print(ans)\n    t -= 1", "def find(n):\n    (start, end) = (0, 3000000)\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid * mid * mid > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num * num) < x:\n        tmp = num * num\n        cbs = find(tmp)\n        num = x + cbs\n    print(num * num)\nT = int(input())\nfor _ in range(T):\n    solve()", "def find(n):\n    (s, e) = (0, 3000000)\n    while e - s > 1:\n        m = (s + e) // 2\n        if m ** 3 > n:\n            e = m\n        else:\n            s = m\n    return s\n\ndef solve():\n    num = int(input())\n    num1 = num\n    while num1 - find(num1 ** 2) < num:\n        temp = num1 ** 2\n        cbs = find(temp)\n        num1 = num + cbs\n    print(num1 ** 2)\nT = int(input())\nfor _ in range(T):\n    solve()", "import numpy as np\nimport math\n\ndef cuberoot(p):\n    ans = p ** (1 / 3)\n    x = round(ans)\n    if x * x * x == p:\n        return x\n    else:\n        return ans\nt = int(input())\nwhile t != 0:\n    x = int(input())\n    r = 10000000000\n    l = 1\n    ans = 0\n    while l <= r:\n        mid = (l + r) // 2\n        sq = mid * mid\n        sc = mid\n        cc = math.floor(cuberoot(sq))\n        dif = sc - cc\n        if dif >= x:\n            ans = mid\n            r = mid - 1\n        else:\n            l = mid + 1\n    print(ans * ans)\n    t = t - 1", "def find(n):\n    start = 0\n    end = 3000000\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid ** 3 > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num ** 2) < x:\n        tmp = num ** 2\n        cbs = find(tmp)\n        num = x + cbs\n    print(num ** 2)\nT = int(input())\nfor i in range(T):\n    solve()", "import string\nfrom functools import lru_cache\nimport atexit, io\nimport sys\nfrom math import log2\nimport math\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right, insort\nfrom math import gcd\nfrom math import sqrt\nfrom collections import Counter, defaultdict\nfrom heapq import heappush, heappop, heapify\nimport heapq\n\nclass FenwickTree:\n\n    def __init__(self, n):\n        self.farr = [0] * (n + 1)\n\n    def prefixSum(self, idx):\n        s = 0\n        while idx > 0:\n            s += self.farr[idx]\n            idx -= idx & -idx\n        return s\n\n    def update(self, idx, val):\n        while idx < len(self.farr):\n            self.farr[idx] += val\n            idx += idx & -idx\n\n    def find(self, k):\n        curr = 0\n        ans = 0\n        prevSum = 0\n        for i in range(log2(n), -1, -1):\n            if self.farr[curr + (i << i)] + prevSum < k:\n                curr += 1 << i\n                prevSum += self.farr[curr]\n        return curr + 1\n\nclass Trie(object):\n\n    def __init__(self):\n        self.trie = {}\n\n    def insert(self, word):\n        t = self.trie\n        for c in word:\n            if c not in t:\n                t[c] = {}\n            t = t[c]\n        t['-'] = True\n\n    def search(self, word):\n        t = self.trie\n        for c in word:\n            if c not in t:\n                return False\n            t = t[c]\n        return '-' in t\n\n    def startsWith(self, prefix):\n        t = self.trie\n        for c in prefix:\n            if c not in t:\n                return False\n            t = t[c]\n        return True\n\n    def query(self, word):\n        ans = 0\n        t = self.trie\n        for i in word:\n            if i not in t:\n                break\n            ans += 1\n            t = t[i]\n        return ans\n\nclass FenvTree:\n\n    def __init__(self, arr):\n        arr.insert(0, 0)\n        self.farr = [0]\n        prefix = [0]\n        for i in arr[1:]:\n            prefix.append(prefix[-1] + i)\n        for i in range(1, len(arr)):\n            idash = i - (i & -i)\n            self.farr.append(prefix[i] - prefix[idash])\n\n    def query(self, l, r):\n        return self.prefixSum(r) - self.prefixSum(l - 1)\n\n    def prefixSum(self, idx):\n        s = 0\n        while idx > 0:\n            s += self.farr[idx]\n            idx -= idx & -idx\n        return s\n\n    def update(self, idx, val):\n        while idx < len(self.farr):\n            self.farr[idx] += val\n            idx += idx & -idx\n\nclass DSU:\n\n    def __init__(self, n):\n        self.parent = []\n        self.size = []\n        for i in range(n + 1):\n            self.parent.append(i)\n            self.size.append(1)\n\n    def union(self, u, v):\n        pu = self.findPar(u)\n        pv = self.findPar(v)\n        if pu == pv:\n            return\n        if self.size[pu] < self.size[pv]:\n            self.parent[pu] = pv\n            self.size[pv] += self.size[pu]\n        else:\n            self.parent[pv] = pu\n            self.size[pu] += self.size[pv]\n\n    def unionByRank(self, u, v):\n        pu = self.findPar(u)\n        pv = self.findPar(v)\n        if pu == pv:\n            return\n        if self.rank[pu] < self.rank[pv]:\n            self.parent[pu] = pv\n        elif self.rank[pv] < self.rank[pu]:\n            self.parent[pv] = pu\n        else:\n            self.parent[pu] = pv\n            self.rank[pv] += 1\n\n    def findPar(self, node):\n        if self.parent[node] == node:\n            return node\n        self.parent[node] = self.findPar(self.parent[node])\n        return self.parent[node]\n\nclass info:\n\n    def __init__(self, _open=0, _close=0, _full=0):\n        self.open = _open\n        self.close = _close\n        self.full = _full\n\nclass SGTree:\n\n    def __init__(self, n):\n        self.seg = [0 for _ in range(4 * n)]\n\n    def build(self, ind, low, high, arr):\n        if low == high:\n            self.seg[ind] = arr[low]\n            return\n        mid = (low + high) // 2\n        self.build(2 * ind + 1, low, mid, arr)\n        self.build(2 * ind + 2, mid + 1, high, arr)\n        self.seg[ind] = min(self.seg[2 * ind + 1], self.seg[2 * ind + 2])\n\n    def query(self, ind, low, high, l, r):\n        if r < low or l > high:\n            return sys.maxsize\n        if low <= l and r >= high:\n            return self.seg[ind]\n        mid = low + high >> 1\n        left = self.query(2 * ind + 1, 0, mid, l, r)\n        right = self.query(2 * ind + 2, mid + 1, high, l, r)\n        return min(left, right)\n\n    def update(self, ind, low, high, i, val):\n        if low == high:\n            self.seg = val\n            return\n        mid = low + high >> 1\n        if i <= mid:\n            self.update(2 * ind + 1, low, mid, i, val)\n        else:\n            self.update(2 * ind + 1, mid + 1, high, i, val)\n        self.seg[ind] = min(self.seg[2 * ind + 1], self.seg[2 * ind + 2])\n\ndef isPalindrome(s):\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef IntList():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef getInts():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef getStrs():\n    return sys.stdin.readline().strip()\n\ndef StrList():\n    list(sys.stdin.readline().strip())\n\ndef FloatList():\n    lis = input().split()\n    lis = list(map(float, lis))\n    return lis\n\ndef SieveOfEratosthenes(n, isPrime):\n    isPrime[0] = isPrime[1] = False\n    for i in range(2, n + 1):\n        isPrime[i] = True\n    p = 2\n    while p * p <= n:\n        if isPrime[p]:\n            i = p * p\n            while i <= n:\n                isPrime[i] = False\n                i += p\n        p += 1\n\ndef findPrimePair(n):\n    isPrime = [0] * (n + 1)\n    SieveOfEratosthenes(n, isPrime)\n    for i in range(0, n):\n        if isPrime[i] and isPrime[n - i]:\n            print(i, n - i)\n            return\n\ndef query(ind, low, high, l, r, seg):\n    if r < low or l > high:\n        return info()\n    if low <= l and r >= high:\n        return self.seg[ind]\n    mid = low + high >> 1\n    left = self.query(2 * ind + 1, 0, mid, l, r, seg)\n    right = self.query(2 * ind + 2, mid + 1, high, l, r, seg)\n    return merge(left, right)\n\ndef merge(left, right):\n    ans = info()\n    ans.full = left.full + right.full + min(left.open, right.close)\n    ans.open = left.open + right.open + min(left.open, right.close)\n    ans.close = left.close + right.close + min(left.open, right.close)\n    return ans\n\ndef build(ind, low, high, s, seg):\n    if low == high:\n        seg[ind] = info(s[low] == '(', s[low] == ')', 0)\n        return\n    mid = (low + high) // 2\n    build(2 * ind + 1, low, mid, s, seg)\n    build(2 * ind + 2, mid + 1, high, s, seg)\n    seg[ind] = merge(seg[2 * ind + 1], seg[2 * ind + 2])\n\ndef countN(lis):\n    ans = 0\n    cnt = 0\n    for i in range(len(lis) - 1, -1, -1):\n        if lis[i] == 0:\n            cnt += 1\n        else:\n            ans += cnt\n    return ans\n\nclass Pair:\n\n    def __init__(self, x, y, gcd):\n        self.x = x\n        self.y = y\n        self.gcd = gcd\n\ndef Euclidean(a, b):\n    if b == 0:\n        return Pair(1, 0, a)\n    dash = Euclidean(b, a % b)\n    return Pair(dash.y, dash.x - a // b * dash.y, dash.gcd)\n\ndef chineseRemainder(a1, n1, a2, n2):\n    p = Euclidean(n1, n2)\n    x = p.x\n    gcd = p.gcd\n    if (a1 - a2) % gcd:\n        return -1\n    k = (a1 - a2) // gcd\n    a = a1 - n1 * (k * x % n2 // gcd)\n    lcm = n1 * n2 // gcd\n    if a < 0:\n        a += lcm\n    return a\nmdd = 998244353\n\ndef ncr(n, k, md):\n    mod = 998244353\n    tab = [[0 for _ in range(k + 1)] for i in range(n + 1)]\n    for i in range(1, len(tab)):\n        tab[i][0] = 1\n    for i in range(1, len(tab)):\n        for j in range(1, min(i + 1, len(tab[0]))):\n            if i == 1 and j == 1:\n                tab[i][j] = 1\n            else:\n                tab[i][j] = (tab[i - 1][j] + tab[i - 1][j - 1]) % mod\n    return tab\n\ndef repeat(i, j, arr):\n    if i > j:\n        return\n    cnt1 = i\n    cnt2 = j\n    while cnt1 < cnt2:\n        (arr[cnt1], arr[cnt2]) = (arr[cnt2], arr[cnt1])\n        cnt1 += 1\n        cnt2 -= 1\n    if i - 1 >= 0:\n        ele = arr[i - 1]\n        if ele > 0:\n            s = int(sqrt(ele - 1)) + 1\n            first = s * s - ele\n            repeat(first, i - 1, arr)\n    return\nspf = []\n\ndef makeSeive(n):\n    for i in range(n + 1):\n        spf.append(i)\n\ndef seive(n):\n    s = int(sqrt(n + 1))\n    for i in range(2, s + 1):\n        if spf[i] == i:\n            for j in range(i * i, n + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = set()\n    while x != 1:\n        ret.add(spf[x])\n        x = x // spf[x]\n    return ret\n\ndef zFunc(patt, txt):\n    st = patt + '#' + txt\n    zArray = [0 for _ in range(len(st))]\n    l = 0\n    r = 0\n    for i in range(1, len(st)):\n        if r >= i:\n            zArray[i] = min(r - i + 1, zArray[i - l])\n        while i + zArray[i] < len(st) and st[zArray[i]] == st[zArray[i] + i]:\n            zArray[i] += 1\n        if zArray[i] + i - 1 > r:\n            l = i\n            r = i + zArray[i] - 1\n    return zArray.count(len(patt))\n\ndef kmp(txt, patt):\n    newString = patt + '#' + txt\n    freqCount = 0\n    freqArray = [0 for _ in range(len(newString))]\n    i = 1\n    length = 0\n    while i < len(newString):\n        if newString[i] == newString[length]:\n            length += 1\n            freqArray[i] = length\n            i += 1\n        elif length > 0:\n            length = freqArray[length - 1]\n        else:\n            freqArray[i] = 0\n            i += 1\n    for i in freqArray:\n        if i == len(patt):\n            freqCount += 1\n    return freqCount\n\ndef getLPS(s):\n    st = '@#' + '#'.join(s) + '#&'\n    c = 0\n    r = 0\n    lps = [0] * len(st)\n    for i in range(1, len(st) - 1):\n        mirror = c - (i - c)\n        if i < r and mirror >= 0:\n            lps[i] = min(lps[mirror], r - i)\n        while st[i + lps[i] + 1] == st[i - lps[i] - 1]:\n            lps[i] += 1\n        if i + lps[i] > r:\n            r = i + lps[i]\n            c = i\n    return max(lps)\nfact = [1 for _ in range(100002)]\nmod = 10 ** 9 + 7\n\ndef getFact(n):\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n\ndef getInv(word):\n    num = math.factorial(len(word))\n    for v in Counter(word).values():\n        num = num * pow(math.factorial(v), mod - 2, mod) % mod\n    return int(num) % (10 ** 9 + 7)\n\ndef subarrayXor(arr, n, m):\n    HashTable = defaultdict(bool)\n    HashTable[0] = 1\n    count = 0\n    curSum = 0\n    for i in arr:\n        curSum ^= i\n        if HashTable[curSum ^ m]:\n            count += HashTable[curSum ^ m]\n        HashTable[curSum] += 1\n    return count\n\ndef get2dPrefixSum(matrix, mid=0):\n    n = len(matrix)\n    m = len(matrix[0])\n    prefix = [[0 for _ in range(m + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n    return prefix\n\ndef get2dPrefixSumCnt(matrix, mid=0):\n    n = len(matrix)\n    m = len(matrix[0])\n    prefix = [[0 for _ in range(m + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n    return prefix\n\ndef getSumRange(r1, c1, r2, c2, prefix):\n    cnt = prefix[r2][c2] - prefix[r2][c1 - 1] - prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1]\n    return cnt\n\ndef getPrefix(arr):\n    prefix = [0]\n    for i in arr:\n        prefix.append(prefix[-1] + i)\n    return prefix\n\ndef getInv(arr):\n    cnt = 0\n    ans = []\n    for i in arr:\n        ind = bisect_right(ans, i)\n        cnt += len(ans) - ind\n        insort(ans, i)\n    return cnt\nM = 10 ** 5\n\ndef getFactors(x):\n    temp = []\n    k = 1\n    while k * k <= x:\n        if x % k == 0:\n            temp.append(k)\n            if k * k != x:\n                temp.append(x // k)\n        k += 1\n    return temp\n\ndef grayCode(n):\n    if not n:\n        return [0]\n    res = [0, 1]\n    for i in range(2, n + 1):\n        for j in range(len(res) - 1, -1, -1):\n            res.append(res[j] | 1 << i - 1)\n    return res\n\ndef threeSum(nums, target):\n    ans = -1\n    d = dict()\n    for (i, j) in enumerate(nums):\n        d[j] = i + 1\n    nums.sort()\n    for i in range(len(nums) - 2):\n        low = i + 1\n        high = len(nums) - 1\n        while low < high:\n            s = nums[i] + nums[low] + nums[high]\n            if s == target:\n                print(d[nums[low]], d[nums[high]], d[nums[i]])\n                return\n                low += 1\n                high -= 1\n            elif s < 0:\n                low = low + 1\n            else:\n                high -= 1\n    print('IMPOSSIBLE')\n    return\n\ndef FuckCF():\n    n = int(input())\n\n    def solve(x):\n        low = 0\n        high = 10 ** 8\n        while low + 1 < high:\n            mid = (low + high) // 2\n            cube = mid * mid * mid\n            if cube > x:\n                high = mid\n            else:\n                low = mid\n        return low\n    val = n\n    while val - solve(val * val) < n:\n        ans = val * val\n        val = n + solve(ans)\n    print(val * val)\nt = 1\nt = int(input())\nfor i in range(t):\n    FuckCF()", "import math\n\ndef find_cube_root(n):\n    start = 0\n    end = 10000000\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid ** 3 > n:\n            end = mid\n        else:\n            start = mid\n    return start\nt = int(input())\nwhile t:\n    x = int(input())\n    num = x\n    while num - find_cube_root(num ** 2) < x:\n        tmp = num ** 2\n        cbrt = find_cube_root(tmp)\n        num = x + cbrt\n    print(num ** 2)\n    t -= 1", "def find(n):\n    start = 0\n    end = 3000000\n    while end - start > 1:\n        mid = (start + end) // 2\n        if mid * mid * mid > n:\n            end = mid\n        else:\n            start = mid\n    return start\n\ndef solve():\n    x = int(input())\n    num = x\n    while num - find(num * num) < x:\n        tmp = num * num\n        cbs = find(tmp)\n        num = x + cbs\n    print(num * num)\nT = int(input())\nfor _ in range(T):\n    solve()", "from math import *\nt = int(input())\nfor _ in range(t):\n    x = int(input())\n    c = x\n    while True:\n        n = c ** 2\n        a = floor((n / 1) ** (1 / 3))\n        if (a + 1) * (a + 1) * (a + 1) <= n:\n            a += 1\n        if c - a >= x:\n            print(n)\n            break\n        c += x + a - c", "from sys import stdin, stdout\nfrom math import log, exp, sqrt, ceil\ninput = stdin.readline\nr_int = lambda : int(input())\nm_int = lambda : map(int, input().split())\nl_int = lambda : list(map(int, input().split()))\n\ndef cbrt(x):\n    return exp(log(x) / 3)\n\ndef solve():\n    x = r_int()\n    a = x - 1\n    z = cbrt(13.5 * a + 1.5 * sqrt(3) * sqrt(a * (27 * a + 4)) + 1)\n    v = (z + 1 / z + 1) / 3\n    r = ceil(v ** 3)\n    if r == round(cbrt(r)) ** 3:\n        r += 1\n    print(r * r)\n\ndef main():\n    n_cases = r_int()\n    for _ in range(n_cases):\n        solve()\nmain()", "t = int(input())\nfor i in range(t):\n    x = int(input())\n    a = x\n    n = x ** 2\n    while int(round(n ** 0.5, 5)) - int(round(n ** (1 / 3), 5)) < x:\n        a = x + int(round(n ** (1 / 3), 5))\n        n = a ** 2\n    if a - 1 - (a - 1) ** (2 / 3) == x:\n        n = (a - 1) ** 2\n    print(n)", "t = int(input())\nfrom math import floor\n\ndef fn(n):\n    a = floor((n + 0.6) ** 0.5)\n    b = floor((n + 0.7) ** (1 / 3))\n    return a - b\nfor i in range(t):\n    n = int(input())\n    start = 1\n    end = 10 ** 10\n    while start < end:\n        mid = (start + end) // 2\n        mid1 = mid ** 2\n        if fn(mid1) >= n:\n            end = mid\n        else:\n            start = mid + 1\n    print(start ** 2)", "def i23(v):\n    y = int(v ** (2.0 / 3.0) + 2)\n    while y ** 3 > v ** 2:\n        y -= 1\n    return y\n\ndef II():\n    return int(input())\nfor _ in range(int(input())):\n    x = II()\n    m = 0\n    while True:\n        m1 = x + i23(m)\n        if m1 == m:\n            break\n        m = m1\n    print(m * m)"]