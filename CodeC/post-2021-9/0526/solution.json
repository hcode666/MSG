["from functools import lru_cache\nfrom sys import setrecursionlimit, stdin\nsetrecursionlimit(10 ** 7)\ninput = stdin.readline\nt = int(input())\n\ndef solve(N, A, B):\n\n    @lru_cache(None)\n    def go(i, j, zeros):\n        if i == -1 and j == -1:\n            return 0\n        tmpi = 2 ** 31\n        tmpj = 2 ** 31\n        if i >= 0:\n            if A[i] == '1':\n                tmpi = go(i - 1, j, zeros) + zeros\n            else:\n                tmpi = go(i - 1, j, zeros + 1)\n        if j >= 0:\n            if B[j] == '1':\n                tmpj = go(i, j - 1, zeros) + zeros\n            else:\n                tmpj = go(i, j - 1, zeros + 1)\n        if tmpj < tmpi:\n            return tmpj\n        else:\n            return tmpi\n    print(go(N - 1, N - 1, 0))\nwhile t:\n    N = int(input())\n    A = input()\n    B = input()\n    solve(N, A, B)\n    t -= 1", "from functools import lru_cache\nfrom sys import setrecursionlimit, stdin\nsetrecursionlimit(10 ** 7)\ninput = stdin.readline\nt = int(input())\n\ndef solve(N, A, B):\n\n    @lru_cache(None)\n    def go(i, j, zeros):\n        if i == -1 and j == -1:\n            return 0\n        tmpi = 2 ** 31\n        tmpj = 2 ** 31\n        if i >= 0:\n            if A[i] == '1':\n                tmpi = go(i - 1, j, zeros) + zeros\n            else:\n                tmpi = go(i - 1, j, zeros + 1)\n        if j >= 0:\n            if B[j] == '1':\n                tmpj = go(i, j - 1, zeros) + zeros\n            else:\n                tmpj = go(i, j - 1, zeros + 1)\n        if tmpj < tmpi:\n            return tmpj\n        else:\n            return tmpi\n    print(go(N - 1, N - 1, 0))\nwhile t:\n    N = int(input())\n    A = input()\n    B = input()\n    solve(N, A, B)\n    t -= 1", "import sys\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\nfor _ in range(int(input())):\n    n = int(input())\n    a = '!' + input()\n    b = '!' + input()\n    dp = [[0 for x in range(n + 1)] for y in range(n + 1)]\n    num_1s_a = [0] * (n + 1)\n    num_1s_b = [0] * (n + 1)\n    for i in range(1, n + 1):\n        num_1s_a[i] = num_1s_a[i - 1] + (a[i] == '1')\n        num_1s_b[i] = num_1s_b[i - 1] + (b[i] == '1')\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0]\n        if a[i] == '0':\n            dp[i][0] += num_1s_a[i - 1]\n        dp[0][i] = dp[0][i - 1]\n        if b[i] == '0':\n            dp[0][i] += num_1s_b[i - 1]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i] == '0':\n                dp[i][j] = dp[i - 1][j] + num_1s_a[i - 1] + num_1s_b[j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n            if b[j] == '0':\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + num_1s_a[i] + num_1s_b[j - 1])\n            else:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1])\n    print(dp[n][n])", "for i in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    INF = float('inf')\n    dp = [[INF for j in range(n + 1)] for k in range(n + 1)]\n    prea = [0 for j in range(n + 1)]\n    preb = [0 for j in range(n + 1)]\n    dp[0][0] = 0\n    for j in range(1, n + 1):\n        prea[j] = prea[j - 1]\n        if a[j - 1] == '1':\n            prea[j] += 1\n    for j in range(1, n + 1):\n        preb[j] = preb[j - 1]\n        if b[j - 1] == '1':\n            preb[j] += 1\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1]\n        if a[j - 1] == '0':\n            dp[0][j] += prea[j]\n    for j in range(1, n + 1):\n        dp[j][0] = dp[j - 1][0]\n        if b[j - 1] == '0':\n            dp[j][0] += preb[j]\n    for j in range(1, n + 1):\n        for k in range(1, n + 1):\n            op1 = dp[j - 1][k]\n            if b[j - 1] == '0':\n                op1 += prea[k] + preb[j]\n            op2 = dp[j][k - 1]\n            if a[k - 1] == '0':\n                op2 += preb[j] + prea[k]\n            dp[j][k] = min(op1, op2)\n    print(dp[-1][-1])", "for i in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    INF = float('inf')\n    dp = [[INF for j in range(n + 1)] for k in range(n + 1)]\n    prea = [0 for j in range(n + 1)]\n    preb = [0 for j in range(n + 1)]\n    dp[0][0] = 0\n    for j in range(1, n + 1):\n        prea[j] = prea[j - 1]\n        if a[j - 1] == '1':\n            prea[j] += 1\n    for j in range(1, n + 1):\n        preb[j] = preb[j - 1]\n        if b[j - 1] == '1':\n            preb[j] += 1\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1]\n        if a[j - 1] == '0':\n            dp[0][j] += prea[j]\n    for j in range(1, n + 1):\n        dp[j][0] = dp[j - 1][0]\n        if b[j - 1] == '0':\n            dp[j][0] += preb[j]\n    for j in range(1, n + 1):\n        for k in range(1, n + 1):\n            op1 = dp[j - 1][k]\n            if b[j - 1] == '0':\n                op1 += prea[k] + preb[j]\n            op2 = dp[j][k - 1]\n            if a[k - 1] == '0':\n                op2 += preb[j] + prea[k]\n            op3 = dp[j - 1][k - 1]\n            if b[j - 1] == '0':\n                op3 += prea[k] + preb[j]\n            if a[k - 1] == '0':\n                op3 += preb[j] + prea[k]\n            dp[j][k] = min(op1, op2, op3)\n    print(dp[-1][-1])", "for _ in range(int(input())):\n    n = int(input())\n    a = '#' + input()\n    b = '#' + input()\n    m = n\n    ps = [0] * (n + 1)\n    pt = [0] * (n + 1)\n    ps[0] = 1 if a[0] == '1' else 0\n    pt[0] = 1 if b[0] == '1' else 0\n    for i in range(1, n + 1):\n        ps[i] = ps[i - 1] + 1 if a[i] == '1' else ps[i - 1]\n    for i in range(1, n + 1):\n        pt[i] = pt[i - 1] + 1 if b[i] == '1' else pt[i - 1]\n    dp = [[0] * (n + 1) for i in range(m + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0]\n        if a[i] == '0':\n            dp[i][0] += ps[i - 1]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1]\n        if b[j] == '0':\n            dp[0][j] += pt[j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i] == '0':\n                dp[i][j] = dp[i - 1][j] + ps[i - 1] + pt[j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n            if b[j] == '0':\n                dp[i][j] = min(dp[i][j - 1] + ps[i] + pt[j - 1], dp[i][j])\n            else:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1])\n    print(dp[n][n])", "for t in range(int(input())):\n    N = int(input())\n    A = str(input())\n    B = str(input())\n    sufA = [0]\n    sufB = [0]\n    for i in range(N - 1, -1, -1):\n        if A[i] == '0':\n            sufA.append(sufA[-1] + 1)\n        else:\n            sufA.append(sufA[-1])\n        if B[i] == '0':\n            sufB.append(sufB[-1] + 1)\n        else:\n            sufB.append(sufB[-1])\n    sufB.reverse()\n    sufA.reverse()\n    dp = []\n    from math import inf\n    for i in range(N + 1):\n        dp.append([inf] * (N + 1))\n    dp[0][0] = 0\n    for j in range(N + 1):\n        for i in range(N + 1):\n            if j < N:\n                if B[j] == '0':\n                    dp[i][j + 1] = min(dp[i][j + 1], dp[i][j])\n                else:\n                    dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + sufA[i] + sufB[j])\n            if i < N:\n                if A[i] == '0':\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])\n                else:\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + sufA[i] + sufB[j])\n    print(dp[N][N])", "from functools import lru_cache\nfrom itertools import count\nimport sys, io, os\nfrom collections import deque\nimport heapq\nimport bisect\nimport copy\nMOD = 1000000007\nNO = lambda : print('NO')\nYES = lambda : print('YES')\n_1 = lambda : print(-1)\nari = lambda : [int(_) for _ in input().split()]\ncin = lambda : int(input())\ncis = lambda : input()\nshow = lambda x: print(x)\nfast = lambda : sys.stdin.readline()\nflush = lambda : sys.stdout.flush()\ntest_case = 1\ntest_case = int(input())\nsys.setrecursionlimit(10 ** 6)\n\ndef ans():\n    n = cin()\n    A = cis()\n    B = cis()\n    Map = {}\n\n    def dfs(i, j, onecount):\n        if i >= n and j >= n:\n            return 0\n        if (i, j) in Map:\n            return Map[i, j]\n        count1 = float('inf')\n        if i < n:\n            caseA = 0\n            if A[i] == '1':\n                caseA = 1\n            forA = 0\n            if A[i] == '0':\n                forA += onecount\n            count1 = min(count1, forA + dfs(i + 1, j, onecount + caseA))\n        if j < n:\n            forB = 0\n            if B[j] == '0':\n                forB += onecount\n            caseB = 0\n            if B[j] == '1':\n                caseB = 1\n            count1 = min(count1, forB + dfs(i, j + 1, onecount + caseB))\n        Map[i, j] = count1\n        return count1\n    print(dfs(0, 0, 0))\n    return\nfor _ in range(test_case):\n    ans()", "from sys import stdin\ninput = stdin.readline\n\ndef solve(A, B, N):\n    countA0 = [0] * (N + 1)\n    countB0 = [0] * (N + 1)\n    for i in reversed(range(N)):\n        countA0[i] = countA0[i + 1] + (1 if A[i] == '0' else 0)\n        countB0[i] = countB0[i + 1] + (1 if B[i] == '0' else 0)\n    inversions = [[None] * (N + 1) for i in range(N + 1)]\n    inversions[N][N] = 0\n    for i in reversed(range(N)):\n        inversions[i][N] = (1 if A[i] == '1' else 0) * countA0[i + 1] + inversions[i + 1][N]\n        inversions[N][i] = (1 if B[i] == '1' else 0) * countB0[i + 1] + inversions[N][i + 1]\n    for i in reversed(range(N)):\n        for j in reversed(range(N)):\n            inv1 = (1 if A[i] == '1' else 0) * (countA0[i + 1] + countB0[j]) + inversions[i + 1][j]\n            inv2 = (1 if B[j] == '1' else 0) * (countA0[i] + countB0[j + 1]) + inversions[i][j + 1]\n            inversions[i][j] = min(inv1, inv2)\n    return inversions[0][0]\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    N = int(input().strip())\n    A = input().strip()\n    B = input().strip()\n    print(solve(A, B, N))", "for _ in range(int(input())):\n    N = int(input())\n    A = input()\n    B = input()\n    oneCountA = []\n    for i in range(len(A)):\n        if i == 0:\n            oneCountA.append(int(A[i]))\n        else:\n            oneCountA.append(int(A[i]) + oneCountA[i - 1])\n    oneCountB = []\n    for i in range(len(B)):\n        if i == 0:\n            oneCountB.append(int(B[i]))\n        else:\n            oneCountB.append(int(B[i]) + oneCountB[i - 1])\n    dp = [[0 for i in range(N + 1)] for i in range(N + 1)]\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i == 0 and j == 0:\n                dp[i][j] = 0\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + (0 if B[j - 1] == '1' else oneCountB[j - 1])\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + (0 if A[i - 1] == '1' else oneCountA[i - 1])\n            else:\n                a = dp[i][j - 1] + (0 if B[j - 1] == '1' else oneCountB[j - 1] + oneCountA[i - 1])\n                b = dp[i - 1][j] + (0 if A[i - 1] == '1' else oneCountA[i - 1] + oneCountB[j - 1])\n                dp[i][j] = min(a, b)\n    print(dp[N][N])", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\ngp = []\nans = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\n\ndef hnbhai(tc):\n    n = sb()\n    a = sa()\n    b = sa()\n    prefa = [0]\n    prefb = [0]\n    for i in range(n):\n        prefa.append(prefa[-1] + int(a[i]))\n        prefb.append(prefb[-1] + int(b[i]))\n    dp = [[float('inf') for i in range(n + 1)] for j in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i == 0 and j == 0:\n                continue\n            if i == 0:\n                dp[i][j] = dp[i][j - 1]\n                if b[j - 1] == '0':\n                    dp[i][j] += prefb[j]\n                continue\n            if j == 0:\n                dp[i][j] = dp[i - 1][j]\n                if a[i - 1] == '0':\n                    dp[i][j] += prefa[i]\n                continue\n            f = prefa[i] if a[i - 1] == '0' else 0\n            s = prefb[j] if b[j - 1] == '0' else 0\n            if a[i - 1] == '0':\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + f + prefb[j])\n            else:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j])\n            if b[j - 1] == '0':\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + prefa[i] + s)\n            else:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1])\n    print(dp[n][n])\n    return\nfor _ in range(sb()):\n    hnbhai(_ + 1)", "for _ in range(int(input())):\n    N = int(input())\n    A = input()\n    B = input()\n    oneCountA = []\n    for i in range(len(A)):\n        if i == 0:\n            oneCountA.append(int(A[i]))\n        else:\n            oneCountA.append(int(A[i]) + oneCountA[i - 1])\n    oneCountB = []\n    for i in range(len(B)):\n        if i == 0:\n            oneCountB.append(int(B[i]))\n        else:\n            oneCountB.append(int(B[i]) + oneCountB[i - 1])\n    dp = [[0 for i in range(N + 1)] for i in range(N + 1)]\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i == 0 and j == 0:\n                dp[i][j] = 0\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + (0 if B[j - 1] == '1' else oneCountB[j - 1])\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + (0 if A[i - 1] == '1' else oneCountA[i - 1])\n            else:\n                a = dp[i][j - 1] + (0 if B[j - 1] == '1' else oneCountB[j - 1] + oneCountA[i - 1])\n                b = dp[i - 1][j] + (0 if A[i - 1] == '1' else oneCountA[i - 1] + oneCountB[j - 1])\n                dp[i][j] = min(a, b)\n    print(dp[N][N])", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = input()\n    a = '#' + a\n    b = input()\n    b = '#' + b\n    dp = [[10 ** 9] * (n + 1) for i in range(n + 1)]\n    pa = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    for i in range(1, n + 1):\n        pa[i] = pa[i - 1] + (a[i] == '1')\n    for i in range(1, n + 1):\n        pb[i] = pb[i - 1] + (b[i] == '1')\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        if a[i] == '0':\n            dp[i][0] = dp[i - 1][0] + pa[i - 1]\n        else:\n            dp[i][0] = dp[i - 1][0]\n        if b[i] == '0':\n            dp[0][i] = dp[0][i - 1] + pb[i - 1]\n        else:\n            dp[0][i] = dp[0][i - 1]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i] == '0':\n                dp[i][j] = dp[i - 1][j] + pa[i - 1] + pb[j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n            if b[j] == '0':\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + pb[j - 1] + pa[i])\n            else:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1])\n    print(dp[n][n])", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n\n    def rec(i, j, zeros, memo={}):\n        if (i, j) in memo:\n            return memo[i, j]\n        if i >= n:\n            x = s2[j:].count('0')\n            count = 0\n            for k in range(j, n):\n                if s2[k] == '0':\n                    x -= 1\n                else:\n                    count += x\n            return count\n        if j >= n:\n            x = s1[i:].count('0')\n            count = 0\n            for k in range(i, n):\n                if s1[k] == '0':\n                    x -= 1\n                else:\n                    count += x\n            return count\n        elif s1[i] == '1' and s2[j] == '1':\n            memo[i, j] = zeros + min(rec(i + 1, j, zeros), rec(i, j + 1, zeros))\n            return memo[i, j]\n        elif s1[i] == '0' and s2[j] == '0':\n            memo[i, j] = min(rec(i + 1, j, zeros - 1), rec(i, j + 1, zeros - 1))\n            return memo[i, j]\n        elif s1[i] == '0':\n            memo[i, j] = min(rec(i + 1, j, zeros - 1), zeros + rec(i, j + 1, zeros))\n            return memo[i, j]\n        elif s2[j] == '0':\n            memo[i, j] = min(rec(i, j + 1, zeros - 1), zeros + rec(i + 1, j, zeros))\n            return memo[i, j]\n    n = int(input())\n    s1 = sys.stdin.readline()\n    s2 = sys.stdin.readline()\n    z = s1.count('0') + s2.count('0')\n    print(rec(0, 0, z))", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n\n    def rec(i, j, zeros, memo={}):\n        if (i, j) in memo:\n            return memo[i, j]\n        if i >= n:\n            x = s2[j:].count('0')\n            count = 0\n            for k in range(j, n):\n                if s2[k] == '0':\n                    x -= 1\n                else:\n                    count += x\n            return count\n        if j >= n:\n            x = s1[i:].count('0')\n            count = 0\n            for k in range(i, n):\n                if s1[k] == '0':\n                    x -= 1\n                else:\n                    count += x\n            return count\n        elif s1[i] == '1' and s2[j] == '1':\n            memo[i, j] = zeros + min(rec(i + 1, j, zeros), rec(i, j + 1, zeros))\n            return memo[i, j]\n        elif s1[i] == '0' and s2[j] == '0':\n            memo[i, j] = min(rec(i + 1, j, zeros - 1), rec(i, j + 1, zeros - 1))\n            return memo[i, j]\n        elif s1[i] == '0':\n            memo[i, j] = min(rec(i + 1, j, zeros - 1), zeros + rec(i, j + 1, zeros))\n            return memo[i, j]\n        elif s2[j] == '0':\n            memo[i, j] = min(rec(i, j + 1, zeros - 1), zeros + rec(i + 1, j, zeros))\n            return memo[i, j]\n    n = int(input())\n    s1 = sys.stdin.readline()\n    s2 = sys.stdin.readline()\n    z = s1.count('0') + s2.count('0')\n    print(rec(0, 0, z))", "import sys\nsys.setrecursionlimit(int(1000000.0))\nfor _ in range(int(input())):\n\n    def rec(i, j, zeros, memo={}):\n        if (i, j) in memo:\n            return memo[i, j]\n        if i >= n:\n            x = s2[j:].count('0')\n            count = 0\n            for k in range(j, n):\n                if s2[k] == '0':\n                    x -= 1\n                else:\n                    count += x\n            return count\n        if j >= n:\n            x = s1[i:].count('0')\n            count = 0\n            for k in range(i, n):\n                if s1[k] == '0':\n                    x -= 1\n                else:\n                    count += x\n            return count\n        elif s1[i] == '1' and s2[j] == '1':\n            memo[i, j] = zeros + min(rec(i + 1, j, zeros), rec(i, j + 1, zeros))\n            return memo[i, j]\n        elif s1[i] == '0' and s2[j] == '0':\n            memo[i, j] = min(rec(i + 1, j, zeros - 1), rec(i, j + 1, zeros - 1))\n            return memo[i, j]\n        elif s1[i] == '0':\n            memo[i, j] = min(rec(i + 1, j, zeros - 1), zeros + rec(i, j + 1, zeros))\n            return memo[i, j]\n        elif s2[j] == '0':\n            memo[i, j] = min(rec(i, j + 1, zeros - 1), zeros + rec(i + 1, j, zeros))\n            return memo[i, j]\n    n = int(input())\n    s1 = sys.stdin.readline()\n    s2 = sys.stdin.readline()\n    z = s1.count('0') + s2.count('0')\n    print(rec(0, 0, z))", "from sys import stdin, stdout, setrecursionlimit\nsetrecursionlimit(10 ** 6)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    A = input().strip()\n    B = input().strip()\n\n    def get_cnt(s):\n        cnt = [0] * n\n        zero = 0\n        for i in range(n - 1, -1, -1):\n            if s[i] == '0':\n                zero += 1\n            cnt[i] = zero\n        return cnt\n    cnt_A = get_cnt(A)\n    cnt_B = get_cnt(B)\n    dp = [[-1] * (n + 1) for i in range(n + 1)]\n\n    def dfs(i, j):\n        if i == n and j == n:\n            return 0\n        if dp[i][j] != -1:\n            return dp[i][j]\n        inv = 0\n        if i < n:\n            inv = cnt_A[i]\n        if j < n:\n            inv += cnt_B[j]\n        ans = float('inf')\n        if i < n:\n            ans = dfs(i + 1, j) + inv * (A[i] == '1')\n        if j < n:\n            ans = min(ans, dfs(i, j + 1) + inv * (B[j] == '1'))\n        dp[i][j] = ans\n        return ans\n    print(dfs(0, 0))", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nimport math\nfor t in range(int(input())):\n    n = int(input())\n    s1 = input()\n    s2 = input()\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    one_1 = [0] * (n + 1)\n    one_2 = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if s1[i - 1] == '1':\n            one_1[i] = one_1[i - 1] + 1\n        else:\n            one_1[i] = one_1[i - 1]\n    for i in range(1, n + 1):\n        if s2[i - 1] == '1':\n            one_2[i] = one_2[i - 1] + 1\n        else:\n            one_2[i] = one_2[i - 1]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] + (one_2[j] if s2[j - 1] == '0' else 0)\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + (one_1[i] if s1[i - 1] == '0' else 0)\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j] + (one_1[i] + one_2[j] if s1[i - 1] == '0' else 0)\n            dp[i][j] = min(dp[i][j], dp[i][j - 1] + (one_1[i] + one_2[j] if s2[j - 1] == '0' else 0))\n    print(dp[-1][-1])", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random\nfrom functools import lru_cache\nfrom itertools import *\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\nfrom functools import lru_cache\nsys.setrecursionlimit(10 ** 8)\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for i in range(how_much_noob_I_am):\n        n = inpu()\n        s = inp()\n        t = inp()\n        dp = [[0] * (n + 1) for i in range(n + 1)]\n        dp[0][0] = 0\n        prefs = [0]\n        for i in range(n):\n            if s[i] == '1':\n                prefs.append(prefs[-1] + 1)\n            else:\n                prefs.append(prefs[-1])\n        preft = [0]\n        for i in range(n):\n            if t[i] == '1':\n                preft.append(preft[-1] + 1)\n            else:\n                preft.append(preft[-1])\n        for i in range(1, n + 1):\n            dp[i][0] = dp[i - 1][0]\n            if s[i - 1] == '0':\n                dp[i][0] += prefs[i - 1]\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1]\n            if t[j - 1] == '0':\n                dp[0][j] += preft[j - 1]\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                r = inf\n                rr = inf\n                if s[i - 1] == '0':\n                    r = dp[i - 1][j] + prefs[i - 1] + preft[j]\n                else:\n                    r = dp[i - 1][j]\n                if t[j - 1] == '0':\n                    rr = dp[i][j - 1] + prefs[i] + preft[j - 1]\n                else:\n                    rr = dp[i][j - 1]\n                dp[i][j] = min(r, rr)\n        print(dp[n][n])\nmain()", "import sys\nRW = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nfrom collections import defaultdict as df\nimport heapq\nimport math\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in list(input())]\n    b = [int(x) for x in list(input())]\n    dp = [[0] * (n + 1) for i in range(n + 1)]\n    suffixa = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        if a[i] == 0:\n            suffixa[i] = suffixa[i + 1] + 1\n        else:\n            suffixa[i] = suffixa[i + 1]\n    suffixb = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        if b[i] == 0:\n            suffixb[i] = suffixb[i + 1] + 1\n        else:\n            suffixb[i] = suffixb[i + 1]\n    dp[n][n] = 0\n    for i in range(n - 1, -1, -1):\n        if a[i] == 0:\n            dp[i][n] = dp[i + 1][n]\n        else:\n            dp[i][n] = dp[i + 1][n] + 1 * suffixa[i + 1]\n    for i in range(n - 1, -1, -1):\n        if b[i] == 0:\n            dp[n][i] = dp[n][i + 1]\n        else:\n            dp[n][i] = dp[n][i + 1] + 1 * suffixb[i + 1]\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            temp1 = dp[j + 1][i] + a[j] * (suffixa[j + 1] + suffixb[i])\n            temp2 = dp[j][i + 1] + b[i] * (suffixa[j] + suffixb[i + 1])\n            dp[j][i] = min(temp1, temp2)\n    print(dp[0][0])", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random\nfrom functools import lru_cache\nfrom itertools import *\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\nfrom functools import lru_cache\nsys.setrecursionlimit(10 ** 8)\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for i in range(how_much_noob_I_am):\n        n = inpu()\n        s = inp()\n        t = inp()\n        prefs = [[0, 0]]\n        (one, zero) = (0, 0)\n        for i in s:\n            if i == '1':\n                one += 1\n                prefs.append([zero, one])\n            else:\n                zero += 1\n                prefs.append([zero, one])\n        preft = [[0, 0]]\n        (one, zero) = (0, 0)\n        for i in t:\n            if i == '1':\n                one += 1\n                preft.append([zero, one])\n            else:\n                zero += 1\n                preft.append([zero, one])\n\n        @lru_cache(None)\n        def fun(x, y):\n            if x == n and y == n:\n                return 0\n            ans = inf\n            if x < n:\n                p = 0\n                if s[x] == '0':\n                    p = prefs[x][1] + preft[y][1]\n                ans = min(ans, p + fun(x + 1, y))\n            if y < n:\n                p = 0\n                if t[y] == '0':\n                    p = prefs[x][1] + preft[y][1]\n                ans = min(ans, p + fun(x, y + 1))\n            return ans\n        print(fun(0, 0))\nmain()", "from sys import maxsize, setrecursionlimit\nsetrecursionlimit(10 ** 6)\n\ndef solve(i, j, z):\n    if (i, j) in dp:\n        return dp[i, j]\n    if i == -1:\n        ans = 0\n        while j >= 0:\n            if B[j] == '0':\n                z += 1\n            else:\n                ans += z\n            j -= 1\n        return ans\n    if j == -1:\n        ans = 0\n        while i >= 0:\n            if A[i] == '0':\n                z += 1\n            else:\n                ans += z\n            i -= 1\n        return ans\n    ans = maxsize\n    if A[i] == '0':\n        ans = min(ans, solve(i - 1, j, z + 1))\n    else:\n        ans = min(ans, z + solve(i - 1, j, z))\n    if B[j] == '0':\n        ans = min(ans, solve(i, j - 1, z + 1))\n    else:\n        ans = min(ans, z + solve(i, j - 1, z))\n    dp[i, j] = ans\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    A = input()\n    B = input()\n    dp = {}\n    print(solve(n - 1, n - 1, 0))", "for _ in range(int(input())):\n    num = int(input())\n    se = input()\n    test = input()\n    s = [0 for _ in range(num + 1)]\n    t = [0 for _ in range(num + 1)]\n    for i in reversed(range(num)):\n        s[i] = s[i + 1]\n        if se[i] == '0':\n            s[i] += 1\n        t[i] = t[i + 1]\n        if test[i] == '0':\n            t[i] += 1\n    dynp = [[-1 for _ in range(num + 1)] for _ in range(num + 1)]\n    dynp[num][num] = 0\n    for i in reversed(range(0, num)):\n        dynp[i][num] = dynp[i + 1][num]\n        if se[i] == '1':\n            dynp[i][num] += s[i]\n        dynp[num][i] = dynp[num][i + 1]\n        if test[i] == '1':\n            dynp[num][i] += t[i]\n    for i in reversed(range(num)):\n        for j in reversed(range(num)):\n            a1 = dynp[i + 1][j]\n            if se[i] == '1':\n                a1 += s[i] + t[j]\n            a2 = dynp[i][j + 1]\n            if test[j] == '1':\n                a2 += s[i] + t[j]\n            dynp[i][j] = min(a1, a2)\n    print(dynp[0][0])", "from functools import lru_cache\nfrom sys import setrecursionlimit, stdin\nsetrecursionlimit(10 ** 7)\ninput = stdin.readline\nt = int(input())\n\ndef solve(N, A, B):\n\n    @lru_cache(None)\n    def go(i, j, zeros):\n        if i == -1 and j == -1:\n            return 0\n        tmpi = 2 ** 31\n        tmpj = 2 ** 31\n        if i >= 0:\n            if A[i] == '1':\n                tmpi = go(i - 1, j, zeros) + zeros\n            else:\n                tmpi = go(i - 1, j, zeros + 1)\n        if j >= 0:\n            if B[j] == '1':\n                tmpj = go(i, j - 1, zeros) + zeros\n            else:\n                tmpj = go(i, j - 1, zeros + 1)\n        if tmpj < tmpi:\n            return tmpj\n        else:\n            return tmpi\n    print(go(N - 1, N - 1, 0))\nwhile t:\n    N = int(input())\n    A = input()\n    B = input()\n    solve(N, A, B)\n    t -= 1", "def algorithm(l, str1, str2):\n    total_cost = [[0 for _ in range(l + 1)] for _ in range(l + 1)]\n    how_many_ones_str1 = [0 for _ in range(l + 1)]\n    how_many_ones_str2 = [0 for _ in range(l + 1)]\n    total_cost[0][0] = 0\n    total_cost[0][1] = 0\n    total_cost[1][0] = 0\n    for i in range(l):\n        how_many_ones_str1[i + 1] = how_many_ones_str1[i] + int(str1[i] == '1')\n        how_many_ones_str2[i + 1] = how_many_ones_str2[i] + int(str2[i] == '1')\n    for i in range(0, l + 1):\n        for j in range(0, l + 1):\n            if i + j == 0:\n                continue\n            if i > 0:\n                if str1[i - 1] == '1':\n                    option1 = total_cost[i - 1][j]\n                else:\n                    option1 = total_cost[i - 1][j] + how_many_ones_str1[i - 1]\n                    if j > 0:\n                        option1 += how_many_ones_str2[j - 1]\n            else:\n                option1 = -1\n            if j > 0:\n                if str2[j - 1] == '1':\n                    option2 = total_cost[i][j - 1]\n                else:\n                    option2 = total_cost[i][j - 1] + how_many_ones_str2[j - 1]\n                    if i > 0:\n                        option2 += how_many_ones_str1[i - 1]\n            else:\n                option2 = -1\n            if (option1 < option2 or option2 == -1) and option1 != -1:\n                total_cost[i][j] = option1\n            else:\n                total_cost[i][j] = option2\n    print(total_cost[l][l])\n\ndef main():\n    number_of_tests = int(input())\n    test_cases = [(int(input()), input(), input()) for _ in range(number_of_tests)]\n    for (l, a, b) in test_cases:\n        algorithm(l, a, b)\ntry:\n    main()\nexcept EOFError:\n    pass", "from collections import deque, defaultdict\nfrom math import sqrt, ceil, factorial, floor, inf, log2, sqrt, gcd\nimport bisect\nimport copy\nfrom itertools import combinations\nimport sys\nimport heapq\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef input():\n    return sys.stdin.readline().strip()\nimport heapq\n\ndef get_set(n):\n    ans = 0\n    for i in range(21):\n        if n & 1 << i > 0:\n            ans += 1\n    return ans % 2 == 0\nfor _ in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    arr_a = [0] * n\n    arr_b = [0] * n\n    for i in range(n - 1, -1, -1):\n        if a[i] == '0':\n            arr_a[i] += 1\n        if b[i] == '0':\n            arr_b[i] += 1\n        if i + 1 < n:\n            arr_a[i] += arr_a[i + 1]\n            arr_b[i] += arr_b[i + 1]\n    dp = [[inf for i in range(n + 1)] for j in range(n + 1)]\n    dp[n][n] = 0\n    for i in range(n - 1, -1, -1):\n        if b[i] == '1':\n            dp[n][i] = arr_b[i]\n        else:\n            dp[n][i] = 0\n        dp[n][i] += dp[n][i + 1]\n    for i in range(n - 1, -1, -1):\n        if a[i] == '1':\n            dp[i][n] = arr_a[i]\n        else:\n            dp[i][n] = 0\n        dp[i][n] += dp[i + 1][n]\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            cnt1 = arr_a[i]\n            cnt2 = arr_b[j]\n            if a[i] == '1':\n                dp[i][j] = min(dp[i][j], dp[i + 1][j] + cnt1 + cnt2)\n            if a[i] == '0':\n                dp[i][j] = min(dp[i][j], dp[i + 1][j])\n            if b[j] == '1':\n                dp[i][j] = min(dp[i][j], dp[i][j + 1] + cnt1 + cnt2)\n            if b[j] == '0':\n                dp[i][j] = min(dp[i][j], dp[i][j + 1])\n    print(dp[0][0])", "tt = int(input())\nwhile tt > 0:\n    n = int(input())\n    a = str(input())\n    b = str(input())\n    pref = []\n    pref1 = []\n    for i in range(n + 1):\n        pref.append(0)\n        pref1.append(0)\n    dp = []\n    for i in range(n + 1):\n        t = []\n        for j in range(n + 1):\n            t.append(1e+18)\n        dp.append(t)\n    dp[n][n] = 0\n    for i in range(n - 1, -1, -1):\n        pref[i] = pref[i + 1]\n        pref[i] += a[i] == '0'\n        pref1[i] = pref1[i + 1]\n        pref1[i] += b[i] == '0'\n    for i in range(n - 1, -1, -1):\n        dp[n][i] = dp[n][i + 1]\n        if b[i] == '1':\n            dp[n][i] += pref[n] + pref1[i]\n    for i in range(n - 1, -1, -1):\n        dp[i][n] = dp[i + 1][n]\n        if a[i] == '1':\n            dp[i][n] += pref[i] + pref1[n]\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if a[i] == '0' and b[j] == '0':\n                dp[i][j] = min(dp[i][j], dp[i + 1][j])\n                dp[i][j] = min(dp[i][j], dp[i][j + 1])\n            elif a[i] == '0' and b[j] == '1':\n                dp[i][j] = min(dp[i][j], dp[i + 1][j])\n                dp[i][j] = min(dp[i][j], dp[i][j + 1] + pref[i] + pref1[j])\n            elif a[i] == '1' and b[j] == '0':\n                dp[i][j] = min(dp[i][j], dp[i][j + 1])\n                dp[i][j] = min(dp[i][j], dp[i + 1][j] + pref[i] + pref1[j])\n            else:\n                dp[i][j] = min(dp[i][j], dp[i + 1][j] + pref[i] + pref1[j])\n                dp[i][j] = min(dp[i][j], dp[i][j + 1] + pref[i] + pref1[j])\n    print(dp[0][0])\n    tt = tt - 1", "import bisect\nimport math\nimport string\nfrom collections import deque, Counter\nimport sys\ninput = lambda : sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\ndp = [[-1] * 501 for i in range(501)]\n\ndef solve():\n    n = int(input())\n    s1 = input()\n    s2 = input()\n    p1 = [0] * (n + 1)\n    p2 = [0] * (n + 1)\n    m = [[1000000000000000000] * (n + 1) for i in range(n + 1)]\n    m[n][n] = 0\n    for i in range(n - 1, -1, -1):\n        p1[i] = p1[i + 1] + (s1[i] == '0')\n        p2[i] = p2[i + 1] + (s2[i] == '0')\n    for i in range(n - 1, -1, -1):\n        m[n][i] = m[n][i + 1]\n        if s2[i] == '1':\n            m[n][i] += p1[n] + p2[i]\n    for i in range(n - 1, -1, -1):\n        m[i][n] = m[i + 1][n]\n        if s1[i] == '1':\n            m[i][n] += p1[i] + p2[n]\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if s1[i] == '0' and s2[j] == '0':\n                m[i][j] = min(m[i][j], m[i + 1][j])\n                m[i][j] = min(m[i][j], m[i][j + 1])\n            elif s1[i] == '0' and s2[j] == '1':\n                m[i][j] = min(m[i][j], m[i + 1][j])\n                m[i][j] = min(m[i][j], m[i][j + 1] + p1[i] + p2[j])\n            elif s1[i] == '1' and s2[j] == '0':\n                m[i][j] = min(m[i][j], m[i][j + 1])\n                m[i][j] = min(m[i][j], m[i + 1][j] + p1[i] + p2[j])\n            else:\n                m[i][j] = min(m[i][j], m[i + 1][j] + p1[i] + p2[j])\n                m[i][j] = min(m[i][j], m[i][j + 1] + p1[i] + p2[j])\n    print(m[0][0])\nfor testis in range(int(input())):\n    solve()", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    pref = [0] * (n + 1)\n    pref1 = [0] * (n + 1)\n    dp = [[float('inf') for i in range(n + 1)] for j in range(n + 1)]\n    dp[n][n] = 0\n    for i in range(n - 1, -1, -1):\n        pref[i] = pref[i + 1] + int(a[i] == '0')\n        pref1[i] = pref1[i + 1] + int(b[i] == '0')\n    for i in range(n - 1, -1, -1):\n        dp[n][i] = dp[n][i + 1]\n        if b[i] == '1':\n            dp[n][i] += pref[n] + pref1[i]\n    for i in range(n - 1, -1, -1):\n        dp[i][n] = dp[i + 1][n]\n        if a[i] == '1':\n            dp[i][n] += pref[i] + pref1[n]\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if a[i] == '0' and b[j] == '0':\n                dp[i][j] = min(dp[i][j], dp[i + 1][j])\n                dp[i][j] = min(dp[i][j], dp[i][j + 1])\n            elif a[i] == '0' and b[j] == '1':\n                dp[i][j] = min(dp[i][j], dp[i + 1][j])\n                dp[i][j] = min(dp[i][j], dp[i][j + 1] + pref[i] + pref1[j])\n            elif a[i] == '1' and b[j] == '0':\n                dp[i][j] = min(dp[i][j], dp[i][j + 1])\n                dp[i][j] = min(dp[i][j], dp[i + 1][j] + pref[i] + pref1[j])\n            else:\n                dp[i][j] = min(dp[i][j], dp[i + 1][j] + pref[i] + pref1[j])\n                dp[i][j] = min(dp[i][j], dp[i][j + 1] + pref[i] + pref1[j])\n    print(dp[0][0])", "from functools import lru_cache\nimport threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        s = input()\n        t = input()\n        pres = [[0, 0]]\n        (a, b) = (0, 0)\n        for i in range(n):\n            if s[i] == '1':\n                b += 1\n                pres.append([a, b])\n            else:\n                a += 1\n                pres.append([a, b])\n        pret = [[0, 0]]\n        (a, b) = (0, 0)\n        for i in range(n):\n            if t[i] == '1':\n                b += 1\n                pret.append([a, b])\n            else:\n                a += 1\n                pret.append([a, b])\n\n        @lru_cache(None)\n        def fun(x, y):\n            if x == n and y == n:\n                return 0\n            ans = float('inf')\n            if x < n:\n                p = 0\n                if s[x] == '0':\n                    p = pres[x][1] + pret[y][1]\n                ans = min(ans, p + fun(x + 1, y))\n            if y < n:\n                p = 0\n                if t[y] == '0':\n                    p = pres[x][1] + pret[y][1]\n                ans = min(ans, p + fun(x, y + 1))\n            return ans\n        print(fun(0, 0))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nsys.setrecursionlimit(10 ** 6)\nd = {}\n\ndef solve(i, j, a, b, ar, br):\n    n = len(a)\n    try:\n        return d[i, j]\n    except:\n        pass\n    if i >= n and j >= n:\n        return 0\n    if i >= n:\n        if b[j] == '1':\n            d[i, j] = br[j]\n        else:\n            d[i, j] = 0\n        d[i, j] += solve(i, j + 1, a, b, ar, br)\n        return d[i, j]\n    if j >= n:\n        if a[i] == '1':\n            d[i, j] = ar[i]\n        else:\n            d[i, j] = 0\n        d[i, j] += solve(i + 1, j, a, b, ar, br)\n        return d[i, j]\n    if a[i] == '1':\n        ans1 = ar[i] + br[j] + solve(i + 1, j, a, b, ar, br)\n    else:\n        ans1 = solve(i + 1, j, a, b, ar, br)\n    if b[j] == '1':\n        ans2 = ar[i] + br[j] + solve(i, j + 1, a, b, ar, br)\n    else:\n        ans2 = solve(i, j + 1, a, b, ar, br)\n    d[i, j] = min(ans1, ans2)\n    return d[i, j]\nfor jfjf in range(int(input())):\n    n = int(input())\n    a = list(input())\n    b = list(input())\n    ar = []\n    br = []\n    sum = 0\n    d = {}\n    for i in range(-1, -n - 1, -1):\n        if a[i] == '0':\n            sum += 1\n        ar.append(sum)\n    sum = 0\n    for i in range(-1, -n - 1, -1):\n        if b[i] == '0':\n            sum += 1\n        br.append(sum)\n    ar.reverse()\n    br.reverse()\n    print(solve(0, 0, a, b, ar, br))", "from functools import lru_cache\nfrom sys import setrecursionlimit, stdin\nsetrecursionlimit(10 ** 7)\ninput = stdin.readline\nt = int(input())\n\ndef solve(N, A, B):\n\n    @lru_cache(None)\n    def go(i, j, zeros):\n        if i == -1 and j == -1:\n            return 0\n        tmpi = 2 ** 31\n        tmpj = 2 ** 31\n        if i >= 0:\n            if A[i] == '1':\n                tmpi = go(i - 1, j, zeros) + zeros\n            else:\n                tmpi = go(i - 1, j, zeros + 1)\n        if j >= 0:\n            if B[j] == '1':\n                tmpj = go(i, j - 1, zeros) + zeros\n            else:\n                tmpj = go(i, j - 1, zeros + 1)\n        if tmpj < tmpi:\n            return tmpj\n        else:\n            return tmpi\n    print(go(N - 1, N - 1, 0))\nwhile t:\n    N = int(input())\n    A = input()\n    B = input()\n    solve(N, A, B)\n    t -= 1", "def checkmin(a, b):\n    dp = [[0 for i in range(len(a) + 1)] for j in range(len(a) + 1)]\n    suf = [0]\n    n = len(a)\n    for i in range(n - 1, -1, -1):\n        suf.append(suf[-1] + (a[i] == '0'))\n    suf = suf[::-1]\n    pre = [0]\n    for i in range(n):\n        pre.append(pre[-1] + (a[i] == '1'))\n    for i in range(1, n + 1):\n        for j in range(n + 1):\n            if b[i - 1] == '0':\n                if j == 0:\n                    dp[i][j] = dp[i - 1][j] + pre[j]\n                else:\n                    dp[i][j] = min(dp[i][j - 1], dp[i - 1][j] + pre[j])\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + suf[j]\n            else:\n                dp[i][j] = min(dp[i][j - 1], dp[i - 1][j] + suf[j])\n    res = 0\n    tot = a.count('0')\n    for i in a:\n        if i == '1':\n            res += tot\n        else:\n            tot -= 1\n    tot = b.count('0')\n    for i in b:\n        if i == '1':\n            res += tot\n        else:\n            tot -= 1\n    return res + dp[-1][-1]\nt = int(input())\nfor _ in range(t):\n    t -= 1\n    n = int(input())\n    a = input()\n    b = input()\n    print(checkmin(a, b))", "def count_ones(arr1, arr2, i, j):\n    return arr1[i] + arr2[j]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s1 = input()\n    s2 = input()\n    prefix_ones_s1 = [0]\n    prefix_ones_s2 = [0]\n    for i in range(n):\n        if s1[i] == '1':\n            prefix_ones_s1.append(prefix_ones_s1[-1] + 1)\n        else:\n            prefix_ones_s1.append(prefix_ones_s1[-1])\n        if s2[i] == '1':\n            prefix_ones_s2.append(prefix_ones_s2[-1] + 1)\n        else:\n            prefix_ones_s2.append(prefix_ones_s2[-1])\n    dp = []\n    for i in range(n + 1):\n        dp.append([float('inf') for j in range(n + 1)])\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        if s2[i - 1] == '0':\n            dp[0][i] = dp[0][i - 1] + count_ones(prefix_ones_s1, prefix_ones_s2, 0, i - 1)\n        else:\n            dp[0][i] = dp[0][i - 1]\n    for i in range(1, n + 1):\n        if s1[i - 1] == '0':\n            dp[i][0] = dp[i - 1][0] + count_ones(prefix_ones_s1, prefix_ones_s2, i - 1, 0)\n        else:\n            dp[i][0] = dp[i - 1][0]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if s2[j - 1] == '0':\n                choice1 = dp[i][j - 1] + count_ones(prefix_ones_s1, prefix_ones_s2, i, j - 1)\n            else:\n                choice1 = dp[i][j - 1]\n            if s1[i - 1] == '0':\n                choice2 = dp[i - 1][j] + count_ones(prefix_ones_s1, prefix_ones_s2, i - 1, j)\n            else:\n                choice2 = dp[i - 1][j]\n            dp[i][j] = min(choice1, choice2)\n    print(dp[-1][-1])", "def solve(n):\n    s1 = input()\n    s2 = input()\n    dp = [[[float('inf'), 0] for i in range(n + 1)] for i in range(n + 1)]\n    dp[0][0][0] = 0\n    for i in range(n):\n        dp[i + 1][0][0] = dp[i][0][0]\n        dp[i + 1][0][1] = dp[i][0][1]\n        if s1[i] == '1':\n            dp[i + 1][0][1] += 1\n        else:\n            dp[i + 1][0][0] += dp[i][0][1]\n    for i in range(n):\n        dp[0][i + 1][0] = dp[0][i][0]\n        dp[0][i + 1][1] = dp[0][i][1]\n        if s2[i] == '1':\n            dp[0][i + 1][1] += 1\n        else:\n            dp[0][i + 1][0] += dp[0][i][1]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == '1':\n                dp[i][j][1] = dp[i - 1][j][1] + 1\n                dp[i][j][0] = dp[i - 1][j][0]\n            else:\n                dp[i][j][1] = dp[i - 1][j][1]\n                dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1]\n            if s2[j - 1] == '1':\n                x = dp[i][j - 1][0]\n                if x < dp[i][j][0]:\n                    dp[i][j][0] = x\n                    dp[i][j][1] = dp[i][j - 1][1] + 1\n            else:\n                x = dp[i][j - 1][0] + dp[i][j - 1][1]\n                if x < dp[i][j][0]:\n                    dp[i][j][0] = x\n                    dp[i][j][1] = dp[i][j - 1][1]\n    print(dp[-1][-1][0])\nfor _ in range(int(input())):\n    n = int(input())\n    solve(n)", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    from functools import lru_cache\n    for _ in range(int(input())):\n        n = int(input())\n        s = input()\n        t = input()\n        prefix = [[0, 0]]\n        for i in range(n):\n            if s[i] == '1':\n                prefix.append([prefix[-1][0], prefix[-1][1] + 1])\n            else:\n                prefix.append([prefix[-1][0] + 1, prefix[-1][1]])\n        p1 = [[0, 0]]\n        for i in range(n):\n            if t[i] == '1':\n                p1.append([p1[-1][0], p1[-1][1] + 1])\n            else:\n                p1.append([p1[-1][0] + 1, p1[-1][1]])\n\n        @lru_cache(None)\n        def dfs(i, j):\n            if i == n and j == n:\n                return 0\n            ans = float('inf')\n            if i < n:\n                l = prefix[i][1] + p1[j][1] if s[i] == '0' else 0\n                ans = min(ans, l + dfs(i + 1, j))\n            if j < n:\n                l = prefix[i][1] + p1[j][1] if t[j] == '0' else 0\n                ans = min(ans, l + dfs(i, j + 1))\n            return ans\n        print(dfs(0, 0))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nsys.setrecursionlimit(10 ** 6)\ninf = 1000000000\n\ndef go(i, j, ones, n, a, b, dp):\n    if i == n and j == n:\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    (c1, c2) = (inf, inf)\n    if i != n:\n        if a[i] == '1':\n            c1 = go(i + 1, j, ones + 1, n, a, b, dp)\n        else:\n            c1 = ones + go(i + 1, j, ones, n, a, b, dp)\n    if j != n:\n        if b[j] == '1':\n            c2 = go(i, j + 1, ones + 1, n, a, b, dp)\n        else:\n            c2 = ones + go(i, j + 1, ones, n, a, b, dp)\n    dp[i][j] = min(c1, c2)\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    dp = [[-1 for i in range(n + 1)] for j in range(n + 1)]\n    print(go(0, 0, 0, n, a, b, dp))", "import sys\nsys.setrecursionlimit(1000000)\n\ndef helper(i, j, count, n):\n    if i == n and j == n:\n        return 0\n    elif (i, j) in dp:\n        return dp[i, j]\n    elif i == n:\n        if b[j] == '1':\n            dp[i, j] = helper(i, j + 1, count + 1, n)\n        else:\n            dp[i, j] = count + helper(i, j + 1, count, n)\n    elif j == n:\n        if a[i] == '1':\n            dp[i, j] = helper(i + 1, j, count + 1, n)\n        else:\n            dp[i, j] = count + helper(i + 1, j, count, n)\n    elif a[i] != b[j]:\n        if a[i] == '0':\n            dp[i, j] = count + helper(i + 1, j, count, n)\n        else:\n            dp[i, j] = count + helper(i, j + 1, count, n)\n    elif a[i] == '0':\n        dp[i, j] = count + min(helper(i + 1, j, count, n), helper(i, j + 1, count, n))\n    else:\n        dp[i, j] = min(helper(i + 1, j, count + 1, n), helper(i, j + 1, count + 1, n))\n    return dp[i, j]\nt = int(sys.stdin.readline())\nfor tt in range(t):\n    n = int(sys.stdin.readline())\n    a = sys.stdin.readline()\n    b = sys.stdin.readline()\n    dp = {}\n    sys.stdout.write(str(helper(0, 0, 0, n)) + '\\n')", "def pprint(d):\n    for row in d:\n        print(*row[1:])\nT = int(input())\nfor T in range(T):\n    n = int(input())\n    a = input()\n    b = input()\n    aa = [0]\n    bb = [0]\n    acount = 0\n    bcount = 0\n    for i in range(n):\n        if a[i] == '1':\n            acount += 1\n        if b[i] == '1':\n            bcount += 1\n        aa.append(acount)\n        bb.append(bcount)\n    d = [[n * n for i in range(n + 1)] for i in range(n + 1)]\n    d[1][0] = 0\n    for row in range(1, n + 1):\n        for col in range(1, n + 1):\n            vara = d[row][col - 1]\n            if a[col - 1] == '0':\n                vara += bb[row - 1] + aa[col]\n            varb = d[row - 1][col]\n            if b[row - 1] == '0':\n                varb += bb[row] + aa[col - 1]\n            d[row][col] = min(vara, varb)\n    print(d[n][n])", "T = int(input())\nfor _ in range(T):\n    n = int(input())\n    s = input()\n    t = input()\n    zs = [0 for _ in range(n + 1)]\n    zt = [0 for _ in range(n + 1)]\n    for i in reversed(range(n)):\n        zs[i] = zs[i + 1]\n        if s[i] == '0':\n            zs[i] += 1\n        zt[i] = zt[i + 1]\n        if t[i] == '0':\n            zt[i] += 1\n    dp = [[-1 for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[n][n] = 0\n    for i in reversed(range(0, n)):\n        dp[i][n] = dp[i + 1][n]\n        if s[i] == '1':\n            dp[i][n] += zs[i]\n        dp[n][i] = dp[n][i + 1]\n        if t[i] == '1':\n            dp[n][i] += zt[i]\n    for i in reversed(range(n)):\n        for j in reversed(range(n)):\n            x1 = dp[i + 1][j]\n            if s[i] == '1':\n                x1 += zs[i] + zt[j]\n            x2 = dp[i][j + 1]\n            if t[j] == '1':\n                x2 += zs[i] + zt[j]\n            dp[i][j] = min(x1, x2)\n    print(dp[0][0])"]