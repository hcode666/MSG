["maxN = 10000009\nprime = [1 for i in range(maxN + 1)]\ni = 2\nwhile i * i <= maxN:\n    if prime[i]:\n        for j in range(i ** 2, maxN + 1, i):\n            prime[j] = False\n    i += 1\n(prime[0], prime[1]) = [0] * 2\nfor i in range(1, maxN + 1):\n    prime[i] += prime[i - 1]\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    cnt = 0\n    print(y - x - (prime[y] - prime[x + 1]))", "maxN = 10000009\nprime = [1 for i in range(maxN + 1)]\ni = 2\nwhile i * i <= maxN:\n    if prime[i]:\n        for j in range(i ** 2, maxN + 1, i):\n            prime[j] = False\n    i += 1\n(prime[0], prime[1]) = [0] * 2\nfor i in range(1, maxN + 1):\n    prime[i] += prime[i - 1]\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    cnt = 0\n    print(y - x - (prime[y] - prime[x + 1]))", "maxN = 10000009\nprime = [1 for i in range(maxN + 1)]\ni = 2\nwhile i * i <= maxN:\n    if prime[i]:\n        for j in range(i ** 2, maxN + 1, i):\n            prime[j] = False\n    i += 1\n(prime[0], prime[1]) = [0] * 2\nfor i in range(1, maxN + 1):\n    prime[i] += prime[i - 1]\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    cnt = 0\n    print(y - x - (prime[y] - prime[x + 1]))", "import math, sys, bisect, heapq, os\nfrom collections import defaultdict, Counter, deque\nfrom itertools import groupby, accumulate\nfrom functools import lru_cache\npr = lambda x: x\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\naj = lambda : list(map(int, input().split()))\n\ndef list3d(a, b, c, d):\n    return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Y(c):\n    print(['NO', 'YES'][c])\n\ndef y(c):\n    print(['no', 'yes'][c])\n\ndef Yy(c):\n    print(['No', 'Yes'][c])\n\ndef SieveOfEratosthenes(n):\n    Z = []\n    prime = [1 for i in range(n + 1)]\n    p = 2\n    prime[0] = prime[1] = 0\n    while p * p <= n:\n        if prime[p] == 1:\n            for i in range(p * p, n + 1, p):\n                prime[i] = 0\n        p += 1\n    return prime\npri = list(accumulate(SieveOfEratosthenes(10000010)))\nfor i in range(int(input())):\n    (x, y) = map(int, input().split())\n    ans = y - x\n    if x == y:\n        print(0)\n    elif y == x + 1:\n        print(1)\n    else:\n        primes = pri[y] - pri[x + 1]\n        ans -= primes\n        print(ans)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\nA = SieveOfEratosthenes(10000010)\nB = [0, 0]\nfor i in range(2, 10000009):\n    if A[i]:\n        B.append(B[-1] + 1)\n    else:\n        B.append(B[-1])\nfor t in range(int(input())):\n    (X, Y) = map(int, input().split())\n    if X == Y:\n        print(0)\n        continue\n    elif X == Y - 1:\n        print(1)\n        continue\n    temp = B[Y] - B[X + 1]\n    print(Y - X - temp)", "from sys import stdin\ndata = stdin.read().split('\\n')\nn = 10000000\nprime = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p ** 2, n + 1, p):\n            prime[i] = False\n    p += 1\nprime[0] = False\nprime[1] = False\nlookup = {0: 0, 1: 0}\nk = 0\nfor p in range(n + 1):\n    if prime[p]:\n        k += 1\n        lookup[p] = k\n    else:\n        lookup[p] = k\nfor i in range(int(data[0])):\n    (X, Y) = map(int, data[i + 1].split(' '))\n    total = Y - X\n    ans = lookup[Y] - lookup[X]\n    ans += total - ans * 2\n    if prime[X + 1]:\n        ans += 1\n    print(ans)", "from math import *\nimport sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nmaxi = 10 ** 7 + 1\nstat = [0 for i in range(maxi)]\nstat[0] = 1\nstat[1] = 1\nfor i in range(2, int(sqrt(maxi) + 1)):\n    if stat[i] == 0:\n        for j in range(i * i, maxi, i):\n            stat[j] = 1\npr_c = [0 for i in range(maxi)]\na = 0\nfor i in range(maxi):\n    if stat[i] == 0:\n        a += 1\n    pr_c[i] = a\nfor _ in range(int(input())):\n    (x, y) = list(map(int, input().split()))\n    ans = y - x - (pr_c[y] - pr_c[x + 1])\n    print(ans)", "from itertools import accumulate\n\ndef generate_primes(n):\n    primes = [True for x in range(n + 1)]\n    num = 2\n    while num * num <= n:\n        if primes[num]:\n            for i in range(num ** 2, n + 1, num):\n                primes[i] = False\n        num += 1\n    primes[0] = False\n    primes[1] = False\n    return primes\nt = int(input().strip())\nprimes = list(accumulate(generate_primes(10 ** 7 + 1)))\nwhile t > 0:\n    t -= 1\n    (x, y) = map(int, input().strip().split())\n    if x == y:\n        print(0)\n    elif x + 1 == y:\n        print(1)\n    else:\n        steps = y - x - (primes[y] - primes[x + 1])\n        print(steps)", "def sieve_of_eratosthenes(n):\n    lis = [True for x in range(0, n + 1)]\n    (lis[0], lis[1]) = (False, False)\n    for i in range(2, int(n ** 0.5) + 1):\n        if lis[i] == True:\n            for j in range(i * 2, n + 1, i):\n                lis[j] = False\n    lis1 = [0]\n    for i in range(1, n + 1):\n        if lis[i] == True:\n            lis1.append(lis1[i - 1] + 1)\n        else:\n            lis1.append(lis1[i - 1])\n    return lis1\nl = sieve_of_eratosthenes(10 ** 7)\nfor i in range(int(input())):\n    (x, y) = [int(x) for x in input().split()]\n    print(y - x - (l[y] - l[x + 1]))", "from itertools import accumulate\n\ndef makeIsPr(p_limit):\n    track = [False, True] * (p_limit // 2 + 1)\n    if p_limit % 2 == 0:\n        track.pop()\n    track[0:3] = [False, False, True]\n    pc = 3\n    while pc * pc <= p_limit:\n        if track[pc]:\n            for a in range(pc * pc, p_limit + 1, 2 * pc):\n                track[a] = False\n        pc += 2\n    return track\npCount = list(accumulate(makeIsPr(10 ** 7)))\nfor _ in range(int(input())):\n    (S, E) = map(int, input().split())\n    print(E - S - (pCount[E] - pCount[S + 1]))", "n = 10000007\nprime = [True for i in range(n + 1)]\n\ndef SieveOfEratosthenes():\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\nSieveOfEratosthenes()\npre = [0] * n\nfor i in range(1, n):\n    if prime[i] == True:\n        pre[i] = pre[i - 1] + 1\n    else:\n        pre[i] = pre[i - 1]\nfor i in range(int(input())):\n    (x, y) = map(int, input().split())\n    print(y - x - (pre[y] - pre[x + 1]))", "def main():\n    primes = [1] * 10000001\n    for i in range(2, 10002):\n        if primes[i] == 1:\n            for j in range(i + i, 10000001, i):\n                primes[j] = 0\n    primes[0] = 0\n    primes[1] = 0\n    for i in range(1, len(primes)):\n        primes[i] = primes[i] + primes[i - 1]\n    for _ in range(int(input())):\n        (X, Y) = map(int, input().split())\n        c = Y - X\n        n = primes[Y] - primes[X + 1]\n        print(c - n)\nmain()", "from itertools import groupby, accumulate\n\ndef solve():\n\n    def SieveOfEratosthenes(n):\n        Z = []\n        prime = [1 for i in range(n + 1)]\n        p = 2\n        prime[0] = prime[1] = 0\n        while p * p <= n:\n            if prime[p] == 1:\n                for i in range(p * p, n + 1, p):\n                    prime[i] = 0\n            p += 1\n        return prime\n    pri = list(accumulate(SieveOfEratosthenes(10000010)))\n    for i in range(int(input())):\n        (x, y) = map(int, input().split())\n        ans = y - x\n        if x == y:\n            print(0)\n        elif y == x + 1:\n            print(1)\n        else:\n            primes = pri[y] - pri[x + 1]\n            ans -= primes\n            print(ans)\nsolve()", "from sys import stdin\nfrom itertools import accumulate\n\ndef makeIsPr(p_limit):\n    track = [False, True] * (p_limit // 2 + 1)\n    if p_limit % 2 == 0:\n        track.pop()\n    track[0:3] = [False, False, True]\n    pc = 3\n    while pc * pc <= p_limit:\n        if track[pc]:\n            for a in range(pc * pc, p_limit + 1, 2 * pc):\n                track[a] = False\n        pc += 2\n    return track\nlim = 10000000\nisPrime = makeIsPr(lim)\npCount = list(accumulate(isPrime))\ninp = stdin.readline\nT = int(inp())\nans = []\nfor _ in range(T):\n    (S, E) = map(int, inp().split())\n    ans.append(E - S - (pCount[E] - pCount[S + 1]))\nprint(*ans, sep='\\n')", "maxn = 10000000.0\nx = int(maxn + 2)\nisPrime = [True] * x\ntotalPrime = [0] * x\nn = int(maxn)\nisPrime[0] = False\nisPrime[1] = False\ni = 2\nfor i in range(2, n + 1):\n    totalPrime[i] = totalPrime[i - 1]\n    if isPrime[i] == True:\n        totalPrime[i] += 1\n        for j in range(i * i, n + 1, i):\n            isPrime[j] = False\nT = int(input())\nfor i in range(T):\n    (X, Y) = map(int, input().split())\n    count = Y - X - (totalPrime[Y] - totalPrime[X + 1])\n    print(count)", "from math import *\nimport sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nmaxi = 10 ** 7\nstat = [0 for i in range(maxi + 2)]\npr_count = [0 for i in range(maxi + 2)]\nstat[0] = 1\nstat[1] = 1\ncount = 0\nfor i in range(2, maxi + 1):\n    if stat[i] == 0:\n        count += 1\n        for j in range(i * i, maxi + 1, i):\n            stat[j] = 1\n    pr_count[i] = count\nfor _ in range(int(input())):\n    (x, y) = list(map(int, input().split()))\n    ans = y - x\n    no_of_pr = pr_count[y] - pr_count[x + 1]\n    ans -= no_of_pr\n    print(ans)", "import sys\nimport bisect\ninput = sys.stdin.readline\n\ndef SieveOfEratosthenes(n):\n    arr = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    for p in range(n + 1):\n        if prime[p]:\n            arr.append(p)\n    return arr\n\ndef solve():\n    (a, b) = map(int, input().split())\n    ans = b - a\n    (l, r) = (bisect.bisect_left(primes, a + 2), bisect.bisect_left(primes, b))\n    ans -= r - l\n    if len(primes) != r and primes[r] == b:\n        ans -= 1\n    print(ans)\nt = int(input())\nprimes = SieveOfEratosthenes(10 ** 7)\nfor _ in range(t):\n    solve()", "import sys\nimport math\nN = 10000002\nis_prime = [1] * N\nis_prime[0] = 0\nis_prime[1] = 0\n\ndef sieve():\n    i = 2\n    while i * i <= N:\n        if is_prime[i] == 0:\n            i += 1\n            continue\n        j = 2 * i\n        while j < N:\n            is_prime[j] = 0\n            j += i\n        i += 1\nsieve()\ntotal_primes = [0] * N\nfor i in range(1, N):\n    total_primes[i] = is_prime[i] + total_primes[i - 1]\nfor case in range(int(input())):\n    [X, Y] = map(int, sys.stdin.readline().split())\n    print(Y - X - (total_primes[Y] - total_primes[X + 1]))", "import sys\nimport math\nN = 10000002\nis_prime = [1] * N\nis_prime[0] = 0\nis_prime[1] = 0\n\ndef sieve():\n    i = 2\n    while i * i <= N:\n        if is_prime[i] == 0:\n            i += 1\n            continue\n        j = 2 * i\n        while j < N:\n            is_prime[j] = 0\n            j += i\n        i += 1\nsieve()\ntotal_primes = [0] * N\nfor i in range(1, N):\n    total_primes[i] = is_prime[i] + total_primes[i - 1]\nfor case in range(int(input())):\n    [X, Y] = map(int, input().split())\n    print(Y - X - (total_primes[Y] - total_primes[X + 1]))", "import sys\nimport math\nN = 10000002\nis_prime = [1] * N\nis_prime[0] = 0\nis_prime[1] = 0\n\ndef sieve():\n    i = 2\n    while i * i <= N:\n        if is_prime[i] == 0:\n            i += 1\n            continue\n        j = 2 * i\n        while j < N:\n            is_prime[j] = 0\n            j += i\n        i += 1\nsieve()\ntotal_primes = [0] * N\nfor i in range(1, N):\n    total_primes[i] = is_prime[i] + total_primes[i - 1]\nfor case in range(int(input())):\n    [X, Y] = map(int, sys.stdin.readline().split())\n    print(Y - X - (total_primes[Y] - total_primes[X + 1]))", "import sys\nimport math\nN = 10000002\nis_prime = [1] * N\nis_prime[0] = 0\nis_prime[1] = 0\n\ndef sieve():\n    i = 2\n    while i * i <= N:\n        if is_prime[i] == 0:\n            i += 1\n            continue\n        j = 2 * i\n        while j < N:\n            is_prime[j] = 0\n            j += i\n        i += 1\nsieve()\ntotal_primes = [0] * N\nfor i in range(1, N):\n    total_primes[i] = is_prime[i] + total_primes[i - 1]\nfor case in range(int(input())):\n    [X, Y] = map(int, sys.stdin.readline().split())\n    print(Y - X - (total_primes[Y] - total_primes[X + 1]))", "import sys\nfrom math import sqrt\n\ndef read(typ=str):\n    return list(map(typ, sys.stdin.readline().split()))\ny = int(10000000.0)\nprime = [1] * (y + 1)\nfor i in range(2, int(sqrt(y)) + 1):\n    if prime[i] == 1:\n        for j in range(i * i, y + 1, i):\n            prime[j] = 0\npcount = 0\npre = [0] * (y + 1)\nfor i in range(y + 1):\n    if prime[i] == 1:\n        pcount += 1\n    pre[i] = pcount\nt = read(int)[0]\nfor _ in range(t):\n    (x, y) = read(int)\n    count = pre[y] - pre[x]\n    if prime[x + 1] == 1:\n        count -= 1\n    print(y - x - count)", "a = int(input())\nMAX = 10000000\nprefix = [0] * (MAX + 1)\n\ndef buildPrefix():\n    prime = [1] * (MAX + 1)\n    p = 2\n    while p * p <= MAX:\n        if prime[p] == 1:\n            i = p * 2\n            while i <= MAX:\n                prime[i] = 0\n                i += p\n        p += 1\n    for p in range(2, MAX + 1):\n        prefix[p] = prefix[p - 1]\n        if prime[p] == 1:\n            prefix[p] += 1\n\ndef query(L, R):\n    return prefix[R] - prefix[L - 1]\nbuildPrefix()\nfor i in range(a):\n    b = list(map(int, input().split()))\n    rnum = b[-1] - b[0] + 1\n    print(rnum - query(b[0] + 2, b[-1]) - 1)", "def is_prime(n):\n    if n % 2 == 0 and n != 2:\n        return False\n    for j in range(3, int(n ** 0.5) + 1, 2):\n        if n % j == 0:\n            return False\n    return True\nn = 10 ** 7\nprime = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p * p, n + 1, p):\n            prime[i] = False\n    p += 1\narr = [0] * (n + 1)\ncnt = 0\nfor p in range(2, n + 1):\n    if prime[p]:\n        cnt += 1\n    arr[p] = cnt\nfor i in range(int(input())):\n    (a, b) = [int(x) for x in input().split()]\n    ans = arr[b] - arr[a + 1]\n    print(b - a - ans)", "import sys\nins = lambda : sys.stdin.readline().strip()\ninarr = lambda s: list(map(s, sys.stdin.readline().strip().split()))\nouts = lambda n: sys.stdout.write(str(n) + '\\n')\noutarr = lambda li: sys.stdout.write(' '.join(map(str, li)) + '\\n')\n\ndef sieve(n):\n    prime = [1 for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == 1:\n            for j in range(p ** 2, n + 1, p):\n                prime[j] = 0\n        p += 1\n    prime[0] = 0\n    prime[1] = 0\n    for j in range(1, n + 1):\n        prime[j] += prime[j - 1]\n    return prime\nprime = sieve(10000009)\nfor _ in range(int(input())):\n    (x, y) = inarr(int)\n    if x + 2 <= y:\n        total_prime = prime[y] - prime[x + 1]\n        outs(y - x - total_prime)\n    else:\n        outs(y - x)", "n = 10 ** 7\nprimes = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if primes[p] == True:\n        for i in range(p * p, n + 1, p):\n            primes[i] = False\n    p = p + 1\npre = [0] * (n + 1)\nfor i in range(2, n + 1):\n    if primes[i]:\n        pre[i] = pre[i - 1] + 1\n    else:\n        pre[i] = pre[i - 1]\nt = int(input())\nfor _ in range(t):\n    (x, y) = map(int, input().split())\n    if x == 1 and y == 3:\n        print(2)\n        continue\n    if primes[x + 1]:\n        ans = y - x - (pre[y] - pre[x]) + 1\n    else:\n        ans = y - x - (pre[y] - pre[x])\n    print(ans)", "l1 = [1] * 10000001\nl1[0] = 0\nl1[1] = 0\nfor i in range(2, 3163):\n    if l1[i] == 1:\n        temp = i * i\n        while temp < 10000001:\n            l1[temp] = 0\n            temp = temp + i\nl2 = [0] * 10000001\nfor i in range(2, len(l1)):\n    if l1[i] == 1:\n        l2[i] = l2[i - 1] + 1\n    else:\n        l2[i] = l2[i - 1]\nfor t in range(int(input())):\n    (x, y) = map(int, input().split())\n    res = y - x - (l2[y] - l2[x + 1])\n    print(res)", "l1 = [1] * 10000001\nl1[0] = 0\nl1[1] = 0\nfor i in range(2, 3163):\n    if l1[i] == 1:\n        for j in range(i + i, 10000001, i):\n            l1[j] = 0\nl2 = [0] * 10000001\nfor i in range(2, len(l1)):\n    if l1[i] == 1:\n        l2[i] = l2[i - 1] + 1\n    else:\n        l2[i] = l2[i - 1]\nfor t in range(int(input())):\n    (x, y) = map(int, input().split())\n    res = y - x - (l2[y] - l2[x + 1])\n    print(res)", "from sys import stdin, stdout\nfrom math import ceil, sqrt\nfrom bisect import bisect_left\n\ndef sieve(MAXN):\n    is_prime[0] = is_prime[1] = 0\n    for i in range(4, MAXN, 2):\n        is_prime[i] = 0\n    for i in range(3, ceil(sqrt(MAXN)), 2):\n        if is_prime[i]:\n            for j in range(i * i, MAXN + 1, i * 2):\n                is_prime[j] = 0\n    primes.append(2)\n    for i in range(3, MAXN, 2):\n        if is_prime[i]:\n            primes.append(i)\nN = int(10000000.0 + 10)\nprimes = []\nis_prime = [1 for _ in range(N)]\nsieve(N)\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    (t1, t2) = (bisect_left(primes, y + 1), bisect_left(primes, x + 1))\n    ans = y - x + t2 - t1\n    if x + 1 == primes[t2]:\n        ans += 1\n    print(ans)", "n = 10 ** 7 + 2\ns = [1] * n\ns[0] = 0\ns[1] = 0\nfor i in range(2, int(n ** 0.5) + 1):\n    if s[i]:\n        for j in range(2 * i, n, i):\n            s[j] = 0\nfreq = [0] * n\nfor i in range(2, n):\n    freq[i] = freq[i - 1] + s[i]\nfor i in range(int(input())):\n    (x, y) = map(int, input().split())\n    ans = y - x - (freq[y] - freq[x + 1])\n    print(ans)", "import math as m\nfrom itertools import accumulate\n\ndef Sieve(n):\n    isPrime = [True] * (n + 1)\n    isPrime[0] = isPrime[1] = False\n    for i in range(2, int(m.sqrt(n))):\n        if isPrime[i]:\n            for j in range(2 * i, n + 1, i):\n                isPrime[j] = False\n    return isPrime\nprim = Sieve(int(10000000.0) + 3)\ntot_prim_nums = list(accumulate(prim))\nt = int(input())\nwhile t:\n    (x, y) = map(int, input().split())\n    ans = tot_prim_nums[y] - tot_prim_nums[x + 1]\n    print(y - x - ans)\n    t -= 1", "prime = [True for i in range(int(10000000.0) + 1)]\np = 2\nn = int(10000000.0)\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p * p, n + 1, p):\n            prime[i] = False\n    p += 1\nli = [0, 0]\nc = 0\nfor i in range(2, int(10000000.0) + 1):\n    if prime[i]:\n        c += 1\n    li.append(c)\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    print(y - x - (li[y] - li[x + 1]))", "n = 10000000\nprime = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p ** 2, n + 1, p):\n            prime[i] = False\n    p += 1\nprime[0] = False\nprime[1] = False\nd = {0: 0, 1: 0}\ncount = 0\nfor p in range(n + 1):\n    if prime[p]:\n        count += 1\n        d[p] = count\n    else:\n        d[p] = count\nfor t in range(int(input())):\n    (X, Y) = map(int, input().split())\n    total = Y - X\n    ans = d[Y] - d[X]\n    ans += total - ans * 2\n    if prime[X + 1]:\n        ans += 1\n    print(ans)", "from math import *\nn = 10000000\nprimes = [True] * (n + 1)\nprimes[0] = False\nprimes[1] = False\nfor i in range(2, int(sqrt(n)) + 1):\n    if primes[i] == True:\n        for j in range(i * i, n + 1, i):\n            primes[j] = False\npre_sum = [0] * (n + 1)\ncount = 0\nfor i in range(len(primes)):\n    if primes[i] == True:\n        count = count + 1\n        pre_sum[i] = count\n    else:\n        pre_sum[i] = count\npre_sum[1] = 1\nt = int(input())\nfor i in range(t):\n    (x, y) = map(int, input().split())\n    dist = y - x\n    p = pre_sum[y] - pre_sum[x + 1]\n    print(dist - p)", "import math\nfrom collections import Counter\nfrom sys import stdin, stdout\ninput = stdin.readline\na = [1] * (10 ** 7 + 3)\na[0] = a[1] = 0\nb = [0] * (10 ** 7 + 3)\nfor i in range(2, int(math.sqrt(10 ** 7 + 3)) + 1):\n    if a[i]:\n        for j in range(i * i, 10 ** 7 + 3, i):\n            a[j] = 0\nb = a\nfor i in range(1, 10 ** 7 + 3):\n    b[i] += b[i - 1]\nfor t in range(int(input())):\n    (x, y) = map(int, input().split())\n    c = y - x\n    d = b[y] - b[x + 1]\n    print(c - d)", "import math\nfrom collections import Counter\nfrom sys import stdin, stdout\ninput = stdin.readline\na = [1] * (10 ** 7 + 3)\na[0] = a[1] = 0\nb = [0] * (10 ** 7 + 3)\nfor i in range(2, int(math.sqrt(10 ** 7 + 3)) + 1):\n    if a[i]:\n        for j in range(i * i, 10 ** 7 + 3, i):\n            a[j] = 0\nfor i in range(1, 10 ** 7 + 3):\n    b[i] = b[i - 1]\n    if a[i] == 1:\n        b[i] += 1\nfor t in range(int(input())):\n    (x, y) = map(int, input().split())\n    c = y - x\n    d = b[y] - b[x + 1]\n    print(c - d)", "n = 10 ** 7 + 10\npr = [True for i in range(n)]\ni = 2\nwhile i * i < n:\n    if pr[i]:\n        for j in range(2 * i, n, i):\n            pr[j] = False\n    i += 1\ndp = [0] * n\npr[0] = pr[1] = False\ndp[0] = 0\ndp[1] = 0\ndp[2] = 1\nfor i in range(3, n):\n    if pr[i]:\n        dp[i] = 1 + dp[i - 2]\n    else:\n        dp[i] = 1 + dp[i - 1]\nimport sys\nfor _ in range(int(input())):\n    (x, y) = map(int, sys.stdin.readline().split())\n    if x == 1:\n        sys.stdout.write(str(dp[y] - dp[x]) + '\\n')\n    elif pr[x + 1]:\n        sys.stdout.write(str(dp[y] - dp[x] + 1) + '\\n')\n    else:\n        sys.stdout.write(str(dp[y] - dp[x]) + '\\n')", "import sys\nfrom math import sqrt\n\ndef read(typ=str):\n    return list(map(typ, sys.stdin.readline().split()))\ny = int(10000000.0)\nprime = [1] * (y + 1)\nfor i in range(2, int(sqrt(y)) + 1):\n    if prime[i] == 1:\n        for j in range(i * i, y + 1, i):\n            prime[j] = 0\npcount = 0\npre = [0] * (y + 1)\nfor i in range(2, y + 1):\n    if prime[i] == 1:\n        pcount += 1\n    pre[i] = pcount\nt = read(int)[0]\nfor _ in range(t):\n    (x, y) = read(int)\n    count = pre[y] - pre[x]\n    if prime[x + 1]:\n        count -= 1\n    print(y - x - count)", "import sys\nfrom math import sqrt, ceil, floor, gcd\nfrom collections import Counter\ninput = lambda : sys.stdin.readline()\n\ndef int_arr():\n    return list(map(int, input().split()))\n\ndef str_arr():\n    return list(map(str, input().split()))\n\ndef get_str():\n    return map(str, input().split())\n\ndef get_int():\n    return map(int, input().split())\n\ndef get_flo():\n    return map(float, input().split())\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nmod = 1000000007\n\ndef generatePrime(n):\n    prime = [1 for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = 0\n        p += 1\n    (prime[0], prime[1]) = (0, 0)\n    for i in range(1, len(prime)):\n        prime[i] += prime[i - 1]\n    return prime\nprime = generatePrime(10000008)\n\ndef solve(a, b):\n    if a + 2 <= b:\n        print(b - a - (prime[b] - prime[a + 1]))\n    else:\n        print(b - a)\nfor _ in range(int(input())):\n    (a, b) = get_int()\n    solve(a, b)", "import sys\nimport bisect\n\ndef get_line():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef in1():\n    return int(input())\n\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            a.append(p)\na = []\nSieveOfEratosthenes(10000000)\nfor _ in range(in1()):\n    (x, y) = get_line()\n    xr = bisect.bisect_right(a, x)\n    yr = bisect.bisect_right(a, y) - 1\n    y_minus_x = y - x\n    diff_of_yr_xr = yr - xr + 1\n    if a[xr] - x < 2:\n        diff_of_yr_xr -= 1\n    print(y_minus_x - diff_of_yr_xr)", "n = 10 ** 7 + 2\ns = [1] * n\ns[0] = 0\ns[1] = 0\nfor i in range(2, int(n ** 0.5) + 1):\n    if s[i]:\n        for j in range(2 * i, n, i):\n            s[j] = 0\nfreq = [0] * n\nfor i in range(2, n):\n    freq[i] = freq[i - 1] + s[i]\nfor i in range(int(input())):\n    (x, y) = map(int, input().split())\n    ans = y - x - (freq[y] - freq[x + 1])\n    print(ans)", "def is_prime(n):\n    if n % 2 == 0 and n != 2:\n        return False\n    for j in range(3, int(n ** 0.5) + 1, 2):\n        if n % j == 0:\n            return False\n    return True\nn = 10 ** 7\nprime = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p * p, n + 1, p):\n            prime[i] = False\n    p += 1\narr = [0] * (n + 1)\ncnt = 0\nfor p in range(2, n + 1):\n    if prime[p]:\n        cnt += 1\n    arr[p] = cnt\nfor i in range(int(input())):\n    (a, b) = [int(x) for x in input().split()]\n    ans = arr[b] - arr[a + 1]\n    print(b - a - ans)", "from itertools import accumulate\n\ndef sieve_of_erothstenes(y):\n    primes = [True] * (y + 1)\n    primes[0] = primes[1] = False\n    s = 2\n    while s * s <= y:\n        if primes[s]:\n            for i in range(s * s, y + 1, s):\n                primes[i] = False\n        s += 1\n    return primes\nprimes = list(accumulate(sieve_of_erothstenes(int(10000000.0 + 1))))\nt = int(input())\nwhile t:\n    t -= 1\n    (x, y) = map(int, input().strip().split())\n    ans = y - x\n    if x == y:\n        print(0)\n    elif y == x + 1:\n        print(1)\n    else:\n        num_of_primes = primes[y] - primes[x + 1]\n        ans -= num_of_primes\n        print(ans)", "from itertools import accumulate\n\ndef SieveOfEratosthenes(n):\n    Z = []\n    prime = [1 for i in range(n + 1)]\n    p = 2\n    prime[0] = prime[1] = 0\n    while p * p <= n:\n        if prime[p] == 1:\n            for i in range(p * p, n + 1, p):\n                prime[i] = 0\n        p += 1\n    return prime\npri = list(accumulate(SieveOfEratosthenes(10000010)))\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    ans = y - x\n    if x == y:\n        print(0)\n    elif y == x + 1:\n        print(1)\n    else:\n        primes = pri[y] - pri[x + 1]\n        ans -= primes\n        print(ans)", "def sieve_of_eratosthenes(n):\n    arr = [True] * (n + 1)\n    p = 2\n    while p * p <= n:\n        if arr[p]:\n            for i in range(p ** 2, n + 1, p):\n                arr[i] = False\n        p += 1\n    arr[0] = False\n    arr[1] = False\n    count = 0\n    prime_count = [0, 0]\n    for i in range(2, n + 1):\n        if arr[i]:\n            count += 1\n        prime_count.append(count)\n    return prime_count\nx_inputs = []\ny_inputs = []\ny_max = -1\nt = int(input())\nfor i in range(0, t):\n    (x, y) = map(int, input().split())\n    x_inputs.append(x)\n    y_inputs.append(y)\n    if y > y_max:\n        y_max = y\nprimes = sieve_of_eratosthenes(y_max)\nfor i in range(0, t):\n    in_between_primes = primes[y_inputs[i]] - primes[x_inputs[i] + 1]\n    steps = y_inputs[i] - x_inputs[i] - in_between_primes\n    print(steps)", "limit = 10000001\nprime = [1 for i in range(limit + 1)]\np = 2\nwhile p * p <= limit:\n    if prime[p] == 1:\n        for i in range(p ** 2, limit + 1, p):\n            prime[i] = 0\n    p += 1\nprime[0] = 0\nprime[1] = 0\nans = [0 for i in range(limit + 1)]\nfor i in range(2, limit + 1):\n    ans[i] = ans[i - 1] + prime[i]\nt = int(input())\nfor _ in range(t):\n    (x, y) = map(int, input().split())\n    if x == 1 and y == 2:\n        print(1)\n    elif x == 1 and y == 3:\n        print(2)\n    elif x == 2 and y == 3:\n        print(1)\n    else:\n        print(y - x - ans[y] + ans[x + 1])", "import sys\nfrom collections import deque\nimport heapq\nimport bisect\nimport copy\nMOD = 1000000007\nNO = lambda : print('NO')\nYES = lambda : print('YES')\n_1 = lambda : print(-1)\nari = lambda : [int(_) for _ in input().split()]\ncin = lambda : int(input())\ncis = lambda : input()\nshow = lambda x: print(x)\nfast = lambda : sys.stdin.readline()\ntest_case = 1\ntest_case = int(fast())\nsys.setrecursionlimit(10 ** 6)\nsieve = [True] * 10000009\nsievenumstore = []\n\ndef dosievestuff():\n    p = 2\n    n = 10000009\n    while p * p <= n:\n        if sieve[p] == True:\n            for i in range(p * p, n + 1, p):\n                if i >= n:\n                    break\n                sieve[i] = False\n        p += 1\n    for i in range(2, len(sieve)):\n        if sieve[i]:\n            sievenumstore.append(i)\n\ndef binarysearchcustom(num):\n    low = 0\n    high = len(sievenumstore)\n    temp = -1\n    while low < high:\n        mid = low + (high - low) // 2\n        if sievenumstore[mid] <= num:\n            temp = mid\n            low = mid + 1\n        else:\n            high = mid\n    return temp\ndosievestuff()\nfor _ in range(test_case):\n    (x, y) = [int(_) for _ in fast().split()]\n    intial = bisect.bisect_right(sievenumstore, x)\n    lastindex = binarysearchcustom(y)\n    if lastindex == -1:\n        lastindex = len(sievenumstore)\n    maximumjumppossible = y - x\n    if abs(x - sievenumstore[intial]) > 1:\n        intial -= 1\n    print(maximumjumppossible - (lastindex - intial))", "def main():\n    primes = [1] * 10000001\n    for i in range(2, 10002):\n        if primes[i] == 1:\n            for j in range(i + i, 10000001, i):\n                primes[j] = 0\n    primes[0] = 0\n    primes[1] = 0\n    for i in range(1, len(primes)):\n        primes[i] = primes[i] + primes[i - 1]\n    for _ in range(int(input())):\n        (X, Y) = map(int, input().split())\n        c = Y - X\n        n = primes[Y] - primes[X + 1]\n        print(c - n)\nmain()", "import io, os, time, math\nfrom sys import stdin, stdout\nfrom bisect import bisect_right as br, bisect_left as bl\n\ndef take_input():\n    return stdin.readline()\n\ndef display_arr(arr):\n    stdout.write(' '.join(map(str, arr)) + '\\n')\n\ndef display_num(num):\n    stdout.write(str(num) + '\\n')\n\ndef sieve():\n    prime = [1] * high\n    p = 2\n    while p * p < high:\n        if prime[p] == 1:\n            i = p * p\n            while i < high:\n                prime[i] = 0\n                i += p\n        p += 1\n    for p in range(2, high):\n        prefix[p] = prefix[p - 1]\n        if prime[p] == 1:\n            prefix[p] += 1\n\ndef query(l, r):\n    return prefix[r] - prefix[l - 1]\nhigh = 10 ** 7 + 1\nprefix = [0] * high\nsieve()\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    p_c = query(x + 2, y)\n    diff = y - x\n    print(diff - p_c)", "from sys import stdin\ndata = stdin.read().split('\\n')\nn = 10000000\nprime = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p ** 2, n + 1, p):\n            prime[i] = False\n    p += 1\nprime[0] = False\nprime[1] = False\nlookup = {0: 0, 1: 0}\nk = 0\nfor p in range(n + 1):\n    if prime[p]:\n        k += 1\n        lookup[p] = k\n    else:\n        lookup[p] = k\nfor i in range(int(data[0])):\n    (X, Y) = map(int, data[i + 1].split(' '))\n    total = Y - X\n    ans = lookup[Y] - lookup[X]\n    ans += total - ans * 2\n    if prime[X + 1]:\n        ans += 1\n    print(ans)", "import sys\nfrom collections import deque\nimport heapq\nimport bisect\nimport copy\nMOD = 1000000007\nNO = lambda : print('NO')\nYES = lambda : print('YES')\n_1 = lambda : print(-1)\nari = lambda : [int(_) for _ in input().split()]\ncin = lambda : int(input())\ncis = lambda : input()\nshow = lambda x: print(x)\nfast = lambda : sys.stdin.readline()\ntest_case = 1\ntest_case = int(fast())\nsys.setrecursionlimit(10 ** 6)\nsieve = [True] * 10000009\nhelper = []\n\ndef dosieve():\n    p = 2\n    n = 10000009\n    while p * p <= n:\n        if sieve[p] == True:\n            for i in range(p * p, n + 1, p):\n                if i >= n:\n                    break\n                sieve[i] = False\n        p += 1\n    for i in range(2, len(sieve)):\n        if sieve[i]:\n            helper.append(i)\n\ndef binary(num):\n    low = 0\n    high = len(helper)\n    temp = -1\n    while low < high:\n        mid = low + (high - low) // 2\n        if helper[mid] <= num:\n            temp = mid\n            low = mid + 1\n        else:\n            high = mid\n    return temp\n\ndef ans():\n    (x, y) = [int(_) for _ in fast().split()]\n    intial = bisect.bisect_right(helper, x)\n    last = binary(y)\n    if last == -1:\n        last = len(helper)\n    maxi = y - x\n    if abs(x - helper[intial]) > 1:\n        intial -= 1\n    print(maxi - (last - intial))\n    return\ndosieve()\nfor _ in range(test_case):\n    ans()", "import math\nlimit = int(10000000.0) + 1\nprime = [1] * limit\nprime[0] = 0\nprime[1] = 0\nfor i in range(2, int(math.sqrt(limit)) + 2):\n    if prime[i]:\n        for j in range(2 * i, limit, i):\n            prime[j] = 0\nprime_prefix_sum = prime[:]\nfor i in range(1, limit):\n    prime_prefix_sum[i] = prime_prefix_sum[i] + prime_prefix_sum[i - 1]\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    ans = y - x\n    no_of_primes = prime_prefix_sum[y - 1] - prime_prefix_sum[x]\n    ans -= no_of_primes\n    if prime[x + 1]:\n        ans = ans + 1\n    if prime[y]:\n        ans = ans - 1\n    print(ans)", "n = 10000000\nprime = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p ** 2, n + 1, p):\n            prime[i] = False\n    p += 1\nprime[0] = False\nprime[1] = False\nlookup = {0: 0, 1: 0}\nk = 0\nfor p in range(n + 1):\n    if prime[p]:\n        k += 1\n        lookup[p] = k\n    else:\n        lookup[p] = k\nfor _ in range(int(input())):\n    (X, Y) = map(int, input().split(' '))\n    total = Y - X\n    ans = lookup[Y] - lookup[X]\n    ans += total - ans * 2\n    if prime[X + 1]:\n        ans += 1\n    print(ans)", "def calprimes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes\nimport bisect\nprimes = calprimes(10000001)\nt = int(input())\nfor t in range(t):\n    (x, y) = [int(x) for x in input().split()]\n    ans = y - x - (bisect.bisect(primes, y) - bisect.bisect(primes, x)) + 1 * (primes[bisect.bisect(primes, x)] - x == 1)\n    print(ans)"]