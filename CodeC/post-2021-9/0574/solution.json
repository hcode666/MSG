["import sys, threading\nimport bisect\nimport math\nimport itertools\nfrom sys import stdout\nfrom heapq import heappush, heappop\nimport heapq\nfrom queue import PriorityQueue\nfrom collections import deque, defaultdict\n\ndef solve(n, tree, m, a):\n    h = [0] * (n + 1)\n    leafs = []\n    bfs = [1]\n    taken = set()\n    for node in bfs:\n        children_found = False\n        for children in tree[node]:\n            if children not in taken:\n                bfs.append(children)\n                h[children] = h[node] + 1\n                children_found = True\n        if children_found is False:\n            leafs.append(node)\n        taken.add(node)\n    a = [0] + a\n    h_leafs = []\n    for leaf in leafs:\n        h_leafs.append(h[leaf])\n    h_leafs.sort()\n    h_pre = [0]\n    for i in range(len(h_leafs)):\n        h_pre.append(h_pre[-1] + h_leafs[i])\n    cnt = 0\n    for i in range(m):\n        time = a[i + 1] - a[i]\n        ind = bisect.bisect_left(h_leafs, time)\n        cnt += ind * time - h_pre[ind]\n    return cnt\nt = int(input())\nans = []\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    tree = []\n    for i in range(n + 1):\n        tree.append([])\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    a = [int(x) for x in input().split()]\n    ans.append(solve(n, tree, m, a))\np = 1\nfor answer in ans:\n    print(answer)\n    p += 1", "from collections import defaultdict\nimport bisect, sys\nsys.setrecursionlimit(10 ** 5)\n\ndef dfs(i, p, dep):\n    leaf = True\n    for j in d[i]:\n        if j == p:\n            continue\n        leaf = False\n        dfs(j, i, dep + 1)\n    if leaf:\n        dist.append(dep)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = defaultdict(list)\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        d[x].append(y)\n        d[y].append(x)\n    A = list(map(int, input().split()))\n    dist = []\n    dfs(1, -1, 0)\n    dist.sort()\n    pre = []\n    pre.append(dist[0])\n    for i in range(1, len(dist)):\n        pre.append(pre[i - 1] + dist[i])\n    (ans, prev) = (0, 0)\n    for i in range(m):\n        sec = A[i] - prev\n        ind = bisect.bisect_left(dist, sec)\n        ind -= 1\n        if ind >= 0:\n            ans += sec * (ind + 1) - pre[ind]\n        prev = A[i]\n    print(ans)", "from collections import deque\nfor tc in range(int(input())):\n    ls = list(map(int, input().split()))\n    graph = []\n    for x in range(ls[0] + 1):\n        graph.append([])\n    for xi in range(ls[0] - 1):\n        x = list(map(int, input().split()))\n        graph[x[0]].append(x[1])\n        graph[x[1]].append(x[0])\n    que = deque()\n    que.append([1, 0])\n    vis = [0] * (ls[0] + 1)\n    dist = [0] * (ls[0] + 1)\n    leaf = []\n    while len(que) > 0:\n        front = que.popleft()\n        (u, dis) = (front[0], front[1])\n        if vis[u] == 0:\n            fl = False\n            for v in graph[u]:\n                if vis[v] == 0:\n                    fl = True\n                    que.append([v, dis + 1])\n                    dist[v] = dist[u] + 1\n            if fl == False:\n                leaf.append(u)\n            vis[u] = 1\n    dic = dict()\n    new = []\n    for x in leaf:\n        if dic.get(dist[x]) is None:\n            dic[dist[x]] = 1\n            new.append(dist[x])\n        else:\n            dic[dist[x]] += 1\n    new.sort()\n    pre1 = []\n    pre2 = []\n    for x in new:\n        if len(pre2) == 0:\n            pre1.append(x * dic[x])\n            pre2.append(dic[x])\n        else:\n            pre1.append(pre1[-1] + dic[x] * x)\n            pre2.append(pre2[-1] + dic[x])\n    op = list(map(int, input().split()))\n    pre = [1]\n    ans = 0\n    for x in range(len(op)):\n        time = op[x] - pre[-1] + 1\n        pre.append(op[x] + 1)\n        lo = 0\n        hi = len(new) - 1\n        tar = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if new[mid] < time:\n                tar = mid\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        if tar != -1:\n            ans += time * pre2[tar] - pre1[tar]\n    print(ans)", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    from bisect import bisect, bisect_left, bisect_right\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        child = [[] * (n + 1) for _ in range(n + 1)]\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            child[u].append(v)\n            child[v].append(u)\n        a = list(map(int, input().split()))\n        dist = []\n\n        def dfs(p, prev, level):\n            yes = True\n            for i in child[p]:\n                if i == prev:\n                    continue\n                yes = False\n                dfs(i, p, level + 1)\n            if yes:\n                dist.append(level)\n        dfs(1, -1, 1)\n        dist.sort()\n        prefix = [0]\n        for el in dist:\n            prefix.append(el + prefix[-1])\n        prev = 0\n        ans = 0\n        for i in range(m):\n            gap = a[i] - prev\n            ind = bisect_right(dist, gap)\n            ans += ind\n            ans += gap * ind - prefix[ind]\n            prev = a[i]\n        print(ans)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from sys import stdin\ninput = stdin.readline\nfrom queue import Queue\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    a = [0]\n    a.extend(list(map(int, input().split())))\n    q = Queue()\n    q.put([0, 0, -1])\n    ind = -1\n    paths = []\n    while not q.empty():\n        li = q.get()\n        node = li[0]\n        ind = li[1]\n        if len(adj[node]) == 1 and node != 0:\n            paths.append(ind)\n        else:\n            for i in range(len(adj[node])):\n                if adj[node][i] != li[2]:\n                    q.put([adj[node][i], ind + 1, node])\n    for i in range(len(paths)):\n        paths[i] += 1\n    d = {}\n    for i in range(len(paths)):\n        if paths[i] not in d:\n            d[paths[i]] = 0\n        d[paths[i]] += 1\n    keys = list(d.keys())\n    mx = max(keys)\n    aa = [0] * (mx + 1)\n    vv = sum(d.values())\n    active = 0\n    curr = 0\n    for i in range(len(aa)):\n        if d.get(i):\n            active += d[i]\n            curr += active\n            aa[i] = curr\n        else:\n            curr += active\n            aa[i] = curr\n    dd = {}\n    for i in range(1, m + 1):\n        time = a[i] - a[i - 1]\n        if time not in dd:\n            dd[time] = 0\n        dd[time] += 1\n    ans = 0\n    for (k, v) in dd.items():\n        if k > mx:\n            ans = ans + (aa[mx] + (k - mx) * active) * v\n        else:\n            ans = ans + aa[k] * v\n    print(ans)", "def next(arr, target):\n    start = 0\n    end = len(arr) - 1\n    ans = len(arr)\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] <= target:\n            start = mid + 1\n        else:\n            ans = mid\n            end = mid - 1\n    return ans\nfrom collections import deque\nt = int(input())\nfor z in range(t):\n    (n, m) = map(int, input().split())\n    adj = dict()\n    for i in range(1, n + 1):\n        adj[i] = set()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a].add(b)\n        adj[b].add(a)\n    a = list(map(int, input().split()))\n    q = deque([[1, 0]])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    leaf = dict()\n    while q:\n        node = q.popleft()\n        if len(adj[node[0]]) == 1 and node[0] != 1:\n            if node[1] in leaf:\n                leaf[node[1]] += 1\n            else:\n                leaf[node[1]] = 1\n            continue\n        for n in adj[node[0]]:\n            if visited[n] == 0:\n                q.append([n, node[1] + 1])\n                visited[n] = 1\n    diff = [a[0]]\n    for i in range(1, m):\n        diff.append(a[i] - a[i - 1])\n    diff.sort()\n    s = [0, diff[0]]\n    for i in range(1, m):\n        s.append(s[-1] + diff[i])\n    ans = 0\n    for level in leaf:\n        count = 0\n        index = next(diff, level)\n        if index != m:\n            count += s[m] - s[index] - level * (m - index)\n        ans += count * leaf[level]\n    print(ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 7)\n\ndef dfs(p, prev, level):\n    yes = True\n    for i in child[p]:\n        if i == prev:\n            continue\n        yes = False\n        dfs(i, p, level + 1)\n    if yes:\n        dist.append(level)\n\ndef b_s(key):\n    (l, h) = (0, len(dist) - 1)\n    ans = -1\n    while l <= h:\n        mid = (l + h) // 2\n        if dist[mid] <= key:\n            ans = mid\n            l = mid + 1\n        else:\n            h = mid - 1\n    return ans\n\ndef answer():\n    ans = 0\n    prev = 0\n    for i in range(m):\n        d = a[i] - prev\n        ind = b_s(d)\n        if ind != -1:\n            ans += (ind + 1) * d - prefix[ind] + (ind + 1)\n        prev = a[i]\n    return ans\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    a = list(map(int, input().split()))\n    dist = []\n    dfs(1, -1, 1)\n    dist.sort()\n    prefix = [dist[0]]\n    for i in range(1, len(dist)):\n        prefix.append(prefix[-1] + dist[i])\n    print(answer())", "from collections import defaultdict\nimport bisect\nimport sys\nsys.setrecursionlimit(10 ** 7)\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    adj = defaultdict(list)\n    leaf = defaultdict(int)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dfs(u, p, depth):\n        count = 0\n        for v in adj[u]:\n            if v == p:\n                continue\n            count += 1\n            dfs(v, u, depth + 1)\n        if count == 0:\n            leaf[depth] += 1\n    dfs(0, 0, 1)\n    A = [int(x) for x in input().split()]\n    gap = [0] * m\n    gap[0] = A[0]\n    for i in range(1, m):\n        gap[i] = A[i] - A[i - 1]\n    gap.sort()\n    pref = [0] * m\n    pref[m - 1] = gap[m - 1]\n    for i in range(m - 2, -1, -1):\n        pref[i] = pref[i + 1] + gap[i]\n    drops = 0\n    for (key, val) in leaf.items():\n        count = 0\n        depth = key\n        lb = bisect.bisect_left(gap, depth)\n        if lb >= m:\n            continue\n        num = m - lb\n        depth -= 1\n        ans = pref[lb] - num * depth\n        drops += ans * val\n    print(drops)", "def main():\n    alpha = 'abcdefghijklmnopqrstuvwxyz'\n    ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    inf = 1e+17\n    mod = 10 ** 9 + 7\n    Max = 2 * 10 ** 6\n    primes = []\n    prime = [True for i in range(Max + 1)]\n    p = 2\n    while p * p <= Max + 1:\n        if prime[p] == True:\n            for i in range(p * p, Max + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, Max + 1):\n        if prime[p]:\n            primes.append(p)\n    primes = set(primes)\n\n    def factorial(n):\n        f = 1\n        for i in range(1, n + 1):\n            f = f * i % mod\n        return f\n\n    def factorial_by(n, by):\n        f = 1\n        for i in range(1, n + 1):\n            if i == by:\n                continue\n            f = f * i % mod\n        return f\n\n    def ncr(n, r):\n        num = den = 1\n        for i in range(r):\n            num = num * (n - i) % mod\n            den = den * (i + 1) % mod\n        return num * pow(den, mod - 2, mod) % mod\n\n    def primeFactors(num):\n        pf = []\n        while num % 2 == 0:\n            pf.append(2)\n            num = num // 2\n        for i in range(3, int(math.sqrt(num)) + 1, 2):\n            while num % i == 0:\n                pf.append(i)\n                num = num // i\n        if num > 2:\n            pf.append(num)\n        return pf\n\n    class Node(object):\n\n        def __init__(self, anc, s):\n            self.anc = anc\n            self.s = s\n\n        def __repr__(self):\n            return str(self.s)\n            pass\n\n    class DSU:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.size = [1] * n\n            self.num_sets = n\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            (a, b) = (self.find(a), self.find(b))\n            if a != b:\n                if self.size[a] < self.size[b]:\n                    (a, b) = (b, a)\n                self.num_sets -= 1\n                self.parent[b] = a\n                self.size[a] += self.size[b]\n\n    def floor(a, b):\n        val = a // b\n        while val * b > a:\n            val -= 1\n        return val\n\n    def solve(n, tree, m, a):\n        h = [0] * (n + 1)\n        leafs = []\n        bfs = [1]\n        taken = set()\n        for node in bfs:\n            children_found = False\n            for children in tree[node]:\n                if children not in taken:\n                    bfs.append(children)\n                    h[children] = h[node] + 1\n                    children_found = True\n            if children_found is False:\n                leafs.append(node)\n            taken.add(node)\n        a = [0] + a\n        h_leafs = []\n        for leaf in leafs:\n            h_leafs.append(h[leaf])\n        h_leafs.sort()\n        h_pre = [0]\n        for i in range(len(h_leafs)):\n            h_pre.append(h_pre[-1] + h_leafs[i])\n        cnt = 0\n        for i in range(m):\n            time = a[i + 1] - a[i]\n            ind = bisect.bisect_left(h_leafs, time)\n            cnt += ind * time - h_pre[ind]\n        return cnt\n    t = int(input())\n    ans = []\n    for _ in range(t):\n        (n, m) = map(int, input().split())\n        tree = []\n        for i in range(n + 1):\n            tree.append([])\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            tree[u].append(v)\n            tree[v].append(u)\n        a = [int(x) for x in input().split()]\n        ans.append(solve(n, tree, m, a))\n    p = 1\n    for answer in ans:\n        print(answer)\n        p += 1\nimport sys, threading\nimport bisect\nimport math\nimport itertools\nfrom sys import stdout\nfrom heapq import heappush, heappop\nimport heapq\nfrom queue import PriorityQueue\nfrom collections import deque, defaultdict\ninput = sys.stdin.readline\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()"]