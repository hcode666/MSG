["from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\nfor _ in range(int(input())):\n    (N, M) = list(map(int, input().split()))\n    arr = []\n    for i in range(N):\n        arr.append(list(map(int, input().split())))\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = arr[-1][-1]\n    solve(arr, dp, N - 1, M - 1)\n    print(dp[0][0])", "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\nfor _ in range(int(input())):\n    (N, M) = list(map(int, input().split()))\n    arr = []\n    for i in range(N):\n        arr.append(list(map(int, input().split())))\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = arr[-1][-1]\n    solve(arr, dp, N - 1, M - 1)\n    print(dp[0][0])", "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\nfor _ in range(int(input())):\n    (N, M) = list(map(int, input().split()))\n    arr = []\n    for i in range(N):\n        arr.append(list(map(int, input().split())))\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = arr[-1][-1]\n    solve(arr, dp, N - 1, M - 1)\n    print(dp[0][0])", "from collections import Counter, defaultdict\nimport sys\n\ndef is_valid(mat, u, v):\n    if u < len(mat) and v < len(mat[0]):\n        return 1\n    return 0\n\ndef sol(r, c, mat):\n    count = 0\n    vis = [[0 for _ in range(c)] for _ in range(r)]\n    q = [(0, (0, 0))]\n    maxArr = [[0 for _ in range(c)] for _ in range(r)]\n    for i in range(r):\n        for j in range(c):\n            maxArr[i][j] = mat[i][j]\n    while q:\n        curr = q.pop(0)\n        x = curr[1][0]\n        y = curr[1][1]\n        count = curr[0]\n        if x >= r or y >= c:\n            continue\n        X = [1, 0]\n        Y = [0, 1]\n        vis[x][y] = 1\n        if count == 0:\n            for i in range(2):\n                u = X[i] + x\n                v = Y[i] + y\n                if is_valid(mat, u, v):\n                    if vis[u][v]:\n                        maxArr[u][v] = min(maxArr[u][v], max(mat[u][v], maxArr[x][y]))\n                    else:\n                        maxArr[u][v] = max(mat[u][v], maxArr[x][y])\n                        q.append((1 - count, (u, v)))\n                        vis[u][v] = 1\n        else:\n            val = 0\n            ind = -1\n            if x + 1 < r:\n                if mat[x + 1][y] > val:\n                    val = max(val, mat[x + 1][y])\n                    ind = 0\n            if y + 1 < c:\n                if mat[x][1 + y] > val:\n                    val = max(val, mat[x][1 + y])\n                    ind = 1\n            if ind == 1:\n                q.append((1 - count, (x, y + 1)))\n                if vis[x][y + 1] == 1:\n                    maxArr[x][y + 1] = min(maxArr[x][y + 1], max(maxArr[x][y], mat[x][y + 1]))\n                else:\n                    maxArr[x][y + 1] = max(maxArr[x][y], mat[x][y + 1])\n                vis[x][y + 1] = 1\n            if ind == 0:\n                q.append((1 - count, (x + 1, y)))\n                if vis[x + 1][y] == 1:\n                    maxArr[x + 1][y] = min(maxArr[x + 1][y], max(maxArr[x][y], mat[x + 1][y]))\n                else:\n                    maxArr[x + 1][y] = max(maxArr[x][y], mat[x + 1][y])\n                vis[x + 1][y] = 1\n    return maxArr[-1][-1]\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    return str(input())\n\ndef invr():\n    return map(int, input().split())\nT = inp()\nfor i in range(T):\n    x = inlt()\n    r = x[0]\n    c = x[1]\n    mat = []\n    for i in range(r):\n        mat.append(inlt())\n    print(sol(r, c, mat))", "for t in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    dp = []\n    for i in range(n):\n        curr = []\n        for i in range(m):\n            curr.append([0, 0])\n        dp.append(curr)\n    dp[-1][-1][0] = int(a[-1][-1])\n    dp[-1][-1][1] = int(a[-1][-1])\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            if i < n - 1 and j < m - 1:\n                if a[i][j + 1] < a[i + 1][j]:\n                    target = (i + 1, j)\n                else:\n                    target = (i, j + 1)\n                dp[i][j][0] += max(a[i][j], dp[target[0]][target[1]][1])\n            elif i < n - 1:\n                target = (i + 1, j)\n                dp[i][j][0] += max(a[i][j], dp[target[0]][target[1]][1])\n            elif j < m - 1:\n                target = (i, j + 1)\n                dp[i][j][0] += max(a[i][j], dp[target[0]][target[1]][1])\n            if i < n - 1 and j < m - 1:\n                dp[i][j][1] += max(a[i][j], min(dp[i + 1][j][0], dp[i][j + 1][0]))\n            elif i < n - 1:\n                dp[i][j][1] += max(a[i][j], dp[i + 1][j][0])\n            elif j < m - 1:\n                dp[i][j][1] += max(a[i][j], dp[i][j + 1][0])\n    print(dp[0][0][1])", "from sys import setrecursionlimit\nmod_ = 10 ** 9 + 7\nsetrecursionlimit(10 ** 7)\n\ndef f(i, j, n, m, a, flag, map_):\n    if (i, j, flag) in map_:\n        return map_[i, j, flag]\n    if (i, j) == (n - 1, m - 1):\n        return a[i][j]\n    max_ = a[i][j]\n    if i == n - 1:\n        max_ = max(max_, f(i, j + 1, n, m, a, 0, map_))\n        map_[i, j, flag] = max_\n        return max_\n    if j == m - 1:\n        max_ = max(max_, f(i + 1, j, n, m, a, 0, map_))\n        map_[i, j, flag] = max_\n        return max_\n    if not flag:\n        cur = 0\n        if a[i + 1][j] > a[i][j + 1]:\n            cur = f(i + 1, j, n, m, a, 1, map_)\n        else:\n            cur = f(i, j + 1, n, m, a, 1, map_)\n        max_ = max(max_, cur)\n    else:\n        max_ = max(max_, min(f(i + 1, j, n, m, a, 0, map_), f(i, j + 1, n, m, a, 0, map_)))\n    map_[i, j, flag] = max_\n    return max_\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = [0] * (n + 1)\n    for i in range(n):\n        a[i] = list(map(int, input().split())) + [0]\n    a[n] = [0] * (m + 1)\n    map_ = {}\n    print(f(0, 0, n, m, a, 1, map_))", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    mat = []\n    for _ in range(n):\n        mat.append(list(map(int, input().split())))\n\n    def valid(i, j):\n        if 1 <= i <= n and 1 <= j <= m:\n            return True\n        return False\n\n    def check(t):\n        seen = set()\n        q = [(1, 1, 0)]\n        if mat[0][0] > t:\n            return False\n        while q:\n            (x, y, v) = q.pop()\n            if x == n and y == m:\n                return True\n            else:\n                v1 = -float('inf')\n                (a, b) = (-1, -1)\n                for (dx, dy) in [(0, 1), (1, 0)]:\n                    (nx, ny) = (dx + x, dy + y)\n                    if v == 0:\n                        if valid(nx, ny) and mat[nx - 1][ny - 1] <= t and ((nx, ny, 1) not in seen):\n                            q.append((nx, ny, 1))\n                            seen.add((nx, ny, 1))\n                    else:\n                        v2 = -float('inf') if not valid(nx, ny) else mat[nx - 1][ny - 1]\n                        if v2 > v1:\n                            v1 = max(v1, v2)\n                            (a, b) = (nx, ny)\n                if v != 0 and v1 <= t and ((a, b, 0) not in seen):\n                    q.append((a, b, 0))\n                    seen.add((a, b, 0))\n        return False\n    low = 0\n    high = 10 ** 6\n    while low <= high:\n        mid = (low + high) // 2\n        if check(mid):\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(list(map(int, input().split())))\n    dp = [[arr[i][j] for j in range(m)] for i in range(n)]\n    for i in range(n - 2, -1, -1):\n        dp[i][-1] = max(dp[i][-1], dp[i + 1][-1])\n    for i in range(m - 2, -1, -1):\n        dp[-1][i] = max(dp[-1][i], dp[-1][i + 1])\n    for i in range(n - 2, -1, -1):\n        for j in range(m - 2, -1, -1):\n            if (i + j) % 2:\n                if arr[i + 1][j] > arr[i][j + 1]:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i][j + 1], dp[i][j])\n            else:\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]), dp[i][j])\n    print(dp[0][0])", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    mat = []\n    for _ in range(n):\n        mat.append(list(map(int, input().split())))\n\n    def valid(i, j):\n        if 1 <= i <= n and 1 <= j <= m:\n            return True\n        return False\n\n    def check(t):\n        seen = set()\n        q = [(1, 1, 0)]\n        if mat[0][0] > t:\n            return False\n        while q:\n            (x, y, v) = q.pop()\n            if x == n and y == m:\n                return True\n            else:\n                v1 = -float('inf')\n                (a, b) = (-1, -1)\n                for (dx, dy) in [(0, 1), (1, 0)]:\n                    (nx, ny) = (dx + x, dy + y)\n                    if v == 0:\n                        if valid(nx, ny) and mat[nx - 1][ny - 1] <= t and ((nx, ny, 1) not in seen):\n                            q.append((nx, ny, 1))\n                            seen.add((nx, ny, 1))\n                    else:\n                        v2 = -float('inf') if not valid(nx, ny) else mat[nx - 1][ny - 1]\n                        if v2 > v1:\n                            v1 = max(v1, v2)\n                            (a, b) = (nx, ny)\n                if v != 0 and v1 <= t and ((a, b, 0) not in seen):\n                    q.append((a, b, 0))\n                    seen.add((a, b, 0))\n        return False\n    low = 0\n    high = 10 ** 6\n    while low <= high:\n        mid = (low + high) // 2\n        if check(mid):\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    grid = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        grid.append(a)\n    dp = [[0 for x in range(m + 1)] for j in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            if i == n - 1 and j == m - 1:\n                dp[i][j] = grid[i][j]\n            elif i == n - 1:\n                dp[i][j] = max(grid[i][j], dp[i][j + 1])\n            elif j == m - 1:\n                dp[i][j] = max(grid[i][j], dp[i + 1][j])\n            elif (i + j) % 2 == 0:\n                dp[i][j] = max(grid[i][j], min(dp[i + 1][j], dp[i][j + 1]))\n            elif grid[i + 1][j] > grid[i][j + 1]:\n                dp[i][j] = max(grid[i][j], dp[i + 1][j])\n            else:\n                dp[i][j] = max(grid[i][j], dp[i][j + 1])\n    print(dp[0][0])", "import sys\nsys.setrecursionlimit(10 ** 6)\nt = int(input())\n\ndef getminval(grid, i, j, m, n, becky, cache):\n    if (i, j) == (m - 1, n - 1):\n        return grid[i][j]\n    key = (becky, i, j)\n    if key in cache:\n        return cache[key]\n    if i == m - 1:\n        curr = getminval(grid, i, j + 1, m, n, not becky, cache)\n        res = max(grid[i][j], curr)\n        cache[key] = res\n        return res\n    if j == n - 1:\n        curr = getminval(grid, i + 1, j, m, n, not becky, cache)\n        res = max(grid[i][j], curr)\n        cache[key] = res\n        return res\n    if becky:\n        a = max(grid[i][j], getminval(grid, i + 1, j, m, n, not becky, cache))\n        b = max(grid[i][j], getminval(grid, i, j + 1, m, n, not becky, cache))\n        res = min(a, b)\n        cache[key] = res\n        return res\n    elif grid[i + 1][j] > grid[i][j + 1]:\n        curr = getminval(grid, i + 1, j, m, n, not becky, cache)\n        res = max(grid[i][j], curr)\n        cache[key] = res\n        return res\n    else:\n        curr = getminval(grid, i, j + 1, m, n, not becky, cache)\n        res = max(grid[i][j], curr)\n        cache[key] = res\n        return res\nfor _ in range(t):\n    (m, n) = map(int, input().split())\n    grid = []\n    for __ in range(m):\n        grid.append(list(map(int, input().split())))\n    print(getminval(grid, 0, 0, m, n, True, {}))", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    dp = [[0] * m for i in range(n)]\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            if j != m - 1:\n                bla1 = grid[i][j + 1]\n                (i1, j1) = (i, j + 1)\n                if i1 + 1 < n and j1 + 1 < m:\n                    bla1 = max(bla1, dp[i1 + 1][j1]) if grid[i1 + 1][j1] >= grid[i1][j1 + 1] else max(bla1, dp[i1][j1 + 1])\n                elif i1 + 1 < n:\n                    bla1 = max(bla1, dp[i1 + 1][j1])\n                elif j1 + 1 < m:\n                    bla1 = max(bla1, dp[i1][j1 + 1])\n                else:\n                    bla1 = bla1\n            else:\n                bla1 = float('inf') * -1\n            if i != n - 1:\n                bla2 = grid[i + 1][j]\n                (i1, j1) = (i + 1, j)\n                if i1 + 1 < n and j1 + 1 < m:\n                    bla2 = max(bla2, dp[i1 + 1][j1]) if grid[i1 + 1][j1] >= grid[i1][j1 + 1] else max(bla2, dp[i1][j1 + 1])\n                elif i1 + 1 < n:\n                    bla2 = max(bla2, dp[i1 + 1][j1])\n                elif j1 + 1 < m:\n                    bla2 = max(bla2, dp[i1][j1 + 1])\n                else:\n                    bla2 = bla2\n            else:\n                bla2 = float('inf') * -1\n            if i != n - 1 and j != m - 1:\n                dp[i][j] = min(max(grid[i][j], bla1), max(grid[i][j], bla2))\n            elif i != n - 1:\n                dp[i][j] = max(grid[i][j], bla2)\n            elif j != m - 1:\n                dp[i][j] = max(grid[i][j], bla1)\n            else:\n                dp[i][j] = grid[i][j]\n    print(dp[0][0])", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    mat = []\n    for _ in range(n):\n        mat.append(list(map(int, input().split())))\n\n    def valid(i, j):\n        if 1 <= i <= n and 1 <= j <= m:\n            return True\n        return False\n\n    def check(t):\n        seen = set()\n        q = [(1, 1, 0)]\n        if mat[0][0] > t:\n            return False\n        while q:\n            (x, y, v) = q.pop()\n            if x == n and y == m:\n                return True\n            else:\n                v1 = -float('inf')\n                (a, b) = (-1, -1)\n                for (dx, dy) in [(0, 1), (1, 0)]:\n                    (nx, ny) = (dx + x, dy + y)\n                    if v == 0:\n                        if valid(nx, ny) and mat[nx - 1][ny - 1] <= t and ((nx, ny, 1) not in seen):\n                            q.append((nx, ny, 1))\n                            seen.add((nx, ny, 1))\n                    else:\n                        v2 = -float('inf') if not valid(nx, ny) else mat[nx - 1][ny - 1]\n                        if v2 > v1:\n                            v1 = max(v1, v2)\n                            (a, b) = (nx, ny)\n                if v != 0 and v1 <= t and ((a, b, 0) not in seen):\n                    q.append((a, b, 0))\n                    seen.add((a, b, 0))\n        return False\n    low = 0\n    high = 10 ** 6\n    while low <= high:\n        mid = (low + high) // 2\n        if check(mid):\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)"]