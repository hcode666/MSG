["from collections import defaultdict\nt = int(input())\nfor cas in range(t):\n    n = int(input())\n    s = input().split()\n    nums = [int(i) for i in s]\n    ans = True\n    bitsets = defaultdict(set)\n    bits_unified = defaultdict(set)\n    for (idx, num) in enumerate(nums):\n        matching_sets = []\n        unified_or = num\n        for bu in bits_unified:\n            if bu & num > 0:\n                unified_or |= bu\n                matching_sets.append(bu)\n        for match in matching_sets:\n            del bits_unified[match]\n        bits_unified[unified_or] = set()\n        for i in range(32):\n            if num & 1 << i:\n                bitsets[i].add(idx)\n    for bu in bits_unified:\n        for i in range(32):\n            if bu & 1 << i:\n                bits_unified[bu] = bits_unified[bu].union(bitsets[i])\n    for k in bits_unified:\n        bitgroup = bits_unified[k]\n        n = len(bitgroup)\n        vals = sorted([nums[i] for i in bitgroup])\n        indices = sorted([i for i in bitgroup])\n        for i in range(n):\n            nums[indices[i]] = vals[i]\n    ans = True\n    for i in range(len(nums) - 1):\n        if nums[i] > nums[i + 1]:\n            ans = False\n            break\n    if ans:\n        print('Yes')\n    else:\n        print('No')", "from collections import defaultdict\nt = int(input())\nfor cas in range(t):\n    n = int(input())\n    s = input().split()\n    nums = [int(i) for i in s]\n    ans = True\n    bitsets = defaultdict(set)\n    bits_unified = defaultdict(set)\n    for (idx, num) in enumerate(nums):\n        matching_sets = []\n        unified_or = num\n        for bu in bits_unified:\n            if bu & num > 0:\n                unified_or |= bu\n                matching_sets.append(bu)\n        for match in matching_sets:\n            del bits_unified[match]\n        bits_unified[unified_or] = set()\n        for i in range(32):\n            if num & 1 << i:\n                bitsets[i].add(idx)\n    for bu in bits_unified:\n        for i in range(32):\n            if bu & 1 << i:\n                bits_unified[bu] = bits_unified[bu].union(bitsets[i])\n    for k in bits_unified:\n        bitgroup = bits_unified[k]\n        n = len(bitgroup)\n        vals = sorted([nums[i] for i in bitgroup])\n        indices = sorted([i for i in bitgroup])\n        for i in range(n):\n            nums[indices[i]] = vals[i]\n    ans = True\n    for i in range(len(nums) - 1):\n        if nums[i] > nums[i + 1]:\n            ans = False\n            break\n    if ans:\n        print('Yes')\n    else:\n        print('No')", "from collections import defaultdict as dd\nt = int(input())\nfor s in range(t):\n    num = int(input())\n    bit = list(map(int, input().split()))\n    max = -50\n    for i in bit:\n        if i > max:\n            max = i\n    binary = len(bin(max).replace('0b', ''))\n    bn = []\n    ids = 0\n    zds = 0\n    for iterable in bit:\n        if iterable == 0:\n            zds = ids\n        b = bin(iterable).replace('0b', '')\n        bn.append('0' * (binary - len(b)) + b)\n    dp = [[float('inf')] * binary for x in range(num)]\n    diff = []\n    current = 2\n    minimum = current\n    for i in range(binary):\n        if bn[0][i] == '1':\n            dp[0][i] = 1\n    for i in range(1, num):\n        alter = dd(int)\n        for j in range(binary):\n            if bn[i][j] == '1':\n                minimum = min(minimum, dp[i - 1][j])\n                dp[i][j] = minimum\n                diff.append(j)\n                if dp[i - 1][j] != float('inf'):\n                    alter[dp[i - 1][j]] = 1\n            else:\n                dp[i][j] = dp[i - 1][j]\n        for k in range(binary):\n            if bn[i][k] == '1' or alter[dp[i][k]]:\n                dp[i][k] = minimum\n        current += 1\n        minimum = current\n        diff = []\n    cy = dd(list)\n    for i in range(num):\n        for j in range(binary):\n            if bn[i][j] == '1':\n                cy[dp[-1][j]].append([bit[i], i])\n                break\n    res = sorted(bit)\n    for i in cy:\n        values = []\n        place = []\n        for (j, k) in cy[i]:\n            values.append(j)\n            place.append(k)\n        values.sort()\n        t = 0\n        for element in values:\n            bit[place[t]] = element\n            t += 1\n    if bit == res:\n        print('Yes')\n    else:\n        print('No')", "from collections import defaultdict as dd\nfor _ in range(int(input())):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    mx = max(lst)\n    bn = len(bin(mx).replace('0b', ''))\n    bform = []\n    idz = 0\n    zid = 0\n    for x in lst:\n        if x == 0:\n            zid = idz\n        bf = bin(x).replace('0b', '')\n        bform.append('0' * (bn - len(bf)) + bf)\n    dp = [[float('inf')] * bn for _ in range(n)]\n    curr = 2\n    mn = curr\n    change = []\n    for x in range(bn):\n        if bform[0][x] == '1':\n            dp[0][x] = 1\n    for x in range(1, n):\n        changed = dd(int)\n        for y in range(bn):\n            if bform[x][y] == '1':\n                mn = min(mn, dp[x - 1][y])\n                dp[x][y] = mn\n                change.append(y)\n                if dp[x - 1][y] != float('inf'):\n                    changed[dp[x - 1][y]] = 1\n            else:\n                dp[x][y] = dp[x - 1][y]\n        for z in range(bn):\n            if bform[x][z] == '1' or changed[dp[x][z]]:\n                dp[x][z] = mn\n        curr += 1\n        mn = curr\n        change = []\n    cycles = dd(list)\n    for x in range(n):\n        for y in range(bn):\n            if bform[x][y] == '1':\n                cycles[dp[-1][y]].append([lst[x], x])\n                break\n    rslt = sorted(lst)\n    for x in cycles:\n        values = []\n        adress = []\n        for (y, z) in cycles[x]:\n            values.append(y)\n            adress.append(z)\n        values.sort()\n        t = 0\n        for el in values:\n            lst[adress[t]] = el\n            t += 1\n    print('Yes' if lst == rslt else 'No ')", "import time\n\ndef solve(N, list):\n    if N <= 1:\n        return 'Yes'\n    masks = {}\n    lm = []\n    ss = sorted(list)\n    for i in range(len(ss) - 1, -1, -1):\n        n = ss[i]\n        found = False\n        for j in range(len(lm)):\n            m = lm[j]\n            if m & n != 0:\n                found = True\n                lm[j] |= n\n                masks[n] = j\n        if not found:\n            lm.append(n)\n            masks[n] = len(lm) - 1\n    for jj in range(N):\n        if masks[ss[jj]] != masks[list[jj]]:\n            return 'No'\n    return 'Yes'\ntic = time.perf_counter()\nT = int(input())\nres = []\nfor i in range(T):\n    N = int(input())\n    list = [int(x) for x in input().split()]\n    res.append(solve(N, list))\nfor el in res:\n    print(el)\ntoc = time.perf_counter()", "import sys\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom collections import deque\nsys.setrecursionlimit(10 ** 8)\nfrom queue import PriorityQueue as pq\nfrom math import gcd\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nlii = lambda : list(map(int, list(ip())))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\ninv = lambda x: pow(x, mod - 2, mod)\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\ndef get(a):\n    if a == par[a]:\n        return a\n    par[a] = get(par[a])\n    return par[a]\n\ndef join(a, b):\n    a = get(a)\n    b = get(b)\n    if a == b:\n        return\n    try:\n        par[a] = b\n    except:\n        pass\nfor _ in range(ii()):\n    n = ii()\n    a = il()\n    if a == sorted(a):\n        print('Yes')\n        continue\n    par = [i for i in range(n + 1)]\n    for i in range(32):\n        temp = []\n        for j in range(n):\n            if a[j] & 1 << i:\n                temp.append(j)\n        for j in range(1, len(temp)):\n            join(temp[j - 1] + 1, temp[j] + 1)\n    b = sorted(a)\n    d = {}\n    for i in range(n):\n        if d.get(b[i]):\n            d[b[i]].append(i + 1)\n        else:\n            d[b[i]] = [i + 1]\n    val = [[[], []] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        val[get(i)][0].append(i)\n        val[get(i)][1].append(d[a[i - 1]][-1])\n        d[a[i - 1]].pop()\n    fl = 0\n    for i in range(n):\n        if sorted(val[i][0]) != sorted(val[i][1]):\n            fl = 1\n            break\n    if fl:\n        print('No')\n    else:\n        print('Yes')", "import math\n\ndef is_sorted(array, sz):\n    if sz == 1:\n        return True\n    for idx in range(sz - 1):\n        if array[idx] > array[idx + 1]:\n            return False\n    return True\n\ndef can_sort(array, sz):\n    if is_sorted(array, sz):\n        return True\n    parent = list(range(sz))\n\n    def union(i, j):\n        parent[find(j)] = find(i)\n        return\n\n    def find(i):\n        if i != parent[i]:\n            parent[i] = find(parent[i])\n        return parent[i]\n    max_digits = int(math.log2(max(array))) + 1\n    arr_copy = array[:]\n    for dig in range(max_digits):\n        first_idx = None\n        for idx in range(sz):\n            num = arr_copy[idx]\n            if num % 2 == 1:\n                if first_idx is None:\n                    first_idx = idx\n                else:\n                    try:\n                        union(first_idx, idx)\n                    except Exception:\n                        pass\n            arr_copy[idx] = num // 2\n    array_indices = [(num, idx) for (idx, num) in enumerate(array)]\n    sorted_array_indices = sorted(array_indices)\n    for (orig, fin) in zip(array_indices, sorted_array_indices):\n        if find(orig[1]) != find(fin[1]):\n            return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().strip().split(' ')))\n    print('Yes' if can_sort(arr, n) else 'No')", "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = parent[find(parent, parent[x])]\n    return parent[x]\n\ndef union(parent, rank, length, x, y):\n    u = find(parent, x)\n    v = find(parent, y)\n    if u == v:\n        return u\n    if rank[u] > rank[v]:\n        parent[v] = u\n        length[u] += length[v]\n        return u\n    elif rank[v] > rank[u]:\n        parent[u] = v\n        length[v] += length[u]\n        return v\n    if length[u] > length[v]:\n        parent[v] = u\n        length[u] += length[v]\n        rank[u] += 1\n        return u\n    parent[u] = v\n    length[v] += length[u]\n    rank[v] += 1\n    return v\n\ndef setup():\n    N = int(input())\n    arr = [x for x in map(int, input().split())]\n    length = [1] * N\n    rank = [1] * N\n    parent = list(range(N))\n    for ii in range(33):\n        i = 0\n        while i < N and (not arr[i] & 1 << ii):\n            i += 1\n        if i < N:\n            u = find(parent, i)\n            i += 1\n            while i < N:\n                if arr[i] & 1 << ii:\n                    v = union(parent, rank, length, u, i)\n                    if length[v] == N:\n                        return True\n                i += 1\n            if length[u] == N:\n                return True\n    dic = {}\n    for i in range(N):\n        x = parent[i]\n        if x in dic:\n            dic[x].append(i)\n        else:\n            dic[x] = [i]\n    for x in dic.values():\n        tempU = sorted(list((arr[y] for y in x)))\n        for i in range(len(x)):\n            arr[x[i]] = tempU[i]\n    for i in range(1, N):\n        if arr[i - 1] > arr[i]:\n            return False\n    return True\nT = int(input())\nfor _ in range(T):\n    if setup():\n        print('Yes')\n    else:\n        print('No')", "import sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef st():\n    return input().rstrip('\\n')\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\nt = inp()\npo = [1]\nfor i in range(30):\n    po.append(2 * po[-1])\nwhile t:\n    t -= 1\n    n = inp()\n    a = lis()\n    bits = [set() for i in range(31)]\n    for i in range(n):\n        for j in range(31):\n            if po[j] & a[i]:\n                bits[j].add(i)\n    for i in range(31):\n        for j in range(i + 1, 31):\n            common = bits[i].intersection(bits[j])\n            if len(common):\n                new = set()\n                for k in bits[i]:\n                    new.add(k)\n                for k in bits[j]:\n                    new.add(k)\n                bits[i] = {}\n                bits[j] = new\n                break\n    a1 = [0] * n\n    for i in range(31):\n        new = []\n        ind = []\n        for j in bits[i]:\n            new.append(a[j])\n            ind.append(j)\n        new.sort()\n        ind.sort()\n        for j in range(len(ind)):\n            a1[ind[j]] = new[j]\n    a.sort()\n    if a == a1:\n        print('Yes')\n    else:\n        print('No')"]