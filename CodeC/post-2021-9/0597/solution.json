["from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\nclass fenwicktree:\n\n    def __init__(self, n):\n        self.BITTree = [0] * (n + 1)\n        self.size = n\n\n    def getsum(self, i):\n        s = 0\n        i = i + 1\n        while i > 0:\n            s += self.BITTree[i]\n            i -= i & -i\n        return s\n\n    def query(self, l, r):\n        return self.getsum(r) - self.getsum(l - 1)\n\n    def update(self, i, v):\n        i += 1\n        while i <= self.size:\n            self.BITTree[i] += v\n            i += i & -i\n\ndef dfs(p, prev):\n    v = a[p - 1]\n    for i in child[p]:\n        v += a[i - 1]\n    count.update(v, 1)\n    for i in child[p]:\n        if i == prev:\n            continue\n        dfs(i, p)\n    for i in take[p]:\n        (t, k, ind) = i\n        (l, h) = (0, n)\n        point = -1\n        while l <= h:\n            mid = (l + h) // 2\n            if count.query(n - mid, n) < t:\n                l = mid + 1\n            else:\n                point = n - mid\n                h = mid - 1\n        if point == -1:\n            continue\n        c = point\n        (l, h) = (0, k)\n        while l <= h:\n            mid = (l + h) // 2\n            val = c * (mid * (mid + 1) // 2)\n            if val < k:\n                l = mid + 1\n            else:\n                ans[ind] = mid\n                h = mid - 1\n    for i in take[p]:\n        (t, k, ind) = i\n    count.update(v, -1)\nfor T in range(1):\n    n = int(input())\n    a = inp()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    take = [[] for i in range(n + 1)]\n    m = int(input())\n    for q in range(m):\n        (x, t, k) = inp()\n        take[x].append([t, k, q])\n    ans = [-1 for i in range(m)]\n    count = fenwicktree(n + 1)\n    dfs(1, 0)\n    print(*ans, sep='\\n')", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\nclass fenwicktree:\n\n    def __init__(self, n):\n        self.BITTree = [0] * (n + 1)\n        self.size = n\n\n    def getsum(self, i):\n        s = 0\n        i = i + 1\n        while i > 0:\n            s += self.BITTree[i]\n            i -= i & -i\n        return s\n\n    def query(self, l, r):\n        return self.getsum(r) - self.getsum(l - 1)\n\n    def update(self, i, v):\n        i += 1\n        while i <= self.size:\n            self.BITTree[i] += v\n            i += i & -i\n\ndef dfs(p, prev):\n    v = a[p - 1]\n    for i in child[p]:\n        v += a[i - 1]\n    count.update(v, 1)\n    for i in child[p]:\n        if i == prev:\n            continue\n        dfs(i, p)\n    for i in take[p]:\n        (t, k, ind) = i\n        (l, h) = (0, n)\n        point = -1\n        while l <= h:\n            mid = (l + h) // 2\n            if count.query(n - mid, n) < t:\n                l = mid + 1\n            else:\n                point = n - mid\n                h = mid - 1\n        if point == -1:\n            continue\n        c = point\n        (l, h) = (0, k)\n        while l <= h:\n            mid = (l + h) // 2\n            val = c * (mid * (mid + 1) // 2)\n            if val < k:\n                l = mid + 1\n            else:\n                ans[ind] = mid\n                h = mid - 1\n    for i in take[p]:\n        (t, k, ind) = i\n    count.update(v, -1)\nfor T in range(1):\n    n = int(input())\n    a = inp()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    take = [[] for i in range(n + 1)]\n    m = int(input())\n    for q in range(m):\n        (x, t, k) = inp()\n        take[x].append([t, k, q])\n    ans = [-1 for i in range(m)]\n    count = fenwicktree(n + 1)\n    dfs(1, 0)\n    print(*ans, sep='\\n')", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\nclass fenwicktree:\n\n    def __init__(self, n):\n        self.BITTree = [0] * (n + 1)\n        self.size = n\n\n    def getsum(self, i):\n        s = 0\n        i = i + 1\n        while i > 0:\n            s += self.BITTree[i]\n            i -= i & -i\n        return s\n\n    def query(self, l, r):\n        return self.getsum(r) - self.getsum(l - 1)\n\n    def update(self, i, v):\n        i += 1\n        while i <= self.size:\n            self.BITTree[i] += v\n            i += i & -i\n\ndef dfs(p, prev):\n    v = a[p - 1]\n    for i in child[p]:\n        v += a[i - 1]\n    count.update(v, 1)\n    for i in child[p]:\n        if i == prev:\n            continue\n        dfs(i, p)\n    for i in take[p]:\n        (t, k, ind) = i\n        (l, h) = (0, n)\n        point = -1\n        while l <= h:\n            mid = (l + h) // 2\n            if count.query(n - mid, n) < t:\n                l = mid + 1\n            else:\n                point = n - mid\n                h = mid - 1\n        if point == -1:\n            continue\n        c = point\n        (l, h) = (0, k)\n        while l <= h:\n            mid = (l + h) // 2\n            val = c * (mid * (mid + 1) // 2)\n            if val < k:\n                l = mid + 1\n            else:\n                ans[ind] = mid\n                h = mid - 1\n    for i in take[p]:\n        (t, k, ind) = i\n    count.update(v, -1)\nfor T in range(1):\n    n = int(input())\n    a = inp()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    take = [[] for i in range(n + 1)]\n    m = int(input())\n    for q in range(m):\n        (x, t, k) = inp()\n        take[x].append([t, k, q])\n    ans = [-1 for i in range(m)]\n    count = fenwicktree(n + 1)\n    dfs(1, 0)\n    print(*ans, sep='\\n')"]