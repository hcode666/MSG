["def works(vec, mask):\n    if vec[-1] & mask != vec[-1]:\n        return False\n    mx = 0\n    for (i, v) in zip(range(len(vec)), vec):\n        if i > mx:\n            break\n        if v & mask == v and v + i > mx:\n            mx = v + i\n    return mx >= len(vec) - 1\nt = int(input())\nfor _ in range(t):\n    __ = input()\n    vec = [int(x) for x in input().split()]\n    if not works(vec, (1 << 20) - 1):\n        print(-1)\n    else:\n        ans = 0\n        for bit in range(19, -1, -1):\n            if not works(vec, ans | (1 << bit) - 1):\n                ans |= 1 << bit\n        print(ans)", "def works(vec, mask):\n    if vec[-1] & mask != vec[-1]:\n        return False\n    mx = 0\n    for (i, v) in zip(range(len(vec)), vec):\n        if i > mx:\n            break\n        if v & mask == v and v + i > mx:\n            mx = v + i\n    return mx >= len(vec) - 1\nt = int(input())\nfor _ in range(t):\n    __ = input()\n    vec = [int(x) for x in input().split()]\n    if not works(vec, (1 << 20) - 1):\n        print(-1)\n    else:\n        ans = 0\n        for bit in range(19, -1, -1):\n            if not works(vec, ans | (1 << bit) - 1):\n                ans |= 1 << bit\n        print(ans)", "def works(vec, mask):\n    if vec[-1] & mask != vec[-1]:\n        return False\n    mx = 0\n    for (i, v) in zip(range(len(vec)), vec):\n        if i > mx:\n            break\n        if v & mask == v and v + i > mx:\n            mx = v + i\n    return mx >= len(vec) - 1\nt = int(input())\nfor _ in range(t):\n    __ = input()\n    vec = [int(x) for x in input().split()]\n    if not works(vec, (1 << 20) - 1):\n        print(-1)\n    else:\n        ans = 0\n        for bit in range(19, -1, -1):\n            if not works(vec, ans | (1 << bit) - 1):\n                ans |= 1 << bit\n        print(ans)", "def works(vec, mask):\n    if vec[-1] & mask != vec[-1]:\n        return False\n    mx = 0\n    for (i, v) in zip(range(len(vec)), vec):\n        if i > mx:\n            break\n        if v & mask == v and v + i > mx:\n            mx = v + i\n    return mx >= len(vec) - 1\nt = int(input())\nfor _ in range(t):\n    __ = input()\n    vec = [int(x) for x in input().split()]\n    if not works(vec, (1 << 20) - 1):\n        print(-1)\n    else:\n        ans = 0\n        for bit in range(19, -1, -1):\n            if not works(vec, ans | (1 << bit) - 1):\n                ans |= 1 << bit\n        print(ans)", "def works(vec, mask):\n    if vec[-1] & mask != vec[-1]:\n        return False\n    mx = 0\n    for (i, v) in zip(range(len(vec)), vec):\n        if i > mx:\n            break\n        if v & mask == v and v + i > mx:\n            mx = v + i\n    return mx >= len(vec) - 1\nt = int(input())\nfor _ in range(t):\n    __ = input()\n    vec = [int(x) for x in input().split()]\n    if not works(vec, (1 << 20) - 1):\n        print(-1)\n    else:\n        ans = 0\n        for bit in range(19, -1, -1):\n            if not works(vec, ans | (1 << bit) - 1):\n                ans |= 1 << bit\n        print(ans)", "def works(vec, mask):\n    if vec[-1] & mask != vec[-1]:\n        return False\n    mx = 0\n    for (i, v) in zip(range(len(vec)), vec):\n        if i > mx:\n            break\n        if v & mask == v and v + i > mx:\n            mx = v + i\n    return mx >= len(vec) - 1\nt = int(input())\nfor _ in range(t):\n    __ = input()\n    vec = [int(x) for x in input().split()]\n    if not works(vec, (1 << 20) - 1):\n        print(-1)\n    else:\n        ans = 0\n        for bit in range(19, -1, -1):\n            if not works(vec, ans | (1 << bit) - 1):\n                ans |= 1 << bit\n        print(ans)", "import math\n\ndef can_cross(arr, removed, bit):\n    length = len(arr)\n    reach = 0\n    for i in range(length):\n        if reach < i:\n            return False\n        if i not in removed and (not arr[i] & 1 << bit):\n            reach = max(reach, i + arr[i])\n        if reach >= length:\n            return True\n    return True\ntests = int(input())\nfor i in range(tests):\n    length = int(input())\n    arr = list(map(int, input().split()))\n    maximum_bit = math.ceil(math.log(max(arr), 2))\n    removed = set()\n    ans = 0\n    if can_cross(arr, removed, maximum_bit + 1):\n        for j in range(maximum_bit, -1, -1):\n            if arr[0] & 1 << j or arr[-1] & 1 << j or (not can_cross(arr, removed, j)):\n                ans |= 1 << j\n            else:\n                for k in range(length):\n                    if arr[k] & 1 << j:\n                        removed.add(k)\n    else:\n        ans = -1\n    print(ans)", "def works(vec, mask):\n    if vec[-1] & mask != vec[-1]:\n        return False\n    mx = 0\n    for (i, v) in zip(range(len(vec)), vec):\n        if i > mx:\n            break\n        if v & mask == v and v + i > mx:\n            mx = v + i\n    return mx >= len(vec) - 1\nt = int(input())\nfor _ in range(t):\n    __ = input()\n    vec = [int(x) for x in input().split()]\n    if not works(vec, (1 << 20) - 1):\n        print(-1)\n    else:\n        ans = 0\n        for bit in range(19, -1, -1):\n            if not works(vec, ans | (1 << bit) - 1):\n                ans |= 1 << bit\n        print(ans)", "def works(vec, mask):\n    if vec[-1] & mask != vec[-1]:\n        return False\n    mx = 0\n    for (i, v) in zip(range(len(vec)), vec):\n        if i > mx:\n            break\n        if v & mask == v and v + i > mx:\n            mx = v + i\n    return mx >= len(vec) - 1\nt = int(input())\nfor _ in range(t):\n    __ = input()\n    vec = [int(x) for x in input().split()]\n    if not works(vec, (1 << 20) - 1):\n        print(-1)\n    else:\n        s = 0\n        for bit in range(19, -1, -1):\n            if not works(vec, s | (1 << bit) - 1):\n                s |= 1 << bit\n        print(s)", "def works(vec, mask):\n    if vec[-1] & mask != vec[-1]:\n        return False\n    mx = 0\n    for (i, v) in zip(range(len(vec)), vec):\n        if i > mx:\n            break\n        if v & mask == v and v + i > mx:\n            mx = v + i\n    return mx >= len(vec) - 1\nt = int(input())\nfor _ in range(t):\n    __ = input()\n    vec = [int(x) for x in input().split()]\n    if not works(vec, (1 << 20) - 1):\n        print(-1)\n    else:\n        ans = 0\n        for bit in range(19, -1, -1):\n            if not works(vec, ans | (1 << bit) - 1):\n                ans |= 1 << bit\n        print(ans)", "def works(vec, mask):\n    if vec[-1] & mask != vec[-1]:\n        return False\n    mx = 0\n    for (i, v) in zip(range(len(vec)), vec):\n        if i > mx:\n            break\n        if v & mask == v and v + i > mx:\n            mx = v + i\n    return mx >= len(vec) - 1\nt = int(input())\nfor _ in range(t):\n    __ = input()\n    vec = [int(x) for x in input().split()]\n    if not works(vec, (1 << 20) - 1):\n        print(-1)\n    else:\n        ans = 0\n        for bit in range(19, -1, -1):\n            if not works(vec, ans | (1 << bit) - 1):\n                ans |= 1 << bit\n        print(ans)", "def check(arr, mask):\n    if arr[0] & mask != arr[0]:\n        return False\n    if arr[-1] & mask != arr[-1]:\n        return False\n    i = 1\n    max_reach = arr[0]\n    while i < len(arr):\n        if i > max_reach:\n            return False\n        if arr[i] & mask == arr[i]:\n            max_reach = max(max_reach, i + arr[i])\n        i += 1\n    return True\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split(' ')))\n    ans = 0\n    for bit in reversed(range(31)):\n        if check(arr, ans + (1 << bit) - 1):\n            continue\n        else:\n            ans += 1 << bit\n    if check(arr, ans):\n        print(ans)\n    else:\n        print(-1)", "from sys import stdin\ninput = stdin.readline\nBIT = 20\n\ndef solve(N, A):\n    if N == 1:\n        return A[0]\n    maximum = 1\n    i = 1\n    while i <= maximum <= N:\n        maximum = max(maximum, i + A[i])\n        i += 1\n    if maximum < N:\n        return -1\n    answer = 0\n    for b in reversed(range(BIT + 1)):\n        mask = answer + (1 << b) - 1\n        maximum = 1\n        if A[1] & mask == A[1] and A[N] & mask == A[N]:\n            i = 1\n            while i <= maximum and i <= N:\n                if A[i] & mask == A[i]:\n                    maximum = max(maximum, i + A[i])\n                i += 1\n        if maximum < N:\n            answer += 1 << b\n    return answer\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    N = int(input().strip())\n    A = [None] + [int(x) for x in input().strip().split()]\n    print(solve(N, A))", "def check(a, mask):\n    if a[0] & mask != a[0]:\n        return False\n    if a[-1] & mask != a[-1]:\n        return False\n    reach = a[0]\n    for i in range(1, n):\n        if i > reach:\n            return False\n        if a[i] & mask == a[i]:\n            reach = max(reach, i + a[i])\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 0\n    for bit in reversed(range(21)):\n        if check(a, ans + (1 << bit) - 1):\n            continue\n        else:\n            ans += 1 << bit\n    if check(a, ans):\n        print(ans)\n    else:\n        print(-1)", "def check(a, mask):\n    if a[0] & mask != a[0]:\n        return False\n    if a[-1] & mask != a[-1]:\n        return False\n    reach = a[0]\n    for i in range(1, n):\n        if i > reach:\n            return False\n        if a[i] & mask == a[i]:\n            reach = max(reach, i + a[i])\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 0\n    for bit in reversed(range(21)):\n        if check(a, ans + (1 << bit) - 1):\n            continue\n        else:\n            ans += 1 << bit\n    if check(a, ans):\n        print(ans)\n    else:\n        print(-1)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n\n    def check(mask):\n        if arr[0] | mask != mask:\n            return False\n        if arr[-1] | mask != mask:\n            return False\n        dp = [False] * n\n        dp[0] = True\n        j = 0\n        for i in range(n):\n            if arr[i] | mask != mask:\n                continue\n            if not dp[i]:\n                continue\n            r = min(n - 1, i + arr[i])\n            while j <= r:\n                if arr[j] | mask == mask:\n                    dp[j] = True\n                j += 1\n        return dp[-1]\n    mask = (1 << 19) - 1\n    if not check(mask):\n        print(-1)\n    else:\n        for i in range(18, -1, -1):\n            mask ^= 1 << i\n            if not check(mask):\n                mask |= 1 << i\n        print(mask)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n\n    def check(mask):\n        if arr[0] | mask != mask:\n            return False\n        if arr[-1] | mask != mask:\n            return False\n        dp = [False] * n\n        dp[0] = True\n        j = 0\n        for i in range(n):\n            if arr[i] | mask != mask:\n                continue\n            if not dp[i]:\n                continue\n            r = min(n - 1, i + arr[i])\n            while j <= r:\n                if arr[j] | mask == mask:\n                    dp[j] = True\n                j += 1\n        return dp[-1]\n    mask = (1 << 19) - 1\n    if not check(mask):\n        print(-1)\n    else:\n        for i in range(18, -1, -1):\n            mask ^= 1 << i\n            if not check(mask):\n                mask |= 1 << i\n        print(mask)", "def decToBin(num):\n    out = [0 for _ in range(32)]\n    idx = 31\n    maxBitPos = 31\n    while num > 0:\n        out[idx] = num % 2\n        if num % 2 == 1:\n            maxBitPos = idx\n        num //= 2\n        idx -= 1\n    return (out, max(0, maxBitPos - 2))\n\ndef binToDec(arr):\n    (num, base) = (0, 1)\n    for bit in arr[::-1]:\n        num += bit * base\n        base *= 2\n    return num\n\ndef isPossible(n, arr):\n    (curr, reach) = (0, 0)\n    while curr < n and curr <= reach:\n        reach = max(reach, curr + arr[curr])\n        curr += 1\n    return reach >= n - 1\n\ndef helper(n, arr, data, ans, k, maxBitPos):\n    (curr, reach) = (0, 0)\n    while curr < n and curr <= reach:\n        isIncluded = True\n        for i in range(maxBitPos, k + 1):\n            if data[curr][i] == 1 and ans[i] == 0:\n                isIncluded = False\n        if isIncluded:\n            reach = max(reach, curr + arr[curr])\n        curr += 1\n    return reach >= n - 1\n\ndef solve(n, arr):\n    if isPossible(n, arr) is False:\n        return -1\n    data = [None for i in range(n)]\n    maxBitPos = 31\n    for i in range(n):\n        (data[i], bitPos) = decToBin(arr[i])\n        maxBitPos = min(maxBitPos, bitPos)\n    ans = [0 for _ in range(32)]\n    for i in range(32):\n        if data[0][i] == 1 or data[-1][i] == 1:\n            ans[i] = 1\n    for i in range(maxBitPos, 32):\n        if ans[i] == 0:\n            if helper(n, arr, data, ans, i, maxBitPos) is False:\n                ans[i] = 1\n    return binToDec(ans)\ntc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(solve(n, arr))", "def canJump(nums):\n    n = len(nums)\n    i = 0\n    while i < n:\n        p = i\n        if p == n - 1:\n            return True\n        if nums[p] == 0 and p != n - 1:\n            return False\n        i += 1\n        nxt = i\n        m = nums[i]\n        while i <= p + nums[p]:\n            if i >= n:\n                return True\n            if m <= nums[i] + (i - p - 1):\n                m = nums[i] + (i - p - 1)\n                nxt = i\n            i += 1\n        if nxt == p:\n            return False\n        i = nxt\n    return False\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    a = arr[0] | arr[-1]\n    p = a\n    nums = []\n    for j in range(n):\n        if a | arr[j] == a:\n            nums.append(arr[j])\n        else:\n            nums.append(0)\n    if canJump(nums):\n        print(a)\n        continue\n    f = False\n    for i in range(20):\n        if a >> i & 1 == 0:\n            a += 1 << i\n            nums = []\n            for j in range(n):\n                if a | arr[j] == a:\n                    nums.append(arr[j])\n                else:\n                    nums.append(0)\n            if canJump(nums):\n                f = True\n                idx = i\n                break\n    if f:\n        arr = nums[:]\n        for i in range(idx - 1, -1, -1):\n            if p >> i & 1 == 0 and a >> i & 1 == 1:\n                nums = []\n                for j in range(n):\n                    if arr[j] >> i & 1 == 0:\n                        nums.append(arr[j])\n                    else:\n                        nums.append(0)\n                if canJump(nums):\n                    arr = nums\n                    a -= 1 << i\n        print(a)\n    else:\n        print(-1)"]