["import sys\nimport math\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef docase():\n    [n] = get_ints()\n    aa = get_ints()\n    ee = [list() for _ in range(0, n)]\n    for _ in range(1, n):\n        [u, v] = get_ints()\n        if v != 1:\n            ee[u - 1].append(v)\n        if u != 1:\n            ee[v - 1].append(u)\n    stack = [(1, 0, ee[0], aa[0], 0, 0)]\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, ee[c - 1], aa[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                print(s)\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n[t] = get_ints()\nfor _ in range(0, t):\n    docase()", "import sys\nimport math\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef docase():\n    [n] = get_ints()\n    aa = get_ints()\n    ee = [list() for _ in range(0, n)]\n    for _ in range(1, n):\n        [u, v] = get_ints()\n        if v != 1:\n            ee[u - 1].append(v)\n        if u != 1:\n            ee[v - 1].append(u)\n    stack = [(1, 0, ee[0], aa[0], 0, 0)]\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, ee[c - 1], aa[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                print(s)\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n[t] = get_ints()\nfor _ in range(0, t):\n    docase()", "import sys\nimport math\n\nclass TreeNode:\n\n    def init(self, value):\n        self.value = value\n        self.gcd = value\n        self.gcdSumOFChildren = 0\nresult = 0\n\ndef solve():\n    n = int(input())\n    ValuesOfNode = list(map(int, input().split()))\n    values = {}\n    for i in range(1, n + 1):\n        values[i] = TreeNode()\n        values[i].value = ValuesOfNode[i - 1]\n        values[i].gcd = ValuesOfNode[i - 1]\n        values[i].gcdSumOFChildren = 0\n    g = {}\n    for i in range(1, n + 1):\n        g[i] = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        g[b].append(a)\n        g[a].append(b)\n\n    def helper(curr, parent):\n        sumofgcd = 0\n        for child in g[curr]:\n            if child != parent:\n                helper(child, curr)\n                values[curr].gcd = math.gcd(values[curr].gcd, values[child].gcd)\n                sumofgcd += values[child].gcd\n        values[curr].gcdSumOFChildren = sumofgcd\n    helper(1, -1)\n    global result\n    result = 0\n\n    def helper2(curr, parent, sum):\n        sum += values[curr].gcdSumOFChildren\n        global result\n        result = max(result, sum)\n        for child in g[curr]:\n            if child != parent:\n                helper2(child, curr, sum - values[child].gcd)\n    helper2(1, -1, 0)\n    print(result)\nsys.setrecursionlimit(10 ** 6)\nnumberOfTestCases = int(input())\nfor i in range(numberOfTestCases):\n    solve()", "import sys\n\nclass Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.gcd = val\n        self.sumOfGcdChildren = 0\n\n    def __str__(self):\n        return f' {self.gcd} {self.sumOfGcdChildren} {self.val}'\n\ndef __gcd(a, b):\n    if b == 0:\n        return a\n    return __gcd(b, a % b)\nans = 0\n\ndef run():\n    n = int(input())\n    nodeval = list(map(int, input().split()))\n    nodes = {}\n    for i in range(1, n + 1):\n        nodes[i] = Node(nodeval[i - 1])\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(curr, parent):\n        sumofgcd = 0\n        for child in graph[curr]:\n            if child != parent:\n                dfs(child, curr)\n                nodes[curr].gcd = __gcd(nodes[curr].gcd, nodes[child].gcd)\n                sumofgcd += nodes[child].gcd\n        nodes[curr].sumOfGcdChildren = sumofgcd\n    dfs(1, -1)\n    global ans\n    ans = 0\n\n    def dfs2(curr, parent, sum):\n        sum += nodes[curr].sumOfGcdChildren\n        global ans\n        ans = max(ans, sum)\n        for child in graph[curr]:\n            if child != parent:\n                dfs2(child, curr, sum - nodes[child].gcd)\n    dfs2(1, -1, 0)\n    print(ans)\nsys.setrecursionlimit(10 ** 6)\ntest = int(input())\nfor i in range(test):\n    run()", "import sys\n\nclass Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.gcd = val\n        self.sumOfGcdChildren = 0\n\n    def str(self):\n        return f' {self.gcd} {self.sumOfGcdChildren} {self.val}'\n\ndef __gcd(a, b):\n    if b == 0:\n        return a\n    return __gcd(b, a % b)\nans = 0\n\ndef run():\n    n = int(input())\n    nodeval = list(map(int, input().split()))\n    nodes = {}\n    for i in range(1, n + 1):\n        nodes[i] = Node(nodeval[i - 1])\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(curr, parent):\n        sumofgcd = 0\n        for child in graph[curr]:\n            if child != parent:\n                dfs(child, curr)\n                nodes[curr].gcd = __gcd(nodes[curr].gcd, nodes[child].gcd)\n                sumofgcd += nodes[child].gcd\n        nodes[curr].sumOfGcdChildren = sumofgcd\n    dfs(1, -1)\n    global ans\n    ans = 0\n\n    def dfs2(curr, parent, sum):\n        sum += nodes[curr].sumOfGcdChildren\n        global ans\n        ans = max(ans, sum)\n        for child in graph[curr]:\n            if child != parent:\n                dfs2(child, curr, sum - nodes[child].gcd)\n    dfs2(1, -1, 0)\n    print(ans)\nsys.setrecursionlimit(10 ** 6)\ntest = int(input())\nfor i in range(test):\n    run()", "import sys\n\nclass Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.gcd = val\n        self.sumOfGcdChildren = 0\n\n    def __str__(self):\n        return f' {self.gcd} {self.sumOfGcdChildren} {self.val}'\n\ndef __gcd(a, b):\n    if b == 0:\n        return a\n    return __gcd(b, a % b)\nans = 0\n\ndef run():\n    n = int(input())\n    nodeval = list(map(int, input().split()))\n    nodes = {}\n    for i in range(1, n + 1):\n        nodes[i] = Node(nodeval[i - 1])\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(curr, parent):\n        sumofgcd = 0\n        for child in graph[curr]:\n            if child != parent:\n                dfs(child, curr)\n                nodes[curr].gcd = __gcd(nodes[curr].gcd, nodes[child].gcd)\n                sumofgcd += nodes[child].gcd\n        nodes[curr].sumOfGcdChildren = sumofgcd\n    dfs(1, -1)\n    global ans\n    ans = 0\n\n    def dfs2(curr, parent, sum):\n        sum += nodes[curr].sumOfGcdChildren\n        global ans\n        ans = max(ans, sum)\n        for child in graph[curr]:\n            if child != parent:\n                dfs2(child, curr, sum - nodes[child].gcd)\n    dfs2(1, -1, 0)\n    print(ans)\nsys.setrecursionlimit(10 ** 6)\ntest = int(input())\nfor i in range(test):\n    run()", "import sys\n\nclass Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.gcd = val\n        self.sumOfGcdChildren = 0\n\n    def __str__(self):\n        return f' {self.gcd} {self.sumOfGcdChildren} {self.val}'\n\ndef __gcd(a, b):\n    if b == 0:\n        return a\n    return __gcd(b, a % b)\nans = 0\n\ndef run():\n    n = int(input())\n    nodeval = list(map(int, input().split()))\n    nodes = {}\n    for i in range(1, n + 1):\n        nodes[i] = Node(nodeval[i - 1])\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(curr, parent):\n        sumofgcd = 0\n        for child in graph[curr]:\n            if child != parent:\n                dfs(child, curr)\n                nodes[curr].gcd = __gcd(nodes[curr].gcd, nodes[child].gcd)\n                sumofgcd += nodes[child].gcd\n        nodes[curr].sumOfGcdChildren = sumofgcd\n    dfs(1, -1)\n    global ans\n    ans = 0\n\n    def dfs2(curr, parent, sum):\n        sum += nodes[curr].sumOfGcdChildren\n        global ans\n        ans = max(ans, sum)\n        for child in graph[curr]:\n            if child != parent:\n                dfs2(child, curr, sum - nodes[child].gcd)\n    dfs2(1, -1, 0)\n    print(ans)\nsys.setrecursionlimit(10 ** 6)\ntest = int(input())\nfor i in range(test):\n    run()", "import sys\n\nclass Node:\n\n    def __init__(self, val):\n        self.val = val\n        self.gcd = val\n        self.sumOfGcdChildren = 0\n\n    def __str__(self):\n        return f' {self.gcd} {self.sumOfGcdChildren} {self.val}'\n\ndef __gcd(a, b):\n    if b == 0:\n        return a\n    return __gcd(b, a % b)\nans = 0\n\ndef run():\n    n = int(input())\n    nodeval = list(map(int, input().split()))\n    nodes = {}\n    for i in range(1, n + 1):\n        nodes[i] = Node(nodeval[i - 1])\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(curr, parent):\n        sumofgcd = 0\n        for child in graph[curr]:\n            if child != parent:\n                dfs(child, curr)\n                nodes[curr].gcd = __gcd(nodes[curr].gcd, nodes[child].gcd)\n                sumofgcd += nodes[child].gcd\n        nodes[curr].sumOfGcdChildren = sumofgcd\n    dfs(1, -1)\n    global ans\n    ans = 0\n\n    def dfs2(curr, parent, sum):\n        sum += nodes[curr].sumOfGcdChildren\n        global ans\n        ans = max(ans, sum)\n        for child in graph[curr]:\n            if child != parent:\n                dfs2(child, curr, sum - nodes[child].gcd)\n    dfs2(1, -1, 0)\n    print(ans)\nsys.setrecursionlimit(10 ** 6)\ntest = int(input())\nfor i in range(test):\n    run()", "def gcd(x, y):\n    if y > x:\n        (x, y) = (y, x)\n    if y == 0:\n        return x\n    if x == 0:\n        return y\n    x = x % y\n    return gcd(y, x)\n\nclass Node:\n    parent = None\n\n    def __init__(self, value, index):\n        self.value = value\n        self.index = index\n        self.child = []\n        self.tree_gcd = None\n        self.beauty_ = None\n\n    def gcd_of_tree(self):\n        if self.tree_gcd != None:\n            return self.tree_gcd\n        x = self.value\n        for c in self.child:\n            x = gcd(x, c.gcd_of_tree())\n        self.tree_gcd = x\n        return x\n\n    def beauty(self):\n        if self.beauty_ != None:\n            return self.beauty_\n        if self.parent == None:\n            sum_ = 0\n        else:\n            sum_ = self.parent.beauty()\n            sum_ = sum_ - self.gcd_of_tree()\n        for c in self.child:\n            sum_ = sum_ + c.gcd_of_tree()\n        self.beauty_ = sum_\n        return sum_\n\ndef assign_parent_child(stack):\n    while len(stack) > 0:\n        (v, p) = stack.pop()\n        v.parent = p\n        if p != None:\n            v.child.remove(p)\n        for c in v.child:\n            stack.append((c, v))\n\ndef bfs(stack, pointer):\n    while len(stack) > pointer:\n        for c in stack[pointer].child:\n            stack.append(c)\n        pointer = pointer + 1\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    n = int(input())\n    arr = list(map(int, input().split()))\n    nodes = []\n    for i in range(n):\n        node = Node(arr[i], i)\n        nodes.append(node)\n    for q in range(n - 1):\n        (i, j) = list(map(int, input().split()))\n        i = i - 1\n        j = j - 1\n        nodes[i].child.append(nodes[j])\n        nodes[j].child.append(nodes[i])\n    stack = []\n    stack.append((nodes[0], None))\n    assign_parent_child(stack)\n    stack = [nodes[0]]\n    bfs(stack, 0)\n    for i in range(len(stack) - 1, -1, -1):\n        stack[i].gcd_of_tree()\n    max_ = 1\n    stack = []\n    stack.append(nodes[0])\n    while len(stack) > 0:\n        node = stack.pop()\n        if len(node.child) != 0:\n            curr = node.beauty()\n            if max_ < curr:\n                max_ = curr\n            stack.extend(node.child)\n    print(max_)", "from math import gcd\nfrom functools import reduce\n\ndef findgcdtree(vals):\n    return reduce(gcd, vals)\n\nclass TreeNode:\n\n    def __init__(self, val, num):\n        self.val = val\n        self.num = num\n        self.children = list()\n        self.visited = 0\n        self.parent = None\n        self.gcd = None\n        self.beauty = 0\n\n    def addLink(self, node):\n        self.children.append(node)\n\n    def maxBeau(self):\n        beautyMax = self.beauty\n        for x in self.children:\n            beautyMax = max(beautyMax, x.maxBeau())\n        return beautyMax\n\ndef findMaxTree(root):\n    nodesToAns = [root]\n    maxBeau = 0\n    while nodesToAns:\n        node = nodesToAns.pop()\n        maxBeau = max(node.beauty, maxBeau)\n        nodesToAns.extend(node.children)\n    return maxBeau\n\ndef calcBeaut89(root):\n    nodesToAns = [root]\n    while nodesToAns:\n        node = nodesToAns.pop()\n        if node.parent != None:\n            node.beauty += node.parent.beauty\n            node.beauty -= node.gcd\n        for x in node.children:\n            node.beauty += x.gcd\n            nodesToAns.append(x)\n\ndef gcdtree(root):\n    nodesToAns = [root]\n    while nodesToAns:\n        node = nodesToAns.pop()\n        notDone = list()\n        vals = [node.val]\n        for x in node.children:\n            if x.gcd == None:\n                notDone.append(x)\n            else:\n                vals.append(x.gcd)\n        if notDone:\n            nodesToAns.append(node)\n            nodesToAns.extend(notDone)\n        else:\n            node.gcd = findgcdtree(vals)\ncase = int(input())\nfor k in range(case):\n    nodes = dict()\n    n = int(input())\n    vals = list(map(int, input().split(' ')))\n    for i in range(n):\n        node = TreeNode(vals[i], i + 1)\n        nodes[i + 1] = node\n    for i in range(0, n - 1):\n        (a, b) = map(int, input().split(' '))\n        nodes[a].addLink(nodes[b])\n        nodes[b].addLink(nodes[a])\n    root = nodes[1]\n    nodesToAns = [root]\n    while nodesToAns:\n        node = nodesToAns.pop()\n        for x in node.children:\n            x.parent = node\n            x.children.remove(node)\n        nodesToAns.extend(node.children)\n    gcdtree(root)\n    calcBeaut89(root)\n    print(findMaxTree(root))", "from math import gcd\nfrom functools import reduce\n\ndef findgcdtree(vals):\n    return reduce(gcd, vals)\n\nclass Node:\n\n    def __init__(self, val, num):\n        self.val = val\n        self.num = num\n        self.children = list()\n        self.visited = 0\n        self.parent = None\n        self.gcd = None\n        self.beauty = 0\n\n    def addLink(self, node):\n        self.children.append(node)\n\n    def maxBeau(self):\n        beautyMax = self.beauty\n        for x in self.children:\n            beautyMax = max(beautyMax, x.maxBeau())\n        return beautyMax\n\ndef findMaxTree(root):\n    nodesToAns = [root]\n    maxBeau = 0\n    while nodesToAns:\n        node = nodesToAns.pop()\n        maxBeau = max(node.beauty, maxBeau)\n        nodesToAns.extend(node.children)\n    return maxBeau\n\ndef calcBeaut89(root):\n    nodesToAns = [root]\n    while nodesToAns:\n        node = nodesToAns.pop()\n        if node.parent != None:\n            node.beauty += node.parent.beauty\n            node.beauty -= node.gcd\n        for x in node.children:\n            node.beauty += x.gcd\n            nodesToAns.append(x)\n\ndef gcdtree(root):\n    nodesToAns = [root]\n    while nodesToAns:\n        node = nodesToAns.pop()\n        notDone = list()\n        vals = [node.val]\n        for x in node.children:\n            if x.gcd == None:\n                notDone.append(x)\n            else:\n                vals.append(x.gcd)\n        if notDone:\n            nodesToAns.append(node)\n            nodesToAns.extend(notDone)\n        else:\n            node.gcd = findgcdtree(vals)\ncase = int(input())\nfor k in range(case):\n    nodes = dict()\n    n = int(input())\n    vals = list(map(int, input().split(' ')))\n    for i in range(n):\n        node = Node(vals[i], i + 1)\n        nodes[i + 1] = node\n    for i in range(0, n - 1):\n        (a, b) = map(int, input().split(' '))\n        nodes[a].addLink(nodes[b])\n        nodes[b].addLink(nodes[a])\n    root = nodes[1]\n    nodesToAns = [root]\n    while nodesToAns:\n        node = nodesToAns.pop()\n        for x in node.children:\n            x.parent = node\n            x.children.remove(node)\n        nodesToAns.extend(node.children)\n    gcdtree(root)\n    calcBeaut89(root)\n    print(findMaxTree(root))", "from math import gcd\nfrom functools import reduce\n\ndef findgcd(vals):\n    return reduce(gcd, vals)\n\nclass Node:\n\n    def __init__(self, val, num):\n        self.val = val\n        self.num = num\n        self.links = []\n        self.visited = 0\n        self.parent = None\n        self.gcd = None\n        self.beauty = 0\n\n    def addLink(self, node):\n        self.links.append(node)\n\n    def __str__(self):\n        string = str(self.num)\n        string += ' -> '\n        for x in self.links:\n            string += str(x.num) + ' '\n        return string\n\n    def printTreeAsRoot(self):\n        nodesToCheck = [self]\n        while nodesToCheck:\n            x = nodesToCheck.pop(0)\n            print(x)\n            nodesToCheck.extend(x.links)\n\n    def printTreegcds(self):\n        print(str(self.num) + ': ' + str(self.gcd))\n        for x in self.links:\n            x.printTreegcds()\n\n    def printTreeBeauties(self):\n        print(str(self.num) + ': ' + str(self.beauty))\n        for x in self.links:\n            x.printTreeBeauties()\n\n    def calcgcd(self):\n        vals = [self.val]\n        for x in self.links:\n            if x.gcd == None:\n                x.calcgcd()\n            vals.append(x.gcd)\n        self.gcd = findgcd(vals)\n\n    def calculateBeauty(self):\n        if self.parent != None:\n            self.beauty = self.parent.beauty - self.gcd\n        for x in self.links:\n            self.beauty += x.gcd\n        for x in self.links:\n            x.calculateBeauty()\n\n    def maxBeauty(self):\n        beautyMax = self.beauty\n        for x in self.links:\n            beautyMax = max(beautyMax, x.maxBeauty())\n        return beautyMax\n\ndef findMaxBeauty(root):\n    nodesToCheck = [root]\n    maxBeauty = 0\n    while nodesToCheck:\n        node = nodesToCheck.pop()\n        maxBeauty = max(node.beauty, maxBeauty)\n        nodesToCheck.extend(node.links)\n    return maxBeauty\n\ndef calcBeauties(root):\n    nodesToCheck = [root]\n    while nodesToCheck:\n        node = nodesToCheck.pop()\n        if node.parent != None:\n            node.beauty += node.parent.beauty\n            node.beauty -= node.gcd\n        for x in node.links:\n            node.beauty += x.gcd\n            nodesToCheck.append(x)\n\ndef calcgcds(root):\n    nodesToCheck = [root]\n    while nodesToCheck:\n        node = nodesToCheck.pop()\n        notDone = []\n        vals = [node.val]\n        for x in node.links:\n            if x.gcd == None:\n                notDone.append(x)\n            else:\n                vals.append(x.gcd)\n        if notDone:\n            nodesToCheck.append(node)\n            nodesToCheck.extend(notDone)\n        else:\n            node.gcd = findgcd(vals)\nt = int(input())\nfor _ in range(t):\n    nodes = {}\n    n = int(input())\n    vals = list(map(int, input().split()))\n    for i in range(n):\n        node = Node(vals[i], i + 1)\n        nodes[i + 1] = node\n    for _ in range(n - 1):\n        (l1, l2) = list(map(int, input().split()))\n        nodes[l1].addLink(nodes[l2])\n        nodes[l2].addLink(nodes[l1])\n    root = nodes[1]\n    nodesToCheck = [root]\n    while nodesToCheck:\n        node = nodesToCheck.pop()\n        for x in node.links:\n            x.parent = node\n            x.links.remove(node)\n        nodesToCheck.extend(node.links)\n    calcgcds(root)\n    calcBeauties(root)\n    print(findMaxBeauty(root))", "import sys\nimport math\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef docase():\n    [n] = get_ints()\n    aa = get_ints()\n    ee = [list() for _ in range(0, n)]\n    for _ in range(1, n):\n        [u, v] = get_ints()\n        if v != 1:\n            ee[u - 1].append(v)\n        if u != 1:\n            ee[v - 1].append(u)\n    stack = [(1, 0, ee[0], aa[0], 0, 0)]\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, ee[c - 1], aa[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                print(s)\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n[t] = get_ints()\nfor _ in range(0, t):\n    docase()", "from math import gcd\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef calc_gcds(tree, A, current_node=1, previous_node=0, gcds=dict()):\n    gcds[current_node] = A[current_node - 1]\n    for x in tree[current_node]:\n        if x == previous_node:\n            continue\n        gcds[current_node] = gcd(gcds[current_node], calc_gcds(tree, A, x, current_node, gcds)[x])\n    return gcds\n\ndef solve(tree, gcds, current_node=1, previous_node=0):\n    s = 0\n    for x in tree[current_node]:\n        if x == previous_node:\n            continue\n        s += gcds[x]\n    ans = []\n    for x in tree[current_node]:\n        if x == previous_node:\n            continue\n        ans.append(s - gcds[x] + solve(tree, gcds, x, current_node))\n    return max([s] + ans)\nfor _ in range(int(input())):\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    tree = dict()\n    for _i in range(N - 1):\n        (u, v) = [int(x) for x in input().split()]\n        if u not in tree:\n            tree[u] = []\n        if v not in tree:\n            tree[v] = []\n        tree[u].append(v)\n        tree[v].append(u)\n    if not tree:\n        print(0)\n        continue\n    gcds = calc_gcds(tree, A)\n    print(solve(tree, gcds))", "import math\nfrom sys import setrecursionlimit\nsetrecursionlimit(1999999999)\n\ndef get_group_gcds(node, parent, tree, values, all_group_values, cut_group_values):\n    group_value = values[node]\n    summ = 0\n    for i in tree[node]:\n        if i != parent:\n            current = get_group_gcds(i, node, tree, values, all_group_values, cut_group_values)\n            summ += current\n            group_value = math.gcd(group_value, current)\n    all_group_values[node] = group_value\n    cut_group_values[node] = summ\n    return group_value\n\ndef find_beauty(node, parent, su, tree, values, all_group_values, cut_group_values):\n    global beauty\n    beauty = max(beauty, su)\n    for i in tree[node]:\n        if i != parent:\n            find_beauty(i, node, su - all_group_values[i] + cut_group_values[i], tree, values, all_group_values, cut_group_values)\n\ndef answer(n, tree, values):\n    global beauty\n    beauty = 0\n    all_group_values = [0] * n\n    cut_group_values = [0] * n\n    ROOT = 1 - 1\n    ROOT_PARENT = ROOT - 1\n    get_group_gcds(ROOT, ROOT_PARENT, tree, values, all_group_values, cut_group_values)\n    find_beauty(0, -1, cut_group_values[0], tree, values, all_group_values, cut_group_values)\n    return beauty\nfor q in range(int(input())):\n    n = int(input())\n    values = [int(e) for e in input().split()]\n    tree = {i: [] for i in range(n)}\n    for i in range(n - 1):\n        link = [int(e) - 1 for e in input().split()]\n        tree[link[0]] += [link[1]]\n        tree[link[1]] += [link[0]]\n    print(answer(n, tree, values))", "import sys\nsys.setrecursionlimit(350000)\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    return gcd(b, a % b)\n\ndef dps(node, parent):\n    visited[node] = True\n    dp[node] = dp[parent] - g_st[node] + g_sum[node]\n    for child in adj[node]:\n        if not visited[child]:\n            if child != parent:\n                dps(child, node)\n\ndef dfs_2(node, parent):\n    visited[node] = False\n    for child in adj[node]:\n        if visited[child]:\n            if child != parent:\n                g_sum[node] += g_st[child]\n                dfs_2(child, node)\n\ndef dfs(node, parent):\n    visited[node] = True\n    g_st[node] = A[node - 1]\n    for child in adj[node]:\n        if child != parent:\n            if not visited[child]:\n                if g_st[child] != 0:\n                    g_st[node] = gcd(g_st[node], g_st[child])\n                else:\n                    g_st[node] = gcd(g_st[node], dfs(child, node))\n    return g_st[node]\nfor _ in range(int(input())):\n    N = int(input())\n    A = [int(i) for i in input().split()]\n    if N == 1:\n        print(0)\n    else:\n        adj = {}\n        for i in range(N):\n            adj[i + 1] = []\n        for i in range(N - 1):\n            (u, v) = [int(i) for i in input().split()]\n            adj[u].append(v)\n            adj[v].append(u)\n        visited = [False] * (N + 1)\n        g_st = [0] * (N + 1)\n        g_sum = [0] * (N + 1)\n        dp = [0] * (N + 1)\n        dfs(1, 0)\n        dfs_2(1, 0)\n        dp[0] = g_st[1]\n        dps(1, 0)\n        print(max(dp))", "from queue import Queue\nimport sys\nsys.setrecursionlimit(10 ** 7)\nimport math\n\ndef dfs(i):\n    vistited[i] = True\n    g = arr[i]\n    for j in tree[i]:\n        if not vistited[j]:\n            g = math.gcd(g, dfs(j))\n    gcd_arr[i] = g\n    return g\n\ndef bfs(i):\n    q = Queue()\n    q.put(i)\n    while not q.empty():\n        x = q.get()\n        g = 0\n        vistited[x] = True\n        if len(tree[x]) == 1:\n            continue\n        for j in tree[x]:\n            if not vistited[j]:\n                q.put(j)\n            g += gcd_arr[j]\n        gcd_arr[x] = g - gcd_arr[x]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    tree = [[] for i in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u - 1].append(v - 1)\n        tree[v - 1].append(u - 1)\n    vistited = [False] * n\n    gcd_arr = [0] * n\n    dfs(0)\n    a = 0\n    for i in tree[0]:\n        a += gcd_arr[i]\n    gcd_arr[0] = a\n    vistited = [False] * n\n    for i in tree[0]:\n        vistited[0] = True\n        bfs(i)\n    print(max(gcd_arr))", "def gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    vertices = list(map(int, input().split()))\n    neighbours = [[] for _ in range(N)]\n    children = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (u, v) = list(map(int, input().split()))\n        neighbours[u - 1].append(v - 1)\n        neighbours[v - 1].append(u - 1)\n    q = [0]\n    l = []\n    visited = [False] * N\n    while q:\n        u = q.pop()\n        visited[u] = True\n        children[u] = [v for v in neighbours[u] if not visited[v]]\n        q.extend(children[u])\n        l.append(u)\n    gcds = [None] * N\n    for u in reversed(l):\n        g = vertices[u]\n        for v in children[u]:\n            g = gcd(g, gcds[v])\n        gcds[u] = g\n    above = [0] * N\n    below = [0] * N\n    for u in l:\n        below[u] = sum((gcds[v] for v in children[u]))\n        for v in children[u]:\n            above[v] = above[u] + below[u] - gcds[v]\n    m = max((above[u] + below[u] for u in l))\n    print(m)", "import sys\nsys.setrecursionlimit(1000000)\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\nfrom math import gcd\n\ndef findgcd(g, nodegcd, node, a, visited):\n    ans = a[node - 1]\n    for i in g[node]:\n        if i not in visited:\n            visited.add(i)\n            ans = gcd(findgcd(g, nodegcd, i, a, visited), ans)\n    nodegcd[node] = ans\n    return ans\n\ndef findpath(g, path, node, visited, curr, nodegcd):\n    for i in g[node]:\n        if i not in visited:\n            visited.add(i)\n            ans = int(curr)\n            ans -= nodegcd[i]\n            for j in g[i]:\n                if j not in visited:\n                    ans += nodegcd[j]\n            path[i] = ans\n            findpath(g, path, i, visited, ans, nodegcd)\nfor t in range(int(input())):\n    n = ni()\n    a = li()\n    g = []\n    for i in range(n + 1):\n        g.append([])\n    for i in range(n - 1):\n        (x, y) = mi()\n        g[x].append(y)\n        g[y].append(x)\n    nodegcd = dict()\n    findgcd(g, nodegcd, 1, a, {1})\n    path = dict()\n    path[1] = 0\n    for i in g[1]:\n        path[1] += nodegcd[i]\n    findpath(g, path, 1, {1}, path[1], nodegcd)\n    print(max(path.values()))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(4 * 10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef solve(p, prev, take):\n    if dp[p][take] != -1:\n        return dp[p][take]\n    if take == 0:\n        gcdval = a[p - 1]\n        for i in child[p]:\n            if i == prev:\n                continue\n            gcdval = gcd(gcdval, solve(i, p, 0))\n        dp[p][take] = gcdval\n        return gcdval\n    else:\n        total = 0\n        for i in child[p]:\n            if i == prev:\n                continue\n            total += solve(i, p, 0)\n        bestans = total\n        for i in child[p]:\n            if i == prev:\n                continue\n            curans = total - solve(i, p, 0) + solve(i, p, 1)\n            bestans = max(bestans, curans)\n        dp[p][take] = bestans\n        return bestans\nfor T in range(int(input())):\n    n = int(input())\n    a = inp()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    dp = [[-1, -1] for i in range(n + 1)]\n    ans = max(solve(1, -1, 0), solve(1, -1, 1))\n    print(ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(4 * 10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef solve(p, prev, take):\n    if dp[p][take] != -1:\n        return dp[p][take]\n    if take == 0:\n        gcdval = a[p - 1]\n        for i in child[p]:\n            if i == prev:\n                continue\n            gcdval = gcd(gcdval, solve(i, p, 0))\n        dp[p][take] = gcdval\n        return gcdval\n    else:\n        total = 0\n        for i in child[p]:\n            if i == prev:\n                continue\n            total += solve(i, p, 0)\n        bestans = total\n        for i in child[p]:\n            if i == prev:\n                continue\n            curans = total - solve(i, p, 0) + solve(i, p, 1)\n            bestans = max(bestans, curans)\n        dp[p][take] = bestans\n        return bestans\nfor T in range(int(input())):\n    n = int(input())\n    a = inp()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    dp = [[-1, -1] for i in range(n + 1)]\n    ans = max(solve(1, -1, 0), solve(1, -1, 1))\n    print(ans)"]