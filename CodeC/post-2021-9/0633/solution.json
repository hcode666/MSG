["mod = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[a[i]] == -1:\n            other[a[i]] = i\n    F = FenwickTree([0 for _ in range(2 * n + 5)])\n    (before, ans) = (1, 0)\n    for x in a:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % mod)\n            before += dp[x]\n            before %= mod\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % mod)\n            ans %= mod\n    print(ans)", "mod = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[a[i]] == -1:\n            other[a[i]] = i\n    F = FenwickTree([0 for _ in range(2 * n + 5)])\n    (before, ans) = (1, 0)\n    for x in a:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % mod)\n            before += dp[x]\n            before %= mod\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % mod)\n            ans %= mod\n    print(ans)", "mod = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[a[i]] == -1:\n            other[a[i]] = i\n    F = FenwickTree([0 for _ in range(2 * n + 5)])\n    (before, ans) = (1, 0)\n    for x in a:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % mod)\n            before += dp[x]\n            before %= mod\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % mod)\n            ans %= mod\n    print(ans)", "mod = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[a[i]] == -1:\n            other[a[i]] = i\n    F = FenwickTree([0 for _ in range(2 * n + 5)])\n    (before, ans) = (1, 0)\n    for x in a:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % mod)\n            before += dp[x]\n            before %= mod\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % mod)\n            ans %= mod\n    print(ans)", "mod = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[a[i]] == -1:\n            other[a[i]] = i\n    F = FenwickTree([0 for _ in range(2 * n + 5)])\n    (before, ans) = (1, 0)\n    for x in a:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % mod)\n            before += dp[x]\n            before %= mod\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % mod)\n            ans %= mod\n    print(ans)"]