["from collections import deque\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [0] + list(map(int, input().strip().split()))\n    dp = [0] * (n + 5)\n    ans = 0\n    stk = deque()\n    for i in range(n, 0, -1):\n        while stk and arr[i] > arr[stk[-1]]:\n            stk.pop()\n        ind = n + 1\n        if stk:\n            ind = stk[-1]\n        stk.append(i)\n        tmp1 = (n + 1) * (ind - i) % mod\n        tmp2 = (ind * (ind - 1) // 2 - i * (i - 1) // 2) % mod\n        tmp = arr[i] * (tmp1 - tmp2) % mod\n        tmp = (tmp + mod) % mod\n        dp[i] = (tmp + dp[ind]) % mod\n        ans += dp[i]\n        ans %= mod\n    print(ans)", "from collections import deque\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [0] + list(map(int, input().strip().split()))\n    dp = [0] * (n + 5)\n    ans = 0\n    stk = deque()\n    for i in range(n, 0, -1):\n        while stk and arr[i] > arr[stk[-1]]:\n            stk.pop()\n        ind = n + 1\n        if stk:\n            ind = stk[-1]\n        stk.append(i)\n        tmp1 = (n + 1) * (ind - i) % mod\n        tmp2 = (ind * (ind - 1) // 2 - i * (i - 1) // 2) % mod\n        tmp = arr[i] * (tmp1 - tmp2) % mod\n        tmp = (tmp + mod) % mod\n        dp[i] = (tmp + dp[ind]) % mod\n        ans += dp[i]\n        ans %= mod\n    print(ans)", "from collections import deque\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    arr = (0, *map(int, input().strip().split()))\n    dp = [0] * (n + 5)\n    ans = 0\n    stk = deque()\n    for i in range(n, 0, -1):\n        while stk and arr[i] > arr[stk[-1]]:\n            stk.pop()\n        ind = n + 1\n        if stk:\n            ind = stk[-1]\n        stk.append(i)\n        tmp1 = (n + 1) * (ind - i) % mod\n        tmp2 = (ind * (ind - 1) // 2 - i * (i - 1) // 2) % mod\n        tmp = arr[i] * (tmp1 - tmp2) % mod\n        tmp = (tmp + mod) % mod\n        dp[i] = (tmp + dp[ind]) % mod\n        ans += dp[i]\n        ans %= mod\n    print(ans)", "inf = float('inf')\nimport sys\nimport pprint\nimport logging\nfrom logging import getLogger\nimport array\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef maps():\n    return [int(i) for i in input().split()]\nlogging.basicConfig(format='%(message)s', level=logging.WARNING)\nlogger = getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\ndef debug(msg, *args):\n    logger.info(f'{msg}={pprint.pformat(args)}')\nmod = int(1000000000.0) + 7\n\ndef mul(a, b):\n    a %= mod\n    b %= mod\n    return (a * b % mod + mod) % mod\n\ndef add(a, b):\n    a %= mod\n    b %= mod\n    return ((a + b) % mod + mod) % mod\n\ndef solve():\n    (n,) = maps()\n    a = [0] + list(maps())\n    ngr = [n + 1] * (n + 1)\n    st = [[inf, inf]]\n    for i in range(1, n + 1):\n        while a[i] >= st[-1][0]:\n            ngr[st[-1][1]] = i\n            st.pop()\n        st.append([a[i], i])\n    dp = [0] * (n + 2)\n    i = n\n    while i >= 0:\n        num = ngr[i] - i\n        dp[i] = mul(a[i], num * (num + 1) // 2)\n        dp[i] = add(dp[i], mul(num * a[i], n - ngr[i] + 1))\n        dp[i] = add(dp[i], dp[ngr[i]])\n        i -= 1\n    ans = 0\n    for i in range(1, n + 1):\n        ans = add(ans, dp[i])\n    print(ans)\nfor _ in range(*maps()):\n    solve()", "import sys\nimport bisect\ninput = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nsys.setrecursionlimit(10 ** 6)\nflsh = lambda : sys.stdout.flush()\nsa = lambda : input()\nsb = lambda : int(input())\nsc = lambda : input().split()\nsd = lambda : list(map(int, input().split()))\nse = lambda : float(input())\nsf = lambda : list(input())\nmod = 10 ** 9 + 7\n\ndef hnbhai():\n    n = sb()\n    a = sd()\n    right = []\n    s = []\n    pre = [0] * (n + 1)\n    for i in range(1, n + 1):\n        pre[i] = n - i + 1\n        pre[i] += pre[i - 1]\n        pre[i] %= mod\n    for i in range(n - 1, -1, -1):\n        while len(s) > 0 and a[s[-1]] < a[i]:\n            s.pop()\n        if len(s) == 0:\n            right.append(n)\n        else:\n            right.append(s[-1])\n        s.append(i)\n    right.reverse()\n    ans = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        ans[i] = a[i] * (pre[right[i]] - pre[i])\n        ans[i] += ans[right[i]]\n        ans[i] %= mod\n    print(sum(ans) % mod)\nfor _ in range(sb()):\n    hnbhai()", "import sys\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom collections import deque\nsys.setrecursionlimit(10 ** 8)\nfrom queue import PriorityQueue as pq\nfrom math import gcd\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nlii = lambda : list(map(int, list(ip())))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\ninv = lambda x: pow(x, mod - 2, mod)\nmod = 10 ** 9 + 7\nmod1 = 998244353\nfor _ in range(ii()):\n    n = ii()\n    a = il()\n    right = []\n    s = []\n    for i in range(n - 1, -1, -1):\n        while len(s) > 0 and a[s[-1]] <= a[i]:\n            s.pop()\n        if len(s) == 0:\n            right.append(n)\n        else:\n            right.append(s[-1])\n        s.append(i)\n    right.reverse()\n    left = []\n    s = []\n    for i in range(n):\n        while len(s) > 0 and a[s[-1]] < a[i]:\n            s.pop()\n        if len(s) == 0:\n            left.append(-1)\n        else:\n            left.append(s[-1])\n        s.append(i)\n    ans = 0\n    for i in range(n):\n        x = i - left[i]\n        y = right[i] - i\n        z = n - right[i]\n        t = y * (y + 1) // 2\n        t1 = y * z\n        t2 = t + t1\n        tot = t2 * x\n        ans += tot * a[i]\n        ans %= mod\n    print(ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef solve(i):\n    if i == n:\n        return 0\n    if dp[i] != -1:\n        return dp[i]\n    m = nind[i] - i\n    x = mul(mul(m, m + 1), 500000004)\n    x = mul(x, a[i])\n    v = mul(mul(m, a[i]), n - nind[i])\n    val = add(add(x, v), solve(nind[i]))\n    dp[i] = val\n    return val\n\ndef answer():\n    s = []\n    for i in range(n):\n        while len(s) and a[s[-1]] < a[i]:\n            nind[s[-1]] = i\n            s.pop()\n        s.append(i)\n    ans = 0\n    for i in range(n):\n        ans = add(ans, solve(i))\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    nind = [n] * n\n    dp = [-1] * n\n    print(answer())"]