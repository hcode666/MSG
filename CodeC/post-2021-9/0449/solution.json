["from collections import defaultdict, deque\n\ndef solve(n, adj, queries):\n    visited = set()\n    queue = deque()\n\n    def bfs(time):\n        while queue and time > 0:\n            size = len(queue)\n            for _ in range(size):\n                u = queue.popleft()\n                for nei in adj[u]:\n                    if nei in visited:\n                        continue\n                    visited.add(nei)\n                    queue.append(nei)\n            time -= 1\n    for (t, val) in queries:\n        if t == 1:\n            if val in visited:\n                continue\n            visited.add(val)\n            queue.append(val)\n        elif t == 2:\n            bfs(val)\n        elif val in visited:\n            print('YES')\n        else:\n            print('NO')\n(n, m, q) = list(map(int, input().split()))\nadj = defaultdict(set)\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    adj[u].add(v)\n    adj[v].add(u)\nqueries = []\nfor _ in range(q):\n    queries.append(list(map(int, input().split())))\nsolve(n, adj, queries)", "from collections import defaultdict, deque\n\ndef solve(n, adj, queries):\n    visited = set()\n    queue = deque()\n\n    def bfs(time):\n        while queue and time > 0:\n            size = len(queue)\n            for _ in range(size):\n                u = queue.popleft()\n                for nei in adj[u]:\n                    if nei in visited:\n                        continue\n                    visited.add(nei)\n                    queue.append(nei)\n            time -= 1\n    for (t, val) in queries:\n        if t == 1:\n            if val in visited:\n                continue\n            visited.add(val)\n            queue.append(val)\n        elif t == 2:\n            bfs(val)\n        elif val in visited:\n            print('YES')\n        else:\n            print('NO')\n(n, m, q) = list(map(int, input().split()))\nadj = defaultdict(set)\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    adj[u].add(v)\n    adj[v].add(u)\nqueries = []\nfor _ in range(q):\n    queries.append(list(map(int, input().split())))\nsolve(n, adj, queries)", "from collections import defaultdict, deque\n\ndef solve(n, adj, queries):\n    visited = set()\n    queue = deque()\n\n    def bfs(time):\n        while queue and time > 0:\n            size = len(queue)\n            for _ in range(size):\n                u = queue.popleft()\n                for nei in adj[u]:\n                    if nei in visited:\n                        continue\n                    visited.add(nei)\n                    queue.append(nei)\n            time -= 1\n    for (t, val) in queries:\n        if t == 1:\n            if val in visited:\n                continue\n            visited.add(val)\n            queue.append(val)\n        elif t == 2:\n            bfs(val)\n        elif val in visited:\n            print('YES')\n        else:\n            print('NO')\n(n, m, q) = list(map(int, input().split()))\nadj = defaultdict(set)\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    adj[u].add(v)\n    adj[v].add(u)\nqueries = []\nfor _ in range(q):\n    queries.append(list(map(int, input().split())))\nsolve(n, adj, queries)", "from collections import defaultdict, deque\n\ndef solve(n, adj, queries):\n    visited = set()\n    queue = deque()\n\n    def bfs(time):\n        while queue and time > 0:\n            size = len(queue)\n            for _ in range(size):\n                u = queue.popleft()\n                for nei in adj[u]:\n                    if nei in visited:\n                        continue\n                    visited.add(nei)\n                    queue.append(nei)\n            time -= 1\n    for (t, val) in queries:\n        if t == 1:\n            if val in visited:\n                continue\n            visited.add(val)\n            queue.append(val)\n        elif t == 2:\n            bfs(val)\n        elif val in visited:\n            print('YES')\n        else:\n            print('NO')\n(n, m, q) = list(map(int, input().split()))\nadj = defaultdict(set)\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    adj[u].add(v)\n    adj[v].add(u)\nqueries = []\nfor _ in range(q):\n    queries.append(list(map(int, input().split())))\nsolve(n, adj, queries)", "from collections import defaultdict, deque\n\ndef solve(n, adj, queries):\n    visited = set()\n    queue = deque()\n\n    def bfs(time):\n        while queue and time > 0:\n            size = len(queue)\n            for _ in range(size):\n                u = queue.popleft()\n                for nei in adj[u]:\n                    if nei in visited:\n                        continue\n                    visited.add(nei)\n                    queue.append(nei)\n            time -= 1\n    for (t, val) in queries:\n        if t == 1:\n            if val in visited:\n                continue\n            visited.add(val)\n            queue.append(val)\n        elif t == 2:\n            bfs(val)\n        elif val in visited:\n            print('YES')\n        else:\n            print('NO')\n(n, m, q) = list(map(int, input().split()))\nadj = defaultdict(set)\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    adj[u].add(v)\n    adj[v].add(u)\nqueries = []\nfor _ in range(q):\n    queries.append(list(map(int, input().split())))\nsolve(n, adj, queries)", "from collections import defaultdict, deque\n\ndef solve(n, adj, queries):\n    visited = set()\n    queue = deque()\n\n    def bfs(time):\n        while queue and time > 0:\n            size = len(queue)\n            for _ in range(size):\n                u = queue.popleft()\n                for nei in adj[u]:\n                    if nei in visited:\n                        continue\n                    visited.add(nei)\n                    queue.append(nei)\n            time -= 1\n    for (t, val) in queries:\n        if t == 1:\n            if val in visited:\n                continue\n            visited.add(val)\n            queue.append(val)\n        elif t == 2:\n            bfs(val)\n        elif val in visited:\n            print('YES')\n        else:\n            print('NO')\n(n, m, q) = list(map(int, input().split()))\nadj = defaultdict(set)\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    adj[u].add(v)\n    adj[v].add(u)\nqueries = []\nfor _ in range(q):\n    queries.append(list(map(int, input().split())))\nsolve(n, adj, queries)", "from collections import defaultdict, deque\n\ndef solve(n, adj, queries):\n    visited = set()\n    queue = deque()\n\n    def bfs(time):\n        while queue and time > 0:\n            size = len(queue)\n            for _ in range(size):\n                u = queue.popleft()\n                for nei in adj[u]:\n                    if nei in visited:\n                        continue\n                    visited.add(nei)\n                    queue.append(nei)\n            time -= 1\n    for (t, val) in queries:\n        if t == 1:\n            if val in visited:\n                continue\n            visited.add(val)\n            queue.append(val)\n        elif t == 2:\n            bfs(val)\n        elif val in visited:\n            print('YES')\n        else:\n            print('NO')\n(n, m, q) = list(map(int, input().split()))\nadj = defaultdict(set)\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    adj[u].add(v)\n    adj[v].add(u)\nqueries = []\nfor _ in range(q):\n    queries.append(list(map(int, input().split())))\nsolve(n, adj, queries)", "import sys\nimport os\nfrom math import *\nfrom collections import *\nimport bisect\nfrom heapq import *\nfrom itertools import permutations\nif os.path.exists('input.txt') and os.path.exists('output.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ninput = sys.stdin.readline\n\ndef lcm(a, b):\n    k1 = math.gcd(a, b)\n    k2 = a * b\n    return k2 // k1\nmod = 10 ** 9 + 7\n\ndef inp():\n    return map(int, input().strip().split(' '))\n\ndef lis():\n    return list(inp())\nmoD = 998244353\nmod = 10 ** 9 + 7\nmod = 998244353\nmod = 10 ** 9 + 7\n\ndef prim(n):\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\nma = 2 * (10 ** 5 + 1)\n\ndef update(ind, val, n):\n    while ind <= n:\n        fenwick[ind] += val\n        ind += ind & -ind\n\ndef qsum(ind):\n    ans = 0\n    while ind > 0:\n        ans += fenwick[ind]\n        ind -= ind & -ind\n    return ans\n\ndef dfs(adj, vis, u, l):\n    vis[u] = 1\n    l.add(u)\n    for i in adj[u]:\n        if vis[i] == 0:\n            dfs(adj, vis, i, l)\nmod = 10 ** 9 + 7\n\ndef dfs(node, p, col, adj, cnt):\n    cnt[col] += 1\n    for i in adj[node]:\n        if i != p:\n            dfs(i, node, col ^ 1, adj, cnt)\n\ndef solve():\n    (n, m, que) = inp()\n    adj = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = inp()\n        adj[u].append(v)\n        adj[v].append(u)\n    mp = [0 for i in range(n + 1)]\n    q = []\n    for i in range(que):\n        (x, y) = inp()\n        if x == 3:\n            print('YES' if mp[y] == 1 else 'NO')\n        elif x == 1:\n            if mp[y] == 0:\n                q.append(y)\n            mp[y] = 1\n        else:\n            i = 0\n            while i < y and q:\n                k = len(q)\n                while k > 0:\n                    if len(q) == 0:\n                        break\n                    u = q.pop(0)\n                    for c in adj[u]:\n                        if mp[c] == 0:\n                            mp[c] = 1\n                            q.append(c)\n                    k -= 1\n                i += 1\nt = 1\nfor _ in range(t):\n    solve()", "import sys\nimport os\nfrom math import *\nfrom collections import *\nimport bisect\nfrom heapq import *\nfrom itertools import permutations\nif os.path.exists('input.txt') and os.path.exists('output.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ninput = sys.stdin.readline\n\ndef lcm(a, b):\n    k1 = math.gcd(a, b)\n    k2 = a * b\n    return k2 // k1\nmod = 10 ** 9 + 7\n\ndef inp():\n    return map(int, input().strip().split(' '))\n\ndef lis():\n    return list(inp())\nmoD = 998244353\nmod = 10 ** 9 + 7\nmod = 998244353\nmod = 10 ** 9 + 7\n\ndef prim(n):\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\nma = 2 * (10 ** 5 + 1)\n\ndef update(ind, val, n):\n    while ind <= n:\n        fenwick[ind] += val\n        ind += ind & -ind\n\ndef qsum(ind):\n    ans = 0\n    while ind > 0:\n        ans += fenwick[ind]\n        ind -= ind & -ind\n    return ans\n\ndef dfs(adj, vis, u, l):\n    vis[u] = 1\n    l.add(u)\n    for i in adj[u]:\n        if vis[i] == 0:\n            dfs(adj, vis, i, l)\nmod = 10 ** 9 + 7\n\ndef dfs(node, p, col, adj, cnt):\n    cnt[col] += 1\n    for i in adj[node]:\n        if i != p:\n            dfs(i, node, col ^ 1, adj, cnt)\n\ndef solve():\n    (n, m, que) = inp()\n    adj = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = inp()\n        adj[u].append(v)\n        adj[v].append(u)\n    mp = [0 for i in range(n + 1)]\n    q = []\n    for i in range(que):\n        (x, y) = inp()\n        if x == 3:\n            print('YES' if mp[y] == 1 else 'NO')\n        elif x == 1:\n            if mp[y] == 0:\n                q.append(y)\n            mp[y] = 1\n        else:\n            i = 0\n            while i < y and q:\n                k = len(q)\n                while k > 0:\n                    if len(q) == 0:\n                        break\n                    u = q.pop(0)\n                    for c in adj[u]:\n                        if mp[c] == 0:\n                            mp[c] = 1\n                            q.append(c)\n                    k -= 1\n                i += 1\nt = 1\nfor _ in range(t):\n    solve()", "(n, m, q) = map(int, input().split())\nl = []\nfor i in range(n + 1):\n    l.append([])\nfor i in range(m):\n    (i, j) = map(int, input().split())\n    l[i].append(j)\n    l[j].append(i)\nqueue = []\ntop = 0\ntime = 0\nisFrozen = [0] * (n + 1)\ncount = 0\nfor i in range(q):\n    while count < n and len(queue) != top and (time != queue[top][1]):\n        vertex = queue[top][0]\n        for i in l[vertex]:\n            if isFrozen[i]:\n                pass\n            else:\n                isFrozen[i] = 1\n                count += 1\n                queue.append([i, queue[top][1] + 1])\n        top += 1\n    (t, v) = map(int, input().split())\n    if t == 1:\n        isFrozen[v] = 1\n        count += 1\n        queue.append([v, time])\n    if t == 2:\n        time += v\n    if t == 3:\n        if isFrozen[v]:\n            print('YES')\n        else:\n            print('NO')", "from sys import stdin\ninput = stdin.readline\n\nclass Graph:\n\n    def __init__(self, n, res):\n        self.num = n\n        self.data = [[] for _ in range(n)]\n        for (x, y) in res:\n            self.data[x - 1].append(y - 1)\n            self.data[y - 1].append(x - 1)\n(n, m, q) = map(int, input().split())\nx = []\ny = []\nfor _ in range(m):\n    li = input().split()\n    x.append(int(li[0]))\n    y.append(int(li[1]))\nres = list(zip(x, y))\ng1 = Graph(n, res)\nv = []\na = []\ni = 0\nj = 0\nfor _ in range(n):\n    v.append(0)\nfor _ in range(q):\n    (b, c) = map(int, input().split())\n    if b == 1 and v[c - 1] != 1:\n        v[c - 1] = 1\n        a.append(c - 1)\n        j = j + 1\n    if b == 3:\n        if v[c - 1] == 1:\n            print('YES')\n        else:\n            print('NO')\n    if b == 2:\n        if j != n:\n            for _ in range(min(c, n - 1)):\n                k = 0\n                while i <= j - 1:\n                    s = a[i]\n                    if j + k == n:\n                        break\n                    for t in g1.data[s]:\n                        if v[t] != 1:\n                            a.append(t)\n                            k += 1\n                            v[t] = 1\n                            if j + k == n:\n                                break\n                    i = i + 1\n                j += k\n                if i == j or j == n:\n                    break", "from sys import stdin\ninput = stdin.readline\n\nclass Graph:\n\n    def __init__(self, n, res):\n        self.num = n\n        self.data = [[] for _ in range(n)]\n        for (x, y) in res:\n            self.data[x - 1].append(y - 1)\n            self.data[y - 1].append(x - 1)\n(n, m, q) = map(int, input().split())\nx = []\ny = []\nfor _ in range(m):\n    li = input().split()\n    x.append(int(li[0]))\n    y.append(int(li[1]))\nres = list(zip(x, y))\ng1 = Graph(n, res)\nv = []\na = []\ni = 0\nj = 0\nfor _ in range(n):\n    v.append(0)\nfor _ in range(q):\n    (b, c) = map(int, input().split())\n    if b == 1 and v[c - 1] != 1:\n        v[c - 1] = 1\n        a.append(c - 1)\n        j = j + 1\n    if b == 3:\n        if v[c - 1] == 1:\n            print('YES')\n        else:\n            print('NO')\n    if b == 2:\n        if j != n:\n            for _ in range(min(c, n - 1)):\n                k = 0\n                while i <= j - 1:\n                    s = a[i]\n                    if j + k == n:\n                        break\n                    for t in g1.data[s]:\n                        if v[t] != 1:\n                            a.append(t)\n                            k += 1\n                            v[t] = 1\n                            if j + k == n:\n                                break\n                    i = i + 1\n                j += k\n                if i == j or j == n:\n                    break", "from sys import stdin\ninput = stdin.readline\n\nclass Graph:\n\n    def __init__(self, n, res):\n        self.num = n\n        self.data = [[] for _ in range(n)]\n        for (x, y) in res:\n            self.data[x - 1].append(y - 1)\n            self.data[y - 1].append(x - 1)\n(n, m, q) = map(int, input().split())\nx = []\ny = []\nfor _ in range(m):\n    li = input().split()\n    x.append(int(li[0]))\n    y.append(int(li[1]))\nres = list(zip(x, y))\ng1 = Graph(n, res)\nv = []\na = []\ni = 0\nj = 0\nfor _ in range(n):\n    v.append(0)\nfor _ in range(q):\n    (b, c) = map(int, input().split())\n    if b == 1 and v[c - 1] != 1:\n        v[c - 1] = 1\n        a.append(c - 1)\n        j = j + 1\n    if b == 3:\n        if v[c - 1] == 1:\n            print('YES')\n        else:\n            print('NO')\n    if b == 2:\n        if j != n:\n            for _ in range(min(c, n - 1)):\n                k = 0\n                while i <= j - 1:\n                    s = a[i]\n                    if j + k == n:\n                        break\n                    for t in g1.data[s]:\n                        if v[t] != 1:\n                            a.append(t)\n                            k += 1\n                            v[t] = 1\n                            if j + k == n:\n                                break\n                    i = i + 1\n                j += k\n                if i == j or j == n:\n                    break", "from sys import stdin\ninput = stdin.readline\n\nclass Graph:\n\n    def __init__(self, n, res):\n        self.num = n\n        self.data = [[] for _ in range(n)]\n        for (x, y) in res:\n            self.data[x - 1].append(y - 1)\n            self.data[y - 1].append(x - 1)\n(n, m, q) = map(int, input().split())\nx = []\ny = []\nfor _ in range(m):\n    li = input().split()\n    x.append(int(li[0]))\n    y.append(int(li[1]))\nres = list(zip(x, y))\ng1 = Graph(n, res)\nv = []\na = []\ni = 0\nj = 0\nfor _ in range(n):\n    v.append(0)\nfor _ in range(q):\n    (b, c) = map(int, input().split())\n    if b == 1 and v[c - 1] != 1:\n        v[c - 1] = 1\n        a.append(c - 1)\n        j = j + 1\n    if b == 3:\n        if v[c - 1] == 1:\n            print('YES')\n        else:\n            print('NO')\n    if b == 2:\n        if j != n:\n            for _ in range(min(c, n - 1)):\n                k = 0\n                while i <= j - 1:\n                    s = a[i]\n                    if j + k == n:\n                        break\n                    for t in g1.data[s]:\n                        if v[t] != 1:\n                            a.append(t)\n                            k += 1\n                            v[t] = 1\n                            if j + k == n:\n                                break\n                    i = i + 1\n                j += k\n                if i == j or j == n:\n                    break", "from sys import stdin\ninput = stdin.readline\n\nclass Graph:\n\n    def __init__(self, n, res):\n        self.num = n\n        self.data = [[] for _ in range(n)]\n        for (x, y) in res:\n            self.data[x - 1].append(y - 1)\n            self.data[y - 1].append(x - 1)\n(n, m, q) = map(int, input().split())\nx = []\ny = []\nfor _ in range(m):\n    li = input().split()\n    x.append(int(li[0]))\n    y.append(int(li[1]))\nres = list(zip(x, y))\ng1 = Graph(n, res)\nv = []\na = []\ni = 0\nj = 0\nfor _ in range(n):\n    v.append(0)\nfor _ in range(q):\n    (b, c) = map(int, input().split())\n    if b == 1 and v[c - 1] != 1:\n        v[c - 1] = 1\n        a.append(c - 1)\n        j = j + 1\n    if b == 3:\n        if v[c - 1] == 1:\n            print('YES')\n        else:\n            print('NO')\n    if b == 2:\n        if j != n:\n            for _ in range(min(c, n - 1)):\n                k = 0\n                while i <= j - 1:\n                    s = a[i]\n                    if j + k == n:\n                        break\n                    for t in g1.data[s]:\n                        if v[t] != 1:\n                            a.append(t)\n                            k += 1\n                            v[t] = 1\n                            if j + k == n:\n                                break\n                    i = i + 1\n                j += k\n                if i == j or j == n:\n                    break", "from sys import stdin\ninput = stdin.readline\n\nclass Graph:\n\n    def __init__(self, n, res):\n        self.num = n\n        self.data = [[] for _ in range(n)]\n        for (x, y) in res:\n            self.data[x - 1].append(y - 1)\n            self.data[y - 1].append(x - 1)\n(n, m, q) = map(int, input().split())\nx = []\ny = []\nfor _ in range(m):\n    li = input().split()\n    x.append(int(li[0]))\n    y.append(int(li[1]))\nres = list(zip(x, y))\ng1 = Graph(n, res)\nv = []\na = []\ni = 0\nj = 0\nfor _ in range(n):\n    v.append(0)\nfor _ in range(q):\n    (b, c) = map(int, input().split())\n    if b == 1 and v[c - 1] != 1:\n        v[c - 1] = 1\n        a.append(c - 1)\n        j = j + 1\n    if b == 3:\n        if v[c - 1] == 1:\n            print('YES')\n        else:\n            print('NO')\n    if b == 2:\n        if j != n:\n            for _ in range(min(c, n - 1)):\n                k = 0\n                while i <= j - 1:\n                    s = a[i]\n                    if j + k == n:\n                        break\n                    for t in g1.data[s]:\n                        if v[t] != 1:\n                            a.append(t)\n                            k += 1\n                            v[t] = 1\n                            if j + k == n:\n                                break\n                    i = i + 1\n                j += k\n                if i == j or j == n:\n                    break", "from sys import stdin\ninp = stdin.readline\n(N, M, Q) = map(int, inp().split())\nfrzn = [False] * (N + 1)\nnbr = [[] for nx in range(N + 1)]\nfor mx in range(M):\n    (u, v) = map(int, inp().split())\n    nbr[u].append(v)\n    nbr[v].append(u)\nfrnt = []\nans = []\nqpend = []\nfor qx in range(Q):\n    (cq, cp) = map(int, inp().split())\n    if cq != 3:\n        qpend.append((cq, cp))\n        continue\n    for (q, p) in qpend:\n        if q == 1:\n            if not frzn[p]:\n                frnt.append(p)\n                frzn[p] = True\n        else:\n            while p and frnt:\n                newfrnt = []\n                for u in frnt:\n                    for v in nbr[u]:\n                        if not frzn[v]:\n                            frzn[v] = True\n                            newfrnt.append(v)\n                frnt = newfrnt\n                p -= 1\n    ans.append('YES' if frzn[cp] else 'NO')\n    qpend = []\nprint('\\n'.join(ans))", "from collections import deque, defaultdict\n\nclass Graph:\n\n    def __init__(self, n=None):\n        self.node_count = n\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, u, v, directed=False):\n        if not directed:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        else:\n            self.adj_list[u].append(v)\n\n    def bfs(self, q, t, vis):\n        for _ in range(t):\n            if not q:\n                break\n            n = len(q)\n            for _ in range(n):\n                root = q.popleft()\n                for x in self.adj_list[root]:\n                    if not vis[x]:\n                        vis[x] = 1\n                        q.append(x)\ng = Graph()\n(n, m, q) = map(int, input().split())\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    g.add_edge(u, v)\nvis = [0] * (n + 1)\nqueue = deque([])\nfor _ in range(q):\n    (a, b) = map(int, input().split())\n    if a == 1:\n        if not vis[b]:\n            vis[b] = 1\n            queue.append(b)\n    elif a == 3:\n        print('YES') if vis[b] else print('NO')\n    elif a == 2:\n        g.bfs(queue, b, vis)", "import sys\nimport os\nfrom math import *\nfrom collections import *\nimport bisect\nfrom heapq import *\nfrom itertools import permutations\nif os.path.exists('input.txt') and os.path.exists('output.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ninput = sys.stdin.readline\n\ndef lcm(a, b):\n    k1 = math.gcd(a, b)\n    k2 = a * b\n    return k2 // k1\nmod = 10 ** 9 + 7\n\ndef inp():\n    return map(int, input().strip().split(' '))\n\ndef lis():\n    return list(inp())\nmoD = 998244353\nmod = 10 ** 9 + 7\nmod = 998244353\nmod = 10 ** 9 + 7\n\ndef prim(n):\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\nma = 2 * (10 ** 5 + 1)\n\ndef update(ind, val, n):\n    while ind <= n:\n        fenwick[ind] += val\n        ind += ind & -ind\n\ndef qsum(ind):\n    ans = 0\n    while ind > 0:\n        ans += fenwick[ind]\n        ind -= ind & -ind\n    return ans\n\ndef dfs(adj, vis, u, l):\n    vis[u] = 1\n    l.add(u)\n    for i in adj[u]:\n        if vis[i] == 0:\n            dfs(adj, vis, i, l)\nmod = 10 ** 9 + 7\n\ndef dfs(node, p, col, adj, cnt):\n    cnt[col] += 1\n    for i in adj[node]:\n        if i != p:\n            dfs(i, node, col ^ 1, adj, cnt)\n\ndef solve():\n    (n, m, que) = inp()\n    adj = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = inp()\n        adj[u].append(v)\n        adj[v].append(u)\n    mp = [0 for i in range(n + 1)]\n    q = []\n    for i in range(que):\n        (x, y) = inp()\n        if x == 3:\n            print('YES' if mp[y] == 1 else 'NO')\n        elif x == 1:\n            if mp[y] == 0:\n                q.append(y)\n            mp[y] = 1\n        else:\n            i = 0\n            while i < y and q:\n                k = len(q)\n                while k > 0:\n                    if len(q) == 0:\n                        break\n                    u = q.pop(0)\n                    for c in adj[u]:\n                        if mp[c] == 0:\n                            mp[c] = 1\n                            q.append(c)\n                    k -= 1\n                i += 1\nt = 1\nfor _ in range(t):\n    solve()", "import collections\n\ndef main():\n    (N, M, Q) = map(int, input().split())\n    adj_list = collections.defaultdict(list)\n    for _ in range(M):\n        (u, v) = map(int, input().split())\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    frozen = set()\n    nbrs_queue = set()\n\n    def bfs_depth(iters: int):\n        nonlocal nbrs_queue\n        while iters and nbrs_queue:\n            nxt_queue = set()\n            for node in nbrs_queue:\n                if node in frozen:\n                    continue\n                frozen.add(node)\n                for nbr in adj_list[node]:\n                    if nbr not in frozen:\n                        nxt_queue.add(nbr)\n            nbrs_queue = nxt_queue\n            iters -= 1\n    for _ in range(Q):\n        (qtype, node) = map(int, input().split())\n        if qtype == 1:\n            if node in frozen:\n                continue\n            frozen.add(node)\n            for nbr in adj_list[node]:\n                if nbr not in frozen:\n                    nbrs_queue.add(nbr)\n        elif qtype == 2:\n            bfs_depth(node)\n        elif node in frozen:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import collections\nfrom math import ceil, gcd, sqrt, log\nINF = float('inf')\nmod = 1000000007\n\ndef solve():\n    (n, m, q) = map(int, input().split())\n    graph = collections.defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [0] * (n + 1)\n    count = 0\n    Q = collections.deque()\n    for i in range(q):\n        (typ, x) = map(int, input().split())\n        if typ == 1:\n            if not visited[x]:\n                visited[x] = 1\n                Q.append(x)\n                count += 1\n        elif typ == 2:\n            time = x\n            if count != n:\n                while time:\n                    siz = len(Q)\n                    for j in range(siz):\n                        node = Q.popleft()\n                        l = graph[node]\n                        for adj in l:\n                            if not visited[adj]:\n                                visited[adj] = 1\n                                count += 1\n                                if count == n:\n                                    break\n                                Q.append(adj)\n                        if count == n:\n                            break\n                    if count == n:\n                        break\n                    time -= 1\n        elif typ == 3:\n            if visited[x] == 1:\n                print('YES')\n            else:\n                print('NO')\nt = 1\nwhile t != 0:\n    solve()\n    t -= 1", "import collections\nfrom math import ceil, gcd, sqrt, log\nINF = float('inf')\nmod = 1000000007\n\ndef solve():\n    (n, m, q) = map(int, input().split())\n    graph = collections.defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [0] * (n + 1)\n    count = 0\n    Q = collections.deque()\n    for i in range(q):\n        (typ, x) = map(int, input().split())\n        if typ == 1:\n            if not visited[x]:\n                visited[x] = 1\n                Q.append(x)\n                count += 1\n        elif typ == 2:\n            time = x\n            if count != n:\n                while time:\n                    siz = len(Q)\n                    for j in range(siz):\n                        node = Q.popleft()\n                        l = graph[node]\n                        for adj in l:\n                            if not visited[adj]:\n                                visited[adj] = 1\n                                count += 1\n                                if count == n:\n                                    break\n                                Q.append(adj)\n                        if count == n:\n                            break\n                    if count == n:\n                        break\n                    time -= 1\n        elif typ == 3:\n            if visited[x] == 1:\n                print('YES')\n            else:\n                print('NO')\nt = 1\nwhile t != 0:\n    solve()\n    t -= 1", "import collections\nfrom math import ceil, gcd, sqrt, log\nINF = float('inf')\nmod = 1000000007\n\ndef solve():\n    (n, m, q) = map(int, input().split())\n    graph = collections.defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [0] * (n + 1)\n    count = 0\n    Q = collections.deque()\n    for i in range(q):\n        (typ, x) = map(int, input().split())\n        if typ == 1:\n            if not visited[x]:\n                visited[x] = 1\n                Q.append(x)\n                count += 1\n        elif typ == 2:\n            time = x\n            if count != n:\n                while time:\n                    siz = len(Q)\n                    for j in range(siz):\n                        node = Q.popleft()\n                        l = graph[node]\n                        for adj in l:\n                            if not visited[adj]:\n                                visited[adj] = 1\n                                count += 1\n                                if count == n:\n                                    break\n                                Q.append(adj)\n                        if count == n:\n                            break\n                    if count == n:\n                        break\n                    time -= 1\n        elif typ == 3:\n            if visited[x] == 1:\n                print('YES')\n            else:\n                print('NO')\nt = 1\nwhile t != 0:\n    solve()\n    t -= 1", "from collections import defaultdict\nadj = defaultdict(list)\n(n, m, Q) = map(int, input().split())\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\nvis = set()\nq = []\nfor i in range(Q):\n    (qt, x) = map(int, input().split())\n    if qt == 1:\n        if x not in vis:\n            q.append(x)\n            vis.add(x)\n    elif qt == 2:\n        while x and q:\n            l = len(q)\n            while l:\n                u = q.pop(0)\n                for v in adj[u]:\n                    if v not in vis:\n                        q.append(v)\n                        vis.add(v)\n                l -= 1\n            x -= 1\n    elif x in vis:\n        print('YES')\n    else:\n        print('NO')", "import sys\nimport os\nfrom math import *\nfrom collections import *\nimport bisect\nfrom heapq import *\nfrom itertools import permutations\nif os.path.exists('input.txt') and os.path.exists('output.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ninput = sys.stdin.readline\n\ndef lcm(a, b):\n    k1 = math.gcd(a, b)\n    k2 = a * b\n    return k2 // k1\nmod = 10 ** 9 + 7\n\ndef inp():\n    return map(int, input().strip().split(' '))\n\ndef lis():\n    return list(inp())\nmoD = 998244353\nmod = 10 ** 9 + 7\nmod = 998244353\nmod = 10 ** 9 + 7\n\ndef prim(n):\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\nma = 2 * (10 ** 5 + 1)\n\ndef update(ind, val, n):\n    while ind <= n:\n        fenwick[ind] += val\n        ind += ind & -ind\n\ndef qsum(ind):\n    ans = 0\n    while ind > 0:\n        ans += fenwick[ind]\n        ind -= ind & -ind\n    return ans\n\ndef dfs(adj, vis, u, l):\n    vis[u] = 1\n    l.add(u)\n    for i in adj[u]:\n        if vis[i] == 0:\n            dfs(adj, vis, i, l)\nmod = 10 ** 9 + 7\n\ndef dfs(node, p, col, adj, cnt):\n    cnt[col] += 1\n    for i in adj[node]:\n        if i != p:\n            dfs(i, node, col ^ 1, adj, cnt)\n\ndef solve():\n    (n, m, que) = inp()\n    adj = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = inp()\n        adj[u].append(v)\n        adj[v].append(u)\n    mp = [0 for i in range(n + 1)]\n    q = []\n    for i in range(que):\n        (x, y) = inp()\n        if x == 3:\n            print('YES' if mp[y] == 1 else 'NO')\n        elif x == 1:\n            if mp[y] == 0:\n                q.append(y)\n            mp[y] = 1\n        else:\n            i = 0\n            while i < y and q:\n                k = len(q)\n                while k > 0:\n                    if len(q) == 0:\n                        break\n                    u = q.pop(0)\n                    for c in adj[u]:\n                        if mp[c] == 0:\n                            mp[c] = 1\n                            q.append(c)\n                    k -= 1\n                i += 1\nt = 1\nfor _ in range(t):\n    solve()", "from sys import stdin\ninp = stdin.readline\n(N, M, Q) = map(int, inp().split())\nfrzn = [False] * (N + 1)\nnbr = [[] for nx in range(N + 1)]\nfrnt = []\nans = []\nfor mx in range(M):\n    (u, v) = map(int, inp().split())\n    nbr[u].append(v)\n    nbr[v].append(u)\nfor qx in range(Q):\n    (q, p) = map(int, inp().split())\n    if q == 1:\n        if not frzn[p]:\n            frnt.append(p)\n            frzn[p] = True\n    elif q == 3:\n        ans.append('YES' if frzn[p] else 'NO')\n    else:\n        while p and frnt:\n            newfrnt = []\n            for u in frnt:\n                for v in nbr[u]:\n                    if not frzn[v]:\n                        frzn[v] = True\n                        newfrnt.append(v)\n            frnt = newfrnt\n            p -= 1\nprint('\\n'.join(ans))", "from sys import stdin\nfrom collections import deque\ninp = stdin.readline\n(N, M, Q) = map(int, inp().split())\nfrzn = [False] * (N + 1)\nnbr = [[] for nx in range(N + 1)]\nfrnt = deque()\nans = []\nfor mx in range(M):\n    (u, v) = map(int, inp().split())\n    nbr[u].append(v)\n    nbr[v].append(u)\nfor qx in range(Q):\n    (q, p) = map(int, inp().split())\n    if q == 1:\n        if not frzn[p]:\n            frnt.append(p)\n            frzn[p] = True\n    elif q == 3:\n        ans.append('YES' if frzn[p] else 'NO')\n    else:\n        while p and frnt:\n            for _ in range(len(frnt)):\n                u = frnt.popleft()\n                for v in nbr[u]:\n                    if not frzn[v]:\n                        frzn[v] = True\n                        frnt.append(v)\n            p -= 1\nprint(*ans, sep='\\n')", "(n, m, q) = map(int, input().split())\ngraph = dict()\ntemp = dict()\nfor i in range(1, n + 1):\n    temp[i] = 0\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    if u not in graph.keys():\n        graph[u] = [v]\n        temp[u] = 0\n    else:\n        graph[u].append(v)\n    if v not in graph.keys():\n        graph[v] = [u]\n        temp[v] = 0\n    else:\n        graph[v].append(u)\nque = list()\nfor i in range(q):\n    (a, b) = map(int, input().split())\n    if a == 3:\n        if temp[b] == 1:\n            print('YES')\n        else:\n            print('NO')\n    elif a == 1:\n        if temp[b] == 0:\n            que.append(b)\n        temp[b] = 1\n    else:\n        for i in range(b):\n            if len(que) == 0:\n                break\n            length = len(que)\n            while length > 0:\n                e = que.pop(0)\n                length -= 1\n                for x in graph[e]:\n                    if temp[x] == 0:\n                        temp[x] = 1\n                        que.append(x)", "import heapq\nfrom collections import deque\n(n, m, q) = map(int, input().split())\ngraph = {}\nx = 10000000000000\nvisited = [False for i in range(n + 1)]\nvc = n\nfrozen = deque([])\nfor i in range(1, n + 1):\n    graph[i] = []\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\nfor _ in range(q):\n    (qu, val) = map(int, input().split())\n    if qu == 1:\n        if not visited[val]:\n            vc -= 1\n            visited[val] = True\n            frozen.append(val)\n    elif qu == 2:\n        if vc > 0:\n            timer = val\n            q = frozen\n            empty = deque()\n            while timer > 0:\n                while q:\n                    vnode = q.popleft()\n                    for i in graph[vnode]:\n                        if not visited[i]:\n                            vc -= 1\n                            empty.append(i)\n                            visited[i] = True\n                    if vc <= 0:\n                        break\n                if vc <= 0:\n                    break\n                q = empty\n                empty = deque()\n                timer -= 1\n            frozen = q\n    else:\n        print('YES' if visited[val] else 'NO')", "(n, m, q) = map(int, input().split())\nadj = [[] for i in range(n + 1)]\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    adj[x].append(y)\n    adj[y].append(x)\nfreeze = [0] * n\nqu = []\nt = 0\nfor i in range(q):\n    (x, y) = map(int, input().split())\n    if x == 1:\n        if not freeze[y - 1]:\n            qu.append(y)\n        freeze[y - 1] = 1\n    elif x == 2:\n        while y > 0 and qu:\n            ll = len(qu)\n            while ll:\n                u = qu.pop(0)\n                for j in adj[u]:\n                    if freeze[j - 1] == 0:\n                        qu.append(j)\n                    freeze[j - 1] = 1\n                ll -= 1\n            y -= 1\n    elif freeze[y - 1] == 1:\n        print('YES')\n    else:\n        print('NO')", "import sys\nimport os\nfrom math import *\nfrom collections import *\nimport bisect\nfrom heapq import *\nfrom itertools import permutations\nif os.path.exists('input.txt') and os.path.exists('output.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ninput = sys.stdin.readline\n\ndef lcm(a, b):\n    k1 = math.gcd(a, b)\n    k2 = a * b\n    return k2 // k1\nmod = 10 ** 9 + 7\n\ndef inp():\n    return map(int, input().strip().split(' '))\n\ndef lis():\n    return list(inp())\nmoD = 998244353\nmod = 10 ** 9 + 7\nmod = 998244353\nmod = 10 ** 9 + 7\n\ndef prim(n):\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\nma = 2 * (10 ** 5 + 1)\n\ndef update(ind, val, n):\n    while ind <= n:\n        fenwick[ind] += val\n        ind += ind & -ind\n\ndef qsum(ind):\n    ans = 0\n    while ind > 0:\n        ans += fenwick[ind]\n        ind -= ind & -ind\n    return ans\n\ndef dfs(adj, vis, u, l):\n    vis[u] = 1\n    l.add(u)\n    for i in adj[u]:\n        if vis[i] == 0:\n            dfs(adj, vis, i, l)\nmod = 10 ** 9 + 7\n\ndef dfs(node, p, col, adj, cnt):\n    cnt[col] += 1\n    for i in adj[node]:\n        if i != p:\n            dfs(i, node, col ^ 1, adj, cnt)\n\ndef solve():\n    (n, m, que) = inp()\n    adj = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = inp()\n        adj[u].append(v)\n        adj[v].append(u)\n    mp = [0 for i in range(n + 1)]\n    q = []\n    for i in range(que):\n        (x, y) = inp()\n        if x == 3:\n            print('YES' if mp[y] == 1 else 'NO')\n        elif x == 1:\n            if mp[y] == 0:\n                q.append(y)\n            mp[y] = 1\n        else:\n            i = 0\n            while i < y and q:\n                k = len(q)\n                while k > 0:\n                    if len(q) == 0:\n                        break\n                    u = q.pop(0)\n                    for c in adj[u]:\n                        if mp[c] == 0:\n                            mp[c] = 1\n                            q.append(c)\n                    k -= 1\n                i += 1\nt = 1\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n(n, m, q) = list(map(int, input().split()))\ngraph = defaultdict(list)\nf = [q + 1] * (n + 1)\n\ndef bfs(n):\n    t = current_time\n    queue = list()\n    if f[n] > t:\n        f[n] = t\n        queue.append(n)\n    while len(queue) > 0:\n        size = len(queue)\n        t += 1\n        while size > 0:\n            o = queue.pop(0)\n            for nn in graph[o]:\n                if f[nn] > t:\n                    f[nn] = t\n                    queue.append(nn)\n            size -= 1\nwhile m > 0:\n    (u, v) = list(map(int, input().split()))\n    graph[u].append(v)\n    graph[v].append(u)\n    m -= 1\ncurrent_time = 0\nwhile q > 0:\n    (t, n) = list(map(int, input().split()))\n    if t == 1:\n        bfs(n)\n    elif t == 2:\n        current_time += n\n    elif f[n] > current_time:\n        print('NO')\n    else:\n        print('YES')\n    q -= 1", "(n, m, q) = map(int, input().split())\nadjancy = dict()\nfor _ in range(1, n + 1):\n    adjancy[_] = []\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    adjancy[u].append(v)\n    adjancy[v].append(u)\nfrozen = set()\nvisited_neigh = set()\nfor i in range(q):\n    (qu, node) = map(int, input().split())\n    if qu == 1:\n        frozen.add(node)\n    elif qu == 3:\n        if node in frozen:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        length = len(frozen)\n        if length == 0 or length == n:\n            continue\n        tem = frozen.copy()\n        for __ in range(node):\n            new = set()\n            for j in tem:\n                if j not in visited_neigh:\n                    for k in adjancy[j]:\n                        frozen.add(k)\n                        new.add(k)\n                    visited_neigh.add(j)\n            tem = new\n            new = set()", "from collections import defaultdict, deque\n\ndef bfs(time):\n    cnt = 0\n    while que and cnt < time:\n        for a in range(len(que)):\n            node = que.popleft()\n            for neighbour in graph[node]:\n                if neighbour not in frozen:\n                    que.append(neighbour)\n                    frozen.add(neighbour)\n        cnt += 1\ngraph = defaultdict(list)\n(n, m, q) = map(int, input().split())\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\nque = deque()\nfrozen = set()\nfor i in range(q):\n    (code, x) = map(int, input().split())\n    if code == 1:\n        if x not in frozen:\n            que.append(x)\n            frozen.add(x)\n    elif code == 2:\n        bfs(x)\n    elif x in frozen:\n        print('YES')\n    else:\n        print('NO')", "from collections import deque\nfrozen = set()\nrecently_frozen = set()\nd = {}\n(n, m, q) = map(int, input().split())\nfor x in range(m):\n    (u, v) = map(int, input().split())\n    if u not in d:\n        d[u] = deque()\n    d[u].append(v)\n    if v not in d:\n        d[v] = deque()\n    d[v].append(u)\nfor x in range(q):\n    (type, value) = map(int, input().split())\n    if type == 1:\n        frozen.add(value)\n        recently_frozen.add(value)\n    if type == 3:\n        if value in frozen:\n            print('YES')\n        else:\n            print('NO')\n    if type == 2:\n        if len(frozen) == n:\n            continue\n        while value > 0:\n            temp = set()\n            for y in recently_frozen:\n                for z in d[y]:\n                    if z not in frozen:\n                        temp.add(z)\n                        frozen.add(z)\n            recently_frozen = temp\n            value -= 1", "(n, m, q) = list(map(int, input().split()))\nisFrozen = [False] * (n + 1)\nchosen = set()\ngraph = {}\nfor i in range(1, n + 1):\n    graph[i] = []\nfor _ in range(m):\n    (i, j) = list(map(int, input().split()))\n    graph[i].append(j)\n    graph[j].append(i)\nfor _ in range(q):\n    (type1, val) = list(map(int, input().split()))\n    if type1 == 1:\n        if isFrozen[val] == False:\n            isFrozen[val] = True\n            for i in graph[val]:\n                if not isFrozen[i]:\n                    chosen.add(i)\n    elif type1 == 3:\n        if isFrozen[val]:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        for i in range(val):\n            temp = set()\n            if len(chosen) == 0:\n                break\n            for node in chosen:\n                isFrozen[node] = True\n                for j in graph[node]:\n                    if not isFrozen[j]:\n                        temp.add(j)\n            chosen = temp", "from collections import deque\n(n, m, q) = map(int, input().split())\ngraph = [[] for i in range(n + 1)]\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\nfrozen = [False for i in range(n + 1)]\nqueue = deque()\nfrozenCount = 0\nfor _ in range(q):\n    (typ, x) = map(int, input().split())\n    if typ == 1:\n        if frozen[x] == False:\n            queue.append(x)\n            frozen[x] = True\n            frozenCount += 1\n    elif typ == 2:\n        if frozenCount != n:\n            for i in range(x):\n                queLen = len(queue)\n                for itera in range(queLen):\n                    node = queue.popleft()\n                    adjList = graph[node]\n                    for adj in adjList:\n                        if frozen[adj] == False:\n                            frozen[adj] = True\n                            frozenCount += 1\n                            if frozenCount == n:\n                                break\n                            queue.append(adj)\n                    if frozenCount == n:\n                        break\n                if frozenCount == n:\n                    break\n    elif typ == 3:\n        if frozen[x]:\n            print('YES')\n        else:\n            print('NO')", "import copy\n(n, m, q1) = map(int, input().split())\nadj = []\nvis = []\nfor _ in range(n + 1):\n    adj.append([])\n    vis.append(0)\nfor _ in range(m):\n    (p, q) = map(int, input().split())\n    adj[p].append(q)\n    adj[q].append(p)\nd = []\nfor _ in range(q1):\n    (type, x) = map(int, input().split())\n    if type == 1:\n        if vis[x] == 0:\n            d.append(x)\n        vis[x] = 1\n    elif type == 3:\n        if vis[x] == 1:\n            print('YES')\n        else:\n            print('NO')\n    elif len(d) != 0:\n        for _ in range(x):\n            k = []\n            if len(d) == 0:\n                break\n            for i in d:\n                for j in adj[i]:\n                    if vis[j] == 0:\n                        vis[j] = 1\n                        k.append(j)\n            d = copy.deepcopy(k)", "def process(n: int, edges: dict, queries: list):\n    is_frozen = set()\n    frozen_perimeter = set()\n    for query in queries:\n        qtype = query[0]\n        qparam = query[1]\n        if qtype == 3:\n            if qparam in is_frozen:\n                print('YES')\n            else:\n                print('NO')\n        elif qtype == 1:\n            if qparam in is_frozen:\n                continue\n            else:\n                is_frozen.add(qparam)\n                frozen_perimeter.add(qparam)\n        else:\n            time = qparam\n            while time > 0 and len(frozen_perimeter) > 0:\n                next_perimeter = set()\n                for node in frozen_perimeter:\n                    next_perimeter |= edges[node]\n                next_perimeter -= is_frozen\n                is_frozen |= next_perimeter\n                frozen_perimeter = next_perimeter\n                time -= 1\n\ndef add_directed_edge(edges: dict, edge: list):\n    if edge[0] not in edges:\n        edges[edge[0]] = set()\n    edges[edge[0]].add(edge[1])\n\ndef add_undirected_edge(edges: dict, edge: list):\n    add_directed_edge(edges, edge)\n    add_directed_edge(edges, [edge[1], edge[0]])\n\ndef get_list(func):\n    return list(map(func, input().split()))\n\ndef solve():\n    (n, m, q) = get_list(int)\n    edges = {}\n    for _ in range(m):\n        edge = get_list(int)\n        add_undirected_edge(edges, edge)\n    queries = []\n    for _ in range(q):\n        queries.append(get_list(int))\n    process(n, edges, queries)\n\ndef test1():\n    n = 6\n    edges = {}\n    add_undirected_edge(edges, [1, 2])\n    add_undirected_edge(edges, [2, 3])\n    add_undirected_edge(edges, [4, 1])\n    add_undirected_edge(edges, [5, 4])\n    add_undirected_edge(edges, [6, 1])\n    add_undirected_edge(edges, [6, 5])\n    queries = [[1, 1], [3, 1], [1, 5], [2, 1], [3, 4], [3, 3]]\n    process(n, edges, queries)\nsolve()", "(n, m, q) = map(int, input().split())\ns = [-1 for i in range(n + 1)]\ns1 = [[] for i in range(n + 1)]\ns2 = []\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    s1[u].append(v)\n    s1[v].append(u)\nfor i in range(q):\n    (t, j) = map(int, input().split())\n    if t == 1:\n        if s[j] == -1:\n            s[j] = 0\n            s2.append(j)\n    elif t == 2:\n        num = len(s2)\n        while j != 0:\n            if len(s2) == 0:\n                break\n            j1 = s2[0]\n            s2.pop(0)\n            num -= 1\n            if s[j1] == 0:\n                for k1 in s1[j1]:\n                    if s[k1] == -1:\n                        s[k1] = 0\n                        s2.append(k1)\n            if num == 0:\n                j -= 1\n                num = len(s2)\n            s[j1] = 1\n    elif t == 3:\n        if s[j] == -1:\n            print('NO')\n        else:\n            print('YES')", "from sys import stdin as sin\n\ndef aint():\n    return int(input())\n\ndef amap():\n    return map(int, sin.readline().split())\n\ndef alist():\n    return list(map(int, sin.readline().split()))\n\ndef astr():\n    return input()\nfrom collections import deque\n(n, m, q) = amap()\nd = {}\nfr = {}\nfor i in range(1, n + 1):\n    d[i] = []\n    fr[i] = False\nfor i in range(m):\n    (u, v) = amap()\n    d[u].append(v)\n    d[v].append(u)\nr = deque([])\nfor i in range(q):\n    (t, x) = amap()\n    if t == 1:\n        if fr.get(x) == False:\n            r.append(x)\n        fr[x] = True\n    elif t == 2:\n        r.append(None)\n        while r and x:\n            curr = r.popleft()\n            if curr != None:\n                for j in d[curr]:\n                    if fr.get(j) == False:\n                        r.append(j)\n                        fr[j] = True\n            else:\n                x -= 1\n                if r:\n                    r.append(None)\n        if r and r[-1] == None:\n            r.pop()\n    elif fr.get(x):\n        print('YES')\n    else:\n        print('NO')", "def explore(frozen, que, c):\n    deq = []\n    for i in que:\n        for j in adj[i]:\n            if frozen[j - 1] == 'NO':\n                frozen[j - 1] = 'YES'\n                deq.append(j - 1)\n                c += 1\n    return (frozen, deq, c)\n(n, m, q) = map(int, input().split())\nadj = [[] for i in range(n)]\nfor t in range(m):\n    (u, v) = map(int, input().split())\n    adj[u - 1].append(v)\n    adj[v - 1].append(u)\nfrozen = ['NO' for i in range(n)]\nque = []\nc = 0\nfor t in range(q):\n    (typ, x) = map(int, input().split())\n    if typ == 1:\n        if frozen[x - 1] == 'NO':\n            frozen[x - 1] = 'YES'\n            que.append(x - 1)\n            c += 1\n    elif typ == 2:\n        if c >= n:\n            continue\n        for k in range(x):\n            (frozen, que, c) = explore(frozen, que, c)\n    else:\n        print(frozen[x - 1])", "import math\nfrom collections import Counter, defaultdict, deque\nimport heapq\nimport sys\nmod = 10 ** 9 + 7\ninput = sys.stdin.readline\nreadInt = lambda : int(input().strip())\nreadfloat = lambda : float(input().strip())\nreadStr = lambda : input().strip()\nintList = lambda : list(map(int, input().strip().split()))\nintMap = lambda : map(int, input().strip().split())\nfloatList = lambda : list(map(float, input().strip().split()))\nfloatMap = lambda : map(float, input().strip().split())\nstrList = lambda : list(input().strip().split())\n\ndef print(*args, end='\\n', sep=' '):\n    for i in args:\n        sys.stdout.write(str(i))\n        sys.stdout.write(sep)\n    sys.stdout.write(end)\n\ndef make_bfs():\n    while q:\n        (tt, u) = q[0]\n        if tt > spend:\n            break\n        (tt, u) = heapq.heappop(q)\n        if u in frozen:\n            continue\n        frozen.add(u)\n        for v in graph[u]:\n            if v not in frozen:\n                q.append([tt + 1, v])\n(n, m, Q) = intMap()\ngraph = defaultdict(list)\nfor i in range(m):\n    (u, v) = intMap()\n    graph[u].append(v)\n    graph[v].append(u)\nspend = 0\nq = []\nfrozen = set()\nfor i in range(Q):\n    (tp, v) = intMap()\n    if tp == 1:\n        heapq.heappush(q, [spend, v])\n    if tp == 2:\n        spend += v\n    if tp == 3:\n        make_bfs()\n        if v in frozen:\n            print('YES')\n        else:\n            print('NO')", "from collections import deque\n(n, m, q) = map(int, input().split())\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    u -= 1\n    v -= 1\n    adj[u].append(v)\n    adj[v].append(u)\nqueue = deque()\nfrozen = set()\n\ndef startFreeze(time):\n    minutes = 0\n    while queue and minutes < time:\n        n = len(queue)\n        for _ in range(n):\n            u = queue.popleft()\n            for v in adj[u]:\n                if v not in frozen:\n                    queue.append(v)\n                    frozen.add(v)\n        minutes += 1\nfor _ in range(q):\n    (qType, x) = map(int, input().split())\n    if qType == 1:\n        if x - 1 not in frozen:\n            queue.append(x - 1)\n            frozen.add(x - 1)\n    elif qType == 2:\n        startFreeze(x)\n    elif qType == 3:\n        if x - 1 in frozen:\n            print('YES')\n        else:\n            print('NO')", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nQueue = deque()\n\ndef solve():\n    (n, m, q) = mp()\n    d = defaultdict(list)\n    for i in range(m):\n        (a, b) = mp()\n        d[a].append(b)\n        d[b].append(a)\n    ma = n - 1\n    Q = deque()\n    v = defaultdict(int)\n    for i in range(q):\n        (a, b) = mp()\n        if a == 3:\n            pr('YES' if v[b] else 'NO')\n        elif a == 1:\n            if v[b] == 0:\n                Q.append(b)\n                v[b] = 1\n        else:\n            while Q:\n                for j in d[Q[0]]:\n                    Queue.append(j)\n                Q.popleft()\n            if ma and Queue:\n                while b and ma:\n                    N = len(Queue)\n                    for j in range(N):\n                        if not v[Queue[0]]:\n                            v[Queue[0]] = 1\n                            for k in d[Queue[0]]:\n                                Queue.append(k)\n                        Queue.popleft()\n                    ma -= 1\n                    b -= 1\nfor _ in range(1):\n    solve()", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom queue import PriorityQueue\nfrom queue import Queue\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nimport random\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\ngp = []\nans = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\n\ndef flip(a, l, r):\n    for i in range(l, r):\n        a[i] = '0' if a[i] == '1' else '1'\n    return\n\ndef hnbhai(tc):\n    (n, m, q) = sd()\n    gp = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = sd()\n        gp[u].append(v)\n        gp[v].append(u)\n    state = [0] * (n + 1)\n    vis = [0] * (n + 1)\n    que = []\n    for i in range(q):\n        (t, u) = sd()\n        if t == 1:\n            if vis[u] == 0:\n                que.append(u)\n                vis[u] = 1\n                state[u] = 1\n            continue\n        if t == 3:\n            if state[u]:\n                print('YES')\n                continue\n            print('NO')\n            continue\n        temp = []\n        while u > 0 and len(que) > 0:\n            u -= 1\n            while len(que) > 0:\n                ele = que.pop()\n                for j in gp[ele]:\n                    if vis[j] == 1:\n                        continue\n                    vis[j] = 1\n                    state[j] = 1\n                    temp.append(j)\n            que = temp.copy()\n            temp = []\nfor _ in range(1):\n    hnbhai(_ + 1)"]