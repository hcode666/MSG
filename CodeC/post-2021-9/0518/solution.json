["import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) + (y + 1) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    temp = a[0]\n    tempc = 0\n    count = []\n    for val in a:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if k >= eff:\n        print(n)\n    else:\n        print(hfindb(count, k) + output)", "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) * (t + 2) // 2 + (y + 1 - s) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = x[5]\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    temp = a[0]\n    tempc = 0\n    count = []\n    for val in a:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if k >= eff:\n        print(n)\n    else:\n        print(hfindb(count, k) + output)", "from heapq import heappush, heappop\n\ndef fun(size, k):\n    val = (size - k) // (k + 1)\n    return k + (size - k) // (k + 1) * ((size - k) // (k + 1) + 1) // 2 * (k + 1 - (size - k) % (k + 1)) + (size - k) % (k + 1) * ((val + 1) * (val + 2) // 2)\n\ndef do(lis, k):\n    myheap = []\n    for i in lis:\n        heappush(myheap, [-(i * (i + 1) // 2 - fun(i, 1)), [i, 1], i * (i + 1) // 2])\n    ans = 0\n    x = 0\n    while x != k:\n        val = heappop(myheap)\n        if val[0] == 0:\n            heappush(myheap, val)\n        else:\n            size = val[1][0]\n            f = val[1][1]\n            heappush(myheap, [-(fun(size, f) - fun(size, f + 1)), [size, f + 1], fun(size, f)])\n        x += 1\n    n = len(myheap)\n    for i in range(n):\n        ans += myheap[i][-1]\n    return ans\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    arr = []\n    prev = l[0]\n    count = 1\n    for i in range(1, n):\n        if prev == l[i]:\n            count += 1\n        else:\n            arr.append(count)\n            prev = l[i]\n            count = 1\n    arr.append(count)\n    print(do(arr, k))", "import heapq\n\ndef comp(x, y):\n    s = (x - y) % (y + 1)\n    t = (x - y) // (y + 1)\n    return s * (t + 1) * (t + 2) // 2 + (y + 1 - s) * t * (t + 1) // 2 + y\n\ndef hfindb(a, k):\n    aa = [[comp(val, 1) - comp(val, 0), val, 0, idx, comp(val, 0), comp(val, 1)] for (idx, val) in enumerate(a)]\n    heapq.heapify(aa)\n    for i in range(k):\n        x = heapq.heappop(aa)\n        x[2] += 1\n        x[4] = comp(x[1], x[2])\n        x[5] = comp(x[1], x[2] + 1)\n        x[0] = x[5] - x[4]\n        heapq.heappush(aa, x)\n    return sum([x[4] for x in aa])\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    temp = a[0]\n    tempc = 0\n    count = []\n    for val in a:\n        if val == temp:\n            tempc += 1\n        else:\n            count.append(tempc)\n            tempc = 1\n            temp = val\n    count.append(tempc)\n    count.sort(reverse=True)\n    output = len(count)\n    eff = sum([t // 2 for t in count])\n    count = [val for val in count if val > 1]\n    output -= len(count)\n    if k >= eff:\n        print(n)\n    else:\n        print(hfindb(count, k) + output)", "from heapq import heappush, heappop\n\ndef fun(size, k):\n    val = (size - k) // (k + 1)\n    return k + (size - k) // (k + 1) * ((size - k) // (k + 1) + 1) // 2 * (k + 1 - (size - k) % (k + 1)) + (size - k) % (k + 1) * ((val + 1) * (val + 2) // 2)\n\ndef do(lis, k):\n    myheap = []\n    for i in lis:\n        heappush(myheap, [-(i * (i + 1) // 2 - fun(i, 1)), [i, 1], i * (i + 1) // 2])\n    ans = 0\n    x = 0\n    while x != k:\n        val = heappop(myheap)\n        if val[0] == 0:\n            heappush(myheap, val)\n        else:\n            size = val[1][0]\n            f = val[1][1]\n            heappush(myheap, [-(fun(size, f) - fun(size, f + 1)), [size, f + 1], fun(size, f)])\n        x += 1\n    n = len(myheap)\n    for i in range(n):\n        ans += myheap[i][-1]\n    return ans\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    arr = []\n    prev = l[0]\n    count = 1\n    for i in range(1, n):\n        if prev == l[i]:\n            count += 1\n        else:\n            arr.append(count)\n            prev = l[i]\n            count = 1\n    arr.append(count)\n    print(do(arr, k))", "from heapq import heappush, heappop\n\ndef fun(size, k):\n    val = (size - k) // (k + 1)\n    return k + (size - k) // (k + 1) * ((size - k) // (k + 1) + 1) // 2 * (k + 1 - (size - k) % (k + 1)) + (size - k) % (k + 1) * ((val + 1) * (val + 2) // 2)\n\ndef do(lis, k):\n    myheap = []\n    for i in lis:\n        heappush(myheap, [-(i * (i + 1) // 2 - fun(i, 1)), [i, 1], i * (i + 1) // 2])\n    ans = 0\n    x = 0\n    while x != k:\n        val = heappop(myheap)\n        if val[0] == 0:\n            heappush(myheap, val)\n        else:\n            size = val[1][0]\n            f = val[1][1]\n            heappush(myheap, [-(fun(size, f) - fun(size, f + 1)), [size, f + 1], fun(size, f)])\n        x += 1\n    n = len(myheap)\n    for i in range(n):\n        ans += myheap[i][-1]\n    return ans\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    arr = []\n    prev = l[0]\n    count = 1\n    for i in range(1, n):\n        if prev == l[i]:\n            count += 1\n        else:\n            arr.append(count)\n            prev = l[i]\n            count = 1\n    arr.append(count)\n    print(do(arr, k))", "def tri(n):\n    return n * (n + 1) // 2\n\ndef cost(split):\n    N = split[0]\n    k = split[1]\n    if N == 1:\n        return 1\n    if k >= N // 2:\n        return N\n    short = (N - k) // (k + 1)\n    extra = short + 1\n    n_extra = (N - k) % (k + 1)\n    n_short = k + 1 - n_extra\n    return n_short * tri(short) + n_extra * tri(extra) + k * 1\nT = int(input())\nfor t in range(T):\n    (N, K) = map(int, input().split())\n    A = map(int, input().split())\n    if K >= N // 2:\n        print(N)\n        continue\n    previous = None\n    partitions = []\n    for a in A:\n        if a == previous:\n            partitions[-1] += 1\n        else:\n            partitions.append(1)\n        previous = a\n    if K >= sum([p // 2 for p in partitions]):\n        print(N)\n        continue\n    splits = [[p, 0, cost([p, 0]) - cost([p, 1])] for p in partitions]\n    if len(splits) == 1:\n        print(cost([N, K]))\n        continue\n    splits.sort(key=lambda x: x[2])\n    for k in range(K):\n        this = splits.pop()\n        this[1] += 1\n        this[2] = cost([this[0], this[1]]) - cost([this[0], this[1] + 1])\n        pos = None\n        if this[2] <= splits[0][2]:\n            pos = 0\n        elif this[2] >= splits[-1][2]:\n            pos = len(splits)\n        else:\n            lo = 0\n            hi = len(splits) - 1\n            while hi - lo > 1:\n                med = (hi + lo) // 2\n                if this[2] == splits[med][2]:\n                    pos = med\n                    break\n                elif this[2] < splits[med][2]:\n                    hi = med\n                else:\n                    assert this[2] > splits[med][2]\n                    lo = med\n            if pos is None:\n                pos = hi\n        splits.insert(pos, this)\n    result = 0\n    for s in splits:\n        result += cost(s)\n    print(result)", "from heapq import *\n\ndef get(le, k):\n    y = le - k - 1\n    g = y // (k + 2)\n    j = y % (k + 2)\n    u = k + 2 - j\n    cost = u * (g * (g + 1) // 2) + j * ((g + 1) * (g + 2) // 2) + k + 1\n    return cost\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    h = []\n    i = 0\n    while i < n:\n        c = 0\n        j = i\n        while j < n and l[i] == l[j]:\n            c += 1\n            j += 1\n        gain = c * (c + 1) // 2 - get(c, 0)\n        heappush(h, [-gain, c, 0, c * (c + 1) // 2])\n        i = j\n    while k != 0 and h:\n        x = heappop(h)\n        if x[0] == 0:\n            heappush(h, x)\n            break\n        else:\n            gain = get(x[1], x[2]) - get(x[1], x[2] + 1)\n            heappush(h, [-gain, x[1], x[2] + 1, get(x[1], x[2])])\n        k -= 1\n    ans = 0\n    for i in h:\n        x = abs(i[-1])\n        ans += x\n    print(ans)", "from heapq import *\n\ndef get(le, k):\n    y = le - k - 1\n    g = y // (k + 2)\n    j = y % (k + 2)\n    u = k + 2 - j\n    cost = u * (g * (g + 1) // 2) + j * ((g + 1) * (g + 2) // 2) + k + 1\n    return cost\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    h = []\n    i = 0\n    while i < n:\n        c = 0\n        j = i\n        while j < n and l[i] == l[j]:\n            c += 1\n            j += 1\n        gain = c * (c + 1) // 2 - get(c, 0)\n        heappush(h, [-gain, c, 0, c * (c + 1) // 2])\n        i = j\n    while k != 0 and h:\n        x = heappop(h)\n        if x[0] == 0:\n            heappush(h, x)\n            break\n        else:\n            gain = get(x[1], x[2]) - get(x[1], x[2] + 1)\n            heappush(h, [-gain, x[1], x[2] + 1, get(x[1], x[2])])\n        k -= 1\n    ans = 0\n    for i in h:\n        x = abs(i[-1])\n        ans += x\n    print(ans)", "from heapq import heappush, heappop\nfrom itertools import groupby\nT = int(input())\nfor _ in range(T):\n    (N, K) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    h = []\n    answer = 0\n    for group in groupby(a):\n        (value, it) = group\n        m = sum((1 for elem in it))\n        f = m * (m + 1) // 2\n        answer += f\n        for i in range(1, m // 2 + 1):\n            k = (m - i) // (i + 1)\n            r = (m - i) % (i + 1)\n            new_f = r * (k + 1) * (k + 2) // 2 + (i + 1 - r) * k * (k + 1) // 2\n            priority = new_f - f + 1\n            heappush(h, priority)\n            f = new_f\n    for i in range(K):\n        try:\n            priority = heappop(h)\n        except:\n            break\n        if priority == 0:\n            break\n        else:\n            answer += priority\n    print(answer)", "from heapq import heapify, heappop, heappush\n\ndef tri(n):\n    return n * (n + 1) // 2\n\ndef numbad(d, c):\n    (x, r) = divmod(c - d, d + 1)\n    return d + tri(x + 1) * r + tri(x) * (d + 1 - r)\nfor tcase in range(int(input())):\n    (n, k) = [int(s) for s in input().split()]\n    a = [int(s) for s in input().split()]\n    (c, pq) = (1, [])\n    for i in range(1, n):\n        if a[i] != a[i - 1]:\n            pq.append((numbad(1, c) - numbad(0, c), 0, c))\n            c = 1\n        else:\n            c += 1\n    pq.append((numbad(1, c) - numbad(0, c), 0, c))\n    heapify(pq)\n    (p, d, c) = heappop(pq)\n    while k > 0 and c - d > d + 1:\n        d += 1\n        heappush(pq, (numbad(d + 1, c) - numbad(d, c), d, c))\n        (p, d, c) = heappop(pq)\n        k -= 1\n    heappush(pq, (p, d, c))\n    print(sum((numbad(d, c) for (p, d, c) in pq)))", "from heapq import heapify, heappop, heappush\n\ndef tri(n):\n    return n * (n + 1) // 2\n\ndef numbad(d, c):\n    r = (c - d) % (d + 1)\n    x = (c - d) // (d + 1)\n    return d + tri(x + 1) * r + tri(x) * (d + 1 - r)\nfor tcase in range(int(input())):\n    (n, k) = [int(s) for s in input().split()]\n    a = [int(s) for s in input().split()]\n    (c, pq) = (1, [])\n    for i in range(1, n):\n        if a[i] != a[i - 1]:\n            pq.append((numbad(1, c) - numbad(0, c), 0, c))\n            c = 1\n        else:\n            c += 1\n    pq.append((numbad(1, c) - numbad(0, c), 0, c))\n    heapify(pq)\n    (p, d, c) = heappop(pq)\n    while k > 0 and c - d > d + 1:\n        d += 1\n        heappush(pq, (numbad(d + 1, c) - numbad(d, c), d, c))\n        (p, d, c) = heappop(pq)\n        k -= 1\n    heappush(pq, (p, d, c))\n    ans = 0\n    for (p, d, c) in pq:\n        ans += numbad(d, c)\n    print(ans)", "import heapq\n\ndef cost(original, partitions):\n    if partitions > (original + 1) // 2:\n        return original\n    ans = partitions - 1\n    remaining = original - partitions + 1\n    base = remaining // partitions\n    leftover = remaining - base * partitions\n    ans += leftover * ((base + 1) * (base + 2) // 2) + (partitions - leftover) * (base * (base + 1) // 2)\n    return ans\n\ndef f(original, partitions):\n    return cost(original, partitions) - cost(original, partitions + 1)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    (*a,) = map(int, input().split())\n    a.append(a[-1] + 1)\n    l = 0\n    lengths = []\n    prev = a[0]\n    for i in a:\n        if i == prev:\n            l += 1\n        else:\n            heapq.heappush(lengths, (-f(l, 1), l, 1))\n            l = 1\n            prev = i\n    for _ in range(k):\n        if lengths[0][0] == 0:\n            break\n        (_, original, partitions) = heapq.heappop(lengths)\n        partitions += 1\n        heapq.heappush(lengths, (-f(original, partitions), original, partitions))\n    print(sum((cost(original, partitions) for (_, original, partitions) in lengths)))"]