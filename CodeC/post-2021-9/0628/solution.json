["def solve(a, swaps):\n    onepos = a.index(1)\n    a = a[onepos:] + a[:onepos]\n    for i in range(1, n):\n        if swaps == 0 or a[i] == i + 1:\n            continue\n        pos = a.index(i + 1)\n        swaps -= 1\n        (a[i], a[pos]) = (a[pos], a[i])\n    return a\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = solve(a[:], 2)\n    onepos = a.index(1)\n    starts = []\n    for i in range(n):\n        if a[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if a[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (a[onepos], a[x]) = (a[x], a[onepos])\n        ans = min(ans, solve(a[:], 1))\n        (a[onepos], a[x]) = (a[x], a[onepos])\n    print(*ans)", "def solve(a, swaps):\n    onepos = a.index(1)\n    a = a[onepos:] + a[:onepos]\n    for i in range(1, n):\n        if swaps == 0 or a[i] == i + 1:\n            continue\n        pos = a.index(i + 1)\n        swaps -= 1\n        (a[i], a[pos]) = (a[pos], a[i])\n    return a\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = solve(a[:], 2)\n    onepos = a.index(1)\n    starts = []\n    for i in range(n):\n        if a[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if a[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (a[onepos], a[x]) = (a[x], a[onepos])\n        ans = min(ans, solve(a[:], 1))\n        (a[onepos], a[x]) = (a[x], a[onepos])\n    print(*ans)", "def solve(a, swaps):\n    onepos = a.index(1)\n    a = a[onepos:] + a[:onepos]\n    for i in range(1, n):\n        if swaps == 0 or a[i] == i + 1:\n            continue\n        pos = a.index(i + 1)\n        swaps -= 1\n        (a[i], a[pos]) = (a[pos], a[i])\n    return a\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = solve(a[:], 2)\n    onepos = a.index(1)\n    starts = []\n    for i in range(n):\n        if a[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if a[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (a[onepos], a[x]) = (a[x], a[onepos])\n        ans = min(ans, solve(a[:], 1))\n        (a[onepos], a[x]) = (a[x], a[onepos])\n    print(*ans)", "def rotate(p):\n    i = p.index(0)\n    return p[i:] + p[:i]\n\ndef swap(p, i1, i2):\n    i1 %= len(p)\n    i2 %= len(p)\n    rv = p.copy()\n    (rv[i1], rv[i2]) = (rv[i2], rv[i1])\n    return rv\n\ndef swaps(p):\n    j = 1\n    while j != len(p) and p[j] == j:\n        j += 1\n    if j == len(p):\n        return [p]\n    i1 = p.index(1)\n    tries = [(j, p.index(j)), (0, i1 - 1), (0, i1), (0, -1), (0, -2), (i1, i1 - 1)]\n    if len(p) > 2:\n        tries.append((i1, p.index(2) - 1))\n    return [rotate(swap(p, j, k)) for (j, k) in tries]\nfor _ in range(int(input())):\n    input()\n    v = [int(x) - 1 for x in input().split()]\n    for x in min((r for q in swaps(rotate(v)) for r in swaps(q))):\n        print(x + 1, end=' ')\n    print()", "def PRLI1(p, end='\\n'):\n    for x in p:\n        print(x + 1, end=' ')\n    print(end=end)\n\ndef LII1():\n    return [int(x) - 1 for x in input().split()]\n\ndef rotate(p):\n    i = p.index(0)\n    return p[i:] + p[:i]\n\ndef swap(p, i1, i2):\n    i1 %= len(p)\n    i2 %= len(p)\n    rv = p.copy()\n    (rv[i1], rv[i2]) = (rv[i2], rv[i1])\n    return rv\n\ndef swaps(p):\n    j = 1\n    while j != len(p) and p[j] == j:\n        j += 1\n    if j == len(p):\n        return [p]\n    try_1 = swap(p, j, p.index(j))\n    try_2 = swap(p, 0, p.index(1) - 1)\n    try_3 = swap(p, 0, p.index(1))\n    try_4 = swap(p, 0, -1)\n    try_5 = swap(p, 0, -2)\n    try_6 = swap(p, p.index(1), p.index(1) - 1)\n    rvs = [try_1, rotate(try_2), rotate(try_3), rotate(try_4), rotate(try_5), rotate(try_6)]\n    if len(p) > 2:\n        rvs.append(rotate(swap(p, p.index(1), p.index(2) - 1)))\n    return rvs\nfor _ in range(int(input())):\n    input()\n    PRLI1(min([r for q in swaps(rotate(LII1())) for r in swaps(q)]))"]