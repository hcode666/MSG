["from sys import stdin, stdout\ninput = stdin.readline\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [0] * n\n\n    def Find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.Find(self.par[x])\n            return self.par[x]\n\n    def Unite(self, x, y):\n        x = self.Find(x)\n        y = self.Find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.par[y] += self.par[x]\n                self.par[x] = y\n            else:\n                self.par[x] += self.par[y]\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n    def Same(self, x, y):\n        return self.Find(x) == self.Find(y)\n\n    def Size(self, x):\n        return -self.par[self.Find(x)]\nfrom bisect import bisect_left as lower_bound\nfrom bisect import bisect_right as upper_bound\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        bit = self.bit = list(x)\n        size = self.size = len(bit)\n        for i in range(size):\n            j = i | i + 1\n            if j < size:\n                bit[j] += bit[i]\n\n    def update(self, idx, x):\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return (idx + 1, k)\n\nclass SortedList:\n    block_size = 700\n\n    def __init__(self, iterable=()):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.fenwick = FenwickTree([0])\n        self.size = 0\n        for item in iterable:\n            self.insert(item)\n\n    def insert(self, x):\n        i = lower_bound(self.macro, x)\n        j = upper_bound(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        if len(self.micros[i]) >= self.block_size:\n            self.micros[i:i + 1] = (self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:])\n            self.micro_size[i:i + 1] = (self.block_size >> 1, self.block_size >> 1)\n            self.fenwick = FenwickTree(self.micro_size)\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=-1):\n        (i, j) = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        return self.micros[i].pop(j)\n\n    def __getitem__(self, k):\n        (i, j) = self._find_kth(k)\n        return self.micros[i][j]\n\n    def count(self, x):\n        return self.upper_bound(x) - self.lower_bound(x)\n\n    def __contains__(self, x):\n        return self.count(x) > 0\n\n    def lower_bound(self, x):\n        i = lower_bound(self.macro, x)\n        return self.fenwick(i) + lower_bound(self.micros[i], x)\n\n    def upper_bound(self, x):\n        i = upper_bound(self.macro, x)\n        return self.fenwick(i) + upper_bound(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.fenwick.find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) - 1 for x in input().split()]\n    ob = UnionFind(n)\n    all = SortedList([a[0]])\n    for i in range(1, n):\n        if not len(all) or all[0] > a[i]:\n            all.insert(a[i])\n            continue\n        ob.Unite(all[0], a[i])\n        while True:\n            if len(all) == 1 or all[1] > a[i]:\n                break\n            ob.Unite(a[i], all.pop(1))\n    if ob.Size(0) == n:\n        print('YES')\n    else:\n        print('NO')", "from sys import stdin, stdout\ninput = stdin.readline\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [0] * n\n\n    def Find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.Find(self.par[x])\n            return self.par[x]\n\n    def Unite(self, x, y):\n        x = self.Find(x)\n        y = self.Find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.par[y] += self.par[x]\n                self.par[x] = y\n            else:\n                self.par[x] += self.par[y]\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n    def Same(self, x, y):\n        return self.Find(x) == self.Find(y)\n\n    def Size(self, x):\n        return -self.par[self.Find(x)]\nfrom bisect import bisect_left as lower_bound\nfrom bisect import bisect_right as upper_bound\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        bit = self.bit = list(x)\n        size = self.size = len(bit)\n        for i in range(size):\n            j = i | i + 1\n            if j < size:\n                bit[j] += bit[i]\n\n    def update(self, idx, x):\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return (idx + 1, k)\n\nclass SortedList:\n    block_size = 700\n\n    def __init__(self, iterable=()):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.fenwick = FenwickTree([0])\n        self.size = 0\n        for item in iterable:\n            self.insert(item)\n\n    def insert(self, x):\n        i = lower_bound(self.macro, x)\n        j = upper_bound(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        if len(self.micros[i]) >= self.block_size:\n            self.micros[i:i + 1] = (self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:])\n            self.micro_size[i:i + 1] = (self.block_size >> 1, self.block_size >> 1)\n            self.fenwick = FenwickTree(self.micro_size)\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=-1):\n        (i, j) = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        return self.micros[i].pop(j)\n\n    def __getitem__(self, k):\n        (i, j) = self._find_kth(k)\n        return self.micros[i][j]\n\n    def count(self, x):\n        return self.upper_bound(x) - self.lower_bound(x)\n\n    def __contains__(self, x):\n        return self.count(x) > 0\n\n    def lower_bound(self, x):\n        i = lower_bound(self.macro, x)\n        return self.fenwick(i) + lower_bound(self.micros[i], x)\n\n    def upper_bound(self, x):\n        i = upper_bound(self.macro, x)\n        return self.fenwick(i) + upper_bound(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.fenwick.find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) - 1 for x in input().split()]\n    ob = UnionFind(n)\n    all = SortedList([a[0]])\n    for i in range(1, n):\n        if not len(all) or all[0] > a[i]:\n            all.insert(a[i])\n            continue\n        ob.Unite(all[0], a[i])\n        while True:\n            if len(all) == 1 or all[1] > a[i]:\n                break\n            ob.Unite(a[i], all.pop(1))\n    if ob.Size(0) == n:\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    st = []\n    m = float('inf')\n    for i in arr:\n        if len(st) == 0 or st[0] >= i:\n            st.append(i)\n            m = min(m, i)\n        elif len(st) > 1:\n            st.clear()\n            st.append(m)\n            m = float('inf')\n    if len(st) != 1:\n        print('NO')\n    else:\n        print('YES')", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    st = []\n    m = float('inf')\n    for i in arr:\n        if len(st) == 0 or st[0] >= i:\n            st.append(i)\n            m = min(m, i)\n        elif len(st) > 1:\n            st.clear()\n            st.append(m)\n            m = float('inf')\n    if len(st) != 1:\n        print('NO')\n    else:\n        print('YES')", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    st = []\n    m = float('inf')\n    for i in arr:\n        if len(st) == 0 or st[0] >= i:\n            st.append(i)\n            m = min(m, i)\n        elif len(st) > 1:\n            st.clear()\n            st.append(m)\n            m = float('inf')\n    if len(st) != 1:\n        print('NO')\n    else:\n        print('YES')", "try:\n    n = int(input())\n\n    def check(arr):\n        maxindex = 0\n        maxi = arr[0]\n        mini = arr[0]\n        for x in range(len(arr)):\n            if arr[x] > maxi:\n                maxi = arr[x]\n                maxindex = x\n        for x in range(len(arr)):\n            if arr[x] < mini and x <= maxindex:\n                mini = arr[x]\n        arr = [mini] + arr[maxindex + 1:]\n        return arr\n    for x in range(n):\n        s = input()\n        s1 = input()\n        l1 = [int(k) for k in s1.split(' ')]\n        result = False\n        while result == False:\n            p = len(l1)\n            if len(l1) == 1:\n                print('YES')\n                result = True\n                break\n            else:\n                l1 = check(l1).copy()\n                if p == len(l1):\n                    result = True\n                    print('NO')\n                    break\n                p = len(l1)\nexcept:\n    print('')", "for _ in range(int(input())):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    stck = []\n    global_min = float('inf')\n    for i in range(n):\n        if len(stck) == 0 or stck[0] >= lst[i]:\n            stck.append(lst[i])\n            global_min = min(lst[i], global_min)\n        elif len(stck) > 1:\n            stck.clear()\n            stck.append(global_min)\n            global_min = float('inf')\n    if len(stck) != 1:\n        print('NO')\n    else:\n        print('YES')", "a = int(input())\nfor i in range(a):\n    n = int(input())\n    L = list(map(int, input().split()))\n    prefix_sum = 0\n    natural_suffix_sum = 0\n    answer = True\n    for i in range(n - 1):\n        prefix_sum += L[i]\n        natural_suffix_sum += n - i\n        if prefix_sum == natural_suffix_sum:\n            answer = False\n    if answer:\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    Max = arr[0]\n    Min = arr[0]\n    for val in arr:\n        if val > Max:\n            Max = Min\n        elif val < Min:\n            Min = val\n    if Max == Min:\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    stck = []\n    global_min = float('inf')\n    for i in range(n):\n        if len(stck) == 0 or stck[0] >= lst[i]:\n            stck.append(lst[i])\n            global_min = min(lst[i], global_min)\n        elif len(stck) > 1:\n            stck.clear()\n            stck.append(global_min)\n            global_min = float('inf')\n    if len(stck) != 1:\n        print('NO')\n    else:\n        print('YES')", "from sys import stdin, stdout\ninput = stdin.readline\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [0] * n\n\n    def Find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.Find(self.par[x])\n            return self.par[x]\n\n    def Unite(self, x, y):\n        x = self.Find(x)\n        y = self.Find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.par[y] += self.par[x]\n                self.par[x] = y\n            else:\n                self.par[x] += self.par[y]\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n    def Same(self, x, y):\n        return self.Find(x) == self.Find(y)\n\n    def Size(self, x):\n        return -self.par[self.Find(x)]\n\nclass SortedList:\n\n    def __init__(self, iterable=[], _load=200):\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return (0, k)\n        if k >= self._len - _list_lens[-1]:\n            return (len(_list_lens) - 1, k + _list_lens[-1] - self._len)\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return (idx + 1, k)\n\n    def _delete(self, pos, idx):\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (lo, pos) = (-1, len(_lists) - 1)\n        while lo + 1 < pos:\n            mi = lo + pos >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def _loc_right(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (pos, hi) = (0, len(_lists))\n        while pos + 1 < hi:\n            mi = pos + hi >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def add(self, value):\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len += 1\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        (pos, idx) = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        (pos, idx) = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        return self._len\n\n    def __getitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        return 'SortedList({0})'.format(list(self))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) - 1 for x in input().split()]\n    ob = UnionFind(n)\n    all = SortedList([a[0]])\n    for i in range(1, n):\n        if not len(all) or all[0] > a[i]:\n            all.add(a[i])\n            continue\n        ob.Unite(all[0], a[i])\n        while True:\n            if len(all) == 1 or all[1] > a[i]:\n                break\n            ob.Unite(a[i], all.pop(1))\n    if ob.Size(0) == n:\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    mn = arr[0]\n    x = arr[0]\n    ptr = 0\n    for i in range(n):\n        if arr[i] <= x:\n            mn = min(mn, arr[i])\n        else:\n            x = mn\n            ptr = i\n    print('YES' if ptr == n - 1 else 'NO')", "import sys\nfrom collections import deque\n\ndef calc(p, lst):\n    stack = deque([])\n    m = sys.maxsize\n    for i in range(p):\n        if not stack:\n            stack.append(lst[i])\n            m = lst[i]\n        elif lst[i] < stack[-1]:\n            stack.append(lst[i])\n        elif lst[i] > m:\n            stack = deque([stack[-1]])\n            m = stack[-1]\n    if len(stack) == 1:\n        print('YES')\n    else:\n        print('NO')\nn = int(input())\nfor i in range(n):\n    p = int(input())\n    lst = list(map(int, input().split()))\n    calc(p, lst)", "import sys\n\ndef calc(p, lst):\n    stack = []\n    m = sys.maxsize\n    for i in range(p):\n        if not stack:\n            stack.append(lst[i])\n            m = lst[i]\n        elif lst[i] < stack[-1]:\n            stack.append(lst[i])\n        elif lst[i] > m:\n            stack = stack[-1:]\n            m = stack[-1]\n    if len(stack) == 1:\n        print('YES')\n    else:\n        print('NO')\nn = int(input())\nfor i in range(n):\n    p = int(input())\n    lst = list(map(int, input().split()))\n    calc(p, lst)", "for i in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    s1 = 0\n    s2 = 0\n    ans = 'YES'\n    for i in range(n - 1):\n        s1 += l[i]\n        s2 += n - i\n        if s1 == s2:\n            ans = 'NO'\n            break\n    print(ans)", "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    done = [False] * (n + 1)\n    upper = n\n    for i in range(1, n + 1):\n        m = 0\n        for j in range(d[i] + 1, upper):\n            done[a[j]] = True\n            m = max(m, a[j])\n        for j in range(m - 1, i, -1):\n            done[j] = True\n        upper = min(upper, d[i])\n    for i in range(2, n + 1):\n        if not done[i]:\n            return 'NO'\n    return 'YES'\nfor T in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = dict()\n    for i in range(n):\n        d[a[i]] = i\n    print(answer())", "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    done = [False] * (n + 1)\n    upper = n\n    for i in range(1, n + 1):\n        m = 0\n        for j in range(d[i] + 1, upper):\n            done[a[j]] = True\n            m = max(m, a[j])\n        for j in range(m - 1, i, -1):\n            done[j] = True\n        upper = min(upper, d[i])\n    for i in range(2, n + 1):\n        if not done[i]:\n            return 'NO'\n    return 'YES'\nfor T in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = dict()\n    for i in range(n):\n        d[a[i]] = i\n    print(answer())", "from collections import deque\n\ndef hello(A):\n    A = [(A[i], i) for i in range(len(A))]\n    maxi = []\n    mmm = 0\n    for (i, j) in A[::-1]:\n        mmm = max(mmm, i)\n        maxi.append(mmm)\n    maxi = maxi[::-1]\n    A = deque(A)\n    while True:\n        if len(A) == 1:\n            return True\n        m = maxi[A[0][1]]\n        mini = 100000000\n        if m == A[0][0]:\n            return False\n        while A and A[0][0] != m:\n            (ele, ind) = A.popleft()\n            mini = min(mini, ele)\n        if len(A) == 1:\n            return True\n        (ele, ind) = A.popleft()\n        maxi[ind] = max(mini, maxi[ind + 1])\n        A.appendleft((mini, ind))\n    return True\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    if hello(A):\n        print('YES')\n    else:\n        print('NO')", "import sys\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom collections import deque\nsys.setrecursionlimit(10 ** 8)\nfrom queue import PriorityQueue as pq\nfrom math import gcd\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nlii = lambda : list(map(int, list(ip())))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\ninv = lambda x: pow(x, mod - 2, mod)\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\nmod = 10 ** 9 + 7\nmod1 = 998244353\nfor _ in range(ii()):\n    n = ii()\n    a = il()\n    if n == 1:\n        print('YES')\n        continue\n    pos = [0 for i in range(n + 1)]\n    fl = 0\n    mn = float('inf')\n    mx = n\n    for i in range(n):\n        if a[i] == mx:\n            pos[a[i]] = 1\n            if a[i] < mn:\n                fl = 1\n                break\n            temp = -1\n            for j in range(n, 0, -1):\n                if pos[j] == 0:\n                    temp = j\n                    break\n            if temp == -1:\n                break\n            else:\n                mx = temp\n                if mx < mn:\n                    fl = 1\n                    break\n        else:\n            mn = min(mn, a[i])\n            pos[a[i]] = 1\n    if fl == 1:\n        print('NO')\n    else:\n        print('YES')", "T = int(input())\nfor i in range(T):\n    N = int(input())\n    P = list(map(int, input().split(' ')))\n    P.reverse()\n    temp_min = P[0]\n    temp_max = P[0]\n    yesval = 'yes'\n    for delta in range(1, N):\n        if temp_min == 1 and temp_max == delta:\n            yesval = 'no'\n            break\n        temp_min = min(temp_min, P[delta])\n        temp_max = max(temp_max, P[delta])\n    if yesval == 'yes':\n        print('YES')\n    else:\n        print('NO')", "def check(a):\n    mi = min(a)\n    ma = max(a)\n    x = a.index(mi)\n    y = a.index(ma)\n    if x < y:\n        return [1]\n    if a[0] == ma or a[-1] == mi:\n        return [0]\n    lmin = 10 ** 9\n    for i in range(y):\n        lmin = min(lmin, a[i])\n    rmax = 0\n    for i in range(len(a) - 1, -1, -1):\n        if a[i] == mi:\n            break\n        rmax = max(rmax, a[i])\n    a = [lmin] + a[y + 1:x] + [rmax]\n    return [2, a]\nt = int(input())\nfor _ in range(t):\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    if a[-1] == n or n == 1 or a[0] == 1:\n        print('YES')\n    elif a[0] == n or a[-1] == 1:\n        print('NO')\n    else:\n        prev = -1\n        while 1:\n            ok = check(a)\n            if ok[0] == 1:\n                fl = 0\n                break\n            elif ok[0] == 0:\n                fl = 1\n                break\n            else:\n                if len(ok[1]) == prev:\n                    fl = 1\n                    break\n                prev = len(ok[1])\n                a = ok[1][:]\n        if fl ^ 1:\n            print('YES')\n        else:\n            print('NO')", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\ngp = []\nans = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\n\ndef flip(a, l, r):\n    for i in range(l, r):\n        a[i] = '0' if a[i] == '1' else '1'\n    return\n\ndef hnbhai(tc):\n    n = sb()\n    a = sd()\n    if n == 1:\n        print('YES')\n        return\n    mn = float('inf')\n    mx = n\n    mark = [0] * (n + 1)\n    for i in range(n):\n        if a[i] == mx:\n            mark[a[i]] = 1\n            if a[i] < mn:\n                print('NO')\n                return\n            ok = -1\n            for j in range(n, 0, -1):\n                if mark[j] == 0:\n                    ok = j\n                    break\n            if ok == -1:\n                break\n            else:\n                mx = ok\n                if mx < mn:\n                    print('NO')\n                    return\n        else:\n            mn = min(mn, a[i])\n            mark[a[i]] = 1\n    print('YES')\n    return\n    return\nfor _ in range(sb()):\n    hnbhai(_ + 1)", "for _ in range(int(input())):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    stck = []\n    global_min = float('inf')\n    for i in range(n):\n        if len(stck) == 0 or stck[0] >= lst[i]:\n            stck.append(lst[i])\n            global_min = min(lst[i], global_min)\n        elif len(stck) > 1:\n            stck.clear()\n            stck.append(global_min)\n            global_min = float('inf')\n    if len(stck) != 1:\n        print('NO')\n    else:\n        print('YES')", "try:\n    n = int(input())\n\n    def check(arr):\n        maxindex = 0\n        maxi = arr[0]\n        mini = arr[0]\n        for x in range(len(arr)):\n            if arr[x] > maxi:\n                maxi = arr[x]\n                maxindex = x\n        for x in range(len(arr)):\n            if arr[x] < mini and x <= maxindex:\n                mini = arr[x]\n        arr = [mini] + arr[maxindex + 1:]\n        return arr\n    for x in range(n):\n        s = input()\n        s1 = input()\n        l1 = [int(k) for k in s1.split(' ')]\n        result = False\n        while result == False:\n            p = len(l1)\n            if len(l1) == 1:\n                print('YES')\n                result = True\n                break\n            else:\n                l1 = check(l1).copy()\n                if p == len(l1):\n                    result = True\n                    print('NO')\n                    break\n                p = len(l1)\nexcept:\n    print('')", "import sys, os, io\ninput = sys.stdin.readline\nfrom collections import defaultdict\nimport bisect\nimport random\nPI = 3.141592653589793\nINF = float('inf')\nMOD = 1000000007\n\ndef bin32(num):\n    return '{0:032b}'.format(num)\n\ndef add(x, y):\n    return (x + y) % MOD\n\ndef sub(x, y):\n    return (x - y + MOD) % MOD\n\ndef mul(x, y):\n    return x * y % MOD\n\ndef gcd(x, y):\n    if y == 0:\n        return x\n    return gcd(y, x % y)\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef power(x, y):\n    res = 1\n    x %= MOD\n    while y != 0:\n        if y & 1:\n            res = mul(res, x)\n        y >>= 1\n        x = mul(x, x)\n    return res\n\ndef mod_inv(n):\n    return power(n, MOD - 2)\n\ndef prob(p, q):\n    return mul(p, power(q, MOD - 2))\n\ndef ii():\n    return int(input())\n\ndef li():\n    return [int(i) for i in input().split()]\n\ndef ls():\n    return [i for i in input().split()]\nfor t in range(ii()):\n    t += 1\n    n = ii()\n    a = li()\n    if n == 1:\n        print('YES')\n        continue\n    if a[-1] == 1 or a[0] == n:\n        print('NO')\n        continue\n    if a.index(n) > a.index(1):\n        print('YES')\n        continue\n    l = INF\n    m = 0\n    indn = a.index(n)\n    ind1 = a.index(1)\n    for i in range(indn):\n        l = min(l, a[i])\n    for i in range(ind1 + 1, n):\n        m = max(m, a[i])\n    if l < m:\n        print('YES')\n    else:\n        x = -1\n        y = -1\n        for i in range(indn + 1, ind1):\n            if a[i] > l:\n                y = i\n            if a[i] < m and x == -1:\n                x = i\n        if x != -1 and y != -1 and (x < y):\n            print('YES')\n        else:\n            print('NO')", "from sys import stdin, stdout\ninput = stdin.readline\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [0] * n\n\n    def Find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.Find(self.par[x])\n            return self.par[x]\n\n    def Unite(self, x, y):\n        x = self.Find(x)\n        y = self.Find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.par[y] += self.par[x]\n                self.par[x] = y\n            else:\n                self.par[x] += self.par[y]\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n    def Same(self, x, y):\n        return self.Find(x) == self.Find(y)\n\n    def Size(self, x):\n        return -self.par[self.Find(x)]\n\nclass SortedList:\n\n    def __init__(self, iterable=[], _load=200):\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return (0, k)\n        if k >= self._len - _list_lens[-1]:\n            return (len(_list_lens) - 1, k + _list_lens[-1] - self._len)\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return (idx + 1, k)\n\n    def _delete(self, pos, idx):\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (lo, pos) = (-1, len(_lists) - 1)\n        while lo + 1 < pos:\n            mi = lo + pos >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def _loc_right(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (pos, hi) = (0, len(_lists))\n        while pos + 1 < hi:\n            mi = pos + hi >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def add(self, value):\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len += 1\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        (pos, idx) = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        (pos, idx) = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        return self._len\n\n    def __getitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        return 'SortedList({0})'.format(list(self))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) - 1 for x in input().split()]\n    ob = UnionFind(n)\n    all = SortedList([a[0]])\n    for i in range(1, n):\n        ind = all.bisect_left(a[i])\n        if ind == 0:\n            all.add(a[i])\n            continue\n        ob.Unite(all[0], a[i])\n        for k in range(ind - 1):\n            x = all.pop(1)\n            ob.Unite(a[i], x)\n    if ob.Size(0) == n:\n        print('YES')\n    else:\n        print('NO')", "import sys\nimport math\nimport random\nimport heapq\ninput = sys.stdin.readline\n\ndef pow(a, n, m):\n    if n == 0:\n        return 1\n    x = pow(a, n // 2, m)\n    if n % 2 == 0:\n        return x * x % m\n    else:\n        return x * x * a % m\n\ndef gcd(a, b):\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef bs(arr, le, ri):\n    l = 0\n    arr.sort()\n    r = len(arr) - 1\n    ans = 10000000\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] >= le and arr[m] <= ri:\n            ans = arr[m]\n            r = m - 1\n        elif arr[m] < le:\n            l = m + 1\n        else:\n            r = m - 1\n    return ans\n\ndef dfs(al, l, p, n, le, pa):\n    l[n] = le\n    p[n] = pa\n    for i in al[n]:\n        if i != pa:\n            dfs(al, l, p, i, le + 1, n)\n\ndef lca(al, l, p, x, y):\n    if l[x] > l[y]:\n        (x, y) = (y, x)\n    d = l[y] - l[x]\n    while d != 0:\n        y = p[y]\n        d -= 1\n    while x != y:\n        x = p[x]\n        y = p[y]\n    return x\n\ndef dfs1(al, i, x, y, vis, p, ans):\n    vis[i] = 1\n    if i == x or i == y:\n        p = 1\n    ans[i] = p\n    for j in al[i]:\n        if vis[j] == 0:\n            dfs1(al, j, x, y, vis, p, ans)\nl = [1] * 100001\nl[0] = 0\nl[1] = 0\nfor i in range(2, 1001):\n    if l[i] == 1:\n        j = i\n        while j * i <= 100000:\n            l[j * i] = 0\n            j += 1\ns = set()\ns.add(1)\ns.add(2)\nls = [1, 2]\nfor i in range(2, 500):\n    for j in range(1, 100001):\n        if j not in s:\n            p = j\n            f = 0\n            for k in range(i):\n                p += ls[-1 - k]\n                if p % (k + 2) == 0:\n                    f = 1\n                    break\n            if f == 0:\n                ls.append(j)\n                s.add(j)\n                break\nt = 1\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    p = list(map(int, input().split()))\n    for i in range(n):\n        ind = -1\n        mi = n + 1\n        for j in range(len(p)):\n            if p[j] < mi:\n                mi = p[j]\n                ind = j\n        ma = max(p[ind:])\n        if ma == mi:\n            break\n        else:\n            p = p[:ind] + [ma]\n    if len(p) == 1:\n        print('YES')\n    else:\n        print('NO')\n    t -= 1"]