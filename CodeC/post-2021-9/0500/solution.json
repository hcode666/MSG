["import sys\nfrom math import gcd\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    v = list(map(int, input().split()))\n\n    def solve(i, p):\n        g[i] = v[i]\n        for j in adj[i]:\n            if j != p:\n                solve(j, i)\n                g[i] = gcd(g[i], g[j])\n    g = [0] * n\n    solve(0, -1)\n\n    def dfs(i, p, gp):\n        d = gp\n        a = []\n        b = []\n        child = []\n        for j in adj[i]:\n            if j != p:\n                d += g[j]\n                a.append(g[j])\n                b.append(g[j])\n                child.append(j)\n        ans[0] = max(ans[0], d)\n        t = len(a)\n        for j in range(1, t):\n            a[j] = gcd(a[j], a[j - 1])\n        for j in reversed(range(t - 1)):\n            b[j] = gcd(b[j], b[j + 1])\n        for k in range(t):\n            ngp = gcd(gp, v[i])\n            if k > 0:\n                ngp = gcd(ngp, a[k - 1])\n            if k < t - 1:\n                ngp = gcd(ngp, b[k + 1])\n            dfs(child[k], i, ngp)\n    ans = [0]\n    dfs(0, -1, 0)\n    print(ans[0])", "import sys\nfrom math import gcd\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    v = list(map(int, input().split()))\n\n    def solve(i, p):\n        g[i] = v[i]\n        for j in adj[i]:\n            if j != p:\n                solve(j, i)\n                g[i] = gcd(g[i], g[j])\n    g = [0] * n\n    solve(0, -1)\n\n    def dfs(i, p, gp):\n        d = gp\n        a = []\n        b = []\n        child = []\n        for j in adj[i]:\n            if j != p:\n                d += g[j]\n                a.append(g[j])\n                b.append(g[j])\n                child.append(j)\n        ans[0] = max(ans[0], d)\n        t = len(a)\n        for j in range(1, t):\n            a[j] = gcd(a[j], a[j - 1])\n        for j in reversed(range(t - 1)):\n            b[j] = gcd(b[j], b[j + 1])\n        for k in range(t):\n            ngp = gcd(gp, v[i])\n            if k > 0:\n                ngp = gcd(ngp, a[k - 1])\n            if k < t - 1:\n                ngp = gcd(ngp, b[k + 1])\n            dfs(child[k], i, ngp)\n    ans = [0]\n    dfs(0, -1, 0)\n    print(ans[0])", "import sys\nfrom math import gcd\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    v = list(map(int, input().split()))\n\n    def solve(i, p):\n        g[i] = v[i]\n        for j in adj[i]:\n            if j != p:\n                solve(j, i)\n                g[i] = gcd(g[i], g[j])\n    g = [0] * n\n    solve(0, -1)\n\n    def dfs(i, p, gp):\n        d = gp\n        a = []\n        b = []\n        child = []\n        for j in adj[i]:\n            if j != p:\n                d += g[j]\n                a.append(g[j])\n                b.append(g[j])\n                child.append(j)\n        ans[0] = max(ans[0], d)\n        t = len(a)\n        for j in range(1, t):\n            a[j] = gcd(a[j], a[j - 1])\n        for j in reversed(range(t - 1)):\n            b[j] = gcd(b[j], b[j + 1])\n        for k in range(t):\n            ngp = gcd(gp, v[i])\n            if k > 0:\n                ngp = gcd(ngp, a[k - 1])\n            if k < t - 1:\n                ngp = gcd(ngp, b[k + 1])\n            dfs(child[k], i, ngp)\n    ans = [0]\n    dfs(0, -1, 0)\n    print(ans[0])", "from math import gcd\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10 ** 7)\nfor i in range(int(input())):\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        x -= 1\n        y -= 1\n        adj[x].append(y)\n        adj[y].append(x)\n    a = list(map(int, input().split()))\n    subgcd = [0] * n\n    vis = [0] * n\n\n    def dfs(src):\n        vis[src] = 1\n        g = a[src]\n        for i in adj[src]:\n            if vis[i] == 0:\n                g = gcd(g, dfs(i))\n        subgcd[src] = g\n        return g\n    dfs(0)\n    vis = [0] * n\n    ans = [0]\n\n    def dfs1(src, parg):\n        cur_ans = parg\n        vis[src] = 1\n        ch = []\n        p = []\n        s = []\n        for i in adj[src]:\n            if vis[i] == 0:\n                ch.append(i)\n                p.append(subgcd[i])\n                s.append(subgcd[i])\n                cur_ans += subgcd[i]\n        l = len(p)\n        for i in range(1, l):\n            p[i] = gcd(p[i - 1], p[i])\n        for i in range(l - 2, -1, -1):\n            s[i] = gcd(s[i + 1], s[i])\n        ans[0] = max(ans[0], cur_ans)\n        for i in range(l):\n            new_parg = a[src]\n            if i > 0:\n                new_parg = gcd(new_parg, p[i - 1])\n            if i < l - 1:\n                new_parg = gcd(new_parg, s[i + 1])\n            new_parg = gcd(new_parg, parg)\n            dfs1(ch[i], new_parg)\n    dfs1(0, 0)\n    print(ans[0])", "import sys\nfrom math import gcd\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    v = list(map(int, input().split()))\n\n    def solve(i, p):\n        g[i] = v[i]\n        for j in adj[i]:\n            if j != p:\n                solve(j, i)\n                g[i] = gcd(g[i], g[j])\n    g = [0] * n\n    solve(0, -1)\n\n    def dfs(i, p, gp):\n        d = gp\n        a = []\n        b = []\n        child = []\n        for j in adj[i]:\n            if j != p:\n                d += g[j]\n                a.append(g[j])\n                b.append(g[j])\n                child.append(j)\n        ans[0] = max(ans[0], d)\n        t = len(a)\n        for j in range(1, t):\n            a[j] = gcd(a[j], a[j - 1])\n        for j in reversed(range(t - 1)):\n            b[j] = gcd(b[j], b[j + 1])\n        for k in range(t):\n            ngp = gcd(gp, v[i])\n            if k > 0:\n                ngp = gcd(ngp, a[k - 1])\n            if k < t - 1:\n                ngp = gcd(ngp, b[k + 1])\n            dfs(child[k], i, ngp)\n    ans = [0]\n    dfs(0, -1, 0)\n    print(ans[0])", "import math\nimport sys\nH = 1000000000 + 7\nsys.setrecursionlimit(10000000)\nfor _ in range(int(input())):\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    v = list(map(int, input().split()))\n\n    def solve(i, p):\n        g[i] = v[i]\n        for j in adj[i]:\n            if j != p:\n                solve(j, i)\n                g[i] = math.gcd(g[i], g[j])\n    g = [0] * n\n    solve(0, -1)\n\n    def dfs(i, p, gp):\n        d = gp\n        a = []\n        b = []\n        child = []\n        for j in adj[i]:\n            if j != p:\n                d += g[j]\n                a.append(g[j])\n                b.append(g[j])\n                child.append(j)\n        ans[0] = max(ans[0], d)\n        t = len(a)\n        for j in range(1, t):\n            a[j] = math.gcd(a[j], a[j - 1])\n        for j in range(t - 2, -1, -1):\n            b[j] = math.gcd(b[j], b[j + 1])\n        for k in range(t):\n            ngp = math.gcd(gp, v[i])\n            if k > 0:\n                ngp = math.gcd(ngp, a[k - 1])\n            if k < t - 1:\n                ngp = math.gcd(ngp, b[k + 1])\n            dfs(child[k], i, ngp)\n    ans = [0]\n    dfs(0, -1, 0)\n    print(ans[0])", "from collections import defaultdict, deque\nfrom math import gcd\nfrom sys import stdin, setrecursionlimit\nsetrecursionlimit(200001)\n\ndef solve():\n    global timer\n    results = []\n    for _ in range(int(stdin.readline().strip())):\n        N = int(stdin.readline().strip())\n        Road = defaultdict(list)\n        Parent = [0] * (N + 1)\n        for _ in range(N - 1):\n            (a, b) = map(int, stdin.readline().strip().split())\n            Road[a].append(b)\n            Road[b].append(a)\n        A = [0] + list(map(int, stdin.readline().strip().split()))\n        euler_tour = []\n        gcd_subtree = [0] * (N + 1)\n        _in = [0] * (N + 1)\n        _out = [0] * (N + 1)\n        timer = 1\n\n        def dfs(G, Parent, A, gcd_subtree, euler_tour, _in, _out, node, p=-1, visited=set()):\n            global timer\n            euler_tour.append(node)\n            visited.add(node)\n            gcd_subtree[node] = A[node]\n            Parent[node] = p\n            _in[node] = timer\n            timer += 1\n            for child in G[node]:\n                if child not in visited:\n                    gcd_subtree[node] = gcd(dfs(G, Parent, A, gcd_subtree, euler_tour, _in, _out, child, node, visited), gcd_subtree[node])\n                    euler_tour.append(node)\n            _out[node] = timer\n            timer += 1\n            return gcd_subtree[node]\n        dfs(Road, Parent, A, gcd_subtree, euler_tour, _in, _out, 1)\n        forward = [0] * (2 * N + 1)\n        backward = [0] * (2 * N + 1)\n        forward[1] = backward[-1] = A[1]\n        for i in range(2, len(euler_tour) + 1):\n            forward[i] = gcd(forward[i - 1], A[euler_tour[i - 1]])\n        for i in range(len(euler_tour) - 1, -1, -1):\n            backward[i] = gcd(backward[i + 1], A[euler_tour[i - 1]])\n        ans = 1\n        for i in list(Road.keys()):\n            children = []\n            for child in Road[i]:\n                if child != Parent[i]:\n                    children.append(gcd_subtree[child])\n            if len(children):\n                temp = sum(children)\n                if i != 1:\n                    temp1 = gcd(forward[_in[i] - 1], backward[_out[i] + 1])\n                    ans = max(ans, temp + temp1)\n                else:\n                    ans = max(ans, temp)\n            else:\n                temp = gcd(forward[_in[i] - 1], backward[_out[i] + 1])\n                ans = max(ans, temp)\n        results.append(ans)\n    print('\\n'.join(map(str, results)))\nsolve()", "import math\nfrom collections import defaultdict\nfrom functools import lru_cache\nimport sys\nsys.setrecursionlimit(1000000)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        (a, b) = [int(i) for i in input().split()]\n        graph[a].append(b)\n        graph[b].append(a)\n    arr = [int(i) for i in input().split()]\n    memo = [0] * (n + 1)\n\n    def helper(node, prev):\n        ans = 0\n        temp = []\n        for ele in graph[node]:\n            if ele == prev:\n                continue\n            temp.append(helper(ele, node))\n        ret = arr[node - 1]\n        for ele in temp:\n            ret = math.gcd(ele, ret)\n        memo[node] = ret\n        return ret\n    helper(1, n + 1)\n    final_ans = []\n\n    def helper2(node, prev, top_gcd):\n        pref = []\n        suff = []\n        for ele in graph[node]:\n            if ele == prev:\n                continue\n            elif len(pref) == 0:\n                pref.append(memo[ele])\n            else:\n                pref.append(memo[ele])\n                pref[-1] = math.gcd(pref[-1], pref[-2])\n        for ele in graph[node][::-1]:\n            if ele == prev:\n                continue\n            elif len(suff) == 0:\n                suff.append(memo[ele])\n            else:\n                suff.append(memo[ele])\n                suff[-1] = math.gcd(suff[-1], suff[-2])\n        suff = suff[::-1]\n        if top_gcd is not None:\n            curr2 = top_gcd\n            start = math.gcd(top_gcd, arr[node - 1])\n        else:\n            curr2 = 0\n            start = arr[node - 1]\n        i = 0\n        for ele in graph[node]:\n            curr = start\n            if ele == prev:\n                continue\n            else:\n                temp1 = i - 1\n                if temp1 >= 0:\n                    curr = math.gcd(curr, pref[temp1])\n                temp1 = i + 1\n                if temp1 < len(pref):\n                    curr = math.gcd(curr, suff[temp1])\n                helper2(ele, node, curr)\n                curr2 += memo[ele]\n                i += 1\n        final_ans.append(curr2)\n        return\n    helper2(1, n + 1, None)\n    print(max(final_ans))", "import math\nfrom heapq import heappush, heappop, heapify\nimport random\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nH = 1000000000 + 7\nsys.setrecursionlimit(10000000)\nfor _ in range(I()):\n    n = I()\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = M()\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    v = L()\n\n    def solve(i, p):\n        g[i] = v[i]\n        for j in adj[i]:\n            if j != p:\n                solve(j, i)\n                g[i] = math.gcd(g[i], g[j])\n    g = [0] * n\n    solve(0, -1)\n\n    def dfs(i, p, gp):\n        d = gp\n        a = []\n        b = []\n        child = []\n        for j in adj[i]:\n            if j != p:\n                d += g[j]\n                a.append(g[j])\n                b.append(g[j])\n                child.append(j)\n        ans[0] = max(ans[0], d)\n        t = len(a)\n        for j in range(1, t):\n            a[j] = math.gcd(a[j], a[j - 1])\n        for j in range(t - 2, -1, -1):\n            b[j] = math.gcd(b[j], b[j + 1])\n        for k in range(t):\n            ngp = math.gcd(gp, v[i])\n            if k > 0:\n                ngp = math.gcd(ngp, a[k - 1])\n            if k < t - 1:\n                ngp = math.gcd(ngp, b[k + 1])\n            dfs(child[k], i, ngp)\n    ans = [0]\n    dfs(0, -1, 0)\n    print(ans[0])", "import math\nfrom heapq import heappush, heappop, heapify\nimport random\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nH = 1000000000 + 7\nsys.setrecursionlimit(10000000)\nfor _ in range(I()):\n    n = I()\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = M()\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    v = L()\n\n    def solve(i, p):\n        g[i] = v[i]\n        for j in adj[i]:\n            if j != p:\n                solve(j, i)\n                g[i] = math.gcd(g[i], g[j])\n    g = [0] * n\n    solve(0, -1)\n\n    def dfs(i, p, gp):\n        d = gp\n        a = []\n        b = []\n        child = []\n        for j in adj[i]:\n            if j != p:\n                d += g[j]\n                a.append(g[j])\n                b.append(g[j])\n                child.append(j)\n        ans[0] = max(ans[0], d)\n        t = len(a)\n        for j in range(1, t):\n            a[j] = math.gcd(a[j], a[j - 1])\n        for j in range(t - 2, -1, -1):\n            b[j] = math.gcd(b[j], b[j + 1])\n        for k in range(t):\n            ngp = math.gcd(gp, v[i])\n            if k > 0:\n                ngp = math.gcd(ngp, a[k - 1])\n            if k < t - 1:\n                ngp = math.gcd(ngp, b[k + 1])\n            dfs(child[k], i, ngp)\n    ans = [0]\n    dfs(0, -1, 0)\n    print(ans[0])", "import math\nfrom heapq import heappush, heappop, heapify\nimport random\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nH = 1000000000 + 7\nsys.setrecursionlimit(10000000)\nfor _ in range(I()):\n    n = I()\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = M()\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    v = L()\n\n    def solve(i, p):\n        g[i] = v[i]\n        for j in adj[i]:\n            if j != p:\n                solve(j, i)\n                g[i] = math.gcd(g[i], g[j])\n    g = [0] * n\n    solve(0, -1)\n\n    def dfs(i, p, gp):\n        d = gp\n        a = []\n        b = []\n        child = []\n        for j in adj[i]:\n            if j != p:\n                d += g[j]\n                a.append(g[j])\n                b.append(g[j])\n                child.append(j)\n        ans[0] = max(ans[0], d)\n        t = len(a)\n        for j in range(1, t):\n            a[j] = math.gcd(a[j], a[j - 1])\n        for j in range(t - 2, -1, -1):\n            b[j] = math.gcd(b[j], b[j + 1])\n        for k in range(t):\n            ngp = math.gcd(gp, v[i])\n            if k > 0:\n                ngp = math.gcd(ngp, a[k - 1])\n            if k < t - 1:\n                ngp = math.gcd(ngp, b[k + 1])\n            dfs(child[k], i, ngp)\n    ans = [0]\n    dfs(0, -1, 0)\n    print(ans[0])", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\nfrom math import gcd\n\ndef dfs(node, parent):\n    cgcd = 0\n    cs = 0\n    for j in d[node]:\n        if j != parent:\n            c = dfs(j, node)\n            cs += c\n            if c != 0:\n                cgcd = gcd(cgcd, c)\n    g[node][1] = [cgcd, cs]\n    if cgcd == 0:\n        cgcd = a[node - 1]\n    else:\n        cgcd = gcd(cgcd, a[node - 1])\n    return cgcd\n\ndef dfs2(node, parent):\n    cgcd = []\n    nodes = []\n    for j in d[node]:\n        if j != parent:\n            nodes.append(j)\n            temp = g[j][1][0]\n            if temp == 0:\n                temp = a[j - 1]\n            else:\n                temp = gcd(temp, a[j - 1])\n            cgcd.append(temp)\n    if len(cgcd):\n        lgcd = [cgcd[0]]\n        for j in range(1, len(cgcd)):\n            lgcd.append(gcd(lgcd[-1], cgcd[j]))\n        rgcd = [cgcd[-1]]\n        for j in range(len(cgcd) - 2, -1, -1):\n            rgcd.append(gcd(rgcd[-1], cgcd[j]))\n        c = 0\n        rgcd.reverse()\n        for j in nodes:\n            ans = gcd(g[node][0], a[node - 1])\n            if c - 1 >= 0:\n                ans = gcd(ans, lgcd[c - 1])\n            if c + 1 < len(rgcd):\n                ans = gcd(ans, rgcd[c + 1])\n            g[j][0] = ans\n            dfs2(j, node)\n            c += 1\nfor i in range(int(input())):\n    d = defaultdict(list)\n    n = int(input())\n    g = [[-1, [0, 0]] for j in range(n + 5)]\n    for j in range(n - 1):\n        (a, b) = map(int, input().split())\n        d[a].append(b)\n        d[b].append(a)\n    a = list(map(int, input().split()))\n    ans = 0\n    dfs(1, -1)\n    g[1][0] = a[0]\n    dfs2(1, 1)\n    g[1][0] = 0\n    for j in range(1, n + 1):\n        ans = max(ans, g[j][0] + g[j][1][1])\n    print(ans)"]