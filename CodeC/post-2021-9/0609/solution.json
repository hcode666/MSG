["import re\nfor _ in range(int(input())):\n    x = y = 0\n    s = input()\n    count0 = count1 = 0\n    for i in s:\n        if i == '1':\n            if count0 > 1:\n                x += 2\n            elif count0 == 1:\n                x += 1\n            count1 += 1\n            count0 = 0\n        else:\n            if count1 > 1:\n                y += 2\n            elif count1 == 1:\n                y += 1\n            count0 += 1\n            count1 = 0\n    if count1 > 1:\n        y += 2\n    elif count1 == 1:\n        y += 1\n    elif count0 > 1:\n        x += 2\n    elif count0 == 1:\n        x += 1\n    flipTrick0 = re.findall('(?=(00(10)+0))', s)\n    x -= len(flipTrick0)\n    flipTrick1 = re.findall('(?=(11(01)+1))', s)\n    y -= len(flipTrick1)\n    print(min(x, y))", "import re\nfor _ in range(int(input())):\n    x = y = 0\n    s = input()\n    count0 = count1 = 0\n    for i in s:\n        if i == '1':\n            if count0 > 1:\n                x += 2\n            elif count0 == 1:\n                x += 1\n            count1 += 1\n            count0 = 0\n        else:\n            if count1 > 1:\n                y += 2\n            elif count1 == 1:\n                y += 1\n            count0 += 1\n            count1 = 0\n    if count1 > 1:\n        y += 2\n    elif count1 == 1:\n        y += 1\n    elif count0 > 1:\n        x += 2\n    elif count0 == 1:\n        x += 1\n    flipTrick0 = re.findall('(?=(00(10)+0))', s)\n    x -= len(flipTrick0)\n    flipTrick1 = re.findall('(?=(11(01)+1))', s)\n    y -= len(flipTrick1)\n    print(min(x, y))", "import re\nfor _ in range(int(input())):\n    x = y = 0\n    s = input()\n    count0 = count1 = 0\n    for i in s:\n        if i == '1':\n            if count0 > 1:\n                x += 2\n            elif count0 == 1:\n                x += 1\n            count1 += 1\n            count0 = 0\n        else:\n            if count1 > 1:\n                y += 2\n            elif count1 == 1:\n                y += 1\n            count0 += 1\n            count1 = 0\n    if count1 > 1:\n        y += 2\n    elif count1 == 1:\n        y += 1\n    elif count0 > 1:\n        x += 2\n    elif count0 == 1:\n        x += 1\n    flipTrick0 = re.findall('(?=(00(10)+0))', s)\n    x -= len(flipTrick0)\n    flipTrick1 = re.findall('(?=(11(01)+1))', s)\n    y -= len(flipTrick1)\n    print(min(x, y))", "import re\nfor _ in range(int(input())):\n    x = y = 0\n    s = input()\n    count0 = count1 = 0\n    for i in s:\n        if i == '1':\n            if count0 > 1:\n                x += 2\n            elif count0 == 1:\n                x += 1\n            count1 += 1\n            count0 = 0\n        else:\n            if count1 > 1:\n                y += 2\n            elif count1 == 1:\n                y += 1\n            count0 += 1\n            count1 = 0\n    if count1 > 1:\n        y += 2\n    elif count1 == 1:\n        y += 1\n    elif count0 > 1:\n        x += 2\n    elif count0 == 1:\n        x += 1\n    flipTrick0 = re.findall('(?=(00(10)+0))', s)\n    x -= len(flipTrick0)\n    flipTrick1 = re.findall('(?=(11(01)+1))', s)\n    y -= len(flipTrick1)\n    print(min(x, y))", "from sys import stdin\nt = int(stdin.readline().rstrip())\nwhile t > 0:\n    s = stdin.readline().rstrip()\n    (v, ans, n) = (0, 0, len(s))\n    i = 0\n    flag1 = flag2 = False\n    while i < n:\n        if s[i] == '0':\n            if not flag1:\n                flag1 = True\n            elif not flag2:\n                flag2 = True\n        elif flag1:\n            if flag2:\n                if i < n - 1:\n                    if s[i + 1] == '0':\n                        ans += 1\n                    else:\n                        ans += 2\n                        flag1 = False\n                        flag2 = False\n                else:\n                    ans += 2\n                    flag1 = False\n                    flag2 = False\n            else:\n                ans += 1\n                flag1 = False\n        i += 1\n    if flag1:\n        if flag2:\n            ans += 2\n        else:\n            ans += 1\n    v = ans\n    ans = 0\n    i = 0\n    flag1 = flag2 = False\n    while i < n:\n        if s[i] == '1':\n            if not flag1:\n                flag1 = True\n            elif not flag2:\n                flag2 = True\n        elif flag1:\n            if flag2:\n                if i < n - 1:\n                    if s[i + 1] == '1':\n                        ans += 1\n                    else:\n                        ans += 2\n                        flag1 = False\n                        flag2 = False\n                else:\n                    ans += 2\n                    flag1 = False\n                    flag2 = False\n            else:\n                ans += 1\n                flag1 = False\n        i += 1\n    if flag1:\n        if flag2:\n            ans += 2\n        else:\n            ans += 1\n    v = min(v, ans)\n    print(v)\n    t -= 1", "def flip(str, val):\n    a = 0\n    b = 0\n    c = 0\n    d = 0\n    for i in range(len(str)):\n        if str[i] == val:\n            c = min(b, c) + 1\n            d = min(b, c)\n            b = a + 1\n            a = a\n        else:\n            c = min(b, c, d + 1)\n            d = min(b, c) + 1\n            b = a\n            a = a + 1\n        a = min(a, b + 1, c + 2, d + 2)\n    return a\nfor i in range(int(input())):\n    str = input()\n    one = flip(str, '1')\n    zero = flip(str, '0')\n    print(min(one, zero))", "from collections import defaultdict\n\ndef flip(s, ch):\n    ans = 0\n    for i in range(2, len(s) - 2):\n        if s[i] == ch and (s[i - 1] != ch and s[i + 1] != ch) and (s[i - 2] != ch or s[i + 2] != ch):\n            s[i] = s[i - 1]\n            ans += 1\n    c = 0\n    for i in range(len(s)):\n        if s[i] != ch:\n            c += 1\n        else:\n            if c == 1:\n                ans += 1\n            elif c > 1:\n                ans += 2\n            c = 0\n    if c == 1:\n        ans += 1\n    if c > 1:\n        ans += 2\n    return ans\nt = int(input())\nfor _ in range(t):\n    s = input()\n    s = list(s)\n    x = [0] * len(s)\n    for i in range(len(s)):\n        x[i] = s[i]\n    print(min(flip(s, '1'), flip(x, '0')))", "import re\nfor _ in range(int(input())):\n    x = y = 0\n    s = input()\n    count0 = count1 = 0\n    for i in s:\n        if i == '1':\n            if count0 > 1:\n                x += 2\n            elif count0 == 1:\n                x += 1\n            count1 += 1\n            count0 = 0\n        else:\n            if count1 > 1:\n                y += 2\n            elif count1 == 1:\n                y += 1\n            count0 += 1\n            count1 = 0\n    if count1 > 1:\n        y += 2\n    elif count1 == 1:\n        y += 1\n    elif count0 > 1:\n        x += 2\n    elif count0 == 1:\n        x += 1\n    flipTrick0 = re.findall('(?=(00(10)+0))', s)\n    x -= len(flipTrick0)\n    flipTrick1 = re.findall('(?=(11(01)+1))', s)\n    y -= len(flipTrick1)\n    print(min(x, y))", "import re\n\ndef calc(bits):\n    zeros = re.findall('(0+)', bits)\n    ones = re.findall('(1+)', bits)\n    count = [0, 0]\n    for zero in zeros:\n        count[0] += 2 if len(zero) > 1 else 1\n    for one in ones:\n        count[1] += 2 if len(one) > 1 else 1\n    flipTrick0 = re.findall('(?=(00(10)+0))', bits)\n    count[0] -= len(flipTrick0)\n    flipTrick1 = re.findall('(?=(11(01)+1))', bits)\n    count[1] -= len(flipTrick1)\n    return min(count[0], count[1])\nfor i in range(int(input())):\n    print(calc(input()))", "def flip(str, val):\n    a = 0\n    b = 0\n    c = 0\n    d = 0\n    for i in range(0, len(str)):\n        if str[i] == val:\n            c = min(b, c) + 1\n            d = min(b, c)\n            b = a + 1\n            a = a\n        else:\n            c = min(b, c, d + 1)\n            d = min(b, c) + 1\n            b = a\n            a = a + 1\n        a = min(a, b + 1, c + 2, d + 2)\n    return a\nt = int(input())\nfor i in range(t):\n    str = input()\n    one = flip(str, '1')\n    zero = flip(str, '0')\n    print(min(one, zero))", "import sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef st():\n    return input().rstrip('\\n')\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\nt = inp()\n\ndef pain(s, n, char):\n    s1 = list(s)\n    res = 0\n    for i in range(n):\n        if s1[i] != char and s1[i] != '#':\n            left = 0\n            right = 0\n            lid = i - 1\n            rid = i + 1\n            while lid >= 0 and s1[lid] == char:\n                left += 1\n                if left > 1:\n                    break\n                lid -= 1\n            while rid < n and s1[rid] == char:\n                right += 1\n                if right > 1:\n                    break\n                rid += 1\n            if left > 1 and right > 1 or (left == 1 and right > 1) or (right == 1 and left > 1):\n                s1[i] = char\n                res += 1\n    co = 0\n    cur = s1[0]\n    for j in range(n):\n        if cur == s1[j]:\n            co += 1\n        else:\n            if cur == char:\n                res += min(2, co)\n            cur = s1[j]\n            co = 1\n    return res\nwhile t:\n    t -= 1\n    s = st()\n    s = s + '#'\n    n = len(s)\n    res = min(pain(s, n, '0'), pain(s, n, '1'))\n    res = min(s.count('0'), s.count('1'), res)\n    ll = []\n    co = 0\n    cur = s[0]\n    for i in s:\n        if i == cur:\n            co += 1\n        else:\n            ll.append(co)\n            co = 1\n            cur = i\n    x = 0\n    y = 0\n    for i in range(len(ll)):\n        if i % 2:\n            x += min(ll[i], 2)\n        else:\n            y += min(ll[i], 2)\n    res = min(res, x, y)\n    print(res)", "import sys\n\nclass Node:\n    __slots__ = ('bit', 'multi', 'l', 'r')\n\n    def __init__(self, bit, multi, l=None, r=None):\n        (self.bit, self.multi, self.l, self.r) = (bit, multi, l, r)\n\n    def __repr__(self):\n        return f'Node({self.bit}, multi={self.multi})'\n\ndef display_list(head, reverse=False):\n    ptr = head\n    while ptr:\n        print(f'{ptr} -> ', end='')\n        ptr = ptr.l if reverse else ptr.r\n    print('')\n\ndef delete_node(n):\n    if n.l:\n        n.l.r = n.r\n    if n.r:\n        n.r.l = n.l\n    del n\n\ndef count_flips(s):\n    n = len(s)\n    last = None\n    for c in s:\n        bit = int(int(c))\n        if last is None:\n            last = Node(bit, False)\n        elif bit != last.bit:\n            new_node = Node(bit, False)\n            new_node.l = last\n            last.r = new_node\n            last = new_node\n        else:\n            last.multi = True\n    if not last.l:\n        return 0\n    if not last.l.l:\n        if last.multi and last.l.multi:\n            return 2\n        else:\n            return 1\n    ops = 0\n    head = last.l\n    while head.l:\n        if head.r and (not head.multi):\n            ops += 1\n            head = head.l\n            head.multi = True\n            delete_node(head.r)\n            delete_node(head.r)\n        else:\n            head = head.l\n    if not head.r:\n        return ops\n    if not head.r.r:\n        if head.multi and head.r.multi:\n            return ops + 2\n        else:\n            return ops + 1\n    ptr = head.r\n    while ptr.r:\n        if ptr.l and ptr.l.multi:\n            ops += 2\n            ptr = ptr.r\n            ptr.multi = True\n            delete_node(ptr.l)\n            delete_node(ptr.l)\n        else:\n            ptr = ptr.r\n    if not ptr.l:\n        return ops\n    if not ptr.l.l:\n        if ptr.multi and ptr.l.multi:\n            return ops + 2\n        else:\n            return ops + 1\n    return ops + 2\nt = int(sys.stdin.readline())\nfor t_itr in range(t):\n    s = sys.stdin.readline().strip()\n    res = min(count_flips(s), count_flips(s[::-1]))\n    sys.stdout.write(str(res) + '\\n')", "t = int(input())\nfor _ in range(t):\n    s = input()\n    l1 = len(s)\n    list_of_ones = []\n    end1 = 0\n    end2 = 0\n    count = 0\n    cost = 0\n    if l1 > 1:\n        for i in range(l1):\n            if i == l1 - 1 or s[i] != s[i + 1]:\n                count += 1\n            if i == 0 and s[i] != s[i + 1]:\n                end1 += 1\n            elif i == l1 - 1 and s[i] != s[i - 1]:\n                end2 += 1\n            elif s[i] != s[i - 1] and s[i] != s[i + 1]:\n                list_of_ones.append(count)\n    l2 = len(list_of_ones)\n    count_end1 = 0\n    i1 = 0\n    while i1 <= l2 - 1:\n        if list_of_ones[i1] - i1 != 2:\n            break\n        count_end1 += 1\n        i1 += 1\n    if count_end1 % 2 == 1:\n        end1 = 0\n    count_end2 = 0\n    j = -1\n    while j >= -l2:\n        if list_of_ones[j] - j != count:\n            break\n        count_end2 += 1\n        j -= 1\n    if count_end2 % 2 == 1:\n        end2 = 0\n    counter = 0\n    if l2 == 1:\n        count -= 2\n        cost += 1\n    else:\n        for i in range(l2):\n            if i == 0 and list_of_ones[i + 1] - list_of_ones[i] != 1 or (i == l2 - 1 and list_of_ones[i] - list_of_ones[i - 1] != 1) or (list_of_ones[i] - list_of_ones[i - 1] != 1 and list_of_ones[i + 1] - list_of_ones[i] != 1):\n                cost += 1\n                count -= 2\n            if i != l2 - 1 and list_of_ones[i + 1] - list_of_ones[i] == 1:\n                cost += 0.5\n                count -= 1\n                counter += 1\n            elif list_of_ones[i] - list_of_ones[i - 1] == 1 and i == l2 - 1 or (i != 0 and list_of_ones[i] - list_of_ones[i - 1] == 1 and (list_of_ones[i + 1] - list_of_ones[i] != 1)):\n                counter += 1\n                if counter % 2 == 0:\n                    cost += 0.5\n                    count -= 1\n                    counter = 0\n                else:\n                    cost += 1\n                    count -= 2\n                    counter = 0\n    ends = end1 + end2\n    if count % 2 == 1:\n        cost += count - 1\n    elif ends == 0:\n        cost += count\n    else:\n        cost += count - 1\n    print(int(cost))", "def solve(X):\n    X.append(-1337)\n    S = [-1337, X[0]]\n    ret = 0\n    i = 1\n    while i < len(X) - 1:\n        if X[i] == 1 and S[-1] > 1:\n            if X[i + 1] != -1337:\n                S[-1] = 9\n                ret += 1\n                i += 2\n            else:\n                S.append(1)\n                i += 1\n        elif X[i] == 1 and S[-1] == 1:\n            S.append(1)\n            i += 1\n        elif X[i] > 1 and S[-1] == 1:\n            while S[-1] == 1 and S[-2] != -1337:\n                S.pop()\n                S.pop()\n                ret += 1\n            S.append(9)\n            i += 1\n        elif X[i] > 1 and S[-1] > 1:\n            S.append(X[i])\n            i += 1\n    S.pop(0)\n    if len(S) % 2 == 0 and S[0] == 1:\n        S.pop(0)\n        S[0] += 1\n        ret += 1\n    elif len(S) % 2 == 0 and S[-1] == 1:\n        S.pop()\n        S[-1] += 1\n        ret += 1\n    if len(S) == 3:\n        return ret + 2\n    if S.count(1) == len(S):\n        return ret + len(S) // 2\n    ret += 2 * (len(S) // 2)\n    return ret\n\ndef convert(S):\n    S += '#'\n    i = 0\n    ret = []\n    for j in range(1, len(S)):\n        if S[j] != S[i]:\n            ret.append(j - i)\n            i = j\n    return ret\nfor _ in range(int(input())):\n    S = input()\n    print(min(solve(convert(S)), S.count('1'), S.count('0')))", "for _ in range(int(input())):\n    s = input()\n    (v, ans, n) = (0, 0, len(s))\n    i = 0\n    flag = flag2 = False\n    while i < n:\n        if s[i] == '0':\n            if not flag:\n                flag = True\n            elif not flag2:\n                flag2 = True\n        elif flag:\n            if flag2:\n                if i < n - 1:\n                    if s[i + 1] == '0':\n                        ans += 1\n                    else:\n                        ans += 2\n                        flag = False\n                        flag2 = False\n                else:\n                    ans += 2\n                    flag = False\n                    flag2 = False\n            else:\n                ans += 1\n                flag = False\n        i += 1\n    if flag:\n        if flag2:\n            ans += 2\n        else:\n            ans += 1\n    v = ans\n    ans = 0\n    i = 0\n    flag = flag2 = False\n    while i < n:\n        if s[i] == '1':\n            if not flag:\n                flag = True\n            elif not flag2:\n                flag2 = True\n        elif flag:\n            if flag2:\n                if i < n - 1:\n                    if s[i + 1] == '1':\n                        ans += 1\n                    else:\n                        ans += 2\n                        flag = False\n                        flag2 = False\n                else:\n                    ans += 2\n                    flag = False\n                    flag2 = False\n            else:\n                ans += 1\n                flag = False\n        i += 1\n    if flag:\n        if flag2:\n            ans += 2\n        else:\n            ans += 1\n    v = min(v, ans)\n    print(v)", "t = int(input())\nwhile t:\n    t = t - 1\n    string = input()\n    count = 1\n    modStr = string\n    change = 1\n    ops = 0\n    (s0, s1, d0, d1) = (0, 0, 0, 0)\n    while change:\n        backup = modStr\n        ops += modStr.count('1101')\n        modStr = modStr.replace('1101', '1111')\n        ops += modStr.count('1011')\n        modStr = modStr.replace('1011', '1111')\n        change = backup != modStr\n    lastSeen = modStr[0]\n    for i in range(1, len(string)):\n        if modStr[i] == lastSeen:\n            count += 1\n        else:\n            if count > 1:\n                if lastSeen == '0':\n                    d0 += 1\n                else:\n                    d1 += 1\n                count = 1\n            else:\n                if lastSeen == '0':\n                    s0 += 1\n                else:\n                    s1 += 1\n                count = 1\n            lastSeen = modStr[i]\n    if count > 1:\n        if lastSeen == '0':\n            d0 += 1\n        else:\n            d1 += 1\n    elif lastSeen == '0':\n        s0 += 1\n    else:\n        s1 += 1\n    ops1 = ops + min(s0 + d0 * 2, s1 + d1 * 2)\n    count = 1\n    modStr = string\n    change = 1\n    ops = 0\n    (s0, s1, d0, d1) = (0, 0, 0, 0)\n    while change:\n        backup = modStr\n        ops += modStr.count('0010')\n        modStr = modStr.replace('0010', '0000')\n        ops += modStr.count('0100')\n        modStr = modStr.replace('0100', '0000')\n        change = backup != modStr\n    lastSeen = modStr[0]\n    for i in range(1, len(string)):\n        if modStr[i] == lastSeen:\n            count += 1\n        else:\n            if count > 1:\n                if lastSeen == '0':\n                    d0 += 1\n                else:\n                    d1 += 1\n                count = 1\n            else:\n                if lastSeen == '0':\n                    s0 += 1\n                else:\n                    s1 += 1\n                count = 1\n            lastSeen = modStr[i]\n    if count > 1:\n        if lastSeen == '0':\n            d0 += 1\n        else:\n            d1 += 1\n    elif lastSeen == '0':\n        s0 += 1\n    else:\n        s1 += 1\n    ops2 = ops + min(s0 + d0 * 2, s1 + d1 * 2)\n    print(min(ops1, ops2))", "T = int(input())\nfor _ in range(T):\n    st = input()\n    str0_1 = st\n    str1_0 = st\n    flag0_1 = True\n    flag1_0 = True\n    count0_1 = 0\n    count1_0 = 0\n    (s00, s10, d00, d10) = (0, 0, 0, 0)\n    (s01, s11, d01, d11) = (0, 0, 0, 0)\n    (s0, d0, s1, d1) = (0, 0, 0, 0)\n    flag = 0\n    flag1 = 0\n    flag2 = 0\n    if len(st) == 1:\n        print(0)\n        continue\n    while flag0_1:\n        if '1101' in str0_1 or '1011' in str0_1:\n            if '1101' in str0_1:\n                count0_1 += str0_1.count('1101')\n                str0_1 = str0_1.replace('1101', '1111')\n            else:\n                count0_1 += str0_1.count('1011')\n                str0_1 = str0_1.replace('1011', '1111')\n        else:\n            flag0_1 = False\n    while flag1_0:\n        if '0010' in str1_0 or '0100' in str1_0:\n            if '0010' in str1_0:\n                count1_0 += str1_0.count('0010')\n                str1_0 = str1_0.replace('0010', '0000')\n            else:\n                count1_0 += str1_0.count('0100')\n                str1_0 = str1_0.replace('0100', '0000')\n        else:\n            flag1_0 = False\n    for i in range(1, len(str0_1)):\n        if str0_1[i] == str0_1[i - 1]:\n            flag2 = 1\n        elif str0_1[i - 1] == '0' and flag2 == 0:\n            s00 += 1\n            flag2 = 0\n        elif str0_1[i - 1] == '0' and flag2 == 1:\n            d00 += 1\n            flag2 = 0\n        elif str0_1[i - 1] == '1' and flag2 == 0:\n            s10 += 1\n            flag2 = 0\n        elif str0_1[i - 1] == '1' and flag2 == 1:\n            d10 += 1\n            flag2 = 0\n    if str0_1[-1] == str0_1[-2]:\n        if str0_1[-1] == '0':\n            d00 += 1\n        else:\n            d10 += 1\n    elif str0_1[-1] == '0':\n        s00 += 1\n    else:\n        s10 += 1\n    for i in range(1, len(str1_0)):\n        if str1_0[i] == str1_0[i - 1]:\n            flag1 = 1\n        elif str1_0[i - 1] == '0' and flag1 == 0:\n            s01 += 1\n            flag1 = 0\n        elif str1_0[i - 1] == '0' and flag1 == 1:\n            d01 += 1\n            flag1 = 0\n        elif str1_0[i - 1] == '1' and flag1 == 0:\n            s11 += 1\n            flag1 = 0\n        elif str1_0[i - 1] == '1' and flag1 == 1:\n            d11 += 1\n            flag1 = 0\n    if str1_0[-1] == str1_0[-2]:\n        if str1_0[-1] == '0':\n            d01 += 1\n        else:\n            d11 += 1\n    elif str1_0[-1] == '0':\n        s01 += 1\n    else:\n        s11 += 1\n    to_0_0 = count0_1 + s00 + 2 * d00\n    to_1_0 = count0_1 + s10 + 2 * d10\n    to_0_1 = count1_0 + s01 + 2 * d01\n    to_1_1 = count1_0 + s11 + 2 * d11\n    print(min(to_0_0, to_1_0, to_0_1, to_1_1))", "def readInt():\n    return int(input())\n\ndef readInts():\n    return [int(x) for x in input().split()]\n\ndef readString():\n    return input().rstrip()\n\ndef readStrings():\n    return input().split()\n\ndef printList(l):\n    return ' '.join((str(x) for x in l))\n\ndef readCase():\n    bin_string = readString()\n    return bin_string\n\ndef solve_target(bin_string, target, other):\n    blocks = bin_string.count(other + target) + bin_string.startswith(target)\n    (pos, large_blocks) = (0, 0)\n    while True:\n        pos = bin_string.find(2 * target, pos)\n        if pos == -1:\n            break\n        pos = bin_string.find(2 * other, pos)\n        large_blocks += 1\n        if pos == -1:\n            break\n    return blocks + large_blocks\n\ndef solve(bin_string):\n    return min(solve_target(bin_string, '0', '1'), solve_target(bin_string, '1', '0'))\ncases = readInt()\nfor case in range(cases):\n    print(solve(readCase()))", "import sys\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom collections import deque\nsys.setrecursionlimit(10 ** 8)\nfrom queue import PriorityQueue as pq\nfrom math import gcd\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nlii = lambda : list(map(int, list(ip())))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\ninv = lambda x: pow(x, mod - 2, mod)\nmod = 10 ** 9 + 7\nmod1 = 998244353\nfor _ in range(ii()):\n    s = list(ip())\n    ans = float('inf')\n    for j in range(2):\n        b = []\n        c = []\n        b.append(s[0])\n        c.append(1)\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                c[-1] += 1\n            else:\n                b.append(s[i])\n                c.append(1)\n        tot = 0\n        for i in range(len(b)):\n            if b[i] == '1':\n                continue\n            elif i == 0:\n                continue\n            elif c[i] > 1:\n                continue\n            elif i == len(b) - 1:\n                continue\n            else:\n                t = c[i - 1] + c[i + 1]\n                if t == 2:\n                    continue\n                else:\n                    tot += 1\n                    c[i + 1] = t + 1\n                    c[i - 1] = 0\n                    b[i - 1] = '0'\n        for i in range(len(b)):\n            if b[i] == '1':\n                if c[i] == 1:\n                    tot += 1\n                else:\n                    tot += 2\n        ans = min(ans, tot)\n        for i in range(len(s)):\n            if s[i] == '1':\n                s[i] = '0'\n            else:\n                s[i] = '1'\n    print(ans)", "from sys import stdin\ninput = stdin.readline\n\ndef flipsemideepsingles(S):\n    count = 0\n    for i in range(2, len(S) - 1):\n        if S[i - 2] == S[i - 1] and S[i - 1] != S[i] and (S[i] != S[i + 1]):\n            count += 1\n            S[i] = S[i - 1]\n    for i in reversed(range(1, len(S) - 2)):\n        if S[i - 1] != S[i] and S[i] != S[i + 1] and (S[i + 1] == S[i + 2]):\n            count += 1\n            S[i] = S[i + 1]\n    return (S, count)\n\ndef flipsingle(S, flip):\n    count = 0\n    for i in range(1, len(S) - 1):\n        if S[i] == flip and S[i - 1] != S[i] and (S[i] != S[i + 1]):\n            count += 1\n            S[i] = S[i - 1]\n    return (S, count)\n\ndef compressflip(S, flip):\n    if S[0] == flip:\n        first = [0]\n    else:\n        first = []\n    for i in range(1, len(S)):\n        if S[i] == flip and S[i] != S[i - 1]:\n            first.append(i)\n    last = []\n    for i in range(len(S) - 1):\n        if S[i] == flip and S[i] != S[i + 1]:\n            last.append(i)\n    if S[len(S) - 1] == flip:\n        last.append(len(S) - 1)\n    count = 0\n    for (a, b) in zip(first, last):\n        if a == b:\n            count += 1\n        else:\n            count += 2\n    return count\n\ndef solve(S):\n    (S, count) = flipsemideepsingles([int(s) for s in S])\n    (S0, count0) = (list(S), count)\n    (S1, count1) = (list(S), count)\n    (S0, count) = flipsingle(S0, 0)\n    count0 += count\n    count = compressflip(S0, 0)\n    count0 += count\n    (S1, count) = flipsingle(S1, 1)\n    count1 += count\n    count = compressflip(S1, 1)\n    count1 += count\n    return min(count0, count1)\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    S = input().strip()\n    print(solve(S))", "from sys import stdin\ninput = stdin.readline\n\ndef flipdeepsingles(S):\n    count = 0\n    for i in range(2, len(S) - 2):\n        if S[i - 2] == S[i - 1] and S[i - 1] != S[i] and (S[i] != S[i + 1]) and (S[i + 1] == S[i + 2]):\n            count += 1\n            S[i] = S[i - 1]\n    return (S, count)\n\ndef flipsemideepsingles(S):\n    count = 0\n    for i in range(2, len(S) - 1):\n        if S[i - 2] == S[i - 1] and S[i - 1] != S[i] and (S[i] != S[i + 1]):\n            count += 1\n            S[i] = S[i - 1]\n    for i in reversed(range(1, len(S) - 2)):\n        if S[i - 1] != S[i] and S[i] != S[i + 1] and (S[i + 1] == S[i + 2]):\n            count += 1\n            S[i] = S[i + 1]\n    return (S, count)\n\ndef flipsingle(S, flip):\n    count = 0\n    for i in range(1, len(S) - 1):\n        if S[i] == flip and S[i - 1] != S[i] and (S[i] != S[i + 1]):\n            count += 1\n            S[i] = S[i - 1]\n    return (S, count)\n\ndef compressflip(S, flip):\n    if S[0] == flip:\n        first = [0]\n    else:\n        first = []\n    for i in range(1, len(S)):\n        if S[i] == flip and S[i] != S[i - 1]:\n            first.append(i)\n    last = []\n    for i in range(len(S) - 1):\n        if S[i] == flip and S[i] != S[i + 1]:\n            last.append(i)\n    if S[len(S) - 1] == flip:\n        last.append(len(S) - 1)\n    count = 0\n    for (a, b) in zip(first, last):\n        if a == b:\n            count += 1\n        else:\n            count += 2\n    return count\n\ndef solve(S):\n    (S, count) = flipsemideepsingles([int(s) for s in S])\n    (S0, count0) = (list(S), count)\n    (S1, count1) = (list(S), count)\n    (S0, count) = flipsingle(S0, 0)\n    count0 += count\n    count = compressflip(S0, 0)\n    count0 += count\n    (S1, count) = flipsingle(S1, 1)\n    count1 += count\n    count = compressflip(S1, 1)\n    count1 += count\n    return min(count0, count1)\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    S = input().strip()\n    print(solve(S))", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\nx = 0\npref = []\nlvl = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\nprime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\ndef func(a):\n    stck = []\n    last = 1\n    c = 0\n    for i in a:\n        if i == '0':\n            if c != 0:\n                stck.append(c)\n            stck.append(0)\n            c = 0\n        else:\n            c += 1\n    if c != 0:\n        stck.append(c)\n    tot = []\n    for i in range(len(stck)):\n        if stck[i] == 0:\n            continue\n        if len(tot) > 0 and i - 2 >= 0 and (stck[i - 2] != 0):\n            if stck[i] == 1:\n                if tot[-1][0] > 1:\n                    tot[-1][0] += stck[i]\n                    tot[-1][1] += 1\n                else:\n                    tot.append([stck[i], 0])\n            else:\n                tot[-1][0] += stck[i]\n                tot[-1][1] += 1\n        else:\n            tot.append([stck[i], 0])\n    ans = 0\n    for (i, j) in tot:\n        ans += 1 + (i > 1) + j\n    return ans\n\ndef hnbhai(tc):\n    a = sa()\n    b = []\n    for i in a:\n        if i == '0':\n            b.append('1')\n        else:\n            b.append('0')\n    print(min(func(a), func(b)))\nfor _ in range(sb()):\n    hnbhai(_ + 1)", "def solve():\n    org = input()\n    make0 = [[float('inf'), float('inf'), float('inf')] for i in range(len(org) + 1)]\n    make1 = [[float('inf'), float('inf'), float('inf')] for i in range(len(org) + 1)]\n    make0[0][0] = 0\n    make1[0][0] = 0\n    for i in range(1, len(org) + 1):\n        if org[i - 1] == '0':\n            make0[i][0] = min(make0[i - 1][0], make0[i - 1][1] + 1, make0[i - 1][2] + 2)\n            make0[i][1] = min(make0[i - 1][0], make0[i - 1][2] + 2) + 1\n            make0[i][2] = min(make0[i - 1][2], make0[i - 1][1]) + 1\n            make1[i][0] = min(make1[i - 1][0] + 1, make1[i - 1][1] + 2, make1[i - 1][2] + 2)\n            make1[i][1] = min(make1[i - 1][0], make1[i - 1][2] + 2)\n            make1[i][2] = min(make1[i - 1][2], make1[i - 1][1])\n        else:\n            make0[i][0] = min(make0[i - 1][0] + 1, make0[i - 1][1] + 2, make0[i - 1][2] + 2)\n            make0[i][1] = min(make0[i - 1][0], make0[i - 1][2] + 2)\n            make0[i][2] = min(make0[i - 1][2], make0[i - 1][1])\n            make1[i][0] = min(make1[i - 1][0], make1[i - 1][1] + 1, make1[i - 1][2] + 2)\n            make1[i][1] = min(make1[i - 1][0], make1[i - 1][2] + 2) + 1\n            make1[i][2] = min(make1[i - 1][2], make1[i - 1][1]) + 1\n    return min(make0[len(org)][0], make1[len(org)][0])\nremaiend_test_cases = 1\nremaiend_test_cases = int(input())\nwhile remaiend_test_cases > 0:\n    print(solve())\n    remaiend_test_cases -= 1", "def cnt(s, one):\n    c1p = 0\n    c1p0 = 0\n    c1p00p = 0\n    c1p0p1 = 0\n    for i in range(0, len(s)):\n        if s[i] == one:\n            c1p00p = min(c1p0, c1p00p) + 1\n            c1p0p1 = min(c1p0, c1p00p)\n            c1p0 = c1p + 1\n            c1p = c1p\n        else:\n            c1p00p = min(c1p0, c1p00p, c1p0p1 + 1)\n            c1p0p1 = min(c1p0, c1p00p) + 1\n            c1p0 = c1p\n            c1p = c1p + 1\n        c1p = min(c1p, c1p0 + 1, c1p00p + 2, c1p0p1 + 2)\n    return c1p\nN = int(input())\nfor i in range(N):\n    s = input()\n    one = cnt(s, '1')\n    zero = cnt(s, '0')\n    print(min(one, zero))", "import re\nimport sys\nfrom functools import reduce\nfrom collections import deque\nimport random\nfrom heapq import heappop, heappush\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nprintf = lambda x: sys.stdout.write(str(x))\n\ndef seqtotuple(s):\n    arr = [1]\n    p = 0\n    for i in range(1, len(s)):\n        if s[i] != s[p]:\n            p = i\n            arr.append(0)\n        arr[-1] += 1\n    return tuple(arr)\n\ndef getcont(s):\n    arr = []\n    c = 0\n    for i in range(1, len(s) - 1):\n        if s[i] == 1:\n            c += 1\n        if s[i] != 1 and c > 0:\n            arr.append(c)\n            c = 0\n    if c:\n        arr.append(c)\n    return arr\n\ndef smart(s):\n    if len(s) == 1:\n        return 0\n    if len(s) == 2:\n        return 1 if s[0] == 1 or s[1] == 1 else 2\n    arr = []\n    arr = getcont(s)\n    t = sum([e // 2 + e % 2 for e in arr])\n    k = len(s) - 2 * t\n    return t + k - k % 2 - ((s[0] == 1 and s[1] != 1 or (s[0] == s[1] == 1 and arr[0] % 2 == 0) or (s[-1] == s[-2] == 1 and arr[-1] % 2 == 0) or (s[-1] == 1 and s[-2] != 1)) and k % 2 == 0)\nt = int(input())\nfor _ in range(t):\n    s = input().strip()\n    seq = seqtotuple(s)\n    printf(smart(seq))\n    printf('\\n')", "from sys import stdin\n\ndef get_answer(S):\n    if len(S) == 1:\n        return 0\n    ones = [0, 0]\n    zeros = [0, 0]\n    (prev, old_prev) = (S[0], -1)\n    (cnt, old_cnt) = (1, 0)\n    ext = 0\n    for x in S[1:]:\n        if x == prev:\n            cnt += 1\n            continue\n        if cnt == 1 and old_cnt > 0:\n            if old_prev == '1':\n                ones[0] -= 1\n                if old_cnt > 1:\n                    ones[1] -= 1\n            if old_prev == '0':\n                zeros[0] -= 1\n                if old_cnt > 1:\n                    zeros[1] -= 1\n            prev = old_prev\n            cnt = old_cnt + 1\n            ext += 1\n            continue\n        if prev == '1':\n            ones[0] += 1\n            if cnt > 1:\n                ones[1] += 1\n            (old_prev, prev) = (prev, x)\n            (old_cnt, cnt) = (cnt, 1)\n        elif prev == '0':\n            zeros[0] += 1\n            if cnt > 1:\n                zeros[1] += 1\n            (old_prev, prev) = (prev, x)\n            (old_cnt, cnt) = (cnt, 1)\n        else:\n            prev = x\n            cnt = 1\n    if prev == '1':\n        ones[0] += 1\n        if cnt > 1:\n            ones[1] += 1\n        prev = x\n        cnt = 1\n    else:\n        zeros[0] += 1\n        if cnt > 1:\n            zeros[1] += 1\n        prev = x\n        cnt = 1\n    return min(sum(ones), sum(zeros)) + ext\n\ndef solve():\n    results = []\n    for _ in range(int(stdin.readline().rstrip())):\n        S = stdin.readline().rstrip()\n        results.append(min(get_answer(S), get_answer(S[::-1])))\n    print('\\n'.join(map(str, results)))\nsolve()", "for _ in range(int(input())):\n    s = input()\n    h = []\n    i = 0\n    while i < len(s):\n        if s[i] == '0' and i + 1 < len(s) and (s[i + 1] == '0'):\n            h.append('a')\n            while i < len(s) and s[i] == '0':\n                i += 1\n            continue\n        elif s[i] == '0' and (i + 1 < len(s) and s[i + 1] == '1' or i + 1 >= len(s)):\n            h.append('d')\n            i += 1\n            continue\n        elif s[i] == '1' and i + 1 < len(s) and (s[i + 1] == '1'):\n            h.append('c')\n            while i < len(s) and s[i] == '1':\n                i += 1\n            continue\n        else:\n            h.append('b')\n            i += 1\n            continue\n    c1 = 0\n    i = 0\n    while i < len(h):\n        if h[i] == 'a':\n            if i + 2 < len(h) and h[i + 1] == 'b' and (h[i + 2] == 'a' or h[i + 2] == 'd'):\n                c1 += 2\n                while i + 2 < len(h) and h[i + 1] == 'b' and (h[i + 2] == 'a' or h[i + 2] == 'd'):\n                    c1 += 1\n                    i += 2\n                i += 1\n            else:\n                c1 += 2\n                i += 1\n        elif h[i] == 'd':\n            c1 += 1\n            i += 1\n        else:\n            i += 1\n    c0 = 0\n    i = 0\n    while i < len(h):\n        if h[i] == 'c':\n            if i + 2 < len(h) and h[i + 1] == 'd' and (h[i + 2] == 'c' or h[i + 2] == 'b'):\n                c0 += 2\n                while i + 2 < len(h) and h[i + 1] == 'd' and (h[i + 2] == 'c' or h[i + 2] == 'b'):\n                    c0 += 1\n                    i += 2\n                i += 1\n            else:\n                c0 += 2\n                i += 1\n        elif h[i] == 'b':\n            c0 += 1\n            i += 1\n        else:\n            i += 1\n    print(min(c0, c1))", "def fun(s):\n    n = len(s)\n    s = ['k'] + s + ['k']\n    i = 1\n    ans = 0\n    while i < n + 1:\n        if s[i] == '0':\n            if s[i - 1] != '0' and s[i + 1] != '0':\n                ans += 1\n            else:\n                while s[i] == '0':\n                    i += 1\n                c = 0\n                if i == n + 1:\n                    ans += 2\n                    break\n                while s[i] == '1':\n                    i += 1\n                    c += 1\n                if i == n + 1:\n                    ans += 2\n                    break\n                if c == 1:\n                    s[i - 1] = '0'\n                    ans += 1\n                    i -= 2\n                else:\n                    ans += 2\n                    i -= 1\n        i += 1\n    return ans\n\ndef f1(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] == '1':\n            s[i] = '0'\n        else:\n            s[i] = '1'\n    return fun(s)\nt = int(input())\nwhile t > 0:\n    t -= 1\n    s = [i for i in input()]\n    x = fun(s)\n    y = f1(s)\n    print(min(x, y))", "def _find_consecutive_one_intervals(s):\n    s = s + '0'\n    windows = []\n    (l, r) = (0, 0)\n    for (r, rc) in enumerate(s):\n        if rc == '1':\n            continue\n        while r > l and s[l] == '0':\n            l += 1\n        if l == r:\n            continue\n        windows.append((l, r))\n        l = r\n    return windows\n\ndef all_zeros(s):\n    if s.count('0') == len(s):\n        return 0\n    if s.count('1') == len(s):\n        return min(len(s), 2)\n    windows = _find_consecutive_one_intervals(s)\n    res = 0\n    consecutive_windows = [[windows[0]]]\n    for (left, right) in windows[1:]:\n        cur_window = (left, right)\n        (prev_left, prev_right) = consecutive_windows[-1][-1]\n        if left - prev_right == 1:\n            consecutive_windows[-1].append(cur_window)\n        else:\n            consecutive_windows.append([cur_window])\n    res = 0\n    for cons_windo in consecutive_windows:\n        if all((r - l == 1 for (l, r) in cons_windo)):\n            res += len(cons_windo)\n        else:\n            res += len(cons_windo) + 1\n    return res\nnum_tests = int(input())\nfor _ in range(num_tests):\n    s = input()\n    zeros = all_zeros(s)\n    ones = all_zeros(s.replace('0', '2').replace('1', '0').replace('2', '1'))\n    print(min(zeros, ones))", "import sys\nimport re\n\ndef calc(bits):\n    zeros = re.findall('(0+)', bits)\n    ones = re.findall('(1+)', bits)\n    count = [0, 0]\n    for zero in zeros:\n        count[0] += 2 if len(zero) > 1 else 1\n    for one in ones:\n        count[1] += 2 if len(one) > 1 else 1\n    flipTrick0 = re.findall('(?=(00(10)+0))', bits)\n    count[0] -= len(flipTrick0)\n    flipTrick1 = re.findall('(?=(11(01)+1))', bits)\n    count[1] -= len(flipTrick1)\n    return min(count[0], count[1])\nfirstInput = True\nfor line in sys.stdin:\n    if firstInput:\n        firstInput = False\n        continue\n    numbers = line.split('\\n')[0]\n    print(str(calc(numbers)))"]