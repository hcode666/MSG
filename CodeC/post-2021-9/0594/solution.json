["from collections import deque\nfrom enum import Enum, auto\n\nclass RedBlackTree:\n\n    class Colour(Enum):\n        RED = auto()\n        BLACK = auto()\n\n    class Node:\n\n        def __init__(self, key):\n            self.parent = None\n            self.left = None\n            self.right = None\n            self.colour = RedBlackTree.Colour.RED\n            self.key = key\n\n        @property\n        def grandparent(self):\n            return self.parent and self.parent.parent\n\n        @property\n        def sibling(self):\n            p = self.parent\n            return p and (p.right if p.left == self else p.left)\n\n        @property\n        def uncle(self):\n            p = self.parent\n            return p and p.sibling\n\n        def has_red_child(self):\n            return self.left and self.left.colour == RedBlackTree.Colour.RED or (self.right and self.right.colour == RedBlackTree.Colour.RED)\n\n        def is_on_left(self):\n            return self.parent.left == self\n\n        def find(self, v):\n            if self.key == v:\n                return self\n            child = self.left if self.key > v else self.right\n            return child and child.find(v)\n\n        def far_left(self):\n            if self.left:\n                return self.left.far_left()\n            else:\n                return self\n\n        def far_right(self):\n            if self.right:\n                return self.right.far_right()\n            else:\n                return self\n\n        def next(self):\n            if self.right:\n                return self.right.far_left()\n            n = self\n            p = n.parent\n            while p:\n                if n == p.left:\n                    return p\n                n = p\n                p = n.parent\n            return None\n\n        def prev(self):\n            if self.left:\n                return self.left.far_right()\n            n = self\n            p = n.parent\n            while p:\n                if n == p.right:\n                    return p\n                n = p\n                p = n.parent\n            return None\n\n        def __str__(self):\n            return str(self.key) + ' ' + str(self.colour)\n\n    def __init__(self):\n        self.root = None\n        self.len = 0\n\n    @staticmethod\n    def is_red(node):\n        return node and node.colour == RedBlackTree.Colour.RED\n\n    def rotate_left(self, n):\n        nnew = n.right\n        p = n.parent\n        n.right = nnew.left\n        nnew.left = n\n        n.parent = nnew\n        if n.right:\n            n.right.parent = n\n        if p:\n            if n == p.left:\n                p.left = nnew\n            elif n == p.right:\n                p.right = nnew\n        else:\n            self.root = nnew\n        nnew.parent = p\n\n    def rotate_right(self, n):\n        nnew = n.left\n        p = n.parent\n        n.left = nnew.right\n        nnew.right = n\n        n.parent = nnew\n        if n.left:\n            n.left.parent = n\n        if p:\n            if n == p.left:\n                p.left = nnew\n            elif n == p.right:\n                p.right = nnew\n        else:\n            self.root = nnew\n        nnew.parent = p\n\n    def insert(self, k):\n        n = self.Node(k)\n\n        def insert_recurse(root):\n            if root and n.key < root.key:\n                if root.left:\n                    insert_recurse(root.left)\n                    return\n                else:\n                    root.left = n\n            elif root:\n                if root.right:\n                    insert_recurse(root.right)\n                    return\n                else:\n                    root.right = n\n            n.parent = root\n\n        def repair_insert(n):\n            if not n.parent:\n                n.colour = RedBlackTree.Colour.BLACK\n            elif n.parent.colour == RedBlackTree.Colour.BLACK:\n                return\n            elif n.uncle and n.uncle.colour == RedBlackTree.Colour.RED:\n                n.parent.colour = RedBlackTree.Colour.BLACK\n                n.uncle.colour = RedBlackTree.Colour.BLACK\n                n.grandparent.colour = RedBlackTree.Colour.RED\n                repair_insert(n.grandparent)\n            else:\n                p = n.parent\n                g = n.grandparent\n                if n == p.right and p == g.left:\n                    self.rotate_left(p)\n                    n = n.left\n                elif n == p.left and p == g.right:\n                    self.rotate_right(p)\n                    n = n.right\n                p = n.parent\n                g = n.grandparent\n                if n == p.left:\n                    self.rotate_right(g)\n                else:\n                    self.rotate_left(g)\n                p.colour = RedBlackTree.Colour.BLACK\n                g.colour = RedBlackTree.Colour.RED\n        insert_recurse(self.root)\n        repair_insert(n)\n        self.root = n\n        while self.root.parent:\n            self.root = self.root.parent\n        self.len += 1\n\n    def remove(self, v):\n\n        def fix_double_black(n):\n            if n == self.root:\n                return\n            p = n.parent\n            s = n.sibling\n            if not s:\n                fix_double_black(n.parent)\n                return\n            if s.colour == RedBlackTree.Colour.RED:\n                p.colour = RedBlackTree.Colour.RED\n                s.colour = RedBlackTree.Colour.BLACK\n                if p.left == n:\n                    self.rotate_left(p)\n                else:\n                    self.rotate_right(p)\n                fix_double_black(n)\n            elif s.has_red_child():\n                if self.is_red(s.left):\n                    if s.is_on_left():\n                        s.left.colour = s.colour\n                        s.colour = p.colour\n                        self.rotate_right(p)\n                    else:\n                        s.left.colour = p.colour\n                        self.rotate_right(s)\n                        self.rotate_left(p)\n                elif s.is_on_left():\n                    s.right.colour = p.colour\n                    self.rotate_left(s)\n                    self.rotate_right(p)\n                else:\n                    s.right.colour = s.colour\n                    s.colour = p.colour\n                    self.rotate_left(p)\n                p.colour = RedBlackTree.Colour.BLACK\n            else:\n                s.colour = RedBlackTree.Colour.RED\n                if p.colour == RedBlackTree.Colour.BLACK:\n                    fix_double_black(p)\n                else:\n                    p.colour = RedBlackTree.Colour.BLACK\n\n        def delete(n):\n            child = n.left or n.right\n            if not (self.is_red(n) or self.is_red(child)):\n                fix_double_black(n)\n            if child:\n                child.parent = n.parent\n                child.colour = RedBlackTree.Colour.BLACK\n            if not n.parent:\n                self.root = child\n            elif n.is_on_left():\n                n.parent.left = child\n            else:\n                n.parent.right = child\n        n = self.root.find(v)\n        if n.right and n.left:\n            m = n.right.far_left()\n            n.key = m.key\n            n = m\n        delete(n)\n        self.len -= 1\n\n    def find(self, v):\n        return self.root and self.root.find(v)\n\n    def __iter__(self):\n        if not self.root:\n            return None\n        n = self.root.far_left()\n        while n:\n            yield n.key\n            n = n.next()\n\n    def __len__(self):\n        return self.len\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        edges = [[int(a) for a in input().split()] for _ in range(n - 1)]\n        aa = [0] + [int(a) for a in input().split()]\n        res = solve(n, edges, aa)\n        print(' '.join(map(str, res)))\nINF = 10000000000000000\n\ndef solve(n, edges, aa):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    parent = [0] * (n + 1)\n    dl = []\n    q = deque([1])\n    while q:\n        v = q.popleft()\n        for w in adj[v]:\n            if w != parent[v]:\n                dl.append(w)\n                parent[w] = v\n                q.append(w)\n    dl.reverse()\n    res = [INF] * (n + 1)\n    values = [RedBlackTree() for _ in range(n + 1)]\n    for (i, a) in enumerate(aa):\n        values[i].insert(a)\n    for u in dl:\n        res[parent[u]] = min(res[parent[u]], res[u])\n        if len(values[u]) > len(values[parent[u]]):\n            (values[u], values[parent[u]]) = (values[parent[u]], values[u])\n        for v in values[u]:\n            values[parent[u]].insert(v)\n            vn = values[parent[u]].find(v)\n            pn = vn.prev()\n            if pn:\n                res[parent[u]] = min(res[parent[u]], pn.key ^ v)\n            nn = vn.next()\n            if nn:\n                res[parent[u]] = min(res[parent[u]], nn.key ^ v)\n    return [-1 if r == INF else r for r in res[1:]]\nmain()", "from collections import deque\nfrom enum import Enum, auto\n\nclass RedBlackTree:\n\n    class Colour(Enum):\n        RED = auto()\n        BLACK = auto()\n\n    class Node:\n\n        def __init__(self, key):\n            self.parent = None\n            self.left = None\n            self.right = None\n            self.colour = RedBlackTree.Colour.RED\n            self.key = key\n\n        @property\n        def grandparent(self):\n            return self.parent and self.parent.parent\n\n        @property\n        def sibling(self):\n            p = self.parent\n            return p and (p.right if p.left == self else p.left)\n\n        @property\n        def uncle(self):\n            p = self.parent\n            return p and p.sibling\n\n        def has_red_child(self):\n            return self.left and self.left.colour == RedBlackTree.Colour.RED or (self.right and self.right.colour == RedBlackTree.Colour.RED)\n\n        def is_on_left(self):\n            return self.parent.left == self\n\n        def find(self, v):\n            if self.key == v:\n                return self\n            child = self.left if self.key > v else self.right\n            return child and child.find(v)\n\n        def far_left(self):\n            if self.left:\n                return self.left.far_left()\n            else:\n                return self\n\n        def far_right(self):\n            if self.right:\n                return self.right.far_right()\n            else:\n                return self\n\n        def next(self):\n            if self.right:\n                return self.right.far_left()\n            n = self\n            p = n.parent\n            while p:\n                if n == p.left:\n                    return p\n                n = p\n                p = n.parent\n            return None\n\n        def prev(self):\n            if self.left:\n                return self.left.far_right()\n            n = self\n            p = n.parent\n            while p:\n                if n == p.right:\n                    return p\n                n = p\n                p = n.parent\n            return None\n\n        def __str__(self):\n            return str(self.key) + ' ' + str(self.colour)\n\n    def __init__(self):\n        self.root = None\n        self.len = 0\n\n    @staticmethod\n    def is_red(node):\n        return node and node.colour == RedBlackTree.Colour.RED\n\n    def rotate_left(self, n):\n        nnew = n.right\n        p = n.parent\n        n.right = nnew.left\n        nnew.left = n\n        n.parent = nnew\n        if n.right:\n            n.right.parent = n\n        if p:\n            if n == p.left:\n                p.left = nnew\n            elif n == p.right:\n                p.right = nnew\n        else:\n            self.root = nnew\n        nnew.parent = p\n\n    def rotate_right(self, n):\n        nnew = n.left\n        p = n.parent\n        n.left = nnew.right\n        nnew.right = n\n        n.parent = nnew\n        if n.left:\n            n.left.parent = n\n        if p:\n            if n == p.left:\n                p.left = nnew\n            elif n == p.right:\n                p.right = nnew\n        else:\n            self.root = nnew\n        nnew.parent = p\n\n    def insert(self, k):\n        n = self.Node(k)\n\n        def insert_recurse(root):\n            if root and n.key < root.key:\n                if root.left:\n                    insert_recurse(root.left)\n                    return\n                else:\n                    root.left = n\n            elif root:\n                if root.right:\n                    insert_recurse(root.right)\n                    return\n                else:\n                    root.right = n\n            n.parent = root\n\n        def repair_insert(n):\n            if not n.parent:\n                n.colour = RedBlackTree.Colour.BLACK\n            elif n.parent.colour == RedBlackTree.Colour.BLACK:\n                return\n            elif n.uncle and n.uncle.colour == RedBlackTree.Colour.RED:\n                n.parent.colour = RedBlackTree.Colour.BLACK\n                n.uncle.colour = RedBlackTree.Colour.BLACK\n                n.grandparent.colour = RedBlackTree.Colour.RED\n                repair_insert(n.grandparent)\n            else:\n                p = n.parent\n                g = n.grandparent\n                if n == p.right and p == g.left:\n                    self.rotate_left(p)\n                    n = n.left\n                elif n == p.left and p == g.right:\n                    self.rotate_right(p)\n                    n = n.right\n                p = n.parent\n                g = n.grandparent\n                if n == p.left:\n                    self.rotate_right(g)\n                else:\n                    self.rotate_left(g)\n                p.colour = RedBlackTree.Colour.BLACK\n                g.colour = RedBlackTree.Colour.RED\n        insert_recurse(self.root)\n        repair_insert(n)\n        self.root = n\n        while self.root.parent:\n            self.root = self.root.parent\n        self.len += 1\n\n    def remove(self, v):\n\n        def fix_double_black(n):\n            if n == self.root:\n                return\n            p = n.parent\n            s = n.sibling\n            if not s:\n                fix_double_black(n.parent)\n                return\n            if s.colour == RedBlackTree.Colour.RED:\n                p.colour = RedBlackTree.Colour.RED\n                s.colour = RedBlackTree.Colour.BLACK\n                if p.left == n:\n                    self.rotate_left(p)\n                else:\n                    self.rotate_right(p)\n                fix_double_black(n)\n            elif s.has_red_child():\n                if self.is_red(s.left):\n                    if s.is_on_left():\n                        s.left.colour = s.colour\n                        s.colour = p.colour\n                        self.rotate_right(p)\n                    else:\n                        s.left.colour = p.colour\n                        self.rotate_right(s)\n                        self.rotate_left(p)\n                elif s.is_on_left():\n                    s.right.colour = p.colour\n                    self.rotate_left(s)\n                    self.rotate_right(p)\n                else:\n                    s.right.colour = s.colour\n                    s.colour = p.colour\n                    self.rotate_left(p)\n                p.colour = RedBlackTree.Colour.BLACK\n            else:\n                s.colour = RedBlackTree.Colour.RED\n                if p.colour == RedBlackTree.Colour.BLACK:\n                    fix_double_black(p)\n                else:\n                    p.colour = RedBlackTree.Colour.BLACK\n\n        def delete(n):\n            child = n.left or n.right\n            if not (self.is_red(n) or self.is_red(child)):\n                fix_double_black(n)\n            if child:\n                child.parent = n.parent\n                child.colour = RedBlackTree.Colour.BLACK\n            if not n.parent:\n                self.root = child\n            elif n.is_on_left():\n                n.parent.left = child\n            else:\n                n.parent.right = child\n        n = self.root.find(v)\n        if n.right and n.left:\n            m = n.right.far_left()\n            n.key = m.key\n            n = m\n        delete(n)\n        self.len -= 1\n\n    def find(self, v):\n        return self.root and self.root.find(v)\n\n    def __iter__(self):\n        if not self.root:\n            return None\n        n = self.root.far_left()\n        while n:\n            yield n.key\n            n = n.next()\n\n    def __len__(self):\n        return self.len\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        edges = [[int(a) for a in input().split()] for _ in range(n - 1)]\n        aa = [0] + [int(a) for a in input().split()]\n        res = solve(n, edges, aa)\n        print(' '.join(map(str, res)))\nINF = 10000000000000000\n\ndef solve(n, edges, aa):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    parent = [0] * (n + 1)\n    dl = []\n    q = deque([1])\n    while q:\n        v = q.popleft()\n        for w in adj[v]:\n            if w != parent[v]:\n                dl.append(w)\n                parent[w] = v\n                q.append(w)\n    dl.reverse()\n    res = [INF] * (n + 1)\n    values = [RedBlackTree() for _ in range(n + 1)]\n    for (i, a) in enumerate(aa):\n        values[i].insert(a)\n    for u in dl:\n        res[parent[u]] = min(res[parent[u]], res[u])\n        if len(values[u]) > len(values[parent[u]]):\n            (values[u], values[parent[u]]) = (values[parent[u]], values[u])\n        for v in values[u]:\n            values[parent[u]].insert(v)\n            vn = values[parent[u]].find(v)\n            pn = vn.prev()\n            if pn:\n                res[parent[u]] = min(res[parent[u]], pn.key ^ v)\n            nn = vn.next()\n            if nn:\n                res[parent[u]] = min(res[parent[u]], nn.key ^ v)\n    return [-1 if r == INF else r for r in res[1:]]\nmain()", "from collections import deque\nfrom enum import Enum, auto\n\nclass RedBlackTree:\n\n    class Colour(Enum):\n        RED = auto()\n        BLACK = auto()\n\n    class Node:\n\n        def __init__(self, key):\n            self.parent = None\n            self.left = None\n            self.right = None\n            self.colour = RedBlackTree.Colour.RED\n            self.key = key\n\n        @property\n        def grandparent(self):\n            return self.parent and self.parent.parent\n\n        @property\n        def sibling(self):\n            p = self.parent\n            return p and (p.right if p.left == self else p.left)\n\n        @property\n        def uncle(self):\n            p = self.parent\n            return p and p.sibling\n\n        def has_red_child(self):\n            return self.left and self.left.colour == RedBlackTree.Colour.RED or (self.right and self.right.colour == RedBlackTree.Colour.RED)\n\n        def is_on_left(self):\n            return self.parent.left == self\n\n        def find(self, v):\n            if self.key == v:\n                return self\n            child = self.left if self.key > v else self.right\n            return child and child.find(v)\n\n        def far_left(self):\n            if self.left:\n                return self.left.far_left()\n            else:\n                return self\n\n        def far_right(self):\n            if self.right:\n                return self.right.far_right()\n            else:\n                return self\n\n        def next(self):\n            if self.right:\n                return self.right.far_left()\n            n = self\n            p = n.parent\n            while p:\n                if n == p.left:\n                    return p\n                n = p\n                p = n.parent\n            return None\n\n        def prev(self):\n            if self.left:\n                return self.left.far_right()\n            n = self\n            p = n.parent\n            while p:\n                if n == p.right:\n                    return p\n                n = p\n                p = n.parent\n            return None\n\n        def __str__(self):\n            return str(self.key) + ' ' + str(self.colour)\n\n    def __init__(self):\n        self.root = None\n        self.len = 0\n\n    @staticmethod\n    def is_red(node):\n        return node and node.colour == RedBlackTree.Colour.RED\n\n    def rotate_left(self, n):\n        nnew = n.right\n        p = n.parent\n        n.right = nnew.left\n        nnew.left = n\n        n.parent = nnew\n        if n.right:\n            n.right.parent = n\n        if p:\n            if n == p.left:\n                p.left = nnew\n            elif n == p.right:\n                p.right = nnew\n        else:\n            self.root = nnew\n        nnew.parent = p\n\n    def rotate_right(self, n):\n        nnew = n.left\n        p = n.parent\n        n.left = nnew.right\n        nnew.right = n\n        n.parent = nnew\n        if n.left:\n            n.left.parent = n\n        if p:\n            if n == p.left:\n                p.left = nnew\n            elif n == p.right:\n                p.right = nnew\n        else:\n            self.root = nnew\n        nnew.parent = p\n\n    def insert(self, k):\n        n = self.Node(k)\n\n        def insert_recurse(root):\n            if root and n.key < root.key:\n                if root.left:\n                    insert_recurse(root.left)\n                    return\n                else:\n                    root.left = n\n            elif root:\n                if root.right:\n                    insert_recurse(root.right)\n                    return\n                else:\n                    root.right = n\n            n.parent = root\n\n        def repair_insert(n):\n            if not n.parent:\n                n.colour = RedBlackTree.Colour.BLACK\n            elif n.parent.colour == RedBlackTree.Colour.BLACK:\n                return\n            elif n.uncle and n.uncle.colour == RedBlackTree.Colour.RED:\n                n.parent.colour = RedBlackTree.Colour.BLACK\n                n.uncle.colour = RedBlackTree.Colour.BLACK\n                n.grandparent.colour = RedBlackTree.Colour.RED\n                repair_insert(n.grandparent)\n            else:\n                p = n.parent\n                g = n.grandparent\n                if n == p.right and p == g.left:\n                    self.rotate_left(p)\n                    n = n.left\n                elif n == p.left and p == g.right:\n                    self.rotate_right(p)\n                    n = n.right\n                p = n.parent\n                g = n.grandparent\n                if n == p.left:\n                    self.rotate_right(g)\n                else:\n                    self.rotate_left(g)\n                p.colour = RedBlackTree.Colour.BLACK\n                g.colour = RedBlackTree.Colour.RED\n        insert_recurse(self.root)\n        repair_insert(n)\n        self.root = n\n        while self.root.parent:\n            self.root = self.root.parent\n        self.len += 1\n\n    def remove(self, v):\n\n        def fix_double_black(n):\n            if n == self.root:\n                return\n            p = n.parent\n            s = n.sibling\n            if not s:\n                fix_double_black(n.parent)\n                return\n            if s.colour == RedBlackTree.Colour.RED:\n                p.colour = RedBlackTree.Colour.RED\n                s.colour = RedBlackTree.Colour.BLACK\n                if p.left == n:\n                    self.rotate_left(p)\n                else:\n                    self.rotate_right(p)\n                fix_double_black(n)\n            elif s.has_red_child():\n                if self.is_red(s.left):\n                    if s.is_on_left():\n                        s.left.colour = s.colour\n                        s.colour = p.colour\n                        self.rotate_right(p)\n                    else:\n                        s.left.colour = p.colour\n                        self.rotate_right(s)\n                        self.rotate_left(p)\n                elif s.is_on_left():\n                    s.right.colour = p.colour\n                    self.rotate_left(s)\n                    self.rotate_right(p)\n                else:\n                    s.right.colour = s.colour\n                    s.colour = p.colour\n                    self.rotate_left(p)\n                p.colour = RedBlackTree.Colour.BLACK\n            else:\n                s.colour = RedBlackTree.Colour.RED\n                if p.colour == RedBlackTree.Colour.BLACK:\n                    fix_double_black(p)\n                else:\n                    p.colour = RedBlackTree.Colour.BLACK\n\n        def delete(n):\n            child = n.left or n.right\n            if not (self.is_red(n) or self.is_red(child)):\n                fix_double_black(n)\n            if child:\n                child.parent = n.parent\n                child.colour = RedBlackTree.Colour.BLACK\n            if not n.parent:\n                self.root = child\n            elif n.is_on_left():\n                n.parent.left = child\n            else:\n                n.parent.right = child\n        n = self.root.find(v)\n        if n.right and n.left:\n            m = n.right.far_left()\n            n.key = m.key\n            n = m\n        delete(n)\n        self.len -= 1\n\n    def find(self, v):\n        return self.root and self.root.find(v)\n\n    def __iter__(self):\n        if not self.root:\n            return None\n        n = self.root.far_left()\n        while n:\n            yield n.key\n            n = n.next()\n\n    def __len__(self):\n        return self.len\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        edges = [[int(a) for a in input().split()] for _ in range(n - 1)]\n        aa = [0] + [int(a) for a in input().split()]\n        res = solve(n, edges, aa)\n        print(' '.join(map(str, res)))\nINF = 10000000000000000\n\ndef solve(n, edges, aa):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    parent = [0] * (n + 1)\n    dl = []\n    q = deque([1])\n    while q:\n        v = q.popleft()\n        for w in adj[v]:\n            if w != parent[v]:\n                dl.append(w)\n                parent[w] = v\n                q.append(w)\n    dl.reverse()\n    res = [INF] * (n + 1)\n    values = [RedBlackTree() for _ in range(n + 1)]\n    for (i, a) in enumerate(aa):\n        values[i].insert(a)\n    for u in dl:\n        res[parent[u]] = min(res[parent[u]], res[u])\n        if len(values[u]) > len(values[parent[u]]):\n            (values[u], values[parent[u]]) = (values[parent[u]], values[u])\n        for v in values[u]:\n            values[parent[u]].insert(v)\n            vn = values[parent[u]].find(v)\n            pn = vn.prev()\n            if pn:\n                res[parent[u]] = min(res[parent[u]], pn.key ^ v)\n            nn = vn.next()\n            if nn:\n                res[parent[u]] = min(res[parent[u]], nn.key ^ v)\n    return [-1 if r == INF else r for r in res[1:]]\nmain()", "from collections import deque\nfrom enum import Enum, auto\n\nclass RedBlackTree:\n\n    class Colour(Enum):\n        RED = auto()\n        BLACK = auto()\n\n    class Node:\n\n        def __init__(self, key):\n            self.parent = None\n            self.left = None\n            self.right = None\n            self.colour = RedBlackTree.Colour.RED\n            self.key = key\n\n        @property\n        def grandparent(self):\n            return self.parent and self.parent.parent\n\n        @property\n        def sibling(self):\n            p = self.parent\n            return p and (p.right if p.left == self else p.left)\n\n        @property\n        def uncle(self):\n            p = self.parent\n            return p and p.sibling\n\n        def has_red_child(self):\n            return self.left and self.left.colour == RedBlackTree.Colour.RED or (self.right and self.right.colour == RedBlackTree.Colour.RED)\n\n        def is_on_left(self):\n            return self.parent.left == self\n\n        def find(self, v):\n            if self.key == v:\n                return self\n            child = self.left if self.key > v else self.right\n            return child and child.find(v)\n\n        def far_left(self):\n            if self.left:\n                return self.left.far_left()\n            else:\n                return self\n\n        def far_right(self):\n            if self.right:\n                return self.right.far_right()\n            else:\n                return self\n\n        def next(self):\n            if self.right:\n                return self.right.far_left()\n            n = self\n            p = n.parent\n            while p:\n                if n == p.left:\n                    return p\n                n = p\n                p = n.parent\n            return None\n\n        def prev(self):\n            if self.left:\n                return self.left.far_right()\n            n = self\n            p = n.parent\n            while p:\n                if n == p.right:\n                    return p\n                n = p\n                p = n.parent\n            return None\n\n        def __str__(self):\n            return str(self.key) + ' ' + str(self.colour)\n\n    def __init__(self):\n        self.root = None\n        self.len = 0\n\n    @staticmethod\n    def is_red(node):\n        return node and node.colour == RedBlackTree.Colour.RED\n\n    def rotate_left(self, n):\n        nnew = n.right\n        p = n.parent\n        n.right = nnew.left\n        nnew.left = n\n        n.parent = nnew\n        if n.right:\n            n.right.parent = n\n        if p:\n            if n == p.left:\n                p.left = nnew\n            elif n == p.right:\n                p.right = nnew\n        else:\n            self.root = nnew\n        nnew.parent = p\n\n    def rotate_right(self, n):\n        nnew = n.left\n        p = n.parent\n        n.left = nnew.right\n        nnew.right = n\n        n.parent = nnew\n        if n.left:\n            n.left.parent = n\n        if p:\n            if n == p.left:\n                p.left = nnew\n            elif n == p.right:\n                p.right = nnew\n        else:\n            self.root = nnew\n        nnew.parent = p\n\n    def insert(self, k):\n        n = self.Node(k)\n\n        def insert_recurse(root):\n            if root and n.key < root.key:\n                if root.left:\n                    insert_recurse(root.left)\n                    return\n                else:\n                    root.left = n\n            elif root:\n                if root.right:\n                    insert_recurse(root.right)\n                    return\n                else:\n                    root.right = n\n            n.parent = root\n\n        def repair_insert(n):\n            if not n.parent:\n                n.colour = RedBlackTree.Colour.BLACK\n            elif n.parent.colour == RedBlackTree.Colour.BLACK:\n                return\n            elif n.uncle and n.uncle.colour == RedBlackTree.Colour.RED:\n                n.parent.colour = RedBlackTree.Colour.BLACK\n                n.uncle.colour = RedBlackTree.Colour.BLACK\n                n.grandparent.colour = RedBlackTree.Colour.RED\n                repair_insert(n.grandparent)\n            else:\n                p = n.parent\n                g = n.grandparent\n                if n == p.right and p == g.left:\n                    self.rotate_left(p)\n                    n = n.left\n                elif n == p.left and p == g.right:\n                    self.rotate_right(p)\n                    n = n.right\n                p = n.parent\n                g = n.grandparent\n                if n == p.left:\n                    self.rotate_right(g)\n                else:\n                    self.rotate_left(g)\n                p.colour = RedBlackTree.Colour.BLACK\n                g.colour = RedBlackTree.Colour.RED\n        insert_recurse(self.root)\n        repair_insert(n)\n        self.root = n\n        while self.root.parent:\n            self.root = self.root.parent\n        self.len += 1\n\n    def remove(self, v):\n\n        def fix_double_black(n):\n            if n == self.root:\n                return\n            p = n.parent\n            s = n.sibling\n            if not s:\n                fix_double_black(n.parent)\n                return\n            if s.colour == RedBlackTree.Colour.RED:\n                p.colour = RedBlackTree.Colour.RED\n                s.colour = RedBlackTree.Colour.BLACK\n                if p.left == n:\n                    self.rotate_left(p)\n                else:\n                    self.rotate_right(p)\n                fix_double_black(n)\n            elif s.has_red_child():\n                if self.is_red(s.left):\n                    if s.is_on_left():\n                        s.left.colour = s.colour\n                        s.colour = p.colour\n                        self.rotate_right(p)\n                    else:\n                        s.left.colour = p.colour\n                        self.rotate_right(s)\n                        self.rotate_left(p)\n                elif s.is_on_left():\n                    s.right.colour = p.colour\n                    self.rotate_left(s)\n                    self.rotate_right(p)\n                else:\n                    s.right.colour = s.colour\n                    s.colour = p.colour\n                    self.rotate_left(p)\n                p.colour = RedBlackTree.Colour.BLACK\n            else:\n                s.colour = RedBlackTree.Colour.RED\n                if p.colour == RedBlackTree.Colour.BLACK:\n                    fix_double_black(p)\n                else:\n                    p.colour = RedBlackTree.Colour.BLACK\n\n        def delete(n):\n            child = n.left or n.right\n            if not (self.is_red(n) or self.is_red(child)):\n                fix_double_black(n)\n            if child:\n                child.parent = n.parent\n                child.colour = RedBlackTree.Colour.BLACK\n            if not n.parent:\n                self.root = child\n            elif n.is_on_left():\n                n.parent.left = child\n            else:\n                n.parent.right = child\n        n = self.root.find(v)\n        if n.right and n.left:\n            m = n.right.far_left()\n            n.key = m.key\n            n = m\n        delete(n)\n        self.len -= 1\n\n    def find(self, v):\n        return self.root and self.root.find(v)\n\n    def __iter__(self):\n        if not self.root:\n            return None\n        n = self.root.far_left()\n        while n:\n            yield n.key\n            n = n.next()\n\n    def __len__(self):\n        return self.len\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        edges = [[int(a) for a in input().split()] for _ in range(n - 1)]\n        aa = [0] + [int(a) for a in input().split()]\n        res = solve(n, edges, aa)\n        print(' '.join(map(str, res)))\nINF = 10000000000000000\n\ndef solve(n, edges, aa):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    parent = [0] * (n + 1)\n    dl = []\n    q = deque([1])\n    while q:\n        v = q.popleft()\n        for w in adj[v]:\n            if w != parent[v]:\n                dl.append(w)\n                parent[w] = v\n                q.append(w)\n    dl.reverse()\n    res = [INF] * (n + 1)\n    values = [RedBlackTree() for _ in range(n + 1)]\n    for (i, a) in enumerate(aa):\n        values[i].insert(a)\n    for u in dl:\n        res[parent[u]] = min(res[parent[u]], res[u])\n        if len(values[u]) > len(values[parent[u]]):\n            (values[u], values[parent[u]]) = (values[parent[u]], values[u])\n        for v in values[u]:\n            values[parent[u]].insert(v)\n            vn = values[parent[u]].find(v)\n            pn = vn.prev()\n            if pn:\n                res[parent[u]] = min(res[parent[u]], pn.key ^ v)\n            nn = vn.next()\n            if nn:\n                res[parent[u]] = min(res[parent[u]], nn.key ^ v)\n    return [-1 if r == INF else r for r in res[1:]]\nmain()", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(2 * 10 ** 5)\n\nclass SortedList:\n\n    def __init__(self, iterable=[], _load=200):\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return (0, k)\n        if k >= self._len - _list_lens[-1]:\n            return (len(_list_lens) - 1, k + _list_lens[-1] - self._len)\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return (idx + 1, k)\n\n    def _delete(self, pos, idx):\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (lo, pos) = (-1, len(_lists) - 1)\n        while lo + 1 < pos:\n            mi = lo + pos >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def _loc_right(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (pos, hi) = (0, len(_lists))\n        while pos + 1 < hi:\n            mi = pos + hi >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def add(self, value):\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len += 1\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        (pos, idx) = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        (pos, idx) = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        return self._len\n\n    def __getitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        return 'SortedList({0})'.format(list(self))\n\nclass OrderedList(SortedList):\n\n    def __init__(self, arg):\n        super().__init__(arg)\n\n    def rangeCountByValue(self, leftVal, rightVal):\n        leftCummulative = self.bisect_left(leftVal)\n        rightCummulative = self.bisect_left(rightVal + 1)\n        return rightCummulative - leftCummulative\n\ndef dfs(p, prev):\n    total = SortedList([])\n    total.add(a[p - 1])\n    value = float('inf')\n    for i in child[p]:\n        if i == prev:\n            continue\n        (take, val) = dfs(i, p)\n        if len(take) > len(total):\n            (total, take) = (take, total)\n        value = min(value, val)\n        for x in take:\n            ind = total.bisect_left(x)\n            if ind < len(total):\n                value = min(value, total[ind] ^ x)\n            if ind > 0:\n                value = min(value, total[ind - 1] ^ x)\n            total.add(x)\n    if value == float('inf'):\n        ans[p - 1] = -1\n    else:\n        ans[p - 1] = value\n    return [total, value]\nfor T in range(int(input())):\n    n = int(input())\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    a = list(map(int, input().split()))\n    ans = [-1 for i in range(n)]\n    dfs(1, -1)\n    print(*ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(2 * 10 ** 5)\n\nclass SortedList:\n\n    def __init__(self, iterable=[], _load=200):\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return (0, k)\n        if k >= self._len - _list_lens[-1]:\n            return (len(_list_lens) - 1, k + _list_lens[-1] - self._len)\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return (idx + 1, k)\n\n    def _delete(self, pos, idx):\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (lo, pos) = (-1, len(_lists) - 1)\n        while lo + 1 < pos:\n            mi = lo + pos >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def _loc_right(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (pos, hi) = (0, len(_lists))\n        while pos + 1 < hi:\n            mi = pos + hi >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def add(self, value):\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len += 1\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        (pos, idx) = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        (pos, idx) = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        return self._len\n\n    def __getitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        return 'SortedList({0})'.format(list(self))\n\nclass OrderedList(SortedList):\n\n    def __init__(self, arg):\n        super().__init__(arg)\n\n    def rangeCountByValue(self, leftVal, rightVal):\n        leftCummulative = self.bisect_left(leftVal)\n        rightCummulative = self.bisect_left(rightVal + 1)\n        return rightCummulative - leftCummulative\n\ndef dfs(p, prev):\n    total = SortedList([])\n    total.add(a[p - 1])\n    value = float('inf')\n    for i in child[p]:\n        if i == prev:\n            continue\n        (take, val) = dfs(i, p)\n        if len(take) > len(total):\n            (total, take) = (take, total)\n        value = min(value, val)\n        for x in take:\n            ind = total.bisect_left(x)\n            if ind < len(total):\n                value = min(value, total[ind] ^ x)\n            if ind > 0:\n                value = min(value, total[ind - 1] ^ x)\n            total.add(x)\n    if value == float('inf'):\n        ans[p - 1] = -1\n    else:\n        ans[p - 1] = value\n    return [total, value]\nfor T in range(int(input())):\n    n = int(input())\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    a = list(map(int, input().split()))\n    ans = [-1 for i in range(n)]\n    dfs(1, -1)\n    print(*ans)"]