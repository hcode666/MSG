["t = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    ar = [int(x) for x in input().split()]\n    f = 0\n    b = [[0 for x in range(31)] for x in range(n)]\n    for i in range(n):\n        x = ar[i]\n        j = 0\n        while x > 0:\n            d = x % 2\n            x //= 2\n            b[i][j] = d\n            j += 1\n    bit = 0\n    while bit < 31:\n        a = []\n        for i in range(n):\n            if b[i][bit] == 1:\n                a.append(i + 1)\n        bit += 1\n        if len(a) < 2:\n            continue\n        print('YES')\n        f = 1\n        print(len(a))\n        i = 0\n        print(1, a[i])\n        a[len(a) - 1] = n\n        while i < len(a) - 1:\n            print(a[i] + 1, a[i + 1])\n            i += 1\n        break\n    if f == 0:\n        print('NO')", "t = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    ar = [int(x) for x in input().split()]\n    f = 0\n    b = [[0 for x in range(31)] for x in range(n)]\n    for i in range(n):\n        x = ar[i]\n        j = 0\n        while x > 0:\n            d = x % 2\n            x //= 2\n            b[i][j] = d\n            j += 1\n    bit = 0\n    while bit < 31:\n        a = []\n        for i in range(n):\n            if b[i][bit] == 1:\n                a.append(i + 1)\n        bit += 1\n        if len(a) < 2:\n            continue\n        print('YES')\n        f = 1\n        print(len(a))\n        i = 0\n        print(1, a[i])\n        a[len(a) - 1] = n\n        while i < len(a) - 1:\n            print(a[i] + 1, a[i + 1])\n            i += 1\n        break\n    if f == 0:\n        print('NO')", "import sys\nimport os\nimport math\nfrom collections import *\nimport bisect\nfrom heapq import *\nfrom itertools import permutations, combinations\nif os.path.exists('input.txt') and os.path.exists('output.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ninput = sys.stdin.readline\n\ndef lcm(a, b):\n    k1 = math.gcd(a, b)\n    k2 = a * b\n    return k2 // k1\n\ndef inp():\n    return map(int, input().strip().split(' '))\n\ndef lis():\n    return list(inp())\nmod = 998244353\n\ndef prim(n):\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef dfs(adj, vis, u, l):\n    vis[u] = 1\n    l.add(u)\n    for i in adj[u]:\n        if vis[i] == 0:\n            dfs(adj, vis, i, l)\nmod = 10 ** 9 + 7\nma = 1002\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ndef dfs(i, j, arr, vis, n, m):\n    vis[i][j] = 1\n    for x in range(4):\n        mx = i + dx[x]\n        my = j + dy[x]\n        if mx >= 0 and mx < n and (my >= 0) and (my < m) and (vis[mx][my] == 0):\n            if arr[i][j] >= arr[mx][my]:\n                dfs(mx, my, arr, vis, n, m)\n\ndef dfs(a, vis, node, c):\n    vis[node] = 1\n    c[0] += 1\n    if vis[a[node]] == 0:\n        dfs(a, vis, a[node], c)\nmod = 998244353\nma = 2 * (10 ** 5 + 1)\nmod = 10 ** 9 + 7\n\ndef f(n):\n    if n % 4 == 0:\n        return n\n    if n % 4 == 1:\n        return 1\n    if n % 4 == 2:\n        return n + 1\n    return 0\n\ndef dfs(node, par, adj, dp, v):\n    dp[node] = 1\n    for i in adj[node]:\n        if i[0] != par:\n            dfs(i[0], node, adj, dp, v)\n            dp[node] += dp[i[0]]\n\ndef dfs1(node, par, adj, dp, v):\n    for i in adj[node]:\n        if i[0] != par:\n            if i[1] == 1:\n                v.append(dp[i[0]])\n            else:\n                dfs1(i[0], node, adj, dp, v)\nl = []\nfor i in range(1, 2 ** 9 + 1):\n    l.append(int(bin(i)[2:]))\n\ndef finv(p, q):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n\ndef pal(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] != s[n - 1 - i]:\n            return False\n    return True\n\ndef f(n):\n    res = 2\n    while res * res <= n:\n        if n % res == 0:\n            return False\n        res += 1\n    return True\n\ndef f(l):\n    mp = {word[::-1]: index for (index, word) in enumerate(l)}\n    ans = []\n    for (index, word) in enumerate(l):\n        for i in range(len(word)):\n            (left, right) = (word[:i + 1], word[i + 1:])\n            if not len(left) == 0 and left == left[::-1] and (right in mp) and (mp[right] != index):\n                ans.append([mp[right], index])\n            if right == right[::-1] and left in mp and (mp[left] != index):\n                ans.append([index, mp[left]])\n    return ans\n\ndef pal(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] != s[n - 1 - i]:\n            return False\n    return True\nmod = 10 ** 9 + 7\n\ndef solve():\n    n = int(input())\n    a = lis()\n    c = 1\n    for j in range(32):\n        l = []\n        for i in range(n):\n            if a[i] & c:\n                l.append(i)\n        if len(l) > 1:\n            cur = 0\n            print('YES')\n            print(len(l))\n            for i in range(len(l) - 1):\n                print(cur + 1, l[i] + 1)\n                cur = l[i] + 1\n            print(cur + 1, n)\n            return\n        c <<= 1\n    print('NO')\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\nfrom collections import Counter\nimport math\nimport bisect\n\nclass dsu:\n\n    def __init__(self):\n        self.parent = defaultdict(int)\n        self.size = [0] * (n + 1)\n\n    def start(self):\n        for i in range(1, n + 1):\n            self.parent[i] = i\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def treeinput(self, m):\n        for i in range(m):\n            (u, v) = map(int, input().split())\n            self.union(u, v)\n\n    def printt(self):\n        print(self.parent)\n\ndef setbit(arr):\n    mask = 1\n    bit = [0] * 32\n    for i in range(32):\n        for k in arr:\n            if k & mask:\n                bit[i] += 1\n        mask <<= 1\n    return bit\n\ndef prefix_sum(nums):\n    prefix = [0]\n    for i in range(len(nums)):\n        prefix.append(prefix[-1] + nums[i])\n    return prefix\n\ndef mx_lensubarray(nums):\n    res = 0\n    j = 0\n    mp = defaultdict(int)\n    prefix = prefixsum(nums)\n    mxSum = 0\n    for i in range(len(nums)):\n        if nums[i] in mp:\n            temp = mp[nums[i]]\n        else:\n            temp = 0\n        j = max(temp, j)\n        mp[nums[i]] = i + 1\n        res = max(res, i - j + 1)\n        mxSum = max(mxSum, prefix[i + 1] - prefix[j])\n    return res\n\ndef lenOfLongSubarr(self, A, N, k):\n    mp = {}\n    sm = 0\n    mxlen = 0\n    for i in range(N):\n        sm += A[i]\n        if sm == k:\n            mxlen = i + 1\n        if sm - k in mp:\n            mxlen = max(mxlen, i - mp[sm - k])\n        if sm not in mp:\n            mp[sm] = i\n    return mxlen\n\ndef no_of_factor(s):\n    cnt = 0\n    x = int(s ** 0.5)\n    for i in range(1, x + 1):\n        if not s % i:\n            cnt = cnt + 1 if s / i == i else cnt + 2\n        i += 1\n    return cnt\n\ndef primes(n):\n    arr = []\n    i = 2\n    while i * i <= n:\n        if not n % i:\n            cnt = 0\n            while not n % i:\n                cnt += 1\n                n //= i\n            arr.append([i, cnt])\n        i += 1\n    if n > 1:\n        arr.append([n, 1])\n    return arr\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    res = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            res.append(i)\n    return res\n\ndef treeinput():\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\ndef dfs_size(node, parent):\n    sum_size[node] = 1\n    for child in adj[node]:\n        if child != parent:\n            dfs_size(child, node)\n            sum_size[node] += sum_size[child]\n\ndef anda(arr):\n    res = arr[0]\n    for i in arr:\n        res &= i\n    return res\n\ndef ora(arr):\n    res = arr[0]\n    for i in arr:\n        res |= i\n    return res\n\ndef xora(arr):\n    res = 0\n    for i in arr:\n        res ^= i\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    (f, mask) = (0, 1)\n    for i in range(32):\n        cnt = 0\n        for num in arr:\n            if num & mask:\n                cnt += 1\n        if cnt >= 2:\n            f = 1\n            break\n        mask <<= 1\n    if f:\n        print('YES')\n        l = 0\n        r = 0\n        ans = []\n        for i in range(n):\n            if arr[i] & mask:\n                ans.append([l + 1, i + 1])\n                l = i + 1\n        ans[-1][-1] = n\n        print(len(ans))\n        for i in ans:\n            print(*i)\n    else:\n        print('NO')", "resultAns = ''\nfor _ in range(int(input())):\n    number = int(input())\n    arrayList = list(map(int, input().split()))\n    inclusive = -1\n    countNumber = 0\n    for i in range(32):\n        counter = 0\n        for j in range(number):\n            if arrayList[j] & 1 << i != 0:\n                counter += 1\n        if counter > 1:\n            inclusive = i\n            countNumber = counter\n            break\n    if inclusive == -1:\n        resultAns += 'NO\\n'\n    else:\n        resultAns += 'YES\\n'\n        resultAns += str(countNumber) + '\\n'\n        lastDigit = 1\n        for i in range(number):\n            if arrayList[i] & 1 << inclusive != 0 and countNumber > 1:\n                resultAns += str(lastDigit) + ' ' + str(i + 1) + '\\n'\n                lastDigit = i + 2\n                countNumber -= 1\n        resultAns += str(lastDigit) + ' ' + str(number) + '\\n'\nprint(resultAns)", "ans = ''\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ind = -1\n    count = 0\n    for i in range(32):\n        cnt = 0\n        for j in range(n):\n            if arr[j] & 1 << i != 0:\n                cnt += 1\n        if cnt > 1:\n            ind = i\n            count = cnt\n            break\n    if ind == -1:\n        ans += 'NO\\n'\n    else:\n        ans += 'YES\\n'\n        ans += str(count) + '\\n'\n        last = 1\n        for i in range(n):\n            if arr[i] & 1 << ind != 0 and count > 1:\n                ans += str(last) + ' ' + str(i + 1) + '\\n'\n                last = i + 2\n                count -= 1\n        ans += str(last) + ' ' + str(n) + '\\n'\nprint(ans)", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    ar = [int(i) for i in input().split(' ')]\n    ind = [1]\n    i = 0\n    while i < 30 and len(ind) < 2:\n        ind.clear()\n        x = 1 << i\n        for j in range(n):\n            if ar[j] & x > 0:\n                ind.append(j)\n        i += 1\n    length = len(ind)\n    if length >= 2:\n        print('YES')\n        print(len(ind))\n        prev = 0\n        for i in ind[:-1]:\n            print(prev + 1, i + 1)\n            prev = i + 1\n        print(prev + 1, n)\n    else:\n        print('NO')\n    t -= 1", "from math import *\nimport sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\n\ndef process(l):\n    start = 1\n    n = len(l)\n    print(n)\n    for i in range(n):\n        end = l[i] + 1\n        print(start, end)\n        start = end + 1\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    max_bit = 65\n    bin_array = [[0 for i in range(max_bit)] for j in range(n)]\n    for i in range(n):\n        num = l[i]\n        _bin = str(bin(num)[2:])\n        c = 0\n        for j in _bin[::-1]:\n            bin_array[i][c] = int(j)\n            c += 1\n    for i in range(max_bit):\n        split_point = []\n        j = 0\n        while j < n:\n            if bin_array[j][i] == 1:\n                split_point.append(j)\n            j += 1\n        if split_point == []:\n            continue\n        elif split_point[-1] != n - 1:\n            split_point[-1] = n - 1\n        if len(split_point) > 1:\n            print('YES')\n            process(split_point)\n            break\n    else:\n        print('NO')", "import math\nfrom bisect import bisect, bisect_left, bisect_right\nimport heapq\nfrom functools import reduce\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as ddc\nfrom collections import Counter\n\ndef intin():\n    return int(input())\n\ndef mapin():\n    return map(int, input().split())\n\ndef strin():\n    return input().split()\nINF = 10 ** 20\nmod = 1000000007\n\ndef LIS(arr, n):\n    dp = [10 ** 9] * (n + 1)\n    for ele in arr:\n        dp[bisect_left(dp, ele)] = ele\n    return bisect_left(dp, 10 ** 9)\n\ndef exponentiation(bas, exp, mod=1000000007):\n    t = 1\n    while exp > 0:\n        if exp % 2 != 0:\n            t = t * bas % mod\n        bas = bas * bas % mod\n        exp //= 2\n    return t % mod\n\ndef MOD(p, q=1, mod=1000000007):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\nyes = 'YES'\nno = 'NO'\neven = 'EVEN'\nodd = 'ODD'\n\ndef process(arr, n):\n    AND = reduce(lambda a, b: a & b, arr)\n    if AND != 0:\n        print('YES')\n        print(n)\n        for i in range(n):\n            print(i + 1, i + 1)\n        return\n    bits = [0] * 32\n    for num in arr:\n        i = 0\n        while num:\n            bits[i] += num & 1\n            num >>= 1\n            i += 1\n    idx = 0\n    while idx < 32:\n        if bits[idx] > 1:\n            break\n        idx += 1\n    if idx == 32:\n        print('NO')\n        return\n    print('YES')\n    print(bits[idx])\n    last = 1\n    for i in range(n):\n        if arr[i] & 1 << idx:\n            print(last, i + 1)\n            last = i + 2\n            bits[idx] -= 1\n        if bits[idx] == 1:\n            break\n    print(last, n)\n\ndef main():\n    for _ in range(int(input())):\n        n = intin()\n        arr = list(mapin())\n        process(arr, n)\nmain()", "import sys\nsys.setrecursionlimit(1000000)\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\n\ndef printyes():\n    print('YES')\n\ndef printno():\n    print('NO')\n\ndef find(a, j):\n    count = 0\n    loc = [0]\n    for i in range(len(a)):\n        if a[i] & 1 << j:\n            count += 1\n            loc.append(i + 1)\n    if count < 2:\n        return False\n    ans = []\n    for i in range(1, len(loc) - 1):\n        ans.append((loc[i - 1] + 1, loc[i]))\n    ans.append((loc[-2] + 1, len(a)))\n    return ans\nfor t in range(int(input())):\n    n = ni()\n    a = li()\n    final = 'NO'\n    ans = []\n    for j in range(32):\n        temp = find(a, j)\n        if temp:\n            final = 'YES'\n            ans = temp\n            break\n    print(final)\n    if ans:\n        print(len(ans))\n        for i in ans:\n            print(*i)", "from sys import stdin\ninput = stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    for i in range(31):\n        (cnt, target) = (0, 1 << i)\n        v = []\n        for j in range(n):\n            if a[j] & target:\n                v.append(j + 1)\n        if len(v) > 1:\n            break\n    if len(v) > 1:\n        print('YES')\n        print(len(v))\n        print(f'1 {v[0]}')\n        for i in range(1, len(v)):\n            if i + 1 < len(v):\n                print(f'{v[i - 1] + 1} {v[i]}')\n            else:\n                print(f'{v[i - 1] + 1} {n}')\n    else:\n        print('NO')", "def solve(n, arr):\n    for i in range(31):\n        left = 0\n        intervals = []\n        for j in range(n):\n            if arr[j] & 1 << i > 0:\n                intervals.append([left + 1, j + 1])\n                left = j + 1\n        if len(intervals) <= 1:\n            continue\n        intervals[-1][1] = n\n        break\n    if not intervals:\n        return 'NO'\n    res = f'YES\\n{len(intervals)}\\n'\n    for (left, right) in intervals:\n        res += f'{left} {right}\\n'\n    return res[:-1]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(solve(n, arr))", "test = int(input())\nwhile test:\n    n = int(input())\n    a = [bin(int(x)) for x in input().split()]\n    ans = []\n    for i in range(-1, -31, -1):\n        for j in range(n):\n            if len(a[j]) - 2 >= -i and a[j][i] == '1':\n                ans.append(j + 1)\n        if len(ans) > 1:\n            break\n        else:\n            ans.clear()\n    if ans:\n        print('YES')\n        print(len(ans))\n        ans.insert(0, 0)\n        ans[-1] = n\n        for i in range(1, len(ans)):\n            print(ans[i - 1] + 1, ans[i])\n    else:\n        print('NO')\n    test -= 1", "import math\nfrom collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    d = defaultdict(list)\n    for (i, x) in enumerate(arr):\n        nt = x\n        while nt > 0:\n            temp = 2 ** int(math.log(nt, 2))\n            nt -= temp\n            d[temp].append(i + 1)\n    key = list(d.keys())\n    val = list(d.values())\n    key.sort()\n    if len(val) == 0:\n        print('NO')\n    else:\n        flag = True\n        for k in key:\n            x = d[k]\n            lx = len(x)\n            if lx > 1:\n                flag = False\n                print('YES')\n                print(lx)\n                print(1, x[0])\n                for i in range(1, lx):\n                    if i == lx - 1:\n                        print(x[i - 1] + 1, n)\n                        break\n                    print(x[i - 1] + 1, x[i])\n                break\n        if flag:\n            print('NO')", "from sys import stdin, stdout\nfrom collections import defaultdict, Counter, deque\nimport math, heapq, bisect\ninput = stdin.readline\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    k = 1\n    flag = 0\n    for i in range(31):\n        total = 0\n        res = list()\n        start = 1\n        for j in range(n):\n            total += a[j]\n            if total & k:\n                res.append([start, j + 1])\n                total = 0\n                start = j + 2\n        if len(res) >= 2:\n            flag = 1\n            res[-1][1] = n\n            break\n        k <<= 1\n    if flag:\n        print('YES')\n        print(len(res))\n        for li in res:\n            print(*li)\n    else:\n        print('NO')", "from math import ceil, log, floor, sqrt, gcd\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if a == [0] * n:\n        print('NO')\n    else:\n        s = 1\n        for i in range(32):\n            p2 = 2 ** i\n            lst = []\n            for j in range(n):\n                if p2 & a[j]:\n                    lst += [j]\n            if len(lst) > 1:\n                break\n        else:\n            print('NO')\n            continue\n        print('YES')\n        print(len(lst))\n        s = 1\n        for i in range(len(lst) - 1):\n            print(s, lst[i] + 1)\n            s = lst[i] + 2\n        print(s, n)", "import sys\nimport os\nimport math\nfrom collections import *\nimport bisect\nfrom heapq import *\nfrom itertools import permutations, combinations\nif os.path.exists('input.txt') and os.path.exists('output.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ninput = sys.stdin.readline\n\ndef lcm(a, b):\n    k1 = math.gcd(a, b)\n    k2 = a * b\n    return k2 // k1\n\ndef inp():\n    return map(int, input().strip().split(' '))\n\ndef lis():\n    return list(inp())\nmod = 998244353\n\ndef prim(n):\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef dfs(adj, vis, u, l):\n    vis[u] = 1\n    l.add(u)\n    for i in adj[u]:\n        if vis[i] == 0:\n            dfs(adj, vis, i, l)\nmod = 10 ** 9 + 7\nma = 1002\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ndef dfs(i, j, arr, vis, n, m):\n    vis[i][j] = 1\n    for x in range(4):\n        mx = i + dx[x]\n        my = j + dy[x]\n        if mx >= 0 and mx < n and (my >= 0) and (my < m) and (vis[mx][my] == 0):\n            if arr[i][j] >= arr[mx][my]:\n                dfs(mx, my, arr, vis, n, m)\n\ndef dfs(a, vis, node, c):\n    vis[node] = 1\n    c[0] += 1\n    if vis[a[node]] == 0:\n        dfs(a, vis, a[node], c)\nmod = 998244353\nma = 2 * (10 ** 5 + 1)\nmod = 10 ** 9 + 7\n\ndef f(n):\n    if n % 4 == 0:\n        return n\n    if n % 4 == 1:\n        return 1\n    if n % 4 == 2:\n        return n + 1\n    return 0\n\ndef dfs(node, par, adj, dp, v):\n    dp[node] = 1\n    for i in adj[node]:\n        if i[0] != par:\n            dfs(i[0], node, adj, dp, v)\n            dp[node] += dp[i[0]]\n\ndef dfs1(node, par, adj, dp, v):\n    for i in adj[node]:\n        if i[0] != par:\n            if i[1] == 1:\n                v.append(dp[i[0]])\n            else:\n                dfs1(i[0], node, adj, dp, v)\nl = []\nfor i in range(1, 2 ** 9 + 1):\n    l.append(int(bin(i)[2:]))\n\ndef finv(p, q):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n\ndef pal(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] != s[n - 1 - i]:\n            return False\n    return True\n\ndef f(n):\n    res = 2\n    while res * res <= n:\n        if n % res == 0:\n            return False\n        res += 1\n    return True\n\ndef f(l):\n    mp = {word[::-1]: index for (index, word) in enumerate(l)}\n    ans = []\n    for (index, word) in enumerate(l):\n        for i in range(len(word)):\n            (left, right) = (word[:i + 1], word[i + 1:])\n            if not len(left) == 0 and left == left[::-1] and (right in mp) and (mp[right] != index):\n                ans.append([mp[right], index])\n            if right == right[::-1] and left in mp and (mp[left] != index):\n                ans.append([index, mp[left]])\n    return ans\n\ndef pal(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] != s[n - 1 - i]:\n            return False\n    return True\nmod = 10 ** 9 + 7\n\ndef solve():\n    n = int(input())\n    a = lis()\n    c = 1\n    for j in range(32):\n        l = []\n        for i in range(n):\n            if a[i] & c:\n                l.append(i)\n        if len(l) > 1:\n            cur = 0\n            print('YES')\n            print(len(l))\n            for i in range(len(l) - 1):\n                print(cur + 1, l[i] + 1)\n                cur = l[i] + 1\n            print(cur + 1, n)\n            return\n        c <<= 1\n    print('NO')\nt = int(input())\nfor _ in range(t):\n    solve()", "from bisect import bisect_left\nfrom re import sub\nimport re\nfrom typing import DefaultDict\nimport math\nfrom collections import defaultdict\nfrom math import sqrt\nimport collections\nfrom sys import maxsize\nfrom itertools import combinations_with_replacement\nimport sys\nimport copy\n\ndef sieve_erasthones(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    return prime\n\ndef calculate(p, q):\n    mod = 998244353\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n\ndef count_factors(n):\n    i = 1\n    c = 0\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n // i == i:\n                c += 1\n            else:\n                c += 2\n        i += 1\n    return c\n\ndef ncr_modulo(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef isprime(n):\n    prime_flag = 0\n    if n > 1:\n        for i in range(2, int(sqrt(n)) + 1):\n            if n % i == 0:\n                prime_flag = 1\n                break\n        if prime_flag == 0:\n            return True\n        else:\n            return False\n    else:\n        return True\n\ndef smallestDivisor(n):\n    if n % 2 == 0:\n        return 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return i\n        i += 2\n    return n\n\ndef dict_ele_count(l):\n    d = DefaultDict(lambda : 0)\n    for ele in l:\n        d[ele] += 1\n    return d\n\ndef max_in_dict(d):\n    maxi = 0\n    for ele in d:\n        if d[ele] > maxi:\n            maxi = d[ele]\n    return maxi\n\ndef element_count(s):\n    l = []\n    k = s[0]\n    c = 0\n    for ele in s:\n        if ele == k:\n            c += 1\n        else:\n            l.append([k, c])\n            k = ele\n            c = 1\n    l.append([k, c])\n    return l\n\ndef modular_exponentiation(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 != 0:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef number_of_primefactor(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return len(set(l))\n\ndef twosum(a, n, x):\n    rem = []\n    for i in range(x):\n        rem.append(0)\n    for i in range(n):\n        if a[i] < x:\n            rem[a[i] % x] += 1\n    for i in range(1, x // 2):\n        if rem[i] > 0 and rem[x - i] > 0:\n            return True\n    if i >= x // 2:\n        if x % 2 == 0:\n            if rem[x // 2] > 1:\n                return True\n            else:\n                return False\n        elif rem[x // 2] > 0 and rem[x - x // 2] > 0:\n            return True\n        else:\n            return False\n\ndef divSum(num):\n    result = 0\n    i = 2\n    while i <= math.sqrt(num):\n        if num % i == 0:\n            if i == num / i:\n                result = result + i\n            else:\n                result = result + (i + num / i)\n        i = i + 1\n    return result + 1 + num\n\ndef subsequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\n\ndef primeFactors(n):\n    d = defaultdict(lambda : 0)\n    while n % 2 == 0:\n        d[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[int(i)] += 1\n            n = n / i\n    if n > 2:\n        d[int(n)] += 1\n    return d\n\ndef calc(s):\n    ans = 0\n    for ele in s:\n        ans += ord(ele) - 96\n    return ans\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    return inv * a % m\n\ndef count(n):\n    ans = 0\n    while n:\n        ans += n % 10\n        n //= 10\n    return ans\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\ndef solve():\n    n = int(input())\n    bool = True\n    l = list(map(int, input().split()))\n    x = -1\n    for i in range(31):\n        c = 0\n        k = 2 ** i\n        for ele in l:\n            if ele & k != 0:\n                c += 1\n        if c > 1:\n            x = k\n            break\n    if x == -1:\n        print('NO')\n    else:\n        ans = []\n        for i in range(n):\n            if l[i] & x != 0:\n                ans.append(i + 1)\n        print('YES')\n        print(len(ans))\n        print(1, ans[0])\n        for i in range(1, len(ans) - 1):\n            print(ans[i - 1] + 1, ans[i])\n        print(ans[-2] + 1, n)\nfor _ in range(int(input())):\n    solve()", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    bit = [0] * 32\n    ok = False\n    for i in a:\n        for j in range(32):\n            if i & 1 << j > 0:\n                bit[j] += 1\n                if bit[j] > 1:\n                    ok = True\n    if ok:\n        print('YES')\n        ans = -1\n        for i in range(32):\n            if bit[i] > 1:\n                print(bit[i])\n                ans = i\n                break\n        s = 0\n        st = 1\n        c = 1\n        for i in range(n):\n            s += a[i]\n            if s & 1 << ans > 0:\n                if c != bit[ans]:\n                    print(st, i + 1)\n                    st = i + 2\n                    s = 0\n                else:\n                    print(st, n)\n                    break\n                c += 1\n    else:\n        print('NO')", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    i = 1\n    flag = True\n    while i < 1000000000.0:\n        t = 0\n        for j in range(n):\n            if a[j] & i == i:\n                t += 1\n        if t >= 2:\n            flag = False\n            print('YES')\n            print(t)\n            f = 1\n            s = -1\n            for j in range(n):\n                if a[j] & i == i:\n                    s = j + 1\n                    print(f, s)\n                    t -= 1\n                    f = j + 2\n                if t == 1:\n                    break\n            print(f, n)\n            break\n        i *= 2\n    if flag:\n        print('NO')", "from math import ceil\nfrom collections import defaultdict\nfor i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = 1\n    poss = False\n    for bit in range(31):\n        ans = []\n        cs = 0\n        l = 0\n        for j in range(n):\n            cs += a[j]\n            if cs & c != 0:\n                ans.append((l, j))\n                l = j + 1\n                cs = 0\n        if l == n and len(ans) >= 2:\n            print('YES')\n            print(len(ans))\n            for (x, y) in ans:\n                print(x + 1, y + 1)\n            poss = True\n            break\n        elif len(ans) >= 2:\n            (pl, pr) = ans.pop()\n            cs = 0\n            for j in range(pl, n):\n                cs += a[j]\n            if cs & c != 0:\n                ans.append((pl, n - 1))\n            print('YES')\n            print(len(ans))\n            for (x, y) in ans:\n                print(x + 1, y + 1)\n            poss = True\n            break\n        c = c * 2\n    if not poss:\n        print('NO')", "import sys\nimport math\nfrom collections import defaultdict, Counter, deque\nfrom bisect import *\nfrom string import ascii_lowercase\nfrom heapq import *\n\ndef readInts():\n    x = list(map(int, sys.stdin.readline().rstrip().split()))\n    return x[0] if len(x) == 1 else x\n\ndef readList(type=int):\n    x = sys.stdin.readline()\n    x = list(map(type, x.rstrip('\\n\\r').split()))\n    return x\n\ndef readStr():\n    x = sys.stdin.readline().rstrip('\\r\\n')\n    return x\nwrite = sys.stdout.write\nread = sys.stdin.readline\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef mergeSort(arr, check=lambda a, b: a < b, reverse=False):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        mergeSort(L, check, reverse)\n        mergeSort(R, check, reverse)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if check(L[i], R[j]):\n                if not reverse:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n            elif not reverse:\n                arr[k] = R[j]\n                j += 1\n            else:\n                arr[k] = L[i]\n                i += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\ndef maxSum(arr, k):\n    max_sum = 0\n    max_cur = 0\n    for (i, num) in enumerate(arr):\n        max_cur = max(max_cur + num, num)\n        if max_cur > max_sum:\n            max_sum = max_cur\n    return max_sum\n\ndef hcf(a, b):\n    if b == 0:\n        return a\n    else:\n        return hcf(b, b % a)\n\ndef get_power(n, m):\n    i = 1\n    p = -1\n    while i <= n:\n        i = i * m\n        p += 1\n    return p\n\ndef fact(n):\n    f = 1\n    for i in range(2, n + 1):\n        f *= i\n    return f\n\ndef find_closest(num, ar):\n    min_d = float('inf')\n    for num2 in ar:\n        d = abs(num2 - num)\n        if d < min_d:\n            min_d = d\n    return min_d\n\ndef check_pal(n):\n    s = str(n)\n    j = len(s) - 1\n    i = 0\n    while j > i:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef solve(t):\n    n = readInts()\n    ar = readList()\n    sar = sorted(ar)\n    flag = False\n    bcnt = [0 for _ in range(30)]\n    anum = -1\n    for (i, num) in enumerate(sar):\n        k = 0\n        while num > 0:\n            if num & 1:\n                bcnt[k] += 1\n            k += 1\n            num = num >> 1\n    for i in range(30):\n        if bcnt[i] > 1:\n            flag = True\n            anum = 2 ** i\n            break\n    if not flag:\n        print('NO')\n        return\n    res = []\n    j = 0\n    while j < n:\n        num = ar[j]\n        if num & anum:\n            res.append([j + 1, j + 1])\n        else:\n            tmp = j\n            while j < n and (not ar[j] & anum):\n                j += 1\n            if j < n and ar[j] & anum:\n                res.append([tmp + 1, j + 1])\n            else:\n                res[-1][1] = n\n        j += 1\n    if len(res) < 2:\n        print('NO')\n    else:\n        print('YES')\n        print(len(res))\n        for pair in res:\n            print(*pair)\n\ndef main():\n    t = 1\n    sys.setrecursionlimit(1000)\n    t = readInts()\n    for i in range(t):\n        solve(i + 1)\nmain()", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    if n == 2:\n        if l[0] & l[1] > 0:\n            print('YES')\n            print(2)\n            print(1, 1)\n            print(2, 2)\n            continue\n        else:\n            print('NO')\n            continue\n    c0 = 0\n    c1 = 0\n    pos = []\n    a = l[0]\n    for j in range(n):\n        i = l[j]\n        if i == 0:\n            c0 += 1\n        elif i % 2 == 1:\n            c1 += 1\n            pos.append(j + 1)\n        a &= i\n    if c0 >= n - 1:\n        print('NO')\n    elif c1 >= 2:\n        print('YES')\n        print(c1)\n        print(1, pos[0])\n        for i in range(len(pos) - 2):\n            print(pos[i] + 1, pos[i + 1])\n        print(pos[-2] + 1, n)\n    elif a > 0:\n        print('YES')\n        print(n)\n        for i in range(0, n):\n            print(i + 1, i + 1)\n    else:\n        pos.clear()\n        pos = {}\n        for i in range(31):\n            pos[i] = []\n        for k in range(n):\n            i = l[k]\n            if i == 0:\n                continue\n            i = bin(i)\n            for j in range(1, len(i) - 1):\n                if i[-j] == '1':\n                    pos[j - 1].append(k + 1)\n        for i in pos:\n            if len(pos[i]) > 1:\n                print('YES')\n                print(len(pos[i]))\n                pos = pos[i]\n                print(1, pos[0])\n                for i in range(len(pos) - 2):\n                    print(pos[i] + 1, pos[i + 1])\n                print(pos[-2] + 1, n)\n                break\n        else:\n            print('NO')", "for _ in range(int(input())):\n    try:\n        n = int(input())\n        l = list(map(int, input().strip().split()))\n        (ind, c) = (-1, 0)\n        for i in range(32):\n            c1 = 0\n            for j in l:\n                if j & 1 << i:\n                    c1 += 1\n            if c1 > 1:\n                c = c1\n                ind = i\n                break\n        if ind == -1:\n            print('NO')\n            continue\n        print('YES')\n        print(c)\n        x = 1\n        c -= 1\n        for i in range(n):\n            if c == 0:\n                break\n            if l[i] & 1 << ind:\n                print(x, end=' ')\n                print(i + 1)\n                x = i + 2\n                c -= 1\n        print(x, end=' ')\n        print(n)\n    finally:\n        pass", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    output_arr = None\n    for i in range(n):\n        z = format(arr[i], '032b')\n        arr[i] = z[::-1]\n    res = False\n    for j in range(32):\n        result = []\n        for i in range(len(arr)):\n            if arr[i][j] == '1':\n                result.append(i)\n        if len(result) > 1:\n            output_arr = result.copy()\n            res = True\n            break\n    if res == False:\n        print('NO')\n    else:\n        print('YES')\n        if len(output_arr) % 2 == 0:\n            print(2)\n            print(1, output_arr[0] + 1)\n            print(output_arr[0] + 2, n)\n        else:\n            print(3)\n            print(1, output_arr[0] + 1)\n            print(output_arr[0] + 2, output_arr[1] + 1)\n            print(output_arr[1] + 2, n)", "for iota in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    odd = []\n    while True:\n        if len(odd) >= 2:\n            break\n        if a == [0] * n:\n            break\n        odd = []\n        for i in range(n):\n            if a[i] % 2 == 1:\n                odd.append(i)\n            a[i] >>= 1\n    if len(odd) < 2:\n        print('NO')\n    else:\n        print('YES')\n        print(len(odd))\n        for i in range(len(odd)):\n            if i == 0:\n                print(1, odd[i] + 1)\n                continue\n            if i == len(odd) - 1:\n                print(odd[i - 1] + 2, n)\n                continue\n            print(odd[i - 1] + 2, odd[i] + 1)", "import sys\ninput = lambda : sys.stdin.readline()\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    a = list(map(int, input().split()))\n    L = [0 for i in range(32)]\n    for i in a:\n        for j in range(32):\n            if i & 1 << j:\n                L[j] += 1\n    f = False\n    for i in range(32):\n        if L[i] > 1:\n            f = True\n            print('YES')\n            t = L[i]\n            print(L[i])\n            break\n    if not f:\n        print('NO')\n        continue\n    j = 1\n    for value in range(n):\n        if a[value] & 1 << i:\n            if t > 1:\n                print(j, value + 1)\n                t -= 1\n            else:\n                print(j, n)\n            j = value + 2", "def fun(n, a):\n    if a == [0] * n:\n        print('NO')\n        return\n    l = []\n    for i in range(n):\n        if a[i] % 2 == 1:\n            l.append(i)\n    if len(l) > 1:\n        print('YES')\n        print(len(l))\n        x = 1\n        for i in range(len(l) - 1):\n            print(x, l[i] + 1)\n            x = l[i] + 2\n        print(x, n)\n        return\n    L = [a[i] // 2 for i in range(n)]\n    return fun(n, L)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    fun(n, a)", "for s in [*open(0)][2::2]:\n    l = [*map(int, s.split())]\n    f = 1\n    for i in range(30):\n        b = 1 << i\n        ind = []\n        for j in range(len(l)):\n            if l[j] & b:\n                ind += [j]\n        if len(ind) > 1:\n            print('YES')\n            print(len(ind))\n            ind = sorted(ind)\n            p = 0\n            for x in ind[:-1]:\n                print(p + 1, x + 1)\n                p = x + 1\n            print(p + 1, len(l))\n            f = 0\n            break\n    if f == 1:\n        print('NO')", "import sys\nfrom math import sqrt, gcd, factorial, ceil, floor, pi\nfrom collections import deque, Counter, OrderedDict\nfrom heapq import heapify, heappush, heappop\ninput = lambda : sys.stdin.readline()\nI = lambda : int(input())\nS = lambda : input().strip()\nM = lambda : map(int, input().strip().split())\nL = lambda : list(map(int, input().strip().split()))\nmod = 1000000007\nfor _ in range(I()):\n    n = I()\n    a = L()\n    arr = [0] * 32\n    for i in a:\n        for j in range(32):\n            if i & 1 << j:\n                arr[j] += 1\n    ans = 'NO'\n    for i in range(32):\n        if arr[i] > 1:\n            ans = 'YES'\n            print(ans)\n            c = arr[i]\n            print(arr[i])\n            break\n    if ans == 'NO':\n        print(ans)\n        continue\n    j = 1\n    for k in range(n):\n        if a[k] & 1 << i:\n            if c > 1:\n                print(j, k + 1)\n                c -= 1\n            else:\n                print(j, n)\n            j = k + 2"]