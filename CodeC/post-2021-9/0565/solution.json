["for _ in range(int(input())):\n    bool = True\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    B.sort(reverse=True)\n    (flag, i, j) = (0, 0, 0)\n    while i < n and j < m:\n        if A[i] > B[j]:\n            flag = 1\n            break\n        elif A[i] < B[j]:\n            i = i + 1\n        else:\n            i = i + 1\n            j = j + 1\n    if flag == 1 or j == m:\n        print('NO')\n    else:\n        ans = B[j + 1:][::-1] + B[:j + 1]\n        print('YES')\n        print(*ans)", "for _ in range(int(input())):\n    bool = True\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    B.sort(reverse=True)\n    (flag, i, j) = (0, 0, 0)\n    while i < n and j < m:\n        if A[i] > B[j]:\n            flag = 1\n            break\n        elif A[i] < B[j]:\n            i = i + 1\n        else:\n            i = i + 1\n            j = j + 1\n    if flag == 1 or j == m:\n        print('NO')\n    else:\n        ans = B[j + 1:][::-1] + B[:j + 1]\n        print('YES')\n        print(*ans)", "for _ in range(int(input())):\n    bool = True\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    B.sort(reverse=True)\n    (flag, i, j) = (0, 0, 0)\n    while i < n and j < m:\n        if A[i] > B[j]:\n            flag = 1\n            break\n        elif A[i] < B[j]:\n            i = i + 1\n        else:\n            i = i + 1\n            j = j + 1\n    if flag == 1 or j == m:\n        print('NO')\n    else:\n        ans = B[j + 1:][::-1] + B[:j + 1]\n        print('YES')\n        print(*ans)", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    l1 = list(map(int, input().split()))\n    l2 = list(map(int, input().split()))\n    ans = []\n    l2.sort()\n    s = False\n    for j in l1:\n        if not l2 or l2[-1] < j:\n            s = True\n            break\n        elif l2[-1] == j:\n            ans.append(j)\n            l2.pop()\n    if not l2 or s:\n        print('NO')\n        continue\n    print('YES')\n    ans.append(l2.pop())\n    print(*l2, *ans)", "import sys\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    lst_n = list(map(int, input().split()))\n    lst_m = list(map(int, input().split()))\n    ans = []\n    lst_m.sort()\n    flag = False\n    for x in lst_n:\n        if not lst_m or lst_m[-1] < x:\n            flag = True\n            break\n        elif lst_m[-1] == x:\n            ans.append(x)\n            lst_m.pop()\n    if not lst_m or flag:\n        print('NO')\n        continue\n    print('YES')\n    ans.append(lst_m.pop())\n    print(*lst_m, *ans)", "for _ in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    b.sort(reverse=True)\n    i = 0\n    j = 0\n    f = True\n    while i < n and j < m:\n        if a[i] < b[j]:\n            i += 1\n        elif a[i] == b[j]:\n            i += 1\n            j += 1\n        else:\n            f = False\n            break\n    if j == m:\n        f = False\n    if f:\n        print('YES')\n        for i in b[j + 1:m][::-1]:\n            print(i, end=' ')\n        for i in b[:j + 1]:\n            print(i, end=' ')\n        print()\n    else:\n        print('NO')", "test = int(input())\nwhile test:\n    (n, m) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    b.sort(reverse=True)\n    i = j = 0\n    found = 1\n    while i < len(a) and j < len(b):\n        if b[j] < a[i]:\n            found = 0\n            break\n        elif b[j] > a[i]:\n            i += 1\n        else:\n            i += 1\n            j += 1\n    if found == 0 or len(b) == j:\n        print('NO')\n    else:\n        k = b[-1:j:-1] + b[0:j + 1]\n        print('YES')\n        print(*k)\n    test -= 1", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    b = sorted(b)\n    i = 0\n    j = m - 1\n    f = 0\n    while i < n and j >= 0:\n        if a[i] > b[j]:\n            print('NO')\n            f = 1\n            break\n        elif a[i] < b[j]:\n            i += 1\n        else:\n            i += 1\n            j -= 1\n    if j == -1:\n        print('NO')\n    elif not f:\n        print('YES')\n        for k in range(j):\n            print(b[k], end=' ')\n        for k in range(m - 1, j - 1, -1):\n            print(b[k], end=' ')\n        print()", "def solve():\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    B.sort()\n    (i, j) = (0, m - 1)\n    while i < n and j >= 0:\n        if A[i] > B[j]:\n            print('NO')\n            return\n        elif A[i] < B[j]:\n            i += 1\n        else:\n            i += 1\n            j -= 1\n    if j == -1:\n        print('NO')\n        return\n    else:\n        print('YES')\n        for k in range(j):\n            print(B[k], end=' ')\n        for k in range(m - 1, j - 1, -1):\n            print(B[k], end=' ')\n        print()\n        return\nt = int(input())\nfor _ in range(t):\n    solve()", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    b.sort(reverse=True)\n    (i, j, f) = (0, 0, True)\n    while i < n and j < m:\n        if a[i] > b[j]:\n            f = False\n            break\n        elif a[i] < b[j]:\n            i += 1\n        else:\n            i += 1\n            j += 1\n        if j == m:\n            f = False\n    if not f:\n        print('NO')\n    else:\n        print('YES')\n        print(*sorted(b[j + 1:]) + b[:j + 1])", "from collections import Counter\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    b.sort()\n    done = False\n    ansArr = []\n    while not done:\n        la = len(a)\n        lb = len(b)\n        if la == 0 and lb == 0:\n            ans = 'NO'\n            break\n        if lb == 0:\n            ans = 'NO'\n            break\n        if la == 0:\n            ans = 'YES'\n            ansArr = b[:-1] + ansArr + [b[-1]]\n            break\n        ma = max(a)\n        mb = max(b)\n        if ma > mb:\n            ans = 'NO'\n            break\n        if mb > ma:\n            ans = 'YES'\n            ansArr = b[:-1] + ansArr + [b[-1]]\n            break\n        f = a.index(ma)\n        a = a[f + 1:]\n        ansArr += [mb]\n        b = b[:-1]\n    print(ans)\n    if ans == 'YES':\n        for i in ansArr:\n            print(i, end=' ')\n        print()", "from collections import Counter\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    b.sort()\n    done = False\n    ansArr = []\n    while not done:\n        la = len(a)\n        lb = len(b)\n        if la == 0 and lb == 0:\n            ans = 'NO'\n            break\n        if lb == 0:\n            ans = 'NO'\n            break\n        if la == 0:\n            ans = 'YES'\n            ansArr = b[:-1] + ansArr + [b[-1]]\n            break\n        ma = max(a)\n        mb = max(b)\n        if ma > mb:\n            ans = 'NO'\n            break\n        if mb > ma:\n            ans = 'YES'\n            ansArr = b[:-1] + ansArr + [b[-1]]\n            break\n        f = a.index(ma)\n        a = a[f + 1:]\n        ansArr += [mb]\n        b = b[:-1]\n    print(ans)\n    if ans == 'YES':\n        for i in ansArr:\n            print(i, end=' ')\n        print()", "for i in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr1 = list(map(int, input().split()[:n]))\n    arr2 = list(map(int, input().split()[:m]))\n    arr2.sort()\n    i = j = 0\n    ans = []\n    while i < n:\n        if j == m:\n            print('NO')\n            break\n        elif arr1[i] < arr2[m - j - 1]:\n            i += 1\n        elif arr1[i] > arr2[m - j - 1]:\n            ans.append(arr2[m - j - 1])\n            j += 1\n        else:\n            ans.append(arr2[m - j - 1])\n            i += 1\n            j += 1\n    if i == n:\n        if j != m:\n            print('YES')\n            ans.append(arr2[m - j - 1])\n            for i in range(m - j - 1):\n                print(arr2[i], end=' ')\n            for item in ans:\n                print(item, end=' ')\n            print()\n        else:\n            print('NO')", "def func():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    b.sort()\n    j = m - 1\n    flg = True\n    req = []\n    for i in range(n):\n        if a[i] == b[j]:\n            req.append(b[j])\n            j -= 1\n            if j < 0:\n                flg = False\n                break\n        elif b[j] < a[i]:\n            flg = False\n            break\n    if flg:\n        ans = b[:j] + req + [b[j]]\n        print('YES')\n        print(*ans)\n    else:\n        print('NO')\nt = int(input())\nfor i in range(t):\n    func()", "from collections import defaultdict\nT = int(input())\nfor _ in range(T):\n    (N, M) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    dic_b = defaultdict(lambda : 0)\n    dic_a = defaultdict(lambda : 0)\n    for y in b:\n        dic_b[y] += 1\n    mx = 0\n    for x in reversed(a):\n        if x < mx:\n            pass\n        else:\n            dic_a[x] += 1\n            mx = x\n    keys_a = sorted(dic_a.keys(), reverse=True)\n    keys_b = sorted(dic_b.keys(), reverse=True)\n    len_a = len(keys_a)\n    len_b = len(keys_b)\n    i = 0\n    while True:\n        if i == min(len_a, len_b):\n            if len_a < len_b:\n                answer = 'YES'\n                v_a = 0\n                k_b = keys_b[i]\n                v_b = dic_b[k_b]\n            else:\n                answer = 'NO'\n            break\n        k_a = keys_a[i]\n        k_b = keys_b[i]\n        if k_a > k_b:\n            answer = 'NO'\n            break\n        elif k_a < k_b:\n            answer = 'YES'\n            v_a = 0\n            v_b = dic_b[k_b]\n            break\n        v_a = dic_a[k_a]\n        v_b = dic_b[k_b]\n        if v_a > v_b:\n            answer = 'NO'\n            break\n        elif v_a < v_b:\n            answer = 'YES'\n            break\n        i = i + 1\n    print(answer)\n    if answer == 'YES':\n        answer = []\n        for j in reversed(range(i + 1, len_b)):\n            answer.extend([keys_b[j]] * dic_b[keys_b[j]])\n        answer.extend([keys_b[i]] * (v_b - v_a - 1))\n        for j in range(i):\n            answer.extend([keys_b[j]] * dic_b[keys_b[j]])\n        answer.extend([keys_b[i]] * (v_a + 1))\n        print(' '.join(map(str, answer)))", "from math import ceil, gcd, factorial, sqrt, floor\nimport queue\nimport re\nfrom itertools import permutations, combinations, accumulate\nfrom collections import Counter, deque\nfrom sys import stdin, stdout\nfrom bisect import bisect, insort, bisect_left, insort_left\n\ndef sieve(meta_path):\n    prime = [True] * (meta_path + 1)\n    p = 2\n    while p * p <= meta_path:\n        if prime[p] == True:\n            for l1 in range(p * p, meta_path + 1, p):\n                prime[l1] = False\n        p += 1\n    return prime\n\ndef simplesieve(meta_path):\n    prime = [2]\n    mark = [False] * (meta_path + 1)\n    for p in range(3, meta_path + 1, 2):\n        if mark[p] == False:\n            prime.append(p)\n            if p * p <= meta_path:\n                for l1 in range(p * p, meta_path + 1, 2 * p):\n                    mark[l1] = True\n    return mark\n\ndef segementedsieve(low, high):\n    limit = int(sqrt(high))\n    primes = simplesieve(limit)\n    prime = [True] * (high - low + 1)\n    for l1 in primes:\n        lower = low // l1\n        if lower <= 1:\n            lower = l1 + l1\n        elif low % l1 != 0:\n            lower = lower * l1 + l1\n        else:\n            lower = lower * l1\n        for l2 in range(lower, high + 1, l1):\n            prime[l2 - low] = False\n    s1 = []\n    s = 0\n    for l in range(low, high + 1):\n        if prime[l - low]:\n            s1.append(l)\n    return s1\n\ndef isprime(meta_path):\n    if meta_path == 2:\n        return True\n    if meta_path % 2 == 0 or meta_path == 1:\n        return False\n    for l1 in range(3, int(meta_path ** 0.5) + 1, 2):\n        if meta_path % l1 == 0:\n            return False\n    return True\n\ndef binpow(s1, s2, s):\n    r2 = 1\n    s1 = s1 % s\n    while s2 > 0:\n        if s2 & 1:\n            r2 = r2 * s1 % s\n        s1 = s1 * s1 % s\n        s2 >>= 1\n    return r2\n\ndef lcm(s1, s2):\n    return s1 // gcd(s1, s2) * s2\n\ndef gcdExtended(s1, s2):\n    if s2 == 0:\n        return (s1, 1, 0)\n    (g, x1, y1) = gcdExtended(s2, s1 % s2)\n    l1 = y1\n    l2 = x1 - s1 // s2 * y1\n    return (g, l1, l2)\n\ndef dfs(graph, s, l1):\n    v = [0] * (s + 1)\n    v[l1] = 1\n    s1 = [l1]\n    z = 0\n    while s1 != []:\n        l = s1.pop()\n        for l1 in graph[l]:\n            if v[l1] == 0:\n                v[l1] = 1\n                s1.append(l1)\n    return 'no'\n\ndef bfs(graph, n, a, dest):\n    v = [0] * (1 + n)\n    d = [0] * (1 + n)\n    d[a] = 0\n    v[a] = 1\n    q = queue.Queue()\n    q.put(a)\n    while not q.empty():\n        z = q.get()\n        for i in graph[z]:\n            if v[i] == 0:\n                v[i] = 1\n                d[i] = d[z] + 1\n                q.put(i)\n    return d[dest]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    b.sort(reverse=True)\n    i = j = 0\n    while i < n and j < m:\n        if a[i] < b[j]:\n            i += 1\n        elif a[i] > b[j]:\n            j += 1\n        else:\n            i += 1\n            j += 1\n    if j == m:\n        print('NO')\n    else:\n        ans = []\n        for i in range(m - 1, j, -1):\n            ans.append(b[i])\n        for i in range(j + 1):\n            ans.append(b[i])\n        print('YES')\n        for i in ans:\n            print(i, end=' ')\n        print()", "from math import ceil, gcd, factorial, sqrt, floor\nimport queue\nimport re\nfrom itertools import permutations, combinations, accumulate\nfrom collections import Counter, deque\nfrom sys import stdin, stdout\nfrom bisect import bisect, insort, bisect_left, insort_left\n\ndef sieve(meta_path):\n    prime = [True] * (meta_path + 1)\n    p = 2\n    while p * p <= meta_path:\n        if prime[p] == True:\n            for l1 in range(p * p, meta_path + 1, p):\n                prime[l1] = False\n        p += 1\n    return prime\n\ndef simplesieve(meta_path):\n    prime = [2]\n    mark = [False] * (meta_path + 1)\n    for p in range(3, meta_path + 1, 2):\n        if mark[p] == False:\n            prime.append(p)\n            if p * p <= meta_path:\n                for l1 in range(p * p, meta_path + 1, 2 * p):\n                    mark[l1] = True\n    return mark\n\ndef segementedsieve(low, high):\n    limit = int(sqrt(high))\n    primes = simplesieve(limit)\n    prime = [True] * (high - low + 1)\n    for l1 in primes:\n        lower = low // l1\n        if lower <= 1:\n            lower = l1 + l1\n        elif low % l1 != 0:\n            lower = lower * l1 + l1\n        else:\n            lower = lower * l1\n        for l2 in range(lower, high + 1, l1):\n            prime[l2 - low] = False\n    s1 = []\n    s = 0\n    for l in range(low, high + 1):\n        if prime[l - low]:\n            s1.append(l)\n    return s1\n\ndef isprime(meta_path):\n    if meta_path == 2:\n        return True\n    if meta_path % 2 == 0 or meta_path == 1:\n        return False\n    for l1 in range(3, int(meta_path ** 0.5) + 1, 2):\n        if meta_path % l1 == 0:\n            return False\n    return True\n\ndef binpow(s1, s2, s):\n    r2 = 1\n    s1 = s1 % s\n    while s2 > 0:\n        if s2 & 1:\n            r2 = r2 * s1 % s\n        s1 = s1 * s1 % s\n        s2 >>= 1\n    return r2\n\ndef lcm(s1, s2):\n    return s1 // gcd(s1, s2) * s2\n\ndef gcdExtended(s1, s2):\n    if s2 == 0:\n        return (s1, 1, 0)\n    (g, x1, y1) = gcdExtended(s2, s1 % s2)\n    l1 = y1\n    l2 = x1 - s1 // s2 * y1\n    return (g, l1, l2)\n\ndef dfs(graph, s, l1):\n    v = [0] * (s + 1)\n    v[l1] = 1\n    s1 = [l1]\n    z = 0\n    while s1 != []:\n        l = s1.pop()\n        for l1 in graph[l]:\n            if v[l1] == 0:\n                v[l1] = 1\n                s1.append(l1)\n    return 'no'\n\ndef bfs(graph, n, a, dest):\n    v = [0] * (1 + n)\n    d = [0] * (1 + n)\n    d[a] = 0\n    v[a] = 1\n    q = queue.Queue()\n    q.put(a)\n    while not q.empty():\n        z = q.get()\n        for i in graph[z]:\n            if v[i] == 0:\n                v[i] = 1\n                d[i] = d[z] + 1\n                q.put(i)\n    return d[dest]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    b.sort(reverse=True)\n    i = j = 0\n    while i < n and j < m:\n        if a[i] < b[j]:\n            i += 1\n        elif a[i] > b[j]:\n            j += 1\n        else:\n            i += 1\n            j += 1\n    if j == m:\n        print('NO')\n    else:\n        ans = []\n        for i in range(j + 1, m):\n            ans.append(b[i])\n        ans.sort()\n        for i in range(j + 1):\n            ans.append(b[i])\n        print('YES')\n        for i in ans:\n            print(i, end=' ')\n        print()", "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    front = b[:]\n    back = [front.pop()]\n    ind = 1\n    for i in range(m - 1):\n        if back[-1] > suf[ind]:\n            print('YES')\n            print(*front + back)\n            return\n        if back[-1] < suf[ind]:\n            print('NO')\n            return\n        x = d[suf[ind]].pop()\n        while x <= ind - 2:\n            x = d[suf[ind]].pop()\n        back.append(front.pop())\n        ind = x + 2\n    ans = front + back\n    (i, j) = (0, 0)\n    while i < m and j < n:\n        if ans[i] > a[j]:\n            j += 1\n        elif ans[i] < a[j]:\n            i += 1\n        else:\n            i += 1\n            j += 1\n    if i >= m:\n        print('NO')\n        return\n    print('YES')\n    print(*ans)\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = sorted(list(map(int, input().split())))\n    d = dict()\n    suf = [-1] * (n + 2)\n    for i in range(n - 1, -1, -1):\n        suf[i + 1] = max(suf[i + 2], a[i])\n        d[a[i]] = d.get(a[i], []) + [i]\n    answer()", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    B.sort()\n    srt = sorted(A)\n    i = j = 0\n    while i < n and j < m:\n        if srt[i] == B[j]:\n            i += 1\n            j += 1\n        elif srt[i] > B[j]:\n            j += 1\n        else:\n            i += 1\n    if i == n:\n        if j < m:\n            print('YES')\n            print(*B)\n        else:\n            (i, j) = (0, m - 1)\n            res = []\n            while i < n and j >= 0:\n                if A[i] < B[j]:\n                    i += 1\n                elif A[i] == B[j]:\n                    res.append(B[j])\n                    i += 1\n                    j -= 1\n                else:\n                    j -= 1\n            if j >= 0:\n                B = B[:j] + res + [B[j]]\n                print('YES')\n                print(*B)\n            else:\n                print('NO')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ni = list(map(int, input().split()))\n    mi = list(map(int, input().split()))\n    mi.sort()\n    maxi = ni[-1]\n    li = [maxi]\n    for i in range(n - 2, -1, -1):\n        if ni[i] >= maxi:\n            maxi = ni[i]\n            li.append(maxi)\n    f = 1\n    k = m - 1\n    x = len(li)\n    for i in range(x):\n        if li[x - 1 - i] > mi[k]:\n            f = 0\n            break\n        elif li[x - 1 - i] < mi[k]:\n            f = 1\n            break\n        else:\n            k = k - 1\n            if k < 0:\n                f = 0\n                break\n    if f:\n        print('YES')\n        for i in range(k):\n            print(mi[i], end=' ')\n        for i in range(m - 1, k - 1, -1):\n            print(mi[i], end=' ')\n        print()\n    else:\n        print('NO')", "T = int(input())\nfor t in range(T):\n    (n, m) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    if max(b) < max(a):\n        print('NO')\n    elif max(b) > max(a):\n        print('YES')\n        b.sort()\n        print(*b, sep=' ')\n    else:\n        mx = []\n        for i in range(n):\n            mx.append([-1, -1])\n        mx[n - 1] = [a[n - 1], n - 1]\n        i = n - 2\n        while i >= 0:\n            if a[i] >= mx[i + 1][0]:\n                mx[i] = [a[i], i]\n            else:\n                mx[i] = [mx[i + 1][0], mx[i + 1][1]]\n            i -= 1\n        decrease = [i for i in b]\n        decrease.sort(reverse=True)\n        ans = []\n        i = 0\n        j = 0\n        found = True\n        while i != n and j != m:\n            num = mx[i][0]\n            idx = mx[i][1]\n            if num > decrease[j]:\n                found = False\n                break\n            elif num < decrease[j]:\n                found = True\n                break\n            else:\n                ans.append(num)\n                i = idx + 1\n            j += 1\n        if not found:\n            print('NO')\n        else:\n            l = len(ans)\n            if l == m:\n                print('NO')\n            else:\n                answer = [i for i in decrease[l + 1:]]\n                answer = answer[::-1]\n                answer.extend(ans)\n                answer.append(decrease[l])\n                print('YES')\n                print(*answer, sep=' ')", "t = int(input())\nfor _ in range(t):\n    (n, m) = [int(i) for i in input().split()]\n    a_inp = input().split()\n    b_inp = input().split()\n    a = [int(i) for i in a_inp]\n    b = [int(i) for i in b_inp]\n    b = sorted(b)\n    mex = -1\n    final_a = []\n    for i in range(n - 1, -1, -1):\n        if a[i] >= mex:\n            mex = a[i]\n            final_a.append(a[i])\n    final_a = final_a[::-1]\n    flag = True ^ False\n    curr_b = m - 1\n    for i in final_a:\n        if b[curr_b] > i:\n            break\n        if b[curr_b] < i:\n            print('NO')\n            flag = False\n            break\n        else:\n            if curr_b == 0:\n                print('NO')\n                flag = False\n                break\n            curr_b -= 1\n    if flag != 0:\n        b_new = []\n        for i in range(0, curr_b):\n            b_new.append(b[i])\n        for i in range(m - 1, curr_b - 1, -1):\n            b_new.append(b[i])\n        print('YES')\n        print(' '.join([str(i) for i in b_new]))", "t = int(input())\n\ndef str_arr(a):\n    return ' '.join(map(str, a))\nfor _ in range(t):\n    (n, m) = [int(i) for i in input().strip().split()]\n    a = [int(i) for i in input().strip().split()]\n    b = [int(i) for i in input().strip().split()]\n    b.sort()\n    cur_max = -float('inf')\n    a_eff = []\n    for i in range(n - 1, -1, -1):\n        if a[i] >= cur_max:\n            cur_max = a[i]\n            a_eff.append(a[i])\n    a_eff = a_eff[::-1]\n    flag = True\n    b_pointer = m - 1\n    for i in a_eff:\n        if b[b_pointer] > i:\n            break\n        if b[b_pointer] < i:\n            print('NO')\n            flag = False\n            break\n        else:\n            if b_pointer == 0:\n                print('NO')\n                flag = False\n                break\n            b_pointer -= 1\n    if flag:\n        b_new = []\n        print('YES')\n        for i in range(0, b_pointer):\n            b_new.append(b[i])\n        for i in range(m - 1, b_pointer - 1, -1):\n            b_new.append(b[i])\n        print(str_arr(b_new))", "import sys\ninput = sys.stdin.readline\nnum_test_cases = int(input())\nfor test_case_ittr in range(num_test_cases):\n    (n, m) = [int(x) for x in input().split()]\n    opponent_lineup = [int(x) for x in input().strip().split()]\n    lineup = [int(x) for x in input().split()]\n    lineup.sort()\n    j = len(lineup) - 1\n    ans = []\n    can_win = True\n    for opponent in opponent_lineup:\n        if lineup[j] == opponent:\n            ans += [lineup[j]]\n            j -= 1\n            if j < 0:\n                can_win = False\n                break\n        elif lineup[j] < opponent:\n            can_win = False\n            break\n    if can_win:\n        ans = lineup[:j] + ans + [lineup[j]]\n        print('YES')\n        print(*ans)\n    else:\n        print('NO')", "I = lambda : list(map(int, input().split()))\nfrom collections import Counter as cc\n(t,) = I()\nfor _ in range(t):\n    (n, m) = I()\n    ar = I()\n    l = sorted(I())\n    srt = sorted(ar)\n    pos = 1\n    j = i = 0\n    while i < n and j < m:\n        if srt[i] == l[j]:\n            j += 1\n            i += 1\n        elif srt[i] > l[j]:\n            j += 1\n        else:\n            i += 1\n    if i == n:\n        if j < m:\n            print('YES')\n            print(*l)\n        else:\n            i = 0\n            j = m - 1\n            rem = []\n            while i < n and j >= 0:\n                if ar[i] < l[j]:\n                    i += 1\n                elif ar[i] == l[j]:\n                    rem.append(l[j])\n                    i += 1\n                    j -= 1\n                else:\n                    j = -1\n                    break\n            if j >= 0:\n                l = l[:j] + rem + [l[j]]\n                print('YES')\n                print(*l)\n            else:\n                print('NO')\n    else:\n        print('NO')"]