["import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\nfor _ in range(int(input())):\n    n = int(input())\n    graph = defaultdict(list)\n    M = 10 ** 9 + 7\n    for _ in range(n - 1):\n        (a, b) = [int(i) for i in input().split()]\n        graph[a].append(b)\n        graph[b].append(a)\n    arr = [int(i) for i in input().split()]\n    ans = []\n\n    def helper(node, prev):\n        min_vals = []\n        max_vals = []\n        curr = arr[node - 1]\n        for ele in graph[node]:\n            if ele != prev:\n                (a, b) = helper(ele, node)\n                min_vals.append((a, ele))\n                max_vals.append((b, ele))\n        if not len(min_vals):\n            ans.append(curr)\n            return (min(1, curr), max(1, curr))\n        min_vals.sort()\n        max_vals.sort(reverse=True)\n        temp = [1]\n        temp.append(curr * min_vals[0][0])\n        temp.append(curr * max_vals[0][0])\n        if len(min_vals) == 1:\n            u = min_vals[0][0]\n            ans.append(u * curr)\n            u = max_vals[0][0]\n            ans.append(u * curr)\n        else:\n            (u1, v1) = (min_vals[0][0], min_vals[1][0])\n            ans.append(u1 * v1 * curr)\n            (u2, v2) = (max_vals[0][0], max_vals[1][0])\n            ans.append(u2 * v2 * curr)\n            if min_vals[0][1] == max_vals[0][1]:\n                ans.append(u1 * v2 * curr)\n                ans.append(u2 * v1 * curr)\n            else:\n                ans.append(u1 * u2 * curr)\n        return (min(temp), max(temp))\n    helper(1, n + 1)\n    print(max(ans) % M)", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\nfor _ in range(int(input())):\n    n = int(input())\n    graph = defaultdict(list)\n    M = 10 ** 9 + 7\n    for _ in range(n - 1):\n        (a, b) = [int(i) for i in input().split()]\n        graph[a].append(b)\n        graph[b].append(a)\n    arr = [int(i) for i in input().split()]\n    ans = []\n\n    def helper(node, prev):\n        min_vals = []\n        max_vals = []\n        curr = arr[node - 1]\n        for ele in graph[node]:\n            if ele != prev:\n                (a, b) = helper(ele, node)\n                min_vals.append((a, ele))\n                max_vals.append((b, ele))\n        if not len(min_vals):\n            ans.append(curr)\n            return (min(1, curr), max(1, curr))\n        min_vals.sort()\n        max_vals.sort(reverse=True)\n        temp = [1]\n        temp.append(curr * min_vals[0][0])\n        temp.append(curr * max_vals[0][0])\n        if len(min_vals) == 1:\n            u = min_vals[0][0]\n            ans.append(u * curr)\n            u = max_vals[0][0]\n            ans.append(u * curr)\n        else:\n            (u1, v1) = (min_vals[0][0], min_vals[1][0])\n            ans.append(u1 * v1 * curr)\n            (u2, v2) = (max_vals[0][0], max_vals[1][0])\n            ans.append(u2 * v2 * curr)\n            if min_vals[0][1] == max_vals[0][1]:\n                ans.append(u1 * v2 * curr)\n                ans.append(u2 * v1 * curr)\n            else:\n                ans.append(u1 * u2 * curr)\n        return (min(temp), max(temp))\n    helper(1, n + 1)\n    print(max(ans) % M)", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\nfor _ in range(int(input())):\n    n = int(input())\n    graph = defaultdict(list)\n    M = 10 ** 9 + 7\n    for _ in range(n - 1):\n        (a, b) = [int(i) for i in input().split()]\n        graph[a].append(b)\n        graph[b].append(a)\n    arr = [int(i) for i in input().split()]\n    ans = []\n\n    def helper(node, prev):\n        min_vals = []\n        max_vals = []\n        curr = arr[node - 1]\n        for ele in graph[node]:\n            if ele != prev:\n                (a, b) = helper(ele, node)\n                min_vals.append((a, ele))\n                max_vals.append((b, ele))\n        if not len(min_vals):\n            ans.append(curr)\n            return (min(1, curr), max(1, curr))\n        min_vals.sort()\n        max_vals.sort(reverse=True)\n        temp = [1]\n        temp.append(curr * min_vals[0][0])\n        temp.append(curr * max_vals[0][0])\n        if len(min_vals) == 1:\n            u = min_vals[0][0]\n            ans.append(u * curr)\n            u = max_vals[0][0]\n            ans.append(u * curr)\n        else:\n            (u1, v1) = (min_vals[0][0], min_vals[1][0])\n            ans.append(u1 * v1 * curr)\n            (u2, v2) = (max_vals[0][0], max_vals[1][0])\n            ans.append(u2 * v2 * curr)\n            if min_vals[0][1] == max_vals[0][1]:\n                ans.append(u1 * v2 * curr)\n                ans.append(u2 * v1 * curr)\n            else:\n                ans.append(u1 * u2 * curr)\n        return (min(temp), max(temp))\n    helper(1, n + 1)\n    print(max(ans) % M)", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    graph = defaultdict(list)\n    M = 10 ** 9 + 7\n    for _ in range(n - 1):\n        (a, b) = [int(i) for i in input().split()]\n        graph[a].append(b)\n        graph[b].append(a)\n    arr = [int(i) for i in input().split()]\n    ans = []\n\n    def helper(node, prev):\n        min_vals = []\n        max_vals = []\n        curr = arr[node - 1]\n        for ele in graph[node]:\n            if ele == prev:\n                continue\n            else:\n                (a, b) = helper(ele, node)\n                min_vals.append((a, ele))\n                max_vals.append((b, ele))\n        if len(min_vals) == 0:\n            ans.append(curr)\n            return (min(1, curr), max(1, curr))\n        min_vals.sort()\n        max_vals.sort(reverse=True)\n        temp = [1]\n        temp.append(curr * min_vals[0][0])\n        temp.append(curr * max_vals[0][0])\n        if len(min_vals) == 1:\n            u = min_vals[0][0]\n            ans.append(u * curr)\n            u = max_vals[0][0]\n            ans.append(u * curr)\n        else:\n            (u1, v1) = (min_vals[0][0], min_vals[1][0])\n            ans.append(u1 * v1 * curr)\n            (u2, v2) = (max_vals[0][0], max_vals[1][0])\n            ans.append(u2 * v2 * curr)\n            if min_vals[0][1] == max_vals[0][1]:\n                ans.append(u1 * v2 * curr)\n                ans.append(u2 * v1 * curr)\n            else:\n                ans.append(u1 * u2 * curr)\n        return (min(temp), max(temp))\n    helper(1, n + 1)\n    print(max(ans) % M)"]