["from sys import stdin\ninput = stdin.readline\nfrom queue import Queue\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        bit = self.bit = list(x)\n        size = self.size = len(bit)\n        for i in range(size):\n            j = i | i + 1\n            if j < size:\n                bit[j] += bit[i]\n\n    def update(self, idx, x):\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return (idx + 1, k)\nblock_size = 700\n\nclass SortedList:\n\n    def __init__(self):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.fenwick = FenwickTree([0])\n        self.size = 0\n\n    def insert(self, x):\n        i = lower_bound(self.macro, x)\n        j = upper_bound(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        if len(self.micros[i]) >= block_size:\n            self.micros[i:i + 1] = (self.micros[i][:block_size >> 1], self.micros[i][block_size >> 1:])\n            self.micro_size[i:i + 1] = (block_size >> 1, block_size >> 1)\n            self.fenwick = FenwickTree(self.micro_size)\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=0):\n        (i, j) = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        return self.micros[i].pop(j)\n\n    def __getitem__(self, k):\n        (i, j) = self._find_kth(k)\n        return self.micros[i][j]\n\n    def __contains__(self, x):\n        i = lower_bound(self.macro, x)\n        j = lower_bound(self.micros[i], x)\n        (i, j) = (i, j) if j < self.micro_size[i] else (i + 1, 0)\n        return i < len(self.micros) and j < self.micros_size[i] and (self.micros[i][j] == x)\n\n    def lower_bound(self, x):\n        i = lower_bound(self.macro, x)\n        return self.fenwick(i) + lower_bound(self.micros[i], x)\n\n    def upper_bound(self, x):\n        i = upper_bound(self.macro, x)\n        return self.fenwick(i) + upper_bound(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.fenwick.find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\n\n    def count(self, x):\n        return self.upper_bound(x) - self.lower_bound(x)\n\ndef helper(s1, s2):\n    a = list(s1)\n    b = list(s2)\n    a.sort()\n    b.sort()\n    if a == b:\n        d1 = {}\n        d2 = {}\n        v1 = [0] * len(s1)\n        v2 = [0] * len(s2)\n        for i in range(len(s1)):\n            if s1[i] not in d1:\n                d1[s1[i]] = Queue()\n            d1[s1[i]].put(i)\n            if s2[i] not in d2:\n                d2[s2[i]] = Queue()\n            d2[s2[i]].put(i)\n        c = SortedList()\n        d = SortedList()\n        curr = 0\n        i = 0\n        j = 0\n        cc = 0\n        while i < len(s1) and j < len(s2):\n            e = d2[s1[i]].queue[0]\n            f = len(d) - d.upper_bound(e)\n            g = d1[s2[j]].queue[0]\n            h = len(c) - c.upper_bound(g)\n            if e + f - i <= g + h - j:\n                d.insert(e)\n                d2[s1[i]].get()\n                d1[s1[i]].get()\n                curr += e + f - cc\n                v2[e] = 1\n                i += 1\n            else:\n                c.insert(g)\n                d1[s2[j]].get()\n                d2[s2[j]].get()\n                curr += g + h - cc\n                v1[g] = 1\n                j += 1\n            cc += 1\n            while i < len(s1) and v1[i] == 1:\n                i += 1\n            while j < len(s2) and v2[j] == 1:\n                j += 1\n        return curr\n    else:\n        return -1\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        s = input().strip()\n        a.append(s)\n    ans = 0\n    p = 1\n    for i in range(m // 2):\n        s1 = ''\n        s2 = ''\n        for j in range(n):\n            s1 += a[j][i]\n            s2 += a[j][m - i - 1]\n        cu = helper(s1, s2)\n        if cu == -1:\n            p = 0\n            break\n        else:\n            ans += cu\n    if p:\n        print(ans)\n    else:\n        print(-1)", "from sys import stdin\ninput = stdin.readline\nfrom queue import Queue\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        bit = self.bit = list(x)\n        size = self.size = len(bit)\n        for i in range(size):\n            j = i | i + 1\n            if j < size:\n                bit[j] += bit[i]\n\n    def update(self, idx, x):\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return (idx + 1, k)\nblock_size = 700\n\nclass SortedList:\n\n    def __init__(self):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.fenwick = FenwickTree([0])\n        self.size = 0\n\n    def insert(self, x):\n        i = lower_bound(self.macro, x)\n        j = upper_bound(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        if len(self.micros[i]) >= block_size:\n            self.micros[i:i + 1] = (self.micros[i][:block_size >> 1], self.micros[i][block_size >> 1:])\n            self.micro_size[i:i + 1] = (block_size >> 1, block_size >> 1)\n            self.fenwick = FenwickTree(self.micro_size)\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=0):\n        (i, j) = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        return self.micros[i].pop(j)\n\n    def __getitem__(self, k):\n        (i, j) = self._find_kth(k)\n        return self.micros[i][j]\n\n    def __contains__(self, x):\n        i = lower_bound(self.macro, x)\n        j = lower_bound(self.micros[i], x)\n        (i, j) = (i, j) if j < self.micro_size[i] else (i + 1, 0)\n        return i < len(self.micros) and j < self.micros_size[i] and (self.micros[i][j] == x)\n\n    def lower_bound(self, x):\n        i = lower_bound(self.macro, x)\n        return self.fenwick(i) + lower_bound(self.micros[i], x)\n\n    def upper_bound(self, x):\n        i = upper_bound(self.macro, x)\n        return self.fenwick(i) + upper_bound(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.fenwick.find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\n\n    def count(self, x):\n        return self.upper_bound(x) - self.lower_bound(x)\n\ndef helper(s1, s2):\n    a = list(s1)\n    b = list(s2)\n    a.sort()\n    b.sort()\n    if a == b:\n        d1 = {}\n        d2 = {}\n        v1 = [0] * len(s1)\n        v2 = [0] * len(s2)\n        for i in range(len(s1)):\n            if s1[i] not in d1:\n                d1[s1[i]] = Queue()\n            d1[s1[i]].put(i)\n            if s2[i] not in d2:\n                d2[s2[i]] = Queue()\n            d2[s2[i]].put(i)\n        c = SortedList()\n        d = SortedList()\n        curr = 0\n        i = 0\n        j = 0\n        cc = 0\n        while i < len(s1) and j < len(s2):\n            e = d2[s1[i]].queue[0]\n            f = len(d) - d.upper_bound(e)\n            g = d1[s2[j]].queue[0]\n            h = len(c) - c.upper_bound(g)\n            if e + f - i <= g + h - j:\n                d.insert(e)\n                d2[s1[i]].get()\n                d1[s1[i]].get()\n                curr += e + f - cc\n                v2[e] = 1\n                i += 1\n            else:\n                c.insert(g)\n                d1[s2[j]].get()\n                d2[s2[j]].get()\n                curr += g + h - cc\n                v1[g] = 1\n                j += 1\n            cc += 1\n            while i < len(s1) and v1[i] == 1:\n                i += 1\n            while j < len(s2) and v2[j] == 1:\n                j += 1\n        return curr\n    else:\n        return -1\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        s = input().strip()\n        a.append(s)\n    ans = 0\n    p = 1\n    for i in range(m // 2):\n        s1 = ''\n        s2 = ''\n        for j in range(n):\n            s1 += a[j][i]\n            s2 += a[j][m - i - 1]\n        cu = helper(s1, s2)\n        if cu == -1:\n            p = 0\n            break\n        else:\n            ans += cu\n    if p:\n        print(ans)\n    else:\n        print(-1)", "from sys import stdin\ninput = stdin.readline\nfrom queue import Queue\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        bit = self.bit = list(x)\n        size = self.size = len(bit)\n        for i in range(size):\n            j = i | i + 1\n            if j < size:\n                bit[j] += bit[i]\n\n    def update(self, idx, x):\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return (idx + 1, k)\nblock_size = 700\n\nclass SortedList:\n\n    def __init__(self):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.fenwick = FenwickTree([0])\n        self.size = 0\n\n    def insert(self, x):\n        i = lower_bound(self.macro, x)\n        j = upper_bound(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        if len(self.micros[i]) >= block_size:\n            self.micros[i:i + 1] = (self.micros[i][:block_size >> 1], self.micros[i][block_size >> 1:])\n            self.micro_size[i:i + 1] = (block_size >> 1, block_size >> 1)\n            self.fenwick = FenwickTree(self.micro_size)\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=0):\n        (i, j) = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        return self.micros[i].pop(j)\n\n    def __getitem__(self, k):\n        (i, j) = self._find_kth(k)\n        return self.micros[i][j]\n\n    def __contains__(self, x):\n        i = lower_bound(self.macro, x)\n        j = lower_bound(self.micros[i], x)\n        (i, j) = (i, j) if j < self.micro_size[i] else (i + 1, 0)\n        return i < len(self.micros) and j < self.micros_size[i] and (self.micros[i][j] == x)\n\n    def lower_bound(self, x):\n        i = lower_bound(self.macro, x)\n        return self.fenwick(i) + lower_bound(self.micros[i], x)\n\n    def upper_bound(self, x):\n        i = upper_bound(self.macro, x)\n        return self.fenwick(i) + upper_bound(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.fenwick.find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\n\n    def count(self, x):\n        return self.upper_bound(x) - self.lower_bound(x)\n\ndef helper(s1, s2):\n    a = list(s1)\n    b = list(s2)\n    a.sort()\n    b.sort()\n    if a == b:\n        d1 = {}\n        d2 = {}\n        v1 = [0] * len(s1)\n        v2 = [0] * len(s2)\n        for i in range(len(s1)):\n            if s1[i] not in d1:\n                d1[s1[i]] = Queue()\n            d1[s1[i]].put(i)\n            if s2[i] not in d2:\n                d2[s2[i]] = Queue()\n            d2[s2[i]].put(i)\n        c = SortedList()\n        d = SortedList()\n        curr = 0\n        i = 0\n        j = 0\n        cc = 0\n        while i < len(s1) and j < len(s2):\n            e = d2[s1[i]].queue[0]\n            f = len(d) - d.upper_bound(e)\n            g = d1[s2[j]].queue[0]\n            h = len(c) - c.upper_bound(g)\n            if e + f - i <= g + h - j:\n                d.insert(e)\n                d2[s1[i]].get()\n                d1[s1[i]].get()\n                curr += e + f - cc\n                v2[e] = 1\n                i += 1\n            else:\n                c.insert(g)\n                d1[s2[j]].get()\n                d2[s2[j]].get()\n                curr += g + h - cc\n                v1[g] = 1\n                j += 1\n            cc += 1\n            while i < len(s1) and v1[i] == 1:\n                i += 1\n            while j < len(s2) and v2[j] == 1:\n                j += 1\n        return curr\n    else:\n        return -1\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        s = input().strip()\n        a.append(s)\n    ans = 0\n    p = 1\n    for i in range(m // 2):\n        s1 = ''\n        s2 = ''\n        for j in range(n):\n            s1 += a[j][i]\n            s2 += a[j][m - i - 1]\n        cu = helper(s1, s2)\n        if cu == -1:\n            p = 0\n            break\n        else:\n            ans += cu\n    if p:\n        print(ans)\n    else:\n        print(-1)", "from sys import stdin\ninput = stdin.readline\nfrom queue import Queue\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        bit = self.bit = list(x)\n        size = self.size = len(bit)\n        for i in range(size):\n            j = i | i + 1\n            if j < size:\n                bit[j] += bit[i]\n\n    def update(self, idx, x):\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return (idx + 1, k)\nblock_size = 700\n\nclass SortedList:\n\n    def __init__(self):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.fenwick = FenwickTree([0])\n        self.size = 0\n\n    def insert(self, x):\n        i = lower_bound(self.macro, x)\n        j = upper_bound(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        if len(self.micros[i]) >= block_size:\n            self.micros[i:i + 1] = (self.micros[i][:block_size >> 1], self.micros[i][block_size >> 1:])\n            self.micro_size[i:i + 1] = (block_size >> 1, block_size >> 1)\n            self.fenwick = FenwickTree(self.micro_size)\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=0):\n        (i, j) = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        return self.micros[i].pop(j)\n\n    def __getitem__(self, k):\n        (i, j) = self._find_kth(k)\n        return self.micros[i][j]\n\n    def __contains__(self, x):\n        i = lower_bound(self.macro, x)\n        j = lower_bound(self.micros[i], x)\n        (i, j) = (i, j) if j < self.micro_size[i] else (i + 1, 0)\n        return i < len(self.micros) and j < self.micros_size[i] and (self.micros[i][j] == x)\n\n    def lower_bound(self, x):\n        i = lower_bound(self.macro, x)\n        return self.fenwick(i) + lower_bound(self.micros[i], x)\n\n    def upper_bound(self, x):\n        i = upper_bound(self.macro, x)\n        return self.fenwick(i) + upper_bound(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.fenwick.find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\n\n    def count(self, x):\n        return self.upper_bound(x) - self.lower_bound(x)\n\ndef helper(s1, s2):\n    a = list(s1)\n    b = list(s2)\n    a.sort()\n    b.sort()\n    if a == b:\n        d1 = {}\n        d2 = {}\n        v1 = [0] * len(s1)\n        v2 = [0] * len(s2)\n        for i in range(len(s1)):\n            if s1[i] not in d1:\n                d1[s1[i]] = Queue()\n            d1[s1[i]].put(i)\n            if s2[i] not in d2:\n                d2[s2[i]] = Queue()\n            d2[s2[i]].put(i)\n        c = SortedList()\n        d = SortedList()\n        curr = 0\n        i = 0\n        j = 0\n        cc = 0\n        while i < len(s1) and j < len(s2):\n            e = d2[s1[i]].queue[0]\n            f = len(d) - d.upper_bound(e)\n            g = d1[s2[j]].queue[0]\n            h = len(c) - c.upper_bound(g)\n            if e + f - i <= g + h - j:\n                d.insert(e)\n                d2[s1[i]].get()\n                d1[s1[i]].get()\n                curr += e + f - cc\n                v2[e] = 1\n                i += 1\n            else:\n                c.insert(g)\n                d1[s2[j]].get()\n                d2[s2[j]].get()\n                curr += g + h - cc\n                v1[g] = 1\n                j += 1\n            cc += 1\n            while i < len(s1) and v1[i] == 1:\n                i += 1\n            while j < len(s2) and v2[j] == 1:\n                j += 1\n        return curr\n    else:\n        return -1\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        s = input().strip()\n        a.append(s)\n    ans = 0\n    p = 1\n    for i in range(m // 2):\n        s1 = ''\n        s2 = ''\n        for j in range(n):\n            s1 += a[j][i]\n            s2 += a[j][m - i - 1]\n        cu = helper(s1, s2)\n        if cu == -1:\n            p = 0\n            break\n        else:\n            ans += cu\n    if p:\n        print(ans)\n    else:\n        print(-1)", "from sys import stdin\ninput = stdin.readline\nfrom queue import Queue\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        bit = self.bit = list(x)\n        size = self.size = len(bit)\n        for i in range(size):\n            j = i | i + 1\n            if j < size:\n                bit[j] += bit[i]\n\n    def update(self, idx, x):\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return (idx + 1, k)\nblock_size = 700\n\nclass SortedList:\n\n    def __init__(self):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.fenwick = FenwickTree([0])\n        self.size = 0\n\n    def insert(self, x):\n        i = lower_bound(self.macro, x)\n        j = upper_bound(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        if len(self.micros[i]) >= block_size:\n            self.micros[i:i + 1] = (self.micros[i][:block_size >> 1], self.micros[i][block_size >> 1:])\n            self.micro_size[i:i + 1] = (block_size >> 1, block_size >> 1)\n            self.fenwick = FenwickTree(self.micro_size)\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=0):\n        (i, j) = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        return self.micros[i].pop(j)\n\n    def __getitem__(self, k):\n        (i, j) = self._find_kth(k)\n        return self.micros[i][j]\n\n    def __contains__(self, x):\n        i = lower_bound(self.macro, x)\n        j = lower_bound(self.micros[i], x)\n        (i, j) = (i, j) if j < self.micro_size[i] else (i + 1, 0)\n        return i < len(self.micros) and j < self.micros_size[i] and (self.micros[i][j] == x)\n\n    def lower_bound(self, x):\n        i = lower_bound(self.macro, x)\n        return self.fenwick(i) + lower_bound(self.micros[i], x)\n\n    def upper_bound(self, x):\n        i = upper_bound(self.macro, x)\n        return self.fenwick(i) + upper_bound(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.fenwick.find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\n\n    def count(self, x):\n        return self.upper_bound(x) - self.lower_bound(x)\n\ndef helper(s1, s2):\n    a = list(s1)\n    b = list(s2)\n    a.sort()\n    b.sort()\n    if a == b:\n        d1 = {}\n        d2 = {}\n        v1 = [0] * len(s1)\n        v2 = [0] * len(s2)\n        for i in range(len(s1)):\n            if s1[i] not in d1:\n                d1[s1[i]] = Queue()\n            d1[s1[i]].put(i)\n            if s2[i] not in d2:\n                d2[s2[i]] = Queue()\n            d2[s2[i]].put(i)\n        c = SortedList()\n        d = SortedList()\n        curr = 0\n        i = 0\n        j = 0\n        cc = 0\n        while i < len(s1) and j < len(s2):\n            e = d2[s1[i]].queue[0]\n            f = len(d) - d.upper_bound(e)\n            g = d1[s2[j]].queue[0]\n            h = len(c) - c.upper_bound(g)\n            if e + f - i <= g + h - j:\n                d.insert(e)\n                d2[s1[i]].get()\n                d1[s1[i]].get()\n                curr += e + f - cc\n                v2[e] = 1\n                i += 1\n            else:\n                c.insert(g)\n                d1[s2[j]].get()\n                d2[s2[j]].get()\n                curr += g + h - cc\n                v1[g] = 1\n                j += 1\n            cc += 1\n            while i < len(s1) and v1[i] == 1:\n                i += 1\n            while j < len(s2) and v2[j] == 1:\n                j += 1\n        return curr\n    else:\n        return -1\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        s = input().strip()\n        a.append(s)\n    ans = 0\n    p = 1\n    for i in range(m // 2):\n        s1 = ''\n        s2 = ''\n        for j in range(n):\n            s1 += a[j][i]\n            s2 += a[j][m - i - 1]\n        cu = helper(s1, s2)\n        if cu == -1:\n            p = 0\n            break\n        else:\n            ans += cu\n    if p:\n        print(ans)\n    else:\n        print(-1)", "from collections import defaultdict\n\ndef chk(s, t):\n    h = defaultdict(list)\n    pos = []\n    for i in range(len(s)):\n        h[s[i]].append(i)\n    for i in range(len(t)):\n        if t[i] not in h or len(h[t[i]]) == 0:\n            return -1\n        pos.append(h[t[i]][0])\n        h[t[i]].pop(0)\n    return pos\n\ndef mergesort(arr):\n    length = len(arr)\n    count = 0\n    if length > 1:\n        (left, right) = (0, length)\n        mid = left + (right - left) // 2\n        (leftarray, a) = mergesort(arr[left:mid])\n        (rightarray, b) = mergesort(arr[mid:right])\n        count += a + b\n        (i, j, k) = (0, 0, 0)\n        while i < len(leftarray) and j < len(rightarray):\n            if leftarray[i] <= rightarray[j]:\n                arr[k] = leftarray[i]\n                i += 1\n            else:\n                arr[k] = rightarray[j]\n                count += len(leftarray) - i\n                j += 1\n            k += 1\n        while i < len(leftarray):\n            arr[k] = leftarray[i]\n            k += 1\n            i += 1\n        while j < len(rightarray):\n            arr[k] = rightarray[j]\n            k += 1\n            j += 1\n    return (arr, count)\nt = int(input())\nfor _ in range(t):\n    (N, M) = map(int, input().split(' '))\n    arr = []\n    for l in range(N):\n        arr.append(list(input()))\n    res = 0\n    chek = False\n    for j in range(M // 2):\n        (s, t) = ('', '')\n        for i in range(N):\n            s += arr[i][j]\n            t += arr[i][M - j - 1]\n        pos = chk(s, t)\n        if pos == -1:\n            print(-1)\n            chek = True\n            break\n        res += mergesort(pos)[1]\n    if not chek:\n        print(res)", "from sys import stdin\ninput = stdin.readline\nfrom queue import Queue\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        bit = self.bit = list(x)\n        size = self.size = len(bit)\n        for i in range(size):\n            j = i | i + 1\n            if j < size:\n                bit[j] += bit[i]\n\n    def update(self, idx, x):\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return (idx + 1, k)\nblock_size = 700\n\nclass SortedList:\n\n    def __init__(self):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.fenwick = FenwickTree([0])\n        self.size = 0\n\n    def insert(self, x):\n        i = lower_bound(self.macro, x)\n        j = upper_bound(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        if len(self.micros[i]) >= block_size:\n            self.micros[i:i + 1] = (self.micros[i][:block_size >> 1], self.micros[i][block_size >> 1:])\n            self.micro_size[i:i + 1] = (block_size >> 1, block_size >> 1)\n            self.fenwick = FenwickTree(self.micro_size)\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=0):\n        (i, j) = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        return self.micros[i].pop(j)\n\n    def __getitem__(self, k):\n        (i, j) = self._find_kth(k)\n        return self.micros[i][j]\n\n    def __contains__(self, x):\n        i = lower_bound(self.macro, x)\n        j = lower_bound(self.micros[i], x)\n        (i, j) = (i, j) if j < self.micro_size[i] else (i + 1, 0)\n        return i < len(self.micros) and j < self.micros_size[i] and (self.micros[i][j] == x)\n\n    def lower_bound(self, x):\n        i = lower_bound(self.macro, x)\n        return self.fenwick(i) + lower_bound(self.micros[i], x)\n\n    def upper_bound(self, x):\n        i = upper_bound(self.macro, x)\n        return self.fenwick(i) + upper_bound(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.fenwick.find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\n\n    def count(self, x):\n        return self.upper_bound(x) - self.lower_bound(x)\n\ndef helper(s1, s2):\n    a = list(s1)\n    b = list(s2)\n    a.sort()\n    b.sort()\n    if a == b:\n        d1 = {}\n        d2 = {}\n        v1 = [0] * len(s1)\n        v2 = [0] * len(s2)\n        for i in range(len(s1)):\n            if s1[i] not in d1:\n                d1[s1[i]] = Queue()\n            d1[s1[i]].put(i)\n            if s2[i] not in d2:\n                d2[s2[i]] = Queue()\n            d2[s2[i]].put(i)\n        c = SortedList()\n        d = SortedList()\n        curr = 0\n        i = 0\n        j = 0\n        cc = 0\n        while i < len(s1) and j < len(s2):\n            e = d2[s1[i]].queue[0]\n            f = len(d) - d.upper_bound(e)\n            g = d1[s2[j]].queue[0]\n            h = len(c) - c.upper_bound(g)\n            if e + f - i <= g + h - j:\n                d.insert(e)\n                d2[s1[i]].get()\n                d1[s1[i]].get()\n                curr += e + f - cc\n                v2[e] = 1\n                i += 1\n            else:\n                c.insert(g)\n                d1[s2[j]].get()\n                d2[s2[j]].get()\n                curr += g + h - cc\n                v1[g] = 1\n                j += 1\n            cc += 1\n            while i < len(s1) and v1[i] == 1:\n                i += 1\n            while j < len(s2) and v2[j] == 1:\n                j += 1\n        return curr\n    else:\n        return -1\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        s = input().strip()\n        a.append(s)\n    ans = 0\n    p = 1\n    for i in range(m // 2):\n        s1 = ''\n        s2 = ''\n        for j in range(n):\n            s1 += a[j][i]\n            s2 += a[j][m - i - 1]\n        cu = helper(s1, s2)\n        if cu == -1:\n            p = 0\n            break\n        else:\n            ans += cu\n    if p:\n        print(ans)\n    else:\n        print(-1)", "from sys import stdin\ninput = stdin.readline\nfrom queue import Queue\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        bit = self.bit = list(x)\n        size = self.size = len(bit)\n        for i in range(size):\n            j = i | i + 1\n            if j < size:\n                bit[j] += bit[i]\n\n    def update(self, idx, x):\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return (idx + 1, k)\nblock_size = 700\n\nclass SortedList:\n\n    def __init__(self):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.fenwick = FenwickTree([0])\n        self.size = 0\n\n    def insert(self, x):\n        i = lower_bound(self.macro, x)\n        j = upper_bound(self.micros[i], x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        if len(self.micros[i]) >= block_size:\n            self.micros[i:i + 1] = (self.micros[i][:block_size >> 1], self.micros[i][block_size >> 1:])\n            self.micro_size[i:i + 1] = (block_size >> 1, block_size >> 1)\n            self.fenwick = FenwickTree(self.micro_size)\n            self.macro.insert(i, self.micros[i + 1][0])\n\n    def pop(self, k=0):\n        (i, j) = self._find_kth(k)\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        return self.micros[i].pop(j)\n\n    def __getitem__(self, k):\n        (i, j) = self._find_kth(k)\n        return self.micros[i][j]\n\n    def __contains__(self, x):\n        i = lower_bound(self.macro, x)\n        j = lower_bound(self.micros[i], x)\n        (i, j) = (i, j) if j < self.micro_size[i] else (i + 1, 0)\n        return i < len(self.micros) and j < self.micros_size[i] and (self.micros[i][j] == x)\n\n    def lower_bound(self, x):\n        i = lower_bound(self.macro, x)\n        return self.fenwick(i) + lower_bound(self.micros[i], x)\n\n    def upper_bound(self, x):\n        i = upper_bound(self.macro, x)\n        return self.fenwick(i) + upper_bound(self.micros[i], x)\n\n    def _find_kth(self, k):\n        return self.fenwick.find_kth(k + self.size if k < 0 else k)\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return (x for micro in self.micros for x in micro)\n\n    def __repr__(self):\n        return str(list(self))\n\n    def count(self, x):\n        return self.upper_bound(x) - self.lower_bound(x)\n\ndef helper(s1, s2):\n    a = list(s1)\n    b = list(s2)\n    a.sort()\n    b.sort()\n    if a == b:\n        d1 = {}\n        d2 = {}\n        v1 = [0] * len(s1)\n        v2 = [0] * len(s2)\n        for i in range(len(s1)):\n            if s1[i] not in d1:\n                d1[s1[i]] = Queue()\n            d1[s1[i]].put(i)\n            if s2[i] not in d2:\n                d2[s2[i]] = Queue()\n            d2[s2[i]].put(i)\n        c = SortedList()\n        d = SortedList()\n        curr = 0\n        i = 0\n        j = 0\n        cc = 0\n        while i < len(s1) and j < len(s2):\n            e = d2[s1[i]].queue[0]\n            f = len(d) - d.upper_bound(e)\n            g = d1[s2[j]].queue[0]\n            h = len(c) - c.upper_bound(g)\n            if e + f - i <= g + h - j:\n                d.insert(e)\n                d2[s1[i]].get()\n                d1[s1[i]].get()\n                curr += e + f - cc\n                v2[e] = 1\n                i += 1\n            else:\n                c.insert(g)\n                d1[s2[j]].get()\n                d2[s2[j]].get()\n                curr += g + h - cc\n                v1[g] = 1\n                j += 1\n            cc += 1\n            while i < len(s1) and v1[i] == 1:\n                i += 1\n            while j < len(s2) and v2[j] == 1:\n                j += 1\n        return curr\n    else:\n        return -1\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        s = input().strip()\n        a.append(s)\n    ans = 0\n    p = 1\n    for i in range(m // 2):\n        s1 = ''\n        s2 = ''\n        for j in range(n):\n            s1 += a[j][i]\n            s2 += a[j][m - i - 1]\n        cu = helper(s1, s2)\n        if cu == -1:\n            p = 0\n            break\n        else:\n            ans += cu\n    if p:\n        print(ans)\n    else:\n        print(-1)"]