["from functools import lru_cache\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\nmod = 998244353\nnum_test_cases = int(input())\nfor test_case_ittr in range(num_test_cases):\n    length = int(input())\n    arr = [int(x) for x in input().split()]\n    parities = [x & 1 for x in arr]\n    if length == 1:\n        print(1)\n        continue\n\n    @lru_cache(None)\n    def DP(i, sum_parity, prev_sum_parity):\n        if i == length:\n            return 0 if sum_parity == prev_sum_parity else 1\n        ret = DP(i + 1, sum_parity ^ parities[i], prev_sum_parity)\n        if sum_parity != prev_sum_parity:\n            ret += DP(i + 1, parities[i], sum_parity)\n        return ret % mod\n    ans = DP(1, parities[0], None)\n    print(ans)\n    DP.cache_clear()", "from functools import lru_cache\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\nmod = 998244353\nnum_test_cases = int(input())\nfor test_case_ittr in range(num_test_cases):\n    length = int(input())\n    arr = [int(x) for x in input().split()]\n    parities = [x & 1 for x in arr]\n    if length == 1:\n        print(1)\n        continue\n\n    @lru_cache(None)\n    def DP(i, sum_parity, prev_sum_parity):\n        if i == length:\n            return 0 if sum_parity == prev_sum_parity else 1\n        ret = DP(i + 1, sum_parity ^ parities[i], prev_sum_parity)\n        if sum_parity != prev_sum_parity:\n            ret += DP(i + 1, parities[i], sum_parity)\n        return ret % mod\n    ans = DP(1, parities[0], None)\n    print(ans)\n    DP.cache_clear()", "from functools import lru_cache\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\nmod = 998244353\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    parities = [x & 1 for x in arr]\n    if n == 1:\n        print(1)\n        continue\n\n    @lru_cache(None)\n    def DP(i, sum_parity, prev_sum_parity):\n        if i == n:\n            return 0 if sum_parity == prev_sum_parity else 1\n        ret = DP(i + 1, sum_parity ^ parities[i], prev_sum_parity)\n        if sum_parity != prev_sum_parity:\n            ret += DP(i + 1, parities[i], sum_parity)\n        return ret % mod\n    ans = DP(1, parities[0], None)\n    print(ans)\n    DP.cache_clear()", "from functools import lru_cache\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\nmod = 998244353\nnum_test_cases = int(input())\nfor test_case_ittr in range(num_test_cases):\n    length = int(input())\n    arr = [int(x) for x in input().split()]\n    parities = [x & 1 for x in arr]\n    if length == 1:\n        print(1)\n        continue\n\n    @lru_cache(None)\n    def DP(i, sum_parity, prev_sum_parity):\n        if i == length:\n            return 0 if sum_parity == prev_sum_parity else 1\n        ret = DP(i + 1, sum_parity ^ parities[i], prev_sum_parity)\n        if sum_parity != prev_sum_parity:\n            ret += DP(i + 1, parities[i], sum_parity)\n        return ret % mod\n    ans = DP(1, parities[0], None)\n    print(ans)\n    DP.cache_clear()", "from functools import lru_cache\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\nmod = 998244353\nnum_test_cases = int(input())\nfor test_case_ittr in range(num_test_cases):\n    length = int(input())\n    arr = [int(x) for x in input().split()]\n    parities = [x & 1 for x in arr]\n    if length == 1:\n        print(1)\n        continue\n\n    @lru_cache(None)\n    def DP(i, sum_parity, prev_sum_parity):\n        if i == length:\n            return 0 if sum_parity == prev_sum_parity else 1\n        ret = DP(i + 1, sum_parity ^ parities[i], prev_sum_parity)\n        if sum_parity != prev_sum_parity:\n            ret += DP(i + 1, parities[i], sum_parity)\n        return ret % mod\n    ans = DP(1, parities[0], None)\n    print(ans)\n    DP.cache_clear()", "MOD = 998244353\n\ndef solve(A, N):\n    dp = [[0] * 2 for i in range(N + 1)]\n    cur_sm = 0\n    (oPrefEven, oPrefOdd) = (0, 0)\n    (ePrefEven, ePrefOdd) = (0, 0)\n    for (i, it) in enumerate(A):\n        ind = i + 1\n        cur_sm += it\n        cur_sm %= 2\n        if cur_sm % 2:\n            dp[ind][1] += 1\n            dp[ind][1] += ePrefEven\n            dp[ind][0] += oPrefOdd\n        else:\n            dp[ind][0] += 1\n            dp[ind][0] += ePrefOdd\n            dp[ind][1] += oPrefEven\n        dp[ind][0] %= MOD\n        dp[ind][1] %= MOD\n        if cur_sm:\n            oPrefEven += dp[ind][0]\n            oPrefOdd += dp[ind][1]\n        else:\n            ePrefEven += dp[ind][0]\n            ePrefOdd += dp[ind][1]\n    return sum(dp[N]) % MOD\nfor case in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(solve(A, N))", "import sys\nM = 998244353\nfrom collections import defaultdict\n\ndef solve(a, n, s, p, dp):\n    key = str(n) + ':' + str(s % 2) + ':' + str(p)\n    if n < 0 and s % 2 == p:\n        return 1\n    if n < 0:\n        return 0\n    if dp[key] != 0:\n        return dp[key]\n    if s % 2 == p:\n        ans = solve(a, n - 1, s + a[n], p, dp) % M + solve(a, n - 1, a[n], not p, dp) % M\n        dp[key] = ans % M\n        return dp[key]\n    dp[key] = solve(a, n - 1, s + a[n], p, dp) % M\n    return dp[key] % M\nfor _ in range(int(input())):\n    n = int(input())\n    dp = defaultdict(int)\n    sys.setrecursionlimit(10 ** 7)\n    a = list(map(int, input().split()))\n    ans = solve(a, n - 2, a[n - 1], True, dp) % M\n    p = solve(a, n - 2, a[n - 1], False, dp) % M\n    print((p + ans) % M)", "M = 998244353\nfrom collections import defaultdict\n\ndef fs(n, a):\n    dp = defaultdict(int)\n    dp[-1, 0, 0] = 1\n    dp[-1, 1, 1] = 1\n    for i in range(n):\n        for k in range(2):\n            for j in range(2):\n                if j == k:\n                    dp[i, j, k] = (dp[i - 1, (j + a[i]) % 2, k] % M + dp[i - 1, a[i] % 2, 1 - k] % M) % M\n                else:\n                    dp[i, j, k] = dp[i - 1, (j + a[i]) % 2, k] % M\n    return (dp[n - 2, a[n - 1] % 2, 1] + dp[n - 2, a[n - 1] % 2, 0]) % M\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = fs(n, a) % M\n    print(f)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    if l[0] % 2 == 0:\n        oe = 1\n        ee = 1\n        oo = 0\n        eo = 0\n        en = 1\n        on = 0\n    else:\n        ee = 0\n        oe = 0\n        eo = 1\n        oo = 1\n        en = 0\n        on = 1\n    for i in l[1:]:\n        if i % 2 == 0:\n            (oo, eo, oe, ee, en, on) = (oo, eo, oe + on, ee + en, oe + on, eo)\n        else:\n            (oo, eo, oe, ee, en, on) = (oe + on, ee + en, oo, eo, oo, en + ee)\n    print((en + on) % 998244353)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    mod = 998244353\n    dp = [1, 1]\n    s = [[1, 1], [0, 0]]\n    p = 0\n    for i in a:\n        p ^= i & 1\n        dp[0] = s[p][1]\n        dp[1] = s[p ^ 1][0]\n        s[p][0] += dp[0]\n        s[p][1] += dp[1]\n        s[p][0] %= mod\n        s[p][1] %= mod\n    print((dp[0] + dp[1]) % mod)", "import math\nmod1 = 998244353\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    l.insert(0, 0)\n    arr = [[[0, 0] for i in range(2)] for j in range(n + 1)]\n    arr[0][1][0] = 1\n    for i in range(1, n + 1):\n        x = l[i] & 1\n        arr[i][0][x] = (arr[i][0][x] + arr[i - 1][1][0]) % mod1\n        arr[i][1][x] = (arr[i][1][x] + arr[i - 1][0][1]) % mod1\n        arr[i][0][0 ^ x] = (arr[i][0][0 ^ x] + arr[i - 1][0][0]) % mod1\n        arr[i][0][1 ^ x] = (arr[i][0][1 ^ x] + arr[i - 1][0][1]) % mod1\n        arr[i][1][0 ^ x] = (arr[i][1][0 ^ x] + arr[i - 1][1][0]) % mod1\n        arr[i][1][1 ^ x] = (arr[i][1][1 ^ x] + arr[i - 1][1][1]) % mod1\n    print((arr[n][1][0] + arr[n][0][1]) % mod1)", "import math\nmod = 998244353\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    l.insert(0, 0)\n    arr = [[[0, 0] for i in range(2)] for j in range(n + 1)]\n    arr[0][1][0] = 1\n    for i in range(1, n + 1):\n        x = l[i] & 1\n        arr[i][0][x] = (arr[i][0][x] + arr[i - 1][1][0]) % mod\n        arr[i][1][x] = (arr[i][1][x] + arr[i - 1][0][1]) % mod\n        arr[i][0][0 ^ x] = (arr[i][0][0 ^ x] + arr[i - 1][0][0]) % mod\n        arr[i][0][1 ^ x] = (arr[i][0][1 ^ x] + arr[i - 1][0][1]) % mod\n        arr[i][1][0 ^ x] = (arr[i][1][0 ^ x] + arr[i - 1][1][0]) % mod\n        arr[i][1][1 ^ x] = (arr[i][1][1 ^ x] + arr[i - 1][1][1]) % mod\n    print((arr[n][1][0] + arr[n][0][1]) % mod)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    mod = 998244353\n    dp = [1, 1]\n    s = [[1, 1], [0, 0]]\n    p = 0\n    for i in a:\n        p ^= i & 1\n        dp[0] = s[p][1]\n        dp[1] = s[p ^ 1][0]\n        s[p][0] += dp[0]\n        s[p][1] += dp[1]\n        s[p][0] %= mod\n        s[p][1] %= mod\n    print((dp[0] + dp[1]) % mod)", "M = 998244353\nfrom collections import defaultdict\n\ndef fs(n, a):\n    dp = defaultdict(int)\n    dp[-1, 0, 0] = 1\n    dp[-1, 1, 1] = 1\n    for i in range(n):\n        for k in range(2):\n            for j in range(2):\n                if j == k:\n                    dp[i, j, k] = (dp[i - 1, (j + a[i]) % 2, k] % M + dp[i - 1, a[i] % 2, 1 - k] % M) % M\n                else:\n                    dp[i, j, k] = dp[i - 1, (j + a[i]) % 2, k] % M\n    return (dp[n - 2, a[n - 1] % 2, 1] + dp[n - 2, a[n - 1] % 2, 0]) % M\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = fs(n, a) % M\n    print(f)", "from sys import stdin, gettrace\nMOD = 998244353\n\ndef solve():\n    n = int(input())\n    aa = [int(a) for a in input().split()]\n    e = 1 - aa[0] % 2\n    o = aa[0] % 2\n    ee = eo = oe = oo = 0\n    for a in aa[1:]:\n        if a % 2 == 0:\n            (e, o, ee, eo, oe, oo) = (e, o, ee + oe + e, eo, eo + oe + o, oo)\n        else:\n            (e, o, ee, eo, oe, oo) = (o, e, eo, ee + oe + e, oo, eo + oe + o)\n        e %= MOD\n        o %= MOD\n        ee %= MOD\n        eo %= MOD\n        oe %= MOD\n        oo %= MOD\n    print((eo + oe + e + o) % MOD)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "M = 998244353\nfrom collections import defaultdict\n\ndef fs(n, a):\n    dp = defaultdict(int)\n    dp[-1, 0, 0] = 1\n    dp[-1, 1, 1] = 1\n    for i in range(n):\n        for k in range(2):\n            for j in range(2):\n                if j == k:\n                    dp[i, j, k] = (dp[i - 1, (j + a[i]) % 2, k] % M + dp[i - 1, a[i] % 2, 1 - k] % M) % M\n                else:\n                    dp[i, j, k] = dp[i - 1, (j + a[i]) % 2, k] % M\n    return (dp[n - 2, a[n - 1] % 2, 1] + dp[n - 2, a[n - 1] % 2, 0]) % M\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = fs(n, a) % M\n    print(f)", "t = int(input())\np = 998244353\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    if l[0] % 2 == 0:\n        oe = 1\n        ee = 1\n        oo = 0\n        eo = 0\n        en = 1\n        on = 0\n    else:\n        ee = 0\n        oe = 0\n        eo = 1\n        oo = 1\n        en = 0\n        on = 1\n    for i in l[1:]:\n        if i % 2 == 0:\n            (oo, eo, oe, ee, en, on) = (oo, eo, (oe + on) % p, (ee + en) % p, (oe + on) % p, eo)\n        else:\n            (oo, eo, oe, ee, en, on) = ((oe + on) % p, (ee + en) % p, oo, eo, oo, (en + ee) % p)\n    print((en + on) % 998244353)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    if l[0] % 2 == 0:\n        oe = 1\n        ee = 1\n        oo = 0\n        eo = 0\n        en = 1\n        on = 0\n    else:\n        ee = 0\n        oe = 0\n        eo = 1\n        oo = 1\n        en = 0\n        on = 1\n    for i in l[1:]:\n        if i % 2 == 0:\n            (oo, eo, oe, ee, en, on) = (oo, eo, oe + on, ee + en, oe + on, eo)\n        else:\n            (oo, eo, oe, ee, en, on) = (oe + on, ee + en, oo, eo, oo, en + ee)\n    print((en + on) % 998244353)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    mod = 998244353\n    dp = []\n    dit = {}\n    idx = -1\n    curr = 0\n    check = []\n    for i in range(n):\n        curr = curr + (arr[i] & 1) & 1\n        check.append(curr)\n        if arr[i] & 1:\n            dit[idx] = i\n            idx = i\n    dit[idx] = float('inf')\n    for i in range(n):\n        dp.append([0, 0])\n    dp.append([1, 1])\n    dp[-2] = [arr[-1] & 1 == 0, arr[-1] & 1]\n    ans_0 = 0\n    ans_1 = 0\n    if check[n - 1] & 1:\n        ans_1 = 1\n    else:\n        ans_0 = 1\n    for i in range(n - 2, -1, -1):\n        if check[i] & 1:\n            ans_1 = (ans_1 + dp[i + 1][0]) % mod\n        else:\n            ans_0 = (ans_0 + dp[i + 1][0]) % mod\n        if arr[i] & 1:\n            odd = 0\n            if check[i] == 1:\n                odd = ans_1\n            else:\n                odd = ans_0\n            even = 0\n            if i in dit and dit[i] != float('inf'):\n                if dit[i] != n - 1:\n                    even = dp[dit[i] + 1][0] + dp[dit[i] + 1][1]\n                else:\n                    even = 1\n        else:\n            odd = dp[i + 1][1]\n            even = dp[i + 1][1] + dp[i + 1][0]\n        dp[i][0] = even % mod\n        dp[i][1] = odd % mod\n    print((dp[0][0] + dp[0][1]) % mod)", "from sys import stdin, gettrace\nMOD = 998244353\n\ndef solve():\n    n = int(input())\n    aa = [int(a) for a in input().split()]\n    e = 1 - aa[0] % 2\n    o = aa[0] % 2\n    ee = eo = oe = oo = 0\n    for a in aa[1:]:\n        if a % 2 == 0:\n            (e, o, ee, eo, oe, oo) = (e, o, ee + oe + e, eo, eo + oe + o, oo)\n        else:\n            (e, o, ee, eo, oe, oo) = (o, e, eo, ee + oe + e, oo, eo + oe + o)\n        e %= MOD\n        o %= MOD\n        ee %= MOD\n        eo %= MOD\n        oe %= MOD\n        oo %= MOD\n    print((eo + oe + e + o) % MOD)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "mod = 998244353\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    a = list(map(int, input().split()))\n    odd = []\n    even = []\n    for i in range(N + 2):\n        odd.append(None)\n        even.append(None)\n    odd[N + 1] = 0\n    even[N + 1] = 0\n    odd[N] = 0\n    even[N] = 1\n    j = N\n    tmp = 0\n    for i in range(N - 1, -1, -1):\n        x = a[i] % 2\n        if x == 0:\n            odd[i] = odd[i + 1]\n            even[i] = (odd[i + 1] + even[i + 1]) % mod\n            tmp = (tmp + even[i]) % mod\n        else:\n            even[i] = (odd[j + 1] + even[j + 1]) % mod\n            odd[i] = (tmp + even[j] + odd[j + 1]) % mod\n            j = i\n            tmp = 0\n    answer = (odd[0] + even[0]) % mod\n    print(answer)", "from functools import lru_cache\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\nmod = 998244353\nnum_test_cases = int(input())\nfor test_case_ittr in range(num_test_cases):\n    length = int(input())\n    arr = [int(x) for x in input().split()]\n    parities = [x & 1 for x in arr]\n    if length == 1:\n        print(1)\n        continue\n\n    @lru_cache(None)\n    def DP(i, sum_parity, prev_sum_parity):\n        if i == length:\n            return 0 if sum_parity == prev_sum_parity else 1\n        ret = DP(i + 1, sum_parity ^ parities[i], prev_sum_parity)\n        if sum_parity != prev_sum_parity:\n            ret += DP(i + 1, parities[i], sum_parity)\n        return ret % mod\n    ans = DP(1, parities[0], None)\n    print(ans)\n    DP.cache_clear()", "T = int(input())\nfor t in range(T):\n    N = int(input())\n    A = list(map(int, input().split(' ')))\n    dp = [[-1, -1, -1, -1] for i in range(N - 1)]\n    if N == 1:\n        print(1)\n    elif N == 2:\n        if A[0] % 2 == A[1] % 2:\n            print(1)\n        else:\n            print(2)\n    else:\n        if A[0] % 2 == 0:\n            dp[0][0] = 1\n            dp[0][1] = 0\n            dp[0][2] = 0\n            dp[0][3] = 2\n        else:\n            dp[0][0] = 1\n            dp[0][1] = 1\n            dp[0][2] = 1\n            dp[0][3] = 0\n        for i in range(1, N - 1):\n            if A[i] % 2 == 0:\n                dp[i][0] = (dp[i - 1][0] + dp[i - 1][2]) % 998244353\n                dp[i][1] = dp[i - 1][1]\n                dp[i][2] = dp[i - 1][2]\n                dp[i][3] = (dp[i - 1][3] + dp[i - 1][0]) % 998244353\n            else:\n                dp[i][0] = (dp[i - 1][3] + dp[i - 1][1]) % 998244353\n                dp[i][1] = dp[i - 1][0]\n                dp[i][2] = dp[i - 1][3]\n                dp[i][3] = (dp[i - 1][2] + dp[i - 1][1]) % 998244353\n        if A[N - 1] % 2 == 1:\n            print((dp[N - 2][1] + dp[N - 2][3]) % 998244353)\n        else:\n            print((dp[N - 2][0] + dp[N - 2][2]) % 998244353)", "from sys import stdin, stdout\ninput = stdin.readline\nmod = 998244353\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(i) % 2 for i in input().split()]\n    dp = [[0, 0] for i in range(n)]\n    dp[0][a[0] % 2] = 1\n    run = a[0]\n    vals = [[0, 0], [0, 0]]\n    for i in range(1, n):\n        if not a[i]:\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][0]) % mod\n            dp[i][1] = dp[i - 1][1]\n        else:\n            dp[i][0] = vals[run ^ 1][1]\n            dp[i][1] = (vals[run][0] + dp[i - 1][0]) % mod\n            dp[i][run ^ 1] += 1\n        vals[run][0] = (vals[run][0] + dp[i - 1][0]) % mod\n        vals[run][1] = (vals[run][1] + dp[i - 1][1]) % mod\n        run = (run + a[i]) % 2\n    print(sum(dp[-1]) % mod)", "from sys import stdin, stdout\ninput = stdin.readline\nmod = 998244353\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(i) % 2 for i in input().split()]\n    dp = [[0, 0] for i in range(n)]\n    dp[0][a[0] % 2] = 1\n    run = a[0]\n    even = [0, 0]\n    odd = [0, 0]\n    for i in range(1, n):\n        if not a[i]:\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][0]) % mod\n            dp[i][1] = dp[i - 1][1]\n        else:\n            dp[i][1] = dp[i - 1][0]\n            if run:\n                dp[i][0] = (dp[i][0] + even[1]) % mod\n                dp[i][1] = (dp[i][1] + odd[0]) % mod\n            else:\n                dp[i][0] = (dp[i][0] + odd[1]) % mod\n                dp[i][1] = (dp[i][1] + even[0]) % mod\n            dp[i][run ^ 1] += 1\n        if run:\n            odd[0] = (odd[0] + dp[i - 1][0]) % mod\n            odd[1] = (odd[1] + dp[i - 1][1]) % mod\n        else:\n            even[0] = (even[0] + dp[i - 1][0]) % mod\n            even[1] = (even[1] + dp[i - 1][1]) % mod\n        run = (run + a[i]) % 2\n    print(sum(dp[-1]) % mod)"]