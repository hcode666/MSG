["import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nsys.setrecursionlimit(3 * 10 ** 5)\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\nx = 0\npref = []\nlvl = []\ngp = []\nans = []\nf = 0\nw = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\n\ndef dfs(i, prod, rem, n):\n    if rem == 0:\n        while i < len(n):\n            prod *= int(n[i])\n            i += 1\n        return prod\n    if i == len(n):\n        return prod\n    mx = 0\n    for j in range(9 - int(n[i])):\n        mx = max(dfs(i + 1, (int(n[i]) + min(j, rem)) * prod, rem - min(j, rem), n), mx)\n    return mx\n\ndef hnbhai(tc):\n    (n, m) = sd()\n    s = sa()\n    t = sa()\n    if m < n:\n        print(-1)\n        return\n    diff = m - n\n    mn = float('inf')\n    for i in range(diff + 1):\n        seq = []\n        if i != 0:\n            seq.append(i - 1)\n        else:\n            seq.append(float('-inf'))\n        for j in range(n):\n            if s[j] != t[j + i]:\n                seq.append(j + i)\n        if diff - i != 0:\n            seq.append(n + i)\n        else:\n            seq.append(float('inf'))\n        if len(seq) == 2:\n            print(diff)\n            return\n        j = 1\n        dp = [[float('inf'), float('inf')] for _ in range(len(seq) + 4)]\n        dp[0][0] = 0\n        dp[0][1] = 0\n        while j < len(seq) - 1:\n            dp[j][0] = min(dp[j][0], dp[j - 1][1] + seq[j] - seq[j - 1])\n            dp[j][1] = dp[j - 1][0]\n            j += 1\n        mn = min(mn, diff + dp[len(seq) - 2][0], diff + dp[len(seq) - 2][1] + seq[len(seq) - 1] - seq[len(seq) - 2])\n    if mn == float('inf'):\n        print(-1)\n        return\n    print(mn)\n    return\nfor _ in range(sb()):\n    hnbhai(_ + 1)", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nsys.setrecursionlimit(3 * 10 ** 5)\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\nx = 0\npref = []\nlvl = []\ngp = []\nans = []\nf = 0\nw = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\n\ndef dfs(i, prod, rem, n):\n    if rem == 0:\n        while i < len(n):\n            prod *= int(n[i])\n            i += 1\n        return prod\n    if i == len(n):\n        return prod\n    mx = 0\n    for j in range(9 - int(n[i])):\n        mx = max(dfs(i + 1, (int(n[i]) + min(j, rem)) * prod, rem - min(j, rem), n), mx)\n    return mx\n\ndef hnbhai(tc):\n    (n, m) = sd()\n    s = sa()\n    t = sa()\n    if m < n:\n        print(-1)\n        return\n    diff = m - n\n    mn = float('inf')\n    for i in range(diff + 1):\n        seq = []\n        if i != 0:\n            seq.append(i - 1)\n        else:\n            seq.append(float('-inf'))\n        for j in range(n):\n            if s[j] != t[j + i]:\n                seq.append(j + i)\n        if diff - i != 0:\n            seq.append(n + i)\n        else:\n            seq.append(float('inf'))\n        if len(seq) == 2:\n            print(diff)\n            return\n        j = 1\n        dp = [[float('inf'), float('inf')] for _ in range(len(seq) + 4)]\n        dp[0][0] = 0\n        dp[0][1] = 0\n        while j < len(seq) - 1:\n            dp[j][0] = min(dp[j][0], dp[j - 1][1] + seq[j] - seq[j - 1])\n            dp[j][1] = dp[j - 1][0]\n            j += 1\n        mn = min(mn, diff + dp[len(seq) - 2][0], diff + dp[len(seq) - 2][1] + seq[len(seq) - 1] - seq[len(seq) - 2])\n    if mn == float('inf'):\n        print(-1)\n        return\n    print(mn)\n    return\nfor _ in range(sb()):\n    hnbhai(_ + 1)", "def mini(s, t):\n    l = len(s)\n    ops = 0\n    for i in range(l - 1):\n        if s[i] != t[i]:\n            s[i] = 1 - s[i]\n            s[i + 1] = 1 - s[i + 1]\n            ops += 1\n    return ops\nTest = int(input())\nfor test in range(Test):\n    temp = input().split()\n    ops = []\n    (n, m) = (int(temp[0]), int(temp[1]))\n    S_str = input()\n    T_str = input()\n    s = list(S_str)\n    t = list(T_str)\n    S = [int(x) for x in s]\n    T = [int(x) for x in t]\n    if len(S) > len(T):\n        pass\n    else:\n        for i in range(len(T) - len(S) + 1):\n            T_temp = T[i:i + len(S)]\n            if (sum(T_temp) - sum(S)) % 2 != 0:\n                if len(S) == len(T):\n                    pass\n                else:\n                    temp = [1 + mini([1 - S[0]] + S[1:], T_temp), 1 + mini(S[:-1] + [1 - S[-1]], T_temp)]\n                    ops = ops + temp\n            else:\n                ops.append(mini(S[:], T_temp))\n                if len(T) > len(S) + 1:\n                    ops.append(2 + mini([1 - S[0]] + S[1:-1] + [1 - S[-1]], T_temp))\n    if ops == []:\n        print('-1')\n    else:\n        ans = min(ops) + len(T) - len(S)\n        print(ans)", "def solve(a, b):\n    n = len(a)\n    (i, count) = (0, 0)\n    while i < n:\n        while i < n and a[i] == b[i]:\n            i += 1\n        if i == n:\n            return count\n        i += 1\n        while i < n and a[i] == b[i]:\n            i += 1\n            count += 1\n        if i == n:\n            return float('inf')\n        (count, i) = (count + 1, i + 1)\n    return count\n\ndef answer():\n    if n > m:\n        return -1\n    ans = float('inf')\n    for i in range(m - n + 1):\n        x = a[:]\n        y = b[i:i + n]\n        ans = min(ans, solve(x, y))\n        if i > 0:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n]\n            if b[i - 1] == '1':\n                ans = min(ans, solve('0' + x, y))\n            else:\n                ans = min(ans, solve('1' + x, y))\n        if i < m - n:\n            ans = min(ans, solve(a[:] + ('0' if b[i + n] == '1' else '1'), b[i:i + n] + b[i + n]))\n        if i and i != m - n:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n] + b[i + n]\n            front = '0' if b[i - 1] == '1' else '1'\n            back = '0' if b[i + n] == '1' else '1'\n            ans = min(ans, solve(front + x + back, y))\n    return -1 if ans == float('inf') else ans + (m - n)\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = input().strip()\n    b = input().strip()\n    print(answer())", "INF = float('inf')\n\ndef count(s, t):\n    s = s.copy()\n    t = t.copy()\n    if len(s) != len(t):\n        return INF\n    n = len(s)\n    c = 0\n    for i in range(n):\n        if s[i] != t[i]:\n            if i + 1 >= n:\n                return INF\n            c += 1\n            s[i] ^= 1\n            s[i + 1] ^= 1\n    return c\n\ndef solve(s, t, beg, end):\n    s = s.copy()\n    t = t.copy()\n    tot = beg + end\n    t = t[beg:]\n    if end != 0:\n        t = t[:-end]\n    if beg == end == 0:\n        return count(s, t) + tot\n    elif end == 0:\n        c1 = count(s, t)\n        s[0] ^= 1\n        c2 = count(s, t) + 1\n        return min(c1, c2) + tot\n    elif beg == 0:\n        c1 = count(s, t)\n        s[-1] ^= 1\n        c2 = count(s, t) + 1\n        return min(c1, c2) + tot\n    else:\n        c1 = count(s, t)\n        s[0] ^= 1\n        c2 = count(s, t) + 1\n        s[-1] ^= 1\n        c3 = count(s, t) + 2\n        s[0] ^= 1\n        c4 = count(s, t) + 1\n        return min(c1, c2, c3, c4) + tot\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = list(map(int, input().strip()))\n    t = list(map(int, input().strip()))\n    if n > m:\n        print(-1)\n        continue\n    elif m == n:\n        x = solve(s, t, 0, 0)\n        print(x if x != INF else -1)\n    else:\n        tot = m - n\n        mini = INF\n        for i in range(tot + 1):\n            mini = min(mini, solve(s, t, i, tot - i))\n        if mini == INF:\n            print(-1)\n        else:\n            print(mini)", "INF = float('inf')\n\ndef count(s, t):\n    s = s.copy()\n    t = t.copy()\n    if len(s) != len(t):\n        return INF\n    n = len(s)\n    c = 0\n    for i in range(n):\n        if s[i] != t[i]:\n            if i + 1 >= n:\n                return INF\n            c += 1\n            s[i] ^= 1\n            s[i + 1] ^= 1\n    return c\n\ndef solve(s, t, beg, end):\n    s = s.copy()\n    t = t.copy()\n    tot = beg + end\n    t = t[beg:]\n    if end != 0:\n        t = t[:-end]\n    if beg == end == 0:\n        return count(s, t) + tot\n    elif end == 0:\n        c1 = count(s, t)\n        s[0] ^= 1\n        c2 = count(s, t) + 1\n        return min(c1, c2) + tot\n    elif beg == 0:\n        c1 = count(s, t)\n        s[-1] ^= 1\n        c2 = count(s, t) + 1\n        return min(c1, c2) + tot\n    else:\n        c1 = count(s, t)\n        s[0] ^= 1\n        c2 = count(s, t) + 1\n        s[-1] ^= 1\n        c3 = count(s, t) + 2\n        s[0] ^= 1\n        c4 = count(s, t) + 1\n        return min(c1, c2, c3, c4) + tot\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = list(map(int, input().strip()))\n    t = list(map(int, input().strip()))\n    if m == 1:\n        mini = count(s, t)\n        if mini == INF:\n            print(-1)\n        else:\n            print(mini)\n        continue\n    if n > m:\n        print(-1)\n        continue\n    tot = m - n\n    mini = INF\n    for i in range(tot + 1):\n        mini = min(mini, solve(s, t, i, tot - i))\n    if mini == INF:\n        print(-1)\n    else:\n        print(mini)", "def solve(a, b):\n    n = len(a)\n    (i, count) = (0, 0)\n    while i < n:\n        while i < n and a[i] == b[i]:\n            i += 1\n        if i == n:\n            return count\n        i += 1\n        while i < n and a[i] == b[i]:\n            i += 1\n            count += 1\n        if i == n:\n            return float('inf')\n        (count, i) = (count + 1, i + 1)\n    return count\n\ndef answer():\n    if n > m:\n        return -1\n    ans = float('inf')\n    for i in range(m - n + 1):\n        x = a[:]\n        y = b[i:i + n]\n        ans = min(ans, solve(x, y))\n        if i > 0:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n]\n            if b[i - 1] == '1':\n                ans = min(ans, solve('0' + x, y))\n            else:\n                ans = min(ans, solve('1' + x, y))\n        if i < m - n:\n            ans = min(ans, solve(a[:] + ('0' if b[i + n] == '1' else '1'), b[i:i + n] + b[i + n]))\n        if i and i != m - n:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n] + b[i + n]\n            front = '0' if b[i - 1] == '1' else '1'\n            back = '0' if b[i + n] == '1' else '1'\n            ans = min(ans, solve(front + x + back, y))\n    return -1 if ans == float('inf') else ans + (m - n)\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = input().strip()\n    b = input().strip()\n    print(answer())", "def solve(a, b):\n    n = len(a)\n    (i, count) = (0, 0)\n    while i < n:\n        while i < n and a[i] == b[i]:\n            i += 1\n        if i == n:\n            return count\n        i += 1\n        while i < n and a[i] == b[i]:\n            i += 1\n            count += 1\n        if i == n:\n            return float('inf')\n        (count, i) = (count + 1, i + 1)\n    return count\n\ndef answer():\n    if n > m:\n        return -1\n    ans = float('inf')\n    for i in range(m - n + 1):\n        x = a[:]\n        y = b[i:i + n]\n        ans = min(ans, solve(x, y))\n        if i > 0:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n]\n            if b[i - 1] == '1':\n                ans = min(ans, solve('0' + x, y))\n            else:\n                ans = min(ans, solve('1' + x, y))\n        if i < m - n:\n            ans = min(ans, solve(a[:] + ('0' if b[i + n] == '1' else '1'), b[i:i + n] + b[i + n]))\n        if i and i != m - n:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n] + b[i + n]\n            front = '0' if b[i - 1] == '1' else '1'\n            back = '0' if b[i + n] == '1' else '1'\n            ans = min(ans, solve(front + x + back, y))\n    return -1 if ans == float('inf') else ans + (m - n)\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = input().strip()\n    b = input().strip()\n    print(answer())", "def solve(a, b):\n    n = len(a)\n    (i, count) = (0, 0)\n    while i < n:\n        while i < n and a[i] == b[i]:\n            i += 1\n        if i == n:\n            return count\n        i += 1\n        while i < n and a[i] == b[i]:\n            i += 1\n            count += 1\n        if i == n:\n            return float('inf')\n        (count, i) = (count + 1, i + 1)\n    return count\n\ndef answer():\n    if n > m:\n        return -1\n    ans = float('inf')\n    for i in range(m - n + 1):\n        x = a[:]\n        y = b[i:i + n]\n        ans = min(ans, solve(x, y))\n        if i > 0:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n]\n            if b[i - 1] == '1':\n                ans = min(ans, solve('0' + x, y))\n            else:\n                ans = min(ans, solve('1' + x, y))\n        if i < m - n:\n            x = a[:]\n            y = b[i:i + n] + b[i + n]\n            if b[i + n] == '1':\n                ans = min(ans, solve(x + '0', y))\n            else:\n                ans = min(ans, solve(x + '1', y))\n        if i != 0 and i != m - n:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n] + b[i + n]\n            front = '0' if b[i - 1] == '1' else '1'\n            back = '0' if b[i + n] == '1' else '1'\n            ans = min(ans, solve(front + x + back, y))\n    return -1 if ans == float('inf') else ans + (m - n)\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = input().strip()\n    b = input().strip()\n    print(answer())", "def solve(a, b):\n    n = len(a)\n    (i, count) = (0, 0)\n    while i < n:\n        while i < n and a[i] == b[i]:\n            i += 1\n        if i == n:\n            return count\n        i += 1\n        while i < n and a[i] == b[i]:\n            i += 1\n            count += 1\n        if i == n:\n            return float('inf')\n        (count, i) = (count + 1, i + 1)\n    return count\n\ndef answer():\n    if n > m:\n        return -1\n    ans = float('inf')\n    for i in range(m - n + 1):\n        x = a[:]\n        y = b[i:i + n]\n        ans = min(ans, solve(x, y))\n        if i > 0:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n]\n            if b[i - 1] == '1':\n                ans = min(ans, solve('0' + x, y))\n            else:\n                ans = min(ans, solve('1' + x, y))\n        if i < m - n:\n            x = a[:]\n            y = b[i:i + n] + b[i + n]\n            if b[i + n] == '1':\n                ans = min(ans, solve(x + '0', y))\n            else:\n                ans = min(ans, solve(x + '1', y))\n        if i != 0 and i != m - n:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n] + b[i + n]\n            if b[i - 1] == '1':\n                front = '0'\n            else:\n                front = '1'\n            if b[i + n] == '1':\n                back = '0'\n            else:\n                back = '1'\n            ans = min(ans, solve(front + x + back, y))\n    if ans == float('inf'):\n        return -1\n    return ans + (m - n)\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = input().strip()\n    b = input().strip()\n    print(answer())", "from sys import stdin\ninput = stdin.readline\n\ndef solve(a, b):\n    n = len(a)\n    (i, count) = (0, 0)\n    while i < n:\n        while i < n and a[i] == b[i]:\n            i += 1\n        if i == n:\n            return count\n        i += 1\n        while i < n and a[i] == b[i]:\n            i += 1\n            count += 1\n        if i == n:\n            return float('inf')\n        (count, i) = (count + 1, i + 1)\n    return count\n\ndef answer():\n    if n > m:\n        return -1\n    ans = float('inf')\n    for i in range(m - n + 1):\n        x = a[:]\n        y = b[i:i + n]\n        ans = min(ans, solve(x, y))\n        if i > 0:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n]\n            if b[i - 1] == '1':\n                ans = min(ans, solve('0' + x, y))\n            else:\n                ans = min(ans, solve('1' + x, y))\n        if i < m - n:\n            x = a[:]\n            y = b[i:i + n] + b[i + n]\n            if b[i + n] == '1':\n                ans = min(ans, solve(x + '0', y))\n            else:\n                ans = min(ans, solve(x + '1', y))\n        if i != 0 and i != m - n:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n] + b[i + n]\n            if b[i - 1] == '1':\n                front = '0'\n            else:\n                front = '1'\n            if b[i + n] == '1':\n                back = '0'\n            else:\n                back = '1'\n            ans = min(ans, solve(front + x + back, y))\n    if ans == float('inf'):\n        return -1\n    return ans + (m - n)\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = input().strip()\n    b = input().strip()\n    print(answer())", "from sys import stdin\ninput = stdin.readline\n\ndef solve(a, b):\n    n = len(a)\n    (i, count) = (0, 0)\n    while i < n:\n        while i < n and a[i] == b[i]:\n            i += 1\n        if i == n:\n            return count\n        i += 1\n        while i < n and a[i] == b[i]:\n            i += 1\n            count += 1\n        if i == n:\n            return float('inf')\n        (count, i) = (count + 1, i + 1)\n    return count\n\ndef answer():\n    if n > m:\n        return -1\n    ans = float('inf')\n    for i in range(m - n + 1):\n        x = a[:]\n        y = b[i:i + n]\n        ans = min(ans, solve(x, y))\n        if i > 0:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n]\n            if b[i - 1] == '1':\n                ans = min(ans, solve('0' + x, y))\n            else:\n                ans = min(ans, solve('1' + x, y))\n        if i < m - n:\n            x = a[:]\n            y = b[i:i + n] + b[i + n]\n            if b[i + n] == '1':\n                ans = min(ans, solve(x + '0', y))\n            else:\n                ans = min(ans, solve(x + '1', y))\n        if i != 0 and i != m - n:\n            x = a[:]\n            y = b[i - 1] + b[i:i + n] + b[i + n]\n            if b[i - 1] == '1':\n                front = '0'\n            else:\n                front = '1'\n            if b[i + n] == '1':\n                back = '0'\n            else:\n                back = '1'\n            ans = min(ans, solve(front + x + back, y))\n    if ans == float('inf'):\n        return -1\n    return ans + (m - n)\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = input().strip()\n    b = input().strip()\n    print(answer())", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nsys.setrecursionlimit(3 * 10 ** 5)\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\nx = 0\npref = []\nlvl = []\ngp = []\nans = []\nf = 0\nw = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\n\ndef dfs(i, prod, rem, n):\n    if rem == 0:\n        while i < len(n):\n            prod *= int(n[i])\n            i += 1\n        return prod\n    if i == len(n):\n        return prod\n    mx = 0\n    for j in range(9 - int(n[i])):\n        mx = max(dfs(i + 1, (int(n[i]) + min(j, rem)) * prod, rem - min(j, rem), n), mx)\n    return mx\n\ndef hnbhai(tc):\n    (n, m) = sd()\n    s = sa()\n    t = sa()\n    if m < n:\n        print(-1)\n        return\n    diff = m - n\n    mn = float('inf')\n    for i in range(diff + 1):\n        seq = []\n        if i != 0:\n            seq.append(i - 1)\n        else:\n            seq.append(float('-inf'))\n        for j in range(n):\n            if s[j] != t[j + i]:\n                seq.append(j + i)\n        if diff - i != 0:\n            seq.append(n + i)\n        else:\n            seq.append(float('inf'))\n        if len(seq) == 2:\n            print(diff)\n            return\n        j = 1\n        dp = [[float('inf'), float('inf')] for _ in range(len(seq) + 4)]\n        dp[0][0] = 0\n        dp[0][1] = 0\n        while j < len(seq) - 1:\n            dp[j][0] = min(dp[j][0], dp[j - 1][1] + seq[j] - seq[j - 1])\n            dp[j][1] = dp[j - 1][0]\n            j += 1\n        mn = min(mn, diff + dp[len(seq) - 2][0], diff + dp[len(seq) - 2][1] + seq[len(seq) - 1] - seq[len(seq) - 2])\n    if mn == float('inf'):\n        print(-1)\n        return\n    print(mn)\n    return\nfor _ in range(sb()):\n    hnbhai(_ + 1)", "INF = float('inf')\n\ndef count(s, t):\n    s = s.copy()\n    t = t.copy()\n    if len(s) != len(t):\n        return INF\n    n = len(s)\n    c = 0\n    for i in range(n):\n        if s[i] != t[i]:\n            if i + 1 >= n:\n                return INF\n            c += 1\n            s[i] ^= 1\n            s[i + 1] ^= 1\n    return c\n\ndef solve(s, t, beg, end):\n    s = s.copy()\n    t = t.copy()\n    tot = beg + end\n    t = t[beg:]\n    if end != 0:\n        t = t[:-end]\n    if beg == end == 0:\n        return count(s, t) + tot\n    elif end == 0:\n        c1 = count(s, t)\n        s[0] ^= 1\n        c2 = count(s, t) + 1\n        return min(c1, c2) + tot\n    elif beg == 0:\n        c1 = count(s, t)\n        s[-1] ^= 1\n        c2 = count(s, t) + 1\n        return min(c1, c2) + tot\n    else:\n        c1 = count(s, t)\n        s[0] ^= 1\n        c2 = count(s, t) + 1\n        s[-1] ^= 1\n        c3 = count(s, t) + 2\n        s[0] ^= 1\n        c4 = count(s, t) + 1\n        return min(c1, c2, c3, c4) + tot\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = list(map(int, input().strip()))\n    t = list(map(int, input().strip()))\n    if m == 1:\n        mini = count(s, t)\n        if mini == INF:\n            print(-1)\n        else:\n            print(mini)\n        continue\n    if m == 2:\n        mini = min(count('0' + s, t), count('1' + s, t), count(s + '0', t), count(s + '1', t)) + 1\n        if mini == INF:\n            print(-1)\n        else:\n            print(mini)\n        continue\n    if n > m:\n        print(-1)\n        continue\n    tot = m - n\n    mini = INF\n    for i in range(tot + 1):\n        mini = min(mini, solve(s, t, i, tot - i))\n    if mini == INF:\n        print(-1)\n    else:\n        print(mini)"]