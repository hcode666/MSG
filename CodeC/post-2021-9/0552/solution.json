["possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\ndef LII():\n    return [int(x) for x in input().split()]\n\ndef ceilq(a, b):\n    return (a + b - 1) // b\n\ndef prime_factors(n):\n    pfs = set({})\n    for p in possible_pfs:\n        if n % p == 0:\n            pfs.add(p)\n            while n % p == 0:\n                n //= p\n        if p * p > n:\n            break\n    if n > 1:\n        pfs.add(n)\n    return pfs\n\ndef copr(l, r, x):\n    if x:\n        y = x.copy()\n        p = y.pop()\n        return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n    else:\n        return r - l + 1\n(a, b, l, r) = LII()\npfs_a = prime_factors(a)\npfs_b = prime_factors(b)\npfs_ab = pfs_a | pfs_b\nprint(copr(l, r, pfs_a) + copr(l, r, pfs_b) - copr(l, r, pfs_ab))", "def prime_factor(x):\n    i = 2\n    primes = []\n    while i * i <= x:\n        if x % i == 0:\n            primes.append(i)\n            while x % i == 0:\n                x //= i\n        i += 1\n    if x > 1:\n        primes.append(x)\n    return primes\n\ndef calc(l, r, primes):\n    sz = len(primes)\n    ans = 0\n    for mask in range(1, 2 ** sz):\n        num = 1\n        for i in range(sz):\n            if mask & 2 ** i:\n                num *= primes[i]\n        parity = bin(mask)[2:].count('1') % 2\n        ct = r // num - (l - 1) // num\n        if parity == 1:\n            ans += ct\n        else:\n            ans -= ct\n    return ans\n(a, b, l, r) = map(int, input().split())\nans = calc(l, r, prime_factor(a)) + calc(l, r, prime_factor(b)) - calc(l, r, list(set(prime_factor(a) + prime_factor(b))))\nprint(r - l + 1 - ans)", "def prime_factor(x):\n    i = 2\n    primes = []\n    while i * i <= x:\n        if x % i == 0:\n            primes.append(i)\n            while x % i == 0:\n                x //= i\n        i += 1\n    if x > 1:\n        primes.append(x)\n    return primes\n\ndef calc(l, r, primes):\n    sz = len(primes)\n    ans = 0\n    for mask in range(1, 2 ** sz):\n        num = 1\n        for i in range(sz):\n            if mask & 2 ** i:\n                num *= primes[i]\n        parity = bin(mask)[2:].count('1') % 2\n        ct = r // num - (l - 1) // num\n        if parity == 1:\n            ans += ct\n        else:\n            ans -= ct\n    return ans\n(a, b, l, r) = map(int, input().split())\nans = calc(l, r, prime_factor(a)) + calc(l, r, prime_factor(b)) - calc(l, r, list(set(prime_factor(a) + prime_factor(b))))\nprint(r - l + 1 - ans)", "def prime_factor(x):\n    i = 2\n    primes = []\n    while i * i <= x:\n        if x % i == 0:\n            primes.append(i)\n            while x % i == 0:\n                x //= i\n        i += 1\n    if x > 1:\n        primes.append(x)\n    return primes\n\ndef calc(l, r, primes):\n    sz = len(primes)\n    ans = 0\n    for mask in range(1, 2 ** sz):\n        num = 1\n        for i in range(sz):\n            if mask & 2 ** i:\n                num *= primes[i]\n        parity = bin(mask)[2:].count('1') % 2\n        ct = r // num - (l - 1) // num\n        if parity == 1:\n            ans += ct\n        else:\n            ans -= ct\n    return ans\n(a, b, l, r) = map(int, input().split())\nans = calc(l, r, prime_factor(a)) + calc(l, r, prime_factor(b)) - calc(l, r, list(set(prime_factor(a) + prime_factor(b))))\nprint(r - l + 1 - ans)", "from sys import stdin\nfrom itertools import chain, combinations\nimport math\n\ndef get_ints():\n    return list(map(int, stdin.readline().strip().split()))\n\ndef primeFactors(n):\n    x = set()\n    while n % 2 == 0:\n        x.add(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            x.add(int(i))\n            n = n / i\n    if n > 2:\n        x.add(int(n))\n    return x\n\ndef no_div_by(set_of_primes, L, R):\n    prod = 1\n    for x in set_of_primes:\n        prod *= x\n    return R // prod - (L - 1) // prod\n\ndef powerset(iterable):\n    s = list(iterable)\n    return chain.from_iterable((combinations(s, r) for r in range(2, len(s) + 1)))\n\ndef compute_gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef lcm(x, y):\n    lcm = x * y // compute_gcd(x, y)\n    return lcm\n(A, B, L, R) = get_ints()\nprimes_A = primeFactors(A)\nprimes_B = primeFactors(B)\nprimes_C = set()\nprimes_C.update(primes_A)\nprimes_C.update(primes_B)\nnumber_of_coprimes = 2 * (R - L + 1)\nP_A = [[x] for x in primes_A]\nP_A.extend(list(powerset(primes_A)))\nfor i in P_A:\n    number_of_coprimes += (-1) ** len(i) * no_div_by(i, L, R)\nP_B = [[x] for x in primes_B]\nP_B.extend(list(powerset(primes_B)))\nfor i in P_B:\n    number_of_coprimes += (-1) ** len(i) * no_div_by(i, L, R)\nnumber_of_common = R - L + 1\nP_C = [[x] for x in primes_C]\nP_C.extend(list(powerset(primes_C)))\nfor i in P_C:\n    number_of_common += (-1) ** len(i) * no_div_by(i, L, R)\nprint(int(number_of_coprimes - number_of_common))", "import math\n\ndef bunkai(a):\n    s = []\n    k = 2\n    while k <= a:\n        if a % k == 0:\n            s.append(k)\n            while True:\n                a //= k\n                if a % k != 0:\n                    break\n        k += 1\n    return s\n\ndef main():\n    (a, b, l, r) = map(int, input().split())\n    af = bunkai(a)\n    bf = bunkai(b)\n    g = list(set(af + bf))\n    g.sort()\n    count = 0\n    ans = 0\n    for i in range(1, 2 ** len(af)):\n        k = 0\n        m = 1\n        for j in range(len(af)):\n            if i & 1 << j:\n                k += 1\n                m = m * af[j] // math.gcd(m, af[j])\n        count += (-1) ** ((k + 1) % 2) * (r // m - (l - 1) // m)\n    ans += r - l + 1 - count\n    count = 0\n    for i in range(1, 2 ** len(bf)):\n        k = 0\n        m = 1\n        for j in range(len(bf)):\n            if i & 1 << j:\n                k += 1\n                m = m * bf[j] // math.gcd(m, bf[j])\n        count += (-1) ** ((k + 1) % 2) * (r // m - (l - 1) // m)\n    ans += r - l + 1 - count\n    countw = 0\n    for i in range(1, 2 ** len(g)):\n        k = 0\n        m = 1\n        for j in range(len(g)):\n            if i & 1 << j:\n                k += 1\n                m = m * g[j] // math.gcd(m, g[j])\n        countw += (-1) ** ((k + 1) % 2) * (r // m - (l - 1) // m)\n    ans = ans - (r - l + 1 - countw)\n    print(ans)\nmain()", "possible_pfs = [2, 3] + [6 * x + d for x in range(1, 5271) for d in [-1, 1]]\n\ndef LII():\n    return [int(x) for x in input().split()]\n\ndef ceilq(a, b):\n    return (a + b - 1) // b\n\ndef prime_factors(n):\n    pfs = set({})\n    for p in possible_pfs:\n        if n % p == 0:\n            pfs.add(p)\n            while n % p == 0:\n                n //= p\n        if p * p > n:\n            break\n    if n > 1:\n        pfs.add(n)\n    return pfs\n\ndef copr(l, r, x):\n    if x:\n        y = x.copy()\n        p = y.pop()\n        return copr(l, r, y) - copr(ceilq(l, p), r // p, y)\n    else:\n        return r - l + 1\n(a, b, l, r) = LII()\npfs_a = prime_factors(a)\npfs_b = prime_factors(b)\npfs_ab = pfs_a | pfs_b\nprint(copr(l, r, pfs_a) + copr(l, r, pfs_b) - copr(l, r, pfs_ab))"]