["import time\nimport sys\nimport math\nfrom collections import defaultdict as dd\nfrom functools import lru_cache\ninty = lambda : int(input())\nstringy = lambda : input().strip()\nmappy = lambda : map(int, input().strip().split())\nfmappy = lambda : map(float, input().strip().split())\nlisty = lambda : list(map(int, input().strip().split()))\ntick = lambda : time.perf_counter()\nlogg = lambda a, b: math.log(a) / math.log(b)\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return abs(x)\nT = inty()\nfor _ in range(T):\n    (x, c) = mappy()\n    if x == 1 or c == 1:\n        print(1)\n        continue\n    flag = True\n    res = sys.maxsize\n    for i in range(1, min(1000, x + 1)):\n        temp = i ** c\n        res = min(temp * x / gcd(temp, x) ** 2, res)\n    print(int(res))", "import time\nimport sys\nimport math\nfrom collections import defaultdict as dd\nfrom functools import lru_cache\ninty = lambda : int(input())\nstringy = lambda : input().strip()\nmappy = lambda : map(int, input().strip().split())\nfmappy = lambda : map(float, input().strip().split())\nlisty = lambda : list(map(int, input().strip().split()))\ntick = lambda : time.perf_counter()\nlogg = lambda a, b: math.log(a) / math.log(b)\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return abs(x)\nT = inty()\nfor _ in range(T):\n    (x, c) = mappy()\n    if x == 1 or c == 1:\n        print(1)\n        continue\n    flag = True\n    res = sys.maxsize\n    for i in range(1, min(1000, x + 1)):\n        temp = i ** c\n        res = min(temp * x / gcd(temp, x) ** 2, res)\n    print(int(res))", "def gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef div(x):\n    arr = []\n    for i in range(1, int(x ** 0.5) + 1):\n        if x % i == 0:\n            if i * i != x:\n                arr.append(i)\n                arr.append(x // i)\n            else:\n                arr.append(i)\n    return arr\n\ndef cal(x, c, d):\n    temp = d ** c\n    g = gcd(temp, x)\n    x = temp * x // (g * g)\n    return x\n\ndef mini_x(x, c):\n    arr = div(x)\n    minx = x\n    for ele in arr:\n        temp = cal(x, c, ele)\n        minx = min(minx, temp)\n    return minx\nt = int(input())\nfor tc in range(t):\n    (x, c) = map(int, input().split())\n    ans = mini_x(x, c)\n    print(ans)", "def gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef div(x):\n    arr = []\n    for i in range(1, int(x ** 0.5) + 1):\n        if x % i == 0:\n            if i * i != x:\n                arr.append(i)\n                arr.append(x // i)\n            else:\n                arr.append(i)\n    return arr\n\ndef cal(x, c, d):\n    temp = d ** c\n    g = gcd(temp, x)\n    x = temp * x // (g * g)\n    return x\n\ndef mini_x(x, c):\n    arr = div(x)\n    minx = x\n    for ele in arr:\n        temp = cal(x, c, ele)\n        minx = min(minx, temp)\n    return minx\nt = int(input())\nfor tc in range(t):\n    (x, c) = map(int, input().split())\n    ans = mini_x(x, c)\n    print(ans)", "def gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef div(x):\n    arr = []\n    for i in range(1, int(x ** 0.5) + 1):\n        if x % i == 0:\n            if i * i != x:\n                arr.append(i)\n                arr.append(x // i)\n            else:\n                arr.append(i)\n    return arr\n\ndef cal(x, c, d):\n    temp = d ** c\n    g = gcd(temp, x)\n    x = temp * x // (g * g)\n    return x\n\ndef mini_x(x, c):\n    arr = div(x)\n    minx = x\n    for ele in arr:\n        temp = cal(x, c, ele)\n        minx = min(minx, temp)\n    return minx\nt = int(input())\nfor tc in range(t):\n    (x, c) = map(int, input().split())\n    ans = mini_x(x, c)\n    print(ans)", "import sys\nimport math\nimport bisect\nimport heapq\nfrom bisect import bisect_right\nfrom sys import stdin, stdout\n\ndef get_ints_in_variables():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_int():\n    return int(sys.stdin.readline())\n\ndef get_ints_in_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_list_of_list(n):\n    return [list(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef myceil(x, y):\n    return (x + y - 1) // y\n\ndef Solution():\n    pass\n\ndef getPrimeFactor(N):\n    factors = []\n    i = 1\n    while i * i <= N:\n        if N % i == 0:\n            factors.append(i)\n            if i != N // i:\n                factors.append(N // i)\n        i += 1\n    return sorted(factors)\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\ndef main():\n    lmt = pow(10, 10)\n    for _ in range(get_int()):\n        (x, c) = get_ints_in_variables()\n        if x == 1 or c == 1:\n            print(1)\n            continue\n        while True:\n            i = 2\n            f = 0\n            p = pow(i, c)\n            while p < lmt:\n                p = pow(i, c)\n                tmp = lcm(p, x) // math.gcd(p, x)\n                if tmp < x:\n                    x = tmp\n                    f = 1\n                    break\n                i += 1\n            if f == 0:\n                break\n        print(x)\nmain()", "T = int(input())\nfor tx in range(T):\n    (X, c) = map(int, input().split())\n    if c == 1:\n        print(1)\n        continue\n    f = 2\n    elim = c // 2 + 1\n    inc = 1\n    newX = 1\n    while f ** elim <= X:\n        if X % f == 0:\n            fct = 0\n            while X % f == 0:\n                fct += 1\n                X //= f\n            fct %= c\n            if fct * 2 > c:\n                fct = c - fct\n            newX *= f ** fct\n        f += inc\n        inc = 2\n    print(X * newX)", "import math\n\ndef prinefactors(n):\n    prime_factors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        while n % i == 0:\n            count += 1\n            n /= i\n        if count != 0:\n            prime_factors.append((i, count))\n    if n > 1:\n        prime_factors.append((int(n), 1))\n    return prime_factors\nT = int(input())\nfor _ in range(T):\n    (X, c) = list(map(int, input().split()))\n    number = 1\n    for j in prinefactors(X):\n        val = j[0]\n        power = j[1]\n        if c - power % c <= power % c:\n            number *= val ** (c - power % c)\n        else:\n            number *= val ** (power % c)\n    print(number)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    x = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            x.append(i)\n    return x\nz = SieveOfEratosthenes(10 ** 5 + 1)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    tt = 1\n    for i in z:\n        p = 0\n        while x % i == 0:\n            x //= i\n            p += 1\n        p %= c\n        p = min((c - p) % c, p)\n        tt *= i ** p\n    if x != 1:\n        tt *= x\n    print(tt)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    x = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            x.append(i)\n    return x\nz = SieveOfEratosthenes(10 ** 5 + 1)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    tt = 1\n    for i in z:\n        p = 0\n        while x % i == 0:\n            x //= i\n            p += 1\n        p %= c\n        p = min((c - p) % c, p)\n        tt *= i ** p\n    if x != 1:\n        tt *= x\n    print(tt)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    x = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            x.append(i)\n    return x\nz = SieveOfEratosthenes(10 ** 5 + 1)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    tt = 1\n    for i in z:\n        p = 0\n        while x % i == 0:\n            x //= i\n            p += 1\n        p %= c\n        p = min((c - p) % c, p)\n        tt *= i ** p\n    if x != 1:\n        tt *= x\n    print(tt)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    x = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            x.append(i)\n    return x\nz = SieveOfEratosthenes(10 ** 5 + 1)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    tt = 1\n    for i in z:\n        p = 0\n        while x % i == 0:\n            x //= i\n            p += 1\n        p %= c\n        p = min((c - p) % c, p)\n        tt *= i ** p\n    if x != 1:\n        tt *= x\n    print(tt)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    x = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            x.append(i)\n    return x\nz = SieveOfEratosthenes(10 ** 5 + 1)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    tt = 1\n    for i in z:\n        p = 0\n        while x % i == 0:\n            x //= i\n            p += 1\n        p %= c\n        p = min((c - p) % c, p)\n        tt *= i ** p\n    if x != 1:\n        tt *= x\n    print(tt)", "import math\nfrom collections import defaultdict\n\ndef primeFactors(n):\n    dic = defaultdict(int)\n    while n % 2 == 0:\n        dic[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            dic[i] += 1\n            n = n / i\n    if n > 2:\n        dic[n] += 1\n    return dic\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if x == 1 or c == 1:\n        print(1)\n    else:\n        dic = primeFactors(x)\n        ans = 1\n        for i in dic:\n            ans = ans * i ** min(c - dic[i] % c, dic[i] % c)\n        print(int(ans))", "T = int(input())\nfor tx in range(T):\n    (X, c) = map(int, input().split())\n    if c == 1:\n        print(1)\n        continue\n    f = 2\n    elim = c // 2 + 1\n    inc = 1\n    newX = 1\n    while f ** elim <= X:\n        if X % f == 0:\n            fct = 0\n            while X % f == 0:\n                fct += 1\n                X //= f\n            fct %= c\n            if fct * 2 > c:\n                fct = c - fct\n            newX *= f ** fct\n        f += inc\n        inc = 2\n    print(X * newX)", "T = int(input())\nfor tx in range(T):\n    (X, c) = map(int, input().split())\n    if c == 1:\n        print(1)\n        continue\n    f = 2\n    inc = 1\n    newX = 1\n    while f * f <= X:\n        fct = 0\n        while X % f == 0:\n            fct += 1\n            X //= f\n        fct %= c\n        if fct * 2 > c:\n            fct = c - fct\n        newX *= f ** fct\n        f += inc\n        inc = 2\n    print(X * newX)", "from math import gcd, pow\n\ndef mi(x, c):\n    while True:\n        f = False\n        for l in range(int(pow(x, 1 / c)) + 100, 1, -1):\n            k = gcd(l ** c, x)\n            if l ** c * x < k ** 2:\n                break\n            if l ** c * x % k ** 2 == 0:\n                if x > l ** c * x // k ** 2:\n                    f = True\n                    x = l ** c * x // k ** 2\n                    break\n        if not f:\n            break\n    return x\nfor l in range(int(input())):\n    (x, c) = [int(a) for a in input().split()]\n    print(mi(x, c))", "import math\n\ndef is_prime(x):\n    if x % 2 == 0:\n        return False\n    sqrtx = math.sqrt(x)\n    for i in range(3, int(sqrtx), 2):\n        if x % i == 0:\n            return False\n    return True\n\ndef prime_factorization(x):\n    factors = []\n    if x % 2 == 0:\n        factors.append([2, 1])\n        x = int(x / 2)\n        while x % 2 == 0:\n            x = int(x / 2)\n            factors[0][1] += 1\n    pf = 3\n    while x >= pf:\n        if is_prime(pf):\n            if x < pf ** 2:\n                factors.append([x, 1])\n                x = 1\n            elif x % pf == 0:\n                factors.append([pf, 1])\n                curr_pos = len(factors) - 1\n                x = int(x / pf)\n                while x % pf == 0:\n                    x = int(x / pf)\n                    factors[curr_pos][1] += 1\n        pf += 2\n    return factors\nt = int(input())\nfor i in range(t):\n    line = input()\n    xc = line.split()\n    x = int(xc[0])\n    c = int(xc[1])\n    if x == 1 or c == 1:\n        print(1)\n    else:\n        factors = prime_factorization(x)\n        total = 1\n        for factor in factors:\n            modc = factor[1] % c\n            factor[1] = min(modc, c - modc)\n            total *= factor[0] ** factor[1]\n        print(total)", "import math\n\ndef primefactors(n):\n    prime_factors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        while n % i == 0:\n            count += 1\n            n = n / i\n        if count != 0:\n            prime_factors.append((i, count))\n    if n > 1:\n        prime_factors.append((int(n), 1))\n    return prime_factors\nfor i in range(int(input())):\n    (x, c) = map(int, input().split())\n    number = 1\n    primeFactors = primefactors(x)\n    for primeFactor in primeFactors:\n        prime = primeFactor[0]\n        power = primeFactor[1]\n        if c - power % c <= power % c:\n            number *= prime ** (c - power % c)\n        else:\n            number *= prime ** (power % c)\n    print(number)", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random, threading\nfrom functools import lru_cache\nfrom itertools import *\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n(M, M1) = (1000000007, 998244353)\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for _ in range(how_much_noob_I_am):\n        (x, c) = sep()\n        d = defaultdict(int)\n        for i in range(2, int(math.sqrt(x)) + 2):\n            while x % i == 0:\n                x //= i\n                d[i] += 1\n        if x != 1:\n            d[x] += 1\n        ans = 1\n        for i in d:\n            res = i ** d[i]\n            for j in range(c, 40, c):\n                (p, q) = (max(d[i], j), min(d[i], j))\n                result = i ** (p - q)\n                if result < res:\n                    res = result\n            ans *= res\n        print(ans)\nmain()", "import math\nimport sys\n\ndef prime_factors(n):\n    res = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            count = 0\n            while n % i == 0:\n                count += 1\n                n //= i\n            res.append([i, count])\n    if n > 1:\n        res.append([n, 1])\n    return res\nt = int(input())\nfor i in range(t):\n    (x, c) = map(int, input().split())\n    if x == 1:\n        print(1)\n        continue\n    factor = prime_factors(x)\n    ans = 1\n    for i in range(len(factor)):\n        (a, b) = factor[i]\n        b = b % c\n        b = min(b, c - b)\n        ans *= a ** b\n    print(ans)", "import math\n\ndef primefactors(n):\n    while n % 2 == 0:\n        lst.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            lst.append(i)\n            n = n / i\n    if n > 2:\n        lst.append(int(n))\nt = int(input())\nfor i in range(t):\n    (x, c) = map(int, input().split())\n    lst = []\n    primefactors(x)\n    dic = {}\n    for j in lst:\n        dic[j] = 0\n    for j in lst:\n        dic[j] += 1\n    ans = {}\n    for j in dic.keys():\n        ele = dic[j]\n        a = ele % c\n        b = c - a\n        ans[j] = min(a, b)\n    ele = 1\n    for j in ans.keys():\n        a = j ** ans[j]\n        ele *= a\n    print(ele)", "from math import gcd\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if x == 1 or c == 1:\n        print(1)\n    else:\n        val1 = int(x ** 0.5)\n        ans = x\n        for i in range(2, val1):\n            po = i ** c\n            ans = min(ans, po * x // gcd(po, x) ** 2)\n        print(ans)", "def gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef div(x):\n    arr = []\n    for i in range(1, int(x ** 0.5) + 1):\n        if x % i == 0:\n            if i * i != x:\n                arr.append(i)\n                arr.append(x // i)\n            else:\n                arr.append(i)\n    return arr\n\ndef cal(x, c, d):\n    temp = d ** c\n    g = gcd(temp, x)\n    x = temp * x // (g * g)\n    return x\n\ndef mini_x(x, c):\n    arr = div(x)\n    minx = x\n    for ele in arr:\n        temp = cal(x, c, ele)\n        minx = min(minx, temp)\n    return minx\nt = int(input())\nfor tc in range(t):\n    (x, c) = map(int, input().split())\n    ans = mini_x(x, c)\n    print(ans)", "from functools import reduce\n\ndef factors(n):\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\nimport math\nfor q in range(int(input())):\n    (x, c) = map(int, input().split())\n    d = []\n    if x == 1 or c == 1 or int(math.exp(math.log(x) / c)) == math.exp(math.log(x) / c):\n        print(1)\n    else:\n        z = factors(x)\n        for k in z:\n            if k != 1:\n                a = k ** c\n                g = math.gcd(a, x)\n                l = a * x // g\n                if l % g == 0:\n                    d.append(min(x, l // g))\n        print(min(d))", "from functools import reduce\n\ndef factors(n):\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\nimport math\nfor q in range(int(input())):\n    (x, c) = map(int, input().split())\n    d = []\n    if x == 1 or c == 1 or int(math.exp(math.log(x) / c)) == math.exp(math.log(x) / c):\n        print(1)\n    else:\n        z = factors(x)\n        for k in z:\n            if k != 1:\n                a = k ** c\n                g = math.gcd(a, x)\n                l = a * x // g\n                if l % g == 0:\n                    d.append(min(x, l // g))\n        print(min(d))", "from math import gcd\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        print(1)\n        continue\n    least = x\n    i = 2\n    while i * i <= x:\n        if x % i == 0:\n            ans = x * i ** c // gcd(x, i ** c) ** 2\n            least = min(ans, least)\n            ans = x * (x // i) ** c // gcd(x, (x // i) ** c) ** 2\n            least = min(ans, least)\n        i += 1\n        if least == 1:\n            break\n    print(least)", "from math import gcd\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        print(1)\n        continue\n    n = x\n    primes = []\n    least = x\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            ans = x * i ** c // gcd(x, i ** c) ** 2\n            least = min(ans, least)\n            ans = x * (n // i) ** c // gcd(x, (n // i) ** c) ** 2\n            least = min(ans, least)\n        i += 1\n        if least == 1:\n            break\n    print(least)", "import math\n\ndef is_prime(x):\n    if x % 2 == 0:\n        return False\n    sqrtx = math.sqrt(x)\n    for i in range(3, int(sqrtx), 2):\n        if x % i == 0:\n            return False\n    return True\n\ndef prime_factorization(x):\n    factors = []\n    if x % 2 == 0:\n        factors.append([2, 1])\n        x = int(x / 2)\n        while x % 2 == 0:\n            x = int(x / 2)\n            factors[0][1] += 1\n    pf = 3\n    while x >= pf:\n        if is_prime(pf):\n            if x < pf ** 2:\n                factors.append([x, 1])\n                x = 1\n            elif x % pf == 0:\n                factors.append([pf, 1])\n                curr_pos = len(factors) - 1\n                x = int(x / pf)\n                while x % pf == 0:\n                    x = int(x / pf)\n                    factors[curr_pos][1] += 1\n        pf += 2\n    return factors\nt = int(input())\nfor i in range(t):\n    line = input()\n    xc = line.split()\n    x = int(xc[0])\n    c = int(xc[1])\n    if x == 1 or c == 1:\n        print(1)\n    else:\n        factors = prime_factorization(x)\n        total = 1\n        for factor in factors:\n            modc = factor[1] % c\n            factor[1] = min(modc, c - modc)\n            total *= factor[0] ** factor[1]\n        print(total)", "from collections import Counter\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef memodict(f):\n\n    class memodict(dict):\n\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n    return memodict().__getitem__\n\ndef pollard_rho(n):\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n    s = (n - 1 & 1 - n).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = p * p % n\n            if p == 1:\n                return gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                (x, y) = (i, (i * i + 1) % n)\n                f = gcd(abs(x - y), n)\n                while f == 1:\n                    (x, y) = ((x * x + 1) % n, (y * y + 1) % n)\n                    y = (y * y + 1) % n\n                    f = gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n\n@memodict\ndef prime_factors(n):\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\n\ndef distinct_factors(n):\n    factors = [1]\n    for (p, exp) in prime_factors(n).items():\n        factors += [p ** i * factor for factor in factors for i in range(1, exp + 1)]\n    return factors\n\ndef all_factors(n):\n    (small, large) = ([], [])\n    for i in range(1, int(n ** 0.5) + 1, 2 if n & 1 else 1):\n        if not n % i:\n            small.append(i)\n            large.append(n // i)\n    if small[-1] == large[-1]:\n        large.pop()\n    large.reverse()\n    small.extend(large)\n    return small\nfor t in range(int(input())):\n    (X, c) = map(int, input().split())\n    f = dict(prime_factors(X))\n    ans = 1\n    for i in f:\n        ans *= i ** min(c - f[i] % c, f[i] % c)\n    print(ans)", "for _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    res = 1\n    for i in range(2, min(x, 100008)):\n        temp = 0\n        while x % i == 0:\n            x //= i\n            temp += 1\n        temp %= y\n        for j in range(min(y - temp, temp)):\n            res *= i\n    if y == 1:\n        print(1)\n    else:\n        print(res * x)", "import math\n\ndef gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        print(1)\n    else:\n        z = x ** (1 / c)\n        z = int(z)\n        y = x + 1\n        if z != 0:\n            for i in range(2, z + 15):\n                i = i ** c\n                a = x * i // (gcd(x, i) * gcd(x, i))\n                y = min(a, y)\n        if y > x:\n            print(x)\n        else:\n            print(y)", "import math\n\ndef gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        print(1)\n    else:\n        z = x ** (1 / c)\n        z = int(z)\n        y = x + 1\n        if z != 0:\n            for i in range(2, z + 15):\n                i = i ** c\n                a = x * i // (gcd(x, i) * gcd(x, i))\n                y = min(a, y)\n        if y > x:\n            print(x)\n        else:\n            print(y)", "import math\n\ndef gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        print(1)\n    else:\n        z = x ** (1 / c)\n        z = int(z)\n        y = x + 1\n        if z != 0:\n            for i in range(2, z + 15):\n                i = i ** c\n                a = x * i // (gcd(x, i) * gcd(x, i))\n                y = min(a, y)\n        if y > x:\n            print(x)\n        else:\n            print(y)", "import math\n\ndef gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        print(1)\n    else:\n        z = x ** (1 / c)\n        z = int(z)\n        y = x + 1\n        if z != 0:\n            for i in range(2, z + 15):\n                i = i ** c\n                a = x * i // (gcd(x, i) * gcd(x, i))\n                y = min(a, y)\n        if y > x:\n            print(x)\n        else:\n            print(y)", "import math\n\ndef gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        print(1)\n    else:\n        z = math.log(x, 10) / c\n        z = 10 ** z\n        if int(z) != z:\n            z = int(z) + 1\n        else:\n            z = int(z)\n        y = x + 1\n        if z != 0:\n            for i in range(2, z + 15):\n                i = i ** c\n                a = y - 1\n                while a < y:\n                    a = x * i // (gcd(x, i) * gcd(x, i))\n                    y = min(a, y)\n        if y > x:\n            print(x)\n        else:\n            print(y)", "import math\n\ndef gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        print(1)\n    else:\n        z = math.log(x, 10) / c\n        z = 10 ** z\n        if int(z) != z:\n            z = int(z) + 1\n        else:\n            z = int(z)\n        y = x + 1\n        if z != 0:\n            for i in range(2, z + 15):\n                i = i ** c\n                a = y - 1\n                while a < y:\n                    a = x * i // (gcd(x, i) * gcd(x, i))\n                    y = min(a, y)\n        if y > x:\n            print(x)\n        else:\n            print(y)", "import math\n\ndef gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        print(1)\n    else:\n        z = math.log(x, 10) / c\n        z = 10 ** z\n        if int(z) != z:\n            z = int(z) + 1\n        else:\n            z = int(z)\n        y = x + 1\n        if z != 0:\n            for i in range(2, z + 21):\n                i = i ** c\n                a = y - 1\n                while a < y:\n                    a = x * i // (gcd(x, i) * gcd(x, i))\n                    y = min(a, y)\n        if y > x:\n            print(x)\n        else:\n            print(y)", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    (X, c) = map(int, input().split())\n    if X == 1 or c == 1:\n        print(1)\n    else:\n        i = 2\n        ans = X\n        for i in range(2, int(X ** (1 / 2))):\n            if X % i == 0:\n                ans = min(ans, i ** c * X // gcd(X, i ** c) ** 2)\n            i += 1\n        print(ans)", "from math import sqrt\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    p = {}\n    v = x\n    for i in range(2, int(sqrt(x)) + 1):\n        while v % i == 0:\n            if i not in p:\n                p[i] = 0\n            p[i] += 1\n            v = v // i\n    if v not in p:\n        p[v] = 1\n    ans = 1\n    for el in p:\n        ans *= el ** min(p[el] % c, c - p[el] % c)\n    print(ans)", "import math\nfrom collections import Counter\n\ndef func(x, n):\n    hcf = math.gcd(x, n)\n    lcm = x * n // hcf\n    return lcm // hcf\n\ndef solve(x, c):\n    while x > 1:\n        n = 0\n        a = 0\n        while a <= x:\n            n += 1\n            a = n ** c\n        n -= 1\n        m = x\n        arr = []\n        for i in range(1, 5 * n):\n            val = func(x, i ** c)\n            arr.append([val, i])\n        arr.sort(key=lambda x: (x[0], x[1]))\n        m = arr[0][0]\n        if m >= x:\n            break\n        else:\n            x = m\n    return x\nfor test in range(int(input())):\n    (n, c) = map(int, input().split())\n    print(solve(n, c))", "import math\nfrom collections import Counter\n\ndef func(x, n):\n    hcf = math.gcd(x, n)\n    lcm = x * n // hcf\n    return lcm // hcf\n\ndef solve(x, c):\n    while x > 1:\n        n = 0\n        a = 0\n        while a <= x:\n            n += 1\n            a = n ** c\n        n -= 1\n        m = x\n        arr = []\n        for i in range(1, 5 * n):\n            val = func(x, i ** c)\n            arr.append([val, i])\n        arr.sort(key=lambda x: (x[0], x[1]))\n        m = arr[0][0]\n        if m >= x:\n            break\n        else:\n            x = m\n    return x\nfor test in range(int(input())):\n    (n, c) = map(int, input().split())\n    print(solve(n, c))", "import math\n\ndef LCM(a, b):\n    return int(a * b / math.gcd(a, b))\n\ndef find_factors(n):\n    factors = []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            factors.append(n // i)\n            factors.append(i)\n        i += 1\n    return factors\n\ndef scoreFunction(x, y):\n    return int(LCM(x, y) / math.gcd(x, y))\n\ndef solve(X, c):\n    factors = find_factors(X)\n    res = [scoreFunction(X, i ** c) for i in factors]\n    return min(res)\nt = int(input())\nfor z in range(t):\n    (X, c) = map(int, input().split())\n    prevAns = solve(X, c)\n    if prevAns < X:\n        answer = prevAns\n        while True:\n            nextAns = solve(prevAns, c)\n            answer = min(nextAns, answer)\n            if nextAns >= prevAns:\n                print(answer)\n                break\n            else:\n                prevAns = answer\n    else:\n        print(X)", "import math\nimport math\n\ndef primeFactors(n):\n    mp = {}\n    while n % 2 == 0:\n        if 2 in mp:\n            mp[2] += 1\n        else:\n            mp[2] = 1\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            if i in mp:\n                mp[i] += 1\n            else:\n                mp[i] = 1\n            n //= i\n    if n > 2:\n        mp[n] = 1\n    return mp\nfor _ in range(int(input())):\n    (X, c) = map(int, input().split())\n    f = primeFactors(X)\n    ans = 1\n    for v in f:\n        f[v] %= c\n        f[v] = min(f[v], c - f[v])\n        ans *= pow(v, f[v])\n    print(ans)", "import math\n\ndef primefactors(n):\n    prime_factors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        while n % i == 0:\n            count += 1\n            n = n / i\n        if count != 0:\n            prime_factors.append((i, count))\n    if n > 1:\n        prime_factors.append((int(n), 1))\n    return prime_factors\nt = int(input())\nfor i in range(t):\n    xc = input().split(' ')\n    x = int(xc[0])\n    c = int(xc[1])\n    number = 1\n    primeFactors = primefactors(x)\n    for primeFactor in primeFactors:\n        prime = primeFactor[0]\n        power = primeFactor[1]\n        if c - power % c <= power % c:\n            number *= prime ** (c - power % c)\n        else:\n            number *= prime ** (power % c)\n    print(number)", "from math import gcd\n\ndef gc(a, b):\n    return gcd(a, b)\n\ndef lc(a, b):\n    return a * b // gc(a, b)\ntry:\n    for tc in range(int(input())):\n        (x, c) = list(map(int, input().split()))\n        if c == 1:\n            print(1)\n        else:\n            r = int(x ** (1 / 2))\n            i = r + 1\n            while i > 1:\n                if x == 1:\n                    break\n                val = i ** c\n                g = gc(x, val)\n                l = lc(x, val)\n                curr = l // g\n                if x > curr:\n                    x = curr\n                i -= 1\n            print(x)\nexcept EOFError:\n    pass", "import math\nT = int(input())\nfor ts in range(T):\n    (X, c) = map(int, input().split(' '))\n    if c == 1:\n        print(1)\n    else:\n        k = 2\n        ans = 1\n        while k ** (c // 2 + 1) <= X:\n            s = 1\n            while X % k ** s == 0:\n                s = s + 1\n            residue = (s - 1) % c\n            if residue > c // 2:\n                residue = c - residue\n            X = X // k ** (s - 1 - residue)\n            k = k + 1\n        print(X)", "import math\nfrom typing import Counter\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    return l\n\ndef solve():\n    (n, c) = list(map(int, input().split()))\n    l = primeFactors(n)\n    d = Counter(l)\n    ans = 1\n    for (i, j) in d.items():\n        if j % c != 0:\n            ans *= pow(i, min(c - j % c, j % c))\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "import math\nfrom typing import Counter\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    return l\n\ndef solve():\n    (n, c) = list(map(int, input().split()))\n    l = primeFactors(n)\n    d = Counter(l)\n    ans = 1\n    for (i, j) in d.items():\n        if j % c != 0:\n            ans *= pow(i, min(j, c - j % c, j % c))\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "import math\n\ndef isprime(n):\n    if n < 4:\n        return True\n    for i in range(2, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            return False\n    return True\n\ndef pfactorz(n) -> dict:\n    f = {}\n    if isprime(n):\n        return {n: 1}\n    i = 2\n    while n > 1:\n        while n % i == 0:\n            f.setdefault(i, 0)\n            f[i] += 1\n            n = int(n / i)\n        i += 1\n    return f\n\ndef mindiff(x, c):\n    if x > c:\n        x %= c\n    return min(abs(c - x), x)\nt = int(input())\nfor _ in range(t):\n    (x, c) = map(int, input().split())\n    if x == 1 or c == 1:\n        print(1)\n        continue\n    if isprime(x):\n        print(x)\n        continue\n    f = pfactorz(x)\n    ans = 1\n    for (key, val) in f.items():\n        md = mindiff(val, c)\n        ans = int(ans * math.pow(key, md))\n    print(ans)", "from math import gcd\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if x == 1 or c == 1:\n        print(1)\n    else:\n        val1 = int(x ** (1 / c)) + 20\n        ans = x\n        for i in range(2, val1):\n            po = i ** c\n            ans = min(ans, po * x // gcd(po, x) ** 2)\n        print(ans)", "t = int(input())\nfor _ in range(t):\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        print(1)\n        continue\n    i = 2\n    f = {}\n    cx = x\n    for i in range(2, 100002):\n        if x == 1:\n            break\n        if x % i == 0:\n            if i not in f:\n                f[i] = 0\n            while x % i == 0:\n                x //= i\n                f[i] += 1\n        i += 1\n    ans = 1\n    if x > 1:\n        f[x] = 1\n    for factor in f:\n        ans *= max(factor ** min(f[factor] % c, c - f[factor] % c), 1)\n    if not f:\n        print(cx)\n        continue\n    print(ans)", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef func(x, c):\n    root = x ** (1 / c)\n    root = int(root) + 2\n    res = x\n    for i in range(root, 0, -1):\n        j = i ** c\n        g = gcd(res, j)\n        res = min(res, res * j // g // g)\n    return res\nt = int(input())\nfor _ in range(t):\n    (x, c) = map(int, input().split())\n    print(func(x, c))", "from math import ceil, gcd, sqrt\nt = int(input())\nwhile t:\n    (x, c) = map(int, input().split(' '))\n    if x == 1 or c == 1:\n        print(1)\n    else:\n        mVal = x\n        for i in range(2, ceil(sqrt(x)) + 1):\n            if x % i == 0:\n                temp = i ** c\n                mVal = min(mVal, x * temp // (gcd(x, temp) * gcd(x, temp)))\n        print(mVal)\n    t -= 1", "def nCr(n, r):\n    return fact(n) / (fact(r) * fact(n - r))\n\ndef fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\nmod = 10 ** 4\n\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    ans = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            ans.append(p)\n    return ans\n\ndef nextPowerOf2(n):\n    count = 0\n    if n and (not n & n - 1):\n        return n\n    while n != 0:\n        n >>= 1\n        count += 1\n    return 1 << count\nfrom collections import defaultdict\nimport math\n\ndef primeFactors(n):\n    res = []\n    while n % 2 == 0:\n        res.append(2)\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            res.append(i)\n            n = n // i\n    if n > 2:\n        res.append(n)\n    return res\n\ndef upper_bound(arr, target):\n    start = 0\n    end = len(arr) - 1\n    ans = -1\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] <= target:\n            start = mid + 1\n        else:\n            ans = mid\n            end = mid - 1\n    return ans\n\ndef get_dis(s1, s2):\n    s = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'\n    a1 = s.index(s1)\n    a2 = s.rfind(s1)\n    b1 = s.index(s2)\n    b2 = s.rfind(s2)\n    return min(abs(a1 - b1), abs(a1 - b2), abs(a2 - b1), abs(a2 - b2))\nfrom collections import defaultdict\n\ndef func(l, m):\n    ans = 0\n    s = set()\n    for ele in l:\n        ans += ele % m\n        print(ans, ele % m, ele, m)\n        if ele % m in s:\n            return -1\n    print('tot', len(l) * (len(l) + 1) // 2, ans)\n    if ans == len(l) * (len(l) + 1) // 2:\n        return 1\n    return 0\n\ndef printDivisors(n):\n    i = 1\n    res = []\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                res.append(i)\n            else:\n                res.append(i)\n                res.append(n // i)\n        i = i + 1\n    return res\n\ndef func(x):\n    c = 0\n    while x != 0 and x % 2 == 0:\n        x = x // 2\n        c += 1\n    return c\nINF = 1000000000000000000000\nfrom collections import deque\n\ndef solve():\n    d = defaultdict(int)\n    (n, k) = list(map(int, input().split()))\n    lis = primeFactors(n)\n    for ele in lis:\n        d[ele] += 1\n    ans = 1\n    st = set()\n    for (ke, v) in d.items():\n        y = ke ** k\n        x = n\n        x = x * y // (math.gcd(x, y) * math.gcd(x, y))\n        while x < n:\n            n = x\n            y = ke ** k\n            x = n\n            x = x * y // (math.gcd(x, y) * math.gcd(x, y))\n    print(n)\nnum_test = 1\nnum_test = int(input())\nfor _ in range(num_test):\n    solve()", "import sys\n\ndef L():\n    return list(map(int, sys.stdin.readline().rstrip().split()))\n\ndef I():\n    return int(sys.stdin.readline())\n\ndef M():\n    return map(int, sys.stdin.readline().rstrip().split())\nfrom math import gcd\n\ndef gcd_val(a, b):\n    return gcd(a, b)\n\ndef lcm_val(a, b):\n    return a * b // gcd(a, b)\nfor _ in range(int(input())):\n    (x, c) = M()\n    if c == 1:\n        print(1)\n    else:\n        r = int(x ** (1 / 2))\n        i = r + 1\n        while i > 1:\n            if x == 1:\n                break\n            gcm = gcd_val(x, i ** c)\n            lcm = lcm_val(x, i ** c)\n            x = min(x, lcm // gcm)\n            i -= 1\n        print(x)", "import math\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        print(1)\n        continue\n    dit = {}\n    n = x\n    for i in range(2, int(math.sqrt(n)) + 2):\n        if n % i == 0:\n            dit[i] = 1\n            n = n // i\n            while n % i == 0:\n                n = n // i\n                dit[i] += 1\n    if n > 1:\n        dit[n] = 1\n    for e in dit:\n        while dit[e] >= c // 2 + 1:\n            if dit[e] >= c:\n                dit[e] -= c\n            else:\n                dit[e] = c - dit[e]\n    ans1 = 1\n    for e in dit:\n        ans1 *= e ** dit[e]\n    print(ans1)", "import math\nfor _ in range(int(input())):\n    (x, c) = map(int, input().split())\n    a = set()\n    for i in range(1, int(x ** 0.5) + 1):\n        if x % i == 0:\n            a.add(i)\n            a.add(x // i)\n    b = x\n    for i in a:\n        b = min(b, x * i ** c // math.gcd(x, i ** c) ** 2)\n    print(b)", "from math import gcd\ntry:\n    for tc in range(int(input())):\n        (x, c) = list(map(int, input().split()))\n        if c == 1:\n            print(1)\n        else:\n            r = int(x ** (1 / 2))\n            i = r + 1\n            while i > 1:\n                if x == 1:\n                    break\n                gcm = gcd(x, i ** c)\n                lcm = x * i ** c // gcm\n                x = min(x, lcm // gcm)\n                i -= 1\n            print(x)\nexcept EOFError:\n    pass", "from math import gcd\ntry:\n    for tc in range(int(input())):\n        (x, c) = list(map(int, input().split()))\n        if c == 1:\n            print(1)\n        else:\n            r = int(x ** (1 / 2))\n            for i in range(r + 1, 1, -1):\n                if x == 1:\n                    break\n                gc = gcd(x, i ** c)\n                lc = x * i ** c // gc\n                x = min(x, lc // gc)\n            print(x)\nexcept EOFError:\n    pass", "import math\nt = int(input())\nprime = [True for i in range(10 ** 6 + 10 + 1)]\np = []\n\ndef SieveOfEratosthenes(n):\n    r = 2\n    while r * r <= n:\n        if prime[r] == True:\n            for i in range(r * r, n + 1, r):\n                prime[i] = False\n        r += 1\n    for r in range(2, n + 1):\n        if prime[r]:\n            p.append(r)\nSieveOfEratosthenes(10 ** 6 + 10)\nwhile t > 0:\n    a = input().split()\n    (x, c) = (int(a[0]), int(a[1]))\n    ans = 1\n    n = len(p)\n    for i in range(n):\n        cur = 0\n        while x % p[i] == 0:\n            cur += 1\n            x = x // p[i]\n        cur = cur % c\n        if cur > 0:\n            g = math.gcd(c, cur)\n            g = min(cur, c - cur)\n            ans = ans * p[i] ** g\n    print(ans * x)\n    t -= 1", "import math\nfor j in range(int(input())):\n    (x, c) = map(int, input().split())\n    l = []\n    i = 1\n    while i <= math.sqrt(x):\n        if x % i == 0:\n            if x / i == i:\n                l.append(i)\n            else:\n                l.extend([i, x // i])\n        i = i + 1\n    l.sort()\n    mi = x\n    for i in l:\n        g = math.gcd(x, i ** c)\n        mi = min(mi, i ** c * x // g // g)\n    print(mi)", "from bisect import bisect_left\nfrom re import sub\nfrom typing import DefaultDict\nimport math\nfrom collections import defaultdict\nfrom math import sqrt\nimport collections\nfrom sys import maxsize\nfrom itertools import combinations_with_replacement\nimport sys\n\ndef sieve_erasthones(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    for p in range(n + 1):\n        if prime[p]:\n            cnt += 1\n    return cnt\n\ndef calculate(p, q):\n    mod = 998244353\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n\ndef count_factors(n):\n    i = 1\n    c = 0\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n // i == i:\n                c += 1\n            else:\n                c += 2\n        i += 1\n    return c\n\ndef ncr_modulo(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef isprime(n):\n    prime_flag = 0\n    if n > 1:\n        for i in range(2, int(sqrt(n)) + 1):\n            if n % i == 0:\n                prime_flag = 1\n                break\n        if prime_flag == 0:\n            return True\n        else:\n            return False\n    else:\n        return True\n\ndef smallestDivisor(n):\n    if n % 2 == 0:\n        return 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return i\n        i += 2\n    return n\n\ndef dict_ele_count(l):\n    d = DefaultDict(lambda : 0)\n    for ele in l:\n        d[ele] += 1\n    return d\n\ndef max_in_dict(d):\n    maxi = 0\n    for ele in d:\n        if d[ele] > maxi:\n            maxi = d[ele]\n    return maxi\n\ndef element_count(s):\n    l = []\n    k = s[0]\n    c = 0\n    for ele in s:\n        if ele == k:\n            c += 1\n        else:\n            l.append([k, c])\n            k = ele\n            c = 1\n    l.append([k, c])\n    return l\n\ndef modular_exponentiation(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 != 0:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef number_of_primefactor(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return len(set(l))\n\ndef twosum(a, n, x):\n    rem = []\n    for i in range(x):\n        rem.append(0)\n    for i in range(n):\n        if a[i] < x:\n            rem[a[i] % x] += 1\n    for i in range(1, x // 2):\n        if rem[i] > 0 and rem[x - i] > 0:\n            return True\n    if i >= x // 2:\n        if x % 2 == 0:\n            if rem[x // 2] > 1:\n                return True\n            else:\n                return False\n        elif rem[x // 2] > 0 and rem[x - x // 2] > 0:\n            return True\n        else:\n            return False\n\ndef divSum(num):\n    result = 0\n    i = 2\n    while i <= math.sqrt(num):\n        if num % i == 0:\n            if i == num / i:\n                result = result + i\n            else:\n                result = result + (i + num / i)\n        i = i + 1\n    return result + 1 + num\n\ndef subsequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\n\ndef primeFactors(n):\n    d = defaultdict(lambda : 0)\n    while n % 2 == 0:\n        d[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[int(i)] += 1\n            n = n / i\n    if n > 2:\n        d[int(n)] += 1\n    return d\n\ndef solve():\n    (x, c) = map(int, input().split())\n    d = primeFactors(x)\n    for ele in d:\n        k = d[ele]\n        while k > k + c - 2 * min(k, c):\n            k = k + c - 2 * min(k, c)\n            d[ele] = k\n    ans = 1\n    for ele in d:\n        ans *= ele ** d[ele]\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "from math import gcd, log, ceil\nfor _ in range(int(input())):\n    (X, c) = map(int, input().split())\n    if c == 1 or X == 1:\n        print(1)\n    else:\n        n = ceil(pow(X, 1 / c)) + 1\n        b = pow(n, c)\n        while n > 1:\n            t = X * b // pow(gcd(X, b), 2)\n            if t < X:\n                X = t\n                n += 1\n            n -= 1\n            b = pow(n, c)\n        print(X)", "import sys\ninput = sys.stdin.readline\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\nt = int(input())\nfor _ in range(t):\n    (x, c) = map(int, input().split())\n    i = 1\n    temp = x\n    ans = 10 ** 291\n    while i * i <= x:\n        if x % i == 0:\n            j = x // i\n            g1 = gcd(x, i ** c)\n            g2 = gcd(x, j ** c)\n            l1 = lcm(x, i ** c)\n            l2 = lcm(x, j ** c)\n            ans = min(ans, l1 // g1)\n            ans = min(ans, l2 // g2)\n        i = i + 1\n    print(ans)", "def PrimeFact(n):\n    import math\n    factors = {}\n    for i in range(2, int(math.sqrt(n)) + 1):\n        c = 0\n        while n % i == 0:\n            n //= i\n            c += 1\n            factors[i] = c\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef main():\n    (x, c) = map(int, input().split())\n    if c == 1 or x == 1:\n        return 1\n    dec = PrimeFact(x)\n    ans = 1\n    for (k, v) in dec.items():\n        cnt = v % c\n        dec[k] = min(cnt, c - cnt)\n        ans *= pow(k, dec[k])\n    return ans\nfor _ in range(int(input())):\n    print(main())", "import math\n\ndef power(x, y):\n    res = 1\n    while y > 0:\n        if y & 1 != 0:\n            res = res * x\n        y = y >> 1\n        x = x * x\n    return res\nt = int(input())\nwhile t:\n    (x, c) = [int(x) for x in input().split()]\n    if c == 1:\n        print(1)\n    else:\n        ans = int(10000000000.0 + 1)\n        for i in range(1, 1000):\n            den = math.gcd(x, power(i, c))\n            den = den * den\n            num = x * power(i, c)\n            temp = num // den\n            if temp < ans:\n                ans = temp\n        print(ans)\n    t = t - 1", "import math\n\ndef power(x, y):\n    res = 1\n    while y > 0:\n        if y & 1 != 0:\n            res = res * x\n        y = y >> 1\n        x = x * x\n    return res\nt = int(input())\nwhile t:\n    (x, c) = [int(x) for x in input().split()]\n    if c == 1:\n        print(1)\n    else:\n        ans = int(10000000000.0 + 1)\n        for i in range(1, 1000):\n            den = math.gcd(x, power(i, c))\n            den = den * den\n            num = x * power(i, c)\n            temp = num // den\n            if temp < ans:\n                ans = temp\n        print(ans)\n    t = t - 1", "from collections import Counter\nimport math\n\ndef primeFactors(n):\n    arr = []\n    while n % 2 == 0:\n        arr.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            arr.append(i)\n            n = n / i\n    if n > 2:\n        arr.append(int(n))\n    return arr\ntc = int(input())\nfor _ in range(tc):\n    (x, c) = map(int, input().split())\n    factors = Counter(primeFactors(x))\n    ans = 1\n    for i in factors:\n        cur = factors[i]\n        cur %= c\n        cur = min(cur, c - cur)\n        ans *= i ** cur\n    print(ans)", "import sys\nfrom math import sqrt, gcd, factorial, ceil, floor\nfrom collections import deque, Counter, OrderedDict\nfrom heapq import heapify, heappush, heappop\ninput = lambda : sys.stdin.readline()\nI = lambda : int(input())\nS = lambda : input().strip()\nM = lambda : map(int, input().strip().split())\nL = lambda : list(map(int, input().strip().split()))\nmod = 1000000007\n\ndef solver(n):\n    while n % 2 == 0:\n        if 2 not in d:\n            d[2] = 0\n        d[2] += 1\n        n //= 2\n    for i in range(3, int(sqrt(n) + 1), 2):\n        if i not in d:\n            d[i] = 0\n        while n % i == 0:\n            d[i] += 1\n            n //= i\n    if n > 2:\n        d[n] = 1\nfor _ in range(I()):\n    d = {}\n    (x, c) = M()\n    solver(x)\n    ans = 1\n    for i in d:\n        ans *= i ** min(c - d[i] % c, d[i] % c)\n    print(ans)", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom queue import PriorityQueue\nfrom queue import Queue\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nimport random\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\ngp = []\nans = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\n\ndef flip(a, l, r):\n    for i in range(l, r):\n        a[i] = '0' if a[i] == '1' else '1'\n    return\n\ndef hnbhai(tc):\n    (n, c) = sd()\n    d = {}\n    x = 2\n    while x * x <= n:\n        cnt = 0\n        while n % x == 0:\n            n //= x\n            cnt += 1\n        d[x] = cnt\n        x += 1\n    if n > 1:\n        d[n] = 1\n    ans = 1\n    for i in d:\n        ans *= i ** min(c - d[i] % c, d[i] % c)\n    print(ans)\n    return\nfor _ in range(sb()):\n    hnbhai(_ + 1)"]