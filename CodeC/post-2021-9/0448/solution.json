["from math import sqrt\nMAX = int(sqrt(10 ** 9) + 1e-05)\npa = [True] * MAX\ni = 2\nwhile i * i <= MAX:\n    if pa[i - 1]:\n        j = i * i\n        while j <= MAX:\n            pa[j - 1] = False\n            j += i\n    i += 1\npr = [num for num in range(2, MAX) if pa[num - 1]]\nfor _ in range(int(input())):\n    N = int(input())\n    nmb = N\n    me = 0\n    res = 0\n    for p in pr:\n        e = 0\n        while nmb % p == 0:\n            nmb //= p\n            e += 1\n        if e > me:\n            res = p\n            me = e\n    if me == 0:\n        res = N\n    print(res)", "def solve():\n    n = int(input())\n    i = 2\n    (maxfreq, v) = (0, -1)\n    while i * i <= n:\n        count = 0\n        while n % i == 0:\n            count += 1\n            n //= i\n        if count > maxfreq:\n            maxfreq = count\n            v = i\n        i += 1\n    if maxfreq:\n        return v\n    return n\nt = int(input())\nwhile t:\n    print(solve())\n    t -= 1", "def solve():\n    n = int(input())\n    i = 2\n    (maxfreq, v) = (0, -1)\n    while i * i <= n:\n        count = 0\n        while n % i == 0:\n            count += 1\n            n //= i\n        if count > maxfreq:\n            maxfreq = count\n            v = i\n        i += 1\n    if maxfreq:\n        return v\n    return n\nt = int(input())\nwhile t:\n    print(solve())\n    t -= 1", "def solve():\n    n = int(input())\n    i = 2\n    factors = []\n    while i * i <= n:\n        count = 0\n        while n % i == 0:\n            count += 1\n            n //= i\n        if count:\n            factors.append([-count, i])\n        i += 1\n    if factors:\n        factors.sort()\n        return factors[0][1]\n    return n\nt = int(input())\nwhile t:\n    print(solve())\n    t -= 1", "import math\nmx = math.ceil(math.sqrt(10 ** 9))\nprimes = []\nprime = [True] * mx\nfor i in range(2, mx):\n    if prime[i]:\n        primes.append(i)\n        for i in range(i ** 2, mx, i):\n            prime[i] = False\nfor _ in range(int(input())):\n    N = int(input())\n    mx = 0\n    val = N\n    for i in primes:\n        if i * i > N:\n            break\n        if N % i == 0:\n            j = 1\n            while not N % i ** j:\n                j += 1\n            if j > mx:\n                mx = j\n                val = i\n    print(val)", "import math\npf = []\n\ndef pfe(x, l):\n    for i in range(l, math.floor(math.sqrt(x)) + 2):\n        if x % i == 0:\n            pf.append(i)\n            pfe(x // i, i)\n            return\n    if x > 1:\n        pf.append(x)\nfor tea in [0] * int(input()):\n    n = int(input())\n    pf = []\n    pfe(n, 2)\n    lol = dict()\n    for i in pf:\n        if i in lol:\n            lol[i] += 1\n        else:\n            lol[i] = 1\n    maxx = -1\n    deMax = -1\n    for i in sorted(list(lol)):\n        if lol[i] > maxx:\n            maxx = lol[i]\n            deMax = i\n    print(deMax)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    i = 2\n    M = 0\n    while i * i <= n:\n        if n % i == 0:\n            cnt = 0\n            while n % i == 0:\n                n //= i\n                cnt += 1\n            if cnt > M:\n                M = cnt\n                ans = i\n        i += 1\n    if n > 1 and M == 0:\n        ans = n\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    i = 2\n    M = 0\n    while i * i <= n:\n        if n % i == 0:\n            cnt = 0\n            while n % i == 0:\n                n //= i\n                cnt += 1\n            if cnt > M:\n                M = cnt\n                ans = i\n        i += 1\n    if n > 1 and M == 0:\n        ans = n\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    i = 2\n    M = 0\n    while i * i <= n:\n        if n % i == 0:\n            cnt = 0\n            while n % i == 0:\n                n //= i\n                cnt += 1\n            if cnt > M:\n                M = cnt\n                ans = i\n        i += 1\n    if n > 1 and M == 0:\n        ans = n\n    print(ans)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    ans = n\n    maxp = 0\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            p = 0\n            while n % i == 0:\n                p += 1\n                n = n // i\n            if p > maxp:\n                maxp = p\n                ans = i\n        i += 1\n    print(ans)", "def func(n):\n    mp = 0\n    no = n\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            temp = n\n            p = 0\n            while n % i == 0:\n                n = n // i\n                p += 1\n            if mp < p:\n                mp = p\n                no = i\n        i += 1\n    return no\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(func(n))", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    ans = n\n    maxp = 0\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            p = 0\n            while n % i == 0:\n                p += 1\n                n = n // i\n            if p > maxp:\n                maxp = p\n                ans = i\n        i += 1\n    print(ans)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    ans = n\n    maxp = 0\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            p = 0\n            while n % i == 0:\n                p += 1\n                n = n // i\n            if p > maxp:\n                maxp = p\n                ans = i\n        i += 1\n    print(ans)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    ans = n\n    maxp = 0\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            p = 0\n            while n % i == 0:\n                p += 1\n                n = n // i\n            if p > maxp:\n                maxp = p\n                ans = i\n        i += 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    i = 2\n    res = n\n    mxp = 0\n    while i * i <= n:\n        if n % i == 0:\n            powr = 0\n            while n % i == 0:\n                n = n // i\n                powr += 1\n            if powr > mxp:\n                mxp = powr\n                res = i\n        i += 1\n    print(res)", "from sys import stdin\nfrom math import sqrt\n\ndef check(n):\n    dic = {2: 0}\n    while n % 2 == 0:\n        dic[2] += 1\n        n = n / 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            if i not in dic.keys():\n                dic[i] = 1\n            else:\n                dic[i] += 1\n            n = n / i\n    if n > 2:\n        dic[n] = 1\n    (key, mx) = (0, 0)\n    for i in dic.keys():\n        if dic[i] > mx:\n            key = i\n            mx = dic[i]\n    return int(key)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(check(n))", "from math import ceil, log, floor, sqrt, gcd\nfor _ in range(int(input())):\n    n = int(input())\n    ans = 0\n    pcnt = 0\n    cnt = 0\n    while n % 2 == 0:\n        cnt += 1\n        n = n / 2\n    if cnt > 0:\n        pcnt = cnt\n        ans = 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        cnt = 0\n        if n % i == 0:\n            while n % i == 0:\n                cnt += 1\n                n = n / i\n            if cnt > pcnt:\n                pcnt = cnt\n                ans = i\n    if ans == 0:\n        ans = n\n    print(ans)", "import math\nfor _ in range(int(input())):\n\n    def func(x):\n        return d[x]\n    N = int(input())\n    d = {}\n    while N % 2 == 0:\n        if 2 in d:\n            d[2] += 1\n        else:\n            d[2] = 1\n        N = N // 2\n    for i in range(3, int(math.sqrt(N)) + 1, 2):\n        while N % i == 0:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n            N = N // i\n        if N == 1:\n            break\n    if N > 2:\n        d[N] = 1\n    a = sorted(d, key=func, reverse=True)\n    print(a[0])", "from collections import Counter\n\ndef get_prime_number(n):\n    i = 2\n    prime_number = []\n    while i * i <= n:\n        if n % i == 0:\n            prime_number.append(i)\n            n //= i\n        else:\n            i += 1\n    if n > 1:\n        prime_number.append(n)\n    return prime_number\nfor _ in range(int(input())):\n    n = int(input())\n    arr = get_prime_number(n)\n    d = Counter(arr)\n    key = list(d.keys())\n    value = list(d.values())\n    print(key[value.index(max(value))])", "from collections import Counter\n\ndef get_prime_factors(n):\n    i = 2\n    prime_factors = []\n    while i * i <= n:\n        if n % i == 0:\n            prime_factors.append(i)\n            n //= i\n        else:\n            i += 1\n    if n > 1:\n        prime_factors.append(n)\n    return prime_factors\nfor _ in range(int(input())):\n    n = int(input())\n    arr = get_prime_factors(n)\n    d = Counter(arr)\n    key = list(d.keys())\n    value = list(d.values())\n    print(key[value.index(max(value))])", "import math\nfrom collections import Counter\n\ndef primeFactors(n):\n    arr = []\n    while n % 2 == 0:\n        arr.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            arr.append(i)\n            n = n / i\n    if n > 2:\n        arr.append(n)\n    cnt = Counter(arr)\n    vmax = max(cnt.values())\n    for (k, v) in cnt.items():\n        if v == vmax:\n            return k\nT = int(input())\nfor tc in range(T):\n    n = int(input())\n    print(primeFactors(n))", "from collections import Counter\n\ndef get_prime_factors(n):\n    i = 2\n    prime_factors = []\n    while i * i <= n:\n        if n % i == 0:\n            prime_factors.append(i)\n            n //= i\n        else:\n            i += 1\n    if n > 1:\n        prime_factors.append(n)\n    return prime_factors\nfor _ in range(int(input())):\n    n = int(input())\n    arr = get_prime_factors(n)\n    d = Counter(arr)\n    key = list(d.keys())\n    value = list(d.values())\n    print(key[value.index(max(value))])", "import math\nfor i in range(int(input())):\n    dic = {2: 0}\n    n = int(input())\n    while n % 2 == 0:\n        n = n / 2\n        dic[2] += 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            n = n / i\n            if i not in dic:\n                dic[i] = 1\n            else:\n                dic[i] += 1\n    if n > 2:\n        dic[n] = 1\n    (maxx, key) = (0, 0)\n    for i in dic.keys():\n        if dic[i] > maxx:\n            maxx = dic[i]\n            key = i\n    print(key)", "import math\n\ndef primeFactors(n):\n    u = []\n    maxi = 0\n    r = 0\n    find = 0\n    while n % 2 == 0:\n        (u.append(2),)\n        n = n / 2\n        r = r + 1\n        if r > maxi:\n            maxi = r\n            find = 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        r = 0\n        while n % i == 0:\n            u.append(i)\n            n = n / i\n            r = r + 1\n        if r > maxi:\n            maxi = r\n            find = i\n    r = 0\n    if n > 2:\n        u.append(n)\n        r = r + 1\n        if r > maxi:\n            maxi = r\n            find = n\n    return find\nm = int(input())\nfor i in range(0, m):\n    t = int(input())\n    v = primeFactors(t)\n    print(v)", "import math\nfor i in range(int(input())):\n    n = int(input())\n    dictt = {2: 0}\n    while n % 2 == 0:\n        n = n / 2\n        dictt[2] += 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            n = n / i\n            if i in list(dictt.keys()):\n                dictt[i] += 1\n            else:\n                dictt[i] = 1\n    if n > 2:\n        dictt[n] = 1\n    maxx = 0\n    pf = 0\n    for i in list(dictt.keys()):\n        if dictt[i] > maxx:\n            maxx = dictt[i]\n            pf = i\n    print(pf)", "import math\nfor i in range(int(input())):\n    n = int(input())\n    dictt = {2: 0}\n    while n % 2 == 0:\n        n = n / 2\n        dictt[2] += 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            n = n / i\n            if i in list(dictt.keys()):\n                dictt[i] += 1\n            else:\n                dictt[i] = 1\n    if n > 2:\n        dictt[n] = 1\n    maxx = 0\n    pf = 0\n    for i in list(dictt.keys()):\n        if dictt[i] > maxx:\n            maxx = dictt[i]\n            pf = i\n    print(pf)", "import math\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    cnt = 0\n    l = []\n    while n % 2 == 0:\n        cnt += 1\n        n = n // 2\n    l.append((2, cnt))\n    for p in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % p == 0:\n            cnt = 0\n            while n % p == 0:\n                n = n // p\n                cnt += 1\n            l.append((p, cnt))\n    if n > 2:\n        l.append((n, 1))\n    print(l[l.index(max(l, key=lambda x: x[1]))][0])\n    t -= 1", "try:\n    from collections import Counter\n    import math\n\n    def primeFactors(n):\n        gl = []\n        while n % 2 == 0:\n            gl.append(2)\n            n = n / 2\n        for i in range(3, int(math.sqrt(n)) + 1, 2):\n            while n % i == 0:\n                gl.append(i)\n                n = n / i\n        if n > 2:\n            gl.append(n)\n        return gl\n    for _ in range(int(input())):\n        n = int(input())\n        cc = primeFactors(n)\n        c = list(Counter(cc).most_common())\n        print(c[0][0])\nexcept:\n    pass", "import heapq\nimport math\nimport sys\nimport collections\nimport bisect\nimport time\nimport random\nimport itertools\nimport string\nfrom collections import Counter, defaultdict\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\nimport math\n\ndef primeFactors(n):\n    ans = []\n    while n % 2 == 0:\n        ans.append(2)\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            ans.append(i)\n            n = n // i\n    if n > 2:\n        ans.append(n)\n    return ans\nfor t in range(int(input())):\n    n = int(input())\n    pf = primeFactors(n)\n    counter = collections.Counter(pf)\n    val = max(counter.values())\n    ans = 10 ** 10\n    for i in counter:\n        if counter[i] == val:\n            ans = min(ans, i)\n    print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    d = defaultdict(int)\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            d[i] += 1\n            n //= i\n        i += 1\n    if n > 1:\n        d[n] = 1\n    print(-max(((v, -k) for (k, v) in d.items()))[1])", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    div = defaultdict(lambda : 0)\n    while n % 2 == 0:\n        div[2] += 1\n        n /= 2\n        p = False\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            div[i] += 1\n            n /= i\n        i += 2\n    if n > 2:\n        div[n] += 1\n    print(max(div, key=lambda x: div[x]))", "def countDivisors(n):\n    cnt = 0\n    ans = 0\n    curr = 0\n    while n % 2 == 0:\n        n //= 2\n        cnt += 1\n    if cnt > curr:\n        ans = 2\n        curr = cnt\n    i = 3\n    while i * i <= n:\n        cnt = 0\n        while n % i == 0:\n            n //= i\n            cnt += 1\n        if cnt > curr:\n            ans = i\n            curr = cnt\n        i += 2\n    if n > 1:\n        if 1 > curr:\n            ans = n\n            curr = 1\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    print(countDivisors(n))", "import math\n\ndef countDivisors(n):\n    dic = dict()\n    while n % 2 == 0:\n        if 2 not in dic:\n            dic[2] = 0\n        dic[2] += 1\n        print\n        (2,)\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            if i not in dic:\n                dic[i] = 0\n            dic[i] += 1\n            n = n // i\n    if n > 2:\n        if n not in dic:\n            dic[n] = 0\n        dic[n] += 1\n    return dic\nfor t in range(int(input())):\n    N = int(input())\n    count = countDivisors(N)\n    maxCount = max(count.values())\n    arr = []\n    for i in count.keys():\n        if count.get(i) == maxCount:\n            arr.append(i)\n    print(min(arr))", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    ans = n\n    lc = 1\n    a2 = 1\n    while n % 2 == 0:\n        lc += 1\n        n = n // 2\n    if lc > a2:\n        a2 = lc\n        ans = 2\n    end = int(n ** 0.5)\n    for i in range(3, math.ceil(math.sqrt(n)) + 1, 2):\n        lc = 1\n        if n % i == 0:\n            while n % i == 0:\n                lc += 1\n                n = n // i\n            if lc > a2:\n                a2 = lc\n                ans = i\n    print(ans)", "import math\nfrom collections import defaultdict\nimport math\n\ndef primeFactors(n):\n    d = defaultdict(int)\n    while n % 2 == 0:\n        d[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[i] += 1\n            n = n / i\n    if n > 2:\n        d[n] += 1\n    return d\nfor _ in range(int(input())):\n    n = int(input())\n    d = primeFactors(n)\n    maxi = max(d.values())\n    for i in sorted(d.keys()):\n        if d[i] == maxi:\n            print(i)\n            break", "from math import sqrt\nfrom sys import stdin\ninput = stdin.readline\n\ndef primeFactor(n):\n    d = {}\n    while n % 2 == 0:\n        if 2 not in d:\n            d[2] = 1\n        else:\n            d[2] += 1\n        n //= 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0 and n:\n            if i not in d:\n                d[i] = 1\n            else:\n                d[i] += 1\n            n //= i\n    if len(d) == 0:\n        print(n)\n    else:\n        print(max(d, key=d.get))\nfor _ in range(int(input())):\n    n = int(input())\n    k = 0\n    primeFactor(n)", "def minPrimeDiv(n):\n    mx = 0\n    minPrime = 1000000007\n    i = 2\n    y = n\n    while i * i <= y:\n        nof = 0\n        while y % i == 0:\n            nof += 1\n            y = y // i\n        if mx < nof:\n            mx = nof\n            minPrime = i\n        i += 1\n    if mx == 0:\n        return n\n    else:\n        return minPrime\nt = int(input())\nfor tc in range(t):\n    n = int(input())\n    print(minPrimeDiv(n))", "import math\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n /= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return l\nt = int(input())\nwhile t:\n    t -= 1\n    x = int(input())\n    l = primeFactors(x)\n    l1 = []\n    lf = []\n    ans = 0\n    cnt = 0\n    for i in l:\n        if i not in l1:\n            l1.append(i)\n    for i in range(len(l1)):\n        x = l1[i]\n        if l.count(x) > cnt:\n            cnt = l.count(x)\n            ans = x\n    print(int(ans))", "from math import ceil, gcd, factorial, sqrt, floor\nimport queue\nimport re\nfrom itertools import permutations, combinations, accumulate\nfrom collections import Counter, deque\nfrom sys import stdin, stdout\nfrom bisect import bisect, insort, bisect_left, insort_left\ninput = lambda : stdin.readline()\n\ndef sieve(n):\n    prime = [True] * (n + 1)\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for l1 in range(p * p, n + 1, p):\n                prime[l1] = False\n        p += 1\n    return prime\n\ndef simplesieve(n):\n    prime = [2]\n    mark = [False] * (n + 1)\n    for p in range(3, n + 1, 2):\n        if mark[p] == False:\n            prime.append(p)\n            if p * p <= n:\n                for l1 in range(p * p, n + 1, 2 * p):\n                    mark[l1] = True\n    return prime\n\ndef segementedsieve(low, high):\n    limit = int(sqrt(high))\n    primes = simplesieve(limit)\n    prime = [True] * (high - low + 1)\n    for l1 in primes:\n        lower = low // l1\n        if lower <= 1:\n            lower = l1 + l1\n        elif low % l1 != 0:\n            lower = lower * l1 + l1\n        else:\n            lower = lower * l1\n        for l2 in range(lower, high + 1, l1):\n            prime[l2 - low] = False\n    s1 = []\n    s = 0\n    for l in range(low, high + 1):\n        if prime[l - low]:\n            s1.append(l)\n    return s1\n\ndef isprime(n):\n    if n == 2:\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    for l1 in range(3, int(n ** 0.5) + 1, 2):\n        if n % l1 == 0:\n            return False\n    return True\n\ndef binpow(s1, s2, s):\n    r2 = 1\n    s1 = s1 % s\n    while s2 > 0:\n        if s2 & 1:\n            r2 = r2 * s1 % s\n        s1 = s1 * s1 % s\n        s2 >>= 1\n    return r2\n\ndef lcm(s1, s2):\n    return s1 // gcd(s1, s2) * s2\n\ndef gcdExtended(s1, s2):\n    if s2 == 0:\n        return (s1, 1, 0)\n    (g, x1, y1) = gcdExtended(s2, s1 % s2)\n    l1 = y1\n    l2 = x1 - s1 // s2 * y1\n    return (g, l1, l2)\n\ndef dfs(graph, s, l1):\n    v = [0] * (s + 1)\n    v[l1] = 1\n    s1 = [l1]\n    z = 0\n    while s1 != []:\n        l = s1.pop()\n        for l1 in graph[l]:\n            if v[l1] == 0:\n                v[l1] = 1\n                s1.append(l1)\n    return 'no'\n\ndef bfs(graph, n, x, dest):\n    v = [0] * (1 + n)\n    d = [0] * (1 + n)\n    d[x] = 0\n    v[x] = 1\n    q = queue.Queue()\n    q.put(x)\n    while not q.empty():\n        z = q.get()\n        for s in graph[z]:\n            if v[s] == 0:\n                v[s] = 1\n                d[s] = d[z] + 1\n                q.put(s)\n    return d[dest]\nprime = simplesieve(31623)\nfor _ in range(int(input())):\n    n = int(input())\n    k = n\n    m = 0\n    ans = n\n    for i in prime:\n        if i > k:\n            break\n        if k % i == 0:\n            c = 0\n            while k % i == 0:\n                c += 1\n                k = k // i\n            if m < c:\n                m = c\n                ans = i\n    print(ans)", "from math import ceil, gcd, factorial, sqrt, floor\nimport queue\nimport re\nfrom itertools import permutations, combinations, accumulate\nfrom collections import Counter, deque\nfrom sys import stdin, stdout\nfrom bisect import bisect, insort, bisect_left, insort_left\ninput = lambda : stdin.readline()\n\ndef sieve(n):\n    prime = [True] * (n + 1)\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for l1 in range(p * p, n + 1, p):\n                prime[l1] = False\n        p += 1\n    return prime\n\ndef simplesieve(n):\n    prime = [2]\n    mark = [False] * (n + 1)\n    for p in range(3, n + 1, 2):\n        if mark[p] == False:\n            prime.append(p)\n            if p * p <= n:\n                for l1 in range(p * p, n + 1, 2 * p):\n                    mark[l1] = True\n    return prime\n\ndef segementedsieve(low, high):\n    limit = int(sqrt(high))\n    primes = simplesieve(limit)\n    prime = [True] * (high - low + 1)\n    for l1 in primes:\n        lower = low // l1\n        if lower <= 1:\n            lower = l1 + l1\n        elif low % l1 != 0:\n            lower = lower * l1 + l1\n        else:\n            lower = lower * l1\n        for l2 in range(lower, high + 1, l1):\n            prime[l2 - low] = False\n    s1 = []\n    s = 0\n    for l in range(low, high + 1):\n        if prime[l - low]:\n            s1.append(l)\n    return s1\n\ndef isprime(n):\n    if n == 2:\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    for l1 in range(3, int(n ** 0.5) + 1, 2):\n        if n % l1 == 0:\n            return False\n    return True\n\ndef binpow(s1, s2, s):\n    r2 = 1\n    s1 = s1 % s\n    while s2 > 0:\n        if s2 & 1:\n            r2 = r2 * s1 % s\n        s1 = s1 * s1 % s\n        s2 >>= 1\n    return r2\n\ndef lcm(s1, s2):\n    return s1 // gcd(s1, s2) * s2\n\ndef gcdExtended(s1, s2):\n    if s2 == 0:\n        return (s1, 1, 0)\n    (g, x1, y1) = gcdExtended(s2, s1 % s2)\n    l1 = y1\n    l2 = x1 - s1 // s2 * y1\n    return (g, l1, l2)\n\ndef dfs(graph, s, l1):\n    v = [0] * (s + 1)\n    v[l1] = 1\n    s1 = [l1]\n    z = 0\n    while s1 != []:\n        l = s1.pop()\n        for l1 in graph[l]:\n            if v[l1] == 0:\n                v[l1] = 1\n                s1.append(l1)\n    return 'no'\n\ndef bfs(graph, n, x, dest):\n    v = [0] * (1 + n)\n    d = [0] * (1 + n)\n    d[x] = 0\n    v[x] = 1\n    q = queue.Queue()\n    q.put(x)\n    while not q.empty():\n        z = q.get()\n        for s in graph[z]:\n            if v[s] == 0:\n                v[s] = 1\n                d[s] = d[z] + 1\n                q.put(s)\n    return d[dest]\nprime = simplesieve(10 ** 5 + 1)\nfor _ in range(int(input())):\n    n = int(input())\n    k = n\n    m = 0\n    ans = n\n    for i in prime:\n        if i > k:\n            break\n        if k % i == 0:\n            c = 0\n            while k % i == 0:\n                c += 1\n                k = k // i\n            if m < c:\n                m = c\n                ans = i\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = {}\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n = n // i\n            if i not in d:\n                d[i] = 0\n            d[i] += 1\n        else:\n            i = i + 1\n    if n not in d:\n        d[n] = 0\n    d[n] += 1\n    mx = max(d.values())\n    a = list(d.keys())\n    for i in range(len(a)):\n        if d[a[i]] == mx:\n            break\n    print(a[i])", "import math\n\ndef primeFactors(n):\n    dic = {2: 0}\n    while n % 2 == 0:\n        dic[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            if i not in dic.keys():\n                dic[i] = 1\n            else:\n                dic[i] += 1\n            n = n / i\n    if n > 2:\n        dic[n] = 1\n    (key, max) = (0, 0)\n    for i in dic.keys():\n        if dic[i] > max:\n            key = i\n            max = dic[i]\n    print(key)\nfor _ in range(int(input())):\n    n = int(input())\n    primeFactors(n)", "import math\nfrom collections import defaultdict\nimport math\n\ndef primeFactors(n):\n    d = defaultdict(int)\n    while n % 2 == 0:\n        d[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[i] += 1\n            n = n / i\n    if n > 2:\n        d[n] += 1\n    return d\nfor _ in range(int(input())):\n    n = int(input())\n    d = primeFactors(n)\n    maxi = max(d.values())\n    for i in sorted(d.keys()):\n        if d[i] == maxi:\n            print(i)\n            break", "from collections import defaultdict\nimport math\n\ndef primeFactors(n):\n    d = defaultdict(int)\n    while n % 2 == 0:\n        d[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[i] += 1\n            n = n / i\n    if n > 2:\n        d[n] += 1\n    return d\nfor _ in range(int(input())):\n    n = int(input())\n    d = primeFactors(n)\n    maxi = max(d.values())\n    for i in sorted(d.keys()):\n        if d[i] == maxi:\n            print(i)\n            break", "def prime_factors(n):\n    (i, factors) = (2, [])\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return list(set(factors))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    primes = prime_factors(n)\n    count = []\n    for prime in primes:\n        k = n\n        counter = 0\n        while k % prime == 0:\n            counter += 1\n            k = k // prime\n        count.append(counter)\n    check2 = -1\n    check1 = []\n    max_occur = 0\n    for i in range(len(primes)):\n        if count[i] > 1:\n            if max_occur == 0:\n                check2 = primes[i]\n                max_occur = count[i]\n            elif count[i] > max_occur:\n                check2 = primes[i]\n                max_occur = count[i]\n            elif count[i] == max_occur:\n                check2 = min(check2, primes[i])\n        else:\n            check1.append(primes[i])\n    if check2 == -1:\n        ans = min(check1)\n    else:\n        ans = check2\n    print(ans)", "import math\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    d = defaultdict(int)\n    if not n & 1:\n        while n % 2 == 0:\n            d[2] += 1\n            n //= 2\n    if n != 1:\n        for i in range(3, int(math.sqrt(n)) + 1, 2):\n            while n % i == 0:\n                d[i] += 1\n                n //= i\n            if n == 1:\n                break\n        else:\n            d[n] = 1\n    print(max(d, key=lambda x: d[x]))", "from collections import defaultdict\nimport math\n\ndef solve(N):\n    d = defaultdict(int)\n    while N % 2 == 0:\n        d[2] += 1\n        N //= 2\n    i = 0\n    for i in range(3, int(math.sqrt(N)) + 1, 2):\n        while N % i == 0:\n            d[i] += 1\n            N = N // i\n    if N > 2:\n        d[N] += 1\n    return d\n    pass\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    d = solve(N)\n    maxi = max(d.values())\n    for i in sorted(d.keys()):\n        if d[i] == maxi:\n            print(i)\n            break", "from math import sqrt\nt = int(input())\n\ndef func(n: int):\n    divs = dict()\n    while n % 2 == 0:\n        try:\n            divs[2] += 1\n        except:\n            divs[2] = 1\n        n /= 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            try:\n                divs[i] += 1\n            except:\n                divs[i] = 1\n            n /= i\n    if n > 1:\n        divs[n] = 1\n    max_freq = 0\n    for divisor in divs:\n        freq = divs[divisor]\n        if freq > max_freq:\n            max_freq = freq\n    for (divisor, freq) in divs.items():\n        if freq == max_freq:\n            return divisor\nwhile t > 0:\n    n = int(input())\n    print(func(n))\n    t -= 1", "from math import sqrt\nt = int(input())\n\ndef func(n: int):\n    divs = dict()\n    while n % 2 == 0:\n        try:\n            divs[2] += 1\n        except:\n            divs[2] = 1\n        n /= 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            try:\n                divs[i] += 1\n            except:\n                divs[i] = 1\n            n /= i\n    if n > 1:\n        divs[n] = 1\n    max_freq = 0\n    for divisor in divs:\n        freq = divs[divisor]\n        if freq > max_freq:\n            max_freq = freq\n    for (divisor, freq) in divs.items():\n        if freq == max_freq:\n            return divisor\nwhile t > 0:\n    n = int(input())\n    print(func(n))\n    t -= 1", "from collections import defaultdict as dd, Counter as C\nfor _ in range(int(input())):\n    n = int(input())\n    D = dd(int)\n    flag = 0\n    while n % 2 == 0:\n        D[2] += 1\n        n //= 2\n        flag = 1\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            D[i] += 1\n            n //= i\n            flag = 1\n        i += 2\n    if flag == 0:\n        print(n)\n    else:\n        cc = C(D)\n        print(cc.most_common(1)[0][0])", "from math import sqrt\n\ndef prime(x):\n    if x == 2:\n        return True\n    else:\n        for i in range(2, int(sqrt(x)) + 1):\n            if x % i == 0:\n                return False\n        return True\n\ndef findddsmallestDivisor(n):\n    if n % 2 == 0:\n        return 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return i\n        i += 2\n    return n\n\ndef finddd(x):\n    maxx = 0\n    anss = x\n    while x % 2 == 0:\n        maxx += 1\n        x /= 2\n        anss = 2\n    for i in range(3, int(sqrt(x)) + 1, 2):\n        cnt = 0\n        while x % i == 0:\n            cnt += 1\n            x /= i\n        if cnt > maxx:\n            maxx = cnt\n            anss = i\n    if x > 2:\n        if 1 > maxx:\n            maxx = 1\n            anss = x\n    return anss\nfor _ in range(int(input())):\n    x = int(input())\n    if x <= 3:\n        print(x)\n    else:\n        print(finddd(x))", "import math\n\ndef simplesieve(n):\n    prime = [2]\n    mark = [False] * (n + 1)\n    for p in range(3, n + 1, 2):\n        if mark[p] == False:\n            prime.append(p)\n            if p * p <= n:\n                for l1 in range(p * p, n + 1, 2 * p):\n                    mark[l1] = True\n    return prime\nv = simplesieve(10 ** 5 + 1)\n\ndef nDivisors(n):\n    t = 0\n    m = -1\n    for i in v:\n        if n % i == 0:\n            lol = 0\n            while n % i == 0:\n                lol += 1\n                n = n // i\n            if t < lol:\n                t = lol\n                m = i\n    if n != 1:\n        if m < 1:\n            return n\n    return m\nfor _ in range(int(input())):\n    n = int(input())\n    print(nDivisors(n))", "import math\n\ndef primeFactors(n):\n    dic = {2: 0}\n    while n % 2 == 0:\n        dic[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            if i not in dic.keys():\n                dic[i] = 1\n            else:\n                dic[i] += 1\n            n = n / i\n    if n > 2:\n        dic[n] = 1\n    (key, max) = (0, 0)\n    for i in dic.keys():\n        if dic[i] > max:\n            key = i\n            max = dic[i]\n    print(key)\nfor _ in range(int(input())):\n    n = int(input())\n    primeFactors(n)", "import math\nfrom collections import defaultdict\nimport math\n\ndef primeFactors(n):\n    d = defaultdict(int)\n    while n % 2 == 0:\n        d[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[i] += 1\n            n = n / i\n    if n > 2:\n        d[n] += 1\n    return d\nfor _ in range(int(input())):\n    n = int(input())\n    d = primeFactors(n)\n    maxi = max(d.values())\n    for i in sorted(d.keys()):\n        if d[i] == maxi:\n            print(i)\n            break", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nmaxN = 100010\ndp = [i for i in range(maxN + 1)]\nsize = 0\nprime = []\ni = 2\nfor i in range(2, maxN + 1):\n    if dp[i] == i:\n        prime.append(i)\n        size += 1\n    j = 0\n    while j < size and i * prime[j] <= maxN and (dp[i * prime[j]] >= prime[j]):\n        dp[i * prime[j]] = prime[j]\n        j += 1\n\ndef solve():\n    n = inp()\n    MA = 0\n    i = 0\n    ans = -1\n    for i in prime:\n        if n % i == 0:\n            c = 0\n            while n % i == 0:\n                n //= i\n                c += 1\n            if c > MA:\n                MA = c\n                ans = i\n    if n != 1:\n        if MA < 1:\n            ans = n\n    pr(ans)\nfor _ in range(inp()):\n    solve()", "from collections import defaultdict\nimport math\nfor _ in range(int(input())):\n    n = int(input())\n    d = defaultdict(int)\n    while n % 2 == 0:\n        d[2] += 1\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[i] += 1\n            n = n // i\n    if n > 2:\n        d[n] += 1\n    ans = -1\n    maxi = 0\n    for (k, v) in d.items():\n        if v > maxi:\n            ans = k\n            maxi = v\n        if v == maxi:\n            ans = min(ans, k)\n    print(ans)", "import math\nfrom collections import Counter\n\ndef prime(n):\n    d = Counter()\n    while n % 2 == 0:\n        d[2] = d.get(2, 0) + 1\n        n = n // 2\n    for i in range(3, math.ceil(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[i] = d.get(i, 0) + 1\n            n = n // i\n    if n > 2:\n        d[n] = d.get(n, 0) + 1\n    return d\nfor _ in range(int(input())):\n    n = int(input())\n    res = prime(n)\n    print(res.most_common()[0][0])", "import math\nfrom collections import Counter\n\ndef prime(n):\n    d = Counter()\n    while n % 2 == 0:\n        d[2] = d.get(2, 0) + 1\n        n = n // 2\n    for i in range(3, math.ceil(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[i] = d.get(i, 0) + 1\n            n = n // i\n    if n > 2:\n        d[n] = d.get(n, 0) + 1\n    return d\nfor _ in range(int(input())):\n    n = int(input())\n    res = prime(n)\n    print(res.most_common()[0][0])", "class Solution:\n\n    def __init__(self):\n        self.prime = []\n        self.d = {}\n\n    def pre(self):\n        for i in range(2, 10 ** 5):\n            if i not in self.d:\n                self.prime.append(i)\n                for j in range(i * 2, 10 ** 5, i):\n                    self.d[j] = 1\ns = Solution()\ns.pre()\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    done = 0\n    one = 0\n    d = {}\n    ncopy = n\n    for j in s.prime:\n        if n % j == 0:\n            d[j] = 0\n            while n % j == 0:\n                n = n // j\n                d[j] += 1\n    if len(d) == 0:\n        print(ncopy)\n        continue\n    maxo = max(d.values())\n    for j in s.prime:\n        if j in d and d[j] == maxo:\n            print(j)\n            break", "class Solution:\n\n    def __init__(self):\n        self.prime = []\n        self.d = {}\n\n    def pre(self):\n        for i in range(2, 10 ** 5):\n            if i not in self.d:\n                self.prime.append(i)\n                for j in range(i * 2, 10 ** 5, i):\n                    self.d[j] = 1\ns = Solution()\ns.pre()\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    done = 0\n    one = 0\n    d = {}\n    ncopy = n\n    for j in s.prime:\n        if n % j == 0:\n            d[j] = 0\n            while n % j == 0:\n                n = n // j\n                d[j] += 1\n    if len(d) == 0:\n        print(ncopy)\n        continue\n    maxo = max(d.values())\n    for j in s.prime:\n        if j in d and d[j] == maxo:\n            print(j)\n            break", "import math\n\ndef primeFactors(n):\n    dicti = {}\n    while n % 2 == 0:\n        dicti[2] = dicti.get(2, 0) + 1\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            dicti[i] = dicti.get(i, 0) + 1\n            n = n // i\n    if n > 2:\n        dicti[n] = dicti.get(n, 0) + 1\n    temp = max(dicti.values())\n    for i in dicti:\n        if dicti[i] == temp:\n            print(i)\n            return\nfor i in range(int(input())):\n    n = int(input())\n    primeFactors(n)", "import math\nfrom collections import Counter\n\ndef pf(n, x):\n    while n % 2 == 0:\n        x.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            x.append(i)\n            n = n / i\n    if n > 2:\n        x.append(n)\nfor _ in range(int(input())):\n    n = int(input())\n    x = []\n    pf(n, x)\n    a = Counter(x).most_common(1)[0][0]\n    print(a)", "for _ in range(int(input())):\n    n = int(input())\n    answ = n\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n        i += 1\n    if n > 2:\n        l.append(n)\n    d = {}\n    for i in l:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    ans = 1\n    for i in d:\n        ans = max(ans, d[i])\n    for i in d:\n        if d[i] == ans:\n            answ = min(answ, i)\n    print(answ)", "from collections import defaultdict\n\ndef primes(n):\n    primfac = defaultdict(lambda : 0)\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            primfac[d] += 1\n            n //= d\n        d += 1\n    if n > 1:\n        primfac[n] += 1\n    return primfac\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    dic = primes(N)\n    lis = [(k, dic[k]) for k in dic.keys()]\n    print(max(lis, key=lambda tupl: (tupl[1], -tupl[0]))[0])", "import math\ntest_cases = int(input())\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    return l\n\ndef most_frequent(List):\n    counter = 0\n    num = List[0]\n    for i in List:\n        curr_frequency = List.count(i)\n        if curr_frequency > counter:\n            counter = curr_frequency\n            num = i\n    return num\nwhile test_cases != 0:\n    n = int(input())\n    l = primeFactors(n)\n    k = most_frequent(l)\n    print(k)\n    test_cases -= 1", "import math\n\ndef mergeSort(lst, start, end):\n    if start == end:\n        return 0\n    middle = start + (end - start) // 2\n    a = mergeSort(lst, start, middle)\n    b = mergeSort(lst, middle + 1, end)\n    c = merge(lst, start, middle, end)\n    return a + b + c\n\ndef merge(lst, start, middle, end):\n    count = 0\n    Llst = lst[start:middle + 1]\n    Rlst = lst[middle + 1:end + 1]\n    n1 = len(Llst)\n    i = 0\n    j = 0\n    k = start\n    while i < middle - start + 1 and j < end - middle:\n        if Llst[i] <= Rlst[j]:\n            lst[k] = Llst[i]\n            i += 1\n            k += 1\n        else:\n            count += n1 - i\n            lst[k] = Rlst[j]\n            j += 1\n            k += 1\n    while i < middle - start + 1:\n        lst[k] = Llst[i]\n        i += 1\n        k += 1\n    while j < end - middle:\n        lst[k] = Rlst[j]\n        j += 1\n        k += 1\n    return count\nt = int(input())\nfor k in range(t):\n    n = int(input())\n    dic = {}\n    while n % 2 == 0:\n        dic[2] = dic.get(2, 0) + 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            dic[i] = dic.get(i, 0) + 1\n            n = n / i\n    if n > 2:\n        dic[n] = dic.get(n, 0) + 1\n    maxi = 0\n    ans = 0\n    for (key, value) in dic.items():\n        if value >= maxi:\n            if maxi == value:\n                ans = min(ans, key)\n            else:\n                ans = key\n            maxi = value\n    print(ans)", "from math import *\nimport sys\ninput = sys.stdin.readline\n\ndef primeFactors(n):\n    m = {}\n    while n % 2 == 0:\n        if 2 in m:\n            m[2] += 1\n        else:\n            m[2] = 1\n        n = n // 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            if i in m:\n                m[i] += 1\n            else:\n                m[i] = 1\n            n = n // i\n    if n > 2:\n        m[n] = 1\n    return m\nfor _ in range(int(input())):\n    n = int(input())\n    f = primeFactors(n)\n    tot = 1\n    for v in f:\n        tot *= f[v] + 1\n    k = 1\n    fact = 1\n    for v in f:\n        cur_fact = tot // (f[v] + 1) * f[v]\n        if cur_fact > fact:\n            fact = cur_fact\n            k = v\n    if k == 1:\n        k = n\n    print(k)", "from math import ceil, gcd, factorial, sqrt, floor\nimport queue\nimport re\nfrom itertools import permutations, combinations, accumulate\nfrom collections import Counter, deque\nfrom sys import stdin, stdout\nfrom bisect import bisect, insort, bisect_left, insort_left\ninput = lambda : stdin.readline()\n\ndef sieve(n):\n    prime = [True] * (n + 1)\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for l1 in range(p * p, n + 1, p):\n                prime[l1] = False\n        p += 1\n    return prime\n\ndef simplesieve(n):\n    prime = [2]\n    mark = [False] * (n + 1)\n    for p in range(3, n + 1, 2):\n        if mark[p] == False:\n            prime.append(p)\n            if p * p <= n:\n                for l1 in range(p * p, n + 1, 2 * p):\n                    mark[l1] = True\n    return prime\n\ndef segementedsieve(low, high):\n    limit = int(sqrt(high))\n    primes = simplesieve(limit)\n    prime = [True] * (high - low + 1)\n    for l1 in primes:\n        lower = low // l1\n        if lower <= 1:\n            lower = l1 + l1\n        elif low % l1 != 0:\n            lower = lower * l1 + l1\n        else:\n            lower = lower * l1\n        for l2 in range(lower, high + 1, l1):\n            prime[l2 - low] = False\n    s1 = []\n    s = 0\n    for l in range(low, high + 1):\n        if prime[l - low]:\n            s1.append(l)\n    return s1\n\ndef isprime(n):\n    if n == 2:\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    for l1 in range(3, int(n ** 0.5) + 1, 2):\n        if n % l1 == 0:\n            return False\n    return True\n\ndef binpow(s1, s2, s):\n    r2 = 1\n    s1 = s1 % s\n    while s2 > 0:\n        if s2 & 1:\n            r2 = r2 * s1 % s\n        s1 = s1 * s1 % s\n        s2 >>= 1\n    return r2\n\ndef lcm(s1, s2):\n    return s1 // gcd(s1, s2) * s2\n\ndef gcdExtended(s1, s2):\n    if s2 == 0:\n        return (s1, 1, 0)\n    (g, x1, y1) = gcdExtended(s2, s1 % s2)\n    l1 = y1\n    l2 = x1 - s1 // s2 * y1\n    return (g, l1, l2)\n\ndef dfs(graph, s, l1):\n    v = [0] * (s + 1)\n    v[l1] = 1\n    s1 = [l1]\n    z = 0\n    while s1 != []:\n        l = s1.pop()\n        for l1 in graph[l]:\n            if v[l1] == 0:\n                v[l1] = 1\n                s1.append(l1)\n    return 'no'\n\ndef bfs(graph, n, x, dest):\n    v = [0] * (1 + n)\n    d = [0] * (1 + n)\n    d[x] = 0\n    v[x] = 1\n    q = queue.Queue()\n    q.put(x)\n    while not q.empty():\n        z = q.get()\n        for s in graph[z]:\n            if v[s] == 0:\n                v[s] = 1\n                d[s] = d[z] + 1\n                q.put(s)\n    return d[dest]\nprime = simplesieve(10 ** 5 + 1)\nfor _ in range(int(input())):\n    n = int(input())\n    k = n\n    m = 0\n    ans = -1\n    for i in prime:\n        if k % i == 0:\n            c = 0\n            while k % i == 0:\n                c += 1\n                k = k // i\n            if m < c:\n                m = c\n                ans = i\n    if k != 1 and m < 1:\n        ans = k\n    print(ans)", "max_prime = int(10 ** 4.5)\n\ndef GetPrimes(max_prime):\n    is_prime = [True for _ in range(max_prime + 1)]\n    primes = []\n    for n in range(2, max_prime + 1):\n        if is_prime[n]:\n            primes += [n]\n            for m in range(2 * n, max_prime + 1, n):\n                is_prime[m] = False\n    return primes\nprimes = GetPrimes(max_prime)\n\ndef GetPrimeFactors(n):\n    powers = {}\n    for prime in primes:\n        while n % prime == 0:\n            if prime in powers:\n                powers[prime] += 1\n            else:\n                powers[prime] = 1\n            n //= prime\n    if n > 1:\n        powers[n] = 1\n    return powers\nnum_test_cases = int(input())\nfor test_case_ittr in range(num_test_cases):\n    n = int(input())\n    powers = GetPrimeFactors(n)\n    prime_factors = sorted(powers)\n    prod = 1\n    for prime_factor in powers:\n        prod *= 1 + powers[prime_factor]\n    best_k = None\n    max_num_divisors_of_m = 0\n    for k in prime_factors:\n        num_divisors_of_m = max(powers[k], 1) * prod // (powers[k] + 1)\n        if num_divisors_of_m > max_num_divisors_of_m:\n            max_num_divisors_of_m = num_divisors_of_m\n            best_k = k\n    print(best_k)", "def prime_factors(n):\n    fact = []\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            cnt = 0\n            while n % i == 0:\n                n //= i\n                cnt += 1\n            fact.append([i, cnt])\n        else:\n            i += 1\n    if n > 1:\n        fact.append([n, 1])\n    return fact\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    fact = prime_factors(n)\n    fact.sort(key=lambda x: [-x[1], x[0]])\n    print(fact[0][0])", "from collections import Counter\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef memodict(f):\n\n    class memodict(dict):\n\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n    return memodict().__getitem__\n\ndef pollard_rho(n):\n    if n & 1 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n    s = (n - 1 & 1 - n).bit_length() - 1\n    d = n >> s\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n        p = pow(a, d, n)\n        if p == 1 or p == n - 1 or a % n == 0:\n            continue\n        for _ in range(s):\n            prev = p\n            p = p * p % n\n            if p == 1:\n                return gcd(prev - 1, n)\n            if p == n - 1:\n                break\n        else:\n            for i in range(2, n):\n                (x, y) = (i, (i * i + 1) % n)\n                f = gcd(abs(x - y), n)\n                while f == 1:\n                    (x, y) = ((x * x + 1) % n, (y * y + 1) % n)\n                    y = (y * y + 1) % n\n                    f = gcd(abs(x - y), n)\n                if f != n:\n                    return f\n    return n\n\n@memodict\ndef prime_factors(n):\n    if n <= 1:\n        return Counter()\n    f = pollard_rho(n)\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = prime_factors(n)\n    print(-1 * sorted([(d[i], -1 * i) for i in d], reverse=True)[0][1])", "from math import sqrt\n\ndef factor(n, dic):\n    p = int(sqrt(n))\n    while n % 2 == 0:\n        if 2 in dic.keys():\n            dic[2] += 1\n        else:\n            dic[2] = 1\n        n = n // 2\n    for i in range(3, p + 1, 2):\n        while n % i == 0:\n            if i in dic.keys():\n                dic[i] += 1\n            else:\n                dic[i] = 1\n            n = n // i\n    if n > 2:\n        dic[n] = 1\n    return dic\nT = int(input())\nfor tc in range(T):\n    n = int(input())\n    dic = factor(n, {})\n    x = 1\n    for key in dic.keys():\n        x = x * (dic[key] + 1)\n    res = 0\n    y = 0\n    for keys in dic.keys():\n        if x // (dic[keys] + 1) * dic[keys] > y:\n            res = keys\n            y = x // (dic[keys] + 1) * dic[keys]\n    print(res)", "import sys\nfrom math import sqrt, gcd\nfrom collections import deque\nsys.setrecursionlimit(10 ** 8)\nI = lambda : int(input())\nS = lambda : input().strip()\nM = lambda : map(int, input().strip().split())\nL = lambda : list(map(int, input().strip().split()))\nmod = 1000000007\n\ndef factor(n):\n    while n % 2 == 0:\n        if 2 in d:\n            d[2] += 1\n        else:\n            d[2] = 1\n        n //= 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n            n //= i\n    if n > 2:\n        d[n] = 1\nfor _ in range(I()):\n    n = I()\n    d = {}\n    factor(n)\n    t = 1\n    for i in d:\n        t *= d[i] + 1\n    ans = 0\n    m = 0\n    for i in d:\n        if t // (d[i] + 1) * d[i] > m:\n            ans = i\n            m = t // (d[i] + 1) * d[i]\n    print(ans)", "import random\nimport sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom collections import Counter\nfrom collections import defaultdict as dd\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline()\nstdint = lambda : int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nstdmap = lambda : map(int, stdstr().split())\nstdarr = lambda : list(map(int, stdstr().split()))\nmod = 1000000007\n\ndef BF(n):\n    poss = set()\n    for i in range(2, n + 1):\n        if n % i == 0:\n            poss.add((n // i, i))\n    poss = sorted(list(poss), key=lambda x: x[1])\n    numdivs = -float('inf')\n    res = -1\n    for i in poss:\n        divs = 0\n        for j in range(1, i[0] + 1):\n            if i[0] % j == 0:\n                divs += 1\n        if divs > numdivs:\n            numdivs = divs\n            res = i[1]\n    return res\n\ndef pf(n):\n    pf = Counter()\n    while n % 2 == 0:\n        pf[2] += 1\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            pf[i] += 1\n            n //= i\n    if n > 1:\n        pf[n] += 1\n    return pf\nfor i in range(stdint()):\n    n = stdint()\n    pfs = pf(n)\n    total = 1\n    for i in pfs:\n        total *= pfs[i] + 1\n    curr = -float('inf')\n    res = float('inf')\n    for i in pfs:\n        pos = total // (pfs[i] + 1)\n        pos *= pfs[i]\n        if pos > curr:\n            curr = pos\n            res = i\n        elif pos == curr:\n            res = min(res, i)\n    print(res)", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n    sys.stderr = open('error.txt', 'w')\ndepth = 200001\nmod = 1000000007\nlim = mod * mod\nsys.setrecursionlimit(depth)\nlinp = lambda : list(minp())\nminp = lambda : map(int, input().split())\nfrom math import inf, ceil, sqrt, log2, gcd\nfrom collections import defaultdict, deque\ndxy = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\ndef expo(a, b):\n    if not b:\n        return 1\n    v = expo(a, b // 2)\n    v = v * v % mod\n    if b % 2:\n        v = v * a % mod\n    return v\n\ndef modinv(a, b):\n    d = expo(b, mod - 2)\n    v = a * d % mod\n    return v\n\ndef checkPrime(n):\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef highestPowerof2(x):\n    x |= x >> 1\n    x |= x >> 2\n    x |= x >> 4\n    x |= x >> 8\n    x |= x >> 16\n    return x ^ x >> 1\n\ndef isVowel(char):\n    return char.lower() in 'aeiou'\n\ndef primeFactors(n):\n    m = n\n    d = defaultdict(lambda : 0)\n    while n % 2 == 0:\n        n = n // 2\n        d[2] += 1\n    i = 3\n    while n > 1 and i * i <= m:\n        while n % i == 0:\n            n = n // i\n            d[i] += 1\n        i += 2\n    if n > 1:\n        d[n] += 1\n    return list(d.items())\nfor _ in range(int(input())):\n    n = int(input())\n    pf = primeFactors(n)\n    m = len(pf)\n    l = [1 for _ in range(m + 1)]\n    r = [1 for _ in range(m + 1)]\n    for i in range(m):\n        l[i + 1] = l[i] * (pf[i][1] + 1)\n    for i in range(m - 1, -1, -1):\n        r[i] = r[i + 1] * (pf[i][1] + 1)\n    ans = inf\n    res = 0\n    for i in range(m):\n        cur = l[i] * r[i + 1] * pf[i][1]\n        if cur > res:\n            res = cur\n            ans = pf[i][0]\n        elif cur == res:\n            ans = min(ans, pf[i][0])\n        else:\n            pass\n    print(ans)", "import math\n\ndef fun(n):\n    ans = []\n    while n % 2 == 0:\n        ans.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            ans.append(i)\n            n = n / i\n    if n > 2:\n        ans.append(int(n))\n    obj = {}\n    for x in ans:\n        obj[x] = 0\n    for x in ans:\n        obj[x] += 1\n    fac = list(obj.keys())\n    fac.sort(key=lambda x: (obj[x], -1 * x), reverse=True)\n    return fac[0]\nt = int(input())\nfor TTT in range(t):\n    n = int(input())\n    ans = fun(n)\n    print(ans)", "import math\n\ndef primeFactors(n):\n    ans = []\n    while n % 2 == 0:\n        ans.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            ans.append(i)\n            n = n / i\n    if n > 2:\n        ans.append(int(n))\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    c = primeFactors(n)\n    now = {}\n    for i in c:\n        if i in now:\n            now[i] += 1\n        else:\n            now[i] = 1\n    mi = float('inf')\n    zero = 0\n    for i in now:\n        now[i] -= 1\n        c = 1\n        for j in now:\n            if now[j] >= 1:\n                c *= now[j] + 1\n        if c > zero:\n            mi = i\n            zero = c\n        elif c == zero:\n            mi = min(mi, i)\n        now[i] += 1\n    print(mi)", "import math\nfrom collections import Counter\n\ndef factor(n):\n    result = []\n    while n % 2 == 0 and n > 0:\n        result.append(2)\n        n //= 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            n = n // i\n            result.append(i)\n        else:\n            i += 2\n    if n > 1:\n        result.append(n)\n    return result\nfor _ in range(int(input())):\n    n = int(input())\n    data = factor(n)\n    cnt = Counter(data)\n    most = -1\n    result = -1\n    for (key, value) in sorted(cnt.items()):\n        if value > most:\n            result = key\n            most = value\n    print(result)", "import sys\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom collections import deque\nsys.setrecursionlimit(10 ** 8)\nfrom queue import PriorityQueue as pq\nfrom math import gcd\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nlii = lambda : list(map(int, list(ip())))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\ninv = lambda x: pow(x, mod - 2, mod)\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\nmod = 10 ** 9 + 7\nmod1 = 998244353\nmx = 10 ** 5 + 2\na = [1 for i in range(mx)]\na[0] = 0\na[1] = 0\np = 2\nwhile p * p < mx:\n    if a[p] == 1:\n        for j in range(p * p, mx, p):\n            a[j] = 0\n    p += 1\npr = []\nfor i in range(mx):\n    if a[i]:\n        pr.append(i)\nfor _ in range(ii()):\n    n = ii()\n    ans = 2\n    d = {}\n    for i in pr:\n        if n % i == 0:\n            while n % i == 0:\n                d[i] = d.get(i, 0) + 1\n                n //= i\n    if n > 1:\n        d[n] = 1\n    mn = 0\n    for i in d:\n        if mn < d[i]:\n            mn = d[i]\n            ans = i\n    print(ans)", "from math import *\nimport sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nprime = []\nsz = 32000\nstat = [0] * sz\nstat[0] = 1\nstat[1] = 1\nfor i in range(2, int(sqrt(sz)) + 1):\n    if stat[i] == 0:\n        for j in range(i * i, sz, i):\n            stat[j] = 1\nfor i in range(sz):\n    if stat[i] == 0:\n        prime.append(i)\nfor _ in range(int(input())):\n    n = int(input())\n    l = []\n    for p in range(2, 3):\n        if n == 1:\n            break\n        c = 0\n        while n % p == 0:\n            n //= p\n            c += 1\n        l.append((c, -p))\n    for p in prime:\n        if n == 1:\n            break\n        c = 0\n        while n % p == 0:\n            n //= p\n            c += 1\n        l.append((c, -p))\n    if n != 1:\n        l.append((1, -n))\n    l.sort()\n    print(-l[-1][-1])", "from sys import stdin\ninput = stdin.readline\nsize = 10 ** 5 + 1\nisprime = [True] * size\nisprime[0] = False\nisprime[1] = False\nprime = []\nfor i in range(2, size):\n    if isprime[i]:\n        for j in range(i + i, size, i):\n            isprime[j] = False\n        prime.append(i)\n\ndef answer():\n    mval = 0\n    (ans, i) = (n, 0)\n    while prime[i] * prime[i] <= n:\n        (x, count) = (n, 0)\n        while x % prime[i] == 0:\n            x //= prime[i]\n            count += 1\n        if mval < count:\n            ans = prime[i]\n            mval = count\n        i += 1\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    print(answer())", "for i in range(int(input())):\n    n = int(input())\n    primes = {}\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            cnt = 0\n            while n % i == 0:\n                n //= i\n                cnt += 1\n            primes.update({i: cnt})\n        i += 1\n    else:\n        if n > 1:\n            primes.update({n: 1})\n    maxi = -1\n    ind = 0\n    for j in primes.keys():\n        if primes[j] > maxi:\n            maxi = primes[j]\n            ind = j\n    print(ind)"]