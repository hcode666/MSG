["from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nx = '2\\n5 2\\n5 3 3 1 2\\n1 2 2\\n2 3 1\\n2 4 1\\n1 5 2\\n4 5\\n5 4\\n10 5\\n3 6 9 2 3 8 3 7 9 7\\n1 2 4\\n1 3 6\\n1 4 8\\n4 5 9\\n1 6 2\\n5 7 3\\n3 8 7\\n3 9 2\\n7 10 9\\n9 2\\n2 1\\n8 5\\n3 2\\n3 10'\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\n\ndef dfs(p, prev, sx, sy, ss, lvl):\n    level[p] = lvl\n    parent[p][0] = prev\n    for i in range(1, 20):\n        if parent[p][i - 1] != -1:\n            parent[p][i] = parent[parent[p][i - 1]][i - 1]\n    px[p] = sx + a[p - 1]\n    py[p] = sy\n    ps[p] = ss\n    for x in range(len(child[p])):\n        (i, w) = child[p][x]\n        if i == prev:\n            continue\n        dfs(i, p, sx + a[p - 1], sy + w, ss + w * (sx + a[p - 1]), lvl + 1)\n\ndef lca(u, v):\n    if level[u] > level[v]:\n        (u, v) = (v, u)\n    dist = level[v] - level[u]\n    for i in range(19, -1, -1):\n        if dist >> i & 1:\n            v = parent[v][i]\n    if u == v:\n        return u\n    for i in range(19, -1, -1):\n        if parent[u][i] != parent[v][i]:\n            u = parent[u][i]\n            v = parent[v][i]\n    return parent[u][0]\n\ndef solve(x, y):\n    Lca = lca(x, y)\n    sxx = px[x] - px[Lca] + a[Lca - 1]\n    syx = py[x] - py[Lca]\n    ssx = ps[x] - ps[Lca] - px[Lca] * syx\n    sxy = px[y] - px[Lca] + a[Lca - 1]\n    syy = py[y] - py[Lca]\n    ssy = ps[y] - ps[Lca] - px[Lca] * syy\n    sumx = ssx + syx * sxy + (sxy - a[Lca - 1]) * syy - ssy\n    sumy = ssy + syy * sxx + (sxx - a[Lca - 1]) * syx - ssx\n    ans = sumx - sumy\n    return ans\n\ndef answer():\n    for i in range(q):\n        (x, y) = map(int, input().split())\n        print(solve(x, y))\nfor T in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        child[u].append([v, w])\n        child[v].append([u, w])\n    (px, py, ps) = ([0] * (n + 1), [0] * (n + 1), [0] * (n + 1))\n    level = [0] * (n + 1)\n    parent = [[-1 for i in range(20)] for j in range(n + 1)]\n    dfs(1, -1, 0, 0, 0, 0)\n    answer()", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nx = '2\\n5 2\\n5 3 3 1 2\\n1 2 2\\n2 3 1\\n2 4 1\\n1 5 2\\n4 5\\n5 4\\n10 5\\n3 6 9 2 3 8 3 7 9 7\\n1 2 4\\n1 3 6\\n1 4 8\\n4 5 9\\n1 6 2\\n5 7 3\\n3 8 7\\n3 9 2\\n7 10 9\\n9 2\\n2 1\\n8 5\\n3 2\\n3 10'\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from collections import defaultdict\nimport math\nimport sys\nsys.setrecursionlimit(int(200000.0))\n\ndef get_mid(s, e):\n    return s + (e - s) // 2\n\ndef build_tree(arr):\n    n = len(arr)\n    n1 = 2 ** math.ceil(math.log2(n))\n    st = [0] * (2 * n1 - 1)\n\n    def builder(segment_start, segment_end, st_idx):\n        if segment_end == segment_start:\n            st[st_idx] = segment_start\n        else:\n            mid = get_mid(segment_start, segment_end)\n            b1 = builder(segment_start, mid, st_idx * 2 + 1)\n            b2 = builder(mid + 1, segment_end, st_idx * 2 + 2)\n            if arr[b1] <= arr[b2]:\n                st[st_idx] = b1\n            else:\n                st[st_idx] = b2\n        return st[st_idx]\n    builder(0, n - 1, 0)\n    return st\n\ndef query_tree(st, arr, query_start, query_end):\n    len_arr = len(arr)\n\n    def q(range_start, range_end, st_idx):\n        if query_start <= range_start and range_end <= query_end:\n            return st[st_idx]\n        elif query_end < range_start or range_end < query_start:\n            return -1\n        else:\n            mid = get_mid(range_start, range_end)\n            b1 = q(range_start, mid, st_idx * 2 + 1)\n            b2 = q(mid + 1, range_end, st_idx * 2 + 2)\n            assert b1 > -1 or b2 > -1\n            if b2 == -1:\n                return b1\n            elif b1 == -1:\n                return b2\n            elif arr[b1] <= arr[b2]:\n                return b1\n            else:\n                return b2\n    return q(0, len_arr - 1, 0)\n\nclass F:\n\n    def __init__(self, node, parent, level, d, c, s):\n        self.node = node\n        self.parent = parent\n        self.level = level\n        self.d = d\n        self.c = c\n        self.s = s\n        self.state = 0\n\ndef do_dfs2(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n    stack = [F(root, -1, 0, d=0, c=0, s=A[root])]\n    while stack:\n        f = stack[-1]\n        if f.state == 1:\n            if f.parent >= 0:\n                trail.append(f.parent)\n            stack.pop()\n            continue\n        trail.append(f.node)\n        levels_by_node[f.node] = f.level\n        D[f.node] = f.d\n        C[f.node] = f.c\n        S[f.node] = f.s\n        for (child, weight) in adj[f.node]:\n            if child != f.parent:\n                stack.append(F(child, f.node, f.level + 1, d=f.d + weight, c=f.c + (f.d + weight) * A[child], s=f.s + A[child]))\n        f.state = 1\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef do_dfs(adj, root, A):\n    N = max(adj)\n    trail = []\n    levels_by_node = [0] * (N + 1)\n    D = [0] * (N + 1)\n    C = [0] * (N + 1)\n    S = [0] * (N + 1)\n\n    def dfs(node, parent, level, d, c, s):\n        trail.append(node)\n        levels_by_node[node] = level\n        D[node] = d\n        C[node] = c\n        S[node] = s\n        for (child, weight) in adj[node]:\n            if child != parent:\n                dfs(child, node, level + 1, d=d + weight, c=c + (d + weight) * A[child], s=s + A[child])\n                trail.append(node)\n    dfs(root, -1, 0, d=0, c=0, s=A[root])\n    return (trail, [levels_by_node[t] for t in trail], D, C, S)\n\ndef solve(A, edges, queries):\n    adj = defaultdict(list, {})\n    for (e1, e2, w) in edges:\n        adj[e1].append((e2, w))\n        adj[e2].append((e1, w))\n    root = next((k for (k, c) in adj.items() if len(c) == 1))\n    (trail, levels, D, C, S) = do_dfs2(adj, root, A)\n    node_to_idx = {}\n    for (idx, node) in enumerate(trail):\n        if node not in node_to_idx:\n            node_to_idx[node] = idx\n    st = build_tree(levels)\n\n    def lca(x, y):\n        xi = node_to_idx[x]\n        yi = node_to_idx[y]\n        levels_idx = query_tree(st, levels, min(xi, yi), max(xi, yi))\n        return trail[levels_idx]\n\n    def a(x, y):\n        p = lca(x, y)\n        sum_a_p1 = S[x] - S[p] + A[p]\n        sum_a_p2 = S[y] - S[p]\n        coef1 = D[x] - D[y] + 2 * D[p]\n        coef2 = D[x] - D[y] - 2 * D[p]\n        sum_of_akdk_p1 = C[x] - C[p] + A[p] * D[p]\n        sum_of_akdk_p2 = C[y] - C[p]\n        return coef1 * sum_a_p1 + coef2 * sum_a_p2 - 2 * sum_of_akdk_p1 + 2 * sum_of_akdk_p2\n    return [a(x, y) for (x, y) in queries]\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (N, Q) = map(int, input().split())\n        A = [0] + list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n        queries = [tuple(map(int, input().split())) for _ in range(Q)]\n        ans = solve(A, edges, queries)\n        for a in ans:\n            print(a)\nif 'paalto' in sys.argv[0] or sys.argv[0].endswith('pydevconsole.py'):\n    lines = iter(x.split('\\n'))\nelse:\n    lines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\n\ndef dfs(p, prev, sx, sy, ss, lvl):\n    level[p] = lvl\n    parent[p][0] = prev\n    for i in range(1, 20):\n        if parent[p][i - 1] != -1:\n            parent[p][i] = parent[parent[p][i - 1]][i - 1]\n    px[p] = sx + a[p - 1]\n    py[p] = sy\n    ps[p] = ss\n    for x in range(len(child[p])):\n        (i, w) = child[p][x]\n        if i == prev:\n            continue\n        dfs(i, p, sx + a[p - 1], sy + w, ss + w * (sx + a[p - 1]), lvl + 1)\n\ndef lca(u, v):\n    if level[u] > level[v]:\n        (u, v) = (v, u)\n    dist = level[v] - level[u]\n    for i in range(19, -1, -1):\n        if dist >> i & 1:\n            v = parent[v][i]\n    if u == v:\n        return u\n    for i in range(19, -1, -1):\n        if parent[u][i] != parent[v][i]:\n            u = parent[u][i]\n            v = parent[v][i]\n    return parent[u][0]\n\ndef solve(x, y):\n    Lca = lca(x, y)\n    sxx = px[x] - px[Lca] + a[Lca - 1]\n    syx = py[x] - py[Lca]\n    ssx = ps[x] - ps[Lca] - px[Lca] * syx\n    sxy = px[y] - px[Lca] + a[Lca - 1]\n    syy = py[y] - py[Lca]\n    ssy = ps[y] - ps[Lca] - px[Lca] * syy\n    sumx = ssx + syx * sxy + (sxy - a[Lca - 1]) * syy - ssy\n    sumy = ssy + syy * sxx + (sxx - a[Lca - 1]) * syx - ssx\n    ans = sumx - sumy\n    return ans\n\ndef answer():\n    for i in range(q):\n        (x, y) = map(int, input().split())\n        print(solve(x, y))\nfor T in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        child[u].append([v, w])\n        child[v].append([u, w])\n    (px, py, ps) = ([0] * (n + 1), [0] * (n + 1), [0] * (n + 1))\n    level = [0] * (n + 1)\n    parent = [[-1 for i in range(20)] for j in range(n + 1)]\n    dfs(1, -1, 0, 0, 0, 0)\n    answer()", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\n\ndef dfs(p, prev, sx, sy, ss, lvl):\n    level[p] = lvl\n    parent[p][0] = prev\n    for i in range(1, 20):\n        if parent[p][i - 1] != -1:\n            parent[p][i] = parent[parent[p][i - 1]][i - 1]\n    px[p] = sx + a[p - 1]\n    py[p] = sy\n    ps[p] = ss\n    for x in range(len(child[p])):\n        (i, w) = child[p][x]\n        if i == prev:\n            continue\n        dfs(i, p, sx + a[p - 1], sy + w, ss + w * (sx + a[p - 1]), lvl + 1)\n\ndef lca(u, v):\n    if level[u] > level[v]:\n        (u, v) = (v, u)\n    dist = level[v] - level[u]\n    for i in range(19, -1, -1):\n        if dist >> i & 1:\n            v = parent[v][i]\n    if u == v:\n        return u\n    for i in range(19, -1, -1):\n        if parent[u][i] != parent[v][i]:\n            u = parent[u][i]\n            v = parent[v][i]\n    return parent[u][0]\n\ndef get(x, Lca):\n    sx = px[x] - px[Lca] + a[Lca - 1]\n    sy = py[x] - py[Lca]\n    ss = ps[x] - ps[Lca] - px[Lca] * sy\n\ndef solve(x, y):\n    Lca = lca(x, y)\n    sxx = px[x] - px[Lca] + a[Lca - 1]\n    syx = py[x] - py[Lca]\n    ssx = ps[x] - ps[Lca] - px[Lca] * syx\n    sxy = px[y] - px[Lca] + a[Lca - 1]\n    syy = py[y] - py[Lca]\n    ssy = ps[y] - ps[Lca] - px[Lca] * syy\n    sumx = ssx + syx * sxy + (sxy - a[Lca - 1]) * syy - ssy\n    sumy = ssy + syy * sxx + (sxx - a[Lca - 1]) * syx - ssx\n    ans = sumx - sumy\n    return ans\n\ndef answer():\n    for i in range(q):\n        (x, y) = map(int, input().split())\n        print(solve(x, y))\nfor T in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        child[u].append([v, w])\n        child[v].append([u, w])\n    (px, py, ps) = ([0] * (n + 1), [0] * (n + 1), [0] * (n + 1))\n    level = [0] * (n + 1)\n    parent = [[-1 for i in range(20)] for j in range(n + 1)]\n    dfs(1, -1, 0, 0, 0, 0)\n    answer()", "import sys\ninput = sys.stdin.readline\nT = int(input())\n\ndef testcase():\n\n    def process(u, v, w, crate_list=False):\n        isolated = False\n        if tree_back[u - 1] != None:\n            known = u - 1\n            unknown = v - 1\n        elif tree_back[v - 1] != None:\n            known = v - 1\n            unknown = u - 1\n        else:\n            isolated = True\n        if isolated:\n            if crate_list:\n                u_unsolved.append(u)\n                v_unsolved.append(v)\n                w_unsolved.append(w)\n            return False\n        else:\n            cache_sum[unknown] = cache_sum[known] + w\n            cache_mul[unknown] = cache_mul[known] + 2 * cache_sum[unknown] * A[unknown]\n            tree_back[unknown] = known\n            hier[unknown] = hier[known] + 1\n            if child_cnt[known] == 0:\n                cache_branch[unknown] = cache_branch[known]\n                branch_hier[unknown] = branch_hier[known]\n                child_cnt[known] += 1\n            else:\n                connect_node.append(known)\n                branch_id[0] = branch_id[0] + 1\n                cache_branch[unknown] = branch_id[0]\n                branch_hier[unknown] = branch_hier[known] + 1\n                child_cnt[known] += 1\n            cache_weight_sum[unknown] = cache_weight_sum[known] + A[unknown]\n            return True\n\n    def process_only(unknown, known, w):\n        cache_sum[unknown] = cache_sum[known] + w\n        cache_mul[unknown] = cache_mul[known] + 2 * cache_sum[unknown] * A[unknown]\n        tree_back[unknown] = known\n        hier[unknown] = hier[known] + 1\n        if child_cnt[known] == 0:\n            cache_branch[unknown] = cache_branch[known]\n            branch_hier[unknown] = branch_hier[known]\n            child_cnt[known] += 1\n        else:\n            connect_node.append(known)\n            branch_id[0] = branch_id[0] + 1\n            cache_branch[unknown] = branch_id[0]\n            branch_hier[unknown] = branch_hier[known] + 1\n            child_cnt[known] += 1\n        cache_weight_sum[unknown] = cache_weight_sum[known] + A[unknown]\n\n    def calc(x, c, yd):\n        if c == 0:\n            return -cache_mul[x] + (cache_sum[x] - yd) * cache_weight_sum[x]\n        else:\n            return -(cache_mul[x] - cache_mul[tree_back[c]]) + (cache_sum[x] + cache_sum[c] - yd) * (cache_weight_sum[x] - cache_weight_sum[tree_back[c]])\n    (N, Q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    (u_unsolved, v_unsolved, w_unsolved) = ([], [], [])\n    (cache_sum, cache_mul, cache_weight_sum, tree_back, hier) = ([0] * N, [0] * N, [0] * N, [None] * N, [None] * N)\n    branch_hier = [None] * N\n    branch_parent = [-1]\n    connect_node = [-1]\n    branch_id = [0]\n    (cache_branch, child_cnt) = ([None] * N, [0] * N)\n    cache_weight_sum[0] = A[0]\n    (tree_back[0], hier[0], branch_hier[0]) = (-1, 0, 0)\n    raw_con = [[] for _ in range(N)]\n    raw_con_len = [[] for _ in range(N)]\n    for i in range(N - 1):\n        (u, v, w) = map(int, input().split())\n        process(u, v, w, crate_list=False)\n        raw_con[u - 1].append(v - 1)\n        raw_con_len[u - 1].append(w)\n        raw_con[v - 1].append(u - 1)\n        raw_con_len[v - 1].append(w)\n    to_be_visited = raw_con[0]\n    visit_len = raw_con_len[0]\n    last_node = [0] * len(to_be_visited)\n    while to_be_visited:\n        unknown = to_be_visited.pop()\n        known = last_node.pop()\n        dist = visit_len.pop()\n        if tree_back[unknown] == None:\n            process_only(unknown, known, dist)\n        for (i, child) in enumerate(raw_con[unknown]):\n            if child != known:\n                to_be_visited.append(child)\n                last_node.append(unknown)\n                visit_len.append(raw_con_len[unknown][i])\n    for i in range(Q):\n        (x, y) = map(int, input().split())\n        x = x - 1\n        y = y - 1\n        (treeX, treeY) = (x, y)\n        while cache_branch[treeX] != cache_branch[treeY]:\n            if branch_hier[treeX] == branch_hier[treeY]:\n                if cache_branch[treeX] != 0:\n                    treeX = connect_node[cache_branch[treeX]]\n                if cache_branch[treeY] != 0:\n                    treeY = connect_node[cache_branch[treeY]]\n            elif branch_hier[treeX] > branch_hier[treeY]:\n                treeX = connect_node[cache_branch[treeX]]\n            else:\n                treeY = connect_node[cache_branch[treeY]]\n        if hier[treeX] > hier[treeY]:\n            common_node = treeY\n        else:\n            common_node = treeX\n        if common_node == x:\n            ans = -calc(y, common_node, 0)\n        elif common_node == y:\n            ans = calc(x, common_node, 0)\n        else:\n            xd = cache_sum[x] - cache_sum[common_node]\n            yd = cache_sum[y] - cache_sum[common_node]\n            ans = calc(x, common_node, yd) - calc(y, common_node, xd) - (xd - yd) * A[common_node]\n        print(ans)\nfor _ in range(T):\n    testcase()"]