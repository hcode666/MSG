["MOD = 998244353\n\ndef modpow(base, exp, mod):\n    result = 1\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef modinv(base, mod):\n    return modpow(base, mod - 2, mod)\nMODINV = [modinv(i, MOD) for i in range(9 * 10 ** 4 + 5)]\n\ndef main(L, N, K):\n    B = [0]\n    for i in range(L):\n        for _ in range(int(N[L - 1 - i])):\n            B.append(B[-1] + (i + 1))\n    B = B[::-1]\n    K -= 1\n    if not K:\n        return B[0]\n    (S, C) = (0, 1)\n    for i in range(len(B)):\n        S = (S + B[i] * C) % MOD\n        C = C * ((K + i) % MOD) * MODINV[i + 1] % MOD\n    return S\nT = int(input().strip())\nfor i in range(T):\n    (N, K) = input().strip().split()[:2]\n    (L, K) = (len(N), int(K))\n    if K == 0:\n        print(L)\n    else:\n        print(main(L, N, K))", "MOD = 998244353\n\ndef modpow(base, exp, mod):\n    result = 1\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef modinv(base, mod):\n    return modpow(base, mod - 2, mod)\nMODINV = [modinv(i, MOD) for i in range(9 * 10 ** 4 + 5)]\n\ndef main(L, N, K):\n    B = [0]\n    for i in range(L):\n        for _ in range(int(N[L - 1 - i])):\n            B.append(B[-1] + (i + 1))\n    B = B[::-1]\n    K -= 1\n    if not K:\n        return B[0]\n    (S, C) = (0, 1)\n    for i in range(len(B)):\n        S = (S + B[i] * C) % MOD\n        C = C * ((K + i) % MOD) * MODINV[i + 1] % MOD\n    return S\nT = int(input().strip())\nfor i in range(T):\n    (N, K) = input().strip().split()[:2]\n    (L, K) = (len(N), int(K))\n    if K == 0:\n        print(L)\n    else:\n        print(main(L, N, K))", "MOD = 998244353\n\ndef modpow(base, exp, mod):\n    result = 1\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef modinv(base, mod):\n    return modpow(base, mod - 2, mod)\nMODINV = [modinv(i, MOD) for i in range(9 * 10 ** 4 + 5)]\n\ndef main(L, N, K):\n    B = [0]\n    for i in range(L):\n        for _ in range(int(N[L - 1 - i])):\n            B.append(B[-1] + (i + 1))\n    B = B[::-1]\n    K -= 1\n    if not K:\n        return B[0]\n    (S, C) = (0, 1)\n    for i in range(len(B)):\n        S = (S + B[i] * C) % MOD\n        C = C * ((K + i) % MOD) * MODINV[i + 1] % MOD\n    return S\nT = int(input().strip())\nfor i in range(T):\n    (N, K) = input().strip().split()[:2]\n    (L, K) = (len(N), int(K))\n    if K == 0:\n        print(L)\n    else:\n        print(main(L, N, K))", "mod = 998244353\nmaxn = 10 ** 6 + 10\ninvs = [1] * maxn\nfor i in range(2, maxn):\n    invs[i] = (mod - mod // i * invs[mod % i]) % mod\nt = int(input())\nfor _ in range(t):\n    (n, k) = input().split()\n    k = int(k)\n    if k == 0:\n        print(len(str(n)))\n        continue\n    pows = []\n    for i in range(len(n)):\n        times = ord(n[-1 - i]) - ord('0')\n        for j in range(times):\n            pows.append(i + 1)\n    (ans, coef, n) = (0, 1, len(pows))\n    for i in range(n):\n        ans += pows[n - 1 - i] * coef\n        coef = coef * (k + i) * invs[i + 1] % mod\n    print(ans % mod)", "mod = 998244353\nmaxn = 10 ** 6 + 10\ninvs = [1] * maxn\nfor i in range(2, maxn):\n    invs[i] = (mod - mod // i * invs[mod % i]) % mod\nt = int(input())\nfor _ in range(t):\n    (n, k) = input().split()\n    k = int(k)\n    if k == 0:\n        print(len(str(n)))\n        continue\n    pows = []\n    for i in range(len(n)):\n        times = ord(n[-1 - i]) - ord('0')\n        for j in range(times):\n            pows.append(i + 1)\n    (ans, coef, n) = (0, 1, len(pows))\n    for i in range(n):\n        ans += pows[n - 1 - i] * coef\n        coef = coef * (k + i) * invs[i + 1] % mod\n    print(ans % mod)", "mod = 998244353\nmaxn = 10 ** 6 + 10\ninvs = [1] * maxn\nfor i in range(2, maxn):\n    invs[i] = (mod - mod // i * invs[mod % i]) % mod\nt = int(input())\nfor _ in range(t):\n    (n, k) = input().split()\n    k = int(k)\n    if k == 0:\n        print(len(str(n)))\n        continue\n    pows = []\n    for i in range(len(n)):\n        times = ord(n[-1 - i]) - ord('0')\n        for j in range(times):\n            pows.append(i + 1)\n    (ans, coef, n) = (0, 1, len(pows))\n    for i in range(n):\n        ans += pows[n - 1 - i] * coef\n        coef = coef * (k + i) * invs[i + 1] % mod\n    print(ans % mod)", "mod = 998244353\nmaxn = 10 ** 6 + 10\ninvs = [1] * maxn\nfor i in range(2, maxn):\n    invs[i] = (mod - mod // i * invs[mod % i]) % mod\nt = int(input())\nfor _ in range(t):\n    (n, k) = input().split()\n    k = int(k)\n    if k == 0:\n        print(len(str(n)))\n        continue\n    pows = []\n    for i in range(len(n)):\n        times = ord(n[-1 - i]) - ord('0')\n        for j in range(times):\n            pows.append(i + 1)\n    (ans, coef, n) = (0, 1, len(pows))\n    for i in range(n):\n        ans += pows[n - 1 - i] * coef\n        coef = coef * (k + i) * invs[i + 1] % mod\n    print(ans % mod)", "mod = 998244353\nmxn = 200000\nfact = [1] * mxn\ninv = [0] * mxn\ninv[1] = 1\nfor i in range(2, mxn):\n    fact[i] = fact[i - 1] * i % mod\n    inv[i] = pow(fact[i], mod - 2, mod)\nfor _ in range(int(input())):\n    (s, k) = input().split()\n    k = int(k)\n    if k == 0:\n        print(len(s) % mod)\n        continue\n    i = len(s) - 1\n    a = []\n    pos = 0\n    p = 0\n    while i >= 0:\n        p += 1\n        d = int(s[i])\n        while d > 0:\n            pos += p\n            a.append(pos)\n            d -= 1\n        i -= 1\n    n = len(a)\n    if k == 1:\n        print(a[n - 1] % mod)\n        continue\n    a = a[::-1]\n    k -= 1\n    ans = a[0]\n    (nu, de) = (k, 1)\n    for i in range(1, n):\n        ans = (ans + mod + a[i] * nu * inv[de]) % mod\n        nu *= k + i\n        nu %= mod\n        de += 1\n    print(ans % mod)", "T = int(input())\nmod = 998244353\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n(fac, ifac) = ([0] * 1000000, [0] * 1000000)\nfac[0] = ifac[0] = 1\nfor i in range(1, 1000000):\n    fac[i] = fac[i - 1] * i % mod\nifac[999999] = inv(fac[999999])\nfor i in reversed(range(1, 999999)):\n    ifac[i] = ifac[i + 1] * (i + 1) % mod\n\ndef C(n, m):\n    return fac[n] * ifac[m] * ifac[n - m] % mod\nfor i in range(T):\n    (N, K) = input().split()\n    (l, K) = (len(N), int(K))\n    if K == 0:\n        print(len(N))\n        continue\n    A = []\n    for c in range(l):\n        for _ in range(int(N[c])):\n            A.append(l - c)\n    A.sort()\n    B = 1\n    answer = 0\n    for i in reversed(range(len(A))):\n        n = len(A) - 1 - i + K - 1\n        m = len(A) - 1 - i\n        answer += A[i] * B * ifac[m] % mod\n        B = B * (len(A) - 1 - i + K) % mod\n    print(answer % mod)", "MOD = 998244353\n\ndef modpow(base, exp, mod):\n    result = 1\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef modinv(base, mod):\n    return modpow(base, mod - 2, mod)\nMODINV = [modinv(i, MOD) for i in range(9 * 10 ** 4 + 5)]\n\ndef main(L, N, K):\n    B = [0]\n    for i in range(L):\n        for _ in range(int(N[L - 1 - i])):\n            B.append(B[-1] + (i + 1))\n    B = B[::-1]\n    K -= 1\n    if not K:\n        return B[0]\n    (S, C) = (0, 1)\n    for i in range(len(B)):\n        S = (S + B[i] * C) % MOD\n        C = C * ((K + i) % MOD) * MODINV[i + 1] % MOD\n    return S\nT = int(input().strip())\nfor _ in range(T):\n    (N, K) = input().strip().split()[:2]\n    (L, K) = (len(N), int(K))\n    if K == 0:\n        print(L)\n    else:\n        print(main(L, N, K))"]