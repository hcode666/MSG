["from sys import stdin, setrecursionlimit\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nsetrecursionlimit(6 * 10 ** 5)\n\ndef dfs(p, prev):\n    d = dict()\n    nextvalue = 0\n    for [u, i] in child[p]:\n        if prev == u:\n            continue\n        (take, value) = dfs(u, p)\n        ans[i] = value\n        if len(take) > len(d):\n            (d, take) = (take, d)\n        for x in take.keys():\n            if x in d:\n                d[x] += take[x]\n                if take[x] != total[x]:\n                    nextvalue -= x\n                    if d[x] == total[x]:\n                        nextvalue -= x\n            else:\n                d[x] = take[x]\n        nextvalue += value\n    if a[p - 1] not in d:\n        d[a[p - 1]] = 1\n        if total[a[p - 1]] > 1:\n            nextvalue += a[p - 1]\n    else:\n        d[a[p - 1]] += 1\n        if d[a[p - 1]] == total[a[p - 1]]:\n            nextvalue -= a[p - 1]\n    return [d, nextvalue]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = inp()\n    total = dict()\n    for i in range(n):\n        total[a[i]] = total.get(a[i], 0) + 1\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0 for i in range(n - 1)]\n    dfs(1, -1)\n    print(*ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nsetrecursionlimit(6 * 10 ** 5)\n\ndef dfs(p, prev):\n    d = dict()\n    nextvalue = 0\n    for [u, i] in child[p]:\n        if prev == u:\n            continue\n        (take, value) = dfs(u, p)\n        ans[i] = value\n        if len(take) > len(d):\n            (d, take) = (take, d)\n        for x in take.keys():\n            if x in d:\n                d[x] += take[x]\n                if take[x] != total[x]:\n                    nextvalue -= x\n                    if d[x] == total[x]:\n                        nextvalue -= x\n            else:\n                d[x] = take[x]\n        nextvalue += value\n    if a[p - 1] not in d:\n        d[a[p - 1]] = 1\n        if total[a[p - 1]] > 1:\n            nextvalue += a[p - 1]\n    else:\n        d[a[p - 1]] += 1\n        if d[a[p - 1]] == total[a[p - 1]]:\n            nextvalue -= a[p - 1]\n    return [d, nextvalue]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = inp()\n    total = dict()\n    for i in range(n):\n        total[a[i]] = total.get(a[i], 0) + 1\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0 for i in range(n - 1)]\n    dfs(1, -1)\n    print(*ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nsetrecursionlimit(6 * 10 ** 5)\n\ndef dfs(p, prev):\n    d = dict()\n    nextvalue = 0\n    for [u, i] in child[p]:\n        if prev == u:\n            continue\n        (take, value) = dfs(u, p)\n        ans[i] = value\n        if len(take) > len(d):\n            (d, take) = (take, d)\n        for x in take.keys():\n            if x in d:\n                d[x] += take[x]\n                if take[x] != total[x]:\n                    nextvalue -= x\n                    if d[x] == total[x]:\n                        nextvalue -= x\n            else:\n                d[x] = take[x]\n        nextvalue += value\n    if a[p - 1] not in d:\n        d[a[p - 1]] = 1\n        if total[a[p - 1]] > 1:\n            nextvalue += a[p - 1]\n    else:\n        d[a[p - 1]] += 1\n        if d[a[p - 1]] == total[a[p - 1]]:\n            nextvalue -= a[p - 1]\n    return [d, nextvalue]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = inp()\n    total = dict()\n    for i in range(n):\n        total[a[i]] = total.get(a[i], 0) + 1\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0 for i in range(n - 1)]\n    dfs(1, -1)\n    print(*ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nsetrecursionlimit(6 * 10 ** 5)\n\ndef dfs(p, prev):\n    d = dict()\n    nextvalue = 0\n    for [u, i] in child[p]:\n        if prev == u:\n            continue\n        (take, value) = dfs(u, p)\n        ans[i] = value\n        if len(take) > len(d):\n            (d, take) = (take, d)\n        for x in take.keys():\n            if x in d:\n                d[x] += take[x]\n                if take[x] != total[x]:\n                    nextvalue -= x\n                    if d[x] == total[x]:\n                        nextvalue -= x\n            else:\n                d[x] = take[x]\n        nextvalue += value\n    if a[p - 1] not in d:\n        d[a[p - 1]] = 1\n        if total[a[p - 1]] > 1:\n            nextvalue += a[p - 1]\n    else:\n        d[a[p - 1]] += 1\n        if d[a[p - 1]] == total[a[p - 1]]:\n            nextvalue -= a[p - 1]\n    return [d, nextvalue]\nfor T in range(int(input())):\n    n = int(input())\n    a = inp()\n    total = dict()\n    for i in range(n):\n        total[a[i]] = total.get(a[i], 0) + 1\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0 for i in range(n - 1)]\n    dfs(1, -1)\n    print(*ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nsetrecursionlimit(6 * 10 ** 5)\n\ndef dfs(p, prev):\n    d = dict()\n    nextvalue = 0\n    for [u, i] in child[p]:\n        if prev == u:\n            continue\n        (take, value) = dfs(u, p)\n        ans[i] = value\n        if len(take) > len(d):\n            (d, take) = (take, d)\n        for x in take.keys():\n            if x in d:\n                d[x] += take[x]\n                if take[x] != total[x]:\n                    nextvalue -= x\n                    if d[x] == total[x]:\n                        nextvalue -= x\n            else:\n                d[x] = take[x]\n        nextvalue += value\n    if a[p - 1] not in d:\n        d[a[p - 1]] = 1\n        if total[a[p - 1]] > 1:\n            nextvalue += a[p - 1]\n    else:\n        d[a[p - 1]] += 1\n        if d[a[p - 1]] == total[a[p - 1]]:\n            nextvalue -= a[p - 1]\n    return [d, nextvalue]\nfor T in range(int(input())):\n    n = int(input())\n    a = inp()\n    total = dict()\n    for i in range(n):\n        total[a[i]] = total.get(a[i], 0) + 1\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0 for i in range(n - 1)]\n    dfs(1, -1)\n    print(*ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nsetrecursionlimit(6 * 10 ** 5)\n\ndef dfs(p, prev):\n    d = dict()\n    nextvalue = 0\n    for [u, i] in child[p]:\n        if prev == u:\n            continue\n        (take, value) = dfs(u, p)\n        ans[i] = value\n        if len(take) > len(d):\n            (d, take) = (take, d)\n        for x in take.keys():\n            if x in d:\n                d[x] += take[x]\n                if take[x] != total[x]:\n                    nextvalue -= x\n                    if d[x] == total[x]:\n                        nextvalue -= x\n            else:\n                d[x] = take[x]\n        nextvalue += value\n    if a[p - 1] not in d:\n        d[a[p - 1]] = 1\n        if total[a[p - 1]] > 1:\n            nextvalue += a[p - 1]\n    else:\n        d[a[p - 1]] += 1\n        if d[a[p - 1]] == total[a[p - 1]]:\n            nextvalue -= a[p - 1]\n    return [d, nextvalue]\nfor T in range(int(input())):\n    n = int(input())\n    a = inp()\n    total = dict()\n    for i in range(n):\n        total[a[i]] = total.get(a[i], 0) + 1\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0 for i in range(n - 1)]\n    dfs(1, -1)\n    print(*ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nsetrecursionlimit(6 * 10 ** 5)\n\ndef dfs(p, prev):\n    d = dict()\n    nextvalue = 0\n    for [u, i] in child[p]:\n        if prev == u:\n            continue\n        (take, value) = dfs(u, p)\n        ans[i] = value\n        if len(take) > len(d):\n            (d, take) = (take, d)\n        for x in take.keys():\n            if x in d:\n                d[x] += take[x]\n                if take[x] != total[x]:\n                    nextvalue -= x\n                    if d[x] == total[x]:\n                        nextvalue -= x\n            else:\n                d[x] = take[x]\n        nextvalue += value\n    if a[p - 1] not in d:\n        d[a[p - 1]] = 1\n        if total[a[p - 1]] > 1:\n            nextvalue += a[p - 1]\n    else:\n        d[a[p - 1]] += 1\n        if d[a[p - 1]] == total[a[p - 1]]:\n            nextvalue -= a[p - 1]\n    return [d, nextvalue]\nfor T in range(int(input())):\n    n = int(input())\n    a = inp()\n    total = dict()\n    for i in range(n):\n        total[a[i]] = total.get(a[i], 0) + 1\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0 for i in range(n - 1)]\n    dfs(1, -1)\n    print(*ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nsetrecursionlimit(6 * 10 ** 5)\n\ndef dfs(p, prev):\n    d = dict()\n    nextvalue = 0\n    for [u, i] in child[p]:\n        if prev == u:\n            continue\n        (take, value) = dfs(u, p)\n        ans[i] = value\n        if len(take) > len(d):\n            (d, take) = (take, d)\n        for x in take.keys():\n            if x in d:\n                d[x] += take[x]\n                if take[x] != total[x]:\n                    nextvalue -= x\n                    if d[x] == total[x]:\n                        nextvalue -= x\n            else:\n                d[x] = take[x]\n        nextvalue += value\n    if a[p - 1] not in d:\n        d[a[p - 1]] = 1\n        if total[a[p - 1]] > 1:\n            nextvalue += a[p - 1]\n    else:\n        d[a[p - 1]] += 1\n        if d[a[p - 1]] == total[a[p - 1]]:\n            nextvalue -= a[p - 1]\n    return [d, nextvalue]\nfor T in range(int(input())):\n    n = int(input())\n    a = inp()\n    total = dict()\n    for i in range(n):\n        total[a[i]] = total.get(a[i], 0) + 1\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0 for i in range(n - 1)]\n    dfs(1, -1)\n    print(*ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nsetrecursionlimit(6 * 10 ** 5)\n\ndef dfs(p, prev):\n    d = dict()\n    nextvalue = 0\n    for [u, i] in child[p]:\n        if prev == u:\n            continue\n        (take, value) = dfs(u, p)\n        ans[i] = value\n        if len(take) > len(d):\n            (d, take) = (take, d)\n        for x in take.keys():\n            if x in d:\n                d[x] += take[x]\n                if take[x] != total[x]:\n                    nextvalue -= x\n                    if d[x] == total[x]:\n                        nextvalue -= x\n            else:\n                d[x] = take[x]\n        nextvalue += value\n    if a[p - 1] not in d:\n        d[a[p - 1]] = 1\n        if total[a[p - 1]] > 1:\n            nextvalue += a[p - 1]\n    else:\n        d[a[p - 1]] += 1\n        if d[a[p - 1]] == total[a[p - 1]]:\n            nextvalue -= a[p - 1]\n    return [d, nextvalue]\nfor T in range(int(input())):\n    n = int(input())\n    a = inp()\n    total = dict()\n    for i in range(n):\n        total[a[i]] = total.get(a[i], 0) + 1\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0 for i in range(n - 1)]\n    dfs(1, -1)\n    print(*ans)"]