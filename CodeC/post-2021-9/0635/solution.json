["from sys import stdin\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\n\ndef b_s(take, left, right):\n    (l, h) = (0, len(take) - 1)\n    while l <= h:\n        mid = (l + h) // 2\n        if take[mid] < left:\n            l = mid + 1\n            continue\n        if take[mid] > right:\n            h = mid - 1\n            continue\n        return take[mid]\n\ndef sparse_query(b, left, right):\n    dist = right - left + 1\n    if dist == 0:\n        return 0\n    for i in range(19, -1, -1):\n        if dist >> i & 1:\n            msb = i\n            break\n    return max(b[left][msb], b[right - (1 << msb) + 1][msb])\n\ndef sparse_table(b):\n    for j in range(1, 20):\n        for i in range(n - (1 << j - 1)):\n            b[i][j] = max(b[i][j - 1], b[i + (1 << j - 1)][j - 1])\n\ndef answer():\n    best_ans = [[0 for i in range(20)] for j in range(n)]\n    best_suf = [[0 for i in range(20)] for j in range(n)]\n    best_pref = [[0 for i in range(20)] for j in range(n)]\n    takes = dict()\n    takep = dict()\n    total = [0]\n    for i in range(n):\n        (ans, sval) = (0, 0)\n        for j in s[i]:\n            if j == '1':\n                sval += 1\n            else:\n                sval -= 1\n            ans = max(ans, sval)\n            if sval <= 0:\n                sval = 0\n        best_ans[i][0] = ans\n        (ans, sval) = (0, 0)\n        for j in s[i]:\n            if j == '1':\n                sval += 1\n            else:\n                sval -= 1\n            ans = max(ans, sval)\n        best_pref[i][0] = ans - max(0, sval)\n        total.append(total[-1] + max(0, sval))\n        key = ans - max(0, sval)\n        if key not in takep:\n            takep[key] = []\n        takep[key].append(i)\n        (ans, sval) = (0, 0)\n        for j in s[i][::-1]:\n            if j == '1':\n                sval += 1\n            else:\n                sval -= 1\n            ans = max(ans, sval)\n        best_suf[i][0] = ans - max(0, sval)\n        key = ans - max(0, sval)\n        if key not in takes:\n            takes[key] = []\n        takes[key].append(i)\n    sparse_table(best_pref)\n    sparse_table(best_suf)\n    sparse_table(best_ans)\n    for i in range(q):\n        (l, r) = inp()\n        (l, r) = (l - 1, r - 1)\n        ans = sparse_query(best_ans, l, r)\n        t = total[r + 1] - total[l]\n        bs = sparse_query(best_suf, l, r)\n        mid = b_s(takes[bs], l, r)\n        bp = max(sparse_query(best_pref, l, mid - 1), sparse_query(best_pref, mid + 1, r))\n        ans = max(ans, t + bs + bp)\n        bp = sparse_query(best_pref, l, r)\n        mid = b_s(takep[bp], l, r)\n        bs = max(sparse_query(best_suf, l, mid - 1), sparse_query(best_suf, mid + 1, r))\n        ans = max(ans, t + bp + bs)\n        print(ans)\nfor T in range(1):\n    (n, q) = inp()\n    (size, s) = ([], [])\n    for i in range(n):\n        size.append(int(input()))\n        s.append(input().strip())\n    answer()", "from sys import stdin\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\n\ndef b_s(take, left, right):\n    (l, h) = (0, len(take) - 1)\n    while l <= h:\n        mid = (l + h) // 2\n        if take[mid] < left:\n            l = mid + 1\n            continue\n        if take[mid] > right:\n            h = mid - 1\n            continue\n        return take[mid]\n\ndef sparse_query(b, left, right):\n    dist = right - left + 1\n    if dist == 0:\n        return 0\n    for i in range(19, -1, -1):\n        if dist >> i & 1:\n            msb = i\n            break\n    return max(b[left][msb], b[right - (1 << msb) + 1][msb])\n\ndef sparse_table(b):\n    for j in range(1, 20):\n        for i in range(n - (1 << j - 1)):\n            b[i][j] = max(b[i][j - 1], b[i + (1 << j - 1)][j - 1])\n\ndef answer():\n    best_ans = [[0 for i in range(20)] for j in range(n)]\n    best_suf = [[0 for i in range(20)] for j in range(n)]\n    best_pref = [[0 for i in range(20)] for j in range(n)]\n    takes = dict()\n    takep = dict()\n    total = [0]\n    for i in range(n):\n        (ans, sval) = (0, 0)\n        for j in s[i]:\n            if j == '1':\n                sval += 1\n            else:\n                sval -= 1\n            ans = max(ans, sval)\n            if sval <= 0:\n                sval = 0\n        best_ans[i][0] = ans\n        (ans, sval) = (0, 0)\n        for j in s[i]:\n            if j == '1':\n                sval += 1\n            else:\n                sval -= 1\n            ans = max(ans, sval)\n        best_pref[i][0] = ans - max(0, sval)\n        total.append(total[-1] + max(0, sval))\n        key = ans - max(0, sval)\n        if key not in takep:\n            takep[key] = []\n        takep[key].append(i)\n        (ans, sval) = (0, 0)\n        for j in s[i][::-1]:\n            if j == '1':\n                sval += 1\n            else:\n                sval -= 1\n            ans = max(ans, sval)\n        best_suf[i][0] = ans - max(0, sval)\n        key = ans - max(0, sval)\n        if key not in takes:\n            takes[key] = []\n        takes[key].append(i)\n    sparse_table(best_pref)\n    sparse_table(best_suf)\n    sparse_table(best_ans)\n    for i in range(q):\n        (l, r) = inp()\n        (l, r) = (l - 1, r - 1)\n        ans = sparse_query(best_ans, l, r)\n        t = total[r + 1] - total[l]\n        bs = sparse_query(best_suf, l, r)\n        mid = b_s(takes[bs], l, r)\n        bp = max(sparse_query(best_pref, l, mid - 1), sparse_query(best_pref, mid + 1, r))\n        ans = max(ans, t + bs + bp)\n        bp = sparse_query(best_pref, l, r)\n        mid = b_s(takep[bp], l, r)\n        bs = max(sparse_query(best_suf, l, mid - 1), sparse_query(best_suf, mid + 1, r))\n        ans = max(ans, t + bp + bs)\n        print(ans)\nfor T in range(1):\n    (n, q) = inp()\n    (size, s) = ([], [])\n    for i in range(n):\n        size.append(int(input()))\n        s.append(input().strip())\n    answer()"]