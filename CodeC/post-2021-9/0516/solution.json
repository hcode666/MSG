["from collections import Counter, defaultdict\nimport math\nimport sys\nfrom collections import Counter\nMOD = 10 ** 9 + 7\n\ndef readArr():\n    return list(map(int, input().split()))\n\ndef readInt():\n    return int(input())\n\ndef readStr():\n    return input()\n\ndef precompute(pat):\n    totalLen = len(pat)\n    lps = [0 for _ in range(totalLen)]\n    length = 0\n    i = 1\n    while i < totalLen:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        elif length != 0:\n            length = lps[length - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\n\ndef KMPSearch(pat, text):\n    lps = precompute(pat)\n    (patLen, textLen) = (len(pat), len(text))\n    (i, j) = (0, 0)\n    while textLen - i >= patLen - j:\n        if text[i] == pat[j]:\n            i += 1\n            j += 1\n        if j == patLen:\n            return True\n        elif i < textLen and text[i] != pat[j]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return False\n\ndef add_to_map(s, mp):\n    for i in range(32):\n        if s[i] == '1':\n            mp[i] += 1\n\ndef remove_from_map(s, mp):\n    for i in range(32):\n        if s[i] == '1':\n            mp[i] -= 1\n\ndef compare_map(m1, m2):\n    for i in range(32):\n        val1 = m1[i] > 0\n        val2 = m2[i] > 0\n        if val1 != val2:\n            return False\n    return True\n\ndef solve():\n    n = readInt()\n    arr = readArr()\n    x = 0\n    not_zero = False\n    for val in arr:\n        if val != 0:\n            not_zero = True\n        x = x | val\n    if not not_zero:\n        print(n)\n        return\n    strs = [bin(val).replace('0b', '').rjust(32, '0') for val in arr]\n    x = bin(x).replace('0b', '').rjust(32, '0')\n    cur_map = [0] * 32\n    ext_map = [0] * 32\n    x_map = [0] * 32\n    add_to_map(x, x_map)\n    for s in strs:\n        add_to_map(s, ext_map)\n    if any([val == 1 for val in ext_map]):\n        print(-1)\n        return\n    i = j = 0\n    ans = -1\n    while j < n and i < n:\n        while j < n and (not compare_map(cur_map, x_map)):\n            add_to_map(strs[j], cur_map)\n            remove_from_map(strs[j], ext_map)\n            j += 1\n        while j < n and compare_map(ext_map, x_map):\n            ans = max(ans, j - i)\n            add_to_map(strs[j], cur_map)\n            remove_from_map(strs[j], ext_map)\n            j += 1\n        if compare_map(ext_map, x_map):\n            ans = max(ans, j - i)\n        remove_from_map(strs[i], cur_map)\n        add_to_map(strs[i], ext_map)\n        i += 1\n    print(ans)\nt = readInt()\nfor test in range(1, t + 1):\n    solve()", "from collections import Counter, defaultdict\nimport math\nimport sys\nfrom collections import Counter\nMOD = 10 ** 9 + 7\n\ndef readArr():\n    return list(map(int, input().split()))\n\ndef readInt():\n    return int(input())\n\ndef readStr():\n    return input()\n\ndef precompute(pat):\n    totalLen = len(pat)\n    lps = [0 for _ in range(totalLen)]\n    length = 0\n    i = 1\n    while i < totalLen:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        elif length != 0:\n            length = lps[length - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\n\ndef KMPSearch(pat, text):\n    lps = precompute(pat)\n    (patLen, textLen) = (len(pat), len(text))\n    (i, j) = (0, 0)\n    while textLen - i >= patLen - j:\n        if text[i] == pat[j]:\n            i += 1\n            j += 1\n        if j == patLen:\n            return True\n        elif i < textLen and text[i] != pat[j]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return False\n\ndef add_to_map(s, mp):\n    for i in range(32):\n        if s[i] == '1':\n            mp[i] += 1\n\ndef remove_from_map(s, mp):\n    for i in range(32):\n        if s[i] == '1':\n            mp[i] -= 1\n\ndef compare_map(m1, m2):\n    for i in range(32):\n        val1 = m1[i] > 0\n        val2 = m2[i] > 0\n        if val1 != val2:\n            return False\n    return True\n\ndef solve():\n    n = readInt()\n    arr = readArr()\n    x = 0\n    not_zero = False\n    for val in arr:\n        if val != 0:\n            not_zero = True\n        x = x | val\n    if not not_zero:\n        print(n)\n        return\n    strs = [bin(val).replace('0b', '').rjust(32, '0') for val in arr]\n    x = bin(x).replace('0b', '').rjust(32, '0')\n    cur_map = [0] * 32\n    ext_map = [0] * 32\n    x_map = [0] * 32\n    add_to_map(x, x_map)\n    for s in strs:\n        add_to_map(s, ext_map)\n    if any([val == 1 for val in ext_map]):\n        print(-1)\n        return\n    i = j = 0\n    ans = -1\n    while j < n and i < n:\n        while j < n and (not compare_map(cur_map, x_map)):\n            add_to_map(strs[j], cur_map)\n            remove_from_map(strs[j], ext_map)\n            j += 1\n        while j < n and compare_map(ext_map, x_map):\n            ans = max(ans, j - i)\n            add_to_map(strs[j], cur_map)\n            remove_from_map(strs[j], ext_map)\n            j += 1\n        if compare_map(ext_map, x_map):\n            ans = max(ans, j - i)\n        remove_from_map(strs[i], cur_map)\n        add_to_map(strs[i], ext_map)\n        i += 1\n    print(ans)\nt = readInt()\nfor test in range(1, t + 1):\n    solve()", "from collections import Counter, defaultdict\nimport math\nimport sys\nfrom collections import Counter\nMOD = 10 ** 9 + 7\n\ndef readArr():\n    return list(map(int, input().split()))\n\ndef readInt():\n    return int(input())\n\ndef readStr():\n    return input()\n\ndef precompute(pat):\n    totalLen = len(pat)\n    lps = [0 for _ in range(totalLen)]\n    length = 0\n    i = 1\n    while i < totalLen:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        elif length != 0:\n            length = lps[length - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\n\ndef KMPSearch(pat, text):\n    lps = precompute(pat)\n    (patLen, textLen) = (len(pat), len(text))\n    (i, j) = (0, 0)\n    while textLen - i >= patLen - j:\n        if text[i] == pat[j]:\n            i += 1\n            j += 1\n        if j == patLen:\n            return True\n        elif i < textLen and text[i] != pat[j]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return False\n\ndef add_to_map(s, mp):\n    for i in range(32):\n        if s[i] == '1':\n            mp[i] += 1\n\ndef remove_from_map(s, mp):\n    for i in range(32):\n        if s[i] == '1':\n            mp[i] -= 1\n\ndef compare_map(m1, m2):\n    for i in range(32):\n        val1 = m1[i] > 0\n        val2 = m2[i] > 0\n        if val1 != val2:\n            return False\n    return True\n\ndef solve():\n    n = readInt()\n    arr = readArr()\n    x = 0\n    not_zero = False\n    for val in arr:\n        if val != 0:\n            not_zero = True\n        x = x | val\n    if not not_zero:\n        print(n)\n        return\n    strs = [bin(val).replace('0b', '').rjust(32, '0') for val in arr]\n    x = bin(x).replace('0b', '').rjust(32, '0')\n    cur_map = [0] * 32\n    ext_map = [0] * 32\n    x_map = [0] * 32\n    add_to_map(x, x_map)\n    for s in strs:\n        add_to_map(s, ext_map)\n    if any([val == 1 for val in ext_map]):\n        print(-1)\n        return\n    i = j = 0\n    ans = -1\n    while j < n and i < n:\n        while j < n and (not compare_map(cur_map, x_map)):\n            add_to_map(strs[j], cur_map)\n            remove_from_map(strs[j], ext_map)\n            j += 1\n        while j < n and compare_map(ext_map, x_map):\n            ans = max(ans, j - i)\n            add_to_map(strs[j], cur_map)\n            remove_from_map(strs[j], ext_map)\n            j += 1\n        if compare_map(ext_map, x_map):\n            ans = max(ans, j - i)\n        remove_from_map(strs[i], cur_map)\n        add_to_map(strs[i], ext_map)\n        i += 1\n    print(ans)\nt = readInt()\nfor test in range(1, t + 1):\n    solve()", "from collections import Counter, defaultdict\nimport math\nimport sys\nfrom collections import Counter\nMOD = 10 ** 9 + 7\n\ndef readArr():\n    return list(map(int, input().split()))\n\ndef readInt():\n    return int(input())\n\ndef readStr():\n    return input()\n\ndef precompute(pat):\n    totalLen = len(pat)\n    lps = [0 for _ in range(totalLen)]\n    length = 0\n    i = 1\n    while i < totalLen:\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        elif length != 0:\n            length = lps[length - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\n\ndef KMPSearch(pat, text):\n    lps = precompute(pat)\n    (patLen, textLen) = (len(pat), len(text))\n    (i, j) = (0, 0)\n    while textLen - i >= patLen - j:\n        if text[i] == pat[j]:\n            i += 1\n            j += 1\n        if j == patLen:\n            return True\n        elif i < textLen and text[i] != pat[j]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return False\n\ndef add_to_map(s, mp):\n    for i in range(32):\n        if s[i] == '1':\n            mp[i] += 1\n\ndef remove_from_map(s, mp):\n    for i in range(32):\n        if s[i] == '1':\n            mp[i] -= 1\n\ndef compare_map(m1, m2):\n    for i in range(32):\n        val1 = m1[i] > 0\n        val2 = m2[i] > 0\n        if val1 != val2:\n            return False\n    return True\n\ndef solve():\n    n = readInt()\n    arr = readArr()\n    x = 0\n    not_zero = False\n    for val in arr:\n        if val != 0:\n            not_zero = True\n        x = x | val\n    if not not_zero:\n        print(n)\n        return\n    strs = [bin(val).replace('0b', '').rjust(32, '0') for val in arr]\n    x = bin(x).replace('0b', '').rjust(32, '0')\n    cur_map = [0] * 32\n    ext_map = [0] * 32\n    x_map = [0] * 32\n    add_to_map(x, x_map)\n    for s in strs:\n        add_to_map(s, ext_map)\n    if any([val == 1 for val in ext_map]):\n        print(-1)\n        return\n    i = j = 0\n    ans = -1\n    while j < n and i < n:\n        while j < n and (not compare_map(cur_map, x_map)):\n            add_to_map(strs[j], cur_map)\n            remove_from_map(strs[j], ext_map)\n            j += 1\n        while j < n and compare_map(ext_map, x_map):\n            ans = max(ans, j - i)\n            add_to_map(strs[j], cur_map)\n            remove_from_map(strs[j], ext_map)\n            j += 1\n        if compare_map(ext_map, x_map):\n            ans = max(ans, j - i)\n        remove_from_map(strs[i], cur_map)\n        add_to_map(strs[i], ext_map)\n        i += 1\n    print(ans)\nt = readInt()\nfor test in range(1, t + 1):\n    solve()", "from bisect import bisect_right\nfrom sys import stdin\ninput = stdin.readline\nMAX = 32\n\ndef solve(N, A):\n    count = [[0] * (N + 1) for i in range(MAX)]\n    for bit in range(MAX):\n        for (i, a) in enumerate(A, start=1):\n            count[bit][i] = count[bit][i - 1] + (a >> bit & 1)\n    for bit in range(MAX):\n        if count[bit][N] == 1:\n            return -1\n    bits = set([bit for bit in range(MAX) if count[bit][N] > 0])\n    maximum = 0\n    for i in range(1, N + 1):\n        if N - i + 1 <= maximum:\n            break\n        missing = []\n        ok = True\n        for bit in bits:\n            if count[bit][i - 1] == 0:\n                missing.append(bit)\n            elif count[bit][i - 1] == count[bit][N]:\n                ok = False\n                break\n        if not ok:\n            break\n        last = N\n        for bit in missing:\n            if count[bit][last] == count[bit][N]:\n                last = bisect_right(count[bit], count[bit][last] - 1) - 1\n                if last == i or last - i + 1 <= maximum:\n                    break\n        ok = True\n        for bit in bits:\n            if count[bit][i - 1] == count[bit][last]:\n                ok = False\n                break\n        if ok:\n            maximum = max(maximum, last - i + 1)\n            if maximum == N - 1:\n                break\n    if maximum == 0:\n        return -1\n    return maximum\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    N = int(input().strip())\n    A = [int(x) for x in input().strip().split()]\n    print(solve(N, A))", "from bisect import bisect_right\nfrom sys import stdin\ninput = stdin.readline\nMAX = 32\n\ndef solve(N, A):\n    count = [[0] * (N + 1) for i in range(MAX)]\n    for bit in range(MAX):\n        for (i, a) in enumerate(A, start=1):\n            count[bit][i] = count[bit][i - 1] + (a >> bit & 1)\n    for bit in range(MAX):\n        if count[bit][N] == 1:\n            return -1\n    bits = set([bit for bit in range(MAX) if count[bit][N] > 0])\n    maximum = 0\n    for i in range(1, N + 1):\n        if N - i + 1 < maximum:\n            break\n        missing = []\n        ok = True\n        for bit in bits:\n            if count[bit][i - 1] == 0:\n                missing.append(bit)\n            elif count[bit][i - 1] == count[bit][N]:\n                ok = False\n                break\n        if not ok:\n            break\n        last = N\n        for bit in missing:\n            if count[bit][last] == count[bit][N]:\n                last = bisect_right(count[bit], count[bit][last] - 1) - 1\n                if last == i or last - i + 1 <= maximum:\n                    break\n        ok = True\n        for bit in bits:\n            if count[bit][i - 1] == count[bit][last]:\n                ok = False\n                break\n        if ok:\n            maximum = max(maximum, last - i + 1)\n            if maximum == N - 1:\n                break\n    if maximum == 0:\n        return -1\n    return maximum\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    N = int(input().strip())\n    A = [int(x) for x in input().strip().split()]\n    print(solve(N, A))"]