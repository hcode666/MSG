["from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(p, prev, turn):\n    (m1, m2) = (float('inf'), -float('inf'))\n    for i in child[p]:\n        if i == prev:\n            continue\n        x = dfs(i, p, turn ^ 1)\n        m1 = min(m1, x + a[p - 1])\n        m2 = max(m2, x + a[p - 1])\n    if p != 1 and len(child[p]) == 1 or len(child[p]) == 0:\n        return a[p - 1]\n    else:\n        return m2 if turn else m1\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    print(dfs(1, -1, 0))", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(p, prev, turn):\n    (m1, m2) = (float('inf'), -float('inf'))\n    for i in child[p]:\n        if i == prev:\n            continue\n        x = dfs(i, p, turn ^ 1)\n        m1 = min(m1, x + a[p - 1])\n        m2 = max(m2, x + a[p - 1])\n    if p != 1 and len(child[p]) == 1 or len(child[p]) == 0:\n        return a[p - 1]\n    else:\n        return m2 if turn else m1\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    print(dfs(1, -1, 0))", "import math\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef solve(A, tree, root, dic):\n    if root in tree:\n        for node in tree.get(root):\n            solve(A, tree, node, dic)\n    if root not in tree:\n        dic[root] = (0, 0)\n    else:\n        minn = 1000000007\n        maxx = -1000000007\n        for node in tree.get(root):\n            minn = min(minn, A[node] + dic.get(node)[1])\n            maxx = max(maxx, A[node] + dic.get(node)[0])\n        dic[root] = (minn, maxx)\n\ndef buildTree(edges):\n    tree = {}\n    for edge in edges:\n        edge.sort()\n        if edge[0] not in tree:\n            tree[edge[0]] = [edge[1]]\n        else:\n            tree[edge[0]].append(edge[1])\n    return tree\nfor t in range(int(input())):\n    (N, K) = map(int, input().split())\n    dic = {}\n    A = list(map(int, input().split()))\n    if N == 1:\n        print(A[0])\n        continue\n    edges = []\n    for i in range(N - 1):\n        (x, y) = map(int, input().split())\n        edges.append([x - 1, y - 1])\n    tree = buildTree(edges)\n    solve(A, tree, 0, dic)\n    print(dic[0][0])", "import math\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef solve(A, tree, root, dic):\n    if root in tree:\n        for node in tree.get(root):\n            solve(A, tree, node, dic)\n    if root not in tree:\n        dic[root] = (0, 0)\n    else:\n        minn = 1000000007\n        maxx = -1000000007\n        for node in tree.get(root):\n            minn = min(minn, A[node] + dic.get(node)[1])\n            maxx = max(maxx, A[node] + dic.get(node)[0])\n        dic[root] = (minn, maxx)\n\ndef buildTree(edges):\n    tree = {}\n    for edge in edges:\n        edge.sort()\n        if edge[0] not in tree:\n            tree[edge[0]] = [edge[1]]\n        else:\n            tree[edge[0]].append(edge[1])\n    return tree\nfor t in range(int(input())):\n    (N, K) = map(int, input().split())\n    dic = {}\n    A = list(map(int, input().split()))\n    if N == 1:\n        print(A[0])\n        continue\n    edges = []\n    for i in range(N - 1):\n        (x, y) = map(int, input().split())\n        edges.append([x - 1, y - 1])\n    tree = buildTree(edges)\n    solve(A, tree, 0, dic)\n    print(dic[0][0])", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(p, prev, turn):\n    (m1, m2) = (float('inf'), -float('inf'))\n    for i in child[p]:\n        if i == prev:\n            continue\n        x = dfs(i, p, turn ^ 1)\n        m1 = min(m1, x + a[p - 1])\n        m2 = max(m2, x + a[p - 1])\n    if p != 1 and len(child[p]) == 1 or len(child[p]) == 0:\n        return a[p - 1]\n    else:\n        return m2 if turn else m1\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    print(dfs(1, -1, 0))", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(p, prev, turn):\n    (m1, m2) = (float('inf'), -float('inf'))\n    for i in child[p]:\n        if i == prev:\n            continue\n        x = dfs(i, p, turn ^ 1)\n        m1 = min(m1, x + a[p - 1])\n        m2 = max(m2, x + a[p - 1])\n    if p != 1 and len(child[p]) == 1 or len(child[p]) == 0:\n        return a[p - 1]\n    else:\n        return m2 if turn else m1\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    print(dfs(1, -1, 0))", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(p, prev, turn):\n    (m1, m2) = (float('inf'), -float('inf'))\n    for i in child[p]:\n        if i == prev:\n            continue\n        x = dfs(i, p, turn ^ 1)\n        m1 = min(m1, x + a[p - 1])\n        m2 = max(m2, x + a[p - 1])\n    if p != 1 and len(child[p]) == 1 or len(child[p]) == 0:\n        return a[p - 1]\n    else:\n        return m2 if turn else m1\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    print(dfs(1, -1, 0))", "T = int(input())\nimport sys\nsys.setrecursionlimit(10000000)\n\nclass Node:\n\n    def __init__(self, weight):\n        self.weight = int(weight)\n        self.cost = None\n        self.child = []\n        self.level = None\n        self.choice = None\n\ndef setLevels(node, level=0):\n    node.level = level\n    for n in node.child:\n        setLevels(n, level + 1)\n\ndef setCost(node, cost=0):\n    node.cost = cost + node.weight\n    for n in node.child:\n        setCost(n, node.cost)\n\ndef findChoice(node):\n    if not node.child:\n        node.choice = node.cost\n        return node.choice\n    options = [findChoice(n) for n in node.child]\n    if node.level % 2:\n        node.choice = max(options)\n    else:\n        node.choice = min(options)\n    return node.choice\nfor _ in range(T):\n    (n, k) = list(map(int, input().split(' ')))\n    weights = list(map(Node, input().split(' ')))\n    for x in range(n - 1):\n        (a, b) = sorted([x - 1 for x in map(int, input().split(' '))])\n        weights[a].child.append(weights[b])\n    setLevels(weights[0])\n    setCost(weights[0])\n    findChoice(weights[0])\n    print(weights[0].choice)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p, prev, turn):\n    (m1, m2) = (float('inf'), -float('inf'))\n    for i in child[p]:\n        if i == prev:\n            continue\n        x = dfs(i, p, turn ^ 1)\n        m1 = min(m1, x + a[p - 1])\n        m2 = max(m2, x + a[p - 1])\n    if p != 1 and len(child[p]) == 1 or len(child[p]) == 0:\n        return a[p - 1]\n    elif turn == 0:\n        return m1\n    else:\n        return m2\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    ans = dfs(1, -1, 0)\n    print(ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p, prev, turn):\n    (m1, m2) = (float('inf'), -float('inf'))\n    count = 0\n    for i in child[p]:\n        if i == prev:\n            continue\n        x = dfs(i, p, turn ^ 1)\n        m1 = min(m1, x + a[p - 1])\n        m2 = max(m2, x + a[p - 1])\n        count += 1\n    if count == 0:\n        return a[p - 1]\n    elif turn == 0:\n        return m1\n    else:\n        return m2\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    ans = dfs(1, -1, 0)\n    print(ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p, prev, lvl):\n    (m1, m2) = (float('inf'), -float('inf'))\n    count = 0\n    for i in child[p]:\n        if i == prev:\n            continue\n        x = dfs(i, p, lvl + 1)\n        m1 = min(m1, x)\n        m2 = max(m2, x)\n        count += 1\n    if count == 0:\n        return a[p - 1]\n    elif lvl & 1 == 0:\n        return m1 + a[p - 1]\n    else:\n        return m2 + a[p - 1]\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    ans = dfs(1, -1, 0)\n    print(ans)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p, prev, turn):\n    x = []\n    for i in child[p]:\n        if i == prev:\n            continue\n        x.append(dfs(i, p, turn ^ 1))\n    if len(x) == 0:\n        return a[p - 1]\n    if turn == 0:\n        return a[p - 1] + min(x)\n    else:\n        return a[p - 1] + max(x)\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    ans = dfs(1, -1, 0)\n    print(ans)", "T = int(input())\nimport sys\nsys.setrecursionlimit(10000000)\n\nclass Node:\n\n    def __init__(self, weight):\n        self.weight = int(weight)\n        self.cost = None\n        self.child = []\n        self.level = None\n        self.choice = None\n\ndef setLevels(node, level=0):\n    node.level = level\n    for n in node.child:\n        setLevels(n, level + 1)\n\ndef setCost(node, cost=0):\n    node.cost = cost + node.weight\n    for n in node.child:\n        setCost(n, node.cost)\n\ndef findChoice(node):\n    if not node.child:\n        node.choice = node.cost\n        return node.choice\n    options = [findChoice(n) for n in node.child]\n    if node.level % 2:\n        node.choice = max(options)\n    else:\n        node.choice = min(options)\n    return node.choice\nfor _ in range(T):\n    (n, k) = list(map(int, input().split(' ')))\n    weights = list(map(Node, input().split(' ')))\n    for x in range(n - 1):\n        (a, b) = sorted([x - 1 for x in map(int, input().split(' '))])\n        weights[a].child.append(weights[b])\n    setLevels(weights[0])\n    setCost(weights[0])\n    findChoice(weights[0])\n    print(weights[0].choice)"]