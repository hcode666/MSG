["MOD = 10 ** 9 + 7\nMAXN = 3 * 10 ** 5\n\ndef modpow(base, exp, mod):\n    result = 1\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef modinv(base, mod):\n    return modpow(base, mod - 2, mod)\nFACT = [1] * (MAXN + 1)\nFACTINV = [1] * (MAXN + 1)\nPOW2 = [1] * (MAXN + 1)\nPOW2_1INV = [1] * (MAXN + 1)\nfor n in range(1, MAXN + 1):\n    FACT[n] = n * FACT[n - 1] % MOD\n    FACTINV[n] = modinv(FACT[n], MOD)\n    POW2[n] = 2 * POW2[n - 1] % MOD\n    POW2_1INV[n] = modinv(POW2[n] - 1, MOD)\n\ndef binomial(N, K):\n    return FACT[N] * FACTINV[K] * FACTINV[N - K]\n\ndef main(N):\n    expect = 0\n    for K in range(1, N + 1):\n        expect = (expect - (-1) ** K * binomial(N, K) * POW2[K] * POW2_1INV[K]) % MOD\n    return expect\nT = int(input().strip())\nfor _ in range(T):\n    N = int(input().strip())\n    print(main(N))", "MOD = 10 ** 9 + 7\nMAXN = 3 * 10 ** 5\n\ndef modpow(base, exp, mod):\n    result = 1\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef modinv(base, mod):\n    return modpow(base, mod - 2, mod)\nFACT = [1] * (MAXN + 1)\nFACTINV = [1] * (MAXN + 1)\nPOW2 = [1] * (MAXN + 1)\nPOW2_1INV = [1] * (MAXN + 1)\nfor n in range(1, MAXN + 1):\n    FACT[n] = n * FACT[n - 1] % MOD\n    FACTINV[n] = modinv(FACT[n], MOD)\n    POW2[n] = 2 * POW2[n - 1] % MOD\n    POW2_1INV[n] = modinv(POW2[n] - 1, MOD)\n\ndef binomial(N, K):\n    return FACT[N] * FACTINV[K] * FACTINV[N - K]\n\ndef main(N):\n    expect = 0\n    for K in range(1, N + 1):\n        expect = (expect - (-1) ** K * binomial(N, K) * POW2[K] * POW2_1INV[K]) % MOD\n    return expect\nT = int(input().strip())\nfor _ in range(T):\n    N = int(input().strip())\n    print(main(N))", "MOD = 10 ** 9 + 7\nMAXN = 3 * 10 ** 5\n\ndef modpow(base, exp, mod):\n    result = 1\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef modinv(base, mod):\n    return modpow(base, mod - 2, mod)\nFACT = [1] * (MAXN + 1)\nFACTINV = [1] * (MAXN + 1)\nPOW2 = [1] * (MAXN + 1)\nPOW2_1INV = [1] * (MAXN + 1)\nfor n in range(1, MAXN + 1):\n    FACT[n] = n * FACT[n - 1] % MOD\n    FACTINV[n] = modinv(FACT[n], MOD)\n    POW2[n] = 2 * POW2[n - 1] % MOD\n    POW2_1INV[n] = modinv(POW2[n] - 1, MOD)\n\ndef binomial(N, K):\n    return FACT[N] * FACTINV[K] * FACTINV[N - K]\n\ndef main(N):\n    expect = 0\n    for K in range(1, N + 1):\n        expect = (expect - (-1) ** K * binomial(N, K) * POW2[K] * POW2_1INV[K]) % MOD\n    return expect\nT = int(input().strip())\nfor _ in range(T):\n    N = int(input().strip())\n    print(main(N))"]