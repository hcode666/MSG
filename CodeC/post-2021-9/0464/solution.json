["from collections import defaultdict\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef cal(a):\n    res = 0\n    temp = 100001 ** 0.5\n    temp = int(temp) + 1\n    i = 2\n    while a > 1:\n        while a % i == 0:\n            res += i\n            a //= i\n        if i == 2:\n            i += 1\n        else:\n            i += 2\n        if i > temp and a > 1:\n            res += a\n            return res\n    return res\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (a, b) = map(int, input().split())\n        g = gcd(a, b)\n        if a == b:\n            print(0)\n        elif a == 1 or b == 1:\n            print(max(cal(a), cal(b)))\n        else:\n            print(cal(a // g) + cal(b // g))", "from collections import defaultdict\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef cal(a):\n    res = 0\n    temp = 100001 ** 0.5\n    temp = int(temp) + 1\n    i = 2\n    while a > 1:\n        while a % i == 0:\n            res += i\n            a //= i\n        if i == 2:\n            i += 1\n        else:\n            i += 2\n        if i > temp and a > 1:\n            res += a\n            return res\n    return res\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (a, b) = map(int, input().split())\n        g = gcd(a, b)\n        if a == b:\n            print(0)\n        elif a == 1 or b == 1:\n            print(max(cal(a), cal(b)))\n        else:\n            print(cal(a // g) + cal(b // g))", "def hel2(x, y):\n    if x == y:\n        return 0\n    l = []\n    for i in range(1, int(x ** 0.5) + 1):\n        if x % i == 0:\n            l.append(i)\n            l.append(x // i)\n            if i * i == x:\n                l.pop()\n    l.sort(reverse=True)\n    cnt = 0\n    prev = x\n    for i in range(1, len(l)):\n        if prev % l[i] == 0 and l[i] % y == 0:\n            cnt += prev // l[i]\n            prev = l[i]\n            if l[i] == y:\n                break\n    return cnt\n\ndef gcd(x, y):\n    if x % y == 0:\n        return y\n    return gcd(y, x % y)\n\ndef fun(n, u, v):\n    g = gcd(u, v)\n    res1 = hel2(u, g)\n    res2 = hel2(v, g)\n    res = res1 + res2\n    return res\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for _ in range(q):\n        (u, v) = map(int, input().split())\n        print(fun(n, u, v))", "def hel2(x, y):\n    if x == y:\n        return 0\n    l = []\n    for i in range(1, int(x ** 0.5) + 1):\n        if x % i == 0:\n            l.append(i)\n            l.append(x // i)\n            if i * i == x:\n                l.pop()\n    l.sort(reverse=True)\n    cnt = 0\n    prev = x\n    for i in range(1, len(l)):\n        if prev % l[i] == 0 and l[i] % y == 0:\n            cnt += prev // l[i]\n            prev = l[i]\n            if l[i] == y:\n                break\n    return cnt\n\ndef gcd(x, y):\n    if x % y == 0:\n        return y\n    return gcd(y, x % y)\n\ndef fun(n, u, v):\n    g = gcd(u, v)\n    res1 = hel2(u, g)\n    res2 = hel2(v, g)\n    res = res1 + res2\n    return res\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for _ in range(q):\n        (u, v) = map(int, input().split())\n        print(fun(n, u, v))", "from math import gcd\nt = int(input())\nfor k in range(t):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        u //= g\n        v //= g\n        ans = 0\n        for i in [u, v]:\n            while i % 2 == 0:\n                i = i // 2\n                ans += 2\n            for j in range(3, i + 1):\n                if j * j > i:\n                    break\n                while i % j == 0:\n                    i = i // j\n                    ans += j\n            if i > 1:\n                ans += i\n        print(ans)", "from math import gcd\nt = int(input())\nfor k in range(t):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        u //= g\n        v //= g\n        ans = 0\n        for i in [u, v]:\n            while i % 2 == 0:\n                i = i // 2\n                ans += 2\n            for j in range(3, i + 1):\n                if j * j > i:\n                    break\n                while i % j == 0:\n                    i = i // j\n                    ans += j\n            if i > 1:\n                ans += i\n        print(ans)", "from math import gcd\nt = int(input())\nfor k in range(t):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        u //= g\n        v //= g\n        ans = 0\n        for i in [u, v]:\n            while i % 2 == 0:\n                i = i // 2\n                ans += 2\n            for j in range(3, i + 1):\n                if j * j > i:\n                    break\n                while i % j == 0:\n                    i = i // j\n                    ans += j\n            if i > 2:\n                ans += i\n        print(ans)", "from math import gcd\nt = int(input())\nfor k in range(t):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        u //= g\n        v //= g\n        ans = 0\n        for i in [u, v]:\n            while i % 2 == 0:\n                i = i // 2\n                ans += 2\n            for j in range(3, i + 1):\n                if j * j > i:\n                    break\n                while i % j == 0:\n                    i = i // j\n                    ans += j\n            if i > 1:\n                ans += i\n        print(ans)", "def gcd(a, b):\n    c = a\n    a = max(a, b)\n    b = min(c, b)\n    while b != 0:\n        c = a % b\n        a = b\n        b = c\n    return a\n\ndef prime_sum(x):\n    if x == 1:\n        return 0\n    i = 2\n    s = 0\n    while i * i <= x:\n        while x % i == 0:\n            s += i\n            x //= i\n        i += 1\n    if x != 1:\n        s += x\n    return s\nfor t in range(int(input())):\n    (n, q) = map(int, input().split())\n    for e in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        (u, v) = (u // g, v // g)\n        print(prime_sum(u) + prime_sum(v))", "from collections import defaultdict\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef cal(a):\n    res = 0\n    temp = 100001 ** 0.5\n    temp = int(temp) + 1\n    i = 2\n    while a > 1:\n        while a % i == 0:\n            res += i\n            a //= i\n        if i == 2:\n            i += 1\n        else:\n            i += 2\n        if i > temp and a > 1:\n            res += a\n            return res\n    return res\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (a, b) = map(int, input().split())\n        g = gcd(a, b)\n        if a == b:\n            print(0)\n        elif a == 1 or b == 1:\n            print(max(cal(a), cal(b)))\n        else:\n            print(cal(a // g) + cal(b // g))", "import sys\nimport os\nimport math\nimport collections\n\ndef primeFactors(n):\n    result = []\n    while n % 2 == 0:\n        result.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            result.append(i)\n            n = n / i\n    if n > 2:\n        result.append(n)\n    result.sort()\n    return result\nT = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    for _ in range(M):\n        (P, Q) = map(int, input().split())\n        A = primeFactors(P)\n        B = primeFactors(Q)\n        C = collections.Counter(A)\n        D = collections.Counter(B)\n        C.subtract(D)\n        val = 0\n        for i in C.items():\n            val += int(i[0] * abs(i[1]))\n        print(val)", "import math\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    for j in range(m):\n        (u, v) = map(int, input().split())\n        fac = math.gcd(u, v)\n        x = u // fac\n        y = v // fac\n        ans = 0\n        for i in [x, y]:\n            j = 2\n            while j * j <= i:\n                while i % j == 0:\n                    ans += j\n                    i //= j\n                j += 1\n            if i > 1:\n                ans += i\n        print(ans)", "from math import gcd\nt = int(input())\nfor _ in range(t):\n    (vertices, queries) = map(int, input().split())\n    while queries > 0:\n        queries -= 1\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        u = u // g\n        v = v // g\n        i = 2\n        ans = 0\n        while i * i <= u:\n            while u % i == 0:\n                ans += i\n                u = u // i\n            i += 1\n        if u > 1:\n            ans += u\n        i = 2\n        while i * i <= v:\n            while v % i == 0:\n                ans += i\n                v = v // i\n            i += 1\n        if v > 1:\n            ans += v\n        print(ans)", "from math import gcd\n\ndef fun(i):\n    ans = 0\n    for j in range(2, i + 1):\n        if j * j > i:\n            break\n        while i % j == 0:\n            i = i // j\n            ans += j\n    if i > 1:\n        ans += i\n    return ans\nfor k in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        u //= g\n        v //= g\n        ans = fun(u) + fun(v)\n        print(ans)", "def gcd(a, b):\n    if a == 0:\n        return abs(b)\n    else:\n        return gcd(b % a, a)\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        u //= g\n        v //= g\n        res = 0\n        for x in [u, v]:\n            for i in range(2, x + 1):\n                if i * i > x:\n                    break\n                while x % i == 0:\n                    x //= i\n                    res += i\n            if x > 1:\n                res += x\n        print(res)", "import math\nl = []\nfor i in range(3, 100001, 2):\n    t = 1\n    for j in range(3, int(math.sqrt(i)) + 1, 2):\n        if i % j == 0:\n            t = 0\n            break\n    if t == 1:\n        l.append(i)\na = [0] * 100001\nfor i in range(2, 100001):\n    if i % 2 == 0:\n        a[i] = a[i // 2] + 2\n    j = 0\n    while l[j] <= math.sqrt(i) + 1:\n        if i % l[j] == 0:\n            a[i] = a[i // l[j]] + l[j]\n            break\n        j += 1\n    if a[i] == 0:\n        a[i] = i\nfor i in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        r = math.gcd(u, v)\n        print(a[u] + a[v] - 2 * a[r])", "from math import gcd\nt = int(input())\nfor k in range(t):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        u //= g\n        v //= g\n        ans = 0\n        for i in [u, v]:\n            for j in range(2, i + 1):\n                if j * j > i:\n                    break\n                while i % j == 0:\n                    i = i // j\n                    ans += j\n            if i > 1:\n                ans += i\n        print(ans)", "from math import gcd\nN = int(100000.0) + 69\ns = list(range(N + 1))\nfor i in range(2, int(N ** 0.5) + 1):\n    if s[i] == i:\n        for j in range(i * i, N, i):\n            if s[j] == j:\n                s[j] = i\n\ndef factors_sum(X):\n    res = 0\n    while X > 1:\n        res += s[X]\n        X //= s[X]\n    return res\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for _ in range(q):\n        (u, v) = map(int, input().split())\n        print(factors_sum(u // gcd(u, v)) + factors_sum(v // gcd(u, v)))", "import math\nT = int(input())\nfor t in range(T):\n    (n, q) = map(int, input().split())\n    s = [0 for i in range(n + 1)]\n\n    def sieve():\n        for i in range(1, n + 1):\n            if i % 2 == 1:\n                s[i] = i\n            else:\n                s[i] = 2\n        for i in range(3, math.ceil(math.sqrt(n + 1)), 2):\n            if s[i] == i:\n                for j in range(i * i, n + 1, i):\n                    if s[j] == j:\n                        s[j] = i\n\n    def getFactorization(x):\n        ret = []\n        while x != 1:\n            ret.append(s[x])\n            x = x // s[x]\n        return ret\n    sieve()\n\n    def dis(a, b):\n        if a >= b:\n            c = a // b\n        else:\n            c = b // a\n        l = getFactorization(c)\n        return sum(l)\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        if u == v:\n            print(0)\n        elif u % v == 0 or v % u == 0:\n            print(dis(u, v))\n        else:\n            c = math.gcd(u, v)\n            print(dis(u, c) + dis(v, c))", "def factors(n):\n    ans = 0\n    while n % 2 == 0:\n        ans += 2\n        n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            ans += i\n            n //= i\n    if n > 2:\n        ans += n\n    return ans\nfrom math import gcd\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        (u, v) = (u // g, v // g)\n        print(factors(u) + factors(v))", "from sys import stdin, stdout\nfrom collections import defaultdict, Counter, deque\nimport math, heapq, bisect\nimport math as mt\ninput = stdin.readline\n\ndef isPowerOfTwo(x):\n    return x and (not x & x - 1)\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\ndef gcd(a, b):\n    return math.gcd(a, b)\n\ndef gcd_list_of_elements(li):\n    n = len(li)\n    res = li[0]\n    for i in range(1, n):\n        res = math.gcd(res, li[i])\n    return res\n\ndef isPalindrome(x):\n    x = str(x)\n    return x == x[::-1]\nMAXN = 100001\nspf = [0 for i in range(MAXN)]\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = list()\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\n\ndef function(num, x):\n    cnt = 0\n    while num % x == 0:\n        cnt += 1\n        num //= x\n    return cnt * x\n\ndef get_cost(num):\n    if num == 1:\n        return 0\n    cost = 0\n    factors = set(getFactorization(num))\n    for factor in factors:\n        cost += function(num, factor)\n    return cost\nsieve()\nt = int(input().strip())\nfor _ in range(t):\n    (n, q) = list(map(int, input().strip().split()))\n    for _ in range(q):\n        (u, v) = list(map(int, input().strip().split()))\n        g = gcd(u, v)\n        ans = get_cost(u // g) + get_cost(v // g)\n        print(ans)", "def factors(n):\n    ans = 0\n    while n % 2 == 0:\n        ans += 2\n        n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            ans += i\n            n //= i\n    if n > 2:\n        ans += n\n    return ans\nfrom math import gcd\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        (u, v) = (u // g, v // g)\n        print(factors(u) + factors(v))", "def factors(n):\n    ans = 0\n    while n % 2 == 0:\n        ans += 2\n        n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            ans += i\n            n //= i\n    if n > 2:\n        ans += n\n    return ans\nfrom math import gcd\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        (u, v) = (u // g, v // g)\n        print(factors(u) + factors(v))", "def factors(n):\n    ans = 0\n    while n % 2 == 0:\n        ans += 2\n        n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            ans += i\n            n //= i\n    if n > 2:\n        ans += n\n    return ans\nfrom math import gcd\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        g = gcd(u, v)\n        (u, v) = (u // g, v // g)\n        print(factors(u) + factors(v))", "import math\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef fun(g, n):\n    ans = 0\n    n = n // g\n    if n == 1:\n        return 0\n    while n % 2 == 0:\n        ans += 2\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            ans += i\n            n = n // i\n    if n > 2:\n        ans += n\n    return ans\nfor t in range(int(input())):\n    (n, qu) = list((int(i) for i in input().split()))\n    for q in range(qu):\n        (u, v) = list((int(i) for i in input().split()))\n        g = gcd(u, v)\n        ans = fun(g, u) + fun(g, v)\n        print(ans)", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef find():\n    m1 = 100001\n    f1 = [0 for i in range(m1)]\n    f1[1] = 1\n    for i in range(2, m1):\n        f1[i] = i\n    for i in range(4, m1, 2):\n        f1[i] = 2\n    for i in range(3, 317):\n        if f1[i] == i:\n            for j in range(i * i, m1, i):\n                if f1[j] == j:\n                    f1[j] = i\n    return f1\nf1 = find()\n\ndef solve(a):\n    dic = defaultdict(lambda : 0)\n    while a != 1:\n        dic[f1[a]] += 1\n        a = a // f1[a]\n    return dic\nfor _ in range(int(input())):\n    (n, q) = list(map(int, input().split()))\n    (count1, count2) = ([], [])\n    for i in range(n):\n        count1.append(i)\n    for i in range(n):\n        count1.append(i)\n    for i in range(q):\n        (a, b) = list(map(int, input().split()))\n        a1 = solve(a)\n        b1 = solve(b)\n        ans = set(list(a1.keys()) + list(b1.keys()))\n        for i in ans:\n            temp = min(a1[i], b1[i])\n            a1[i] -= temp\n            b1[i] -= temp\n        res = 0\n        for i in ans:\n            res += i * (a1[i] + b1[i])\n        print(res)\n    for i in range(n):\n        count2.append(i)\n    for j in range(n):\n        count2.append(j)", "from math import ceil, sqrt\nfrom collections import defaultdict\n\ndef spffunc():\n    lim = 10 ** 5\n    s = [0] * lim\n    s[1] = 1\n    for i in range(2, lim):\n        s[i] = i\n    for i in range(4, lim, 2):\n        s[i] = 2\n    for i in range(3, ceil(sqrt(lim))):\n        if s[i] == i:\n            for l in range(i * i, lim, i):\n                if s[l] == l:\n                    s[l] = i\n    return s\nspf = spffunc()\n\ndef gpf(n):\n    gpfdict = defaultdict(int)\n    while n != 1:\n        gpfdict[spf[n]] += 1\n        n = n // spf[n]\n    return gpfdict\nfor _ in range(int(input())):\n    (a, b) = [int(i) for i in input().split()]\n    for i1 in range(b):\n        op = 0\n        (u, v) = [int(i) for i in input().split()]\n        u = gpf(u)\n        v = gpf(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i2 in x:\n            if u[i2] > v[i2]:\n                m = v[i2]\n            else:\n                m = u[i2]\n            u[i2] -= m\n            v[i2] -= m\n        for i3 in x:\n            op += i3 * (u[i3] + v[i3])\n        print(op)", "import math\nfrom collections import defaultdict\n\ndef check1():\n    maxi = 100001\n    df = [0] * maxi\n    df[1] = 1\n    for i in range(2, maxi):\n        df[i] = i\n    for i in range(4, maxi, 2):\n        df[i] = 2\n    for i in range(3, math.ceil(math.sqrt(maxi))):\n        if df[i] == i:\n            for j in range(i * i, maxi, i):\n                if df[j] == j:\n                    df[j] = i\n    return df\ndf = check1()\n\ndef check2(k):\n    m = defaultdict(lambda : 0)\n    while k != 1:\n        m[df[k]] += 1\n        k = k // df[k]\n    return m\nt = int(input())\nwhile t:\n    (s, g) = map(int, input().split())\n    for i in range(g):\n        (v, b) = list(map(int, input().split()))\n        v = check2(v)\n        b = check2(b)\n        d = set(list(v.keys()) + list(b.keys()))\n        for i in d:\n            h = min(v[i], b[i])\n            v[i] -= h\n            b[i] -= h\n        bhu = 0\n        for i in d:\n            bhu += i * (v[i] + b[i])\n        print(bhu)\n    t -= 1", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef j1():\n    j2 = 100001\n    j3 = [0 for i in range(j2)]\n    j3[1] = 1\n    for j4 in range(2, j2):\n        j3[j4] = j4\n    for j5 in range(4, j2, 2):\n        j3[j5] = 2\n    for j6 in range(3, math.ceil(math.sqrt(j2))):\n        if j3[j6] == j6:\n            for j in range(j6 * j6, j2, j6):\n                if j3[j] == j:\n                    j3[j] = j6\n    return j3\nj3 = j1()\n\ndef j7(x):\n    j8 = defaultdict(lambda : 0)\n    while x != 1:\n        j8[j3[x]] += 1\n        x = x // j3[x]\n    return j8\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (j9, j10) = list(map(int, input().split()))\n        j9 = j7(j9)\n        j10 = j7(j10)\n        x = set(list(j9.keys()) + list(j10.keys()))\n        for i in x:\n            y = min(j9[i], j10[i])\n            j9[i] -= y\n            j10[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (j9[i] + j10[i])\n        print(ans)\nj11 = 1\nj11 = int(input())\nfor _ in range(j11):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\n\ndef myprime():\n    MAXN = 100001\n    prime = [0 for i in range(MAXN)]\n    prime[1] = 1\n    for i in range(2, MAXN):\n        prime[i] = i\n    for i in range(4, MAXN, 2):\n        prime[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if prime[i] == i:\n            for j in range(i * i, MAXN, i):\n                if prime[j] == j:\n                    prime[j] = i\n    return prime\nprime = myprime()\n\ndef getPrimefactor(x):\n    rr = defaultdict(lambda : 0)\n    while x != 1:\n        rr[prime[x]] += 1\n        x = x // prime[x]\n    return rr\n\ndef solve():\n    (n, q) = list(map(int, sys.stdin.readline().split()))\n    for i in range(q):\n        (u, v) = list(map(int, sys.stdin.readline().split()))\n        u = getPrimefactor(u)\n        v = getPrimefactor(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            temp = min(u[i], v[i])\n            u[i] -= temp\n            v[i] -= temp\n        finalans = 0\n        for i in x:\n            finalans += i * (u[i] + v[i])\n        print(finalans)\nt = 1\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef getPrimeFactorizationLOGN(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPrimeFactorizationLOGN(u)\n        v = getPrimeFactorizationLOGN(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport bisect, string, math, time, functools, random, fractions\nfrom bisect import *\nfrom heapq import heappush, heappop, heapify\nfrom queue import PriorityQueue\nfrom collections import deque, defaultdict, Counter\nfrom itertools import permutations, combinations, groupby\nimport random\nimport queue\n\ndef smallestfactor():\n    mx = 100001\n    sm = [0 for i in range(mx)]\n    sm[1] = 1\n    for i in range(2, mx):\n        sm[i] = i\n    for i in range(4, mx, 2):\n        sm[i] = 2\n    for i in range(3, math.ceil(math.sqrt(mx))):\n        if sm[i] == i:\n            for j in range(i * i, mx, i):\n                if sm[j] == j:\n                    sm[j] = i\n    return sm\nsm = smallestfactor()\n\ndef solve(x):\n    res = defaultdict(lambda : 0)\n    while x != 1:\n        res[sm[x]] += 1\n        x = x // sm[x]\n    return res\nt = int(input())\nwhile t:\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        u = solve(u)\n        v = solve(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        res = 0\n        for i in x:\n            res += (u[i] + v[i]) * i\n        print(res)\n    t -= 1", "import math\nfrom collections import defaultdict\n\ndef function1():\n    maximum_of_all = 1000001\n    temp = [0 for j in range(maximum_of_all)]\n    temp[1] = 1000001\n    for j in range(2, maximum_of_all):\n        temp[j] = j\n    for j in range(4, maximum_of_all, 2):\n        temp[j] = 2\n    for j in range(3, math.ceil(math.sqrt(maximum_of_all))):\n        if temp[j] == j:\n            for i in range(j * j, maximum_of_all, j):\n                if temp[i] == i:\n                    temp[i] = j\n    return temp\ntemp = function1()\n\ndef function2(var):\n    result = defaultdict(lambda : 0)\n    while var != 1:\n        result[temp[var]] += 1\n        var = var // temp[var]\n    return result\n\ndef pushkar():\n    (num, qry) = list(map(int, input().split()))\n    for j in range(qry):\n        (m, n) = list(map(int, input().split()))\n        m = function2(m)\n        n = function2(n)\n        raj = set(list(m.keys()) + list(n.keys()))\n        for i in raj:\n            k = min(m[i], n[i])\n            m[i] -= k\n            n[i] -= k\n        answer = 0\n        for j in raj:\n            answer += j * (m[j] + n[j])\n        print(answer)\ntc = 1\ntc = int(input())\nfor j in range(tc):\n    pushkar()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieve():\n    m1 = 100001\n    spf = [0 for i in range(m1)]\n    spf[1] = 1\n    for i in range(2, m1):\n        spf[i] = i\n    for i in range(4, m1, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(m1))):\n        if spf[i] == i:\n            for j in range(i * i, m1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieve()\n\ndef getp(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getp(u)\n        v = getp(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import math\nfrom collections import defaultdict\nmylimit = 100009\n\ndef AnotherHelpingFunction():\n    finalVariable = [0 for i in range(mylimit)]\n    finalVariable[1] = 1\n    for i in range(2, mylimit):\n        finalVariable[i] = i\n    for i in range(4, mylimit, 2):\n        finalVariable[i] = 2\n    for i in range(3, math.ceil(math.sqrt(mylimit))):\n        if finalVariable[i] == i:\n            for j in range(i * i, mylimit, i):\n                if finalVariable[j] == j:\n                    finalVariable[j] = i\n    return finalVariable\ngettingValue = AnotherHelpingFunction()\n\ndef FindTrueValue(asish):\n    ReturnedVal = defaultdict(int)\n    while asish != 1:\n        ReturnedVal[gettingValue[asish]] += 1\n        asish //= gettingValue[asish]\n    return ReturnedVal\ntrials = int(input())\nwhile trials:\n    trials -= 1\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (presence, haveToGo) = list(map(int, input().split()))\n        haveToGo = FindTrueValue(haveToGo)\n        presence = FindTrueValue(presence)\n        GettingAllElementInSet = set([*presence.keys(), *haveToGo.keys()])\n        for i in GettingAllElementInSet:\n            FindingSecondValue = min(presence[i], haveToGo[i])\n            presence[i] -= FindingSecondValue\n            haveToGo[i] -= FindingSecondValue\n        FinalAns = 0\n        for i in GettingAllElementInSet:\n            FinalAns += i * (presence[i] + haveToGo[i])\n        print(FinalAns)", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef getPrimeFactorizationLOGN(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPrimeFactorizationLOGN(u)\n        v = getPrimeFactorizationLOGN(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\n\ndef sieve():\n    MAXN = 100000\n    spfst = [0 for i in range(MAXN)]\n    spfst[1] = 100000\n    for i in range(2, MAXN):\n        spfst[i] = i\n    for i in range(4, MAXN, 2):\n        spfst[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spfst[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spfst[j] == j:\n                    spfst[j] = i\n    return spfst\nspfst = sieve()\n\ndef prime(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spfst[x]] += 1\n        x = x // spfst[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = prime(u)\n        v = prime(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        result = 0\n        for i in x:\n            result += i * (u[i] + v[i])\n        print(result)\ntest = 1\ntest = int(input())\nfor _ in range(test):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sSP():\n    MN = 100001\n    spf = [0 for i in range(MN)]\n    spf[1] = 1\n    for i in range(2, MN):\n        spf[i] = i\n    for i in range(4, MN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MN))):\n        if spf[i] == i:\n            for j in range(i * i, MN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nsf = sSP()\n\ndef pf(i):\n    ref = defaultdict(lambda : 0)\n    while i != 1:\n        ref[sf[i]] += 1\n        i = i // sf[i]\n    return ref\nt = 1\nt = int(input())\nfor _ in range(t):\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = pf(u)\n        v = pf(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            z = min(u[i], v[i])\n            u[i] -= z\n            v[i] -= z\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)", "from collections import defaultdict\nimport math\nimport sys\n\ndef primeFact(x):\n    check = 0\n    flag = True\n    Bool = 1\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        check += 2\n        x = x // spf[x]\n    Bool = 0\n    return ret\n\ndef sieve():\n    Bool = True\n    maximize = 100001\n    maxN = 100001\n    spf = [0 for i in range(maxN)]\n    spf[1] = 1\n    pick = 3\n    for i in range(2, maxN):\n        maximize -= 1\n        spf[i] = i\n        pick += 3\n    for i in range(4, maxN, 2):\n        spf[i] = 2\n        maximize -= 1\n    for i in range(3, math.ceil(math.sqrt(maxN))):\n        if spf[i] == i:\n            Bool = False\n            for j in range(i * i, maxN, i):\n                maximize -= 1\n                if spf[j] == j:\n                    Bool = True\n                    pick += 1\n                    spf[j] = i\n    pick += maximize\n    Bool = False\n    return spf\nspf = sieve()\nchecker = 100001\nT = int(input())\nfor _ in range(T):\n    (N, Q) = map(int, input().split())\n    sums = 0\n    for z in range(Q):\n        (u, v) = map(int, input().split())\n        v = primeFact(v)\n        u = primeFact(u)\n        sums = 1\n        cnt = 0\n        x = set(list(u.keys()) + list(v.keys()))\n        values = '12345'\n        marker = 1\n        for i in x:\n            marker += 1\n            y = min(u[i], v[i])\n            sums += 1\n            cnt += marker + sums\n            v[i] -= y\n            u[i] -= y\n        ans = 0\n        for i in x:\n            sums += 9\n            ans += i * (u[i] + v[i])\n        print(str(ans))", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForPF():\n    MAX = 100001\n    spf = [0 for i in range(MAX)]\n    spf[1] = 1\n    for i in range(2, MAX):\n        spf[i] = i\n    for i in range(4, MAX, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAX))):\n        if spf[i] == i:\n            for j in range(i * i, MAX, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForPF()\n\ndef getPF(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPF(u)\n        v = getPF(v)\n        X = set(list(u.keys()) + list(v.keys()))\n        for i in X:\n            yy = min(u[i], v[i])\n            u[i] -= yy\n            v[i] -= yy\n        ans = 0\n        for i in X:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\nS = sys.stdin.readline\n\ndef helper():\n    M = 100001\n    spf = [0] * M\n    spf[1] = 1\n    for i in range(2, M):\n        spf[i] = i\n    for i in range(4, M, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(M))):\n        if spf[i] == i:\n            for j in range(i ** 2, M, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = helper()\n\ndef helper1(x):\n    r = defaultdict(lambda : 0)\n    while x != 1:\n        r[spf[x]] += 1\n        x = x // spf[x]\n    return r\ntest = int(input())\nwhile test:\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        u = helper1(u)\n        v = helper1(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        out = 0\n        for i in x:\n            out += i * (u[i] + v[i])\n        print(out)\n    test -= 1", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sfun1():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sfun1()\n\ndef fun2(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = fun2(u)\n        v = fun2(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef getPrimeFactorizationLOGN(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPrimeFactorizationLOGN(u)\n        v = getPrimeFactorizationLOGN(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef getPrimeFactorizationLoGN(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPrimeFactorizationLoGN(u)\n        v = getPrimeFactorizationLoGN(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef getPrimeFactorizationLOGN(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPrimeFactorizationLOGN(u)\n        v = getPrimeFactorizationLOGN(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import math\nt = int(input())\nfrom collections import Counter\nimport math as mt\nMAXN = 100001\nspf = [0 for i in range(MAXN)]\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\nsieve()\n\ndef getFactorization(x):\n    ret = list()\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\nfor _ in range(t):\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (x, y) = list(map(int, input().split()))\n        ans = 0\n        if y > x:\n            (x, y) = (y, x)\n        if x == y:\n            print(0)\n            continue\n        else:\n            g = mt.gcd(x, y)\n            a = x // g\n            count = getFactorization(a)\n            c = Counter(count)\n            for (key, value) in c.items():\n                ans += key * value\n            b = y // g\n            count = getFactorization(b)\n            d = Counter(count)\n            for (key, value) in d.items():\n                ans += key * value\n            print(ans)", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sfspf():\n    maxm = 100001\n    main_data_for_the_result = [0 for i in range(maxm)]\n    main_data_for_the_result[1] = 1\n    for i in range(2, maxm):\n        main_data_for_the_result[i] = i\n    for i in range(4, maxm, 2):\n        main_data_for_the_result[i] = 2\n    for i in range(3, math.ceil(math.sqrt(maxm))):\n        if main_data_for_the_result[i] == i:\n            for j in range(i * i, maxm, i):\n                if main_data_for_the_result[j] == j:\n                    main_data_for_the_result[j] = i\n    return main_data_for_the_result\nmain_data_for_the_result = sfspf()\n\ndef gettheprimefectrozationofthenumber(x):\n    res = defaultdict(lambda : 0)\n    while x != 1:\n        res[main_data_for_the_result[x]] += 1\n        x = x // main_data_for_the_result[x]\n    return res\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = gettheprimefectrozationofthenumber(u)\n        v = gettheprimefectrozationofthenumber(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import math\nt = int(input())\nfrom collections import Counter\nimport math as mt\nMAXN = 100001\nspf = [0 for i in range(MAXN)]\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\nsieve()\n\ndef getFactorization(x):\n    ret = list()\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\nfor _ in range(t):\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (x, y) = list(map(int, input().split()))\n        ans = 0\n        if y > x:\n            (x, y) = (y, x)\n        if x == y:\n            print(0)\n            continue\n        else:\n            g = mt.gcd(x, y)\n            a = x // g\n            count = getFactorization(a)\n            c = Counter(count)\n            for (key, value) in c.items():\n                ans += key * value\n            b = y // g\n            count = getFactorization(b)\n            d = Counter(count)\n            for (key, value) in d.items():\n                ans += key * value\n            print(ans)", "import sys\nimport math as mt\nfrom collections import defaultdict\ninput = sys.stdin.readline\nMAXN = 100001\nspf = [0 for i in range(MAXN)]\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\nsieve()\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getFactorization(u)\n        v = getFactorization(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef shubham():\n    maxValue = 100001\n    arr = [0 for i in range(maxValue)]\n    arr[1] = 1\n    for i in range(2, maxValue):\n        arr[i] = i\n    for i in range(4, maxValue, 2):\n        arr[i] = 2\n    for i in range(3, math.ceil(math.sqrt(maxValue))):\n        if arr[i] == i:\n            for j in range(i * i, maxValue, i):\n                if arr[j] == j:\n                    arr[j] = i\n    return arr\narr = shubham()\n\ndef bansal(temp):\n    x = defaultdict(lambda : 0)\n    while temp != 1:\n        x[arr[temp]] += 1\n        temp = temp // arr[temp]\n    return x\n\ndef google():\n    (N, Q) = list(map(int, input().split()))\n    for i in range(Q):\n        (u, v) = list(map(int, input().split()))\n        u = bansal(u)\n        v = bansal(v)\n        z = set(list(u.keys()) + list(v.keys()))\n        for i in z:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in z:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    google()", "import math\nt = int(input())\nfor T in range(t):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (a, b) = map(int, input().split())\n        g = math.gcd(a, b)\n        a = a // g\n        b = b // g\n        ans = 0\n        while a % 2 == 0:\n            ans += 2\n            a //= 2\n        while b % 2 == 0:\n            ans += 2\n            b //= 2\n        j = 3\n        while a > 1 and j <= math.sqrt(a):\n            while a % j == 0:\n                ans += j\n                a //= j\n            j += 2\n        j = 3\n        while b > 1 and j <= math.sqrt(b):\n            while b % j == 0:\n                ans += j\n                b //= j\n            j += 2\n        if a > 1:\n            ans += a\n            a = 1\n        if b > 1:\n            ans += b\n            b = 1\n        print(ans)", "from ctypes import cdll\nfrom email.policy import default\nfrom operator import itemgetter\nfrom sys import maxsize, stdin\nfrom collections import Counter, defaultdict\nimport numpy as np\nfrom math import ceil, sqrt\n\ndef soe() -> list:\n    maximum = 100001\n    temp2 = list((0 for i in range(maximum)))\n    temp2[1] = 1\n    for i in range(2, maximum):\n        temp2[i] = i\n    for i in range(4, maximum, 2):\n        temp2[i] = 2\n    for i in range(3, ceil(sqrt(maximum))):\n        if temp2[i] == i:\n            for j in range(i * i, maximum, i):\n                if temp2[j] == j:\n                    temp2[j] = i\n    return temp2\ntemp2 = soe()\n\ndef pf(val: int) -> defaultdict:\n    temp = defaultdict(lambda : 0)\n    while val != 1:\n        temp[temp2[val]] += 1\n        val //= temp2[val]\n    return temp\nt = int(stdin.readline().strip())\nwhile t > 0:\n    (n, q) = map(int, stdin.readline().strip().split(' '))\n    for i in range(q):\n        (u, v) = map(int, stdin.readline().strip().split(' '))\n        u = pf(val=u)\n        v = pf(val=v)\n        res1 = u.keys()\n        res2 = v.keys()\n        res1 = list(res1)\n        res2 = list(res2)\n        check = set(res1 + res2)\n        for i in check:\n            m = min(u[i], v[i])\n            u[i] -= m\n            v[i] -= m\n        ans = 0\n        for i in check:\n            ans += i * (u[i] + v[i])\n        print(ans)\n    t -= 1", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef get_prime_numbers_quickly():\n    MAX_INT_VALUE = 100001\n    get_prime_in_constant = [0 for index_value in range(MAX_INT_VALUE)]\n    get_prime_in_constant[1] = 1\n    for index_value in range(2, MAX_INT_VALUE):\n        get_prime_in_constant[index_value] = index_value\n    for index_value in range(4, MAX_INT_VALUE, 2):\n        get_prime_in_constant[index_value] = 2\n    for index_value in range(3, math.ceil(math.sqrt(MAX_INT_VALUE))):\n        if get_prime_in_constant[index_value] == index_value:\n            for j in range(index_value * index_value, MAX_INT_VALUE, index_value):\n                if get_prime_in_constant[j] == j:\n                    get_prime_in_constant[j] = index_value\n    return get_prime_in_constant\nget_prime_in_constant = get_prime_numbers_quickly()\n\ndef primeFactorsFunction(input_number):\n    list_of_prime_factors = defaultdict(lambda : 0)\n    while input_number != 1:\n        list_of_prime_factors[get_prime_in_constant[input_number]] += 1\n        input_number = input_number // get_prime_in_constant[input_number]\n    return list_of_prime_factors\n\ndef answer_finding_method():\n    (n, q) = list(map(int, input().split()))\n    for index_value in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = primeFactorsFunction(u)\n        v = primeFactorsFunction(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for index_value in x:\n            y = min(u[index_value], v[index_value])\n            u[index_value] = u[index_value] - y\n            v[index_value] = v[index_value] - y\n        answer = 0\n        for index_value in x:\n            answer += index_value * (u[index_value] + v[index_value])\n        print(answer)\ntestcases_for_given_problem = 1\ntestcases_for_given_problem = int(input())\nwhile testcases_for_given_problem:\n    testcases_for_given_problem -= 1\n    answer_finding_method()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef getPrimeFactorizationLOGN(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPrimeFactorizationLOGN(u)\n        v = getPrimeFactorizationLOGN(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef getPrimeFactorizationLOGN(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPrimeFactorizationLOGN(u)\n        v = getPrimeFactorizationLOGN(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    primes = []\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for i in range(2, n + 1):\n        if prime[i] == True:\n            primes.append(i)\n    return (primes, prime)\n\ndef primeFactors(n, current, prim, bools):\n    ans = 0\n    k = n\n    c = 0\n    while n > 1 and current[n] == 0:\n        if bools[n]:\n            ans += n\n            n = 1\n        if n % prim[c] == 0:\n            ans += prim[c]\n            n = n // prim[c]\n        else:\n            c = c + 1\n    current[k] = ans + current[n]\nimport math\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    current = [0 for i in range(n + 1)]\n    (prims, bools) = SieveOfEratosthenes(n)\n    for i in range(2, n + 1):\n        primeFactors(i, current, prims, bools)\n    for i in range(q):\n        (a, b) = map(int, input().split())\n        x = math.gcd(a, b)\n        if x == a and x == b:\n            print(0)\n        elif x == a:\n            print(current[b // x])\n        elif x == b:\n            print(current[a // x])\n        else:\n            print(current[a // x] + current[b // x])", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForSmallestPrimeFactor():\n    M = 109001\n    spf = [0 for i in range(M)]\n    spf[1] = 1\n    for i in range(2, M):\n        spf[i] = i\n    for i in range(4, M, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(M))):\n        if spf[i] == i:\n            for j in range(i * i, M, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef LOGN(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = LOGN(u)\n        v = LOGN(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for k in x:\n            y = min(u[k], v[k])\n            u[k] -= y\n            v[k] -= y\n        ans = 0\n        for j in x:\n            ans += j * (u[j] + v[j])\n        print(ans)\nw = 1\nw = int(input())\nfor _ in range(w):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef getPrimeFactorizationLOGN(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPrimeFactorizationLOGN(u)\n        v = getPrimeFactorizationLOGN(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import math\nprimes = []\nlcd = {}\nRange = 200001\nisPrime = [True for x in range(Range)]\ntemp = 2\nfor i in range(temp):\n    isPrime[i] = False\nfor i in range(2, int(math.sqrt(Range))):\n    if isPrime[i]:\n        for j in range(i * i, Range, i):\n            isPrime[j] = False\n            if j not in lcd:\n                lcd[j] = i\nfor i in range(Range):\n    if isPrime[i]:\n        primes.append(i)\n\ndef primeSum(n):\n    if n <= 1:\n        return 0\n    ans = 0\n    while n in lcd:\n        ans += lcd[n]\n        n //= lcd[n]\n    return ans + n\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, q) = [int(x) for x in input().split()]\n    for i in range(q):\n        (u, v) = [int(x) for x in input().split()]\n        gcd = math.gcd(u, v)\n        ans = primeSum(u // gcd) + primeSum(v // gcd)\n        print(ans)", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef fun():\n    P = 100001\n    pp = [0 for ps in range(P)]\n    pp[1] = 1\n    for ps in range(2, P):\n        pp[ps] = ps\n    for ps in range(4, P, 2):\n        pp[ps] = 2\n    for ps in range(3, math.ceil(math.sqrt(P))):\n        if pp[ps] == ps:\n            for j in range(ps * ps, P, ps):\n                if pp[j] == j:\n                    pp[j] = ps\n    return pp\npp = fun()\n\ndef myFunc2(xs):\n    res = defaultdict(lambda : 0)\n    while xs != 1:\n        res[pp[xs]] += 1\n        xs = xs // pp[xs]\n    return res\n\ndef myFunc():\n    (ns, qs) = list(map(int, input().split()))\n    for ps in range(qs):\n        (us, vs) = list(map(int, input().split()))\n        us = myFunc2(us)\n        vs = myFunc2(vs)\n        xs = set(list(us.keys()) + list(vs.keys()))\n        for ps in xs:\n            ys = min(us[ps], vs[ps])\n            us[ps] -= ys\n            vs[ps] -= ys\n        ans = 0\n        for ps in xs:\n            ans += ps * (us[ps] + vs[ps])\n        print(ans)\n\ndef main():\n    ts = 1\n    ts = int(input())\n    for _ in range(ts):\n        myFunc()\nmain()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 109001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef getPrimeFactorizationLOGN(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPrimeFactorizationLOGN(u)\n        v = getPrimeFactorizationLOGN(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import math\nfrom collections import defaultdict\nLIMITN = 100007\n\ndef sieve():\n    spf = [0 for i in range(LIMITN)]\n    spf[1] = 1\n    for i in range(2, LIMITN):\n        spf[i] = i\n    for i in range(4, LIMITN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(LIMITN))):\n        if spf[i] == i:\n            for j in range(i * i, LIMITN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nsf = sieve()\n\ndef get(xxx):\n    d = defaultdict(int)\n    while xxx != 1:\n        d[sf[xxx]] += 1\n        xxx //= sf[xxx]\n    return d\nt = int(input())\nwhile t:\n    t -= 1\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (src, dest) = list(map(int, input().split()))\n        src = get(src)\n        dest = get(dest)\n        xxx = set([*src.keys(), *dest.keys()])\n        for i in xxx:\n            yyy = min(src[i], dest[i])\n            src[i] -= yyy\n            dest[i] -= yyy\n        res = 0\n        for i in xxx:\n            res += i * (src[i] + dest[i])\n        print(res)", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sievef():\n    MAXN = 100001\n    num = 1234\n    reversed_num = 0\n    while num != 0:\n        digit = num % 10\n        reversed_num = reversed_num * 10 + digit\n        num //= 10\n    num = 1234\n    reversed_num = 0\n    while num != 0:\n        digit = num % 10\n        reversed_num = reversed_num * 10 + digit\n        num //= 10\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    num = 1234\n    reversed_num = 0\n    while num != 0:\n        digit = num % 10\n        reversed_num = reversed_num * 10 + digit\n        num //= 10\n    for i in range(2, MAXN):\n        spf[i] = i\n        num = 1234\n    reversed_num = 0\n    while num != 0:\n        digit = num % 10\n        reversed_num = reversed_num * 10 + digit\n        num //= 10\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n        num = 1234\n    reversed_num = 0\n    while num != 0:\n        digit = num % 10\n        reversed_num = reversed_num * 10 + digit\n        num //= 10\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sievef()\n\ndef getp(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    num = 1234\n    reversed_num = 0\n    while num != 0:\n        digit = num % 10\n        reversed_num = reversed_num * 10 + digit\n        num //= 10\n    num = 1234\n    reversed_num = 0\n    while num != 0:\n        digit = num % 10\n        reversed_num = reversed_num * 10 + digit\n        num //= 10\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getp(u)\n        v = getp(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys, math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef pp(c):\n    f = defaultdict(lambda : 0)\n    while c != 1:\n        f[p[c]] = f[p[c]] + 1\n        c = c // p[c]\n    return f\n\ndef s1():\n    m = 100001\n    p = [0 for i in range(m)]\n    p[1] = 1\n    for i in range(2, m):\n        p[i] = i\n    for i in range(4, m, 2):\n        p[i] = 2\n    for i in range(3, math.ceil(math.sqrt(m))):\n        if p[i] == i:\n            for k in range(i * i, m, i):\n                if p[k] == k:\n                    p[k] = i\n    return p\np = s1()\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        v = pp(v)\n        u = pp(u)\n        y = set(list(u.keys()) + list(v.keys()))\n        for i in y:\n            if u[i] < v[i]:\n                x = u[i]\n            else:\n                x = v[i]\n            v[i] -= x\n            u[i] -= x\n        ans = 0\n        for i in y:\n            ans += i * (u[i] + v[i])\n        print(ans)\ntest = 1\ntest = int(input())\nfor _ in range(test):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef getPrimeFactorizationLogn(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\nt = int(input())\nwhile t > 0:\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPrimeFactorizationLogn(u)\n        v = getPrimeFactorizationLogn(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        res = 0\n        for i in x:\n            res += i * (u[i] + v[i])\n        print(res)\n    t -= 1", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef primefactor():\n    max_n = 100001\n    pf = [0 for j in range(max_n)]\n    pf[1] = 1\n    for i in range(2, max_n):\n        pf[i] = i\n    for i in range(4, max_n, 2):\n        pf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(max_n))):\n        if pf[i] == i:\n            for k in range(i * i, max_n, i):\n                if pf[k] == k:\n                    pf[k] = i\n    return pf\npf = primefactor()\n\ndef fact(a):\n    res = defaultdict(lambda : 0)\n    while a != 1:\n        res[pf[a]] += 1\n        a = a // pf[a]\n    return res\n\ndef fin():\n    (n, q) = list(map(int, input().split(' ')))\n    for i in range(q):\n        (u, v) = list(map(int, input().split(' ')))\n        u = fact(u)\n        v = fact(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = int(input())\nfor _ in range(t):\n    fin()", "from math import floor\nmxV = 10 ** 5 + 1\nmxP = floor(mxV ** 0.5) + 3\np_factors = [[] for i in range(mxV)]\n\ndef pre_compute():\n    for i in range(2, mxP):\n        if len(p_factors[i]) > 0:\n            continue\n        for j in range(i, mxV, i):\n            p_factors[j].append([i, 0])\n    for i in range(2, mxV):\n        v = i\n        for pf in p_factors[i]:\n            p = pf[0]\n            count = 0\n            while v % p == 0:\n                count += 1\n                v //= p\n            pf[1] = count\n        if v > 1:\n            p_factors[i].append([v, 1])\npre_compute()\nfor t in range(int(input())):\n    (n, q) = tuple(map(int, input().strip().split()))\n    for x in range(q):\n        (u, v) = tuple(map(int, input().strip().split()))\n        ans = 0\n        u_pf = p_factors[u]\n        v_pf = p_factors[v]\n        (i, u_size) = (0, len(u_pf))\n        (j, v_size) = (0, len(v_pf))\n        while i < u_size and j < v_size:\n            (pu, pv) = (u_pf[i][0], v_pf[j][0])\n            (puc, pvc) = (u_pf[i][1], v_pf[j][1])\n            if pu == pv:\n                ans += pu * abs(puc - pvc)\n                i += 1\n                j += 1\n            elif pu < pv:\n                ans += pu * puc\n                i += 1\n            else:\n                ans += pv * pvc\n                j += 1\n        while i < u_size:\n            ans += u_pf[i][0] * u_pf[i][1]\n            i += 1\n        while j < v_size:\n            ans += v_pf[j][0] * v_pf[j][1]\n            j += 1\n        print(ans)", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sfspf():\n    MAXN = 100001\n    sp = [0 for i in range(MAXN)]\n    sp[1] = 1\n    for i in range(2, MAXN):\n        sp[i] = i\n    for i in range(4, MAXN, 2):\n        sp[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if sp[i] == i:\n            for j in range(i * i, MAXN, i):\n                if sp[j] == j:\n                    sp[j] = i\n    return sp\nsp = sfspf()\n\ndef gpfl(x):\n    re = defaultdict(lambda : 0)\n    while x != 1:\n        re[sp[x]] += 1\n        x = x // sp[x]\n    return re\n\ndef sol():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = gpfl(u)\n        v = gpfl(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        an = 0\n        for i in x:\n            an += i * (u[i] + v[i])\n        print(an)\nfor _ in range(int(input())):\n    sol()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef s1():\n    MAX = 100001\n    s = [0 for i in range(MAX)]\n    s[1] = 1\n    for i in range(2, MAX):\n        s[i] = i\n    for i in range(4, MAX, 2):\n        s[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAX))):\n        if s[i] == i:\n            for j in range(i * i, MAX, i):\n                if s[j] == j:\n                    s[j] = i\n    return s\ns = s1()\n\ndef gp(n):\n    res = defaultdict(lambda : 0)\n    while n != 1:\n        res[s[n]] += 1\n        n = n // s[n]\n    return res\n\ndef solve():\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = gp(u)\n        v = gp(v)\n        ans = set(list(u.keys()) + list(v.keys()))\n        for i in ans:\n            m = min(u[i], v[i])\n            u[i] -= m\n            v[i] -= m\n        a = 0\n        for i in ans:\n            a += i * (u[i] + v[i])\n        print(a)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef seivep():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = seivep()\n\ndef getp(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getp(u)\n        v = getp(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import math as mm\nimport sys as ss\nfrom collections import defaultdict as dd\n\ndef help1():\n    MN = 100001\n    res = [0 for i in range(MN)]\n    res[1] = 1\n    for _ in range(2, MN):\n        res[_] = _\n    for j in range(4, MN, 2):\n        res[j] = 2\n    for i in range(3, mm.ceil(mm.sqrt(MN))):\n        if res[i] == i:\n            for k in range(i * i, MN, i):\n                if res[k] == k:\n                    res[k] = i\n    return res\nres = help1()\n\ndef help2(a):\n    ans = dd(lambda : 0)\n    while a != 1:\n        ans[res[a]] += 1\n        a = a // res[a]\n    return ans\ninput = ss.stdin.readline\n\ndef solve_this_case():\n    (n, x) = map(int, input().split())\n    for z in range(1, x + 1):\n        (a, b) = map(int, input().split())\n        b = help2(b)\n        a = help2(a)\n        q = set(list(a.keys()) + list(b.keys()))\n        for j in q:\n            y = min(a[j], b[j])\n            a[j] = a[j] - y\n            b[j] = b[j] - y\n        res = 0\n        for k in q:\n            res += k * (a[k] + b[k])\n        print(res)\n\ndef main():\n    t = int(input())\n    for __ in range(t):\n        solve_this_case()\nmain()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef smalprime():\n    MAXX = 100001\n    spf = [0 for i in range(MAXX)]\n    spf[1] = 1\n    for i in range(2, MAXX):\n        spf[i] = i\n    for i in range(4, MAXX, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXX))):\n        if spf[i] == i:\n            for j in range(i * i, MAXX, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = smalprime()\n\ndef getprimefac(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getprimefac(u)\n        v = getprimefac(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef SmallestFac():\n    MAXN = 100001\n    var = [0 for i in range(MAXN)]\n    var[1] = 1\n    for i in range(2, MAXN):\n        var[i] = i\n    for i in range(4, MAXN, 2):\n        var[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if var[i] == i:\n            for j in range(i * i, MAXN, i):\n                if var[j] == j:\n                    var[j] = i\n    return var\nvar = SmallestFac()\n\ndef gPrimeFac(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[var[x]] += 1\n        x = x // var[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = gPrimeFac(u)\n        v = gPrimeFac(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import math\n\ndef findMinSum(num):\n    sum = 0\n    i = 2\n    while i * i <= num:\n        while num % i == 0:\n            sum += i\n            num //= i\n        i += 1\n    if num == 1:\n        return sum\n    sum += num\n    return sum\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for qq in range(q):\n        (u, v) = map(int, input().split())\n        (u, v) = (min(u, v), max(u, v))\n        if u == v:\n            print(0)\n        elif v % u == 0:\n            print(findMinSum(v // u))\n        else:\n            g = math.gcd(u, v)\n            print(findMinSum(u // g) + findMinSum(v // g))", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sx():\n    mxn = 100001\n    s = [0 for i in range(mxn)]\n    s[1] = 1\n    for i in range(2, mxn):\n        s[i] = i\n    for i in range(4, mxn, 2):\n        s[i] = 2\n    for i in range(3, math.ceil(math.sqrt(mxn))):\n        if s[i] == i:\n            for j in range(i * i, mxn, i):\n                if s[j] == j:\n                    s[j] = i\n    return s\ns = sx()\n\ndef f(x):\n    res = defaultdict(lambda : 0)\n    while x != 1:\n        res[s[x]] += 1\n        x = x // s[x]\n    return res\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (a, b) = list(map(int, input().split()))\n        a = f(a)\n        b = f(b)\n        x = set(list(a.keys()) + list(b.keys()))\n        for i in x:\n            y = min(a[i], b[i])\n            a[i] -= y\n            b[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (a[i] + b[i])\n        print(ans)\nt = 1\nt = int(input())\nfor j in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\n\ndef smallprimefactor():\n    maxn = 100001\n    spf = [0 for i in range(maxn)]\n    spf[1] = 1\n    for i in range(2, maxn):\n        spf[i] = i\n    for i in range(4, maxn, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(maxn))):\n        if spf[i] == i:\n            for j in range(i * i, maxn, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = smallprimefactor()\n\ndef getprimefactor(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getprimefactor(u)\n        v = getprimefactor(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieve():\n    MAX = 100001\n    sp = [0 for i in range(MAX)]\n    sp[1] = 1\n    for i in range(2, MAX):\n        sp[i] = i\n    for i in range(4, MAX, 2):\n        sp[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAX))):\n        if sp[i] == i:\n            for j in range(i * i, MAX, i):\n                if sp[j] == j:\n                    sp[j] = i\n    return sp\nsp = sieve()\n\ndef primeFact(x):\n    res = defaultdict(lambda : 0)\n    while x != 1:\n        res[sp[x]] += 1\n        x = x // sp[x]\n    return res\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = primeFact(u)\n        v = primeFact(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sspf():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sspf()\n\ndef primeFLG(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = primeFLG(u)\n        v = primeFLG(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nfor _ in range(int(input())):\n    solve()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieve():\n    mymxy = 100001\n    ggspfis = [0 for i in range(mymxy)]\n    ggspfis[1] = 1\n    for i in range(2, mymxy):\n        ggspfis[i] = i\n    for i in range(4, mymxy, 2):\n        ggspfis[i] = 2\n    for i in range(3, math.ceil(math.sqrt(mymxy))):\n        if ggspfis[i] == i:\n            for j in range(i * i, mymxy, i):\n                if ggspfis[j] == j:\n                    ggspfis[j] = i\n    return ggspfis\nggspfis = sieve()\n\ndef getp(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[ggspfis[x]] += 1\n        x = x // ggspfis[x]\n    return ret\n\ndef solve():\n    (mynn, letsq) = list(map(int, input().split()))\n    for i in range(letsq):\n        (gguu, v) = list(map(int, input().split()))\n        gguu = getp(gguu)\n        v = getp(v)\n        x = set(list(gguu.keys()) + list(v.keys()))\n        for i in x:\n            y = min(gguu[i], v[i])\n            gguu[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (gguu[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import math\nN = int(100000.0)\nsieve = [True] * (N + 1)\nfactor = [0] * (N + 1)\nfor j in range(2, N + 1):\n    if sieve[j]:\n        factor[j] = j\n        for k in range(2 * j, N + 1, j):\n            factor[k] = j\n            sieve[k] = False\nsm = [0] * (N + 1)\nfor j in range(2, N + 1):\n    sm[j] = factor[j] + sm[j // factor[j]]\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    for _ in range(q):\n        (u, v) = map(int, input().split())\n        l = math.gcd(u, v)\n        print(sm[u] - sm[l] + sm[v] - sm[l])", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sieveForSmallestPrimeFactor():\n    MAXN = 100001\n    spf = [0 for i in range(MAXN)]\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieveForSmallestPrimeFactor()\n\ndef getPrimeFact(x):\n    ret = defaultdict(lambda : 0)\n    while x != 1:\n        ret[spf[x]] += 1\n        x = x // spf[x]\n    return ret\n\ndef solve():\n    (n, q) = list(map(int, input().split()))\n    for i in range(q):\n        (u, v) = list(map(int, input().split()))\n        u = getPrimeFact(u)\n        v = getPrimeFact(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = 1\nt = int(input())\nfor i in range(t):\n    solve()", "import math\n\ndef printDivisors(n):\n    v = []\n    while n % 2 == 0:\n        v.append(2)\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            v.append(i)\n            n = n // i\n    if n > 2:\n        v.append(n)\n    return v\nimport collections\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (x, y) = map(int, input().split())\n        div_x = printDivisors(x)\n        div_y = printDivisors(y)\n        d = collections.defaultdict(lambda : 0)\n        for j in div_x:\n            d[j] += 1\n        for j in div_y:\n            d[j] -= 1\n        ans = 0\n        for j in d:\n            ans += abs(d[j]) * j\n        print(ans)", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef smpf():\n    MAXN = 100001\n    some = [0 for i in range(MAXN)]\n    some[1] = 1\n    for i in range(2, MAXN):\n        some[i] = i\n    for i in range(4, MAXN, 2):\n        some[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAXN))):\n        if some[i] == i:\n            for j in range(i * i, MAXN, i):\n                if some[j] == j:\n                    some[j] = i\n    return some\nsome = smpf()\n\ndef gpfln(shi):\n    result = defaultdict(lambda : 0)\n    while shi != 1:\n        result[some[shi]] += 1\n        shi = shi // some[shi]\n    return result\n\ndef shiva_solution():\n    (n, ran) = list(map(int, input().split()))\n    for i in range(ran):\n        (sk, ga) = list(map(int, input().split()))\n        sk = gpfln(sk)\n        ga = gpfln(ga)\n        shi = set(list(sk.keys()) + list(ga.keys()))\n        for i in shi:\n            va = min(sk[i], ga[i])\n            sk[i] -= va\n            ga[i] -= va\n        answer = 0\n        for i in shi:\n            answer += i * (sk[i] + ga[i])\n        print(answer)\ntest = int(input())\nfor _ in range(test):\n    shiva_solution()", "import sys\nimport math\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef sfsp():\n    maxii = 100001\n    pdf = [0 for h in range(maxii)]\n    pdf[1] = 1\n    for h in range(2, maxii):\n        pdf[h] = h\n    for h in range(4, maxii, 2):\n        pdf[h] = 2\n    for h in range(3, math.ceil(math.sqrt(maxii))):\n        if pdf[h] == h:\n            for j in range(h * h, maxii, h):\n                if pdf[j] == j:\n                    pdf[j] = h\n    return pdf\npdf = sfsp()\n\ndef gpfl(m):\n    ret = defaultdict(lambda : 0)\n    while m != 1:\n        ret[pdf[m]] += 1\n        m = m // pdf[m]\n    return ret\n\ndef resans():\n    (n, r) = list(map(int, input().split()))\n    for h in range(r):\n        (s, t) = list(map(int, input().split()))\n        s = gpfl(s)\n        t = gpfl(t)\n        m = set(list(s.keys()) + list(t.keys()))\n        for h in m:\n            y = min(s[h], t[h])\n            s[h] -= y\n            t[h] -= y\n        sol = 0\n        for h in m:\n            sol += h * (s[h] + t[h])\n        print(sol)\nt = 1\nt = int(input())\nfor _ in range(t):\n    resans()", "from math import gcd\n\ndef maxfact(n):\n    i = 2\n    ans = 0\n    while i * i <= n:\n        while n % i == 0:\n            ans += i\n            n = n // i\n        i += 1\n    if n != 1:\n        return ans + n\n    return ans\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for ii in range(q):\n        (u, v) = map(int, input().split())\n        x = gcd(u, v)\n        ans = maxfact(u) + maxfact(v) - 2 * maxfact(x)\n        print(ans)", "import sys\nimport math\nfrom collections import defaultdict\n\ndef baba():\n    maxi = 10 ** 6\n    lauda = [0 for i in range(maxi)]\n    lauda[1] = 1\n    for i in range(2, maxi):\n        lauda[i] = i\n    for i in range(4, maxi, 2):\n        lauda[i] = 2\n    for i in range(3, math.ceil(math.sqrt(maxi))):\n        if lauda[i] == i:\n            for j in range(i * i, maxi, i):\n                if lauda[j] == j:\n                    lauda[j] = i\n    return lauda\nlauda = baba()\n\ndef maa(x):\n    rate = defaultdict(lambda : 0)\n    while x != 1:\n        rate[lauda[x]] += 1\n        x = x // lauda[x]\n    return rate\n\ndef solve():\n    if 5 == 8:\n        print('')\n    if 5 == 8:\n        print('')\n    if 5 == 8:\n        print('')\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        u = maa(u)\n        v = maa(v)\n        x = set(list(u.keys()) + list(v.keys()))\n        for i in x:\n            y = min(u[i], v[i])\n            u[i] -= y\n            v[i] -= y\n        ans = 0\n        for i in x:\n            ans += i * (u[i] + v[i])\n        print(ans)\nt = int(input())\nfor i in range(t):\n    if 5 == 8:\n        print('')\n    hui = 0\n    while hui < 2:\n        hui += 1\n    solve()", "def computeGCD(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return abs(x)\n\ndef factorize(n):\n    sieve = [True] * int(n ** 0.5 + 2)\n    for x in range(2, int(len(sieve) ** 0.5 + 2)):\n        if not sieve[x]:\n            continue\n        for i in range(x * x, len(sieve), x):\n            sieve[i] = False\n    factors = []\n    for i in range(2, len(sieve)):\n        if i * i > n:\n            break\n        if not sieve[i]:\n            continue\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 1:\n        factors.append(n)\n    return sum(factors)\nT = int(input())\nfor ts in range(T):\n    (N, Q) = map(int, input().split(' '))\n    for q in range(Q):\n        (u, v) = map(int, input().split(' '))\n        if u == v:\n            print(0)\n        else:\n            A = computeGCD(u, v)\n            print(factorize(u // A) + factorize(v // A))", "import math\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (a, b) = map(int, input().split())\n        if a == b:\n            print(0)\n            continue\n        (a, b) = (min(a, b), max(a, b))\n        g = math.gcd(a, b)\n        (a, b) = (a // g, b // g)\n        suma = 0\n        i = 2\n        while i * i <= a + 2:\n            while a % i == 0:\n                suma += i\n                a //= i\n            i += 1\n        if a != 1:\n            suma += a\n        sumb = 0\n        i = 2\n        while i * i <= b + 2:\n            while b % i == 0:\n                sumb += i\n                b //= i\n            i += 1\n        if b != 1:\n            suma += b\n        print(suma + sumb)", "import math\nt = int(input())\nfor i in range(t):\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        num = math.gcd(u, v)\n        ans = 0\n        u = u // num\n        while u != 1:\n            while u % 2 == 0:\n                ans += 2\n                u = u // 2\n            for j in range(3, int(u ** 0.5) + 1, 2):\n                while u % j == 0:\n                    ans += j\n                    u = u // j\n            if u > 2:\n                ans += u\n                break\n        u = v\n        u = u // num\n        while u != 1:\n            while u % 2 == 0:\n                ans += 2\n                u = u // 2\n            for j in range(3, int(u ** 0.5) + 1, 2):\n                while u % j == 0:\n                    ans += j\n                    u = u // j\n            if u > 2:\n                ans += u\n                break\n        print(ans)", "import math, sys\nfrom collections import defaultdict, deque\nimport bisect as bi\n\ndef yes():\n    print('YES')\n\ndef no():\n    print('NO')\n\ndef I():\n    return int(sys.stdin.readline())\n\ndef In():\n    return map(int, sys.stdin.readline().split())\n\ndef Sn():\n    return sys.stdin.readline().strip()\n\ndef dict(a):\n    d = {}\n    for x in a:\n        if d.get(x, -1) != -1:\n            d[x] += 1\n        else:\n            d[x] = 1\n    return d\n\ndef find_gt(a, x):\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:\n        return -1\n\ndef getFactorization(x):\n    ret = list()\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\n\ndef main():\n    try:\n        (n, q) = In()\n        for i in range(q):\n            (a, b) = In()\n            (a1, b1, c1) = (getFactorization(a), getFactorization(b), getFactorization(math.gcd(a, b)))\n            print(sum(a1) + sum(b1) - 2 * sum(c1))\n    except:\n        pass\nM = 998244353\nP = 1000000007\nimport math as mt\nMAXN = 100001\nglobal spf\nspf = [0 for i in range(MAXN)]\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\nsieve()\nfor _ in range(I()):\n    main()", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random, threading\nfrom functools import lru_cache\nfrom itertools import *\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n(M, M1) = (1000000007, 998244353)\n\ndef sieve():\n    spf = [i for i in range(10 ** 5 + 10)]\n    for i in range(2, len(spf), 2):\n        spf[i] = 2\n    for i in range(3, int(math.sqrt(len(spf))) + 1):\n        if spf[i] == i:\n            for j in range(i * i, len(spf), i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nspf = sieve()\n\ndef factor(x):\n    res = []\n    while x != 1:\n        res.append(spf[x])\n        x //= spf[x]\n    return res\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for _ in range(how_much_noob_I_am):\n        (n, q) = sep()\n        for i in range(q):\n            (u, v) = sep()\n            if u > v:\n                (u, v) = (v, u)\n            p = math.gcd(u, v)\n            u //= p\n            factoru = sum(factor(u))\n            v //= p\n            factorv = sum(factor(v))\n            print(factorv + factoru)\nmain()", "from math import gcd\nfrom math import sqrt\n\ndef PrimeFact(n):\n    factors = {}\n    for i in range(2, int(sqrt(n)) + 1):\n        c = 0\n        while n % i == 0:\n            n //= i\n            c += 1\n            factors[i] = c\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef main():\n    (n, q) = map(int, input().split())\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        if u == v:\n            print(0)\n        else:\n            hcf = gcd(u, v)\n            u = u // hcf\n            v = v // hcf\n            uf = PrimeFact(u)\n            vf = PrimeFact(v)\n            up = 0\n            for (k, v) in uf.items():\n                up += k * v\n            vp = 0\n            for (k, v) in vf.items():\n                vp += k * v\n            print(up + vp)\n    return\nfor _ in range(int(input())):\n    main()", "import sys\nfrom math import gcd, sqrt\ninput = lambda : sys.stdin.readline()\nT = int(input())\nfor _ in range(T):\n    (n, q) = map(int, input().strip().split())\n    for t in range(q):\n        (u, v) = map(int, input().strip().split())\n        w = gcd(u, v)\n        u = u // w\n        v = v // w\n        dic = {}\n        while u % 2 == 0:\n            dic[2] = dic.get(2, 0) + 1\n            u //= 2\n        for i in range(3, int(sqrt(u)) + 1, 2):\n            while u % i == 0:\n                dic[i] = dic.get(i, 0) + 1\n                u //= i\n        if u > 2:\n            dic[u] = dic.get(u, 0) + 1\n        while v % 2 == 0:\n            dic[2] = dic.get(2, 0) + 1\n            v //= 2\n        for i in range(3, int(sqrt(v)) + 1, 2):\n            while v % i == 0:\n                dic[i] = dic.get(i, 0) + 1\n                v //= i\n        if v > 2:\n            dic[v] = dic.get(v, 0) + 1\n        L = 0\n        for i in dic.keys():\n            L += i * dic[i]\n        print(L)", "import sys, math\ninput = sys.stdin.readline\nM = int(1000000000.0) + 7\nN = int(100000.0) + 5\nsieve = [1] * N\nfor i in range(2, N):\n    if sieve[i] == 1:\n        for j in range(i * i, N, i):\n            sieve[j] = i\nsumOfpf = [0] * N\nfor i in range(2, N):\n    if sieve[i] == 1:\n        sumOfpf[i] = i\n    else:\n        sumOfpf[i] = sieve[i] + sumOfpf[i // sieve[i]]\n\ndef solve():\n    (n, q) = map(int, input().split())\n    for _ in range(q):\n        (u, v) = map(int, input().split())\n        (u, v) = (min(u, v), max(u, v))\n        if v % u == 0:\n            print(sumOfpf[v // u])\n        else:\n            hcf = math.gcd(u, v)\n            ans = sumOfpf[v // hcf] + sumOfpf[u // hcf]\n            lcm = u * v // hcf\n            if lcm // u <= n and lcm // v <= n:\n                ans = min(ans, sumOfpf[lcm // u] + sumOfpf[lcm // v])\n            print(ans)\nfor _ in range(int(input())):\n    solve()"]