["import math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(1, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    print(*dp[1:])\nsolve()", "import math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(1, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    print(*dp[1:])\nsolve()", "import math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(1, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    print(*dp[1:])\nsolve()", "from fractions import Fraction\n(n, p) = input().split()\nn = int(n)\np = int(p)\nm = 998244353\n\ndef modInverse(A, M):\n    m0 = M\n    y = 0\n    x = 1\n    if M == 1:\n        return 0\n    while A > 1:\n        q = A // M\n        t = M\n        M = A % M\n        A = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef power(x, y):\n    res = 1\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x\n        y = y >> 1\n        x = x * x\n    return res\ntwo = 1\nk = 1\nl = 2\nx = 1\ns = 1\narr = [499122177]\nfor i in range(2, n + 1):\n    l = l * 2 * p ** 2 % m\n    x = x * p % m\n    two = two * 2 % m\n    k = (2 * k + 2 * x * s + two * x ** 2 % m) % m\n    s = (2 * s + x * two) % m\n    arr.append(k * modInverse(l, m) % m)\nprint(' '.join((str(i) for i in arr)))", "import math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(1, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    print(*dp[1:])\nsolve()", "m = 998244353\n(n, p) = [int(x) for x in input().split()]\nppow = ppow2 = pow(2, -1, m)\nprecip = pow(p, -1, m)\nprecipsq = pow(p, -2, m)\npsum = 0\ntot_sum = 0\nfor i in range(n):\n    tot_sum += psum * ppow * 2 % m + ppow2\n    tot_sum %= m\n    print(tot_sum, end=' ' if i < n - 1 else '\\n')\n    psum = (psum + ppow) % m\n    ppow = ppow * precip % m\n    ppow2 = ppow2 * precipsq % m", "import math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(1, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    print(*dp[1:])\nsolve()", "import math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(1, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    print(*dp[1:])\nsolve()", "import math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(1, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    print(*dp[1:])\nsolve()", "mod = 998244353\n(n, p) = map(int, input().split())\nr = pow(2, -1, mod)\nx = pow(p, -1, mod)\nm = 0\na = 1\nprint(r, end=' ')\nfor i in range(n - 1):\n    m += pow(x, i, mod)\n    a = x * a % mod\n    r += a * pow(2, -1, mod) * m + pow(a, 2, mod) * pow(2, -1, mod)\n    r = r % mod\n    print(r, end=' ')", "mod = 998244353\n(n, p) = map(int, input().split())\nf = pow(2, -1, mod)\nq = pow(p, -1, mod)\nsumq = 0\nQ = 1\nprint(f, end=' ')\nfor i in range(n - 1):\n    sumq += pow(q, i, mod)\n    Q = q * Q % mod\n    f += Q * pow(2, -1, mod) * sumq + pow(Q, 2, mod) * pow(2, -1, mod)\n    f %= mod\n    print(f, end=' ')", "import sys\nimport math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef aelkfblsIebfosbfpiasbnfpisbfipsebgfipsRbgfpiysbrgripysbgzsbgpiusbgipsbgfisBisbifbsoifgbsOIfbsigfboiysbgfoiysbfisfisefiysEiyfbsIYefbsIYbfisbfiebgfiebgiwrbgiobgiozsrbgioswbgiwsbgSIYbgsIYbgfiySbfgisbgfizsybgzsibgzsibgzsieybzsiebfizsefbzsibfzsibfizsyebfiesbfSIybfesybfzswsfbgzsbfzsyifbyisfbisebfsEbyfsyiebfisfbaISbfaISYbfaISYfbSYbfAYEbfyAEBfayBfyIAEbfiAYbfaEIYaIYfbaIfbaYIbfAYIEfbaIYbfa():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(2, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    for i in range(1, N + 1):\n        print(dp[i], end=' ')\n    print()\naelkfblsIebfosbfpiasbnfpisbfipsebgfipsRbgfpiysbrgripysbgzsbgpiusbgipsbgfisBisbifbsoifgbsOIfbsigfboiysbgfoiysbfisfisefiysEiyfbsIYefbsIYbfisbfiebgfiebgiwrbgiobgiozsrbgioswbgiwsbgSIYbgsIYbgfiySbfgisbgfizsybgzsibgzsibgzsieybzsiebfizsefbzsibfzsibfizsyebfiesbfSIybfesybfzswsfbgzsbfzsyifbyisfbisebfsEbyfsyiebfisfbaISbfaISYbfaISYfbSYbfAYEbfyAEBfayBfyIAEbfiAYbfaEIYaIYfbaIfbaYIbfAYIEfbaIYbfa()", "import math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(1, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    print(*dp[1:])\nsolve()", "MOD1 = 998244353\n\ndef mul(a, b):\n    return a % MOD1 * (b % MOD1) % MOD1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=MOD1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(2, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= MOD1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % MOD1\n    dp.remove(0)\n    print(*dp)\nsolve()", "import sys\nimport math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(2, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    for i in range(1, N + 1):\n        print(dp[i], end=' ')\n    print()\nsolve()", "def func(i):\n    return func2(i, 998244351)\n\ndef func2(a, b):\n    if b == 0:\n        return 1\n    temp = func2(a, b // 2)\n    temp = func3(temp, temp)\n    if b % 2:\n        return func3(temp, a)\n    return temp\n\ndef func3(a, b):\n    i = a % 998244353\n    j = b % 998244353\n    return i * j % 998244353\n(n, p) = map(int, input().split())\n(l1, l2) = ([0] * (n + 1), [0] * (n + 1))\n(l1[1], l2[1], fun2) = (func(2), func(2), func(2))\nfor i in range(2, n + 1):\n    res1 = func2(p, i - 1)\n    res2 = func(res1)\n    val = l1[i - 1] + func3(func2(res2, 2), fun2) + func3(res2, l2[i - 1])\n    l1[i] = val % 998244353\n    l2[i] = (l2[i - 1] + func3(res2, fun2)) % 998244353\nl1 = l1[1:]\nprint(*l1)", "import math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n(N, P) = map(int, input().split())\ndp = [0] * (N + 1)\ndp2 = [0] * (N + 1)\ndp[1] = dp2[1] = mod_inverse(2)\ninv2 = mod_inverse(2)\nfor i in range(2, N + 1):\n    y = binpow(P, i - 1)\n    y = mod_inverse(y)\n    val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n    val = val % mod1\n    dp[i] = val\n    dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\nfor i in range(1, N + 1):\n    print(dp[i], end=' ')\nprint()", "MOD1 = 998244353\n\ndef mul(a, b):\n    return a * b % MOD1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=MOD1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(2, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = (dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])) % MOD1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % MOD1\n    print(*dp[1:])\nsolve()", "import math\nMOD = 998244353\n\ndef multiply(a, b):\n    return a % MOD * (b % MOD) % MOD\n\ndef power(a, b):\n    if b == 0:\n        return 1\n    tmp = power(a, b // 2)\n    tmp = multiply(tmp, tmp)\n    if b % 2:\n        return multiply(tmp, a)\n    return tmp\n\ndef inverse(a, m=MOD):\n    return power(a, m - 2)\n\ndef main_func():\n    (num_cases, prime) = map(int, input().split())\n    dp = [0] * (num_cases + 1)\n    dp2 = [0] * (num_cases + 1)\n    dp[1] = dp2[1] = inverse(2)\n    inv2 = inverse(2)\n    for i in range(2, num_cases + 1):\n        y = power(prime, i - 1)\n        y = inverse(y)\n        val = dp[i - 1] + multiply(power(y, 2), inv2) + multiply(y, dp2[i - 1])\n        val %= MOD\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + multiply(y, inv2)) % MOD\n    print(*dp[1:])\nmain_func()", "import math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n(N, P) = map(int, input().split())\ndp = [0] * (N + 1)\ndp2 = [0] * (N + 1)\ndp[1] = dp2[1] = mod_inverse(2)\ninv2 = mod_inverse(2)\nfor i in range(2, N + 1):\n    y = binpow(P, i - 1)\n    y = mod_inverse(y)\n    val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n    val %= mod1\n    dp[i] = val\n    dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\nfor i in range(1, N + 1):\n    print(dp[i], end=' ')\nprint()", "import sys\nfrom fractions import Fraction\nMOD = 998244353\nM = lambda i: i % MOD\n\ndef inv(a):\n    return pow(M(a), MOD - 2, MOD)\n\ndef ipow(a, b):\n    a = M(a)\n    if b < 0:\n        return inv(ipow(a, -b))\n    else:\n        return pow(a, b, MOD)\n\ndef solve(n, p):\n    last = 0\n    f = 0.0\n    for k in range(1, n + 1):\n        t = ipow(p, k) - 1\n        t = M(t * inv(2 * (p - 1) * ipow(p, k - 1)))\n        t = M(t + last * inv(p * p))\n        last = t\n        print(t, end=' ')\n    print()\n(n, p) = map(int, sys.stdin.read().split())\nsolve(n, p)", "mod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(2, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    for i in range(1, N + 1):\n        print(dp[i], end=' ')\n    print()\nT = 1\nwhile T:\n    solve()\n    T -= 1", "import math\nimport random\nimport statistics\nimport operator\nimport itertools\nimport sys\nimport copy\nfrom collections import defaultdict, Counter, deque, OrderedDict\nfrom heapq import heapify, heappush, heappop\nfrom functools import lru_cache, reduce\nfrom bisect import bisect_left, bisect_right\nKPMOD2 = 1000000007\nKPMOD1 = 998244353\n\ndef modinverse(a):\n    return binpow(a, KPMOD1 - 2)\n\ndef modinv(a, KPMOD1=1000000007):\n    return binpow(a, KPMOD1 - 2)\n\ndef mult(a, b):\n    return a % KPMOD1 * (b % KPMOD1) % KPMOD1\n\ndef add(a, b):\n    return (a % KPMOD1 + b % KPMOD1) % KPMOD1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    res = binpow(a, b // 2) % KPMOD1\n    if b % 2:\n        return res * res * a % KPMOD1\n    else:\n        return res * res % KPMOD1\n\ndef fact(a):\n    if a == 0 or a == 1:\n        return 1\n    return a * (fact(a) % KPMOD1) % KPMOD1\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef isPrime(n):\n    if n == 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\nMAX = 100\nfact = [1] * MAX\ninvfact = [1] * MAX\nfor i in range(1, MAX):\n    fact[i] = fact[i - 1] * i % KPMOD1\n    invfact[i] = invfact[i - 1] * modinverse(i) % KPMOD1\n\ndef factors(n):\n    if n == 0:\n        return set()\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n(KPN, KPP) = [int(x) for x in input().split()]\nKPL1 = [0] * (KPN + 1)\nKPL2 = [0] * (KPN + 1)\nKPL1[1] = KPL2[1] = modinverse(2)\nKPM = modinverse(2)\nfor i in range(2, KPN + 1):\n    KPY = binpow(KPP, i - 1)\n    KPY = modinverse(KPY)\n    KPV = KPL1[i - 1] + mult(binpow(KPY, 2), KPM) + mult(KPY, KPL2[i - 1])\n    KPV %= KPMOD1\n    KPL1[i] = KPV\n    KPL2[i] = (KPL2[i - 1] + mult(KPY, KPM)) % KPMOD1\nfor i in range(1, KPN + 1):\n    print(KPL1[i], end=' ')", "def mod_inv(a, MOD):\n    return pow(a, MOD - 2, MOD)\n(N, P) = map(int, input().split())\nMOD = 998244353\ndp = [0] * (N + 1)\ndp2 = [0] * (N + 1)\ndp[1] = dp2[1] = mod_inv(2, MOD)\ninv2 = mod_inv(2, MOD)\nfor i in range(2, N + 1):\n    y = pow(P, i - 1, MOD)\n    y = mod_inv(y, MOD)\n    val = (dp[i - 1] + pow(y, 2, MOD) * inv2 % MOD + y * dp2[i - 1] % MOD) % MOD\n    dp[i] = val\n    dp2[i] = (dp2[i - 1] + y * inv2 % MOD) % MOD\nfor i in range(1, N + 1):\n    print(dp[i], end=' ')", "maxi = 998244353\n\ndef gun(a, b):\n    return a % maxi * (b % maxi) % maxi\n\ndef hard(a, b):\n    if b == 0:\n        return 1\n    t = hard(a, b // 2)\n    t = gun(t, t)\n    if b % 2:\n        return gun(t, a)\n    return t\n\ndef inve(a, m=maxi):\n    return hard(a, m - 2)\n\ndef hardik():\n    (k, l) = map(int, input().split())\n    pca = [0] * (k + 1)\n    pcb = [0] * (k + 1)\n    pca[1] = pcb[1] = inve(2)\n    inv2 = inve(2)\n    for i in range(2, k + 1):\n        y = hard(l, i - 1)\n        y = inve(y)\n        value = (pca[i - 1] + gun(hard(y, 2), inv2) + gun(y, pcb[i - 1])) % maxi\n        pca[i] = value\n        pcb[i] = (pcb[i - 1] + gun(y, inv2)) % maxi\n    for i in range(1, k + 1):\n        print(pca[i], end=' ')\n    print()\nhardik()", "def mul(a, b, mod1=998244353):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b, mod1=998244353):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=998244353):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0 for _ in range(N + 1)]\n    dp2 = [0 for _ in range(N + 1)]\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(2, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = (dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])) % 998244353\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % 998244353\n    for i in range(1, N + 1):\n        print(dp[i], end=' ')\n    print()\nsolve()", "m = 998244353\n[n, p] = [int(x) for x in input().split()]\n\ndef gcdExtended(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    (gcd, x1, y1) = gcdExtended(b % a, a)\n    x = y1 - b // a * x1\n    y = x1\n    return (gcd, x, y)\n\ndef inverse(a):\n    return gcdExtended(a, m)[1]\ncumulative = 1\ninverse_list = [1]\nmodulo_list = [1]\np_inverse = inverse(p)\nfor i in range(1, 2 * n):\n    inverse_list.append(p_inverse * inverse_list[-1] % m)\n    modulo_list.append(p * modulo_list[-1] % m)\ncommon = inverse(2 * p - 2)\nans_list = [0]\nfor i in range(1, n + 1):\n    x = ans_list[-1] + common * (m - 1 + modulo_list[i]) * inverse_list[2 * i - 2]\n    x = x % m\n    ans_list.append(x)\nfor i in range(1, n + 1):\n    print(ans_list[i], end=' ')", "def mod_inv(a, MOD):\n    return pow(a, MOD - 2, MOD)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inv(2, MOD)\n    inv2 = mod_inv(2, MOD)\n    for i in range(2, N + 1):\n        y = pow(P, i - 1, MOD)\n        y = mod_inv(y, MOD)\n        val = (dp[i - 1] + pow(y, 2, MOD) * inv2 % MOD + y * dp2[i - 1] % MOD) % MOD\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + y * inv2 % MOD) % MOD\n    for i in range(1, N + 1):\n        print(dp[i], end=' ')\n    print()\nsolve()", "def multiply_mod(kane1, kane2, mod=998244353):\n    return kane1 % mod * (kane2 % mod) % mod\n\ndef power_mod(kane1, kane2, mod=998244353):\n    if kane2 == 0:\n        return 1\n    tmp = power_mod(kane1, kane2 // 2, mod)\n    tmp = multiply_mod(tmp, tmp, mod)\n    if kane2 % 2:\n        return multiply_mod(tmp, kane1, mod)\n    return tmp\n\ndef inverse_mod(kane1, mod=998244353):\n    return power_mod(kane1, mod - 2, mod)\n\ndef compute_sequence(N, P):\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = inverse_mod(2)\n    inv2 = inverse_mod(2)\n    for i in range(2, N + 1):\n        y = power_mod(P, i - 1)\n        y = inverse_mod(y)\n        val = dp[i - 1] + multiply_mod(power_mod(y, 2), inv2) + multiply_mod(y, dp2[i - 1])\n        val %= 998244353\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + multiply_mod(y, inv2)) % 998244353\n    return dp[1:]\n(N, P) = map(int, input().split())\nresult = compute_sequence(N, P)\nfor res in result:\n    print(res, end=' ')", "MOD = 998244353\n(n, p) = map(int, input().split())\n\ndef into(x, y):\n    return x % MOD * (y % MOD) % MOD\n\ndef tow(x, y):\n    if y == 0:\n        return 1\n    cur = tow(x, y // 2)\n    cur = into(cur, cur)\n    if y % 2:\n        return into(cur, x)\n    return cur\n\ndef minv(x):\n    return tow(x, MOD - 2)\n(a, b) = ([0] * (n + 1), [0] * (n + 1))\na[1] = b[1] = minv(2)\ni2 = minv(2)\nfor i in range(2, n + 1):\n    tmp = minv(tow(p, i - 1))\n    t = (a[i - 1] + into(tow(tmp, 2), i2) + into(tmp, b[i - 1])) % MOD\n    (a[i], b[i]) = (t, (into(tmp, i2) + b[i - 1]) % MOD)\nprint(*a[1:])", "def mod_inverse(a, m=998244353):\n    return binpow(a, m - 2, m)\n\ndef binpow(a, b, mod=998244353):\n    if not b:\n        return 1\n    tmp = binpow(a, b // 2, mod)\n    tmp = mul(tmp, tmp, mod)\n    if b % 2:\n        return mul(tmp, a, mod)\n    return tmp\n\ndef mul(a, b, mod=998244353):\n    return a * b % mod\nfor _ in range(1):\n    (N, P) = map(int, input().split())\n    dp2 = [0] * (N + 1)\n    dp = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(2, N + 1):\n        y = binpow(P, i - 1, 998244353)\n        y = mod_inverse(y, 998244353)\n        val = (dp[i - 1] + mul(binpow(y, 2, 998244353), inv2) + mul(y, dp2[i - 1], 998244353)) % 998244353\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2, 998244353)) % 998244353\n    print(*dp[1:])", "mod = 998244353\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef bp(a, b):\n    if b == 0:\n        return 1\n    tmp = bp(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mi(a, m=mod):\n    return bp(a, m - 2)\n(n, p) = map(int, input().split())\ndp = [0] * (n + 1)\ndp2 = [0] * (n + 1)\ndp[1] = dp2[1] = mi(2)\ninv2 = mi(2)\nfor i in range(2, n + 1):\n    y = bp(p, i - 1)\n    y = mi(y)\n    val = dp[i - 1] + mul(bp(y, 2), inv2) + mul(y, dp2[i - 1])\n    val %= mod\n    dp[i] = val\n    dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod\nprint(*dp[1:])", "import math\nmod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\nmod1 = 998244353\n(N, P) = map(int, input().split())\ndp = [0] * (N + 1)\ndp2 = [0] * (N + 1)\ndp[1] = dp2[1] = mod_inverse(2)\ninv2 = mod_inverse(2)\nfor i in range(2, N + 1):\n    y = binpow(P, i - 1)\n    y = mod_inverse(y)\n    val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n    val %= mod1\n    dp[i] = val\n    dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\nfor i in range(1, N + 1):\n    print(dp[i], end=' ')\nprint()", "mod1 = 998244353\n\ndef mul(a, b):\n    return a * b % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().strip().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(2, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = (dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])) % mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    for i in range(1, N + 1):\n        print(dp[i], end=' ')\n    print()\nsolve()", "def binaryPow(a, b):\n    if b == 0:\n        return 1\n    tmp = binaryPow(a, b // 2)\n    tmp = modMultiply(tmp, tmp)\n    if b % 2:\n        return modMultiply(tmp, a)\n    return tmp\n\ndef modulo1():\n    return 998244353\n\ndef inverseMod(a, m=modulo1()):\n    return pow(a, m - 2, m)\n\ndef modMultiply(a, b):\n    return a % modulo1() * (b % modulo1()) % modulo1()\n(N, P) = map(int, input().split())\nDP = [0] * (N + 1)\nDP2 = [0] * (N + 1)\nDP[1] = DP2[1] = inverseMod(2)\ninverse2 = inverseMod(2)\nfor i in range(2, N + 1):\n    y = binaryPow(P, i - 1)\n    y = inverseMod(y)\n    val = DP[i - 1] + modMultiply(binaryPow(y, 2), inverse2) + modMultiply(y, DP2[i - 1])\n    val %= modulo1()\n    DP[i] = val\n    DP2[i] = (DP2[i - 1] + modMultiply(y, inverse2)) % modulo1()\nprint(*DP[1:])", "def mul(a, b, mod=998244353):\n    return a * b % mod\n\ndef binpow(a, b, mod=998244353):\n    result = 1\n    while b > 0:\n        if b & 1:\n            result = mul(result, a, mod)\n        a = mul(a, a, mod)\n        b >>= 1\n    return result\n\ndef mod_inverse(a, m=998244353):\n    return binpow(a, m - 2, m)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0 for i in range(N + 1)]\n    dp2 = [0 for i in range(N + 1)]\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(2, N + 1):\n        y = pow(P, i - 1, 998244353)\n        y = mod_inverse(y)\n        val = (dp[i - 1] + mul(pow(y, 2, 998244353), inv2) + mul(y, dp2[i - 1])) % 998244353\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % 998244353\n    for i in range(1, N + 1):\n        print(dp[i], end=' ')\n    print()\nsolve()", "mod1 = 998244353\n\ndef mul(a, b):\n    return a % mod1 * (b % mod1) % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a, m=mod1):\n    return binpow(a, m - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(2, N + 1):\n        y = binpow(P, i - 1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(binpow(y, 2), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    for i in range(1, N + 1):\n        print(dp[i], end=' ')\n    print()\nsolve()", "mod1 = 998244353\n\ndef mul(a, b):\n    return a * b % mod1\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    tmp = binpow(a, b // 2)\n    tmp = mul(tmp, tmp)\n    if b % 2:\n        return mul(tmp, a)\n    return tmp\n\ndef mod_inverse(a):\n    return binpow(a, mod1 - 2)\n\ndef solve():\n    (N, P) = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp2 = [0] * (N + 1)\n    dp[1] = dp2[1] = mod_inverse(2)\n    inv2 = mod_inverse(2)\n    for i in range(2, N + 1):\n        y = pow(P, i - 1, mod1)\n        y = mod_inverse(y)\n        val = dp[i - 1] + mul(pow(y, 2, mod1), inv2) + mul(y, dp2[i - 1])\n        val %= mod1\n        dp[i] = val\n        dp2[i] = (dp2[i - 1] + mul(y, inv2)) % mod1\n    print(*dp[1:])\nsolve()", "from functools import total_ordering\nfrom numbers import Number\n__version__ = '0.3.0'\n\n@total_ordering\nclass Mod:\n\n    def __init__(self, value, modulus):\n        if not isinstance(value, Number):\n            raise ValueError('Value is not a number')\n        if not isinstance(modulus, Number):\n            raise ValueError('Modulus is not a number')\n        if modulus == 0:\n            raise ValueError('Modulus value cannot be zero')\n        if modulus != int(modulus):\n            raise ValueError('Modulus is not an integer')\n        self._modulus = int(modulus)\n        self._value = int(value) % self._modulus\n\n    def __int__(self):\n        return self._value\n\n    def __float__(self):\n        return float(self._value)\n\n    def __hash__(self):\n        return hash(self._value)\n\n    @property\n    def modulus(self):\n        return self._modulus\n\n    def copy(self, modulus=None):\n        return Mod(self._value, modulus if modulus else self._modulus)\n\n    def _extended_gcd(self):\n        t_value = 0\n        new_t = 1\n        r_value = self._modulus\n        new_r = self._value\n        while True:\n            if new_r == 0:\n                return [r_value, t_value]\n            quotient = r_value // new_r\n            (t_value, new_t) = (new_t, t_value - quotient * new_t)\n            (r_value, new_r) = (new_r, r_value - quotient * new_r)\n\n    @property\n    def inverse(self):\n        (r_value, t_value) = self._extended_gcd()\n        if r_value != 1:\n            raise ValueError('the value {} cannot be inverted'.format(self))\n        value = t_value + (self._modulus if t_value < 0 else 0)\n        return Mod(value, self._modulus)\n\n    def __eq__(self, other):\n        if not isinstance(other, Number):\n            return False\n        if isinstance(other, Mod):\n            modulus = min((self._modulus, other._modulus))\n        else:\n            modulus = self._modulus\n        return int(self) % modulus == int(other) % modulus\n\n    def __lt__(self, other):\n        if not isinstance(other, Number):\n            return False\n        if isinstance(other, Mod):\n            modulus = min((self._modulus, other._modulus))\n        else:\n            modulus = self._modulus\n        return int(self) % modulus < int(other) % modulus\n\n    def __pos__(self):\n        return self.copy()\n\n    def __neg__(self):\n        return Mod(-self._value, self._modulus)\n\n    def _convert(self, other):\n        if isinstance(other, Mod):\n            if other._modulus != self._modulus:\n                raise ValueError('Not same modulus: {} != {}'.format(self._modulus, other._modulus))\n            return other\n        if isinstance(other, int):\n            return Mod(other, self._modulus)\n        return None\n\n    def __add__(self, other):\n        converted = self._convert(other)\n        if converted is None:\n            return self._value + other\n        return Mod(self._value + converted._value, self._modulus)\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        converted = self._convert(other)\n        if converted is None:\n            return self._value - other\n        return Mod(self._value - converted._value, self._modulus)\n\n    def __rsub__(self, other):\n        return -self + other\n\n    def __mul__(self, other):\n        converted = self._convert(other)\n        if converted is None:\n            return self._value * other\n        return Mod(self._value * converted._value, self._modulus)\n    __rmul__ = __mul__\n\n    def __truediv__(self, other):\n        return float(self) / float(other)\n\n    def __rtruediv__(self, other):\n        return float(other) / float(self)\n\n    def __floordiv__(self, other):\n        converted = self._convert(other)\n        if converted is None:\n            return self._value // other\n        if converted._value == 0:\n            raise ZeroDivisionError('integer division by {}'.format(converted))\n        inverted = other * self.inverse\n        return inverted.inverse\n\n    def __rfloordiv__(self, other):\n        converted = self._convert(other)\n        if converted is None:\n            return other // self._value\n        return converted * self.inverse\n\n    def __pow__(self, other):\n        converted = self._convert(other)\n        if converted is None:\n            return self._value ** other\n        if isinstance(other, Mod):\n            result = pow(self._value, other._value, self._modulus)\n        else:\n            result = pow(self._value, other, self._modulus)\n        return Mod(result, self._modulus)\n\n    def __rpow__(self, other):\n        converted = self._convert(other)\n        if converted is None:\n            return pow(other, self._value, self._modulus)\n        result = pow(converted._value, self._value, self._modulus)\n        return Mod(result, self._modulus)\nMOD = 998244353\n(n, p) = map(int, input().split())\na = Mod(0, MOD)\nb = Mod(0, MOD)\nscore_for_round = Mod(1, MOD)\nfor i in range(1, n + 1):\n    a += score_for_round\n    b += score_for_round * score_for_round\n    result = (a * a + b) // 4\n    print(int(result), end='' if i == n else ' ')\n    score_for_round //= p"]