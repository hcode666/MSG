["def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef doit(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    if s != 0:\n        return 0\n    return 1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\nt = int(input())\nfor tt in range(t):\n    (x, s) = [int(xx) for xx in input().split(' ')]\n    print(str(doit(x, s)))", "def ok(m, x, s):\n    ns = s - x\n    for msb in bits:\n        if ns >= msb:\n            q = min(m - 1, ns // msb)\n            ns -= q * msb\n    return ns == 0\nt = int(input())\nfor i in range(t):\n    (x, s) = map(int, input().split())\n    bits = []\n    for i in range(30, -1, -1):\n        if x >> i & 1:\n            num = 1 << i\n            bits.append(num)\n    l = 1\n    r = s\n    ans = -1\n    while l <= r:\n        m = (l + r) // 2\n        if ok(m, x, s):\n            ans = m\n            r = m - 1\n        else:\n            l = m + 1\n    print(ans)", "def ok(m, x, s):\n    ns = s - x\n    for msb in bits:\n        if ns >= msb:\n            q = min(m - 1, ns // msb)\n            ns -= q * msb\n    return ns == 0\nt = int(input())\nfor i in range(t):\n    (x, s) = map(int, input().split())\n    bits = []\n    for i in range(30, -1, -1):\n        if x >> i & 1:\n            num = 1 << i\n            bits.append(num)\n    l = 1\n    r = s\n    ans = -1\n    while l <= r:\n        m = (l + r) // 2\n        if ok(m, x, s):\n            ans = m\n            r = m - 1\n        else:\n            l = m + 1\n    print(ans)", "def ok(m, x, s):\n    ns = s - x\n    for msb in bits:\n        if ns >= msb:\n            q = min(m - 1, ns // msb)\n            ns -= q * msb\n    return ns == 0\nt = int(input())\nfor i in range(t):\n    (x, s) = map(int, input().split())\n    bits = []\n    for i in range(30, -1, -1):\n        if x >> i & 1:\n            num = 1 << i\n            bits.append(num)\n    l = 1\n    r = s\n    ans = -1\n    while l <= r:\n        m = (l + r) // 2\n        if ok(m, x, s):\n            ans = m\n            r = m - 1\n        else:\n            l = m + 1\n    print(ans)", "def ok(m, x, s):\n    ns = s - x\n    for msb in bits:\n        if ns >= msb:\n            q = min(m - 1, ns // msb)\n            ns -= q * msb\n    return ns == 0\nt = int(input())\nfor i in range(t):\n    (x, s) = map(int, input().split())\n    if x > s:\n        print(-1)\n    else:\n        bits = []\n        for i in range(30, -1, -1):\n            if x >> i & 1:\n                num = 1 << i\n                bits.append(num)\n        else:\n            l = 1\n            r = s\n            ans = -1\n            while l <= r:\n                m = (l + r) // 2\n                if ok(m, x, s):\n                    ans = m\n                    r = m - 1\n                else:\n                    l = m + 1\n            print(ans)", "def ok(m, x, s):\n    ns = s - x\n    for msb in bits:\n        if ns >= msb:\n            q = min(m - 1, ns // msb)\n            ns -= q * msb\n    return ns == 0\nt = int(input())\nfor i in range(t):\n    (x, s) = map(int, input().split())\n    if x > s:\n        print(-1)\n    else:\n        bits = []\n        for i in range(30, -1, -1):\n            if x >> i & 1:\n                num = 1 << i\n                bits.append(num)\n        if s % num != 0:\n            print(-1)\n        else:\n            l = 1\n            r = s\n            ans = r\n            while l <= r:\n                m = (l + r) // 2\n                if ok(m, x, s):\n                    ans = m\n                    r = m - 1\n                else:\n                    l = m + 1\n            print(ans)", "t = int(input())\nfor i in range(t):\n    (x, s) = map(int, input().split())\n    if x > s:\n        print(-1)\n    else:\n        bits = []\n        for i in range(30, -1, -1):\n            if x >> i & 1:\n                num = 1 << i\n                bits.append(num)\n        if s % num != 0:\n            print(-1)\n        else:\n\n            def ok(m, x, s):\n                ns = s - x\n                if ns == 0:\n                    return True\n                for msb in bits:\n                    if ns >= msb:\n                        q = min(m - 1, ns // msb)\n                        ns -= q * msb\n                        if ns == 0:\n                            return True\n                return False\n            l = 1\n            r = s\n            ans = r\n            while l <= r:\n                m = (l + r) // 2\n                if ok(m, x, s):\n                    ans = m\n                    r = m - 1\n                else:\n                    l = m + 1\n            print(ans)", "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef doit(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    if s != 0:\n        return 0\n    return 1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\nt = int(input())\nfor tt in range(t):\n    (x, s) = [int(xx) for xx in input().split(' ')]\n    print(str(doit(x, s)))", "import sys\nfrom functools import reduce\nimport math\n\ndef is_possible(cap, bit_idx, target):\n    if cap >= target:\n        return True\n    elif cap == 0:\n        return False\n    for b in bit_idx:\n        m = min(cap, target // 2 ** b)\n        target -= m * 2 ** b\n        if target == 0:\n            return True\n    return False\n\ndef binary_search(f, low, high):\n    mid = (high + low) // 2\n    if high <= low:\n        return low\n    if f(mid):\n        return binary_search(f, low, mid)\n    else:\n        return binary_search(f, mid + 1, high)\n\ndef get_bit_idx(x):\n    bits = []\n    idx = 0\n    while 2 ** idx <= x:\n        if x >> idx & 1:\n            bits.append(idx)\n        idx += 1\n    return bits\n\ndef solve(X, S):\n    t = S - X\n    n = 1\n    bi = get_bit_idx(X)[::-1]\n    if t % 2 ** bi[-1] > 0:\n        return -1\n    t //= 2 ** bi[-1]\n    bi = [b - bi[-1] for b in bi]\n    return binary_search(lambda cap: is_possible(cap, bit_idx=bi, target=t), 0, t) + 1\n\ndef pp(input):\n    cases = int(input())\n    for case in range(cases):\n        (X, S) = map(int, input().split())\n        print(solve(X, S))\nlines = iter(sys.stdin.read().split('\\n'))\npp(lambda : next(lines))", "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef doit(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    if s != 0:\n        return 0\n    return 1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\nt = int(input())\nfor tt in range(t):\n    (x, s) = [int(xx) for xx in input().split(' ')]\n    print(str(doit(x, s)))", "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef doit(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    if s != 0:\n        return 0\n    return 1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\nt = int(input())\nfor tt in range(t):\n    (x, s) = [int(xx) for xx in input().split(' ')]\n    print(str(doit(x, s)))", "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef doit(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    if s != 0:\n        return 0\n    return 1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\nt = int(input())\nfor tt in range(t):\n    (x, s) = [int(xx) for xx in input().split(' ')]\n    print(str(doit(x, s)))", "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef doit(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    if s != 0:\n        return 0\n    return 1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\nt = int(input())\nfor tt in range(t):\n    (x, s) = [int(xx) for xx in input().split(' ')]\n    print(str(doit(x, s)))", "def possible(X, S, count):\n    sum = S - X\n    count -= 1\n    B = 29\n    for b in range(B, -1, -1):\n        if X >> b & 1 == 0:\n            continue\n        times = min(count, sum // 2 ** b)\n        sum -= times * 2 ** b\n    return sum == 0\n\ndef solve():\n    for _ in range(int(input())):\n        (x, s) = list(map(int, input().split()))\n        l = 1\n        r = 10 ** 9 + 1\n        while l < r:\n            m = int(l + (r - l) / 2)\n            if possible(x, s, m):\n                r = m\n            else:\n                l = m + 1\n        if r > 10 ** 9:\n            r = -1\n        print(r)\nsolve()", "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef doit(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    if s != 0:\n        return 0\n    return 1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\nt = int(input())\nfor tt in range(t):\n    (x, s) = [int(xx) for xx in input().split(' ')]\n    print(str(doit(x, s)))", "def possible(X, S, count):\n    sum = S - X\n    count -= 1\n    B = 29\n    for b in range(B, -1, -1):\n        if X >> b & 1 == 0:\n            continue\n        times = min(count, sum // 2 ** b)\n        sum -= times * 2 ** b\n    return sum == 0\n\ndef solve():\n    for _ in range(int(input())):\n        (x, s) = list(map(int, input().split()))\n        l = 1\n        r = 10 ** 9 + 1\n        while l < r:\n            m = int(l + (r - l) / 2)\n            if possible(x, s, m):\n                r = m\n            else:\n                l = m + 1\n        if r > 10 ** 9:\n            r = -1\n        print(r)\nsolve()", "for _ in range(int(input())):\n    (x, s) = map(int, input().split())\n    (cnt, i, l, h) = ([], 0, 1, 10 ** 9 + 1)\n    while 1 << i <= x:\n        if 1 << i & x > 0:\n            cnt.append(1 << i)\n        i += 1\n    while l < h:\n        mid = (l + h) // 2\n        suma = s - x\n        for j in range(len(cnt) - 1, -1, -1):\n            suma -= min(mid - 1, suma // cnt[j]) * cnt[j]\n        if suma == 0:\n            h = mid\n        else:\n            l = mid + 1\n    if h < 10 ** 9 + 1:\n        print(h)\n    else:\n        print(-1)", "def possible(x, s, cnt):\n    total = s - x\n    cnt -= 1\n    bit = 29\n    for i in range(bit, -1, -1):\n        if x & 1 << i == 0:\n            continue\n        else:\n            time = min(cnt, total // (1 << i))\n            total -= time * (1 << i)\n    return total == 0\nfor _ in range(int(input())):\n    (x, s) = map(int, input().split())\n    low = 1\n    high = 10 ** 9 + 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if possible(x, s, mid):\n            high = mid\n        else:\n            low = mid + 1\n    if high > 10 ** 9:\n        print('-1')\n    else:\n        print(high)", "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef doit(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    if s != 0:\n        return 0\n    return 1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\nt = int(input())\nfor tt in range(t):\n    (x, s) = [int(xx) for xx in input().split(' ')]\n    print(str(doit(x, s)))", "def check(size):\n    S = s - x\n    size -= 1\n    for j in range(29, -1, -1):\n        if x & 1 << j:\n            times = min(size, S // (1 << j))\n            S -= times * (1 << j)\n    return S == 0\nfor _ in range(int(input())):\n    (x, s) = map(int, input().split())\n    l = 1\n    high = 10 ** 9 + 1\n    ans = -1\n    while l <= high:\n        mid = (l + high) // 2\n        if check(mid):\n            ans = mid\n            high = mid - 1\n        else:\n            l = mid + 1\n    print(ans)", "bits = [pow(2, i) for i in range(30, -1, -1)]\n\ndef gen(m, coins, target):\n    for coin in coins:\n        target -= coin * min(m, target // coin)\n    return target == 0\n\ndef getArr(x):\n    ans = []\n    for b in bits:\n        if x >= b:\n            x -= b\n            ans.append(b)\n    return ans\n\ndef isInvalid(x, s):\n    if x > s:\n        return True\n    while x % 2 == 0 and x > 0:\n        if s % 2 == 1:\n            return True\n        x = x // 2\n        s = s // 2\n    return False\n\ndef mysol(x, s):\n    if x == 0:\n        return -1\n    if isInvalid(x, s):\n        return -1\n    s -= x\n    low = s // x\n    high = s\n    xrr = getArr(x)\n    while low < high:\n        mid = (low + high) // 2\n        if gen(mid, xrr, s):\n            high = mid\n        else:\n            low = mid + 1\n    return 1 + high\nfor _ in range(int(input())):\n    (x, s) = map(int, input().split())\n    print(mysol(x, s))", "def BS(B, S, N, X):\n    S -= X\n    newN = int(N - 1)\n    for i in range(len(B) - 1, -1, -1):\n        if B[i] == '1':\n            count = S // 2 ** i\n            S -= min(newN, count) * 2 ** i\n    return S == 0\nfor t in range(int(input())):\n    (X, S) = map(int, input().split())\n    if X > S:\n        print(-1)\n        continue\n    B = str(bin(X))[2:]\n    B = B[::-1]\n    l = 1\n    r = int(S)\n    while r != l:\n        mid = (r + l) // 2\n        newS = int(S)\n        if BS(B, newS, mid, X):\n            r = int(mid)\n        else:\n            l = int(mid + 1)\n    if BS(B, S, l, X):\n        print(l)\n    else:\n        print(-1)", "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef doit(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    if s != 0:\n        return 0\n    return 1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\nt = int(input())\nfor tt in range(t):\n    (x, s) = [int(xx) for xx in input().split(' ')]\n    print(str(doit(x, s)))", "from sys import stdin\ninput = stdin.readline\n\ndef check(size):\n    req = s - x\n    for i in range(29, -1, -1):\n        if x >> i & 1:\n            remove = size * (1 << i)\n            if remove <= req:\n                req -= remove\n            else:\n                req %= 1 << i\n    if req == 0:\n        return True\n    return False\n\ndef answer():\n    (l, h) = (0, 10 ** 9)\n    ans = -1\n    while l <= h:\n        mid = (l + h) // 2\n        if check(mid):\n            ans = mid + 1\n            h = mid - 1\n        else:\n            l = mid + 1\n    return ans\nfor T in range(int(input())):\n    (x, s) = map(int, input().split())\n    print(answer())"]