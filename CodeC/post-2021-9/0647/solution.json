["from sys import stdin\ninput = stdin.readline\nmod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef sub(a, b):\n    return (a - b + mod) % mod\n\ndef answer():\n    for i in range(60):\n        if n >> i & 1:\n            x = i\n    dp = [0 for j in range(m + 1)]\n    for i in range(1, m + 1):\n        dp[i] = 1\n    for i in range(x - 1, -1, -1):\n        prefix = [0 for j in range(m + 1)]\n        for j in range(1, m + 1):\n            prefix[j] = add(prefix[j - 1], dp[j])\n        for j in range(1, m + 1):\n            if i & 1 == 0:\n                this = sub(prefix[m], prefix[j])\n                dp[j] = mul(this, this)\n            else:\n                this = prefix[j - 1]\n                dp[j] = mul(this, this)\n    ans = 0\n    for j in range(1, m + 1):\n        ans = add(ans, dp[j])\n    return ans\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    print(answer())", "from sys import stdin\ninput = stdin.readline\nmod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef sub(a, b):\n    return (a - b + mod) % mod\n\ndef answer():\n    for i in range(60):\n        if n >> i & 1:\n            x = i\n    dp = [0 for j in range(m + 1)]\n    for i in range(1, m + 1):\n        dp[i] = 1\n    for i in range(x - 1, -1, -1):\n        prefix = [0 for j in range(m + 1)]\n        for j in range(1, m + 1):\n            prefix[j] = add(prefix[j - 1], dp[j])\n        for j in range(1, m + 1):\n            if i & 1 == 0:\n                this = sub(prefix[m], prefix[j])\n                dp[j] = mul(this, this)\n            else:\n                this = prefix[j - 1]\n                dp[j] = mul(this, this)\n    ans = 0\n    for j in range(1, m + 1):\n        ans = add(ans, dp[j])\n    return ans\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    print(answer())", "MOD = int(10 ** 9) + 7\n\ndef solve(N, M):\n    height = 0\n    while N > 0:\n        height += 1\n        N = N // 2\n    dp = [[0 for i in range(0, M + 1)] for j in range(0, height + 1)]\n    for j in range(1, M + 1):\n        dp[1][j] = 1\n    for i in range(2, height + 1):\n        if i & 1 == 0:\n            sum = 0\n            for j in range(1, M + 1):\n                dp[i][j] += sum * sum\n                sum += dp[i - 1][j]\n                dp[i][j] %= MOD\n                sum %= MOD\n        else:\n            sum = 0\n            for j in range(M, 0, -1):\n                dp[i][j] += sum * sum\n                sum += dp[i - 1][j]\n                dp[i][j] %= MOD\n                sum %= MOD\n    ans = 0\n    for i in range(1, M + 1):\n        ans += dp[height][i]\n        ans %= MOD\n    print(ans)\nT = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    solve(N, M)", "import numpy as np\nmod = 10 ** 9 + 7\n\ndef solve(n, m):\n    if n == 1:\n        return m\n    if m == 1:\n        return 0\n    layers = n.bit_length()\n    f = np.ones((layers, m + 1), dtype=int)\n    g = np.ones((layers, m + 1), dtype=int)\n    for ly in range(1, layers):\n        cumsums = f[ly - 1][1:m].cumsum() % mod\n        g[ly][2:m + 1] = cumsums * cumsums % mod\n        cumsums = g[ly - 1][m:1:-1].cumsum() % mod\n        f[ly][m - 1:0:-1] = cumsums * cumsums % mod\n    result = np.sum(f[-1][1:m]) % mod\n    return result\nT = int(input())\nfor _ in range(T):\n    (n, m) = [int(x) for x in input().split()]\n    result = solve(n, m)\n    print(result)"]