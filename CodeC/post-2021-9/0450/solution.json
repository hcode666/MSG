["import sys\ntcs = 1\ntcs = int(input())\nfor tc in range(tcs):\n    (n, k) = list(map(int, input().split()))\n    if n == 1:\n        print(bin(k)[2:].count('1'))\n    else:\n        ans = i = 0\n        bit = flg = 1\n        while flg:\n            if k >= (1 << i) * n:\n                ans += n\n                k -= (1 << i) * n\n                flg = 1\n            else:\n                cnt = k // (1 << i)\n                k -= cnt * (1 << i)\n                ans += cnt\n                if k:\n                    k = (1 << i) - k\n                    for j in range(31):\n                        if 1 << j & k:\n                            ans -= 1\n                    ans += 1\n                flg = 0\n            i += 1\n        print(ans)", "import math\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    if k <= n:\n        print(k)\n    elif n == 1:\n        b = bin(k)\n        c = b.count('1')\n        print(c)\n    else:\n        a = []\n        i = 2\n        t = 0\n        while True:\n            a.append(i - 1)\n            if (i - 1) * (n - 1) > k:\n                i //= 2\n                break\n            i *= 2\n        b = math.log(i, 2)\n        t += (n - 1) * b\n        l = k - (i - 1) * (n - 1)\n        if l in a:\n            t += math.log(l + 1, 2)\n        else:\n            j = l // i\n            t += j\n            l = l % i\n            j = bin(l)\n            t += j.count('1')\n        print(int(t))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    bit = bin(k)[:1:-1]\n    (pos, ans, cnt, m) = ([], 0, 0, len(bit))\n    for i in range(m - 1):\n        temp = n + cnt\n        flag = not int(bit[i]) and temp % 2 or (int(bit[i]) and (not temp % 2))\n        ans += n - flag\n        pos.append(n - flag)\n        cnt = (temp - flag) // 2\n    if not cnt and bit[-1] == '1':\n        ans += 1\n    elif cnt > 1:\n        cnt = (cnt - 1) * 2\n        for i in range(m - 2, -1, -1):\n            if cnt <= pos[i]:\n                ans -= cnt\n                break\n            ans -= pos[i]\n            cnt = (cnt - pos[i]) * 2\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    bit = bin(k)[:1:-1]\n    (pos, ans, cnt, m) = ([], 0, 0, len(bit))\n    for i in range(m - 1):\n        temp = n + cnt\n        if not int(bit[i]) and temp % 2 or (int(bit[i]) and (not temp % 2)):\n            ans += n - 1\n            pos.append(n - 1)\n            cnt = (temp - 1) // 2\n        else:\n            ans += n\n            pos.append(n)\n            cnt = temp // 2\n    if not cnt and bit[-1] == '1':\n        ans += 1\n    elif cnt > 1:\n        cnt = (cnt - 1) * 2\n        for i in range(m - 2, -1, -1):\n            if cnt <= pos[i]:\n                ans -= cnt\n                break\n            ans -= pos[i]\n            cnt = (cnt - pos[i]) * 2\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    bit = bin(k)[:1:-1]\n    m = len(bit)\n    (mask, ans, cnt) = (1, 0, 0)\n    pos = []\n    for i in range(m - 1):\n        temp = n + cnt\n        if not int(bit[i]) and temp % 2 or (int(bit[i]) and (not temp % 2)):\n            ans += n - 1\n            pos.append(n - 1)\n            cnt = (temp - 1) // 2\n        else:\n            ans += n\n            pos.append(n)\n            cnt = temp // 2\n    if not cnt and bit[-1] == '1':\n        ans += 1\n    elif cnt > 1:\n        cnt = (cnt - 1) * 2\n        for i in range(m - 2, -1, -1):\n            if cnt <= pos[i]:\n                ans -= cnt\n                break\n            ans -= pos[i]\n            cnt = (cnt - pos[i]) * 2\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    bit = bin(k)[:1:-1]\n    m = len(bit)\n    (mask, ans, cnt) = (1, 0, 0)\n    pos = []\n    for i in range(m - 1):\n        temp = n + cnt\n        if not int(bit[i]):\n            if temp % 2:\n                ans += n - 1\n                pos.append(n - 1)\n                cnt = (temp - 1) // 2\n            else:\n                ans += n\n                pos.append(n)\n                cnt = temp // 2\n        elif temp % 2:\n            ans += n\n            pos.append(n)\n            cnt = temp // 2\n        else:\n            ans += n - 1\n            pos.append(n - 1)\n            cnt = (temp - 1) // 2\n    if not cnt and bit[-1] == '1':\n        ans += 1\n    elif cnt > 1:\n        i = m - 2\n        cnt = (cnt - 1) * 2\n        while cnt:\n            if cnt <= pos[i]:\n                ans -= cnt\n                break\n            ans -= pos[i]\n            cnt = (cnt - pos[i]) * 2\n            i -= 1\n    print(ans)", "def setBits(n):\n    if n == 0:\n        return 0\n    count = 1\n    while True:\n        n = n & n - 1\n        if n != 0:\n            count += 1\n        else:\n            break\n    return count\narr = []\n\ndef precomputation():\n    for i in range(33):\n        temp = 1 << i\n        temp -= 1\n        arr.append(temp)\n\ndef solve():\n    (n, k) = map(int, input().split())\n    i = 0\n    while arr[i] * n < k:\n        i += 1\n    (a, b) = (arr[i], arr[i - 1])\n    (seta, setb) = (i, i - 1)\n    upper = k - n * b\n    lower = a - b\n    x = upper // lower\n    if upper % lower != 0:\n        x += 1\n    y = n - x\n    ans = x * seta + y * setb\n    z = x * a + y * b - k\n    ans -= setBits(z)\n    return ans\nfor _ in range(int(input())):\n    precomputation()\n    print(solve())", "from math import ceil\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    i = 1\n    while n * ((1 << i) - 1) < k:\n        i += 1\n    (a, b) = (1 << i - 1, 1 << i)\n    y = ceil((k - n * (a - 1)) / a)\n    x = n - y\n    su = (a - 1) * x + (b - 1) * y\n    print((i - 1) * x + i * y - bin(su - k).count('1'))", "strng = lambda : input()\ninp = lambda : int(input())\nmul = lambda : map(int, input().split())\njn = lambda x, l: x.join(map(str, l))\nstrlst = lambda : list(input())\nlst = lambda : list(map(int, input().split()))\ndd = lambda : defaultdict(lambda : 0)\nfrom collections import defaultdict\nfrom math import ceil, log, floor, sqrt, gcd, log10\nfor _ in range(inp()):\n    (n, k) = mul()\n    i = 1\n    while True:\n        if (2 ** i - 1) * n <= k:\n            i += 1\n        else:\n            i -= 1\n            break\n    rem = k - n * (2 ** i - 1)\n    e = rem // 2 ** i\n    ans = (n - 1) * i + e\n    change = bin(rem % 2 ** i + 2 ** i - 1)\n    print(ans + change.count('1'))", "test = int(input())\nwhile test:\n    (n, k) = map(int, input().split())\n    i = 1\n    while True:\n        if (2 ** i - 1) * n <= k:\n            i += 1\n        else:\n            i -= 1\n            break\n    rem = k - n * (2 ** i - 1)\n    extra_1 = rem // 2 ** i\n    ans = n * i + extra_1\n    change = bin(rem % 2 ** i + 2 ** i - 1)\n    print(ans - i + change.count('1'))\n    test -= 1", "t = int(input())\nwhile t > 0:\n    t = t - 1\n    s = input().split()\n    n = int(s[0])\n    k = int(s[1])\n    ans = 0\n    while k > 0:\n        if k <= n:\n            ans = ans + k\n            k = 0\n        else:\n            diff = k - n\n            if diff % 2 == 0:\n                ans = ans + n\n                k = diff // 2\n            else:\n                ans = ans + n - 1\n                k = (diff + 1) // 2\n    print(ans)", "import math\n\ndef listp2(n):\n    l = []\n    while n > 0:\n        t = 2 ** int(math.log(n, 2))\n        n -= t\n        l.append(t)\n    return len(l)\n\ndef solve(n, k):\n    if n >= k:\n        return k\n    if k == 0:\n        return 0\n    if n == 1:\n        return listp2(k)\n    cpow = 1\n    csb = 1\n    ans = 0\n    while k > 0:\n        nbr = k // cpow\n        if nbr > n:\n            ans += n\n            k -= cpow * n\n            cpow *= 2\n            csb += 1\n        else:\n            ans += nbr\n            rm = k % cpow\n            (scp, spp) = (listp2(2 * cpow - 1 + rm), listp2(cpow - 1 + rm))\n            if 0 < nbr < n:\n                if scp + csb - 1 >= spp + csb:\n                    ans -= csb\n                    ans += scp\n                else:\n                    ans -= csb - 1\n                    ans += spp\n            elif nbr == 0:\n                ans -= csb - 1\n                ans += spp\n            else:\n                ans -= csb\n                ans += scp\n            k = 0\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    print(solve(n, k))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    f = True\n    res = 0\n    j = 0\n    while f:\n        if k >= (1 << j) * n:\n            res += n\n            k -= (1 << j) * n\n        else:\n            z = k // (1 << j)\n            k -= z * (1 << j)\n            res += z\n            if k:\n                k = (1 << j) - k\n                for i in range(31):\n                    if 1 << i & k:\n                        res -= 1\n                res += 1\n            f = False\n        j += 1\n    print(res)", "import math\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    count = 0\n    i = 0\n    last = 0\n    while k:\n        if n * 2 ** i <= k:\n            k -= n * 2 ** i\n            count += n\n            last += 2 ** i\n        else:\n            count += k // 2 ** i\n            k -= k // 2 ** i * 2 ** i\n            if k:\n                count -= math.log2(last + 1)\n                count += bin(last + k).count('1')\n                k = 0\n        i += 1\n    print(int(count))", "import sys\nout = []\nt = int(input())\nfor test in range(t):\n    n_k = list(map(int, input().split()))\n    n = n_k[0]\n    k = n_k[1]\n    power = 0\n    f = 0\n    count_ones_of_filled_mini = 0\n    while k > 0:\n        while k >= 2 ** power:\n            num_slots = min(k // 2 ** power, n)\n            if num_slots == n:\n                count_ones_of_filled_mini += 1\n            f += num_slots\n            k -= num_slots * 2 ** power\n            power += 1\n        if k > 0:\n            k += 2 ** power - 1\n            f += bin(k)[2:].count('1') - count_ones_of_filled_mini\n            k = 0\n    out.append(str(f))\nsys.stdout.write('\\n'.join(out))", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random, threading\nfrom functools import lru_cache\nfrom itertools import *\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n(M, M1) = (1000000007, 998244353)\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for _ in range(how_much_noob_I_am):\n        (n, k) = sep()\n        if n == 1:\n            print(bin(k).count('1'))\n            continue\n        if n >= k:\n            print(k)\n            continue\n        ans = n\n        k -= n\n        j = 1\n        while k:\n            if k >= 2 ** j * n:\n                k -= 2 ** j * n\n                j += 1\n                ans += n\n            else:\n                tot = k // 2 ** j\n                ans += tot\n                k = k % 2 ** j\n                a = 2 ** j - 1\n                a += k\n                ans += bin(a).count('1') - j\n                break\n        print(ans)\nmain()", "testCases = int(input())\nwhile testCases > 0:\n    testCases -= 1\n    (n, k) = input().split()\n    n = int(n)\n    k = int(k)\n    ans = 0\n    power = 1\n    while k > 0:\n        if k > n:\n            if k % 2 == n % 2:\n                k -= n\n                ans += n\n            else:\n                k -= n - 1\n                ans += n - 1\n        else:\n            ans += k\n            break\n        k //= 2\n    print(ans)", "n = int(input())\nfor _ in range(n):\n    (N, x) = map(int, input().split())\n    ans = 0\n    while x:\n        cur = min(x, N)\n        if cur & 1 != x & 1:\n            cur -= 1\n        ans += cur\n        x = (x - cur) // 2\n    print(int(ans))", "import math\nt = int(input())\nfor k in range(t):\n    (n, k) = input().split()\n    (n, k) = (int(n), int(k))\n    if n >= k:\n        print(k)\n    else:\n        ones = 0\n        while True:\n            if math.floor(k / (2 ** (ones + 1) - 1)) < n:\n                break\n            ones += 1\n        ost = k - (2 ** ones - 1) * n\n        dist = 2 ** (ones + 1) - 2 ** ones\n        cnt = math.floor(ost / dist)\n        ost2 = ost - cnt * dist\n        end = ost2 + (2 ** ones - 1)\n        cnt_bits = bin(end).count('1')\n        print(cnt * (ones + 1) + (n - cnt - 1) * ones + cnt_bits)", "t = int(input())\nwhile t:\n    t -= 1\n    (n, k) = list(map(int, input().split()))\n    (res, cnt) = (0, 0)\n    for _ in range(31):\n        if k % 2 == n % 2:\n            cnt = n\n        else:\n            cnt = n - 1\n        res += min(cnt, k)\n        k -= min(cnt, k)\n        k //= 2\n    print(res)", "import sys\nimport math\nfrom collections import defaultdict, Counter, deque\nfrom bisect import *\nfrom string import ascii_lowercase\nfrom heapq import *\n\ndef readInts():\n    x = list(map(int, sys.stdin.readline().rstrip().split()))\n    return x[0] if len(x) == 1 else x\n\ndef readList(type=int):\n    x = sys.stdin.readline()\n    x = list(map(type, x.rstrip('\\n\\r').split()))\n    return x\n\ndef readStr():\n    x = sys.stdin.readline().rstrip('\\r\\n')\n    return x\nwrite = sys.stdout.write\nread = sys.stdin.readline\nMAXN = 1123456\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef mergeSort(arr, check=lambda a, b: a < b, reverse=False):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        mergeSort(L, check, reverse)\n        mergeSort(R, check, reverse)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if check(L[i], R[j]):\n                if not reverse:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n            elif not reverse:\n                arr[k] = R[j]\n                j += 1\n            else:\n                arr[k] = L[i]\n                i += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\ndef maxSum(arr, k):\n    max_sum = 0\n    max_cur = 0\n    for (i, num) in enumerate(arr):\n        max_cur = max(max_cur + num, num)\n        if max_cur > max_sum:\n            max_sum = max_cur\n    return max_sum\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\ndef get_power(n, m):\n    i = 1\n    p = 0\n    while i <= n:\n        i = i * m\n        p += 1\n    return p\n\ndef fact(n):\n    f = 1\n    for i in range(2, n + 1):\n        f *= i\n    return f\n\ndef find_closest(num, ar):\n    min_d = float('inf')\n    for num2 in ar:\n        d = abs(num2 - num)\n        if d < min_d:\n            min_d = d\n    return min_d\n\ndef check_pal(n):\n    s = str(n)\n    j = len(s) - 1\n    i = 0\n    while j > i:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef get_primes():\n    primes = [False for _ in range(MAXN + 1)]\n    used = [False for _ in range(MAXN + 1)]\n    for i in range(2, MAXN + 1):\n        if not used[i]:\n            primes[i] = True\n            for j in range(i, MAXN + 1, i):\n                used[j] = True\n    return primes\n\ndef isPrime(primes, n):\n    if primes[n]:\n        return True\n    return False\n\ndef solve(t, primes=None):\n    (k, n) = readInts()\n    res = 0\n    cur = 1\n    while n > 0:\n        nxt = max(n - k * cur, 0)\n        if nxt != 0:\n            rem = nxt % (cur * 2)\n            if rem == 0:\n                rem = cur * 2\n            nxt = max(nxt, nxt + (cur * 2 - rem))\n        plc = (n - nxt) // cur\n        res += plc\n        n = nxt\n        cur *= 2\n    print(res)\n\ndef main():\n    t = 1\n    t = readInts()\n    for i in range(t):\n        solve(i + 1)\nmain()", "import math\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    if m <= n:\n        print(m)\n    elif n == 1:\n        a = bin(m)[2:].count('1')\n        print(a)\n    else:\n        d = 0\n        ans = 0\n        while m != 0:\n            if n * 2 ** d <= m:\n                ans += n\n                m -= n * 2 ** d\n                d += 1\n            else:\n                ans += m // 2 ** d\n                m = m % 2 ** d\n                ans -= d\n                h = m\n                m = 0\n                for j in range(d):\n                    h += 2 ** j\n                ans += bin(h).count('1')\n        print(ans)", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    ans = 0\n    i = 0\n    while True:\n        if k >= (1 << i) * n:\n            ans += n\n            k -= (1 << i) * n\n        else:\n            temp = k // (1 << i)\n            k -= temp * (1 << i)\n            ans += temp\n            if k:\n                k = (1 << i) - k\n                for j in range(31):\n                    if 1 << j & k:\n                        ans -= 1\n                ans += 1\n            break\n        i += 1\n    print(ans)", "def isPalindrome(s):\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef IntList():\n    lis = input().split()\n    lis = list(map(int, lis))\n    return lis\n\ndef StrList():\n    s = input()\n    lis = [val for val in s]\n    return lis\n\ndef FloatList():\n    lis = input().split()\n    lis = list(map(float, lis))\n    return lis\n\ndef searchRange(nums, target):\n    res = []\n    ans1 = -1\n    ans2 = -1\n\n    def bs(nums, key):\n        start = 0\n        end = len(nums) - 1\n        ans = -1\n        while start <= end:\n            mid = start + (end - start) // 2\n            if nums[mid] == key:\n                ans = mid\n                end = mid - 1\n            elif nums[mid] > key:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return ans\n\n    def bs1(nums, key):\n        start = 0\n        end = len(nums) - 1\n        ans = -1\n        while start <= end:\n            mid = start + (end - start) // 2\n            if nums[mid] == key:\n                ans = mid\n                start = mid + 1\n            elif nums[mid] > key:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return ans\n    ans1 = bs(nums, target)\n    ans2 = bs1(nums, target)\n    res.append(ans1)\n    res.append(ans2)\n    return res\n\ndef SieveOfEratosthenes(n, isPrime):\n    isPrime[0] = isPrime[1] = False\n    for i in range(2, n + 1):\n        isPrime[i] = True\n    p = 2\n    while p * p <= n:\n        if isPrime[p] == True:\n            i = p * p\n            while i <= n:\n                isPrime[i] = False\n                i += p\n        p += 1\n\ndef findPrimePair(n):\n    isPrime = [0] * (n + 1)\n    SieveOfEratosthenes(n, isPrime)\n    for i in range(0, n):\n        if isPrime[i] and isPrime[n - i]:\n            print(i, n - i)\n            return\n\ndef solveByPRateek():\n    (n, k) = map(int, input().split())\n    if n == 1:\n        i = 0\n        a = 1 << i\n        while a < k:\n            i += 1\n            a = 1 << i\n            a -= 1\n        print(i)\n        return\n    if n >= k:\n        print(k)\n        return\n    result = 0\n    check = True\n    i = 0\n    while check:\n        if k >= (1 << i) * n:\n            result += n\n            k -= (1 << i) * n\n            check = True\n        else:\n            cnt = k // (1 << i)\n            k -= cnt * (1 << i)\n            result += cnt\n            if k:\n                k = (1 << i) - k\n                for j in range(32):\n                    if 1 << j & k:\n                        result -= 1\n                result += 1\n            check = False\n        i += 1\n    print(result)\ntt = int(input())\nwhile tt:\n    tt -= 1\n    solveByPRateek()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    result = 0\n    bit = 1\n    check = True\n    i = 0\n    while check:\n        if k >= (1 << i) * n:\n            result += n\n            k -= (1 << i) * n\n            check = True\n        else:\n            cnt = k // (1 << i)\n            k -= cnt * (1 << i)\n            result += cnt\n            if k:\n                k = (1 << i) - k\n                for j in range(31):\n                    if 1 << j & k:\n                        result -= 1\n                result += 1\n            check = False\n        i += 1\n    print(result)", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    ans = 0\n    b = 1\n    flag = True\n    i = 0\n    while flag:\n        if k >= (1 << i) * n:\n            ans += n\n            k -= (1 << i) * n\n            flag = True\n        else:\n            count = k // (1 << i)\n            k -= count * (1 << i)\n            ans += count\n            if k:\n                k = (1 << i) - k\n                for j in range(31):\n                    if 1 << j & k:\n                        ans -= 1\n                ans += 1\n            flag = False\n        i += 1\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    NoOfBits = 0\n    f = True\n    i = 0\n    while f:\n        if k >= (1 << i) * n:\n            NoOfBits += n\n            k -= (1 << i) * n\n            f = True\n        else:\n            count = k // (1 << i)\n            k -= count * (1 << i)\n            NoOfBits += count\n            if k:\n                k = (1 << i) - k\n                for j in range(31):\n                    if 1 << j & k:\n                        NoOfBits -= 1\n                NoOfBits += 1\n            f = False\n        i += 1\n    print(NoOfBits)", "from math import gcd\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 0\n    i = 0\n    while True:\n        if k >= (1 << i) * n:\n            ans += n\n            k -= (1 << i) * n\n        else:\n            ct = k // (1 << i)\n            k -= ct * (1 << i)\n            ans += ct\n            if k:\n                k = (1 << i) - k\n                for j in range(31):\n                    if 1 << j & k:\n                        ans -= 1\n                ans += 1\n            break\n        i += 1\n    print(ans)", "for i in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    indices = [0] * 35\n    s = str(bin(k))\n    for i in range(1, len(s) - 1):\n        if s[-i] == '1':\n            indices[-i] = 1\n    for j in range(len(indices)):\n        for i in range(len(indices) - 1):\n            if indices[i] == 0:\n                continue\n            elif indices[i] * 2 + indices[i + 1] <= n:\n                indices[i + 1] += indices[i] * 2\n                indices[i] = 0\n            else:\n                temp = (n - indices[i + 1]) // 2\n                indices[i] -= temp\n                indices[i + 1] += temp * 2\n    print(sum(indices))", "from sys import stdin\ninput = stdin.readline\n\ndef solve(N, K):\n    count = 0\n    index = 0\n    while count + N * 2 ** index <= K:\n        count += N * 2 ** index\n        index += 1\n    if count == K:\n        return N * index\n    x = (K - count) // 2 ** index\n    if count + x * 2 ** index == K:\n        return N * index + x\n    excess = (x + 1) * 2 ** index - (K - count)\n    excess = [int(b) for b in bin(excess)[2:]]\n    return N * index + x + 1 - sum(excess)\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    (N, K) = [int(x) for x in input().strip().split()]\n    print(solve(N, K))", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    z = 0\n    while k > 0:\n        t = min(n, k)\n        if k - t & 1:\n            t -= 1\n        z += t\n        k -= t\n        k //= 2\n    print(z)", "import math\nfor iota in range(int(input())):\n    (n, k) = tuple(map(int, input().split()))\n    if n == 1:\n        print(bin(k).count('1'))\n        continue\n    if n >= k:\n        print(k)\n        continue\n    i = 1\n    val = 1\n    summ = n * val\n    ans = n\n    while True:\n        if summ == k:\n            break\n        val += pow(2, i)\n        if n * val <= k:\n            ans += n\n            summ = n * val\n        else:\n            tries = (k - summ) / pow(2, i)\n            ans += int(tries)\n            if int(tries) != tries:\n                toadd = k - summ - int(tries) * pow(2, i)\n                ans -= i\n                ans += bin(val + toadd - pow(2, i)).count('1')\n                summ = k\n                continue\n            summ = k\n        i += 1\n    print(ans)", "import sys\nsys.setrecursionlimit(1000000)\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\n\ndef printyes():\n    print('YES')\n\ndef printno():\n    print('NO')\n\ndef f(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\nfor t in range(int(input())):\n    (n, k) = mi()\n    i = 0\n    count = 0\n    for i in range(32):\n        maxcount = k // 2 ** i\n        if maxcount > n:\n            k -= n * 2 ** i\n            count += n\n        else:\n            k -= maxcount * 2 ** i\n            count += maxcount\n            if k > 0:\n                count -= f(2 ** i - 1)\n                count += f(2 ** i - 1 + k)\n            break\n    print(count)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = i = 0\n    while 1:\n        if k >= (1 << i) * n:\n            a += n\n            k -= (1 << i) * n\n        else:\n            mi = k // (1 << i)\n            k -= mi * (1 << i)\n            a += mi\n            if k:\n                k = (1 << i) - k\n                for j in range(31):\n                    if 1 << j & k:\n                        a -= 1\n                a += 1\n            break\n        i += 1\n    print(a)", "import math\n\ndef ffind(a, n):\n    c = 0\n    while n > 0:\n        if n % 2 == 1:\n            c += 1\n        n = n // 2\n    return a + c\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if n >= k:\n        print(min(n, k))\n    else:\n        a = 1\n        c = 0\n        if n < 2:\n            print(ffind(0, k))\n        else:\n            while k >= (n - 1) * a:\n                k = k - (n - 1) * a\n                c = c + (n - 1)\n                a = a * 2\n            aa = k // a\n            ans = c + aa + ffind(0, k - a * aa)\n            print(ans)", "for i in range(int(input())):\n    (n, k) = map(int, input().split())\n    li = []\n    i = 1\n    while i <= k:\n        li.append(i - 1)\n        i *= 2\n    if i - 1 == k:\n        li.append(k)\n    if k <= n:\n        print(k)\n    elif n == 1:\n        bits = 0\n        while k:\n            if k & 1:\n                bits += 1\n            k = k >> 1\n        print(bits)\n    else:\n        va = -1\n        for w in li:\n            if w * n >= k:\n                va = w\n                break\n        bits = n * li.index(va)\n        su = va * n\n        diff = va - li[li.index(va) - 1]\n        diff1 = su - k\n        mod = diff1 // diff\n        bits -= mod\n        if diff1 % diff != 0:\n            diff = diff1 - mod * diff\n            bits -= li.index(va)\n            (c, v) = (0, va - diff)\n            while v:\n                if v & 1:\n                    c += 1\n                v = v >> 1\n            bits += c\n        print(bits)", "from math import log2\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(list(bin(k)[2:]).count('1'))\n    elif k <= n:\n        print(k)\n    else:\n        ans = n\n        k -= n\n        (bit, occr) = (2, k // 2)\n        (mx_bit, mx_bit_occr) = (0, 0)\n        while occr:\n            if occr > n:\n                occr = n\n            (mx_bit, mx_bit_occr) = (bit, occr)\n            k -= occr * bit\n            ans += occr\n            bit *= 2\n            occr = k // bit\n        nxt_emp_cnt = n - mx_bit_occr\n        if k == 0:\n            print(ans)\n        else:\n            while k < bit:\n                bit = bit // 2\n            while k != 0:\n                occr = k // bit\n                (l1, l2) = (log2(mx_bit) - 1, log2(bit))\n                ans -= int(l1 - l2) * occr\n                k -= occr * bit\n                mx_bit = bit\n                if k == 0:\n                    break\n                while k < bit:\n                    bit = bit // 2\n            print(ans)", "t = int(input())\nfor T in range(t):\n    (n, k) = map(int, input().split())\n    if n >= k:\n        print(k)\n    else:\n        mx = 1\n        mn = 1\n        ans = n\n        i = 2\n        k -= n\n        q = 0\n        while k >= i:\n            if k >= i * n:\n                al = n\n                mx += i\n                mn = mx\n            else:\n                al = k // i\n                q = n - al\n                mx += i\n            ans += al\n            k -= al * i\n            i *= 2\n        el = 0\n        i //= 2\n        c1 = 0\n        c2 = 0\n        mx1 = mx\n        mn1 = mn\n        u = k + mx1\n        v = k + mn1\n        while mx1:\n            c1 += mx1 & 1\n            mx1 >>= 1\n        while mn1:\n            c2 += mn1 & 1\n            mn1 >>= 1\n        c3 = 0\n        c4 = 0\n        while u:\n            c3 += u & 1\n            u >>= 1\n        while v:\n            c4 += v & 1\n            v >>= 1\n        ans = ans - min(c1 - c3, c2 - c4)\n        print(ans)", "from math import ceil, gcd, factorial, sqrt, log, log2, pi\nimport queue\nimport heapq as hq\nfrom itertools import permutations, combinations, accumulate, product\nfrom collections import Counter, deque\nfrom bisect import bisect, insort, bisect_left, insort_left\nfrom sys import stdin, stdout\ninput = stdin.readline\n\ndef sieve(n):\n    prime = [True] * (n + 1)\n    p = 2\n    prime[0] = False\n    prime[1] = False\n    for p in range(2, int(n ** 0.5) + 1):\n        if prime[p] == True:\n            for l1 in range(p * p, n + 1, p):\n                prime[l1] = False\n    return prime\n\ndef simplesieve(n):\n    prime = [2]\n    mak = [False] * (n + 1)\n    for p in range(3, n + 1, 2):\n        if mak[p] == False:\n            prime.append(p)\n            if p * p <= n:\n                for l1 in range(p * p, n + 1, 2 * p):\n                    mak[l1] = True\n    return prime\n\ndef segementedsieve(low, high):\n    primes = simplesieve(int(high ** 0.5))\n    prime = [True] * (high - low + 1)\n    for i in primes:\n        lower = low // i * i\n        if lower < low:\n            lower += i\n        for j in range(lower, high + 1, i):\n            if j != i:\n                prime[j - low] = False\n    ans = []\n    for i in range(low, high + 1):\n        if prime[i - low]:\n            ans.append(i)\n    return ans\n\ndef isprime(n):\n    if n == 2:\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    for l1 in range(3, int(n ** 0.5) + 1, 2):\n        if n % l1 == 0:\n            return False\n    return True\n\ndef binpow(a, b, m):\n    r2 = 1\n    a = a % m\n    while b > 0:\n        if b & 1:\n            r2 = r2 * a % m\n        a = a * a % m\n        b >>= 1\n    return r2\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\n\ndef gcdExtended(a, b):\n    if b == 0:\n        return (a, 1, 0)\n    (g, x1, y1) = gcdExtended(b, a % b)\n    (x1, y1) = (y1, x1 - a // b * y1)\n    return (g, x1, y1)\n\ndef binseach(a, l, r, key):\n    while r - l > 1:\n        m = l + (r - l) // 2\n        if a[m] <= key:\n            l = m\n        else:\n            r = m\n    if a[l] == key:\n        return l\n    if a[r] == key:\n        return r\n    return -1\n\ndef inorder(root):\n    (res, stack) = ([], [])\n    current = root\n    while True:\n        while current:\n            stack.append(current)\n            current = current.left\n        if len(stack) == 0:\n            return res\n        node = stack[-1]\n        stack.pop(len(stack) - 1)\n        if node.data != None:\n            res.append(node.data)\n        current = node.right\n    return res\n\ndef find(n):\n    if par[n] == n:\n        return n\n    par[n] = find(par[n])\n    return par[n]\n\ndef union(a, b):\n    a1 = find(a)\n    b1 = find(b)\n    if a1 != b1:\n        if rank[a1] >= rank[b1]:\n            par[b1] = a1\n            rank[a1] += rank[b1]\n        else:\n            rank[b1] += rank[a1]\n            par[a1] = b1\n\ndef dfs(s, p):\n    v[s] = 1\n    path.append(s)\n    for i in a[s]:\n        if v[i] == 0:\n            if dfs(i):\n                return True\n        elif i != p:\n            path.append(i)\n            return True\n    path.pop()\n    return False\n\ndef bfs(graph, n, x, dest):\n    v = [0] * (1 + n)\n    d = [0] * (1 + n)\n    d[x] = 0\n    v[x] = 1\n    q = queue.Queue()\n    q.put(x)\n    p = [0] * (1 + n)\n    p[x] = -1\n    while not q.empty():\n        z = q.get()\n        for s in graph[z]:\n            if v[s] == 0:\n                v[s] = 1\n                d[s] = d[z] + 1\n                q.put(s)\n    return d[dest]\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if n >= k:\n        print(k)\n        continue\n    c = 0\n    ans = 0\n    if abs(k - n) % 2 == 0:\n        while 1:\n            if 2 ** c * n <= k:\n                k = k - 2 ** c * n\n            else:\n                break\n            c += 1\n            ans += n\n        ans += k // 2 ** c\n        rem = k % 2 ** c\n        rem = 2 ** c - rem\n        if rem > 0:\n            ans += 1\n        for i in range(63, -1, -1):\n            if rem & 1 << i:\n                ans -= 1\n        print(ans)\n    else:\n        k = k - (n - 1)\n        c = 1\n        ans = n - 1\n        while 1:\n            if 2 ** c * n <= k:\n                k = k - 2 ** c * n\n            else:\n                break\n            c += 1\n            ans += n\n        ans += k // 2 ** c\n        rem = k % 2 ** c\n        rem = 2 ** c - rem\n        if rem > 0:\n            ans += 1\n        for i in range(63, -1, -1):\n            if rem & 1 << i:\n                ans -= 1\n        print(ans)", "for z in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 0\n    if n >= k:\n        print(k)\n    else:\n        n = n - 1\n        i = 1\n        while k != 0:\n            div = k // i\n            if div == 0:\n                break\n            div = min(n, div)\n            k -= div * i\n            i *= 2\n            ans += div\n        print(ans + str(bin(k)[2:]).count('1'))", "import math\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    nsb = 0\n    i = 0\n    while True:\n        tmp2 = 1 << i\n        tmp = tmp2 * n\n        if k >= tmp:\n            nsb += n\n            k -= tmp\n        else:\n            mdiff = k // tmp2\n            k -= mdiff * tmp2\n            nsb += mdiff\n            if k:\n                k = tmp2 - k\n                for j in range(0, 31):\n                    if 1 << j & k:\n                        nsb -= 1\n                nsb += 1\n            break\n        i += 1\n    print(math.floor(nsb))", "T = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    (val, ans) = (0, 0)\n    for i in range(28):\n        a = 1 << i\n        if (val + a) * N == M:\n            val += a\n            i += 1\n            break\n        if (val + a) * N > M:\n            break\n        val += a\n    M -= val * N\n    ans += N * i\n    B = M // (1 << i)\n    M -= B * (1 << i)\n    ans += B\n    ans -= i\n    C = bin(val + M)\n    D = C[2:].count('1')\n    ans += D\n    print(ans)", "from math import pow\nfor _ in range(int(input())):\n\n    def countSetBits(n):\n        count = 0\n        while n:\n            n &= n - 1\n            count += 1\n        return count\n    ans = 0\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(countSetBits(k))\n    elif k <= n:\n        print(k)\n    else:\n        ans = 0\n        i = 0\n        while n * (int(pow(2, i)) - 1) <= k:\n            i += 1\n        i -= 1\n        ans = n * i\n        x = int(pow(2, i))\n        k = k - n * (int(pow(2, i)) - 1)\n        z = k // x\n        k -= z * x\n        ans += z\n        y = int(pow(2, i)) - 1\n        ans -= i\n        y += k\n        ans += countSetBits(y)\n        print(ans)", "from math import pow\nfor _ in range(int(input())):\n\n    def countSetBits(n):\n        count = 0\n        while n:\n            n &= n - 1\n            count += 1\n        return count\n    ans = 0\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(countSetBits(k))\n    elif k <= n:\n        print(k)\n    else:\n        ans = 0\n        i = 0\n        while n * (int(pow(2, i)) - 1) <= k:\n            i += 1\n        i -= 1\n        ans = n * i\n        x = int(pow(2, i))\n        k = k - n * (int(pow(2, i)) - 1)\n        z = k // x\n        k -= z * x\n        ans += z\n        y = int(pow(2, i)) - 1\n        ans -= i\n        y += k\n        ans += countSetBits(y)\n        print(ans)", "from math import pow\nfor _ in range(int(input())):\n\n    def countSetBits(n):\n        count = 0\n        while n:\n            n &= n - 1\n            count += 1\n        return count\n    ans = 0\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(countSetBits(k))\n    elif k <= n:\n        print(k)\n    else:\n        ans = 0\n        i = 0\n        while n * (int(pow(2, i)) - 1) <= k:\n            i += 1\n        i -= 1\n        ans = n * i\n        x = int(pow(2, i))\n        k = k - n * (int(pow(2, i)) - 1)\n        z = k // x\n        k -= z * x\n        ans += z\n        y = int(pow(2, i)) - 1\n        ans -= i\n        y += k\n        ans += countSetBits(y)\n        print(ans)", "def cb(x):\n    s = bin(x)\n    ans = 0\n    for i in s:\n        if i == '1':\n            ans += 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    a = list(map(int, input().split()))\n    n: int = a[0]\n    k = a[1]\n    if n >= k:\n        print(k)\n    else:\n        cd = 0\n        i = 0\n        ans = 0\n        while k:\n            if k >= n * 2 ** i:\n                ans = ans + n\n                cd = cd + 2 ** i\n                k = k - n * 2 ** i\n            else:\n                ans += k // 2 ** i\n                k = k - 2 ** i * (k // 2 ** i)\n                break\n            i += 1\n        print(ans - cb(cd) + cb(k + cd))", "def set_bits_in(num):\n    count = 0\n    while num > 0:\n        if num & 1 == 1:\n            count += 1\n        num = num >> 1\n    return count\nfor _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    ans = 0\n    a = 1\n    while k > 0:\n        if k % (a * 2):\n            c = min(k // a, n if n % 2 else n - 1)\n            k = k - a * c\n            ans += c\n        else:\n            c = min(k // a, n - 1 if n % 2 else n)\n            k = k - a * c\n            ans += c\n        a = a * 2\n    print(ans)", "def ccc(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    c = n\n    cnt = 0\n    ans = 0\n    cc = 0\n    summ = 0\n    while c > 1:\n        cnt += 1\n        c = c // 2\n    for i in range(40):\n        w = 2 ** i\n        rem = k % w\n        if summ + n * w <= k:\n            summ += n * w\n            ans += n\n        else:\n            diff = (k - summ) // w\n            rem = (k - summ) % w\n            ans += diff\n            ans -= i\n            q = 2 ** i - 1\n            kk = q + rem\n            j = ccc(kk)\n            ans += j\n            break\n    print(ans)", "def count_set_bits(num):\n    count = 0\n    while num > 0:\n        count += num & 1\n        num = num >> 1\n    return count\nnq = int(input())\nfor _ in range(nq):\n    inp = list(input().split())\n    n = int(inp[0])\n    k = int(inp[1])\n    k_1 = k\n    i = 0\n    count = 0\n    a = []\n    while 2 ** i <= k:\n        tmp = k // 2 ** i\n        tmp = min(tmp, n - 1)\n        a.append(tmp)\n        count += tmp\n        k += -tmp * 2 ** i\n        i += 1\n    count += count_set_bits(k)\n    print(count)", "T = int(input())\n\ndef check(n):\n    if n > 0:\n        return n % 2 + check(n // 2)\n    else:\n        return 0\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    i = 1\n    if K == 0:\n        print(0)\n        continue\n    s = 0\n    while K > 0:\n        if K >= i * N:\n            s += N\n            K -= i * N\n            i = i * 2\n        else:\n            s += K // i\n            K -= K // i * i\n            if check(i - 1) - check(i - 1 + K) >= check(i * 2 - 1) - check(i * 2 - 1 + K):\n                s += check(i * 2 - 1 + K)\n                s -= check(i * 2 - 1)\n            else:\n                s += check(i - 1 + K)\n                s -= check(i - 1)\n            K = 0\n    print(s)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    ret = 0\n    while K:\n        num_bits_set = N\n        if (N - K) % 2:\n            num_bits_set -= 1\n        if num_bits_set > K:\n            num_bits_set -= (num_bits_set - K) // 2 * 2\n        ret += num_bits_set\n        K -= num_bits_set\n        K //= 2\n    print(ret)", "tc = int(input())\nfor case in range(tc):\n    (n, k) = map(int, input().split())\n    ans = 0\n    mod = 1\n    mn = float('inf')\n    while k >= mod:\n        giv = k // mod\n        if giv >= n:\n            mn = mod\n        ans += min(giv, n)\n        k -= min(giv, n) * mod\n        mod += mod\n    if mn != float('inf'):\n        x = (mn << 1) - 1\n        cnt = bin(k + x)[2:].count('1') - bin(x)[2:].count('1')\n        ans += cnt\n    print(ans)", "import math\nfor h in range(int(input())):\n    (n, k) = map(int, input().split())\n    c = 0\n    i = 0\n    while k > 0:\n        if n * 2 ** i <= k:\n            k -= n * 2 ** i\n            c += n\n        else:\n            break\n        i += 1\n    c += k // 2 ** i\n    k = k % 2 ** i\n    if k != 0:\n        c -= i\n        c += 1\n        k -= 1\n        c += bin(k)[2:].count('1')\n    print(c)", "for _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    start = 1\n    k = x\n    ans = 0\n    while x:\n        if start * n <= x:\n            x -= start * n\n            ans += n\n        else:\n            kitne = x // start\n            ans += kitne\n            x -= kitne * start\n            if x:\n                ans += 1 - str(bin(start - x)).count('1')\n            x = 0\n        start *= 2\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 0\n    i = 0\n    last = k\n    n -= 1\n    while k > 0:\n        pow = 1 << i\n        i += 1\n        minus = n * pow\n        if minus <= k:\n            ans += n\n            k -= minus\n        else:\n            ans += k // pow\n            k -= k // pow * pow\n        if k == last:\n            break\n        last = k\n    ans += bin(k)[2:].count('1')\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 0\n    i = 0\n    last = k\n    add = 0\n    fu = k\n    n -= 1\n    while k > 0:\n        pow = 1 << i\n        add += pow\n        if add > fu:\n            break\n        i += 1\n        minus = n * pow\n        if minus <= k:\n            ans += n\n            k -= minus\n        else:\n            ans += k // pow\n            k -= k // pow * pow\n        if k == last:\n            break\n        last = k\n    ans += bin(k)[2:].count('1')\n    print(ans)", "def solve():\n    (n, k) = list(map(int, input().split()))\n    bi = bin(k).replace('0b', '')\n    bi = bi[::-1]\n    arr = [int(i) for i in bi]\n    rep = 0\n    while rep < 30:\n        i = len(bi) - 1\n        while i >= 0:\n            if arr[i] > 0:\n                incr = 2 ** i\n                for j in range(i):\n                    fit = incr // 2 ** j\n                    push = max(0, n - arr[j]) // fit\n                    we = min(arr[i], push)\n                    arr[j] += we * fit\n                    arr[i] -= we\n                    if arr[i] == 0:\n                        break\n            i -= 1\n        rep += 1\n    print(sum(arr))\ntry:\n    for tc in range(int(input())):\n        solve()\nexcept:\n    pass", "def setBitNumber(n):\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n = n + 1\n    return n >> 1\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(bin(k).count('1'))\n    elif k < n:\n        print(k)\n    else:\n        final = 0\n        ans = setBitNumber(k // n)\n        if k // n == ans * 2 - 1:\n            ans = k // n\n        else:\n            ans -= 1\n        reminder = k - ans * n\n        temp = ans + 1\n        x = reminder // temp\n        reminder -= x * temp\n        reminder += ans\n        final = x + bin(reminder).count('1') + bin(ans).count('1') * (n - 1)\n        print(final)", "import math\nT = int(input())\nfor _ in range(T):\n    (n, k) = map(int, input().split())\n    if k <= n:\n        ans = k\n    else:\n        ans = n\n        k -= n\n        i = 1\n        j = 1\n        while k > 0:\n            if 2 * j * n <= k:\n                ans += n\n                k -= 2 * j * n\n                j *= 2\n                i += 1\n            else:\n                ans += k // (2 * j)\n                k -= k // (2 * j) * (2 * j)\n                a = 2 ** i - 1\n                x = str(bin(a))\n                a += k\n                y = str(bin(a))\n                ans += y.count('1') - x.count('1')\n                k = 0\n    print(ans)"]