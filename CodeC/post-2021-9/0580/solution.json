["t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "import math\n\ndef minimum_move(n, array):\n    prefix_sum = [array[0]]\n    for i in range(1, len(array)):\n        prefix_sum.append(prefix_sum[i - 1] + array[i])\n    total = prefix_sum[-1]\n    if total == 0:\n        ans = n\n        for num in prefix_sum:\n            if num == 0:\n                ans -= 1\n        return ans\n    sign = 1 if total > 0 else -1\n    total = abs(total)\n\n    def possible(l, e):\n        s = 0\n        for num in prefix_sum:\n            if num == (s + 1) * e:\n                s += 1\n        return s >= l\n    ans = n - 1\n    for i in reversed(range(1, math.ceil(math.sqrt(total)) + 1)):\n        if total % i != 0:\n            continue\n        if possible(i, total // i * sign):\n            ans = min(ans, n - i)\n        if possible(total // i, i * sign):\n            ans = min(ans, n - total // i)\n    return ans\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    array = list(map(int, input().split(' ')))\n    print(minimum_move(N, array))", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "q = int(input())\nfor y in range(q):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "q = int(input())\nfor y in range(q):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "q = int(input())\nfor y in range(q):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "import math\n\ndef minimum_move(n, array):\n    prefix_sum = [array[0]]\n    for i in range(1, len(array)):\n        prefix_sum.append(prefix_sum[i - 1] + array[i])\n    total = prefix_sum[-1]\n    if total == 0:\n        ans = n\n        for num in prefix_sum:\n            if num == 0:\n                ans -= 1\n        return ans\n    sign = 1 if total > 0 else -1\n    total = abs(total)\n\n    def possible(l, e):\n        s = 0\n        for num in prefix_sum:\n            if num == (s + 1) * e:\n                s += 1\n        return s >= l\n    ans = n - 1\n    for i in reversed(range(1, math.ceil(math.sqrt(total)) + 1)):\n        if total % i != 0:\n            continue\n        if possible(i, total // i * sign):\n            ans = min(ans, n - i)\n        if possible(total // i, i * sign):\n            ans = min(ans, n - total // i)\n    return ans\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    array = list(map(int, input().split(' ')))\n    print(minimum_move(N, array))", "import math\n\ndef minimum_move(n, array):\n    prefix_sum = [array[0]]\n    for i in range(1, len(array)):\n        prefix_sum.append(prefix_sum[i - 1] + array[i])\n    total = prefix_sum[-1]\n    if total == 0:\n        ans = n\n        for num in prefix_sum:\n            if num == 0:\n                ans -= 1\n        return ans\n    sign = 1 if total > 0 else -1\n    total = abs(total)\n\n    def possible(l, e):\n        s = 0\n        for num in prefix_sum:\n            if num == (s + 1) * e:\n                s += 1\n        return s >= l\n    ans = n - 1\n    for i in reversed(range(1, math.ceil(math.sqrt(total)) + 1)):\n        if total % i != 0:\n            continue\n        if possible(i, total // i * sign):\n            ans = min(ans, n - i)\n        if possible(total // i, i * sign):\n            ans = min(ans, n - total // i)\n    return ans\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    array = list(map(int, input().split(' ')))\n    print(minimum_move(N, array))", "import sys\nimport itertools\nMAXN = 30000\nSQRTMAXN = 175\nISPRIME = [1] * (MAXN + 1)\nPRIMES = [2]\n\ndef sieve():\n    for i in range(MAXN // 2):\n        ISPRIME[2 * i] = 0\n    ISPRIME[1] = 0\n    ISPRIME[2] = 1\n    for i in range(3, SQRTMAXN):\n        if ISPRIME[i]:\n            for j in range(i * i, MAXN + 1, 2 * i):\n                ISPRIME[j] = 0\n    for i in range(3, MAXN + 1, 2):\n        if ISPRIME[i]:\n            PRIMES.append(i)\nsieve()\n\ndef decomp(N):\n    ANS = {}\n    if N < 2:\n        return {}\n    for P in PRIMES:\n        while N % P == 0:\n            ANS[P] = ANS.get(P, 0) + 1\n            N //= P\n        if N == 1:\n            break\n    if N > 1:\n        ANS[N] = 1\n    return ANS\n\ndef divisors(N):\n    if N == 0:\n        return set()\n    D = set()\n    dec = decomp(N)\n    for xxx in itertools.product(*(range(x + 1) for x in dec.values())):\n        M = 1\n        for (p, powa) in zip(dec.keys(), xxx):\n            M *= p ** powa\n        D.add(M)\n    return D\n\ndef issubsequence(subseq, arr):\n    a = 0\n    for s in range(len(subseq)):\n        try:\n            a = arr.index(subseq[s], a) + 1\n        except:\n            return False\n    return True\n\ndef main(N, A):\n    cumS = [0] * N\n    for i in range(N):\n        cumS[i] = cumS[i - 1] + A[i]\n    if cumS[N - 1] == 0:\n        return N - cumS.count(0)\n    if cumS[N - 1] != 0:\n        divi = sorted([d for d in divisors(abs(cumS[N - 1])) if d <= N], reverse=True)\n    else:\n        divi = sorted([d for d in range(1, N + 1)], reverse=True)\n    for d in divi:\n        subseq = [cumS[N - 1] // d * k for k in range(1, d + 1)]\n        if issubsequence(subseq, cumS):\n            return N - d\nT = int(input().strip())\nfor _ in range(T):\n    N = int(input().strip())\n    A = [int(x) for x in input().strip().split()[:N]]\n    print(main(N, A))", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "def cal(x, ps):\n    n = len(ps)\n    mul = 0\n    i = 0\n    while i < n and mul // x < ps[-1] // x:\n        if mul + x == ps[i]:\n            mul += x\n        i += 1\n    cnt = ps[-1] // x if mul == ps[-1] else 1\n    return n - cnt\nfor t in range(int(input().strip())):\n    n = int(input().strip())\n    a = tuple(map(int, input().strip().split()))\n    ps = [a[0]]\n    for i in range(1, n):\n        ps.append(ps[i - 1] + a[i])\n    cnt0 = ps.count(0)\n    ans = n - (cnt0 if ps[-1] == 0 else 1)\n    f = 1\n    while f * f <= abs(ps[-1]):\n        if abs(ps[-1]) % f == 0:\n            ans = min(ans, cal(f * ps[-1] // abs(ps[-1]), ps), cal(ps[-1] // f, ps))\n        f += 1\n    print(ans)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "def poss(res, elem, len):\n    cnt = 0\n    for i in res:\n        if i == elem * (cnt + 1):\n            cnt += 1\n    return cnt >= len\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    res = [sum(ar[:i + 1]) for i in range(len(ar))]\n    s = res[-1]\n    ans = 0\n    if s == 0:\n        cn = res.count(0)\n        ans = n - cn\n    else:\n        sn = 1 if s > 0 else -1\n        s = abs(s)\n        ans = n - 1\n        i = 1\n        while i * i <= s:\n            if s % i != 0:\n                i += 1\n                continue\n            ln1 = i\n            elem1 = s // i * sn\n            ln2 = s // i\n            elem2 = i * sn\n            i += 1\n            if poss(res, elem1, ln1):\n                ans = min(ans, n - ln1)\n            if poss(res, elem2, ln2):\n                ans = min(ans, n - ln2)\n    print(ans)", "def poss(res, elem, len):\n    cnt = 0\n    for i in res:\n        if i == elem * (cnt + 1):\n            cnt += 1\n    return cnt >= len\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    res = [sum(ar[:i + 1]) for i in range(len(ar))]\n    s = res[-1]\n    ans = 0\n    if s == 0:\n        cn = res.count(0)\n        ans = n - cn\n    else:\n        sn = 1 if s > 0 else -1\n        s = abs(s)\n        ans = n - 1\n        i = 1\n        while i * i <= s:\n            if s % i != 0:\n                i += 1\n                continue\n            ln1 = i\n            elem1 = s // i * sn\n            ln2 = s // i\n            elem2 = i * sn\n            i += 1\n            if poss(res, elem1, ln1):\n                ans = min(ans, n - ln1)\n            if poss(res, elem2, ln2):\n                ans = min(ans, n - ln2)\n    print(ans)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "import math\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = sum(a)\n    p = [0] * n\n    p[0] = a[0]\n    for i in range(1, n):\n        p[i] = a[i] + p[i - 1]\n    f = []\n    pos = 1\n    if s < 0:\n        pos = -1\n    for i in range(1, int(math.sqrt(abs(s))) + 1):\n        if s % i == 0:\n            f.append(pos * i)\n            if i != abs(s // i):\n                f.append(s // i)\n    ans = n - 1\n    if s == 0:\n        z = p.count(0)\n        ans = min(ans, n - z)\n    else:\n        for i in range(len(f)):\n            count = 1\n            for j in range(n):\n                if p[j] == f[i] * count:\n                    count = count + 1\n            if abs((count - 1) * f[i]) >= abs(s):\n                ans = min(ans, n - s // f[i])\n    print(ans)", "def poss(res, elem, len):\n    cnt = 0\n    for i in res:\n        if i == elem * (cnt + 1):\n            cnt += 1\n    return cnt >= len\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    res = [sum(ar[:i + 1]) for i in range(len(ar))]\n    s = res[-1]\n    ans = 0\n    if s == 0:\n        cn = res.count(0)\n        ans = n - cn\n    else:\n        sn = 1 if s > 0 else -1\n        s = abs(s)\n        ans = n - 1\n        i = 1\n        while i * i <= s:\n            if s % i != 0:\n                i += 1\n                continue\n            ln1 = i\n            elem1 = s // i * sn\n            ln2 = s // i\n            elem2 = i * sn\n            i += 1\n            if poss(res, elem1, ln1):\n                ans = min(ans, n - ln1)\n            if poss(res, elem2, ln2):\n                ans = min(ans, n - ln2)\n    print(ans)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "import sys\nimport itertools\nMAX = 30000\nSQRTMAX = 175\nISPRIME = [1] * (MAX + 1)\nPRIMES = [2]\n\ndef sieve():\n    for i in range(MAX // 2):\n        ISPRIME[2 * i] = 0\n    ISPRIME[1] = 0\n    ISPRIME[2] = 1\n    for i in range(3, SQRTMAX):\n        if ISPRIME[i]:\n            for j in range(i * i, MAX + 1, 2 * i):\n                ISPRIME[j] = 0\n    for i in range(3, MAX + 1, 2):\n        if ISPRIME[i]:\n            PRIMES.append(i)\nsieve()\n\ndef decomp(N):\n    ANS = {}\n    if N < 2:\n        return {}\n    for P in PRIMES:\n        while N % P == 0:\n            ANS[P] = ANS.get(P, 0) + 1\n            N //= P\n        if N == 1:\n            break\n    if N > 1:\n        ANS[N] = 1\n    return ANS\n\ndef divisors(N):\n    if N == 0:\n        return set()\n    D = set()\n    dec = decomp(N)\n    for xxx in itertools.product(*(range(x + 1) for x in dec.values())):\n        M = 1\n        for (p, powa) in zip(dec.keys(), xxx):\n            M *= p ** powa\n        D.add(M)\n    return D\n\ndef issubsequence(subseq, arr):\n    a = 0\n    for s in range(len(subseq)):\n        try:\n            a = arr.index(subseq[s], a) + 1\n        except:\n            return False\n    return True\n\ndef main(N, A):\n    cumS = [0] * N\n    for i in range(N):\n        cumS[i] = cumS[i - 1] + A[i]\n    if cumS[N - 1] == 0:\n        return N - cumS.count(0)\n    if cumS[N - 1] != 0:\n        divi = sorted([d for d in divisors(abs(cumS[N - 1])) if d <= N], reverse=True)\n    else:\n        divi = sorted([d for d in range(1, N + 1)], reverse=True)\n    for d in divi:\n        subseq = [cumS[N - 1] // d * k for k in range(1, d + 1)]\n        if issubsequence(subseq, cumS):\n            return N - d\nT = int(input().strip())\nfor _ in range(T):\n    N = int(input().strip())\n    A = [int(x) for x in input().strip().split()[:N]]\n    print(main(N, A))", "t = int(float(input()))\nfor _ in range(t):\n    n = int(float(input()))\n    a = list(map(int, input().split()))\n    s = sum(a)\n    prefix_sum = a[:]\n    for i in range(1, n):\n        prefix_sum[i] += prefix_sum[i - 1]\n    if s == 0:\n        c = 0\n        for i in range(n):\n            if prefix_sum[i] != 0:\n                c += 1\n        print(c)\n    else:\n        for i in range(n, 0, -1):\n            if s % i == 0:\n                f = s // i\n                x = f\n                for j in range(n):\n                    if prefix_sum[j] == x:\n                        x += f\n                    if x - f == s:\n                        break\n                if x - f == s:\n                    print(n - i)\n                    break", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "from sys import stdin\nfrom itertools import accumulate\nfrom bisect import bisect\n\ndef makeLPF(f_limit):\n    lpf = [2, 1] * (f_limit // 2 + 1)\n    if f_limit % 2 == 0:\n        lpf.pop()\n    lpf[0:3] = [0, 0, 1]\n    k = 3\n    while k * k <= f_limit:\n        if lpf[k] == 1:\n            for m in range(k * k, f_limit + 1, 2 * k):\n                if lpf[m] == 1:\n                    lpf[m] = k\n        k += 2\n    return lpf\n\ndef factors(num, primes, lim):\n    red = abs(num)\n    fac = [1]\n    if red < 2:\n        return [1]\n    for p in primes[:bisect(primes, lim)]:\n        if red % p == 0:\n            nfac = [1]\n            while red % p == 0:\n                red //= p\n                nfac.append(nfac[-1] * p)\n            fac = [f * n for n in nfac for f in fac]\n        if p > red:\n            break\n    if red > 1 and red <= lim:\n        fac.extend([red * f for f in fac])\n    return sorted(fac)\nLPF = makeLPF(30000)\nprs = [v for (v, lp) in enumerate(LPF) if lp == 1]\ninp = stdin.readline\nT = int(inp())\nfor tx in range(T):\n    N = int(inp())\n    S = list(map(int, inp().split()))\n    acS = list(accumulate(S))\n    tot = acS[-1]\n    if tot == 0:\n        print(N - acS.count(0))\n        continue\n    atot = abs(tot)\n    fails = []\n    best = 1\n    fac = factors(tot, prs, N)\n    if fac[-1] > N:\n        fac = fac[:bisect(fac, N)]\n    for partn in fac[1:]:\n        for f in fails:\n            if partn % f == 0:\n                break\n        else:\n            inc = tot // partn\n            ix = 0\n            for v in range(inc, tot, inc):\n                try:\n                    ix = acS.index(v, ix)\n                except ValueError:\n                    fails.append(partn)\n                    break\n            else:\n                best = partn\n    print(N - best)", "from sys import stdin\nfrom itertools import accumulate\nfrom bisect import bisect\n\ndef makeLPF(f_limit):\n    lpf = [2, 1] * (f_limit // 2 + 1)\n    if f_limit % 2 == 0:\n        lpf.pop()\n    lpf[0:3] = [0, 0, 1]\n    k = 3\n    while k * k <= f_limit:\n        if lpf[k] == 1:\n            for m in range(k * k, f_limit + 1, 2 * k):\n                if lpf[m] == 1:\n                    lpf[m] = k\n        k += 2\n    return lpf\n\ndef factors(num, primes):\n    red = abs(num)\n    fac = [1]\n    if red < 2:\n        return [1]\n    for p in primes:\n        if red % p == 0:\n            nfac = [1]\n            while red % p == 0:\n                red //= p\n                nfac.append(nfac[-1] * p)\n            fac = [f * n for n in nfac for f in fac]\n        if p > red:\n            break\n    if red > 1:\n        fac.extend([red * f for f in fac])\n    return sorted(fac)\nLPF = makeLPF(30000)\nprs = [v for (v, lp) in enumerate(LPF) if lp == 1]\ninp = stdin.readline\nT = int(inp())\nfor tx in range(T):\n    N = int(inp())\n    S = list(map(int, inp().split()))\n    acS = list(accumulate(S))\n    tot = acS[-1]\n    if tot == 0:\n        print(N - acS.count(0))\n        continue\n    atot = abs(tot)\n    fails = []\n    best = 1\n    fac = factors(tot, prs)\n    if fac[-1] > N:\n        fac = fac[:bisect(fac, N)]\n    for partn in fac[1:]:\n        for f in fails:\n            if partn % f == 0:\n                break\n        else:\n            inc = tot // partn\n            ix = 0\n            for v in range(inc, tot, inc):\n                try:\n                    ix = acS.index(v, ix)\n                except ValueError:\n                    fails.append(partn)\n                    break\n            else:\n                best = partn\n    print(N - best)", "from sys import stdin\nfrom itertools import accumulate\n\ndef makeLPF(f_limit):\n    lpf = [2, 1] * (f_limit // 2 + 1)\n    if f_limit % 2 == 0:\n        lpf.pop()\n    lpf[0:3] = [0, 0, 1]\n    k = 3\n    while k * k <= f_limit:\n        if lpf[k] == 1:\n            for m in range(k * k, f_limit + 1, 2 * k):\n                if lpf[m] == 1:\n                    lpf[m] = k\n        k += 2\n    return lpf\n\ndef factors(num, primes):\n    red = abs(num)\n    fac = [1]\n    if red < 2:\n        return [1]\n    for p in primes:\n        if red % p == 0:\n            nfac = [1]\n            while red % p == 0:\n                red //= p\n                nfac.append(nfac[-1] * p)\n            fac = [f * n for n in nfac for f in fac]\n        if p > red:\n            break\n    if red > 1:\n        fac.extend([red * f for f in fac])\n    return sorted(fac)\nLPF = makeLPF(30000)\nprs = [v for (v, lp) in enumerate(LPF) if lp == 1]\ninp = stdin.readline\nT = int(inp())\nfor tx in range(T):\n    N = int(inp())\n    S = list(map(int, inp().split()))\n    acS = list(accumulate(S))\n    tot = acS[-1]\n    if tot == 0:\n        print(N - acS.count(0))\n        continue\n    atot = abs(tot)\n    fails = []\n    best = 1\n    fac = factors(tot, prs)\n    while fac[-1] > N:\n        fac.pop()\n    for partn in fac[1:]:\n        for f in fails:\n            if partn % f == 0:\n                break\n        else:\n            inc = tot // partn\n            ix = 0\n            for v in range(inc, tot, inc):\n                try:\n                    ix = acS.index(v, ix)\n                except ValueError:\n                    fails.append(partn)\n                    break\n            else:\n                best = partn\n    print(N - best)", "from sys import stdin\nfrom itertools import accumulate\ninp = stdin.readline\nT = int(inp())\nfor tx in range(T):\n    N = int(inp())\n    accA = list(accumulate(map(int, inp().split())))\n    tot = accA[-1]\n    if tot == 0:\n        print(N - accA.count(0))\n        continue\n    atot = abs(tot)\n    partn = min(N, atot)\n    fails = []\n    best = 1\n    for partn in range(2, min(N, atot) + 1):\n        if tot % partn == 0:\n            for f in fails:\n                if partn % f == 0:\n                    break\n            else:\n                inc = tot // partn\n                ix = 0\n                for v in range(inc, tot, inc):\n                    try:\n                        ix = accA.index(v, ix)\n                    except ValueError:\n                        fails.append(partn)\n                        break\n                else:\n                    best = partn\n    print(N - best)", "from sys import stdin\nfrom itertools import accumulate\ninp = stdin.readline\nT = int(inp())\nfor tx in range(T):\n    N = int(inp())\n    acS = list(accumulate(map(int, inp().split())))\n    tot = acS[-1]\n    if tot == 0:\n        print(N - acS.count(0))\n        continue\n    atot = abs(tot)\n    partn = min(N, atot)\n    fails = []\n    cof = [] if atot > N else [atot]\n    best = 1\n    for partn in range(2, N + 1):\n        if tot % partn == 0:\n            for f in fails:\n                if partn % f == 0:\n                    break\n            else:\n                inc = tot // partn\n                ix = 0\n                for v in range(inc, tot, inc):\n                    try:\n                        ix = acS.index(v, ix)\n                    except ValueError:\n                        fails.append(partn)\n                        break\n                else:\n                    best = partn\n    print(N - best)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = []\n    s = 0\n    for i in range(n):\n        s += a[i]\n        b.append(s)\n    if s == 0:\n        c = 0\n        for i in range(n):\n            if b[i] != 0:\n                c += 1\n        print(c)\n    else:\n        for i in range(n, 0, -1):\n            if s % i == 0:\n                d = s // i\n                e = d\n                for j in range(n):\n                    if b[j] == e:\n                        e += d\n                    if e - d == s:\n                        break\n                if e - d == s:\n                    print(n - i)\n                    break", "import math\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = sum(a)\n    p = [0] * n\n    p[0] = a[0]\n    for i in range(1, n):\n        p[i] = a[i] + p[i - 1]\n    f = []\n    pos = 1\n    if s < 0:\n        pos = -1\n    for i in range(1, int(math.sqrt(abs(s))) + 1):\n        if s % i == 0:\n            f.append(pos * i)\n            if i != abs(s // i):\n                f.append(s // i)\n    ans = n - 1\n    if s == 0:\n        z = p.count(0)\n        ans = min(ans, n - z)\n    else:\n        for i in range(len(f)):\n            count = 1\n            for j in range(n):\n                if p[j] == f[i] * count:\n                    count = count + 1\n            if abs((count - 1) * f[i]) >= abs(s):\n                ans = min(ans, n - s // f[i])\n    print(ans)", "def partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nx = int(input())\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "def func(n, arr):\n    total = sum(arr)\n    if total == 0:\n        a = [arr[0]]\n        for i in range(1, n):\n            a.append(a[i - 1] + arr[i])\n        i = a.index(total)\n        moves = i\n        curr = i\n        for j in range(i + 1, n):\n            if a[j] == total:\n                moves += j - curr - 1\n                curr = j\n        return moves\n    curr = 0\n    d = {}\n    for i in range(n):\n        curr += arr[i]\n        if d.get(curr) == None:\n            d[curr] = [i]\n        else:\n            d[curr].append(i)\n    for i in range(n, 0, -1):\n        if total % i == 0:\n            num = total // i\n            curr = total\n            index = n\n            while curr != 0:\n                if d.get(curr) != None:\n                    found = False\n                    for j in range(len(d[curr]) - 1, -1, -1):\n                        if d[curr][j] < index:\n                            index = d[curr][j]\n                            found = True\n                            break\n                    if not found:\n                        break\n                    curr -= num\n                else:\n                    break\n            if curr == 0:\n                return n - i\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(func(n, arr))", "from sys import stdin\nfrom itertools import accumulate\ninp = stdin.readline\nT = int(inp())\nfor tx in range(T):\n    N = int(inp())\n    S = list(map(int, inp().split()))\n    acS = list(accumulate(S))\n    tot = acS[-1]\n    if tot == 0:\n        print(N - acS.count(0))\n        continue\n    atot = abs(tot)\n    partn = min(N, atot)\n    while partn > 1:\n        if tot % partn == 0:\n            inc = tot // partn\n            ix = 0\n            for v in range(inc, tot, inc):\n                try:\n                    ix = acS.index(v, ix)\n                except ValueError:\n                    break\n            else:\n                break\n        partn = atot // (1 + atot // partn)\n    print(N - partn)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "T = int(input())\nfor _ in range(T):\n    n = int(input())\n    A = list(map(int, input().split()))\n    SUM = sum(A)\n    op = -1\n    for i in range(n, 0, -1):\n        if SUM % i == 0:\n            if SUM != 0:\n                target = SUM // i\n                SS = SUM\n                j = 0\n                sd = 0\n                flag = 0\n                while j < n:\n                    if sd + A[j] == target:\n                        SS = SS - (sd + A[j])\n                        flag += 1\n                        sd = 0\n                        if SS == 0:\n                            break\n                    else:\n                        sd += A[j]\n                    j += 1\n                if flag * target == SUM:\n                    op = n - flag\n                    break\n            else:\n                target = SUM // i\n                j = 0\n                sd = 0\n                flag = 0\n                while j < n:\n                    sd += A[j]\n                    if sd == target:\n                        flag += 1\n                        sd = 0\n                    j += 1\n                if flag * target == SUM:\n                    op = n - flag\n                    break\n    if op != -1:\n        print(op)", "T = int(input())\nfor _ in range(T):\n    n = int(input())\n    A = list(map(int, input().split()))\n    SUM = sum(A)\n    op = -1\n    for i in range(n, 0, -1):\n        if SUM % i == 0:\n            if SUM != 0:\n                target = SUM // i\n                SS = SUM\n                j = 0\n                sd = 0\n                flag = 0\n                while j < n:\n                    if sd + A[j] == target and (SS - (sd + A[j])) % target == 0:\n                        SS = SS - (sd + A[j])\n                        flag += 1\n                        sd = 0\n                        if SS == 0:\n                            break\n                    else:\n                        sd += A[j]\n                    j += 1\n                if flag * target == SUM:\n                    op = n - flag\n                    break\n            else:\n                target = SUM // i\n                j = 0\n                sd = 0\n                flag = 0\n                while j < n:\n                    sd += A[j]\n                    if sd == target:\n                        flag += 1\n                        sd = 0\n                    j += 1\n                if flag * target == SUM:\n                    op = n - flag\n                    break\n    if op != -1:\n        print(op)", "from math import floor\n\ndef split_possible(n, arr, n1):\n    ss_sum = sum(arr) // n1\n    (ss, ss_len) = ([], 0)\n    curr = 0\n    for i in range(n):\n        curr += arr[i]\n        if curr == ss_sum and ss_len < n1:\n            ss.append(curr)\n            curr = 0\n            ss_len += 1\n    if sum(ss) != ss_sum * n1 or curr != 0:\n        return False\n    return True\n\ndef zero_possible(n, arr):\n    (ss, ss_len) = ([], 0)\n    curr = 'NA'\n    for i in range(n):\n        curr = curr + arr[i] if curr != 'NA' else arr[i]\n        if curr == 0:\n            ss.append(curr)\n            curr = 'NA' if i != n - 1 else 'FIN'\n            ss_len += 1\n    if curr == 'FIN':\n        return (True, ss_len)\n    return (False, -1)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    s = abs(sum(arr))\n    if arr == [arr[0]] * n:\n        print(0)\n    elif n == 2:\n        print(1)\n    else:\n        k = 1\n        lim = floor(s ** 0.5) + 1\n        if s != 0:\n            for el in range(1, min(lim, n) + 1):\n                if s % el == 0:\n                    if split_possible(n, arr, el):\n                        k = max(k, el)\n                    if s // el <= n and split_possible(n, arr, s // el):\n                        k = max(k, s // el)\n        if s == 0:\n            (f, v) = zero_possible(n, arr)\n            if f:\n                k = max(k, v)\n        print(n - k)", "t = int(input())\nfor y in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    print(len(arr) - main_count)", "x = int(input())\n\ndef partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    d = {}\n    d_len = 0\n    s = sum(l)\n    for i in range(1, int(math.sqrt(abs(s))) + 1):\n        if s % i == 0:\n            if s < 0:\n                r = -1\n            else:\n                r = 1\n            if abs(s) // i <= n:\n                d[r * i] = abs(s // i)\n                d_len += 1\n            if abs(i) <= n and i != s // i:\n                d[s // i] = abs(i)\n                d_len += 1\n    if s > 0:\n        d = {k: v for (k, v) in sorted(d.items(), key=lambda x: x[0])}\n    else:\n        d = {k: v for (k, v) in sorted(d.items(), reverse=True, key=lambda x: x[0])}\n    if d == {}:\n        count = 0\n        for i in range(n - 1):\n            if l[i] != 0:\n                l[i + 1] = l[i] + l[i + 1]\n                count += 1\n        if l[-1] != 0:\n            count += 1\n        print(count)\n    elif d_len == 1:\n        (a, b) = d.popitem()\n        print(n - b)\n    else:\n        flag = False\n        for (i, j) in d.items():\n            k = l[:]\n            count = 0\n            for x in range(n - 1):\n                if k[x] != i:\n                    k[x + 1] = k[x] + k[x + 1]\n                    count += 1\n            if k[-1] != i:\n                count += 1\n            if count <= n - j:\n                print(n - j)\n                flag = True\n                break", "import sys\nimport itertools\nMAXN = 30000\nSQRTMAXN = 175\nISPRIME = [1] * (MAXN + 1)\nPRIMES = [2]\n\ndef sieve():\n    for i in range(MAXN // 2):\n        ISPRIME[2 * i] = 0\n    ISPRIME[1] = 0\n    ISPRIME[2] = 1\n    for i in range(3, SQRTMAXN):\n        if ISPRIME[i]:\n            for j in range(i * i, MAXN + 1, 2 * i):\n                ISPRIME[j] = 0\n    for i in range(3, MAXN + 1, 2):\n        if ISPRIME[i]:\n            PRIMES.append(i)\nsieve()\n\ndef decomp(N):\n    ANS = {}\n    if N < 2:\n        return {}\n    for P in PRIMES:\n        while N % P == 0:\n            ANS[P] = ANS.get(P, 0) + 1\n            N //= P\n        if N == 1:\n            break\n    if N > 1:\n        ANS[N] = 1\n    return ANS\n\ndef divisors(N):\n    if N == 0:\n        return set()\n    D = set()\n    dec = decomp(N)\n    for xxx in itertools.product(*(range(x + 1) for x in dec.values())):\n        M = 1\n        for (p, powa) in zip(dec.keys(), xxx):\n            M *= p ** powa\n        D.add(M)\n    return D\n\ndef issubsequence(subseq, arr):\n    a = 0\n    for s in range(len(subseq)):\n        try:\n            a = arr.index(subseq[s], a) + 1\n        except:\n            return False\n    return True\n\ndef main(N, A):\n    cumS = [0] * N\n    for i in range(N):\n        cumS[i] = cumS[i - 1] + A[i]\n    if cumS[N - 1] == 0:\n        return N - cumS.count(0)\n    if cumS[N - 1] != 0:\n        divi = sorted([d for d in divisors(abs(cumS[N - 1])) if d <= N], reverse=True)\n    else:\n        divi = sorted([d for d in range(1, N + 1)], reverse=True)\n    for d in divi:\n        subseq = [cumS[N - 1] // d * k for k in range(1, d + 1)]\n        if issubsequence(subseq, cumS):\n            return N - d\nT = int(input().strip())\nfor _ in range(T):\n    N = int(input().strip())\n    A = [int(x) for x in input().strip().split()[:N]]\n    print(main(N, A))", "NEG = -10 ** 9 - 7\n\ndef factors(n):\n    neg = False\n    if n < 0:\n        neg = True\n        n = abs(n)\n    ret = set()\n    if n == 0:\n        ret.add(0)\n        return ret\n    for i in range(1, n, 1):\n        if i * i > n:\n            break\n        if n % i == 0:\n            ret.add(i)\n            ret.add(int(n / i))\n    if neg:\n        nret = set()\n        for i in ret:\n            nret.add(0 - i)\n        return nret\n    return ret\n\ndef checkComb(a, sm):\n    ts = NEG\n    sec = 0\n    for i in range(len(a)):\n        if ts == NEG:\n            ts = 0\n        ts += a[i]\n        if ts == sm:\n            sec += 1\n            ts = NEG\n    if ts == NEG or ts == 0:\n        return len(a) - sec\n    if ts % abs(sm) == 0:\n        mul = int(abs(ts) / abs(sm))\n        if sm * mul == ts:\n            return -1\n        return len(a) - (sec - mul)\n    return -1\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    sm = sum(a)\n    ans = len(a) - 1\n    if len(a) <= 1:\n        print('0')\n        continue\n    fac = factors(sm)\n    for f in fac:\n        st = checkComb(a, f)\n        if st >= 0 and st < ans:\n            ans = st\n    print(int(ans))", "x = int(input())\n\ndef partitions2(array, n, K):\n    if e % K != 0:\n        return False\n    temp = 0\n    count = n - K\n    c = False\n    imp = True\n    cursum = 0\n    for i in range(n):\n        if count < 0:\n            imp = False\n            break\n        if cursum + array[i] == e / K and temp <= K:\n            temp += 1\n            c = False\n            cursum = 0\n        elif cursum + array[i] == -e / K and temp > K:\n            temp = temp - 1\n            c = False\n            cursum = 0\n        else:\n            cursum += array[i]\n        if c:\n            count = count - 1\n        c = True\n    if count < 0:\n        imp = False\n    return temp == K and imp\nfor i in range(x):\n    N = int(input())\n    l = list(map(int, input().split()))\n    e = sum(l)\n    for i in range(N, 0, -1):\n        k = i\n        if partitions2(l, N, k):\n            val = k\n            break\n    print(N - val)", "from typing import List\n\ndef contains(l1: List[int], l2: List[int]) -> bool:\n    (i, j) = (0, 0)\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            i += 1\n            j += 1\n        else:\n            j += 1\n    return i == len(l1)\n\ndef solve(t):\n    N = int(input())\n    A = list(map(int, input().split()))\n    answer = N - 1\n    total = sum(A)\n    prefix_sum_A = [a for a in A]\n    for i in range(1, N):\n        prefix_sum_A[i] += prefix_sum_A[i - 1]\n    for target_length in reversed(range(2, N + 1)):\n        if total % target_length == 0:\n            target_value = total // target_length\n            prefix_sums = [i * target_value for i in range(1, target_length + 1)]\n            if contains(prefix_sums, prefix_sum_A):\n                answer = N - target_length\n                break\n    print(answer)\nT = int(input())\nfor t in range(T):\n    solve(t + 1)", "def func(n, arr):\n    total = sum(arr)\n    if total == 0:\n        a = [arr[0]]\n        for i in range(1, n):\n            a.append(a[i - 1] + arr[i])\n        i = a.index(total)\n        moves = i\n        curr = i\n        for j in range(i + 1, n):\n            if a[j] == total:\n                moves += j - curr - 1\n                curr = j\n        return moves\n    curr = 0\n    d = {}\n    for i in range(n):\n        curr += arr[i]\n        if d.get(curr) == None:\n            d[curr] = [i]\n        else:\n            d[curr].append(i)\n    for i in range(n, 0, -1):\n        if total % i == 0:\n            num = total // i\n            curr = total\n            index = n\n            while curr != 0:\n                if d.get(curr) != None:\n                    found = False\n                    for j in range(len(d[curr]) - 1, -1, -1):\n                        if d[curr][j] < index:\n                            index = d[curr][j]\n                            found = True\n                            break\n                    if not found:\n                        break\n                    curr -= num\n                else:\n                    break\n            if curr == 0:\n                return n - i\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(func(n, arr))", "from itertools import accumulate\n\ndef check_valid(acc, ind, i):\n    res = ind\n    ind += 1\n    mult = 2\n    sm = acc[-1]\n    try:\n        while ind < len(acc) and abs(i * mult) <= abs(sm):\n            ind2 = acc.index(i * mult, ind)\n            res += ind2 - ind\n            mult += 1\n            ind = ind2 + 1\n        res += len(acc) - ind\n        return res\n    except ValueError:\n        return -1\nfor _ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split()))\n    acc = list(accumulate(li))\n    acc_set = set(acc)\n    sm = acc[-1]\n    ans = []\n    if sm != 0:\n        for (ind, i) in enumerate(acc):\n            if i != 0 and sm % i == 0 and (sm * i > 0) and (set(range(i, sm + 1, i)) - acc_set == set()):\n                res = check_valid(acc, ind, i)\n                if res != -1:\n                    ans.append(res)\n        print(min(ans))\n    else:\n        ind = acc.index(0)\n        res = check_valid(acc, ind, 0)\n        print(res)", "from itertools import accumulate\n\ndef check_valid(acc, ind, i):\n    res = ind\n    ind += 1\n    mult = 2\n    sm = acc[-1]\n    try:\n        while ind < len(acc) and abs(i * mult) <= abs(sm):\n            ind2 = acc.index(i * mult, ind)\n            res += ind2 - ind\n            mult += 1\n            ind = ind2 + 1\n        res += len(acc) - ind\n        return res\n    except ValueError:\n        return -1\nfor _ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split()))\n    acc = list(accumulate(li))\n    acc_set = set(acc)\n    sm = acc[-1]\n    ans = []\n    if sm != 0:\n        for (ind, i) in enumerate(acc):\n            if i != 0 and sm % i == 0 and (sm * i > 0) and (set(range(i, sm + 1, i)) - acc_set == set()):\n                res = check_valid(acc, ind, i)\n                if res != -1:\n                    ans.append(res)\n        print(min(ans))\n    else:\n        ind = acc.index(0)\n        res = check_valid(acc, ind, 0)\n        print(res)", "from math import sqrt\nfrom sys import stdin\ninput = stdin.readline\n\ndef factors(n):\n    f = set()\n    step = 2 if n % 2 == 1 else 1\n    for x in range(1, int(sqrt(n)) + 1, step):\n        (q, r) = divmod(n, x)\n        if r == 0:\n            f.add(x)\n            f.add(q)\n    return f\n\ndef solve(N, A):\n    total = sum(A)\n    if total == 0:\n        count = 0\n        subtotal = 0\n        for a in A:\n            if subtotal + a != 0:\n                subtotal += a\n                count += 1\n            else:\n                subtotal = 0\n        assert subtotal == 0\n        return count\n    else:\n        sign = 1 if total >= 0 else -1\n        total = abs(total)\n        divs = factors(total)\n        minimum = N - 1\n        for d in divs:\n            if total // d <= N:\n                count = 0\n                subtotal = 0\n                number = 0\n                for a in A:\n                    if subtotal + a != sign * d or number == total // d:\n                        subtotal += a\n                        count += 1\n                    else:\n                        subtotal = 0\n                        number += 1\n                if subtotal == 0:\n                    minimum = min(minimum, count)\n                    assert number == total // d\n        return minimum\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    N = int(input().strip())\n    A = [int(x) for x in input().strip().split()]\n    print(solve(N, A))", "import sys\ninput = sys.stdin.readline\n\ndef check(part_sum, k, A):\n    curr_sum = None\n    for (i, a) in enumerate(A):\n        curr_sum = (0 if curr_sum is None else curr_sum) + a\n        if k > 1 and curr_sum == part_sum:\n            curr_sum = None\n            k -= 1\n    return k == 1 and curr_sum == part_sum\nfor _ in range(int(input().strip())):\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    prefix = [0] * (N + 1)\n    for (i, a) in enumerate(A):\n        prefix[i + 1] = a + prefix[i]\n    total = prefix[-1]\n    for k in reversed(range(1, N + 1)):\n        if total % k != 0:\n            continue\n        part_sum = total // k\n        if check(part_sum, k, A):\n            print(N - k)\n            break"]