["def SoE(n):\n    a = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            a.append(p)\n    return (prime, a)\n\ndef binary_search(l, r, a, tar):\n    if l > r:\n        return -1\n    m = (l + r) // 2\n    if a[m] == tar:\n        return m\n    elif a[m] < tar:\n        return binary_search(m + 1, r, a, tar)\n    else:\n        return binary_search(l, m - 1, a, tar)\nt = int(input())\n(a, b) = SoE(100000)\nfor _ in range(t):\n    n = int(input())\n    i = n - 1\n    while a[i] == False:\n        i -= 1\n    p = i\n    left = n\n    curr = binary_search(0, len(b) - 1, b, p)\n    value = n * p\n    ans = 0\n    while left > 0:\n        num = value // b[curr]\n        if b[curr] == 2:\n            pass\n        elif num % 2 == 1:\n            num = num - 1\n        if left - num >= 0:\n            left -= num\n            ans = num * b[curr]\n            curr = curr - 1\n        elif b[curr] == 2:\n            ans = ans + b[curr] * left\n            left = 0\n        elif left % 2 == 1:\n            ans = ans + b[curr] * (left - 1)\n            left = 1\n            curr = curr - 1\n        else:\n            ans = ans + b[curr] * left\n            left = 0\n            curr = curr - 1\n    print(ans // 2)", "def SoE(n):\n    a = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            a.append(p)\n    return (prime, a)\n\ndef binary_search(l, r, a, tar):\n    if l > r:\n        return -1\n    m = (l + r) // 2\n    if a[m] == tar:\n        return m\n    elif a[m] < tar:\n        return binary_search(m + 1, r, a, tar)\n    else:\n        return binary_search(l, m - 1, a, tar)\nt = int(input())\n(a, b) = SoE(100000)\nfor _ in range(t):\n    n = int(input())\n    i = n - 1\n    while a[i] == False:\n        i -= 1\n    p = i\n    left = n\n    curr = binary_search(0, len(b) - 1, b, p)\n    value = n * p\n    ans = 0\n    while left > 0:\n        num = value // b[curr]\n        if b[curr] == 2:\n            pass\n        elif num % 2 == 1:\n            num = num - 1\n        if left - num >= 0:\n            left -= num\n            ans = num * b[curr]\n            curr = curr - 1\n        elif b[curr] == 2:\n            ans = ans + b[curr] * left\n            left = 0\n        elif left % 2 == 1:\n            ans = ans + b[curr] * (left - 1)\n            left = 1\n            curr = curr - 1\n        else:\n            ans = ans + b[curr] * left\n            left = 0\n            curr = curr - 1\n    print(ans // 2)", "def SoE(n):\n    a = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            a.append(p)\n    return (prime, a)\n\ndef binary_search(l, r, a, tar):\n    if l > r:\n        return -1\n    m = (l + r) // 2\n    if a[m] == tar:\n        return m\n    elif a[m] < tar:\n        return binary_search(m + 1, r, a, tar)\n    else:\n        return binary_search(l, m - 1, a, tar)\nt = int(input())\n(a, b) = SoE(100000)\nfor _ in range(t):\n    n = int(input())\n    i = n - 1\n    while a[i] == False:\n        i -= 1\n    p = i\n    left = n\n    curr = binary_search(0, len(b) - 1, b, p)\n    value = n * p\n    ans = 0\n    while left > 0:\n        num = value // b[curr]\n        if b[curr] == 2:\n            pass\n        elif num % 2 == 1:\n            num = num - 1\n        if left - num >= 0:\n            left -= num\n            ans = num * b[curr]\n            curr = curr - 1\n        elif b[curr] == 2:\n            ans = ans + b[curr] * left\n            left = 0\n        elif left % 2 == 1:\n            ans = ans + b[curr] * (left - 1)\n            left = 1\n            curr = curr - 1\n        else:\n            ans = ans + b[curr] * left\n            left = 0\n            curr = curr - 1\n    print(ans // 2)", "import sys\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef isprime(x):\n    y = 1\n    i = 3\n    while i <= x ** 0.5:\n        if x % i == 0:\n            y = 0\n            break\n        i += 2\n    return y\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 3:\n        print(3)\n        continue\n    tmp = n - 1 if n % 2 == 0 else n - 2\n    while not isprime(tmp):\n        tmp -= 2\n    if n * tmp % 2 == 0:\n        print(n * tmp // 2)\n    else:\n        print(((n - 1) * tmp + 2) // 2)", "p = [1] * 100005\np[0] = 0\np[1] = 0\nfor i in range(2, int(100005 ** 0.5) + 1):\n    if p[i]:\n        for j in range(i + i, 100005, i):\n            p[j] = 0\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    for i in range(100005):\n        if i < n:\n            if p[i]:\n                lp = i\n        else:\n            break\n    t = n * lp\n    if t % 2:\n        print(((n - 1) * lp + 2) // 2)\n    else:\n        print(t // 2)", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random\nfrom functools import lru_cache\nfrom itertools import *\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n(M, M1) = (1000000007, 998244353)\n\ndef sieve():\n    prime = [True] * (10 ** 5 + 1)\n    (prime[0], prime[1]) = (False, False)\n    for i in range(2, int(math.sqrt(10 ** 5 + 1)) + 1):\n        if prime[i] == True:\n            for j in range(i * i, 10 ** 5 + 1, i):\n                prime[j] = False\n    return prime\nd = sieve()\nres = []\nfor i in range(10 ** 5 + 1):\n    if d[i]:\n        res.append(i)\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for _ in range(how_much_noob_I_am):\n        n = inpu()\n        idx = bisect.bisect_left(res, n) - 1\n        val = res[idx] - 2\n        if n & 1:\n            print(n + (n - 1) // 2 * val)\n        else:\n            print(n + n // 2 * val)\nmain()", "def snek(x):\n    for j in range(2, x):\n        if x % j == 0:\n            return False\n    return True\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    c = 0\n    for j in range(n - 1, 1, -1):\n        if snek(j):\n            c = j\n            break\n    if n % 2 == 0:\n        ans = n * c // 2\n    else:\n        ans = ((n - 1) * c + 2) // 2\n    print(ans)", "def prime(a):\n    for i in range(2, a):\n        if a % i == 0:\n            return False\n    return True\nfor i in range(int(input())):\n    n = int(input())\n    p = 0\n    for i in range(n - 1, 1, -1):\n        if prime(i):\n            p = i\n            break\n    if n % 2 == 0:\n        ans = n * p // 2\n    else:\n        ans = ((n - 1) * p + 2) // 2\n    print(ans)", "def prime(a):\n    for i in range(2, a):\n        if a % i == 0:\n            return False\n    return True\nfor i in range(int(input())):\n    n = int(input())\n    p = 0\n    for i in range(n - 1, 1, -1):\n        if prime(i):\n            p = i\n            break\n    if n % 2 == 0:\n        ans = n * p // 2\n    else:\n        ans = ((n - 1) * p + 2) // 2\n    print(ans)", "n = 10 ** 6\n\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\nprime = SieveOfEratosthenes(n)\nt = int(input())\nfor i in range(t):\n    nodes = int(input())\n    l_prime = nodes - 1\n    while not prime[l_prime]:\n        l_prime -= 1\n    if nodes % 2 == 0:\n        deg_sum = l_prime * nodes\n    else:\n        deg_sum = l_prime * (nodes - 1) + 2\n    print(deg_sum // 2)", "def SoE(n):\n    a = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            a.append(p)\n    return (prime, a)\n\ndef binary_search(l, r, a, tar):\n    if l > r:\n        return -1\n    m = (l + r) // 2\n    if a[m] == tar:\n        return m\n    elif a[m] < tar:\n        return binary_search(m + 1, r, a, tar)\n    else:\n        return binary_search(l, m - 1, a, tar)\nt = int(input())\n(a, b) = SoE(100000)\nfor _ in range(t):\n    n = int(input())\n    i = n - 1\n    while a[i] == False:\n        i -= 1\n    p = i\n    left = n\n    curr = binary_search(0, len(b) - 1, b, p)\n    value = n * p\n    ans = 0\n    while left > 0:\n        num = value // b[curr]\n        if b[curr] == 2:\n            pass\n        elif num % 2 == 1:\n            num = num - 1\n        if left - num >= 0:\n            left -= num\n            ans = num * b[curr]\n            curr = curr - 1\n        elif b[curr] == 2:\n            ans = ans + b[curr] * left\n            left = 0\n        elif left % 2 == 1:\n            ans = ans + b[curr] * (left - 1)\n            left = 1\n            curr = curr - 1\n        else:\n            ans = ans + b[curr] * left\n            left = 0\n            curr = curr - 1\n    print(ans // 2)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    primes = []\n    for p in range(n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes\n\ndef lowerBound(ls, key):\n    lowerInd = 0\n    while lowerInd < len(ls):\n        if key > ls[lowerInd]:\n            lowerInd += 1\n        else:\n            return lowerInd\n    return lowerInd\nt = int(input())\nprimes = SieveOfEratosthenes(10 ** 6 + 1)\nfor _ in range(t):\n    n = int(input())\n    ind = lowerBound(primes, n)\n    if primes[ind] > n - 1:\n        ind -= 1\n    max = n * primes[ind]\n    if max % 2 == 1:\n        max = primes[ind] * (n - 1) + 2\n    print(max // 2)", "def ss(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(n, 1, -1):\n        if prime[p]:\n            return p\nfor _ in range(int(input())):\n    n = int(input())\n    if not n % 2:\n        print(ss(n - 1) * n // 2)\n    else:\n        print(ss(n - 1) * (n - 1) // 2 + 1)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            f.append(p)\n\ndef bs(val, n):\n    (l, r) = (0, n - 1)\n    ans = 0\n    while l <= r:\n        mid = l + (r - l) // 2\n        c = f[mid]\n        if c == val:\n            return val\n        elif c > val:\n            r = mid - 1\n        else:\n            ans = max(ans, f[mid])\n            l = mid + 1\n    return ans\nf = []\nSieveOfEratosthenes(10 ** 5 + 10)\nl = len(f)\nfor i in range(int(input())):\n    n = int(input())\n    v = bs(n - 1, l)\n    if n & 1:\n        ans = (n - 1) * v // 2\n        ans += 1\n    else:\n        ans = n * v // 2\n    print(ans)", "prime_table = []\n\ndef sieve(limit):\n    global prime_table\n    prime_table = [False, False, True] + [True, False] * (limit // 2 + 1)\n    for i in range(3, int(limit ** 0.5) + 1, 2):\n        if prime_table[i]:\n            for j in range(i * i, limit + 1, i * 2):\n                prime_table[j] = False\n\ndef isPrime(num):\n    global prime_table\n    return prime_table[num]\nsieve(pow(10, 6))\nfor _ in range(int(input())):\n    n = int(input())\n    largest_prime = n - 1\n    while not isPrime(largest_prime):\n        largest_prime -= 1\n    total = n * largest_prime\n    if total % 2 == 1:\n        total = (n - 1) * largest_prime + 2\n    print(total // 2)", "from bisect import bisect, bisect_left\nfrom math import ceil\n\ndef seive_of_eratosthenes(n):\n    is_prime = [True for _ in range(n + 1)]\n    (is_prime[0], is_prime[1]) = (False, False)\n    for i in range(2, int(n ** 0.5) + 1):\n        for j in range(2 * i, n + 1, i):\n            is_prime[j] = False\n    res = []\n    for i in range(2, n):\n        if is_prime[i]:\n            res.append(i)\n    return res\np = seive_of_eratosthenes(10 ** 5 + 10)\nfor _ in range(int(input())):\n    n = int(input())\n    a = bisect_left(p, n - 1)\n    if p[a] != n - 1:\n        a -= 1\n    v = p[a]\n    if n % 2 == 0:\n        print(n // 2 * v)\n    else:\n        print((n - 1) // 2 * v + 1)", "import math\n\ndef fun(n):\n    if n == 2:\n        return False\n    a = int(math.sqrt(n))\n    for i in range(2, a + 2):\n        if n % i == 0:\n            return True\n    return False\nfor _ in range(int(input())):\n    n = int(input())\n    e = n - 1\n    while fun(e):\n        e -= 1\n    if n & 1 == 0:\n        print(n * e // 2)\n    else:\n        print((n - 1) * e // 2 + 1)", "import math\n\ndef fun(n):\n    if n == 2:\n        return False\n    a = int(math.sqrt(n))\n    for i in range(2, a + 2):\n        if n % i == 0:\n            return True\n    return False\nfor _ in range(int(input())):\n    n = int(input())\n    e = n - 1\n    while fun(e):\n        e -= 1\n    if n & 1 == 0:\n        print(n * e // 2)\n    else:\n        print((n - 1) * e // 2 + 1)", "from math import sqrt\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef getprime(n):\n    if isPrime(n):\n        return n\n    return getprime(n - 1)\nfor _ in range(int(input())):\n    n = int(input())\n    val = getprime(n - 1)\n    ans = n * val\n    if ans % 2 != 0:\n        ans = (n - 1) * val + 2\n    print(ans // 2)", "from sys import stdin\ninput = stdin.readline\nsize = 2 * 10 ** 5 + 1\nisprime = [True] * size\nisprime[0] = False\nisprime[1] = False\nprime = []\nfor i in range(2, size):\n    if isprime[i]:\n        for j in range(i + i, size, i):\n            isprime[j] = False\n        prime.append(i)\n\ndef answer():\n    for i in range(len(prime)):\n        if prime[i] > n - 1:\n            p = prime[i - 1]\n            break\n    if n & 1 == 0:\n        ans = n * p // 2\n    else:\n        ans = (n - 1) * p // 2 + 1\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    print(answer())", "from bisect import bisect_left as bl\na = []\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            a.append(p)\nsieve(10 ** 5)\nfor _ in range(int(input())):\n    n = int(input())\n    t = bl(a, n - 1)\n    if t >= len(a) or a[t] > n - 1:\n        t -= 1\n    deg = a[t]\n    if n % 2:\n        print((deg * (n - 1) + 2) // 2)\n    else:\n        print(deg * n // 2)", "import bisect\nprime = [1] * (10 ** 5 + 5)\nprime[0] = 0\nprime[1] = 0\n\ndef sieve():\n    max_n = 10 ** 5\n    i = 2\n    while i * i <= max_n:\n        if prime[i]:\n            for j in range(i * i, max_n + 1, i):\n                prime[j] = 0\n        i += 1\nsieve()\nprime = [i for i in range(len(prime)) if prime[i] == 1]\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    if n == 3:\n        print(3)\n    elif n == 4:\n        print(6)\n    elif n == 5:\n        print(7)\n    else:\n        idx = bisect.bisect_left(prime, n) - 1\n        val = prime[idx] - 2\n        if n & 1:\n            print(n + (n - 1) // 2 * val)\n        else:\n            print(n + n // 2 * val)", "from bisect import bisect_left as bl\na = []\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            a.append(p)\nsieve(10 ** 5)\nfor _ in range(int(input())):\n    n = int(input())\n    t = bl(a, n - 1)\n    if t >= len(a) or a[t] > n - 1:\n        t -= 1\n    deg = a[t]\n    if n % 2:\n        print((deg * (n - 1) + 2) // 2)\n    else:\n        print(deg * n // 2)", "prime_table = []\n\ndef sieve(limit):\n    global prime_table\n    prime_table = [False, False, True] + [True, False] * (limit // 2 + 1)\n    for i in range(3, int(limit ** 0.5) + 1, 2):\n        if prime_table[i]:\n            for j in range(i * i, limit + 1, i * 2):\n                prime_table[j] = False\n\ndef isPrime(num):\n    global prime_table\n    return prime_table[num]\nsieve(pow(10, 6))\nfor _ in range(int(input())):\n    n = int(input())\n    largest_prime = n - 1\n    while not isPrime(largest_prime):\n        largest_prime -= 1\n    total = n * largest_prime\n    if total % 2 == 1:\n        total = (n - 1) * largest_prime + 2\n    print(total // 2)", "array_of_primes = []\nfor i in range(2, 10 ** 5 + 5000):\n    yesval = 'no'\n    for j in range(2, min(round(i ** 0.5) + 2, i)):\n        if i % j == 0:\n            yesval = 'yes'\n            break\n    if yesval == 'no':\n        array_of_primes.append(i)\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    val = 2\n    if N == 3:\n        print(3)\n    elif N % 2 == 0:\n        for theta in range(10 ** 4):\n            if array_of_primes[theta] >= N:\n                val = array_of_primes[theta - 1]\n                break\n        print(val * N // 2)\n    else:\n        for theta in range(10 ** 4):\n            if array_of_primes[theta] >= N:\n                val = array_of_primes[theta - 1]\n                break\n        print(val * (N - 1) // 2 + 1)", "from bisect import bisect_left\n\ndef prime_list(n):\n    primes = []\n    arr = [True] * n\n    for i in range(2, n):\n        if arr[i]:\n            primes.append(i)\n            j = i\n            while j <= n - 1:\n                arr[j] = False\n                j += i\n    return primes\n\ndef largest_prime(n):\n    x = bisect_left(primes, n)\n    return primes[x - 1]\n\ndef solve(n):\n    p = largest_prime(n)\n    if n % 2 == 0:\n        return n * p // 2\n    else:\n        return ((n - 1) * p + 2) // 2\nprimes = prime_list(100000)\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    result = solve(n)\n    print(result)", "import sys, os, io\ninput = sys.stdin.readline\nfrom collections import defaultdict\nimport bisect\nimport random\nPI = 3.141592653589793\nINF = float('inf')\nMOD = 1000000007\n\ndef bin32(num):\n    return '{0:032b}'.format(num)\n\ndef add(x, y):\n    return (x + y) % MOD\n\ndef sub(x, y):\n    return (x - y + MOD) % MOD\n\ndef mul(x, y):\n    return x * y % MOD\n\ndef gcd(x, y):\n    if y == 0:\n        return x\n    return gcd(y, x % y)\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef power(x, y):\n    res = 1\n    x %= MOD\n    while y != 0:\n        if y & 1:\n            res = mul(res, x)\n        y >>= 1\n        x = mul(x, x)\n    return res\n\ndef mod_inv(n):\n    return power(n, MOD - 2)\n\ndef prob(p, q):\n    return mul(p, power(q, MOD - 2))\n\ndef ii():\n    return int(input())\n\ndef li():\n    return [int(i) for i in input().split()]\n\ndef ls():\n    return [i for i in input().split()]\nN = 10 ** 5 + 10\nprime = [1 for i in range(N)]\nfor i in range(2, N):\n    if prime[i]:\n        for j in range(i + i, N, i):\n            prime[j] = 0\np = 2\nprev = [0 for i in range(N)]\nfor i in range(3, N):\n    prev[i] = p\n    if prime[i]:\n        p = i\nfor t in range(ii()):\n    t += 1\n    n = ii()\n    if n % 2 == 0:\n        print(n // 2 * prev[n])\n    else:\n        print((2 + (n - 1) * prev[n]) // 2)", "def largest_prime(n):\n    primes = []\n    arr = [True] * n\n    for i in range(2, n):\n        if arr[i]:\n            primes.append(i)\n            j = i\n            while j <= n - 1:\n                arr[j] = False\n                j += i\n    return primes[-1]\n\ndef solve(n):\n    p = largest_prime(n)\n    if n % 2 == 0:\n        return n * p // 2\n    else:\n        return ((n - 1) * p + 2) // 2\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    result = solve(n)\n    print(result)", "import sys\nimport math\nimport random\nimport heapq\ninput = sys.stdin.readline\n\ndef pow(a, n, m):\n    if n == 0:\n        return 1\n    x = pow(a, n // 2, m)\n    if n % 2 == 0:\n        return x * x % m\n    else:\n        return x * x * a % m\n\ndef gcd(a, b):\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef bs(arr, le, ri):\n    l = 0\n    arr.sort()\n    r = len(arr) - 1\n    ans = 10000000\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] >= le and arr[m] <= ri:\n            ans = arr[m]\n            r = m - 1\n        elif arr[m] < le:\n            l = m + 1\n        else:\n            r = m - 1\n    return ans\n\ndef dfs(al, l, p, n, le, pa):\n    l[n] = le\n    p[n] = pa\n    for i in al[n]:\n        if i != pa:\n            dfs(al, l, p, i, le + 1, n)\n\ndef lca(al, l, p, x, y):\n    if l[x] > l[y]:\n        (x, y) = (y, x)\n    d = l[y] - l[x]\n    while d != 0:\n        y = p[y]\n        d -= 1\n    while x != y:\n        x = p[x]\n        y = p[y]\n    return x\n\ndef dfs1(al, i, x, y, vis, p, ans):\n    vis[i] = 1\n    if i == x or i == y:\n        p = 1\n    ans[i] = p\n    for j in al[i]:\n        if vis[j] == 0:\n            dfs1(al, j, x, y, vis, p, ans)\nl = [1] * 100001\nl[0] = 0\nl[1] = 0\nfor i in range(2, 1001):\n    if l[i] == 1:\n        j = i\n        while j * i <= 100000:\n            l[j * i] = 0\n            j += 1\nls = [2] * 100001\np = 3\nfor i in range(4, 100001):\n    ls[i] = p\n    if l[i] == 1:\n        p = i\nt = 1\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    if n * ls[n] % 2 == 0:\n        print(n * ls[n] // 2)\n    else:\n        print((n - 1) * ls[n] // 2 + 1)\n    t -= 1", "from bisect import *\nt = int(input())\nprimes = []\nvis = [0] * (10 ** 5 + 5)\nfor i in range(2, 10 ** 5 + 1):\n    if vis[i] == 0:\n        primes.append(i)\n        for j in range(i, 10 ** 5 + 1, i):\n            vis[j] = 1\nfor _ in range(t):\n    t -= 1\n    n = int(input())\n    z = bisect_right(primes, n - 1)\n    z -= 1\n    if n % 2 == 0:\n        ed = n * primes[z]\n        ed = ed // 2\n    else:\n        ed = (n - 1) * primes[z]\n        ed += 2\n        ed = ed // 2\n    print(ed)"]