["import sys\nsys.setrecursionlimit(1000000)\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\n\ndef printyes():\n    print('YES')\n\ndef printno():\n    print('NO')\n\nclass RangeQuery:\n\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        (i, n) = (1, len(_data[0]))\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, begin, end):\n        depth = (end - begin).bit_length() - 1\n        return self.func(self._data[depth][begin], self._data[depth][end - (1 << depth)])\n\nclass LCA:\n\n    def __init__(self, root, graph):\n        self.time = [-1] * len(graph)\n        self.path = [-1] * len(graph)\n        P = [-1] * len(graph)\n        t = -1\n        dfs = [root]\n        while dfs:\n            node = dfs.pop()\n            self.path[t] = P[node]\n            self.time[node] = t = t + 1\n            for nei in graph[node]:\n                if self.time[nei] == -1:\n                    P[nei] = node\n                    dfs.append(nei)\n        self.rmq = RangeQuery((self.time[node] for node in self.path))\n\n    def __call__(self, a, b):\n        if a == b:\n            return a\n        a = self.time[a]\n        b = self.time[b]\n        if a > b:\n            (a, b) = (b, a)\n        return self.path[self.rmq.query(a, b)]\n\ndef find(g, s, ct, visited, node, n):\n    ct[node][ord(s[node - 1]) - 97] += 1\n    for i in g[node]:\n        if i not in visited:\n            visited.add(i)\n            for k in range(26):\n                ct[i][k] += ct[node][k]\n            find(g, s, ct, visited, i, n)\nfor t in range(int(input())):\n    n = ni()\n    s = si()\n    g = []\n    for i in range(n + 1):\n        g.append([])\n    for i in range(n - 1):\n        (a, b) = mi()\n        g[a].append(b)\n        g[b].append(a)\n    L = LCA(1, g)\n    visited = set()\n    visited.add(1)\n    ct = []\n    for i in range(n + 5):\n        ct.append([0] * 26)\n    find(g, s, ct, visited, 1, n)\n    for q in range(int(input())):\n        (a, b) = mi()\n        if a < 1 or b < 1 or a > n or (b > n):\n            printno()\n            continue\n        curr = L(a, b)\n        if curr < 1 or curr > n:\n            printno()\n            continue\n        flag = False\n        for i in range(26):\n            if ct[a][i] - ct[curr][i] > 0 and ct[b][i] - ct[curr][i] > 0:\n                flag = True\n                break\n        if flag:\n            printyes()\n        else:\n            printno()", "import sys\nsys.setrecursionlimit(1000000)\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\n\ndef printyes():\n    print('YES')\n\ndef printno():\n    print('NO')\n\nclass RangeQuery:\n\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        (i, n) = (1, len(_data[0]))\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, begin, end):\n        depth = (end - begin).bit_length() - 1\n        return self.func(self._data[depth][begin], self._data[depth][end - (1 << depth)])\n\nclass LCA:\n\n    def __init__(self, root, graph):\n        self.time = [-1] * len(graph)\n        self.path = [-1] * len(graph)\n        P = [-1] * len(graph)\n        t = -1\n        dfs = [root]\n        while dfs:\n            node = dfs.pop()\n            self.path[t] = P[node]\n            self.time[node] = t = t + 1\n            for nei in graph[node]:\n                if self.time[nei] == -1:\n                    P[nei] = node\n                    dfs.append(nei)\n        self.rmq = RangeQuery((self.time[node] for node in self.path))\n\n    def __call__(self, a, b):\n        if a == b:\n            return a\n        a = self.time[a]\n        b = self.time[b]\n        if a > b:\n            (a, b) = (b, a)\n        return self.path[self.rmq.query(a, b)]\n\ndef find(g, s, ct, visited, node, n):\n    ct[node][ord(s[node - 1]) - 97] += 1\n    for i in g[node]:\n        if i not in visited:\n            visited.add(i)\n            for k in range(26):\n                ct[i][k] += ct[node][k]\n            find(g, s, ct, visited, i, n)\nfor t in range(int(input())):\n    n = ni()\n    s = si()\n    g = []\n    for i in range(n + 1):\n        g.append([])\n    for i in range(n - 1):\n        (a, b) = mi()\n        g[a].append(b)\n        g[b].append(a)\n    L = LCA(1, g)\n    visited = set()\n    visited.add(1)\n    ct = []\n    for i in range(n + 5):\n        ct.append([0] * 26)\n    find(g, s, ct, visited, 1, n)\n    for q in range(int(input())):\n        (a, b) = mi()\n        if a < 1 or b < 1 or a > n or (b > n):\n            printno()\n            continue\n        curr = L(a, b)\n        if curr < 1 or curr > n:\n            printno()\n            continue\n        flag = False\n        for i in range(26):\n            if ct[a][i] - ct[curr][i] > 0 and ct[b][i] - ct[curr][i] > 0:\n                flag = True\n                break\n        if flag:\n            printyes()\n        else:\n            printno()", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    import math\n\n    def dfs(u, p, memo, lev, log, g):\n        memo[u][0] = p\n        for i in range(1, log + 1):\n            memo[u][i] = memo[memo[u][i - 1]][i - 1]\n        for v in g[u]:\n            if v != p:\n                lev[v] = lev[u] + 1\n                dfs(v, u, memo, lev, log, g)\n\n    def lca(u, v, log, lev, memo):\n        if lev[u] < lev[v]:\n            (u, v) = (v, u)\n        for i in range(log, -1, -1):\n            if lev[u] - pow(2, i) >= lev[v]:\n                u = memo[u][i]\n        if u == v:\n            return v\n        for i in range(log, -1, -1):\n            if memo[u][i] != memo[v][i]:\n                u = memo[u][i]\n                v = memo[v][i]\n        return memo[u][0]\n    for _ in range(int(input())):\n        n = int(input())\n\n        def helper(node, par, se):\n            o = ord(s[node - 1]) - ord('a')\n            se[o] += 1\n            seen[node] = se[:]\n            for nie in g[node]:\n                if nie != par:\n                    helper(nie, node, se[:])\n        seen = [set() for _ in range(n + 1)]\n        s = list((el for el in input()))\n        log = math.ceil(math.log(n, 2))\n        g = [[] for i in range(n + 1)]\n        memo = [[-1 for i in range(log + 1)] for j in range(n + 1)]\n        lev = [0 for i in range(n + 1)]\n        for _ in range(n - 1):\n            (a, b) = map(int, input().split())\n            g[a].append(b)\n            g[b].append(a)\n        dfs(1, 1, memo, lev, log, g)\n        helper(1, -1, [0] * 26)\n        for _ in range(int(input())):\n            (a, b) = map(int, input().split())\n            p = lca(a, b, log, lev, memo)\n            f = False\n            for j in range(26):\n                if f:\n                    break\n                o = seen[a][j] - seen[p][j]\n                r = seen[b][j] - seen[p][j]\n                if o > 0 and r > 0:\n                    f = True\n            if f:\n                print('YES')\n            else:\n                print('NO')\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(5 * 10 ** 5)\n\ndef dfs(p, prev, this, lvl):\n    level[p] = lvl\n    parent[p][0] = prev\n    for i in range(1, 21):\n        if parent[p][i - 1] != -1:\n            parent[p][i] = parent[parent[p][i - 1]][i - 1]\n    this[ord(a[p - 1]) - 97] += 1\n    count[p] = this[:]\n    for i in child[p]:\n        if i == prev:\n            continue\n        dfs(i, p, this[:], lvl + 1)\n\ndef lca(u, v):\n    if level[u] > level[v]:\n        (u, v) = (v, u)\n    dist = level[v] - level[u]\n    for i in range(20, -1, -1):\n        if dist >> i & 1:\n            v = parent[v][i]\n    if u == v:\n        return u\n    for i in range(20, -1, -1):\n        if parent[u][i] != parent[v][i]:\n            u = parent[u][i]\n            v = parent[v][i]\n    return parent[u][0]\n\ndef answer():\n    for q in range(int(input())):\n        (u, v) = map(int, input().split())\n        (Lca, yes) = (lca(u, v), False)\n        for i in range(26):\n            left = count[u][i] - count[Lca][i]\n            right = count[v][i] - count[Lca][i]\n            if left >= 1 and right >= 1:\n                yes = True\n                break\n        if yes:\n            print('YES')\n        else:\n            print('NO')\nfor T in range(int(input())):\n    n = int(input())\n    a = input().strip()\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    parent = [[-1 for i in range(21)] for j in range(n + 1)]\n    level = [0 for i in range(n + 1)]\n    count = [None for i in range(n + 1)]\n    this = [0 for i in range(26)]\n    dfs(1, -1, this, 0)\n    answer()"]