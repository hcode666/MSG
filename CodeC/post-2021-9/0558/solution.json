["t = int(input())\nwhile t > 0:\n    S = list(input())\n    l = len(S)\n    Fans = 0\n    if S[-1] == 'N':\n        Fans = 1\n        S[-1] = 'P'\n    for i in range(1, l):\n        if S[i] == 'N' and S[i - 1] == 'N':\n            S[i] = 'P'\n            Fans += 1\n    nc = S.count('N')\n    ans = Fans + abs(l // 3 - nc)\n    print(ans)\n    t -= 1", "t = int(input())\nwhile t > 0:\n    S = list(input())\n    l = len(S)\n    Fans = 0\n    if S[-1] == 'N':\n        Fans = 1\n        S[-1] = 'P'\n    for i in range(1, l):\n        if S[i] == 'N' and S[i - 1] == 'N':\n            S[i] = 'P'\n            Fans += 1\n    nc = S.count('N')\n    ans = Fans + abs(l // 3 - nc)\n    print(ans)\n    t -= 1", "t = int(input())\nfor i in range(t):\n    s = list(input())\n    l = len(s)\n    c = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        c = 1\n    for j in range(l):\n        if j - 1 >= 0 and s[j - 1] == 'N' and (s[j] == 'N'):\n            s[j] = 'P'\n            c += 1\n    c2 = 0\n    r = l // 3\n    for k in range(l):\n        if s[k] == 'N':\n            c2 += 1\n    c += abs(r - c2)\n    print(int(c))", "t = int(input())\nfor _ in range(t):\n    s = list(input())\n    l = len(s)\n    final_count = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        final_count = 1\n    for i in range(l):\n        if i - 1 >= 0 and s[i - 1] == 'N' and (s[i] == 'N'):\n            s[i] = 'P'\n            final_count += 1\n    countN = 0\n    reqN = l // 3\n    for i in range(l):\n        if s[i] == 'N':\n            countN += 1\n    final_count += abs(reqN - countN)\n    print(int(final_count))", "t = int(input())\nL = []\nfor _ in range(0, t):\n    s = list(input())\n    l = len(s)\n    finalcount = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        finalcount += 1\n    for i in range(0, l):\n        if i >= 1 and s[i] == 'N' and (s[i - 1] == 'N'):\n            s[i] = 'P'\n            finalcount += 1\n    countN = 0\n    reqN = l // 3\n    for i in range(0, l):\n        if s[i] == 'N':\n            countN += 1\n    finalcount += abs(reqN - countN)\n    L.append(finalcount)\nprint(*L, sep='\\n')", "from collections import Counter\nfrom functools import reduce\nt = int(input())\nfor _ in range(t):\n    a = list(input())\n    (n, c, inv) = (len(a), len(a) // 3, 0)\n    if a[-1] == 'N':\n        inv += 1\n        a[-1] = 'P'\n    cn = 0\n    for el in a:\n        if el == 'N':\n            cn += 1\n        else:\n            kp = min(c, (cn + 1) // 2)\n            inv += cn - kp\n            c -= kp\n            cn = 0\n    print(inv + c)", "for tc in range(int(input())):\n    s = list(input())\n    x = 0\n    (p, n) = (0, 0)\n    np = 0\n    req = len(s) // 3\n    while x < len(s) - 1 and np < req:\n        if s[x] + s[x + 1] == 'NP':\n            if np < req:\n                s[x] = '-'\n                s[x + 1] = '-'\n                np += 1\n                x += 2\n            else:\n                break\n                x += 1\n        else:\n            x += 1\n    ct = 0\n    x = 0\n    while x < len(s) - 1 and np < req:\n        if s[x] + s[x + 1] == 'NN':\n            if np < req:\n                ct += 1\n                s[x] = '-'\n                s[x + 1] = '-'\n                np += 1\n                x += 2\n            else:\n                break\n                x += 1\n        else:\n            x += 1\n    x = 0\n    while x < len(s) - 1 and np < req:\n        if s[x] + s[x + 1] == 'PP':\n            if np < req:\n                ct += 1\n                s[x] = '-'\n                s[x + 1] = '-'\n                np += 1\n                x += 2\n            else:\n                break\n                x += 1\n        else:\n            x += 1\n    x = 0\n    while x < len(s) - 1 and np < req:\n        if s[x] + s[x + 1] == 'PN':\n            if np < req:\n                ct += 2\n                s[x] = '-'\n                s[x + 1] = '-'\n                np += 1\n                x += 2\n            else:\n                break\n                x += 1\n        else:\n            x += 1\n    for x in s:\n        if x == 'N':\n            ct += 1\n    print(ct)", "for _ in range(int(input())):\n    s = input()\n    n_no = s.count('N')\n    p_no = s.count('P')\n    cnt = 0\n    if s[-1] == 'N':\n        cnt += 1\n        n_no -= 1\n        p_no += 1\n    s = s[:len(s) - 1] + 'P'\n    nn_no = 0\n    i = 0\n    while i < len(s):\n        if s[i:i + 2] == 'NN':\n            nn_no += 1\n            i += 1\n        i += 1\n    n_no -= nn_no\n    p_no += nn_no\n    cnt += nn_no\n    n = len(s) // 3\n    if n_no == n:\n        print(cnt)\n    elif n_no < n:\n        cnt = cnt + n - n_no\n        print(cnt)\n    elif n_no > n:\n        cnt = cnt + n_no - n\n        print(cnt)", "def recorrer_texto(texto: str):\n    count = 0\n    l_texto = list(texto)\n    if len(texto) % 3:\n        return -1\n    elif texto[-1] == 'N':\n        l_texto[-1] = 'P'\n        count += 1\n    for i in range(len(texto) - 1):\n        if l_texto[i] == 'N' and l_texto[i + 1] == 'N':\n            l_texto[i + 1] = 'P'\n            count += 1\n    return count + abs(l_texto.count('N') - len(texto) // 3)\nfor _ in range(int(input())):\n    print(recorrer_texto(str(input())))", "for _ in range(int(input())):\n    s = list(input())\n    (ans, nct) = (0, 0)\n    reqd = len(s) // 3\n    if s[-1] == 'N':\n        ans = 1\n        s[-1] = 'P'\n    for c in s:\n        if c == 'P':\n            keep = min(reqd, (nct + 1) // 2)\n            ans += nct - keep\n            reqd -= keep\n            nct = 0\n        else:\n            nct += 1\n    print(ans + reqd)", "for _ in range(int(input())):\n    s = input()\n    n_no = s.count('N')\n    p_no = s.count('P')\n    cnt = 0\n    if s[-1] == 'N':\n        cnt += 1\n        n_no -= 1\n        p_no += 1\n    s = s[:len(s) - 1] + 'P'\n    nn_no = 0\n    i = 0\n    while i < len(s):\n        if s[i:i + 2] == 'NN':\n            nn_no += 1\n            i += 1\n        i += 1\n    n_no -= nn_no\n    p_no += nn_no\n    cnt += nn_no\n    n = len(s) // 3\n    if n_no == n:\n        print(cnt)\n    elif n_no < n:\n        cnt = cnt + n - n_no\n        print(cnt)\n    elif n_no > n:\n        cnt = cnt + n_no - n\n        print(cnt)", "def recorrer_texto(texto: str):\n    count = 0\n    l_texto = list(texto)\n    if len(texto) % 3 != 0:\n        return -1\n    elif texto[-1] == 'N':\n        l_texto[-1] = 'P'\n        count += 1\n    for i in range(len(texto) - 1):\n        if l_texto[i] == 'N' and l_texto[i + 1] == 'N':\n            l_texto[i + 1] = 'P'\n            count += 1\n    return count + abs(l_texto.count('N') - len(texto) // 3)\nT = int(input())\nfor _ in range(T):\n    texto = str(input())\n    print(recorrer_texto(texto))", "for _ in range(int(input())):\n    s = input()\n    n = len(s)\n    li = []\n    for i in range(n):\n        li.append(s[i])\n    f = 0\n    for i in range(len(s) - 1):\n        if li[i] == 'N':\n            if li[i + 1] == 'N':\n                f = f + 1\n                li[i + 1] = 'P'\n    if li[-1] == 'N':\n        f = f + 1\n        li[-1] = 'P'\n    c = 0\n    for i in range(n):\n        if li[i] == 'P':\n            c = c + 1\n    f = f + abs(n - c - n // 3)\n    print(f)", "for _ in range(int(input())):\n    s = list(input())\n    (ans, nct) = (0, 0)\n    reqd = len(s) // 3\n    if s[-1] == 'N':\n        ans = 1\n        s[-1] = 'P'\n    for c in s:\n        if c == 'P':\n            keep = min(reqd, (nct + 1) // 2)\n            ans += nct - keep\n            reqd -= keep\n            nct = 0\n        else:\n            nct += 1\n    print(ans + abs(reqd))", "import math\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfor _ in range(I()):\n    s = list(S())\n    n = len(s)\n    ans = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        ans += 1\n    for i in range(n - 1):\n        if s[i] == 'N' and s[i + 1] != 'P':\n            ans += 1\n            s[i + 1] = 'P'\n    c1 = s.count('N')\n    print(ans + abs(c1 - n // 3))", "import sys\n\ndef count_flips(n, string):\n    flips = 0\n    string = list(string)\n    for i in range(1, n):\n        if string[i - 1] == 'N' and string[i] == 'N':\n            string[i] = 'P'\n            flips += 1\n        if i == n - 1 and string[i] == 'N':\n            string[i] = 'P'\n            flips += 1\n    freq_n = 0\n    freq_p = 0\n    for i in range(n):\n        if string[i] == 'N':\n            freq_n += 1\n    freq_p = n - freq_n\n    flips += abs(n // 3 - freq_n)\n    return flips\n\ndef main():\n    test_case = int(sys.stdin.readline())\n    for tc in range(test_case):\n        string = sys.stdin.readline().strip('\\n')\n        n = len(string)\n        print(count_flips(n, string))\nmain()", "import math\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfor _ in range(I()):\n    s = list(S())\n    n = len(s)\n    ans = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        ans += 1\n    for i in range(n - 1):\n        if s[i] == 'N' and s[i + 1] != 'P':\n            ans += 1\n            s[i + 1] = 'P'\n    c1 = s.count('N')\n    print(ans + abs(c1 - n // 3))", "def solve(s, n):\n    flips = 0\n    for i in range(1, n):\n        if s[i] == 'N' and s[i - 1] == 'N':\n            s = s[:i] + 'P' + s[i + 1:]\n            flips += 1\n    if s[n - 1] == 'N':\n        flips += 1\n        s = s[:-1] + 'P'\n    cnp = s.count('NP')\n    cp = s.count('P')\n    if cnp == n // 3 and cp == n - n // 3:\n        return flips\n    diff = abs(cnp - n // 3)\n    flips += diff\n    return flips\nt = int(input())\nfor _ in range(t):\n    s = input()\n    ans = solve(s, len(s))\n    print(ans)", "from collections import defaultdict as dd\n\ndef solve(S):\n    ln = len(S)\n    x = ln // 3\n    C = dd(int)\n    ind = 0\n    while ind < len(S):\n        if ind + 1 < len(S):\n            cur = S[ind:ind + 2]\n        else:\n            cur = S[ind]\n        if cur in ('NP', 'NN', 'PP'):\n            C[cur] += 1\n            ind += 2\n        else:\n            C[S[ind]] += 1\n            ind += 1\n    if C['NP'] == x:\n        return 2 * C['NN'] + C['N']\n    if C['NP'] < x:\n        gap = x - C['NP']\n        sub = min(gap, C['NN'])\n        change = sub\n        C['NN'] -= sub\n        gap -= sub\n        sub = min(gap, C['PP'])\n        change += sub\n        gap -= sub\n        C['PP'] -= sub\n        assert gap == 0\n        return change + 2 * C['NN'] + C['N']\n    else:\n        gap = C['NP'] - x\n        return gap + 2 * C['NN'] + C['N']\nfor case in range(int(input())):\n    S = input()\n    ans = solve(S)\n    print(ans)", "def solve():\n    s = list(input())\n    len_s = len(s)\n    ans = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        ans += 1\n    for i in range(len_s - 1):\n        if s[i] == 'N' and s[i + 1] != 'P':\n            ans += 1\n            s[i + 1] = 'P'\n    cnt_n = s.count('N')\n    print(ans + abs(cnt_n - len_s // 3))\nT = int(input())\nfor i in range(T):\n    solve()", "for t in range(int(input())):\n    s = list(input())\n    l = len(s)\n    ans = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        ans += 1\n    for i in range(l - 1):\n        if s[i] == 'N' and s[i + 1] == 'N':\n            s[i + 1] = 'P'\n            ans += 1\n    p = 1\n    np = 0\n    for i in range(l - 1):\n        if s[i] == 'N':\n            np += 1\n            p -= 1\n        else:\n            p += 1\n    if p == np:\n        print(ans)\n    elif p > np:\n        print(ans + (p - np) // 3)\n    else:\n        print(ans + (np - p) // 3)", "import math\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfor _ in range(I()):\n    s = list(S())\n    n = len(s)\n    ans = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        ans += 1\n    for i in range(n - 1):\n        if s[i] == 'N' and s[i + 1] != 'P':\n            ans += 1\n            s[i + 1] = 'P'\n    c1 = s.count('N')\n    print(ans + abs(c1 - n // 3))", "import math\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfor _ in range(I()):\n    s = list(S())\n    n = len(s)\n    ans = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        ans += 1\n    for i in range(n - 1):\n        if s[i] == 'N' and s[i + 1] != 'P':\n            ans += 1\n            s[i + 1] = 'P'\n    c1 = s.count('N')\n    print(ans + abs(c1 - n // 3))", "def main():\n    s = list(input())\n    l = len(s)\n    ans = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        ans += 1\n    for i in range(l - 1):\n        if s[i] == 'N' and s[i + 1] == 'N':\n            s[i + 1] = 'P'\n            ans += 1\n    p = 1\n    np = 0\n    for i in range(l - 1):\n        if s[i] == 'N':\n            np += 1\n            p -= 1\n        else:\n            p += 1\n    if p == np:\n        return ans\n    elif p > np:\n        return ans + (p - np) // 3\n    else:\n        return ans + (np - p) // 3\nfor _ in range(int(input())):\n    print(main())", "def main():\n    s = list(input())\n    l = len(s)\n    ans = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        ans += 1\n    for i in range(l - 1):\n        if s[i] == 'N' and s[i + 1] == 'N':\n            s[i + 1] = 'P'\n            ans += 1\n    p = 1\n    np = 0\n    for i in range(l - 1):\n        if s[i] == 'N':\n            np += 1\n            p -= 1\n        else:\n            p += 1\n    if p == np:\n        return ans\n    elif p > np:\n        return ans + (p - np) // 3\n    else:\n        return ans + (np - p) // 3\nfor _ in range(int(input())):\n    print(main())", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n    sys.stderr = open('error.txt', 'w')\ndepth = 200001\nmod = 1000000007\nlim = mod * mod\nsys.setrecursionlimit(depth)\nlinp = lambda : list(minp())\nminp = lambda : map(int, input().split())\nfrom math import inf, ceil, sqrt, log2, gcd\nfrom collections import defaultdict, deque\ndxy = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\ndef expo(a, b):\n    if not b:\n        return 1\n    v = expo(a, b // 2)\n    v = v * v % mod\n    if b % 2:\n        v = v * a % mod\n    return v\n\ndef modinv(a, b):\n    d = expo(b, mod - 2)\n    v = a * d % mod\n    return v\n\ndef checkPrime(n):\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\nfor _ in range(int(input())):\n    s = list(str(input()))\n    n = len(s)\n    k = n // 3\n    v = [False for _ in range(n)]\n    c = 0\n    ans = 0\n    for i in range(n - 1):\n        if s[i] == 'N' and s[i + 1] == 'P' and (c < k):\n            v[i] = True\n            v[i + 1] = True\n            c += 1\n    for i in range(n - 1):\n        if c < k and v[i] == False and (v[i + 1] == False) and (s[i] == 'N') and (s[i + 1] == 'N'):\n            s[i + 1] = 'P'\n            c += 1\n            ans += 1\n            v[i] = True\n            v[i + 1] = True\n    for i in range(n - 1):\n        if c < k and v[i] == False and (v[i + 1] == False) and (s[i] == 'P') and (s[i + 1] == 'P'):\n            s[i] = 'N'\n            c += 1\n            ans += 1\n            v[i] = True\n            v[i + 1] = True\n    for i in range(n):\n        if not v[i] and s[i] == 'N':\n            s[i] = 'P'\n            v[i] = True\n            ans += 1\n    if c != k:\n        ans += 1\n    print(ans)", "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    ans = 0\n    if a[-1] == 'N':\n        a[-1] = 'P'\n        ans += 1\n    countnp = 0\n    for i in range(n - 1):\n        countnp += a[i] + a[i + 1] == 'NP'\n    (countn, countp) = (0, 0)\n    for i in range(n):\n        countn += a[i] == 'N'\n        countp += a[i] == 'P'\n    if countnp > n // 3:\n        ans += countn - n // 3\n    else:\n        for i in range(1, n - 1):\n            if a[i] == 'N' and a[i - 1] == 'N':\n                a[i] = 'P'\n                countp += 1\n                ans += 1\n        ans += abs(countp - (n - n // 3))\n    return ans\nfor T in range(int(input())):\n    a = list(input().strip())\n    n = len(a)\n    print(answer())", "def fun(a, b, c, d, e, f):\n    if c >= f:\n        return c - f + 2 * d + e\n    res = f - c\n    if d >= res:\n        return res + 2 * (d - res) + e\n    res1 = res - d\n    if res1 <= a:\n        return e + res\n    return d + a + (res - d - a) + (res - d - a)\nfor _ in range(int(input())):\n    s = list(input())\n    n = len(s)\n    cpp = 0\n    cp = 0\n    no = 0\n    npp = 0\n    a = 0\n    i = 0\n    while i < n:\n        if s[i] == 'P':\n            if i + 1 < n and s[i + 1] == 'P':\n                cpp += 1\n                i += 1\n            else:\n                cp += 1\n        elif i + 1 < n and s[i + 1] == 'P':\n            npp += 1\n            i += 1\n        elif i + 1 < n and s[i + 1] == 'N':\n            a += 1\n            i += 1\n        else:\n            no += 1\n        i += 1\n    print(fun(cpp, cp, npp, a, no, n // 3))", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n    s = st()\n    N = len(s)\n    i = n = nn = p = np = pp = 0\n    while i < N:\n        if s[i] == 'P':\n            if i + 1 < N and s[i + 1] == 'P':\n                pp += 1\n                i += 1\n            else:\n                p += 1\n        elif i + 1 < N and s[i + 1] == 'P':\n            np += 1\n            i += 1\n        elif i + 1 < N and s[i + 1] == 'N':\n            nn += 1\n            i += 1\n        else:\n            n += 1\n        i += 1\n    req = N // 3\n    if np >= req:\n        pr(np - req + 2 * nn + n)\n    else:\n        left = req - np\n        if nn >= left:\n            pr(2 * nn - left + n)\n        else:\n            x = left - nn\n            if pp >= x:\n                pr(left + n)\n            else:\n                pr(2 * left - nn - pp)\nfor _ in range(inp()):\n    solve()", "import math\nimport sys\nyhuji = sys.stdin.readline\nFC = lambda : yhuji().rstrip()\nAS = lambda : int(FC())\nFT = lambda : map(int, FC().split())\nL = lambda : list(FT())\npolk4 = 1000000007\npolk5 = 998244353\nfor _ in range(AS()):\n    aswed = list(FC())\n    deswqa = len(aswed)\n    cdfret = 0\n    if aswed[-1] == 'N':\n        aswed[-1] = 'P'\n        cdfret += 1\n    for hyujnm in range(deswqa - 1):\n        if aswed[hyujnm] == 'N' and aswed[hyujnm + 1] != 'P':\n            cdfret += 1\n            aswed[hyujnm + 1] = 'P'\n    hbny4 = aswed.count('N')\n    print(cdfret + abs(hbny4 - deswqa // 3))", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nsys.setrecursionlimit(3 * 10 ** 5)\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\nx = 0\npref = []\nlvl = []\ngp = []\nans = []\nf = 0\nw = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\n\ndef dfs(i, prod, rem, n):\n    if rem == 0:\n        while i < len(n):\n            prod *= int(n[i])\n            i += 1\n        return prod\n    if i == len(n):\n        return prod\n    mx = 0\n    for j in range(9 - int(n[i])):\n        mx = max(dfs(i + 1, (int(n[i]) + min(j, rem)) * prod, rem - min(j, rem), n), mx)\n    return mx\n\ndef hnbhai(tc):\n    s = list(sa())\n    n = len(s)\n    last = []\n    tot = 0\n    tnp = 0\n    p = 0\n    for i in range(n):\n        if s[i] == 'N':\n            tot += 1\n        if s[i] == 'P':\n            if tot >= 1:\n                tnp += 1\n            tot -= 1\n            if tot >= 1:\n                last.append(tot)\n            tot = 0\n    p = s.count('P') - tnp\n    last.append(tot)\n    ans = 0\n    x = 0\n    for i in last:\n        ans += (i + 1) // 2\n        if i % 2:\n            p += 1\n        tnp += i // 2\n    if tnp > p:\n        print(ans + (n // 3 - p) // 2)\n        return\n    print(ans + (n // 3 - tnp))\nfor _ in range(sb()):\n    hnbhai(_ + 1)", "for _ in range(int(input())):\n    S = list(input())\n    n = len(S)\n    Nexcess = S.count('N') - n // 3\n    NseriesStarted = False\n    odd = False\n    moves = 0\n    for i in range(n):\n        if S[i] == 'N':\n            if NseriesStarted:\n                if odd:\n                    S[i] = 'P'\n                    moves += 1\n                    odd = False\n                else:\n                    odd = True\n            else:\n                NseriesStarted = True\n                odd = True\n        elif NseriesStarted:\n            NseriesStarted = False\n    if S[-1] == 'N':\n        moves += 1\n    if Nexcess >= moves:\n        print(Nexcess)\n    else:\n        print(2 * moves - Nexcess)", "from sys import stdin, stdout, setrecursionlimit as srl\nfrom threading import stack_size\nfrom collections import deque, defaultdict as dd\nfrom math import gcd, ceil, sqrt\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nflush = stdout.flush\np = int(1000000000.0 + 7)\ntc = 1\ntc = int(input())\nfor _ in range(1, tc + 1):\n    s = input()\n    n = len(s) // 3\n    l = [i for i in s]\n    ans = 0\n    for i in range(len(l) - 1):\n        if l[i] == l[i + 1] and l[i] == 'N':\n            ans += 1\n            l[i + 1] = 'P'\n    if l[-1] == 'N':\n        l[-1] = 'P'\n        ans += 1\n    s = ''\n    for i in l:\n        s = s + i\n    (p, np) = (0, 0)\n    for i in s:\n        if i == 'N':\n            np += 1\n    print(ans + abs(n - np))", "import math\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfor _ in range(I()):\n    s = list(S())\n    n = len(s)\n    ans = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        ans += 1\n    for i in range(n - 1):\n        if s[i] == 'N' and s[i + 1] != 'P':\n            ans += 1\n            s[i + 1] = 'P'\n    c1 = s.count('N')\n    print(ans + abs(c1 - n // 3))", "from collections import defaultdict\nans = ''\nfor _ in range(int(input())):\n    st = input()\n    d = {'NP': 0, 'P': 0, 'N': 0}\n    count = 0\n    i = 0\n    while i < len(st):\n        if i < len(st) - 1 and st[i] == 'N' and (st[i + 1] == 'N'):\n            count += 1\n            d['NP'] += 1\n            i += 1\n        elif i < len(st) - 1 and st[i] == 'N' and (st[i + 1] == 'P'):\n            d['NP'] += 1\n            i += 1\n        elif st[i] == 'P':\n            d['P'] += 1\n        elif st[i] == 'N':\n            d['P'] += 1\n            count += 1\n        i += 1\n    t = abs(d['NP'] - d['P']) / 3\n    if t % 1 == 0:\n        count += int(t)\n    else:\n        count = -1\n    ans += str(count) + '\\n'\nprint(ans)", "import math\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfor _ in range(I()):\n    s = list(S())\n    n = len(s)\n    ans = 0\n    if s[-1] == 'N':\n        s[-1] = 'P'\n        ans += 1\n    for i in range(n - 1):\n        if s[i] == 'N' and s[i + 1] != 'P':\n            ans += 1\n            s[i + 1] = 'P'\n    c1 = s.count('N')\n    print(ans + abs(c1 - n // 3))", "import sys\nimport math\nimport random\nimport heapq\ninput = sys.stdin.readline\n\ndef pow(a, n, m):\n    if n == 0:\n        return 1\n    x = pow(a, n // 2, m)\n    if n % 2 == 0:\n        return x * x % m\n    else:\n        return x * x * a % m\n\ndef gcd(a, b):\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef bs(arr, le, ri):\n    l = 0\n    arr.sort()\n    r = len(arr) - 1\n    ans = 10000000\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] >= le and arr[m] <= ri:\n            ans = arr[m]\n            r = m - 1\n        elif arr[m] < le:\n            l = m + 1\n        else:\n            r = m - 1\n    return ans\nt = int(input())\nwhile t > 0:\n    s = input().strip()\n    f = 0\n    if s[-1] == 'N':\n        f += 1\n    n = len(s)\n    i = n - 2\n    while i > 0:\n        if s[i] == 'N' and s[i - 1] == 'N':\n            f += 1\n            i -= 1\n        i -= 1\n    p = s.count('P') + f\n    print(f + abs(2 * n // 3 - p))\n    t -= 1", "for _ in range(int(input())):\n    s = input()\n    n = len(s)\n    (ans, count) = (0, 0)\n    s = list(s)\n    for i in range(1, n):\n        if s[i] == 'N' and s[i - 1] == 'N':\n            s[i] = 'P'\n            ans += 1\n        elif s[i] == 'N' and i == n - 1:\n            s[i] = 'P'\n            ans += 1\n        if s[i] == 'N':\n            count += 1\n    if s[0] == 'N':\n        count += 1\n    ans += abs(n // 3 - count)\n    print(ans)"]