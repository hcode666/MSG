["import math\nMOD7 = pow(10, 9) + 7\nMAXF = pow(10, 5)\nmy_list = [0] * (MAXF + 1)\n\ndef last(l):\n    return (l + 1) * l / 2\n\ndef get_level_and_index(n):\n    idx = -1\n    line = -1\n    if n == 1:\n        return (1, 1)\n    left = 2\n    right = 1 + math.floor(math.sqrt(2 * n))\n    while left <= right:\n        line = int((left + right) / 2)\n        if last(line) >= n and last(line - 1) < n:\n            break\n        elif last(line > n):\n            right = l - 1\n        else:\n            left = line + 1\n    idx = int(n - line * (line - 1) / 2)\n    return (line, idx)\n\ndef pow_mod(x, y, p):\n    x = x % p\n    if x == 0:\n        return 0\n    res = 1\n    while y > 0:\n        if y & 1:\n            res = res * x\n            res = res % p\n            y = y - 1\n        x = x * x % p\n        y = int(y / 2)\n    return res\n\ndef inv(x, p):\n    return pow_mod(x, p - 2, p)\n\ndef lci(line, i, p=MOD7):\n    x = my_list[line] * inv(my_list[i], p) % p\n    y = inv(my_list[line - i], p)\n    return x * y % p\nmy_list[0] = 1\nmy_list[1] = 1\nfor i in range(2, MAXF):\n    my_list[i] = my_list[i - 1] * i % MOD7\nT = int(input())\nfor _ in range(T):\n    (s, e) = map(int, input().split(' '))\n    (start_l, start_i) = get_level_and_index(s)\n    (end_l, end_i) = get_level_and_index(e)\n    line = end_l - start_l\n    i = end_i - start_i\n    ans = -1\n    if line <= 0 or i < 0 or i > line:\n        ans = 0\n    else:\n        ans = lci(line, i)\n    print(ans)", "import math\nMOD7 = pow(10, 9) + 7\nMAXF = pow(10, 5)\nmy_list = [0] * (MAXF + 1)\n\ndef last(l):\n    return (l + 1) * l / 2\n\ndef get_level_and_index(n):\n    idx = -1\n    line = -1\n    if n == 1:\n        return (1, 1)\n    left = 2\n    right = 1 + math.floor(math.sqrt(2 * n))\n    while left <= right:\n        line = int((left + right) / 2)\n        if last(line) >= n and last(line - 1) < n:\n            break\n        elif last(line > n):\n            right = l - 1\n        else:\n            left = line + 1\n    idx = int(n - line * (line - 1) / 2)\n    return (line, idx)\n\ndef pow_mod(x, y, p):\n    x = x % p\n    if x == 0:\n        return 0\n    res = 1\n    while y > 0:\n        if y & 1:\n            res = res * x\n            res = res % p\n            y = y - 1\n        x = x * x % p\n        y = int(y / 2)\n    return res\n\ndef inv(x, p):\n    return pow_mod(x, p - 2, p)\n\ndef lci(line, i, p=MOD7):\n    x = my_list[line] * inv(my_list[i], p) % p\n    y = inv(my_list[line - i], p)\n    return x * y % p\nmy_list[0] = 1\nmy_list[1] = 1\nfor i in range(2, MAXF):\n    my_list[i] = my_list[i - 1] * i % MOD7\nT = int(input())\nfor _ in range(T):\n    (s, e) = map(int, input().split(' '))\n    (start_l, start_i) = get_level_and_index(s)\n    (end_l, end_i) = get_level_and_index(e)\n    line = end_l - start_l\n    i = end_i - start_i\n    ans = -1\n    if line <= 0 or i < 0 or i > line:\n        ans = 0\n    else:\n        ans = lci(line, i)\n    print(ans)", "from math import ceil, sqrt\ndisplay_modulo = 10 ** 9 + 7\nmax_factor = 10 ** 5\nfactors = [None] * (max_factor + 1)\n\ndef power_modulo(a, b, pow):\n    a %= pow\n    if a == 0:\n        return 0\n    prod = 1\n    while b > 0:\n        if b % 2 == 1:\n            prod *= a\n            prod %= pow\n            b -= 1\n        a *= a\n        a %= pow\n        b //= 2\n    return prod\n\ndef binom(n, k, p):\n    return factors[n] * inv(factors[k], p) % p * inv(factors[n - k], p) % p\n\ndef inv(a, p):\n    return power_modulo(a, p - 2, p)\n\ndef get_last_node(level):\n    return (level + 1) * level // 2\n\ndef get_level_index_tuple(n):\n    i = -1000\n    l = -1000\n    if n == 1:\n        return (1, 1)\n    finish = 1 + ceil(sqrt(n * 2))\n    begin = 2\n    while begin <= finish:\n        l = (begin + finish) // 2\n        last = get_last_node(l)\n        if last >= n and get_last_node(l - 1) < n:\n            break\n        elif last > n:\n            finish = l - 1\n        else:\n            begin = l + 1\n    i = n - l * (l - 1) // 2\n    return (l, i)\nfactors[0] = 1\nfactors[1] = 1\nfor i in range(2, max_factor + 1):\n    factors[i] = factors[i - 1] * i % display_modulo\nfor _ in range(int(input())):\n    (s, e) = map(int, input().split())\n    t1 = get_level_index_tuple(s)\n    t2 = get_level_index_tuple(e)\n    res = -1000\n    i_difference = t2[1] - t1[1]\n    l_difference = t2[0] - t1[0]\n    if l_difference <= 0 or i_difference < 0 or i_difference > l_difference:\n        res = 0\n    else:\n        res = binom(l_difference, i_difference, display_modulo)\n    print(res)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef getcoord(num):\n    y = int((2 * num + 0.25) ** 0.5 + 0.5)\n    x = int(num - y * (y - 1) / 2)\n    if x == 0:\n        y -= 1\n        x = y\n    return (x, y)\nT = int(input())\nfor i in range(T):\n    (s, e) = map(int, input().split())\n    E = getcoord(e)\n    S = getcoord(s)\n    n = E[1] - S[1]\n    r = E[0] - S[0]\n    if n < 1 or r < 0 or n < r:\n        print(0)\n    else:\n        print(ncr(n, r, 10 ** 9 + 7))", "import sys\nfrom math import floor, sqrt\nT = int(input())\nprime = 10 ** 9 + 7\nMAX_LINE = 10 ** 5 + 5\nfactorials = [None] * MAX_LINE\n\ndef modulo_power(a, b):\n    res = 1\n    while b > 0:\n        res = res * a % prime\n        b -= 1\n    return res\n\ndef power(x, y, m=prime):\n    x %= m\n    res = 1\n    while y > 0:\n        if y % 2 == 1:\n            res = res * x % m\n        y = y // 2\n        x = x * x % m\n    return res\n\ndef power_modulo(a, b, pow=prime):\n    a %= pow\n    if a == 0:\n        return 0\n    prod = 1\n    while b > 0:\n        if b % 2 == 1:\n            prod *= a\n            prod %= pow\n            b -= 1\n        a *= a\n        a %= pow\n        b //= 2\n    return prod\nfactorials[0] = 1\nfor i in range(1, MAX_LINE):\n    factorials[i] = factorials[i - 1] * i % prime\n\ndef modulo_fact(n):\n    return factorials[n]\n\ndef modulo_inverse_fact(n):\n    a = modulo_fact(n)\n    return power(a, prime - 2) % prime\n\ndef comb_formula(n, p):\n    if n < 0 or p < 0 or n - p < 0:\n        return 0\n    else:\n        return modulo_fact(n) * modulo_inverse_fact(p) % prime * modulo_inverse_fact(n - p) % prime\n\ndef testcase():\n\n    def series_sum(n):\n        return n * (n + 1) / 2\n\n    def get_line_no(n):\n        close_line = floor(sqrt(2 * n))\n        line_end = series_sum(close_line)\n        if line_end < n:\n            close_line += 1\n            index = n - line_end\n        else:\n            index = close_line - line_end + n\n        return (close_line, int(index))\n    (s, e) = map(int, input().split())\n    (s_line, s_ind) = get_line_no(s)\n    (e_line, e_ind) = get_line_no(e)\n    print(int(comb_formula(e_line - s_line, e_ind - s_ind)))\nfor _ in range(T):\n    testcase()", "import sys\ninput = sys.stdin.readline\nimport math\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * power(den, p - 2, p) % p\n\ndef level(n):\n    n = n * 2\n    ans = 4 * n + 1\n    d = math.ceil(math.sqrt(ans) - 1)\n    if d % 2 != 0:\n        d += 1\n    level = d // 2\n    return int(level)\n\ndef LR(n):\n    level = 1\n    while True:\n        sm = level * (level + 1) // 2\n        if sm >= n:\n            rank = level - abs(sm - n)\n            return (level, rank)\n        level += 1\nfor _ in range(int(input())):\n    lst = list(map(int, input().split()))\n    (s, e) = (lst[0], lst[1])\n    if s == e:\n        print(0)\n        continue\n    ls = level(s)\n    le = level(e)\n    sms = int(ls * (ls + 1) // 2)\n    sme = int(le * (le + 1) // 2)\n    rs = ls - abs(sms - s)\n    re = le - abs(sme - e)\n    ld = le - ls\n    if ld >= 0:\n        if (re - rs < 0 or ld < re - rs) != True:\n            ans = ncr(ld, re - rs, 10 ** 9 + 7)\n            print(ans)\n        else:\n            print(0)\n    else:\n        print(0)", "from math import ceil, sqrt\ndisplay_modulo = 10 ** 9 + 7\nmax_factor = 10 ** 5\nfactors = [None] * (max_factor + 1)\n\ndef power_modulo(a, b, pow):\n    a %= pow\n    if a == 0:\n        return 0\n    prod = 1\n    while b > 0:\n        if b % 2 == 1:\n            prod *= a\n            prod %= pow\n            b -= 1\n        a *= a\n        a %= pow\n        b //= 2\n    return prod\n\ndef binom(n, k, p):\n    return factors[n] * inv(factors[k], p) % p * inv(factors[n - k], p) % p\n\ndef inv(a, p):\n    return power_modulo(a, p - 2, p)\n\ndef get_last_node(level):\n    return (level + 1) * level // 2\n\ndef get_level_index_tuple(n):\n    i = -1000\n    l = -1000\n    if n == 1:\n        return (1, 1)\n    finish = 1 + ceil(sqrt(n * 2))\n    begin = 2\n    while begin <= finish:\n        l = (begin + finish) // 2\n        last = get_last_node(l)\n        if last >= n and get_last_node(l - 1) < n:\n            break\n        elif last > n:\n            finish = l - 1\n        else:\n            begin = l + 1\n    i = n - l * (l - 1) // 2\n    return (l, i)\nfactors[0] = 1\nfactors[1] = 1\nfor i in range(2, max_factor + 1):\n    factors[i] = factors[i - 1] * i % display_modulo\nfor _ in range(int(input())):\n    (s, e) = map(int, input().split())\n    t1 = get_level_index_tuple(s)\n    t2 = get_level_index_tuple(e)\n    res = -1000\n    i_difference = t2[1] - t1[1]\n    l_difference = t2[0] - t1[0]\n    if l_difference <= 0 or i_difference < 0 or i_difference > l_difference:\n        res = 0\n    else:\n        res = binom(l_difference, i_difference, display_modulo)\n    print(res)", "from math import ceil, sqrt\ndisplay_modulo = 10 ** 9 + 7\nmax_factor = 10 ** 5\nfactors = [None] * (max_factor + 1)\n\ndef power_modulo(a, b, pow):\n    a %= pow\n    if a == 0:\n        return 0\n    prod = 1\n    while b > 0:\n        if b % 2 == 1:\n            prod *= a\n            prod %= pow\n            b -= 1\n        a *= a\n        a %= pow\n        b //= 2\n    return prod\n\ndef binom(n, k, p):\n    return factors[n] * inv(factors[k], p) % p * inv(factors[n - k], p) % p\n\ndef inv(a, p):\n    return power_modulo(a, p - 2, p)\n\ndef get_last_node(level):\n    return (level + 1) * level // 2\n\ndef get_level_index_tuple(n):\n    i = -1000\n    l = -1000\n    if n == 1:\n        return (1, 1)\n    finish = 1 + ceil(sqrt(n * 2))\n    begin = 2\n    while begin <= finish:\n        l = (begin + finish) // 2\n        last = get_last_node(l)\n        if last >= n and get_last_node(l - 1) < n:\n            break\n        elif last > n:\n            finish = l - 1\n        else:\n            begin = l + 1\n    i = n - l * (l - 1) // 2\n    return (l, i)\nfactors[0] = 1\nfactors[1] = 1\nfor i in range(2, max_factor + 1):\n    factors[i] = factors[i - 1] * i % display_modulo\nfor _ in range(int(input())):\n    (s, e) = map(int, input().split())\n    t1 = get_level_index_tuple(s)\n    t2 = get_level_index_tuple(e)\n    res = -1000\n    i_difference = t2[1] - t1[1]\n    l_difference = t2[0] - t1[0]\n    if l_difference <= 0 or i_difference < 0 or i_difference > l_difference:\n        res = 0\n    else:\n        res = binom(l_difference, i_difference, display_modulo)\n    print(res)", "import math\nmax_no = int(100000.0)\nmod_7 = int(1000000000.0 + 7)\nfactorial = [None] * (max_no + 1)\nfactorial[0] = 1\nfactorial[1] = 1\nfor i in range(2, max_no + 1):\n    factorial[i] = factorial[i - 1] * i % mod_7\n\ndef last_elem(lvl):\n    return (lvl + 1) * lvl // 2\n\ndef powmod(a, b, p):\n    a %= p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b % 2 == 1:\n            product *= a\n            product %= p\n            b -= 1\n        a *= a\n        a %= p\n        b //= 2\n    return product\n\ndef inv(a, p):\n    return powmod(a, p - 2, p)\n\ndef nCk(n, k, p):\n    return factorial[n] * inv(factorial[k], p) % p * inv(factorial[n - k], p) % p\n\ndef get_level_index(n):\n    lvl = -1\n    idx = -1\n    if n == 1:\n        return [(1, 1)]\n    start = 2\n    end = 1 + math.ceil(math.sqrt(n * 2))\n    while start <= end:\n        lvl = (start + end) // 2\n        if last_elem(lvl) >= n and last_elem(lvl - 1) < n:\n            break\n        elif last_elem(lvl) > n:\n            end = lvl - 1\n        else:\n            start = lvl + 1\n    idx = n - lvl * (lvl - 1) // 2\n    return [(lvl, idx)]\nt = int(input())\nfor _ in range(t):\n    (s, e) = map(int, input().split())\n    result_1 = []\n    result_2 = []\n    result_1 = get_level_index(s)\n    result_2 = get_level_index(e)\n    s1v1 = result_1[0][0]\n    sidx = result_1[0][1]\n    e1v1 = result_2[0][0]\n    eidx = result_2[0][1]\n    L = e1v1 - s1v1\n    K = eidx - sidx\n    ans = -1\n    if L <= 0 or K < 0 or K > L:\n        ans = 0\n    else:\n        ans = nCk(L, K, mod_7)\n    print(ans)", "from math import ceil, sqrt\ndisplay_modulo = 10 ** 9 + 7\nmax_factor = 10 ** 5\nfactors = [None] * (max_factor + 1)\n\ndef power_modulo(a, b, pow):\n    a %= pow\n    if a == 0:\n        return 0\n    prod = 1\n    while b > 0:\n        if b % 2 == 1:\n            prod *= a\n            prod %= pow\n            b -= 1\n        a *= a\n        a %= pow\n        b //= 2\n    return prod\n\ndef binom(n, k, p):\n    return factors[n] * inv(factors[k], p) % p * inv(factors[n - k], p) % p\n\ndef inv(a, p):\n    return power_modulo(a, p - 2, p)\n\ndef get_last_node(level):\n    return (level + 1) * level // 2\n\ndef get_level_index_tuple(n):\n    i = -1000\n    l = -1000\n    if n == 1:\n        return (1, 1)\n    finish = 1 + ceil(sqrt(n * 2))\n    begin = 2\n    while begin <= finish:\n        l = (begin + finish) // 2\n        last = get_last_node(l)\n        if last >= n and get_last_node(l - 1) < n:\n            break\n        elif last > n:\n            finish = l - 1\n        else:\n            begin = l + 1\n    i = n - l * (l - 1) // 2\n    return (l, i)\nfactors[0] = 1\nfactors[1] = 1\nfor i in range(2, max_factor + 1):\n    factors[i] = factors[i - 1] * i % display_modulo\nfor _ in range(int(input())):\n    (s, e) = map(int, input().split())\n    t1 = get_level_index_tuple(s)\n    t2 = get_level_index_tuple(e)\n    res = -1000\n    i_difference = t2[1] - t1[1]\n    l_difference = t2[0] - t1[0]\n    if l_difference <= 0 or i_difference < 0 or i_difference > l_difference:\n        res = 0\n    else:\n        res = binom(l_difference, i_difference, display_modulo)\n    print(res)", "import math\n\nclass solution:\n\n    def __init__(self):\n        self.mod = 1000000007\n        self.fact = []\n        self.fact.append(1)\n        self.fact.append(1)\n        for i in range(2, 100001):\n            self.fact.append(self.fact[-1] * i % self.mod)\n\n    def powMod(self, p, base, Pow):\n        base = base % p\n        if base == 0:\n            return 0\n        product = 1\n        while Pow > 0:\n            if Pow % 2 == 1:\n                Pow -= 1\n                product = product * base\n                product = product % p\n            Pow = Pow // 2\n            base = base * base\n            base = base % p\n        return product\n\n    def lastElem(self, lvl):\n        return (lvl + 1) * lvl // 2\n\n    def getLvlIdx(self, n):\n        lvl = -1\n        idx = -1\n        if n == 1:\n            return (1, 1)\n        st = 2\n        end = 1 + math.ceil(math.sqrt(2 * n))\n        while st <= end:\n            lvl = (st + end) // 2\n            if self.lastElem(lvl) >= n and self.lastElem(lvl - 1) < n:\n                break\n            elif self.lastElem(lvl) > n:\n                end = lvl - 1\n            else:\n                st = lvl + 1\n        idx = n - lvl * (lvl - 1) // 2\n        return (lvl, idx)\n\n    def inv(self, a, p):\n        return self.powMod(p, a, p - 2)\n\n    def nCk(self, n, k, p):\n        return self.fact[n] * self.inv(self.fact[k], p) % p * self.inv(self.fact[n - k], p) % p\nt = int(input())\nsolver = solution()\nfor tests in range(t):\n    l = list(map(int, input().split()))\n    s = l[0]\n    res1 = solver.getLvlIdx(s)\n    sidx = res1[1]\n    slvl = res1[0]\n    e = l[1]\n    res2 = solver.getLvlIdx(e)\n    elvl = res2[0]\n    eidx = res2[1]\n    Ldiff = elvl - slvl\n    Idiff = eidx - sidx\n    res = 0\n    if Ldiff > 0 and Idiff >= 0 and (Idiff <= Ldiff):\n        res = solver.nCk(Ldiff, Idiff, 1000000007)\n    print(res)", "import math\nmod7 = 1000000007\nMAXF = 100000\n\ndef last_elem(lvl):\n    return (lvl + 1) * lvl // 2\n\ndef powmod(a, b, p):\n    a %= p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b & 1:\n            product *= a\n            product %= p\n            b -= 1\n        a *= a\n        a %= p\n        b //= 2\n    return product\n\ndef inv(a, p):\n    return powmod(a, p - 2, p)\n\ndef nck(n, k, p):\n    return arr[n] * inv(arr[k], p) % p * inv(arr[n - k], p) % p\n\ndef get_lvl_idx(n):\n    lvl = -1\n    idx = -1\n    if n == 1:\n        return [1, 1]\n    st = 2\n    end = math.ceil(math.sqrt(2 * n))\n    while st <= end:\n        lvl = (st + end) // 2\n        if last_elem(lvl) >= n and last_elem(lvl - 1) < n:\n            break\n        elif last_elem(lvl) > n:\n            end = lvl - 1\n        else:\n            st = lvl + 1\n    idx = n - lvl * (lvl - 1) // 2\n    return [lvl, idx]\narr = [0 for i in range(MAXF)]\narr[0] = 1\narr[1] = 1\nfor i in range(2, MAXF):\n    arr[i] = arr[i - 1] * i % mod7\nt = int(input())\nfor _ in range(t):\n    (s, e) = map(int, input().split())\n    res1 = get_lvl_idx(s)\n    res2 = get_lvl_idx(e)\n    x1 = res1[0]\n    x2 = res1[1]\n    x3 = res2[0]\n    x4 = res2[1]\n    L = x3 - x1\n    K = x4 - x2\n    ans = -1\n    if L <= 0 or K < 0 or K > L:\n        ans = 0\n    else:\n        ans = nck(L, K, mod7)\n    print(ans)", "from math import sqrt, ceil\nMOD = 10 ** 9 + 7\nMAX = 10 ** 5\nfactors = [None] * (MAX + 1)\n\ndef get_last_elem_in_lvl(level_index):\n    return (level_index + 1) * level_index // 2\n\ndef powerer_mod(num1, num2, power):\n    num1 %= power\n    if 0 == num1:\n        return 0\n    res = 1\n    while num2 > 0:\n        if num2 % 2 == 1:\n            res *= num1\n            res %= power\n            num2 -= 1\n        num1 *= num1\n        num1 %= power\n        num2 //= 2\n    return res\n\ndef inv(num, power):\n    return powerer_mod(num, power - 2, power)\n\ndef binom_nCk(n, k, p):\n    return factors[n] * inv(factors[k], p) % p * inv(factors[n - k], p) % p\n\ndef get_number_level_and_index_tuple(number):\n    if 1 == number:\n        return (1, 1)\n    start = 2\n    end = 1 + ceil(sqrt(number * 2))\n    while start <= end:\n        level = (start + end) // 2\n        last = get_last_elem_in_lvl(level)\n        if last >= number and get_last_elem_in_lvl(level - 1) < number:\n            break\n        elif last > number:\n            end = level - 1\n        else:\n            start = level + 1\n    index = number - level * (level - 1) // 2\n    return (level, index)\nfactors[0] = 1\nfactors[1] = 1\nfor i in range(2, MAX + 1):\n    factors[i] = factors[i - 1] * i % MOD\nT = int(input())\nfor _ in range(T):\n    (S, E) = map(int, input().split())\n    S_tuple = get_number_level_and_index_tuple(S)\n    E_tuple = get_number_level_and_index_tuple(E)\n    delta_l = E_tuple[0] - S_tuple[0]\n    delta_i = E_tuple[1] - S_tuple[1]\n    if delta_l <= 0 or delta_i < 0 or delta_i > delta_l:\n        res = 0\n    else:\n        res = binom_nCk(delta_l, delta_i, MOD)\n    print(res)", "from math import ceil, sqrt\nprint_mod = 10 ** 9 + 7\nmax_factor = 10 ** 5\nfactors = [None] * (max_factor + 1)\n\ndef get_last_item(level_index):\n    return (level_index + 1) * level_index // 2\n\ndef power_and_mod(a, b, pow):\n    a %= pow\n    if a == 0:\n        return 0\n    prod = 1\n    while b > 0:\n        if b % 2 == 1:\n            prod *= a\n            prod %= pow\n            b -= 1\n        a *= a\n        a %= pow\n        b //= 2\n    return prod\n\ndef inv(a, p):\n    return power_and_mod(a, p - 2, p)\n\ndef binom(n, k, p):\n    return factors[n] * inv(factors[k], p) % p * inv(factors[n - k], p) % p\n\ndef get_number_level_and_index_tuple(number):\n    level = -1000\n    index = -1000\n    if number == 1:\n        return (1, 1)\n    start = 2\n    end = 1 + ceil(sqrt(number * 2))\n    while start <= end:\n        level = (start + end) // 2\n        last = get_last_item(level)\n        if last >= number and get_last_item(level - 1) < number:\n            break\n        elif last > number:\n            end = level - 1\n        else:\n            start = level + 1\n    index = number - level * (level - 1) // 2\n    return (level, index)\nfactors[0] = 1\nfactors[1] = 1\nfor i in range(2, max_factor + 1):\n    factors[i] = factors[i - 1] * i % print_mod\nt = int(input())\nfor _ in range(t):\n    (s, e) = map(int, input().split())\n    first_tuple = get_number_level_and_index_tuple(s)\n    second_tuple = get_number_level_and_index_tuple(e)\n    levels_diff = second_tuple[0] - first_tuple[0]\n    index_diff = second_tuple[1] - first_tuple[1]\n    result = -1000\n    if levels_diff <= 0 or index_diff < 0 or index_diff > levels_diff:\n        result = 0\n    else:\n        result = binom(levels_diff, index_diff, print_mod)\n    print(result)", "import math\nmodulu7 = pow(10, 9) + 7\nmaximum = pow(10, 5)\nmy_list = [0] * (maximum + 1)\n\ndef getLevelAndIndex(n):\n    if n == 1:\n        return (1, 1)\n    ind = -1\n    line = -1\n    left = 2\n    right = 1 + math.floor(math.sqrt(2 * n))\n    while left <= right:\n        line = int((left + right) / 2)\n        if last(line) >= n and last(line - 1) < n:\n            break\n        elif last(line > n):\n            right = l - 1\n        else:\n            left = line + 1\n    ind = int(n - line * (line - 1) / 2)\n    return (line, ind)\n\ndef moduluPower(base, y, p):\n    if base == 0:\n        return 0\n    base = base % p\n    res = 1\n    while y > 0:\n        if y & 1:\n            res = res * base\n            res = res % p\n            y -= 1\n        base = base * base % p\n        y = int(y / 2)\n    return res\n\ndef last(l):\n    return (l + 1) * l / 2\n\ndef inv(x, p):\n    if x > 0:\n        return moduluPower(x, p - 2, p)\n    else:\n        return moduluPower(x, p - 2, p)\n\ndef lci(line, i, p=modulu7):\n    xValue = inv(my_list[i], p) * my_list[line] % p\n    yValue = inv(my_list[line - i], p)\n    XMulY = xValue * yValue\n    return XMulY % p\nmy_list[1] = 1\nmy_list[0] = 1\nfor i in range(2, maximum):\n    my_list[i] = i * my_list[i - 1] % modulu7\nT = int(input())\nfor _ in range(T):\n    (s, e) = map(int, input().split(' '))\n    (startL, startI) = getLevelAndIndex(s)\n    (endL, endI) = getLevelAndIndex(e)\n    line = endL - startL\n    i = endI - startI\n    ans = -1\n    if line < 1 or i < 0 or i > line:\n        ans = 0\n    else:\n        ans = lci(line, i)\n    print(ans)", "import math\nMAXF = pow(10, 5)\nfact = [0] * (MAXF + 1)\nMOD7 = pow(10, 9) + 7\n\ndef inv(a, p):\n    return pow_mod(a, p - 2, p)\n\ndef levelCindex(level, index, p=MOD7):\n    a = fact[level] * inv(fact[index], p)\n    a = a % p\n    b = inv(fact[level - index], p)\n    return a * b % p\n\ndef get_level_index(n):\n    if n == 1:\n        return (1, 1)\n    level = -1\n    index = -1\n    start = 2\n    end = 1 + math.floor(math.sqrt(2 * n))\n    while start <= end:\n        level = int((start + end) / 2)\n        if last_element(level) > n - 1 and last_element(level - 1) < n:\n            break\n        elif last_element(level > n):\n            end = level - 1\n        else:\n            start = level + 1\n    index = int(n - level * (level - 1) / 2)\n    return (level, index)\n\ndef pow_mod(a, b, p):\n    a = a % p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b & 1:\n            product = product * a\n            product = product % p\n            b = b - 1\n        a = a * a\n        a = a % p\n        b = int(b / 2)\n    return product\n\ndef last_element(level):\n    res = level * (level + 1)\n    return res / 2\nfact[0] = 1\nfact[1] = 1\nfor i in range(2, MAXF):\n    fact[i] = fact[i - 1] * i % MOD7\nT = int(input())\nfor _ in range(T):\n    (s, e) = map(int, input().split(' '))\n    (start_level, start_index) = get_level_index(s)\n    (end_level, end_index) = get_level_index(e)\n    level = end_level - start_level\n    index = end_index - start_index\n    ans = -1\n    if level <= 0 or index < 0 or index > level:\n        ans = 0\n    else:\n        ans = levelCindex(level, index)\n    print(ans)", "from math import sqrt\n\ndef level(x):\n    le = lambda i: i * (i + 1) // 2\n    if x == 1:\n        return (1, 1)\n    else:\n        st = 2\n        end = int(sqrt(2 * x)) + 1\n        while st <= end:\n            mid = (st + end) // 2\n            t1 = le(mid)\n            t2 = le(mid - 1)\n            if x <= t1 and t2 < x:\n                break\n            elif t1 < x:\n                st = mid + 1\n            else:\n                end = mid - 1\n        return (mid, x - le(mid - 1))\n\ndef factorial(y):\n    if y < 2:\n        return y\n    else:\n        f = [0 for i in range(y + 1)]\n        f[0] = 1\n        f[1] = 1\n        i = 2\n        while i < y + 1:\n            f[i] = f[i - 1] * i % (10 ** 9 + 7)\n            i += 1\n        return f[y]\nT = int(input())\nfor tc in range(T):\n    (s, e) = map(int, input().split())\n    (s1, s2) = level(s)\n    (e1, e2) = level(e)\n    a = e1 - s1\n    b = e2 - s2\n    if a <= 0 or b < 0 or b > a:\n        print(0)\n    else:\n        z = 10 ** 9 + 7\n        nm = 1\n        dn = 1\n        for i in range(b):\n            nm = nm * (a - i) % z\n            dn = dn * (i + 1) % z\n        print(nm * pow(dn, z - 2, z) % z)", "t = int(input())\nfact = [0] * (10 ** 5 + 7)\nfact[0] = fact[1] = 1\nfor i in range(2, 10 ** 5 + 7):\n    fact[i] = i * fact[i - 1] % (10 ** 9 + 7)\n\ndef get_level_indx(s):\n    n = int((1 + pow(1 + 8 * (s - 1), 0.5)) / 2)\n    n_start = n * (n - 1) // 2 + 1\n    s_indx = s - n_start\n    return (n, s_indx + 1)\n\ndef inv(x, y):\n    return pow(x, y - 2, y)\n\ndef solve(n, k, p=10 ** 9 + 7):\n    return fact[n] * inv(fact[k], p) % p * inv(fact[n - k], p) % p\nfor _ in range(t):\n    (s, e) = [int(x) for x in input().split()]\n    (s_level, s_indx) = get_level_indx(s)\n    (e_level, e_indx) = get_level_indx(e)\n    level_diff = e_level - s_level\n    indx_diff = e_indx - s_indx\n    if level_diff <= 0 or indx_diff < 0 or indx_diff > level_diff:\n        print(0)\n    else:\n        print(solve(level_diff, indx_diff))", "import math\n\ndef modPow(a, x, p):\n    res = 1\n    while x > 0:\n        if x % 2 != 0:\n            res = res * a % p\n        a = a * a % p\n        x //= 2\n    return res\n\ndef modInverse(a, p):\n    return modPow(a, p - 2, p)\n\ndef modBinomial(n, k, p):\n    numerator = 1\n    for i in range(k):\n        numerator = numerator * (n - i) % p\n    denominator = 1\n    for i in range(1, k + 1):\n        denominator = denominator * i % p\n    return numerator * modInverse(denominator, p) % p\n\ndef binarySearch(num):\n    if num == 1:\n        return 1\n    left = 2\n    right = 1 + math.ceil(math.sqrt(2 * num))\n    middle = -1\n    while left < right:\n        middle = (right + left) // 2\n        lastElem = middle * (middle + 1) // 2\n        prevLast = middle * (middle - 1) // 2\n        if prevLast < num <= lastElem:\n            break\n        elif num < lastElem:\n            right = middle\n        else:\n            left = middle\n    return middle\n\ndef findLoc(num):\n    level = binarySearch(num)\n    ind = num - level * (level - 1) // 2\n    res = (level, ind)\n    return res\n\ndef findNumOfPaths(s, e):\n    dataS = findLoc(s)\n    dataE = findLoc(e)\n    levels = dataE[0] - dataS[0]\n    indices = dataE[1] - dataS[1]\n    p = 10 ** 9 + 7\n    if levels <= 0 or indices < 0 or indices > levels:\n        return 0\n    else:\n        return modBinomial(levels, indices, p)\nT = int(input())\nfor _ in range(T):\n    (s, e) = map(int, input().split())\n    print(findNumOfPaths(s, e))", "import math\nMOD7 = pow(10, 9) + 7\nMAXF = pow(10, 5)\nmy_list = [0] * (MAXF + 1)\n\ndef last(l):\n    return (l + 1) * l / 2\n\ndef get_level_and_index(n):\n    ind = -1\n    line = -1\n    if n == 1:\n        return (1, 1)\n    left = 2\n    right = 1 + math.floor(math.sqrt(2 * n))\n    while left <= right:\n        line = int((left + right) / 2)\n        if last(line) >= n and last(line - 1) < n:\n            break\n        elif last(line > n):\n            right = l - 1\n        else:\n            left = line + 1\n    ind = int(n - line * (line - 1) / 2)\n    return (line, ind)\n\ndef pow_mod(x, y, p):\n    x = x % p\n    if x == 0:\n        return 0\n    res = 1\n    while y > 0:\n        if y & 1:\n            res = res * x\n            res = res % p\n            y = y - 1\n        x = x * x % p\n        y = int(y / 2)\n    return res\n\ndef inv(x, p):\n    return pow_mod(x, p - 2, p)\n\ndef lci(line, i, p=MOD7):\n    x = my_list[line] * inv(my_list[i], p) % p\n    y = inv(my_list[line - i], p)\n    return x * y % p\nmy_list[0] = 1\nmy_list[1] = 1\nfor i in range(2, MAXF):\n    my_list[i] = my_list[i - 1] * i % MOD7\nT = int(input())\nfor _ in range(T):\n    (s, e) = map(int, input().split(' '))\n    (start_l, start_i) = get_level_and_index(s)\n    (end_l, end_i) = get_level_and_index(e)\n    line = end_l - start_l\n    i = end_i - start_i\n    ans = -1\n    if line <= 0 or i < 0 or i > line:\n        ans = 0\n    else:\n        ans = lci(line, i)\n    print(ans)", "import math\nMOD = 1000000007\nmemo_table = {}\n\ndef get_level(k):\n    return math.ceil((math.sqrt(8 * k + 1) - 1) / 2)\n\ndef check_path(m, lsv, lev):\n    if m >= lsv and m <= lev:\n        return True\n    else:\n        return False\n\ndef get_end_level_interval(n, sl, el):\n    diff = el - sl\n    lsv = n + diff * (sl + el - 1) // 2\n    lev = n + diff * (sl + 1 + el) // 2\n    return (lsv, lev)\n\ndef get_paths(h, k):\n    if (h, k) in memo_table:\n        return memo_table[h, k]\n    elif (k, h) in memo_table:\n        return memo_table[k, h]\n    else:\n        num = den = 1\n        for i in range(k - 1):\n            num = num * (h + k - 2 - i) % MOD\n            den = den * (i + 1) % MOD\n        res = num * pow(den, MOD - 2, MOD) % MOD\n        memo_table[h, k] = res\n        return res\nt = int(input())\nwhile t:\n    (n, m) = tuple(map(int, input().strip().split()))[:2]\n    if n >= m:\n        print(0)\n        t -= 1\n        continue\n    N = get_level(n)\n    M = get_level(m)\n    if M == N:\n        print(0)\n        t -= 1\n        continue\n    (lsv, lev) = get_end_level_interval(n, N, M)\n    if check_path(m, lsv, lev):\n        s1 = M - N - (m - lsv) + 1\n        s2 = m - lsv + 1\n        res = get_paths(s1, s2)\n        print(res)\n        t -= 1\n        continue\n    else:\n        print(0)\n        t -= 1\n        continue", "def level(i):\n    st = 1\n    en = 10000000\n    while st <= en:\n        mid = (st + en) // 2\n        if mid * (mid + 1) // 2 > i:\n            en = mid - 1\n        elif mid * (mid + 1) // 2 < i:\n            st = mid + 1\n        else:\n            return mid\n    return st\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nMOD = 10 ** 9 + 7\nt = int(input())\nwhile t:\n    t -= 1\n    (s, e) = map(int, input().split(' '))\n    if s > e:\n        print(0)\n        continue\n    (ns, ne) = (level(s) - 1, level(e) - 1)\n    (rs, re) = (s - ns * (ns + 1) // 2 - 1, e - ne * (ne + 1) // 2 - 1)\n    if ne <= ns or re < rs:\n        print(0)\n        continue\n    print(ncr(ne - ns, re - rs, MOD))", "import math\nmod7 = 10 ** 9 + 7\nmaxf = 10 ** 5\nfact = [0] * (maxf + 1)\nfact[0] = fact[1] = 1\nfor i in range(2, maxf + 1):\n    fact[i] = fact[i - 1] * i % mod7\n\ndef powmod(a, b, p):\n    a %= p\n    if a == 0:\n        return 0\n    to_ret = 1\n    while b > 0:\n        if b % 2 == 1:\n            to_ret *= a\n            to_ret %= p\n            b -= 1\n        a *= a\n        a %= p\n        b = int(b / 2)\n    return to_ret\n\ndef inv(a, p):\n    return powmod(a, p - 2, p)\n\ndef nCk(n, k, p):\n    return fact[n] * inv(fact[k], p) % p * inv(fact[n - k], p) % p\n\ndef last_item(lvl):\n    return int((lvl + 1) * lvl / 2)\n\ndef lvl_idx(n: int):\n    lvl: int = -1\n    idx: int = -1\n    if n == 1:\n        return (1, 1)\n    st: int = 2\n    end: int = 1 + int(math.ceil(math.sqrt(2 * n)))\n    while st <= end:\n        lvl = int((st + end) / 2)\n        if last_item(lvl) >= n > last_item(lvl - 1):\n            break\n        elif last_item(lvl) > n:\n            end = lvl - 1\n        else:\n            st = lvl + 1\n    idx = n - int(lvl * (lvl - 1) / 2)\n    return (lvl, idx)\ntry:\n    for t in range(int(input())):\n        the_input = input().split()\n        s = int(the_input[0])\n        e = int(the_input[1])\n        res1 = lvl_idx(s)\n        res2 = lvl_idx(e)\n        L = res2[0] - res1[0]\n        K = res2[1] - res1[1]\n        res = -1\n        if L <= 0 or K < 0 or K > L:\n            res = 0\n        else:\n            res = nCk(L, K, mod7)\n        print(res)\nexcept EOFError as e:\n    pass", "import math\nfrom fractions import Fraction\n\ndef factorial():\n    fact[0] = 1\n    fact[1] = 1\n    for i in range(2, 100001):\n        fact[i] = fact[i - 1] * i % 1000000007\n\ndef inverse(n):\n    v = 1000000005\n    p = 1000000007\n    n = n % p\n    if n == 0:\n        return 0\n    val = 1\n    while v > 0:\n        if v % 2 == 1:\n            val = val * n\n            val = val % p\n            v -= 1\n        n = n * n\n        n = n % p\n        v = v // 2\n    return val\n\ndef ncr(n, r):\n    fn = fact[n]\n    fr = fact[r]\n    fnr = fact[n - r]\n    val = fnr * fr\n    ls = str(Fraction(fn, val)).split('/')\n    if len(ls) == 1:\n        numr = int(ls[0])\n        val = numr % 1000000007\n    else:\n        numr = int(ls[0])\n        denmr = int(ls[1])\n        denmr = inverse(denmr)\n        val = numr * denmr % 1000000007\n    return val\n\ndef pos(n):\n    if n == 1:\n        return (1, 1)\n    l = 1\n    r = int(math.sqrt(2 * n)) + 2\n    while l <= r:\n        m = (l + r) // 2\n        lm = m * (m + 1) // 2\n        lm1 = (m - 1) * m // 2\n        if lm >= n and lm1 < n:\n            break\n        elif lm < n:\n            l = m + 1\n        else:\n            r = m - 1\n    pos = n - m * (m - 1) // 2\n    return (m, pos)\nfact = [1] * 100001\nfactorial()\nt = int(input())\nfor i in range(t):\n    (s, e) = map(int, input().split())\n    (sl, spos) = pos(s)\n    (el, epos) = pos(e)\n    dl = el - sl\n    dpos = epos - spos\n    if dl > 0 and (dpos >= 0 and dpos <= dl):\n        print(ncr(dl, dpos))\n    else:\n        print(0)", "import math\nfrom fractions import Fraction\n\ndef factorial():\n    fact[0] = 1\n    fact[1] = 1\n    for i in range(2, 10000001):\n        fact[i] = fact[i - 1] * i % 1000000007\n\ndef inverse(n):\n    v = 1000000005\n    p = 1000000007\n    n = n % p\n    if n == 0:\n        return 0\n    val = 1\n    while v > 0:\n        if v % 2 == 1:\n            val = val * n\n            val = val % p\n            v -= 1\n        n = n * n\n        n = n % p\n        v = v // 2\n    return val\n\ndef ncr(n, r):\n    fn = fact[n]\n    fr = fact[r]\n    fnr = fact[n - r]\n    val = fnr * fr\n    ls = str(Fraction(fn, val)).split('/')\n    if len(ls) == 1:\n        numr = int(ls[0])\n        val = numr % 1000000007\n    else:\n        numr = int(ls[0])\n        denmr = int(ls[1])\n        denmr = inverse(denmr)\n        val = numr * denmr % 1000000007\n    return val\n\ndef pos(n):\n    if n == 1:\n        return (1, 1)\n    l = 1\n    r = int(math.sqrt(2 * n)) + 2\n    while l <= r:\n        m = (l + r) // 2\n        lm = m * (m + 1) // 2\n        lm1 = (m - 1) * m // 2\n        if lm >= n and lm1 < n:\n            break\n        elif lm < n:\n            l = m + 1\n        else:\n            r = m - 1\n    pos = n - m * (m - 1) // 2\n    return (m, pos)\nfact = [1] * 10000001\nfactorial()\nt = int(input())\nfor i in range(t):\n    (s, e) = map(int, input().split())\n    (sl, spos) = pos(s)\n    (el, epos) = pos(e)\n    dl = el - sl\n    dpos = epos - spos\n    if dl > 0 and (dpos >= 0 and dpos <= dl):\n        print(ncr(dl, dpos))\n    else:\n        print(0)", "import math\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef coordinates(a):\n    D = math.sqrt(8 * a + 1)\n    n = (D - 1) / 2\n    if n.is_integer():\n        y = int(n)\n    else:\n        y = math.ceil(n)\n    x = 2 * a - y * y - 1\n    coordinate = (x, y)\n    return coordinate\n\ndef possible_ways(s, e):\n    x1 = coordinates(s)[0]\n    x2 = coordinates(e)[0]\n    y1 = coordinates(s)[1]\n    y2 = coordinates(e)[1]\n    answer = 0\n    if s == e:\n        answer = 1\n    elif y2 - y1 < abs(x2 - x1):\n        answer = 0\n    else:\n        answer = ncr(int(y2 - y1), int(int(y2 - y1 + x2 - x1) / 2), 1000000007)\n    return answer\nT = int(input())\nfor i in range(T):\n    list = [int(x) for x in input().split()]\n    s = list[0]\n    e = list[1]\n    print(possible_ways(s, e))", "import math\nmod = int(1000000000.0 + 7)\nfact = {}\nfact[0] = 1\nfor i in range(1, 1000001):\n    fact[i] = int(fact[i - 1] * i % mod)\n\ndef find_lvl_ind(v):\n    D = math.ceil(math.sqrt(1 + 8 * v))\n    if D % 2 == 0:\n        D = D + 1\n    lvl = (D - 1) / 2\n    while True:\n        l = (lvl - 1) * lvl / 2\n        m = (lvl + 1) * lvl / 2\n        if v <= m and v > l:\n            break\n        elif v > m:\n            lvl = lvl + 1\n        else:\n            lvl = lvl - 1\n    last_lvl_max = (lvl - 1) * lvl / 2\n    index = v - last_lvl_max\n    return (lvl, index - 1)\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef modInverse(a, p):\n    return power(a, p - 2, p)\n\ndef nCrModp(n, r, p):\n    return fact[n] * modInverse(fact[r], p) % p * modInverse(fact[n - r], p) % p\nfor _ in range(int(input())):\n    (s, e) = map(int, input().split())\n    (s_lvl, s_index) = find_lvl_ind(s)\n    (e_lvl, e_index) = find_lvl_ind(e)\n    L = e_lvl - s_lvl\n    I = e_index - s_index\n    p = 1\n    if I > L or I < 0 or L <= 0:\n        p = 0\n    else:\n        p = nCrModp(int(L), int(I), mod)\n    print(int(p))", "import math\nmod7 = 10 ** 9 + 7\nmaxf = 10 ** 5\nfact = [0] * (maxf + 1)\n\ndef power_mod(a, b, p):\n    a %= p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b % 2 == 1:\n            product *= a\n            product %= p\n            b -= 1\n        a *= a\n        a %= p\n        b = int(b / 2)\n    return product\n\ndef inv(a, p):\n    return power_mod(a, p - 2, p)\n\ndef number_of_routes(n, k, p):\n    return fact[n] * inv(fact[k], p) % p * inv(fact[n - k], p) % p\n\ndef last_elem(level):\n    return int((level + 1) * level / 2)\n\ndef level_and_index(n):\n    level = -1\n    index = -1\n    if n == 1:\n        return (1, 1)\n    st = 2\n    end = 1 + int(math.ceil(math.sqrt(2 * n)))\n    while st <= end:\n        level = int((st + end) / 2)\n        if last_elem(level) >= n > last_elem(level - 1):\n            break\n        elif last_elem(level) > n:\n            end = level - 1\n        else:\n            st = level + 1\n    index = n - int(level * (level - 1) / 2)\n    return (level, index)\nfact[0] = fact[1] = 1\nfor i in range(2, maxf + 1):\n    fact[i] = fact[i - 1] * i % mod7\ntimes = int(input())\nresults = []\nfor i in range(times):\n    inputs = input().split()\n    s = int(inputs[0])\n    e = int(inputs[1])\n    (s_level, s_index) = level_and_index(s)\n    (e_level, e_index) = level_and_index(e)\n    level = e_level - s_level\n    index = e_index - s_index\n    if level <= 0 or index < 0 or index > level:\n        result = 0\n    else:\n        result = number_of_routes(level, index, mod7)\n    results.append(result)\nfor r in results:\n    print(r)", "import math\nmod7 = 10 ** 9 + 7\nmaxf = 10 ** 5\nfact = [0] * (maxf + 1)\n\ndef powmod(a, b, p):\n    a %= p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b % 2 == 1:\n            product *= a\n            product %= p\n            b -= 1\n        a *= a\n        a %= p\n        b = int(b / 2)\n    return product\n\ndef inv(a, p):\n    return powmod(a, p - 2, p)\n\ndef nCk(n, k, p):\n    return fact[n] * inv(fact[k], p) % p * inv(fact[n - k], p) % p\n\ndef last_elem(lvl):\n    return int((lvl + 1) * lvl / 2)\n\ndef lvl_idx(n: int):\n    lvl: int = -1\n    idx: int = -1\n    if n == 1:\n        return (1, 1)\n    st: int = 2\n    end: int = 1 + int(math.ceil(math.sqrt(2 * n)))\n    while st <= end:\n        lvl = int((st + end) / 2)\n        if last_elem(lvl) >= n > last_elem(lvl - 1):\n            break\n        elif last_elem(lvl) > n:\n            end = lvl - 1\n        else:\n            st = lvl + 1\n    idx = n - int(lvl * (lvl - 1) / 2)\n    return (lvl, idx)\nfact[0] = fact[1] = 1\nfor i in range(2, maxf + 1):\n    fact[i] = fact[i - 1] * i % mod7\nt = int(input())\nfor _ in range(t):\n    (s, e) = tuple((int(x) for x in input().split()))\n    res1 = lvl_idx(s)\n    res2 = lvl_idx(e)\n    slv1 = res1[0]\n    sidx = res1[1]\n    elv1 = res2[0]\n    eidx = res2[1]\n    L = elv1 - slv1\n    K = eidx - sidx\n    _ans = -1\n    if L <= 0 or K < 0 or K > L:\n        _ans = 0\n    else:\n        _ans = nCk(L, K, mod7)\n    print(_ans)", "import math\n\ndef XtoRC(X):\n    R = math.ceil((math.sqrt(8 * X + 1) - 1) / 2 - 1)\n    C = 2 * (X - 1) - R * (R + 2)\n    return (R, C)\n\ndef RCtoX(R, C):\n    return (C + R * (R + 2)) // 2 + 1\nMOD = 10 ** 9 + 7\n\ndef modpow(base, exp, mod):\n    result = 1\n    while exp:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef modinv(base, mod):\n    return modpow(base, mod - 2, mod)\n(FACT, FACTINV) = ([1] * 44750, [1] * 44750)\nfor k in range(1, 44750):\n    FACT[k] = k * FACT[k - 1] % MOD\n    FACTINV[k] = modinv(FACT[k], MOD)\n\ndef naive(RS, CS, RE, CE):\n    if RS == RE and CS == CE:\n        return 1\n    if abs(CE - CS) > RE - RS:\n        return 0\n    if CE > CS:\n        CE = CS * 2 - CE\n    (RS, CS, RE, CE) = (0, 0, RE - RS, CE - CS)\n    return FACT[RE] * FACTINV[(RE + CE) // 2] * FACTINV[(RE - CE) // 2] % MOD\n\ndef main(S, E):\n    (RC_S, RC_E) = (XtoRC(S), XtoRC(E))\n    return naive(RC_S[0], RC_S[1], RC_E[0], RC_E[1])\nT = int(input().strip())\nfor _ in range(T):\n    (S, E) = [int(x) for x in input().strip().split()[:2]]\n    print(main(S, E))", "import math\nMOD7 = pow(10, 9) + 7\nMAXF = pow(10, 5)\nfact = [0] * (MAXF + 1)\n\ndef last_element(level):\n    return (level + 1) * level / 2\n\ndef get_level_index(n):\n    level = -1\n    index = -1\n    if n == 1:\n        return (1, 1)\n    start = 2\n    end = 1 + math.floor(math.sqrt(2 * n))\n    while start <= end:\n        level = int((start + end) / 2)\n        if last_element(level) >= n and last_element(level - 1) < n:\n            break\n        elif last_element(level > n):\n            end = level - 1\n        else:\n            start = level + 1\n    index = int(n - level * (level - 1) / 2)\n    return (level, index)\n\ndef pow_mod(a, b, p):\n    a = a % p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b & 1:\n            product = product * a\n            product = product % p\n            b = b - 1\n        a = a * a % p\n        b = int(b / 2)\n    return product\n\ndef inv(a, p):\n    return pow_mod(a, p - 2, p)\n\ndef levelCindex(level, index, p=MOD7):\n    a = fact[level] * inv(fact[index], p) % p\n    b = inv(fact[level - index], p)\n    return a * b % p\nfact[0] = 1\nfact[1] = 1\nfor i in range(2, MAXF):\n    fact[i] = fact[i - 1] * i % MOD7\nT = int(input())\nfor _ in range(T):\n    (s, e) = map(int, input().split(' '))\n    (start_level, start_index) = get_level_index(s)\n    (end_level, end_index) = get_level_index(e)\n    level = end_level - start_level\n    index = end_index - start_index\n    ans = -1\n    if level <= 0 or index < 0 or index > level:\n        ans = 0\n    else:\n        ans = levelCindex(level, index)\n    print(ans)", "import math\nMOD7 = pow(10, 9) + 7\nMAXF = pow(10, 5)\nfact = [0] * (MAXF + 1)\n\ndef last_element(level):\n    return (level + 1) * level / 2\n\ndef get_level_index(n):\n    level = -1\n    index = -1\n    if n == 1:\n        return (1, 1)\n    start = 2\n    end = 1 + math.floor(math.sqrt(2 * n))\n    while start <= end:\n        level = int((start + end) / 2)\n        if last_element(level) >= n and last_element(level - 1) < n:\n            break\n        elif last_element(level > n):\n            end = level - 1\n        else:\n            start = level + 1\n    index = int(n - level * (level - 1) / 2)\n    return (level, index)\n\ndef pow_mod(a, b, p):\n    a = a % p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b & 1:\n            product = product * a\n            product = product % p\n            b = b - 1\n        a = a * a % p\n        b = int(b / 2)\n    return product\n\ndef inv(a, p):\n    return pow_mod(a, p - 2, p)\n\ndef levelCindex(level, index, p=MOD7):\n    a = fact[level] * inv(fact[index], p) % p\n    b = inv(fact[level - index], p)\n    return a * b % p\nfact[0] = 1\nfact[1] = 1\nfor i in range(2, MAXF):\n    fact[i] = fact[i - 1] * i % MOD7\nT = int(input())\nfor _ in range(T):\n    (s, e) = map(int, input().split(' '))\n    (start_level, start_index) = get_level_index(s)\n    (end_level, end_index) = get_level_index(e)\n    level = end_level - start_level\n    index = end_index - start_index\n    ans = -1\n    if level <= 0 or index < 0 or index > level:\n        ans = 0\n    else:\n        ans = levelCindex(level, index)\n    print(ans)", "def find_row_col(num):\n    (low, high) = (1, 50000)\n    row = -1\n    while low <= high:\n        mid = (low + high) // 2\n        val = mid * (mid + 1) // 2\n        if num > val:\n            low = mid + 1\n        else:\n            row = mid\n            high = mid - 1\n    k = num - row * (row - 1) // 2\n    return (k, row - k + 1)\nP = int(1000000000.0 + 7)\n\ndef nCr(n, r):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % P\n        den = den * (i + 1) % P\n    return num * pow(den, P - 2, P) % P\nfor _ in range(int(input())):\n    (s, e) = map(int, input().strip().split())\n    ((row_s, col_s), (row_e, col_e)) = (find_row_col(s), find_row_col(e))\n    if row_e < row_s or col_e < col_s:\n        print(0)\n    elif row_e == row_s and col_e == col_s:\n        print(1)\n    else:\n        (m, n) = (row_e - row_s, col_e - col_s)\n        print(nCr(m + n, min(m, n)))", "m = pow(10, 9) + 7\nfac_m = [0 for c in range(50001)]\nfac_m[0] = 1\nfor i in range(1, 50001):\n    fac_m[i] = fac_m[i - 1] * i % m\ninv_fac_m = [0 for d in range(50001)]\ninv_fac_m[50000] = pow(fac_m[-1], m - 2, m)\nfor j in range(49999, -1, -1):\n    inv_fac_m[j] = inv_fac_m[j + 1] * (j + 1) % m\nimport math\nfor i in range(int(input())):\n    (s, e) = map(int, input().split())\n\n    def row(x):\n        res = (-1 + math.sqrt(1 + 8 * x)) / 2\n        return math.ceil(res)\n    s_row = row(s)\n    e_row = row(e)\n    n = e_row - s_row\n    a = s + (e_row - s_row) * (e_row + s_row - 1) // 2\n    b = s + (e_row - s_row) * (e_row + s_row + 1) // 2\n    if n <= 0:\n        print(0)\n    elif e > b or e < a:\n        print(0)\n    else:\n        k = e - a\n        print(fac_m[n] * inv_fac_m[k] * inv_fac_m[n - k] % m)", "import bisect as bi\nM = 10 ** 9 + 7\nN = 10 ** 5\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m=M):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nfact = [1, 1]\nfor i in range(2, N + 1):\n    fact.append(fact[-1] * i % M)\nnumsPerRow = [i * (i + 1) // 2 + 1 for i in range(N)]\n\ndef findpos(x):\n    i = bi.bisect_right(numsPerRow, x)\n    return (i, x - numsPerRow[i - 1])\nfor _ in range(int(input())):\n    (s, e) = list(map(int, input().split()))\n    (srow, sidx) = findpos(s)\n    (erow, eidx) = findpos(e)\n    if erow <= srow or eidx < sidx or eidx - sidx > erow - srow:\n        print(0)\n    else:\n        R = eidx - sidx\n        L = erow - srow - R\n        print(fact[L + R] * modinv(fact[L] * fact[R]) % M)", "(Ln, mod) = (4 * 10 ** 4, 10 ** 9 + 7)\nft = [1] * Ln\nfor i in range(2, Ln):\n    ft[i] = ft[i - 1] * i % mod\nt = int(input())\nfor _ in range(t):\n    h = 1\n    (s, e) = map(int, input().split())\n    if s > e:\n        print(0)\n        continue\n    while h * (h + 1) // 2 < s:\n        h += 1\n    L = h\n    while h * (h + 1) // 2 < e:\n        h += 1\n    H = h\n    n = H - L\n    r = e - H * (H - 1) // 2 + L * (L - 1) // 2 - s\n    if n == 0 or n < r or r < 0:\n        print(0)\n        continue\n    R = pow(ft[r], mod - 2, mod)\n    NR = pow(ft[n - r], mod - 2, mod)\n    print(ft[n] * R % mod * NR % mod)", "(Ln, mod) = (10 ** 5, 10 ** 9 + 7)\nft = [1] * Ln\nfor i in range(2, Ln):\n    ft[i] = ft[i - 1] * i % mod\nt = int(input())\nfor _ in range(t):\n    h = 1\n    (s, e) = map(int, input().split())\n    if s > e:\n        print(0)\n        continue\n    while h * (h + 1) // 2 < s:\n        h += 1\n    L = h\n    while h * (h + 1) // 2 < e:\n        h += 1\n    H = h\n    n = H - L\n    r = e - H * (H - 1) // 2 + L * (L - 1) // 2 - s\n    if n == 0 or n < r or r < 0:\n        print(0)\n        continue\n    R = pow(ft[r], mod - 2, mod)\n    NR = pow(ft[n - r], mod - 2, mod)\n    print(ft[n] * R % mod * NR % mod)", "import math\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nwhile t > 0:\n    (s, e) = map(int, input().split())\n    x = math.sqrt(1 + 8 * s)\n    y = math.sqrt(1 + 8 * e)\n    s_row = math.ceil((x - 1) / 2)\n    s_column = s - s_row * (s_row - 1) // 2\n    e_row = math.ceil((y - 1) / 2)\n    e_column = e - e_row * (e_row - 1) // 2\n    r = e_column - s_column\n    n = e_row - s_row\n    p = int(1000000000.0 + 7)\n    if n <= 0 or r < 0 or r > n:\n        print(0)\n    else:\n        ans = ncr(n, r, p)\n        print(ans)\n    t = t - 1", "import math\nmod7 = 1000000007\nMAXF = 100000\n\ndef powmod(a, b, p):\n    a = a % p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b % 2 == 1:\n            product = product * a\n            product = product % p\n            b = b - 1\n        a = a * a\n        a = a % p\n        b = b / 2\n    return product\n\ndef inv(a, p):\n    return powmod(a, p - 2, p)\n\ndef nCk(n, k, p):\n    return fact[n] * inv(fact[k], p) % p * inv(fact[n - k], p) % p\n\ndef last_elem(level):\n    return (level + 1) * level / 2\n\ndef get_level_index(n):\n    level = -1\n    index = -1\n    if n == 1:\n        return (1, 1)\n    start = 2\n    end = 1 + math.ceil(math.sqrt(2 * n))\n    while start <= end:\n        level = (start + end) / 2\n        level = math.floor(level)\n        if last_elem(level) >= n and last_elem(level - 1) < n:\n            break\n        elif last_elem(level) > n:\n            end = level - 1\n        else:\n            start = level + 1\n    index = n - level * (level - 1) / 2\n    index = int(index)\n    return (level, index)\nfact = []\nfact.append(1)\nfact.append(1)\nfor i in range(MAXF + 1):\n    i = i + 2\n    fact.append(fact[i - 1] * i % mod7)\nt = int(input())\nfor i in range(t):\n    (s, e) = map(str, input().split(' '))\n    s = int(s)\n    e = int(e)\n    (slevel, sindex) = get_level_index(s)\n    (elevel, eindex) = get_level_index(e)\n    L = elevel - slevel\n    K = eindex - sindex\n    ans = -1\n    if L <= 0 or K < 0 or K > L:\n        ans = 0\n    else:\n        ans = nCk(L, K, mod7)\n    print(ans)", "from bisect import bisect_left, bisect_right\nN = 50000\nfact = [1]\nmod = 1000000007\nfor i in range(1, N + 1):\n    fact.append(fact[-1] * i % mod)\narr = []\nc = 1\nfor i in range(0, N):\n    arr.append(c + i)\n    c += i\nt = int(input())\nfor i in range(t):\n    (s, e) = map(int, input().split())\n    x = bisect_right(arr, s) - 1\n    y = bisect_right(arr, e) - 1\n    df = y - x\n    d1 = s - arr[x]\n    d2 = arr[x + 1] - s - 1\n    d3 = e - arr[y]\n    d4 = arr[y + 1] - e - 1\n    if s > e:\n        print(0)\n    elif d3 < d1 or d4 < d2:\n        print(0)\n    else:\n        num = fact[df]\n        den = fact[df - (e - arr[y] - d1)] * fact[e - arr[y] - d1] % mod\n        ans = num * pow(den, mod - 2, mod) % mod\n        print(ans)", "import math\n\ndef ind_level(a, dic):\n    if a == 0:\n        return (-1, -1)\n    if a == 1:\n        return (1, 1)\n    else:\n        st = 2\n        end = 49999\n        while st <= end:\n            m = (st + end) // 2\n            if dic[m][0] <= a and dic[m][1] >= a:\n                return (m, a - dic[m][0] + 1)\n            elif dic[m][0] > a:\n                end = m - 1\n            elif dic[m][1] < a:\n                st = m + 1\n\ndef pmd(a, b, c):\n    a %= c\n    if a == 0:\n        return 0\n    prod = 1\n    while b > 0:\n        if b % 2 == 1:\n            prod *= a\n            prod %= c\n            b -= 1\n        a *= a\n        a %= c\n        b /= 2\n    return prod\n\ndef inv(a, p):\n    return pmd(a, p - 2, p)\n\ndef ncr(n, k, p):\n    return fact[n] * inv(fact[k], p) % p * inv(fact[n - k], p) % p\nt = int(input())\ndic = {}\nfor i in range(1, 50000):\n    k = i * (i + 1) // 2\n    dic[i] = [k - i + 1, k, i]\nmod = 10 ** 9 + 7\nfact = [1, 1]\nfor i in range(2, 50000):\n    fact.append(i * fact[i - 1] % mod)\nfor i in range(t):\n    [a, b] = list(map(int, input().split()))\n    if a > b:\n        print(0)\n    else:\n        (lvl1, ind1) = ind_level(a, dic)\n        (lvl2, ind2) = ind_level(b, dic)\n        ldif = lvl2 - lvl1\n        idif = ind2 - ind1\n        if ldif <= 0 or idif < 0 or ldif < idif:\n            print(0)\n        elif ldif == idif:\n            print(1)\n        else:\n            print(int(ncr(ldif, idif, mod)))", "import math\nt = int(input())\nmod = 10 ** 9 + 7\nfact = [1, 1]\nfor i in range(2, 50000):\n    fact.append(fact[-1] * i % mod)\n\ndef modInv(val):\n    return pow(val, mod - 2, mod)\n\ndef getRow(val):\n    row = math.ceil((-1 + math.sqrt(1 + 8 * val)) / 2)\n    return row\n\ndef getCol(row, val):\n    last = row * (row + 1) // 2\n    return row - (last - val)\nfor _ in range(t):\n    (s, e) = map(int, input().split())\n    if s > e:\n        print(0)\n    else:\n        r1 = getRow(s)\n        c1 = getCol(r1, s)\n        r2 = getRow(e)\n        c2 = getCol(r2, e)\n        r1 -= 1\n        c1 -= 1\n        r2 -= 1\n        c2 -= 1\n        if c2 - c1 >= 0 and c2 - c1 <= r2 - r1:\n            r = r2 - r1\n            c = c2 - c1\n            ans = fact[r] * modInv(fact[c]) % mod * modInv(fact[r - c]) % mod % mod\n            print(ans)\n        else:\n            print(0)", "from math import *\nt = int(input())\nfor _ in range(t):\n    (s, e) = map(int, input().split())\n\n    def getRow(x):\n        return int((1 + (8 * x - 3) ** 0.5) / 2)\n\n    def getCol(x, n):\n        return x - n * (n - 1) // 2\n\n    def pow(x, y, p):\n        res = 1\n        x %= p\n        while y > 0:\n            if y % 2 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def nCr(n, r, p):\n        res = 1\n        res1 = 1\n        for i in range(r):\n            res *= n - i\n            res %= p\n            res1 *= i + 1\n            res1 %= p\n        return res * pow(res1, p - 2, p) % p\n    x1 = getRow(s)\n    x2 = getRow(e)\n    y1 = getCol(s, x1)\n    y2 = getCol(e, x2)\n    d = x2 - x1\n    r = y2 - y1\n    if d >= 0 and d >= r and (r >= 0):\n        y = nCr(d, r, 10 ** 9 + 7)\n        print(int(y) % (10 ** 9 + 7))\n    else:\n        print(0)", "mod = 10 ** 9 + 7\n\ndef GetPosition(x):\n    last_complete_row = (-1 + (1 + 8 * x) ** 0.5) // 2\n    remainder = x - last_complete_row * (last_complete_row + 1) // 2\n    if remainder:\n        row = last_complete_row + 1\n        col = remainder\n        return (int(row), int(col))\n    row = col = last_complete_row\n    return (int(row), int(col))\n\ndef ModInverse(n):\n    return pow(n, mod - 2, mod)\n\ndef NChooseK(n, k):\n    numerator = factorial[n]\n    denom = factorial[n - k] * factorial[k] % mod\n    return numerator * ModInverse(denom) % mod\nfactorial = [1]\nfor n in range(1, 46000):\n    factorial += [factorial[-1] * n % mod]\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    (x_start, x_end) = [int(x) for x in input().split()]\n    (row_start, col_start) = GetPosition(x_start)\n    (row_end, col_end) = GetPosition(x_end)\n    rows_down = row_end - row_start\n    cols_over = col_end - col_start\n    if rows_down < 0 or cols_over < 0 or cols_over > rows_down:\n        print(0)\n        continue\n    ans = NChooseK(rows_down, cols_over)\n    print(ans)", "import math\nmod = int(1000000000.0 + 7)\n\ndef sum_natural(n):\n    return n * (n + 1) / 2\n\ndef binary_search(n, st, end):\n    if n == 1:\n        return 1\n    if end >= st:\n        level = st + (end - st) // 2\n        if sum_natural(level) >= n and sum_natural(level - 1) < n:\n            return level\n        elif sum_natural(level) > n:\n            return binary_search(n, st, level - 1)\n        else:\n            return binary_search(n, level + 1, end)\n\ndef fact(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] * i % mod\n    return dp\n\ndef powmod(a, b, p):\n    a %= p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b % 2 == 1:\n            product *= a\n            product %= p\n            b -= 1\n        a *= a\n        a %= p\n        b /= 2\n    return product\n\ndef inv(a, p):\n    return powmod(a, p - 2, p)\n\ndef ncr(n, r, precomp_fact):\n    return precomp_fact[n] * inv(precomp_fact[r], mod) % mod * inv(precomp_fact[n - r], mod) % mod\n\ndef solve(precomp_fact):\n    (s, e) = list(map(int, input().split()))\n    if s > e:\n        print(0)\n        return 0\n    level_s = int(binary_search(s, 2, 10000000000.0))\n    level_e = int(binary_search(e, 2, 10000000000.0))\n    idx_s = int(s - sum_natural(level_s - 1))\n    idx_e = int(e - sum_natural(level_e - 1))\n    diff_l = level_e - level_s\n    diff_idx = idx_e - idx_s\n    if diff_l < 0 or diff_idx < 0 or diff_idx > diff_l:\n        print(0)\n        return\n    ans = ncr(diff_l, diff_idx, precomp_fact)\n    print(int(ans))\nprecomp_facts = fact(10000000)\nt = int(input())\nwhile t:\n    solve(precomp_facts)\n    t -= 1", "t = int(input().strip())\n\ndef get_row_starting_cell(row):\n    return 1 + row * (row - 1) // 2\n\ndef get_position(cell):\n    (l, r) = (1, int(100000.0))\n    while l + 1 < r:\n        m = l + (r - l) // 2\n        starting_cell = get_row_starting_cell(m)\n        if starting_cell > cell:\n            r = m\n        else:\n            l = m\n    assert get_row_starting_cell(l) <= cell < get_row_starting_cell(l + 1)\n    return (l, cell - get_row_starting_cell(l) + 1)\nMOD = int(1000000000.0) + 7\n\ndef get_inverse_modulo(i, mod=MOD):\n    return pow(i, mod - 2, mod)\ninverse_factorial_modulo = [0] * int(100000.0)\ninverse_factorial_modulo[0] = 1\nfor i in range(1, int(100000.0)):\n    inverse_factorial_modulo[i] = inverse_factorial_modulo[i - 1] * get_inverse_modulo(i) % MOD\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    start = 1\n    for i in range(n + 1 - r, n + 1):\n        start = start * i % MOD\n    start = start * inverse_factorial_modulo[r] % MOD\n    return start\nfor _ in range(t):\n    (start, end) = map(int, input().strip().split())\n    (start_x, start_y) = get_position(start)\n    (end_x, end_y) = get_position(end)\n    offset_x = end_x - start_x\n    offset_y = end_y - start_y\n    if offset_y < 0 or offset_y > offset_x:\n        print(0)\n        continue\n    print(ncr(offset_x, offset_y))", "def pyramid(s, e):\n    if e <= s:\n        print(0)\n        return\n    d1 = int((1 + (8 * s - 7) ** 0.5) / 2)\n    d2 = int((1 + (8 * e - 7) ** 0.5) / 2)\n    n = abs(d2 - d1)\n    h1 = s - d1 * (d1 - 1) // 2\n    h2 = e - d2 * (d2 - 1) // 2\n    r = int(abs(h2 - h1))\n    if h1 > h2 or abs(h1 - h2) > abs(d1 - d2):\n        print(0)\n        return\n    elif h1 == h2 or abs(h1 - h2) == abs(d1 - d2):\n        print(1)\n        return\n    k = 1000000007\n    print(int(ncr(n, r, k)))\n    return\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor _ in range(t):\n    (s, e) = map(int, input().split())\n    pyramid(s, e)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor _ in range(t):\n    (s, e) = map(int, input().split())\n    if e <= s:\n        print(0)\n    else:\n        d_s = (1 + (8 * s - 7) ** 0.5) / 2\n        d_s = int(d_s)\n        d_e = (1 + (8 * e - 7) ** 0.5) / 2\n        d_e = int(d_e)\n        h_s = s - 1 - d_s * (d_s - 1) // 2\n        h_e = e - 1 - d_e * (d_e - 1) // 2\n        if abs(h_s - h_e) > abs(d_s - d_e):\n            print(0)\n        elif abs(h_s - h_e) == abs(d_s - d_e) or h_s - h_e == 0:\n            print(1)\n        elif h_e - h_s < 0:\n            print(0)\n        else:\n            print(int(ncr(d_e - d_s, abs(h_s - h_e), 1000000007)))", "from math import ceil\nfrom math import sqrt\nmod = 10 ** 9 + 7\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef last_ele(n):\n    return int(n * (n + 1) / 2)\n\ndef hi(block):\n    lvl = -1\n    if block == 1:\n        return (1, 1)\n    st = 2\n    end = 1 + ceil(sqrt(2 * block))\n    while st <= end:\n        lvl = int((st + end) / 2)\n        if last_ele(lvl) >= block and last_ele(lvl - 1) < block:\n            break\n        elif last_ele(lvl) > block:\n            end = lvl - 1\n        else:\n            st = lvl + 1\n    index = block - int(lvl * (lvl - 1) / 2)\n    return (lvl, index)\nt = int(input())\nfor z in range(t):\n    (x, y) = map(int, input().split())\n    if x > y:\n        print(0)\n    else:\n        (hx, ix) = hi(x)\n        (hy, iy) = hi(y)\n        L = hy - hx\n        K = iy - ix\n        if L <= 0 or K < 0 or K > L:\n            print(0)\n        else:\n            print(ncr(L, K, mod))", "P = 1000000000.0 + 7\n\ndef find_location(index):\n    i = 1\n    max_idx = 0\n    while True:\n        max_idx += i\n        if max_idx >= index:\n            lvl = i\n            idx = lvl - (max_idx - index)\n            return (lvl, idx)\n        i += 1\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef main():\n    T = int(input())\n    for tc in range(T):\n        (e, s) = map(int, input().split(' '))\n        (s_lvl, s_idx) = find_location(s)\n        (e_lvl, e_idx) = find_location(e)\n        lvl = s_lvl - e_lvl\n        idx = s_idx - e_idx\n        if idx < 0 or s_lvl < e_lvl or (s_lvl == e_lvl and s_idx != e_idx):\n            print(0)\n        else:\n            print(ncr(lvl, idx, int(1000000000.0 + 7)))\nmain()", "def sumofn(n):\n    return int(n * (n + 1) / 2)\n\ndef level_search(n):\n    l = 0\n    r = 44725\n    while l <= r:\n        mid = l + (r - l) // 2\n        if sumofn(mid) >= n and sumofn(mid - 1) < n:\n            return mid\n        elif sumofn(mid) > n:\n            r = mid - 1\n        elif sumofn(mid) < n:\n            l = mid + 1\n\ndef index(a, l):\n    return int(a - l * (l - 1) / 2)\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor _ in range(t):\n    (s, e) = list(map(int, input().split(' ')))\n    level_s = level_search(s)\n    level_e = level_search(e)\n    index_s = index(s, level_s)\n    index_e = index(e, level_e)\n    diff_level = level_e - level_s\n    diff_index = index_e - index_s\n    ans = 1\n    if diff_level <= 0 or diff_index < 0 or diff_index > diff_level:\n        ans = 0\n    else:\n        ans = ncr(diff_level, diff_index, 1000000007)\n    print(int(ans))", "def sumofn(n):\n    return int(n * (n + 1) / 2)\n\ndef level_search(n):\n    l = 0\n    r = 44725\n    while l <= r:\n        mid = l + (r - l) // 2\n        if sumofn(mid) >= n and sumofn(mid - 1) < n:\n            return mid\n        elif sumofn(mid) > n:\n            r = mid - 1\n        elif sumofn(mid) < n:\n            l = mid + 1\n\ndef index(a, l):\n    return int(a - l * (l - 1) / 2)\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor _ in range(t):\n    (s, e) = list(map(int, input().split(' ')))\n    level_s = level_search(s)\n    level_e = level_search(e)\n    index_s = index(s, level_s)\n    index_e = index(e, level_e)\n    diff_level = level_e - level_s\n    diff_index = index_e - index_s\n    ans = 1\n    if diff_level <= 0 or diff_index < 0 or diff_index > diff_level:\n        ans = 0\n    else:\n        ans = ncr(diff_level, diff_index, 1000000007)\n    print(int(ans))", "def sumofn(n):\n    return int(n * (n + 1) / 2)\n\ndef level_search(n):\n    l = 0\n    r = 44725\n    while l <= r:\n        mid = l + (r - l) // 2\n        if sumofn(mid) >= n and sumofn(mid - 1) < n:\n            return mid\n        elif sumofn(mid) > n:\n            r = mid - 1\n        elif sumofn(mid) < n:\n            l = mid + 1\n\ndef index(a, l):\n    return int(a - l * (l - 1) / 2)\n\ndef factorial(n):\n    dp_arr = [1]\n    for i in range(1, n + 1):\n        dp_arr.append(i * dp_arr[i - 1])\n    return dp_arr[len(dp_arr) - 1] % 1000000007\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor _ in range(t):\n    (s, e) = list(map(int, input().split(' ')))\n    level_s = level_search(s)\n    level_e = level_search(e)\n    index_s = index(s, level_s)\n    index_e = index(e, level_e)\n    diff_level = level_e - level_s\n    diff_index = index_e - index_s\n    ans = 1\n    if diff_level <= 0 or diff_index < 0 or diff_index > diff_level:\n        ans = 0\n    else:\n        ans = ncr(diff_level, diff_index, 1000000007)\n    print(int(ans))", "import math\np = 1000000007\nt = int(input())\nfor i in range(t):\n    (s, e) = map(int, input().split())\n    m = math.ceil(math.sqrt(2 * s))\n    x = s - m * (m - 1) / 2 - 1\n    while x < 0:\n        m -= 1\n        x = s - m * (m - 1) / 2 - 1\n    n = math.ceil(math.sqrt(2 * e))\n    y = -1\n    y = e - n * (n - 1) / 2 - 1\n    while y < 0:\n        n -= 1\n        y = e - n * (n - 1) / 2 - 1\n    a = int(n - m)\n    b = int(y - x)\n    if b < 0 or a < 0 or b > a:\n        print(0)\n    else:\n        num = 1\n        den = 1\n        r = min(b, a - b)\n        for i in range(r):\n            num = num * (a - i) % p\n            den = den * (i + 1) % p\n        print(num * pow(den, p - 2, p) % p)", "from math import ceil, sqrt, factorial\nfact = [1]\nfor i in range(1, 44721):\n    fact.append(fact[-1] * i)\n\ndef powmod(a, b, p):\n    a %= p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b % 2 == 1:\n            product *= a\n            product %= p\n            b -= 1\n        a *= a\n        a %= p\n        b /= 2\n    return product\n\ndef inv(a, p):\n    return powmod(a, p - 2, p)\n\ndef nCk(n, k, p):\n    return fact[n] * inv(fact[k], p) % p * inv(fact[n - k], p) % p\n\ndef suum(n):\n    l = ceil(((8 * n + 1) ** 0.5 - 1) / 2)\n    num = (l ** 2 - l + 2) // 2\n    return (l, n - num)\nfor _ in range(int(input())):\n    (s, e) = list(map(int, input().split()))\n    if e > s:\n        s = suum(s)\n        e = suum(e)\n        l = e[0] - s[0]\n        k = e[1] - s[1]\n        if l > 0 and k >= 0 and (l >= k):\n            print(nCk(l, k, 1000000007))\n        else:\n            print(0)\n    else:\n        print(0)", "import math\n\ndef findIndex(t):\n    x = (t - 1) * 2\n    if 1 + 4 * x < 0:\n        ind1 = 0\n    else:\n        k = math.sqrt(1 + 4 * x)\n        if -1 + k >= 0:\n            ind1 = (-1 + k) // 2\n        else:\n            ind1 = (-1 + k) // 2\n    first = ind1 * (ind1 + 1) // 2 + 1\n    ind2 = t - first\n    return (int(ind1), int(ind2))\nt = int(input())\nfor _ in range(t):\n    (s, e) = map(int, input().split())\n    if s > e:\n        print(0)\n        continue\n    if s == e:\n        print(1)\n        continue\n    (sr, sc) = findIndex(s)\n    (er, ec) = findIndex(e)\n    if sc + (er - sr) < ec or ec < sc:\n        print(0)\n        continue\n    i = er - sr\n    j = ec - sc\n    numerator = denominator = 1\n    for x in range(j):\n        numerator = numerator * (i - x) % 1000000007\n        denominator = denominator * (x + 1) % 1000000007\n    res = numerator * pow(denominator, 1000000007 - 2, 1000000007) % 1000000007\n    print(res)", "import math\nBIG_NUMBER = 7 + 10 ** 9\nfactorial = dict()\nfactorial[0] = 1\nfor i in range(1, 200000):\n    factorial[i] = factorial[i - 1] * i % BIG_NUMBER\n\ndef get_first_element(row):\n    return 1 + row * (row - 1) / 2\n\ndef get_last_element(row):\n    return row * (row + 1) / 2\n\ndef is_in_row(number, row):\n    if row < 1:\n        return False\n    elif row == 1:\n        return number == 1\n    row_start = row * (row - 1) / 2 + 1\n    row_end = row * (row + 1) / 2\n    return row_start <= number <= row_end\n\ndef get_row_number(number):\n    if number == 1:\n        return 1\n    elif number <= 3:\n        return 2\n    temp_float = math.sqrt(2.0 * number)\n    temp_int = int(temp_float)\n    possible_rows = [temp_int, temp_int + 1]\n    for row in possible_rows:\n        if is_in_row(number, row):\n            return row\n    return temp_int\n\ndef get_width_from_center(number, row):\n    middle = (float(get_first_element(row)) + float(get_last_element(row))) / 2.0\n    return middle - float(number)\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y % 2 == 1:\n            res = res * x % p\n        y = int(y / 2)\n        x = x * x % p\n    return res\n\ndef mod_inverse(n, p):\n    return power(n, p - 2, p)\n\ndef num_combinations(n, r, p):\n    return factorial[n] * mod_inverse(factorial[r], p) % p * (mod_inverse(factorial[n - r], p) % p) % p\n\ndef compute_num_paths(start, end):\n    if start >= end:\n        return 0\n    start_row = get_row_number(start)\n    end_row = get_row_number(end)\n    height_diff = end_row - start_row\n    if height_diff <= 0:\n        return 0\n    start_width = get_width_from_center(start, start_row)\n    end_width = get_width_from_center(end, end_row)\n    width_diff = int(math.fabs(2.0 * (end_width - start_width)))\n    if width_diff > height_diff:\n        return 0\n    if width_diff == height_diff:\n        return 1\n    num_lefts = int((height_diff + width_diff) / 2.0)\n    num_rights = int((height_diff - width_diff) / 2.0)\n    return num_combinations(height_diff, num_lefts, BIG_NUMBER)\nfor _ in range(int(input())):\n    (s, e) = list(map(int, input().strip().split(' ')))\n    print(compute_num_paths(s, e))", "def get_rows(start, end):\n    j = 1\n    k = 1\n    got_start = False\n    value = [0, 0]\n    while True:\n        if not got_start and start <= j:\n            value[0] = k\n            got_start = True\n        elif end <= j:\n            value[1] = k\n            return value\n        k += 1\n        j += k\n\ndef ncrmodm(n, r, m):\n    if r == 0 or r == n:\n        return 1\n    up = 1\n    down = 1\n    for i in range(r):\n        up = up * (n - i) % m\n        down = down * (i + 1) % m\n    return up * pow(down, m - 2, m) % m\nfor _ in range(int(input())):\n    (s, e) = map(int, input().split(' '))\n    m = 7 + 10 ** 9\n    if s >= e:\n        print(0)\n        continue\n    (srow, erow) = get_rows(s, e)\n    step = erow - srow\n    s += erow * (erow + 1) // 2 - srow * (srow + 1) // 2\n    side = s - e\n    if side > 0:\n        if side > step:\n            print(0)\n        else:\n            if side > step - side:\n                side = step - side\n            print(ncrmodm(step, side, m))\n    elif side == 0:\n        print(1)\n    else:\n        print(0)", "import sys\nimport math\nmod = 1000000007\nmx = 10 ** 5\nfact = [0] * mx\nfact[0] = 0\nfact[1] = 1\nfor x in range(2, mx):\n    fact[x] = fact[x - 1] * x % mod\n\ndef powmod(a, b, p):\n    a %= p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b & 1:\n            product *= a\n            product %= p\n            --b\n        a *= a\n        a %= p\n        b //= 2\n    return product\n\ndef inv(a, p):\n    return powmod(a, p - 2, p)\n\ndef nCk(n, k, p):\n    return fact[n] * inv(fact[k], p) % p * inv(fact[n - k], p) % p\n\ndef preCalculation(N, another):\n    mod = 1000000007\n    if another == 1:\n        return 1\n    else:\n        return nCk(N, another - 1, mod)\n\ndef res(ls):\n    tar = ls[0]\n    lo = 1\n    hi = 10000000\n    mod = 1000000007\n    ans = -1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        chk = mid * (mid + 1) // 2\n        if tar == chk:\n            ans = mid\n            break\n        elif tar < chk:\n            ans = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    tar1 = ls[1]\n    lo = 1\n    hi = 10000000\n    ans1 = -1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        chk = mid * (mid + 1) // 2\n        if tar1 == chk:\n            ans1 = mid\n            break\n        elif tar1 < chk:\n            ans1 = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    reqRight = ans1 * (ans1 + 1) // 2 - ans * (ans + 1) // 2\n    reqLeft = ans1 * (ans1 - 1) // 2 - ans * (ans - 1) // 2\n    reqRight += ls[0]\n    reqLeft += ls[0]\n    if reqLeft <= ls[1] <= reqRight:\n        req = preCalculation(ans1 - ans, min((ans1 - ans - (ls[1] - reqLeft), ls[1] - reqLeft)) + 1)\n        return req % mod\n    else:\n        return 0\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\nfor tc in range(int(input())):\n    (a, b) = get_ints()\n    print(res([a, b]))", "mod = pow(10, 9) + 7\na = [0] * 100000\na[0] = 1\nfor i in range(1, len(a)):\n    a[i] = a[i - 1] * i % mod\n\ndef cos(x):\n    p = pow(1 + 8 * x, 0.5) - 1\n    p //= 2\n    if (p * p + p) // 2 < x:\n        p += 1\n    return int(p)\n\ndef solve():\n    (s, e) = map(int, input().split())\n    x1 = cos(s)\n    x2 = cos(e)\n    y1 = s - (x1 * x1 - x1) // 2\n    y2 = e - (x2 * x2 - x2) // 2\n    y11 = (x1 * x1 + x1) // 2 - s\n    y22 = (x2 * x2 + x2) // 2 - e\n    if y2 < y1 or y11 > y22:\n        print(0)\n        return\n    n = x2 - x1\n    r = y2 - y1\n    ncr = a[n] * pow(a[r], mod - 2, mod) % mod * pow(a[n - r], mod - 2, mod) % mod\n    print(ncr)\nfor iii in range(int(input())):\n    solve()", "import math\nN = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\nInverseofNumber(10 ** 9 + 7)\nInverseofFactorial(10 ** 9 + 7)\nfactorial(10 ** 9 + 7)\n\ndef lev(n):\n    return math.ceil((-1 + (1 + 8 * n) ** 0.5) / 2)\n\ndef bs(n, x):\n    return x - n * (n - 1) // 2\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    d2 = bs(lev(y), y) - bs(lev(x), x)\n    d1 = lev(y) - lev(x)\n    if d1 <= 0 or d2 < 0 or d2 > d1:\n        print(0)\n    else:\n        d1 = abs(lev(x) - lev(y))\n        print(Binomial(d1, d2, 10 ** 9 + 7))", "import math\nN = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\nInverseofNumber(10 ** 9 + 7)\nInverseofFactorial(10 ** 9 + 7)\nfactorial(10 ** 9 + 7)\n\ndef lev(n):\n    return math.ceil((-1 + (1 + 8 * n) ** 0.5) / 2)\n\ndef bs(n, x):\n    return x - n * (n - 1) // 2\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    d2 = bs(lev(y), y) - bs(lev(x), x)\n    d1 = lev(y) - lev(x)\n    if d1 <= 0 or d2 < 0 or d2 > d1:\n        print(0)\n    else:\n        d1 = abs(lev(x) - lev(y))\n        print(Binomial(d1, d2, 10 ** 9 + 7))", "import math\nN = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\nInverseofNumber(10 ** 9 + 7)\nInverseofFactorial(10 ** 9 + 7)\nfactorial(10 ** 9 + 7)\n\ndef lev(n):\n    return math.ceil((-1 + (1 + 8 * n) ** 0.5) / 2)\n\ndef bs(n, x):\n    return x - n * (n - 1) // 2\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    d2 = bs(lev(y), y) - bs(lev(x), x)\n    d1 = lev(y) - lev(x)\n    if d1 <= 0 or d2 < 0 or d2 > d1:\n        print(0)\n    else:\n        d1 = abs(lev(x) - lev(y))\n        print(Binomial(d1, d2, 10 ** 9 + 7))", "MODULO = 10 ** 9 + 7\n\ndef combination(n):\n    return n * (n + 1) // 2\n\ndef isGreater(row, s):\n    if combination(row) >= s:\n        return 1\n    else:\n        return 0\n\ndef get_coordinates(num):\n    row = gRow(num)\n    hd = get_horizontal_dist(row, num)\n    return (row, hd)\n\ndef gRow(s):\n    ans = -1\n    l = 1\n    h = 10 ** 9\n    while l <= h:\n        mid = l + (h - l) // 2\n        if isGreater(mid, s):\n            best = mid\n            h = mid - 1\n        else:\n            l = mid + 1\n    return best\n\ndef get_horizontal_dist(row, num):\n    midne = combination(row - 1) + 1\n    column = num - midne\n    start = 1 - row\n    return start + 2 * column\n\ndef nComb_r(n, r, p):\n    num = 1\n    den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor _ in range(t):\n    (s, e) = list(map(int, input().split()))\n    (r1, hd1) = get_coordinates(s)\n    (r2, hd2) = get_coordinates(e)\n    hdiff = abs(hd1 - hd2)\n    if hdiff > r2 - r1:\n        print(0)\n    else:\n        nhd = hd2 - hd1\n        r2 -= r1\n        r1 = 0\n        startcolumn = -r2\n        col = (nhd - startcolumn) // 2\n        n = r2\n        ans = nComb_r(n, col, MODULO)\n        print(ans)", "from math import gcd\n\ndef comb(n):\n    return n * (n + 1) // 2\n\ndef isGreater(row, s):\n    return comb(row) >= s\nMOD = 10 ** 9 + 7\n\ndef get_row(s):\n    best = -1\n    lo = 1\n    hi = 10 ** 9\n    while lo <= hi:\n        mi = lo + hi >> 1\n        if isGreater(mi, s):\n            best = mi\n            hi = mi - 1\n        else:\n            lo = mi + 1\n    return best\n\ndef get_horizontal_dist(row, num):\n    mine = comb(row - 1) + 1\n    col = num - mine\n    start = 1 - row\n    return start + 2 * col\n\ndef get_coordinates(num):\n    row = get_row(num)\n    hd = get_horizontal_dist(row, num)\n    return (row, hd)\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor _ in range(t):\n    (s, e) = list(map(int, input().split()))\n    (r1, hd1) = get_coordinates(s)\n    (r2, hd2) = get_coordinates(e)\n    hdiff = abs(hd1 - hd2)\n    if hdiff > r2 - r1:\n        print(0)\n    else:\n        newhd1 = 0\n        newhd2 = hd2 - hd1\n        r2 -= r1\n        r1 = 0\n        start_col = -r2\n        col = (newhd2 - start_col) // 2\n        n = r2\n        ans = ncr(n, col, MOD)\n        print(ans)", "import math\nfrom random import randint\n\ndef timeTaken(func):\n    from time import time\n\n    def decorator(*args, **kwargs):\n        start = time()\n        returned = func(*args, **kwargs)\n        end = time()\n        if int(100 * (end - start)) / 100 > 0.01:\n            print('Time taken is: ', int(100 * (end - start)) / 100, 'Sec')\n        return returned\n    return decorator\n\ndef memoize(func):\n    mem = {}\n\n    def memoizer(*args, **kwargs):\n        key = str(args) + str(kwargs)\n        if key not in mem:\n            mem[key] = func(*args, **kwargs)\n        return mem[key]\n    return memoizer\n\ndef counter(lst):\n    q = [0] * max(lst)\n    for i in range(len(lst)):\n        q[lst[i] - 1] = q[lst[i] - 1] + 1\n    return q\n\ndef counter_elements(lst):\n    q = dict()\n    for i in range(len(lst)):\n        if lst[i] not in q:\n            q[lst[i]] = 0\n        q[lst[i]] = q[lst[i]] + 1\n    return q\n\ndef string_counter(lst):\n    q = [0] * 26\n    for i in range(len(lst)):\n        q[ord(lst[i]) - 97] = q[ord(lst[i]) - 97] + 1\n    return q\n\ndef factorial(n, m=1000000007):\n    q = 1\n    for i in range(n):\n        q = q * (i + 1) % m\n    return q\n\ndef factors(n):\n    q = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            q.extend([i, n // i])\n    return q\n\ndef prime_factors(n):\n    q = []\n    while n % 2 == 0:\n        q.append(2)\n        n = n // 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            q.append(i)\n            n = n // i\n    if n > 2:\n        q.append(n)\n    return q\n\ndef power_two(x):\n    return x and (not x & x - 1)\n\ndef ceil(a, b):\n    return -(-a // b)\n\ndef getPrimes(MAX=10 ** 5):\n    primes = [2]\n    for n in range(3, MAX, 2):\n        sqrt_n = math.sqrt(n)\n        for prime in primes:\n            if prime > sqrt_n:\n                primes.append(n)\n                break\n            if n % prime == 0:\n                break\n    return primes\n\ndef sieve(MAX=10 ** 5):\n    spf = [i for i in range(MAX)]\n    for i in range(4, MAX, 2):\n        spf[i] = 2\n    for i in range(3, math.ceil(math.sqrt(MAX))):\n        if spf[i] == i:\n            for j in range(i * i, MAX, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\nMOD = 10 ** 9 + 7\n\ndef mod_mul(a, b):\n    return a % MOD * (b % MOD) % MOD\n\ndef mod_sum(a, b):\n    return (a + b) % MOD\n\ndef mod_inv(a):\n    return pow(a, MOD - 2, MOD)\nimport io, os, sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    return input().strip()\n\ndef invr():\n    return map(int, input().split())\n\ndef outp(n):\n    sys.stdout.write(str(n) + '\\n')\n\ndef outlt(lst):\n    sys.stdout.write(' '.join(map(str, lst)) + '\\n')\n\ndef outplt(lst):\n    sys.stdout.write('\\n'.join(map(str, lst)))\n\ndef qA(N, A):\n    d = {}\n    for a in A:\n        d[a] = d[a] + 1 if a in d else 1\n    mx = max(d.values())\n    if mx == N:\n        return 0\n    elif mx == 1:\n        return -1\n    else:\n        return N - mx + 1\n\ndef qB(N, M):\n    if N == M:\n        return '01' * (N + 1)\n    elif N > M:\n        return '01' * M + '010' * (N - M)\n    else:\n        return '10' * N + '101' * (M - N)\n\ndef qC(N, S):\n    seq = {'R': 'P', 'P': 'S', 'S': 'R'}\n\n    def rps(x, y):\n        return x if x == y or x == seq[y] else y\n    w = [{'R': None, 'P': None, 'S': None} for x in range(N - 1)]\n    w.append({x: rps(x, S[N - 1]) for x in 'RPS'})\n    for i in range(N - 1):\n        x = N - i - 2\n        for y in 'RPS':\n            w[x][y] = w[x + 1][rps(y, S[x + 1])]\n    ans = ''\n    for i in range(N):\n        ans += w[i][S[i]]\n    return ans\n\ndef qD(N, A):\n    c = [[[0, 0] for x in range(N)] for y in range(N)]\n    c[0][0] = [int(A[0][0]), int(A[0][0])]\n    for i in range(1, N):\n        c[i][0] = [1, c[i - 1][0][1] + 1] if A[i][0] == '1' else [0, 0]\n        c[0][i] = [c[0][i - 1][0] + 1, 1] if A[0][i] == '1' else [0, 0]\n    for i in range(1, N):\n        for j in range(1, N):\n            if A[i][j] == '1':\n                (c[i][j][0], c[i][j][1]) = (c[i][j - 1][0] + 1, c[i - 1][j][1] + 1)\n    ans = sum((sum((1 for a in A[y] if a == '1')) for y in range(N)))\n    for col in range(N):\n        for row in range(N):\n            if c[row][col][1] and c[row][col][0]:\n                for l in range(row + 1, N):\n                    wd = l - row\n                    if c[l][col][1] == 0 or wd > N - 1 - col:\n                        break\n                    if c[row][col + wd][0] >= wd and c[l][col + wd][1] >= wd and (c[l][col + wd][0] >= wd):\n                        ans += 1\n    return ans\n\ndef factorials(n):\n    facts = [1, 1]\n    for i in range(2, n + 1):\n        facts.append(facts[-1] * i % MOD)\n    return facts\nfact = factorials(100000)\n\ndef numberOfPaths(m, n):\n    return fact[m + n - 2] * mod_inv(mod_mul(fact[n - 1], fact[m - 1])) % MOD\n\ndef rowNum(x):\n    ans = ((1 + x * 8) ** 0.5 - 1) / 2\n    return int(ans) if ans == int(ans) else int(ans) + 1\n\ndef colNum(row, x):\n    return x - row * (row - 1) // 2\n\ndef qE(s, e):\n    (r1, r2) = (rowNum(s), rowNum(e))\n    (c1, c2) = (colNum(r1, s), colNum(r2, e))\n    m = abs(c1 - c2)\n    return 0 if c2 < c1 or c2 - c1 > r2 - r1 or r2 <= r1 else numberOfPaths(m + 1, r2 - r1 - m + 1)\nfor _ in range(inp()):\n    (s, e) = inlt()\n    outp(qE(s, e))", "import math\nMAXN = 100000\nMODVAL = 1000000007\n\ndef getCoeff(n, k, fact):\n    return fact[n] * pow(fact[n - k], MODVAL - 2, MODVAL) * pow(fact[k], MODVAL - 2, MODVAL) % MODVAL\n\ndef getRow(x):\n    return math.ceil((math.sqrt(8 * x + 1) - 1) / 2)\n\ndef getCol(x, r):\n    return x - r * (r - 1) // 2\n\ndef getAns(a, b, fact):\n    (rA, rB) = (getRow(a), getRow(b))\n    (cA, cB) = (getCol(a, rA), getCol(b, rB))\n    if rB <= rA:\n        return 0\n    if abs(cA - cB) > rB - rA:\n        return 0\n    if cB < cA:\n        return 0\n    else:\n        (right, left) = (cB - cA, rB - rA - (cB - cA))\n    return getCoeff(left + right, right, fact)\n\ndef main():\n    fact = [-1 for _ in range(MAXN)]\n    (fact[0], fact[1]) = (1, 1)\n    for i in range(2, MAXN):\n        fact[i] = fact[i - 1] * i % MODVAL\n    n = int(input())\n    for _ in range(n):\n        [a, b] = list(map(int, input().split()))\n        print(getAns(a, b, fact))\nmain()", "MOD = pow(10, 9) + 7\nlevel_ends = [0]\nfactorial = [1, 1]\nfor i in range(1, 50000):\n    factorial.append((i + 1) * factorial[-1] % MOD)\n    temp = i * (i + 1) >> 1\n    if temp <= MOD - 7:\n        level_ends.append(temp)\n    else:\n        level_ends.append(temp)\n        break\n\ndef inverse(a, b, m):\n    a = a % m\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b % 2 == 1:\n            product = product * a\n            product = product % m\n            b = b - 1\n        a = a * a\n        a = a % m\n        b = int(b / 2)\n    return product\n\ndef calculate(n, k, m):\n    return factorial[n] * inverse(factorial[k], m - 2, m) % m * inverse(factorial[n - k], m - 2, m) % m\n\ndef find_level(n, start, end):\n    for i in range(0, len(level_ends) - 1):\n        if level_ends[i] < n <= level_ends[i + 1]:\n            return i\nt = int(input())\nwhile t != 0:\n    (start, end) = input().split()\n    start = int(start)\n    end = int(end)\n    start_level = -1\n    end_level = -1\n    start_level = find_level(start, 0, len(level_ends))\n    end_level = find_level(end, 0, len(level_ends))\n    end_left = level_ends[end_level] - level_ends[start_level] + start\n    end_right = level_ends[end_level + 1] - level_ends[start_level] - start_level + start - 1\n    ans = 0\n    if end_left <= end <= end_right:\n        modified_end_level = end_level - start_level\n        modified_column = end - end_left\n        ans = calculate(modified_end_level, modified_column, MOD)\n    print(ans)\n    t -= 1", "import math as m\nN = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef comb(n, r):\n    (ans, div) = (1, 1)\n    if r > n / 2:\n        r = n - r\n    for i in range(r):\n        ans = ans * (n - i)\n        div = div * (i + 1)\n    return ans // div\n\ndef F_index(n):\n    a = m.floor(m.sqrt(2 * n))\n    if n <= (a * a + a) // 2:\n        x = a\n    else:\n        x = a + 1\n    y = n - (x * x - x) // 2\n    return (x, y)\n(t, L, p) = (int(input()), [], 10 ** 9 + 7)\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nfor i in range(t):\n    l = input().split(' ')\n    (start, destn) = (int(l[0]), int(l[1]))\n    (x1, y1) = F_index(start)\n    (x2, y2) = F_index(destn)\n    (n, r) = (x2 - x1, y2 - y1)\n    if n <= 0 or r < 0 or r > n:\n        L.append(0)\n    else:\n        L.append(Binomial(n, r, p))\nfor i in range(t):\n    print(L[i])", "import bisect\nfrom math import factorial\nlista = [n * (n + 1) // 2 for n in range(1, 44722)]\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nfor _ in range(int(input())):\n    (start, end) = map(int, input().split())\n    if start >= end:\n        print(0)\n    elif start == 1:\n        diag = bisect.bisect_left(lista, end)\n        kend = lista[diag] - end\n        if nstart <= nend and kstart <= kend:\n            print(ncr(diag, kend, 1000000007))\n        else:\n            print(0)\n    else:\n        diag = bisect.bisect_left(lista, start)\n        kstart = lista[diag] - start\n        nstart = lista[diag] - lista[diag - 1] - kstart - 1\n        diag1 = bisect.bisect_left(lista, end)\n        kend = lista[diag1] - end\n        nend = lista[diag1] - lista[diag1 - 1] - kend - 1\n        if nstart <= nend and kstart <= kend:\n            print(ncr(diag1 - diag, kend - kstart, 1000000007))\n        else:\n            print(0)", "from math import ceil\nmod = 10 ** 9 + 7\n\ndef power(a, b, p):\n    ans = 1\n    a = a % p\n    while b:\n        if b & 1:\n            ans = ans * a % p\n        b = b >> 1\n        a = a * a % p\n    return ans\n\ndef inverse_mod(n, p):\n    return power(n, p - 2, p)\n\ndef nCr(n, r, p):\n    if n < r:\n        return 0\n    if r == 0:\n        return 1\n    y = [0] * (n + 1)\n    y[0] = 1\n    y[1] = 1\n    for i in range(2, n + 1):\n        y[i] = i * y[i - 1] % p\n    return y[n] * inverse_mod(y[r], p) % p * (inverse_mod(y[n - r], p) % p) % p\n\ndef func(x):\n    ans = ceil(((1 + 8 * x) ** 0.5 - 1) / 2)\n    return ans\n\ndef func1(n, x):\n    num = (x - 1) * x // 2\n    return n - num\nfor u in range(int(input())):\n    (s, e) = map(int, input().split())\n    row_n1 = func(s)\n    row_n2 = func(e)\n    d1 = row_n2 - row_n1\n    idx_n1 = func1(s, row_n1)\n    idx_n2 = func1(e, row_n2)\n    d2 = idx_n2 - idx_n1\n    if d1 <= 0 or d2 < 0 or d1 < d2:\n        print(0)\n    else:\n        print(nCr(d1, d2, mod))", "import math\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nfor _ in range(int(input())):\n    (st, en) = [int(s) for s in input().split()]\n    aa = math.floor(math.sqrt(2 * st))\n    if st <= (aa * aa + aa) // 2:\n        sti = aa\n    else:\n        sti = aa + 1\n    stj = st - (sti * sti - sti) // 2\n    aa = math.floor(math.sqrt(2 * en))\n    if en <= (aa * aa + aa) // 2:\n        eni = aa\n    else:\n        eni = aa + 1\n    enj = en - (eni * eni - eni) // 2\n    if sti > eni or stj > enj:\n        print(0)\n        continue\n    if sti == eni and stj == enj:\n        print(0)\n        continue\n    (i, j) = (eni - sti, enj - stj)\n    (mx, mn) = (max(i, j), min(i, j))\n    print(ncr(i, j, 10 ** 9 + 7))", "from math import sqrt, factorial\n\ndef level(num):\n    return (-1 + sqrt(1 + 4 * 2 * (num - 1))) // 2\n\ndef lower_bound(lvl):\n    return lvl * (lvl + 1) / 2\n\ndef left_bound(lvl):\n    return lower_bound(lvl) + 1\n\ndef upper_bound(lvl):\n    lvl += 1\n    return lvl * (lvl + 1) / 2\n\ndef pos(num):\n    lvl = level(num)\n    return num - lower_bound(lvl)\nh = {}\nt = int(input())\nfor x in range(t):\n    (s, e) = list(map(int, input().split()))\n    if s >= e:\n        print(0)\n        continue\n    src = 1\n    shift = pos(e) - pos(s) + 1\n    lvl_diff = level(e) - level(s)\n    if lvl_diff == 0:\n        print(0)\n        continue\n    max_shift = upper_bound(lvl_diff) - lower_bound(lvl_diff)\n    if (shift > max_shift) | (shift <= 0):\n        print(0)\n        continue\n    new_e = lower_bound(lvl_diff) + shift\n    if new_e in h:\n        print(h[new_e])\n        continue\n    epos = int(pos(new_e)) - 1\n    nr = lvl_diff - epos\n    h[new_e] = factorial(lvl_diff) // (factorial(epos) * factorial(nr)) % 1000000007\n    print(h[new_e])", "import math\nmod7 = 10 ** 9 + 7\nmax = 10 ** 5\nfact = [1, 1]\nfor i in range(2, max + 1):\n    fact.append(i * fact[i - 1] % mod7)\n\ndef findLevelAndIndex(num):\n    if num == 1:\n        return (1, 0)\n    start = 2\n    end = 1 + math.ceil(math.sqrt(2 * num))\n    while start <= end:\n        mid = int((start + end) / 2)\n        if mid * (mid + 1) / 2 >= num > mid * (mid - 1) / 2:\n            level = mid\n            break\n        elif num > mid * (mid + 1) / 2:\n            start = mid\n        else:\n            end = mid\n    return (level, num - (level * (level - 1) / 2 + 1))\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef modInverse(a, p):\n    return power(a, p - 2, p)\n\ndef choose(n, k):\n    return fact[n] * (modInverse(fact[k], mod7) % mod7) * modInverse(fact[n - k], mod7) % mod7\nt = int(input())\nfor _ in range(t):\n    (s, e) = map(int, input().split())\n    (Sl, Si) = map(int, findLevelAndIndex(s))\n    (El, Ei) = map(int, findLevelAndIndex(e))\n    Dl = El - Sl\n    Di = Ei - Si\n    if Dl > 0 and Dl >= Di >= 0:\n        ans = choose(Dl % mod7, Di % mod7) % mod7\n        print(ans)\n    else:\n        print(0)", "import math\n\ndef cord(a):\n    x = ((1 + 8 * a) ** 0.5 - 1) / 2\n    if x % 1 == 0:\n        x = int(x)\n    else:\n        x = int(x) + 1\n    y = int(a - x * (x - 1) / 2)\n    return (x, y)\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef way(s, e):\n    (sx, sy) = cord(s)\n    (ex, ey) = cord(e)\n    x = ex - sx\n    y = ey - sy\n    z = x - y\n    if x < 1 or y < 0 or z < 0:\n        return 0\n    ans = ncr(y + z, min(y, z), 1000000007)\n    return ans\nfor i in range(int(input())):\n    (s, e) = map(int, input().split())\n    print(way(s, e))", "import math\n\ndef sear(a):\n    l = 0\n    u = a\n    c = -1\n    while l <= u:\n        if l == u:\n            c = l\n            break\n        c = (l + u) // 2\n        if c * (c + 1) // 2 >= a and c * (c - 1) // 2 < a:\n            break\n        if c * (c + 1) // 2 > a:\n            u = c - 1\n        else:\n            l = c + 1\n    return [c, a - c * (c - 1) // 2]\n\ndef powmod(a, b, p):\n    a %= p\n    if a == 0:\n        return 0\n    ret = 1\n    while b > 0:\n        if b & 1:\n            ret *= a\n            ret %= p\n            b -= 1\n        a *= a\n        a %= p\n        b //= 2\n    return ret\nmod = 10 ** 9 + 7\nfa = [1]\nfor i in range(1, 10 ** 5 + 1):\n    fa.append(fa[-1] * i % mod)\n\ndef inv(a, b):\n    return powmod(a, b - 2, b)\n\ndef nck(n, k, p):\n    return fa[n] * inv(fa[k], p) % p * inv(fa[n - k], p) % p\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = sear(n)\n    b = sear(m)\n    v = b[0] - a[0]\n    i = b[1] - a[1]\n    if v >= i >= 0 and v > 0:\n        print(nck(v, i, mod))\n    else:\n        print(0)", "import math\n\ndef pwm(a, b, m):\n    a = a % m\n    if a == 0:\n        return 0\n    p = 1\n    while b > 0:\n        if b % 2 == 1:\n            p = p * a\n            p = p % m\n            b = b - 1\n        a = a * a\n        a = a % m\n        b = b / 2\n    return p\n\ndef fun2(a, m):\n    return pwm(a, m - 2, m)\n\ndef fun(n, r, m):\n    return lst[n] * fun2(lst[r], m) % m * fun2(lst[n - r], m) % m\nlst = []\nlst += [1]\nlst += [1]\nfor i in range(2, 100001):\n    lst += [lst[i - 1] * i % 1000000007]\nt = int(input())\nfor i in range(t):\n    m = 1000000007\n    lst1 = input().split()\n    x = int(lst1[0])\n    y = int(lst1[1])\n    k1 = int((math.sqrt(8 * x - 7) - 1) / 2)\n    k2 = int((math.sqrt(8 * y - 7) - 1) / 2)\n    k1n1 = int(k1 * (k1 + 1) / 2 + 1)\n    k1n2 = k1n1 + k1\n    k1d1 = x - k1n1\n    k1d2 = k1n2 - x\n    k2n1 = int(k2 * (k2 + 1) / 2 + 1)\n    k2n2 = k2n1 + k2\n    k2d1 = y - k2n1\n    k2d2 = k2n2 - y\n    if k2 > k1 and k2d1 >= k1d1 and (k2d2 >= k1d2):\n        n = int(k2 - k1)\n        r = y - (k2n1 + k1d1)\n        print(fun(n, r, m))\n    else:\n        print(0)", "from sys import stdin\n\ndef bezout(x, m):\n    if m == 0:\n        return (1, 0)\n    (u, v) = bezout(m, x % m)\n    return (v, u - x // m * v)\n\ndef inverse(x, m):\n    return bezout(x, m)[0] % m\n\ndef binomial(fact, n, k, mod):\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * inverse(fact[k] * fact[n - k], mod) % mod\n\ndef solve():\n    MOD = 10 ** 9 + 7\n    results = []\n    fact = [1]\n    for i in range(1, 100000):\n        fact.append(fact[-1] * i % MOD)\n    for _ in range(int(stdin.readline().strip())):\n        (s, e) = map(int, stdin.readline().rstrip().split())\n        level1 = int((8 * s - 7) ** 0.5 - 1) // 2\n        level2 = int((8 * e - 7) ** 0.5 - 1) // 2\n        s_start = level1 * (level1 + 1) // 2 + 1\n        s_end = s_start + level1\n        e_start = level2 * (level2 + 1) // 2 + 1\n        e_end = e_start + level2\n        if level2 <= level1 or e - e_start < s - s_start or e_end - e < s_end - s:\n            results.append(0)\n            continue\n        if e - e_start == s - s_start or e_end - e == s_end - s:\n            results.append(1)\n            continue\n        tmp = e_start + s - s_start\n        k = e - tmp\n        results.append(binomial(fact, level2 - level1, k, MOD))\n    print('\\n'.join(map(str, results)))\nsolve()", "import sys\nimport math\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\ninput = sys.stdin.readline\nT = int(input())\nlevel = lambda x: math.ceil((-1 + math.sqrt(1 + 8 * x)) / 2)\nfor _ in range(T):\n    (S, E) = map(int, input().split())\n    levelS = level(S)\n    levelE = level(E)\n    if levelS >= levelE:\n        print(0)\n    else:\n        max_add = (levelS + 1 + levelE) * (levelE - levelS) // 2\n        min_add = max_add - levelE + levelS\n        inRange0 = E >= S + min_add and E <= S + max_add\n        lefts = S + max_add - E\n        currLevel = levelS + lefts\n        print(0 if not inRange0 else ncr(levelE - levelS, currLevel - levelS, 1000000007))", "import math\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef last_ele(n):\n    return int((n + 1) * n / 2)\n\ndef get_level(n):\n    lev = -1\n    ind = -1\n    if n == 1:\n        return 1\n    st = 2\n    end = math.ceil(math.sqrt(2 * n))\n    while st <= end:\n        lev = int((st + end) / 2)\n        if last_ele(lev) >= n and last_ele(lev - 1) < n:\n            break\n        elif last_ele(lev) > n:\n            end = lev - 1\n        else:\n            st = lev + 1\n    return lev\n\ndef get_index(n):\n    lev = -1\n    ind = -1\n    if n == 1:\n        return 1\n    st = 2\n    end = math.ceil(math.sqrt(2 * n))\n    while st <= end:\n        lev = int((st + end) / 2)\n        if last_ele(lev) >= n and last_ele(lev - 1) < n:\n            break\n        elif last_ele(lev) > n:\n            end = lev - 1\n        else:\n            st = lev + 1\n    ind = n - int((lev - 1) * lev / 2)\n    return ind\nfor _ in range(int(input())):\n    (s, e) = map(int, input().split())\n    l1 = get_level(s)\n    l2 = get_level(e)\n    i1 = get_index(s)\n    i2 = get_index(e)\n    l = l2 - l1\n    id = i2 - i1\n    if l <= 0 or id < 0 or id > l:\n        print('0')\n    else:\n        print(ncr(l, id, 10 ** 9 + 7))", "import sys\nMOD = 10 ** 9 + 7\nFACT = [1]\n\ndef pyramid_moves(start, end):\n    (sr, sc) = getcoords(start)\n    (er, ec) = getcoords(end)\n    return comb(er - sr, ec - sc)\n\ndef comb(a, b):\n    if a < 0 or not 0 <= b <= a:\n        return 0\n    return fact(a) * pow(fact(b) * fact(a - b), MOD - 2, MOD) % MOD\n\ndef fact(a):\n    while a >= len(FACT):\n        FACT.append(FACT[-1] * len(FACT) % MOD)\n    return FACT[a]\n\ndef getcoords(n):\n    r = int((2 * n) ** 0.5)\n    if r * (r + 1) // 2 >= n:\n        r -= 1\n    c = n - r * (r + 1) // 2 - 1\n    return (r, c)\nncases = int(input())\nfor _ in range(ncases):\n    print(pyramid_moves(*[int(s) for s in input().split()]))", "from typing import DefaultDict\nfrom math import sqrt\nimport math\n\ndef calculate(p, q):\n    mod = 998244353\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n\ndef nCrModpDP(n, r, p):\n    C = [0] * (n + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        j = min(i, r)\n        while j > 0:\n            C[j] = (C[j] + C[j - 1]) % p\n            j -= 1\n    return C[r]\n\ndef nCrModpLucas(n, r, p):\n    if r == 0:\n        return 1\n    ni = int(n % p)\n    ri = int(r % p)\n    return nCrModpLucas(int(n / p), int(r / p), p) * nCrModpDP(ni, ri, p) % p\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef isprime(n):\n    prime_flag = 0\n    if n > 1:\n        for i in range(2, int(sqrt(n)) + 1):\n            if n % i == 0:\n                prime_flag = 1\n                break\n        if prime_flag == 0:\n            return True\n        else:\n            return False\n    else:\n        return True\n\ndef smallestDivisor(n):\n    if n % 2 == 0:\n        return 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return i\n        i += 2\n    return n\n\ndef dict_ele_count(l):\n    d = DefaultDict(lambda : 0)\n    for ele in l:\n        d[ele] += 1\n    return d\n\ndef max_in_dict(d):\n    maxi = 0\n    for ele in d:\n        if d[ele] > maxi:\n            maxi = d[ele]\n    return maxi\n\ndef element_count(s):\n    l = []\n    k = s[0]\n    c = 0\n    for ele in s:\n        if ele == k:\n            c += 1\n        else:\n            l.append([k, c])\n            k = ele\n            c = 1\n    l.append([k, c])\n    return l\n\ndef row(n):\n    x = math.sqrt(8 * n + 1)\n    x -= 1\n    x /= 2\n    if int(x) == x:\n        return int(x)\n    return int(x) + 1\n\ndef get_index(n):\n    x = row(n)\n    y = x * (x + 1) // 2\n    return int(x + n - y)\nfor _ in range(int(input())):\n    bool = True\n    flag = True\n    ans = 1\n    mod = 10 ** 9 + 7\n    (n, k) = map(int, input().split())\n    if n == k:\n        print(1)\n    elif row(n) >= row(k) or get_index(n) > get_index(k):\n        print(0)\n    else:\n        diag = get_index(k) - get_index(n)\n        tot = row(k) - row(n)\n        print(ncr(tot, diag, mod))", "t = int(input())\nmod = 10 ** 9 + 7\n\ndef binary_row(k):\n    l = 1\n    h = 45000\n    while l <= h:\n        mid = l + (h - l) // 2\n        start = mid * (mid - 1) // 2 + 1\n        end = start + mid - 1\n        if start <= k <= end:\n            return mid - 1\n        elif k > end:\n            l = mid + 1\n        elif k < start:\n            h = mid - 1\n    return l - 1\n\ndef binomial_coeff(n, r):\n    r = min(r, n - r)\n    (num, den) = (1, 1)\n    i = n\n    for j in range(1, r + 1):\n        num = num * i % mod\n        den = den * j % mod\n        i -= 1\n    res = 1\n    y = mod - 2\n    x = den\n    while y:\n        if y & 1:\n            res = res * x % mod\n        y = y // 2\n        x = x * x % mod\n    ans = num * res % mod\n    return ans\nfor i in range(t):\n    (s, e) = map(int, input().split())\n    if s == e:\n        print(1)\n    elif s < e:\n        row_s = binary_row(s)\n        row_e = binary_row(e)\n        col_s = s - (row_s * (row_s + 1) // 2 + 1)\n        col_e = e - (row_e * (row_e + 1) // 2 + 1)\n        rel_row = row_e - row_s\n        rel_col = col_e - col_s\n        if rel_row != 0 and 0 <= rel_col <= rel_row:\n            print(binomial_coeff(rel_row, rel_col) % (10 ** 9 + 7))\n        else:\n            print(0)\n    else:\n        print(0)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef getcoord(num):\n    y = int((2 * num + 0.25) ** 0.5 + 0.5)\n    x = int(num - y * (y - 1) / 2)\n    if x == 0:\n        y -= 1\n        x = y\n    return (x, y)\nT = int(input())\nfor i in range(T):\n    (s, e) = map(int, input().split())\n    E = getcoord(e)\n    S = getcoord(s)\n    n = E[1] - S[1]\n    r = E[0] - S[0]\n    if n < 1 or r < 0 or n < r:\n        print(0)\n    else:\n        print(ncr(n, r, 10 ** 9 + 7))", "import math\nmod7 = int(1000000000.0 + 7)\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef le(level):\n    return (level + 1) * level // 2\n\ndef get_values(n):\n    level = -1\n    index = -1\n    if n == 1:\n        return (1, 1)\n    start = 2\n    end = 1 + math.ceil(math.sqrt(2 * n))\n    while start <= end:\n        level = (start + end) // 2\n        if le(level) >= n and le(level - 1) < n:\n            break\n        elif le(level) > n:\n            end = level - 1\n        else:\n            start = level + 1\n    index = n - level * (level - 1) // 2\n    return (level, index)\n\ndef get_ans(s, e):\n    res1 = get_values(s)\n    res2 = get_values(e)\n    s_level = res1[0]\n    s_index = res1[1]\n    e_level = res2[0]\n    e_index = res2[1]\n    lvl = e_level - s_level\n    idx = e_index - s_index\n    answer = -1\n    if lvl <= 0 or idx < 0 or idx > lvl:\n        answer = 0\n    else:\n        answer = ncr(lvl, idx, mod7)\n    return answer % mod7\nt = int(input())\nwhile t:\n    t -= 1\n    (s, e) = map(int, input().split())\n    ans = get_ans(s, e)\n    print(ans)", "import sys\ninput = sys.stdin.readline\nfact = [1] * (10 ** 5 + 2)\ntS = 0\ntf = 1\nmod = 10 ** 9 + 7\nfor i in range(1, 10 ** 5 + 2):\n    fact[i] = fact[i - 1] * i % mod\n\ndef powmod(a, b, p):\n    a %= p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b % 2 == 1:\n            product *= a\n            product %= p\n            b = b - 1\n        a *= a\n        a %= p\n        b /= 2\n    return product\n\ndef inv(a, p):\n    return powmod(a, p - 2, p)\n\ndef nCk(n, k, p):\n    return fact[n] * inv(fact[k], p) % p * inv(fact[n - k], p) % p\nfor _ in range(int(input())):\n    (A, B) = map(int, input().split())\n    if A > B:\n        print(0)\n        continue\n    (a, b) = (0, 0)\n    (ai, bi) = (0, 0)\n    (i, k) = (1, 0)\n    while i <= B:\n        k += 1\n        if i <= A:\n            a = k\n            ai = i\n        i += k\n    b = k\n    bi = i - k\n    if B - bi < A - ai:\n        print(0)\n        continue\n    elif bi + b - 1 - B < ai + a - 1 - A:\n        print(0)\n        continue\n    n = b - a\n    r = B - (bi + A - ai)\n    ans = nCk(n, r, mod)\n    print(ans)", "import math\nN = 100001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef level(n):\n    n = n - 1\n    b = math.sqrt(1 + 8 * n)\n    b = b + 1\n    return int(b // 2)\n\ndef pos(n, l):\n    m = l * (l - 1)\n    m = m // 2\n    m = n - m\n    return int(m)\n\ndef fa(n, c):\n    a = math.factorial(n)\n    b = math.factorial(c)\n    d = math.factorial(n - c)\n    e = a // b // d\n    fa = 10 ** 9 + 7\n    return e % fa\n\ndef pyr(a, b):\n    return 1\n    if a > b:\n        return 0\n    if a == b:\n        return 1\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nn = int(input())\nfor i in range(n):\n    x = list(input().split(' '))\n    ac = int(x[0])\n    bc = int(x[1])\n    l1 = level(ac)\n    p1 = pos(ac, l1)\n    l2 = level(bc)\n    p2 = pos(bc, l2)\n    dp = p2 - p1\n    dl = l2 - l1\n    if dp > dl or dp < 0 or ac > bc:\n        print(0)\n    elif ac == bc or dp == dl or dp == 0:\n        print(1)\n    else:\n        ji = 10 ** 9 + 7\n        print(Binomial(dl, dp, ji))", "import math\nN = 100001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef level(n):\n    n = n - 1\n    b = math.sqrt(1 + 8 * n)\n    b = b + 1\n    return int(b // 2)\n\ndef pos(n, l):\n    m = l * (l - 1)\n    m = m // 2\n    m = n - m\n    return int(m)\n\ndef fa(n, c):\n    a = math.factorial(n)\n    b = math.factorial(c)\n    d = math.factorial(n - c)\n    e = a // b // d\n    fa = 10 ** 9 + 7\n    return e % fa\n\ndef pyr(a, b):\n    return 1\n    if a > b:\n        return 0\n    if a == b:\n        return 1\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nn = int(input())\nfor i in range(n):\n    x = list(input().split(' '))\n    ac = int(x[0])\n    bc = int(x[1])\n    l1 = level(ac)\n    p1 = pos(ac, l1)\n    l2 = level(bc)\n    p2 = pos(bc, l2)\n    dp = p2 - p1\n    dl = l2 - l1\n    if dp > dl or dp < 0 or ac > bc:\n        print(0)\n    elif ac == bc or dp == dl or dp == 0:\n        print(1)\n    else:\n        ji = 10 ** 9 + 7\n        print(Binomial(dl, dp, ji))", "from math import ceil, sqrt\nM = 10 ** 9 + 7\nfact = [1, 1]\nfor i in range(2, 10 ** 5 + 1):\n    fact.append(fact[i - 1] * i % M)\n\ndef powmod(a, b, p):\n    a %= p\n    if a == 0:\n        return 0\n    product = 1\n    while b > 0:\n        if b % 2 == 1:\n            product *= a\n            product %= p\n            b -= 1\n        a *= a\n        a %= p\n        b /= 2\n    return product\n\ndef inv(a, p):\n    return powmod(a, p - 2, p)\n\ndef nCk(n, k, p):\n    return fact[n] * inv(fact[k], p) % p * inv(fact[n - k], p) % p\n\ndef get_row_idx(n):\n    level = ceil((sqrt(8 * n + 1) - 1) / 2)\n    idx = n - level * (level - 1) // 2\n    return (level, idx)\nfor _ in range(int(input())):\n    (s, e) = map(int, input().split())\n    (sl, si) = get_row_idx(s)\n    (el, ei) = get_row_idx(e)\n    L = el - sl\n    K = ei - si\n    if L <= 0 or K < 0 or K > L:\n        print(0)\n        continue\n    print(nCk(L, K, M))", "import sys\ninput = sys.stdin.readline\nprint = sys.stdout.write\n\ndef nCrModp(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nmodn = 1000000007\nt = int(input())\nfor tt in range(t):\n    (s, e) = map(int, input().split())\n    if e <= s:\n        print('0\\n')\n        continue\n    srow = int((s * 2) ** 0.5 + 0.5)\n    erow = int((e * 2) ** 0.5 + 0.5)\n    n = erow - srow\n    if n <= 0:\n        print('0\\n')\n        continue\n    start = int(s + n / 2 * (srow + erow - 1))\n    if e < start:\n        print('0\\n')\n        continue\n    end = int(s + n / 2 * (srow + 1 + erow))\n    if e > end:\n        print('0\\n')\n        continue\n    r = e - start\n    print(str(nCrModp(n, r, modn)) + '\\n')", "from bisect import *\nimport sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef st():\n    return input().rstrip('\\n')\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\nt = inp()\np = 10 ** 9 + 7\nfac = [1]\ninv = [pow(1, p - 2, p)]\nfor i in range(1, 10 ** 5):\n    fac.append(fac[-1] * i % p)\n    inv.append(pow(fac[-1], p - 2, p))\nhave = [1]\nfor i in range(10 ** 5):\n    have.append(have[-1] + 1 + i)\nwhile t:\n    t -= 1\n    (s, e) = ma()\n    fi = bisect_right(have, s)\n    se = bisect_right(have, e)\n    if fi >= se:\n        print(0)\n    else:\n        r1 = fi\n        r2 = se\n        c1 = s - have[fi - 1] + 1\n        c2 = e - have[se - 1] + 1\n        n = r2 - r1\n        le = c1\n        re = c1 + n\n        if c2 < le or c2 > re:\n            print(0)\n        else:\n            r = abs(c1 - c2)\n            res = fac[n] * inv[r] * inv[n - r]\n            print(res % p)", "def row_column(num):\n    n = 0\n    while num > n * (n + 1) // 2:\n        n = n + 1\n    return (n - 1, num - n * (n - 1) // 2 - 1)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    return p if y % 2 == 0 else x * p % m\n\ndef ncr(n, r, p, fact):\n    num = fact[n]\n    den = fact[n - r] * fact[r] % m\n    return num * power(den, p - 2, p) % p\nt = int(input())\nfact = [0] * 100001\nfact[0] = 1\nm = 1000000007\nfor i in range(1, 100001):\n    fact[i] = fact[i - 1] * i % m\nfor _ in range(t):\n    (s, e) = map(int, input().split())\n    (sr, sc) = row_column(s)\n    (er, ec) = row_column(e)\n    rr = er - sr\n    rc = ec - sc\n    if rr >= rc and rr >= 0 and (rc >= 0):\n        ans = ncr(rr, rc, m, fact)\n        print(ans)\n    else:\n        print(0)", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef sub(a, b):\n    return (a - b + mod) % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef ncr(n, r):\n    return mul(fact[n], mul(facti[n - r], facti[r]))\n\ndef div(a, b):\n    return mul(a, pow(b, mod - 2, mod))\n(fact, facti) = ([1], [1])\nsize = 2 * 10 ** 5 + 1\nfor i in range(1, size):\n    fact.append(mul(fact[-1], i))\n    facti.append(pow(fact[-1], mod - 2, mod))\n\ndef find(x):\n    (l, h) = (0, x)\n    while l <= h:\n        mid = (l + h) // 2\n        val = mid * (mid + 1) // 2\n        if val < x:\n            total = val\n            row = mid + 1\n            l = mid + 1\n        else:\n            h = mid - 1\n    return [total, row]\n\ndef answer():\n    (total1, row1) = find(s)\n    (total2, row2) = find(e)\n    (p1, p2) = (s - total1, e - total2)\n    n = row2 - row1\n    r = p2 - p1\n    if r < 0 or r > n:\n        return 0\n    return ncr(n, r)\nfor T in range(int(input())):\n    (s, e) = map(int, input().split())\n    dp = dict()\n    count = 0\n    print(answer())", "import sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\n\ndef _sum(i):\n    return i * (i + 1) // 2\n\ndef search(el):\n    if el == 1:\n        return (1, 1)\n    i = 0\n    while True:\n        i += 1\n        if _sum(i) >= el:\n            row = i\n            start = _sum(i) - i + 1\n            end = _sum(i)\n            col = el - start + 1\n            return (row, col)\nmod = 10 ** 9 + 7\nsz = 10 ** 5 + 1\nfact = [1, 1]\nfor i in range(2, sz):\n    fact.append(fact[-1] * i % mod)\ninv_fact = []\nfor i in range(sz):\n    inv_fact.append(pow(fact[i], mod - 2, mod))\n\ndef ncr(n, r):\n    return fact[n] * inv_fact[n - r] % mod * inv_fact[r] % mod\nfor _ in range(int(input())):\n    (s, e) = list(map(int, input().split()))\n    start = search(s)\n    end = search(e)\n    if start[0] < end[0] and start[1] <= end[1] <= start[1] + end[0] - start[0]:\n        down = end[0] - start[0]\n        left = end[1] - start[1]\n        print(ncr(down, left) % mod)\n    else:\n        print(0)", "import math\nP = 10 ** 9 + 7\n\ndef C(n, r):\n    num = 1\n    den = 1\n    for j in range(1, r + 1):\n        num = num * (n - j + 1) % P\n        den = den * j % P\n    pro = num * pow(den, P - 2, P)\n    return pro % P\n\ndef g(n):\n    m = math.floor((-1 + (1 + 8 * n) ** 0.5) * 0.5)\n    z = n - m * (m + 1) // 2\n    if z == 0:\n        return (m - 1, m - 1)\n    else:\n        return (m, z - 1)\n\ndef f(s, e):\n    (i_s, j_s) = g(s)\n    (i_e, j_e) = g(e)\n    if i_e < i_s:\n        return 0\n    else:\n        p = i_e - i_s\n        q = j_e - j_s\n        if 0 <= q <= p:\n            P1 = C(p, q)\n            return P1\n        else:\n            return 0\nt = int(input())\nfor i in range(0, t):\n    (s, e) = map(int, input().split())\n    print(f(s, e))"]