["for _ in range(int(input())):\n    N = int(input())\n    A = [int(i) for i in input().split()]\n    dict = {}\n    ans = 4 * N\n    front = 0\n    back = 0\n    while back < N:\n        if A[back] in dict:\n            for i in range(front, dict[A[back]]):\n                if A[i] in dict:\n                    del dict[A[i]]\n            ans = min(2 * min(front, N - back) + max(front, N - back), ans)\n            front = dict[A[back]] + 1\n            dict[A[back]] = back\n            back += 1\n        else:\n            dict[A[back]] = back\n            back += 1\n    ans = min(2 * min(front, N - back) + max(front, N - back), ans)\n    print(ans)", "for _ in range(int(input())):\n    N = int(input())\n    A = [int(i) for i in input().split()]\n    dict = {}\n    ans = 4 * N\n    front = 0\n    back = 0\n    while back < N:\n        if A[back] in dict:\n            for i in range(front, dict[A[back]]):\n                if A[i] in dict:\n                    del dict[A[i]]\n            ans = min(2 * min(front, N - back) + max(front, N - back), ans)\n            front = dict[A[back]] + 1\n            dict[A[back]] = back\n            back += 1\n        else:\n            dict[A[back]] = back\n            back += 1\n    ans = min(2 * min(front, N - back) + max(front, N - back), ans)\n    print(ans)", "from sys import stdin\ninput = stdin.readline\nfrom math import ceil, floor, sqrt, log2\nfrom heapq import heappush, heappop\nfrom collections import deque\nfrom functools import lru_cache\nfrom bisect import bisect_left, bisect_right\n\ndef rl(t=int):\n    return list(map(t, input().split()))\nT = int(input())\nfor t in range(1, T + 1):\n    n = int(input())\n    a = rl()\n    ret = n - 1\n    i = 0\n    seen = set()\n    for (j, cur) in enumerate(a):\n        while cur in seen:\n            seen.remove(a[i])\n            i += 1\n        seen.add(a[j])\n        left = i\n        right = n - j - 1\n        ret = min(ret, max(left, right) + 2 * min(left, right))\n    print(ret)", "from sys import stdin\ninput = stdin.readline\nfrom math import ceil, floor, sqrt, log2\nfrom heapq import heappush, heappop\nfrom collections import deque\nfrom functools import lru_cache\nfrom bisect import bisect_left, bisect_right\n\ndef rl(t=int):\n    return list(map(t, input().split()))\nT = int(input())\nfor t in range(1, T + 1):\n    n = int(input())\n    a = rl()\n    ret = n - 1\n    i = 0\n    seen = set()\n    for (j, cur) in enumerate(a):\n        while cur in seen:\n            seen.remove(a[i])\n            i += 1\n        seen.add(a[j])\n        left = i\n        right = n - j - 1\n        ret = min(ret, max(left, right) + 2 * min(left, right))\n    print(ret)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = n\n    start = 0\n    x = 0\n    d = {arr[0]: 1}\n    for i in range(1, n):\n        d[arr[i]] = d.get(arr[i], 0) + 1\n        if d[arr[i]] > 1:\n            x = start\n            y = n - i\n            temp1 = 2 * x + y\n            temp2 = 2 * y + x\n            ans = min(ans, temp1, temp2)\n        while d[arr[i]] > 1:\n            d[arr[start]] -= 1\n            start += 1\n    x = start\n    y = 0\n    temp1 = 2 * x + y\n    temp2 = 2 * y + x\n    ans = min(ans, temp1, temp2)\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    mp = {}\n    j = 0\n    ans = 10000000000\n    for i in range(0, n):\n        if a[i] in mp:\n            mp[a[i]] += 1\n        else:\n            mp[a[i]] = 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        x = j\n        y = n - i - 1\n        ans = min(ans, 2 * x + y, x + y * 2)\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    mp = {}\n    j = 0\n    ans = 10000000000\n    for i in range(0, n):\n        if a[i] in mp:\n            mp[a[i]] += 1\n        else:\n            mp[a[i]] = 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        x = j\n        y = n - i - 1\n        ans = min(ans, 2 * x + y, x + y * 2)\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    ind = 0\n    swap = n\n    for i in range(n):\n        if a[i] in d:\n            d[a[i]] += 1\n        else:\n            d[a[i]] = 1\n        while d[a[i]] > 1:\n            d[a[ind]] -= 1\n            ind += 1\n        swap = min(swap, ind + (n - i - 1) + min(ind, n - i - 1))\n    print(swap)", "from collections import Counter\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1 or max(Counter(a).values()) == 1:\n        print(0)\n    else:\n        (ans, cnt, j) = (0, {}, -1)\n        for i in range(n):\n            try:\n                val = cnt[a[i]]\n                j = i - 1\n                break\n            except:\n                cnt[a[i]] = 1\n            j = i\n        ans = n - j - 1\n        for i in range(1, n):\n            cnt[a[i - 1]] = 0\n            for k in range(j + 1, n):\n                try:\n                    val = cnt[a[k]]\n                    if val == 1:\n                        j = k - 1\n                        break\n                    cnt[a[k]] = 1\n                except:\n                    cnt[a[k]] = 1\n                j = k\n            ans = min(ans, min(2 * i + n - j - 1, i + 2 * (n - j - 1)))\n            if j == n - 1:\n                break\n        print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    d = defaultdict(lambda : 0, {})\n    (ans, j) = (None, 0)\n    for i in range(n):\n        d[l[i]] += 1\n        while d[l[i]] > 1:\n            d[l[j]] -= 1\n            j += 1\n        if ans == None:\n            ans = 2 * min(j, n - i - 1) + max(j, n - i - 1)\n        else:\n            ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 10 ** 10\n    mp = {}\n    j = 0\n    for i in range(n):\n        if a[i] in mp.keys():\n            mp[a[i]] += 1\n        else:\n            mp[a[i]] = 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    ans = 10 ** 10\n    j = 0\n    for k in range(n):\n        if a[k] in d.keys():\n            d[a[k]] += 1\n        else:\n            d[a[k]] = 1\n        while d[a[k]] > 1:\n            d[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - k - 1) + max(j, n - k - 1))\n    print(ans)", "T = int(input())\n\ndef int_arr_input():\n    return [int(x) for x in input().split()]\n\ndef compute_next_idx(A, N):\n    next_idx = [N - 1 for i in range(N)]\n    i = j = 0\n    cnt = dict()\n    while j < N:\n        j_key = str(A[j])\n        prev = cnt.get(j_key, 0)\n        cnt[j_key] = prev + 1\n        if prev == 1:\n            while i <= j:\n                next_idx[i] = j - 1\n                i_key = str(A[i])\n                cur = cnt[i_key]\n                cnt[i_key] = cur - 1\n                i += 1\n                if cur == 2:\n                    break\n        j += 1\n    return next_idx\nwhile T:\n    T -= 1\n    N = int(input())\n    A = int_arr_input()\n    next_idx = compute_next_idx(A, N)\n    ret = 1000000000.0\n    for i in range(N):\n        j = next_idx[i]\n        m1 = 2 * i + N - j - 1\n        m2 = i + 2 * (N - j - 1)\n        ret = min(ret, min(m1, m2))\n    print(ret)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dic = {}\n    sample = []\n    max_l = start = 0\n    for (i, key) in enumerate(a):\n        if key in dic and start <= dic[key]:\n            start = dic[key] + 1\n        elif i - start + 1 > max_l:\n            max_l = i - start + 1\n            sample = [[start, i]]\n        elif i - start + 1 == max_l:\n            sample.append([start, i])\n        dic[key] = i\n    ans = 10 ** 9\n    for (i, j) in sample:\n        ans = min(ans, min(i, n - j - 1) * 2 + max(i, n - j - 1))\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 10 ** 10\n    mp = {}\n    j = 0\n    for i in range(0, n):\n        if a[i] in mp.keys():\n            mp[a[i]] += 1\n        else:\n            mp[a[i]] = 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 10 ** 10\n    mp = dict()\n    j = 0\n    for i in range(0, n):\n        if a[i] in mp.keys():\n            mp[a[i]] += 1\n        else:\n            mp[a[i]] = 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "t = int(input())\nfor k in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    j = 0\n    cnt = 0\n    mp = {}\n    ans = n - 1\n    for i in range(n):\n        if a[i] not in mp:\n            mp[a[i]] = 1\n        else:\n            mp[a[i]] += 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - 1 - i) + max(n - 1 - i, j))\n    print(ans)", "ans = ''\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    (l, r) = (0, 0)\n    maxLen = 0\n    (maxL, maxR) = (-1, -1)\n    candi = []\n    st = set()\n    while r < n:\n        while r < n and arr[r] not in st:\n            st.add(arr[r])\n            r += 1\n        if maxLen <= r - l:\n            maxLen = r - l\n            maxL = l\n            maxR = r - 1\n            candi.append([maxLen, maxL, maxR])\n        while l <= r and r < n and (arr[r] in st):\n            st.remove(arr[l])\n            l += 1\n    res = float('inf')\n    for cand in candi:\n        if cand[0] == maxLen:\n            res = min(res, 2 * cand[1] + (n - cand[2] - 1), cand[1] + 2 * (n - cand[2] - 1))\n    ans += str(res) + '\\n'\nprint(ans)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 10 ** 10\n    mp = {}\n    j = 0\n    for i in range(n):\n        if a[i] in mp.keys():\n            mp[a[i]] += 1\n        else:\n            mp[a[i]] = 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    mp = defaultdict(lambda : 0)\n    ans = float('inf')\n    n = int(input())\n    j = 0\n    l = list(map(int, input().split()))\n    for i in range(n):\n        mp[l[i]] += 1\n        while mp[l[i]] > 1:\n            mp[l[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "for _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    d = {}\n    j = 0\n    ans = 10 ** 10\n    for i in range(N):\n        if A[i] in d.keys():\n            d[A[i]] += 1\n        else:\n            d[A[i]] = 1\n        while d[A[i]] > 1:\n            d[A[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, N - i - 1) + max(j, N - i - 1))\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (ans, j) = (n, 0)\n    index = dict()\n    for i in range(n):\n        if a[i] in index.keys():\n            j = max(j, index[a[i]])\n            index[a[i]] = i + 1\n        else:\n            index[a[i]] = i + 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = input().split()\n    (ans, j) = (10 ** 10, 0)\n    index = dict()\n    for i in range(n):\n        if a[i] in index.keys():\n            j = max(j, index[a[i]])\n            index[a[i]] = i + 1\n        else:\n            index[a[i]] = i + 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    hmap = {}\n    l = 0\n    res = 10 ** 10\n    for r in range(0, n):\n        if A[r] in hmap.keys():\n            hmap[A[r]] += 1\n        else:\n            hmap[A[r]] = 1\n        while hmap[A[r]] > 1:\n            hmap[A[l]] -= 1\n            l += 1\n        res = min(res, 2 * min(l, n - r - 1) + max(l, n - r - 1))\n    print(res)", "for _ in range(int(input())):\n    s = int(input())\n    inp = list(map(int, input().split()))\n    dic = {}\n    j = 0\n    res = 10 ** 10\n    for i in range(s):\n        if inp[i] not in dic.keys():\n            dic[inp[i]] = 1\n        else:\n            dic[inp[i]] += 1\n        while dic[inp[i]] > 1:\n            dic[inp[j]] -= 1\n            j += 1\n        res = min(res, 2 * min(j, s - i - 1) + max(j, s - i - 1))\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    a = {arr[0]}\n    i = 0\n    j = 1\n    ans = float('inf')\n    while j < n:\n        if arr[j] in a:\n            while arr[j] in a:\n                a.remove(arr[i])\n                i += 1\n        a.add(arr[j])\n        ans = min(ans, max(i, n - j - 1) + 2 * min(i, n - j - 1))\n        j += 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    a = {arr[0]}\n    i = 0\n    j = 1\n    ans = float('inf')\n    while j < n:\n        if arr[j] in a:\n            while arr[j] in a:\n                a.remove(arr[i])\n                i += 1\n        a.add(arr[j])\n        ans = min(ans, max(i, n - j - 1) + 2 * min(i, n - j - 1))\n        j += 1\n    print(ans)", "def solve(n, arr):\n    i = 0\n    seen = set()\n    maxLen = 0\n    left = right = -1\n    res = float('inf')\n    for j in range(n):\n        while arr[j] in seen:\n            seen.remove(arr[i])\n            i += 1\n        seen.add(arr[j])\n        if j - i + 1 >= maxLen:\n            maxLen = j - i + 1\n            left = i\n            right = j\n            removeLeftFirst = left * 2 + n - right - 1\n            removeRightFirst = (n - right - 1) * 2 + left\n            res = min(res, removeLeftFirst, removeRightFirst)\n    if left == 0:\n        return n - right - 1\n    if right == n - 1:\n        return left\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(solve(n, arr))", "from collections import Counter, defaultdict\n\nclass Solution:\n\n    def __init__(self):\n        pass\n\n    def solve(self, n, p):\n        start = 0\n        end = -1\n        maxLength = 0\n        seenSet = set()\n        ms = []\n        me = []\n        while end < n - 1:\n            end += 1\n            while p[end] in seenSet:\n                seenSet.remove(p[start])\n                start += 1\n            seenSet.add(p[end])\n            if maxLength < end - start + 1:\n                maxLength = end - start + 1\n                ms = [start]\n                me = [end]\n            elif maxLength == end - start + 1:\n                ms.append(start)\n                me.append(end)\n        minOp = float('inf')\n        for i in range(len(ms)):\n            minOp = min(n - maxLength + min(ms[i], n - me[i] - 1), minOp)\n        print(minOp)\nt = int(input())\ns = Solution()\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    s.solve(n, arr)", "for _ in range(int(input())):\n    n = int(input())\n    l1 = list(map(int, input().split()))\n    ans = 10 ** 10\n    mp = {}\n    j = 0\n    for i in range(0, n):\n        if l1[i] in mp.keys():\n            mp[l1[i]] += 1\n        else:\n            mp[l1[i]] = 1\n        while mp[l1[i]] > 1:\n            mp[l1[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "def printArr(a):\n    s = ''\n    for i in a:\n        s += str(i) + ' '\n    print(s[0:-1])\nimport sys\nsys.setrecursionlimit(10 ** 5)\n\ndef topop(l, h, n):\n    x = n - h - 1\n    if x < l:\n        return 2 * x + l\n    else:\n        return 2 * l + x\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(_) for _ in input().split()]\n    l = 0\n    h = 0\n    t = 0\n    d = dict()\n    for i in range(n):\n        x = a[i]\n        if x in d and d[x] >= t:\n            y = d[x]\n            if topop(l, h, n) > topop(t, y, n):\n                l = t\n                h = y\n            if topop(l, h, n) > topop(y + 1, i, n):\n                l = y + 1\n                h = i\n            if topop(l, h, n) > topop(y, i - 1, n):\n                l = y\n                h = i - 1\n            if topop(l, h, n) > topop(t, i - 1, n):\n                l = t\n                h = i - 1\n            t = y + 1\n        d[x] = i\n    if topop(t, n - 1, n) < topop(l, h, n):\n        print(topop(t, n - 1, n))\n    else:\n        print(topop(l, h, n))", "from collections import defaultdict, Counter\n\ndef ans(l):\n    n = len(l)\n    d = defaultdict(lambda : 1000000)\n    a = [0] * n\n    for i in range(n - 1, -1, -1):\n        a[i] = d[l[i]]\n        d[l[i]] = i\n        if i < n - 1:\n            a[i] = min(a[i + 1], a[i])\n    if a[0] == 1000000:\n        return 0\n    ans = 1000000\n    for j in range(n - 1):\n        if a[j + 1] == 1000000:\n            ans = min(ans, j + 1)\n            break\n        ans = min(ans, 2 * (j + 1) + n - a[j + 1])\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = list(map(int, input().split()))\n    print(min(ans(s), ans(s[::-1])))", "from cmath import inf\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    d = defaultdict(lambda : 0)\n    j = 0\n    ans = inf\n    for i in range(n):\n        d[l[i]] += 1\n        while d[l[i]] > 1:\n            d[l[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    (unique, maxUnique, ind, s, queue) = (0, 0, 0, set(), [])\n    ans = float('inf')\n    for i in range(n):\n        if nums[i] not in s:\n            unique += 1\n        else:\n            if unique >= maxUnique:\n                (maxUnique, ind) = (unique, i - unique)\n                ans = min(ans, 2 * min(ind, n - i) + max(ind, n - i))\n            while queue[0] != nums[i]:\n                s.remove(queue.pop(0))\n            queue.pop(0)\n            unique = len(queue) + 1\n        queue.append(nums[i])\n        s.add(nums[i])\n    if unique >= maxUnique:\n        ans = min(ans, n - unique)\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    (unique, maxUnique, ind, s, queue) = (0, 0, 0, set(), [])\n    ans = float('inf')\n    for i in range(n):\n        if nums[i] not in s:\n            unique += 1\n        else:\n            if unique >= maxUnique:\n                (maxUnique, ind) = (unique, i - unique)\n                ans = min(ans, 2 * min(ind, n - i) + max(ind, n - i))\n            while queue[0] != nums[i]:\n                s.remove(queue.pop(0))\n            queue.pop(0)\n            unique = len(queue) + 1\n        queue.append(nums[i])\n        s.add(nums[i])\n    if unique >= maxUnique:\n        (maxUnique, ind) = (unique, n - unique)\n        ans = min(ans, 2 * min(ind, n - ind - maxUnique) + max(ind, n - ind - maxUnique))\n    print(ans)", "import math, sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfrom collections import defaultdict\nfor _ in range(I()):\n    n = I()\n    arr = L()\n    ans = 1000000000.0\n    mp = defaultdict(int)\n    r = 0\n    for l in range(n):\n        while r < n and (not mp[arr[r]]):\n            mp[arr[r]] += 1\n            r += 1\n        ans = min(ans, l + 2 * (n - r))\n        ans = min(ans, 2 * l + (n - r))\n        mp[arr[l]] -= 1\n    print(ans)", "for _ in range(int(input())):\n    N = int(input())\n    A = [int(i) for i in input().split()]\n    dict = {}\n    ans = 4 * N\n    front = 0\n    back = 0\n    while back < N:\n        if A[back] in dict:\n            for i in range(front, dict[A[back]]):\n                if A[i] in dict:\n                    del dict[A[i]]\n            ans = min(2 * min(front, N - back) + max(front, N - back), ans)\n            front = dict[A[back]] + 1\n            dict[A[back]] = back\n            back += 1\n        else:\n            dict[A[back]] = back\n            back += 1\n    ans = min(2 * min(front, N - back) + max(front, N - back), ans)\n    print(ans)", "from collections import defaultdict\nimport sys\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        vec = input().split()\n        vec = [int(i) for i in vec]\n        mp = {}\n        mp = defaultdict(lambda : 0, mp)\n        ans = n - 1\n        back = 0\n        front = 0\n        mp[vec[0]] += 1\n        x = 0\n        y = n - 1\n        while front < n - 1:\n            front += 1\n            y -= 1\n            if mp[vec[front]] == 1:\n                front -= 1\n                y += 1\n                if front == back:\n                    front += 1\n                    y -= 1\n                    back += 1\n                    x += 1\n                else:\n                    mp[vec[back]] -= 1\n                    back += 1\n                    x += 1\n            else:\n                mp[vec[front]] += 1\n            ans = min(ans, min(x + 2 * y, y + 2 * x))\n        print(ans)\n    return 0\nmain()", "from collections import defaultdict\nt = int(input())\nfor test in range(t):\n    n = int(input())\n    num = list(map(int, input().split()))\n    ans = float('inf')\n    mx = max(num)\n    mp = defaultdict(int)\n    j = 0\n    for i in range(n):\n        mp[num[i]] += 1\n        while mp[num[i]] > 1:\n            mp[num[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 10 ** 10\n    mp = {}\n    j = 0\n    for i in range(n):\n        if a[i] in mp.keys():\n            mp[a[i]] += 1\n        else:\n            mp[a[i]] = 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    mp = {}\n    j = 0\n    ans = float('inf')\n    for i in range(n):\n        mp[a[i]] = mp.get(a[i], 0) + 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "t = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 10 ** 10\n    hashmap = {}\n    j = 0\n    for i in range(n):\n        if a[i] in hashmap.keys():\n            hashmap[a[i]] += 1\n        else:\n            hashmap[a[i]] = 1\n        while hashmap[a[i]] > 1:\n            hashmap[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "for i in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split(' ')))\n    hash_map = {}\n    j = 0\n    ans = 10 ** 10\n    for i in range(len(arr)):\n        if arr[i] in hash_map.keys():\n            hash_map[arr[i]] += 1\n        else:\n            hash_map[arr[i]] = 1\n        while hash_map[arr[i]] > 1:\n            hash_map[arr[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "result = []\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().strip().split()))\n    mapIndex = dict()\n    (st, ed) = (0, n - 1)\n    res = []\n    for i in range(n):\n        if arr[i] not in mapIndex:\n            mapIndex[arr[i]] = i\n            ed = i\n        else:\n            ind = mapIndex[arr[i]]\n            e = n - 1 - ed\n            res.append(min(2 * st + e, st + 2 * e))\n            st = ind + 1\n            while ind >= 0 and arr[ind] in mapIndex:\n                if mapIndex[arr[ind]] == ind:\n                    del mapIndex[arr[ind]]\n                ind -= 1\n            mapIndex[arr[i]] = i\n    e = n - 1 - ed\n    res.append(min(2 * st + e, st + 2 * e))\n    result.append(str(min(res)))\nprint('\\n'.join(result))", "for _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    ans = 99999999999999\n    my_dict = {}\n    j = 0\n    for _ in range(N):\n        if A[_] in my_dict.keys():\n            my_dict[A[_]] += 1\n        else:\n            my_dict[A[_]] = 1\n        while my_dict[A[_]] > 1:\n            my_dict[A[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, N - _ - 1) + max(j, N - _ - 1))\n    print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    h = defaultdict(int)\n    c = n\n    j = 0\n    for i in range(n):\n        if a[i] in h:\n            t = h[a[i]]\n        else:\n            t = 0\n        j = max(t, j)\n        h[a[i]] = 1 + i\n        c = min(c, min(j, n - i - 1) + j + n - i - 1)\n    print(c)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    h = defaultdict(int)\n    c = n\n    j = 0\n    for i in range(n):\n        if a[i] in h:\n            t = h[a[i]]\n        else:\n            t = 0\n        j = max(t, j)\n        h[a[i]] = 1 + i\n        c = min(c, min(j, n - i - 1) + j + n - i - 1)\n    print(c)", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(a % b, a)\n\ndef solve(arr, n):\n    a = {}\n    (temp, ans, j) = (n - 1, n, 0)\n    i = 0\n    while i < n:\n        temp = n - i - 1\n        if arr[i] in a:\n            j = max(a[arr[i]], j)\n        else:\n            j = max(0, j)\n        a[arr[i]] = 1 + i\n        ans = min(ans, min(j, temp) + j + temp)\n        i += 1\n    return ans\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        print(solve(arr, n))\nmain()", "from collections import defaultdict\n\ndef solve(a):\n    heap = defaultdict(int)\n    count = n\n    j = 0\n    for i in range(n):\n        (r, temp) = (n - i - 1, heap.get(a[i], 0))\n        j = max(temp, j)\n        heap[a[i]] = 1 + i\n        count = min(count, min(j, r) + j + r)\n    return count\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(a))", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split(' ')))\n    dct = defaultdict(lambda : 0)\n    nee = n + 1\n    (start, end) = (0, 0)\n    for j in range(n):\n        if end <= j:\n            dct = defaultdict(lambda : 0)\n            dct[arr[j]] += 1\n            start = j\n            end = j\n        else:\n            while start != j:\n                dct[arr[start]] -= 1\n                start += 1\n        while end < n - 1 and (not dct[arr[end + 1]]):\n            dct[arr[end + 1]] += 1\n            end += 1\n        x = max(start, n - 1 - end)\n        y = min(start, n - 1 - end)\n        nee = min(x + 2 * y, nee)\n    print(nee)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split(' ')))\n    dct = defaultdict(lambda : 0)\n    nee = n + 1\n    (start, end) = (0, 0)\n    for j in range(n):\n        if end <= j:\n            dct = defaultdict(lambda : 0)\n            dct[arr[j]] += 1\n            start = j\n            end = j\n        else:\n            while start != j:\n                dct[arr[start]] -= 1\n                start += 1\n        while end < n - 1 and (not dct[arr[end + 1]]):\n            dct[arr[end + 1]] += 1\n            end += 1\n        x = max(start, n - 1 - end)\n        y = min(start, n - 1 - end)\n        nee = min(x + 2 * y, nee)\n    print(nee)", "for i in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    j = 0\n    ans = 10 ** 18\n    d = dict()\n    for i in range(n):\n        if l[i] not in d:\n            d[l[i]] = 1\n        else:\n            d[l[i]] += 1\n        while d[l[i]] > 1:\n            d[l[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "from collections import defaultdict\n\ndef largest_subarray(a, n):\n    index = defaultdict(lambda : 0)\n    ans = 0\n    j = 0\n    ind1 = 0\n    ind2 = 0\n    for i in range(n):\n        j = max(index[a[i]], j)\n        ans = max(ans, i - j + 1)\n        if ans == i - j + 1:\n            ind1 = i\n            ind2 = j\n        index[a[i]] = i + 1\n        i += 1\n    return [ans, ind1, ind2]\nfrom collections import Counter\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    n1 = n\n    a1 = {}\n    for i in range(n):\n        if a[i] not in a1:\n            a1[a[i]] = 1\n        else:\n            a1[a[i]] += 1\n    n2 = len(a1)\n    if n1 == n2:\n        print(0)\n    else:\n        ans = n - 1\n        x = largest_subarray(a, n)\n        ind1 = min(x[1], x[2])\n        ind2 = max(x[1], x[2])\n        ans1 = ind1 + 2 * (n - ind2 - 1)\n        ans2 = 2 * ind1 + (n - ind2 - 1)\n        ans = min(ans1, ans2)\n        x = largest_subarray(a[::-1], n)\n        ind1 = min(x[1], x[2])\n        ind2 = max(x[1], x[2])\n        ans1 = ind1 + 2 * (n - ind2 - 1)\n        ans2 = 2 * ind1 + (n - ind2 - 1)\n        ans = min(ans1, ans2, ans)\n        print(ans)", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 10 ** 10\n    mp = {}\n    j = 0\n    for i in range(0, n):\n        if a[i] in mp.keys():\n            mp[a[i]] += 1\n        else:\n            mp[a[i]] = 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)\n    t -= 1", "for t in range(int(input())):\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    freq = {}\n    ans = n - 1\n    j = 0\n    for i in range(n):\n        if A[i] not in freq:\n            freq[A[i]] = 1\n        else:\n            freq[A[i]] += 1\n        while freq[A[i]] > 1:\n            freq[A[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 10 ** 10\n    mp = {}\n    j = 0\n    for i in range(n):\n        if a[i] in mp.keys():\n            mp[a[i]] += 1\n        else:\n            mp[a[i]] = 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    mp = {}\n    j = 0\n    ans = 10 ** 10\n    for i in range(n):\n        if arr[i] in mp:\n            mp[arr[i]] += 1\n        else:\n            mp[arr[i]] = 1\n        while mp[arr[i]] > 1:\n            mp[arr[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)\n    t = t - 1", "t = int(input())\n\ndef solve(ar):\n    mp = {}\n    n = len(ar)\n    ans = float('inf')\n    (i, j) = (0, 0)\n    while j < n:\n        if ar[j] not in mp or mp[ar[j]] == 0:\n            mp[ar[j]] = 1\n        elif mp[ar[j]] == 1:\n            while ar[i] != ar[j]:\n                mp[ar[i]] -= 1\n                i += 1\n            i += 1\n        ans = min(ans, 2 * i + n - j - 1, 2 * (n - j - 1) + i)\n        j += 1\n    return ans\nfor _ in range(t):\n    n = int(input())\n    x = list(map(int, input().split()))\n    print(solve(x))", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = [int(_) for _ in input().split()]\n    freq = {}\n    j = 0\n    ans = pow(10, 9) + 1\n    for i in range(n):\n        if arr[i] not in freq:\n            freq[arr[i]] = 1\n        else:\n            freq[arr[i]] += 1\n        while freq[arr[i]] > 1:\n            freq[arr[j]] -= 1\n            j += 1\n        ans = min(ans, max(j, n - i - 1) + 2 * min(j, n - i - 1))\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    l = 0\n    hm = {}\n    for i in range(n):\n        hm[arr[i]] = 0\n    res = 1000000000.0\n    for i in range(n):\n        hm[arr[i]] += 1\n        while hm[arr[i]] > 1:\n            hm[arr[l]] -= 1\n            l += 1\n        res = min(res, 2 * min(l, n - i - 1) + max(l, n - i - 1))\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 10 ** 10\n    mp = {}\n    j = 0\n    for i in range(0, n):\n        if a[i] in mp.keys():\n            mp[a[i]] += 1\n        else:\n            mp[a[i]] = 1\n        while mp[a[i]] > 1:\n            mp[a[j]] -= 1\n            j += 1\n        ans = min(ans, 2 * min(j, n - i - 1) + max(j, n - i - 1))\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    lis = list(map(int, input().split()))\n    coll = {}\n    for i in lis:\n        if i not in coll:\n            coll[i] = 0\n    p1 = 0\n    p2 = 0\n    ans = n - 1\n    (l, r) = (-1, -1)\n    while p2 < n:\n        if coll[lis[p2]] == 0:\n            coll[lis[p2]] = 1\n            p2 += 1\n        else:\n            while coll[lis[p2]] != 0:\n                coll[lis[p1]] -= 1\n                p1 += 1\n            coll[lis[p2]] = 1\n            p2 += 1\n        le = p1 - 0\n        ri = n - p2\n        ans = min(ans, min(2 * le + ri, le + 2 * ri))\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    l1 = [int(i) for i in input().split()]\n    d1 = {}\n    for i in l1:\n        d1[i] = -1\n    j = 0\n    ans = -1\n    for i in range(n):\n        while j < n and d1[l1[j]] == -1:\n            d1[l1[j]] = 1\n            j += 1\n        if ans == -1:\n            ans = min(i * 2 + (n - j), (n - j) * 2 + i)\n        else:\n            ans = min(ans, i * 2 + (n - j), (n - j) * 2 + i)\n        d1[l1[i]] = -1\n    print(ans)", "test = int(input())\nwhile test:\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    f = dict()\n    i = j = 0\n    ans = 1000000.0\n    while j < n:\n        if a[j] in f.keys():\n            f[a[j]] += 1\n        else:\n            f[a[j]] = 1\n        if f[a[j]] > 1:\n            while a[i] != a[j]:\n                f[a[i]] -= 1\n                i += 1\n            f[a[j]] -= 1\n            i += 1\n        ans = min(ans, 2 * i + n - j - 1, 2 * (n - j - 1) + i)\n        j += 1\n    test -= 1\n    print(ans)", "from collections import deque\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = list(map(int, input().split()))\n    longest = [1] * N\n    unique = {}\n    start = 0\n    for i in range(N):\n        if A[i] in unique and unique[A[i]] >= start:\n            start = min(i, unique[A[i]] + 1)\n        longest[i] = i - start + 1\n        unique[A[i]] = i\n    max_longest = max(longest)\n    ans = N - 1\n    for i in range(N):\n        if longest[i] == max_longest:\n            left = i - max_longest + 1\n            right = N - i - 1\n            ans = min(ans, min(left, right) * 2 + max(left, right))\n    print(ans)", "from collections import deque\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = list(map(int, input().split()))\n    longest = [1] * N\n    unique = {}\n    start = 0\n    for i in range(N):\n        if A[i] in unique and unique[A[i]] >= start:\n            start = min(i, unique[A[i]] + 1)\n        longest[i] = i - start + 1\n        unique[A[i]] = i\n    max_longest = max(longest)\n    sub = []\n    for i in range(N):\n        if longest[i] == max_longest:\n            sub.append([i - max_longest + 1, i])\n    ans = N - 1\n    for i in sub:\n        left = i[0]\n        right = N - i[1] - 1\n        ans = min(ans, min(left, right) * 2 + max(left, right))\n    print(ans)", "import sys\nfrom itertools import count, islice\nfor s in islice(sys.stdin, 2, None, 2):\n    a = s.split()\n    n = len(a)\n    d = {}\n    r = 200000.0\n    j = 0\n    for (i, x) in zip(count(n - 1, -1), a):\n        j = max(j, d.get(x, 0))\n        d[x] = n - i\n        r = min(r, i + j + min(i, j))\n    print(r)", "import sys\nfrom itertools import count, islice\nfor s in islice(sys.stdin, 2, None, 2):\n    a = s.split()\n    n = len(a)\n    d = {}\n    r = 200000.0\n    j = 0\n    for (i, x) in zip(count(n - 1, -1), a):\n        j = max(j, d.get(x, 0))\n        d[x] = n - i\n        r = min(r, i + j + min(i, j))\n    print(r)", "import math\nfrom bisect import bisect_left, bisect_right\nimport heapq\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as ddc\nfrom collections import Counter\n\ndef intin():\n    return int(input())\n\ndef mapin():\n    return map(int, input().split())\n\ndef strin():\n    return input().split()\nINF = 10 ** 20\nmod = 1000000007\n\ndef exponentiation(bas, exp, mod=1000000007):\n    t = 1\n    while exp > 0:\n        if exp % 2 != 0:\n            t = t * bas % mod\n        bas = bas * bas % mod\n        exp //= 2\n    return t % mod\n\ndef MOD(p, q=1, mod=1000000007):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n\ndef process(arr, n):\n    ans = 1000000000.0\n    (left, right) = (0, n)\n    curr = 0\n    unique = ddc(int)\n    temp = 0\n    for ele in arr:\n        unique[ele] += 1\n        while unique[ele] > 1:\n            unique[arr[left]] -= 1\n            left += 1\n        right -= 1\n        ans = min(ans, 2 * min(left, right) + max(left, right))\n    return ans\n\ndef main():\n    for _ in range(int(input())):\n        n = intin()\n        arr = list(mapin())\n        print(process(arr, n))\nmain()", "import sys\nfrom itertools import islice\nfor s in islice(sys.stdin, 2, None, 2):\n    a = s.split()\n    n = len(a)\n    d = {}\n    r = 200000.0\n    k = 0\n    for (i, x) in enumerate(map(int, a), 1):\n        k = min(i - d.get(x, 0), k + 1)\n        d[x] = i\n        r = min(r, n - k + min(i - k, n - i))\n    print(r)", "import sys\nfrom itertools import islice\nfor s in islice(sys.stdin, 2, None, 2):\n    a = s.split()\n    n = len(a)\n    d = {}\n    r = 200000.0\n    k = 0\n    for (i, x) in enumerate(a, 1):\n        k = min(i - d.get(x, 0), k + 1)\n        d[x] = i\n        r = min(r, n - k + min(i - k, n - i))\n    print(r)", "import sys\nfrom itertools import islice\nfor s in islice(sys.stdin, 2, None, 2):\n    a = s.split()\n    n = len(a)\n    d = {}\n    r = 200000.0\n    k = 0\n    for (i, x) in enumerate(a, 1):\n        k = min(i - d.get(x, -1), k + 1)\n        d[x] = i\n        r = min(r, n - k + min(i - k, n - i))\n    print(r)", "import sys\nfrom itertools import islice\nfor s in islice(sys.stdin, 2, None, 2):\n    a = s.split()\n    n = len(a)\n    d = {}\n    r = 200000.0\n    k = 0\n    for (i, x) in enumerate(a):\n        k = min(i - d.get(x, -1), k + 1)\n        d[x] = i\n        r = min(r, n - k + min(i - k + 1, n - i - 1))\n    print(r)", "import sys\nfrom itertools import islice\nfor s in islice(sys.stdin, 2, None, 2):\n    a = s.split()\n    n = len(a)\n    k = 0\n    r = 200000.0\n    d = {}\n    for (i, x) in enumerate(a):\n        m = i - d.get(x, -1)\n        d[x] = i\n        if m <= k:\n            k = m\n        else:\n            k += 1\n        r = min(r, n - k + min(i - k + 1, n - i - 1))\n    print(r)", "def help(a):\n    map = dict()\n    n = len(a)\n    res = n\n    j = 0\n    for i in range(n):\n        r = n - i - 1\n        temp = 0\n        if a[i] in map:\n            temp = map[a[i]]\n        j = max(j, temp)\n        map[a[i]] = 1 + i\n        res = min(res, min(j, r) + j + r)\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    print(help(a))", "for i in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    l1 = []\n    s = {}\n    start = -1\n    mx = 0\n    l1 = []\n    for i in range(n):\n        if l[i] in s and s[l[i]] > start:\n            start = s[l[i]]\n            s[l[i]] = i\n            if i == n - 1:\n                l1.append([start + 1, i])\n        else:\n            l1.append([start + 1, i])\n            s[l[i]] = i\n    if l.count(l[0]) == n and n != 1:\n        print(n - 1)\n    elif l1:\n        l2 = []\n        for i in l1:\n            a = i[0]\n            b = n - i[1] - 1\n            if b > a:\n                (a, b) = (b, a)\n            l2.append(b * 2 + a)\n        print(min(l2))\n    else:\n        print(0)", "from collections import Counter\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    i = 0\n    j = n - 1\n    new = 0\n    res = Counter(arr)\n    if len(res) == 1:\n        print(len(arr) - 1)\n        continue\n    if res.most_common()[0][1] == 1:\n        print(0)\n        continue\n    i_ans = 0\n    j_ans = 0\n    flag1 = 0\n    flag2 = 0\n    while i < j:\n        if res[arr[i]] > 1:\n            res[arr[i]] -= 1\n            i_ans = i\n            flag1 = 1\n        if res[arr[j]] > 1:\n            res[arr[j]] -= 1\n            j_ans = j\n            flag2 = 1\n        i += 1\n        j -= 1\n    if flag1 and flag2:\n        x = i_ans - 0 + 1\n        y = n - j_ans\n    elif flag1:\n        x = i_ans - 0 + 1\n        y = 0\n    elif flag2:\n        x = 0\n        y = n - j_ans\n    ans1 = 2 * min(x, y) + max(x, y)\n    i = 0\n    res = Counter(arr)\n    ans2 = 0\n    i_ans = 0\n    flag = 0\n    while i < n:\n        if res[arr[i]] > 1:\n            res[arr[i]] -= 1\n            i_ans = i\n            flag = 1\n        i += 1\n    if flag:\n        ans2 = i_ans - 0 + 1\n        ans1 = min(ans1, ans2)\n    i = n - 1\n    res = Counter(arr)\n    j_ans = 0\n    flag = 0\n    while i > -1:\n        if res[arr[i]] > 1:\n            res[arr[i]] -= 1\n            j_ans = i\n            flag = 1\n        i -= 1\n    if flag:\n        ans3 = n - j_ans\n        ans1 = min(ans1, ans3)\n    print(ans1)", "for _ in range(int(input())):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    mp = {}\n    r = n - 1\n    res = n\n    j = 0\n    for i in range(n):\n        r = n - i - 1\n        if nums[i] in mp:\n            temp = mp[nums[i]]\n        else:\n            temp = 0\n        j = max(temp, j)\n        mp[nums[i]] = i + 1\n        res = min(res, min(j, r) + j + r)\n    print(res)", "for _ in range(int(input())):\n    N = int(input())\n    A = [int(i) for i in input().split()]\n    dict = {}\n    ans = 4 * N\n    front = 0\n    back = 0\n    while back < N:\n        if A[back] in dict:\n            for i in range(front, dict[A[back]]):\n                if A[i] in dict:\n                    del dict[A[i]]\n            ans = min(2 * min(front, N - back) + max(front, N - back), ans)\n            front = dict[A[back]] + 1\n            dict[A[back]] = back\n            back += 1\n        else:\n            dict[A[back]] = back\n            back += 1\n    ans = min(2 * min(front, N - back) + max(front, N - back), ans)\n    print(ans)", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(a % b, a)\n\ndef solve(arr, n):\n    a = {}\n    (temp, ans, j) = (n - 1, n, 0)\n    i = 0\n    while i < n:\n        temp = n - i - 1\n        if arr[i] in a:\n            j = max(a[arr[i]], j)\n        else:\n            j = max(0, j)\n        a[arr[i]] = 1 + i\n        ans = min(ans, min(j, temp) + j + temp)\n        i += 1\n    return ans\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        print(solve(arr, n))\nmain()", "def fun(i, j, n):\n    left = i\n    right = n - j - 1\n    if left == right:\n        return 3 * left\n    elif left > right:\n        return 2 * right + left\n    else:\n        return 2 * left + right\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    j = 0\n    ans = 1000000000\n    for i in range(len(a)):\n        if a[i] not in d.keys():\n            d[a[i]] = i\n        else:\n            d[a[i]] = i\n            while a[j] != a[i]:\n                del d[a[j]]\n                j += 1\n            j += 1\n        ans = min(fun(j, i, n), ans)\n    print(ans)", "from bisect import bisect_left\nfrom re import sub\nimport re\nfrom typing import DefaultDict\nimport math\nfrom collections import defaultdict\nfrom math import sqrt\nimport collections\nfrom sys import maxsize\nfrom itertools import combinations_with_replacement\nimport sys\nimport copy\n\ndef sieve_erasthones(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    for p in range(n + 1):\n        if prime[p]:\n            cnt += 1\n    return cnt\n\ndef calculate(p, q):\n    mod = 998244353\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n\ndef count_factors(n):\n    i = 1\n    c = 0\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n // i == i:\n                c += 1\n            else:\n                c += 2\n        i += 1\n    return c\n\ndef ncr_modulo(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef isprime(n):\n    prime_flag = 0\n    if n > 1:\n        for i in range(2, int(sqrt(n)) + 1):\n            if n % i == 0:\n                prime_flag = 1\n                break\n        if prime_flag == 0:\n            return True\n        else:\n            return False\n    else:\n        return True\n\ndef smallestDivisor(n):\n    if n % 2 == 0:\n        return 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return i\n        i += 2\n    return n\n\ndef dict_ele_count(l):\n    d = DefaultDict(lambda : 0)\n    for ele in l:\n        d[ele] += 1\n    return d\n\ndef max_in_dict(d):\n    maxi = 0\n    for ele in d:\n        if d[ele] > maxi:\n            maxi = d[ele]\n    return maxi\n\ndef element_count(s):\n    l = []\n    k = s[0]\n    c = 0\n    for ele in s:\n        if ele == k:\n            c += 1\n        else:\n            l.append([k, c])\n            k = ele\n            c = 1\n    l.append([k, c])\n    return l\n\ndef modular_exponentiation(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 != 0:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef number_of_primefactor(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return len(set(l))\n\ndef twosum(a, n, x):\n    rem = []\n    for i in range(x):\n        rem.append(0)\n    for i in range(n):\n        if a[i] < x:\n            rem[a[i] % x] += 1\n    for i in range(1, x // 2):\n        if rem[i] > 0 and rem[x - i] > 0:\n            return True\n    if i >= x // 2:\n        if x % 2 == 0:\n            if rem[x // 2] > 1:\n                return True\n            else:\n                return False\n        elif rem[x // 2] > 0 and rem[x - x // 2] > 0:\n            return True\n        else:\n            return False\n\ndef divSum(num):\n    result = 0\n    i = 2\n    while i <= math.sqrt(num):\n        if num % i == 0:\n            if i == num / i:\n                result = result + i\n            else:\n                result = result + (i + num / i)\n        i = i + 1\n    return result + 1 + num\n\ndef subsequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\n\ndef primeFactors(n):\n    d = defaultdict(lambda : 0)\n    while n % 2 == 0:\n        d[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[int(i)] += 1\n            n = n / i\n    if n > 2:\n        d[int(n)] += 1\n    return d\n\ndef calc(s):\n    ans = 0\n    for ele in s:\n        ans += ord(ele) - 96\n    return ans\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    return inv * a % m\n\ndef count(n):\n    ans = 0\n    while n:\n        ans += n % 10\n        n //= 10\n    return ans\n\ndef solve():\n    n = int(input())\n    l = list(map(int, input().split()))\n    i = 0\n    ans = 10 ** 5 * 2\n    c = 0\n    d = defaultdict(lambda : -1)\n    while i < n:\n        if d[l[i]] == -1:\n            d[l[i]] = i\n            i += 1\n        else:\n            k1 = min(c, n - i)\n            k2 = max(c, n - i)\n            ans = min(ans, 2 * k1 + k2)\n            i = d[l[i]] + 1\n            c = i\n            d = defaultdict(lambda : -1)\n    k1 = min(c, n - i)\n    k2 = max(c, n - i)\n    ans = min(ans, 2 * k1 + k2)\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "from collections import defaultdict\n\ndef largest_subarray(a, n):\n    index = defaultdict(lambda : 0)\n    res = 0\n    j = 0\n    l = n - 1\n    r = 0\n    ans = []\n    for i in range(n):\n        j = max(index[a[i]], j)\n        ans.append([i - j + 1, j, i])\n        index[a[i]] = i + 1\n        i += 1\n    return ans\nfor _ in range(int(input())):\n    l = 1000000\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = []\n    c = []\n    b = largest_subarray(a, n)\n    c = max(b)\n    for i in range(len(b)):\n        k = 0\n        if b[i][0] == c[0]:\n            k = 2 * min(b[i][1], n - 1 - b[i][2])\n            k += max(b[i][1], n - 1 - b[i][2])\n            l = min(l, k)\n    print(l)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    h = defaultdict(int)\n    c = n\n    j = 0\n    for i in range(n):\n        if a[i] in h:\n            t = h[a[i]]\n        else:\n            t = 0\n        j = max(t, j)\n        h[a[i]] = 1 + i\n        c = min(c, min(j, n - i - 1) + j + n - i - 1)\n    print(c)", "for _ in range(int(input())):\n    n = int(input())\n    l1 = list(map(int, input().split()))\n    b = n\n    j = 0\n    cout = dict()\n    for i in range(n):\n        a = n - i - 1\n        if l1[i] in cout:\n            temp = cout[l1[i]]\n        else:\n            temp = 0\n        j = max(j, temp)\n        cout[l1[i]] = 1 + i\n        b = min(b, min(j, a) + j + a)\n    print(b)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    ar = list(map(int, input().strip().split()))[:n]\n    dic = {}\n    r = n - 1\n    ans = n\n    j = 0\n    for i in range(n):\n        r = n - i - 1\n        if ar[i] in dic:\n            x = dic[ar[i]]\n        else:\n            x = 0\n        j = max(x, j)\n        dic[ar[i]] = 1 + i\n        ans = min(ans, min(j, r) + j + r)\n    print(ans)", "def solve(abbbbbdddahajsdasasadasdsadasdas, lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll):\n    asdassssssssssssssssssssssssssssssssssssssfsfas = {}\n    uattassaasdadasdsavsdfadasdasdasdsadasdasdasdsa = lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll - 1\n    uattasadasdasdasdsadasdasdasdsa = lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll\n    rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr = 0\n    for iterator_of_aslaaaadasdasdasdscsdc in range(lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll):\n        uattassaasdadasdsavsdfadasdasdasdsadasdasdasdsa = lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll - iterator_of_aslaaaadasdasdasdscsdc - 1\n        if abbbbbdddahajsdasasadasdsadasdas[iterator_of_aslaaaadasdasdasdscsdc] not in asdassssssssssssssssssssssssssssssssssssssfsfas:\n            uuuuuuuuuuuuuuuuumyjyjtyjtyyyyyyyyyyyyyyyyyyyyyyjht = 0\n        else:\n            uuuuuuuuuuuuuuuuumyjyjtyjtyyyyyyyyyyyyyyyyyyyyyyjht = asdassssssssssssssssssssssssssssssssssssssfsfas[abbbbbdddahajsdasasadasdsadasdas[iterator_of_aslaaaadasdasdasdscsdc]]\n        rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr = max(rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr, uuuuuuuuuuuuuuuuumyjyjtyjtyyyyyyyyyyyyyyyyyyyyyyjht)\n        asdassssssssssssssssssssssssssssssssssssssfsfas[abbbbbdddahajsdasasadasdsadasdas[iterator_of_aslaaaadasdasdasdscsdc]] = iterator_of_aslaaaadasdasdasdscsdc + 1\n        uattasadasdasdasdsadasdasdasdsa = min(uattasadasdasdasdsadasdasdasdsa, min(rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr, uattassaasdadasdsavsdfadasdasdasdsadasdasdasdsa) + rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr + uattassaasdadasdsavsdfadasdasdasdsadasdasdasdsa)\n    return uattasadasdasdasdsadasdasdasdsa\nfor _ in range(int(input())):\n    lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll = int(input())\n    abbbbbdddahajsdasasadasdsadasdas = list(map(int, input().split()))\n    print(solve(abbbbbdddahajsdasasadasdsadasdas, lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll))", "import sys\nimport math\nfrom collections import defaultdict, Counter, deque\nfrom bisect import *\nfrom string import ascii_lowercase\nfrom heapq import *\n\ndef readInts():\n    x = list(map(int, sys.stdin.readline().rstrip().split()))\n    return x[0] if len(x) == 1 else x\n\ndef readList(type=int):\n    x = sys.stdin.readline()\n    x = list(map(type, x.rstrip('\\n\\r').split()))\n    return x\n\ndef readStr():\n    x = sys.stdin.readline().rstrip('\\r\\n')\n    return x\nwrite = sys.stdout.write\nread = sys.stdin.readline\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef mergeSort(arr, check=lambda a, b: a < b, reverse=False):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        mergeSort(L, check, reverse)\n        mergeSort(R, check, reverse)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if check(L[i], R[j]):\n                if not reverse:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n            elif not reverse:\n                arr[k] = R[j]\n                j += 1\n            else:\n                arr[k] = L[i]\n                i += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\ndef maxSum(arr, k):\n    max_sum = 0\n    max_cur = 0\n    for (i, num) in enumerate(arr):\n        max_cur = max(max_cur + num, num)\n        if max_cur > max_sum:\n            max_sum = max_cur\n    return max_sum\n\ndef hcf(a, b):\n    if b == 0:\n        return a\n    else:\n        return hcf(b, b % a)\n\ndef get_power(n, m):\n    i = 1\n    p = -1\n    while i <= n:\n        i = i * m\n        p += 1\n    return p\n\ndef fact(n):\n    f = 1\n    for i in range(2, n + 1):\n        f *= i\n    return f\n\ndef find_closest(num, ar):\n    min_d = float('inf')\n    for num2 in ar:\n        d = abs(num2 - num)\n        if d < min_d:\n            min_d = d\n    return min_d\n\ndef check_pal(n):\n    s = str(n)\n    j = len(s) - 1\n    i = 0\n    while j > i:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef solve(t):\n    n = readInts()\n    ar = readList()\n    si = 0\n    ei = 0\n    si2 = 0\n    ei2 = 0\n    mxl = 0\n    seen = set()\n    curs = 0\n    cure = 0\n    tind = {}\n    for (i, num) in enumerate(ar):\n        if num in tind and tind[num] >= curs:\n            curl = cure - curs + 1\n            if curl > mxl:\n                mxl = curl\n                si = curs\n                ei = cure\n            if curl >= mxl:\n                mxl = curl\n                si2 = curs\n                ei2 = cure\n            curs = tind[num] + 1\n            tind[num] = i\n            cure = i\n        else:\n            cure = i\n            tind[num] = i\n            curl = cure - curs + 1\n            if curl > mxl:\n                mxl = curl\n                si = curs\n                ei = cure\n            if curl >= mxl:\n                mxl = curl\n                si2 = curs\n                ei2 = cure\n    res1 = 0\n    res1 += si\n    res1 += n - ei - 1\n    res1 += min(si, n - ei - 1)\n    res2 = 0\n    res2 += si2\n    res2 += n - ei2 - 1\n    res2 += min(si2, n - ei2 - 1)\n    print(min(res1, res2))\n\ndef main():\n    t = 1\n    sys.setrecursionlimit(1000)\n    t = readInts()\n    for i in range(t):\n        solve(i + 1)\nmain()", "from sys import stdin, stdout\nfrom collections import defaultdict, Counter, deque, OrderedDict\nimport math, heapq, bisect\ninput = stdin.readline\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    d = OrderedDict()\n    ans = pow(10, 10)\n    start = 0\n    end = 0\n    cnt = 0\n    for i in range(n):\n        d[a[i]] = d.get(a[i], 0) + 1\n        if d[a[i]] > 1:\n            sol1 = 2 * start + n - (end + 1)\n            sol2 = start + 2 * (n - (end + 1))\n            ans = min(ans, sol1)\n            ans = min(ans, sol2)\n            for key in d.copy():\n                del d[key]\n                cnt += 1\n                if key == a[i]:\n                    break\n            d[a[i]] = d.get(a[i], 0) + 1\n            start = cnt\n            end = i\n        else:\n            end = i\n    sol1 = 2 * start + n - (end + 1)\n    sol2 = start + 2 * (n - (end + 1))\n    ans = min(ans, sol1)\n    ans = min(ans, sol2)\n    print(ans)", "inf = 10 ** 6\nfor tcase in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    l = 0\n    ans = inf\n    for (i, x) in enumerate(a):\n        if x in d:\n            v = d[x]\n            while l <= v:\n                del d[a[l]]\n                l += 1\n        d[x] = i\n        r = n - 1 - i\n        nop = 2 * min(l, r) + max(l, r)\n        ans = min(ans, nop)\n    print(ans)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline()\nstdint = lambda : int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nmod = 1000000007\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    (d, ans, var) = ({}, n, 0)\n    for i in range(n):\n        if l[i] in d:\n            t = d[l[i]]\n        else:\n            t = 0\n        var = max(var, t)\n        d[l[i]] = 1 + i\n        q = min(var, n - i - 1) + var + n - i - 1\n        ans = min(ans, q)\n    print(ans)", "def func():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    dic = {}\n    i = j = 0\n    ans = n\n    while i < n:\n        r = n - 1 - i\n        present = dic.get(arr[i], 0)\n        j = max(j, present)\n        dic[arr[i]] = i + 1\n        ans = min(min(j, r) + j + r, ans)\n        i += 1\n    print(ans)\ntc = int(input())\nwhile tc > 0:\n    func()\n    tc -= 1", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    dic = {}\n    for i in range(n):\n        dic[arr[i]] = 0\n    l = 0\n    h = n - 1\n    ans = n\n    for i in range(n):\n        temp = 0\n        h = n - 1 - i\n        l = max(dic[arr[i]], l)\n        dic[arr[i]] = 1 + i\n        ans = min(ans, min(l, h) + l + h)\n    print(ans)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    start = maxLength = 0\n    dic = {}\n    leftptr = rightptr = 0\n    new = []\n    for (i, ch) in enumerate(arr):\n        if ch in dic and start <= dic[ch]:\n            start = dic[ch] + 1\n        elif i - start + 1 > maxLength:\n            maxLength = i - start + 1\n            leftptr = start\n            rightptr = i\n            new = [[leftptr, rightptr]]\n        elif i - start + 1 == maxLength:\n            new.append([start, i])\n        dic[ch] = i\n    ans = +math.inf\n    for (i, j) in new:\n        ans = min(ans, min(i, n - 1 - j) + i + n - 1 - j)\n    print(ans)", "t = int(input())\nwhile t:\n    a = int(input())\n    b = list(map(int, input().split(' ')))\n    (s, check, index) = (len(b) - 1, 0, a)\n    p = 0\n    local = {}\n    while p < a:\n        k = s - p\n        c = local[b[p]] if b[p] in local.keys() else 0\n        check = max(c, check)\n        local[b[p]] = p + 1\n        mk = k + check + min(k, check)\n        index = min(index, mk)\n        p += 1\n    print(index)\n    t -= 1", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nt = inp()\nfor _ in range(t):\n    n = inp()\n    l = li()\n    d = {}\n    j = 0\n    jt = n - 1\n    r = n\n    for i in range(n):\n        jt = n - i - 1\n        if l[i] in d:\n            t = d[l[i]]\n        else:\n            t = 0\n        j = max(t, j)\n        d[l[i]] = i + 1\n        r = min(r, min(j, jt) + j + jt)\n    print(r)", "import sys\nfrom math import inf\ninput = lambda : sys.stdin.readline()\n\ndef finder(L):\n    const = float('inf')\n    dic = {}\n    c = 0\n    i = 0\n    j = 0\n    n = len(L)\n    ans = 0\n    (ai, aj) = (0, 0)\n    while j < n:\n        if L[j] not in dic.keys():\n            dic[L[j]] = 1\n            c += 1\n        else:\n            dic[L[j]] += 1\n            c -= 1\n        if c == j - i + 1:\n            if c >= ans:\n                if j != n - 1:\n                    x = i + n - j - 1\n                else:\n                    x = 0\n                if i != 0:\n                    y = i + n - j - 1\n                else:\n                    y = 0\n                const = min(const, min(i + x, n - j - 1 + y))\n                ans = c\n            j += 1\n        else:\n            while i <= j and c < j - i + 1:\n                if L[i] in dic.keys():\n                    dic[L[i]] -= 1\n                    if dic[L[i]] == 0:\n                        c -= 1\n                        dic.pop(L[i])\n                    elif dic[L[i]] == 1:\n                        c += 1\n                i += 1\n            if c == j - i + 1:\n                if c >= ans:\n                    if j != n - 1:\n                        x = i + n - j - 1\n                    else:\n                        x = 0\n                    if i != 0:\n                        y = i + n - j - 1\n                    else:\n                        y = 0\n                    const = min(const, min(i + x, n - j - 1 + y))\n                    ans = c\n            j += 1\n    return const\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(set(a)) == n:\n        print(0)\n    else:\n        print(finder(a))"]