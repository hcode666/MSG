["ri = lambda : int(input())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nfrom heapq import heappush, heappop\n\ndef solve():\n    (n, m) = rl()\n    z = []\n    for i in range(n + 1):\n        z.append([])\n    visited = [0] * (n + 1)\n    for _ in range(m):\n        (x, y) = rl()\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, n + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, n + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (n + 1)\n    heap = []\n    for i in range(n, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]\n\ndef main():\n    for _ in range(ri()):\n        print(*solve())\nmain()", "ri = lambda : int(input())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nfrom heapq import heappush, heappop\n\ndef solve():\n    (n, m) = rl()\n    z = []\n    for i in range(n + 1):\n        z.append([])\n    visited = [0] * (n + 1)\n    for _ in range(m):\n        (x, y) = rl()\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, n + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, n + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (n + 1)\n    heap = []\n    for i in range(n, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]\n\ndef main():\n    for _ in range(ri()):\n        print(*solve())\nmain()", "import heapq\nfor _ in range(int(input())):\n    (n, n_quer) = list(map(int, input().split()))\n    quer = [n] * (n + 1)\n    for _ in range(n_quer):\n        (x, y) = list(map(int, input().split()))\n        quer[x] = y\n    ind = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        ind[quer[i]].append(i)\n    pq = []\n    res = [1] * (n + 1)\n    flag = False\n    for i in range(n, 0, -1):\n        for val in ind[i]:\n            heapq.heappush(pq, -val)\n        if not pq:\n            print(-1)\n            flag = True\n            break\n        res[i] = -heapq.heappop(pq)\n    if not flag:\n        print(*res[1:])", "import heapq\nfor _ in range(int(input())):\n    (n, n_quer) = list(map(int, input().split()))\n    quer = [n] * (n + 1)\n    for _ in range(n_quer):\n        (x, y) = list(map(int, input().split()))\n        quer[x] = y\n    ind = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        ind[quer[i]].append(i)\n    pq = []\n    res = [1] * (n + 1)\n    flag = False\n    for i in range(n, 0, -1):\n        for val in ind[i]:\n            heapq.heappush(pq, -val)\n        if not pq:\n            print(-1)\n            flag = True\n            break\n        res[i] = -heapq.heappop(pq)\n    if not flag:\n        print(*res[1:])", "import heapq\nt = int(input())\nwhile t > 0:\n    (n, m) = [int(x) for x in input().split()]\n    last = [n for i in range(n + 1)]\n    for i in range(m):\n        (x, y) = [int(x) for x in input().split()]\n        last[x] = y\n    v = [[] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        v[last[i]].append(i)\n    ans = [None for i in range(n + 1)]\n    q = list()\n    for i in range(n, 0, -1):\n        for ele in v[i]:\n            heapq.heappush(q, -ele)\n        if len(q) == 0:\n            ans[0] = -1\n            break\n        ans[i] = -heapq.heappop(q)\n    if ans[0] is not None:\n        print(-1)\n    else:\n        print(*ans[1:])\n    t -= 1", "import heapq\nt = int(input())\nwhile t > 0:\n    (n, m) = [int(x) for x in input().split()]\n    last = [n for i in range(n + 1)]\n    for i in range(m):\n        (x, y) = [int(x) for x in input().split()]\n        last[x] = y\n    v = [[] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        v[last[i]].append(i)\n    ans = [None for i in range(n + 1)]\n    q = list()\n    for i in range(n, 0, -1):\n        for ele in v[i]:\n            heapq.heappush(q, -ele)\n        if len(q) == 0:\n            ans[0] = -1\n            break\n        ans[i] = -heapq.heappop(q)\n    if ans[0] is not None:\n        print(-1)\n    else:\n        print(*ans[1:])\n    t -= 1", "import heapq\nt = int(input())\nwhile t > 0:\n    (n, m) = [int(x) for x in input().split()]\n    last = [n for i in range(n + 1)]\n    for i in range(m):\n        (x, y) = [int(x) for x in input().split()]\n        last[x] = y\n    v = [[] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        v[last[i]].append(i)\n    ans = [None for i in range(n + 1)]\n    q = list()\n    for i in range(n, 0, -1):\n        for ele in v[i]:\n            heapq.heappush(q, -ele)\n        if len(q) == 0:\n            ans[0] = -1\n            break\n        ans[i] = -heapq.heappop(q)\n    if ans[0] is not None:\n        print(-1)\n    else:\n        print(*ans[1:])\n    t -= 1", "import heapq\nt = int(input())\nwhile t > 0:\n    (n, m) = [int(x) for x in input().split()]\n    last = [n for i in range(n + 1)]\n    for i in range(m):\n        (x, y) = [int(x) for x in input().split()]\n        last[x] = y\n    v = [[] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        v[last[i]].append(i)\n    ans = [None for i in range(n + 1)]\n    q = list()\n    for i in range(n, 0, -1):\n        for ele in v[i]:\n            heapq.heappush(q, -ele)\n        if len(q) == 0:\n            ans[0] = -1\n            break\n        ans[i] = -heapq.heappop(q)\n    if ans[0] is not None:\n        print(-1)\n    else:\n        print(*ans[1:])\n    t -= 1", "import heapq\nt = int(input())\nwhile t > 0:\n    (n, m) = [int(x) for x in input().split()]\n    last = [n for i in range(n + 1)]\n    for i in range(m):\n        (x, y) = [int(x) for x in input().split()]\n        last[x] = y\n    v = [[] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        v[last[i]].append(i)\n    ans = [None for i in range(n + 1)]\n    q = list()\n    for i in range(n, 0, -1):\n        for ele in v[i]:\n            heapq.heappush(q, -ele)\n        if len(q) == 0:\n            ans[0] = -1\n            break\n        ans[i] = -heapq.heappop(q)\n    if ans[0] is not None:\n        print(-1)\n    else:\n        print(*ans[1:])\n    t -= 1", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    max_idx = [[] for _1 in range(n)]\n    used = [False] * n\n    fail = False\n    for _1 in range(m):\n        (x, y) = list(map(int, input().split()))\n        max_idx[y - 1].append(x)\n        used[x - 1] = True\n    for i in range(n):\n        if used[i] == False:\n            max_idx[-1].append(i + 1)\n    pq = []\n    ans = []\n    for i in range(n - 1, -1, -1):\n        for x in max_idx[i]:\n            heapq.heappush(pq, -x)\n        if len(pq) == 0:\n            fail = True\n            break\n        ans.append(-heapq.heappop(pq))\n    if fail:\n        print(-1)\n        continue\n    ans = reversed(ans)\n    print(*ans)", "strng = lambda : input().split()[0]\ninp = lambda : int(input())\nmul = lambda : map(int, input().split())\njn = lambda x, l: x.join(map(str, l))\nslst = lambda : list(input().split())\nsilst = lambda : list(map(int, input().split()))\nlst = lambda : list(map(int, input().split()))\ndd = lambda : defaultdict(lambda : 0)\nimport sys\ninput = sys.stdin.readline\nfrom heapq import heapify, nsmallest, nlargest, heappush, heappop\nfrom collections import defaultdict, deque\nfrom math import ceil, log, floor, sqrt, gcd, log10\nfor _ in range(inp()):\n    (n, m) = mul()\n    d = defaultdict(lambda : [])\n    vis = [False] * (n + 1)\n    for i in range(m):\n        (val, pos) = mul()\n        d[pos] += [val]\n        vis[val] = True\n    for i in range(1, n + 1):\n        if vis[i] == False:\n            d[n] += [i]\n    a = []\n    ans = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        for val in d[i]:\n            heappush(a, -val)\n        if a:\n            ans[i] = -heappop(a)\n        else:\n            break\n    else:\n        print(*ans[1:])\n        continue\n    print(-1)", "from sys import stdin\ninput = stdin.readline\n\nclass Node:\n\n    def __init__(self, val=-1):\n        self.val = val\n\nclass maxheap:\n\n    def __init__(self):\n        self.a = []\n\n    def getsize(self):\n        return len(self.a)\n\n    def insert(self, node):\n        self.a.append(node)\n        ci = len(self.a) - 1\n        pi = (ci - 1) // 2\n        while pi >= 0:\n            if self.a[pi].val < self.a[ci].val:\n                (self.a[pi], self.a[ci]) = (self.a[ci], self.a[pi])\n            else:\n                break\n            ci = pi\n            pi = (ci - 1) // 2\n\n    def remove(self):\n        if len(self.a) == 0:\n            return 'Empty'\n        (self.a[0], self.a[-1]) = (self.a[-1], self.a[0])\n        ele = self.a.pop()\n        te = len(self.a)\n        pi = 0\n        while 1:\n            if 2 * pi + 2 < te:\n                if self.a[2 * pi + 1].val >= self.a[2 * pi + 2].val:\n                    if self.a[pi].val >= self.a[2 * pi + 1].val:\n                        break\n                    else:\n                        (self.a[pi], self.a[2 * pi + 1]) = (self.a[2 * pi + 1], self.a[pi])\n                        pi = 2 * pi + 1\n                elif self.a[pi].val >= self.a[2 * pi + 2].val:\n                    break\n                else:\n                    (self.a[pi], self.a[2 * pi + 2]) = (self.a[2 * pi + 2], self.a[pi])\n                    pi = 2 * pi + 2\n            elif 2 * pi + 1 < te:\n                if self.a[pi].val >= self.a[2 * pi + 1].val:\n                    break\n                else:\n                    (self.a[pi], self.a[2 * pi + 1]) = (self.a[2 * pi + 1], self.a[pi])\n                    pi = 2 * pi + 1\n            else:\n                break\n        return ele\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    d = {}\n    e = {}\n    b = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        a.append([x, y])\n        e[x] = True\n        if y not in d:\n            d[y] = [x]\n        else:\n            d[y].append(x)\n        b.append(y)\n    b.sort()\n    check = 1\n    for i in range(m):\n        if b[i] < i + 1:\n            check = 0\n            break\n    if check:\n        left = []\n        for i in range(n):\n            if e.get(i + 1) is None:\n                left.append(i + 1)\n        mxh = maxheap()\n        for num in left:\n            mxh.insert(Node(num))\n        ans = []\n        for i in range(n, 0, -1):\n            if d.get(i) is not None:\n                for num in d[i]:\n                    mxh.insert(Node(num))\n            ans.append(mxh.remove().val)\n        ans.reverse()\n        print(*ans)\n    else:\n        print(-1)", "import heapq\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    nums = [1 for i in range(n + 1)]\n    a = [[] for i in range(n + 1)]\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        nums[x] = 0\n        a[y].append(x)\n    for i in range(1, n + 1):\n        if nums[i]:\n            a[n].append(i)\n    q = []\n    ans = []\n    f = 1\n    for i in range(n, 0, -1):\n        for j in a[i]:\n            heapq.heappush(q, -1 * j)\n        if len(q) == 0:\n            print(-1)\n            f = 0\n            break\n        ans.append(-1 * heapq.heappop(q))\n    if f:\n        print(*ans[::-1])", "ri = lambda : int(input())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nfrom heapq import heappush, heappop\n\ndef solve():\n    (n, m) = rl()\n    z = []\n    for i in range(n + 1):\n        z.append([])\n    visited = [0] * (n + 1)\n    for _ in range(m):\n        (x, y) = rl()\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, n + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, n + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (n + 1)\n    heap = []\n    for i in range(n, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]\n\ndef main():\n    for _ in range(ri()):\n        print(*solve())\nmain()", "ri = lambda : int(input())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nfrom heapq import heappush, heappop\n\ndef solve():\n    (n, m) = rl()\n    z = []\n    for i in range(n + 1):\n        z.append([])\n    visited = [0] * (n + 1)\n    for _ in range(m):\n        (x, y) = rl()\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, n + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, n + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (n + 1)\n    heap = []\n    for i in range(n, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]\n\ndef main():\n    for _ in range(ri()):\n        print(*solve())\nmain()", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    heap = []\n    heapq.heapify(heap)\n    check = {}\n    arr = [0] * (n + 1)\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        if y not in check:\n            check[y] = [x]\n        else:\n            check[y] += [x]\n        arr[x] = 1\n    for i in range(1, len(arr)):\n        if not arr[i]:\n            heapq.heappush(heap, -i)\n    flag = 0\n    res = [0] * n\n    for i in range(n, 0, -1):\n        if i in check:\n            for j in check[i]:\n                heapq.heappush(heap, -j)\n        if not heap:\n            flag = 1\n            break\n        res[i - 1] = -heapq.heappop(heap)\n    if flag:\n        print(-1)\n    else:\n        print(*res)", "from heapq import heappush, heappop, heapify\nfrom sys import stdin\ninput = stdin.readline\n\ndef solve(N, M, conditions):\n    V = [[] for i in range(N + 1)]\n    used = set(range(1, N + 1))\n    for (X, Y) in conditions:\n        V[Y].append(X)\n        used.remove(X)\n    V[N] += list(used)\n    possible = []\n    permutation = [None] * (N + 1)\n    for i in reversed(range(1, N + 1)):\n        for p in V[i]:\n            heappush(possible, -p)\n        if not possible:\n            return [-1]\n        permutation[i] = -heappop(possible)\n    return permutation[1:]\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    (N, M) = [int(x) for x in input().strip().split()]\n    conditions = []\n    for i in range(M):\n        (Xi, Yi) = [int(x) for x in input().strip().split()]\n        conditions.append((Xi, Yi))\n    print(*solve(N, M, conditions))", "from heapq import heappush, heappop\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    bag = dict()\n    numset = set()\n    for i in range(m):\n        (num, p) = map(int, input().split())\n        if p in bag:\n            bag[p].append(num)\n        else:\n            bag[p] = [num]\n        numset.add(num)\n    bottle = []\n    for i in range(1, n + 1):\n        if not i in numset:\n            heappush(bottle, -i)\n    ans = [0] * n\n    status = True\n    while n > 0:\n        if n in bag:\n            for num in bag[n]:\n                heappush(bottle, -num)\n        if len(bottle) == 0:\n            status = False\n            break\n        ans[n - 1] = str(-heappop(bottle))\n        n -= 1\n    if status:\n        print(' '.join(ans))\n    else:\n        print(-1)", "import heapq as heap\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = [set() for i in range(n + 1)]\n    (ps, ts) = (set(range(1, n + 1)), set())\n    for i in range(m):\n        (k1, k2) = map(int, input().split())\n        arr[k2].add(k1)\n        ts.add(k1)\n    rms = ps.difference(ts)\n    arr[-1] = arr[-1].union(rms)\n    hp = []\n    flag = True\n    ans = [0 for i in range(n)]\n    for i in range(n, 0, -1):\n        while arr[i]:\n            heap.heappush(hp, -arr[i].pop())\n        if hp:\n            ans[i - 1] = -heap.heappop(hp)\n        else:\n            print(-1)\n            flag = False\n            break\n    if flag:\n        for x in ans:\n            print(x, end=' ')\n        print('\\r')", "import heapq\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\n\ndef yn(ans):\n    if ans:\n        print('YES')\n    else:\n        print('NO')\nfor T in range(int(input())):\n    (n, m) = mi()\n    a = []\n    for i in range(n):\n        a.append([])\n    curr = set(range(1, n + 1))\n    for i in range(m):\n        (x, y) = mi()\n        if x in curr:\n            curr.remove(x)\n        a[y - 1].append(x)\n    ans = [-1] * n\n    curr = list(curr)\n    for i in range(len(curr)):\n        curr[i] = -curr[i]\n    heapq.heapify(curr)\n    flag = True\n    for i in range(n, 0, -1):\n        for j in a[i - 1]:\n            heapq.heappush(curr, -j)\n        if len(curr) == 0:\n            flag = False\n            break\n        else:\n            ans[i - 1] = -int(heapq.heappop(curr))\n    if not flag:\n        print(-1)\n    else:\n        print(*ans)", "import heapq\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    nums = [[] for _ in range(n)]\n    vis = [0] * n\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        nums[y - 1].append(x - 1)\n        vis[x - 1] = 1\n    for i in range(n):\n        if not vis[i]:\n            nums[-1].append(i)\n    heap = []\n    ans = [0] * n\n    for i in range(n - 1, -1, -1):\n        for j in nums[i]:\n            heapq.heappush(heap, -(j + 1))\n        if not heap:\n            ans = [-1]\n            break\n        ans[i] = -heapq.heappop(heap)\n    print(*ans)", "import heapq\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    dic = defaultdict(lambda : [])\n    heap = []\n    flag = [0] * n\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        dic[y - 1].append(x)\n        flag[x - 1] = 1\n    for i in range(n):\n        if flag[i] == 0:\n            heap.append(-(i + 1))\n    heapq.heapify(heap)\n    flag = 0\n    ans = [0] * n\n    for i in range(n - 1, -1, -1):\n        for value in dic[i]:\n            heapq.heappush(heap, -1 * value)\n        if heap:\n            ans[i] = heapq.heappop(heap)\n        else:\n            flag = 1\n            break\n    if flag:\n        print(-1)\n    else:\n        for i in ans:\n            print(-1 * i, end=' ')\n        print()", "import heapq\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    dic = defaultdict(lambda : [])\n    heap = []\n    flag = [0] * n\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        dic[y - 1].append(x)\n        flag[x - 1] = 1\n    for i in range(n):\n        if flag[i] == 0:\n            heap.append(-i - 1)\n    heapq.heapify(heap)\n    flag = 0\n    ans = [0] * n\n    for i in range(n - 1, -1, -1):\n        for value in dic[i]:\n            heapq.heappush(heap, -1 * value)\n        if heap:\n            ans[i] = heapq.heappop(heap)\n        else:\n            flag = 1\n            break\n    if flag:\n        print(-1)\n    else:\n        for i in ans:\n            print(-1 * i, end=' ')\n        print()", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    heap = []\n    heapq.heapify(heap)\n    check = {}\n    arr = [0] * (n + 1)\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        if y not in check:\n            check[y] = [x]\n        else:\n            check[y] += [x]\n        arr[x] = 1\n    for i in range(1, len(arr)):\n        if not arr[i]:\n            heapq.heappush(heap, -i)\n    flag = 0\n    res = [0] * n\n    for i in range(n, 0, -1):\n        if i in check:\n            for j in check[i]:\n                heapq.heappush(heap, -j)\n        if not heap:\n            flag = 1\n            break\n        res[i - 1] = -heapq.heappop(heap)\n    if flag:\n        print(-1)\n    else:\n        print(*res)", "strng = lambda : input().split()[0]\ninp = lambda : int(input())\nmul = lambda : map(int, input().split())\njn = lambda x, l: x.join(map(str, l))\nslst = lambda : list(input().split())\nsilst = lambda : list(map(int, input().split()))\nlst = lambda : list(map(int, input().split()))\ndd = lambda : defaultdict(lambda : 0)\nimport sys\ninput = sys.stdin.readline\nfrom heapq import heapify, nsmallest, nlargest, heappush, heappop\nfrom collections import defaultdict, deque\nfrom math import ceil, log, floor, sqrt, gcd, log10\nfor _ in range(inp()):\n    (n, m) = mul()\n    d = defaultdict(lambda : [])\n    vis = [False] * (n + 1)\n    for i in range(m):\n        (val, pos) = mul()\n        d[pos] += [val]\n        vis[val] = True\n    for i in range(1, n + 1):\n        if vis[i] == False:\n            d[n] += [i]\n    a = []\n    ans = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        for val in d[i]:\n            heappush(a, -val)\n        if a:\n            ans[i] = -heappop(a)\n        else:\n            break\n    else:\n        print(*ans[1:])\n        continue\n    print(-1)", "from collections import defaultdict\nimport heapq\n\ndef solve():\n    (n, m) = map(int, input().split())\n    hs = defaultdict(int)\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        hs[a] = max(hs[a], b)\n    qu = sorted(list(hs.items()), key=lambda x: (x[1], x[0]))\n    ans = [-1 for _ in range(n + 1)]\n    hp = []\n    heapq.heapify(hp)\n    (rt, rtx) = (n, n)\n    while rt > 0:\n        if rt < len(qu):\n            print(-1)\n            return\n        while rtx in hs:\n            rtx -= 1\n        while qu and qu[-1][1] == rt:\n            heapq.heappush(hp, -qu.pop()[0])\n        if not hp:\n            ans[rt] = rtx\n            rtx -= 1\n        elif rt == len(qu) + 1:\n            ans[rt] = -heapq.heappop(hp)\n        elif -hp[0] > rtx:\n            ans[rt] = -heapq.heappop(hp)\n        else:\n            ans[rt] = rtx\n            rtx -= 1\n        rt -= 1\n    print(' '.join(map(str, ans[1:])))\nt = int(input())\nfor _ in range(t):\n    solve()", "def gcd(a, b):\n    (a, b) = (max(a, b), min(a, b))\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nimport sys\nfrom heapq import heappush, heappop\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\nt = int(input())\nfor _ in range(t):\n    (n, m) = get_ints()\n    arr = [[] for i in range(n)]\n    seen = set()\n    for i in range(m):\n        (a, b) = get_ints()\n        seen.add(a)\n        arr[b - 1].append(a)\n    for i in range(n):\n        if i + 1 not in seen:\n            arr[n - 1].append(i + 1)\n\n    def solve():\n        pq = []\n        res = [None for i in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(len(arr[i])):\n                heappush(pq, -arr[i][j])\n            if not pq:\n                return [-1]\n            num = -heappop(pq)\n            res[i] = num\n        return res\n    print(*solve())", "import heapq, collections\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    h = []\n    a = {}\n    ok = True\n    d = collections.defaultdict(list)\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        d[y].append(x)\n        a[x] = 1\n    for i in range(1, n + 1):\n        if i not in a:\n            d[n].append(i)\n    ans = [0] * n\n    for i in range(n, 0, -1):\n        for j in d[i]:\n            heapq.heappush(h, -j)\n        if h:\n            ans[i - 1] = -heapq.heappop(h)\n        else:\n            ok = False\n    if ok:\n        print(*ans)\n    else:\n        print(-1)", "import heapq\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    last = [n for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        last[u] = v\n    arr = [[] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        arr[last[i]].append(i)\n    hp = []\n    ans = [0 for i in range(n + 1)]\n    heapq.heapify(hp)\n    fl = 0\n    for i in range(n, 0, -1):\n        for j in arr[i]:\n            heapq.heappush(hp, -j)\n        if hp:\n            ans[i] = -heapq.heappop(hp)\n        else:\n            fl = 1\n            break\n    if fl == 1:\n        print(-1)\n    else:\n        print(*ans[1:])", "import heapq\nt = int(input())\nwhile t:\n    (p, q) = map(int, input().split())\n    z = []\n    po = {}\n    for i in range(q):\n        (c, d) = map(int, input().split())\n        z.append((c, d))\n        po[c] = True\n    z.sort(key=lambda x: x[1])\n    l = [-i for i in range(p, 0, -1) if i not in po]\n    heapq.heapify(l)\n    check = []\n    for k in range(p, 0, -1):\n        while len(z) > 0 and z[-1][1] == k:\n            u = z.pop()\n            heapq.heappush(l, -u[0])\n        if len(l) == 0:\n            print(-1)\n            break\n        check.append(-heapq.heappop(l))\n    else:\n        print(*check[::-1])\n    t -= 1", "import random\nimport math\nfrom collections import defaultdict, Counter\nfrom functools import lru_cache\nimport bisect\nimport heapq\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = list(range(n))\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            self.parents[x] = y\ndire = [0, 1, 0, -1, 0]\n\ndef is_prime(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef google(t):\n    print('Case #{}:'.format(t), end=' ')\nRANDOM = random.randrange(2 ** 62)\n\ndef Wrapper(x):\n    return x ^ RANDOM\n\ndef solve():\n    (n, m) = map(int, input().split())\n    cond = []\n    condn = {}\n    for i in range(m):\n        (a, b) = map(int, input().split())\n        cond.append((a, b))\n        condn[a] = True\n    cond.sort(key=lambda x: x[1])\n    canadd = [-i for i in range(n, 0, -1) if i not in condn]\n    heapq.heapify(canadd)\n    ans = []\n    for i in range(n, 0, -1):\n        while len(cond) > 0 and cond[-1][1] == i:\n            p = cond.pop()\n            heapq.heappush(canadd, -p[0])\n        if len(canadd) == 0:\n            print(-1)\n            break\n        ans.append(-heapq.heappop(canadd))\n    else:\n        print(*ans[::-1])\nfor t in range(int(input())):\n    solve()", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    dit = {x: [] for x in range(1, n + 1)}\n    s = set([x for x in range(1, n + 1)])\n    for i in range(m):\n        (a, b) = map(int, input().split())\n        dit[b].append(a)\n        s.remove(a)\n    c = 0\n    f = True\n    for i in range(1, n + 1):\n        c += len(dit[i])\n        if c > i:\n            f = False\n            break\n    if not f:\n        print(-1)\n        continue\n    hp = []\n    for e in s:\n        heappush(hp, -e)\n    ans = [0] * n\n    for i in range(n, 0, -1):\n        for e in dit[i]:\n            heappush(hp, -e)\n        top = -heappop(hp)\n        ans[i - 1] = top\n    print(*ans)"]