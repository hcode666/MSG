["for z in range(int(input())):\n    (n, k) = map(int, input().split())\n    A = []\n    for i in range(n):\n        A += list(map(int, input().split()))\n    A.sort()\n    leftcount = int(n / 2)\n    rightcount = n - leftcount - 1\n    righttotal = rightcount * n\n    rmax = n * n - righttotal - 1\n    ans = -1\n    start = leftcount\n    end = n * n - righttotal - (n - 1) - 1\n    while start <= end:\n        mid = start + int((end - start) / 2)\n        x = 0\n        y = mid\n        vis = []\n        for i in range(n * n):\n            vis.append(0)\n        tot = 0\n        cnt = 0\n        sums = 0\n        while tot != n:\n            if cnt == leftcount:\n                if vis[y] == 0:\n                    sums += A[y]\n                    vis[y] = 1\n                    y += 1\n                    tot += 1\n                    cnt = 0\n                else:\n                    y += 1\n            elif vis[x] == 0:\n                vis[x] = 1\n                x += 1\n                cnt += 1\n            else:\n                x += 1\n        if sums <= k:\n            ans = mid\n            start = mid + 1\n        else:\n            end = mid - 1\n    if ans == -1:\n        print(-1)\n    else:\n        print(A[ans])", "for z in range(int(input())):\n    (n, k) = map(int, input().split())\n    A = []\n    for i in range(n):\n        A += list(map(int, input().split()))\n    A.sort()\n    leftcount = int(n / 2)\n    rightcount = n - leftcount - 1\n    righttotal = rightcount * n\n    rmax = n * n - righttotal - 1\n    ans = -1\n    start = leftcount\n    end = n * n - righttotal - (n - 1) - 1\n    while start <= end:\n        mid = start + int((end - start) / 2)\n        x = 0\n        y = mid\n        vis = []\n        for i in range(n * n):\n            vis.append(0)\n        tot = 0\n        cnt = 0\n        sums = 0\n        while tot != n:\n            if cnt == leftcount:\n                if vis[y] == 0:\n                    sums += A[y]\n                    vis[y] = 1\n                    y += 1\n                    tot += 1\n                    cnt = 0\n                else:\n                    y += 1\n            elif vis[x] == 0:\n                vis[x] = 1\n                x += 1\n                cnt += 1\n            else:\n                x += 1\n        if sums <= k:\n            ans = mid\n            start = mid + 1\n        else:\n            end = mid - 1\n    if ans == -1:\n        print(-1)\n    else:\n        print(A[ans])", "for z in range(int(input())):\n    (n, k) = map(int, input().split())\n    A = []\n    for i in range(n):\n        A += list(map(int, input().split()))\n    A.sort()\n    leftcount = int(n / 2)\n    rightcount = n - leftcount - 1\n    righttotal = rightcount * n\n    rmax = n * n - righttotal - 1\n    ans = -1\n    start = leftcount\n    end = n * n - righttotal - (n - 1) - 1\n    while start <= end:\n        mid = start + int((end - start) / 2)\n        x = 0\n        y = mid\n        vis = []\n        for i in range(n * n):\n            vis.append(0)\n        tot = 0\n        cnt = 0\n        sums = 0\n        while tot != n:\n            if cnt == leftcount:\n                if vis[y] == 0:\n                    sums += A[y]\n                    vis[y] = 1\n                    y += 1\n                    tot += 1\n                    cnt = 0\n                else:\n                    y += 1\n            elif vis[x] == 0:\n                vis[x] = 1\n                x += 1\n                cnt += 1\n            else:\n                x += 1\n        if sums <= k:\n            ans = mid\n            start = mid + 1\n        else:\n            end = mid - 1\n    if ans == -1:\n        print(-1)\n    else:\n        print(A[ans])", "for z in range(int(input())):\n    (n, k) = map(int, input().split())\n    A = []\n    for i in range(n):\n        A += list(map(int, input().split()))\n    A.sort()\n    leftcount = int(n / 2)\n    rightcount = n - leftcount - 1\n    righttotal = rightcount * n\n    rmax = n * n - righttotal - 1\n    ans = -1\n    start = leftcount\n    end = n * n - righttotal - (n - 1) - 1\n    while start <= end:\n        mid = start + int((end - start) / 2)\n        x = 0\n        y = mid\n        vis = []\n        for i in range(n * n):\n            vis.append(0)\n        tot = 0\n        cnt = 0\n        sums = 0\n        while tot != n:\n            if cnt == leftcount:\n                if vis[y] == 0:\n                    sums += A[y]\n                    vis[y] = 1\n                    y += 1\n                    tot += 1\n                    cnt = 0\n                else:\n                    y += 1\n            elif vis[x] == 0:\n                vis[x] = 1\n                x += 1\n                cnt += 1\n            else:\n                x += 1\n        if sums <= k:\n            ans = mid\n            start = mid + 1\n        else:\n            end = mid - 1\n    if ans == -1:\n        print(-1)\n    else:\n        print(A[ans])", "t = int(input())\nfor _ in range(t):\n    args = [int(x) for x in input().split()]\n    (n, k) = (args[0], args[1])\n    nums = []\n    for __ in range(n):\n        nums.extend([int(x) for x in input().split()])\n    nums.sort()\n    min_goodness = 0\n    for i in range(n):\n        min_goodness += nums[(i + 1) * (n // 2)]\n    if min_goodness > k:\n        print(-1)\n        continue\n    (lo, hi) = (n // 2, n * n - 1)\n    goodness = -1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        taken = 0\n        rlim = n * n\n        less = mid\n        i = mid\n        cost = 0\n        while taken <= n and i < rlim:\n            if less >= n // 2:\n                cost += nums[i]\n                less -= n // 2\n                rlim -= n - n // 2 - 1\n                if rlim <= i:\n                    break\n                taken += 1\n            else:\n                less += 1\n            i += 1\n        if taken == n and cost <= k:\n            lo = mid + 1\n            goodness = nums[mid]\n        else:\n            hi = mid - 1\n    print(goodness)", "t = int(input())\nfor _ in range(t):\n    args = [int(x) for x in input().split()]\n    (n, k) = (args[0], args[1])\n    nums = []\n    for __ in range(n):\n        nums.extend([int(x) for x in input().split()])\n    nums.sort()\n    min_goodness = 0\n    for i in range(n):\n        min_goodness += nums[(i + 1) * (n // 2)]\n    if min_goodness > k:\n        print(-1)\n        continue\n    (lo, hi) = (n // 2, n * n - 1)\n    goodness = -1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        taken = 0\n        rlim = n * n\n        less = mid\n        i = mid\n        cost = 0\n        while taken <= n and i < rlim:\n            if less >= n // 2:\n                cost += nums[i]\n                less -= n // 2\n                rlim -= n - n // 2 - 1\n                if rlim <= i:\n                    break\n                taken += 1\n            else:\n                less += 1\n            i += 1\n        if taken == n and cost <= k:\n            lo = mid + 1\n            goodness = nums[mid]\n        else:\n            hi = mid - 1\n    print(goodness)", "try:\n    for t in range(int(input())):\n        (n, k) = map(int, input().split())\n        a = []\n        for i in range(n):\n            r = list(input().split())\n            for i in range(n):\n                r[i] = int(r[i])\n            for element in r:\n                a.append(element)\n            r = []\n        a.sort()\n\n        def solve(a, m):\n            summ = a[m]\n            d = n // 2\n            for i in range(2, n + 1):\n                summ += a[max(m + i - 1, d + (i - 1) * (d + 1))]\n            return summ\n        l = n // 2\n        r = n * n - n - n * (n // 2 - (n + 1) % 2)\n        while r - l > 1:\n            m = (l + r) // 2\n            if solve(a, m) > k:\n                r = m - 1\n            else:\n                l = m\n        if solve(a, r) <= k:\n            print(a[r])\n        elif solve(a, l) <= k:\n            print(a[l])\n        else:\n            print(-1)\nexcept:\n    pass", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    mat = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        for j in temp:\n            mat.append(j)\n    mat.sort()\n    med = n // 2\n    medians = []\n    l = 0\n    while l < n:\n        medians.append(med)\n        med += n // 2 + 1\n        l += 1\n    postfix = [0] * n\n    summ = 0\n    for i in range(n - 1, -1, -1):\n        summ += mat[medians[i]]\n        postfix[i] = summ\n    if postfix[0] > k:\n        print(-1)\n    else:\n        ans = mat[medians[0]]\n        t = 0\n        for i in range(1, n):\n            low = t + 1\n            high = medians[i] - i\n            if high < low:\n                low = high\n            t = high\n            while low <= high:\n                mid = (low + high) // 2\n                temp = postfix[i]\n                for j in range(i):\n                    temp += mat[mid + j]\n                if temp > k:\n                    high = mid - 1\n                else:\n                    if mat[mid] > ans:\n                        ans = mat[mid]\n                    low = mid + 1\n        print(ans)", "import math\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l1 = []\n    for _ in range(n):\n        l1 = l1 + list(map(int, input().split()))\n    l1.sort()\n    l = ini = math.ceil((n + 1) / 2) - 1\n    h = ini * n\n    good = -1\n    while l <= h:\n        mid = (l + h) // 2\n        if mid == ini * n:\n            if sum(l1[mid:mid + n]) <= k:\n                good = max(good, l1[mid])\n                l = mid + 1\n            else:\n                h = mid - 1\n        else:\n            short = ini * n - mid\n            check_tot = 0\n            e = mid + (math.floor(mid / ini) - 1)\n            for j in range(mid, e + 1):\n                check_tot += l1[j]\n            rem = mid - ini * math.floor(mid / ini)\n            check_tot += l1[e + ini - rem + 1] if rem != 0 else 0\n            start = e + 2 * ini - rem + 2 if rem != 0 else e + ini + 1\n            for j in range(start, start + (n - math.ceil(mid / ini) - 1) * (ini + 1) + 1, ini + 1):\n                check_tot += l1[j]\n            if check_tot <= k:\n                good = max(good, l1[mid])\n                l = mid + 1\n            else:\n                h = mid - 1\n    print(good)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nt = int(input())\nfor tt in range(t):\n    (n, k) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.extend(list(map(int, input().split())))\n    arr = sorted(arr)\n    ans = n * int(n / 2)\n    sum = 0\n    for i in range(ans, ans + n):\n        sum += arr[i]\n    while sum > k:\n        if ans <= 1:\n            break\n        fix = int((ans - 1) / int(n / 2)) - 1\n        if fix < 0:\n            break\n        sum += arr[ans - 1] - arr[ans + fix]\n        ans -= 1\n    if sum > k:\n        print(-1)\n    else:\n        print(arr[ans])", "from collections import defaultdict\nfrom sys import stdin, stdout, setrecursionlimit\nimport math\n(readline, writeline) = (stdin.readline, stdout.write)\nsetrecursionlimit(100005)\nfor _ in range(int(readline())):\n    lst = []\n    (n, k) = map(int, readline().split())\n    for i in range(n):\n        lst += list(map(int, readline().split()))\n    lst.sort()\n    ans = -1\n    l = n // 2\n    r = n * l\n    while l <= r:\n        mid = (l + r) // 2\n        (tot, cnt, add, x) = (0, 0, 0, 0)\n        visited = [0] * n ** 2\n        tar = mid\n        while tot != n:\n            if cnt == n // 2:\n                if not visited[tar]:\n                    visited[tar] = 1\n                    tot += 1\n                    add += lst[tar]\n                    cnt = 0\n                tar += 1\n            else:\n                if not visited[x]:\n                    visited[x] = 1\n                    cnt += 1\n                x += 1\n        if add > k:\n            r = mid - 1\n        else:\n            ans = lst[mid]\n            l = mid + 1\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = []\n    for i in range(n):\n        t = list(map(int, input().split()))\n        a += t\n    a.sort()\n    r = n * (n // 2)\n    l = n // 2\n    ans = -1\n    while r >= l:\n        mid = (l + r) // 2\n        i = mid\n        v = 1\n        sm = a[mid]\n        left = mid - n // 2\n        while v != n:\n            if left >= n // 2:\n                i += 1\n                left -= n // 2\n            else:\n                i += n // 2 - left + 1\n                left = 0\n            sm += a[i]\n            v += 1\n        if sm <= k:\n            l = mid + 1\n            ans = mid\n        else:\n            r = mid - 1\n    if ans == -1:\n        print(-1)\n    else:\n        print(a[ans])", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = []\n    for i in range(n):\n        t = list(map(int, input().split()))\n        a += t\n    a.sort()\n    r = n * (n // 2)\n    l = n // 2\n    ans = -1\n    while r >= l:\n        mid = (l + r) // 2\n        i = mid\n        v = 1\n        sm = a[mid]\n        left = mid - n // 2\n        while v != n:\n            if left >= n // 2:\n                i += 1\n                left -= n // 2\n            else:\n                i += n // 2 - left + 1\n                left = 0\n            sm += a[i]\n            v += 1\n        if sm <= k:\n            l = mid + 1\n            ans = mid\n        else:\n            r = mid - 1\n    if ans == -1:\n        print(-1)\n    else:\n        print(a[ans])", "for T in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append([int(i) for i in input().split()])\n    ar = []\n    for i in range(n):\n        for j in range(n):\n            ar.append(arr[i][j])\n    ar.sort()\n    leftcount = n // 2\n    rightcount = n - leftcount - 1\n    righttotal = rightcount * n\n    ans = -1\n    l = leftcount\n    r = n * n - righttotal - (n - 1) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        sum = 0\n        cnt = 0\n        tot = 0\n        x = 0\n        y = mid\n        vis = [0] * (n * n)\n        while tot != n:\n            if cnt == leftcount:\n                if vis[y] == 0:\n                    vis[y] = 1\n                    sum += ar[y]\n                    y += 1\n                    tot += 1\n                    cnt = 0\n                else:\n                    y += 1\n            elif vis[x] == 0:\n                vis[x] = 1\n                x += 1\n                cnt += 1\n            else:\n                x += 1\n        if sum <= k:\n            ans = mid\n            l = mid + 1\n        else:\n            r = mid - 1\n    if ans == -1:\n        print(ans)\n    else:\n        print(ar[ans])", "inf = float('inf')\nimport sys\nimport pprint\nimport logging\nfrom logging import getLogger\nimport array\nimport collections\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef maps():\n    return [int(i) for i in input().split()]\nlogging.basicConfig(format='%(message)s', level=logging.WARNING)\nlogger = getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\ndef debug(msg, *args):\n    logger.info(f'{msg}={pprint.pformat(args)}')\nfrom math import ceil\nfrom itertools import permutations, combinations\nfrom collections import Counter\nfor _ in range(*maps()):\n    (n, k) = maps()\n    A = []\n    [A.extend(maps()) for i in range(n)]\n    A.sort()\n    debug('A', A)\n    (N, mi_cost, i, j) = (n * n, 0, n // 2, 0)\n    while j < n:\n        mi_cost += A[i]\n        i += n // 2 + 1\n        j += 1\n    if mi_cost > k:\n        print(-1)\n        continue\n    (lo, hi) = (n // 2, N - 1)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        taken = 0\n        cost = 0\n        rleft = N\n        i = mid\n        smallest = mid\n        while taken < n and i < N:\n            if i >= rleft:\n                break\n            if smallest >= n // 2:\n                taken += 1\n                cost += A[i]\n                rleft -= n - n // 2 - 1\n                smallest -= n // 2\n                if i >= rleft:\n                    cost = k + 1\n                    break\n            else:\n                smallest += 1\n            i += 1\n        if taken < n:\n            cost = k + 1\n        if cost <= k:\n            lo = mid\n        else:\n            hi = mid - 1\n    print(A[lo])", "from math import ceil\n\ndef ii():\n    return int(input())\n\ndef imi():\n    return map(int, input().split())\n\ndef il():\n    return list(map(int, input().split()))\ninf = 10 ** 30\n\ndef max_cost(i, li, n, m):\n    if i < m:\n        return inf\n    ar = [1] * (n * n + 1)\n    j = 1\n    s = 0\n    lt = i\n    for _ in range(n):\n        if i > n * n:\n            return inf\n        c = 0\n        while c < m - 1:\n            if ar[j] >= 0:\n                ar[j] = -1\n                c += 1\n            j += 1\n            if j > n * n:\n                break\n        while ar[i] == -1:\n            i += 1\n            if i > n * n:\n                return inf\n        s += li[i]\n        ar[i] = -1\n        lt = i\n    if n * n - lt < n * (n - m):\n        return inf\n    return s\nt = int(input())\nfor _ in range(t):\n    (n, k) = imi()\n    li = []\n    for i in range(n):\n        li += il()\n    li.sort()\n    li = [0] + li\n    m = ceil((n + 1) / 2)\n    l = m\n    r = n * n\n    ans = -1\n    while l < r:\n        i = (l + r) // 2\n        if max_cost(i, li, n, m) <= k:\n            ans = max(li[i], ans)\n            l = i + 1\n        else:\n            r = i - 1\n    if max_cost(l, li, n, m) <= k:\n        ans = li[l]\n    print(ans)", "import sys\ninput = sys.stdin.readline\nfrom math import ceil\n\ndef ii():\n    return int(input())\n\ndef imi():\n    return map(int, input().split())\n\ndef il():\n    return list(map(int, input().split()))\ninf = 10 ** 30\n\ndef max_cost(i, li, n, m):\n    ar = [1] * (n * n + 1)\n    j = 1\n    s = 0\n    ans = []\n    for _ in range(n):\n        if i > n * n:\n            return inf\n        c = 0\n        while c < m - 1:\n            if ar[j] >= 0:\n                ar[j] = -1\n                c += 1\n            j += 1\n            if j > n * n:\n                break\n        while ar[i] == -1:\n            i += 1\n            if i > n * n:\n                return inf\n        ans.append(i)\n        s += li[i]\n        ar[i] = -1\n    if n * n - ans[n - 1] < n * (n - m):\n        return inf\n    return s\nt = int(input())\nfor _ in range(t):\n    (n, k) = imi()\n    li = []\n    for i in range(n):\n        li += il()\n    li.sort()\n    li = [0] + li\n    m = ceil((n + 1) / 2)\n    l = m\n    r = n * n\n    ans = -1\n    while l < r:\n        i = (l + r) // 2\n        if max_cost(i, li, n, m) <= k:\n            ans = max(li[i], ans)\n            l = i + 1\n        else:\n            r = i - 1\n    if max_cost(l, li, n, m) <= k:\n        ans = li[l]\n    print(ans)", "import sys\ninput = sys.stdin.readline\nfrom math import ceil\n\ndef ii():\n    return int(input())\n\ndef imi():\n    return map(int, input().split())\n\ndef il():\n    return list(map(int, input().split()))\ninf = 10 ** 30\n\ndef max_cost(i, li, n, m):\n    if i < m or i > n * m - n + 1:\n        return inf\n    ar = [1] * (n * n + 1)\n    j = 1\n    s = 0\n    ans = []\n    for _ in range(n):\n        if i > n * n:\n            return inf\n        c = 0\n        while c < m - 1:\n            if ar[j] >= 0:\n                ar[j] = -1\n                c += 1\n            j += 1\n            if j > n * n:\n                break\n        while ar[i] == -1:\n            i += 1\n            if i > n * n:\n                return inf\n        ans.append(i)\n        s += li[i]\n        ar[i] = -1\n    if n * n - ans[n - 1] < n * (n - m):\n        return inf\n    return s\nt = int(input())\nfor _ in range(t):\n    (n, k) = imi()\n    li = []\n    for i in range(n):\n        li += il()\n    li.sort()\n    li = [0] + li\n    m = ceil((n + 1) / 2)\n    l = m\n    r = n * n\n    ans = -1\n    while l < r:\n        i = (l + r) // 2\n        if max_cost(i, li, n, m) <= k:\n            ans = max(li[i], ans)\n            l = i + 1\n        else:\n            r = i - 1\n    if max_cost(l, li, n, m) <= k:\n        ans = li[l]\n    print(ans)", "from math import ceil\n\ndef ii():\n    return int(input())\n\ndef imi():\n    return map(int, input().split())\n\ndef il():\n    return list(map(int, input().split()))\ninf = 10 ** 30\n\ndef max_cost(i, li, n, m):\n    if i < m or i > n * m - n + 1:\n        return inf\n    ar = [1] * (n * n + 1)\n    j = 1\n    s = 0\n    ans = []\n    for _ in range(n):\n        if i > n * n:\n            return inf\n        c = 0\n        while c < m - 1:\n            if ar[j] >= 0:\n                ar[j] = -1\n                c += 1\n            j += 1\n            if j > n * n:\n                break\n        while ar[i] == -1:\n            i += 1\n            if i > n * n:\n                return inf\n        ans.append(i)\n        s += li[i]\n        ar[i] = -1\n    for i in ans:\n        ar[i] = 1\n    j = n * n\n    for i in ans[::-1]:\n        if j < 1:\n            return inf\n        c = 0\n        while c < n - m:\n            if ar[j] >= 0:\n                c += 1\n                ar[j] = -1\n            j -= 1\n            if j < 1:\n                break\n        if ar[i] == -1:\n            return inf\n        ar[i] = -1\n    return s\nt = int(input())\nfor _ in range(t):\n    (n, k) = imi()\n    li = []\n    for i in range(n):\n        li += il()\n    li.sort()\n    li = [0] + li\n    m = ceil((n + 1) / 2)\n    l = m\n    r = n * n\n    ans = -1\n    while l < r:\n        i = (l + r) // 2\n        if max_cost(i, li, n, m) <= k:\n            ans = max(li[i], ans)\n            l = i + 1\n        else:\n            r = i - 1\n    if max_cost(l, li, n, m) <= k:\n        ans = li[l]\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    median = n // 2\n    x = median - 1\n    num = n * median\n    flag = 0\n    a = []\n    for i in range(n):\n        a.extend(map(int, input().split()))\n    a.sort()\n    s = sum(a[num:num + n])\n    if s <= k:\n        print(min(a[num:num + n]))\n    else:\n        ref = a[median:num].copy()\n        new_lst = a[num:num + n].copy()\n        new_lst.reverse()\n        while len(ref):\n            x += 1\n            new_lst.append(ref[-1])\n            new_lst.pop(x // median)\n            if k >= sum(new_lst):\n                print(ref[-1])\n                flag = 1\n                break\n            else:\n                ref.pop(-1)\n        if not flag:\n            print(-1)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    median = n // 2\n    x = median - 1\n    num = n * median\n    flag = 0\n    a = []\n    for i in range(n):\n        a.extend(map(int, input().split()))\n    a.sort()\n    s = sum(a[num:num + n])\n    if s <= k:\n        print(min(a[num:num + n]))\n    else:\n        ref = a[median:num].copy()\n        new_lst = a[num:num + n].copy()\n        new_lst.reverse()\n        while len(ref):\n            x += 1\n            new_lst.append(ref[-1])\n            new_lst.pop(x // median)\n            if k >= sum(new_lst):\n                print(ref[-1])\n                flag = 1\n                break\n            else:\n                ref.pop(-1)\n        if not flag:\n            print(-1)", "import math\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    arr = [0]\n    arr2D = []\n    for i in range(n):\n        arr2D.append(list(map(int, input().split())))\n    for i in range(n):\n        for j in range(n):\n            arr.append(arr2D[i][j])\n    arr.sort()\n    total = n * n\n    start = int(math.ceil((n + 1) / 2))\n    end = (n - start) * n\n    mini = 0\n    medianCollection = []\n    count = 0\n    for i in range(start, total - end + 1):\n        medianCollection.append(arr[i])\n        count += 1\n        if count % start == 1:\n            mini += arr[i]\n    if k < mini:\n        print(-1)\n    else:\n        prefixSum = [0 for i in range(count + 1)]\n        prefixSum[0] = medianCollection[0]\n        for i in range(1, count):\n            prefixSum[i] = prefixSum[i - 1] + medianCollection[i]\n        wsum = 0\n        mins = 9999999999999999999\n        for i in range(count - 1, count - n - 1, -1):\n            wsum += medianCollection[i]\n            mins = min(mins, medianCollection[i])\n        if wsum <= k:\n            print(mins)\n            continue\n        else:\n            lsum = 0\n            loop = n\n            ansYes = True\n            moves = count - 1\n            while moves >= 0:\n                if moves % start == 0:\n                    lsum += medianCollection[moves]\n                    loop = loop - 1\n                wsum = lsum + prefixSum[moves] - prefixSum[moves - loop]\n                if wsum <= k:\n                    ansYes = False\n                    print(mins)\n                    break\n                mins = min(mins, medianCollection[moves - loop])\n                moves = moves - 1\n            if ansYes:\n                print(-1)", "import math\nfrom collections import deque, defaultdict\nfrom math import sqrt, ceil, factorial, floor, inf, gcd, log\nimport bisect\nimport sys\nimport random\nimport heapq\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef possible(ind, n, k, l):\n    max_ind = n * n // 2 + n - 1\n    mid = n // 2\n    counter = n\n    val = ind // mid\n    sm = sum(l[ind:ind + val])\n    counter -= ind // mid\n    if counter <= 0 and sm <= k:\n        return True\n    remain = ind % mid\n    break_cond = n * n\n    for i in range(ind + val, n * n):\n        if remain == mid:\n            sm += l[i]\n            counter -= 1\n            remain = 0\n        else:\n            remain += 1\n        if counter == 0:\n            break_cond = i\n            break\n    if break_cond <= max_ind and sm <= k:\n        return True\n    return False\n\ndef main():\n    for _ in range(int(input())):\n        (n, k) = get_ints()\n        l = []\n        for _ in range(n):\n            tmp = get_array()\n            l.extend(tmp)\n        l.sort()\n        if n == 1:\n            if l[0] > k:\n                print(-1)\n            else:\n                print(l[0])\n            continue\n        ans = -1\n        left = n // 2\n        right = n * n // 2\n        while right >= left:\n            mid = (left + right) // 2\n            if possible(mid, n, k, l):\n                ans = l[mid]\n                left = mid + 1\n            else:\n                right = mid - 1\n        print(ans)\nmain()", "from math import ceil, log2, floor, sqrt, gcd\nfrom collections import defaultdict, deque\nfrom os import P_WAIT\nfrom collections import defaultdict\nfrom ntpath import realpath\nimport sys\nimport os.path\nsys.setrecursionlimit(200000)\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r+')\n    sys.stdout = open('output.txt', 'w')\n\ndef MI():\n    return map(int, input().split())\nmod = 10 ** 9 + 7\n\ndef solve(testcase):\n    (n, k) = MI()\n    a = []\n    for i in range(n):\n        l = list(MI())\n        for j in l:\n            a.append(j)\n    a.sort()\n    mid = n // 2\n    minn = 0\n    d = n - mid - 1\n    max_mid = n ** 2 - n * d - n\n    st = mid\n    en = max_mid\n    ans = -1\n    while st <= en and st >= 0 and (en < n ** 2):\n        m = st + en >> 1\n        cost = 0\n        pre = m\n        i = m\n        c = n\n        while i < n ** 2:\n            cost += a[i]\n            pre -= mid\n            if pre < mid:\n                i += mid - max(0, pre) + 1\n                pre = mid\n            else:\n                i += 1\n            c -= 1\n            if c == 0:\n                break\n        if cost <= k:\n            st = m + 1\n            ans = max(a[m], ans)\n        else:\n            en = m - 1\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    solve(_ + 1)", "import math\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    M = []\n    for i in range(N):\n        M.append(list(map(int, input().split())))\n    A = []\n    for i in range(N):\n        A.extend(M[i])\n    A.sort()\n    a = N * N - (N - math.ceil((N + 1) / 2)) * N - N\n    c = 0\n    h = N\n    l = 0\n    for i in range(a, a + N):\n        l += A[i]\n    a -= 1\n    while l > K and a >= math.ceil((N + 1) / 2) - 1:\n        if c == 0:\n            h -= 1\n        l += A[a] - A[a + h]\n        a -= 1\n        c = (c + 1) % (math.ceil((N + 1) / 2) - 1)\n    if l > K:\n        print(-1)\n    else:\n        print(A[a + 1])", "def find(point):\n    (cnt, sum) = (0, 0)\n    temp = point\n    while cnt != n:\n        if temp >= n // 2:\n            sum = sum + l[point]\n            temp = temp - n // 2\n        elif temp:\n            sum = sum + l[point + (n // 2 - temp)]\n            point = point + (n // 2 - temp)\n            temp = 0\n        else:\n            sum = sum + l[point + n // 2]\n            point = point + n // 2\n        point = point + 1\n        cnt = cnt + 1\n    return sum\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = []\n    for _ in range(n):\n        l.extend(list(map(int, input().split())))\n    l.sort()\n    ans = -1\n    low = n // 2\n    high = n * (n // 2)\n    while low <= high:\n        mid = (low + high) // 2\n        temp = find(mid)\n        if temp <= k:\n            ans = l[mid]\n            low = mid + 1\n        else:\n            high = mid - 1\n    print(ans)", "def find(point):\n    (cnt, sum) = (0, 0)\n    temp = point\n    while cnt != n:\n        if temp >= n // 2:\n            sum = sum + l[point]\n            temp = temp - n // 2\n        elif temp:\n            sum = sum + l[point + (n // 2 - temp)]\n            point = point + (n // 2 - temp)\n            temp = 0\n        else:\n            sum = sum + l[point + n // 2]\n            point = point + n // 2\n        point = point + 1\n        cnt = cnt + 1\n    return sum\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = []\n    for _ in range(n):\n        l.extend(list(map(int, input().split())))\n    l.sort()\n    ans = -1\n    low = n // 2\n    high = n * (n // 2)\n    while low <= high:\n        mid = (low + high) // 2\n        temp = find(mid)\n        if temp <= k:\n            ans = l[mid]\n            low = mid + 1\n        else:\n            high = mid - 1\n    print(ans)", "def find(point):\n    (cnt, sum) = (0, 0)\n    temp = point\n    while cnt != n:\n        if temp >= n // 2:\n            sum = sum + l[point]\n            temp = temp - n // 2\n        elif temp:\n            sum = sum + l[point + (n // 2 - temp)]\n            point = point + (n // 2 - temp)\n            temp = 0\n        else:\n            sum = sum + l[point + n // 2]\n            point = point + n // 2\n        point = point + 1\n        cnt = cnt + 1\n    return sum\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = []\n    for _ in range(n):\n        l.extend(list(map(int, input().split())))\n    l.sort()\n    ans = -1\n    low = n // 2\n    high = n * (n // 2)\n    while low <= high:\n        mid = (low + high) // 2\n        temp = find(mid)\n        if temp <= k:\n            ans = l[mid]\n            low = mid + 1\n        else:\n            high = mid - 1\n    print(ans)", "t = int(input())\nfor i in range(t):\n    t -= 1\n    (n, k) = map(int, input().split())\n    r = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        r.extend(a)\n    r.sort()\n    re = n * (n // 2)\n    z = sum(r[re:re + n])\n    if z <= k:\n        print(r[re])\n    else:\n        fl = 0\n        cur = z\n        lastpos = re + n - 1\n        firstpos = re\n        for i in range(n - 1):\n            for j in range(n // 2):\n                cur -= r[lastpos - 1]\n                lastpos -= 1\n                cur += r[firstpos - 1]\n                firstpos -= 1\n                if cur <= k:\n                    fl = 1\n                    print(r[firstpos])\n                    break\n            lastpos -= 1\n            if fl:\n                break\n        if fl == 0:\n            print(-1)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nt = int(input())\nfor tt in range(t):\n    (n, k) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.extend(list(map(int, input().split())))\n    arr = sorted(arr)\n    ans = n * int(n / 2)\n    sum = 0\n    for i in range(ans, ans + n):\n        sum += arr[i]\n    while sum > k:\n        if ans <= 1:\n            break\n        fix = int((ans - 1) / int(n / 2)) - 1\n        if fix < 0:\n            break\n        sum += arr[ans - 1] - arr[ans + fix]\n        ans -= 1\n    if sum > k:\n        print(-1)\n    else:\n        print(arr[ans])", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = []\n    for _ in range(n):\n        a.extend(map(int, input().split()))\n    a.sort()\n    med = n // 2\n    cost_minim = sum((a[med + i * (med + 1)] for i in range(n)))\n    if cost_minim > k:\n        print(-1)\n    else:\n        med_minim = a[n * med:n * (med + 1)]\n        cost_med_minim = sum(med_minim)\n        minim = med_minim[0]\n        if cost_med_minim <= k:\n            print(minim)\n        else:\n            num = a[:n * (med + 1)][::-1]\n            s = sum(num[:n])\n            (pos, right) = (0, n)\n            while s > k:\n                if pos % (med + 1) == 0:\n                    pos += 1\n                    right -= 1\n                s += num[pos + right] - num[pos]\n                pos += 1\n            print(num[pos - 1 + right])", "import sys\nimport math\nimport random\nimport heapq\ninput = sys.stdin.readline\n\ndef pow(a, n):\n    if n == 0:\n        return 1\n    x = pow(a, n // 2)\n    if n % 2 == 0:\n        return x * x\n    else:\n        return x * x * a\n\ndef gcd(a, b):\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef bs(arr, le, ri):\n    l = 0\n    arr.sort()\n    r = len(arr) - 1\n    ans = 10000000\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] >= le and arr[m] <= ri:\n            ans = arr[m]\n            r = m - 1\n        elif arr[m] < le:\n            l = m + 1\n        else:\n            r = m - 1\n    return ans\nt = int(input())\nwhile t > 0:\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    for i in range(n - 1):\n        l.extend(list(map(int, input().split())))\n    l.sort(reverse=True)\n    x = (n // 2 + n % 2 - 1) * n\n    te = x\n    m = 0\n    for i in range(n):\n        m += l[x]\n        x += 1\n    if m <= k:\n        print(l[x - 1])\n    else:\n        y = n // 2 + 1\n        while m > k and n * n - 1 - x >= n // 2:\n            if (n * n - te) % y != 0:\n                m -= l[te]\n                m += l[x]\n                x += 1\n                te += 1\n            else:\n                te += 1\n        if m <= k:\n            print(l[x - 1])\n        else:\n            print(-1)\n    t -= 1"]