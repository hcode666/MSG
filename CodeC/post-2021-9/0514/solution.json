["operations = []\nnOps = 0\n\ndef operate(x, y, z):\n    operations.append([arr[x], arr[y], arr[z]])\n    global nOps\n    nOps += 1\n    (arr[x], arr[y], arr[z]) = (arr[x] ^ arr[y], arr[y] ^ arr[z], arr[z] ^ arr[x])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    operations = []\n\n    def operate(x, y, z):\n        operations.append([arr[x], arr[y], arr[z]])\n        (arr[x], arr[y], arr[z]) = (arr[x] ^ arr[y], arr[y] ^ arr[z], arr[z] ^ arr[x])\n    for bit in range(30, -1, -1):\n        idx = []\n        for i in range(n):\n            if arr[i] >> bit & 1:\n                idx.append(i)\n            if len(idx) == 3:\n                operate(idx[0], idx[1], idx[2])\n                idx = []\n        if len(idx) == 1:\n            x = idx[0]\n            (y, z, w) = ((i + 1) % n, (i + 2) % n, (i + 3) % n)\n            operate(x, y, z)\n            operate(y, z, w)\n            operate(x, y, z)\n        elif len(idx) == 2:\n            x = idx[0]\n            nxt = []\n            for i in range(1, 4):\n                ii = (x + i) % n\n                if ii != idx[1]:\n                    nxt.append(ii)\n            y = idx[1]\n            (z, w) = (nxt[0], nxt[1])\n            operate(y, z, w)\n            operate(x, y, w)\n    print(len(operations))\n    for op in operations:\n        print('%d %d %d' % (op[0], op[1], op[2]))", "operations = []\nnOps = 0\n\ndef operate(x, y, z):\n    operations.append([arr[x], arr[y], arr[z]])\n    global nOps\n    nOps += 1\n    (arr[x], arr[y], arr[z]) = (arr[x] ^ arr[y], arr[y] ^ arr[z], arr[z] ^ arr[x])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    operations = []\n\n    def operate(x, y, z):\n        operations.append([arr[x], arr[y], arr[z]])\n        (arr[x], arr[y], arr[z]) = (arr[x] ^ arr[y], arr[y] ^ arr[z], arr[z] ^ arr[x])\n    for bit in range(30, -1, -1):\n        idx = []\n        for i in range(n):\n            if arr[i] >> bit & 1:\n                idx.append(i)\n            if len(idx) == 3:\n                operate(idx[0], idx[1], idx[2])\n                idx = []\n        if len(idx) == 1:\n            x = idx[0]\n            (y, z, w) = ((i + 1) % n, (i + 2) % n, (i + 3) % n)\n            operate(x, y, z)\n            operate(y, z, w)\n            operate(x, y, z)\n        elif len(idx) == 2:\n            x = idx[0]\n            nxt = []\n            for i in range(1, 4):\n                ii = (x + i) % n\n                if ii != idx[1]:\n                    nxt.append(ii)\n            y = idx[1]\n            (z, w) = (nxt[0], nxt[1])\n            operate(y, z, w)\n            operate(x, y, w)\n    print(len(operations))\n    for op in operations:\n        print('%d %d %d' % (op[0], op[1], op[2]))", "operations = []\nnOps = 0\n\ndef operate(x, y, z):\n    operations.append([arr[x], arr[y], arr[z]])\n    global nOps\n    nOps += 1\n    (arr[x], arr[y], arr[z]) = (arr[x] ^ arr[y], arr[y] ^ arr[z], arr[z] ^ arr[x])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    operations = []\n\n    def operate(x, y, z):\n        operations.append([arr[x], arr[y], arr[z]])\n        (arr[x], arr[y], arr[z]) = (arr[x] ^ arr[y], arr[y] ^ arr[z], arr[z] ^ arr[x])\n    for bit in range(30, -1, -1):\n        idx = []\n        for i in range(n):\n            if arr[i] >> bit & 1:\n                idx.append(i)\n            if len(idx) == 3:\n                operate(idx[0], idx[1], idx[2])\n                idx = []\n        if len(idx) == 1:\n            x = idx[0]\n            (y, z, w) = ((i + 1) % n, (i + 2) % n, (i + 3) % n)\n            operate(x, y, z)\n            operate(y, z, w)\n            operate(x, y, z)\n        elif len(idx) == 2:\n            x = idx[0]\n            nxt = []\n            for i in range(1, 4):\n                ii = (x + i) % n\n                if ii != idx[1]:\n                    nxt.append(ii)\n            y = idx[1]\n            (z, w) = (nxt[0], nxt[1])\n            operate(y, z, w)\n            operate(x, y, w)\n    print(len(operations))\n    for op in operations:\n        print('%d %d %d' % (op[0], op[1], op[2]))", "operations = []\nnOps = 0\n\ndef operate(x, y, z):\n    operations.append([arr[x], arr[y], arr[z]])\n    global nOps\n    nOps += 1\n    (arr[x], arr[y], arr[z]) = (arr[x] ^ arr[y], arr[y] ^ arr[z], arr[z] ^ arr[x])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    operations = []\n\n    def operate(x, y, z):\n        operations.append([arr[x], arr[y], arr[z]])\n        (arr[x], arr[y], arr[z]) = (arr[x] ^ arr[y], arr[y] ^ arr[z], arr[z] ^ arr[x])\n    for bit in range(30, -1, -1):\n        idx = []\n        for i in range(n):\n            if arr[i] >> bit & 1:\n                idx.append(i)\n            if len(idx) == 3:\n                operate(idx[0], idx[1], idx[2])\n                idx = []\n        if len(idx) == 1:\n            x = idx[0]\n            (y, z, w) = ((i + 1) % n, (i + 2) % n, (i + 3) % n)\n            operate(x, y, z)\n            operate(y, z, w)\n            operate(x, y, z)\n        elif len(idx) == 2:\n            x = idx[0]\n            nxt = []\n            for i in range(1, 4):\n                ii = (x + i) % n\n                if ii != idx[1]:\n                    nxt.append(ii)\n            y = idx[1]\n            (z, w) = (nxt[0], nxt[1])\n            operate(y, z, w)\n            operate(x, y, w)\n    print(len(operations))\n    for op in operations:\n        print('%d %d %d' % (op[0], op[1], op[2]))", "operations = []\nnOps = 0\n\ndef operate(x, y, z):\n    operations.append([arr[x], arr[y], arr[z]])\n    global nOps\n    nOps += 1\n    (arr[x], arr[y], arr[z]) = (arr[x] ^ arr[y], arr[y] ^ arr[z], arr[z] ^ arr[x])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    operations = []\n\n    def operate(x, y, z):\n        operations.append([arr[x], arr[y], arr[z]])\n        (arr[x], arr[y], arr[z]) = (arr[x] ^ arr[y], arr[y] ^ arr[z], arr[z] ^ arr[x])\n    for bit in range(30, -1, -1):\n        idx = []\n        for i in range(n):\n            if arr[i] >> bit & 1:\n                idx.append(i)\n            if len(idx) == 3:\n                operate(idx[0], idx[1], idx[2])\n                idx = []\n        if len(idx) == 1:\n            x = idx[0]\n            (y, z, w) = ((i + 1) % n, (i + 2) % n, (i + 3) % n)\n            operate(x, y, z)\n            operate(y, z, w)\n            operate(x, y, z)\n        elif len(idx) == 2:\n            x = idx[0]\n            nxt = []\n            for i in range(1, 4):\n                ii = (x + i) % n\n                if ii != idx[1]:\n                    nxt.append(ii)\n            y = idx[1]\n            (z, w) = (nxt[0], nxt[1])\n            operate(y, z, w)\n            operate(x, y, w)\n    print(len(operations))\n    for op in operations:\n        print('%d %d %d' % (op[0], op[1], op[2]))", "powers = [2 ** i for i in range(43)]\n\ndef binarToDec(a):\n    ans = 0\n    for i in range(len(a)):\n        ans += a[i] * powers[i]\n    return ans\nfor lkdk in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = []\n    ans = []\n    for i in a:\n        x = bin(i)[2:]\n        x = x.zfill(35)\n        b.append(list(x))\n    for i in range(35):\n        (zero, one) = ([], [])\n        for j in range(n):\n            if b[j][i] == '0':\n                zero.append(j)\n            else:\n                one.append(j)\n        while len(one) >= 3:\n            ab = one.pop()\n            bc = one.pop()\n            cd = one.pop()\n            zero.append(ab)\n            zero.append(bc)\n            zero.append(cd)\n            ans.append((a[ab], a[bc], a[cd]))\n            x1 = a[ab] ^ a[bc]\n            x2 = a[bc] ^ a[cd]\n            x3 = a[cd] ^ a[ab]\n            a[ab] = x1\n            a[bc] = x2\n            a[cd] = x3\n            b[ab] = list(bin(x1)[2:].zfill(35))\n            b[bc] = list(bin(x2)[2:].zfill(35))\n            b[cd] = list(bin(x3)[2:].zfill(35))\n        if len(one) == 1:\n            ab = one.pop()\n            bc = zero.pop()\n            cd = zero.pop()\n            ans.append((a[ab], a[bc], a[cd]))\n            x1 = a[ab] ^ a[bc]\n            x2 = a[cd] ^ a[ab]\n            x3 = a[bc] ^ a[cd]\n            a[ab] = x1\n            a[bc] = x2\n            a[cd] = x3\n            b[ab] = list(bin(x1)[2:].zfill(35))\n            b[bc] = list(bin(x2)[2:].zfill(35))\n            b[cd] = list(bin(x3)[2:].zfill(35))\n            zero.append(cd)\n            one.append(bc)\n            one.append(ab)\n        if len(one) == 2:\n            ab = one.pop()\n            bc = zero.pop()\n            cd = zero.pop()\n            ans.append((a[ab], a[bc], a[cd]))\n            x1 = a[ab] ^ a[bc]\n            x2 = a[cd] ^ a[ab]\n            x3 = a[bc] ^ a[cd]\n            a[ab] = x1\n            a[bc] = x2\n            a[cd] = x3\n            b[ab] = list(bin(x1)[2:].zfill(35))\n            b[bc] = list(bin(x2)[2:].zfill(35))\n            b[cd] = list(bin(x3)[2:].zfill(35))\n            zero.append(cd)\n            one.append(bc)\n            one.append(ab)\n        if len(one) == 3:\n            ab = one.pop()\n            bc = one.pop()\n            cd = one.pop()\n            zero.append(ab)\n            zero.append(bc)\n            zero.append(cd)\n            ans.append((a[ab], a[bc], a[cd]))\n            x1 = a[ab] ^ a[bc]\n            x2 = a[bc] ^ a[cd]\n            x3 = a[cd] ^ a[ab]\n            a[ab] = x1\n            a[bc] = x2\n            a[cd] = x3\n            b[ab] = list(bin(x1)[2:].zfill(35))\n            b[bc] = list(bin(x2)[2:].zfill(35))\n            b[cd] = list(bin(x3)[2:].zfill(35))\n    print(len(ans))\n    for i in ans:\n        print(*i)", "import queue\nimport collections\nimport sys\nmod7 = 1000000007\ndiff4 = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndir4 = ['R', 'D', 'L', 'U']\nrevdir4 = ['L', 'U', 'R', 'D']\nlocal = False\n\ndef fastinp():\n    return sys.stdin.readline().strip()\n\ndef fastout(str):\n    sys.stdout.writeline(str)\n\ndef getarr(_type=int):\n    return [_type(x) for x in fastinp().split()]\n\ndef getint():\n    return int(fastinp())\n\ndef initarr_2d(row, col, defval=0):\n    return [[defval for i in range(0, col)] for j in range(0, row)]\n\ndef grid_check(i, j, n, m):\n    return i >= 0 and j >= 0 and (i < n) and (j < m)\nt = getint()\nfor i in range(t):\n    n = getint()\n    a = getarr()\n    oper = []\n\n    def dooper(ix, iy, iz):\n        x = a[ix]\n        y = a[iy]\n        z = a[iz]\n        oper.append([x, y, z])\n        a[ix] = x ^ y\n        a[iy] = z ^ y\n        a[iz] = x ^ z\n    for b in range(30, -1, -1):\n        idx = []\n        for i in range(0, n):\n            if a[i] >> b & 1 == 1:\n                idx.append(i)\n            if len(idx) == 3:\n                dooper(idx[0], idx[1], idx[2])\n                idx = []\n        if len(idx) > 0:\n            idx0 = []\n            ii = idx[0]\n            for d in range(0, 6):\n                curi = (ii + d) % n\n                if curi not in idx:\n                    idx0.append(curi)\n            if len(idx) == 1:\n                ix = idx0[0]\n                iy = idx0[1]\n                iz = idx0[2]\n                dooper(ii, ix, iy)\n                dooper(ii, ix, iz)\n                dooper(ii, iy, iz)\n            if len(idx) == 2:\n                ij = idx[1]\n                ix = idx0[1]\n                iy = idx0[2]\n                dooper(ij, ix, iy)\n                dooper(ii, ij, iy)\n    print(len(oper))\n    for l in oper:\n        print(l[0], l[1], l[2])"]