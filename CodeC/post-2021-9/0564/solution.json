["def check(arr, mean, n):\n    sum = 0\n    for i in range(len(arr)):\n        sum += arr[i]\n    allowed_operations = n * mean - sum\n    if allowed_operations < 0:\n        return -1\n    required_operations = 0\n    for i in range((n - 1) // 2, n):\n        required_operations += max(0, mean - arr[i])\n    if required_operations > allowed_operations:\n        return -1\n    else:\n        return allowed_operations\nfor i in range(int(input())):\n    N = int(input())\n    arr = [int(x) for x in input().split()]\n    arr = sorted(arr)\n    l = arr[(len(arr) - 1) // 2]\n    r = arr[len(arr) - 1]\n    ans = -1\n    n = len(arr)\n    while l <= r:\n        mid = (l + r) // 2\n        minOp = check(arr, mid, n)\n        if minOp != -1:\n            ans = minOp\n            r = mid - 1\n        else:\n            l = mid + 1\n    print(ans)", "def check(arr, mean, n):\n    sum = 0\n    for i in range(len(arr)):\n        sum += arr[i]\n    allowed_operations = n * mean - sum\n    if allowed_operations < 0:\n        return -1\n    required_operations = 0\n    for i in range((n - 1) // 2, n):\n        required_operations += max(0, mean - arr[i])\n    if required_operations > allowed_operations:\n        return -1\n    else:\n        return allowed_operations\nfor i in range(int(input())):\n    N = int(input())\n    arr = [int(x) for x in input().split()]\n    arr = sorted(arr)\n    l = arr[(len(arr) - 1) // 2]\n    r = arr[len(arr) - 1]\n    ans = -1\n    n = len(arr)\n    while l <= r:\n        mid = (l + r) // 2\n        minOp = check(arr, mid, n)\n        if minOp != -1:\n            ans = minOp\n            r = mid - 1\n        else:\n            l = mid + 1\n    print(ans)", "def check(arr, mean, n):\n    sum = 0\n    for i in range(len(arr)):\n        sum += arr[i]\n    allowed_operations = n * mean - sum\n    if allowed_operations < 0:\n        return -1\n    required_operations = 0\n    for i in range((n - 1) // 2, n):\n        required_operations += max(0, mean - arr[i])\n    if required_operations > allowed_operations:\n        return -1\n    else:\n        return allowed_operations\nfor i in range(int(input())):\n    N = int(input())\n    arr = [int(x) for x in input().split()]\n    arr = sorted(arr)\n    l = arr[(len(arr) - 1) // 2]\n    r = arr[len(arr) - 1]\n    ans = -1\n    n = len(arr)\n    while l <= r:\n        mid = (l + r) // 2\n        minOp = check(arr, mid, n)\n        if minOp != -1:\n            ans = minOp\n            r = mid - 1\n        else:\n            l = mid + 1\n    print(ans)", "def check_mean_median(arr, n, x):\n    cost_mean = n * x - sum(arr)\n    if cost_mean < 0:\n        return -1\n    cost_median = 0\n    for i in range((n - 1) // 2, n):\n        cost_median += max(0, x - arr[i])\n    if cost_median > cost_mean:\n        return -1\n    else:\n        return cost_mean\n\ndef solve(arr, n):\n    arr.sort()\n    (low, high, ans) = (arr[(n - 1) // 2], 10 ** 9 + 10, -1)\n    while low <= high:\n        mid = low + (high - low) // 2\n        min_oper = check_mean_median(arr, n, mid)\n        if min_oper != -1:\n            ans = min_oper\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    solve(arr, n)", "def check_mean_median(arr, n, x):\n    cost_mean = n * x - sum(arr)\n    if cost_mean < 0:\n        return -1\n    cost_median = 0\n    for i in range((n - 1) // 2, n):\n        cost_median += max(0, x - arr[i])\n    if cost_median > cost_mean:\n        return -1\n    else:\n        return cost_mean\n\ndef solve(arr, n):\n    arr.sort()\n    (low, high, ans) = (arr[(n - 1) // 2], 10 ** 9 + 10, -1)\n    while low <= high:\n        mid = low + (high - low) // 2\n        min_oper = check_mean_median(arr, n, mid)\n        if min_oper != -1:\n            ans = min_oper\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    solve(arr, n)", "def snek(a, n, x):\n    c = n * x - sum(a)\n    if c < 0:\n        return -1\n    c2 = 0\n    for i in range((n - 1) // 2, n):\n        c2 += max(0, x - a[i])\n    if c2 > c:\n        return -1\n    else:\n        return c\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    (l, h, ans) = (a[(n - 1) // 2], 10 ** 9 + 10, -1)\n    while l <= h:\n        m1 = l + (h - l) // 2\n        m2 = snek(a, n, m1)\n        if m2 != -1:\n            ans = m2\n            h = m1 - 1\n        else:\n            l = m1 + 1\n    print(ans)", "def check_mean_median(arr, n, x):\n    cost_mean = n * x - sum(arr)\n    if cost_mean < 0:\n        return -1\n    cost_median = 0\n    for i in range((n - 1) // 2, n):\n        cost_median += max(0, x - arr[i])\n    if cost_median > cost_mean:\n        return -1\n    else:\n        return cost_mean\n\ndef solve(arr, n):\n    arr.sort()\n    (low, high, ans) = (arr[(n - 1) // 2], 10 ** 9 + 10, -1)\n    while low <= high:\n        mid = low + (high - low) // 2\n        min_oper = check_mean_median(arr, n, mid)\n        if min_oper != -1:\n            ans = min_oper\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    solve(arr, n)", "for _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    a.sort()\n    mod_in = (n - 1) // 2\n    l = a[mod_in] - 1\n    r = 10 ** 9\n    while r - l > 1:\n        cur = (l + r) // 2\n        meanop = cur * n - sum(a)\n        medianop = 0\n        for i in range(mod_in, n):\n            medianop += max(0, cur - a[i])\n        if meanop >= medianop:\n            r = cur\n        else:\n            l = cur\n    print(r * n - sum(a))", "import sys\nint1 = lambda x: int(x) - 1\npDB = lambda *x: print(*x, end='\\n', file=sys.stderr)\np2D = lambda x: print(*x, sep='\\n', end='\\n\\n', file=sys.stderr)\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef LI1():\n    return list(map(int1, sys.stdin.readline().split()))\n\ndef LLI1(rows_number):\n    return [LI1() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline().rstrip()\ndij = [(0, 1), (-1, 0), (0, -1), (1, 0)]\ninf = 18446744073709551615\nmd = 10 ** 9 + 7\n\ndef solve():\n\n    def binary_search(l, r, ok, minimize):\n        if minimize:\n            l -= 1\n        else:\n            r += 1\n        while l + 1 < r:\n            m = (l + r) // 2\n            if ok(m) ^ minimize:\n                l = m\n            else:\n                r = m\n        if minimize:\n            return r\n        return l\n\n    def ok(v):\n        if v * n < s:\n            return False\n        t = v * n\n        for i in range(mid, n):\n            t -= max(v, aa[i])\n        return t >= pre\n    n = II()\n    aa = LI()\n    mid = (n - 1) // 2\n    aa.sort()\n    pre = sum(aa[:mid])\n    s = sum(aa)\n    m = aa[mid]\n    v = binary_search(m, 10 ** 9 + 5, ok, True)\n    ans = v * n - s\n    print(ans)\nfor _ in range(II()):\n    solve()", "def check(A, N, x):\n    mean_op = N * x - sum(A)\n    if mean_op < 0:\n        return -1\n    median_op = 0\n    for i in range((N - 1) // 2, N):\n        median_op += max(0, x - A[i])\n    if median_op <= mean_op:\n        return mean_op\n    else:\n        return -1\n\ndef solve(A, N):\n    A.sort()\n    low = A[(N - 1) // 2]\n    high = 10 ** 9 + 10\n    ans = -1\n    while low <= high:\n        mid = low + (high - low) // 2\n        min_operations = check(A, N, mid)\n        if min_operations == -1:\n            low = mid + 1\n        else:\n            high = mid - 1\n            ans = min_operations\n    print(ans)\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    solve(A, N)", "def cal(arr, n, med):\n    ind = n // 2 - 1 if n % 2 == 0 else (n + 1) // 2 - 1\n    c = 0\n    for i in range(ind, n):\n        if i == ind:\n            c += med - arr[ind]\n            arr[ind] = med\n        elif arr[i - 1] > arr[i]:\n            c += arr[i - 1] - arr[i]\n            arr[i] = arr[i - 1]\n    tot = sum(arr)\n    if tot > med * n:\n        return -1\n    else:\n        return c + (med * n - tot)\nfor _ in range(int(input())):\n    n = int(input())\n    arr = sorted(list(map(int, input().split())))\n    tot = sum(arr)\n    median = arr[n // 2 - 1] if n % 2 == 0 else arr[(n + 1) // 2 - 1]\n    if tot == median * n:\n        print(0)\n    elif tot < median * n:\n        print(median * n - tot)\n    else:\n        l = median + 1\n        h = 10 ** 9 + 1\n        fc = 10 ** 18\n        while l <= h:\n            mid = (l + h) // 2\n            cost = cal(arr[:], n, mid)\n            if cost == -1:\n                l = mid + 1\n            else:\n                fc = min(fc, cost)\n                h = mid - 1\n        print(fc)", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nsys.setrecursionlimit(3 * 10 ** 5)\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\n\ndef hnbhai(tc):\n    n = sb()\n    a = sd()\n    a.sort()\n    m = (n - 1) // 2\n    sm = sum(a)\n    avg = sm / n\n    ans = float('inf')\n    low = a[m]\n    high = 10 ** 15\n    while low <= high:\n        mid = (low + high) // 2\n        left = n * mid - sm\n        for i in range(m, n):\n            if a[i] < mid:\n                left -= mid - a[i]\n        if left >= 0:\n            ans = n * mid - sm\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)\n    return\nfor _ in range(sb()):\n    hnbhai(_ + 1)", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nsys.setrecursionlimit(3 * 10 ** 5)\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\n\ndef hnbhai(tc):\n    n = sb()\n    a = sd()\n    a.sort()\n    m = (n - 1) // 2\n    sm = sum(a)\n    avg = sm / n\n    if avg < a[m]:\n        print(n * a[m] - sm)\n        return\n    ans = float('inf')\n    low = 0\n    high = 10 ** 15\n    while low <= high:\n        mid = (low + high) // 2\n        left = n * mid - sm\n        for i in range(m, n):\n            if a[i] < mid:\n                left -= mid - a[i]\n        if left >= 0:\n            ans = n * mid - sm\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)\n    return\nfor _ in range(sb()):\n    hnbhai(_ + 1)", "def check(a, n, k):\n    meanop = n * k - sum(a)\n    if meanop < 0:\n        return -1\n    medianop = 0\n    for i in range((n - 1) // 2, n):\n        medianop += max(0, k - a[i])\n    if medianop > meanop:\n        return -1\n    return meanop\n\ndef solve(a, n):\n    a.sort()\n    (low, high, ans) = (a[(n - 1) // 2], 10 ** 9 + 10, -1)\n    while low <= high:\n        k = low + (high - low) // 2\n        op = check(a, n, k)\n        if op != -1:\n            ans = op\n            high = k - 1\n        else:\n            low = k + 1\n    print(ans)\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    a = list(map(int, input().split()))\n    solve(a, n)", "import sys\ninput = sys.stdin.readline\n\ndef feasible(arr, tar, total):\n    N = len(arr)\n    meanop = N * tar - total\n    medianop = 0\n    for i in range((N - 1) // 2, N):\n        medianop += max(0, tar - arr[i])\n    if meanop >= medianop:\n        return meanop\n    return -1\nt = int(input())\nfor case in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    l = A[(n - 1) // 2]\n    r = 10 ** 9\n    total = sum(A)\n    while l <= r:\n        mid = (l + r) // 2\n        res = feasible(A, mid, total)\n        if res != -1:\n            r = mid - 1\n            ans = res\n        else:\n            l = mid + 1\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\ndef feasible(arr, tar, total):\n    N = len(arr)\n    meanop = N * tar - total\n    medianop = 0\n    for i in range((N - 1) // 2, N):\n        medianop += max(0, tar - arr[i])\n    if meanop >= medianop:\n        return meanop\n    return -1\nt = int(input())\nfor case in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    l = A[(n - 1) // 2]\n    r = 10 ** 9\n    total = sum(A)\n    while l <= r:\n        mid = l + (r - l) // 2\n        res = feasible(A, mid, total)\n        if res != -1:\n            r = mid - 1\n            ans = res\n        else:\n            l = mid + 1\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\ndef valid(k, arr, total):\n    mean_op = k * len(arr) - total\n    median_op = 0\n    n = len(arr)\n    for i in range((n - 1) // 2, n):\n        median_op += max(0, k - arr[i])\n    if mean_op >= median_op:\n        return mean_op\n    return -1\nfor t in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    low = arr[(n - 1) // 2]\n    high = 10 ** 9\n    ans = -1\n    total = sum(arr)\n    while low <= high:\n        mid = low + (high - low) // 2\n        status = valid(mid, arr, total)\n        if status != -1:\n            ans = status\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)", "import sys\nint1 = lambda x: int(x) - 1\npDB = lambda *x: print(*x, end='\\n', file=sys.stderr)\np2D = lambda x: print(*x, sep='\\n', end='\\n\\n', file=sys.stderr)\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef LI1():\n    return list(map(int1, sys.stdin.readline().split()))\n\ndef LLI1(rows_number):\n    return [LI1() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline().rstrip()\ndij = [(0, 1), (-1, 0), (0, -1), (1, 0)]\ninf = 18446744073709551615\nmd = 10 ** 9 + 7\n\ndef solve():\n\n    def binary_search(l, r, ok, minimize):\n        if minimize:\n            l -= 1\n        else:\n            r += 1\n        while l + 1 < r:\n            m = (l + r) // 2\n            if ok(m) ^ minimize:\n                l = m\n            else:\n                r = m\n        if minimize:\n            return r\n        return l\n\n    def ok(v):\n        if v * n < s:\n            return False\n        t = v * n\n        for i in range(mid, n):\n            t -= max(v, aa[i])\n        return t >= pre\n    n = II()\n    aa = LI()\n    mid = (n - 1) // 2\n    aa.sort()\n    pre = sum(aa[:mid])\n    s = sum(aa)\n    m = aa[mid]\n    v = binary_search(m, 10 ** 9 + 5, ok, True)\n    ans = v * n - s\n    print(ans)\nfor _ in range(II()):\n    solve()", "def findMedian(A):\n    return A[(len(A) - 1) // 2]\n\ndef isX(A, X):\n    summ = 0\n    for i in range(len(A)):\n        if i < (len(A) - 1) // 2:\n            summ += A[i]\n        else:\n            summ += max(X, A[i])\n    return summ <= len(A) * X\nfor t in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    sumA = sum(A)\n    originalMedian = findMedian(A)\n    if originalMedian * N >= sumA:\n        print(originalMedian * N - sumA)\n    else:\n        l = int(originalMedian)\n        r = max(A)\n        while r - l > 1:\n            mid = (l + r) // 2\n            if isX(A, mid):\n                r = int(mid)\n            else:\n                l = int(mid)\n        print(r * N - sumA)", "from math import ceil\n\ndef is_feasible(ans, arr):\n    n = len(arr)\n    median_pos = n // 2\n    if n % 2 == 0:\n        median_pos -= 1\n    if arr[median_pos] > ans:\n        return False\n    req = n * ans - sum(arr)\n    moves = 0\n    for i in range(median_pos, len(arr)):\n        if arr[i] < ans:\n            moves += ans - arr[i]\n    if moves > req:\n        return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    MAX = 10 ** 9 + 1\n    arr = list(sorted(map(int, input().split())))\n    l = 0\n    fin_ans = MAX\n    while l <= MAX:\n        ans = (l + MAX) // 2\n        if is_feasible(ans, arr):\n            fin_ans = min(fin_ans, ans)\n            MAX = ans - 1\n        else:\n            l = ans + 1\n    print(n * fin_ans - sum(arr))", "def check(arr, s, n, x):\n    op1 = x * n - s\n    if op1 < 0:\n        return -1\n    op2 = 0\n    for i in range((n - 1) // 2, n):\n        op2 += max(x - arr[i], 0)\n    if op2 > op1:\n        return -1\n    return op1\nfor t in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    s = sum(arr)\n    (low, high) = (arr[(n - 1) // 2], 10 ** 9)\n    ans = 0\n    while low <= high:\n        md = (low + high) // 2\n        val = check(arr, s, n, md)\n        if val != -1:\n            ans = val\n            high = md - 1\n        else:\n            low = md + 1\n    print(ans)", "def check(A, N, x):\n    meanop = N * x - sum(A)\n    if meanop < 0:\n        return -1\n    medianop = 0\n    for i in range((N - 1) // 2, N):\n        medianop += max(0, x - A[i])\n    if medianop > meanop:\n        return -1\n    return meanop\n\ndef solve(A, N):\n    A.sort()\n    (low, high, ans) = (A[(N - 1) // 2], 10 ** 9 + 10, -1)\n    while low <= high:\n        mid = low + (high - low) // 2\n        minop = check(A, N, mid)\n        if minop != -1:\n            ans = minop\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = list(map(int, input().split()))\n    solve(A, N)", "for _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    s = sum(A)\n    low = A[(n - 1) // 2]\n    high = 10 ** 9\n    ans = 10 ** 9\n    while low <= high:\n        k = (low + high) // 2\n        mean = k * n - s\n        median = 0\n        for i in range((n - 1) // 2, n):\n            median += max(0, k - A[i])\n        if mean >= median:\n            ans = mean\n            high = k - 1\n        else:\n            low = k + 1\n    print(ans)", "import math\n\ndef check(mean):\n    req_op = mean * n - s\n    idx = (n - 1) // 2\n    if l[idx] > mean:\n        return False\n    r = mean - l[idx]\n    for i in range(idx + 1, n):\n        if l[i] < mean:\n            r += mean - l[i]\n    return r <= req_op\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    l.sort()\n    s = sum(l)\n    res = 10 ** 18\n    low = 1\n    high = 10 ** 24\n    while low <= high:\n        mid = (low + high) // 2\n        if check(mid):\n            res = min(res, mid * n - s)\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(res)", "import sys\ninput = sys.stdin.readline\n\ndef valid(k, arr, total):\n    mean_op = k * len(arr) - total\n    median_op = 0\n    n = len(arr)\n    for i in range((n - 1) // 2, n):\n        median_op += max(0, k - arr[i])\n    if mean_op >= median_op:\n        return mean_op\n    return -1\nfor t in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    low = arr[(n - 1) // 2]\n    high = 10 ** 9\n    ans = -1\n    total = sum(arr)\n    while low <= high:\n        mid = low + (high - low) // 2\n        status = valid(mid, arr, total)\n        if status != -1:\n            ans = status\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)", "from bisect import bisect\nfor tcase in range(int(input())):\n    n = int(input())\n    a = sorted(map(int, input().split()))\n    s = [0]\n    for x in a:\n        s.append(s[-1] + x)\n    im = (n - 1) // 2\n    (l, r) = (a[im], a[n - 1])\n    while l < r:\n        m = (l + r) // 2\n        i = bisect(a, m)\n        x = m * (i - im) - (s[i] - s[im])\n        if m * n < s[n] + x:\n            l = m + 1\n        else:\n            r = m\n    print(l * n - s[n])", "for _ in range(int(input())):\n    n = int(input())\n    arr = [int(x) for x in input().split(' ')]\n    arr.sort()\n    s = sum(arr)\n    mean = s / n\n    med = arr[(n - 1) // 2]\n    if med == mean:\n        print(0)\n        continue\n\n    def check(k):\n        meanop = k * n - s\n        medop = 0\n        for i in range((n - 1) // 2, n):\n            if arr[i] < k:\n                medop += k - arr[i]\n            else:\n                break\n        if meanop >= medop:\n            return meanop\n        return -1\n    l = med\n    h = arr[-1]\n    ans = 0\n    while l <= h:\n        mid = l + (h - l) // 2\n        a = check(mid)\n        if a == -1:\n            l = mid + 1\n        else:\n            ans = a\n            h = mid - 1\n    print(ans)", "from math import ceil\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    idx = (n - 1) // 2\n    s = 0\n    for i in range(n):\n        s += arr[i] - arr[idx]\n    if s <= 0:\n        print(abs(s))\n    else:\n        x = sum(arr)\n        low = 0\n        high = 10 ** 9 + 1\n        ans = 0\n        while low <= high:\n            mid = (low + high) // 2\n            s = 0\n            for el in arr[idx:]:\n                s += max(0, mid - el)\n            if arr[idx] <= mid and s <= mid * n - x:\n                ans = mid * n - x\n                high = mid - 1\n            else:\n                low = mid + 1\n        print(ans)", "def check(mean):\n    req_op = mean * n - cur_sum\n    idx = (n - 1) // 2\n    if a[idx] > mean:\n        return False\n    r = mean - a[idx]\n    for i in range(idx + 1, n):\n        if a[i] < mean:\n            r += mean - a[i]\n    return r <= req_op\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    cur_sum = sum(a)\n    ans = 10 ** 18\n    (low, high) = (1, 10 ** 24)\n    while low <= high:\n        mid = (low + high) // 2\n        if check(mid):\n            ans = min(ans, mid * n - cur_sum)\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)", "from sys import stdin\ninput = stdin.readline\n\ndef check(x):\n    ans = 0\n    for i in range(middle, n):\n        ans += max(0, x - a[i])\n    if n * x < s + ans:\n        return -1\n    return n * x - (s + ans) + ans\n\ndef answer():\n    s = sum(a)\n    (l, h) = (a[middle], a[-1])\n    while l <= h:\n        mid = (l + h) // 2\n        value = check(mid)\n        if value != -1:\n            ans = value\n            h = mid - 1\n        else:\n            l = mid + 1\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    a = sorted(list(map(int, input().split())))\n    s = sum(a)\n    middle = n // 2\n    if n & 1 == 0:\n        middle -= 1\n    print(answer())", "def possible(rmd):\n    rs = n * rmd\n    cs = s\n    for j in range(md, n):\n        cs += max(rmd - a[j], 0)\n    if rs < cs:\n        return (False, -1)\n    return (True, rs - s)\nfor i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = sum(a)\n    a.sort()\n    ans = float('inf')\n    if n & 1:\n        md = n // 2\n    else:\n        md = n // 2 - 1\n    md2 = s // n\n    mod = s % n\n    if mod != 0:\n        md2 += 1\n    l = max(a[md], md2)\n    r = a[-1]\n    p = 0\n    while l <= r:\n        mid = l + (r - l) // 2\n        check = possible(mid)\n        if check[0]:\n            if ans > check[1]:\n                ans = check[1]\n                p = mid\n            r = mid - 1\n        else:\n            l = mid + 1\n    print(ans)", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n\n    def check(a, b):\n        if l[n // 2 - (n % 2 == 0)] > a:\n            return False\n        for i in range(n // 2 - (n % 2 == 0), n):\n            if l[i] < a:\n                need = a - l[i]\n                if need > b:\n                    return False\n                b -= need\n            else:\n                return True\n        return b >= 0\n    n = inp()\n    l = li()\n    s = sum(l)\n    l.sort()\n    if s % n == 0 and l[n // 2 - (n % 2 == 0)] == s // n:\n        print(0)\n        return\n    low = 1\n    ans = 0\n    high = mod * mod\n    S = s\n    s = n - s % n\n    while low <= high:\n        mid = (low + high) // 2\n        new_s = mid * n\n        if new_s < S:\n            low = mid + 1\n            continue\n        median = mid\n        temp = new_s - S\n        if check(median, temp):\n            ans = temp\n            high = mid - 1\n        else:\n            low = mid + 1\n    pr(ans)\nfor _ in range(inp()):\n    solve()", "import sys\nint1 = lambda x: int(x) - 1\npDB = lambda *x: print(*x, end='\\n', file=sys.stderr)\np2D = lambda x: print(*x, sep='\\n', end='\\n\\n', file=sys.stderr)\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef LI1():\n    return list(map(int1, sys.stdin.readline().split()))\n\ndef LLI1(rows_number):\n    return [LI1() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline().rstrip()\ndij = [(0, 1), (-1, 0), (0, -1), (1, 0)]\ninf = 18446744073709551615\nmd = 10 ** 9 + 7\n\ndef solve():\n\n    def binary_search(l, r, ok, minimize):\n        if minimize:\n            l -= 1\n        else:\n            r += 1\n        while l + 1 < r:\n            m = (l + r) // 2\n            if ok(m) ^ minimize:\n                l = m\n            else:\n                r = m\n        if minimize:\n            return r\n        return l\n\n    def ok(v):\n        if v * n < s:\n            return False\n        t = v * n\n        for i in range(mid, n):\n            t -= max(v, aa[i])\n        return t >= pre\n    n = II()\n    aa = LI()\n    mid = (n - 1) // 2\n    aa.sort()\n    pre = sum(aa[:mid])\n    s = sum(aa)\n    m = aa[mid]\n    v = binary_search(m, 10 ** 9 + 5, ok, True)\n    ans = v * n - s\n    print(ans)\nfor _ in range(II()):\n    solve()", "import sys\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom collections import deque\nfrom queue import PriorityQueue as pq\nfrom math import gcd\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nlii = lambda : list(map(int, list(ip())))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\ninv = lambda x: pow(x, mod - 2, mod)\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\nmod = 10 ** 9 + 7\nmod1 = 998244353\nfor _ in range(ii()):\n    n = ii()\n    a = il()\n    a.sort()\n    x = a[n // 2 - (1 - n % 2)]\n    y = sum(a) / n\n    if x == y:\n        print(0)\n        continue\n    if y < x:\n        print(x * n - sum(a))\n        continue\n    l = 1\n    h = 10 ** 15\n    s = sum(a)\n    b = [0 for i in range(n)]\n    ans = -1\n    while l <= h:\n        m = (l + h) // 2\n        t1 = m * n - s\n        t = 0\n        for i in range(n // 2 - (1 - n % 2), n):\n            if a[i] < m:\n                t += m - a[i]\n        if t <= t1:\n            ans = t1\n            h = m - 1\n        else:\n            l = m + 1\n    print(ans)"]