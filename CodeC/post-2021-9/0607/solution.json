["import bisect\n\ndef LII():\n    return [int(x) for x in input().split()]\n\ndef longest_incr_length(s):\n    vec_last = []\n    for x in s:\n        i = bisect.bisect_left(vec_last, x)\n        if i != len(vec_last):\n            vec_last[i] = x\n        else:\n            vec_last.append(x)\n    return len(vec_last)\nfor _ in range(int(input())):\n    (n, m, k) = LII()\n    specials = []\n    for __ in range(k):\n        (sx, sy) = LII()\n        if sx != n and sy != m:\n            specials.append((sx, sy))\n    specials.sort(key=lambda p: (p[0], -p[1]))\n    max_spec = longest_incr_length([y for (x, y) in specials])\n    print(m + n - 2 - max_spec)", "import bisect\n\ndef LII():\n    return [int(x) for x in input().split()]\n\ndef longest_incr_length(s):\n    vec_last = []\n    for x in s:\n        i = bisect.bisect_left(vec_last, x)\n        if i != len(vec_last):\n            vec_last[i] = x\n        else:\n            vec_last.append(x)\n    return len(vec_last)\nfor _ in range(int(input())):\n    (n, m, k) = LII()\n    specials = []\n    for __ in range(k):\n        (sx, sy) = LII()\n        if sx != n and sy != m:\n            specials.append((sx, sy))\n    specials.sort(key=lambda p: (p[0], -p[1]))\n    max_spec = longest_incr_length([y for (x, y) in specials])\n    print(m + n - 2 - max_spec)", "from sys import stdin\ninput = stdin.readline\n\ndef lis(nums, cmp=lambda x, y: x < y):\n    P = [0] * len(nums)\n    M = [0] * (len(nums) + 1)\n    L = 0\n    for i in range(len(nums)):\n        (lo, hi) = (1, L)\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if cmp(nums[M[mid]], nums[i]):\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        newL = lo\n        P[i] = M[newL - 1]\n        M[newL] = i\n        L = max(L, newL)\n    S = [0] * L\n    k = M[L]\n    for i in range(L - 1, -1, -1):\n        (S[i], k) = (nums[k], P[k])\n    return S\n\ndef solve(N, M, specials):\n    specials = [(X, -Y) for (X, Y) in specials]\n    specials = sorted(specials)\n    specials = [-Y for (X, Y) in specials]\n    return N + M - 2 - len(lis(specials))\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    (N, M, K) = [int(x) for x in input().strip().split()]\n    specials = set()\n    for i in range(K):\n        (X, Y) = [int(x) for x in input().strip().split()]\n        if X < N and Y < M:\n            specials.add((X, Y))\n    print(solve(N, M, specials))", "from bisect import bisect_left\n\ndef lis(a):\n    s = []\n    for el in a:\n        if not s:\n            s.append(el)\n        else:\n            ind = bisect_left(s, el)\n            if ind == len(s):\n                s.append(el)\n            else:\n                s[ind] = el\n    return len(s)\nfor _ in range(int(input())):\n    (m, n, q) = map(int, input().split())\n    if q == 0:\n        print(m - 1 + n - 1)\n    else:\n        ans = m - 1 + n - 1\n        points = []\n        for _ in range(q):\n            points.append(list(map(int, input().split())))\n        points.sort(key=lambda x: (x[0], -x[1]))\n        t = [b for (a, b) in points if a < m and b < n]\n        print(n + m - 2 - lis(t))", "import bisect\n\ndef solve():\n    (n, m, k) = map(int, input().split())\n    tiles = []\n    for _ in range(k):\n        (l, w) = map(int, input().split())\n        if l == n or w == m:\n            k -= 1\n        else:\n            tiles.append((l, w))\n    tiles.sort(key=lambda x: (x[0], -x[1]))\n    lis = []\n    for (l, w) in tiles:\n        pos = bisect.bisect_left(lis, w)\n        if pos == len(lis):\n            lis.append(w)\n        else:\n            lis[pos] = w\n    print(n + m - 2 - len(lis))\nt = int(input())\nfor _ in range(t):\n    solve()", "def lis(nums, cmp=lambda x, y: x < y):\n    P = [0] * len(nums)\n    M = [0] * (len(nums) + 1)\n    L = 0\n    for i in range(len(nums)):\n        (lo, hi) = (1, L)\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if cmp(nums[M[mid]], nums[i]):\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        newL = lo\n        P[i] = M[newL - 1]\n        M[newL] = i\n        L = max(L, newL)\n    S = [0] * L\n    k = M[L]\n    for i in range(L - 1, -1, -1):\n        (S[i], k) = (nums[k], P[k])\n    return S\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    cells = []\n    for i in range(k):\n        (x, y) = map(int, input().split())\n        if x < n and y < m:\n            cells.append([x, -y])\n    cells.sort()\n    vals = []\n    for (x, y) in cells:\n        vals.append(-y)\n    print(n - 1 + m - 1 - len(lis(vals)))", "for _ in range(int(input())):\n    [n, m, k] = list(map(int, input().split()))\n    tot = (m - 1) * (n - 1)\n    arr = []\n    for i in range(k):\n        [a, b] = list(map(int, input().split()))\n        if a < n and b < m:\n            arr.append((a, b))\n    arr.sort(key=lambda x: (x[0], -1 * x[1]))\n    import bisect\n    x = []\n    for i in arr:\n        k = len(x)\n        temp = bisect.bisect_left(x, i[1])\n        if temp == k:\n            x.append(i[1])\n        else:\n            x[temp] = i[1]\n    print(m + n - 2 - len(x))", "for _ in range(int(input())):\n    [n, m, k] = list(map(int, input().split()))\n    tot = (m - 1) * (n - 1)\n    arr = []\n    for i in range(k):\n        [a, b] = list(map(int, input().split()))\n        if a < n and b < m:\n            arr.append((a, b))\n    arr.sort(key=lambda x: (x[0], -1 * x[1]))\n    import bisect\n    x = []\n    for i in arr:\n        k = len(x)\n        temp = bisect.bisect_left(x, i[1])\n        if temp == k:\n            x.append(i[1])\n        else:\n            x[temp] = i[1]\n    print(m + n - 2 - len(x))", "def lis(nums, cmp=lambda x, y: x < y):\n    P = [0] * len(nums)\n    M = [0] * (len(nums) + 1)\n    L = 0\n    for i in range(len(nums)):\n        (lo, hi) = (1, L)\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if cmp(nums[M[mid]], nums[i]):\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        newL = lo\n        P[i] = M[newL - 1]\n        M[newL] = i\n        L = max(L, newL)\n    S = [0] * L\n    k = M[L]\n    for i in range(L - 1, -1, -1):\n        (S[i], k) = (nums[k], P[k])\n    return S\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    cells = []\n    for i in range(k):\n        (x, y) = map(int, input().split())\n        if x < n and y < m:\n            cells.append([x, -y])\n    cells.sort()\n    vals = []\n    for (x, y) in cells:\n        vals.append(-y)\n    print(n - 1 + m - 1 - len(lis(vals)))"]