["import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom queue import PriorityQueue\nfrom queue import Queue\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nimport random\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\ngp = []\nans = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\n\ndef flip(a, l, r):\n    for i in range(l, r):\n        a[i] = '0' if a[i] == '1' else '1'\n    return\n\ndef hnbhai(tc):\n    n = sb()\n    a = sd()\n    a.sort()\n    prefix = [0] * n\n    for i in range(n):\n        prefix[i] = a[i]\n        if i > 0:\n            prefix[i] += prefix[i - 1]\n    dp = [-1] * n\n    dp[n - 1] = 0\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            dp[i] = max(dp[i], dp[j] + (prefix[j - 1] if j - 1 >= 0 else 0) - prefix[i] + a[j] % a[i])\n    print(dp[0] + a[0])\n    return\nfor _ in range(sb()):\n    hnbhai(_ + 1)", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\nfrom queue import PriorityQueue\nfrom queue import Queue\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nimport random\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\na = []\n(n, k) = (0, 0)\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\ngp = []\nans = []\n\ndef update_it(bit, i, val):\n    n = len(bit)\n    while i < n:\n        bit[i] += val\n        i += i & -i\n\ndef get_ans(bit, i):\n    n = len(bit)\n    tot = 0\n    while i > 0:\n        tot += bit[i]\n        i -= i & -i\n    return tot\n\ndef flip(a, l, r):\n    for i in range(l, r):\n        a[i] = '0' if a[i] == '1' else '1'\n    return\n\ndef hnbhai(tc):\n    n = sb()\n    a = sd()\n    a.sort()\n    prefix = [0] * n\n    for i in range(n):\n        prefix[i] = a[i]\n        if i > 0:\n            prefix[i] += prefix[i - 1]\n    dp = [-1] * n\n    dp[n - 1] = 0\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            dp[i] = max(dp[i], dp[j] + (prefix[j - 1] if j - 1 >= 0 else 0) - prefix[i] + a[j] % a[i])\n    print(dp[0] + a[0])\n    return\nfor _ in range(sb()):\n    hnbhai(_ + 1)"]