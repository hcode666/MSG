["from collections import deque\n\ndef topoSort(V, adj):\n    q = deque()\n    indegree = [0] * (V + 1)\n    for i in range(1, V + 1):\n        for j in adj[i]:\n            indegree[j] += 1\n    for i in range(1, V + 1):\n        if indegree[i] == 0:\n            q.append(i)\n    arr = []\n    while q:\n        node = q.popleft()\n        indegree[node] -= 1\n        arr.append(node)\n        for k in adj[node]:\n            indegree[k] -= 1\n            if indegree[k] == 0:\n                q.append(k)\n    for i in indegree:\n        if i > 0:\n            return False\n    return True\n\ndef solve(n, m, adj):\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1\nfor test in range(int(input())):\n    n = int(input())\n    m = int(input())\n    adj = []\n    for i in range(n + 1):\n        adj.append([])\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        adj[x].append(y)\n    print(solve(n, m, adj))", "from collections import deque\n\ndef topoSort(V, adj):\n    q = deque()\n    indegree = [0] * (V + 1)\n    for i in range(1, V + 1):\n        for j in adj[i]:\n            indegree[j] += 1\n    for i in range(1, V + 1):\n        if indegree[i] == 0:\n            q.append(i)\n    arr = []\n    while q:\n        node = q.popleft()\n        indegree[node] -= 1\n        arr.append(node)\n        for k in adj[node]:\n            indegree[k] -= 1\n            if indegree[k] == 0:\n                q.append(k)\n    for i in indegree:\n        if i > 0:\n            return False\n    return True\n\ndef solve(n, m, adj):\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1\nfor test in range(int(input())):\n    n = int(input())\n    m = int(input())\n    adj = []\n    for i in range(n + 1):\n        adj.append([])\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        adj[x].append(y)\n    print(solve(n, m, adj))", "from collections import deque\n\ndef topoSort(V, adj):\n    q = deque()\n    indegree = [0] * (V + 1)\n    for i in range(1, V + 1):\n        for j in adj[i]:\n            indegree[j] += 1\n    for i in range(1, V + 1):\n        if indegree[i] == 0:\n            q.append(i)\n    arr = []\n    while q:\n        node = q.popleft()\n        indegree[node] -= 1\n        arr.append(node)\n        for k in adj[node]:\n            indegree[k] -= 1\n            if indegree[k] == 0:\n                q.append(k)\n    for i in indegree:\n        if i > 0:\n            return False\n    return True\n\ndef solve(n, m, adj):\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1\nfor test in range(int(input())):\n    n = int(input())\n    m = int(input())\n    adj = []\n    for i in range(n + 1):\n        adj.append([])\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        adj[x].append(y)\n    print(solve(n, m, adj))", "def dfs(graph, cr, vi, st):\n    vi[cr] = st[cr] = True\n    for i in graph.get(cr, []):\n        if st[i]:\n            return True\n        if vi[i]:\n            continue\n        if dfs(graph, i, vi, st):\n            return True\n    st[cr] = False\n    return False\n\ndef hascycle(graph, n):\n    vi = [False] * n\n    st = [False] * n\n    for i in range(n):\n        if vi[i]:\n            continue\n        if dfs(graph, i, vi, st):\n            return True\n    return False\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    e = int(input())\n    graph = {}\n    for i in range(e):\n        (l, r) = map(int, input().split())\n        graph[l - 1] = graph.get(l - 1, []) + [r - 1]\n    if hascycle(graph, n):\n        print(-1)\n        continue\n    count = 0\n    for i in range(n):\n        if not graph.get(i, []):\n            count += 1\n    print(count - 1)", "def dfs(graph, cr, vi, st):\n    vi[cr] = st[cr] = True\n    for i in graph.get(cr, []):\n        if st[i]:\n            return True\n        if vi[i]:\n            continue\n        if dfs(graph, i, vi, st):\n            return True\n    st[cr] = False\n    return False\n\ndef hascycle(graph, n):\n    vi = [False] * n\n    st = [False] * n\n    for i in range(n):\n        if vi[i]:\n            continue\n        if dfs(graph, i, vi, st):\n            return True\n    return False\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    e = int(input())\n    graph = {}\n    for i in range(e):\n        (l, r) = map(int, input().split())\n        graph[l - 1] = graph.get(l - 1, []) + [r - 1]\n    if hascycle(graph, n):\n        print(-1)\n        continue\n    count = 0\n    for i in range(n):\n        if not graph.get(i, []):\n            count += 1\n    print(count - 1)", "for _ in range(int(input())):\n    n = int(input())\n    m = int(input())\n    d = [[] for i in range(n + 1)]\n    inc = [0 for i in range(n + 1)]\n    for i in range(m):\n        (a, b) = map(int, input().split())\n        d[a].append(b)\n        inc[b] += 1\n    c = 0\n    ans = 0\n    q = list()\n    for i in range(1, n + 1):\n        if inc[i] == 0:\n            q.append(i)\n        if len(d[i]) == 0:\n            ans += 1\n    while len(q) > 0:\n        c += 1\n        i = q.pop(0)\n        for x in d[i]:\n            inc[x] -= 1\n            if inc[x] == 0:\n                q.append(x)\n    if c != n:\n        print(-1)\n    else:\n        print(ans - 1)", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random, threading\nfrom functools import lru_cache\nfrom itertools import *\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n(M, M1) = (1000000007, 998244353)\n\ndef dfs(curr, col, d):\n    col[curr] = 1\n    for j in d[curr]:\n        if col[j] == 0:\n            if dfs(j, col, d):\n                return True\n        elif col[j] == 1:\n            return True\n    col[curr] = 2\n    return False\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for _ in range(1, how_much_noob_I_am + 1):\n        n = inpu()\n        m = inpu()\n        d = defaultdict(list)\n        for i in range(m):\n            (a, b) = sep()\n            d[a].append(b)\n        col = [0] * (n + 1)\n        for i in range(1, n + 1):\n            if col[i] == 0:\n                if dfs(i, col, d):\n                    print(-1)\n                    break\n        else:\n            ans = 0\n            for i in range(1, n + 1):\n                if len(d[i]) == 0:\n                    ans += 1\n            print(ans - 1)\nmain()", "import collections\ntestcase = int(input())\nwhile testcase:\n    testcase -= 1\n    n = int(input())\n    m = int(input())\n    graph = []\n    for i in range(n + 1):\n        graph.append([])\n    for i in range(m):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n    q = []\n    indegree = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            indegree[j] += 1\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            q.append(i)\n    ct = 0\n    while q:\n        x = q.pop()\n        ct += 1\n        for it in graph[x]:\n            indegree[it] -= 1\n            if indegree[it] == 0:\n                q.append(it)\n    if ct != n:\n        print(-1)\n    else:\n        ans = 0\n        for i in range(1, n + 1):\n            if len(graph[i]) == 0:\n                ans += 1\n        print(ans - 1)", "import collections\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    m = int(input())\n    graph = collections.defaultdict(set)\n    for i in range(m):\n        (a, b) = map(int, input().split())\n        graph[a].add(b)\n    q = []\n    indegree = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            indegree[j] += 1\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            q.append(i)\n    ct = 0\n    while q:\n        x = q.pop()\n        ct += 1\n        for k in graph[x]:\n            indegree[k] -= 1\n            if indegree[k] == 0:\n                q.append(k)\n    if ct == n:\n        ans = 0\n        for i in range(1, n + 1):\n            if len(graph[i]) == 0:\n                ans += 1\n        print(ans - 1)\n    else:\n        print(-1)"]