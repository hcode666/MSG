["import math, bisect, heapq, random, sys, itertools\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\np2 = [1]\nfor i in range(70):\n    p2.append(p2[-1] * 2)\np = 10 ** 9 + 7\nANS = []\nfor t in range(int(input())):\n    (n,) = ints()\n    a = ints()\n    inds = [i for i in range(n)]\n    rn = 1000\n    v = 0\n    for i in range(rn):\n        (p, q, r, s) = random.sample(inds, 4)\n        x = a[p] ^ a[q]\n        y = a[r] ^ a[s]\n        (c1, c2) = (0, 0)\n        while x:\n            if x % 2:\n                c1 += 1\n            x //= 2\n        while y:\n            if y % 2:\n                c2 += 1\n            y //= 2\n        if c1 == c2:\n            v = 1\n            break\n    if v:\n        print(p + 1, q + 1, r + 1, s + 1)\n    else:\n        print(-1)", "import math, bisect, heapq, random, sys, itertools\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\np2 = [1]\nfor i in range(70):\n    p2.append(p2[-1] * 2)\np = 10 ** 9 + 7\nANS = []\nfor t in range(int(input())):\n    (n,) = ints()\n    a = ints()\n    inds = [i for i in range(n)]\n    rn = 1000\n    v = 0\n    for i in range(rn):\n        (p, q, r, s) = random.sample(inds, 4)\n        x = a[p] ^ a[q]\n        y = a[r] ^ a[s]\n        (c1, c2) = (0, 0)\n        while x:\n            if x % 2:\n                c1 += 1\n            x //= 2\n        while y:\n            if y % 2:\n                c2 += 1\n            y //= 2\n        if c1 == c2:\n            v = 1\n            break\n    if v:\n        print(p + 1, q + 1, r + 1, s + 1)\n    else:\n        print(-1)", "import math, bisect, heapq, random, sys, itertools\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\np2 = [1]\nfor i in range(70):\n    p2.append(p2[-1] * 2)\np = 10 ** 9 + 7\nANS = []\nfor t in range(int(input())):\n    (n,) = ints()\n    a = ints()\n    inds = [i for i in range(n)]\n    rn = 1000\n    v = 0\n    for i in range(rn):\n        (p, q, r, s) = random.sample(inds, 4)\n        x = a[p] ^ a[q]\n        y = a[r] ^ a[s]\n        (c1, c2) = (0, 0)\n        while x:\n            if x % 2:\n                c1 += 1\n            x //= 2\n        while y:\n            if y % 2:\n                c2 += 1\n            y //= 2\n        if c1 == c2:\n            v = 1\n            break\n    if v:\n        print(p + 1, q + 1, r + 1, s + 1)\n    else:\n        print(-1)", "import math, bisect, heapq, random, sys, itertools\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\np2 = [1]\nfor i in range(70):\n    p2.append(p2[-1] * 2)\np = 10 ** 9 + 7\nANS = []\nfor t in range(int(input())):\n    (n,) = ints()\n    a = ints()\n    inds = [i for i in range(n)]\n    rn = 1000\n    v = 0\n    for i in range(rn):\n        (p, q, r, s) = random.sample(inds, 4)\n        x = a[p] ^ a[q]\n        y = a[r] ^ a[s]\n        (c1, c2) = (0, 0)\n        while x:\n            if x % 2:\n                c1 += 1\n            x //= 2\n        while y:\n            if y % 2:\n                c2 += 1\n            y //= 2\n        if c1 == c2:\n            v = 1\n            break\n    if v:\n        print(p + 1, q + 1, r + 1, s + 1)\n    else:\n        print(-1)", "import collections\nfrom collections import defaultdict\n\ndef pop(x):\n    return bin(x).count('1')\n\ndef fun():\n    for i1 in range(n - 3):\n        for i2 in range(i1 + 1, n - 2):\n            for i3 in range(i2 + 1, n - 1):\n                for i4 in range(i3 + 1, n):\n                    if pop(a[i1] ^ a[i2]) == pop(a[i3] ^ a[i4]):\n                        return [i1, i2, i3, i4]\n                    if pop(a[i1] ^ a[i3]) == pop(a[i2] ^ a[i4]):\n                        return [i1, i3, i2, i4]\n                    if pop(a[i1] ^ a[i4]) == pop(a[i3] ^ a[i2]):\n                        return [i1, i4, i3, i2]\n    return -1\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    if n >= 62:\n        d = defaultdict(lambda : [])\n        for i in range(0, n, 2):\n            tmp = pop(a[i] ^ a[i + 1])\n            d[tmp] += [i, i + 1]\n            if len(d[tmp]) > 2:\n                print(*[x + 1 for x in d[tmp]])\n                break\n    else:\n        tmp = fun()\n        if tmp == -1:\n            print(-1)\n        else:\n            print(*[x + 1 for x in tmp])", "co = lambda z: bin(z).count('1')\n\ndef bruteforce(n, a):\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                for l in range(n):\n                    net = set([i, j, k, l])\n                    if len(net) == 4:\n                        x = a[i] ^ a[j]\n                        y = a[k] ^ a[l]\n                        if co(x) == co(y):\n                            print(i + 1, j + 1, k + 1, l + 1)\n                            return\n    print(-1)\n    return\n\ndef solve(n, a):\n    net = [-1] * 32\n    for i in range(0, n - 1, 2):\n        k = co(a[i] ^ a[i + 1])\n        if net[k] != -1:\n            print(i + 1, i + 2, net[k] + 1, net[k] + 2)\n            return\n        net[k] = i\nfor _ in range(int(input())):\n    n = int(input())\n    a = tuple(map(int, input().split()))\n    if n <= 62:\n        bruteforce(n, a)\n    else:\n        solve(n, a)", "co = lambda z: bin(z).count('1')\nfor _ in range(int(input())):\n\n    def bruteforce(n, a):\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    for l in range(n):\n                        net = set([i, j, k, l])\n                        if len(net) == 4:\n                            x = a[i] ^ a[j]\n                            y = a[k] ^ a[l]\n                            if co(x) == co(y):\n                                print(i + 1, j + 1, k + 1, l + 1)\n                                return\n        print(-1)\n        return\n\n    def solve(n, a):\n        net = [-1] * 32\n        for i in range(0, n - 1, 2):\n            k = co(a[i] ^ a[i + 1])\n            if net[k] != -1:\n                print(i + 1, i + 2, net[k] + 1, net[k] + 2)\n                return\n            net[k] = i\n    n = int(input())\n    a = tuple(map(int, input().split()))\n    if n <= 62:\n        bruteforce(n, a)\n    else:\n        solve(n, a)", "for _ in range(int(input())):\n    co = lambda z: bin(z).count('1')\n\n    def bruteforce(n, a):\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    for l in range(n):\n                        net = set([i, j, k, l])\n                        if len(net) == 4:\n                            x = a[i] ^ a[j]\n                            y = a[k] ^ a[l]\n                            if co(x) == co(y):\n                                print(i + 1, j + 1, k + 1, l + 1)\n                                return\n        print(-1)\n        return\n\n    def solve(n, a):\n        net = [-1] * 32\n        for i in range(0, n - 1, 2):\n            k = co(a[i] ^ a[i + 1])\n            if net[k] != -1:\n                print(i + 1, i + 2, net[k] + 1, net[k] + 2)\n                return\n            net[k] = i\n    n = int(input())\n    a = tuple(map(int, input().split()))\n    if n <= 62:\n        bruteforce(n, a)\n    else:\n        solve(n, a)", "def brutef(A):\n    c = 0\n    for i in range(0, len(A)):\n        for j in range(i + 1, len(A)):\n            for k in range(i + 1, len(A)):\n                if k == j:\n                    continue\n                for l in range(k + 1, len(A)):\n                    if l == j:\n                        continue\n                    if bin(A[i] ^ A[j]).count('1') == bin(A[k] ^ A[l]).count('1'):\n                        c = 1\n                        print(i + 1, '', j + 1, '', k + 1, '', l + 1)\n                        break\n                if c == 1:\n                    break\n            if c == 1:\n                break\n        if c == 1:\n            break\n    if c != 1:\n        print(-1)\n\ndef eff(A):\n    v = []\n    for i in range(31):\n        v.append(-1)\n    for i in range(0, len(A) - 1, 2):\n        x = bin(A[i] ^ A[i + 1]).count('1')\n        if v[x] != -1:\n            print(v[x] + 1, '', v[x] + 2, '', i + 1, '', i + 2)\n            break\n        else:\n            v[x] = i\nT = int(input())\nfor cases in range(T):\n    N = int(input())\n    A = list(map(int, input().split()))\n    if N <= 64:\n        brutef(A)\n    else:\n        eff(A)", "def solve1(a):\n    v = {}\n    for i in range(0, len(a), 2):\n        x = popcount(a[i] ^ a[i + 1])\n        if x not in v:\n            v[x] = [i, i + 1]\n        elif x in v:\n            print(v[x].pop(0) + 1, v[x].pop(0) + 1, i + 1, i + 2)\n            return\n\ndef popcount(x):\n    count = 0\n    while x > 0:\n        if x & 1 == 1:\n            count = count + 1\n        x = x >> 1\n    return count\n\ndef solve2(a):\n    n = len(a)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(i + 1, n):\n                if j == k:\n                    continue\n                for l in range(k + 1, n):\n                    if j == l:\n                        continue\n                    if popcount(a[i] ^ a[j]) == popcount(a[k] ^ a[l]):\n                        print(i + 1, j + 1, k + 1, l + 1)\n                        return\n    print(-1)\nT = int(input())\nfor tc in range(T):\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    solve2(a)", "def solve1(a):\n    v = {}\n    for i in range(0, len(a), 2):\n        x = popcount(a[i] ^ a[i + 1])\n        if x not in v:\n            v[x] = [i, i + 1]\n        elif x in v:\n            print(v[x].pop(0) + 1, v[x].pop(0) + 1, i + 1, i + 2)\n            return\n\ndef popcount(x):\n    count = 0\n    while x > 0:\n        if x & 1 == 1:\n            count = count + 1\n        x = x >> 1\n    return count\n\ndef solve2(a):\n    n = len(a)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(i + 1, n):\n                if j == k:\n                    continue\n                for l in range(k + 1, n):\n                    if j == l:\n                        continue\n                    if popcount(a[i] ^ a[j]) == popcount(a[k] ^ a[l]):\n                        print(i + 1, j + 1, k + 1, l + 1)\n                        return\n    print(-1)\nT = int(input())\nfor tc in range(T):\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    if n >= 69:\n        solve1(a)\n    elif n < 69:\n        solve2(a)", "def solve1(a):\n    v = {}\n    for i in range(0, len(a), 2):\n        x = popcount(a[i] ^ a[i + 1])\n        if x not in v:\n            v[x] = [i, i + 1]\n        elif x in v:\n            print(v[x].pop(0) + 1, v[x].pop(0) + 1, i + 1, i + 2)\n            return\n\ndef popcount(x):\n    count = 0\n    while x > 0:\n        if x & 1 == 1:\n            count = count + 1\n        x = x >> 1\n    return count\n\ndef solve2(a):\n    n = len(a)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(i + 1, n):\n                if j == k:\n                    continue\n                for l in range(k + 1, n):\n                    if j == l:\n                        continue\n                    if popcount(a[i] ^ a[j]) == popcount(a[k] ^ a[l]):\n                        print(i + 1, j + 1, k + 1, l + 1)\n                        return\n    print(-1)\nT = int(input())\nfor tc in range(T):\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    if n >= 69:\n        solve1(a)\n    elif n < 69:\n        solve2(a)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline()\nstdint = lambda : int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nmod = 1000000007\n\ndef setbit(x):\n    ans = 0\n    while x:\n        x &= x - 1\n        ans += 1\n    return ans\n\ndef func():\n    n = inp()\n    sq = seq()\n    n = min(n, 32)\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                for l in range(n):\n                    if len(set([i, j, k, l])) == 4:\n                        if setbit(sq[i] ^ sq[j]) == setbit(sq[k] ^ sq[l]):\n                            print(i + 1, j + 1, k + 1, l + 1)\n                            return\n    print(-1)\nt = inp()\nfor i in range(t):\n    func()", "def popc(n):\n    c = 0\n    while n > 0:\n        c += 1\n        n = n & n - 1\n    return c\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    if n >= 64:\n        d = [[-1, -1] for i in range(31)]\n        if n % 2 != 0:\n            n = n - 1\n        for i in range(0, n, 2):\n            t = popc(l[i] ^ l[i + 1])\n            if d[t] != [-1, -1]:\n                print(d[t][0] + 1, d[t][1] + 1, i + 1, i + 2)\n                break\n            else:\n                d[t] = [i, i + 1]\n    else:\n        ans = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(i + 1, n):\n                    if j == k:\n                        continue\n                    for m in range(i + 1, n):\n                        if m == k or m == j:\n                            continue\n                        t1 = popc(l[i] ^ l[j])\n                        t2 = popc(l[k] ^ l[m])\n                        if t1 == t2:\n                            print(i + 1, j + 1, k + 1, m + 1)\n                            ans = True\n                            break\n                    if ans:\n                        break\n                if ans:\n                    break\n            if ans:\n                break\n        if not ans:\n            print(-1)", "import math, bisect, heapq, random, sys, itertools\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\np2 = [1]\nfor i in range(70):\n    p2.append(p2[-1] * 2)\np = 10 ** 9 + 7\nANS = []\nfor t in range(int(input())):\n    (n,) = ints()\n    a = ints()\n    inds = [i for i in range(n)]\n    rn = 1000\n    v = 0\n    for i in range(rn):\n        (p, q, r, s) = random.sample(inds, 4)\n        x = a[p] ^ a[q]\n        y = a[r] ^ a[s]\n        (c1, c2) = (0, 0)\n        while x:\n            if x % 2:\n                c1 += 1\n            x //= 2\n        while y:\n            if y % 2:\n                c2 += 1\n            y //= 2\n        if c1 == c2:\n            v = 1\n            break\n    if v:\n        print(p + 1, q + 1, r + 1, s + 1)\n    else:\n        print(-1)", "t = int(input())\nwhile t != 0:\n\n    def co(z):\n        return bin(z).count('1')\n\n    def bruteforce(n, a):\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    for l in range(n):\n                        net = set([i, j, k, l])\n                        if len(net) == 4:\n                            x = a[i] ^ a[j]\n                            y = a[k] ^ a[l]\n                            if co(x) == co(y):\n                                print(i + 1, j + 1, k + 1, l + 1)\n                                return\n        print(-1)\n        return\n\n    def solve(n, a):\n        net = [-1] * 32\n        for i in range(0, n - 1, 2):\n            k = co(a[i] ^ a[i + 1])\n            if net[k] != -1:\n                print(i + 1, i + 2, net[k] + 1, net[k] + 2)\n                return\n            net[k] = i\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n <= 62:\n        bruteforce(n, a)\n    else:\n        solve(n, a)\n    t -= 1", "t = int(input())\nwhile t != 0:\n\n    def co(z):\n        return bin(z).count('1')\n\n    def bruteforce(n, a):\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    for l in range(n):\n                        net = set([i, j, k, l])\n                        if len(net) == 4:\n                            x = a[i] ^ a[j]\n                            y = a[k] ^ a[l]\n                            if co(x) == co(y):\n                                print(i + 1, j + 1, k + 1, l + 1)\n                                return\n        print(-1)\n        return\n\n    def solve(n, a):\n        net = [-1] * 32\n        for i in range(0, n - 1, 2):\n            k = co(a[i] ^ a[i + 1])\n            if net[k] != -1:\n                print(i + 1, i + 2, net[k] + 1, net[k] + 2)\n                return\n            net[k] = i\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n <= 62:\n        bruteforce(n, a)\n    else:\n        solve(n, a)\n    t -= 1", "import math, bisect, heapq, random, sys, itertools\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\np2 = [1]\nfor i in range(70):\n    p2.append(p2[-1] * 2)\np = 10 ** 9 + 7\nANS = []\nfor t in range(int(input())):\n    (n,) = ints()\n    a = ints()\n    inds = [i for i in range(n)]\n    rn = 1000\n    v = 0\n    for i in range(rn):\n        (p, q, r, s) = random.sample(inds, 4)\n        x = a[p] ^ a[q]\n        y = a[r] ^ a[s]\n        (c1, c2) = (0, 0)\n        while x:\n            if x % 2:\n                c1 += 1\n            x //= 2\n        while y:\n            if y % 2:\n                c2 += 1\n            y //= 2\n        if c1 == c2:\n            v = 1\n            break\n    if v:\n        print(p + 1, q + 1, r + 1, s + 1)\n    else:\n        print(-1)"]