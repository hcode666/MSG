["from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\n\ndef dfs(p, prev, lvl):\n    for i in child[p]:\n        if i == prev:\n            continue\n        dfs(i, p, lvl + 1)\n    if lvl & 1:\n        a.append(abs(len(child[p]) - 2))\n\ndef answer():\n    if q == 1:\n        return sum(a)\n    else:\n        dp = 1\n        for i in range(len(a)):\n            dp |= dp << a[i]\n        total = sum(a)\n        ans = float('inf')\n        for i in range(n + 1):\n            if dp >> i & 1:\n                ans = min(ans, abs(total - 2 * i))\n        return ans\nfor T in range(int(input())):\n    (n, q) = map(int, input().split())\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    child[1].append(-1)\n    a = []\n    dfs(1, -1, 1)\n    print(answer())", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\n\ndef dfs(p, prev, lvl):\n    for i in child[p]:\n        if i == prev:\n            continue\n        dfs(i, p, lvl + 1)\n    if lvl & 1:\n        a.append(abs(len(child[p]) - 2))\n\ndef answer():\n    if q == 1:\n        return sum(a)\n    else:\n        dp = 1\n        for i in range(len(a)):\n            dp |= dp << a[i]\n        total = sum(a)\n        ans = float('inf')\n        for i in range(n + 1):\n            if dp >> i & 1:\n                ans = min(ans, abs(total - 2 * i))\n        return ans\nfor T in range(int(input())):\n    (n, q) = map(int, input().split())\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    child[1].append(-1)\n    a = []\n    dfs(1, -1, 1)\n    print(answer())", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\n\ndef dfs(p, prev, lvl):\n    for i in child[p]:\n        if i == prev:\n            continue\n        dfs(i, p, lvl + 1)\n    if lvl & 1:\n        a.append(abs(len(child[p]) - 2))\n\ndef answer():\n    if q == 1:\n        return sum(a)\n    else:\n        dp = 1\n        for i in range(len(a)):\n            dp |= dp << a[i]\n        total = sum(a)\n        ans = float('inf')\n        for i in range(n + 1):\n            if dp >> i & 1:\n                ans = min(ans, abs(total - 2 * i))\n        return ans\nfor T in range(int(input())):\n    (n, q) = map(int, input().split())\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    child[1].append(-1)\n    a = []\n    dfs(1, -1, 1)\n    print(answer())", "T = int(input())\nfor t in range(T):\n    (N, Q) = [int(h) for h in input().split()]\n    neb = [[] for n in range(N)]\n    for n in range(N - 1):\n        (u, v) = [int(h) for h in input().split()]\n        neb[u - 1].append(v - 1)\n        neb[v - 1].append(u - 1)\n    depth = [0] * N\n    depth[0] = 1\n    queue = [0]\n    idx = 0\n    while idx < len(queue):\n        parent = queue[idx]\n        for child in neb[parent]:\n            if depth[child] > 0:\n                continue\n            depth[child] = depth[parent] + 1\n            queue.append(child)\n        idx += 1\n    nums = [len(neb[0]) - 1]\n    for n in range(1, N):\n        if depth[n] % 2 == 1:\n            nums.append(abs(len(neb[n]) - 2))\n    if Q == 1:\n        print(sum(nums))\n    else:\n        nums.sort(reverse=True)\n        if N > 500:\n            s = 0\n            for x in nums:\n                s = min(s + x, abs(s - x))\n            print(s)\n            continue\n\n        def sums(i, j):\n            if j == i + 1:\n                return [nums[i]]\n            k = (i + j) // 2\n            left = sums(i, k)\n            right = sums(k, j)\n            ret = set()\n            for u in left:\n                for v in right:\n                    ret.add(u + v)\n                    ret.add(abs(u - v))\n            return list(ret)\n        all_sums = sums(0, len(nums))\n        print(min(all_sums))"]