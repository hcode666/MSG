["from collections import deque\nimport math\n\ndef applyPermutation(seq, permutation):\n    newSeq = []\n    for i in range(len(seq)):\n        newSeq.append(seq[permutation[i]])\n    return newSeq\n\ndef permute(seq, permutation, b):\n    while b > 0:\n        if b & 1:\n            seq = applyPermutation(seq, permutation)\n        permutation = applyPermutation(permutation, permutation)\n        b >>= 1\n    return seq\n\ndef find_length(graph, n):\n    lis = []\n    vis = [False] * n\n    for i in range(n):\n        length = 0\n        if not vis[i]:\n            q = deque([i])\n            vis[i] = True\n            while q:\n                node = q.popleft()\n                length += 1\n                for j in graph[node]:\n                    if not vis[j]:\n                        q.append(j)\n                        vis[j] = True\n            lis.append(length)\n    return lis\n\ndef LCMofArray(a):\n    lcm = a[0]\n    for i in range(1, len(a)):\n        lcm = lcm * a[i] // math.gcd(lcm, a[i])\n    return lcm\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    seq = list(range(1, n + 1))\n    seq = [i - 1 for i in seq]\n    permutation = list(range(1, n, 2)) + list(range(2, n + 1, 2))\n    permutation = [i - 1 for i in permutation]\n    graph = []\n    for i in range(n):\n        graph.append([])\n    for i in range(n):\n        u = permutation[i]\n        v = seq[i]\n        graph[u].append(v)\n    len_arr = find_length(graph, n)\n    lcm = LCMofArray(len_arr)\n    k = k % lcm\n    res = permute(seq, permutation, k)\n    res = [i + 1 for i in res]\n    print(*res)", "from collections import deque\nimport math\n\ndef applyPermutation(seq, permutation):\n    newSeq = []\n    for i in range(len(seq)):\n        newSeq.append(seq[permutation[i]])\n    return newSeq\n\ndef permute(seq, permutation, b):\n    while b > 0:\n        if b & 1:\n            seq = applyPermutation(seq, permutation)\n        permutation = applyPermutation(permutation, permutation)\n        b >>= 1\n    return seq\n\ndef find_length(graph, n):\n    lis = []\n    vis = [False] * n\n    for i in range(n):\n        length = 0\n        if not vis[i]:\n            q = deque([i])\n            vis[i] = True\n            while q:\n                node = q.popleft()\n                length += 1\n                for j in graph[node]:\n                    if not vis[j]:\n                        q.append(j)\n                        vis[j] = True\n            lis.append(length)\n    return lis\n\ndef LCMofArray(a):\n    lcm = a[0]\n    for i in range(1, len(a)):\n        lcm = lcm * a[i] // math.gcd(lcm, a[i])\n    return lcm\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    seq = list(range(1, n + 1))\n    seq = [i - 1 for i in seq]\n    permutation = list(range(1, n, 2)) + list(range(2, n + 1, 2))\n    permutation = [i - 1 for i in permutation]\n    graph = []\n    for i in range(n):\n        graph.append([])\n    for i in range(n):\n        u = permutation[i]\n        v = seq[i]\n        graph[u].append(v)\n    len_arr = find_length(graph, n)\n    lcm = LCMofArray(len_arr)\n    k = k % lcm\n    res = permute(seq, permutation, k)\n    res = [i + 1 for i in res]\n    print(*res)", "def applyPermutation(seq, permutation):\n    newSeq = []\n    for i in range(len(seq)):\n        newSeq.append(seq[permutation[i]])\n    return newSeq\n\ndef permute(seq, permutation, b):\n    while b > 0:\n        if b & 1:\n            seq = applyPermutation(seq, permutation)\n        permutation = applyPermutation(permutation, permutation)\n        b >>= 1\n    return seq\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    seq = list(range(1, n + 1))\n    seq = [i - 1 for i in seq]\n    permutation = list(range(1, n, 2)) + list(range(2, n + 1, 2))\n    permutation = [i - 1 for i in permutation]\n    res = permute(seq, permutation, k)\n    res = [i + 1 for i in res]\n    print(*res)", "def applyPermutation(seq, permutation):\n    newSeq = []\n    for i in range(len(seq)):\n        newSeq.append(seq[permutation[i] - 1])\n    return newSeq\n\ndef permute(seq, permutation, b):\n    while b > 0:\n        if b & 1:\n            seq = applyPermutation(seq, permutation)\n        permutation = applyPermutation(permutation, permutation)\n        b >>= 1\n    return seq\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    seq = list(range(1, n + 1))\n    permutation = list(range(1, n, 2)) + list(range(2, n + 1, 2))\n    print(*permute(seq, permutation, k))", "t = int(input())\nfor _ in range(t):\n    (n, k) = list(map(int, input().split()))\n    sequence = [i for i in range(1, n + 1)]\n    permutation = [2 * i + 1 for i in range(n // 2)]\n    sub_perm = [2 * i for i in range(1, n // 2 + 1)]\n    permutation.extend(sub_perm)\n\n    def apply_perm(seq, perm):\n        new_seq = seq.copy()\n        for i in range(len(seq)):\n            new_seq[i] = seq[perm[i] - 1]\n        return new_seq\n\n    def perm_k(seq, perm, k):\n        while k:\n            if k % 2:\n                seq = apply_perm(seq, perm)\n            perm = apply_perm(perm, perm)\n            k >>= 1\n        return seq\n    print(*perm_k(sequence, permutation, k))", "def exp_permutation(seq, p, n):\n\n    def permute(_seq, permutation):\n        return [_seq[i] for i in permutation]\n    while n:\n        if n % 2:\n            seq = permute(seq, p)\n        p = permute(p, p)\n        n = n // 2\n    return seq\nt = int(input())\nwhile t:\n    (N, K) = map(int, input().split())\n    seq = list(range(1, N + 1))\n    p = [i - 1 for i in range(1, N, 2)] + [i - 1 for i in range(2, N + 1, 2)]\n    for k in exp_permutation(seq, p, K):\n        print(k, end=' ')\n    print()\n    t = t - 1", "def exp_permutation(seq, p, n):\n\n    def permute(_seq, permutation):\n        return [_seq[i] for i in permutation]\n    while n:\n        if n % 2:\n            seq = permute(seq, p)\n        p = permute(p, p)\n        n = n // 2\n    return seq\nt = int(input())\nwhile t:\n    (N, K) = map(int, input().split())\n    seq = list(range(1, N + 1))\n    p = [i - 1 for i in range(1, N, 2)] + [i - 1 for i in range(2, N + 1, 2)]\n    for k in exp_permutation(seq, p, K):\n        print(k, end=' ')\n    print()\n    t = t - 1", "def binexpo(a, b, m):\n    a %= m\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % m\n        a = a * a % m\n        b >>= 1\n    return res\n\ndef exe():\n    (n, k) = map(int, input().split())\n    l = []\n    for i in range(1, n + 1):\n        l.append(i)\n    kk = binexpo(2, k, n - 1)\n    p = kk - 1 % (n - 1)\n    if kk - 1 < 0:\n        p += n - 1\n    print(1, end=' ')\n    m = 1\n    for i in range(n - 2):\n        print(l[(m + p) % (n - 1)], end=' ')\n        m = l[(m + p) % (n - 1)]\n    print(n)\n    return\nfor i in range(int(input())):\n    exe()", "t = int(input())\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef lcm(x, y):\n    lcm = x * y // gcd(x, y)\n    return lcm\n\ndef riffle(permutations, n, k):\n    positions = []\n    for i in range(n):\n        positions.append(i + 1)\n    for permutation in permutations:\n        for i in range(len(permutation)):\n            positions[permutation[(i + k) % len(permutation)]] = permutation[i] + 1\n    return positions\n\ndef backwardsRiffe(positions, n):\n    newPositions = []\n    positionsFirstHalf = positions[0:n // 2]\n    positionsSecondHalf = positions[n // 2:]\n    for i in range(n // 2):\n        newPositions.append(positionsFirstHalf[i])\n        newPositions.append(positionsSecondHalf[i])\n    return newPositions\n\ndef singleRiffle(currentPositions, n):\n    if currentPositions % 2:\n        return n // 2 + (currentPositions - 1) // 2\n    else:\n        return currentPositions // 2\n\ndef findOrder(permutations):\n    if len(permutations) == 0:\n        return 1\n    order = len(permutations[0])\n    for permutation in permutations:\n        order = lcm(order, len(permutation))\n    return order\n\ndef findPermutations(n):\n    permutations = []\n    positionsNotSeen = set()\n    for i in range(1, n - 1):\n        positionsNotSeen.add(i)\n    count = 0\n    while count != n - 2:\n        permutation = []\n        startingPosition = positionsNotSeen.pop()\n        currentPosition = startingPosition\n        currentPosition = singleRiffle(currentPosition, n)\n        permutation.append(currentPosition)\n        count += 1\n        while startingPosition != currentPosition:\n            positionsNotSeen.remove(currentPosition)\n            currentPosition = singleRiffle(currentPosition, n)\n            permutation.append(currentPosition)\n            count += 1\n        permutations.append(permutation)\n    return permutations\nfor _ in range(t):\n    inputs = [int(item) for item in input().split()]\n    n = inputs[0]\n    k = inputs[1]\n    permutations = findPermutations(n)\n    order = findOrder(permutations)\n    riffleAmount = k % order\n    print(*riffle(permutations, n, k))", "def build_perm(n):\n    p = []\n    p = list(range(0, n, 2)) + list(range(1, n + 1, 2))\n    return p\n\ndef permutate(sequence, perm_list):\n    new_sequence = [-1] * len(sequence)\n    for (i, j) in enumerate(perm_list):\n        new_sequence[i] = sequence[j]\n    return new_sequence\n\ndef multiple_permutation(sequence, permutation, k):\n    while k > 0:\n        if k & 1:\n            sequence = permutate(sequence, permutation)\n        permutation = permutate(permutation, permutation)\n        k = k // 2\n    return sequence\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    permutation = build_perm(n)\n    sequence = list(range(1, n + 1))\n    print(*multiple_permutation(sequence, permutation, k))", "def Permutation(a, b):\n    ans = [0] * len(a)\n    for i in range(len(a)):\n        ans[i] = a[b[i]]\n    return ans\n\ndef PowerPermutation(a, b, c):\n    while c:\n        if c & 1:\n            a = Permutation(a, b)\n        b = Permutation(b, b)\n        c >>= 1\n    return a\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = [i for i in range(1, N + 1)]\n    Perm = [i for i in range(0, N, 2)] + [i for i in range(1, N, 2)]\n    print(*PowerPermutation(A, Perm, K))", "def Permutation(a, perm):\n    new_seq = [0] * len(a)\n    for i in range(len(a)):\n        new_seq[i] = a[perm[i]]\n    return new_seq\n\ndef PowerPermutation(a, b, c):\n    while c:\n        if c & 1:\n            a = Permutation(a, b)\n        b = Permutation(b, b)\n        c >>= 1\n    return a\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = [i for i in range(1, N + 1)]\n    perm = [i for i in range(0, N, 2)] + [i for i in range(1, N, 2)]\n    print(*PowerPermutation(A, perm, K))", "def Permutation(a, perm):\n    new_seq = [0] * len(a)\n    for i in range(len(a)):\n        new_seq[i] = a[perm[i]]\n    return new_seq\n\ndef PowerPermutation(a, b, c):\n    while c:\n        if c & 1:\n            a = Permutation(a, b)\n        b = Permutation(b, b)\n        c >>= 1\n    return a\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = [i for i in range(1, N + 1)]\n    perm = []\n    for i in range(0, N, 2):\n        perm.append(i)\n    for i in range(1, N, 2):\n        perm.append(i)\n    print(*PowerPermutation(A, perm, K))", "def solve(n, k):\n    next = [0] * (n + 1)\n    ans = [False] * (n + 1)\n    for i in range(1, len(next)):\n        if i & 1:\n            next[1 + i // 2] = i\n        else:\n            next[n // 2 + i // 2] = i\n    for i in range(1, len(next)):\n        if not ans[i]:\n            ans[i] = True\n            curr = i\n            cycle = []\n            cycle.append(curr)\n            while next[curr] != i:\n                curr = next[curr]\n                cycle.append(curr)\n                ans[i] = True\n            for j in range(0, len(cycle)):\n                ans[cycle[j]] = cycle[(j + k) % len(cycle)]\n    for i in range(1, len(ans)):\n        print(ans[i], end=' ')\n    print()\nt = int(input())\nwhile t:\n    line = input().split(' ')\n    n = int(line[0])\n    k = int(line[1])\n    solve(n, k)\n    t -= 1", "t = int(input())\nwhile t:\n    (a, b) = map(int, input().split(' '))\n    a = a - 1\n    for i in range(a + 1):\n        if (2 << i) % a == 1:\n            ct = i + 1\n            break\n    if ct == b:\n        itr = a + 1\n    elif ct > b:\n        itr = (1 << b) % a\n    elif ct < b:\n        itr = 1 << b % ct % a\n    z = 0\n    for i in range(a + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % a\n        if z == 0:\n            z = a\n    print()\n    t -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "def mul(a, b, n):\n    tmp = {}\n    for i in range(n):\n        tmp[i + 1] = a[b[i + 1]]\n    return tmp\nt = int(input())\nfor _ in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    positions = {}\n    for i in range(1, n // 2 + 1):\n        positions[i] = 2 * i - 1\n    for i in range(n // 2 + 1, n + 1):\n        positions[i] = 2 * (i - n // 2)\n    inipositions = {}\n    for i in range(n):\n        inipositions[i + 1] = i + 1\n    while k:\n        if k & 1:\n            inipositions = mul(inipositions, positions, n)\n        positions = mul(positions, positions, n)\n        k //= 2\n    print(' '.join(map(str, list(inipositions.values()))))", "def mul(a, b, n):\n    tmp = {}\n    for i in range(n):\n        tmp[i + 1] = a[b[i + 1]]\n    return tmp\nt = int(input())\nfor _ in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    positions = {}\n    for i in range(1, n // 2 + 1):\n        positions[i] = 2 * i - 1\n    for i in range(n // 2 + 1, n + 1):\n        positions[i] = 2 * (i - n // 2)\n    inipositions = {}\n    for i in range(n):\n        inipositions[i + 1] = i + 1\n    while k:\n        if k & 1:\n            inipositions = mul(inipositions, positions, n)\n        positions = mul(positions, positions, n)\n        k //= 2\n    print(' '.join(map(str, list(inipositions.values()))))", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "t = int(input())\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef lcm(x, y):\n    lcm = x * y // gcd(x, y)\n    return lcm\n\ndef riffle(permutations, n, k):\n    positions = []\n    for i in range(n):\n        positions.append(i + 1)\n    for permutation in permutations:\n        for i in range(len(permutation)):\n            positions[permutation[(i + k) % len(permutation)]] = permutation[i] + 1\n    return positions\n\ndef backwardsRiffe(positions, n):\n    newPositions = []\n    positionsFirstHalf = positions[0:n // 2]\n    positionsSecondHalf = positions[n // 2:]\n    for i in range(n // 2):\n        newPositions.append(positionsFirstHalf[i])\n        newPositions.append(positionsSecondHalf[i])\n    return newPositions\n\ndef singleRiffle(currentPositions, n):\n    if currentPositions % 2:\n        return n // 2 + (currentPositions - 1) // 2\n    else:\n        return currentPositions // 2\n\ndef findOrder(permutations):\n    if len(permutations) == 0:\n        return 1\n    order = len(permutations[0])\n    for permutation in permutations:\n        order = lcm(order, len(permutation))\n    return order\n\ndef findPermutations(n):\n    permutations = []\n    positionsNotSeen = set()\n    for i in range(1, n - 1):\n        positionsNotSeen.add(i)\n    count = 0\n    while count != n - 2:\n        permutation = []\n        startingPosition = positionsNotSeen.pop()\n        currentPosition = startingPosition\n        currentPosition = singleRiffle(currentPosition, n)\n        permutation.append(currentPosition)\n        count += 1\n        while startingPosition != currentPosition:\n            positionsNotSeen.remove(currentPosition)\n            currentPosition = singleRiffle(currentPosition, n)\n            permutation.append(currentPosition)\n            count += 1\n        permutations.append(permutation)\n    return permutations\nfor _ in range(t):\n    inputs = [int(item) for item in input().split()]\n    n = inputs[0]\n    k = inputs[1]\n    permutations = findPermutations(n)\n    order = findOrder(permutations)\n    riffleAmount = k % order\n    print(*riffle(permutations, n, k))", "t = int(input())\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef lcm(x, y):\n    lcm = x * y // gcd(x, y)\n    return lcm\n\ndef riffle(permutations, n, k):\n    positions = []\n    for i in range(n):\n        positions.append(i + 1)\n    for permutation in permutations:\n        for i in range(len(permutation)):\n            positions[permutation[(i + k) % len(permutation)]] = permutation[i] + 1\n    return positions\n\ndef backwardsRiffe(positions, n):\n    newPositions = []\n    positionsFirstHalf = positions[0:n // 2]\n    positionsSecondHalf = positions[n // 2:]\n    for i in range(n // 2):\n        newPositions.append(positionsFirstHalf[i])\n        newPositions.append(positionsSecondHalf[i])\n    return newPositions\n\ndef singleRiffle(currentPositions, n):\n    if currentPositions % 2:\n        return n // 2 + (currentPositions - 1) // 2\n    else:\n        return currentPositions // 2\n\ndef findOrder(permutations):\n    if len(permutations) == 0:\n        return 1\n    order = len(permutations[0])\n    for permutation in permutations:\n        order = lcm(order, len(permutation))\n    return order\n\ndef findPermutations(n):\n    permutations = []\n    positionsNotSeen = set()\n    for i in range(1, n - 1):\n        positionsNotSeen.add(i)\n    count = 0\n    while count != n - 2:\n        permutation = []\n        startingPosition = positionsNotSeen.pop()\n        currentPosition = startingPosition\n        currentPosition = singleRiffle(currentPosition, n)\n        permutation.append(currentPosition)\n        count += 1\n        while startingPosition != currentPosition:\n            positionsNotSeen.remove(currentPosition)\n            currentPosition = singleRiffle(currentPosition, n)\n            permutation.append(currentPosition)\n            count += 1\n        permutations.append(permutation)\n    return permutations\nfor _ in range(t):\n    inputs = [int(item) for item in input().split()]\n    n = inputs[0]\n    k = inputs[1]\n    permutations = findPermutations(n)\n    order = findOrder(permutations)\n    riffleAmount = k % order\n    print(*riffle(permutations, n, k))", "t = int(input())\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef lcm(x, y):\n    lcm = x * y // gcd(x, y)\n    return lcm\n\ndef riffle(permutations, n, k):\n    positions = []\n    for i in range(n):\n        positions.append(i + 1)\n    for permutation in permutations:\n        for i in range(len(permutation)):\n            positions[permutation[(i + k) % len(permutation)]] = permutation[i] + 1\n    return positions\n\ndef backwardsRiffe(positions, n):\n    newPositions = []\n    positionsFirstHalf = positions[0:n // 2]\n    positionsSecondHalf = positions[n // 2:]\n    for i in range(n // 2):\n        newPositions.append(positionsFirstHalf[i])\n        newPositions.append(positionsSecondHalf[i])\n    return newPositions\n\ndef singleRiffle(currentPositions, n):\n    if currentPositions % 2:\n        return n // 2 + (currentPositions - 1) // 2\n    else:\n        return currentPositions // 2\n\ndef findOrder(permutations):\n    if len(permutations) == 0:\n        return 1\n    order = len(permutations[0])\n    for permutation in permutations:\n        order = lcm(order, len(permutation))\n    return order\n\ndef findPermutations(n):\n    permutations = []\n    positionsNotSeen = set()\n    for i in range(1, n - 1):\n        positionsNotSeen.add(i)\n    count = 0\n    while count != n - 2:\n        permutation = []\n        startingPosition = positionsNotSeen.pop()\n        currentPosition = startingPosition\n        currentPosition = singleRiffle(currentPosition, n)\n        permutation.append(currentPosition)\n        count += 1\n        while startingPosition != currentPosition:\n            positionsNotSeen.remove(currentPosition)\n            currentPosition = singleRiffle(currentPosition, n)\n            permutation.append(currentPosition)\n            count += 1\n        permutations.append(permutation)\n    return permutations\nfor _ in range(t):\n    inputs = [int(item) for item in input().split()]\n    n = inputs[0]\n    k = inputs[1]\n    permutations = findPermutations(n)\n    order = findOrder(permutations)\n    riffleAmount = k % order\n    print(*riffle(permutations, n, k))", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (p, k) = map(int, input().split(' '))\n    p = p - 1\n    for i in range(p + 1):\n        if (2 << i) % p == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = p + 1\n    elif ct > k:\n        itr = (1 << k) % p\n    elif ct < k:\n        itr = 1 << k % ct % p\n    z = 0\n    for i in range(p + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % p\n        if z == 0:\n            z = p\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "t = int(input())\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef lcm(x, y):\n    lcm = x * y // gcd(x, y)\n    return lcm\n\ndef riffle(permutations, n, k):\n    positions = []\n    for i in range(n):\n        positions.append(i + 1)\n    for permutation in permutations:\n        for i in range(len(permutation)):\n            positions[permutation[(i + k) % len(permutation)]] = permutation[i] + 1\n    return positions\n\ndef backwardsRiffe(positions, n):\n    newPositions = []\n    positionsFirstHalf = positions[0:n // 2]\n    positionsSecondHalf = positions[n // 2:]\n    for i in range(n // 2):\n        newPositions.append(positionsFirstHalf[i])\n        newPositions.append(positionsSecondHalf[i])\n    return newPositions\n\ndef singleRiffle(currentPositions, n):\n    if currentPositions % 2:\n        return n // 2 + (currentPositions - 1) // 2\n    else:\n        return currentPositions // 2\n\ndef findOrder(permutations):\n    if len(permutations) == 0:\n        return 1\n    order = len(permutations[0])\n    for permutation in permutations:\n        order = lcm(order, len(permutation))\n    return order\n\ndef findPermutations(n):\n    permutations = []\n    positionsNotSeen = set()\n    for i in range(1, n - 1):\n        positionsNotSeen.add(i)\n    count = 0\n    while count != n - 2:\n        permutation = []\n        startingPosition = positionsNotSeen.pop()\n        currentPosition = startingPosition\n        currentPosition = singleRiffle(currentPosition, n)\n        permutation.append(currentPosition)\n        count += 1\n        while startingPosition != currentPosition:\n            positionsNotSeen.remove(currentPosition)\n            currentPosition = singleRiffle(currentPosition, n)\n            permutation.append(currentPosition)\n            count += 1\n        permutations.append(permutation)\n    return permutations\nfor _ in range(t):\n    inputs = [int(item) for item in input().split()]\n    n = inputs[0]\n    k = inputs[1]\n    permutations = findPermutations(n)\n    order = findOrder(permutations)\n    riffleAmount = k % order\n    print(*riffle(permutations, n, k))", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "t = int(input())\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef lcm(x, y):\n    lcm = x * y // gcd(x, y)\n    return lcm\n\ndef riffle(permutations, n, k):\n    positions = []\n    for i in range(n):\n        positions.append(i + 1)\n    for permutation in permutations:\n        for i in range(len(permutation)):\n            positions[permutation[(i + k) % len(permutation)]] = permutation[i] + 1\n    return positions\n\ndef backwardsRiffe(positions, n):\n    newPositions = []\n    positionsFirstHalf = positions[0:n // 2]\n    positionsSecondHalf = positions[n // 2:]\n    for i in range(n // 2):\n        newPositions.append(positionsFirstHalf[i])\n        newPositions.append(positionsSecondHalf[i])\n    return newPositions\n\ndef singleRiffle(currentPositions, n):\n    if currentPositions % 2:\n        return n // 2 + (currentPositions - 1) // 2\n    else:\n        return currentPositions // 2\n\ndef findOrder(permutations):\n    if len(permutations) == 0:\n        return 1\n    order = len(permutations[0])\n    for permutation in permutations:\n        order = lcm(order, len(permutation))\n    return order\n\ndef findPermutations(n):\n    permutations = []\n    positionsNotSeen = set()\n    for i in range(1, n - 1):\n        positionsNotSeen.add(i)\n    count = 0\n    while count != n - 2:\n        permutation = []\n        startingPosition = positionsNotSeen.pop()\n        currentPosition = startingPosition\n        currentPosition = singleRiffle(currentPosition, n)\n        permutation.append(currentPosition)\n        count += 1\n        while startingPosition != currentPosition:\n            positionsNotSeen.remove(currentPosition)\n            currentPosition = singleRiffle(currentPosition, n)\n            permutation.append(currentPosition)\n            count += 1\n        permutations.append(permutation)\n    return permutations\nfor _ in range(t):\n    inputs = [int(item) for item in input().split()]\n    n = inputs[0]\n    k = inputs[1]\n    permutations = findPermutations(n)\n    order = findOrder(permutations)\n    riffleAmount = k % order\n    print(*riffle(permutations, n, k))", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    n -= 1\n    for j in range(n + 1):\n        if (2 << j) % n == 1:\n            c = j + 1\n            break\n    if c == k:\n        r = n + 1\n    elif c > k:\n        r = (1 << k) % n\n    elif c < k:\n        r = 1 << k % c % n\n    z = 0\n    for y in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + r) % n\n        if z == 0:\n            z = n\n    print()", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "t = int(input())\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef lcm(x, y):\n    lcm = x * y // gcd(x, y)\n    return lcm\n\ndef riffle(permutations, n, k):\n    positions = []\n    for i in range(n):\n        positions.append(i + 1)\n    for permutation in permutations:\n        for i in range(len(permutation)):\n            positions[permutation[(i + k) % len(permutation)]] = permutation[i] + 1\n    return positions\n\ndef backwardsRiffe(positions, n):\n    newPositions = []\n    positionsFirstHalf = positions[0:n // 2]\n    positionsSecondHalf = positions[n // 2:]\n    for i in range(n // 2):\n        newPositions.append(positionsFirstHalf[i])\n        newPositions.append(positionsSecondHalf[i])\n    return newPositions\n\ndef singleRiffle(currentPositions, n):\n    if currentPositions % 2:\n        return n // 2 + (currentPositions - 1) // 2\n    else:\n        return currentPositions // 2\n\ndef findOrder(permutations):\n    if len(permutations) == 0:\n        return 1\n    order = len(permutations[0])\n    for permutation in permutations:\n        order = lcm(order, len(permutation))\n    return order\n\ndef findPermutations(n):\n    permutations = []\n    positionsNotSeen = set()\n    for i in range(1, n - 1):\n        positionsNotSeen.add(i)\n    count = 0\n    while count != n - 2:\n        permutation = []\n        startingPosition = positionsNotSeen.pop()\n        currentPosition = startingPosition\n        currentPosition = singleRiffle(currentPosition, n)\n        permutation.append(currentPosition)\n        count += 1\n        while startingPosition != currentPosition:\n            positionsNotSeen.remove(currentPosition)\n            currentPosition = singleRiffle(currentPosition, n)\n            permutation.append(currentPosition)\n            count += 1\n        permutations.append(permutation)\n    return permutations\nfor _ in range(t):\n    inputs = [int(item) for item in input().split()]\n    n = inputs[0]\n    k = inputs[1]\n    permutations = findPermutations(n)\n    order = findOrder(permutations)\n    riffleAmount = k % order\n    print(*riffle(permutations, n, k))", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "t = int(input())\nwhile t:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    t -= 1", "t = int(input())\nwhile t:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    t -= 1", "from sys import stdin, stdout\ninput = stdin.readline\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    vis = set()\n    ans = [i + 1 for i in range(n)]\n    for i in range(2, n):\n        if i not in vis:\n            vis.add(i)\n            temp = [i]\n            start = i\n            while True:\n                start *= 2\n                start -= 1\n                start %= n - 1\n                if start == temp[0] or not start:\n                    break\n                temp.append(start)\n                vis.add(start)\n            l = len(temp)\n            for j in range(l):\n                ans[temp[j] - 1] = temp[(j + k) % l]\n    print(*ans)", "from sys import stdin, stdout\ninput = stdin.readline\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    vis = set()\n    ans = [i + 1 for i in range(n)]\n    for i in range(2, n):\n        if i not in vis:\n            vis.add(i)\n            temp = [i]\n            start = i\n            while True:\n                start *= 2\n                start -= 1\n                start %= n - 1\n                if start == temp[0] or not start:\n                    break\n                temp.append(start)\n                vis.add(start)\n            l = len(temp)\n            for j in range(l):\n                ans[temp[j] - 1] = temp[(j + k) % l]\n    print(*ans)", "from sys import stdin, stdout\ninput = stdin.readline\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    vis = set()\n    ans = [i + 1 for i in range(n)]\n    for i in range(2, n):\n        if i not in vis:\n            vis.add(i)\n            temp = [i]\n            start = i\n            while True:\n                start *= 2\n                start -= 1\n                start %= n - 1\n                if start == temp[0] or not start:\n                    break\n                temp.append(start)\n                vis.add(start)\n            l = len(temp)\n            for j in range(l):\n                ans[temp[j] - 1] = temp[(j + k) % l]\n    print(*ans)", "from sys import stdin, stdout\ninput = stdin.readline\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    vis = set()\n    ans = [i + 1 for i in range(n)]\n    for i in range(2, n):\n        if i not in vis:\n            vis.add(i)\n            temp = [i]\n            start = i\n            while True:\n                start *= 2\n                start -= 1\n                start %= n - 1\n                if start == temp[0] or not start:\n                    break\n                temp.append(start)\n                vis.add(start)\n            l = len(temp)\n            for j in range(l):\n                ans[temp[j] - 1] = temp[(j + k) % l]\n    print(*ans)", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "T = int(input())\nwhile T:\n    (N, K) = map(int, input().split(' '))\n    N = N - 1\n    for i in range(N + 1):\n        if (2 << i) % N == 1:\n            temp = i + 1\n            break\n    if temp == K:\n        itr = N + 1\n    elif temp > K:\n        itr = (1 << K) % N\n    elif temp < K:\n        itr = 1 << K % temp % N\n    Z = 0\n    for i in range(N + 1):\n        print(Z + 1, end=' ')\n        Z = (Z + itr) % N\n        if Z == 0:\n            Z = N\n    print()\n    T -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "T = int(input())\nwhile T:\n    (N, K) = map(int, input().split(' '))\n    N = N - 1\n    for i in range(N + 1):\n        if (2 << i) % N == 1:\n            temp = i + 1\n            break\n    if temp == K:\n        itr = N + 1\n    elif temp > K:\n        itr = (1 << K) % N\n    elif temp < K:\n        itr = 1 << K % temp % N\n    Z = 0\n    for i in range(N + 1):\n        print(Z + 1, end=' ')\n        Z = (Z + itr) % N\n        if Z == 0:\n            Z = N\n    print()\n    T -= 1", "from sys import stdin, stdout\ninput = stdin.readline\na = int(input())\nfor _ in range(a):\n    (m, k) = map(int, input().split())\n    vis = set()\n    ans = [i + 1 for i in range(m)]\n    for i in range(2, m):\n        if i not in vis:\n            vis.add(i)\n            temp = [i]\n            start = i\n            while True:\n                start *= 2\n                start -= 1\n                start %= m - 1\n                if start == temp[0] or not start:\n                    break\n                temp.append(start)\n                vis.add(start)\n            l = len(temp)\n            for j in range(l):\n                ans[temp[j] - 1] = temp[(j + k) % l]\n    print(*ans)", "from sys import stdin, stdout\ninput = stdin.readline\na = int(input())\nfor _ in range(a):\n    (m, k) = map(int, input().split())\n    vis = set()\n    ans = [i + 1 for i in range(m)]\n    for i in range(2, m):\n        if i not in vis:\n            vis.add(i)\n            temp = [i]\n            start = i\n            while True:\n                start *= 2\n                start -= 1\n                start %= m - 1\n                if start == temp[0] or not start:\n                    break\n                temp.append(start)\n                vis.add(start)\n            l = len(temp)\n            for j in range(l):\n                ans[temp[j] - 1] = temp[(j + k) % l]\n    print(*ans)", "from sys import stdin, stdout\ninput = stdin.readline\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    vis = set()\n    ans = [i + 1 for i in range(n)]\n    for i in range(1, n + 1):\n        if i not in vis:\n            vis.add(i)\n            temp = [i]\n            start = i\n            while True:\n                start *= 2\n                start -= 1\n                if start > n:\n                    start += 1\n                    start %= n\n                if start == temp[0] or not start:\n                    break\n                temp.append(start)\n                vis.add(start)\n            l = len(temp)\n            for j in range(l):\n                ans[temp[j] - 1] = temp[(j + k) % l]\n    print(*ans)", "from sys import stdin, stdout\ninput = stdin.readline\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    vis = set()\n    ans = [i + 1 for i in range(n)]\n    for i in range(2, n):\n        if i not in vis:\n            vis.add(i)\n            temp = [i]\n            start = i\n            while True:\n                start *= 2\n                start -= 1\n                start %= n - 1\n                if start == temp[0] or not start:\n                    break\n                temp.append(start)\n                vis.add(start)\n            l = len(temp)\n            for j in range(l):\n                ans[temp[j] - 1] = temp[(j + k) % l]\n    print(*ans)", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "t = int(input())\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef lcm(x, y):\n    lcm = x * y // gcd(x, y)\n    return lcm\n\ndef riffle(permutations, n, k):\n    positions = []\n    for i in range(n):\n        positions.append(i + 1)\n    for permutation in permutations:\n        for i in range(len(permutation)):\n            positions[permutation[(i + k) % len(permutation)]] = permutation[i] + 1\n    return positions\n\ndef backwardsRiffe(positions, n):\n    newPositions = []\n    positionsFirstHalf = positions[0:n // 2]\n    positionsSecondHalf = positions[n // 2:]\n    for i in range(n // 2):\n        newPositions.append(positionsFirstHalf[i])\n        newPositions.append(positionsSecondHalf[i])\n    return newPositions\n\ndef singleRiffle(currentPositions, n):\n    if currentPositions % 2:\n        return n // 2 + (currentPositions - 1) // 2\n    else:\n        return currentPositions // 2\n\ndef findOrder(permutations):\n    if len(permutations) == 0:\n        return 1\n    order = len(permutations[0])\n    for permutation in permutations:\n        order = lcm(order, len(permutation))\n    return order\n\ndef findPermutations(n):\n    permutations = []\n    positionsNotSeen = set()\n    for i in range(1, n - 1):\n        positionsNotSeen.add(i)\n    count = 0\n    while count != n - 2:\n        permutation = []\n        startingPosition = positionsNotSeen.pop()\n        currentPosition = startingPosition\n        currentPosition = singleRiffle(currentPosition, n)\n        permutation.append(currentPosition)\n        count += 1\n        while startingPosition != currentPosition:\n            positionsNotSeen.remove(currentPosition)\n            currentPosition = singleRiffle(currentPosition, n)\n            permutation.append(currentPosition)\n            count += 1\n        permutations.append(permutation)\n    return permutations\nfor _ in range(t):\n    inputs = [int(item) for item in input().split()]\n    n = inputs[0]\n    k = inputs[1]\n    permutations = findPermutations(n)\n    order = findOrder(permutations)\n    riffleAmount = k % order\n    print(*riffle(permutations, n, k))", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "t = int(input())\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef lcm(x, y):\n    lcm = x * y // gcd(x, y)\n    return lcm\n\ndef riffle(permutations, n, k):\n    positions = []\n    for i in range(n):\n        positions.append(i + 1)\n    for permutation in permutations:\n        for i in range(len(permutation)):\n            positions[permutation[(i + k) % len(permutation)]] = permutation[i] + 1\n    return positions\n\ndef backwardsRiffe(positions, n):\n    newPositions = []\n    positionsFirstHalf = positions[0:n // 2]\n    positionsSecondHalf = positions[n // 2:]\n    for i in range(n // 2):\n        newPositions.append(positionsFirstHalf[i])\n        newPositions.append(positionsSecondHalf[i])\n    return newPositions\n\ndef singleRiffle(currentPositions, n):\n    if currentPositions % 2:\n        return n // 2 + (currentPositions - 1) // 2\n    else:\n        return currentPositions // 2\n\ndef findOrder(permutations):\n    if len(permutations) == 0:\n        return 1\n    order = len(permutations[0])\n    for permutation in permutations:\n        order = lcm(order, len(permutation))\n    return order\n\ndef findPermutations(n):\n    permutations = []\n    positionsNotSeen = set()\n    for i in range(1, n - 1):\n        positionsNotSeen.add(i)\n    count = 0\n    while count != n - 2:\n        permutation = []\n        startingPosition = positionsNotSeen.pop()\n        currentPosition = startingPosition\n        currentPosition = singleRiffle(currentPosition, n)\n        permutation.append(currentPosition)\n        count += 1\n        while startingPosition != currentPosition:\n            positionsNotSeen.remove(currentPosition)\n            currentPosition = singleRiffle(currentPosition, n)\n            permutation.append(currentPosition)\n            count += 1\n        permutations.append(permutation)\n    return permutations\nfor _ in range(t):\n    inputs = [int(item) for item in input().split()]\n    n = inputs[0]\n    k = inputs[1]\n    permutations = findPermutations(n)\n    order = findOrder(permutations)\n    riffleAmount = k % order\n    print(*riffle(permutations, n, k))", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "T = int(input())\nwhile T:\n    (N, K) = map(int, input().split(' '))\n    N = N - 1\n    for i in range(N + 1):\n        if (2 << i) % N == 1:\n            temp = i + 1\n            break\n    if temp == K:\n        itr = N + 1\n    elif temp > K:\n        itr = (1 << K) % N\n    elif temp < K:\n        itr = 1 << K % temp % N\n    Z = 0\n    for i in range(N + 1):\n        print(Z + 1, end=' ')\n        Z = (Z + itr) % N\n        if Z == 0:\n            Z = N\n    print()\n    T -= 1", "tcases = int(input())\nwhile tcases:\n    (n, k) = map(int, input().split(' '))\n    n = n - 1\n    for i in range(n + 1):\n        if (2 << i) % n == 1:\n            ct = i + 1\n            break\n    if ct == k:\n        itr = n + 1\n    elif ct > k:\n        itr = (1 << k) % n\n    elif ct < k:\n        itr = 1 << k % ct % n\n    z = 0\n    for i in range(n + 1):\n        print(z + 1, end=' ')\n        z = (z + itr) % n\n        if z == 0:\n            z = n\n    print()\n    tcases -= 1", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if n == 2:\n        print(1, 2)\n        continue\n    x = [0]\n    for i in range(1, n + 1):\n        if i % 2 == 1:\n            x.append((i + 1) // 2)\n        else:\n            x.append((n + i) // 2)\n    flag = [0] * (n - 2)\n    i = 2\n    chain = []\n    ct = 0\n    while ct < n - 2:\n        tmp = []\n        while 1:\n            if flag[x[i] - 2]:\n                break\n            ct += 1\n            tmp.append(x[i])\n            flag[x[i] - 2] = 1\n            i = x[i]\n        if len(tmp) > 0:\n            chain.append(tmp)\n        i += 1\n    ans = [0] * n\n    ans[0] = 1\n    for i in range(len(chain)):\n        m = k % len(chain[i])\n        for j in range(len(chain[i])):\n            ans[chain[i][(m + j) % len(chain[i])] - 1] = chain[i][j]\n    ans[-1] = n\n    for i in ans:\n        print(i, end=' ')\n    print('')", "T = int(input())\nwhile T:\n    (N, K) = map(int, input().split(' '))\n    N = N - 1\n    for i in range(N + 1):\n        if (2 << i) % N == 1:\n            temp = i + 1\n            break\n    if temp == K:\n        itr = N + 1\n    elif temp > K:\n        itr = (1 << K) % N\n    elif temp < K:\n        itr = 1 << K % temp % N\n    Z = 0\n    for i in range(N + 1):\n        print(Z + 1, end=' ')\n        Z = (Z + itr) % N\n        if Z == 0:\n            Z = N\n    print()\n    T -= 1"]