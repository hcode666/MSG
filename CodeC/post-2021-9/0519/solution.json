["import random\nimport math\nfrom collections import defaultdict, Counter, deque, OrderedDict\nfrom functools import lru_cache\nimport bisect\nimport heapq\nimport sys\ninput = lambda : sys.stdin.readline().strip()\n\nclass SegmentTree:\n\n    def __init__(self, arr, func=lambda x, y: x + y, defaultvalue=0):\n        self.n = len(arr)\n        self.segmentTree = [0] * self.n + arr\n        self.func = func\n        self.defaultvalue = defaultvalue\n        self.buildSegmentTree(arr)\n\n    def buildSegmentTree(self, arr):\n        for i in range(self.n - 1, 0, -1):\n            self.segmentTree[i] = self.func(self.segmentTree[2 * i], self.segmentTree[2 * i + 1])\n\n    def query(self, l, r):\n        l += self.n\n        r += self.n\n        res = self.defaultvalue\n        while l < r:\n            if l & 1:\n                res = self.func(res, self.segmentTree[l])\n                l += 1\n            l >>= 1\n            if r & 1:\n                r -= 1\n                res = self.func(res, self.segmentTree[r])\n            r >>= 1\n        return res\n\n    def update(self, i, value):\n        i += self.n\n        self.segmentTree[i] = value\n        while i > 1:\n            i >>= 1\n            self.segmentTree[i] = self.func(self.segmentTree[2 * i], self.segmentTree[2 * i + 1])\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = list(range(n))\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            self.parents[x] = y\ndire = [0, 1, 0, -1, 0]\n\ndef is_prime(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef case(t):\n    print('Case #{}:'.format(t), end=' ')\nRANDOM = random.randrange(2 ** 62)\n\ndef Wrapper(x):\n    return x ^ RANDOM\n\ndef solve():\n    n = int(input())\n    mapp = defaultdict(set)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        mapp[a].add(b)\n        mapp[b].add(a)\n    parentmapp = defaultdict(lambda : -1)\n    needed = defaultdict(lambda : 0)\n\n    def remove_parent(i, p=None):\n        if p != None:\n            parentmapp[i] = p\n            needed[p] += 1\n            mapp[i].remove(p)\n        for j in mapp[i]:\n            remove_parent(j, i)\n    remove_parent(1)\n    dp = [0] * (n + 1)\n    dp[0] = -1\n    ans = n - 1\n    q = int(input())\n    for i in range(q):\n        v = list(map(int, input().split()))\n        if v[0] == 1:\n            zc = needed[v[1]]\n            if zc == 0 and dp[v[1]] == 0:\n                dp[v[1]] = 1\n                if v[1] != 1:\n                    needed[parentmapp[v[1]]] -= 1\n                    ans -= 1\n                else:\n                    ans = n - 1\n        else:\n            print(ans)\nfor t in range(int(input())):\n    solve()", "import random\nimport math\nfrom collections import defaultdict, Counter, deque, OrderedDict\nfrom functools import lru_cache\nimport bisect\nimport heapq\nimport sys\ninput = lambda : sys.stdin.readline().strip()\n\nclass SegmentTree:\n\n    def __init__(self, arr, func=lambda x, y: x + y, defaultvalue=0):\n        self.n = len(arr)\n        self.segmentTree = [0] * self.n + arr\n        self.func = func\n        self.defaultvalue = defaultvalue\n        self.buildSegmentTree(arr)\n\n    def buildSegmentTree(self, arr):\n        for i in range(self.n - 1, 0, -1):\n            self.segmentTree[i] = self.func(self.segmentTree[2 * i], self.segmentTree[2 * i + 1])\n\n    def query(self, l, r):\n        l += self.n\n        r += self.n\n        res = self.defaultvalue\n        while l < r:\n            if l & 1:\n                res = self.func(res, self.segmentTree[l])\n                l += 1\n            l >>= 1\n            if r & 1:\n                r -= 1\n                res = self.func(res, self.segmentTree[r])\n            r >>= 1\n        return res\n\n    def update(self, i, value):\n        i += self.n\n        self.segmentTree[i] = value\n        while i > 1:\n            i >>= 1\n            self.segmentTree[i] = self.func(self.segmentTree[2 * i], self.segmentTree[2 * i + 1])\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = list(range(n))\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            self.parents[x] = y\ndire = [0, 1, 0, -1, 0]\n\ndef is_prime(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef case(t):\n    print('Case #{}:'.format(t), end=' ')\nRANDOM = random.randrange(2 ** 62)\n\ndef Wrapper(x):\n    return x ^ RANDOM\n\ndef solve():\n    n = int(input())\n    mapp = defaultdict(set)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        mapp[a].add(b)\n        mapp[b].add(a)\n    parentmapp = defaultdict(lambda : -1)\n    needed = defaultdict(lambda : 0)\n\n    def remove_parent(i, p=None):\n        if p != None:\n            parentmapp[i] = p\n            needed[p] += 1\n            mapp[i].remove(p)\n        for j in mapp[i]:\n            remove_parent(j, i)\n    remove_parent(1)\n    dp = [0] * (n + 1)\n    dp[0] = -1\n    ans = n - 1\n    q = int(input())\n    for i in range(q):\n        v = list(map(int, input().split()))\n        if v[0] == 1:\n            zc = needed[v[1]]\n            if zc == 0 and dp[v[1]] == 0:\n                dp[v[1]] = 1\n                if v[1] != 1:\n                    needed[parentmapp[v[1]]] -= 1\n                    ans -= 1\n                else:\n                    ans = n - 1\n        else:\n            print(ans)\nfor t in range(int(input())):\n    solve()", "import random\nimport math\nfrom collections import defaultdict, Counter, deque, OrderedDict\nfrom functools import lru_cache\nimport bisect\nimport heapq\nimport sys\ninput = lambda : sys.stdin.readline().strip()\n\nclass SegmentTree:\n\n    def __init__(self, arr, func=lambda x, y: x + y, defaultvalue=0):\n        self.n = len(arr)\n        self.segmentTree = [0] * self.n + arr\n        self.func = func\n        self.defaultvalue = defaultvalue\n        self.buildSegmentTree(arr)\n\n    def buildSegmentTree(self, arr):\n        for i in range(self.n - 1, 0, -1):\n            self.segmentTree[i] = self.func(self.segmentTree[2 * i], self.segmentTree[2 * i + 1])\n\n    def query(self, l, r):\n        l += self.n\n        r += self.n\n        res = self.defaultvalue\n        while l < r:\n            if l & 1:\n                res = self.func(res, self.segmentTree[l])\n                l += 1\n            l >>= 1\n            if r & 1:\n                r -= 1\n                res = self.func(res, self.segmentTree[r])\n            r >>= 1\n        return res\n\n    def update(self, i, value):\n        i += self.n\n        self.segmentTree[i] = value\n        while i > 1:\n            i >>= 1\n            self.segmentTree[i] = self.func(self.segmentTree[2 * i], self.segmentTree[2 * i + 1])\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = list(range(n))\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            self.parents[x] = y\ndire = [0, 1, 0, -1, 0]\n\ndef is_prime(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef case(t):\n    print('Case #{}:'.format(t), end=' ')\nRANDOM = random.randrange(2 ** 62)\n\ndef Wrapper(x):\n    return x ^ RANDOM\n\ndef solve():\n    n = int(input())\n    mapp = defaultdict(set)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        mapp[a].add(b)\n        mapp[b].add(a)\n    parentmapp = defaultdict(lambda : -1)\n    needed = defaultdict(lambda : 0)\n\n    def remove_parent(i, p=None):\n        if p != None:\n            parentmapp[i] = p\n            needed[p] += 1\n            mapp[i].remove(p)\n        for j in mapp[i]:\n            remove_parent(j, i)\n    remove_parent(1)\n    dp = [0] * (n + 1)\n    dp[0] = -1\n    ans = n - 1\n    q = int(input())\n    for i in range(q):\n        v = list(map(int, input().split()))\n        if v[0] == 1:\n            zc = needed[v[1]]\n            if zc == 0 and dp[v[1]] == 0:\n                dp[v[1]] = 1\n                if v[1] != 1:\n                    needed[parentmapp[v[1]]] -= 1\n                    ans -= 1\n                else:\n                    ans = n - 1\n        else:\n            print(ans)\nfor t in range(int(input())):\n    solve()", "import sys\nsys.setrecursionlimit(1000000)\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\nfrom collections import deque, Counter\nfrom heapq import heappush, heappop\nfor _ in range(int(input())):\n\n    def solve():\n        n = int(input())\n        adj = [[] for _ in range(n)]\n        res = n - 1\n        par = [-1 for _ in range(n)]\n        ch = [0 for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = get_ints()\n            adj[u - 1].append(v - 1)\n            adj[v - 1].append(u - 1)\n\n        def dfs(node, pa):\n            for an in adj[node]:\n                if an != pa:\n                    par[an] = node\n                    ch[node] += 1\n                    dfs(an, node)\n        dfs(0, -1)\n        vis = [False for _ in range(n)]\n        for _ in range(int(input())):\n            qu = get_list()\n            if qu[0] == 1:\n                if ch[qu[1] - 1] == 0:\n                    if vis[qu[1] - 1]:\n                        continue\n                    if qu[1] == 1:\n                        res = n - 1\n                        continue\n                    res -= 1\n                    vis[qu[1] - 1] = True\n                    if qu[1] != 1:\n                        ch[par[qu[1] - 1]] -= 1\n            else:\n                print(res)\n    solve()", "def dfs(curr, ar, ct, tree):\n    count = 0\n    for i in ar[curr]:\n        if tree[curr] == i:\n            continue\n        tree[i] = curr\n        count += dfs(i, ar, ct, tree)\n    ct[curr] = count\n    return 1\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        l[u].append(v)\n        l[v].append(u)\n    ct = [0 for _ in range(n + 1)]\n    tree = [0 for _ in range(n + 1)]\n    dfs(1, l, ct, tree)\n    q = int(input())\n    g_ct = n - 1\n    one = [False] * (n + 1)\n    for _ in range(q):\n        ar = list(map(int, input().split()))\n        if ar[0] == 1:\n            curr = ar[1]\n            if ct[curr] == 0 and (not one[curr]):\n                ct[tree[curr]] -= 1\n                g_ct -= 1\n                one[curr] = True\n        else:\n            print(n - 1 if one[1] else g_ct)", "def dfs(curr, ar, ct, tree):\n    count = 0\n    for i in ar[curr]:\n        if tree[curr] == i:\n            continue\n        tree[i] = curr\n        count += dfs(i, ar, ct, tree)\n    ct[curr] = count\n    return 1\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        l[u].append(v)\n        l[v].append(u)\n    ct = [0 for _ in range(n + 1)]\n    tree = [0 for _ in range(n + 1)]\n    dfs(1, l, ct, tree)\n    q = int(input())\n    g_ct = n - 1\n    one = [False] * (n + 1)\n    for _ in range(q):\n        ar = list(map(int, input().split()))\n        if ar[0] == 1:\n            curr = ar[1]\n            if ct[curr] == 0 and (not one[curr]):\n                ct[tree[curr]] -= 1\n                g_ct -= 1\n                one[curr] = True\n        else:\n            print(n - 1 if one[1] else g_ct)", "def dfs(curr, ar, ct, tree):\n    count = 0\n    for i in ar[curr]:\n        if tree[curr] == i:\n            continue\n        tree[i] = curr\n        count += dfs(i, ar, ct, tree)\n    ct[curr] = count\n    return 1\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        l[u].append(v)\n        l[v].append(u)\n    ct = [0 for _ in range(n + 1)]\n    tree = [0 for _ in range(n + 1)]\n    dfs(1, l, ct, tree)\n    q = int(input())\n    g_ct = n - 1\n    one = [False] * (n + 1)\n    for _ in range(q):\n        ar = list(map(int, input().split()))\n        if ar[0] == 1:\n            curr = ar[1]\n            if ct[curr] == 0 and (not one[curr]):\n                ct[tree[curr]] -= 1\n                g_ct -= 1\n                one[curr] = True\n        else:\n            print(n - 1 if one[1] else g_ct)", "def order(parent, children, thisdict, visited, element, par):\n    if visited[element] == True:\n        return\n    visited[element] = True\n    parent[element] = par\n    if par != -1:\n        children[par].append(element)\n    for i in thisdict[element]:\n        if visited[i] == False:\n            order(parent, children, thisdict, visited, i, element)\nfor i in range(int(input())):\n    N = int(input())\n    thisdict = {}\n    value = [0 for _ in range(N)]\n    parent = [-1 for i in range(N)]\n    children = [[] for i in range(N)]\n    visited = [False for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = input().split()\n        u = int(u) - 1\n        v = int(v) - 1\n        if u in thisdict:\n            thisdict[u].append(v)\n        else:\n            thisdict[u] = [v]\n        if v in thisdict:\n            thisdict[v].append(u)\n        else:\n            thisdict[v] = [u]\n    order(parent, children, thisdict, visited, 0, -1)\n    Q = int(input())\n    ones = 0\n    for i in range(Q):\n        x = input().split()\n        type = int(x[0])\n        if type == 1:\n            index = int(x[1])\n            index = index - 1\n            if value[index] == 1:\n                continue\n            if children[index] == []:\n                value[index] = 1\n                ones += 1\n            else:\n                lol = 1\n                for j in children[index]:\n                    if value[j] == 0:\n                        lol = 0\n                        break\n                    lol = lol & value[j]\n                if lol == 1:\n                    value[index] = 1\n                    ones += 1\n        elif ones == N:\n            print(N - 1)\n        else:\n            print(N - 1 - ones)", "import queue\n\ndef _bfs(r, adj, parent, visited, chld):\n    q = queue.Queue()\n    q.put(r)\n    while q.empty() is False:\n        curr = q.get()\n        visited[curr - 1] = True\n        count = 0\n        for child in adj[curr]:\n            if visited[child - 1] is False:\n                parent[child - 1] = curr\n                visited[child - 1] = True\n                q.put(child)\n                count += 1\n        chld[curr - 1] = count\n\ndef solve(n, edges, q, queries):\n    adj = {}\n    for (a, b) in edges:\n        if a not in adj:\n            adj[a] = [b]\n        else:\n            adj[a].append(b)\n        if b not in adj:\n            adj[b] = [a]\n        else:\n            adj[b].append(a)\n    values = [0 for i in range(n)]\n    parent = [-1 for i in range(n)]\n    visited = [False for i in range(n)]\n    child = [0 for i in range(n)]\n    _bfs(1, adj, parent, visited, child)\n    ans = n - 1\n    for qu in queries:\n        if qu[0] == 1:\n            node = qu[1]\n            if values[node - 1] == 1 or child[node - 1] > 0:\n                continue\n            else:\n                child[parent[node - 1] - 1] -= 1\n                values[node - 1] = 1\n                if ans > 0:\n                    ans -= 1\n        elif values[0] == 1:\n            print(n - 1)\n        else:\n            print(ans)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    edges = []\n    for i in range(n - 1):\n        edges.append([int(x) for x in input().split()])\n    q = int(input())\n    queries = []\n    for i in range(q):\n        queries.append([int(x) for x in input().split()])\n    solve(n, edges, q, queries)", "import queue\n\ndef _bfs(r, adj, parent, visited, chld):\n    q = queue.Queue()\n    q.put(r)\n    while q.empty() is False:\n        curr = q.get()\n        visited[curr - 1] = True\n        count = 0\n        for child in adj[curr]:\n            if visited[child - 1] is False:\n                parent[child - 1] = curr\n                visited[child - 1] = True\n                q.put(child)\n                count += 1\n        chld[curr - 1] = count\n\ndef solve(n, edges, q, queries):\n    adj = {}\n    for (a, b) in edges:\n        if a not in adj:\n            adj[a] = [b]\n        else:\n            adj[a].append(b)\n        if b not in adj:\n            adj[b] = [a]\n        else:\n            adj[b].append(a)\n    values = [0 for i in range(n)]\n    parent = [-1 for i in range(n)]\n    visited = [False for i in range(n)]\n    child = [0 for i in range(n)]\n    _bfs(1, adj, parent, visited, child)\n    ans = n - 1\n    for qu in queries:\n        if qu[0] == 1:\n            node = qu[1]\n            if values[node - 1] == 1 or child[node - 1] > 0:\n                continue\n            else:\n                child[parent[node - 1] - 1] -= 1\n                values[node - 1] = 1\n                if ans > 0:\n                    ans -= 1\n        elif values[0] == 1:\n            print(n - 1)\n        else:\n            print(ans)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    edges = []\n    for i in range(n - 1):\n        edges.append([int(x) for x in input().split()])\n    q = int(input())\n    queries = []\n    for i in range(q):\n        queries.append([int(x) for x in input().split()])\n    solve(n, edges, q, queries)", "from collections import deque\nfor tea in range(int(input())):\n    n = int(input())\n    conn = dict()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        if a in conn:\n            conn[a].append(b)\n        else:\n            conn[a] = [b]\n        if b in conn:\n            conn[b].append(a)\n        else:\n            conn[b] = [a]\n    parent = [-1 for i in range(n)]\n    children = [[] for i in range(n)]\n    bfs = deque([0])\n    while True:\n        try:\n            lol = bfs.popleft()\n        except:\n            break\n        for i in conn[lol]:\n            if i != parent[lol]:\n                parent[i] = lol\n                children[lol].append(i)\n                bfs.append(i)\n    values = [0 for i in range(n)]\n    oneCount = 0\n    for queue in range(int(input())):\n        prompt = [int(x) for x in input().split()]\n        if prompt[0] == 1:\n            if values[prompt[1] - 1] == 1 or oneCount < len(children[prompt[1] - 1]):\n                continue\n            lol = 1\n            for i in children[prompt[1] - 1]:\n                lol = lol & values[i]\n            if lol == 1:\n                oneCount += 1\n            values[prompt[1] - 1] = lol\n        elif oneCount == n:\n            print(n - 1)\n        else:\n            print(n - 1 - oneCount)", "def dfs(curr, adj, par, child):\n    for elem in adj[curr]:\n        if par[elem] != -1:\n            continue\n        par[elem] = curr\n        child[curr].append(elem)\n        dfs(elem, adj, par, child)\nfor i in range(int(input())):\n    n = int(input())\n    val = [0] * n\n    adj = []\n    child = []\n    for j in range(n):\n        adj.append([])\n        child.append([])\n    for j in range(n - 1):\n        (s, d) = map(int, input().split())\n        adj[s - 1].append(d - 1)\n        adj[d - 1].append(s - 1)\n    good = n - 1\n    par = [-2] + [-1] * (n - 1)\n    dfs(0, adj, par, child)\n    for q in range(int(input())):\n        ask = list(map(int, input().split()))\n        if ask[0] == 2:\n            print(good % n)\n        else:\n            node = ask[1] - 1\n            if val[node] == 1:\n                continue\n            if len(child[node]) == 0:\n                val[node] = 1\n                good -= 1\n            else:\n                change = True\n                for elem in child[node]:\n                    if val[elem] == 0:\n                        change = False\n                        break\n                if change:\n                    good -= 1\n                    val[node] = 1", "def dfs(curr, adj, par, child):\n    for elem in adj[curr]:\n        if par[elem] != -1:\n            continue\n        par[elem] = curr\n        child[curr].append(elem)\n        dfs(elem, adj, par, child)\nfor i in range(int(input())):\n    n = int(input())\n    val = [0] * n\n    adj = []\n    child = []\n    for j in range(n):\n        adj.append([])\n        child.append([])\n    for j in range(n - 1):\n        (s, d) = map(int, input().split())\n        adj[s - 1].append(d - 1)\n        adj[d - 1].append(s - 1)\n    good = n - 1\n    par = [-2] + [-1] * (n - 1)\n    dfs(0, adj, par, child)\n    for q in range(int(input())):\n        ask = list(map(int, input().split()))\n        if ask[0] == 2:\n            print(good % n)\n        else:\n            node = ask[1] - 1\n            if val[node] == 1:\n                continue\n            if len(child[node]) == 0:\n                val[node] = 1\n                good -= 1\n            else:\n                change = True\n                for elem in child[node]:\n                    if val[elem] == 0:\n                        change = False\n                        break\n                if change:\n                    good -= 1\n                    val[node] = 1", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\nfor tea in range(int(input())):\n    n = int(input())\n    conn = dict()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        if a in conn:\n            conn[a].append(b)\n        else:\n            conn[a] = [b]\n        if b in conn:\n            conn[b].append(a)\n        else:\n            conn[b] = [a]\n    parent = [-1 for i in range(n)]\n    children = [[] for i in range(n)]\n    bfs = deque([0])\n    while True:\n        try:\n            lol = bfs.popleft()\n        except:\n            break\n        for i in conn[lol]:\n            if i != parent[lol]:\n                parent[i] = lol\n                children[lol].append(i)\n                bfs.append(i)\n    values = [0 for i in range(n)]\n    oneCount = 0\n    for queue in range(int(input())):\n        prompt = [int(x) for x in input().split()]\n        if prompt[0] == 1:\n            if values[prompt[1] - 1] == 1 or oneCount < len(children[prompt[1] - 1]):\n                continue\n            lol = 1\n            for i in children[prompt[1] - 1]:\n                lol = lol & values[i]\n            if lol == 1:\n                oneCount += 1\n            values[prompt[1] - 1] = lol\n        elif oneCount == n:\n            print(n - 1)\n        else:\n            print(n - 1 - oneCount)", "from collections import deque\nfor tea in range(int(input())):\n    n = int(input())\n    conn = dict()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        if a in conn:\n            conn[a].append(b)\n        else:\n            conn[a] = [b]\n        if b in conn:\n            conn[b].append(a)\n        else:\n            conn[b] = [a]\n    parent = [-1 for i in range(n)]\n    children = [[] for i in range(n)]\n    bfs = deque([0])\n    while True:\n        try:\n            lol = bfs.popleft()\n        except:\n            break\n        for i in conn[lol]:\n            if i != parent[lol]:\n                parent[i] = lol\n                children[lol].append(i)\n                bfs.append(i)\n    values = [0 for i in range(n)]\n    oneCount = 0\n    for queue in range(int(input())):\n        prompt = [int(x) for x in input().split()]\n        if prompt[0] == 1:\n            if values[prompt[1] - 1] == 1 or oneCount < len(children[prompt[1] - 1]):\n                continue\n            lol = 1\n            for i in children[prompt[1] - 1]:\n                lol = lol & values[i]\n            if lol == 1:\n                oneCount += 1\n            values[prompt[1] - 1] = lol\n        elif oneCount == n:\n            print(n - 1)\n        else:\n            print(n - 1 - oneCount)", "for _ in range(int(input())):\n    n = int(input())\n    graph = [dict() for _ in range(n + 1)]\n    cnt = [0] * (n + 1)\n    cnt[1] = 1\n    graph[0][1] = True\n    graph[1][0] = True\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        cnt[u] += 1\n        cnt[v] += 1\n        graph[u][v] = True\n        graph[v][u] = True\n    ans = n - 1\n    for _ in range(int(input())):\n        inp = [int(x) for x in input().split()]\n        if len(inp) > 1:\n            node = inp[1]\n            if cnt[node] > 0:\n                if cnt[node] == 1:\n                    pnode = None\n                    for i in graph[node].keys():\n                        pnode = i\n                    graph[pnode].pop(node)\n                    cnt[node] -= 1\n                    cnt[pnode] -= 1\n                    if node == 1:\n                        ans = n - 1\n                    else:\n                        ans -= 1\n        else:\n            print(ans)", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random, threading\nfrom functools import lru_cache\nfrom itertools import *\nimport sys\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n(M, M1, pi) = (1000000007, 998244353, 3.141592653589793)\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for _ in range(1, how_much_noob_I_am + 1):\n        n = inpu()\n        d = defaultdict(list)\n        indegree = defaultdict(int)\n        par = [-1] * (n + 1)\n        q = deque()\n        q.append([1, -1])\n        for i in range(n - 1):\n            (a, b) = sep()\n            d[a].append(b)\n            d[b].append(a)\n            indegree[a] += 1\n            indegree[b] += 1\n        while q:\n            (s, p) = q.popleft()\n            for j in d[s]:\n                if j == p:\n                    continue\n                par[j] = s\n                q.append([j, s])\n        curr = set()\n        for i in range(2, n + 1):\n            if indegree[i] == 1:\n                curr.add(i)\n        q = inpu()\n        tot = set()\n        for i in range(q):\n            l = lis()\n            if l[0] == 1:\n                if l[1] in curr:\n                    tot.add(l[1])\n                    curr.remove(l[1])\n                    if par[l[1]] == -1:\n                        continue\n                    indegree[par[l[1]]] -= 1\n                    if par[l[1]] == 1:\n                        if indegree[par[l[1]]] == 0:\n                            curr.add(par[l[1]])\n                    elif indegree[par[l[1]]] == 1:\n                        curr.add(par[l[1]])\n            else:\n                if len(tot) == n:\n                    print(n - 1)\n                    continue\n                print(n - 1 - len(tot))\nmain()", "T = int(input())\nfor _ in range(T):\n    V = int(input())\n    val = {i + 1: 0 for i in range(V)}\n    E = []\n    P = {i + 1: -1 for i in range(V)}\n    C = {i + 1: [] for i in range(V)}\n    A = {i + 1: [] for i in range(V)}\n    for i in range(V - 1):\n        (u, v) = (int(j) for j in input().split())\n        E.append((u, v))\n        A[u].append(v)\n        A[v].append(u)\n    vis = {i + 1: False for i in range(V)}\n    qu = [1]\n    while len(qu) != 0:\n        v = qu[-1]\n        qu.pop()\n        vis[v] = True\n        for u in A[v]:\n            if not vis[u]:\n                qu.append(u)\n                C[v].append(u)\n                P[u] = v\n    Q = int(input())\n    gE = [True] * (V - 1)\n    gEn = V - 1\n    for i in range(Q):\n        inpQ = [int(j) for j in input().split()]\n        if inpQ[0] == 1:\n            u = inpQ[1]\n            if len(C[u]) == 0:\n                if val[u] == 1:\n                    continue\n                if val[u] == 0:\n                    val[u] = 1\n                    gEn -= 1\n            else:\n                new_val = 1\n                for c in C[u]:\n                    if val[c] == 0:\n                        new_val = 0\n                        break\n                if new_val == val[u]:\n                    continue\n                else:\n                    val[u] = 1\n                    if u == 1:\n                        gEn = V - 1\n                    else:\n                        gEn -= 1\n        if inpQ[0] == 2:\n            print(gEn)", "from collections import deque\nfor tea in range(int(input())):\n    n = int(input())\n    conn = dict()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        if a in conn:\n            conn[a].append(b)\n        else:\n            conn[a] = [b]\n        if b in conn:\n            conn[b].append(a)\n        else:\n            conn[b] = [a]\n    parent = [-1 for i in range(n)]\n    children = [[] for i in range(n)]\n    bfs = deque([0])\n    while True:\n        try:\n            lol = bfs.popleft()\n        except:\n            break\n        for i in conn[lol]:\n            if i != parent[lol]:\n                parent[i] = lol\n                children[lol].append(i)\n                bfs.append(i)\n    values = [0 for i in range(n)]\n    oneCount = 0\n    for queue in range(int(input())):\n        prompt = [int(x) for x in input().split()]\n        if prompt[0] == 1:\n            if values[prompt[1] - 1] == 1 or oneCount < len(children[prompt[1] - 1]):\n                continue\n            lol = 1\n            for i in children[prompt[1] - 1]:\n                lol = lol & values[i]\n            if lol == 1:\n                oneCount += 1\n            values[prompt[1] - 1] = lol\n        elif oneCount == n:\n            print(n - 1)\n        else:\n            print(n - 1 - oneCount)", "from collections import deque\nfor tea in range(int(input())):\n    n = int(input())\n    conn = dict()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        if a in conn:\n            conn[a].append(b)\n        else:\n            conn[a] = [b]\n        if b in conn:\n            conn[b].append(a)\n        else:\n            conn[b] = [a]\n    parent = [-1 for i in range(n)]\n    children = [[] for i in range(n)]\n    bfs = deque([0])\n    while True:\n        try:\n            lol = bfs.popleft()\n        except:\n            break\n        for i in conn[lol]:\n            if i != parent[lol]:\n                parent[i] = lol\n                children[lol].append(i)\n                bfs.append(i)\n    values = [0 for i in range(n)]\n    oneCount = 0\n    for queue in range(int(input())):\n        prompt = [int(x) for x in input().split()]\n        if prompt[0] == 1:\n            if values[prompt[1] - 1] == 1 or oneCount < len(children[prompt[1] - 1]):\n                continue\n            lol = 1\n            for i in children[prompt[1] - 1]:\n                lol = lol & values[i]\n            if lol == 1:\n                oneCount += 1\n            values[prompt[1] - 1] = lol\n        elif oneCount == n:\n            print(n - 1)\n        else:\n            print(n - 1 - oneCount)", "T = int(input())\n\ndef dfs1(cur, adj, cnt, parents):\n    ccnt = 0\n    for c in adj[cur]:\n        if parents[cur] == c:\n            continue\n        parents[c] = cur\n        ccnt += dfs1(c, adj, cnt, parents)\n    cnt[cur] = ccnt\n    return 1\nfor t in range(T):\n    n = int(input())\n    adj = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    cnt = [0 for _ in range(n + 1)]\n    parents = [0 for _ in range(n + 1)]\n    dfs1(1, adj, cnt, parents)\n    Q = int(input())\n    gcnt = n - 1\n    all_one = [False] * (n + 1)\n    for q in range(Q):\n        cmd = list(map(int, input().split()))\n        if cmd[0] == 1:\n            cur = cmd[1]\n            if cnt[cur] == 0 and (not all_one[cur]):\n                cnt[parents[cur]] -= 1\n                gcnt -= 1\n                all_one[cur] = True\n        else:\n            print(n - 1 if all_one[1] else gcnt)"]