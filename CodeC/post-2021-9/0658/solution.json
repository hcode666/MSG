["def gcd(a, b):\n    (a, b) = (max(a, b), min(a, b))\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    flag = 0\n    cur = A[0]\n    for i in range(1, n):\n        new = gcd(cur, A[i])\n        if new == 1:\n            if flag == 0:\n                flag = 1\n                r = i\n                continue\n            print(-1)\n            break\n        cur = new\n    else:\n        if flag == 0:\n            print(0)\n            continue\n        (A[r], A[-1]) = (A[-1], A[r])\n        flag = 0\n        cur = A[-1]\n        l = 0\n        for i in range(n - 2, -1, -1):\n            g = gcd(A[i], cur)\n            if g == 1:\n                if flag == 0:\n                    flag = 1\n                    l = i\n                    continue\n                print(-1)\n                break\n            cur = g\n        else:\n            if l == 0 and r == n - 1:\n                print(0)\n                continue\n            if l == 0:\n                print(1)\n                print(r + 1, n)\n                continue\n            if r == n - 1:\n                print(1)\n                print(1, l + 1)\n                continue\n            print(2)\n            print(1, l + 1)\n            print(r + 1, n)", "def gcd(a, b):\n    (a, b) = (max(a, b), min(a, b))\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    flag = 0\n    cur = A[0]\n    for i in range(1, n):\n        new = gcd(cur, A[i])\n        if new == 1:\n            if flag == 0:\n                flag = 1\n                r = i\n                continue\n            print(-1)\n            break\n        cur = new\n    else:\n        if flag == 0:\n            print(0)\n            continue\n        (A[r], A[-1]) = (A[-1], A[r])\n        flag = 0\n        cur = A[-1]\n        l = 0\n        for i in range(n - 2, -1, -1):\n            g = gcd(A[i], cur)\n            if g == 1:\n                if flag == 0:\n                    flag = 1\n                    l = i\n                    continue\n                print(-1)\n                break\n            cur = g\n        else:\n            if l == 0 and r == n - 1:\n                print(0)\n                continue\n            if l == 0:\n                print(1)\n                print(r + 1, n)\n                continue\n            if r == n - 1:\n                print(1)\n                print(1, l + 1)\n                continue\n            print(2)\n            print(1, l + 1)\n            print(r + 1, n)", "import math\n\ndef gcdd(n, l):\n    p = [0] * (n + 2)\n    s = [0] * (n + 2)\n    for i in range(n):\n        p[i + 1] = math.gcd(p[i], l[i])\n    for i in range(n - 1, -1, -1):\n        s[i + 1] = math.gcd(s[i + 2], l[i])\n    if p[-2] != 1:\n        print(0)\n        return\n    indx = []\n    for i in range(1, n + 1):\n        if math.gcd(p[i - 1], s[i + 1]) != 1:\n            indx.append(i)\n    if len(indx) < 2:\n        print(-1)\n        return\n    a = []\n    if indx[0] != 1:\n        a.append((1, indx[0]))\n    if indx[-1] != n:\n        a.append((indx[-1], n))\n    print(len(a))\n    for j in a:\n        print(*j)\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    ar = list(map(int, input().split()))\n    gcdd(n, ar)\n    t -= 1", "import math\n\ndef gcdd(n, l):\n    p = [0] * (n + 2)\n    s = [0] * (n + 2)\n    for i in range(n):\n        p[i + 1] = math.gcd(p[i], l[i])\n    for i in range(n - 1, -1, -1):\n        s[i + 1] = math.gcd(s[i + 2], l[i])\n    if p[-2] != 1:\n        print(0)\n        return\n    indx = []\n    for i in range(1, n + 1):\n        if math.gcd(p[i - 1], s[i + 1]) != 1:\n            indx.append(i)\n    if len(indx) < 2:\n        print(-1)\n        return\n    a = []\n    if indx[0] != 1:\n        a.append((1, indx[0]))\n    if indx[-1] != n:\n        a.append((indx[-1], n))\n    print(len(a))\n    for j in a:\n        print(*j)\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    ar = list(map(int, input().split()))\n    gcdd(n, ar)\n    t -= 1", "import math\n\ndef gcdd(n, l):\n    p = [0] * (n + 2)\n    s = [0] * (n + 2)\n    for i in range(n):\n        p[i + 1] = math.gcd(p[i], l[i])\n    for i in range(n - 1, -1, -1):\n        s[i + 1] = math.gcd(s[i + 2], l[i])\n    if p[-2] != 1:\n        print(0)\n        return\n    indx = []\n    for i in range(1, n + 1):\n        if math.gcd(p[i - 1], s[i + 1]) != 1:\n            indx.append(i)\n    if len(indx) < 2:\n        print(-1)\n        return\n    a = []\n    if indx[0] != 1:\n        a.append((1, indx[0]))\n    if indx[-1] != n:\n        a.append((indx[-1], n))\n    print(len(a))\n    for j in a:\n        print(*j)\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    ar = list(map(int, input().split()))\n    gcdd(n, ar)\n    t -= 1", "import math\n\ndef ga(n, l):\n    pgcd = [0] * (n + 2)\n    sgcd = [0] * (n + 2)\n    for i in range(n):\n        pgcd[i + 1] = math.gcd(pgcd[i], l[i])\n    for i in range(n - 1, -1, -1):\n        sgcd[i + 1] = math.gcd(sgcd[i + 2], l[i])\n    if pgcd[-2] != 1:\n        print(0)\n        return\n    ind = []\n    for i in range(1, n + 1):\n        if math.gcd(pgcd[i - 1], sgcd[i + 1]) != 1:\n            ind.append(i)\n    if len(ind) < 2:\n        print(-1)\n        return\n    ans = []\n    if ind[0] != 1:\n        ans.append((1, ind[0]))\n    if ind[-1] != n:\n        ans.append((ind[-1], n))\n    print(len(ans))\n    for i in ans:\n        print(*i)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ga(n, arr)", "def gcd(a, b):\n    (a, b) = (max(a, b), min(a, b))\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    flag = 0\n    cur = A[0]\n    for i in range(1, n):\n        new = gcd(cur, A[i])\n        if new == 1:\n            if flag == 0:\n                flag = 1\n                r = i\n                continue\n            print(-1)\n            break\n        cur = new\n    else:\n        if flag == 0:\n            print(0)\n            continue\n        (A[r], A[-1]) = (A[-1], A[r])\n        flag = 0\n        cur = A[-1]\n        l = 0\n        for i in range(n - 2, -1, -1):\n            g = gcd(A[i], cur)\n            if g == 1:\n                if flag == 0:\n                    flag = 1\n                    l = i\n                    continue\n                print(-1)\n                break\n            cur = g\n        else:\n            if l == 0 and r == n - 1:\n                print(0)\n                continue\n            if l == 0:\n                print(1)\n                print(r + 1, n)\n                continue\n            if r == n - 1:\n                print(1)\n                print(1, l + 1)\n                continue\n            print(2)\n            print(1, l + 1)\n            print(r + 1, n)", "def gcd(a, b):\n    (a, b) = (max(a, b), min(a, b))\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    flag = 0\n    cur = A[0]\n    for i in range(1, n):\n        new = gcd(cur, A[i])\n        if new == 1:\n            if flag == 0:\n                flag = 1\n                r = i\n                continue\n            print(-1)\n            break\n        cur = new\n    else:\n        if flag == 0:\n            print(0)\n            continue\n        (A[r], A[-1]) = (A[-1], A[r])\n        flag = 0\n        cur = A[-1]\n        l = 0\n        for i in range(n - 2, -1, -1):\n            g = gcd(A[i], cur)\n            if g == 1:\n                if flag == 0:\n                    flag = 1\n                    l = i\n                    continue\n                print(-1)\n                break\n            cur = g\n        else:\n            if l == 0 and r == n - 1:\n                print(0)\n                continue\n            if l == 0:\n                print(1)\n                print(r + 1, n)\n                continue\n            if r == n - 1:\n                print(1)\n                print(1, l + 1)\n                continue\n            print(2)\n            print(1, l + 1)\n            print(r + 1, n)", "import collections\nimport heapq\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom io import BytesIO, IOBase\nimport os\n\ndef values():\n    return tuple(map(int, sys.stdin.readline().split()))\n\ndef inlsts():\n    return [int(i) for i in sys.stdin.readline().split()]\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef instr():\n    return sys.stdin.readline().strip()\n\ndef words():\n    return [i for i in sys.stdin.readline().strip().split()]\n\ndef chars():\n    return [i for i in sys.stdin.readline().strip()]\n\ndef solve():\n    n = inp()\n    l = inlsts()\n    pgcd = [0] * (n + 2)\n    sgcd = [0] * (n + 2)\n    for i in range(n):\n        pgcd[i + 1] = math.gcd(pgcd[i], l[i])\n    for i in range(n - 1, -1, -1):\n        sgcd[i + 1] = math.gcd(sgcd[i + 2], l[i])\n    if pgcd[-2] != 1:\n        print(0)\n        return\n    ind = []\n    for i in range(1, n + 1):\n        if math.gcd(pgcd[i - 1], sgcd[i + 1]) != 1:\n            ind.append(i)\n    if len(ind) < 2:\n        print(-1)\n        return\n    ans = []\n    if ind[0] != 1:\n        ans.append((1, ind[0]))\n    if ind[-1] != n:\n        ans.append((ind[-1], n))\n    print(len(ans))\n    for i in ans:\n        print(*i)\nfor i in range(inp()):\n    solve()", "from math import *\nimport sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    pgcd = [0 for i in range(n)]\n    sgcd = [0 for i in range(n)]\n    pgcd[0] = l[0]\n    for i in range(1, n):\n        pgcd[i] = gcd(pgcd[i - 1], l[i])\n    sgcd[-1] = l[-1]\n    for i in range(n - 2, -1, -1):\n        sgcd[i] = gcd(sgcd[i + 1], l[i])\n    if pgcd[-1] != 1:\n        print(0)\n        continue\n    count = 0\n    ind = []\n    for i in range(n):\n        if i == 0:\n            g = sgcd[i + 1]\n        elif i == n - 1:\n            g = pgcd[i - 1]\n        else:\n            g = gcd(pgcd[i - 1], sgcd[i + 1])\n        if g != 1:\n            count += 1\n            ind.append(i)\n    if count < 2:\n        print(-1)\n    elif 0 in ind and n - 1 in ind:\n        print(0)\n    elif 0 in ind:\n        print(1)\n        print(1 + ind[1], n)\n    elif n - 1 in ind:\n        print(1)\n        print(1, ind[0] + 1)\n    else:\n        print(2)\n        print(1, 1 + ind[0])\n        print(1 + ind[1], n)", "from math import *\nimport sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    pgcd = [0 for i in range(n)]\n    sgcd = [0 for i in range(n)]\n    pgcd[0] = l[0]\n    for i in range(1, n):\n        pgcd[i] = gcd(pgcd[i - 1], l[i])\n    sgcd[-1] = l[-1]\n    for i in range(n - 2, -1, -1):\n        sgcd[i] = gcd(sgcd[i + 1], l[i])\n    if pgcd[-1] != 1:\n        print(0)\n        continue\n    count = 0\n    ind = []\n    for i in range(n):\n        if i == 0:\n            g = sgcd[i + 1]\n        elif i == n - 1:\n            g = pgcd[i - 1]\n        else:\n            g = gcd(pgcd[i - 1], sgcd[i + 1])\n        if g != 1:\n            count += 1\n            ind.append(i)\n    if count < 2:\n        print(-1)\n    elif 0 in ind and n - 1 in ind:\n        print(0)\n    elif 0 in ind:\n        print(1)\n        print(1 + ind[1], n)\n    elif n - 1 in ind:\n        print(1)\n        print(1, ind[0] + 1)\n    else:\n        print(2)\n        print(1, 1 + ind[0])\n        print(1 + ind[1], n)", "import sys, math\n\ndef get_arr():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef find_gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\nt = int(sys.stdin.readline())\nfor t2 in range(t):\n    n = int(sys.stdin.readline())\n    a = get_arr()\n    if n == 2:\n        print(0)\n        continue\n    arr = a\n    num1 = a[0]\n    num2 = a[1]\n    gcd = find_gcd(num1, num2)\n    idx1 = -1\n    idx2 = -1\n    if gcd == 1:\n        idx1 = 1\n    else:\n        for i in range(2, n):\n            gcd = find_gcd(gcd, a[i])\n            if gcd == 1:\n                idx1 = i\n                break\n    if idx1 == -1:\n        print(0)\n        continue\n    swaps = 0\n    ans = []\n    if idx1 != n - 1:\n        temp = arr[-1]\n        arr[-1] = arr[idx1]\n        arr[idx1] = temp\n        swaps += 1\n        ans.append([idx1 + 1, n])\n    num1 = a[0]\n    num2 = a[1]\n    gcd = find_gcd(num1, num2)\n    fl = 0\n    for i in range(2, n - 1):\n        if gcd == 1:\n            print(-1)\n            fl = 1\n            break\n        gcd = find_gcd(gcd, a[i])\n    if gcd == 1 and fl != 1:\n        print(-1)\n        fl = 1\n    if fl == 1:\n        continue\n    a.reverse()\n    num1 = a[0]\n    num2 = a[1]\n    gcd = find_gcd(num1, num2)\n    idx1 = -1\n    idx2 = -1\n    if gcd == 1:\n        idx1 = 1\n    else:\n        for i in range(2, n - 1):\n            gcd = find_gcd(gcd, a[i])\n            if gcd == 1:\n                idx1 = i\n                break\n    if idx1 == -1:\n        print(swaps)\n        for i in ans:\n            print(*i)\n        continue\n    temp = arr[-1]\n    arr[-1] = arr[idx1]\n    arr[idx1] = temp\n    swaps += 1\n    ans.append([1, n - idx1])\n    num1 = a[0]\n    num2 = a[1]\n    gcd = find_gcd(num1, num2)\n    fl = 0\n    for i in range(2, n - 1):\n        if gcd == 1:\n            print(-1)\n            fl = 1\n            break\n        gcd = find_gcd(gcd, a[i])\n    if gcd == 1 and fl != 1:\n        print(-1)\n        fl = 1\n    if fl == 1:\n        continue\n    print(swaps)\n    for i in ans:\n        print(*i)", "from math import gcd\nfrom sys import stdin\ninput = stdin.readline\n\ndef good(N, A):\n    G = A[0]\n    for i in range(1, N - 1):\n        G = gcd(A[i], G)\n        if G == 1:\n            return False\n    G = A[1]\n    for i in range(2, N):\n        G = gcd(A[i], G)\n        if G == 1:\n            return False\n    return True\n\ndef solve(N, A):\n    if N == 2:\n        if gcd(*A) == 1:\n            return (0, [])\n        else:\n            return (-1, [])\n    G = A[0]\n    k = None\n    for i in range(1, N):\n        G = gcd(A[i], G)\n        if G == 1:\n            k = i\n            break\n    if k == None:\n        return (0, [])\n    count = 0\n    operations = []\n    if k != N - 1:\n        count += 1\n        operations.append((k + 1, N))\n        A = A[:k] + list(reversed(A[k:]))\n    G = A[N - 1]\n    k = None\n    for i in reversed(range(N - 1)):\n        G = gcd(A[i], G)\n        if G == 1:\n            k = i\n            break\n    if k != None and k != 0:\n        count += 1\n        operations.append((1, k + 1))\n        A = list(reversed(A[:k + 1])) + A[k + 1:]\n    if good(N, A):\n        return (count, operations)\n    else:\n        return (-1, [])\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    N = int(input().strip())\n    A = [int(x) for x in input().strip().split()]\n    (X, operations) = solve(N, A)\n    print(X)\n    for operation in operations:\n        print(*operation)"]