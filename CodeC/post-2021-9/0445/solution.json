["t = int(input())\nans = []\nfor _ in range(t):\n    n = int(input())\n    l = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        l[u].append([v, w])\n        l[v].append([u, w])\n    xorl = [0 for i in range(n + 1)]\n    visited = [False for i in range(n + 1)]\n    queue = [l[1]]\n    q2 = [1]\n    visited[1] = True\n    while queue:\n        s = queue.pop(0)\n        si = q2.pop(0)\n        for i in s:\n            if visited[i[0]] == False:\n                xorl[i[0]] = xorl[si] ^ i[1]\n                queue.append(l[i[0]])\n                q2.append(i[0])\n                visited[i[0]] = True\n    d = {}\n    t = 0\n    for i in range(1, len(xorl)):\n        for j in range(i + 1, len(xorl)):\n            if xorl[i] ^ xorl[j] in d:\n                a = d[xorl[i] ^ xorl[j]][0]\n                b = d[xorl[i] ^ xorl[j]][1]\n                c1 = i\n                d1 = j\n                t = 1\n            else:\n                d[xorl[i] ^ xorl[j]] = [i, j]\n        if t:\n            break\n    if t:\n        print(a, b, c1, d1)\n    else:\n        print(-1)", "t = int(input())\nans = []\nfor _ in range(t):\n    n = int(input())\n    l = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        l[u].append([v, w])\n        l[v].append([u, w])\n    xorl = [0 for i in range(n + 1)]\n    visited = [False for i in range(n + 1)]\n    queue = [l[1]]\n    q2 = [1]\n    visited[1] = True\n    while queue:\n        s = queue.pop(0)\n        si = q2.pop(0)\n        for i in s:\n            if visited[i[0]] == False:\n                xorl[i[0]] = xorl[si] ^ i[1]\n                queue.append(l[i[0]])\n                q2.append(i[0])\n                visited[i[0]] = True\n    d = {}\n    t = 0\n    for i in range(1, len(xorl)):\n        for j in range(i + 1, len(xorl)):\n            if xorl[i] ^ xorl[j] in d:\n                a = d[xorl[i] ^ xorl[j]][0]\n                b = d[xorl[i] ^ xorl[j]][1]\n                c1 = i\n                d1 = j\n                t = 1\n            else:\n                d[xorl[i] ^ xorl[j]] = [i, j]\n        if t:\n            break\n    if t:\n        print(a, b, c1, d1)\n    else:\n        print(-1)", "import math\nimport bisect\nfor _ in range(int(input())):\n    n = int(input())\n    l = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a = list(map(int, input().strip().split()))\n        l[a[0]].append([a[1], a[2]])\n        l[a[1]].append([a[0], a[2]])\n    xorl = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    queue = []\n    q2 = []\n    q2.append(1)\n    queue.append(l[1])\n    visited[1] = True\n    while queue:\n        s = queue.pop(0)\n        si = q2.pop(0)\n        for i in s:\n            if visited[i[0]] == False:\n                xorl[i[0]] = xorl[si] ^ i[1]\n                queue.append(l[i[0]])\n                q2.append(i[0])\n                visited[i[0]] = True\n    d = {}\n    t = 0\n    for i in range(1, len(xorl)):\n        for j in range(i + 1, len(xorl)):\n            if xorl[i] ^ xorl[j] in d:\n                a1 = d[xorl[i] ^ xorl[j]][0]\n                b1 = d[xorl[i] ^ xorl[j]][1]\n                c1 = i\n                d1 = j\n                t = 1\n                break\n            else:\n                d[xorl[i] ^ xorl[j]] = [i, j]\n        if t:\n            break\n    if t:\n        print(a1, b1, c1, d1)\n    else:\n        print(-1)", "import math\nimport bisect\nfor _ in range(int(input())):\n    n = int(input())\n    l = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a = list(map(int, input().strip().split()))\n        l[a[0]].append([a[1], a[2]])\n        l[a[1]].append([a[0], a[2]])\n    xorl = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    queue = []\n    q2 = []\n    q2.append(1)\n    queue.append(l[1])\n    visited[1] = True\n    while queue:\n        s = queue.pop(0)\n        si = q2.pop(0)\n        for i in s:\n            if visited[i[0]] == False:\n                xorl[i[0]] = xorl[si] ^ i[1]\n                queue.append(l[i[0]])\n                q2.append(i[0])\n                visited[i[0]] = True\n    d = {}\n    t = 0\n    for i in range(1, len(xorl)):\n        for j in range(i + 1, len(xorl)):\n            if xorl[i] ^ xorl[j] in d:\n                a1 = d[xorl[i] ^ xorl[j]][0]\n                b1 = d[xorl[i] ^ xorl[j]][1]\n                c1 = i\n                d1 = j\n                t = 1\n                break\n            else:\n                d[xorl[i] ^ xorl[j]] = [i, j]\n        if t:\n            break\n    if t:\n        print(a1, b1, c1, d1)\n    else:\n        print(-1)", "mod_ = 10 ** 9 + 7\nans = [[-1]]\n\ndef dfs(root, g, p, px, weight, start, map_):\n    xor = px ^ weight\n    (left, right) = (min(start, root), max(start, root))\n    if start != root and xor in map_:\n        if map_[xor] != (left, right):\n            ans[0] = [*map_[xor], left, right]\n            return\n    map_[xor] = (left, right)\n    for (v, w) in g[root]:\n        if len(ans[0]) == 4:\n            return\n        if v == p:\n            continue\n        dfs(v, g, root, xor, w, start, map_)\nt = int(input())\nfor _ in range(t):\n    ans[0] = [-1]\n    n = int(input())\n    g = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        g[u].append([v, w])\n        g[v].append([u, w])\n    map_ = {}\n    for i in range(1, n + 1):\n        if len(ans[0]) == 4:\n            break\n        dfs(i, g, 0, 0, 0, i, map_)\n    print(*ans[0])", "def solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    (dist, vis) = ([0] * n, [0] * n)\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for x in mp.items():\n        if len(x[1]) > 1:\n            (f, s) = (x[1][0], x[1][1])\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print('-1')\nt = int(input())\nfor i in range(t):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef dfs(dist, graph, node=1):\n    for child in graph[node]:\n        if dist[child[0]] == -1:\n            dist[child[0]] = dist[node] ^ child[1]\n            dfs(dist, graph, child[0])\n\ndef solve():\n    n = int(input())\n    graph = {}\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        if u in graph:\n            graph[u].append((v, w))\n        else:\n            graph[u] = [(v, w)]\n        if v in graph:\n            graph[v].append((u, w))\n        else:\n            graph[v] = [(u, w)]\n    distances = [-1] * (n + 1)\n    distances[0] = 0\n    distances[1] = 0\n    dfs(distances, graph)\n    m = {}\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            currDistance = distances[i] ^ distances[j]\n            if currDistance not in m:\n                m[currDistance] = (i, j)\n            else:\n                (a, b) = m[currDistance]\n                print(a, b, i, j)\n                return\n    print(-1)\n    return\nfor _ in range(int(input())):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef dfs(dist, graph, node=1):\n    for child in graph[node]:\n        if dist[child[0]] == -1:\n            dist[child[0]] = dist[node] ^ child[1]\n            dfs(dist, graph, child[0])\n\ndef solve():\n    n = int(input())\n    graph = {}\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        if u in graph:\n            graph[u].append((v, w))\n        else:\n            graph[u] = [(v, w)]\n        if v in graph:\n            graph[v].append((u, w))\n        else:\n            graph[v] = [(u, w)]\n    distances = [-1] * (n + 1)\n    distances[0] = 0\n    distances[1] = 0\n    dfs(distances, graph)\n    m = {}\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            currDistance = distances[i] ^ distances[j]\n            if currDistance not in m:\n                m[currDistance] = (i, j)\n            else:\n                (a, b) = m[currDistance]\n                print(a, b, i, j)\n                return\n    print(-1)\n    return\nfor _ in range(int(input())):\n    solve()", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    graph = defaultdict(list)\n    for __ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        graph[u].append([v, w])\n        graph[v].append([u, w])\n    dp = [0 for i in range(n + 1)]\n\n    def dfs(graph, src, dp, par=-1):\n        for (child, wt) in graph[src]:\n            if child != par:\n                dp[child] = dp[src] ^ wt\n                dfs(graph, child, dp, src)\n    dfs(graph, 1, dp)\n    f = 0\n    res = {}\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            val = dp[i] ^ dp[j]\n            if val in res:\n                print(str(res[val][0]) + ' ' + str(res[val][1]) + ' ' + str(i) + ' ' + str(j))\n                f = 1\n                break\n            else:\n                res[val] = (i, j)\n        if f:\n            break\n    if not f:\n        print(-1)", "from collections import *\nfrom math import *\nfrom queue import *\nfrom heapq import *\nt_ = int(input())\nfor _ in range(t_):\n    n = int(input())\n    adj = defaultdict(list)\n    for __ in range(n - 1):\n        (u, v, wt) = map(int, input().split())\n        adj[u].append([v, wt])\n        adj[v].append([u, wt])\n    prefixXor = [0] * (n + 1)\n\n    def dfs(adj, src, prefixXor, par):\n        for (neigh, wt) in adj[src]:\n            if neigh != par:\n                prefixXor[neigh] = prefixXor[src] ^ wt\n                dfs(adj, neigh, prefixXor, src)\n    dfs(adj, 1, prefixXor, -1)\n    res = {}\n\n    def solve():\n        for k1 in range(1, len(prefixXor)):\n            v1 = prefixXor[k1]\n            for k2 in range(k1 + 1, len(prefixXor)):\n                v2 = prefixXor[k2]\n                tmp = v1 ^ v2\n                if tmp in res:\n                    if res[tmp][0] != k1 or res[tmp][0] != k2:\n                        return (res[tmp][0], res[tmp][1], k1, k2)\n                res[v1 ^ v2] = (k1, k2)\n        return (-1,)\n    print(*solve())", "import sys\ninput = sys.stdin.readline\n\ndef dfs(dist, graph, node=1):\n    for child in graph[node]:\n        if dist[child[0]] == -1:\n            dist[child[0]] = dist[node] ^ child[1]\n            dfs(dist, graph, child[0])\n\ndef solve():\n    n = int(input())\n    graph = {}\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        if u in graph:\n            graph[u].append((v, w))\n        else:\n            graph[u] = [(v, w)]\n        if v in graph:\n            graph[v].append((u, w))\n        else:\n            graph[v] = [(u, w)]\n    distances = [-1] * (n + 1)\n    distances[0] = 0\n    distances[1] = 0\n    dfs(distances, graph)\n    m = {}\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            currDistance = distances[i] ^ distances[j]\n            if currDistance not in m:\n                m[currDistance] = (i, j)\n            else:\n                (a, b) = m[currDistance]\n                print(a, b, i, j)\n                return\n    print(-1)\n    return\nfor _ in range(int(input())):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef dfs(dist, graph, node=1):\n    for child in graph[node]:\n        if dist[child[0]] == -1:\n            dist[child[0]] = dist[node] ^ child[1]\n            dfs(dist, graph, child[0])\n\ndef solve():\n    n = int(input())\n    graph = {}\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        if u in graph:\n            graph[u].append((v, w))\n        else:\n            graph[u] = [(v, w)]\n        if v in graph:\n            graph[v].append((u, w))\n        else:\n            graph[v] = [(u, w)]\n    distances = [-1] * (n + 1)\n    distances[0] = 0\n    distances[1] = 0\n    dfs(distances, graph)\n    m = {}\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            currDistance = distances[i] ^ distances[j]\n            if currDistance not in m:\n                m[currDistance] = (i, j)\n            else:\n                (a, b) = m[currDistance]\n                print(a, b, i, j)\n                return\n    print(-1)\n    return\nfor _ in range(int(input())):\n    solve()", "from collections import *\nfrom math import *\nfrom queue import *\nfrom heapq import *\nt_ = int(input())\nfor _ in range(t_):\n    n = int(input())\n    adj = defaultdict(list)\n    for __ in range(n - 1):\n        (u, v, wt) = map(int, input().split())\n        adj[u].append([v, wt])\n        adj[v].append([u, wt])\n    prefixXor = [0] * (n + 1)\n\n    def dfs(adj, src, prefixXor, par):\n        for (neigh, wt) in adj[src]:\n            if neigh != par:\n                prefixXor[neigh] = prefixXor[src] ^ wt\n                dfs(adj, neigh, prefixXor, src)\n    dfs(adj, 1, prefixXor, -1)\n    res = {}\n\n    def solve():\n        for k1 in range(1, len(prefixXor)):\n            v1 = prefixXor[k1]\n            for k2 in range(k1 + 1, len(prefixXor)):\n                v2 = prefixXor[k2]\n                tmp = v1 ^ v2\n                if tmp in res:\n                    if res[tmp][0] != k1 or res[tmp][0] != k2:\n                        return (res[tmp][0], res[tmp][1], k1, k2)\n                res[v1 ^ v2] = (k1, k2)\n        return (-1,)\n    print(*solve())", "import math\nimport bisect\nfor _ in range(int(input())):\n    n = int(input())\n    l = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a = list(map(int, input().strip().split()))\n        l[a[0]].append([a[1], a[2]])\n        l[a[1]].append([a[0], a[2]])\n    xorl = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    queue = []\n    q2 = []\n    q2.append(1)\n    queue.append(l[1])\n    visited[1] = True\n    while queue:\n        s = queue.pop(0)\n        si = q2.pop(0)\n        for i in s:\n            if visited[i[0]] == False:\n                xorl[i[0]] = xorl[si] ^ i[1]\n                queue.append(l[i[0]])\n                q2.append(i[0])\n                visited[i[0]] = True\n    d = {}\n    t = 0\n    for i in range(1, len(xorl)):\n        for j in range(i + 1, len(xorl)):\n            if xorl[i] ^ xorl[j] in d:\n                a1 = d[xorl[i] ^ xorl[j]][0]\n                b1 = d[xorl[i] ^ xorl[j]][1]\n                c1 = i\n                d1 = j\n                t = 1\n                break\n            else:\n                d[xorl[i] ^ xorl[j]] = [i, j]\n        if t:\n            break\n    if t:\n        print(a1, b1, c1, d1)\n    else:\n        print(-1)", "import sys\ninput = sys.stdin.readline\n\ndef dfs(dist, graph, node=1):\n    for child in graph[node]:\n        if dist[child[0]] == -1:\n            dist[child[0]] = dist[node] ^ child[1]\n            dfs(dist, graph, child[0])\n\ndef solve():\n    n = int(input())\n    graph = {}\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        if u in graph:\n            graph[u].append((v, w))\n        else:\n            graph[u] = [(v, w)]\n        if v in graph:\n            graph[v].append((u, w))\n        else:\n            graph[v] = [(u, w)]\n    distances = [-1] * (n + 1)\n    distances[0] = 0\n    distances[1] = 0\n    dfs(distances, graph)\n    m = {}\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            currDistance = distances[i] ^ distances[j]\n            if currDistance not in m:\n                m[currDistance] = (i, j)\n            else:\n                (a, b) = m[currDistance]\n                print(a, b, i, j)\n                return\n    print(-1)\n    return\nfor _ in range(int(input())):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef dfs(dist, graph, node=1):\n    for child in graph[node]:\n        if dist[child[0]] == -1:\n            dist[child[0]] = dist[node] ^ child[1]\n            dfs(dist, graph, child[0])\n\ndef solve():\n    n = int(input())\n    graph = {}\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        if u in graph:\n            graph[u].append((v, w))\n        else:\n            graph[u] = [(v, w)]\n        if v in graph:\n            graph[v].append((u, w))\n        else:\n            graph[v] = [(u, w)]\n    distances = [-1] * (n + 1)\n    distances[0] = 0\n    distances[1] = 0\n    dfs(distances, graph)\n    m = {}\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            currDistance = distances[i] ^ distances[j]\n            if currDistance not in m:\n                m[currDistance] = (i, j)\n            else:\n                (a, b) = m[currDistance]\n                print(a, b, i, j)\n                return\n    print(-1)\n    return\nfor _ in range(int(input())):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef dfs(dist, graph, node=1):\n    for child in graph[node]:\n        if dist[child[0]] == -1:\n            dist[child[0]] = dist[node] ^ child[1]\n            dfs(dist, graph, child[0])\n\ndef solve():\n    n = int(input())\n    graph = {}\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        if u in graph:\n            graph[u].append((v, w))\n        else:\n            graph[u] = [(v, w)]\n        if v in graph:\n            graph[v].append((u, w))\n        else:\n            graph[v] = [(u, w)]\n    distances = [-1] * (n + 1)\n    distances[0] = 0\n    distances[1] = 0\n    dfs(distances, graph)\n    m = {}\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            currDistance = distances[i] ^ distances[j]\n            if currDistance not in m:\n                m[currDistance] = (i, j)\n            else:\n                (a, b) = m[currDistance]\n                print(a, b, i, j)\n                return\n    print(-1)\n    return\nfor _ in range(int(input())):\n    solve()", "import math\nimport bisect\nfor _ in range(int(input())):\n    n = int(input())\n    l = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a = list(map(int, input().strip().split()))\n        l[a[0]].append([a[1], a[2]])\n        l[a[1]].append([a[0], a[2]])\n    xorl = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    queue = []\n    q2 = []\n    q2.append(1)\n    queue.append(l[1])\n    visited[1] = True\n    while queue:\n        s = queue.pop(0)\n        si = q2.pop(0)\n        for i in s:\n            if visited[i[0]] == False:\n                xorl[i[0]] = xorl[si] ^ i[1]\n                queue.append(l[i[0]])\n                q2.append(i[0])\n                visited[i[0]] = True\n    d = {}\n    t = 0\n    for i in range(1, len(xorl)):\n        for j in range(i + 1, len(xorl)):\n            if xorl[i] ^ xorl[j] in d:\n                a1 = d[xorl[i] ^ xorl[j]][0]\n                b1 = d[xorl[i] ^ xorl[j]][1]\n                c1 = i\n                d1 = j\n                t = 1\n                break\n            else:\n                d[xorl[i] ^ xorl[j]] = [i, j]\n        if t:\n            break\n    if t:\n        print(a1, b1, c1, d1)\n    else:\n        print(-1)", "from collections import defaultdict\n\ndef solve(curr, xor):\n    if visited[curr - 1]:\n        cache[curr] = xor\n        visited[curr - 1] = 0\n        for (av, w) in tree[curr]:\n            if visited[av - 1]:\n                solve(av, xor ^ w)\nt = int(input())\nfor _ in range(0, t):\n    tree = defaultdict(list)\n    n = int(input())\n    cache = defaultdict(list)\n    for i in range(1, n):\n        (u, v, w) = map(int, input().split())\n        tree[u].append([v, w])\n        tree[v].append([u, w])\n        cache[w].append([u, v])\n    visited = [1] * n\n    solve(1, 0)\n    store = {}\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            xor = cache[i] ^ cache[j]\n            if xor in store:\n                print(*[store[xor][0], store[xor][1], i, j])\n                break\n            else:\n                store[xor] = [i, j]\n        else:\n            continue\n        break\n    else:\n        print(-1)\n    continue", "import math\nimport bisect\nfor _ in range(int(input())):\n    n = int(input())\n    l = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a = list(map(int, input().strip().split()))\n        l[a[0]].append([a[1], a[2]])\n        l[a[1]].append([a[0], a[2]])\n    xorl = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    queue = []\n    q2 = []\n    q2.append(1)\n    queue.append(l[1])\n    visited[1] = True\n    while queue:\n        s = queue.pop(0)\n        si = q2.pop(0)\n        for i in s:\n            if visited[i[0]] == False:\n                xorl[i[0]] = xorl[si] ^ i[1]\n                queue.append(l[i[0]])\n                q2.append(i[0])\n                visited[i[0]] = True\n    d = {}\n    t = 0\n    for i in range(1, len(xorl)):\n        for j in range(i + 1, len(xorl)):\n            if xorl[i] ^ xorl[j] in d:\n                a1 = d[xorl[i] ^ xorl[j]][0]\n                b1 = d[xorl[i] ^ xorl[j]][1]\n                c1 = i\n                d1 = j\n                t = 1\n                break\n            else:\n                d[xorl[i] ^ xorl[j]] = [i, j]\n        if t:\n            break\n    if t:\n        print(a1, b1, c1, d1)\n    else:\n        print(-1)", "import math\nimport bisect\nfor _ in range(int(input())):\n    n = int(input())\n    l = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a = list(map(int, input().strip().split()))\n        l[a[0]].append([a[1], a[2]])\n        l[a[1]].append([a[0], a[2]])\n    xorl = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    queue = []\n    q2 = []\n    q2.append(1)\n    queue.append(l[1])\n    visited[1] = True\n    while queue:\n        s = queue.pop(0)\n        si = q2.pop(0)\n        for i in s:\n            if visited[i[0]] == False:\n                xorl[i[0]] = xorl[si] ^ i[1]\n                queue.append(l[i[0]])\n                q2.append(i[0])\n                visited[i[0]] = True\n    d = {}\n    t = 0\n    for i in range(1, len(xorl)):\n        for j in range(i + 1, len(xorl)):\n            if xorl[i] ^ xorl[j] in d:\n                a1 = d[xorl[i] ^ xorl[j]][0]\n                b1 = d[xorl[i] ^ xorl[j]][1]\n                c1 = i\n                d1 = j\n                t = 1\n                break\n            else:\n                d[xorl[i] ^ xorl[j]] = [i, j]\n        if t:\n            break\n    if t:\n        print(a1, b1, c1, d1)\n    else:\n        print(-1)", "from collections import defaultdict\n\ndef solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "def fn(weight, tree, travelled, graph):\n    travelled[tree] = 1\n    for val in weight[tree]:\n        if not travelled[val[0]]:\n            graph[val[0]] = graph[tree] ^ val[1]\n            fn(weight, val[0], travelled, graph)\n\ndef solve():\n    n = int(input())\n    weight = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        weight[u].append([v, w])\n        weight[v].append([u, w])\n    number = [0] * n\n    travelled = [0] * n\n    number[0] = 0\n    fn(weight, 0, travelled, number)\n    mp = {}\n    for i in range(n):\n        if number[i] in mp:\n            mp[number[i]].append(i)\n        else:\n            mp[number[i]] = [i]\n    for val in mp.items():\n        if len(val[1]) > 1:\n            f = val[1][0]\n            s = val[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    flag = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if number[i] ^ number[j] in flag:\n                flag[number[i] ^ number[j]].append([i, j])\n                if len(flag[number[i] ^ number[j]]) > 1:\n                    print(flag[number[i] ^ number[j]][0][0] + 1, flag[number[i] ^ number[j]][0][1] + 1, flag[number[i] ^ number[j]][1][0] + 1, flag[number[i] ^ number[j]][1][1] + 1)\n                    return\n            else:\n                flag[number[i] ^ number[j]] = [[i, j]]\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport copy\nimport math\nimport heapq\nimport bisect\nimport statistics\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom heapq import heapify, heappush, heappop\nfrom itertools import permutations, combinations\nfrom collections import Counter, OrderedDict, deque\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom functools import lru_cache, reduce\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrr = lambda : input().strip()\njl = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmuli = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline()\nstdint = lambda : int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nmod = 1000000007\n\ndef xd(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            xd(adj, x[0], vis, dis)\n\ndef xd1(adj, node, v, d):\n    v[node] = 0\n    for x in adj[node]:\n        if not v[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            xd1(adj, x[0], v, dis)\nfor _ in range(int(input())):\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (a, b, w) = map(int, input().split())\n        a = a - 1\n        b = b - 1\n        adj[a].append([b, w])\n        adj[b].append([a, w])\n    dist = [0] * n\n    vis = [0] * n\n    k = float('inf')\n    m = [0] * n\n    i = [0] * n\n    dist[0] = 0\n    xd(adj, 0, vis, dist)\n    mp = {}\n    h = 0\n    for i in range(n):\n        if dist[i] not in mp:\n            mp[dist[i]] = []\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            (f, s) = (x[1][0], x[1][1])\n            if f == 0 and s == n - 1:\n                h = 2\n                print('1 2 2 ' + str(n - 1))\n            elif f == 0:\n                h = 2\n                print('1 ' + str(n - 1) + ' ' + str(s + 1) + ' ' + str(n - 1))\n            elif s == n - 1:\n                h = 2\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            else:\n                h = 2\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            break\n    else:\n        mp2 = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                if dist[i] ^ dist[j] not in mp2:\n                    mp2[dist[i] ^ dist[j]] = []\n                mp2[dist[i] ^ dist[j]].append([i, j])\n                if len(mp2[dist[i] ^ dist[j]]) > 1:\n                    print(str(mp2[dist[i] ^ dist[j]][0][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][0][1] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][1] + 1))\n                    h = 1\n                    break\n            if h == 1:\n                break\n    if h == 0:\n        print('-1')", "import sys\nsys.setrecursionlimit(100000)\n\ndef fn(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            fn(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    fn(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for x in mp.items():\n        if len(x[1]) > 1:\n            (f, s) = (x[1][0], x[1][1])\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n                if len(mp2[dist[i] ^ dist[j]]) > 1:\n                    gg1 = mp2[dist[i] ^ dist[j]][0][0] + 1\n                    gg2 = mp2[dist[i] ^ dist[j]][0][1] + 1\n                    gg3 = mp2[dist[i] ^ dist[j]][1][0] + 1\n                    gg4 = mp2[dist[i] ^ dist[j]][1][1] + 1\n                    print(gg1, gg2, gg3, gg4)\n                    return\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "def solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    (dist, vis) = ([0] * n, [0] * n)\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for x in mp.items():\n        if len(x[1]) > 1:\n            (f, s) = (x[1][0], x[1][1])\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print('-1')\nt = int(input())\nfor _ in range(t):\n    solve()", "def dfs(node, adj, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            dfs(x[0], adj, vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    dist = [0] * n\n    vis = [0] * n\n    dfs(0, adj, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append((i, j))\n                if len(mp2[dist[i] ^ dist[j]]) > 1:\n                    print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                    return\n            else:\n                mp2[dist[i] ^ dist[j]] = [(i, j)]\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef df(ad, node, dst, vised):\n    vised[node] = True\n    for (i, j) in ad[node]:\n        if not vised[i]:\n            dst[i] = dst[node] ^ j\n            df(ad, i, dst, vised)\n\ndef sol():\n    ad = defaultdict(list)\n    n = int(input())\n    for L in range(n - 1):\n        (x, v, w) = map(int, input().split())\n        ad[x - 1].append([v - 1, w])\n        ad[v - 1].append([x - 1, w])\n    dst = [float('inf')] * n\n    vised = [False] * n\n    dst[0] = 0\n    df(ad, 0, dst, vised)\n    hash = defaultdict(list)\n    for i in range(n):\n        hash[dst[i]].append(i)\n    for (k, nodes) in hash.items():\n        if len(nodes) > 1:\n            (x, v) = (nodes[0], nodes[1])\n            if x == 0 and v == n - 1:\n                print(1, 2, 2, n - 1)\n            elif x == 0:\n                print(1, n - 1, v + 1, n - 1)\n            elif v == n - 1:\n                print(1, x + 1, 1, v + 1)\n            else:\n                print(1, x + 1, 1, v + 1)\n            return\n    hash1 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            hash1[dst[i] ^ dst[j]].append([i, j])\n            if len(hash1[dst[i] ^ dst[j]]) > 1:\n                print(hash1[dst[i] ^ dst[j]][0][0] + 1, hash1[dst[i] ^ dst[j]][0][1] + 1, hash1[dst[i] ^ dst[j]][1][0] + 1, hash1[dst[i] ^ dst[j]][1][1] + 1)\n                return\n    print(-1)\n    return\nte = int(input())\nwhile te:\n    te -= 1\n    sol()", "def fnxor(ad, node, vi, dis):\n    vi[node] = 1\n    for xx in ad[node]:\n        if not vi[xx[0]]:\n            dis[xx[0]] = dis[node] ^ xx[1]\n            fnxor(ad, xx[0], vi, dis)\n\ndef solve():\n    n = int(input())\n    ad = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        ad[u].append([v, w])\n        ad[v].append([u, w])\n    dis = [0] * n\n    vi = [0] * n\n    dis[0] = 0\n    fnxor(ad, 0, vi, dis)\n    mp = {}\n    for i in range(n):\n        if dis[i] in mp:\n            mp[dis[i]].append(i)\n        else:\n            mp[dis[i]] = [i]\n    for xx in mp.items():\n        if len(xx[1]) > 1:\n            ff = xx[1][0]\n            ss = xx[1][1]\n            if ff == 0:\n                print('1', n - 1, ss + 1, n - 1)\n            elif ff == 0 and ss == n - 1:\n                print('1', '2', '2', n - 1)\n            elif ss == n - 1:\n                print('1', ff + 1, '1', ss + 1)\n            else:\n                print('1', ff + 1, '1', ss + 1)\n            return\n    Map2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dis[i] ^ dis[j] in Map2:\n                Map2[dis[i] ^ dis[j]].append([i, j])\n                if len(Map2[dis[i] ^ dis[j]]) > 1:\n                    print(Map2[dis[i] ^ dis[j]][0][0] + 1, Map2[dis[i] ^ dis[j]][0][1] + 1, Map2[dis[i] ^ dis[j]][1][0] + 1, Map2[dis[i] ^ dis[j]][1][1] + 1)\n                    return\n            else:\n                Map2[dis[i] ^ dis[j]] = [[i, j]]\n    print('-1')\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nsys.setrecursionlimit(10 ** 7)\n\ndef solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for (k, v) in mp.items():\n        if len(v) > 1:\n            f = v[0]\n            s = v[1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n                if len(mp2[dist[i] ^ dist[j]]) > 1:\n                    print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                    return\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef dfs(l, j, v, d):\n    v[j] = 1\n    for x in l[j]:\n        if v[x[0]] == 0:\n            d[x[0]] = d[j] ^ x[1]\n            dfs(l, x[0], v, d)\nt = inp()\nfor i in range(t):\n    n = inp()\n    l = [[] for _ in range(0, n)]\n    for i in range(n - 1):\n        (a, b, c) = mp()\n        a = a - 1\n        b = b - 1\n        l[a].append((b, c))\n        l[b].append((a, c))\n    dst = [0] * n\n    v = [0] * n\n    dfs(l, 0, v, dst)\n    d = {}\n    for i in range(n):\n        try:\n            d[i].append(i)\n        except:\n            d[i] = [i]\n    f = 0\n    if f == 0:\n        d2 = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                try:\n                    d2[dst[i] ^ dst[j]].append((i, j))\n                except:\n                    d2[dst[i] ^ dst[j]] = [(i, j)]\n                if len(d2[dst[i] ^ dst[j]]) > 1:\n                    print(d2[dst[i] ^ dst[j]][0][0] + 1, d2[dst[i] ^ dst[j]][0][1] + 1, d2[dst[i] ^ dst[j]][1][0] + 1, d2[dst[i] ^ dst[j]][1][1] + 1)\n                    f = 2\n                    break\n            if f == 2:\n                break\n    if f == 0:\n        print(-1)", "from collections import defaultdict\n\ndef get2(x, node, visit, distance):\n    visit[node] = 1\n    for i in x[node]:\n        if not visit[i[0]]:\n            distance[i[0]] = distance[node] ^ i[1]\n            get2(x, i[0], visit, distance)\n\ndef get():\n    n = int(input())\n    x = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        x[u].append([v, w])\n        x[v].append([u, w])\n    distance = [0] * n\n    visit = [0] * n\n    distance[0] = 0\n    get2(x, 0, visit, distance)\n    dic = defaultdict(list)\n    for i in range(n):\n        dic[distance[i]].append(i)\n    for i in dic.items():\n        if len(i[1]) > 1:\n            f = i[1][0]\n            s = i[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    dic2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dic2[distance[i] ^ distance[j]].append([i, j])\n            if len(dic2[distance[i] ^ distance[j]]) > 1:\n                print(dic2[distance[i] ^ distance[j]][0][0] + 1, dic2[distance[i] ^ distance[j]][0][1] + 1, dic2[distance[i] ^ distance[j]][1][0] + 1, dic2[distance[i] ^ distance[j]][1][1] + 1)\n                return\n    print(-1)\nfor _ in range(int(input())):\n    get()", "def solve2(adj, node, vis, dist):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dist[x[0]] = dist[node] ^ x[1]\n            solve2(adj, x[0], vis, dist)\n\ndef solve():\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] not in mp:\n            mp[dist[i]] = []\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] not in mp2:\n                mp2[dist[i] ^ dist[j]] = []\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor i in range(t):\n    solve()", "import math\nimport bisect\nfor _ in range(int(input())):\n    n = int(input())\n    l = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a = list(map(int, input().strip().split()))\n        l[a[0]].append([a[1], a[2]])\n        l[a[1]].append([a[0], a[2]])\n    if n <= 500:\n        xorl = [0] * (n + 1)\n        visited = [False] * (n + 1)\n        queue = []\n        q2 = []\n        q2.append(1)\n        queue.append(l[1])\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if visited[i[0]] == False:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a1 = d[xorl[i] ^ xorl[j]][0]\n                    b1 = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            print(a1, b1, c1, d1)\n        else:\n            print(-1)\n    elif n <= 20000:\n        t = 0\n        for k in range(1, n):\n            xorl = [0] * (n + 1)\n            visited = [False] * (n + 1)\n            queue = []\n            q2 = []\n            q2.append(k)\n            queue.append(l[k])\n            visited[k] = True\n            while queue:\n                s = queue.pop(0)\n                si = q2.pop(0)\n                for i in s:\n                    if visited[i[0]] == False:\n                        xorl[i[0]] = xorl[si] ^ i[1]\n                        queue.append(l[i[0]])\n                        q2.append(i[0])\n                        visited[i[0]] = True\n            d = {}\n            for i in range(1, len(xorl)):\n                if i != k:\n                    if xorl[i] in d:\n                        b1 = d[xorl[i]]\n                        d1 = i\n                        a1 = k\n                        c1 = k\n                        t = 1\n                        break\n                    else:\n                        d[xorl[i]] = i\n            if len(d) == len(xorl) - 2:\n                for i in range(1, len(l)):\n                    for j in range(len(l[i])):\n                        if l[i][j][1] in d:\n                            a1 = k\n                            b1 = d[l[i][j][1]]\n                            c1 = i\n                            d1 = l[i][j][0]\n                            if a1 == c1 and b1 == d1 or (a1 == d1 and b1 == c1):\n                                pass\n                            else:\n                                t = 1\n                                break\n                    if t == 1:\n                        break\n            if t == 1:\n                break\n        if t == 1:\n            print(a1, b1, c1, d1)\n        else:\n            xorl = [0] * (n + 1)\n            visited = [False] * (n + 1)\n            queue = []\n            q2 = []\n            q2.append(1)\n            queue.append(l[1])\n            visited[1] = True\n            while queue:\n                s = queue.pop(0)\n                si = q2.pop(0)\n                for i in s:\n                    if visited[i[0]] == False:\n                        xorl[i[0]] = xorl[si] ^ i[1]\n                        queue.append(l[i[0]])\n                        q2.append(i[0])\n                        visited[i[0]] = True\n            d = {}\n            for i in range(2, len(xorl)):\n                if xorl[i] in d:\n                    b1 = d[xorl[i]]\n                    d1 = i\n                    break\n                else:\n                    d[xorl[i]] = i\n            if len(d) == len(xorl) - 2:\n                t = 0\n                for i in range(2, len(xorl)):\n                    for j in range(i, len(xorl)):\n                        if i != j:\n                            y = xorl[i]\n                            z = xorl[j]\n                            if y ^ z in d:\n                                a1 = 1\n                                b1 = d[xorl[i] ^ xorl[j]]\n                                c1 = i\n                                d1 = j\n                                t = 1\n                                break\n                    if t == 1:\n                        break\n                if t == 1:\n                    print(a1, b1, c1, d1)\n                else:\n                    print(-1)\n            else:\n                print(1, b1, 1, d1)\n    else:\n        xorl = [0] * (n + 1)\n        visited = [False] * (n + 1)\n        queue = []\n        q2 = []\n        q2.append(1)\n        queue.append(l[1])\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if visited[i[0]] == False:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        for i in range(2, len(xorl)):\n            if xorl[i] in d:\n                b1 = d[xorl[i]]\n                d1 = i\n                break\n            else:\n                d[xorl[i]] = i\n        if len(d) == len(xorl) - 2:\n            t = 0\n            for i in range(len(l)):\n                for j in range(len(l[i])):\n                    if l[i][j][1] in d:\n                        a1 = 1\n                        b1 = d[l[i][j][1]]\n                        c1 = i\n                        d1 = l[i][j][0]\n                        if a1 == c1 and b1 == d1 or (a1 == d1 and b1 == c1):\n                            pass\n                        elif a1 != b1 and c1 != d1:\n                            t = 1\n                            break\n                if t == 1:\n                    break\n            if t == 1:\n                print(a1, b1, c1, d1)\n            else:\n                print(-1)\n        else:\n            print(1, b1, 1, d1)", "def solve(node):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dist[x[0]] = dist[node] ^ x[1]\n            solve(x[0])\n\ndef main():\n    n = int(input())\n    global adj\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    global vis\n    global dist\n    dist = [0] * n\n    vis = [0] * n\n    solve(0)\n    mp = {}\n    for i in range(n):\n        curr = dist[i]\n        if curr not in mp:\n            mp[curr] = []\n        mp[curr].append(i)\n    for (k, v) in mp.items():\n        if len(v) > 1:\n            f = v[0]\n            s = v[1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp1 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            curr = dist[i] ^ dist[j]\n            if curr not in mp1:\n                mp1[curr] = []\n            mp1[curr].append([i, j])\n            if len(mp1[curr]) > 1:\n                print(mp1[curr][0][0] + 1, mp1[curr][0][1] + 1, mp1[curr][1][0] + 1, mp1[curr][1][1] + 1)\n                return\n    print(-1)\n    return\nfor _ in range(int(input())):\n    main()", "from collections import defaultdict\n\ndef dfs(adj_list, node, visited, distances):\n    visited[node] = True\n    for (neighbor, weight) in adj_list[node]:\n        if not visited[neighbor]:\n            distances[neighbor] = distances[node] ^ weight\n            dfs(adj_list, neighbor, visited, distances)\n\ndef find_path():\n    n = int(input())\n    adj_list = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n    distances = [0] * n\n    visited = [False] * n\n    dfs(adj_list, 0, visited, distances)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[distances[i]].append(i)\n    for (key, value) in mp.items():\n        if len(value) > 1:\n            (f, s) = (value[0], value[1])\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[distances[i] ^ distances[j]].append([i, j])\n            if len(mp2[distances[i] ^ distances[j]]) > 1:\n                (a, b) = (mp2[distances[i] ^ distances[j]][0], mp2[distances[i] ^ distances[j]][1])\n                print(a[0] + 1, a[1] + 1, b[0] + 1, b[1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    find_path()", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef dfs(l, j, v, d):\n    v[j] = 1\n    for x in l[j]:\n        if v[x[0]] == 0:\n            d[x[0]] = d[j] ^ x[1]\n            dfs(l, x[0], v, d)\nt = inp()\nfor i in range(t):\n    n = inp()\n    l = [[] for _ in range(0, n)]\n    for i in range(n - 1):\n        (a, b, c) = mp()\n        a = a - 1\n        b = b - 1\n        l[a].append((b, c))\n        l[b].append((a, c))\n    dst = [0] * n\n    v = [0] * n\n    dfs(l, 0, v, dst)\n    d = {}\n    for i in range(n):\n        try:\n            d[i].append(i)\n        except:\n            d[i] = [i]\n    f = 0\n    for i in d:\n        if len(d[i]) > 1:\n            a1 = d[i][0]\n            a2 = d[i][1]\n            if a1 == 0 and a2 == n - 1:\n                print(1, 2, 2, n - 1)\n            elif a1 == 0:\n                print(1, n - 1, a2 + 1, n - 1)\n            elif a2 == n - 1:\n                print(1, a1 + 1, 1, a2 + 1)\n            else:\n                print(1, a1 + 1, 1, a2 + 1)\n            f = 1\n            break\n    if f == 0:\n        d2 = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                try:\n                    d2[dst[i] ^ dst[j]].append((i, j))\n                except:\n                    d2[dst[i] ^ dst[j]] = [(i, j)]\n                if len(d2[dst[i] ^ dst[j]]) > 1:\n                    print(d2[dst[i] ^ dst[j]][0][0] + 1, d2[dst[i] ^ dst[j]][0][1] + 1, d2[dst[i] ^ dst[j]][1][0] + 1, d2[dst[i] ^ dst[j]][1][1] + 1)\n                    f = 2\n                    break\n            if f == 2:\n                break\n    if f == 0:\n        print(-1)", "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (p, q, r) = map(int, input().split())\n        adj[p - 1].append((q - 1, r))\n        adj[q - 1].append((p - 1, r))\n    vis = [0] * n\n    dist = [0] * n\n\n    def dfs(node, d):\n        vis[node] = 1\n        dist[node] = d\n        for (q, r) in adj[node]:\n            if not vis[q]:\n                dfs(q, d ^ r)\n    dfs(0, 0)\n    s = defaultdict(list)\n    for (i, d) in enumerate(dist):\n        s[d].append(i)\n    for (k, q) in s.items():\n        if len(q) > 1:\n            (p, q) = (q[0], q[1])\n            if p == 0 and q == n - 1:\n                print(1, 2, 2, n - 1)\n            elif p == 0:\n                print(1, n - 1, q + 1, n - 1)\n            elif q == n - 1:\n                print(1, p + 1, 1, q + 1)\n            else:\n                print(1, p + 1, 1, q + 1)\n            return\n    s2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            s2[dist[i] ^ dist[j]].append((i, j))\n            if len(s2[dist[i] ^ dist[j]]) > 1:\n                (a, b) = s2[dist[i] ^ dist[j]][0]\n                (c, d) = s2[dist[i] ^ dist[j]][1]\n                print(a + 1, b + 1, c + 1, d + 1)\n                return\n    print(-1)\nt = int(input())\nfor i in range(t):\n    solve()", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\ndef solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print('-1')\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\nfor _ in range(int(input())):\n    N = int(input())\n    graph = defaultdict(set)\n    for _ in range(N - 1):\n        (u, v, w) = map(int, input().split())\n        graph[u].add((v, w))\n        graph[v].add((u, w))\n    f = [False]\n    ans = defaultdict(list)\n    ind = [-1]\n\n    def helper(node, parent, res, src):\n        if not f[0]:\n            for (child, w) in graph[node]:\n                if child != parent:\n                    helper(child, node, res ^ w, src)\n            if parent != -1:\n                if ans[res]:\n                    if ans[res][0] not in [[src, node], [node, src]]:\n                        ans[res].append([src, node])\n                        f[0] = True\n                        ind[0] = res\n                elif src != node:\n                    ans[res].append([src, node])\n        return res\n    for i in range(1, N + 1):\n        helper(i, -1, 0, i)\n    if ind[0] == -1:\n        print(-1)\n    else:\n        tmp = ans[ind[0]]\n        print(*tmp[0], *tmp[1])", "def dfs(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            dfs(adj, x[0], vis, dis)\n\ndef evlos():\n    nested = int(input())\n    adj = [[] for i in range(nested)]\n    for i in range(nested - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * nested\n    vis = [0] * nested\n    dfs(adj, 0, vis, dist)\n    mp = {}\n    for i in range(nested):\n        mp[dist[i]] = mp.get(dist[i], []) + [i]\n    for x in mp.items():\n        if len(x[1]) > 1:\n            (f, s) = (x[1][0], x[1][1])\n            if f == 0 and s == nested - 1:\n                print('1 2 2', nested - 1)\n            elif f == 0:\n                print('1', nested - 1, s + 1, nested - 1)\n            elif s == nested - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = {}\n    for i in range(nested):\n        for j in range(i + 1, nested):\n            mp2[dist[i] ^ dist[j]] = mp2.get(dist[i] ^ dist[j], []) + [[i, j]]\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\ntest = int(input())\nfor _ in range(test):\n    evlos()", "import sys\nimport math\nimport heapq\nimport bisect\nfrom collections import defaultdict\n\ndef defval():\n    return []\n\ndef dfs(v):\n    Visited[v] = 1\n    for x in adj[v]:\n        if Visited[x[0]] == 0:\n            dis[x[0]] = dis[v] ^ x[1]\n            dfs(x[0])\nt = int(input())\nfor _ in range(t):\n    flag = False\n    n = int(input())\n    adj = defaultdict(defval)\n    for j in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dis = [0] * (n + 1)\n    Visited = [0] * (n + 1)\n    dfs(1)\n    d = defaultdict(defval)\n    for i in range(1, n + 1):\n        d[dis[i]].append(i)\n    for j in d:\n        if len(d[j]) > 1:\n            (fir, sec) = (d[j][0], d[j][1])\n            if fir == 1 and sec == n:\n                print(1, 2, 2, n - 1)\n            elif fir == 1:\n                print(1, n - 1, sec, n - 1)\n            else:\n                print(1, fir, 1, sec)\n            flag = True\n            break\n    if flag:\n        continue\n    d2 = defaultdict(defval)\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            check = dis[i] ^ dis[j]\n            d2[check].append([i, j])\n            if len(d2[check]) > 1:\n                print(d2[check][0][0], d2[check][0][1], d2[check][1][0], d2[check][1][1])\n                flag = True\n                break\n        if flag:\n            break\n    else:\n        print(-1)", "def fn(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            fn(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    fn(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] not in mp:\n            mp[dist[i]] = []\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print('1 2 2 ' + str(n))\n            elif f == 0:\n                print('1 ' + str(n) + ' ' + str(s + 1) + ' ' + str(n))\n            elif s == n - 1:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            else:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] not in mp2:\n                mp2[dist[i] ^ dist[j]] = []\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(str(mp2[dist[i] ^ dist[j]][0][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][0][1] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][1] + 1))\n                return\n    print('-1')\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nimport heapq\nimport bisect\nfrom collections import defaultdict\n\ndef defval():\n    return []\n\ndef dfs(v):\n    vis[v] = 1\n    for x in adj[v]:\n        if vis[x[0]] == 0:\n            dist[x[0]] = dist[v] ^ x[1]\n            dfs(x[0])\nt = int(input())\nfor _ in range(t):\n    flag = False\n    n = int(input())\n    adj = defaultdict(defval)\n    for j in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * (n + 1)\n    vis = [0] * (n + 1)\n    dfs(1)\n    d = defaultdict(defval)\n    for i in range(1, n + 1):\n        d[dist[i]].append(i)\n    for j in d:\n        if len(d[j]) > 1:\n            (fir, sec) = (d[j][0], d[j][1])\n            if fir == 1 and sec == n:\n                print(1, 2, 2, n - 1)\n            elif fir == 1:\n                print(1, n - 1, sec, n - 1)\n            else:\n                print(1, fir, 1, sec)\n            flag = True\n            break\n    if flag:\n        continue\n    d2 = defaultdict(defval)\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            d2[dist[i] ^ dist[j]].append([i, j])\n            if len(d2[dist[i] ^ dist[j]]) > 1:\n                print(d2[dist[i] ^ dist[j]][0][0], d2[dist[i] ^ dist[j]][0][1], d2[dist[i] ^ dist[j]][1][0], d2[dist[i] ^ dist[j]][1][1])\n                flag = True\n                break\n        if flag:\n            break\n    else:\n        print(-1)", "import sys\nimport math\n\ndef computeGCD(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return abs(x)\nfrom collections import defaultdict\n\ndef defval():\n    return []\n\ndef dfs(v):\n    vis[v] = 1\n    for x in adj[v]:\n        if vis[x[0]] == 0:\n            dist[x[0]] = dist[v] ^ x[1]\n            dfs(x[0])\nt = int(input())\nfor _ in range(t):\n    flag = False\n    n = int(input())\n    adj = defaultdict(defval)\n    for j in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * (n + 1)\n    vis = [0] * (n + 1)\n    dfs(1)\n    d = defaultdict(defval)\n    for i in range(1, n + 1):\n        d[dist[i]].append(i)\n    for j in d:\n        if len(d[j]) > 1:\n            (fir, sec) = (d[j][0], d[j][1])\n            if fir == 1 and sec == n:\n                print(1, 2, 2, n - 1)\n            elif fir == 1:\n                print(1, n - 1, sec, n - 1)\n            else:\n                print(1, fir, 1, sec)\n            flag = True\n            break\n    if flag:\n        continue\n    d2 = defaultdict(defval)\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            d2[dist[i] ^ dist[j]].append([i, j])\n            if len(d2[dist[i] ^ dist[j]]) > 1:\n                print(d2[dist[i] ^ dist[j]][0][0], d2[dist[i] ^ dist[j]][0][1], d2[dist[i] ^ dist[j]][1][0], d2[dist[i] ^ dist[j]][1][1])\n                flag = True\n                break\n        if flag:\n            break\n    else:\n        print(-1)", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef riches(adj_list, node, visited, distances):\n    visited[node] = True\n    for (neighbor, weight) in adj_list[node]:\n        if not visited[neighbor]:\n            distances[neighbor] = distances[node] ^ weight\n            riches(adj_list, neighbor, visited, distances)\n\ndef bold():\n    n = int(input())\n    ramu = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        ramu[u].append([v, w])\n        ramu[v].append([u, w])\n    fonotics = [0] * n\n    guage = [0] * n\n    fonotics[0] = 0\n    riches(ramu, 0, guage, fonotics)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[fonotics[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print('1 2 2 ' + str(n - 1))\n            elif f == 0:\n                print('1 ' + str(n - 1) + ' ' + str(s + 1) + ' ' + str(n - 1))\n            elif s == n - 1:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            else:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[fonotics[i] ^ fonotics[j]].append([i, j])\n            if len(mp2[fonotics[i] ^ fonotics[j]]) > 1:\n                print(str(mp2[fonotics[i] ^ fonotics[j]][0][0] + 1) + ' ' + str(mp2[fonotics[i] ^ fonotics[j]][0][1] + 1) + ' ' + str(mp2[fonotics[i] ^ fonotics[j]][1][0] + 1) + ' ' + str(mp2[fonotics[i] ^ fonotics[j]][1][1] + 1))\n                return\n    print('-1')\nt = int(input())\nfor i in range(t):\n    bold()", "import sys\nimport math\nimport heapq\nimport bisect\n\ndef computeGCD(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return abs(x)\nfrom collections import defaultdict\n\ndef defval():\n    return []\n\ndef dfs(v):\n    vis[v] = 1\n    for x in adj[v]:\n        if vis[x[0]] == 0:\n            dist[x[0]] = dist[v] ^ x[1]\n            dfs(x[0])\nt = int(input())\nfor _ in range(t):\n    flag = False\n    n = int(input())\n    adj = defaultdict(defval)\n    for j in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * (n + 1)\n    vis = [0] * (n + 1)\n    dfs(1)\n    d = defaultdict(defval)\n    for i in range(1, n + 1):\n        d[dist[i]].append(i)\n    for j in d:\n        if len(d[j]) > 1:\n            (fir, sec) = (d[j][0], d[j][1])\n            if fir == 1 and sec == n:\n                print(1, 2, 2, n - 1)\n            elif fir == 1:\n                print(1, n - 1, sec, n - 1)\n            else:\n                print(1, fir, 1, sec)\n            flag = True\n            break\n    if flag:\n        continue\n    d2 = defaultdict(defval)\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            d2[dist[i] ^ dist[j]].append([i, j])\n            if len(d2[dist[i] ^ dist[j]]) > 1:\n                print(d2[dist[i] ^ dist[j]][0][0], d2[dist[i] ^ dist[j]][0][1], d2[dist[i] ^ dist[j]][1][0], d2[dist[i] ^ dist[j]][1][1])\n                flag = True\n                break\n        if flag:\n            break\n    else:\n        print(-1)", "import sys\nimport math\nimport heapq\nimport bisect\n\ndef computeGCD(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return abs(x)\nfrom collections import defaultdict\n\ndef defval():\n    return []\n\ndef dfs(v):\n    vis[v] = 1\n    for x in adj[v]:\n        if vis[x[0]] == 0:\n            dist[x[0]] = dist[v] ^ x[1]\n            dfs(x[0])\nt = int(input())\nfor _ in range(t):\n    flag = False\n    n = int(input())\n    adj = defaultdict(defval)\n    for j in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = []\n    vis = []\n    for i in range(n + 1):\n        dist.append(0)\n        vis.append(0)\n    dist = [0] * (n + 1)\n    vis = [0] * (n + 1)\n    dfs(1)\n    d = defaultdict(defval)\n    for i in range(1, n + 1):\n        d[dist[i]].append(i)\n    for j in d:\n        if len(d[j]) > 1:\n            (fir, sec) = (d[j][0], d[j][1])\n            if fir == 1 and sec == n:\n                print(1, 2, 2, n - 1)\n            elif fir == 1:\n                print(1, n - 1, sec, n - 1)\n            else:\n                print(1, fir, 1, sec)\n            flag = True\n            break\n    if flag:\n        continue\n    d2 = defaultdict(defval)\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            d2[dist[i] ^ dist[j]].append([i, j])\n            if len(d2[dist[i] ^ dist[j]]) > 1:\n                print(d2[dist[i] ^ dist[j]][0][0], d2[dist[i] ^ dist[j]][0][1], d2[dist[i] ^ dist[j]][1][0], d2[dist[i] ^ dist[j]][1][1])\n                flag = True\n                break\n        if flag:\n            break\n    else:\n        print(-1)", "from collections import defaultdict\n\ndef dfs(node, parent, adj, vis, dis):\n    vis[node] = True\n    for (nei, w) in adj[node]:\n        if nei != parent:\n            dis[nei] = dis[node] ^ w\n            dfs(nei, node, adj, vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        adj[u - 1].append((v - 1, w))\n        adj[v - 1].append((u - 1, w))\n    vis = [False] * n\n    dis = [0] * n\n    dfs(0, -1, adj, vis, dis)\n    dist_map = defaultdict(list)\n    for (i, d) in enumerate(dis):\n        dist_map[d].append(i)\n    if len(dist_map) == 1:\n        (u, v) = (dist_map[0][0], dist_map[0][-1])\n        if u == 0 and v == n - 1:\n            print(1, 2, 2, n - 1)\n        elif u == 0:\n            print(1, n - 1, v + 1, n - 1)\n        elif v == n - 1:\n            print(1, u + 1, 1, v + 1)\n        else:\n            print(1, u + 1, 1, v + 1)\n    else:\n        xor_map = defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                xor_map[dis[i] ^ dis[j]].append((i, j))\n                if len(xor_map[dis[i] ^ dis[j]]) == 2:\n                    (u1, v1) = xor_map[dis[i] ^ dis[j]][0]\n                    (u2, v2) = xor_map[dis[i] ^ dis[j]][1]\n                    print(u1 + 1, v1 + 1, u2 + 1, v2 + 1)\n                    return\n        print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef dfs(adj, node, vis, dist):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dist[x[0]] = dist[node] ^ x[1]\n            dfs(adj, x[0], vis, dist)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dfs(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport math\nimport heapq\nimport bisect\nfrom collections import defaultdict\n\ndef defval():\n    return []\n\ndef dfs(v):\n    vis[v] = 1\n    for x in adj[v]:\n        if vis[x[0]] == 0:\n            dist[x[0]] = dist[v] ^ x[1]\n            dfs(x[0])\nt = int(input())\nfor _ in range(t):\n    flag = False\n    n = int(input())\n    adj = defaultdict(defval)\n    for j in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * (n + 1)\n    vis = [0] * (n + 1)\n    dfs(1)\n    d = defaultdict(defval)\n    for i in range(1, n + 1):\n        d[dist[i]].append(i)\n    for j in d:\n        if len(d[j]) > 1:\n            (fir, sec) = (d[j][0], d[j][1])\n            if fir == 1 and sec == n:\n                print(1, 2, 2, n - 1)\n            elif fir == 1:\n                print(1, n - 1, sec, n - 1)\n            else:\n                print(1, fir, 1, sec)\n            flag = True\n            break\n    if flag:\n        continue\n    d2 = defaultdict(defval)\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            d2[dist[i] ^ dist[j]].append([i, j])\n            if len(d2[dist[i] ^ dist[j]]) > 1:\n                print(d2[dist[i] ^ dist[j]][0][0], d2[dist[i] ^ dist[j]][0][1], d2[dist[i] ^ dist[j]][1][0], d2[dist[i] ^ dist[j]][1][1])\n                flag = True\n                break\n        if flag:\n            break\n    else:\n        print(-1)", "from collections import defaultdict\n\ndef solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (r, g, w) = map(int, input().split())\n        r -= 1\n        g -= 1\n        adj[r].append((g, w))\n        adj[g].append((r, w))\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append((i, j))\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print('-1')\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef dfs(node, adj, vis, dist):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dist[x[0]] = dist[node] ^ x[1]\n            dfs(x[0], adj, vis, dist)\n\ndef solve():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    dist = [0] * n\n    vis = [0] * n\n    dfs(0, adj, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append((i, j))\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "def fn(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            fn(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    fn(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] not in mp:\n            mp[dist[i]] = []\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] not in mp2:\n                mp2[dist[i] ^ dist[j]] = []\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "from typing import List, Tuple\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(adj_list: List[List[Tuple[int, int]]], node: int, visited: List[int], distance: List[int]) -> None:\n    visited[node] = 1\n    for (v, w) in adj_list[node]:\n        if not visited[v]:\n            distance[v] = distance[node] ^ w\n            dfs(adj_list, v, visited, distance)\n\ndef solve() -> None:\n    n = int(input())\n    adj_list = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n    dist = [0] * n\n    visited = [0] * n\n    dist[0] = 0\n    dfs(adj_list, 0, visited, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for (k, v) in mp.items():\n        if len(v) > 1:\n            f = v[0]\n            s = v[1]\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print('-1')\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef dfs(adj1, node1, vis1, dis1):\n    vis1[node1] = 1\n    for x1 in adj1[node1]:\n        if not vis1[x1[0]]:\n            dis1[x1[0]] = dis1[node1] ^ x1[1]\n            dfs(adj1, x1[0], vis1, dis1)\n\ndef solve():\n    n1 = int(input())\n    adj1 = defaultdict(list)\n    for i in range(n1 - 1):\n        (u1, v1, w1) = map(int, input().split())\n        u1 -= 1\n        v1 -= 1\n        adj1[u1].append([v1, w1])\n        adj1[v1].append([u1, w1])\n    dist1 = [0] * n1\n    vis1 = [0] * n1\n    dfs(adj1, 0, vis1, dist1)\n    mp = defaultdict(list)\n    for i in range(n1):\n        mp[dist1[i]].append(i)\n    for x1 in mp.items():\n        if len(x1[1]) > 1:\n            (f1, s1) = (x1[1][0], x1[1][1])\n            if f1 == 0 and s1 == n1 - 1:\n                print(1, 2, 2, n1 - 1)\n            elif f1 == 0:\n                print(1, n1 - 1, s1 + 1, n1 - 1)\n            elif s1 == n1 - 1:\n                print(1, f1 + 1, 1, s1 + 1)\n            else:\n                print(1, f1 + 1, 1, s1 + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n1):\n        for j in range(i + 1, n1):\n            mp2[dist1[i] ^ dist1[j]].append([i, j])\n            if len(mp2[dist1[i] ^ dist1[j]]) > 1:\n                print(mp2[dist1[i] ^ dist1[j]][0][0] + 1, mp2[dist1[i] ^ dist1[j]][0][1] + 1, mp2[dist1[i] ^ dist1[j]][1][0] + 1, mp2[dist1[i] ^ dist1[j]][1][1] + 1)\n                return\n    print(-1)\nt1 = int(input())\nfor _ in range(t1):\n    solve()", "def dfs(adj_list, node, visited, distances):\n    visited[node] = True\n    for (neighbor, weight) in adj_list[node]:\n        if not visited[neighbor]:\n            distances[neighbor] = distances[node] ^ weight\n            dfs(adj_list, neighbor, visited, distances)\n\ndef sol():\n    num_nodes = int(input())\n    adj_list = [[] for _ in range(num_nodes)]\n    for i in range(num_nodes - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n    distances = [0] * num_nodes\n    visited = [False] * num_nodes\n    distances[0] = 0\n    dfs(adj_list, 0, visited, distances)\n    distance_map = {}\n    for i in range(num_nodes):\n        if distances[i] in distance_map:\n            distance_map[distances[i]].append(i)\n        else:\n            distance_map[distances[i]] = [i]\n    for (k, v) in distance_map.items():\n        if len(v) > 1:\n            f = v[0]\n            s = v[1]\n            if f == 0 and s == num_nodes - 1:\n                print(1, 2, 2, num_nodes - 1)\n            elif f == 0:\n                print(1, num_nodes - 1, s + 1, num_nodes - 1)\n            elif s == num_nodes - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    distance_pairs = {}\n    for i in range(num_nodes):\n        for j in range(i + 1, num_nodes):\n            xor_val = distances[i] ^ distances[j]\n            if xor_val in distance_pairs:\n                distance_pairs[xor_val].append((i, j))\n                if len(distance_pairs[xor_val]) > 1:\n                    print(distance_pairs[xor_val][0][0] + 1, distance_pairs[xor_val][0][1] + 1, distance_pairs[xor_val][1][0] + 1, distance_pairs[xor_val][1][1] + 1)\n                    return\n            else:\n                distance_pairs[xor_val] = [(i, j)]\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    sol()", "from collections import defaultdict\n\ndef fn(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            fn(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    fn(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print('1 2 2 ' + str(n - 1))\n            elif f == 0:\n                print('1 ' + str(n - 1) + ' ' + str(s + 1) + ' ' + str(n - 1))\n            elif s == n - 1:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            else:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(str(mp2[dist[i] ^ dist[j]][0][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][0][1] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][1] + 1))\n                return\n    print('-1')\nt = int(input())\nfor i in range(t):\n    solve()", "from collections import defaultdict\n\ndef solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            p = x[1][0]\n            q = x[1][1]\n            if p != 0 and q != n - 1:\n                print(1, p + 1, 1, q + 1)\n            elif q == n - 1:\n                print(1, p + 1, 1, q + 1)\n            elif p == 0:\n                print(1, n - 1, q + 1, n - 1)\n            else:\n                print(1, 2, 2, n - 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\na = int(input())\nwhile a > 0:\n    solve()\n    a -= 1", "import sys\nsys.setrecursionlimit(10 ** 6 + 5)\n\ndef solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve(n, adj):\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for (k, v) in mp.items():\n        if len(v) > 1:\n            (f, s) = (v[0], v[1])\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print('-1')\nfor t in range(int(input())):\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    solve(n, adj)", "import sys\nsys.setrecursionlimit(10 ** 6)\nSIZE = int(1000000.0 + 2)\nJM = 1022\nMOD = 1000000005 + 2\n\ndef dfs(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            dfs(adj, x[0], vis, dis)\n\ndef megha():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dfs(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for (key, val) in mp.items():\n        if len(val) > 1:\n            f = val[0]\n            s = val[1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nct = int(input())\nfor x in range(ct):\n    megha()", "import sys\nimport math\nimport heapq\nimport bisect\nfrom collections import defaultdict\n\ndef defval():\n    return []\n\ndef dfs(v):\n    vis[v] = 1\n    for x in adj[v]:\n        if vis[x[0]] == 0:\n            dist[x[0]] = dist[v] ^ x[1]\n            dfs(x[0])\nt = int(input())\nfor _ in range(t):\n    flag = False\n    n = int(input())\n    adj = defaultdict(defval)\n    for j in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dfs(0)\n    d = defaultdict(defval)\n    for i in range(n):\n        d[dist[i]].append(i)\n    for j in d:\n        if len(d[j]) > 1:\n            (fir, sec) = (d[j][0], d[j][1])\n            if fir == 0 and sec == n - 1:\n                print(1, 2, 2, n - 1)\n            elif fir == 0:\n                print(1, n - 1, sec + 1, n - 1)\n            elif sec == n - 1:\n                print(1, fir + 1, 1, sec + 1)\n            else:\n                print(1, fir + 1, 1, sec + 1)\n            flag = True\n            break\n    if flag:\n        continue\n    d2 = defaultdict(defval)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d2[dist[i] ^ dist[j]].append([i, j])\n            if len(d2[dist[i] ^ dist[j]]) > 1:\n                print(d2[dist[i] ^ dist[j]][0][0] + 1, d2[dist[i] ^ dist[j]][0][1] + 1, d2[dist[i] ^ dist[j]][1][0] + 1, d2[dist[i] ^ dist[j]][1][1] + 1)\n                flag = True\n                break\n        if flag:\n            break\n    else:\n        print(-1)", "def fn(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            fn(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    fn(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] not in mp:\n            mp[dist[i]] = []\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            (f, s) = (x[1][0], x[1][1])\n            if f == 0 and s == n - 1:\n                print('1 2 2 ' + str(n - 1))\n            elif f == 0:\n                print('1 ' + str(n - 1) + ' ' + str(s + 1) + ' ' + str(n - 1))\n            elif s == n - 1:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            else:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] not in mp2:\n                mp2[dist[i] ^ dist[j]] = []\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(str(mp2[dist[i] ^ dist[j]][0][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][0][1] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][1] + 1))\n                return\n    print('-1')\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef answer():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    dist = [0] * n\n    vis = [0] * n\n    traversal(0, adj, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append((i, j))\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\n\ndef traversal(node, adj, vis, dist):\n    vis[node] = 1\n    for (v, w) in adj[node]:\n        if not vis[v]:\n            dist[v] = dist[node] ^ w\n            traversal(v, adj, vis, dist)\ntc = int(input())\nfor i in range(tc):\n    answer()", "from collections import defaultdict\n\ndef dfs(adj, node, vis, dist):\n    vis[node] = True\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dist[x[0]] = dist[node] ^ x[1]\n            dfs(adj, x[0], vis, dist)\n\ndef solve():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [False] * n\n    dfs(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for (k, v) in mp.items():\n        if len(v) > 1:\n            (f, s) = (v[0], v[1])\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor i in range(t):\n    solve()", "import sys\nsys.setrecursionlimit(10 ** 6)\nMOD = 1000000007\nSIZE = int(1000000.0 + 2)\n\ndef dfs(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            dfs(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dfs(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for (key, val) in mp.items():\n        if len(val) > 1:\n            f = val[0]\n            s = val[1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "def solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] not in mp:\n            mp[dist[i]] = []\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] not in mp2:\n                mp2[dist[i] ^ dist[j]] = []\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print('-1')\nt = int(input())\nfor i in range(t):\n    solve()", "import sys\nfrom collections import defaultdict\n\ndef dfs(adj_list, node, visited, distance):\n    visited[node] = True\n    for (neighbor, weight) in adj_list[node]:\n        if not visited[neighbor]:\n            distance[neighbor] = distance[node] ^ weight\n            dfs(adj_list, neighbor, visited, distance)\n\ndef find_path(n, edges):\n    adj_list = defaultdict(list)\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n    distances = [0] * n\n    visited = [False] * n\n    distances[0] = 0\n    dfs(adj_list, 0, visited, distances)\n    dist_map = defaultdict(list)\n    for i in range(n):\n        dist_map[distances[i]].append(i)\n    for (dist, nodes) in dist_map.items():\n        if len(nodes) > 1:\n            f = nodes[0]\n            s = nodes[1]\n            if f == 0 and s == n - 1:\n                return [1, 2, 2, n - 1]\n            elif f == 0:\n                return [1, n - 1, s + 1, n - 1]\n            elif s == n - 1:\n                return [1, f + 1, 1, s + 1]\n            else:\n                return [1, f + 1, 1, s + 1]\n    dist_edge_map = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist_edge_map[distances[i] ^ distances[j]].append([i, j])\n            if len(dist_edge_map[distances[i] ^ distances[j]]) > 1:\n                edge1 = dist_edge_map[distances[i] ^ distances[j]][0]\n                edge2 = dist_edge_map[distances[i] ^ distances[j]][1]\n                return [edge1[0] + 1, edge1[1] + 1, edge2[0] + 1, edge2[1] + 1]\n    return [-1]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    edges = []\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        edges.append((u, v, w))\n    path = find_path(n, edges)\n    print(*path)", "from collections import defaultdict\n\ndef dfs(adj_list, node, visited, distance):\n    visited[node] = True\n    for (neighbour, weight) in adj_list[node]:\n        if not visited[neighbour]:\n            distance[neighbour] = distance[node] ^ weight\n            dfs(adj_list, neighbour, visited, distance)\n\ndef find_path(n, adj_list):\n    distance = [0] * n\n    visited = [False] * n\n    dfs(adj_list, 0, visited, distance)\n    path = defaultdict(list)\n    for i in range(n):\n        path[distance[i]].append(i)\n    for (dist, nodes) in path.items():\n        if len(nodes) > 1:\n            (f, s) = (nodes[0], nodes[1])\n            if f == 0 and s == n - 1:\n                return [1, 2, 2, n - 1]\n            elif f == 0:\n                return [1, n - 1, s + 1, n - 1]\n            elif s == n - 1:\n                return [1, f + 1, 1, s + 1]\n            else:\n                return [1, f + 1, 1, s + 1]\n    return None\n\ndef find_cycle(n, adj_list):\n    distance = [0] * n\n    visited = [False] * n\n    dfs(adj_list, 0, visited, distance)\n    cycle = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            cycle[distance[i] ^ distance[j]].append([i, j])\n            if len(cycle[distance[i] ^ distance[j]]) > 1:\n                return [cycle[distance[i] ^ distance[j]][0][0] + 1, cycle[distance[i] ^ distance[j]][0][1] + 1, cycle[distance[i] ^ distance[j]][1][0] + 1, cycle[distance[i] ^ distance[j]][1][1] + 1]\n    return None\n\ndef solve():\n    n = int(input())\n    adj_list = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj_list[u].append([v, w])\n        adj_list[v].append([u, w])\n    path = find_path(n, adj_list)\n    if path:\n        print(*path)\n        return\n    cycle = find_cycle(n, adj_list)\n    if cycle:\n        print(*cycle)\n        return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "def fn(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            fn(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    fn(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n                if len(mp2[dist[i] ^ dist[j]]) > 1:\n                    print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                    return\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n    print('-1')\n\ndef input_test_case():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\ndef main():\n    input_test_case()\nmain()", "import sys\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for (k, v) in mp.items():\n        if len(v) > 1:\n            f = v[0]\n            s = v[1]\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n                if len(mp2[dist[i] ^ dist[j]]) > 1:\n                    print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                    return\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef dfs(adj_list, node, visited, distance):\n    visited[node] = 1\n    for x in adj_list[node]:\n        if not visited[x[0]]:\n            distance[x[0]] = distance[node] ^ x[1]\n            dfs(adj_list, x[0], visited, distance)\n\ndef solve():\n    n = int(input())\n    adj_list = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj_list[u].append([v, w])\n        adj_list[v].append([u, w])\n    distance = [0] * n\n    visited = [0] * n\n    distance[0] = 0\n    dfs(adj_list, 0, visited, distance)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[distance[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            (f, s) = (x[1][0], x[1][1])\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[distance[i] ^ distance[j]].append([i, j])\n            if len(mp2[distance[i] ^ distance[j]]) > 1:\n                print(mp2[distance[i] ^ distance[j]][0][0] + 1, mp2[distance[i] ^ distance[j]][0][1] + 1, mp2[distance[i] ^ distance[j]][1][0] + 1, mp2[distance[i] ^ distance[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef solve2(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            solve2(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    solve2(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef iareobaergb(aj, nde, vis, dis):\n    vis[nde] = 1\n    for x in aj[nde]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[nde] ^ x[1]\n            iareobaergb(aj, x[0], vis, dis)\n\ndef rfoywefooabrvub():\n    n = int(input())\n    aj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        aj[u].append([v, w])\n        aj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    iareobaergb(aj, 0, vis, dist)\n    m = defaultdict(list)\n    for i in range(n):\n        m[dist[i]].append(i)\n    for q in m.items():\n        if len(q[1]) > 1:\n            f = q[1][0]\n            s = q[1][1]\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    m2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            m2[dist[i] ^ dist[j]].append([i, j])\n            if len(m2[dist[i] ^ dist[j]]) > 1:\n                print(m2[dist[i] ^ dist[j]][0][0] + 1, m2[dist[i] ^ dist[j]][0][1] + 1, m2[dist[i] ^ dist[j]][1][0] + 1, m2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print('-1')\ng = int(input())\nfor _ in range(g):\n    rfoywefooabrvub()", "def dfs(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            dfs(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    dfs(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print('1 2 2 ' + str(n))\n            elif f == 0:\n                print('1 ' + str(n) + ' ' + str(s + 1) + ' ' + str(n))\n            elif s == n - 1:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            else:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(str(mp2[dist[i] ^ dist[j]][0][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][0][1] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][1] + 1))\n                return\n    print('-1')\nt = int(input())\nfor i in range(t):\n    solve()", "def dfs(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            dfs(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    dfs(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print('1 2 2 ' + str(n))\n            elif f == 0:\n                print('1 ' + str(n) + ' ' + str(s + 1) + ' ' + str(n))\n            elif s == n - 1:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            else:\n                print('1 ' + str(f + 1) + ' 1 ' + str(s + 1))\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(str(mp2[dist[i] ^ dist[j]][0][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][0][1] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][0] + 1) + ' ' + str(mp2[dist[i] ^ dist[j]][1][1] + 1))\n                return\n    print('-1')\nt = int(input())\nfor i in range(t):\n    solve()", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    g = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        g[u].append((v, w))\n        g[v].append((u, w))\n    d = [0] * (n + 1)\n\n    def dfs(x, p):\n        for (y, k) in g[x]:\n            if y != p:\n                d[y] = k ^ d[x]\n                dfs(y, x)\n    dfs(1, 0)\n    fa = False\n    grp = defaultdict(list)\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            x = d[i] ^ d[j]\n            grp[x].append((i, j))\n            if len(grp[x]) > 1:\n                fa = True\n                res = [grp[x][0], grp[x][1]]\n                break\n        if fa:\n            break\n    if fa:\n        print(*res[0], *res[1])\n    else:\n        print(-1)", "import collections\n\ndef answer(arr, conn, vectorr, two):\n    vectorr[conn] = 1\n    for j in arr[conn]:\n        if not vectorr[j[0]]:\n            two[j[0]] = two[conn] ^ j[1]\n            answer(arr, j[0], vectorr, two)\n\ndef solve():\n    n = int(input())\n    arr = [[] for i in range(n)]\n    for i in range(n - 1):\n        (ss, tt, uu) = map(int, input().split())\n        ss -= 1\n        tt -= 1\n        arr[ss].append([tt, uu])\n        arr[tt].append([ss, uu])\n    one = [0] * n\n    two = [0] * n\n    one[0] = 0\n    answer(arr, 0, two, one)\n    nop = collections.defaultdict(list)\n    for i in range(n):\n        nop[one[i]].append(i)\n    for jk in nop.items():\n        if len(jk[1]) > 1:\n            flag1 = jk[1][0]\n            flag2 = jk[1][1]\n            if flag1 == 0 and flag2 == n - 1:\n                print(1, 2, 2, n - 1)\n            elif flag1 == 0:\n                print(1, n - 1, flag2 + 1, n - 1)\n            elif flag2 == n - 1:\n                print(1, flag1 + 1, 1, flag2 + 1)\n            else:\n                print(1, flag1 + 1, 1, flag2 + 1)\n            return\n    arr2 = collections.defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            arr2[one[i] ^ one[j]].append([i, j])\n            if len(arr2[one[i] ^ one[j]]) > 1:\n                print(arr2[one[i] ^ one[j]][0][0] + 1, arr2[one[i] ^ one[j]][0][1] + 1, arr2[one[i] ^ one[j]][1][0] + 1, arr2[one[i] ^ one[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor i in range(t):\n    solve()", "import sys\nfrom collections import defaultdict\n\ndef fn(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            fn(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    fn(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "def fn(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            fn(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    fn(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp.keys():\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for x in mp:\n        if len(mp[x]) > 1:\n            f = mp[x][0]\n            s = mp[x][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2.keys():\n                mp2[dist[i] ^ dist[j]].append([i, j])\n                if len(mp2[dist[i] ^ dist[j]]) > 1:\n                    print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                    return\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef imp_fun(adjascency_lst, node, visited_vec, distance_vec):\n    visited_vec[node] = 1\n    for iter in adjascency_lst[node]:\n        if visited_vec[iter[0]] == 0:\n            distance_vec[iter[0]] = distance_vec[node] ^ iter[1]\n            imp_fun(adjascency_lst, iter[0], visited_vec, distance_vec)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    adjascency_lst = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        adjascency_lst[u - 1].append([v - 1, w])\n        adjascency_lst[v - 1].append([u - 1, w])\n    distance_vect = [0] * n\n    visited_vec = [0] * n\n    distance_vect[0] = 0\n    imp_fun(adjascency_lst, 0, visited_vec, distance_vect)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[distance_vect[i]].append(i)\n    er = 0\n    for iter in mp.items():\n        if len(iter[1]) > 1:\n            f = iter[1][0]\n            s = iter[1][1]\n            if s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            er += 1\n            break\n    if er > 0:\n        continue\n    second_map = defaultdict(list)\n    for i in range(n):\n        if er > 0:\n            break\n        for j in range(i + 1, n):\n            if er > 0:\n                break\n            second_map[distance_vect[i] ^ distance_vect[j]].append([i, j])\n            if len(second_map[distance_vect[i] ^ distance_vect[j]]) > 1:\n                print(second_map[distance_vect[i] ^ distance_vect[j]][0][0] + 1, second_map[distance_vect[i] ^ distance_vect[j]][0][1] + 1, second_map[distance_vect[i] ^ distance_vect[j]][1][0] + 1, second_map[distance_vect[i] ^ distance_vect[j]][1][1] + 1)\n                er += 1\n                break\n        if er > 0:\n            continue\n    if er > 0:\n        continue\n    print(-1)", "mod = 10 ** 9 + 7\n\ndef checkerforlecker(adj, node, dis, vis):\n    vis[node] = 1\n    for it in adj[node]:\n        if not vis[it[0]]:\n            dis[it[0]] = dis[node] ^ it[1]\n            checkerforlecker(adj, it[0], dis, vis)\n\ndef harukicheck2():\n    n = int(input())\n    res = 0\n    pakkachakka = 1\n    v = []\n    panipani = {}\n    for x in map(int, input().split()):\n        panipani[x] = panipani.get(x, 0) + 1\n    for i in range(1, n + 1):\n        temp = pakkachakka * panipani.get(i, 0)\n        temp %= mod\n        res += temp\n        pakkachakka = temp\n        res %= mod\n    print(res)\n\ndef harukicheck():\n    n = int(input())\n    adj = [[] for i in range(n)]\n    (fullpeck, vis) = ([0] * n, [0] * n)\n    for i in range(n - 1):\n        (edgeu, edgy, w) = map(int, input().split())\n        edgeu -= 1\n        edgy -= 1\n        adj[edgeu].append([edgy, w])\n        adj[edgy].append([edgeu, w])\n    fullpeck[0] = 0\n    checkerforlecker(adj, 0, fullpeck, vis)\n    pepper = {}\n    for i in range(n):\n        pepper[fullpeck[i]] = pepper.get(fullpeck[i], []) + [i]\n    for (k, value) in pepper.items():\n        if len(value) >= 2:\n            f = value[0]\n            s = value[1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    pepper2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            pepper2[fullpeck[i] ^ fullpeck[j]] = pepper2.get(fullpeck[i] ^ fullpeck[j], []) + [[i, j]]\n            if len(pepper2[fullpeck[i] ^ fullpeck[j]]) >= 2:\n                print(pepper2[fullpeck[i] ^ fullpeck[j]][0][0] + 1, pepper2[fullpeck[i] ^ fullpeck[j]][0][1] + 1, pepper2[fullpeck[i] ^ fullpeck[j]][1][0] + 1, pepper2[fullpeck[i] ^ fullpeck[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nwhile t > 0:\n    harukicheck()\n    t -= 1", "from collections import defaultdict\n\ndef func(adjacent, node, visited, distance):\n    visited[node] = 1\n    for i in adjacent[node]:\n        if not visited[i[0]]:\n            distance[i[0]] = distance[node] ^ i[1]\n            func(adjacent, i[0], visited, distance)\n\ndef solve():\n    n = int(input())\n    adjacent = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adjacent[u].append([v, w])\n        adjacent[v].append([u, w])\n    distance = [0] * n\n    visited = [0] * n\n    distance[0] = 0\n    func(adjacent, 0, visited, distance)\n    result = defaultdict(list)\n    for i in range(n):\n        result[distance[i]].append(i)\n    for j in result.items():\n        if len(j[1]) > 1:\n            (a, b) = (j[1][0], j[1][1])\n            if a == 0 and b == n - 1:\n                print(1, 2, 2, n - 1)\n            elif a == 0:\n                print(1, n - 1, b + 1, n - 1)\n            elif b == n - 1:\n                print(1, a + 1, 1, b + 1)\n            else:\n                print(1, a + 1, 1, b + 1)\n            return\n    result2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            result2[distance[i] ^ distance[j]].append([i, j])\n            if len(result2[distance[i] ^ distance[j]]) > 1:\n                print(result2[distance[i] ^ distance[j]][0][0] + 1, result2[distance[i] ^ distance[j]][0][1] + 1, result2[distance[i] ^ distance[j]][1][0] + 1, result2[distance[i] ^ distance[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "def dfs(adj, node, vis, dist):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dist[x[0]] = dist[node] ^ x[1]\n            dfs(adj, x[0], vis, dist)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dfs(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for (k, v) in mp.items():\n        if len(v) > 1:\n            (f, s) = (v[0], v[1])\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n                if len(mp2[dist[i] ^ dist[j]]) > 1:\n                    print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                    return\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n    print('-1')\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            dfs(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    dfs(adj, 0, vis, dist)\n    mp = dict()\n    for i in range(n):\n        if dist[i] not in mp:\n            mp[dist[i]] = []\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] not in mp2:\n                mp2[dist[i] ^ dist[j]] = []\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "def countingSort(arr, exp1):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n    for i in range(0, n):\n        index = arr[i] // exp1\n        count[index % 10] += 1\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp1\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n    i = 0\n    for i in range(0, len(arr)):\n        arr[i] = output[i]\n\ndef radixSort(arr):\n    max1 = max(arr)\n    exp = 1\n    while max1 / exp >= 1:\n        countingSort(arr, exp)\n        exp *= 10\n\ndef fn(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            fn(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    fn(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] not in mp:\n            mp[dist[i]] = []\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] not in mp2:\n                mp2[dist[i] ^ dist[j]] = []\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef dfs(adj, node, vis, dist):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dist[x[0]] = dist[node] ^ x[1]\n            dfs(adj, x[0], vis, dist)\n\ndef solve():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    dist = [0] * n\n    vis = [0] * n\n    dfs(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            (f, s) = (x[1][0], x[1][1])\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print('-1')\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef dfs(adj_list, node, vis, dist):\n    vis[node] = True\n    for (v, w) in adj_list[node]:\n        if not vis[v]:\n            dist[v] = dist[node] ^ w\n            dfs(adj_list, v, vis, dist)\n\ndef solve():\n    n = int(input())\n    adj_list = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n    dist = [0] * n\n    vis = [False] * n\n    dfs(adj_list, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nwhile t:\n    solve()\n    t -= 1", "def fn(adj, node, vis, dis):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dis[x[0]] = dis[node] ^ x[1]\n            fn(adj, x[0], vis, dis)\n\ndef solve():\n    n = int(input())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    fn(adj, 0, vis, dist)\n    mp = {}\n    for i in range(n):\n        if dist[i] in mp:\n            mp[dist[i]].append(i)\n        else:\n            mp[dist[i]] = [i]\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print('1 2 2', n - 1)\n            elif f == 0:\n                print('1', n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print('1', f + 1, '1', s + 1)\n            else:\n                print('1', f + 1, '1', s + 1)\n            return\n    mp2 = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i] ^ dist[j] in mp2:\n                mp2[dist[i] ^ dist[j]].append([i, j])\n                if len(mp2[dist[i] ^ dist[j]]) > 1:\n                    print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                    return\n            else:\n                mp2[dist[i] ^ dist[j]] = [[i, j]]\n    print('-1')\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\n\ndef dfs(adj, node, vis, dist):\n    vis[node] = 1\n    for x in adj[node]:\n        if not vis[x[0]]:\n            dist[x[0]] = dist[node] ^ x[1]\n            dfs(adj, x[0], vis, dist)\n\ndef solve():\n    n = int(input())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append([v, w])\n        adj[v].append([u, w])\n    dist = [0] * n\n    vis = [0] * n\n    dist[0] = 0\n    dfs(adj, 0, vis, dist)\n    mp = defaultdict(list)\n    for i in range(n):\n        mp[dist[i]].append(i)\n    for x in mp.items():\n        if len(x[1]) > 1:\n            f = x[1][0]\n            s = x[1][1]\n            if f == 0 and s == n - 1:\n                print(1, 2, 2, n - 1)\n            elif f == 0:\n                print(1, n - 1, s + 1, n - 1)\n            elif s == n - 1:\n                print(1, f + 1, 1, s + 1)\n            else:\n                print(1, f + 1, 1, s + 1)\n            return\n    mp2 = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mp2[dist[i] ^ dist[j]].append([i, j])\n            if len(mp2[dist[i] ^ dist[j]]) > 1:\n                print(mp2[dist[i] ^ dist[j]][0][0] + 1, mp2[dist[i] ^ dist[j]][0][1] + 1, mp2[dist[i] ^ dist[j]][1][0] + 1, mp2[dist[i] ^ dist[j]][1][1] + 1)\n                return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()"]