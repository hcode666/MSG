["def base_2(x):\n    return bin(x)[2:]\n\ndef f_plus_g(x):\n    b = base_2(x)\n    k = len(b) - 1\n    c = b.count('0')\n    return c + 2 ** (k + 1) + 2 ** k - 1 - x\nfor _ in range(int(input())):\n    (l, r) = [int(x) for x in input().split()]\n    assert l >= 1 and l <= r\n    k = len(base_2(r)) - 1\n    if 2 ** k >= l:\n        print(k + 2 ** (k + 1) - 1)\n        continue\n    x = l\n    mx = 0\n    while x <= r:\n        mx = max(mx, f_plus_g(x))\n        i = (x ^ x - 1).bit_length() - 1\n        x += 2 ** i\n    print(mx)", "def base_2(x):\n    return bin(x)[2:]\n\ndef f_plus_g(x):\n    b = base_2(x)\n    k = len(b) - 1\n    c = b.count('0')\n    return c + 2 ** (k + 1) + 2 ** k - 1 - x\nfor _ in range(int(input())):\n    (l, r) = [int(x) for x in input().split()]\n    assert l >= 1 and l <= r\n    k = len(base_2(r)) - 1\n    if 2 ** k >= l:\n        print(k + 2 ** (k + 1) - 1)\n        continue\n    x = l\n    mx = 0\n    while x <= r:\n        mx = max(mx, f_plus_g(x))\n        i = (x ^ x - 1).bit_length() - 1\n        x += 2 ** i\n    print(mx)", "a = int(input())\nfor i in range(a):\n    (L, R) = map(int, input().split())\n    ans = 0\n    x = bin(L)\n    y = bin(R)\n    p = len(x) - 2\n    q = len(y) - 2\n    if q > p:\n        ans = 2 ** q + q - 2\n    elif q == p:\n        A = []\n        b = min(R - L, 30)\n        c = 2 ** p - 1\n        d = x.count('0') - 1\n        g_L = c - (L - 2 ** (p - 1))\n        f_L = d\n        if L == R:\n            ans = g_L + f_L\n        else:\n            for j in range(1, b + 1):\n                t = bin(L + j).count('0') + g_L - j - 1\n                A.append(t)\n            f = max(A)\n            ans = max(g_L + f_L, f)\n    print(ans)", "a = int(input())\nfor i in range(a):\n    (L, R) = map(int, input().split())\n    ans = 0\n    x = bin(L)\n    y = bin(R)\n    p = len(x) - 2\n    q = len(y) - 2\n    if q > p:\n        ans = 2 ** q + q - 2\n    elif q == p:\n        A = []\n        b = min(R - L, 30)\n        c = 2 ** p - 1\n        d = x.count('0') - 1\n        g_L = c - (L - 2 ** (p - 1))\n        f_L = d\n        if R > L:\n            for j in range(1, b + 1):\n                t = bin(L + j).count('0') + g_L - j - 1\n                A.append(t)\n            f = max(A)\n            ans = max(g_L + f_L, f)\n        else:\n            ans = f_L + g_L\n    print(ans)", "def base_2(x):\n    return bin(x)[2:]\n\ndef f_plus_g(x):\n    b = base_2(x)\n    k = len(b) - 1\n    c = b.count('0')\n    return c + 2 ** (k + 1) + 2 ** k - 1 - x\nfor _ in range(int(input())):\n    (l, r) = [int(x) for x in input().split()]\n    assert l >= 1 and l <= r\n    k = len(base_2(r)) - 1\n    if 2 ** k >= l:\n        print(k + 2 ** (k + 1) - 1)\n        continue\n    x = l\n    mx = 0\n    while x <= r:\n        mx = max(mx, f_plus_g(x))\n        i = (x ^ x - 1).bit_length() - 1\n        x += 2 ** i\n    print(mx)", "def FF(x):\n    return format(x, 'b').count('0')\n\ndef GG(x):\n    pwr2 = x.bit_length()\n    return p_of_2[pwr2] + p_of_2[pwr2 - 1] - x - 1\n\ndef F_G(x):\n    pwr2 = x.bit_length()\n    return format(x, 'b').count('0') + p_of_2[pwr2] + p_of_2[pwr2 - 1] - x - 1\np_of_2 = {i: 2 ** i for i in range(31)}\nfor _ in range(int(input())):\n    (L, R) = map(int, input().split())\n    if R == L:\n        print(F_G(L))\n        continue\n    power_of_2 = max(p_of_2[R.bit_length()] - 1, L)\n    if p_of_2[R.bit_length() - 1] > L:\n        print(F_G(p_of_2[R.bit_length() - 1]))\n        continue\n    upp_lim = L + 2 * R.bit_length()\n    if upp_lim > R:\n        upp_lim = R + 1\n    print(max((F_G(x) for x in range(L, upp_lim))))", "import math\n\ndef bnary(n):\n    return bin(n).replace('0b', '')\n\ndef g(x):\n    if x == 1:\n        return 1\n    if x % 2 == 1:\n        return 2 * g(x // 2)\n    return 2 * g(x // 2) + 1\n\ndef f(x):\n    if x == 1:\n        return 0\n    if x % 2 == 1:\n        return f(x // 2)\n    return f(x // 2) + 1\n\ndef h(x):\n    return f(x) + g(x)\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    x = 1 << int(math.log(r, 2))\n    if x >= l and x <= r:\n        print(f(x) + g(x))\n    else:\n        res = h(l)\n        for i in range(int(math.log(r, 2))):\n            if l >> i & 1 == 1:\n                if l + (1 << i) <= r:\n                    res = max(res, h((l >> i << i) + (1 << i)))\n        print(res)", "def f(n):\n    ans = 0\n    b = bin(n)[2:]\n    for i in b[1:]:\n        if i == '0':\n            ans += 1\n    return ans\n\ndef g(n):\n    ans = 1\n    b = bin(n)[2:]\n    for i in b[1:]:\n        ans *= 2\n        if i == '0':\n            ans += 1\n    return ans\n\ndef solver(l, r):\n    p = 1 << int(len(bin(r)) - 3)\n    x = max(l, p)\n    ans = f(x) + g(x)\n    for i in range(30):\n        if x + i <= r:\n            ans = max(ans, f(x + i) + g(x + i))\n    return ans\nfor t in range(int(input())):\n    (l, r) = map(int, input().split())\n    print(solver(l, r))", "t = int(input())\n\ndef f(x):\n    if x == 1:\n        return 0\n    elif not x & 1:\n        return f(x // 2) + 1\n    else:\n        return f((x - 1) // 2)\n\ndef g(x):\n    if x == 1:\n        return 1\n    elif not x & 1:\n        return 2 * g(x // 2) + 1\n    else:\n        return 2 * g((x - 1) // 2)\n\ndef go(x):\n    return g(x) + f(x)\n\ndef solve():\n    (L, R) = [int(x) for x in input().split(' ')]\n    for i in range(32, -1, -1):\n        if L <= 1 << i <= R:\n            print(go(1 << i))\n            return\n    best = go(L)\n    for x in range(L + 1, min(L + 15, R + 1)):\n        tmp = go(x)\n        if tmp > best:\n            best = tmp\n    print(best)\nwhile t:\n    solve()\n    t -= 1", "t = int(input())\nwhile t:\n    (a, b) = input().split()\n    (a, b) = (int(a), int(b))\n    n = bin(b)[2:]\n    l = len(n)\n    x = 2 ** (l - 1)\n    if x >= a:\n        print(2 * x - 1 + l - 1)\n    elif a > x:\n        k = 2 * x - 1\n        n2 = bin(x)[2:]\n        mx = 0\n        for j in range(a, min(a + 20, b) + 1):\n            n1 = bin(j)[2:]\n            c = 0\n            for i in range(len(n2)):\n                if n1[i] == n2[i] == '0':\n                    c += 1\n            z = k - (j - x) + c\n            if z > mx:\n                mx = z\n        print(mx)\n    t -= 1", "import sys\nfrom math import log\n\ndef f(x):\n    if x == 1:\n        return 0\n    if x % 2 == 0:\n        return f(x // 2) + 1\n    return f(x // 2)\n\ndef g(x):\n    if x == 1:\n        return 1\n    if x % 2 == 0:\n        return 2 * g(x // 2) + 1\n    return 2 * g(x // 2)\n\ndef main():\n    tc = int(input())\n    for _ in range(tc):\n        (a, b) = map(int, input().split())\n        x = 1 << int(log(b, 2))\n        if x >= a and x <= b:\n            print(f(x) + g(x))\n        else:\n            ans = f(a) + g(a)\n            for i in range(int(log(b, 2))):\n                if a >> i & 1 == 1:\n                    if a + (1 << i) <= b:\n                        x = (a >> i << i) + (1 << i)\n                        ans = max(ans, f(x) + g(x))\n            print(ans)\nmain()", "import math\n\ndef bnary(n):\n    return bin(n).replace('0b', '')\n\ndef g(x):\n    if x == 1:\n        return 1\n    if x % 2 == 1:\n        return 2 * g(x // 2)\n    return 2 * g(x // 2) + 1\n\ndef f(x):\n    if x == 1:\n        return 0\n    if x % 2 == 1:\n        return f(x // 2)\n    return f(x // 2) + 1\n\ndef h(x):\n    return f(x) + g(x)\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    x = 1 << int(math.log(r, 2))\n    if x >= l and x <= r:\n        print(f(x) + g(x))\n    else:\n        res = h(l)\n        for i in range(int(math.log(r, 2))):\n            if l >> i & 1 == 1:\n                if l + (1 << i) <= r:\n                    res = max(res, h((l >> i << i) + (1 << i)))\n        print(res)", "def base_2(x):\n    return bin(x)[2:]\n\ndef f_plus_g(x):\n    b = base_2(x)\n    k = len(b) - 1\n    c = b.count('0')\n    return c + 2 ** (k + 1) + 2 ** k - 1 - x\nfor _ in range(int(input())):\n    (l, r) = [int(x) for x in input().split()]\n    assert l >= 1 and l <= r\n    k = len(base_2(r)) - 1\n    if 2 ** k >= l:\n        print(k + 2 ** (k + 1) - 1)\n        continue\n    x = l\n    nx = 0\n    while x <= r:\n        nx = max(nx, f_plus_g(x))\n        i = (x ^ x - 1).bit_length() - 1\n        x += 2 ** i\n    print(nx)", "import math\nt = int(input())\n\ndef value1(val):\n    a = int(math.log(val, 2))\n    low = 2 ** a\n    high = 2 ** (a + 1)\n    x1 = val - low\n    x2 = high - 1 - val\n    if x1 > x2:\n        ans = low + x2\n    else:\n        ans = high - 1 - x1\n    return ans\n\ndef makebin(num):\n    cnt = 0\n    while num != 0:\n        r = num % 2\n        if r == 0:\n            cnt += 1\n        num = num // 2\n    return cnt\nwhile t != 0:\n    (a, b) = map(int, input().split())\n    x1 = int(math.log(a, 2))\n    x2 = int(math.log(b, 2))\n    m1 = 0\n    if x1 == x2:\n        for i in range(a, min(b + 1, a + 30)):\n            m1 = max(m1, makebin(i) + value1(i))\n        print(m1)\n    else:\n        print(x2 + 2 ** (x2 + 1) - 1)\n    t = t - 1", "from cmath import log\nfrom sys import stdin\nimport sys\nfrom collections import Counter\nimport math\ninput = lambda : stdin.readline().rstrip()\nfor _ in range(int(input())):\n\n    def f(x):\n        if x == 1:\n            return 0\n        if x % 2 == 0:\n            return 1 + f(x // 2)\n        if x % 2:\n            return f(x // 2)\n\n    def g(x):\n        if x == 1:\n            return 1\n        if x % 2 == 0:\n            return 1 + 2 * g(x // 2)\n        if x % 2:\n            return 2 * g(x // 2)\n    (a, b) = map(int, input().split())\n    ans = 0\n    p = math.log2(b)\n    t = pow(2, int(p))\n    if t >= a:\n        print(f(t) + g(t))\n        continue\n    for i in range(a, min(a + 14, b + 1)):\n        ans = max(ans, f(i) + g(i))\n    print(ans)", "from cmath import log\nfrom sys import stdin\nimport sys\nfrom collections import Counter\nimport math\ninput = lambda : stdin.readline().rstrip()\nfor _ in range(int(input())):\n\n    def f(x):\n        if x == 1:\n            return 0\n        if x % 2 == 0:\n            return 1 + f(x // 2)\n        if x % 2:\n            return f(x // 2)\n\n    def g(x):\n        if x == 1:\n            return 1\n        if x % 2 == 0:\n            return 1 + 2 * g(x // 2)\n        if x % 2:\n            return 2 * g(x // 2)\n    (a, b) = map(int, input().split())\n    ans = 0\n    p = math.log2(b)\n    t = pow(2, int(p))\n    if t >= a:\n        print(f(t) + g(t))\n        continue\n    for i in range(a, min(a + 16, b + 1)):\n        ans = max(ans, f(i) + g(i))\n    print(ans)", "def base_2(x):\n    return bin(x)[2:]\n\ndef f_plus_g(x):\n    b = base_2(x)\n    k = len(b) - 1\n    c = b.count('0')\n    return c + 2 ** (k + 1) + 2 ** k - 1 - x\nfor _ in range(int(input())):\n    (l, r) = [int(x) for x in input().split()]\n    assert l >= 1 and l <= r\n    k = len(base_2(r)) - 1\n    if 2 ** k >= l:\n        print(k + 2 ** (k + 1) - 1)\n        continue\n    x = l\n    mx = 0\n    while x <= r:\n        mx = max(mx, f_plus_g(x))\n        i = (x ^ x - 1).bit_length() - 1\n        x += 2 ** i\n    print(mx)", "def base_2(x):\n    return bin(x)[2:]\n\ndef f_plus_g(x):\n    b = base_2(x)\n    r = len(b) - 1\n    c = b.count('0')\n    return c + 2 ** (r + 1) + 2 ** r - 1 - x\nfor _ in range(int(input())):\n    (l, r) = [int(x) for x in input().split()]\n    assert l >= 1 and l <= r\n    len_l = len(base_2(l))\n    len_r = len(base_2(r))\n    if len_r > len_l:\n        print(2 ** len_r - 1 + (len_r - 1))\n        continue\n    m = l\n    mx = 0\n    while m <= r:\n        mx = max(mx, f_plus_g(m))\n        i = (m ^ m - 1).bit_length() - 1\n        m += 2 ** i\n    print(mx)", "import math\nt = int(input())\nfor _ in range(t):\n    (l, r) = map(int, input().split())\n    if int(math.log2(l)) < int(math.log2(r)):\n        n = 2 ** int(math.log2(r))\n        print(int(math.log2(n)) + 2 * n - 1)\n    elif int(math.log2(l)) == int(math.log2(r)):\n        if math.log2(l) == int(math.log2(l)):\n            print(int(math.log2(l)) + 2 * l - 1)\n        else:\n            b = bin(l)[2:]\n            gs = ''\n            for i in range(len(b)):\n                if i == 0:\n                    gs += b[i]\n                elif b[i] == '1':\n                    gs += '0'\n                elif b[i] == '0':\n                    gs += '1'\n            g = int(gs, 2)\n            msum = g + b.count('0')\n            for i in range(1, 31):\n                d = l + i\n                if d > r:\n                    break\n                bd = bin(d)[2:]\n                f = bd.count('0')\n                if f + g - i > msum:\n                    msum = f + g - i\n            print(msum)", "t = int(input())\n\ndef f(n):\n    if n == 1:\n        return 0\n    elif n % 2 == 0:\n        return f(n // 2) + 1\n    else:\n        return f(n // 2)\n\ndef g(n):\n    if n == 1:\n        return 1\n    elif n % 2 == 0:\n        return 2 * g(n // 2) + 1\n    else:\n        return 2 * g(n // 2)\nfor _ in range(t):\n    (l, r) = map(int, input().split())\n    m = 0\n    i = 2 ** 29\n    flag = 0\n    while i != 1:\n        if i <= r and i >= l:\n            print(f(i) + g(i))\n            flag = 1\n            break\n        i = i // 2\n    if flag == 0:\n        m = 0\n        if r - l <= 100:\n            for i in range(l, r + 1):\n                m = max(m, f(i) + g(i))\n            print(m)\n        else:\n            for i in range(l, l + 15):\n                m = max(m, f(i) + g(i))\n            print(m)", "import math\n\ndef F(x):\n    if x == 1:\n        return 0\n    if x % 2:\n        return F(x // 2)\n    else:\n        return F(x // 2) + 1\n\ndef G(x):\n    if x == 1:\n        return 1\n    if x % 2:\n        return G(x // 2) * 2\n    else:\n        return G(x // 2) * 2 + 1\nfor _ in range(int(input())):\n    (l, r) = [int(i) for i in input().split()]\n    x = 2 ** len(bin(r)[3:])\n    if l > x:\n        ans = []\n        for i in range(15):\n            ans.append(F(min(l + i, r)) + G(min(l + i, r)))\n        print(max(ans))\n    else:\n        print(F(x) + G(x))", "from math import log\nfrom functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\n@lru_cache(None)\ndef f(x):\n    if x == 1:\n        return 0\n    elif x % 2 == 0:\n        return f(x // 2) + 1\n    return f(x // 2)\n\n@lru_cache(None)\ndef g(x):\n    if x == 1:\n        return 1\n    return 2 * g(x // 2) + (1 if x % 2 == 0 else 0)\nfor i in range(int(input())):\n    (l, r) = map(int, input().split())\n    t = int(log(r, 2))\n    p = pow(2, t)\n    if l <= p <= r:\n        print(f(p) + g(p))\n    elif l == r:\n        print(f(l) + g(l))\n    else:\n        res = 0\n        for el in range(l, min(r, l + 30)):\n            res = max(res, f(el) + g(el))\n        for el in range(r, max(r - 30, l - 1), -1):\n            res = max(res, f(el) + g(el))\n        print(res)", "f = lambda x: bin(x).count('0') - 1\ng = lambda x: (~x & (1 << x.bit_length()) - 1) + (1 << x.bit_length() - 1)\n\ndef solve(l, r):\n    p = 1\n    best = None\n    while p <= r:\n        if p >= l:\n            best = p\n        p <<= 1\n    if best is not None:\n        return f(best) + g(best)\n    return max((f(k) + g(k) for k in range(l, min(l + 100, r + 1))))\nt = int(input())\nfor _ in range(t):\n    (l, r) = map(int, input().split())\n    print(solve(l, r))", "def LII():\n    return [int(x) for x in input().split()]\n\ndef candidates(m, ln):\n    if m == 0:\n        return [m]\n    rv = []\n    while m < 2 ** ln:\n        rv.append(m)\n        b = bin(m)[2:]\n        i = b.rindex('1')\n        m += 2 ** (len(b) - 1 - i)\n    return rv\n\ndef vl(x):\n    b = bin(x)[2:]\n    r = len(b) - 1\n    c = b.count('0')\n    return c + 2 ** (r + 1) + 2 ** r - 1 - x\nfor _ in range(int(input())):\n    (l, r) = LII()\n    mx = 0\n    i = len(bin(l)) - 3\n    assert 2 ** i <= l\n    while 2 ** i <= r:\n        l0 = max(l, 2 ** i)\n        r0 = min(r, 2 ** (i + 1) - 1)\n        for x in candidates(l0 - 2 ** i, i):\n            y = x + 2 ** i\n            if y <= r0 and vl(y) > mx:\n                mx = vl(y)\n        i += 1\n    print(mx)", "RI = lambda : [int(_x) for _x in input().split()]\nII = lambda : int(input())\nfrom itertools import permutations as p\nfrom random import randint as R\nimport sys\nimport math\nmod = 10 ** 9 + 7\nmxn = 2 * 10 ** 5 + 10\nF = [1] * mxn\nm1 = {}\nm2 = {}\n\ndef f(x):\n    if x == 1:\n        return 0\n    if x in m1:\n        return m1[x]\n    if x & 1:\n        ans = f(x // 2)\n    else:\n        ans = f(x // 2) + 1\n    m1[x] = ans\n    return ans\n\ndef g(x):\n    if x == 1:\n        return 1\n    if x in m2:\n        return m2[x]\n    if x & 1:\n        ans = 2 * g(x // 2)\n    else:\n        ans = 2 * g(x // 2) + 1\n    m2[x] = ans\n    return ans\nfor _ in range(II()):\n    (l, r) = RI()\n    nn = 1\n    while nn * 2 <= r:\n        nn *= 2\n    if nn >= l:\n        mid = nn\n    else:\n        mid = l\n    mx = f(mid) + g(mid)\n    for i in range(32):\n        if 1 << i & mid:\n            mid ^= 1 << i\n        elif l <= mid | 1 << i <= r:\n            mx = max(mx, f(mid | 1 << i) + g(mid | 1 << i))\n    print(mx)", "import math\n\ndef fplusg(x):\n    f = bin(x)[2:].count('0')\n    temp = 2 ** (math.floor(math.log2(x)) + 1)\n    g = temp + temp // 2 - 1 - x\n    return f + g\nfor tea in range(int(input())):\n    (l, r) = map(int, input().split())\n    lawl = 2 ** math.floor(math.log2(r))\n    if lawl >= l:\n        print(fplusg(lawl))\n    else:\n        ell = l\n        paw = 1\n        best = -1\n        while ell <= r:\n            best = max(best, fplusg(ell))\n            paw *= 2\n            if ell % paw != 0:\n                ell += paw // 2\n        print(best)", "from random import randint\nimport sys\ninput = lambda : sys.stdin.readline().strip()\nir = lambda : int(sys.stdin.readline())\nrir = lambda : range(int(sys.stdin.readline()))\nmir = lambda : map(int, sys.stdin.readline().split())\nlmir = lambda : list(map(int, sys.stdin.readline().split()))\n\ndef naive(l, r):\n    return max((h(x) for x in range(l, r + 1)))\n\ndef smart(l, r):\n    ans = 0\n    i = r\n    while i >= l:\n        ans = max(ans, ph(i))\n        i &= i - 1\n    i = l\n    while i <= r:\n        ans = max(ans, ph(i))\n        i += i - (i & i - 1)\n    return ans\n\ndef debug():\n    for _ in range(1000):\n        args = sorted([randint(1, 1000), randint(1, 1000)])\n        nn = naive(*args)\n        ss = smart(*args)\n        if nn != ss:\n            print(args, '|', nn, ss)\n    sys.exit(0)\n\ndef f(x):\n    return 0 if x == 1 else f(x >> 1) + (~x & 1)\n\ndef g(x):\n    return 1 if x == 1 else 2 * g(x >> 1) + (~x & 1)\n\ndef h(x):\n    return f(x) + g(x)\n\ndef ph(x):\n    return bin(x).count('0') + 3 * (1 << x.bit_length() - 1) - x - 2\nfor _ in rir():\n    (l, r) = mir()\n    print(smart(l, r))"]