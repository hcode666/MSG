["from math import ceil\nfor _ in range(int(input())):\n    n = int(input())\n    all = [int(i) for i in input().split()]\n    ans = 0\n    all.sort()\n    for i in range(n):\n        ans = max(ans, ceil((i + 1) / all[i]))\n    print(ans)", "from collections import defaultdict\nimport math\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    d = defaultdict(int)\n    for i in a:\n        d[i] += 1\n    s = 1\n    el = 0\n    for i in range(1, max(a) + 1):\n        if d[i] > s * i - el:\n            s += math.ceil((d[i] - s * i + el) / i)\n        el += d[i]\n    print(s)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    A.sort()\n    count = 1\n    B = []\n    for i in range(n - 1):\n        if A[i] != A[i + 1]:\n            if (i + 1) % A[i] == 0:\n                B.append((i + 1) // A[i])\n            else:\n                B.append((i + 1) // A[i] + 1)\n    if n % A[n - 1] == 0:\n        B.append(n // A[n - 1])\n    else:\n        B.append(n // A[n - 1] + 1)\n    print(max(B))", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    A.sort()\n    count = 1\n    B = []\n    for i in range(n - 1):\n        if A[i] != A[i + 1]:\n            if (i + 1) % A[i] == 0:\n                B.append((i + 1) // A[i])\n            else:\n                B.append((i + 1) // A[i] + 1)\n    if n % A[n - 1] == 0:\n        B.append(n // A[n - 1])\n    else:\n        B.append(n // A[n - 1] + 1)\n    print(max(B))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split(' ')))\n    count = {}\n    for c in arr:\n        count[c] = 1 + count.get(c, 0)\n    ans = 0\n    k = 0\n    for i in range(1, n + 1):\n        val = count.get(i, 0)\n        ans = max(ans, math.ceil((val + k) / i))\n        k += val\n    print(ans)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 0\n    for i in range(n):\n        ans = max(ans, math.ceil((i + 1) / a[i]))\n    print(int(ans))", "from math import ceil\nT = int(input())\nfinal = list()\nfor t in range(T):\n    N = int(input())\n    array = sorted(map(int, input().split()))\n    (ans, index) = (0, 1)\n    for number in array:\n        ans = max(ceil(index / number), ans)\n        index += 1\n    final.append(ans)\nfor f in final:\n    print(f)", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "from heapq import heapify, heappush, heappop\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    heapify(arr)\n    list1 = [1]\n    heapify(list1)\n    while arr:\n        x = heappop(arr)\n        y = heappop(list1)\n        if x >= y:\n            y += 1\n            heappush(list1, y)\n        else:\n            heappush(list1, y)\n            heappush(list1, 2)\n    print(len(list1))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([i // A[i] + 1 for i in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "from heapq import heapify, heappush, heappop\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    heapify(arr)\n    list1 = [1]\n    heapify(list1)\n    while arr:\n        x = heappop(arr)\n        y = heappop(list1)\n        if x >= y:\n            y += 1\n            heappush(list1, y)\n        else:\n            heappush(list1, y)\n            heappush(list1, 2)\n    print(len(list1))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "for i in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(max([j // A[j] + 1 for j in range(N)]))", "import bisect\nfor z in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    a.sort()\n    c = 0\n    while n > 0:\n        i = 1\n        while bisect.bisect_left(a, i) != n:\n            a.pop(bisect.bisect_left(a, i))\n            i += 1\n            n -= 1\n        c += 1\n    print(c)", "for i in range(int(input())):\n    lens = int(input())\n    array = list(map(int, input().split()))\n    array.sort()\n    k = 0\n    for i in range(len(array)):\n        a = i + 1\n        b = array[i]\n        k = max(-(-a // b), k)\n    print(k)", "class SortedList:\n\n    def __init__(self, iterable=[], _load=200):\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return (0, k)\n        if k >= self._len - _list_lens[-1]:\n            return (len(_list_lens) - 1, k + _list_lens[-1] - self._len)\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return (idx + 1, k)\n\n    def _delete(self, pos, idx):\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (lo, pos) = (-1, len(_lists) - 1)\n        while lo + 1 < pos:\n            mi = lo + pos >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def _loc_right(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (pos, hi) = (0, len(_lists))\n        while pos + 1 < hi:\n            mi = pos + hi >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def add(self, value):\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len += 1\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        (pos, idx) = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        (pos, idx) = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        return self._len\n\n    def __getitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        return 'SortedList({0})'.format(list(self))\nt = int(input())\nfor j in range(t):\n    length = int(input())\n    arr = SortedList(list(map(int, input().split())))\n    c = 0\n    while len(arr) > 0:\n        i = 1\n        while arr.bisect_left(i) != len(arr):\n            arr.pop(arr.bisect_left(i))\n            i += 1\n        c += 1\n    print(c)", "import bisect\nimport heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    q = []\n    res = 0\n    for x in A:\n        if not q or (q and q[0] > x):\n            heapq.heappush(q, 2)\n            res += 1\n        else:\n            heapq.heappush(q, heapq.heappop(q) + 1)\n    print(res)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr = sorted(arr)\n    q = list()\n    heapq.heappush(q, 1)\n    for i in range(n):\n        if arr[i] >= q[0]:\n            heapq.heappush(q, q[0] + 1)\n            heapq.heappop(q)\n        else:\n            heapq.heappush(q, 2)\n    print(len(q))", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr = sorted(arr)\n    q = list()\n    heapq.heappush(q, 1)\n    for i in range(n):\n        if arr[i] >= q[0]:\n            heapq.heappush(q, q[0] + 1)\n            heapq.heappop(q)\n        else:\n            heapq.heappush(q, 2)\n    print(len(q))", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr = sorted(arr)\n    q = list()\n    heapq.heappush(q, 1)\n    for i in range(n):\n        if arr[i] >= q[0]:\n            heapq.heappush(q, q[0] + 1)\n            heapq.heappop(q)\n        else:\n            heapq.heappush(q, 2)\n    print(len(q))", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr = sorted(arr)\n    q = list()\n    heapq.heappush(q, 1)\n    for i in range(n):\n        if arr[i] >= q[0]:\n            heapq.heappush(q, q[0] + 1)\n            heapq.heappop(q)\n        else:\n            heapq.heappush(q, 2)\n    print(len(q))", "import collections as clts\nimport math\nimport heapq\n\ndef gcd(x, y):\n    if y == 0:\n        return x\n    else:\n        return gcd(y, x % y)\n\ndef lcm(x, y):\n    return int(x / gcd(x, y) * y)\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    valid = True\n    for i in range(N):\n        if A[i] < i + 1:\n            valid = False\n            break\n    if valid:\n        print(1)\n    else:\n        A = sorted(A)\n        ele = []\n        for i in range(N):\n            if len(ele) == 0:\n                heapq.heappush(ele, 1)\n            else:\n                e = heapq.heappop(ele)\n                if A[i] >= e + 1:\n                    heapq.heappush(ele, e + 1)\n                else:\n                    heapq.heappush(ele, 1)\n                    heapq.heappush(ele, e)\n        print(len(ele))", "import collections as clts\nimport math\nimport heapq\n\ndef gcd(x, y):\n    if y == 0:\n        return x\n    else:\n        return gcd(y, x % y)\n\ndef lcm(x, y):\n    return int(x / gcd(x, y) * y)\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    valid = True\n    for i in range(N):\n        if A[i] < i + 1:\n            valid = False\n            break\n    if valid:\n        print(1)\n    else:\n        A = sorted(A)\n        ele = []\n        for i in range(N):\n            if len(ele) == 0:\n                heapq.heappush(ele, 1)\n            else:\n                e = heapq.heappop(ele)\n                if A[i] >= e + 1:\n                    heapq.heappush(ele, e + 1)\n                else:\n                    heapq.heappush(ele, 1)\n                    heapq.heappush(ele, e)\n        print(len(ele))", "import sys\nfrom os import path\nif path.exists('Input.txt'):\n    sys.stdin = open('Input.txt', 'r')\n    sys.stdout = open('Output.txt', 'w')\nimport math\nfrom collections import deque\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = dict()\n    for ii in range(1, n + 1):\n        d[ii] = 0\n    for i in range(n):\n        d[a[i]] += 1\n    ans = 0\n    y = 0\n    for i in range(1, n + 1):\n        y += d[i]\n        x = math.ceil(y / i)\n        ans = max(ans, x)\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "from queue import PriorityQueue\ncase = int(input())\nfor _ in range(case):\n    n = int(input())\n    arr = list(map(int, input().split(' ')))\n    arr.sort()\n    que = PriorityQueue()\n    que.put(1)\n    for i in range(n):\n        val = que.get()\n        if arr[i] >= val:\n            que.put(val + 1)\n        else:\n            que.put(val)\n            que.put(2)\n    print(que.qsize())", "import sys, math, bisect, heapq, collections, itertools, functools\ninum = lambda : int(sys.stdin.readline())\nimap = lambda : map(int, sys.stdin.readline().split())\nitup = lambda : tuple(map(int, sys.stdin.readline().split()))\nisor = lambda : sorted(map(int, sys.stdin.readline().split()))\nisor2 = lambda nums: sorted(nums, key=lambda num1: (num1[0], num1[1]))\nilis = lambda : [int(zz) for zz in sys.stdin.readline().split()]\ndd = lambda : collections.defaultdict(lambda : 0)\nadjlist = lambda : collections.defaultdict(lambda : [])\nlcm = lambda num1, num2: num1 * num2 // math.gcd(num1, num2)\nnpr = lambda num1, num2: math.factorial(num1) // math.factorial(num1 - num2)\nlowerpower = lambda num1, num2: pow(num2, math.floor(math.log(num1, num2)))\nupperpower = lambda num1, num2: pow(num2, math.ceil(math.log(num1, num2)))\nisperfectsquare = lambda num1: math.ceil(math.log(num1, 2)) == math.floor(math.log(num1, 2))\nncr = lambda num1, num2: math.factorial(num1) // (math.factorial(num2) * math.factorial(num1 - num2))\nfiltereven = lambda nums: list(filter(lambda num1: num1 % 2 == 0, nums))\nfilteroddd = lambda nums: list(filter(lambda num1: num1 % 2 != 0, nums))\nfact = lambda num1: functools.reduce(lambda num2, num3: num2 * num3, range(1, num1 + 1))\nfreqarray = lambda nums: collections.Counter(nums)\nbitsetarray = lambda nums: [int(num1) for num1 in bin(nums)[2:]]\nlengthbitset = lambda num1: math.ceil(math.log(num1 + 0.1, 2))\nbit_check = lambda num1, num2: num1 & 1 << num2\nbit_set = lambda num1, num2: num1 | 1 << num2\nbit_unset = lambda num1, num2: num1 & ~(1 << num2)\nbit_toggle = lambda num1, num2: num1 ^ 1 << num2\nminheap = lambda nums: 1 if heapq.heapify(nums) == None else 0\nmaxheap = lambda nums: 1 if heapq._heapify_max(nums) == None else 0\nlowerbound = lambda nums, key, start, stop: bisect.bisect_left(nums, key, lo=start, hi=stop)\nupperbound = lambda nums, key, start, stop: bisect.bisect_right(nums, key, lo=start, hi=stop)\ninorder = lambda root: inorder(root.left) + [root.val] + inorder(root.right) if root else []\nprefixsumarray = lambda nums: list(itertools.accumulate(nums, lambda num1, num2: num1 + num2))\nsuffixsumarray = lambda nums: prefixsum(reversed(nums))\ngrid = lambda rows, cols: [[0 for j in range(cols)] for idx in range(rows)]\npalindromeindices = lambda num1: [(num1 // 2 - i - (0 if num1 & 1 else 1), num1 // 2 + i) for i in range(num1 // 2 + (1 if num1 & 1 else 0))]\nonum = lambda num1: '%d' % num1\nomap = lambda num1, num2: '%d %d' % (num1, num2)\nolis = lambda nums: ' '.join((str(nums[idx]) for idx in range(len(nums))))\nodict = lambda nums: '\\n'.join((str('%idx: %s' % (num1[0], ' '.join((str(num2) for num2 in num1[1])))) for num1 in zip(nums.keys(), nums.values())))\nogrid = lambda grid: '\\n'.join((' '.join((str(num1) for num1 in nums)) for nums in grid))\ntcs = 1 if not True else int(input())\nfor tc in range(1, tcs + 1):\n    n = inum()\n    arr = isor()\n    cur = ans = 1\n    while len(arr) > 0:\n        pos = bisect.bisect_left(arr, cur)\n        if pos != len(arr):\n            arr.pop(pos)\n            cur += 1\n        else:\n            cur = 1\n            ans += 1\n    print(ans)", "for i in range(int(input())):\n    lens = int(input())\n    array = list(map(int, input().split()))\n    array.sort()\n    k = 0\n    for i in range(len(array)):\n        a = i + 1\n        b = array[i]\n        k = max(-(-a // b), k)\n    print(k)", "from heapq import heapify, heappush, heappop\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    array = list(map(int, input().split(' ')[:n]))\n    array.sort()\n    minheap = [0]\n    heapify(minheap)\n    for num in array:\n        temp = heappop(minheap)\n        if temp < num:\n            temp += 1\n            heappush(minheap, temp)\n        else:\n            heappush(minheap, temp)\n            heappush(minheap, 1)\n    print(len(minheap))\n    t -= 1", "for i in range(int(input())):\n    lens = int(input())\n    array = list(map(int, input().split()))\n    array.sort()\n    k = 0\n    for i in range(len(array)):\n        a = i + 1\n        b = array[i]\n        k = max(-(-a // b), k)\n    print(k)", "for i in range(int(input())):\n    lens = int(input())\n    array = list(map(int, input().split()))\n    array.sort()\n    k = 0\n    for i in range(len(array)):\n        a = i + 1\n        b = array[i]\n        k = max(-(-a // b), k)\n    print(k)", "for i in range(int(input())):\n    lens = int(input())\n    array = list(map(int, input().split()))\n    array.sort()\n    k = 0\n    for i in range(len(array)):\n        a = i + 1\n        b = array[i]\n        k = max(-(-a // b), k)\n    print(k)", "test = int(input())\nwhile test:\n    test -= 1\n    val = int(input())\n    A = input()\n    A = list(map(int, A.split(' ')))\n    maxIndex = max(max(A) + 1, val + 1)\n    newA = [0] * maxIndex\n    for i in A:\n        newA[i] += 1\n    sumx = 0\n    k = 0\n    for i in range(1, val + 1):\n        sumx += newA[i]\n        k = max(k, (sumx + i - 1) // i)\n    print(k)", "test = int(input())\nwhile test:\n    test -= 1\n    val = int(input())\n    A = input()\n    A = list(map(int, A.split(' ')))\n    maxIndex = max(max(A) + 1, val + 1)\n    newA = [0] * maxIndex\n    for i in A:\n        newA[i] += 1\n    sumx = 0\n    k = 0\n    for i in range(1, val + 1):\n        sumx += newA[i]\n        k = max(k, (sumx + i - 1) // i)\n    print(k)", "test = int(input())\nwhile test:\n    test -= 1\n    val = int(input())\n    A = input()\n    A = list(map(int, A.split(' ')))\n    maxIndex = max(max(A) + 1, val + 1)\n    newA = [0] * maxIndex\n    for i in A:\n        newA[i] += 1\n    sumx = 0\n    k = 0\n    for i in range(1, val + 1):\n        sumx += newA[i]\n        k = max(k, (sumx + i - 1) // i)\n    print(k)", "test = int(input())\nwhile test:\n    test -= 1\n    val = int(input())\n    A = input()\n    A = list(map(int, A.split(' ')))\n    maxIndex = max(max(A) + 1, val + 1)\n    newA = [0] * maxIndex\n    for i in A:\n        newA[i] += 1\n    sumx = 0\n    k = 0\n    for i in range(1, val + 1):\n        sumx += newA[i]\n        k = max(k, (sumx + i - 1) // i)\n    print(k)", "from queue import PriorityQueue\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    q = PriorityQueue()\n    q.put(1)\n    a.sort()\n    for i in a:\n        minIndex = q.get()\n        if i >= minIndex:\n            q.put(minIndex + 1)\n        else:\n            q.put(2)\n            q.put(minIndex)\n    print(q.qsize())", "t = int(input())\nc = 0\nfor i in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    a.sort()\n    print(max([i // a[i] + 1 for i in range(n)]))", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    arr.sort()\n    ans = 0\n    for i in range(n):\n        ans = max(ans, math.ceil((i + 1) / arr[i]))\n    print(ans)", "import math\nfor i in range(int(input())):\n    n = int(input())\n    nlist = list(map(int, input().split()))\n    nlist.sort()\n    ans = 0\n    count = 1\n    filled = 0\n    for j in range(1, n):\n        if nlist[j] != nlist[j - 1]:\n            curr = nlist[j - 1] * ans - filled\n            filled += count\n            if count >= curr:\n                count -= curr\n                ans += math.ceil(count / nlist[j - 1])\n            count = 1\n        else:\n            count += 1\n    curr = nlist[n - 1] * ans - filled\n    filled += count\n    if count >= curr:\n        count -= curr\n        ans += math.ceil(count / nlist[n - 1])\n    print(ans)", "import heapq\n\ndef solve(n, arr):\n    arr = sorted(arr)\n    q = list()\n    heapq.heappush(q, 1)\n    for i in range(n):\n        if arr[i] >= q[0]:\n            heapq.heappush(q, q[0] + 1)\n            heapq.heappop(q)\n        else:\n            heapq.heappush(q, 2)\n    return len(q)\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    print(solve(n, arr))\n    t -= 1", "for i in range(int(input())):\n    lens = int(input())\n    array = list(map(int, input().split()))\n    array.sort()\n    ans = 0\n    for i in range(len(array)):\n        a = i + 1\n        b = array[i]\n        ans = max(-(-a // b), ans)\n    print(ans)", "for i in range(int(input())):\n    lens = int(input())\n    array = list(map(int, input().split()))\n    array.sort()\n    ans = 0\n    for i in range(len(array)):\n        a = i + 1\n        b = array[i]\n        ans = max(-(-a // b), ans)\n    print(ans)", "for i in range(int(input())):\n    lens = int(input())\n    array = list(map(int, input().split()))\n    array.sort()\n    ans = 0\n    for i in range(len(array)):\n        a = i + 1\n        b = array[i]\n        ans = max(-(-a // b), ans)\n    print(ans)", "for i in range(int(input())):\n    lens = int(input())\n    array = list(map(int, input().split()))\n    array.sort()\n    ans = 0\n    for i in range(len(array)):\n        a = i + 1\n        b = array[i]\n        ans = max(-(-a // b), ans)\n    print(ans)", "import collections\nt = int(input())\nfor _ in range(0, t):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    B = collections.Counter(A)\n    (L, R) = (0, N + 1)\n    while L + 1 < R:\n        M = (L + R) // 2\n        ans = 1\n        C = []\n        for i in range(M):\n            C.append([])\n        j = 0\n        i = 0\n        while i < N:\n            if len(C[j]) < A[i]:\n                C[j].append(A[i])\n                i += 1\n                ans = 0\n            else:\n                j += 1\n            if j >= M:\n                j %= M\n                if ans:\n                    break\n                ans = 1\n        if i == N:\n            R = M\n        else:\n            L = M\n    print(R)", "import sys\nimport os\nimport math\nimport collections\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    B = collections.Counter(A)\n    (L, R) = (0, N + 1)\n    while L + 1 < R:\n        M = (L + R) // 2\n        ans = 1\n        C = []\n        for i in range(M):\n            C.append([])\n        j = 0\n        i = 0\n        while i < N:\n            if len(C[j]) < A[i]:\n                C[j].append(A[i])\n                i += 1\n                ans = 0\n            else:\n                j += 1\n            if j >= M:\n                j %= M\n                if ans:\n                    break\n                ans = 1\n        if i == N:\n            R = M\n        else:\n            L = M\n    print(R)", "import copy\nimport math\n\ndef solve(a, b):\n    a.sort()\n    b = [[a[0], 1]]\n    c = 0\n    for i in range(1, len(a)):\n        if a[i] == b[c][0]:\n            b[c][1] += 1\n        else:\n            c += 1\n            b.append([a[i], 1])\n    c = 0\n    d = 0\n    while len(b) != 0:\n        r = 0\n        c = 0\n        e = len(b)\n        for i in range(e):\n            if b[i - c][0] - r >= b[i - c][1]:\n                r += b[i - c][1]\n                b.pop(i - c)\n                c += 1\n            else:\n                b[i - c][1] -= b[i - c][0] - r\n                r = b[i - c][0]\n        d += 1\n    print(d)\nfor i in range(int(input())):\n    a = int(input())\n    b = list(map(int, input().strip().split()))\n    solve(b, a)", "for _ in range(int(input())):\n    sizeOfInput = int(input())\n    tempList = list(map(int, input().split()))\n    dict = {}\n    for x in tempList:\n        dict[x] = dict.get(x, 0) + 1\n    sortedDict = {}\n    for key in sorted(dict.keys()):\n        sortedDict[key] = dict[key]\n    AnswerList = []\n    numberOfAnswerLists = 0\n    for element in list(sortedDict.keys()):\n        nextList = 0\n        for i in range(1, sortedDict[element] + 1):\n            if numberOfAnswerLists == 0:\n                AnswerList.append([element])\n                numberOfAnswerLists += 1\n            else:\n                inserted = False\n                for lists in range(nextList, numberOfAnswerLists):\n                    if element >= len(AnswerList[lists]) + 1:\n                        AnswerList[lists].append(element)\n                        nextList = lists\n                        inserted = True\n                        break\n                if inserted == False:\n                    AnswerList.append([element])\n                    nextList = numberOfAnswerLists\n                    numberOfAnswerLists += 1\n    print(numberOfAnswerLists)", "import bisect\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    l.sort()\n    slst = [1]\n    for i in l:\n        if i >= slst[0]:\n            tmp = slst[0]\n            del slst[0]\n            bisect.insort(slst, tmp + 1)\n        else:\n            slst = [2] + slst\n    print(len(slst))", "import heapq\nfor t in range(int(input())):\n    n = int(input())\n    lst = [int(x) for x in input().split()]\n    lst.sort()\n    lst1 = []\n    heapq.heapify(lst1)\n    heapq.heappush(lst1, 1)\n    cntr = 1\n    for x in lst[1:]:\n        if x > lst1[0]:\n            a = heapq.heappop(lst1)\n            heapq.heappush(lst1, a + 1)\n            pass\n        else:\n            cntr += 1\n            heapq.heappush(lst1, 1)\n    print(cntr)", "from queue import PriorityQueue\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    q = PriorityQueue()\n    q.put(1)\n    for item in arr:\n        ln = q.get()\n        if item >= ln:\n            ln += 1\n        else:\n            q.put(2)\n        q.put(ln)\n    print(q.qsize())", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    l.sort()\n    heap = []\n    heapq.heappush(heap, 1)\n    for i in range(n):\n        cur = l[i]\n        top = heapq.heappop(heap)\n        if cur >= top:\n            top += 1\n        else:\n            heapq.heappush(heap, 2)\n        heapq.heappush(heap, top)\n    print(len(heap))", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    arr.sort()\n    ans = 0\n    for i in range(len(arr)):\n        k = math.ceil((i + 1) / arr[i])\n        ans = max(ans, k)\n    print(ans)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    arr.sort()\n    ans = 0\n    for i in range(len(arr)):\n        k = math.ceil((i + 1) / arr[i])\n        ans = max(ans, k)\n    print(ans)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    arr.sort()\n    ans = 0\n    for i in range(len(arr)):\n        k = math.ceil((i + 1) / arr[i])\n        ans = max(ans, k)\n    print(ans)", "from math import ceil\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))[:n]\n    c = 0\n    l.sort()\n    for i in range(n):\n        c = max(c, ceil((i + 1) / l[i]))\n    print(c)", "from queue import PriorityQueue\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    q = PriorityQueue()\n    q.put(0)\n    for item in arr:\n        ln = q.get()\n        if item >= ln + 1:\n            ln += 1\n        else:\n            q.put(1)\n        q.put(ln)\n    print(q.qsize())", "from queue import PriorityQueue\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    q = PriorityQueue()\n    q.put((0, 1))\n    for item in arr:\n        (ln, mn) = q.get()\n        if item >= ln + 1:\n            ln += 1\n            mn = min(mn, item)\n        else:\n            q.put((1, item))\n        q.put((ln, mn))\n    print(q.qsize())", "from queue import PriorityQueue\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    q = PriorityQueue()\n    q.put((0, 1))\n    for item in arr:\n        (ln, mn) = q.get()\n        if item >= ln + 1 and item >= mn:\n            ln += 1\n            mn = min(mn, item)\n        else:\n            q.put((1, item))\n        q.put((ln, mn))\n    print(q.qsize())", "import heapq\nfrom math import gcd, sqrt, ceil\n\ndef ti():\n    return tuple(map(int, input().split()))\n\ndef li():\n    return list(map(int, input().split()))\n\ndef si():\n    return input().split()\n\ndef ii():\n    return int(input())\n\ndef ip():\n    return input()\nfor tastcas in range(int(input())):\n    n = ii()\n    a = li()\n    a.sort()\n    ans = 0\n    for i in range(n):\n        ans = max(ans, ceil((i + 1) / a[i]))\n    print(ans)", "from math import ceil\nfor _ in range(int(input())):\n    n = int(input())\n    all = [int(i) for i in input().split()]\n    ans = 0\n    all.sort()\n    for i in range(n):\n        ans = max(ans, ceil((i + 1) / all[i]))\n    print(ans)"]