["import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log2, ceil\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom bisect import insort\nfrom collections import Counter\nfrom collections import deque\nfrom heapq import heappush, heappop, heapify\nfrom itertools import permutations, combinations\nfrom itertools import accumulate as ac\nfrom random import randint as ri\nmod = int(1000000000.0) + 7\nip = lambda : int(stdin.readline())\ninp = lambda : map(int, stdin.readline().split())\nips = lambda : stdin.readline().rstrip()\nout = lambda x: stdout.write(str(x) + '\\n')\n\ndef prime(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\nt = ip()\nfor _ in range(t):\n    (n, k) = inp()\n    a = []\n    b = []\n    pr = prime(n + 1)\n    st = n // 2 + 1\n    for i in range(2, st):\n        a.append(i)\n    for i in range(st, n + 1):\n        if pr[i]:\n            b.append(i)\n        else:\n            a.append(i)\n    sta = list(a)\n    stb = list(b)\n    b.append(1)\n    f = False\n    while b:\n        if k == len(a):\n            f = True\n            ans = a\n            break\n        elif k == len(b):\n            f = True\n            ans = b\n            break\n        else:\n            a.append(b.pop())\n    a = list(sta)\n    b = list(stb)\n    a.append(1)\n    while b:\n        if k == len(a):\n            f = True\n            ans = a\n            break\n        elif k == len(b):\n            f = True\n            ans = b\n            break\n        else:\n            a.append(b.pop())\n    if f:\n        print('Yes')\n        ans.sort()\n        print(*ans)\n    else:\n        print('No')", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n\n    def find(a):\n        x = []\n        while a != arr[a]:\n            x.append(a)\n            a = arr[a]\n        for i in x:\n            arr[i] = a\n        return a\n\n    def union(a, b):\n        if size[a] > size[b]:\n            arr[b] = a\n            size[a] += size[b]\n        else:\n            arr[a] = b\n            size[b] += size[a]\n    (n, k) = mp()\n    arr = [i for i in range(n + 1)]\n    size = [1] * (n + 1)\n    i = 2\n    while i * 2 <= n:\n        if arr[i] == i:\n            for j in range(2 * i, n + 1, i):\n                (x, y) = (find(i), find(j))\n                if x != y:\n                    union(x, y)\n        i += 1\n    d = defaultdict(list)\n    for i in range(1, n + 1):\n        a = find(i)\n        d[a].append(i)\n    x = list(d.keys())\n    x.sort(key=lambda y: len(d[y]))\n    ans = []\n    N = len(x)\n    i = N - 1\n    while k > 0 and i >= 0:\n        if len(d[x[i]]) <= k:\n            ans.append(x[i])\n            k -= len(d[x[i]])\n        i -= 1\n    if k != 0:\n        pr('No')\n    else:\n        pr('Yes')\n        for i in ans:\n            print(*d[i])\nfor _ in range(inp()):\n    solve()"]