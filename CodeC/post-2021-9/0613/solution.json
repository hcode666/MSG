["import collections\nimport math\nmod = 1000000007\n\ndef multiply(a, b):\n    mul = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                mul[i][j] += a[i][k] * b[k][j]\n                mul[i][j] %= mod\n    return mul\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = map(int, input().split())\n    s = str(input())\n    matrix_A = [0] * 10\n    for x in s:\n        matrix_A[ord(x) - ord('0')] += 1\n    matrix_C = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            cur = str(j * k)\n            matrix_C[i][j] += cur.count(str(i))\n    matrix_E = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        matrix_E[i][i] = 1\n    while m != 0:\n        if m % 2 == 1:\n            matrix_E = multiply(matrix_E, matrix_C)\n            m -= 1\n        matrix_C = multiply(matrix_C, matrix_C)\n        m //= 2\n    matrix_B = [0] * 10\n    for i in range(10):\n        for j in range(10):\n            matrix_B[i] += matrix_A[j] * matrix_E[i][j]\n            matrix_B[i] %= mod\n    print(sum(matrix_B) % mod)", "import collections\nimport math\nmod = 1000000007\n\ndef multiply(a, b):\n    mul = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                mul[i][j] += a[i][k] * b[k][j]\n                mul[i][j] %= mod\n    return mul\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = map(int, input().split())\n    s = str(input())\n    matrix_A = [0] * 10\n    for x in s:\n        matrix_A[ord(x) - ord('0')] += 1\n    matrix_C = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            cur = str(j * k)\n            matrix_C[i][j] += cur.count(str(i))\n    matrix_E = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        matrix_E[i][i] = 1\n    while m != 0:\n        if m % 2 == 1:\n            matrix_E = multiply(matrix_E, matrix_C)\n            m -= 1\n        matrix_C = multiply(matrix_C, matrix_C)\n        m //= 2\n    matrix_B = [0] * 10\n    for i in range(10):\n        for j in range(10):\n            matrix_B[i] += matrix_A[j] * matrix_E[i][j]\n            matrix_B[i] %= mod\n    print(sum(matrix_B) % mod)", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "import math, bisect, heapq, random, sys, itertools\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\np2 = [1]\nfor i in range(70):\n    p2.append(p2[-1] * 2)\np = 10 ** 9 + 7\nANS = []\n\ndef mul(X, Y):\n    result = [[0 for j in range(len(Y[0]))] for i in range(len(X))]\n    for i in range(len(X)):\n        for j in range(len(Y[0])):\n            for k in range(len(Y)):\n                result[i][j] = (result[i][j] + X[i][k] * Y[k][j]) % p\n    return result\n\ndef mat_exp(A, n):\n    res = [[0 for i in range(10)] for j in range(10)]\n    for i in range(10):\n        res[i][i] = 1\n    while n:\n        if n % 2:\n            res = mul(A, res)\n        n //= 2\n        A = mul(A, A)\n    return res\nfor t in range(int(input())):\n    (n, k, m) = ints()\n    a = [int(i) for i in input().strip()]\n    A = [[0 for i in range(10)] for j in range(10)]\n    for i in range(10):\n        x = str(i * k)\n        x = [int(j) for j in x]\n        for j in x:\n            A[j][i] += 1\n    A = mat_exp(A, m)\n    r = [[0] for i in range(10)]\n    for i in a:\n        r[i][0] += 1\n    ans = mul(A, r)\n    print(sum((sum(i) for i in ans)) % p)", "import numpy as np\nnmax = 1000000007\nfor i in range(int(input())):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "import collections\nimport math\nmod = 1000000007\n\ndef multiply(a, b):\n    mul = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                mul[i][j] += a[i][k] * b[k][j]\n                mul[i][j] %= mod\n    return mul\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = map(int, input().split())\n    s = str(input())\n    matrix_A = [0] * 10\n    for x in s:\n        matrix_A[ord(x) - ord('0')] += 1\n    matrix_C = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            cur = str(j * k)\n            matrix_C[i][j] += cur.count(str(i))\n    matrix_E = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        matrix_E[i][i] = 1\n    while m != 0:\n        if m % 2 == 1:\n            matrix_E = multiply(matrix_E, matrix_C)\n            m -= 1\n        matrix_C = multiply(matrix_C, matrix_C)\n        m //= 2\n    matrix_B = [0] * 10\n    for i in range(10):\n        for j in range(10):\n            matrix_B[i] += matrix_A[j] * matrix_E[i][j]\n            matrix_B[i] %= mod\n    print(sum(matrix_B) % mod)", "import collections\nimport math\nmod = 1000000007\n\ndef multiply(a, b):\n    mul = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                mul[i][j] += a[i][k] * b[k][j]\n                mul[i][j] %= mod\n    return mul\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = map(int, input().split())\n    s = str(input())\n    matrix_A = [0] * 10\n    for x in s:\n        matrix_A[ord(x) - ord('0')] += 1\n    matrix_C = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            cur = str(j * k)\n            matrix_C[i][j] += cur.count(str(i))\n    matrix_E = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        matrix_E[i][i] = 1\n    while m != 0:\n        if m % 2 == 1:\n            matrix_E = multiply(matrix_E, matrix_C)\n            m -= 1\n        matrix_C = multiply(matrix_C, matrix_C)\n        m //= 2\n    matrix_B = [0] * 10\n    for i in range(10):\n        for j in range(10):\n            matrix_B[i] += matrix_A[j] * matrix_E[i][j]\n            matrix_B[i] %= mod\n    print(sum(matrix_B) % mod)", "import collections\nimport math\nmod = 1000000007\n\ndef multiply(a, b):\n    mul = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                mul[i][j] += a[i][k] * b[k][j]\n                mul[i][j] %= mod\n    return mul\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = map(int, input().split())\n    s = str(input())\n    matrix_A = [0] * 10\n    for x in s:\n        matrix_A[ord(x) - ord('0')] += 1\n    matrix_C = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            cur = str(j * k)\n            matrix_C[i][j] += cur.count(str(i))\n    matrix_E = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        matrix_E[i][i] = 1\n    while m != 0:\n        if m % 2 == 1:\n            matrix_E = multiply(matrix_E, matrix_C)\n            m -= 1\n        matrix_C = multiply(matrix_C, matrix_C)\n        m //= 2\n    matrix_B = [0] * 10\n    for i in range(10):\n        for j in range(10):\n            matrix_B[i] += matrix_A[j] * matrix_E[i][j]\n            matrix_B[i] %= mod\n    print(sum(matrix_B) % mod)", "import collections\nimport math\nmod = 1000000007\n\ndef multiply(a, b):\n    mul = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                mul[i][j] += a[i][k] * b[k][j]\n                mul[i][j] %= mod\n    return mul\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = map(int, input().split())\n    s = str(input())\n    matrix_A = [0] * 10\n    for x in s:\n        matrix_A[ord(x) - ord('0')] += 1\n    matrix_C = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            cur = str(j * k)\n            matrix_C[i][j] += cur.count(str(i))\n    matrix_E = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        matrix_E[i][i] = 1\n    while m != 0:\n        if m % 2 == 1:\n            matrix_E = multiply(matrix_E, matrix_C)\n            m -= 1\n        matrix_C = multiply(matrix_C, matrix_C)\n        m //= 2\n    matrix_B = [0] * 10\n    for i in range(10):\n        for j in range(10):\n            matrix_B[i] += matrix_A[j] * matrix_E[i][j]\n            matrix_B[i] %= mod\n    print(sum(matrix_B) % mod)", "import collections\nimport math\nmod = 1000000007\n\ndef multiply(a, b):\n    mul = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                mul[i][j] += a[i][k] * b[k][j]\n                mul[i][j] %= mod\n    return mul\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = map(int, input().split())\n    s = str(input())\n    matrix_A = [0] * 10\n    for x in s:\n        matrix_A[ord(x) - ord('0')] += 1\n    matrix_C = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            cur = str(j * k)\n            matrix_C[i][j] += cur.count(str(i))\n    matrix_E = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        matrix_E[i][i] = 1\n    while m != 0:\n        if m % 2 == 1:\n            matrix_E = multiply(matrix_E, matrix_C)\n            m -= 1\n        matrix_C = multiply(matrix_C, matrix_C)\n        m //= 2\n    matrix_B = [0] * 10\n    for i in range(10):\n        for j in range(10):\n            matrix_B[i] += matrix_A[j] * matrix_E[i][j]\n            matrix_B[i] %= mod\n    print(sum(matrix_B) % mod)", "def PROBLEM():\n    for _ in range(int(input())):\n        ins = list(map(int, input().split()))\n        n = ins[0]\n        k = ins[1]\n        t = ins[2]\n        m = 10 ** 9 + 7\n        init_num = input()\n        A = [None] * 10\n        for i in range(10):\n            A[i] = [0] * 10\n        for i in range(10):\n            v = str_to_vector(str(i * k))\n            for j in range(10):\n                A[j][i] = v[j]\n        Am = matpow(A, t, m)\n        init_vec = str_to_vector(init_num)\n        final_vec = [0] * 10\n        for i in range(10):\n            for j in range(10):\n                final_vec[i] += Am[i][j] * init_vec[j] % m\n        final_sum = 0\n        for i in range(10):\n            final_sum = (final_sum + final_vec[i]) % m\n        print(final_sum)\n\ndef str_to_vector(s):\n    res = [0] * 10\n    for i in range(0, len(s)):\n        idx = int(s[i])\n        res[idx] = res[idx] + 1\n    return res\n\ndef matmul(A, B, m):\n    n = len(A)\n    res = [None] * n\n    for i in range(n):\n        res[i] = [0] * n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                res[i][j] += A[i][k] * B[k][j] % m\n    return res\n\ndef identity(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = [0] * n\n        res[i][i] = 1\n    return res\n\ndef matpow(A, k, m):\n    n = len(A)\n    if k == 0:\n        return identity(n)\n    p = matpow(A, k // 2, m)\n    p = matmul(p, p, m)\n    if k % 2 == 0:\n        return p\n    else:\n        return matmul(p, A, m)\nPROBLEM()", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "import collections\nimport math\nmod = 1000000007\n\ndef multiply(a, b):\n    mul = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                mul[i][j] += a[i][k] * b[k][j]\n                mul[i][j] %= mod\n    return mul\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = map(int, input().split())\n    s = str(input())\n    matrix_A = [0] * 10\n    for x in s:\n        matrix_A[ord(x) - ord('0')] += 1\n    matrix_C = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            cur = str(j * k)\n            matrix_C[i][j] += cur.count(str(i))\n    matrix_E = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        matrix_E[i][i] = 1\n    while m != 0:\n        if m % 2 == 1:\n            matrix_E = multiply(matrix_E, matrix_C)\n            m -= 1\n        matrix_C = multiply(matrix_C, matrix_C)\n        m //= 2\n    matrix_B = [0] * 10\n    for i in range(10):\n        for j in range(10):\n            matrix_B[i] += matrix_A[j] * matrix_E[i][j]\n            matrix_B[i] %= mod\n    print(sum(matrix_B) % mod)", "import collections\nimport math\nmod = 1000000007\n\ndef multiply(a, b):\n    mul = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                mul[i][j] += a[i][k] * b[k][j]\n                mul[i][j] %= mod\n    return mul\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = map(int, input().split())\n    s = str(input())\n    matrix_A = [0] * 10\n    for x in s:\n        matrix_A[ord(x) - ord('0')] += 1\n    matrix_C = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            cur = str(j * k)\n            matrix_C[i][j] += cur.count(str(i))\n    matrix_E = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        matrix_E[i][i] = 1\n    while m != 0:\n        if m % 2 == 1:\n            matrix_E = multiply(matrix_E, matrix_C)\n            m -= 1\n        matrix_C = multiply(matrix_C, matrix_C)\n        m //= 2\n    matrix_B = [0] * 10\n    for i in range(10):\n        for j in range(10):\n            matrix_B[i] += matrix_A[j] * matrix_E[i][j]\n            matrix_B[i] %= mod\n    print(sum(matrix_B) % mod)", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "import numpy as np\nnmax = 10 ** 9 + 7\nfor _ in range(int(input())):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "def multiply(A, B, N):\n    result = [[0 for i in range(N)] for i in range(N)]\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                result[i][j] += A[i][k] * B[k][j]\n                result[i][j] %= MOD\n    return result\n\ndef power(A, N):\n    ans = [[0 for i in range(10)] for i in range(10)]\n    for i in range(10):\n        ans[i][i] = 1\n    while N:\n        if N & 1:\n            ans = multiply(ans, A, 10)\n        N >>= 1\n        A = multiply(A, A, 10)\n    return ans\n\ndef preprocess(F, K):\n    for i in range(10):\n        for j in range(10):\n            x = i * K\n            if x == 0 and x == j:\n                F[i][j] += 1\n                continue\n            while x > 0:\n                if x % 10 == j:\n                    F[i][j] += 1\n                x //= 10\nt = int(input())\nwhile t:\n    (n, k, m) = map(int, input().split(' '))\n    s = input()\n    F = [[0 for i in range(10)] for i in range(10)]\n    preprocess(F, k)\n    cnt = [0 for i in range(10)]\n    for i in s:\n        cnt[int(i)] += 1\n    (count, MOD) = (0, 10 ** 9 + 7)\n    matrix = power(F, m)\n    for i in range(10):\n        for j in range(10):\n            count += cnt[i] * matrix[i][j]\n            count %= MOD\n    print(count)\n    t -= 1", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "def DIGIMULK():\n    for _ in range(int(input())):\n        ins = list(map(int, input().split()))\n        n = ins[0]\n        k = ins[1]\n        t = ins[2]\n        m = 10 ** 9 + 7\n        init_num = input()\n        A = [None] * 10\n        for i in range(10):\n            A[i] = [0] * 10\n        for i in range(10):\n            v = str_to_vector(str(i * k))\n            for j in range(10):\n                A[j][i] = v[j]\n        Am = matpow(A, t, m)\n        init_vec = str_to_vector(init_num)\n        final_vec = [0] * 10\n        for i in range(10):\n            for j in range(10):\n                final_vec[i] += Am[i][j] * init_vec[j] % m\n        final_sum = 0\n        for i in range(10):\n            final_sum = (final_sum + final_vec[i]) % m\n        print(final_sum)\n\ndef str_to_vector(s):\n    res = [0] * 10\n    for i in range(0, len(s)):\n        idx = int(s[i])\n        res[idx] = res[idx] + 1\n    return res\n\ndef matmul(A, B, m):\n    n = len(A)\n    res = [None] * n\n    for i in range(n):\n        res[i] = [0] * n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                res[i][j] += A[i][k] * B[k][j] % m\n    return res\n\ndef identity(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = [0] * n\n        res[i][i] = 1\n    return res\n\ndef matpow(A, k, m):\n    n = len(A)\n    if k == 0:\n        return identity(n)\n    p = matpow(A, k // 2, m)\n    p = matmul(p, p, m)\n    if k % 2 == 0:\n        return p\n    else:\n        return matmul(p, A, m)\nDIGIMULK()", "import collections\nimport math\nmod = 1000000007\n\ndef multiply(d, y):\n    mul = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                mul[i][j] += d[i][k] * y[k][j]\n                mul[i][j] %= mod\n    return mul\nz = int(input())\nfor _ in range(z):\n    (n, k, m) = map(int, input().split())\n    s = str(input())\n    matrix_A = [0] * 10\n    for x in s:\n        matrix_A[ord(x) - ord('0')] += 1\n    matrix_C = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            cur = str(j * k)\n            matrix_C[i][j] += cur.count(str(i))\n    matrix_E = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        matrix_E[i][i] = 1\n    while m != 0:\n        if m % 2 == 1:\n            matrix_E = multiply(matrix_E, matrix_C)\n            m -= 1\n        matrix_C = multiply(matrix_C, matrix_C)\n        m //= 2\n    matrix_B = [0] * 10\n    for i in range(10):\n        for j in range(10):\n            matrix_B[i] += matrix_A[j] * matrix_E[i][j]\n            matrix_B[i] %= mod\n    print(sum(matrix_B) % mod)", "import collections\nimport math\nmod = 1000000007\n\ndef multiply(a, b):\n    mul = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                mul[i][j] += a[i][k] * b[k][j]\n                mul[i][j] %= mod\n    return mul\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = map(int, input().split())\n    s = str(input())\n    matrix_A = [0] * 10\n    for x in s:\n        matrix_A[ord(x) - ord('0')] += 1\n    matrix_C = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        for j in range(10):\n            cur = str(j * k)\n            matrix_C[i][j] += cur.count(str(i))\n    matrix_E = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        matrix_E[i][i] = 1\n    while m != 0:\n        if m % 2 == 1:\n            matrix_E = multiply(matrix_E, matrix_C)\n            m -= 1\n        matrix_C = multiply(matrix_C, matrix_C)\n        m //= 2\n    matrix_B = [0] * 10\n    for i in range(10):\n        for j in range(10):\n            matrix_B[i] += matrix_A[j] * matrix_E[i][j]\n            matrix_B[i] %= mod\n    print(sum(matrix_B) % mod)", "def compute(st, k, m):\n    di = {i: [str(i * k).count(str(j)) for j in range(10)] for i in range(10)}\n    cach = [[int(i == j) for i in range(10)] for j in range(10)]\n    temp = [[0 for i in range(10)] for j in range(10)]\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                temp[i][k] = (temp[i][k] + cach[i][j] * di[j][k]) % (10 ** 9 + 7)\n    cach = temp[:][:]\n    s = [0 for i in range(10)]\n    for e in st:\n        s[int(e)] += 1\n    while m > 0:\n        if m % 2 == 1:\n            temps = [0 for i in range(10)]\n            for i in range(10):\n                for j in range(10):\n                    temps[j] = (temps[j] + s[i] * cach[i][j]) % (10 ** 9 + 7)\n            s = temps[:]\n        temp = [[0 for i in range(10)] for j in range(10)]\n        for i in range(10):\n            for j in range(10):\n                for k in range(10):\n                    temp[i][k] = (temp[i][k] + cach[i][j] * cach[j][k]) % (10 ** 9 + 7)\n        cach = temp[:][:]\n        m = m // 2\n    return sum(s) % (10 ** 9 + 7)\nt = int(input())\nfor i in range(t):\n    inp1 = input()\n    inp1 = inp1.split(' ')\n    inp1 = [int(inp1[i]) for i in range(len(inp1))]\n    inp2 = input()\n    print(compute(inp2, inp1[1], inp1[2]))", "def DIGIMULK():\n    for _ in range(int(input())):\n        ins = list(map(int, input().split()))\n        n = ins[0]\n        k = ins[1]\n        t = ins[2]\n        m = 10 ** 9 + 7\n        init_num = input()\n        A = [None] * 10\n        for i in range(10):\n            A[i] = [0] * 10\n        for i in range(10):\n            v = str_to_vector(str(i * k))\n            for j in range(10):\n                A[j][i] = v[j]\n        Am = matpow(A, t, m)\n        init_vec = str_to_vector(init_num)\n        final_vec = [0] * 10\n        for i in range(10):\n            for j in range(10):\n                final_vec[i] += Am[i][j] * init_vec[j] % m\n        final_sum = 0\n        for i in range(10):\n            final_sum = (final_sum + final_vec[i]) % m\n        print(final_sum)\n\ndef str_to_vector(s):\n    res = [0] * 10\n    for i in range(0, len(s)):\n        idx = int(s[i])\n        res[idx] = res[idx] + 1\n    return res\n\ndef matmul(A, B, m):\n    n = len(A)\n    res = [None] * n\n    for i in range(n):\n        res[i] = [0] * n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                res[i][j] += A[i][k] * B[k][j] % m\n    return res\n\ndef identity(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = [0] * n\n        res[i][i] = 1\n    return res\n\ndef matpow(A, k, m):\n    n = len(A)\n    if k == 0:\n        return identity(n)\n    p = matpow(A, k // 2, m)\n    p = matmul(p, p, m)\n    if k % 2 == 0:\n        return p\n    else:\n        return matmul(p, A, m)\nDIGIMULK()", "MOD = 10 ** 9 + 7\n\nclass ModuloMatrix:\n\n    def __init__(self, N=10, ident=False, K=None):\n        self.N = N\n        self.values = [[0] * N for _ in range(N)]\n        if ident:\n            for i in range(N):\n                self.values[i][i] = 1\n        elif K is not None:\n            for j in range(N):\n                SK = str(j * K)\n                for i in range(N):\n                    self.values[i][j] += SK.count(str(i))\n\n    def __mul__(self, M):\n        R = ModuloMatrix(self.N)\n        for i in range(self.N):\n            for j in range(self.N):\n                for k in range(self.N):\n                    R.values[i][j] = (R.values[i][j] + self.values[i][k] * M.values[k][j]) % MOD\n        return R\n\n    def __pow__(self, P):\n        R = ModuloMatrix(self.N, ident=True)\n        while P:\n            if P % 2:\n                R = R * self\n            self = self * self\n            P >>= 1\n        return R\n\n    def dot(self, V):\n        R = [[0] for _ in range(self.N)]\n        for i in range(self.N):\n            j = 0\n            for k in range(self.N):\n                R[i][j] = (R[i][j] + self.values[i][k] * V[k][j]) % MOD\n        return R\n\n    def __str__(self):\n        txt = ''\n        for i in range(self.N):\n            txt += i and '\\n' or ''\n            for j in range(self.N):\n                txt += (j and ' ' or '') + str(self.values[i][j])\n        return txt\n\ndef naive(N, K, M, S):\n    E = [[0] for _ in range(10)]\n    for s in S:\n        E[int(s)][0] += 1\n    mat = ModuloMatrix(K=K)\n    mat = mat ** M\n    E = mat.dot(E)\n    return sum((e[0] for e in E)) % MOD\nT = int(input().strip())\nfor _ in range(T):\n    (N, K, M) = [int(x) for x in input().strip().split()[:3]]\n    S = input().strip()[:N]\n    print(naive(N, K, M, S))", "import numpy as np\nnmax = 1000000007\nt = int(input())\nfor i in range(t):\n    mat = np.zeros((10, 10))\n    mat = mat.astype(int)\n    (n, k, m) = map(int, input().split())\n    if m == 0:\n        print(n)\n        input()\n        continue\n    for j in range(10):\n        for v in map(int, list(str(j * k))):\n            mat[v, j] += 1\n    mats = [mat]\n    for j in range(int(np.log2(m))):\n        mat = mat @ mat % nmax\n        mats.append(mat)\n    fmat = np.identity(10)\n    fmat = fmat.astype(int)\n    j = 0\n    while m > 0:\n        if m % 2 == 1:\n            fmat = fmat @ mats[j] % nmax\n        m = m // 2\n        j += 1\n    vec = np.zeros((10, 1))\n    vec = vec.astype(int)\n    for v in map(int, list(input())):\n        vec[v, 0] += 1\n    outvec = fmat @ vec % nmax\n    print(sum(sum(outvec) % nmax))", "from typing import List\nMODULO = 10 ** 9 + 7\n\ndef multiply_matmat(A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n    return [[sum((a * b % MODULO for (a, b) in zip(A[r], [row[c] for row in B]))) % MODULO for c in range(10)] for r in range(10)]\n\ndef multiply_matvec(A: List[List[int]], v: List[int]) -> List[int]:\n    return [sum((a * b % MODULO for (a, b) in zip(A[r], v))) % MODULO for r in range(10)]\n\ndef power_mat(A: List[List[int]], exp: int) -> List[List[int]]:\n    if exp == 1:\n        return A\n    elif exp % 2 == 0:\n        return power_mat(multiply_matmat(A, A), exp // 2)\n    else:\n        return multiply_matmat(A, power_mat(multiply_matmat(A, A), exp // 2))\n\ndef solve(t):\n    (N, K, M) = map(int, input().split())\n    S = input().strip()\n    P = [S.count(str(i)) for i in range(10)]\n    A = [[0 for j in range(10)] for i in range(10)]\n    for p in range(10):\n        new_balls = '%d' % (p * K)\n        for new_p in map(int, new_balls):\n            A[new_p][p] += 1\n    if M > 0:\n        P = multiply_matvec(power_mat(A, M), P)\n    print(sum(P) % MODULO)\nT = int(input())\nfor t in range(T):\n    solve(t + 1)", "from sys import stdin\ninput = stdin.readline\nMODULO = 10 ** 9 + 7\n\ndef matvectormultiply(a, b, m):\n    c = [0] * m\n    for i in range(m):\n        for j in range(m):\n            c[i] = (c[i] + a[i][j] * b[j]) % MODULO\n    return c\n\ndef matmultiply(a, b, m):\n    c = [[0] * m for i in range(m)]\n    for i in range(m):\n        for j in range(m):\n            for k in range(m):\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % MODULO\n    return c\n\ndef matadd(a, b, m):\n    c = [[0] * m for i in range(m)]\n    for i in range(m):\n        for j in range(m):\n            c[i][j] = (a[i][j] + b[i][j]) % MODULO\n    return c\n\ndef matpower(a, n, m):\n    answer = [[1 if i == j else 0 for i in range(m)] for j in range(m)]\n    while n > 0:\n        if n % 2 == 1:\n            answer = matmultiply(answer, a, m)\n        a = matmultiply(a, a, m)\n        n = n // 2\n    return answer\n\ndef solve(N, K, M, S):\n    balls = [0] * 10\n    for s in S:\n        balls[int(s)] += 1\n    black = [[0] * 10 for i in range(10)]\n    for i in range(10):\n        for s in str(i * K):\n            black[int(s)][i] += 1\n    black = matpower(black, M, 10)\n    return sum(matvectormultiply(black, balls, 10)) % MODULO\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    (N, K, M) = [int(x) for x in input().strip().split()]\n    S = input().strip()\n    print(solve(N, K, M, S))", "p = 10 ** 9 + 7\n\ndef get_s_v(s):\n    l = [0 for i in range(10)]\n    for e in s:\n        l[int(e)] += 1\n    return l\n\ndef get_m(k):\n    l = [[0 for i in range(10)] for j in range(10)]\n    for i in range(10):\n        v = get_s_v(str(i * k))\n        for j in range(10):\n            l[j][i] = v[j]\n    return l\n\ndef get_p(m):\n    l = list()\n    while m > 0:\n        l.append(m % 2)\n        m = m // 2\n    return l\n\ndef sq(X):\n    Y = list()\n    for i in range(10):\n        Y.append([])\n        for j in range(10):\n            r = 0\n            for k in range(10):\n                r += X[i][k] * X[k][j] % p\n            Y[i].append(r)\n    return Y\n\ndef get_p_of_m(A, n):\n    l = [A]\n    i = 0\n    B = list(A)\n    while i < n:\n        B = sq(B)\n        l.append(B)\n        i += 1\n    return l\n\ndef mul(A, v):\n    w = list()\n    for i in range(len(v)):\n        r = 0\n        for j in range(len(v)):\n            r += A[i][j] * v[j] % p\n        w.append(r)\n    return w\n\ndef get_res(pa, po, q):\n    for i in range(len(pa)):\n        if pa[i] == 1:\n            q = mul(po[i], q)\n    return q\nfor i in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    s = input()\n    q_0 = get_s_v(s)\n    A = get_m(k)\n    parts = get_p(m)\n    powers = get_p_of_m(A, len(parts))\n    print(sum(get_res(parts, powers, q_0)) % p)", "Mod = 10 ** 9 + 7\nt = int(input())\nfor tt in range(t):\n    K100X = [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]\n    a = list(map(int, input().split()))\n    n = a[0]\n    k = a[1]\n    m = a[2]\n    M = str(m)\n    l = list(map(int, input()))\n    Lcalu = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    for firstput_i in range(n):\n        Lcalu[l[firstput_i]] += 1\n    for kmaker_i in range(10):\n        for kmaker_j in list(map(int, str(kmaker_i * k))):\n            K100X[0][kmaker_j][kmaker_i] += 1\n    for kmaker_h in range(1, 10):\n        if m < 10 ** kmaker_h:\n            break\n        for kmaker_i in range(10):\n            Lkmaker = [0] * 10\n            Lkmaker[kmaker_i] = 1\n            Lkmaker = tuple(Lkmaker)\n            for kmaker_j in range(10):\n                lkmaker = [0] * 10\n                for kmaker_k in range(10):\n                    for kmaker_l in range(10):\n                        lkmaker[kmaker_k] += K100X[kmaker_h - 1][kmaker_k][kmaker_l] * Lkmaker[kmaker_l]\n                Lkmaker = tuple(lkmaker)\n            for kmaker_final in range(10):\n                K100X[kmaker_h][kmaker_final][kmaker_i] += Lkmaker[kmaker_final] % Mod\n    for calu_i in range(len(M)):\n        LLcalu = tuple(Lcalu)\n        for calu_i5 in range(int(M[(calu_i + 1) * -1])):\n            lcalu = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n            for calu_j in range(10):\n                for calu_k in range(10):\n                    lcalu[calu_j] += K100X[calu_i][calu_j][calu_k] * LLcalu[calu_k]\n            LLcalu = tuple(lcalu)\n        for y_i in range(10):\n            Lcalu[y_i] = LLcalu[y_i] % Mod\n    FINALAns = 0\n    for z_i in range(10):\n        FINALAns += Lcalu[z_i]\n    print(FINALAns % Mod)", "import sys\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\n\ndef DFS(num_steps_left, ball_counts):\n    if num_steps_left == 0:\n        return ball_counts\n    for i in range(len(bin(num_steps_left))):\n        if 1 << i & num_steps_left:\n            step_size = 1 << i\n            new_ball_counts = [0 for j in range(10)]\n            for (ball_val, cnt) in enumerate(ball_counts):\n                new_ball_counts = [x + cnt * y for (x, y) in zip(new_ball_counts, dp[step_size][ball_val])]\n            return DFS(num_steps_left - step_size, new_ball_counts)\nnum_test_cases = int(input())\nfor test_case_ittr in range(num_test_cases):\n    (num_balls, multiplier, num_steps) = [int(x) for x in input().split()]\n    balls = [int(x) for x in input().strip()]\n    dp = dict()\n    step_size = 1\n    dp[step_size] = dict()\n    for ball_val in range(10):\n        dp[step_size][ball_val] = [0 for i in range(10)]\n        for digit in str(multiplier * ball_val):\n            dp[step_size][ball_val][int(digit)] += 1\n    step_size *= 2\n    while step_size <= num_steps:\n        dp[step_size] = dict()\n        half_step = step_size // 2\n        for ball_val in range(10):\n            arr = [0 for i in range(10)]\n            for (val, cnt) in enumerate(dp[half_step][ball_val]):\n                delta = [cnt * y for y in dp[half_step][val]]\n                arr = [(x + y) % mod for (x, y) in zip(arr, delta)]\n            dp[step_size][ball_val] = arr\n        step_size *= 2\n    ball_counts = [0 for i in range(10)]\n    for x in balls:\n        ball_counts[x] += 1\n    ans = sum(DFS(num_steps, ball_counts)) % mod\n    print(ans)", "import sys\ninput = sys.stdin.readline\nMOD = 10 ** 9 + 7\n\ndef identity(n):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        matrix[i][i] = 1\n    return matrix\n\ndef multiply(mat1, mat2):\n    (r1, r2) = (len(mat1), len(mat2))\n    (c1, c2) = (len(mat1[0]), len(mat2[0]))\n    result = [[0] * c2 for _ in range(r1)]\n    for i in range(r1):\n        for j in range(c2):\n            for k in range(r2):\n                result[i][j] = (result[i][j] + mat1[i][k] * mat2[k][j]) % MOD\n    return result\n\ndef power(mat, n):\n    res = identity(len(mat))\n    while n:\n        if n & 1:\n            res = multiply(res, mat)\n        mat = multiply(mat, mat)\n        n = n >> 1\n    return res\nfor _ in range(int(input().strip())):\n    (N, K, M) = map(int, input().strip().split())\n    S = input().strip()\n    mat = [[0] * 10 for _ in range(10)]\n    for i in range(10):\n        action = str(i * K)\n        for s in action:\n            mat[int(s)][i] += 1\n    mat = power(mat, M)\n    vec = [0] * 10\n    for s in S:\n        vec[int(s)] += 1\n    ans = 0\n    for i in range(10):\n        for j in range(10):\n            ans = (ans + mat[i][j] * vec[j]) % MOD\n    print(ans)", "M = 10 ** 9 + 7\n\ndef initNum(inp):\n    ret = [[0 for i in range(10)]]\n    for i in inp:\n        ret[0][int(i)] += 1\n    return ret\n\ndef cntNum(num):\n    cnt = [0 for i in range(10)]\n    if num == 0:\n        cnt[0] = 1\n    while num > 0:\n        d = num % 10\n        cnt[d] += 1\n        num = int(num / 10)\n    return cnt\n\ndef prepareMultMat(k):\n    mat = [[0 for i in range(10)] for j in range(10)]\n    for i in range(10):\n        num = i * k\n        nxtNum = cntNum(num)\n        for j in range(10):\n            mat[i][j] = (mat[i][j] + nxtNum[j]) % M\n    return mat\n\ndef matMul(a, b, n, m, c):\n    res = [[0 for i in range(c)] for j in range(n)]\n    for i in range(n):\n        for j in range(c):\n            for k in range(m):\n                res[i][j] = (res[i][j] + a[i][k] * b[k][j] % M) % M\n    return res\n\ndef powMat(a, p):\n    if p == 1:\n        return a\n    if p == 2:\n        return matMul(a, a, 10, 10, 10)\n    at = powMat(a, int(p / 2))\n    if p % 2 == 0:\n        return matMul(at, at, 10, 10, 10)\n    else:\n        return matMul(matMul(at, at, 10, 10, 10), a, 10, 10, 10)\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = [int(x) for x in input().split()]\n    nums = input()\n    ini = initNum(nums)\n    if m == 0:\n        print(sum(ini[0]))\n        continue\n    mul = powMat(prepareMultMat(k), m)\n    ansAr = matMul(ini, mul, 1, 10, 10)\n    ans = sum(ansAr[0]) % M\n    print(ans)"]