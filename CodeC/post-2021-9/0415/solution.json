["(n, c) = map(int, input().split())\nd = dict()\nchecker = [False for i in range(n)]\nfor i in range(n - 1):\n    t = tuple(map(int, input().split()))\n    if not checker[t[0] - 1]:\n        checker[t[0] - 1] = True\n        d[t[0]] = list()\n    d[t[0]].append(t[1])\n    if not checker[t[1] - 1]:\n        checker[t[1] - 1] = True\n        d[t[1]] = list()\n    d[t[1]].append(t[0])\nif c == 1:\n    if n == 1:\n        print(1)\n    else:\n        print(0)\nelse:\n    val = 0\n    for i in range(n):\n        val = max(val, len(d[i + 1]))\n    if val + 1 > c:\n        print(0)\n    else:\n        re = c\n        q = 1\n        checker[0] = False\n        new_c = list()\n        for e in d[1]:\n            new_c.append(e)\n            checker[e - 1] = False\n            q += 1\n        for i in range(len(d[1])):\n            re = re * (c - 1 - i) % (10 ** 9 + 7)\n        while q < n:\n            new_new_c = list()\n            for e in new_c:\n                for ee in d[e]:\n                    if checker[ee - 1]:\n                        new_new_c.append(ee)\n                        checker[ee - 1] = False\n                        q += 1\n                for i in range(len(d[e]) - 1):\n                    re = re * (c - 2 - i) % (10 ** 9 + 7)\n            new_c = new_new_c.copy()\n        print(re)", "(n, c) = map(int, input().split())\nd = dict()\nchecker = [False for i in range(n)]\nfor i in range(n - 1):\n    t = tuple(map(int, input().split()))\n    if not checker[t[0] - 1]:\n        checker[t[0] - 1] = True\n        d[t[0]] = list()\n    d[t[0]].append(t[1])\n    if not checker[t[1] - 1]:\n        checker[t[1] - 1] = True\n        d[t[1]] = list()\n    d[t[1]].append(t[0])\nif c == 1:\n    if n == 1:\n        print(1)\n    else:\n        print(0)\nelse:\n    val = 0\n    for i in range(n):\n        val = max(val, len(d[i + 1]))\n    if val + 1 > c:\n        print(0)\n    else:\n        re = c\n        q = 1\n        checker[0] = False\n        new_c = list()\n        for e in d[1]:\n            new_c.append(e)\n            checker[e - 1] = False\n            q += 1\n        for i in range(len(d[1])):\n            re = re * (c - 1 - i) % (10 ** 9 + 7)\n        while q < n:\n            new_new_c = list()\n            for e in new_c:\n                for ee in d[e]:\n                    if checker[ee - 1]:\n                        new_new_c.append(ee)\n                        checker[ee - 1] = False\n                        q += 1\n                for i in range(len(d[e]) - 1):\n                    re = re * (c - 2 - i) % (10 ** 9 + 7)\n            new_c = new_new_c.copy()\n        print(re)", "from typing import List\nTRUNCATOR = 10 ** 9 + 7\n\ndef main(nodes_num: int, colors_num: int, edges: List[List[int]]) -> int:\n    if nodes_num == 1:\n        return colors_num\n    adjacency_lists: List[List[int]] = [[] for _ in range(nodes_num)]\n    for (u, v) in edges:\n        adjacency_lists[u - 1].append(v - 1)\n        adjacency_lists[v - 1].append(u - 1)\n    required_colors_num = 1 + len(max(adjacency_lists, key=lambda x: len(x)))\n    if colors_num < required_colors_num:\n        return 0\n    dfs_stack = []\n    node_is_visited = [False] * nodes_num\n    res = 1\n    for node_idx in range(nodes_num):\n        if len(adjacency_lists[node_idx]) == 1:\n            dfs_stack.append(adjacency_lists[node_idx][0])\n            node_is_visited[dfs_stack[0]] = True\n            break\n    while dfs_stack:\n        node_idx = dfs_stack.pop()\n        used_nodes_num = 1 if node_is_visited[node_idx] and res != 1 else 0\n        for adjacent_idx in adjacency_lists[node_idx]:\n            if node_is_visited[adjacent_idx]:\n                used_nodes_num += 1\n            elif len(adjacency_lists[adjacent_idx]) > 1:\n                dfs_stack.append(adjacent_idx)\n                node_is_visited[adjacent_idx] = True\n        numerator = colors_num - used_nodes_num\n        denominator = colors_num - len(adjacency_lists[node_idx]) - 1\n        for multiplier in range(denominator + 1, numerator + 1):\n            res = res * multiplier % TRUNCATOR\n    return res\n(nodes_n, colors_n) = [int(num) for num in input().split()]\nedges = [[int(num) for num in input().split()] for _ in range(nodes_n - 1)]\nprint(main(nodes_n, colors_n, edges))", "import sys\nM = 10 ** 9 + 7\ni = (map(int, s.split()) for s in sys.stdin)\n(n, c) = next(i)\ng = [None] + [[] for _ in range(n)]\nV = [None, True] + [False] * (n - 1)\nfor (u, v) in i:\n    g[u].append(v)\n    g[v].append(u)\nfact = [1] * c\nfor i in range(1, c):\n    fact[i] = fact[i - 1] * i % M\nr = c\nst = [1]\nwhile st:\n    u = st.pop()\n    f = u > 1\n    k = c - 1 - f\n    m = len(g[u]) - f\n    if m > k:\n        r = 0\n        break\n    r = r * fact[k] * pow(fact[k - m], M - 2, M) % M\n    for v in g[u]:\n        if not V[v]:\n            V[v] = True\n            st.append(v)\nprint(r)", "import sys\nsys.setrecursionlimit(10 ** 6)\n(n, c) = map(int, input().split())\ntree = {}\nchild = [0] * (n + 1)\nparent = {}\nval = [0] * (n + 1)\nmod = 10 ** 9 + 7\nfor i in range(1, n + 1):\n    child[i] = 0\n    tree[i] = []\n    parent[i] = 0\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    tree[a] += [b]\n    tree[b] += [a]\n\ndef dfs(root, par):\n    if val[root]:\n        return\n    x = 0\n    if par == -1:\n        val[root] = c\n    else:\n        x = child[par]\n        if child[parent[par]]:\n            val[root] = (c - x - 2) % mod\n        else:\n            val[root] = (c - x - 1) % mod\n        child[par] += 1\n    for node in tree[root]:\n        if node != par:\n            parent[node] = root\n            dfs(node, root)\ndfs(1, -1)\nans = 1\nfor i in range(1, len(val)):\n    ans = ans * val[i] % mod\nprint(ans % mod)", "import sys\nsys.setrecursionlimit(10000000)\nfrom collections import defaultdict as dd\nMOD = 10 ** 9 + 7\n\ndef count(graph, c, d, cur, childnum, parent=None):\n    result = c - min(d, 2) - childnum\n    after_parent = False\n    for (i, child) in enumerate(graph[cur]):\n        if child == parent:\n            after_parent = True\n            continue\n        result *= count(graph, c, d + 1, child, i - after_parent, cur)\n        result %= MOD\n    return result % MOD\n\ndef main():\n    (n, c) = map(int, input().split())\n    graph = dd(list)\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    degrees = dd(int)\n    for i in range(1, n + 1):\n        degrees[len(graph[i])] += 1\n    if n == 1:\n        print(c)\n        return\n    result = c * (c - 1)\n    for (d, cnt) in degrees.items():\n        for x in range(2, d + 1):\n            result *= pow(c - x, cnt, MOD)\n            result %= MOD\n    print(result)\nmain()", "import sys\nsys.setrecursionlimit(10000000)\nfrom collections import defaultdict as dd\nMOD = 10 ** 9 + 7\n\ndef count(graph, c, d, cur, childnum, parent=None):\n    result = c - min(d, 2) - childnum\n    after_parent = False\n    for (i, child) in enumerate(graph[cur]):\n        if child == parent:\n            after_parent = True\n            continue\n        result *= count(graph, c, d + 1, child, i - after_parent, cur)\n        result %= MOD\n    return result % MOD\n\ndef main():\n    (n, c) = map(int, input().split())\n    graph = dd(list)\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    print(count(graph, c, 0, 1, 0, None))\nmain()", "(n, c) = map(int, input().split())\nl = [int(0) for x in range(n)]\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    l[u - 1] = l[u - 1] + int(1)\nl.sort()\nl.reverse()\nz = l[0]\nv = l[1]\nl.remove(z)\nd = min(l)\nn = l.index(d)\nl = l[:n]\nl2 = [1]\nmul = 1\nfor i in range(v):\n    mul = mul * (c - 2 - i)\n    l2.append(mul)\nmax = 1\nfor k in range(z + 1):\n    max = max * (c - k) % (10 ** 9 + 7)\nfor j in l:\n    max = max * l2[j] % (10 ** 9 + 7)\nprint(max % (10 ** 9 + 7))", "import collections as col\n(n, c) = map(int, input().split())\nl = [int(0) for x in range(n)]\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    l[u - 1] = l[u - 1] + int(1)\nl.sort()\nl.reverse()\nz = l[0]\nv = l[1]\nl.remove(z)\nd = min(l)\nn = l.index(d)\nl = l[:n]\nl2 = col.deque([1])\nmul = 1\nfor i in range(v):\n    mul = mul * (c - 2 - i)\n    l2.append(mul)\nmax = 1\nfor k in range(z + 1):\n    max = max * (c - k) % (10 ** 9 + 7)\nfor j in l:\n    max = max * l2[j] % (10 ** 9 + 7)\nprint(max % (10 ** 9 + 7))", "mod = 10 ** 9 + 7\n(n, c) = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\nans = 1\nvis = [0] * (n + 1)\nqueue = [(1, 0)]\nwhile queue:\n    (node, nearby) = queue.pop()\n    ans = ans * (c - nearby) % mod\n    (vis[node], nearby) = (1, 1)\n    for i in graph[node]:\n        if not vis[i]:\n            queue.append((i, nearby))\n        nearby += 1\nprint(ans)", "from collections import defaultdict\nmod = 1000000007\n(n, c) = map(int, input().split())\ndic = defaultdict(int)\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    dic[u] += 1\nans = c\nseclayer = True\nfor el in dic:\n    if seclayer:\n        k = c - 1\n        for i in range(dic[el]):\n            ans = ans * k % mod\n            k -= 1\n        seclayer = False\n    else:\n        k = c - 2\n        for i in range(dic[el]):\n            ans = ans * k % mod\n            k -= 1\nans %= mod\nprint(ans)", "def build_graph(connections):\n    graph = {}\n    for (n1, n2) in connections:\n        if n1 in graph:\n            graph[n1].add(n2)\n        else:\n            graph[n1] = set([n2])\n        if n2 in graph:\n            graph[n2].add(n1)\n        else:\n            graph[n2] = set([n1])\n    for k in graph:\n        graph[k] = list(graph[k])\n    return graph\n\ndef f(connections, c):\n    graph = build_graph(connections)\n    diffs = {}\n    for k in graph:\n        diffs[k] = 0\n    mod = 10 ** 9 + 7\n    visited = set()\n    frontier = []\n    root = list(graph.keys())[0]\n    res = c\n    if len(graph[root]) == 0:\n        return res\n    visited.add(root)\n    frontier_block = graph[root]\n    frontier += frontier_block\n    for i in range(len(frontier_block)):\n        diffs[frontier_block[i]] = 1 + len(frontier_block) - 1 - i\n    k = frontier.pop()\n    visited.add(k)\n    if c == 1:\n        return 0\n    res *= c - 1\n    if len(graph[root]) == 1 and len(graph[k]) == 1:\n        return res\n    frontier_block = list(set(graph[k]) - visited)\n    frontier += frontier_block\n    for i in range(len(frontier_block)):\n        diffs[frontier_block[i]] = 2 + len(frontier_block) - 1 - i\n    while len(frontier) > 0:\n        k = frontier.pop()\n        visited.add(k)\n        if c <= diffs[k]:\n            return 0\n        res = res * (c - diffs[k]) % mod\n        frontier_block = list(set(graph[k]) - visited)\n        frontier += frontier_block\n        for i in range(len(frontier_block)):\n            diffs[frontier_block[i]] = 2 + len(frontier_block) - 1 - i\n    return res\n(n, c) = [int(el) for el in input().split(' ')]\nconnections = []\nfor i in range(n - 1):\n    (n1, n2) = [int(el) for el in input().split(' ')]\n    connections.append((n1, n2))\nprint(f(connections, c))", "from collections import defaultdict\nmod = 10 ** 9 + 7\n(n, c) = map(int, input().split())\ndic = defaultdict(int)\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    dic[u] += 1\nans = c\nseclayer = True\nfor el in dic:\n    if seclayer:\n        k = c - 1\n        for i in range(dic[el]):\n            ans = ans * k % mod\n            k -= 1\n        seclayer = False\n    else:\n        k = c - 2\n        for i in range(dic[el]):\n            ans = ans * k % mod\n            k -= 1\nans %= mod\nprint(ans)", "from collections import defaultdict\n\ndef solve(t):\n    (n, c) = map(int, input().split())\n    d = defaultdict(int)\n    mod = 1000000007\n    for _ in range(n - 1):\n        (x, y) = map(int, input().split())\n        d[x] += 1\n    ans = c\n    county = 1\n    for ele in d:\n        if county == 1:\n            k = c - 1\n            for _ in range(d[ele]):\n                ans *= k\n                ans %= mod\n                k -= 1\n            county += 1\n        else:\n            k = c - 2\n            for _ in range(d[ele]):\n                ans *= k\n                ans %= mod\n                k -= 1\n    return ans\nt = 1\nprint(solve(t))", "from collections import defaultdict\n\ndef solve(t):\n    (n, c) = map(int, input().split())\n    d = defaultdict(int)\n    mod = 1000000007\n    for _ in range(n - 1):\n        (x, y) = map(int, input().split())\n        d[x] += 1\n    ans = c\n    county = 1\n    for ele in d:\n        if county == 1:\n            k = c - 1\n            for _ in range(d[ele]):\n                ans *= k\n                ans %= mod\n                k -= 1\n            county += 1\n        else:\n            k = c - 2\n            for _ in range(d[ele]):\n                ans *= k\n                ans %= mod\n                k -= 1\n    return ans\nt = 1\nprint(solve(t))", "from collections import defaultdict\n\ndef solve(t):\n    (n, c) = map(int, input().split())\n    d = defaultdict(lambda : 0)\n    mod = 1000000007\n    for _ in range(n - 1):\n        (x, y) = map(int, input().split())\n        d[x] += 1\n    ans = c\n    county = 1\n    for ele in d:\n        if county == 1:\n            k = c - 1\n            for _ in range(d[ele]):\n                ans *= k\n                ans %= mod\n                k -= 1\n            county += 1\n        else:\n            k = c - 2\n            for _ in range(d[ele]):\n                ans *= k\n                ans %= mod\n                k -= 1\n    return ans\nt = 1\nprint(solve(t))", "from bisect import bisect_left\nfrom bisect import bisect_right\nfrom getopt import getopt\nfrom re import sub\nimport re\nfrom typing import DefaultDict\nimport math\nfrom collections import defaultdict\nfrom math import sqrt\nimport collections\nfrom sys import maxsize\nfrom itertools import combinations_with_replacement\nimport sys\nimport copy\nimport heapq\nfrom collections import deque\n\ndef sieve_erasthones(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    return prime\n\ndef calculate(p, q):\n    mod = 998244353\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n\ndef count_factors(n):\n    i = 1\n    c = 0\n    ans = []\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n // i == i:\n                c += 1\n                ans.append(n // i)\n            else:\n                c += 2\n                ans.append(i)\n                ans.append(n // i)\n        i += 1\n    return ans\n\ndef ncr_modulo(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef isprime(n):\n    prime_flag = 0\n    if n > 1:\n        for i in range(2, int(sqrt(n)) + 1):\n            if n % i == 0:\n                prime_flag = 1\n                break\n        if prime_flag == 0:\n            return True\n        else:\n            return False\n    else:\n        return True\n\ndef smallestDivisor(n):\n    if n % 2 == 0:\n        return 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return i\n        i += 2\n    return n\n\ndef dict_ele_count(l):\n    d = defaultdict(lambda : 0)\n    for ele in l:\n        d[ele] += 1\n    return d\n\ndef max_in_dict(d):\n    maxi = 0\n    for ele in d:\n        if d[ele] > maxi:\n            maxi = d[ele]\n    return maxi\n\ndef element_count(s):\n    l = []\n    k = s[0]\n    c = 0\n    for ele in s:\n        if ele == k:\n            c += 1\n        else:\n            l.append([k, c])\n            k = ele\n            c = 1\n    l.append([k, c])\n    return l\n\ndef modular_exponentiation(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 != 0:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef number_of_primefactor(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\ndef twosum(a, n, x):\n    rem = []\n    for i in range(x):\n        rem.append(0)\n    for i in range(n):\n        if a[i] < x:\n            rem[a[i] % x] += 1\n    for i in range(1, x // 2):\n        if rem[i] > 0 and rem[x - i] > 0:\n            return True\n    if i >= x // 2:\n        if x % 2 == 0:\n            if rem[x // 2] > 1:\n                return True\n            else:\n                return False\n        elif rem[x // 2] > 0 and rem[x - x // 2] > 0:\n            return True\n        else:\n            return False\n\ndef divSum(num):\n    result = 0\n    i = 2\n    while i <= math.sqrt(num):\n        if num % i == 0:\n            if i == num / i:\n                result = result + i\n            else:\n                result = result + (i + num / i)\n        i = i + 1\n    return result + 1 + num\n\ndef subsequence(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0\n    i = 0\n    while j < m and i < n:\n        if str1[j] == str2[i]:\n            j = j + 1\n        i = i + 1\n    return j == m\n\ndef primeFactors(n):\n    d = defaultdict(lambda : 0)\n    while n % 2 == 0:\n        d[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[int(i)] += 1\n            n = n / i\n    if n > 2:\n        d[int(n)] += 1\n    return d\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    return inv * a % m\n\ndef count(n):\n    ans = 0\n    while n:\n        ans += n % 10\n        n //= 10\n    return ans\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\ndef check(n):\n    c = 0\n    while n % 2 == 0:\n        n //= 2\n        c += 1\n    return c\n\ndef modInverse(b, m):\n    return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    return inv * a % m\n\ndef lisToStr(s):\n    str1 = ''\n    for ele in s:\n        str1 += ele\n    return str1\n\ndef listy(l):\n    ans = []\n    for i in range(len(l)):\n        ans.append(heapq.heappop(l))\n    return ans\n\ndef getOdd(n):\n    for i in range(1, 33, 2):\n        if 2 ** i > n:\n            return 2 ** (i - 2)\n\ndef pali(s, i, j):\n    while i <= j:\n        if s[i] == s[j]:\n            i += 1\n            j -= 1\n        else:\n            return False\n    return True\n\ndef solve(t):\n    (n, c) = map(int, input().split())\n    d = defaultdict(lambda : 0)\n    mod = 1000000007\n    for _ in range(n - 1):\n        (x, y) = map(int, input().split())\n        d[x] += 1\n    ans = c\n    county = 1\n    for ele in d:\n        if county == 1:\n            k = c - 1\n            for _ in range(d[ele]):\n                ans *= k\n                ans %= mod\n                k -= 1\n            county += 1\n        else:\n            k = c - 2\n            for _ in range(d[ele]):\n                ans *= k\n                ans %= mod\n                k -= 1\n    return ans\nt = 1\nprint(solve(t))", "import collections, math, bisect, sys\nfrom collections import OrderedDict, Counter, defaultdict\nfrom sys import stdin, stdout\n\ndef get_line():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef in1():\n    return int(stdin.readline())\n\ndef display_arr(arr):\n    stdout.write(' '.join(map(str, arr)) + '\\n')\n\ndef display_num(num):\n    stdout.write(str(num) + '\\n')\n\ndef factorial(n):\n    return n * factorial(n - 1) if n > 1 else 1\n\ndef fact(n):\n    n = n - 1\n    return n * (n + 1) // 2\n\ndef lcm(x, y):\n    return x * y // math.gcd(x, y)\na = []\n\ndef SieveOfEratosthenes(n):\n    prime = [True] * (n + 1)\n    p = 2\n    while p * p <= n:\n        print(p)\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    a = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            a.append(p)\n\ndef add(i):\n    return (1 << i) - 1\n\ndef rsb(k):\n    p = 1\n    while k > 0:\n        if k & 1:\n            return p - 1\n        p += 1\n        k = k >> 1\n\ndef phone_number(s):\n    ans = ''\n    l = 0\n    mul = 1\n    for i in range(len(s)):\n        if s[i] == ' ':\n            r = i\n            char = s[l:r]\n            if char == 'double':\n                mul = 2\n            elif char == 'triple':\n                mul = 3\n            else:\n                ans += mul * d[char]\n                mul = 1\n            l = r + 1\n    ans += mul * str(d[s[l:len(s)]])\n    return ans\n\ndef reverseColumns(arr):\n    (arr[0][0], arr[3][0]) = (arr[3][0], arr[0][0])\n    (arr[0][1], arr[3][1]) = (arr[3][1], arr[0][1])\n    (arr[0][2], arr[3][2]) = (arr[3][2], arr[0][2])\n    (arr[0][3], arr[3][3]) = (arr[3][3], arr[0][3])\n    (arr[1][0], arr[2][0]) = (arr[2][0], arr[1][0])\n    (arr[1][3], arr[2][3]) = (arr[2][3], arr[1][3])\n    (arr[1][1], arr[2][1]) = (arr[2][1], arr[1][1])\n    (arr[1][2], arr[2][2]) = (arr[2][2], arr[1][2])\n    return arr\n\ndef transpose(arr):\n    R = C = 4\n    for i in range(R):\n        for j in range(i, C):\n            t = arr[i][j]\n            arr[i][j] = arr[j][i]\n            arr[j][i] = t\n    return arr\n\ndef isPrime(n):\n    if n == 1:\n        return 0\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return 0\n        i += 1\n    return 1\n\ndef give_matrix(e):\n    temp = []\n    me = []\n    for i in range(16):\n        temp.append(ord(e[i]))\n    me.append(temp[0:4])\n    me.append(temp[4:8])\n    me.append(temp[8:12])\n    me.append(temp[12:16])\n    return me\n\ndef XOR(m1, m2):\n    for i in range(len(m1)):\n        for j in range(len(m2)):\n            m1[i][j] = m1[i][j] ^ m2[i][j]\n    return m1\n\ndef x_4(m1):\n    for i in range(len(m1)):\n        for j in range(len(m1)):\n            m1[i][j] = m1[i][j] ^ 4\n    return m1\n\ndef isFeasible(a, k, ans):\n    n = len(a)\n    res = sum = i = 0\n    res = 1\n    while i < n:\n        sum += a[i]\n        if sum > ans:\n            res += 1\n            sum = a[i]\n        i += 1\n    if res <= k:\n        return 1\n    return 0\n\ndef binary_search(a, l, r):\n    while l <= r:\n        m = (l + r) // 2\n        if isFeasible(a, k, m):\n            r = m - 1\n        else:\n            l = m + 1\n    return l\n\ndef isCollinear(a, b, c):\n    (x1, y1) = a\n    (x2, y2) = b\n    (x3, y3) = c\n    a = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)\n    if a == 0:\n        return 1\n    return 0\n\ndef rec(a, n, p):\n    if n <= -1:\n        return 0\n    (no_take2, no_take1, take1, take2, no_take_even, no_take_odd) = (0, 0, 0, 0, 0, 0)\n    if p:\n        if a[n] & 1:\n            take1 += a[n] + rec(a, n - 1, ~p)\n        else:\n            no_take1 += rec(a, n - 1, ~p)\n    elif a[n] % 2 == 0:\n        take2 += a[n] + rec(a, n - 1, ~p)\n    else:\n        no_take2 += rec(a, n - 1, ~p)\n    return max(no_take2, no_take1, take1, take2, no_take_even, no_take_odd)\n\ndef digitSum(x):\n    sum = 0\n    while x:\n        sum += x % 10\n        x //= 10\n    return sum\nimport string\na = []\nfor l in string.ascii_lowercase:\n    a.append(l)\nfrom functools import lru_cache\n\ndef removeInvalidParentheses(s):\n\n    def dfs(s):\n        mi = calc(s)\n        if mi == 0:\n            return [s]\n        ans = []\n        for x in range(len(s)):\n            if s[x] in ('(', ')'):\n                ns = s[:x] + s[x + 1:]\n                if ns not in visited and calc(ns) < mi:\n                    visited.add(ns)\n                    ans.extend(dfs(ns))\n        return ans\n\n    def calc(s):\n        a = b = 0\n        for c in s:\n            a += {'(': 1, ')': -1}.get(c, 0)\n            b += a < 0\n            a = max(a, 0)\n        return a + b\n    visited = set([s])\n    return dfs(s)\n\ndef countAllBits(A):\n    ans = 0\n    a = [0] * 32\n    for bit in range(32):\n        for n in A:\n            if n & 1 << bit:\n                a[bit] = 1\n                ans += 1\n    return sum(a)\n\ndef diff(a, b):\n    ans = 0\n    for i in range(len(a)):\n        ans += abs(a[i] - b[i])\n    return ans\nnum = ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9')\n(cap, smal) = (set(), set())\nfor letter in string.ascii_uppercase:\n    cap.add(letter)\nfor letter in string.ascii_lowercase:\n    smal.add(letter)\nspe = ('#', '@', '*', '&')\nd = {}\n\ndef dp(n, t):\n    if n == 1:\n        dp[n, t] = 1\n        return dp[n, t]\n    if n in (2, 3):\n        return dp[n, t]\n    if (n, t) in d:\n        return d[n, t]\n    else:\n        (p1, p2, p3) = (float('inf'), float('inf'), float('inf'))\n        if t == 1:\n            p1 = min(dp(n - 2, 2), dp(n - 3, 3))\n        elif t == 2:\n            p2 = min(dp(n - 1, 1), dp(n - 3, 3))\n        else:\n            p3 = min(dp(n - 2, 2), dp(n - 1, 1))\n        d[n, t] = 1 + min(p1, p2, p3)\n        return d[n, t]\n\ndef removeReverse(S):\n    res = []\n    d = set()\n    c = 0\n    for i in S:\n        if i not in d:\n            d.add(i)\n            res.append(i)\n        else:\n            c += 1\n    print(c, res)\n    if c & 1:\n        res = res[::-1]\n    return ''.join(res)\na = [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16]\nb = [2, 3, 5, 6, 8, 9, 11, 12, 14, 15, 17]\nc = [3, 4, 6, 7, 9, 10, 12, 13, 15, 16]\nd = [4, 5, 7, 8, 10, 11, 13, 14, 16]\ne = [5, 6, 8, 9, 11, 12, 14, 15, 17]\nf = [6, 7, 9, 10, 12, 13, 15, 16, 18]\n\ndef percent(x, p):\n    return x * p / 100\n\ndef maximalSquare(A) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dp = [[0 for i in range(n + 1)] for i in range(m + 1)]\n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                dp[i + 1][j + 1] = 1 + min(dp[i + 1][j], dp[i][j], dp[i][j + 1])\n                ans = max(ans, dp[i + 1][j + 1])\n    return ans\n\ndef isPali(s):\n    (l, r) = (0, len(s) - 1)\n    while l < r:\n        if s[l] != s[r]:\n            return 0\n        (l, r) = (l + 1, r - 1)\n    return s\n\ndef main():\n\n    def solve():\n        f = a[n - 1]\n        if f == 0:\n            return 'NO'\n        s = a[f - 1]\n        if s == 0:\n            return 'NO'\n        return 'YES'\n    (n, c) = get_line()\n    mod = 1000000007\n    graph = [[] for i in range(n + 1)]\n    for _ in range(n - 1):\n        (a, b) = get_line()\n        graph[a].append(b)\n        graph[b].append(a)\n    seen = set()\n    q = [(1, 0)]\n    ans = 1\n    while q:\n        (node, nearby) = q.pop()\n        ans = ans * (c - nearby) % mod\n        seen.add(node)\n        nearby = 1\n        for i in graph[node]:\n            if i not in seen:\n                q.append((i, nearby))\n            nearby += 1\n    print(ans)\nmain()", "(n, c) = input().split()\n(n, c) = (int(n), int(c))\narr = []\nfor i in range(n - 1):\n    pair = input().split()\n    arr.append([int(pair[0]), int(pair[1])])\nif n == 1:\n    print(c)\nelse:\n    mp = {}\n    for i in range(n - 1):\n        pair = arr[i]\n        v1 = pair[0]\n        v2 = pair[1]\n        if v1 not in mp:\n            mp[v1] = [v2]\n        else:\n            mp[v1].append(v2)\n        if v2 not in mp:\n            mp[v2] = [v1]\n        else:\n            mp[v2].append(v1)\n    memo = {}\n    mod = 10 ** 9 + 7\n    val = arr[0][0]\n    cur_layer = 1\n    cnt = 1\n    layer = []\n    brks = []\n    flag = True\n    while True:\n        if flag == False:\n            break\n        if cur_layer == 1:\n            cnt = cnt * c % mod\n            for i in range(len(mp[val])):\n                layer.append(mp[val][i])\n            cur_layer += 1\n            memo[val] = True\n            continue\n        if cur_layer == 2:\n            prev_nodes = 0\n            for i in range(len(layer)):\n                if c - 1 - prev_nodes <= 0:\n                    flag = False\n                cnt = cnt * (c - 1 - prev_nodes) % mod\n                prev_nodes += 1\n            new_layer = []\n            new_brks = []\n            for i in range(len(layer)):\n                if len(new_brks) == 0:\n                    new_brks.append(len(mp[layer[i]]) - 1)\n                else:\n                    new_brks.append(new_brks[len(new_brks) - 1] + len(mp[layer[i]]) - 1)\n                memo[layer[i]] = True\n                for j in range(len(mp[layer[i]])):\n                    if mp[layer[i]][j] in memo:\n                        continue\n                    new_layer.append(mp[layer[i]][j])\n            cur_layer += 1\n            layer = new_layer\n            brks = new_brks\n            if len(new_layer) == 0:\n                break\n            continue\n        prev_nodes = 0\n        pt = 0\n        for i in range(len(layer)):\n            if i == brks[pt]:\n                prev_nodes = 0\n                pt += 1\n            if c - 2 - prev_nodes <= 0:\n                flag = False\n            cnt = cnt * (c - 2 - prev_nodes) % mod\n            prev_nodes += 1\n        new_layer = []\n        new_brks = []\n        for i in range(len(layer)):\n            if len(new_brks) == 0:\n                new_brks.append(len(mp[layer[i]]) - 1)\n            else:\n                new_brks.append(new_brks[len(new_brks) - 1] + len(mp[layer[i]]) - 1)\n            memo[layer[i]] = True\n            for j in range(len(mp[layer[i]])):\n                if mp[layer[i]][j] in memo:\n                    continue\n                new_layer.append(mp[layer[i]][j])\n        cur_layer += 1\n        layer = new_layer\n        brks = new_brks\n        if len(new_layer) == 0:\n            break\n        continue\n    if flag == False:\n        print(0)\n    else:\n        print(cnt)", "from collections import defaultdict\nimport sys\n\ndef dfs(root, parent, graph, ways, c, child_colored):\n    if parent == -1:\n        ways[root] = c\n    elif parent == 0:\n        ways[root] = max(c - 1 - child_colored[parent], 0)\n    else:\n        ways[root] = max(c - 1 - child_colored[parent] - 1, 0)\n    for child in graph[root]:\n        if child != parent:\n            dfs(child, root, graph, ways, c, child_colored)\n            child_colored[root] += 1\nsys.setrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\n(n, c) = [int(x) for x in input().split()]\ngraph = defaultdict(list)\nfor i in range(n - 1):\n    (u, v) = [int(x) for x in input().split()]\n    graph[u - 1].append(v - 1)\n    graph[v - 1].append(u - 1)\nchild_colored = defaultdict(int)\nways = [0] * n\ndfs(0, -1, graph, ways, c, child_colored)\nans = 1\nfor way in ways:\n    ans = ans * way % mod\nprint(ans)", "from collections import defaultdict\nimport sys\n\ndef dfs(root, parent, graph, ways, c, child_colored):\n    if parent == -1:\n        ways[root] = c\n    elif parent == 0:\n        ways[root] = max(c - 1 - child_colored[parent], 0)\n    else:\n        ways[root] = max(c - 1 - child_colored[parent] - 1, 0)\n    for child in graph[root]:\n        if child != parent:\n            dfs(child, root, graph, ways, c, child_colored)\n            child_colored[root] += 1\nsys.setrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\n(n, c) = [int(x) for x in input().split()]\ngraph = defaultdict(list)\nfor i in range(n - 1):\n    (u, v) = [int(x) for x in input().split()]\n    graph[u - 1].append(v - 1)\n    graph[v - 1].append(u - 1)\nchild_colored = defaultdict(int)\nways = [0] * n\ndfs(0, -1, graph, ways, c, child_colored)\nans = 1\nfor way in ways:\n    ans = ans * way % mod\nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\n(n, c) = map(int, input().split())\ngr = [[] for i in range(n)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    gr[x - 1].append(y - 1)\n    gr[y - 1].append(x - 1)\n\ndef dfs(i, n, f, vis):\n    if i in vis:\n        return 1\n    vis.add(i)\n    ans = 1\n    c = 1\n    if f == 0:\n        for j in gr[i]:\n            if j not in vis:\n                ans = ans * (n - c) * dfs(j, n, 1, vis)\n                ans %= 10 ** 9 + 7\n                c += 1\n    else:\n        c = 2\n        for j in gr[i]:\n            if j not in vis:\n                ans = ans * (n - c) * dfs(j, n, 1, vis)\n                c += 1\n                ans %= 10 ** 9 + 7\n    return ans\nans = c * dfs(0, c, 0, set())\nans %= 10 ** 9 + 7\nprint(ans)", "ri = lambda : int(input())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(1000000)\nM = 1000000007\nways = 0\n\ndef dfs(node, s, color):\n    c = 0\n    if not node:\n        return\n    if node not in parent:\n        ways = color - s\n    elif parent[node] not in parent:\n        ways = color - s - 1\n    else:\n        ways = color - s - 2\n    choices[node] = ways % M\n    if node not in adj:\n        return\n    for x in adj[node]:\n        dfs(x, c, color)\n        c += 1\n\ndef calc():\n    for i in adj:\n        if i == root:\n            f = c * find(c - 1, len(adj[i]))\n            f %= M\n            ways = ways + f\n            ways %= M\n        else:\n            f = find(c - 2, len(adj[i]))\n            f %= M\n            ways = ways * f\n            ways %= M\n\ndef find(n, r):\n    if r > n:\n        flag = 0\n        return 0\n    total = 1\n    for i in range(n - r + 1, n + 1):\n        total = total * i\n        total %= M\n    return total\n(n, c) = rl()\nadj = {}\nparent = {}\nchoices = {}\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    if x not in adj:\n        adj[x] = [y]\n    else:\n        adj[x].append(y)\n    parent[y] = x\nroot = None\nfor x in adj:\n    if x not in parent:\n        root = x\n        break\ndfs(root, 0, c)\nans = 1\nfor x in choices:\n    ans *= choices[x]\n    ans %= M\nprint(ans)", "mod = 10 ** 9 + 7\n(n, c) = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\nans = 1\nvis = [0] * (n + 1)\nqueue = [(1, 0)]\nwhile queue:\n    (node, nearby) = queue.pop()\n    ans = ans * (c - nearby) % mod\n    (vis[node], nearby) = (1, 1)\n    for i in graph[node]:\n        if not vis[i]:\n            queue.append((i, nearby))\n        nearby += 1\nprint(ans)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\n\ndef dfs(node, par, x):\n    v[node] = 1\n    ans = x\n    if par == -1:\n        j = 1\n    else:\n        j = 2\n    for i in adj[node]:\n        if not v[i]:\n            ans *= dfs(i, node, c - j)\n            ans %= mod\n            j += 1\n    return ans\n(n, c) = map(int, input().split())\nadj = {i + 1: [] for i in range(n)}\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\nv = [0] * (n + 1)\nfans = dfs(1, -1, c)\nfans %= mod\nprint(fans)", "import sys\nsys.setrecursionlimit(10 ** 6)\n(n, c) = map(int, input().split())\ngr = [[] for i in range(n)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    gr[x - 1].append(y - 1)\n    gr[y - 1].append(x - 1)\n\ndef dfs(i, n, f, vis):\n    if i in vis:\n        return 1\n    vis.add(i)\n    ans = 1\n    c = 1\n    if f == 0:\n        for j in gr[i]:\n            if j not in vis:\n                ans = ans * (n - c) * dfs(j, n, 1, vis)\n                ans %= 10 ** 9 + 7\n                c += 1\n    else:\n        c = 2\n        for j in gr[i]:\n            if j not in vis:\n                ans = ans * (n - c) * dfs(j, n, 1, vis)\n                c += 1\n                ans %= 10 ** 9 + 7\n    return ans\nans = c * dfs(0, c, 0, set())\nans %= 10 ** 9 + 7\nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\n(n, c) = map(int, input().split())\ngr = [[] for i in range(n)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    gr[x - 1].append(y - 1)\n    gr[y - 1].append(x - 1)\n\ndef dfs(i, n, f, vis):\n    if i in vis:\n        return 1\n    vis.add(i)\n    ans = 1\n    c = 1\n    if f == 0:\n        for j in gr[i]:\n            if j not in vis:\n                ans = ans * (n - c) * dfs(j, n, 1, vis)\n                ans %= 10 ** 9 + 7\n                c += 1\n    else:\n        c = 2\n        for j in gr[i]:\n            if j not in vis:\n                ans = ans * (n - c) * dfs(j, n, 1, vis)\n                c += 1\n                ans %= 10 ** 9 + 7\n    return ans\nans = c * dfs(0, c, 0, set())\nans %= 10 ** 9 + 7\nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\n\ndef dfs(node, par, x):\n    v[node] = 1\n    ans = x\n    j = 1 if par == -1 else 2\n    for i in adj[node]:\n        if not v[i]:\n            ans *= dfs(i, node, c - j)\n            ans %= mod\n            j += 1\n    return ans\n(n, c) = map(int, input().split())\nadj = {i + 1: [] for i in range(n)}\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\nv = [0] * (n + 1)\nfans = dfs(1, -1, c)\nfans %= mod\nprint(fans)", "import sys\nfrom math import sqrt, gcd, factorial, ceil, floor, pi\nfrom collections import deque, Counter, OrderedDict\nfrom heapq import heapify, heappush, heappop\nsys.setrecursionlimit(10 ** 6)\ninput = lambda : sys.stdin.readline()\nI = lambda : int(input())\nS = lambda : input().strip()\nM = lambda : map(int, input().strip().split())\nL = lambda : list(map(int, input().strip().split()))\nmod = 10 ** 9 + 7\n\ndef dfs(node, par, x):\n    v[node] = 1\n    ans = x\n    j = 1 if par == -1 else 2\n    for i in adj[node]:\n        if not v[i]:\n            ans *= dfs(i, node, c - j)\n            ans %= mod\n            j += 1\n    return ans\n(n, c) = M()\nadj = {i + 1: [] for i in range(n)}\nfor i in range(n - 1):\n    (u, v) = M()\n    adj[u].append(v)\n    adj[v].append(u)\nv = [0] * (n + 1)\nfans = dfs(1, -1, c)\nfans %= mod\nprint(fans)", "def two_input():\n    return map(int, input().strip().split())\nimport sys\nsys.setrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\n\ndef dfs(node, par, x):\n    v[node] = 1\n    ans = x\n    j = 1 if par == -1 else 2\n    for i in adj[node]:\n        if not v[i]:\n            ans *= dfs(i, node, c - j)\n            ans %= mod\n            j += 1\n    return ans\n(n, c) = two_input()\nadj = {i + 1: [] for i in range(n)}\nfor i in range(n - 1):\n    (u, v) = two_input()\n    adj[u].append(v)\n    adj[v].append(u)\nv = [0] * (n + 1)\nfans = dfs(1, -1, c)\nfans %= mod\nprint(fans)", "def two_input():\n    return map(int, input().strip().split())\nimport sys\nfrom math import sqrt, gcd, factorial, ceil, floor, pi\nfrom collections import deque, Counter, OrderedDict\nfrom heapq import heapify, heappush, heappop\nsys.setrecursionlimit(10 ** 6)\ninput = lambda : sys.stdin.readline()\nI = lambda : int(input())\nS = lambda : input().strip()\nM = lambda : map(int, input().strip().split())\nL = lambda : list(map(int, input().strip().split()))\nmod = 10 ** 9 + 7\n\ndef dfs(node, par, x):\n    v[node] = 1\n    ans = x\n    j = 1 if par == -1 else 2\n    for i in adj[node]:\n        if not v[i]:\n            ans *= dfs(i, node, c - j)\n            ans %= mod\n            j += 1\n    return ans\n(n, c) = two_input()\nadj = {i + 1: [] for i in range(n)}\nfor i in range(n - 1):\n    (u, v) = two_input()\n    adj[u].append(v)\n    adj[v].append(u)\nv = [0] * (n + 1)\nfans = dfs(1, -1, c)\nfans %= mod\nprint(fans)", "import sys\nfrom math import sqrt, gcd, factorial, ceil, floor, pi\nfrom collections import deque, Counter, OrderedDict\nfrom heapq import heapify, heappush, heappop\nsys.setrecursionlimit(10 ** 6)\ninput = lambda : sys.stdin.readline()\nI = lambda : int(input())\nS = lambda : input().strip()\nM = lambda : map(int, input().strip().split())\nL = lambda : list(map(int, input().strip().split()))\nmod = 10 ** 9 + 7\n\ndef dfs(node, par, x):\n    v[node] = 1\n    ans = x\n    j = 1 if par == -1 else 2\n    for i in adj[node]:\n        if not v[i]:\n            ans *= dfs(i, node, c - j)\n            ans %= mod\n            j += 1\n    return ans\n(n, c) = M()\nadj = {i + 1: [] for i in range(n)}\nfor i in range(n - 1):\n    (u, v) = M()\n    adj[u].append(v)\n    adj[v].append(u)\nv = [0] * (n + 1)\nfans = dfs(1, -1, c)\nfans %= mod\nprint(fans)", "import sys\nfrom math import sqrt, gcd, factorial, ceil, floor, pi\nfrom collections import deque, Counter, OrderedDict\nfrom heapq import heapify, heappush, heappop\nsys.setrecursionlimit(10 ** 6)\ninput = lambda : sys.stdin.readline()\nI = lambda : int(input())\nS = lambda : input().strip()\nM = lambda : map(int, input().strip().split())\nL = lambda : list(map(int, input().strip().split()))\nmod = 10 ** 9 + 7\n\ndef dfs(node, par, x):\n    v[node] = 1\n    ans = x\n    j = 1 if par == -1 else 2\n    for i in adj[node]:\n        if not v[i]:\n            ans *= dfs(i, node, c - j)\n            ans %= mod\n            j += 1\n    return ans\n(n, c) = M()\nadj = {i + 1: [] for i in range(n)}\nfor i in range(n - 1):\n    (u, v) = M()\n    adj[u].append(v)\n    adj[v].append(u)\nv = [0] * (n + 1)\nfans = dfs(1, -1, c)\nfans %= mod\nprint(fans)", "import sys\nfrom queue import Queue\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\nfor _ in range(1):\n    (n, c) = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    q = Queue()\n    vis = [False] * (n + 1)\n    q.put((1, c))\n    vis[1] = True\n    ans = c\n    while not q.empty():\n        (node, C) = q.get()\n        i = 1\n        for child in adj[node]:\n            if not vis[child]:\n                ans *= C - i\n                ans %= mod\n                q.put((child, max(C - i, c - 1)))\n                i += 1\n                vis[child] = True\n    print(ans)", "import sys\nfrom math import sqrt, gcd, factorial, ceil, floor, pi\nfrom collections import deque, Counter, OrderedDict\nfrom heapq import heapify, heappush, heappop\nsys.setrecursionlimit(10 ** 6)\ninput = lambda : sys.stdin.readline()\nI = lambda : int(input())\nS = lambda : input().strip()\nM = lambda : map(int, input().strip().split())\nL = lambda : list(map(int, input().strip().split()))\nmod = 10 ** 9 + 7\n\ndef dfs(node, par, x):\n    v[node] = 1\n    ans = x\n    j = 1 if par == -1 else 2\n    for i in adj[node]:\n        if not v[i]:\n            ans *= dfs(i, node, c - j)\n            ans %= mod\n            j += 1\n    return ans\n(n, c) = M()\nadj = {i + 1: [] for i in range(n)}\nfor i in range(n - 1):\n    (u, v) = M()\n    adj[u].append(v)\n    adj[v].append(u)\nv = [0] * (n + 1)\nfans = dfs(1, -1, c)\nfans %= mod\nprint(fans)", "import sys\nimport threading\ninput = sys.stdin.readline\nsys.setrecursionlimit(3 * 10 ** 6)\nglobal k\nk = 10 ** 9 + 7\n\ndef dfs(vertex, gp, visited, c):\n    global v\n    global k\n    global ans\n    if vertex == 0:\n        visited[vertex] = 1\n        ans *= c\n    for i in range(len(gp[vertex])):\n        if visited[gp[vertex][i]] == 1:\n            c += 1\n        else:\n            visited[gp[vertex][i]] = 1\n            ans = ans * max(0, c - i - 1) % k\n            dfs(gp[vertex][i], gp, visited, v - 1)\n    return\n\ndef main():\n    global ans\n    global v\n    (n, v) = map(int, input().split())\n    gp = []\n    for i in range(n):\n        gp.append([])\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        gp[x - 1].append(y - 1)\n        gp[y - 1].append(x - 1)\n    visited = [0] * n\n    ans = 1\n    dfs(0, gp, visited, v)\n    print(ans)\nthreading.stack_size(10 ** 9)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import math\nimport sys\nsys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nfor _ in range(1):\n    (N, C) = map(int, input().split())\n    edges = {}\n    for i in range(1, N + 1):\n        edges[i] = []\n    for i in range(N - 1):\n        (x, y) = map(int, input().split())\n        edges[x].append(y)\n        edges[y].append(x)\n    visited = set()\n    ans = {1: C}\n    dummy = {1: C}\n\n    def explore(X):\n        visited.add(X)\n        rem = dummy[1]\n        if X == 1:\n            rem -= 1\n        else:\n            rem -= 2\n        for ch in edges[X]:\n            if ch not in visited:\n                ans[ch] = rem\n                visited.add(ch)\n                explore(ch)\n                rem -= 1\n        return\n    ans = {1: C}\n    visited.add(1)\n    explore(1)\n    A = 1\n    for i in ans:\n        A *= ans[i]\n        A %= MOD\n    print(A)", "import sys\nsys.setrecursionlimit(10 ** 7)\n(n, c) = map(int, input().split())\ndit = {}\nmod = 10 ** 9 + 7\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    if a in dit:\n        dit[a].append(b)\n    else:\n        dit[a] = [b]\n    if b in dit:\n        dit[b].append(a)\n    else:\n        dit[b] = [a]\nglobal ans\nans = 1\n\ndef fun(node, ad, p):\n    global ans\n    ans = ans * (c - ad) % mod\n    if p == -1:\n        adj = 1\n    else:\n        adj = 2\n    if node not in dit:\n        return\n    for u in dit[node]:\n        if u != p:\n            fun(u, adj, node)\n            adj += 1\nfun(1, 0, -1)\nprint(ans)", "I = lambda : list(map(int, input().split()))\n(n, c) = I()\nmod = 10 ** 9 + 7\ndeg = [0] * n\ngr = [[] for i in range(n)]\nfor i in range(n - 1):\n    (a, b) = I()\n    deg[a - 1] += 1\n    deg[b - 1] += 1\n    gr[a - 1].append(b - 1)\n    gr[b - 1].append(a - 1)\nvis = [0] * n\nfact = [1] * (10 ** 6 + 2)\nfor i in range(2, len(fact)):\n    fact[i] = i * fact[i - 1] % mod\n\ndef ncr(n, r):\n    den = pow(fact[n - r] * fact[r], mod - 2, mod)\n    return fact[n] * den % mod\nif max(deg) + 1 > c:\n    an = 0\nelse:\n    an = 1\n    st = [[0, c]]\n    while st:\n        cur = st.pop()\n        node = cur[0]\n        vis[node] = 1\n        an = an * cur[1] % mod\n        if node == 0:\n            val = c - 1\n        else:\n            val = c - 2\n        for j in gr[node]:\n            if not vis[j]:\n                vis[j] = 1\n                st.append([j, val])\n                val -= 1\nprint(an)", "(n, c) = map(int, input().split())\nmp = {}\nmp1 = {}\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    if x in mp:\n        mp[x].append(y)\n    else:\n        mp[x] = [y]\nroot = list(mp.keys())[0]\nmp2 = {}\nmod = 1000000000.0 + 7\nans = 1\nq = [root]\nc2 = c\nmp2[root] = c\nwhile len(q):\n    temp = []\n    while len(q):\n        k = q.pop()\n        if mp2[k] < c:\n            c2 = c - 1\n        if k in mp:\n            for i in mp[k]:\n                temp.append(i)\n                c2 -= 1\n                mp2[i] = c2\n    q = temp\nfor i in mp2:\n    ans = mp2[i] * ans % mod\n    ans %= mod\nprint(int(ans))", "import sys\nsys.setrecursionlimit(1000001)\nscan = sys.stdin.readline\nimport math\n(N, C) = map(int, input().strip().split())\ntree = []\nv = set([])\ni = 0\nwhile i <= N:\n    tree.append([])\n    i = i + 1\ni = 0\nwhile i < N - 1:\n    temp = list(map(int, input().strip().split()))\n    tree[temp[0]].append(temp[1])\n    tree[temp[1]].append(temp[0])\n    i = i + 1\n\ndef rec(x):\n    r = 1\n    v.add(x)\n    l = len(tree[x])\n    k = 0\n    if x == 1:\n        j = 1\n    else:\n        j = 2\n    while k < l:\n        if tree[x][k] not in v:\n            r = r * ((C - j) * rec(tree[x][k])) % 1000000007 % 1000000007\n            j = j + 1\n        k = k + 1\n    return r\nprint(C * rec(1) % 1000000007)", "from sys import stdin\ninput = stdin.readline\n(n, c) = map(int, input().split())\nd = {}\nmod = 10 ** 9 + 7\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    if u not in d:\n        d[u] = 0\n    d[u] += 1\n    if v not in d:\n        d[v] = 0\n    d[v] += 1\nans = c\nfor i in range(d[1]):\n    ans = ans * (c - i - 1) % mod\nfor i in range(2, n + 1):\n    for j in range(d[i] - 1):\n        ans = ans * (c - 2 - j) % mod\nprint(ans)", "import collections\nimport math\nfrom queue import Queue\n[n, c] = [int(i) for i in input().split()]\nparent = [-1] * n\nmod = 10 ** 9 + 7\nfor i in range(n - 1):\n    [u, v] = [int(j) for j in input().split()]\n    a = min(u - 1, v - 1)\n    b = max(u - 1, v - 1)\n    parent[b] = a\nans = c\nparent = parent[1:]\nd = collections.Counter(parent)\nfor i in d:\n    if i == 0:\n        val = 1\n    else:\n        val = 2\n    for j in range(d[i]):\n        ans = ans * (c - val - j) % mod\nprint(ans)", "from collections import deque\n(n, c) = map(int, input().split())\nadj = [[] for k in range(n)]\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    adj[u - 1].append(v - 1)\npro = 1\nque = deque([[0, c, 0]])\nwhile que:\n    (node, val, level) = que.popleft()\n    pro = pro * val % (10 ** 9 + 7)\n    if val == 0:\n        break\n    if level < 1:\n        v = val - 1\n    else:\n        v = c - 2\n    for a in adj[node]:\n        que.append([a, v, level + 1])\n        v -= 1\nprint(pro)", "[n, c] = list(map(int, input().split(' ')))\nhm = {}\nm = 10 ** 9 + 7\nfor i in range(n - 1):\n    [u, v] = list(map(int, input().split(' ')))\n    if u in hm:\n        hm[u] += [v]\n    else:\n        hm[u] = [v]\nans = c\nfor i in range(len(hm[1])):\n    ans = ans * (c - i - 1) % m\nfor (k, v1) in hm.items():\n    if k != 1:\n        d = len(v1)\n        for j in range(d):\n            ans = ans * (c - 2 - j) % m\nprint(ans)", "mod = 10 ** 9 + 7\n(n, c) = [int(item) for item in input().split(' ')]\nneighbers = {}\nfor i in range(n - 1):\n    (source, target) = [int(item) for item in input().split(' ')]\n    if not neighbers.__contains__(source):\n        neighbers[source] = []\n    neighbers[source].append(target)\n    if not neighbers.__contains__(target):\n        neighbers[target] = []\n    neighbers[target].append(source)\nres = 1\nfirst_node = 1\nres *= c\nfor i in range(c - len(neighbers[first_node]), c):\n    res = res * i % mod\nfor (parent, child_c) in neighbers.items():\n    if parent != first_node and len(child_c) != 1:\n        for i in range(c - len(child_c), c - 1):\n            res = res * i % mod\nprint(res)", "ri = lambda : int(input())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\nM = 1000000007\n\ndef find(n, r):\n    if r > n:\n        flag = 0\n        return 0\n    total = 1\n    for i in range(n - r + 1, n + 1):\n        total = total * i\n        total %= M\n    return total\n(n, c) = rl()\nadj = {}\nparent = set()\nchild = set()\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    if x not in adj:\n        adj[x] = [y]\n    else:\n        adj[x].append(y)\n    parent.add(x)\n    child.add(y)\nfor x in parent:\n    if x not in child:\n        root = x\n        break\nways = 0\nfor i in adj:\n    if i == root:\n        f = c * find(c - 1, len(adj[i]))\n        f %= M\n        ways = ways + f\n        ways %= M\n    else:\n        f = find(c - 2, len(adj[i]))\n        f %= M\n        ways = ways * f\n        ways %= M\nprint(ways)", "from sys import stdin\nfrom sys import setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(int(1000000000.0))\n\ndef ii():\n    return int(input())\n\ndef li():\n    return list(map(int, input().split()))\nfrom math import sqrt\n\ndef perfect_sq(n):\n    x = int(sqrt(n))\n    while x * x < n:\n        x += 1\n    while x * x > n:\n        x -= 1\n    return x * x == n\nmod = int(1000000000.0) + 7\n(n, c) = li()\ngraph = [[] for i in range(n + 1)]\nans = [c for i in range(n + 1)]\nfor i in range(n - 1):\n    (u, v) = li()\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef dfs(at, p=0):\n    cnt = 1 + (p > 0)\n    for child in graph[at]:\n        if child == p:\n            continue\n        ans[child] -= cnt\n        cnt += 1\n        dfs(child, at)\ndfs(1)\nval = 1\nfor i in range(1, n + 1):\n    val = val * max(0, ans[i]) % mod\nprint(val)", "import sys, math, heapq, bisect\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6 + 5)\nints = lambda : list(map(int, input().split()))\n\ndef gprint(t, ans=''):\n    print(f'Case #{t + 1}:', ans)\np = 10 ** 9 + 7\ninf = 10 ** 20 + 7\n\ndef dfs(node, c, isRoot):\n    done.add(node)\n    ans = 1\n    if isRoot:\n        start = c - 1\n    else:\n        start = c - 2\n    for i in tree[node]:\n        if i not in done:\n            ans = ans * start * dfs(i, c, False) % p\n            start -= 1\n    return ans\n(n, c) = ints()\ntree = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = ints()\n    tree[x].append(y)\n    tree[y].append(x)\ndone = set()\nans = c * dfs(1, c, True)\nprint(ans % p)"]