["import heapq\n\ndef find_min_cost(City, Road, adj):\n    cost = [float('inf') for i in range(City + 1)]\n    cost[1] = 0\n    flag = [False for i in range(City + 1)]\n    start = [[0, 1]]\n    while len(start):\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[City]\nt = int(input())\nfor _ in range(t):\n    line = input().split()\n    (c, r) = (int(line[0]), int(line[1]))\n    adj = [[] for i in range(c + 1)]\n    for _ in range(r):\n        edge = input().split()\n        (p, q) = (int(edge[0]), int(edge[1]))\n        adj[p].append([q, 0])\n        adj[q].append([p, 0])\n    for i in range(1, c):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    print(find_min_cost(c, r, adj))", "import heapq\n\ndef dijkstra():\n    dist = [float('inf') for i in range(n + 1)]\n    dist[1] = 0\n    visited = set()\n    q = []\n    heapq.heapify(q)\n    heapq.heappush(q, [0, 1])\n    while len(q):\n        (dis, u) = heapq.heappop(q)\n        if u in visited:\n            continue\n        visited.add(u)\n        for (v, w_uv) in ad[u]:\n            if dist[v] > dist[u] + w_uv:\n                dist[v] = dist[u] + w_uv\n                heapq.heappush(q, [dist[v], v])\n    return dist[n]\nt = int(input())\nwhile t:\n    inp = input().split()\n    n = int(inp[0])\n    m = int(inp[1])\n    e = set()\n    ad = [[] for i in range(n + 1)]\n    for i in range(m):\n        inpt = input().split()\n        u = int(inpt[0])\n        v = int(inpt[1])\n        e.add((u, v))\n        e.add((v, u))\n        ad[u].append([v, 0])\n        ad[v].append([u, 0])\n    for i in range(1, n):\n        if (i, i + 1) not in e:\n            ad[i].append([i + 1, 1])\n            ad[i + 1].append([i, 1])\n    print(dijkstra())\n    t -= 1", "import heapq\n\ndef dijkstra():\n    dist = [float('inf') for i in range(n + 1)]\n    dist[1] = 0\n    visited = set()\n    q = []\n    heapq.heapify(q)\n    heapq.heappush(q, [0, 1])\n    while len(q):\n        (dis, u) = heapq.heappop(q)\n        if u in visited:\n            continue\n        visited.add(u)\n        for (v, w_uv) in ad[u]:\n            if dist[v] > dist[u] + w_uv:\n                dist[v] = dist[u] + w_uv\n                heapq.heappush(q, [dist[v], v])\n    return dist[n]\nt = int(input())\nwhile t:\n    inp = input().split()\n    n = int(inp[0])\n    m = int(inp[1])\n    e = set()\n    ad = [[] for i in range(n + 1)]\n    for i in range(m):\n        inpt = input().split()\n        u = int(inpt[0])\n        v = int(inpt[1])\n        e.add((u, v))\n        e.add((v, u))\n        ad[u].append([v, 0])\n        ad[v].append([u, 0])\n    for i in range(1, n):\n        if (i, i + 1) not in e:\n            ad[i].append([i + 1, 1])\n            ad[i + 1].append([i, 1])\n    print(dijkstra())\n    t -= 1", "from heapq import heappop, heappush\nfor op in range(int(input())):\n    (n, m) = map(int, input().split())\n    gr = [set() for _ in range(n)]\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        gr[a].add(b)\n        gr[b].add(a)\n    q = [0]\n    seen = set()\n    while q:\n        node = q.pop()\n        seen.add(node)\n        for nie in gr[node]:\n            if nie not in seen:\n                q.append(nie)\n    q = [(0, n - 1)]\n    p = {}\n    while q:\n        (cost, node) = heappop(q)\n        if node in seen:\n            print(cost)\n            break\n        for nie in gr[node]:\n            if nie not in p or p[nie] > cost:\n                heappush(q, (cost, nie))\n                p[nie] = cost\n        nie = node - 1\n        if nie not in gr[node]:\n            if nie not in p or p[nie] > cost + 1:\n                heappush(q, (cost + 1, nie))\n                p[nie] = cost + 1\n        nie = node + 1\n        if nie < n:\n            if nie not in gr[node]:\n                if nie not in p or p[nie] > cost + 1:\n                    heappush(q, (cost + 1, nie))\n                    p[nie] = cost + 1", "from heapq import heappop, heappush\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [set() for _ in range(n)]\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        graph[a].add(b)\n        graph[b].add(a)\n    q = [0]\n    seen = set()\n    while q:\n        node = q.pop()\n        seen.add(node)\n        for nie in graph[node]:\n            if nie not in seen:\n                q.append(nie)\n    q = [(0, n - 1)]\n    p = {}\n    while q:\n        (cost, node) = heappop(q)\n        if node in seen:\n            print(cost)\n            break\n        for nie in graph[node]:\n            if nie not in p or p[nie] > cost:\n                heappush(q, (cost, nie))\n                p[nie] = cost\n        nie = node - 1\n        if nie not in graph[node]:\n            if nie not in p or p[nie] > cost + 1:\n                heappush(q, (cost + 1, nie))\n                p[nie] = cost + 1\n        nie = node + 1\n        if nie < n:\n            if nie not in graph[node]:\n                if nie not in p or p[nie] > cost + 1:\n                    heappush(q, (cost + 1, nie))\n                    p[nie] = cost + 1", "import heapq\n\ndef dijktra(graph, h):\n    explored = ['n' for i in range(graph.v_count)]\n    while explored[-1] == 'n':\n        (val, vertex) = heapq.heappop(h)\n        if explored[vertex - 1] == 'n':\n            for neigh in graph.vertices[vertex]:\n                if explored[neigh - 1] == 'n':\n                    (v1, v2) = sorted([neigh, vertex])\n                    temp = val + graph.edges[v1, v2]\n                    heapq.heappush(h, (temp, neigh))\n        explored[vertex - 1] = 'y'\n    return val\n\nclass Graph:\n\n    def __init__(self, v, e):\n        self.edges = {}\n        self.vertices = {}\n        self.v_count = v\n        self.e_count = e\nfor t in range(int(input())):\n    (v, e) = map(int, input().split(' '))\n    graph = Graph(v, e)\n    h = []\n    for j in range(e):\n        (v1, v2) = map(int, input().split(' '))\n        graph.edges[tuple(sorted([v1, v2]))] = 0\n        if v1 not in graph.vertices:\n            graph.vertices[v1] = []\n        if v2 not in graph.vertices:\n            graph.vertices[v2] = []\n        graph.vertices[v1].append(v2)\n        graph.vertices[v2].append(v1)\n    for j in range(1, v):\n        if (j, j + 1) not in graph.edges:\n            graph.edges[j, j + 1] = 1\n            (v1, v2) = (j, j + 1)\n            if v1 not in graph.vertices:\n                graph.vertices[v1] = []\n            if v2 not in graph.vertices:\n                graph.vertices[v2] = []\n            graph.vertices[v1].append(v2)\n            graph.vertices[v2].append(v1)\n    heapq.heappush(h, (0, 1))\n    print(dijktra(graph, h))", "import heapq\n\ndef dijktra(graph, h):\n    explored = ['n' for i in range(graph.v_count)]\n    while explored[-1] == 'n':\n        (val, vertex) = heapq.heappop(h)\n        if explored[vertex - 1] == 'n':\n            for neigh in graph.vertices[vertex]:\n                if explored[neigh - 1] == 'n':\n                    (v1, v2) = sorted([neigh, vertex])\n                    temp = val + graph.edges[v1, v2]\n                    heapq.heappush(h, (temp, neigh))\n        explored[vertex - 1] = 'y'\n        if vertex == graph.v_count:\n            store = val\n    return store\n\nclass Graph:\n\n    def __init__(self, v, e):\n        self.edges = {}\n        self.vertices = {}\n        self.v_count = v\n        self.e_count = e\nfor t in range(int(input())):\n    (v, e) = map(int, input().split(' '))\n    graph = Graph(v, e)\n    h = []\n    for j in range(e):\n        (v1, v2) = map(int, input().split(' '))\n        graph.edges[tuple(sorted([v1, v2]))] = 0\n        if v1 not in graph.vertices:\n            graph.vertices[v1] = []\n        if v2 not in graph.vertices:\n            graph.vertices[v2] = []\n        graph.vertices[v1].append(v2)\n        graph.vertices[v2].append(v1)\n    for j in range(1, v):\n        if (j, j + 1) not in graph.edges:\n            graph.edges[j, j + 1] = 1\n            (v1, v2) = (j, j + 1)\n            if v1 not in graph.vertices:\n                graph.vertices[v1] = []\n            if v2 not in graph.vertices:\n                graph.vertices[v2] = []\n            graph.vertices[v1].append(v2)\n            graph.vertices[v2].append(v1)\n    heapq.heappush(h, (0, 1))\n    print(dijktra(graph, h))", "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom heapq import heappush, heappop\nfrom sys import maxsize as inf\n\ndef dijkstra(graph, n, src):\n    vis = [False] * n\n    heap = []\n    dist = [inf] * n\n    dist[src] = 0\n    vis[src] = True\n    heappush(heap, (0, src))\n    while heap:\n        (d, node) = heappop(heap)\n        if dist[node] < d:\n            continue\n        vis[node] = True\n        for (adj, weight) in graph[node]:\n            if not vis[adj] and d + weight < dist[adj]:\n                dist[adj] = d + weight\n                heappush(heap, (dist[adj], adj))\n    return dist[n - 1]\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    arr = [False for _ in range(n)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        adj[u - 1].append((v - 1, 0))\n        adj[v - 1].append((u - 1, 0))\n        if abs(u - v) == 1:\n            arr[min(u, v) - 1] = True\n    for i in range(n - 1):\n        if arr[i]:\n            continue\n        adj[i].append((i + 1, 1))\n        adj[i + 1].append((i, 1))\n    print(dijkstra(adj, n, 0))", "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom heapq import heappush, heappop\nfrom sys import maxsize as inf\n\ndef dijkstra(graph, n, src):\n    vis = [False] * n\n    heap = []\n    dist = [inf] * n\n    dist[src] = 0\n    vis[src] = True\n    heappush(heap, (0, src))\n    while heap:\n        (d, node) = heappop(heap)\n        if dist[node] < d:\n            continue\n        vis[node] = True\n        for (adj, weight) in graph[node]:\n            if not vis[adj] and d + weight < dist[adj]:\n                dist[adj] = d + weight\n                heappush(heap, (dist[adj], adj))\n    return dist[n - 1]\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        adj[u - 1].append((v - 1, 0))\n        adj[v - 1].append((u - 1, 0))\n    for i in range(n - 1):\n        if i + 1 in adj[i]:\n            continue\n        adj[i].append((i + 1, 1))\n        adj[i + 1].append((i, 1))\n    print(dijkstra(adj, n, 0))", "from heapq import heappop, heappush\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [set() for _ in range(n)]\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        graph[a].add(b)\n        graph[b].add(a)\n    q = [0]\n    seen = set()\n    while q:\n        node = q.pop()\n        seen.add(node)\n        for nie in graph[node]:\n            if nie not in seen:\n                q.append(nie)\n    q = [(0, n - 1)]\n    p = {}\n    while q:\n        (cost, node) = heappop(q)\n        if node in seen:\n            print(cost)\n            break\n        for nie in graph[node]:\n            if nie not in p or p[nie] > cost:\n                heappush(q, (cost, nie))\n                p[nie] = cost\n        nie = node - 1\n        if nie not in graph[node]:\n            if nie not in p or p[nie] > cost + 1:\n                heappush(q, (cost + 1, nie))\n                p[nie] = cost + 1\n        nie = node + 1\n        if nie < n:\n            if nie not in graph[node]:\n                if nie not in p or p[nie] > cost + 1:\n                    heappush(q, (cost + 1, nie))\n                    p[nie] = cost + 1", "import sys\nfrom math import sqrt, gcd, factorial\nfrom collections import deque, Counter, OrderedDict\nsys.setrecursionlimit(10 ** 6)\ninput = lambda : sys.stdin.readline()\nI = lambda : int(input())\nS = lambda : input().strip()\nM = lambda : map(int, input().strip().split())\nL = lambda : list(map(int, input().strip().split()))\nmod = 1000000007\n\ndef dfs(node, dist):\n    v[node] = 1\n    cc.append(node)\n    d[node] = dist\n    for i in adj[node]:\n        if not v[i]:\n            dfs(i, dist)\nfor _ in range(I()):\n    (n, m) = M()\n    adj = {i + 1: [] for i in range(n)}\n    for i in range(m):\n        (a, b) = M()\n        adj[a].append(b)\n        adj[b].append(a)\n    cc = deque()\n    v = [0] * (n + 1)\n    d = [0] * (n + 1)\n    dfs(n, 0)\n    while cc:\n        curr = cc.popleft()\n        if curr > 1 and (not v[curr - 1]):\n            dfs(curr - 1, d[curr] + 1)\n        if curr < n and (not v[curr + 1]):\n            dfs(curr + 1, d[curr] + 1)\n    print(d[1])", "from heapq import *\nimport sys\ninput = sys.stdin.readline\nINF = 10 ** 9\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    edges = set()\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        adj[a].append([b, 0])\n        adj[b].append([a, 0])\n        edges.add((a, b))\n        edges.add((b, a))\n    for i in range(1, n):\n        if (i, i + 1) not in edges:\n            adj[i].append([i + 1, 1])\n            adj[i + 1].append([i, 1])\n    dis = [INF] * (n + 1)\n    dis[1] = 0\n    pq = []\n    heappush(pq, [0, 1])\n    while pq:\n        (cur_dis, cur_nd) = heappop(pq)\n        for (nex, nex_dis) in adj[cur_nd]:\n            if dis[nex] > cur_dis + nex_dis:\n                dis[nex] = cur_dis + nex_dis\n                heappush(pq, [dis[nex], nex])\n    print(dis[n])", "from sys import stdin\ninp = stdin.readline\n\ndef solve_path(N, M):\n    nbr = [[] for _ in range(N + 1)]\n    avl = [False] + [True] * N\n    for _ in range(M):\n        (u, v) = map(int, inp().split())\n        nbr[u].append(v)\n        nbr[v].append(u)\n    front = [1]\n    avl[1] = False\n    cost = 0\n    while avl[N]:\n        fx = 0\n        while fx < len(front):\n            for nb in nbr[front[fx]]:\n                if avl[nb]:\n                    front.append(nb)\n                    avl[nb] = False\n            fx += 1\n        if not avl[N]:\n            break\n        fwd = []\n        cost += 1\n        for f in front:\n            for fn in range(f - 1, f + 2, 2):\n                if avl[fn]:\n                    fwd.append(fn)\n                    avl[fn] = False\n        front = fwd\n    return cost\nT = int(inp())\nfor tx in range(T):\n    (N, M) = map(int, inp().split())\n    print(solve_path(N, M))", "from collections import defaultdict\nimport heapq\nT = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    graph = defaultdict(list)\n    present = [0 for _ in range(N)]\n    for i in range(M):\n        (u, v) = map(int, input().split())\n        graph[u].append((v, 0))\n        graph[v].append((u, 0))\n        if abs(u - v) == 1:\n            present[min(u, v)] = 1\n    for i in range(1, N):\n        if present[i] == 0:\n            graph[i].append((i + 1, 1))\n            graph[i + 1].append((i, 1))\n    cost = [float('inf') for _ in range(N + 1)]\n    heap = [(0, 1)]\n    cost[1] = 0\n    while heap:\n        (cur_cost, node) = heapq.heappop(heap)\n        for (n, c) in graph[node]:\n            if c + cur_cost < cost[n]:\n                cost[n] = c + cur_cost\n                heapq.heappush(heap, (cost[n], n))\n    print(cost[-1])", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random\nfrom functools import lru_cache\nfrom itertools import *\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n(M, M1) = (1000000007, 998244353)\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for __ in range(how_much_noob_I_am):\n        (n, m) = sep()\n        d = defaultdict(list)\n        for _ in range(m):\n            (a, b) = sep()\n            d[a].append(b)\n            d[b].append(a)\n        q = []\n        heapq.heappush(q, [0, 1])\n        visited = [False] * (n + 1)\n        dis = [inf] * (n + 1)\n        dis[1] = 0\n        while q:\n            (dist, s) = heapq.heappop(q)\n            for i in d[s]:\n                if dis[i] > dist:\n                    dis[i] = dist\n                    heapq.heappush(q, [dist, i])\n            if s + 1 <= n:\n                if dis[s + 1] > dist + 1:\n                    dis[s + 1] = dist + 1\n                    heapq.heappush(q, [dist + 1, s + 1])\n            if s - 1 >= 1:\n                if dis[s - 1] > dist + 1:\n                    dis[s - 1] = dist + 1\n                    heapq.heappush(q, [dist + 1, s - 1])\n        print(dis[n])\nmain()", "import sys\nRW = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRI = lambda : int(sys.stdin.readline().strip())\nRS = lambda : sys.stdin.readline().strip().split()\nfrom collections import OrderedDict as of\nfrom collections import defaultdict as df\nimport heapq\nimport math\nfrom math import ceil, floor\nsys.setrecursionlimit(100005)\n\nclass Graph:\n\n    def __init__(self, adj):\n        self.adj = adj\n        self.n = len(self.adj)\n        self.vis = [0] * n\n        self.minheap = []\n        self.dis = [float('inf')] * self.n\n\n    def solve(self):\n        self.dis[0] = 0\n        self.minheap.append((0, 0))\n        while len(self.minheap) > 0:\n            (distance, node) = heapq.heappop(self.minheap)\n            if self.vis[node] == 1:\n                continue\n            self.vis[node] = 1\n            for (next, nextdis) in self.adj[node]:\n                if self.vis[next] == 1:\n                    continue\n                disttemp = distance + nextdis\n                if disttemp < self.dis[next]:\n                    self.dis[next] = disttemp\n                    heapq.heappush(self.minheap, (disttemp, next))\nt = RI()\nfor _ in range(t):\n    (n, m) = RW()\n    adj = [[] for i in range(n)]\n    for i in range(m):\n        (a, b) = RW()\n        a -= 1\n        b -= 1\n        adj[a].append((b, 0))\n        adj[b].append((a, 0))\n    for i in range(n - 1):\n        adj[i].append((i + 1, 1))\n        adj[i + 1].append((i, 1))\n    g = Graph(adj)\n    g.solve()\n    print(g.dis[n - 1])", "import sys\nRW = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRI = lambda : int(sys.stdin.readline().strip())\nRS = lambda : sys.stdin.readline().strip().split()\nfrom collections import OrderedDict as of\nfrom collections import defaultdict as df\nimport heapq\nimport math\nfrom math import ceil, floor\nsys.setrecursionlimit(100005)\n\nclass Graph:\n\n    def __init__(self, adj):\n        self.adj = adj\n        self.n = len(self.adj)\n        self.vis = [0] * n\n        self.minheap = []\n        self.dis = [float('inf')] * self.n\n\n    def solve(self):\n        self.dis[0] = 0\n        self.minheap.append((0, 0))\n        while len(self.minheap) > 0:\n            (distance, node) = heapq.heappop(self.minheap)\n            if self.vis[node] == 1:\n                continue\n            self.vis[node] = 1\n            for (next, nextdis) in self.adj[node]:\n                if self.vis[next] == 1:\n                    continue\n                disttemp = distance + nextdis\n                if disttemp < self.dis[next]:\n                    self.dis[next] = disttemp\n                    heapq.heappush(self.minheap, (disttemp, next))\nt = RI()\nfor _ in range(t):\n    (n, m) = RW()\n    adj = [[] for i in range(n)]\n    for i in range(m):\n        (a, b) = RW()\n        a -= 1\n        b -= 1\n        adj[a].append((b, 0))\n        adj[b].append((a, 0))\n    for i in range(n - 1):\n        adj[i].append((i + 1, 1))\n        adj[i + 1].append((i, 1))\n    g = Graph(adj)\n    g.solve()\n    print(g.dis[n - 1])", "import sys\nRW = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRI = lambda : int(sys.stdin.readline().strip())\nRS = lambda : sys.stdin.readline().strip().split()\nfrom collections import OrderedDict as of\nfrom collections import defaultdict as df\nimport heapq\nimport math\nfrom math import ceil, floor\nsys.setrecursionlimit(100005)\n\nclass Graph:\n\n    def __init__(self, adj):\n        self.adj = adj\n        self.n = len(self.adj)\n        self.vis = [0] * n\n        self.minheap = []\n        self.dis = [float('inf')] * self.n\n\n    def solve(self):\n        self.dis[0] = 0\n        self.minheap.append((0, 0))\n        while len(self.minheap) > 0:\n            (distance, node) = heapq.heappop(self.minheap)\n            if self.dis[node] < distance:\n                continue\n            self.vis[node] = 1\n            for (next, nextdis) in self.adj[node]:\n                if self.vis[next] == 1:\n                    continue\n                disttemp = distance + nextdis\n                if disttemp < self.dis[next]:\n                    self.dis[next] = disttemp\n                    heapq.heappush(self.minheap, (disttemp, next))\nt = RI()\nfor _ in range(t):\n    (n, m) = RW()\n    adj = [[] for i in range(n)]\n    for i in range(m):\n        (a, b) = RW()\n        a -= 1\n        b -= 1\n        adj[a].append((b, 0))\n        adj[b].append((a, 0))\n    for i in range(n - 1):\n        adj[i].append((i + 1, 1))\n        adj[i + 1].append((i, 1))\n    g = Graph(adj)\n    g.solve()\n    print(g.dis[n - 1])", "import sys\nRW = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRI = lambda : int(sys.stdin.readline().strip())\nRS = lambda : sys.stdin.readline().strip().split()\nfrom collections import OrderedDict as of\nfrom collections import defaultdict as df\nimport heapq\nimport math\nfrom math import ceil, floor\nsys.setrecursionlimit(100005)\n\nclass Graph:\n\n    def __init__(self, adj):\n        self.adj = adj\n        self.n = len(self.adj)\n        self.vis = [0] * n\n        self.minheap = []\n        self.dis = [float('inf')] * self.n\n\n    def solve(self):\n        self.dis[0] = 0\n        self.minheap.append((0, 0))\n        while len(self.minheap) > 0:\n            (distance, node) = heapq.heappop(self.minheap)\n            if self.dis[node] < distance:\n                continue\n            self.vis[node] = 1\n            for (next, nextdis) in self.adj[node]:\n                if self.vis[next] == 1:\n                    continue\n                disttemp = distance + nextdis\n                if disttemp < self.dis[next]:\n                    self.dis[next] = disttemp\n                    heapq.heappush(self.minheap, (disttemp, next))\nt = RI()\nfor _ in range(t):\n    (n, m) = RW()\n    adj = [[] for i in range(n)]\n    for i in range(m):\n        (a, b) = RW()\n        a -= 1\n        b -= 1\n        adj[a].append((b, 0))\n        adj[b].append((a, 0))\n    for i in range(n - 1):\n        adj[i].append((i + 1, 1))\n        adj[i + 1].append((i, 1))\n    g = Graph(adj)\n    g.solve()\n    print(g.dis[n - 1])", "from collections import defaultdict\nimport heapq\nimport math\nfrom math import sqrt\nfor _ in range(int(input())):\n    g = defaultdict(dict)\n    d = defaultdict(dict)\n    (n, q) = map(int, input().split())\n    for i in range(1, n):\n        g[i][i + 1] = 1\n        g[i + 1][i] = 1\n    for i in range(q):\n        (m, k) = map(int, input().split())\n        g[m][k] = 0\n        g[k][m] = 0\n    global ans\n    ans = 0\n\n    def dij():\n        h = [(0, 1)]\n        p = [float('inf') for i in range(n + 1)]\n        p[1] = 0\n        global ans\n        while h:\n            (x, y) = heapq.heappop(h)\n            if y == n:\n                ans = x\n                break\n            v[y] = True\n            for j in g[y]:\n                if v[j]:\n                    continue\n                d = x + g[y][j]\n                if d < p[j]:\n                    p[j] = d\n                    heapq.heappush(h, (d, j))\n    v = [False for i in range(n + 1)]\n    dij()\n    print(ans)", "import math, bisect, heapq, random, sys, itertools\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\np2 = [1]\nfor i in range(70):\n    p2.append(p2[-1] * 2)\np = 10 ** 9 + 7\nANS = []\ngraph = []\nvisited = []\n\ndef bfs(queue, n, x):\n    done = set()\n    while queue:\n        q = set()\n        for i in queue:\n            done.add(i)\n            for j in graph[i]:\n                if visited[j] == -1:\n                    visited[j] = x\n                    q.add(j)\n        queue = q\n    next_q = set()\n    for i in done:\n        if i - 1 >= 1 and visited[i - 1] == -1:\n            visited[i - 1] = x + 1\n            next_q.add(i - 1)\n        if i + 1 <= n and visited[i + 1] == -1:\n            visited[i + 1] = x + 1\n            next_q.add(i + 1)\n    if next_q:\n        bfs(next_q, n, x + 1)\nfor t in range(int(input())):\n    (n, m) = ints()\n    graph = [set() for i in range(n + 1)]\n    visited = [-1] * (n + 1)\n    for i in range(m):\n        (x, y) = ints()\n        graph[x].add(y)\n        graph[y].add(x)\n    visited[1] = 0\n    bfs([1], n, 0)\n    print(visited[n])", "from heapq import *\nfrom dis import dis\nimport os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nfrom random import randint\nimport re\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n    (n, m) = mp()\n    d = defaultdict(list)\n    x = [0] * (n + 1)\n    for i in range(m):\n        (a, b) = mp()\n        (a, b) = (min(a, b), max(a, b))\n        d[a].append((b, 0))\n        d[b].append((a, 0))\n        if b - a == 1:\n            x[a] = 1\n    for i in range(1, n):\n        if x[i] == 0:\n            d[i].append((i + 1, 1))\n            d[i + 1].append((i, 1))\n    h = [(0, 1)]\n    v = [0] * (n + 1)\n    dist = [INF] * (n + 1)\n    dist[1] = 0\n    while h:\n        (b, a) = heappop(h)\n        if v[a]:\n            continue\n        v[a] = 1\n        for i in d[a]:\n            if b + i[1] < dist[i[0]]:\n                dist[i[0]] = b + i[1]\n                heappush(h, (dist[i[0]], i[0]))\n    pr(dist[n])\nfor _ in range(inp()):\n    solve()", "from heapq import *\nfrom dis import dis\nimport os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nfrom random import randint\nimport re\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n    (n, m) = mp()\n    d = defaultdict(list)\n    x = [0] * (n + 1)\n    for i in range(m):\n        (a, b) = mp()\n        (a, b) = (min(a, b), max(a, b))\n        d[a].append((b, 0))\n        d[b].append((a, 0))\n        if b - a == 1:\n            x[a] = 1\n    for i in range(1, n):\n        if x[i] == 0:\n            d[i].append((i + 1, 1))\n            d[i + 1].append((i, 1))\n    h = [(0, 1)]\n    v = [0] * (n + 1)\n    dist = [INF] * (n + 1)\n    dist[1] = 0\n    while h:\n        (b, a) = heappop(h)\n        if v[a]:\n            continue\n        v[a] = 1\n        for i in d[a]:\n            if b + i[1] < dist[i[0]]:\n                dist[i[0]] = b + i[1]\n                heappush(h, (dist[i[0]], i[0]))\n    pr(dist[n])\nfor _ in range(inp()):\n    solve()", "from heapq import *\nfrom dis import dis\nimport os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nfrom random import randint\nimport re\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n    (n, m) = mp()\n    d = defaultdict(list)\n    x = [0] * (n + 1)\n    for i in range(m):\n        (a, b) = mp()\n        (a, b) = (min(a, b), max(a, b))\n        d[a].append((b, 0))\n        d[b].append((a, 0))\n        if b - a == 1:\n            x[a] = 1\n    for i in range(1, n):\n        if x[i] == 0:\n            d[i].append((i + 1, 1))\n            d[i + 1].append((i, 1))\n    h = [(0, 1)]\n    v = [0] * (n + 1)\n    dist = [INF] * (n + 1)\n    dist[1] = 0\n    while h:\n        (b, a) = heappop(h)\n        if v[a]:\n            continue\n        v[a] = 1\n        for i in d[a]:\n            if b + i[1] < dist[i[0]]:\n                dist[i[0]] = b + i[1]\n                heappush(h, (dist[i[0]], i[0]))\n    pr(dist[n])\nfor _ in range(inp()):\n    solve()", "from heapq import *\nfrom dis import dis\nimport os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nfrom random import randint\nimport re\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n    (n, m) = mp()\n    d = defaultdict(list)\n    x = [0] * (n + 1)\n    for i in range(m):\n        (a, b) = mp()\n        (a, b) = (min(a, b), max(a, b))\n        d[a].append((b, 0))\n        d[b].append((a, 0))\n        if b - a == 1:\n            x[a] = 1\n    for i in range(1, n):\n        if x[i] == 0:\n            d[i].append((i + 1, 1))\n            d[i + 1].append((i, 1))\n    q = deque()\n    q.append(1)\n    v = [0] * (n + 1)\n    dist = [INF] * (n + 1)\n    dist[1] = 0\n    while q:\n        a = q.popleft()\n        for i in d[a]:\n            if dist[a] + i[1] < dist[i[0]]:\n                dist[i[0]] = dist[a] + i[1]\n                if i[1] == 0:\n                    q.appendleft(i[0])\n                else:\n                    q.append(i[0])\n    pr(dist[n])\nfor _ in range(inp()):\n    solve()", "from heapq import *\nfrom dis import dis\nimport os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nfrom random import randint\nimport re\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n    (n, m) = mp()\n    d = defaultdict(list)\n    x = [0] * (n + 1)\n    for i in range(m):\n        (a, b) = mp()\n        (a, b) = (min(a, b), max(a, b))\n        d[a].append((b, 0))\n        d[b].append((a, 0))\n        if b - a == 1:\n            x[a] = 1\n    for i in range(1, n):\n        if x[i] == 0:\n            d[i].append((i + 1, 1))\n            d[i + 1].append((i, 1))\n    h = [(0, 1)]\n    v = [0] * (n + 1)\n    dist = [INF] * (n + 1)\n    dist[1] = 0\n    while h:\n        (b, a) = heappop(h)\n        if v[a]:\n            continue\n        v[a] = 1\n        for i in d[a]:\n            if b + i[1] < dist[i[0]]:\n                dist[i[0]] = b + i[1]\n                heappush(h, (dist[i[0]], i[0]))\n    pr(dist[n])\nfor _ in range(inp()):\n    solve()", "from heapq import heappop, heappush\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [set() for _ in range(n)]\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        graph[a].add(b)\n        graph[b].add(a)\n    q = [0]\n    seen = set()\n    while q:\n        node = q.pop()\n        seen.add(node)\n        for nie in graph[node]:\n            if nie not in seen:\n                q.append(nie)\n    q = [(0, n - 1)]\n    p = {}\n    while q:\n        (cost, node) = heappop(q)\n        if node in seen:\n            print(cost)\n            break\n        for nie in graph[node]:\n            if nie not in p or p[nie] > cost:\n                heappush(q, (cost, nie))\n                p[nie] = cost\n        nie = node - 1\n        if nie not in graph[node]:\n            if nie not in p or p[nie] > cost + 1:\n                heappush(q, (cost + 1, nie))\n                p[nie] = cost + 1\n        nie = node + 1\n        if nie < n:\n            if nie not in graph[node]:\n                if nie not in p or p[nie] > cost + 1:\n                    heappush(q, (cost + 1, nie))\n                    p[nie] = cost + 1", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nfrom random import randint\nimport re\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n\n    def find(a):\n        x = []\n        while a != par[a]:\n            x.append(a)\n            a = par[a]\n        for i in x:\n            par[i] = a\n        return a\n\n    def union(a, b):\n        a = find(a)\n        b = find(b)\n        if a != b:\n            par[a] = b\n    (n, m) = mp()\n    par = {i: i for i in range(1, n + 1)}\n    for i in range(m):\n        (a, b) = mp()\n        union(a, b)\n    x = defaultdict(list)\n    for i in range(1, n + 1):\n        x[find(i)].append(i)\n    cur = [0] * (n + 1)\n    c = 1\n    for i in x:\n        for j in x[i]:\n            cur[j] = c\n        c += 1\n    d = defaultdict(list)\n    for i in range(1, n):\n        d[cur[i]].append(cur[i + 1])\n        d[cur[i + 1]].append(cur[i])\n    dist = [INF] * (c + 1)\n    dist[1] = 0\n    q = deque()\n    q.append(1)\n    while q:\n        a = q.popleft()\n        for i in d[a]:\n            if dist[i] == INF:\n                q.append(i)\n                dist[i] = dist[a] + 1\n    pr(dist[cur[n]])\nfor _ in range(inp()):\n    solve()", "from heapq import heappop, heappush\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [set() for _ in range(n)]\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        graph[a].add(b)\n        graph[b].add(a)\n    q = [0]\n    seen = set()\n    while q:\n        node = q.pop()\n        seen.add(node)\n        for nie in graph[node]:\n            if nie not in seen:\n                q.append(nie)\n    q = [(0, n - 1)]\n    p = {}\n    while q:\n        (cost, node) = heappop(q)\n        if node in seen:\n            print(cost)\n            break\n        for nie in graph[node]:\n            if nie not in p or p[nie] > cost:\n                heappush(q, (cost, nie))\n                p[nie] = cost\n        nie = node - 1\n        if nie not in graph[node]:\n            if nie not in p or p[nie] > cost + 1:\n                heappush(q, (cost + 1, nie))\n                p[nie] = cost + 1\n        nie = node + 1\n        if nie < n:\n            if nie not in graph[node]:\n                if nie not in p or p[nie] > cost + 1:\n                    heappush(q, (cost + 1, nie))\n                    p[nie] = cost + 1", "from sys import stdin\ninput = stdin.readline\nimport heapq\n\ndef answer():\n    ans = [float('inf') for i in range(n + 1)]\n    ans[1] = 0\n    v = [False for i in range(n + 1)]\n    q = [[0, 1]]\n    while len(q):\n        (val, p) = heapq.heappop(q)\n        if v[p]:\n            continue\n        v[p] = True\n        for x in edges[p]:\n            if ans[x[0]] > ans[p] + x[1]:\n                ans[x[0]] = ans[p] + x[1]\n                heapq.heappush(q, [ans[x[0]], x[0]])\n    return ans[n]\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    edges = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        edges[u].append([v, 0])\n        edges[v].append([u, 0])\n    for i in range(1, n):\n        edges[i].append([i + 1, 1])\n        edges[i + 1].append([i, 1])\n    print(answer())", "from sys import stdin\ninput = stdin.readline\nimport heapq\n\ndef answer():\n    ans = [float('inf') for i in range(n + 1)]\n    ans[1] = 0\n    v = [False for i in range(n + 1)]\n    q = [[0, 1]]\n    while len(q):\n        (val, p) = heapq.heappop(q)\n        if v[p]:\n            continue\n        v[p] = True\n        for x in edges[p]:\n            if ans[x[0]] > ans[p] + x[1]:\n                ans[x[0]] = ans[p] + x[1]\n                heapq.heappush(q, [ans[x[0]], x[0]])\n    return ans[n]\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    edges = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        edges[u].append([v, 0])\n        edges[v].append([u, 0])\n    for i in range(1, n):\n        edges[i].append([i + 1, 1])\n        edges[i + 1].append([i, 1])\n    print(answer())", "import sys\nimport math\nfrom collections import defaultdict\nimport heapq\n\nclass DisjointSet:\n\n    def __init__(self, n):\n        self.parent = []\n        for i in range(n):\n            self.parent.append(i)\n\n    def find(self, node):\n        if node != self.parent[node]:\n            self.parent[node] = self.find(self.parent[node])\n        return self.parent[node]\n\n    def union(self, u, v):\n        leader_u = self.find(u)\n        leader_v = self.find(v)\n        if leader_v != leader_u:\n            self.parent[leader_u] = leader_v\n\nclass Graph:\n\n    def __init__(self):\n        self.neighbours = defaultdict(list)\n\n    def addEdge(self, u, v, cost):\n        self.neighbours[u].append([v, cost])\n        self.neighbours[v].append([u, cost])\n\n    def dijkstra(self, source, n):\n        distance = defaultdict(lambda : float('inf'))\n        visited = defaultdict(lambda : False)\n        distance[source] = 0\n        pq = [[0, source, 0]]\n        heapq.heapify(pq)\n        shortest_path_tree = defaultdict(lambda : float('inf'))\n        shortest_path_tree[0] = 0\n        while pq:\n            (d, u, lastAdded) = heapq.heappop(pq)\n            for (v, c) in self.neighbours[u]:\n                if distance[v] > d + c:\n                    distance[v] = d + c\n                    shortest_path_tree[v] = c\n                    heapq.heappush(pq, [distance[v], v, c])\n                if distance[v] == d + c:\n                    if c < shortest_path_tree[v]:\n                        distance[v] = d + c\n                        shortest_path_tree[v] = c\n                        heapq.heappush(pq, [distance[v], v, c])\n        return distance\nfor some_random_name in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = {}\n    for i in range(n - 1):\n        d[i + 1, i + 2] = 1\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        d[x, y] = 0\n    g = Graph()\n    for i in d:\n        g.addEdge(i[0], i[1], d[i])\n    distance = g.dijkstra(1, n)\n    print(distance[n])"]