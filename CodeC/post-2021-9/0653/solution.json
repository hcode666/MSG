["from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(3 * 10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev, t):\n    if dp[p][t] != -1:\n        return dp[p][t]\n    best = []\n    for i in child[p]:\n        if i == prev:\n            continue\n        (tv1, tv2) = (dfs(i, p, 0), dfs(i, p, 1))\n        best.append([tv1 - tv2, tv1, tv2])\n    best.sort()\n    ans = 0\n    if t == 0:\n        counter = 2\n        while len(best) and counter:\n            counter -= 1\n            (diff, tv1, tv2) = best.pop()\n            ans += tv2\n        while len(best):\n            (diff, tv1, tv2) = best.pop()\n            ans += tv1 + 1\n    else:\n        counter = 1\n        while len(best) and counter:\n            counter -= 1\n            (diff, tv1, tv2) = best.pop()\n            ans += tv2\n        while len(best):\n            (diff, tv1, tv2) = best.pop()\n            ans += tv1 + 1\n    dp[p][t] = ans\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    dp = [[-1, -1] for i in range(n + 1)]\n    print(dfs(1, -1, 0))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(3 * 10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev, t):\n    if dp[p][t] != -1:\n        return dp[p][t]\n    best = []\n    for i in child[p]:\n        if i == prev:\n            continue\n        (tv1, tv2) = (dfs(i, p, 0), dfs(i, p, 1))\n        best.append([tv1 - tv2, tv1, tv2])\n    best.sort()\n    ans = 0\n    if t == 0:\n        counter = 2\n        while len(best) and counter:\n            counter -= 1\n            (diff, tv1, tv2) = best.pop()\n            ans += tv2\n        while len(best):\n            (diff, tv1, tv2) = best.pop()\n            ans += tv1 + 1\n    else:\n        counter = 1\n        while len(best) and counter:\n            counter -= 1\n            (diff, tv1, tv2) = best.pop()\n            ans += tv2\n        while len(best):\n            (diff, tv1, tv2) = best.pop()\n            ans += tv1 + 1\n    dp[p][t] = ans\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    dp = [[-1, -1] for i in range(n + 1)]\n    print(dfs(1, -1, 0))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(3 * 10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev, t):\n    if dp[p][t] != -1:\n        return dp[p][t]\n    best = []\n    for i in child[p]:\n        if i == prev:\n            continue\n        (tv1, tv2) = (dfs(i, p, 0), dfs(i, p, 1))\n        best.append([tv1 - tv2, tv1, tv2])\n    best.sort()\n    ans = 0\n    if t == 0:\n        counter = 2\n        while len(best) and counter:\n            counter -= 1\n            (diff, tv1, tv2) = best.pop()\n            ans += tv2\n        while len(best):\n            (diff, tv1, tv2) = best.pop()\n            ans += tv1 + 1\n    else:\n        counter = 1\n        while len(best) and counter:\n            counter -= 1\n            (diff, tv1, tv2) = best.pop()\n            ans += tv2\n        while len(best):\n            (diff, tv1, tv2) = best.pop()\n            ans += tv1 + 1\n    dp[p][t] = ans\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    dp = [[-1, -1] for i in range(n + 1)]\n    print(dfs(1, -1, 0))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(3 * 10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev, t):\n    if dp[p][t] != -1:\n        return dp[p][t]\n    best = []\n    for i in child[p]:\n        if i == prev:\n            continue\n        (tv1, tv2) = (dfs(i, p, 0), dfs(i, p, 1))\n        best.append([tv1 - tv2, tv1, tv2])\n    best.sort()\n    ans = 0\n    if t == 0:\n        counter = 2\n        while len(best) and counter:\n            counter -= 1\n            (diff, tv1, tv2) = best.pop()\n            ans += tv2\n        while len(best):\n            (diff, tv1, tv2) = best.pop()\n            ans += tv1 + 1\n    else:\n        counter = 1\n        while len(best) and counter:\n            counter -= 1\n            (diff, tv1, tv2) = best.pop()\n            ans += tv2\n        while len(best):\n            (diff, tv1, tv2) = best.pop()\n            ans += tv1 + 1\n    dp[p][t] = ans\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = inp()\n        child[u].append(v)\n        child[v].append(u)\n    dp = [[-1, -1] for i in range(n + 1)]\n    print(dfs(1, -1, 0))"]