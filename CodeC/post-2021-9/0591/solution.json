["N = 1001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nt = int(input())\nfor tt in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    aa = [0] * n\n    p1 = 0\n    q1 = 0\n    for r in range(n):\n        if a[r] != 0:\n            aa[a[r] - 1] = 1\n    for rr in range(n):\n        if a[rr] == 0:\n            if aa[rr] == 0:\n                q1 += 1\n            else:\n                p1 += 1\n    if p1 == 0 and q1 == 0:\n        print(0)\n        continue\n    ans = fact[p1 + q1]\n    if q1 == 0:\n        print(ans)\n        continue\n    for rrr in range(1, q1 + 1):\n        if rrr & 1 == 0:\n            ans = (ans + Binomial(q1, rrr, p) * fact[p1 + q1 - rrr] % p) % p\n        else:\n            ans = (ans - Binomial(q1, rrr, p) * fact[p1 + q1 - rrr] % p) % p\n    print(ans)", "N = 1001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nt = int(input())\nfor tt in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    aa = [0] * n\n    p1 = 0\n    q1 = 0\n    for r in range(n):\n        if a[r] != 0:\n            aa[a[r] - 1] = 1\n    for rr in range(n):\n        if a[rr] == 0:\n            if aa[rr] == 0:\n                q1 += 1\n            else:\n                p1 += 1\n    if p1 == 0 and q1 == 0:\n        print(0)\n        continue\n    ans = fact[p1 + q1]\n    if q1 == 0:\n        print(ans)\n        continue\n    for rrr in range(1, q1 + 1):\n        if rrr & 1 == 0:\n            ans = (ans + Binomial(q1, rrr, p) * fact[p1 + q1 - rrr] % p) % p\n        else:\n            ans = (ans - Binomial(q1, rrr, p) * fact[p1 + q1 - rrr] % p) % p\n    print(ans)", "N = 1000\nmod = 10 ** 9 + 7\nfact = [1 for i in range(N + 1)]\ninv = [1 for i in range(N + 1)]\nval = 1\nfor i in range(1, N + 1):\n    val = val * i % mod\n    fact[i] = val\n    inv[i] = pow(fact[i], mod - 2, mod)\n\ndef nCr(n, r):\n    return fact[n] * inv[r] * inv[n - r] % mod\np = 10 ** 9 + 7\nt = int(input())\nfor tt in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    aa = [0] * n\n    p1 = 0\n    q1 = 0\n    for r in range(n):\n        if a[r] != 0:\n            aa[a[r] - 1] = 1\n    for rr in range(n):\n        if a[rr] == 0:\n            if aa[rr] == 0:\n                q1 += 1\n            else:\n                p1 += 1\n    if p1 == 0 and q1 == 0:\n        print(0)\n        continue\n    ans = fact[p1 + q1]\n    for rrr in range(1, q1 + 1):\n        if rrr & 1 == 0:\n            ans = (ans + nCr(q1, rrr) * fact[p1 + q1 - rrr] % p) % p\n        else:\n            ans = (ans - nCr(q1, rrr) * fact[p1 + q1 - rrr] % p) % p\n    print(ans)", "import math, sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfact = [1] * 10000\nfor i in range(1, 10000):\n    fact[i] = fact[i - 1] * i % mod1\nfor _ in range(I()):\n    n = I()\n    a = L()\n    s1 = set()\n    s2 = set()\n    s3 = set()\n    if 0 not in a:\n        print(0)\n        continue\n    for i in range(n):\n        if a[i] == 0:\n            s1.add(i + 1)\n        else:\n            s2.add(a[i])\n    for i in range(1, n + 1):\n        if i not in s2:\n            s3.add(i)\n    k = len(s1 & s3)\n    t = len(s1)\n    ans = fact[t]\n    for i in range(1, k + 1):\n        p = fact[k] * pow(fact[k - i], mod1 - 2, mod1) * pow(fact[i], mod1 - 2, mod1) * fact[t - i] % mod1\n        if i % 2 == 1:\n            ans = (ans - p) % mod1\n        else:\n            ans = (ans + p) % mod1\n    print(ans)"]