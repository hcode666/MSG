["import heapq\nfor _ in range(int(input())):\n    number = int(input())\n    eff = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    heap = []\n    tempheap = []\n    ans = 0\n    realans = [0.0]\n    k = 1\n    for i in range(number):\n        heapq.heappush(heap, [b[i], eff[i]])\n    condition1 = True\n    while tempheap or (condition1 and heap[0][0] < k):\n        condition = True\n        if not heap:\n            condition = False\n        while condition and heap[0][0] == k - 1:\n            mn = heapq.heappop(heap)\n            heapq.heappush(tempheap, [-mn[1], mn[0]])\n            if not heap:\n                condition = False\n        if not heap:\n            condition1 = False\n        m = heapq.heappop(tempheap)\n        ans = ans + -m[0]\n        realans.append(ans / k)\n        k += 1\n    print(max(realans))", "import heapq\nfor _ in range(int(input())):\n    number = int(input())\n    eff = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    heap = []\n    tempheap = []\n    ans = 0\n    realans = [0.0]\n    k = 1\n    for i in range(number):\n        heapq.heappush(heap, [b[i], eff[i]])\n    condition1 = True\n    while tempheap or (condition1 and heap[0][0] < k):\n        condition = True\n        if not heap:\n            condition = False\n        while condition and heap[0][0] == k - 1:\n            mn = heapq.heappop(heap)\n            heapq.heappush(tempheap, [-mn[1], mn[0]])\n            if not heap:\n                condition = False\n        if not heap:\n            condition1 = False\n        m = heapq.heappop(tempheap)\n        ans = ans + -m[0]\n        realans.append(ans / k)\n        k += 1\n    print(max(realans))", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = []\n    for _ in range(n):\n        arr.append([])\n    for (x, y) in zip(a, b):\n        arr[y].append(x)\n    heap = []\n    score = 0\n    sm = 0\n    ni = 0\n    i = 0\n    while i < n:\n        for task in arr[i]:\n            heappush(heap, -task)\n        if len(heap) == 0:\n            break\n        val = -heappop(heap)\n        sm += val\n        ni += 1\n        score = max(score, sm / ni)\n        i += 1\n    print(score)", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = []\n    for _ in range(n):\n        arr.append([])\n    for (x, y) in zip(a, b):\n        arr[y].append(x)\n    heap = []\n    score = 0\n    sm = 0\n    ni = 0\n    i = 0\n    while i < n:\n        for task in arr[i]:\n            heappush(heap, -task)\n        if len(heap) == 0:\n            break\n        val = -heappop(heap)\n        sm += val\n        ni += 1\n        score = max(score, sm / ni)\n        i += 1\n    print(score)", "import sys, os.path\nif os.path.exists('input.txt'):\n    sys.stdout = open('output.txt', 'w')\n    sys.stdin = open('input.txt', 'r')\n\ndef solve(n, eff, preq):\n    from heapq import heapify, heappop as pop, heappush as push\n    tasks = {}\n    for (e, p) in zip(eff, preq):\n        tasks[p] = tasks.get(p, [])\n        tasks[p].append(e)\n    if 0 not in tasks:\n        return 0\n    res = 0\n    total = 0\n    done = 0\n    heap = [-val for val in tasks[0]]\n    heapify(heap)\n    while heap:\n        val = -pop(heap)\n        total += val\n        done += 1\n        res = max(res, total / done)\n        if done in tasks:\n            for x in tasks[done]:\n                push(heap, -x)\n    return res\n\ndef main():\n    sys.setrecursionlimit(10 ** 8)\n    for _ in range(int(input())):\n        n = int(input())\n        eff = [int(val) for val in input().split()]\n        preq = [int(val) for val in input().split()]\n        result = solve(n, eff, preq)\n        print(result)\nmain()", "import heapq\nt = int(input())\nfor _ in range(t):\n    pq = []\n    n = int(input())\n    arr = list(map(int, input().split()))\n    brr = list(map(int, input().split()))\n    crr = []\n    for _ in range(n):\n        crr.append([])\n    for i in range(n):\n        (a, b) = (arr[i], brr[i])\n        crr[b].append(a)\n    ans = 0\n    sumation = 0\n    for i in range(n):\n        for val in crr[i]:\n            heapq.heappush(pq, -val)\n        if len(pq) == 0:\n            break\n        sumation -= heapq.heappop(pq)\n        if sumation / (i + 1) > ans:\n            ans = sumation / (i + 1)\n    print(ans)", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = [[] for i in range(n)]\n    for i in range(n):\n        arr[b[i]].append(a[i])\n    ans = 0\n    sum = 0\n    heap = []\n    for i in range(n):\n        for j in arr[i]:\n            heapq.heappush(heap, -j)\n        if not heap:\n            break\n        sum += -heapq.heappop(heap)\n        ans = max(ans, sum / (i + 1))\n    print(ans)", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = [[] for i in range(n)]\n    for i in range(n):\n        arr[b[i]].append(a[i])\n    ans = 0\n    sum = 0\n    heap = []\n    for i in range(n):\n        for j in arr[i]:\n            heapq.heappush(heap, -j)\n        if not heap:\n            break\n        sum += -heapq.heappop(heap)\n        ans = max(ans, sum / (i + 1))\n    print(ans)", "import heapq\n\ndef prepare_split_tasks(num, a1, a2):\n    tasks = [[] for x in range(num)]\n    for j in range(num):\n        tasks[a2[j]].append(a1[j] * -1)\n    return tasks\nt = int(input().strip())\nwhile t > 0:\n    t -= 1\n    n = int(input().strip())\n    arr1 = list(map(int, input().strip().split()))\n    arr2 = list(map(int, input().strip().split()))\n    split_tasks = prepare_split_tasks(n, arr1, arr2)\n    max_value = 0\n    value = 0\n    cnt = 0\n    tasks_in_consideration = split_tasks[0]\n    heapq.heapify(tasks_in_consideration)\n    for i in range(n):\n        if len(tasks_in_consideration) == 0:\n            break\n        task = heapq.heappop(tasks_in_consideration)\n        value = value + task * -1\n        cnt += 1\n        if value / cnt > max_value:\n            max_value = value / cnt\n        if i < n - 1:\n            for x in split_tasks[i + 1]:\n                heapq.heappush(tasks_in_consideration, x)\n    print(max_value)", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n    dic = {}\n    for (i, a) in enumerate(A):\n        if B[i] in dic:\n            dic[B[i]].append(a)\n        else:\n            dic[B[i]] = [a]\n    heap = []\n    (sm, ans) = (0, 0)\n    for i in range(N):\n        if i in dic:\n            for d in dic[i]:\n                heappush(heap, -d)\n        if not heap:\n            break\n        sm += -heappop(heap)\n        ans = max(ans, sm / (i + 1))\n    print(ans)", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n    dic = {}\n    for (i, a) in enumerate(A):\n        if B[i] in dic:\n            dic[B[i]].append(a)\n        else:\n            dic[B[i]] = [a]\n    heap = []\n    (sm, ans) = (0, 0)\n    for i in range(N):\n        if i in dic:\n            for d in dic[i]:\n                heappush(heap, -d)\n        if not heap:\n            break\n        sm += -heappop(heap)\n        ans = max(ans, sm / (i + 1))\n    print(ans)", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    h = []\n    totalA = 0\n    bestAverage = 0\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    programs = [(a[i], b[i]) for i in range(n)]\n    programs = sorted(programs, key=lambda x: x[1])\n    numUsed = 0\n    j = 0\n    if programs[0][1] > 0:\n        print(0)\n        continue\n    while True:\n        while j < n:\n            if programs[j][1] <= numUsed:\n                heappush(h, -programs[j][0])\n                j += 1\n            else:\n                break\n        if h:\n            nextProgram = -heappop(h)\n            totalA += nextProgram\n            numUsed += 1\n            bestAverage = max(bestAverage, totalA / float(numUsed))\n        else:\n            break\n    print(bestAverage)", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = []\n    for _ in range(n):\n        arr.append([])\n    for (x, y) in zip(a, b):\n        arr[y].append(x)\n    heap = []\n    i = 0\n    ni = 0\n    sm = 0\n    score = 0\n    while i < n:\n        for task in arr[i]:\n            heappush(heap, -task)\n        if len(heap) == 0:\n            break\n        val = -heappop(heap)\n        sm += val\n        ni += 1\n        score = max(score, sm / ni)\n        i += 1\n    print(score)", "from queue import PriorityQueue\nq = PriorityQueue()\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = dict()\n    b = list(map(int, input().split()))\n    for i in range(n):\n        if b[i] not in d:\n            d[b[i]] = [a[i]]\n        else:\n            d[b[i]].append(a[i])\n    qu = PriorityQueue()\n    s = 0\n    ma = 0\n    i = 0\n    c = 0\n    if 0 not in d:\n        print(0)\n    else:\n        for j in d[i]:\n            qu.put(-1 * j)\n        while qu.qsize() > 0:\n            s += -1 * qu.get()\n            c += 1\n            avg = s / c\n            if avg > ma:\n                ma = avg\n            i += 1\n            if i in d:\n                for j in d[i]:\n                    qu.put(-1 * j)\n        print(ma)", "import heapq\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    dic = defaultdict(list)\n    for i in range(n):\n        dic[b[i]].append(a[i])\n    count = 0\n    last_push = -1\n    l = []\n    curr_max = 0\n    mean = 0\n    while count < n + 1:\n        while last_push < count:\n            last_push += 1\n            for i in dic[last_push]:\n                heapq.heappush(l, -1 * i)\n        if len(l) == 0:\n            break\n        else:\n            mean = mean * count + -1 * heapq.heappop(l)\n            count += 1\n            mean = mean / count\n            curr_max = max(mean, curr_max)\n    print(round(curr_max, 6))", "import heapq\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    dic = defaultdict(list)\n    for i in range(n):\n        dic[b[i]].append(a[i])\n    count = 0\n    last_push = -1\n    l = []\n    curr_max = 0\n    mean = 0\n    while count < n + 1:\n        while last_push < count:\n            last_push += 1\n            for i in dic[last_push]:\n                heapq.heappush(l, -1 * i)\n        if len(l) == 0:\n            break\n        else:\n            mean = mean * count + -1 * heapq.heappop(l)\n            count += 1\n            mean = mean / count\n            curr_max = max(mean, curr_max)\n    print(round(curr_max, 6))", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().lstrip().split()))\n    b = list(map(int, input().lstrip().split()))\n    li = []\n    for i in range(n):\n        li.append([])\n    for (x, y) in zip(a, b):\n        li[y].append(x)\n    heap = []\n    i = 0\n    score = 0\n    total = 0\n    count = 0\n    while i < n:\n        for j in li[i]:\n            heappush(heap, -j)\n        if len(heap) == 0:\n            break\n        val = -heappop(heap)\n        score += val\n        count += 1\n        total = max(total, score / count)\n        i += 1\n    print(total)", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().lstrip().split()))\n    b = list(map(int, input().lstrip().split()))\n    li = []\n    for i in range(n):\n        li.append([])\n    for (x, y) in zip(a, b):\n        li[y].append(x)\n    heap = []\n    i = 0\n    score = 0\n    total = 0\n    count = 0\n    while i < n:\n        for j in li[i]:\n            heappush(heap, -j)\n        if len(heap) == 0:\n            break\n        val = -heappop(heap)\n        score += val\n        count += 1\n        total = max(total, score / count)\n        i += 1\n    print(total)", "import heapq\nfor _ in range(int(input())):\n    N = int(input())\n    Q = list(map(int, input().split()))\n    R = list(map(int, input().split()))\n    dic = {}\n    for i in range(N):\n        if R[i] in dic:\n            dic[R[i]].append(Q[i])\n        else:\n            dic[R[i]] = [Q[i]]\n    li = []\n    mx = 0\n    sm = 0\n    cnt = 0\n    idx = 0\n    while True:\n        if idx in dic:\n            for i in dic[idx]:\n                heapq.heappush(li, -i)\n        idx += 1\n        if len(li) == 0:\n            break\n        eff = -heapq.heappop(li)\n        sm += eff\n        cnt += 1\n        mx = max(mx, sm / cnt)\n    print(mx)", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = []\n    for _ in range(n):\n        arr.append([])\n    for (x, y) in zip(a, b):\n        arr[y].append(x)\n    heap = []\n    i = 0\n    score = 0\n    sm = 0\n    ni = 0\n    while i < n:\n        for task in arr[i]:\n            heappush(heap, -task)\n        if len(heap) == 0:\n            break\n        val = -heappop(heap)\n        sm += val\n        ni += 1\n        score = max(score, sm / ni)\n        i += 1\n    print(score)", "import heapq\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    dic = {}\n    for i in range(N):\n        if B[i] in dic:\n            dic[B[i]].append(A[i])\n        else:\n            dic[B[i]] = [A[i]]\n    li = []\n    mx = 0\n    sm = 0\n    cnt = 0\n    idx = 0\n    while True:\n        if idx in dic:\n            for i in dic[idx]:\n                heapq.heappush(li, -i)\n        idx += 1\n        if len(li) == 0:\n            break\n        eff = -heapq.heappop(li)\n        sm += eff\n        cnt += 1\n        mx = max(mx, sm / cnt)\n    print(mx)", "from heapq import *\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = []\n    for _ in range(n):\n        arr.append([])\n    for (x, y) in zip(a, b):\n        arr[y].append(x)\n    heap = []\n    sm = 0\n    score = 0\n    ni = 0\n    i = 0\n    while i < n:\n        for task in arr[i]:\n            heappush(heap, -task)\n        if len(heap) == 0:\n            break\n        val = -heappop(heap)\n        sm += val\n        ni += 1\n        score = max(score, sm / ni)\n        i += 1\n    print(score)", "from heapq import *\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = []\n    for _ in range(n):\n        arr.append([])\n    for (x, y) in zip(a, b):\n        arr[y].append(x)\n    i = 0\n    heap = []\n    sum = 0\n    score = 0\n    while i < n:\n        for task in arr[i]:\n            heappush(heap, -task)\n        if len(heap) == 0:\n            break\n        val = -heappop(heap)\n        sum += val\n        i += 1\n        score = max(score, sum / i)\n    print(score)\n    t -= 1", "import heapq\nfor t in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    curr = list()\n    heapq.heapify(curr)\n    new = []\n    for i in range(N):\n        new.append((A[i], B[i]))\n\n    def cmp(x):\n        return x[-1]\n    new.sort(key=cmp)\n    j = 0\n    ans = 0\n    currans = 0\n    for k in range(1, N + 1):\n        while j < N and new[j][-1] < k:\n            heapq.heappush(curr, -new[j][0])\n            j += 1\n        if len(curr) == 0:\n            break\n        currans += -heapq.heappop(curr)\n        ans = max(ans, currans / k)\n    print(ans)", "import heapq as hp\ntest = int(input())\nwhile test:\n    n = int(input())\n    a = input().split()\n    b = input().split()\n    c = []\n    for i in range(n):\n        c.append([])\n    l = 0\n    while l < n:\n        c[int(b[l])].append(int(a[l]))\n        l += 1\n    heap = []\n    hp.heapify(heap)\n    ans = cthelp = 0\n    count = 0\n    for i in c:\n        for k in i:\n            hp.heappush(heap, -k)\n        if len(heap) == 0:\n            break\n        else:\n            count += 1\n            cthelp += -1 * hp.heappop(heap)\n        ans = max(ans, cthelp / count)\n    print(ans)\n    test -= 1", "from heapq import *\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    A = [int(_) for _ in input().split()]\n    B = [int(_) for _ in input().split()]\n    arr = [[] for _ in range(n)]\n    for i in range(n):\n        arr[B[i]].append(A[i])\n    heap = []\n    i = addn = ans = 0\n    while i < n:\n        for task in arr[i]:\n            heappush(heap, -task)\n        if len(heap) == 0:\n            break\n        eff = -heappop(heap)\n        addn += eff\n        ans = max(ans, addn / (i + 1))\n        i += 1\n    print(ans)", "import math\nimport bisect\nimport heapq\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as ddc\nfrom collections import Counter\n\ndef intin():\n    return int(input())\n\ndef mapin():\n    return map(int, input().split())\n\ndef strin():\n    return input().split()\nINF = 10 ** 20\nmod = 1000000007\n\ndef exponentiation(bas, exp, mod=1000000007):\n    t = 1\n    while exp > 0:\n        if exp % 2 != 0:\n            t = t * bas % mod\n        bas = bas * bas % mod\n        exp //= 2\n    return t % mod\n\ndef MOD(p, q=1, mod=1000000007):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n\ndef process(A, B, N):\n    Dict = ddc(list)\n    for i in range(N):\n        Dict[B[i]].append(A[i])\n    Q = []\n    (curr, done, Max) = (0, 0, 0)\n    for i in range(N):\n        for ele in Dict[i]:\n            heapq.heappush(Q, -ele)\n        if not Q:\n            break\n        curr += -heapq.heappop(Q)\n        done += 1\n        Max = max(Max, curr / done)\n    return Max\n\ndef main():\n    for _ in range(int(input())):\n        N = intin()\n        A = list(mapin())\n        B = list(mapin())\n        print(process(A, B, N))\nmain()", "from collections import Counter, defaultdict, deque\nimport itertools\nimport re\nimport math\nfrom functools import reduce\nimport operator\nimport bisect\nimport heapq\nimport functools\nmod = 10 ** 9 + 7\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    tr = [[] for _ in range(n)]\n    for i in range(n):\n        tr[b[i]].append(a[i])\n    ans = 0\n    su = 0\n    heap = []\n    for i in range(n):\n        for j in tr[i]:\n            heapq.heappush(heap, -j)\n        if not heap:\n            break\n        su += -heapq.heappop(heap)\n        ans = max(ans, su / (i + 1))\n    print(ans)", "import heapq\nfor _ in range(int(input())):\n    numberOfSessions = int(input())\n    efficiencySessionList = list(map(int, input().split()))\n    sessionsRequiredList = list(map(int, input().split()))\n    mappedEfficiencyRequired = [(sessionsRequiredList[i], i) for i in range(numberOfSessions)]\n    mappedEfficiencyRequired.sort(reverse=True)\n    heap = []\n    highestScore = sumVal = 0\n    for minK in range(numberOfSessions):\n        while mappedEfficiencyRequired and mappedEfficiencyRequired[-1][0] <= minK:\n            index = mappedEfficiencyRequired[-1][1]\n            mappedEfficiencyRequired.pop()\n            heapq.heappush(heap, -efficiencySessionList[index])\n        if heap:\n            sumVal += -heapq.heappop(heap)\n            highestScore = max(highestScore, sumVal / (minK + 1))\n        else:\n            break\n    print('{:.6f}'.format(highestScore))", "import heapq\nfor _ in range(int(input())):\n    numberOfSessions = int(input())\n    efficiencySessionList = list(map(int, input().split()))\n    sessionsRequiredList = list(map(int, input().split()))\n    mappedEfficiencyRequired = [(sessionsRequiredList[i], i) for i in range(numberOfSessions)]\n    mappedEfficiencyRequired.sort(reverse=True)\n    heap = []\n    highestScore = sumVal = 0\n    for minK in range(numberOfSessions):\n        while mappedEfficiencyRequired and mappedEfficiencyRequired[-1][0] <= minK:\n            index = mappedEfficiencyRequired[-1][1]\n            mappedEfficiencyRequired.pop()\n            heapq.heappush(heap, -efficiencySessionList[index])\n        if heap:\n            sumVal += -heapq.heappop(heap)\n            highestScore = max(highestScore, sumVal / (minK + 1))\n        else:\n            break\n    print('{:.6f}'.format(highestScore))", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    nums = sorted(zip(b, a))\n    heap = []\n    (ans, temp, count) = (0.0, 0, 0)\n    (i, j) = (0, 0)\n    while j < n:\n        while i < n and nums[i][0] <= j:\n            heapq.heappush(heap, -1 * nums[i][1])\n            i += 1\n        if heap:\n            temp += -1 * heapq.heappop(heap)\n            count += 1\n            ans = max(ans, temp / count)\n            j += 1\n        else:\n            break\n    print('%.6f' % ans)", "import heapq\nimport numpy as np\ntc = int(input())\nwhile tc:\n    tc -= 1\n    n = int(input())\n    A = np.array(list(map(float, input().strip().split())))\n    B = np.array(list(map(int, input().strip().split())))\n    arr = [[] for _ in range(n)]\n    for (a, b) in zip(A, B):\n        arr[b].append(a)\n    li = []\n    i = 0\n    score = 0\n    sm = 0\n    ni = 0\n    while i < n:\n        for k in arr[i]:\n            heapq.heappush(li, -k)\n        if len(li) == 0:\n            break\n        v = -heapq.heappop(li)\n        sm += v\n        ni += 1\n        score = max(score, sm / ni)\n        i += 1\n    print(score)", "import sys\nimport math\nfrom collections import defaultdict, Counter, deque\nfrom bisect import *\nfrom string import ascii_lowercase\nfrom heapq import *\n\ndef readInts():\n    x = list(map(int, sys.stdin.readline().rstrip().split()))\n    return x[0] if len(x) == 1 else x\n\ndef readList(type=int):\n    x = sys.stdin.readline()\n    x = list(map(type, x.rstrip('\\n\\r').split()))\n    return x\n\ndef readStr():\n    x = sys.stdin.readline().rstrip('\\r\\n')\n    return x\nwrite = sys.stdout.write\nread = sys.stdin.readline\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef mergeSort(arr, check=lambda a, b: a < b, reverse=False):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        mergeSort(L, check, reverse)\n        mergeSort(R, check, reverse)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if check(L[i], R[j]):\n                if not reverse:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n            elif not reverse:\n                arr[k] = R[j]\n                j += 1\n            else:\n                arr[k] = L[i]\n                i += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\ndef maxSum(arr):\n    max_sum = float('-inf')\n    max_cur = 0\n    for num in ar:\n        max_cur = max(max_cur + num, num)\n        if max_cur > max_sum:\n            max_sum = max_cur\n    return max_sum\n\ndef hfc(a, b):\n    if b == 0:\n        return a\n    else:\n        return hcf(b, b % a)\n\ndef get_power(n, m):\n    i = 1\n    p = -1\n    while i <= n:\n        i = i * m\n        p += 1\n    return p\n\ndef fact(n):\n    f = 1\n    for i in range(2, n + 1):\n        f *= i\n    return f\n\ndef solve(t):\n    n = readInts()\n    ar1 = readList()\n    ar2 = readList()\n    dic = {}\n    k = 0\n    res = 0\n    for i in range(n):\n        num = ar2[i]\n        if num in dic:\n            dic[num].append(ar1[i])\n        else:\n            dic[num] = [ar1[i]]\n    heap = []\n    heapify(heap)\n    max_sum = 0\n    for i in range(n):\n        if i in dic and len(dic[i]) > 0:\n            for task in dic[i]:\n                heappush(heap, -task)\n        if len(heap) == 0:\n            break\n        max_sum += -heappop(heap)\n        k += 1\n        res = max(res, max_sum / k)\n    print(res)\n\ndef main():\n    t = readInts()\n    for i in range(t):\n        solve(i + 1)\nmain()", "from heapq import heappush, heappop\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = []\n    heap = []\n    (tc, ti, res) = (0, 0, 0)\n    for _ in range(n):\n        l.append([])\n    for (x, y) in zip(a, b):\n        l[y].append(x)\n    for i in range(n):\n        for j in l[i]:\n            heappush(heap, -j)\n        if len(heap) == 0:\n            break\n        tc += -heappop(heap)\n        ti += 1\n        res = max(res, tc / ti)\n    print(res)", "from collections import defaultdict\nimport heapq\nimport math\nfrom math import sqrt\nfor _ in range(int(input())):\n    d = defaultdict(list)\n    n = int(input())\n    l = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    for i in range(n):\n        d[p[i]].append(l[i])\n    h = []\n    s = 0\n    for i in d[s]:\n        heapq.heappush(h, -1 * i)\n    ans = 0\n    maxi = -1 * float('inf')\n    while h:\n        s += 1\n        ans += -1 * heapq.heappop(h)\n        maxi = max(maxi, ans / float(s))\n        if s in d:\n            for i in d[s]:\n                heapq.heappush(h, -1 * i)\n    print(max(maxi, 0))", "from sys import stdin, stdout\nfrom collections import defaultdict\nimport heapq\ninput = stdin.readline\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    a1 = list(map(int, input().strip().split()))\n    b1 = list(map(int, input().strip().split()))\n    d = defaultdict(list)\n    for i in range(n):\n        key = b1[i]\n        value = a1[i]\n        d[key].append(-1 * value)\n    li = d[0]\n    heapq.heapify(li)\n    maxi = 0\n    k = []\n    sumi = 0\n    length = 0\n    while True:\n        if not li:\n            break\n        ele = -1 * heapq.heappop(li)\n        k.append(ele)\n        length += 1\n        sumi += ele\n        maxi = max(maxi, sumi / length)\n        temp = d[length]\n        for i in range(len(temp)):\n            heapq.heappush(li, temp[i])\n    print(maxi)", "from heapq import *\nfor t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = [[] for i in range(n)]\n    for (x, y) in zip(a, b):\n        arr[y].append(x)\n    score = sm = 0\n    heap = []\n    for i in range(n):\n        for task in arr[i]:\n            heappush(heap, -task)\n        if len(heap) == 0:\n            break\n        sm += -heappop(heap)\n        score = max(score, sm / (i + 1))\n    print(score)", "from queue import PriorityQueue\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    lsta = list(map(int, input().split()))\n    lstb = list(map(int, input().split()))\n    dic = {}\n    for h in range(n):\n        dic[h] = []\n    for r in range(n):\n        dic[lstb[r]].append(lsta[r])\n    ind = 0\n    su = 0\n    a = 0\n    q = PriorityQueue()\n    c = 0\n    lsta = []\n    while True:\n        if ind > n - 1:\n            break\n        else:\n            for r in dic[ind]:\n                q.put(-r)\n            if q.empty() == True:\n                ind = n + 1\n            else:\n                su += -q.get()\n                ind += 1\n                a += 1\n                lsta.append(su / a)\n    if lsta == []:\n        print(0)\n    else:\n        print(max(0, max(lsta)))", "import collections\nfrom math import ceil, gcd, sqrt, log\nfrom heapq import *\nINF = float('inf')\nmod = 1000000007\n\ndef solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    net = collections.defaultdict(list)\n    maxHeap = []\n    for (x, y) in zip(A, B):\n        net[y].append(x)\n    ans = 0\n    s = 0\n    tasksdone = 0\n    for i in range(n):\n        if i in net:\n            l = net[i]\n            for j in l:\n                heappush(maxHeap, -j)\n        if not maxHeap:\n            break\n        x = -heappop(maxHeap)\n        s += x\n        tasksdone += 1\n        ans = max(ans, s / tasksdone)\n    print(ans)\nt = int(input())\nwhile t != 0:\n    solve()\n    t -= 1", "import collections\nfrom math import ceil, gcd, sqrt, log\nfrom heapq import *\nINF = float('inf')\nmod = 1000000007\n\ndef solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    net = dict()\n    maxHeap = []\n    for i in range(n):\n        net[i] = []\n    for (x, y) in zip(A, B):\n        net[y].append(x)\n    ans = 0\n    s = 0\n    tasksdone = 0\n    for i in range(n):\n        if i in net:\n            l = net[i]\n            for j in l:\n                heappush(maxHeap, -j)\n        if not maxHeap:\n            break\n        x = -heappop(maxHeap)\n        s += x\n        tasksdone += 1\n        ans = max(ans, s / tasksdone)\n    print(ans)\nt = int(input())\nwhile t != 0:\n    solve()\n    t -= 1", "from heapq import heapify, heappop, heappush\n\ndef solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    l = [[] for _ in range(n)]\n    for (a, b) in zip(A, B):\n        l[b].append(a)\n    last = 0\n    res = 0\n    h = []\n    for i in range(n):\n        for a in l[i]:\n            heappush(h, (-a, i))\n        if not h:\n            break\n        assert len(h) > 0\n        (a, b) = heappop(h)\n        a = -a\n        last += a\n        res = max(res, last / (i + 1))\n    print(res)\nt = int(input())\nfor _ in range(t):\n    solve()", "from queue import PriorityQueue\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ans = [[] for i in range(n + 1)]\n    dp = [0 for i in range(n + 1)]\n    for i in range(n):\n        ans[b[i]].append(l[i])\n    lis = PriorityQueue()\n    for i in range(1, n + 1):\n        li = ans[i - 1]\n        for x in li:\n            lis.put(-x)\n        if not lis.empty():\n            dp[i] = dp[i - 1]\n            dp[i] += -lis.get()\n        else:\n            break\n    maxe = 0\n    for i in range(1, n + 1):\n        dp[i] /= i\n        maxe = max(dp[i], maxe)\n    maxe = max(dp)\n    print('{:6f}'.format(maxe))", "import collections, heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    preq = collections.defaultdict(list)\n    for i in range(n):\n        preq[b[i]].append(a[i])\n    heap = []\n    for i in preq[0]:\n        heapq.heappush(heap, -i)\n    i = 1\n    ans = 0\n    sm = 0\n    while heap:\n        cand = -heapq.heappop(heap)\n        sm += cand\n        ans = max(ans, sm / i)\n        for j in preq[i]:\n            heapq.heappush(heap, -j)\n        i += 1\n    print('{:.6f}'.format(max(ans, 0)))", "from sys import stdin, stdout\ninput = stdin.readline\n\nclass SortedList:\n\n    def __init__(self, iterable=[], _load=200):\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return (0, k)\n        if k >= self._len - _list_lens[-1]:\n            return (len(_list_lens) - 1, k + _list_lens[-1] - self._len)\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return (idx + 1, k)\n\n    def _delete(self, pos, idx):\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (lo, pos) = (-1, len(_lists) - 1)\n        while lo + 1 < pos:\n            mi = lo + pos >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def _loc_right(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (pos, hi) = (0, len(_lists))\n        while pos + 1 < hi:\n            mi = pos + hi >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def add(self, value):\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len += 1\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        (pos, idx) = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        (pos, idx) = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        return self._len\n\n    def __getitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        return 'SortedList({0})'.format(list(self))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    g = [[] for i in range(n)]\n    unused = SortedList([])\n    for i in range(n):\n        g[b[i]].append(a[i])\n        if b[i] == 0:\n            unused.add(a[i])\n    curr_sum = 0\n    curr_eles = 0\n    maxi = 0\n    while len(unused):\n        x = unused.pop()\n        curr_sum += x\n        curr_eles += 1\n        maxi = max(maxi, curr_sum / curr_eles)\n        if curr_eles < n:\n            for i in g[curr_eles]:\n                unused.add(i)\n    print(maxi)", "from heapq import heappush, heappop\nfrom sys import stdin\ninput = stdin.readline\n\nclass Plan:\n    __slots__ = ['effectiveness', 'index']\n\n    def __init__(self, effectiveness, index):\n        self.effectiveness = effectiveness\n        self.index = index\n\ndef solve(N, training):\n    answer = 0\n    count = 0\n    training = sorted(training, key=lambda x: x.index)\n    usable = []\n    first = 0\n    for k in range(1, N + 1):\n        while first < N and training[first].index == k - 1:\n            heappush(usable, -training[first].effectiveness)\n            first += 1\n        if not usable:\n            break\n        count += -heappop(usable)\n        answer = max(answer, count / k)\n    return answer\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    N = int(input().strip())\n    A = [int(x) for x in input().strip().split()]\n    B = [int(x) for x in input().strip().split()]\n    training = [Plan(a, b) for (a, b) in zip(A, B)]\n    print('{0:.6f}'.format(solve(N, training)))", "from heapq import heappush, heappop\nfrom sys import stdin\ninput = stdin.readline\n\nclass Plan:\n    __slots__ = ['effectiveness', 'index']\n\n    def __init__(self, effectiveness, index):\n        self.effectiveness = effectiveness\n        self.index = index\n\ndef solve(N, training):\n    answer = 0\n    count = 0\n    training = sorted(training, key=lambda x: x.index)\n    usable = []\n    first = 0\n    for k in range(1, N + 1):\n        while first < N and training[first].index == k - 1:\n            heappush(usable, -training[first].effectiveness)\n            first += 1\n        if not usable:\n            break\n        best = -heappop(usable)\n        count += best\n        answer = max(answer, count / k)\n    return answer\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    N = int(input().strip())\n    A = [int(x) for x in input().strip().split()]\n    B = [int(x) for x in input().strip().split()]\n    training = [Plan(a, b) for (a, b) in zip(A, B)]\n    print('{0:.6f}'.format(solve(N, training)))", "from heapq import heappush, heappop\n\ndef solve(n, arr):\n    j = 0\n    (a, b) = (0.0, 0.0)\n    heap = []\n    for i in range(n):\n        while j < n and arr[j][1] <= i:\n            heappush(heap, -arr[j][0])\n            j += 1\n        if not heap:\n            break\n        else:\n            a -= heappop(heap)\n            b = max(b, a / (i + 1))\n    return b\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = list(zip(a, b))\n    arr.sort(key=lambda x: (x[1], -x[0]))\n    if arr[0][1] > 0:\n        print(0)\n        continue\n    print('%.7f' % solve(n, arr))", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    req = list(map(int, input().split()))\n    ans = 0\n    dit = {}\n    for i in range(n):\n        if req[i] in dit:\n            dit[req[i]].append(arr[i])\n        else:\n            dit[req[i]] = [arr[i]]\n    hp = []\n    i = 0\n    count = 0\n    s = 0\n    while True:\n        if i not in dit:\n            if not hp:\n                break\n            else:\n                s += -heapq.heappop(hp)\n        else:\n            m = max(dit[i])\n            if not hp or (hp and -hp[0] < m):\n                s += m\n                dit[i].remove(m)\n                for e in dit[i]:\n                    heapq.heappush(hp, -e)\n            else:\n                s += -heapq.heappop(hp)\n                for e in dit[i]:\n                    heapq.heappush(hp, -e)\n        count += 1\n        curr = s / count\n        ans = max(ans, curr)\n        i += 1\n    print('%.6f' % ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    pairs = defaultdict(list)\n    for i in range(N):\n        pairs[B[i]].append(A[i])\n    breakpoints = set()\n    for k in pairs:\n        breakpoints.add(k)\n        pairs[k].sort()\n    breakpoints = sorted(list(breakpoints))\n    j = 0\n    m = len(breakpoints)\n    lst = pairs[0]\n    ans = [0]\n    s = 0\n    for i in range(N):\n        if j < m - 1 and i >= breakpoints[j + 1]:\n            lst.extend(pairs[breakpoints[j + 1]])\n            lst.sort()\n            j += 1\n        if not lst:\n            break\n        s += lst.pop()\n        ans.append(s / (i + 1))\n    print(max(ans))", "from heapq import heappush, heappop\n\ndef solve(n, arr):\n    j = 0\n    (a, b) = (0.0, 0.0)\n    heap = []\n    for i in range(n):\n        while j < n and arr[j][1] <= i:\n            heappush(heap, -arr[j][0])\n            j += 1\n        if not heap:\n            break\n        else:\n            a -= heappop(heap)\n            b = max(b, a / (i + 1))\n    return b\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arr = list(zip(a, b))\n    arr.sort(key=lambda x: (x[1], -x[0]))\n    if arr[0][1] > 0:\n        print(0)\n        continue\n    print('%.7f' % solve(n, arr))", "import heapq\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    sb = [(b[i], i) for i in range(n)]\n    sb.sort(reverse=True)\n    hp = []\n    summ = maxval = 0\n    for k in range(n):\n        while sb and sb[-1][0] <= k:\n            idx = sb[-1][1]\n            sb.pop()\n            heapq.heappush(hp, -a[idx])\n        if hp:\n            ai = -heapq.heappop(hp)\n            summ += ai\n            if summ / (k + 1) > maxval:\n                maxval = summ / (k + 1)\n        else:\n            break\n    print(maxval)", "N = 10\ntree = [0] * (2 * N)\n\ndef build(arr):\n    for i in range(n):\n        tree[n + i] = arr[i]\n    for i in range(n - 1, 0, -1):\n        tree[i] = tree[i << 1] + tree[i << 1 | 1]\n\ndef updateTreeNode(p, value):\n    tree[p + n] = value\n    p = p + n\n    i = p\n    while i > 1:\n        tree[i >> 1] = tree[i] + tree[i ^ 1]\n        i >>= 1\n\ndef query(l, r):\n    res = 0\n    l += n\n    r += n\n    while l < r:\n        if l & 1:\n            res += tree[l]\n            l += 1\n        if r & 1:\n            r -= 1\n            res += tree[r]\n        l >>= 1\n        r >>= 1\n    return res\nfrom heapq import heappop, heappush, heapify\nfor i in range(int(input())):\n    heap = []\n    heapify(heap)\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append([B[i], A[i]])\n    l = sorted(l)\n    j = 0\n    cs = 0.0\n    ms = 0.0\n    for req in range(n):\n        while j < n and l[j][0] <= req:\n            heappush(heap, -l[j][1])\n            j += 1\n        if heap == []:\n            break\n        else:\n            cs -= heappop(heap)\n            ms = max(ms, cs / (req + 1))\n    print('{0:.6f}'.format(ms))", "from heapq import heappush, heappop\nfor tcase in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    la = [[] for i in range(n + 1)]\n    for (i, k) in enumerate(b):\n        la[k].append(-a[i])\n    pq = []\n    k = 0\n    s = 0\n    ans = 0.0\n    while len(la[k]) > 0 or len(pq) > 0:\n        while len(la[k]) > 0:\n            heappush(pq, la[k].pop())\n        s -= heappop(pq)\n        k += 1\n        ans = max(ans, s / k)\n    print('{:.6f}'.format(ans))", "from heapq import heappop, heappush, heapify\nfor i in range(int(input())):\n    heap = []\n    heapify(heap)\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append([B[i], A[i]])\n    l = sorted(l)\n    j = 0\n    cs = 0.0\n    ms = 0.0\n    for req in range(n):\n        while j < n and l[j][0] <= req:\n            heappush(heap, -l[j][1])\n            j += 1\n        if heap == []:\n            break\n        else:\n            cs -= heappop(heap)\n            ms = max(ms, cs / (req + 1))\n    print('{0:.6f}'.format(ms))", "from heapq import heapify, heappush, heappop\nfor tcase in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    la = [[] for i in range(n + 1)]\n    for (i, k) in enumerate(b):\n        la[k].append(-a[i])\n    pq = []\n    k = 0\n    s = 0\n    ans = 0.0\n    while len(la[k]) > 0 or len(pq) > 0:\n        while len(la[k]) > 0:\n            heappush(pq, la[k].pop())\n        s -= heappop(pq)\n        k += 1\n        ans = max(ans, 1.0 * s / k)\n    print('{:.6f}'.format(ans))", "import math\nimport itertools\nimport heapq\nfrom math import floor, ceil\n\ndef lcm(a, b):\n    return abs(a * b) // math.gcd(a, b)\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef isSubsequence(s, t):\n    for i in range(0, len(s)):\n        try:\n            index = t.index(s[i])\n        except ValueError:\n            return False\n        t = t[index + 1:]\n    return True\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    D = {}\n    nums = set()\n    for i in range(N):\n        req = B[i]\n        if req in D:\n            D[req].append(A[i])\n        else:\n            D[req] = [A[i]]\n        nums.add(B[i])\n    nums = sorted(list(nums))\n    soFar = 0\n    ans = 0\n    taken = 0\n    h = []\n    heapq.heapify(h)\n    for req in range(max(nums) + 1):\n        if taken < req:\n            break\n        else:\n            if req in D:\n                l = D[req][:]\n                for x in range(len(l)):\n                    heapq.heappush(h, -l[x])\n            if len(h) == 0:\n                break\n            currMax = -heapq.heappop(h)\n            soFar += currMax\n            taken += 1\n            ans = max(ans, soFar / taken)\n    while h:\n        currMax = -heapq.heappop(h)\n        soFar += currMax\n        taken += 1\n        ans = max(ans, soFar / taken)\n    print(ans)", "import heapq\nt = int(input())\nfor _ in range(t):\n    pq = []\n    n = int(input())\n    arr = list(map(int, input().split()))\n    brr = list(map(int, input().split()))\n    crr = []\n    for _ in range(n):\n        crr.append([])\n    for i in range(n):\n        (a, b) = (arr[i], brr[i])\n        crr[b].append(a)\n    ans = 0\n    sumation = 0\n    for i in range(n):\n        for val in crr[i]:\n            heapq.heappush(pq, -val)\n        if len(pq) == 0:\n            break\n        sumation -= heapq.heappop(pq)\n        if sumation / (i + 1) > ans:\n            ans = sumation / (i + 1)\n    print(ans)", "from collections import defaultdict\nimport heapq\nt = int(input())\nfor _ in range(t):\n    length = int(input())\n    eff = list(map(int, input().split()))\n    req = list(map(int, input().split()))\n    dicti = defaultdict(list)\n    for i in range(length):\n        dicti[req[i]].append(eff[i])\n    cand = []\n    ans = []\n    for i in range(length):\n        for j in dicti[i]:\n            heapq.heappush(cand, -j)\n        if len(cand) == 0:\n            break\n        ans.append(heapq.heappop(cand))\n    curr = 0\n    for i in range(len(ans)):\n        curr -= ans[i]\n        ans[i] = curr / (i + 1)\n    ans.append(0)\n    print(max(ans))", "from heapq import heappush, heapify, heappop\nt = int(input())\nfor z in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    d = dict()\n    for i in range(n):\n        d[i] = []\n    for i in range(n):\n        if b[i] in d:\n            d[b[i]].append(-a[i])\n    max_ans = 0\n    ans = 0\n    count = 0\n    fh = []\n    lh = 0\n    for i in range(n):\n        for x in d[count]:\n            heappush(fh, x)\n            lh += 1\n        if lh == 0:\n            break\n        x = heappop(fh)\n        lh -= 1\n        count += 1\n        ans -= x\n        max_ans = max(max_ans, ans / count)\n    print(max_ans)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = []\n    for i in range(n):\n        c.append([b[i], a[i]])\n    c.sort(key=lambda x: (x[0], -x[1]))\n    ans = [0]\n    h = []\n    x = 0\n    i = 0\n    while i < n:\n        if c[i][0] <= x:\n            if x == 0:\n                ans.append(c[i][1])\n                i += 1\n            else:\n                while i < n and c[i][0] <= x:\n                    heapq.heappush(h, c[i][1] * -1)\n                    i += 1\n                ans.append((ans[-1] * x + heapq.heappop(h) * -1) / (x + 1))\n            x += 1\n        elif c[i][0] > x:\n            if len(h) == 0:\n                break\n            ans.append((ans[-1] * x + heapq.heappop(h) * -1) / (x + 1))\n            x += 1\n    if x < n - 1:\n        while x < n - 1:\n            if len(h) == 0:\n                break\n            ans.append((ans[-1] * x + heapq.heappop(h) * -1) / (x + 1))\n            x += 1\n    print('{0:.6f}'.format(max(ans)))", "from heapq import heappop, heappush, heapify\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = []\n    ll = [[] for i in range(n)]\n    heapify(l)\n    for i in range(n):\n        if b[i] == 0:\n            heappush(l, -1 * a[i])\n        ll[b[i]].append(a[i])\n    ans = 0\n    count = 0\n    anss = 0\n    while len(l):\n        if count == 0:\n            ans = -l[0]\n            heappop(l)\n            count += 1\n            if count <= n - 1:\n                for i in range(len(ll[count])):\n                    heappush(l, -1 * ll[count][i])\n        else:\n            ans += -l[0]\n            heappop(l)\n            count += 1\n            if count <= n - 1:\n                for i in range(len(ll[count])):\n                    heappush(l, -1 * ll[count][i])\n        anss = max(anss, ans / count)\n    print(anss)", "import heapq\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    l = []\n    for i in range(0, n):\n        l.append([])\n    for i in range(0, n):\n        l[b[i]].append(-a[i])\n    ans = []\n    if l[0] == []:\n        print(0)\n        continue\n    heapq.heapify(l[0])\n    ans.append(heapq.heappop(l[0]))\n    for i in range(1, n):\n        for j in l[i]:\n            heapq.heappush(l[0], j)\n        if len(l[0]) == 0:\n            break\n        ans.append(ans[-1] + heapq.heappop(l[0]))\n    if ans == []:\n        print(0)\n        continue\n    for i in range(0, len(ans)):\n        ans[i] = ans[i] / (i + 1)\n    print(max(0, -min(ans)))", "import math, bisect, heapq, random, sys, itertools\ninput = sys.stdin.readline\n\ndef gprint(t, ans):\n    print(f'Case #{t + 1}:', ans)\nints = lambda : list(map(int, input().split()))\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\np2 = [1]\np = 10 ** 9 + 7\nANS = []\nfor t in range(int(input())):\n    n = int(input())\n    a = ints()\n    b = ints()\n    arr = []\n    bad = []\n    (n1, n2) = (0, 0)\n    for i in range(n):\n        if a[i] >= 0:\n            arr.append((b[i], a[i]))\n            n1 += 1\n        else:\n            bad.append((b[i], a[i]))\n            n2 += 1\n    arr.sort()\n    bad.sort()\n    ans = 0\n    s = 0\n    (i1, i2) = (0, 0)\n    c = 0\n    pos = []\n    neg = []\n    while True:\n        while i1 < n1:\n            if arr[i1][0] <= c:\n                bisect.insort(pos, arr[i1][1])\n                i1 += 1\n            else:\n                break\n        if pos:\n            s += pos.pop()\n            c += 1\n            ans = max(ans, s / c)\n            continue\n        while i2 < n2:\n            if bad[i2][0] <= c:\n                bisect.insort(neg, bad[i2][1])\n                i2 += 1\n            else:\n                break\n        if neg:\n            s += neg.pop()\n            c += 1\n        else:\n            break\n    print(ans)", "from collections import Counter, defaultdict, deque\nimport itertools\nimport re\nimport math\nfrom functools import reduce\nimport operator\nimport bisect\nimport heapq\nimport functools\nmod = 10 ** 9 + 7\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    tr = [[] for _ in range(n)]\n    for i in range(n):\n        tr[b[i]].append(a[i])\n    ans = 0\n    su = 0\n    heap = []\n    for i in range(n):\n        for j in tr[i]:\n            heapq.heappush(heap, -j)\n        if not heap:\n            break\n        su += -heapq.heappop(heap)\n        ans = max(ans, su / (i + 1))\n    print(ans)"]