["from bisect import *\nfrom heapq import *\nfrom math import *\nfrom collections import defaultdict as ddc\nfrom collections import Counter\nfrom functools import reduce\n\ndef intin():\n    return int(input())\n\ndef mapin():\n    return map(int, input().split())\n\ndef strin():\n    return input().split()\nINF = 10 ** 20\nmod = 1000000007\n\ndef hashit(arr, size, mod=10 ** 9 + 7):\n    if not size:\n        return\n    (mul, hashh, div) = (256, 0, (1 << 8 * size - 8) % mod)\n    C = defaultdict(list)\n    for i in range(size):\n        hashh = (mul * hashh + arr[i]) % mod\n    C[hashh].append(0)\n    for i in range(len(arr) - size):\n        hashh = (mul * (hashh - arr[i] * div) + arr[i + size]) % mod\n        C[hashh].append(i + 1)\n    return C\n\ndef LIS(arr, n):\n    dp = [10 ** 9] * (n + 1)\n    for ele in arr:\n        dp[bisect_left(dp, ele)] = ele\n    return bisect_left(dp, 10 ** 9)\n\ndef exponentiation(bas, exp, mod=10 ** 9 + 7):\n    t = 1\n    while exp > 0:\n        if exp % 2 != 0:\n            t = t * bas % mod\n        bas = bas * bas % mod\n        exp //= 2\n    return t % mod\n\ndef MOD(p, q=1, mod=1000000007):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\nyes = 'YES'\nno = 'NO'\neven = 'EVEN'\nodd = 'ODD'\n\ndef graphin(n):\n    zz = defaultdict(set)\n    for i in range(n - 1):\n        (a, b) = mapin()\n        zz[a].add(b)\n        zz[b].add(a)\n    return zz\n\ndef process(arr, n, Q):\n    h = []\n    heappush(h, [0, 0])\n    for i in range(1, n):\n        temp = arr[i - 1] - arr[i]\n        heappush(h, [-temp, i])\n    for (i, x) in Q:\n        arr[i - 1] = x\n        if i > 1:\n            temp = arr[i - 2] - arr[i - 1]\n            heappush(h, [-temp, i - 1])\n        if i < n:\n            temp = arr[i - 1] - arr[i]\n            heappush(h, [-temp, i])\n        while h:\n            (val, i) = heappop(h)\n            if arr[i] - arr[i - 1] == val or i == 0:\n                if val > 0:\n                    print(0)\n                else:\n                    print(-val)\n                heappush(h, [val, i])\n                break\n\ndef main():\n    for _ in range(int(input())):\n        (n, q) = mapin()\n        arr = list(mapin())\n        Q = []\n        for i in range(q):\n            (i, x) = mapin()\n            Q.append([i, x])\n        process(arr, n, Q)\nmain()", "from bisect import *\nfrom heapq import *\nfrom math import *\nfrom collections import defaultdict as ddc\nfrom collections import Counter\nfrom functools import reduce\n\ndef intin():\n    return int(input())\n\ndef mapin():\n    return map(int, input().split())\n\ndef strin():\n    return input().split()\nINF = 10 ** 20\nmod = 1000000007\n\ndef hashit(arr, size, mod=10 ** 9 + 7):\n    if not size:\n        return\n    (mul, hashh, div) = (256, 0, (1 << 8 * size - 8) % mod)\n    C = defaultdict(list)\n    for i in range(size):\n        hashh = (mul * hashh + arr[i]) % mod\n    C[hashh].append(0)\n    for i in range(len(arr) - size):\n        hashh = (mul * (hashh - arr[i] * div) + arr[i + size]) % mod\n        C[hashh].append(i + 1)\n    return C\n\ndef LIS(arr, n):\n    dp = [10 ** 9] * (n + 1)\n    for ele in arr:\n        dp[bisect_left(dp, ele)] = ele\n    return bisect_left(dp, 10 ** 9)\n\ndef exponentiation(bas, exp, mod=10 ** 9 + 7):\n    t = 1\n    while exp > 0:\n        if exp % 2 != 0:\n            t = t * bas % mod\n        bas = bas * bas % mod\n        exp //= 2\n    return t % mod\n\ndef MOD(p, q=1, mod=1000000007):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\nyes = 'YES'\nno = 'NO'\neven = 'EVEN'\nodd = 'ODD'\n\ndef graphin(n):\n    zz = defaultdict(set)\n    for i in range(n - 1):\n        (a, b) = mapin()\n        zz[a].add(b)\n        zz[b].add(a)\n    return zz\n\ndef process(arr, n, Q):\n    h = []\n    heappush(h, [0, 0])\n    for i in range(1, n):\n        temp = arr[i - 1] - arr[i]\n        heappush(h, [-temp, i])\n    for (i, x) in Q:\n        arr[i - 1] = x\n        if i > 1:\n            temp = arr[i - 2] - arr[i - 1]\n            heappush(h, [-temp, i - 1])\n        if i < n:\n            temp = arr[i - 1] - arr[i]\n            heappush(h, [-temp, i])\n        while h:\n            (val, i) = heappop(h)\n            if arr[i] - arr[i - 1] == val or i == 0:\n                if val > 0:\n                    print(0)\n                else:\n                    print(-val)\n                heappush(h, [val, i])\n                break\n\ndef main():\n    for _ in range(int(input())):\n        (n, q) = mapin()\n        arr = list(mapin())\n        Q = []\n        for i in range(q):\n            (i, x) = mapin()\n            Q.append([i, x])\n        process(arr, n, Q)\nmain()", "from bisect import *\nfrom heapq import *\nfrom math import *\nfrom collections import defaultdict as ddc\nfrom collections import Counter\nfrom functools import reduce\n\ndef intin():\n    return int(input())\n\ndef mapin():\n    return map(int, input().split())\n\ndef strin():\n    return input().split()\nINF = 10 ** 20\nmod = 1000000007\n\ndef hashit(arr, size, mod=10 ** 9 + 7):\n    if not size:\n        return\n    (mul, hashh, div) = (256, 0, (1 << 8 * size - 8) % mod)\n    C = defaultdict(list)\n    for i in range(size):\n        hashh = (mul * hashh + arr[i]) % mod\n    C[hashh].append(0)\n    for i in range(len(arr) - size):\n        hashh = (mul * (hashh - arr[i] * div) + arr[i + size]) % mod\n        C[hashh].append(i + 1)\n    return C\n\ndef LIS(arr, n):\n    dp = [10 ** 9] * (n + 1)\n    for ele in arr:\n        dp[bisect_left(dp, ele)] = ele\n    return bisect_left(dp, 10 ** 9)\n\ndef exponentiation(bas, exp, mod=10 ** 9 + 7):\n    t = 1\n    while exp > 0:\n        if exp % 2 != 0:\n            t = t * bas % mod\n        bas = bas * bas % mod\n        exp //= 2\n    return t % mod\n\ndef MOD(p, q=1, mod=1000000007):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\nyes = 'YES'\nno = 'NO'\neven = 'EVEN'\nodd = 'ODD'\n\ndef graphin(n):\n    zz = defaultdict(set)\n    for i in range(n - 1):\n        (a, b) = mapin()\n        zz[a].add(b)\n        zz[b].add(a)\n    return zz\n\ndef process(arr, n, Q):\n    h = []\n    heappush(h, [0, 0])\n    for i in range(1, n):\n        temp = arr[i - 1] - arr[i]\n        heappush(h, [-temp, i])\n    for (i, x) in Q:\n        arr[i - 1] = x\n        if i > 1:\n            temp = arr[i - 2] - arr[i - 1]\n            heappush(h, [-temp, i - 1])\n        if i < n:\n            temp = arr[i - 1] - arr[i]\n            heappush(h, [-temp, i])\n        while h:\n            (val, i) = heappop(h)\n            if arr[i] - arr[i - 1] == val or i == 0:\n                if val > 0:\n                    print(0)\n                else:\n                    print(-val)\n                heappush(h, [val, i])\n                break\n\ndef main():\n    for _ in range(int(input())):\n        (n, q) = mapin()\n        arr = list(mapin())\n        Q = []\n        for i in range(q):\n            (i, x) = mapin()\n            Q.append([i, x])\n        process(arr, n, Q)\nmain()", "T = int(input())\nfor t in range(T):\n    (N, Q) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    maximo = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n    for q in range(Q):\n        recalculate = False\n        (i, x) = list(map(int, input().split()))\n        i -= 1\n        if i > 0 and maximo == A[i - 1] - A[i]:\n            recalculate = True\n        if i < N - 1 and maximo == A[i] - A[i + 1]:\n            recalculate = True\n        A[i] = x\n        if recalculate:\n            maximo = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n        else:\n            if i > 0:\n                maximo = max(maximo, A[i - 1] - A[i])\n            if i < N - 1:\n                maximo = max(maximo, A[i] - A[i + 1])\n        print(maximo)", "for i in range(int(input())):\n    (n, q) = map(int, input().split())\n    ar = list(map(int, input().split()))\n    maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n    for i in range(q):\n        (i, val) = map(int, input().split())\n        i -= 1\n        if i > 0 and ar[i - 1] - ar[i] == maxi or (i + 1 < n and ar[i] - ar[i + 1] == maxi):\n            ar[i] = val\n            maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n        else:\n            ar[i] = val\n            if i > 0:\n                maxi = max(maxi, ar[i - 1] - ar[i])\n            if i + 1 < n:\n                maxi = max(maxi, ar[i] - ar[i + 1])\n        print(maxi)", "for i in range(int(input())):\n    (n, q) = map(int, input().split())\n    ar = list(map(int, input().split()))\n    maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n    for i in range(q):\n        (i, val) = map(int, input().split())\n        i -= 1\n        if i > 0 and ar[i - 1] - ar[i] == maxi or (i + 1 < n and ar[i] - ar[i + 1] == maxi):\n            ar[i] = val\n            maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n        else:\n            ar[i] = val\n            if i > 0:\n                maxi = max(maxi, ar[i - 1] - ar[i])\n            if i + 1 < n:\n                maxi = max(maxi, ar[i] - ar[i + 1])\n        print(maxi)", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    ar = list(map(int, input().split()))\n    maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n    for _ in range(q):\n        (i, val) = map(int, input().split())\n        i -= 1\n        if i > 0 and ar[i - 1] - ar[i] == maxi or (i + 1 < n and ar[i] - ar[i + 1] == maxi):\n            ar[i] = val\n            maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n        else:\n            ar[i] = val\n            if i > 0:\n                maxi = max(maxi, ar[i - 1] - ar[i])\n            if i + 1 < n:\n                maxi = max(maxi, ar[i] - ar[i + 1])\n        print(maxi)", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    ar = list(map(int, input().split()))\n    maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n    for _ in range(q):\n        (i, val) = map(int, input().split())\n        i -= 1\n        if i > 0 and ar[i - 1] - ar[i] == maxi or (i + 1 < n and ar[i] - ar[i + 1] == maxi):\n            ar[i] = val\n            maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n        else:\n            ar[i] = val\n            if i > 0:\n                maxi = max(maxi, ar[i - 1] - ar[i])\n            if i + 1 < n:\n                maxi = max(maxi, ar[i] - ar[i + 1])\n        print(maxi)", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    ar = list(map(int, input().split()))\n    maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n    for _ in range(q):\n        (i, val) = map(int, input().split())\n        i -= 1\n        if i > 0 and ar[i - 1] - ar[i] == maxi or (i + 1 < n and ar[i] - ar[i + 1] == maxi):\n            ar[i] = val\n            maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n        else:\n            ar[i] = val\n            if i > 0:\n                maxi = max(maxi, ar[i - 1] - ar[i])\n            if i + 1 < n:\n                maxi = max(maxi, ar[i] - ar[i + 1])\n        print(maxi)", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    ar = list(map(int, input().split()))\n    maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n    for _ in range(q):\n        (i, val) = map(int, input().split())\n        i -= 1\n        if i > 0 and ar[i - 1] - ar[i] == maxi or (i + 1 < n and ar[i] - ar[i + 1] == maxi):\n            ar[i] = val\n            maxi = max([0] + [ar[i] - ar[i + 1] for i in range(n - 1)])\n        else:\n            ar[i] = val\n            if i > 0:\n                maxi = max(maxi, ar[i - 1] - ar[i])\n            if i + 1 < n:\n                maxi = max(maxi, ar[i] - ar[i + 1])\n        print(maxi)", "for i in range(int(input())):\n    (n, q) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    maximo = max([0] + [a - b for (a, b) in zip(a, a[1:])])\n    for j in range(q):\n        recalculate = False\n        (i, x) = list(map(int, input().split()))\n        i -= 1\n        if i > 0 and maximo == a[i - 1] - a[i]:\n            recalculate = True\n        if i < n - 1 and maximo == a[i] - a[i + 1]:\n            recalculate = True\n        a[i] = x\n        if recalculate:\n            maximo = max([0] + [a - b for (a, b) in zip(a, a[1:])])\n        else:\n            if i > 0:\n                maximo = max(maximo, a[i - 1] - a[i])\n            if i < n - 1:\n                maximo = max(maximo, a[i] - a[i + 1])\n        print(maximo)", "for i in range(int(input())):\n    (n, q) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    maximo = max([0] + [a - b for (a, b) in zip(a, a[1:])])\n    for j in range(q):\n        recalculate = False\n        (i, x) = list(map(int, input().split()))\n        i -= 1\n        if i > 0 and maximo == a[i - 1] - a[i]:\n            recalculate = True\n        if i < n - 1 and maximo == a[i] - a[i + 1]:\n            recalculate = True\n        a[i] = x\n        if recalculate:\n            maximo = max([0] + [a - b for (a, b) in zip(a, a[1:])])\n        else:\n            if i > 0:\n                maximo = max(maximo, a[i - 1] - a[i])\n            if i < n - 1:\n                maximo = max(maximo, a[i] - a[i + 1])\n        print(maximo)", "for _ in range(int(input())):\n    (N, Q) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    maxi = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n    for q in range(Q):\n        recalculate = False\n        (i, x) = list(map(int, input().split()))\n        i -= 1\n        if i > 0 and maxi == A[i - 1] - A[i]:\n            recalculate = True\n        if i < N - 1 and maxi == A[i] - A[i + 1]:\n            recalculate = True\n        A[i] = x\n        if recalculate:\n            maxi = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n        else:\n            if i > 0:\n                maxi = max(maxi, A[i - 1] - A[i])\n            if i < N - 1:\n                maxi = max(maxi, A[i] - A[i + 1])\n        print(maxi)", "T = int(input())\nfor t in range(T):\n    (N, Q) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    maximo = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n    for q in range(Q):\n        recalculate = False\n        (i, x) = list(map(int, input().split()))\n        i -= 1\n        if i > 0 and maximo == A[i - 1] - A[i]:\n            recalculate = True\n        if i < N - 1 and maximo == A[i] - A[i + 1]:\n            recalculate = True\n        A[i] = x\n        if recalculate:\n            maximo = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n        else:\n            if i > 0:\n                maximo = max(maximo, A[i - 1] - A[i])\n            if i < N - 1:\n                maximo = max(maximo, A[i] - A[i + 1])\n        print(maximo)", "T = int(input())\nfor t in range(T):\n    (N, Q) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    maximo = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n    for q in range(Q):\n        recalculate = False\n        (i, x) = list(map(int, input().split()))\n        i -= 1\n        if i > 0 and maximo == A[i - 1] - A[i]:\n            recalculate = True\n        if i < N - 1 and maximo == A[i] - A[i + 1]:\n            recalculate = True\n        A[i] = x\n        if recalculate:\n            maximo = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n        else:\n            if i > 0:\n                maximo = max(maximo, A[i - 1] - A[i])\n            if i < N - 1:\n                maximo = max(maximo, A[i] - A[i + 1])\n        print(maximo)", "from collections import *\nfrom itertools import *\nfrom functools import *\nfrom heapq import *\nimport sys, math\ninput = sys.stdin.readline\n\ndef segfunc(x, y):\n    return max(x, y)\nide_ele = -(1 << 30)\n\nclass SegTree:\n\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        res = self.ide_ele\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\ndef answer():\n    (N, Q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = [A[i] - A[i + 1] for i in range(N - 1)]\n    T = SegTree(B, segfunc, ide_ele)\n    for _ in range(Q):\n        (i, x) = map(int, input().split())\n        i -= 1\n        A[i] = x\n        if i == 0:\n            T.update(0, A[i] - A[i + 1])\n        elif i == N - 1:\n            T.update(N - 2, A[N - 2] - A[N - 1])\n        else:\n            T.update(i - 1, A[i - 1] - A[i])\n            T.update(i, A[i] - A[i + 1])\n        print(max(T.query(0, N - 1), 0))\nfor _ in range(int(input())):\n    answer()", "T = int(input())\nfor _ in range(T):\n    (N, Q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    goodness = 0\n    for j in range(N - 1):\n        goodness = max(goodness, A[j] - A[j + 1])\n    for q in range(Q):\n        (i, x) = map(int, input().split())\n        change = False\n        if i > 1 and goodness == A[i - 2] - A[i - 1]:\n            change = True\n        if i < N and goodness == A[i - 1] - A[i]:\n            change = True\n        A[i - 1] = x\n        if change:\n            goodness = 0\n            for j in range(N - 1):\n                goodness = max(goodness, A[j] - A[j + 1])\n        else:\n            if i > 1:\n                goodness = max(goodness, A[i - 2] - A[i - 1])\n            if i < N:\n                goodness = max(goodness, A[i - 1] - A[i])\n        print(goodness)", "T = int(input())\nfor _ in range(T):\n    (N, Q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    goodness = 0\n    for j in range(N - 1):\n        goodness = max(goodness, A[j] - A[j + 1])\n    for q in range(Q):\n        (i, x) = map(int, input().split())\n        change = False\n        if i > 1 and goodness == A[i - 2] - A[i - 1]:\n            change = True\n        if i < N and goodness == A[i - 1] - A[i]:\n            change = True\n        A[i - 1] = x\n        if change:\n            goodness = 0\n            for j in range(N - 1):\n                goodness = max(goodness, A[j] - A[j + 1])\n        else:\n            if i > 1:\n                goodness = max(goodness, A[i - 2] - A[i - 1])\n            if i < N:\n                goodness = max(goodness, A[i - 1] - A[i])\n        print(goodness)", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    l1 = list(map(int, input().split()))\n    maximo = max([0] + [a - b for (a, b) in zip(l1, l1[1:])])\n    for blah in range(q):\n        (i, xy) = list(map(int, input().split()))\n        i -= 1\n        rc = False\n        if i > 0 and maximo == l1[i - 1] - l1[i]:\n            rc = True\n        if i < n - 1 and maximo == l1[i] - l1[i + 1]:\n            rc = True\n        l1[i] = xy\n        if rc:\n            maximo = max([0] + [a - b for (a, b) in zip(l1, l1[1:])])\n        else:\n            if i > 0:\n                maximo = max(maximo, l1[i - 1] - l1[i])\n            if i < n - 1:\n                maximo = max(maximo, l1[i] - l1[i + 1])\n        print(maximo)", "from heapq import heapify, heappop, heappush\nt = int(input())\nfor _ in range(t):\n    (N, Q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    h = {}\n    mh = []\n    for i in range(N - 1):\n        if A[i] > A[i + 1]:\n            mh.append(-(A[i] - A[i + 1]))\n        h[A[i] - A[i + 1]] = 1 + h.get(A[i] - A[i + 1], 0)\n    heapify(mh)\n    for q in range(Q):\n        (i, x) = map(int, input().split())\n        i -= 1\n        if i < N - 1:\n            h[A[i] - A[i + 1]] -= 1\n            h[x - A[i + 1]] = 1 + h.get(x - A[i + 1], 0)\n            heappush(mh, -(x - A[i + 1]))\n        if i > 0:\n            h[A[i - 1] - A[i]] -= 1\n            h[A[i - 1] - x] = 1 + h.get(A[i - 1] - x, 0)\n            heappush(mh, -(A[i - 1] - x))\n        A[i] = x\n        while h[-mh[0]] == 0:\n            heappop(mh)\n        print(-mh[0] if mh[0] < 0 else 0)", "from sys import maxsize\nINT_MIN = -maxsize\n\ndef construct_segment_tree(a: list, n: int, segtree):\n    for i in range(n):\n        segtree[n + i] = a[i]\n    for i in range(n - 1, 0, -1):\n        segtree[i] = max(segtree[2 * i], segtree[2 * i + 1])\n\ndef update(pos: int, value: int, n: int, segtree):\n    pos += n\n    segtree[pos] = value\n    while pos > 1:\n        pos //= 2\n        segtree[pos] = max(segtree[2 * pos], segtree[2 * pos + 1])\n\ndef range_query(left: int, right: int, n: int, segtree) -> int:\n    left += n\n    right += n\n    ma = INT_MIN\n    while left < right:\n        if left & 1:\n            ma = max(ma, segtree[left])\n            left += 1\n        if right & 1:\n            right -= 1\n            ma = max(ma, segtree[right])\n        left //= 2\n        right //= 2\n    return ma\nt = int(input())\nfor _ in range(t):\n    (N, Q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    res = []\n    for i in range(N - 1):\n        res.append(A[i] - A[i + 1])\n    tree = [0] * (2 * len(res))\n    construct_segment_tree(res, len(res), tree)\n    for q in range(Q):\n        (i, x) = map(int, input().split())\n        i -= 1\n        if i == 0:\n            update(i, x - A[i + 1], N - 1, tree)\n        elif i == N - 1:\n            update(i - 1, A[i - 1] - x, N - 1, tree)\n        else:\n            update(i - 1, A[i - 1] - x, N - 1, tree)\n            update(i, x - A[i + 1], N - 1, tree)\n        A[i] = x\n        res = max(0, range_query(0, N - 1, N - 1, tree))\n        print(res)", "from heapq import heappop, heappush\nt = int(input())\nfor i in range(t):\n    (n, q) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    heap = []\n    d = {}\n    for i in range(1, n):\n        if arr[i - 1] > arr[i]:\n            diff = arr[i - 1] - arr[i]\n            heappush(heap, -diff)\n            if diff not in d:\n                d[diff] = 0\n            d[diff] += 1\n    for j in range(q):\n        (index, ele) = map(int, input().split())\n        index -= 1\n        if index != 0 and arr[index] < arr[index - 1]:\n            diff = arr[index - 1] - arr[index]\n            if d[diff] != 0:\n                d[diff] -= 1\n        if index != n - 1 and arr[index] > arr[index + 1]:\n            diff = arr[index] - arr[index + 1]\n            if d[diff] != 0:\n                d[diff] -= 1\n        arr[index] = ele\n        if index != 0 and arr[index] < arr[index - 1]:\n            diff = arr[index - 1] - arr[index]\n            if diff not in d or d[diff] == 0:\n                heappush(heap, -diff)\n                d[diff] = 0\n            d[diff] += 1\n        if index != n - 1 and arr[index] > arr[index + 1]:\n            diff = arr[index] - arr[index + 1]\n            if diff not in d or d[diff] == 0:\n                heappush(heap, -diff)\n                d[diff] = 0\n            d[diff] += 1\n        while heap:\n            diff = -1 * heappop(heap)\n            if d[diff] != 0:\n                heappush(heap, -1 * diff)\n                break\n        if heap:\n            print(-1 * heap[0])\n        else:\n            print(0)", "t = int(input())\nfor _ in range(t):\n    (N, Q) = map(int, input().split())\n    arrA = list(map(int, input().split()))\n    ops_count = 0\n    index = -1\n    compute = False\n    for inp in range(Q):\n        (i, x) = map(int, input().split())\n        arrA[i - 1] = x\n        if i == index + 1 or i == index + 2:\n            compute = True\n        init_total_ops = 0\n        if inp == 0 or compute:\n            compute = False\n            incre = 0\n            max_diff = 0\n            for it in range(N - 1):\n                ele1 = arrA[it]\n                ele2 = arrA[it + 1]\n                temp_diff = ele1 - ele2\n                if max_diff < temp_diff:\n                    max_diff = temp_diff\n                    index = it\n            ops_count = max_diff\n        elif i == 1:\n            if arrA[0] > arrA[1]:\n                diff = arrA[0] - arrA[1]\n                if diff > ops_count:\n                    ops_count = diff\n                    index = 0\n        elif i == N:\n            if arrA[N - 2] > arrA[N - 1]:\n                diff = arrA[N - 2] - arrA[N - 1]\n                if diff > ops_count:\n                    ops_count = diff\n                    index = N - 2\n        elif arrA[i - 2] > arrA[i - 1] or arrA[i - 1] > arrA[i]:\n            if arrA[i - 2] - arrA[i - 1] > arrA[i - 1] - arrA[i]:\n                diff = arrA[i - 2] - arrA[i - 1]\n                if diff > ops_count:\n                    ops_count = diff\n                    index = i - 2\n            else:\n                diff = arrA[i - 1] - arrA[i]\n                if diff > ops_count:\n                    ops_count = diff\n                    index = i - 1\n        print(ops_count)", "from collections import defaultdict\n\ndef goodness(A, idx, ans, mp, mpp):\n    nxt = ans\n    if idx > 0:\n        mpp[mp[idx]] = max(mpp[mp[idx]] - 1, 0)\n        sol = max(0, A[idx - 1] - A[idx])\n        mp[idx] = sol\n        mpp[sol] += 1\n        nxt = max(nxt, sol)\n    if idx < len(A) - 1:\n        mpp[mp[idx + 1]] = max(mpp[mp[idx + 1]] - 1, 0)\n        sol = max(0, A[idx] - A[idx + 1])\n        mp[idx + 1] = sol\n        mpp[sol] += 1\n        nxt = max(nxt, sol)\n    if nxt > ans:\n        return (nxt, mp, mpp)\n    elif mpp[ans] > 0:\n        return (ans, mp, mpp)\n    maxx = 0\n    for (x, y) in mpp.items():\n        if y > 0:\n            maxx = max(maxx, x)\n    return (maxx, mp, mpp)\n\ndef solve():\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    mp = defaultdict(int)\n    mpp = defaultdict(int)\n    ans = 0\n    for i in range(1, len(A)):\n        sol = max(0, A[i - 1] - A[i])\n        mp[i] = sol\n        mpp[sol] += 1\n        ans = max(ans, sol)\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        A[a - 1] = b\n        (ans, mp, mpp) = goodness(A, a - 1, ans, mp, mpp)\n        print(ans)\nfor _ in range(int(input())):\n    solve()", "import sys\nimport heapq as hp\n\nclass Obj(object):\n\n    def __init__(self, diff, indx):\n        self.val = (diff, indx)\n\n    def __lt__(self, other):\n        return self.val[0] > other.val[0]\n\ndef print(a):\n    sys.stdout.write(str(a) + '\\n')\n\ndef input():\n    return sys.stdin.readline()\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    d = {}\n    h = []\n    for i in range(1, n):\n        diff = l[i - 1] - l[i]\n        hp.heappush(h, Obj(diff, i))\n    for w in range(k):\n        (x, y) = map(int, input().split())\n        x -= 1\n        l[x] = y\n        if x > 0:\n            nd1 = l[x - 1] - l[x]\n            hp.heappush(h, Obj(nd1, x))\n        if x < n - 1:\n            nd2 = l[x] - l[x + 1]\n            hp.heappush(h, Obj(nd2, x + 1))\n        while True:\n            (dif, ind) = h[0].val\n            if l[ind - 1] - l[ind] == dif:\n                print(max(0, dif))\n                break\n            hp.heappop(h)", "import numpy as np\nfrom heapq import heapify, heappush, heappop\n\ndef ggt(A):\n    goodness_tata = list(np.diff(A))\n    heapify(goodness_tata)\n    return goodness_tata\n\ndef ugt(A, goodness_tata, cheap, i, x):\n    if i - 1:\n        heappush(goodness_tata, x - A[i - 2])\n        heappush(cheap, A[i - 1] - A[i - 2])\n    if i < len(A):\n        heappush(goodness_tata, A[i] - x)\n        heappush(cheap, A[i] - A[i - 1])\n    A[i - 1] = x\n\ndef sgt(goodness_tata, cheap):\n    s = goodness_tata[0]\n    while cheap and s == cheap[0]:\n        heappop(goodness_tata)\n        heappop(cheap)\n        s = goodness_tata[0]\n    return s * -int(s < 0)\nT = int(input())\nfor i in range(T):\n    (N, Q) = map(int, input().split())\n    A = np.array(input().split(), dtype=int)\n    goodness_tata = ggt(A)\n    cheap = []\n    for j in range(Q):\n        (i, x) = map(int, input().split())\n        ugt(A, goodness_tata, cheap, i, x)\n        print(sgt(goodness_tata, cheap))", "T = int(input())\nfor t in range(T):\n    (N, Q) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    maximo = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n    for q in range(Q):\n        recalculate = False\n        (i, x) = list(map(int, input().split()))\n        i -= 1\n        if i > 0 and maximo == A[i - 1] - A[i]:\n            recalculate = True\n        if i < N - 1 and maximo == A[i] - A[i + 1]:\n            recalculate = True\n        A[i] = x\n        if recalculate:\n            maximo = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n        else:\n            if i > 0:\n                maximo = max(maximo, A[i - 1] - A[i])\n            if i < N - 1:\n                maximo = max(maximo, A[i] - A[i + 1])\n        print(maximo)", "T = int(input())\n\ndef findMax(p):\n    (ans1, ans2) = (set(), 0)\n    for i in range(len(p)):\n        if p[i] > ans2:\n            ans1 = {i}\n            ans2 = p[i]\n        elif p[i] == ans2:\n            ans1.add(i)\n        else:\n            pass\n    return (ans1, ans2)\n\ndef updateMax(maxSet, maxValue, index, value):\n    if value < maxValue:\n        if index in maxSet:\n            maxSet.remove(index)\n        else:\n            pass\n    elif value == maxValue:\n        maxSet.add(index)\n    else:\n        maxSet = {index}\n        maxValue = value\n    return (maxSet, maxValue)\nfor _ in range(T):\n    (n, q) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    arr = [0] * n\n    for i in range(1, n):\n        arr[i] = max(a[i - 1] - a[i], 0)\n    (maxSet, maxVal) = findMax(arr)\n    for __ in range(q):\n        (i, x) = [int(x) for x in input().split()]\n        a[i - 1] = x\n        if i != 1:\n            arr[i - 1] = max(a[i - 2] - x, 0)\n            (maxSet, maxVal) = updateMax(maxSet, maxVal, i - 1, arr[i - 1])\n            if len(maxSet) == 0:\n                (maxSet, maxVal) = findMax(arr)\n        if i != n:\n            arr[i] = max(x - a[i], 0)\n            (maxSet, maxVal) = updateMax(maxSet, maxVal, i, arr[i])\n            if len(maxSet) == 0:\n                (maxSet, maxVal) = findMax(arr)\n        print(maxVal)"]