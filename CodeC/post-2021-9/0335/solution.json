["for _ in range(int(input())):\n    (N, X, Y) = list(map(int, input().split()))\n    A = sorted(list(map(int, input().split())))\n    xd = 0\n    v = A[0] ^ X\n    for i in range(N):\n        if A[i] > v:\n            break\n        if A[i] ^ X <= A[i]:\n            break\n        v = min(v, A[i] ^ X)\n        A[i] = A[i] ^ X\n        xd += 1\n        if xd == Y:\n            break\n    Y -= xd\n    A = sorted(A)\n    if Y % 2 == 0:\n        print(*A)\n    else:\n        A[0] = A[0] ^ X\n        print(*A)", "import heapq as hq\n\ndef soln(n, x, y, arr):\n    arr = [[arr[i], i] for i in range(n)]\n    hq.heapify(arr)\n    (ind, count) = (-1, -1)\n    for ix in range(y):\n        (cur, i) = hq.heappop(arr)\n        hq.heappush(arr, [cur ^ x, i])\n        if i == ind:\n            count += 1\n            if count > 3:\n                if y - ix - 1 & 1:\n                    (cur, i) = hq.heappop(arr)\n                    hq.heappush(arr, [cur ^ x, i])\n                break\n        else:\n            ind = i\n            count = 0\n    return sorted([i[0] for i in arr])\nfor _ in range(int(input())):\n    (n, x, y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    print(*soln(n, x, y, arr))", "for _ in range(int(input())):\n    (N, X, Y) = list(map(int, input().split()))\n    A = sorted(list(map(int, input().split())))\n    xd = 0\n    v = A[0] ^ X\n    for i in range(N):\n        if A[i] > v:\n            break\n        if A[i] ^ X <= A[i]:\n            break\n        v = min(v, A[i] ^ X)\n        A[i] = A[i] ^ X\n        xd += 1\n        if xd == Y:\n            break\n    Y -= xd\n    A = sorted(A)\n    if Y % 2 == 0:\n        print(*A)\n    else:\n        A[0] = A[0] ^ X\n        print(*A)", "for t in range(int(input())):\n    (n, x, y) = [int(el) for el in input().split()]\n    a = sorted([int(el) for el in input().split()])\n    new = []\n    currentmin = (float('inf'), -1)\n    for (index, el) in enumerate(a):\n        if el < currentmin[0] and y != 0:\n            el ^= x\n            new.append(el)\n            currentmin = min((el, index), currentmin)\n            y -= 1\n        else:\n            index -= 1\n            break\n    newarray = new + a[index + 1:]\n    if y % 2 != 0:\n        newarray[currentmin[1]] ^= x\n    print(*sorted(newarray))", "import heapq\nfor item in range(int(input())):\n    (n, x, y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    heapq.heapify(arr)\n    temp = y\n    while y:\n        if y == 0:\n            break\n        t = arr[0] ^ x\n        if t < arr[0]:\n            break\n        heapq.heappop(arr)\n        heapq.heappush(arr, t)\n        y = y - 1\n    if y % 2 != 0:\n        t = arr[0] ^ x\n        heapq.heappop(arr)\n        heapq.heappush(arr, t)\n    arr.sort()\n    print(*arr, sep=' ')", "import heapq\nfor item in range(int(input())):\n    (n, x, y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    heapq.heapify(arr)\n    temp = y\n    while y:\n        if y == 0:\n            break\n        t = arr[0] ^ x\n        if t < arr[0]:\n            break\n        heapq.heappop(arr)\n        heapq.heappush(arr, t)\n        y = y - 1\n    if y % 2 != 0:\n        t = arr[0] ^ x\n        heapq.heappop(arr)\n        heapq.heappush(arr, t)\n    arr.sort()\n    print(*arr, sep=' ')", "import heapq\nfor item in range(int(input())):\n    (n, x, y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    heapq.heapify(arr)\n    temp = y\n    while y:\n        if y == 0:\n            break\n        t = arr[0] ^ x\n        if t < arr[0]:\n            break\n        heapq.heappop(arr)\n        heapq.heappush(arr, t)\n        y = y - 1\n    if y % 2 == 1:\n        t = arr[0] ^ x\n        heapq.heappop(arr)\n        heapq.heappush(arr, t)\n    arr.sort()\n    print(*arr, sep=' ')", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "from bisect import bisect_right\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (N, X, Y) = map(int, input().split())\n    A = sorted(list(map(int, input().split())))\n    (xor, ind) = (float('inf'), 0)\n    for i in range(N):\n        if Y == 0:\n            break\n        if xor <= A[i]:\n            break\n        tmp = A[i] ^ X\n        if tmp < xor:\n            xor = tmp\n            ind = i\n        A[i] = tmp\n        Y -= 1\n    if Y % 2:\n        A[ind] ^= X\n    A.sort()\n    print(*A)", "from bisect import bisect_right\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (N, X, Y) = map(int, input().split())\n    A = sorted(list(map(int, input().split())))\n    for j in range(Y):\n        n = A.pop(0) ^ X\n        i = bisect_right(A, n)\n        if i == N - 1:\n            A.append(n)\n        else:\n            A.insert(i, n)\n        if i == 0:\n            if (Y - j - 1) % 2:\n                A[0] ^= X\n            break\n    print(*A)", "from bisect import bisect_left\nfrom code import interact\nfrom heapq import heapify, heappush, heappop\nfrom collections import deque\nfrom pydoc import plain\nimport sys\nfrom math import gcd, sqrt, log10, log2, floor, ceil, sqrt\ninput = sys.stdin.readline\n\ndef il():\n    return [int(a) for a in input().strip().split()]\n\ndef ip():\n    return input().strip()\n\ndef ii():\n    return int(input())\n\ndef ot(in_p, *args, e=' '):\n    if type(in_p) == list:\n        print(*in_p, end=e)\n    if type(in_p) == str or type(in_p) == int:\n        print(in_p, end=e)\n        for l in args:\n            print(l, end=e)\n    print()\n\ndef a_pwr_n(a, n, mod):\n    if n == 1:\n        return a % mod\n    if n % 2 == 0:\n        val = a_pwr_n(a, n // 2, mod)\n        return val % mod * val % mod\n    else:\n        return a % mod * a_pwr_n(a, n - 1, mod) % mod\n\ndef rg(*ag):\n    if len(ag) == 3:\n        return range(ag[0], ag[1], ag[2])\n    elif len(ag) == 2:\n        return range(ag[0], ag[1])\n    elif len(ag) == 1:\n        return range(ag[0])\n    else:\n        raise 'invalid input'\n\ndef ispal(i, j, st):\n    while i <= j:\n        if st[i] == st[j]:\n            i = i + 1\n            j = j - 1\n        else:\n            return False\n    return True\nmod = 1000000000 + 7\ndx = [-1, -2, 1, 2, 2, -2, -1, 1]\ndy = [2, 1, 2, 1, -1, -1, -2, -2]\nfor _ in range(ii()):\n    (N, A, B) = il()\n    arr = il()\n    m = []\n    for j in arr:\n        heappush(m, (j, False))\n    for k in range(B):\n        ele = heappop(m)\n        if ele[1]:\n            s = B - k\n            if s % 2 == 0:\n                heappush(m, ele)\n            else:\n                heappush(m, (ele[0] ^ A, True))\n            break\n        heappush(m, (ele[0] ^ A, True))\n    ans = ''\n    while m:\n        ans += str(heappop(m)[0]) + ' '\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, x, y) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort()\n    l[0] ^= x\n    m = l[0]\n    count = 1\n    for i in range(1, n):\n        if l[i] >= m or count >= y:\n            break\n        l[i] ^= x\n        m = min(l[i], m)\n        count += 1\n    l.sort()\n    if (y - count) % 2:\n        l[0] ^= x\n    print(*l)", "t = int(input())\nfor _ in range(t):\n    (n, x, y) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort()\n    l[0] ^= x\n    m = l[0]\n    count = 1\n    for i in range(1, n):\n        if l[i] >= m or count >= y:\n            break\n        l[i] ^= x\n        m = min(l[i], m)\n        count += 1\n    l.sort()\n    if (y - count) % 2:\n        l[0] ^= x\n    print(*l)", "import heapq\nfor _ in range(int(input())):\n    (n, x, y) = [int(temp) for temp in input().split()]\n    a = {}\n    a = [int(temp) for temp in input().split()]\n    heapq.heapify(a)\n    while y:\n        min = x ^ a[0]\n        if n == 1 or (n == 2 and min < a[1]) or (n > 2 and min < a[1] and (min < a[2])):\n            break\n        heapq.heappop(a)\n        heapq.heappush(a, min)\n        y -= 1\n    if y % 2:\n        a[0] = a[0] ^ x\n    for i in range(0, n):\n        print(heapq.heappop(a), end=' ')\n    print()", "def solve(N, X, Y, A):\n    A.sort()\n    A[0] ^= X\n    mn = A[0]\n    count = 1\n    for i in range(1, N):\n        if A[i] >= mn or count >= Y:\n            break\n        A[i] ^= X\n        mn = min(A[i], mn)\n        count += 1\n    A.sort()\n    if (Y - count) % 2:\n        A[0] ^= X\n    return A\nfor _ in range(int(input())):\n    (N, X, Y) = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n    print(*solve(N, X, Y, A))", "for _ in range(int(input())):\n    (n, x, y) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    c = a[0] ^ x\n    i = 1\n    a[0] = a[0] ^ x\n    while i < len(a) and c > a[i] and (i < y):\n        a[i] = a[i] ^ x\n        if a[i] < c:\n            c = a[i]\n        i += 1\n    a.sort()\n    if (y - i) % 2 != 0:\n        a[0] = a[0] ^ x\n    print(*a)", "for _ in range(int(input())):\n    (N, X, Y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    operation_count = 1\n    arr[0] = arr[0] ^ X\n    minimum = arr[0]\n    for i in range(1, N):\n        if arr[i] < minimum and operation_count < Y:\n            operation_count += 1\n            arr[i] = arr[i] ^ X\n            minimum = min(arr[i], minimum)\n        else:\n            break\n    arr.sort()\n    if (Y - operation_count) % 2 == 1:\n        arr[0] = arr[0] ^ X\n    print(*arr)", "for _ in range(int(input())):\n    (N, X, Y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    operation_count = 1\n    arr[0] = arr[0] ^ X\n    minimum = arr[0]\n    for i in range(1, N):\n        if arr[i] < minimum and operation_count < Y:\n            operation_count += 1\n            arr[i] = arr[i] ^ X\n            minimum = min(arr[i], minimum)\n        else:\n            break\n    arr.sort()\n    if (Y - operation_count) % 2 == 1:\n        arr[0] = arr[0] ^ X\n    print(*arr)", "for _ in range(int(input())):\n    (N, X, Y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    operation_count = 1\n    arr[0] = arr[0] ^ X\n    minimum = arr[0]\n    for i in range(1, N):\n        if arr[i] < minimum and operation_count < Y:\n            operation_count += 1\n            arr[i] = arr[i] ^ X\n            minimum = min(arr[i], minimum)\n        else:\n            break\n    arr.sort()\n    if (Y - operation_count) % 2 == 1:\n        arr[0] = arr[0] ^ X\n    print(*arr)", "for _ in range(int(input())):\n    (N, X, Y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    operation_count = 1\n    arr[0] = arr[0] ^ X\n    minimum = arr[0]\n    for i in range(1, N):\n        if arr[i] < minimum and operation_count < Y:\n            operation_count += 1\n            arr[i] = arr[i] ^ X\n            minimum = min(arr[i], minimum)\n    arr.sort()\n    if (Y - operation_count) % 2 == 1:\n        arr[0] = arr[0] ^ X\n    print(*arr)", "for _ in range(int(input())):\n    (N, X, Y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    operation_count = 1\n    arr[0] = arr[0] ^ X\n    minimum = arr[0]\n    for i in range(1, N):\n        if arr[i] < minimum and operation_count < Y:\n            operation_count += 1\n            arr[i] = arr[i] ^ X\n            minimum = min(arr[i], minimum)\n    arr.sort()\n    if (Y - operation_count) % 2 == 1:\n        arr[0] = arr[0] ^ X\n    print(*arr)", "import bisect\nr = int(input())\nfor _ in range(r):\n    (n, x, y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    c = 0\n    while y > 0:\n        t = arr[0] ^ x\n        del arr[0]\n        p = bisect.bisect_left(arr, t)\n        if p == 0 or y == 1:\n            if y % 2 == 0:\n                t = t ^ x\n                arr.insert(p, t)\n                break\n            else:\n                arr.insert(p, t)\n                break\n        else:\n            arr.insert(p, t)\n            y -= 1\n    print(*arr)", "import bisect\nfor i in range(int(input())):\n    a = list(map(int, input().strip().split()))\n    b = list(map(int, input().strip().split()))\n    b.sort()\n    while True:\n        t = b[0] ^ a[1]\n        del b[0]\n        c = bisect.bisect_left(b, t)\n        if c == 0 or a[2] - 1 == 0:\n            if a[2] % 2 == 1:\n                b.insert(c, t)\n                break\n            else:\n                t = t ^ a[1]\n                b.insert(c, t)\n                break\n        else:\n            a[2] -= 1\n            b.insert(c, t)\n    print(*b)", "import bisect\nfor i in range(int(input())):\n    a = list(map(int, input().strip().split()))\n    b = list(map(int, input().strip().split()))\n    b.sort()\n    while True:\n        t = b[0] ^ a[1]\n        del b[0]\n        c = bisect.bisect_left(b, t)\n        if c == 0 or a[2] - 1 == 0:\n            if a[2] % 2 == 1:\n                b.insert(c, t)\n                break\n            else:\n                t = t ^ a[1]\n                b.insert(c, t)\n                break\n        else:\n            a[2] -= 1\n            b.insert(c, t)\n    print(*b)", "for _ in range(int(input())):\n    (N, X, Y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    operation_count = 1\n    arr[0] = arr[0] ^ X\n    minimum = arr[0]\n    for i in range(1, N):\n        if arr[i] < minimum and operation_count < Y:\n            operation_count += 1\n            arr[i] = arr[i] ^ X\n            minimum = min(arr[i], minimum)\n    arr.sort()\n    if (Y - operation_count) % 2 == 1:\n        arr[0] = arr[0] ^ X\n    print(*arr)", "import heapq\n\ndef main():\n    import sys\n    test_cases = int(sys.stdin.readline())\n    for _ in range(test_cases):\n        (_, X, Y) = (int(n) for n in sys.stdin.readline().strip().split())\n        A = [int(n) for n in sys.stdin.readline().strip().split()]\n        heapq.heapify(A)\n        while Y:\n            a = A[0]\n            b = a ^ X\n            if b < a:\n                break\n            else:\n                heapq.heappop(A)\n                heapq.heappush(A, b)\n                Y -= 1\n        if Y % 2 == 1:\n            a = heapq.heappop(A)\n            b = a ^ X\n            heapq.heappush(A, b)\n        A.sort()\n        print(' '.join((str(a) for a in A)))\nmain()", "def solve_test_case():\n    (N, X, Y) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    A.sort()\n    operation_count = 1\n    A[0] = A[0] ^ X\n    minimum = A[0]\n    for i in range(1, N):\n        if A[i] < minimum and operation_count < Y:\n            operation_count += 1\n            A[i] = A[i] ^ X\n            minimum = min(A[i], minimum)\n    A.sort()\n    if (Y - operation_count) % 2 == 1:\n        A[0] = A[0] ^ X\n    print(*A)\nT = int(input())\nfor _ in range(T):\n    solve_test_case()", "for i in range(int(input())):\n    (n, x, y) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    a.sort()\n    c = 1\n    a[0] = a[0] ^ x\n    m = a[0]\n    for j in range(1, n):\n        if a[j] < m and c < y:\n            c += 1\n            a[j] = a[j] ^ x\n            m = min(a[j], m)\n    a.sort()\n    if (y - c) % 2 == 1:\n        a[0] = a[0] ^ x\n    print(*a)", "for i in range(int(input())):\n    (n, x, y) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    a.sort()\n    c = 1\n    a[0] = a[0] ^ x\n    m = a[0]\n    for j in range(1, n):\n        if a[j] < m and c < y:\n            c += 1\n            a[j] = a[j] ^ x\n            m = min(a[j], m)\n    a.sort()\n    if (y - c) % 2 == 1:\n        a[0] = a[0] ^ x\n    print(*a)", "import heapq as h\n\ndef insert(arr: list, x, low: int, high: int):\n    if high >= low:\n        mid = (high + low) // 2\n        if arr[mid] <= x:\n            if mid + 1 == len(arr) or arr[mid + 1] >= x:\n                arr.insert(mid + 1, x)\n            else:\n                insert(arr, x, mid + 1, high)\n        else:\n            insert(arr, x, low, mid - 1)\n    else:\n        arr.insert(0, x)\nt = int(input())\nfor _ in range(t):\n    (n, x, y) = map(int, input().split(' '))\n    if n == 1:\n        a = int(input())\n        print(a) if y % 2 == 0 else print(a ^ x)\n    else:\n        a = list(map(int, input().split(' ')))\n        h.heapify(a)\n        __ = 0\n        while __ < y:\n            b = h.heappop(a)\n            xored = b ^ x\n            h.heappush(a, xored)\n            __ += 1\n            c = h.heappop(a)\n            if c == xored:\n                if (y - __) % 2 == 0:\n                    h.heappush(a, c)\n                else:\n                    h.heappush(a, b)\n                break\n            else:\n                h.heappush(a, c)\n        a.sort()\n        print(*a)", "import heapq as h\n\ndef insert(arr: list, x, low: int, high: int):\n    if high >= low:\n        mid = (high + low) // 2\n        if arr[mid] <= x:\n            if mid + 1 == len(arr) or arr[mid + 1] >= x:\n                arr.insert(mid + 1, x)\n            else:\n                insert(arr, x, mid + 1, high)\n        else:\n            insert(arr, x, low, mid - 1)\n    else:\n        arr.insert(0, x)\nt = int(input())\nfor _ in range(t):\n    (n, x, y) = map(int, input().split(' '))\n    if n == 1:\n        a = int(input())\n        print(a) if y % 2 == 0 else print(a ^ x)\n    else:\n        a = list(map(int, input().split(' ')))\n        h.heapify(a)\n        __ = 0\n        while __ < y:\n            b = h.heappop(a)\n            xored = b ^ x\n            h.heappush(a, xored)\n            __ += 1\n            c = h.heappop(a)\n            if c == xored:\n                if (y - __) % 2 == 0:\n                    h.heappush(a, c)\n                else:\n                    h.heappush(a, b)\n                break\n            else:\n                h.heappush(a, c)\n        a.sort()\n        print(*a)", "for _ in range(int(input())):\n    (n, x, y) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    a[0] ^= x\n    minxor = a[0]\n    j = 1\n    while j < y and j < n and (minxor > a[j]):\n        a[j] ^= x\n        minxor = min(minxor, a[j])\n        j += 1\n    a.sort()\n    if (y - j) % 2 == 1:\n        a[0] = a[0] ^ x\n    a.sort()\n    print(*a)", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random, threading\nfrom functools import lru_cache\nfrom itertools import *\nimport sys\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n(M, M1) = (1000000007, 998244353)\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for _ in range(how_much_noob_I_am):\n        (n, x, y) = sep()\n        arr = lis()\n        arr.sort()\n        xor = arr[0] ^ x\n        if xor <= arr[0]:\n            min1 = 0\n        else:\n            min1 = 0\n            arr[0] = xor\n            y -= 1\n            for i in range(1, n):\n                if y == 0:\n                    break\n                if arr[i] >= xor:\n                    break\n                p = arr[i] ^ x\n                if p < xor:\n                    xor = p\n                    min1 = i\n                arr[i] = p\n                y -= 1\n        if y % 2 != 0:\n            arr[min1] = arr[min1] ^ x\n        arr.sort()\n        print(*arr)\nmain()", "for _ in range(int(input())):\n    (n, x, steps) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    a[0] ^= x\n    minXor = a[0]\n    step = 1\n    while step < steps and step < n and (minXor > a[step]):\n        a[step] ^= x\n        minXor = min(minXor, a[step])\n        step += 1\n    a.sort()\n    if (steps - step) % 2:\n        a[0] ^= x\n    print(*a)", "t = int(input())\nfor _ in range(t):\n    (n, x, y) = map(int, input().split())\n    ali = list(map(int, input().split()))\n    ali.sort()\n    nm = ali[0] ^ x\n    i = 1\n    ali[0] = ali[0] ^ x\n    while i < len(ali) and nm > ali[i] and (i < y):\n        ali[i] = ali[i] ^ x\n        if ali[i] < nm:\n            nm = ali[i]\n        i += 1\n    ali.sort()\n    if (y - i) % 2 != 0:\n        ali[0] = ali[0] ^ x\n    print(*ali)", "for _ in range(int(input())):\n    (n, x, y) = map(int, input().split())\n    num = list(map(int, input().split()))\n    num.sort()\n    co = 1\n    small = num[0] ^ x\n    num[0] = small\n    for i in range(1, n):\n        char = num[i]\n        if char < small and co < y:\n            co += 1\n            num[i] = char ^ x\n            small = min(char ^ x, small)\n    num.sort()\n    r = y - co\n    if r % 2 == 1:\n        num[0] = num[0] ^ x\n    for i in range(n):\n        print(num[i], end=' ')\n    print('')", "import bisect\nt = int(input())\nfor t_1 in range(t):\n    (n, x, y) = [int(item) for item in input().split(' ')]\n    numbers = [int(item) for item in input().split(' ')]\n    numbers = sorted(numbers)\n    count_of_each_number = {}\n    for num in numbers + [item ^ x for item in numbers]:\n        if not count_of_each_number.__contains__(num):\n            count_of_each_number[num] = 0\n    for num in numbers:\n        if not count_of_each_number.__contains__(num):\n            count_of_each_number[num] = 0\n        count_of_each_number[num] += 1\n    all_nums = sorted(count_of_each_number.keys())\n    index_Of_all = 0\n    done_steps = 0\n    while done_steps < y:\n        while count_of_each_number[all_nums[index_Of_all]] == 0:\n            index_Of_all += 1\n        min_number = all_nums[index_Of_all]\n        new_number = min_number ^ x\n        reminded_y = y - done_steps\n        if new_number < min_number:\n            done_steps += reminded_y - reminded_y % 2\n            doing_steps = reminded_y % 2\n        else:\n            doing_steps = min(reminded_y, count_of_each_number[min_number])\n        count_of_each_number[min_number] -= doing_steps\n        count_of_each_number[new_number] += doing_steps\n        done_steps += doing_steps\n    result = []\n    for num in all_nums:\n        for i in range(count_of_each_number[num]):\n            result.append(num)\n    print(' '.join([str(item) for item in result]))", "from queue import PriorityQueue\nt = int(input())\nfor _ in range(t):\n    (n, x, y) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    q = PriorityQueue()\n    for each in arr:\n        q.put(each)\n    while y:\n        smallest = q.get()\n        if smallest ^ x > smallest:\n            q.put(smallest ^ x)\n            y -= 1\n        elif y & 1 == 0:\n            q.put(smallest)\n            break\n        else:\n            q.put(smallest ^ x)\n            break\n    while not q.empty():\n        print(q.get(), end=' ')\n    print()", "from heapq import heappush, heappop, heapify\n\ndef solve(n, x, y, arr):\n    h = [(num, i) for (i, num) in enumerate(arr)]\n    heapify(h)\n    seen = set()\n    last = -1\n    while y > 0:\n        (num, i) = heappop(h)\n        y -= 1\n        heappush(h, (num ^ x, i))\n        if i in seen:\n            last = i\n            break\n        seen.add(i)\n    if y % 2 == 1:\n        arr[last] ^= x\n    for i in seen:\n        if i != last:\n            arr[i] ^= x\n    return ' '.join(map(str, sorted(arr)))\nfor _ in range(int(input())):\n    (n, x, y) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    print(solve(n, x, y, arr))", "t = int(input())\nfor _ in range(t):\n    (n, x, y) = map(int, input().split())\n    ls = list(map(int, input().split()))\n    ls.sort()\n    m = ls[0] ^ x\n    c = 1\n    ls[0] = m\n    for i in range(1, n):\n        ch = ls[i]\n        if ls[i] < m and c < y:\n            c += 1\n            ls[i] = ch ^ x\n            m = min(m, ch ^ x)\n    ls.sort()\n    r = y - c\n    if r % 2 == 1:\n        ls[0] = ls[0] ^ x\n    print(*ls)", "for _ in range(int(input())):\n    (n, x, y) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    c = a[0] ^ x\n    i = 1\n    a[0] = a[0] ^ x\n    while i < len(a) and c > a[i] and (i < y):\n        a[i] = a[i] ^ x\n        if a[i] < c:\n            c = a[i]\n        i += 1\n    a.sort()\n    if (y - i) % 2 != 0:\n        a[0] = a[0] ^ x\n    print(*a)", "n = int(input())\nfor i in range(n):\n    (N, X, Y) = (int(x) for x in input().split())\n    ls = [int(x) for x in input().split()]\n    ls.sort()\n    count = 1\n    mini = ls[0]\n    small = mini ^ X\n    ls[0] = small\n    for i in range(1, N):\n        ch = ls[i]\n        if ch < small and count < Y:\n            count = count + 1\n            ls[i] = ch ^ X\n            small = min(ch ^ X, small)\n    ls.sort()\n    r = Y - count\n    if r % 2 == 1:\n        ls[0] = ls[0] ^ X\n    for i in ls:\n        print(i, end=' ')\n    else:\n        print()", "import heapq\nfrom heapq import heappop, heappush, heapify\nt = int(input())\nfor i in range(t):\n    (N, X, Y) = map(int, input().strip().split())\n    ls = list(map(int, input().strip().split()))\n    heapq.heapify(ls)\n    prev = -1\n    while Y > 0:\n        a = heapq.heappop(ls)\n        val = a ^ X\n        if val == prev:\n            heapq.heappush(ls, a)\n            break\n        heapq.heappush(ls, val)\n        prev = a\n        Y -= 1\n    if Y % 2 == 1:\n        a = heapq.heappop(ls)\n        val = a ^ X\n        heapq.heappush(ls, val)\n    ls.sort()\n    for j in range(N):\n        print(ls[j], end=' ')\n    print()", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "from heapq import heapify, heappop, heappush\nfor _ in range(int(input())):\n    (n, x, y) = map(int, input().split())\n    a = list(map(int, input().split()))\n    heapify(a)\n    for c in range(y):\n        i = heappop(a)\n        j = i ^ x\n        if j <= i:\n            if (y - c) % 2 == 0:\n                j ^= x\n            heappush(a, j)\n            break\n        heappush(a, j)\n    l = [heappop(a) for _ in range(n)]\n    print(*l)", "n = int(input())\nfor i in range(n):\n    (N, X, Y) = (int(x) for x in input().split())\n    ls = [int(x) for x in input().split()]\n    ls.sort()\n    count = 1\n    mini = ls[0]\n    small = mini ^ X\n    ls[0] = small\n    for i in range(1, N):\n        ch = ls[i]\n        if ch < small and count < Y:\n            count = count + 1\n            ls[i] = ch ^ X\n            small = min(ch ^ X, small)\n    ls.sort()\n    r = Y - count\n    if r % 2 == 1:\n        ls[0] = ls[0] ^ X\n    for i in ls:\n        print(i, end=' ')\n    else:\n        print()", "n = int(input())\nfor i in range(n):\n    (N, X, Y) = (int(x) for x in input().split())\n    ls = [int(x) for x in input().split()]\n    ls.sort()\n    count = 1\n    mini = ls[0]\n    small = mini ^ X\n    ls[0] = small\n    for i in range(1, N):\n        ch = ls[i]\n        if ch < small and count < Y:\n            count = count + 1\n            ls[i] = ch ^ X\n            small = min(ch ^ X, small)\n    ls.sort()\n    r = Y - count\n    if r % 2 == 1:\n        ls[0] = ls[0] ^ X\n    for i in ls:\n        print(i, end=' ')\n    else:\n        print()", "def fib():\n    [n, x, y] = list(map(int, input().split()))\n    num = list(map(int, input().split()))\n    num.sort()\n    co = 1\n    small = num[0] ^ x\n    num[0] = small\n    for i in range(1, n):\n        char = num[i]\n        if char < small and co < y:\n            co += 1\n            num[i] = char ^ x\n            small = min(char ^ x, small)\n    num.sort()\n    r = y - co\n    if r % 2 == 1:\n        num[0] = num[0] ^ x\n    print(' '.join((str(x) for x in num)))\nn = int(input())\nfor i in range(n):\n    fib()", "def fib():\n    [n, x, y] = list(map(int, input().split()))\n    num = list(map(int, input().split()))\n    num.sort()\n    co = 1\n    small = num[0] ^ x\n    num[0] = small\n    for i in range(1, n):\n        char = num[i]\n        if char < small and co < y:\n            co += 1\n            num[i] = char ^ x\n            small = min(char ^ x, small)\n    num.sort()\n    r = y - co\n    if r % 2 == 1:\n        num[0] = num[0] ^ x\n    print(' '.join((str(x) for x in num)))\nn = int(input())\nfor i in range(n):\n    fib()", "import heapq\nt = int(input())\nwhile t:\n    t -= 1\n    (n, x, y) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    heapq.heapify(arr)\n    last = None\n    while y:\n        a = heapq.heappop(arr)\n        if last == a:\n            heapq.heappush(arr, a)\n            break\n        y -= 1\n        last = a ^ x\n        heapq.heappush(arr, a ^ x)\n    arr.sort()\n    if y % 2:\n        arr[0] ^= x\n    s = ''\n    for a in arr:\n        s += str(a)\n        s += ' '\n    print(s[:-1])", "import heapq\n\ndef xoring(arr, X, Y, N):\n    if N == 1:\n        if Y % 2 == 0:\n            return arr\n        else:\n            return [arr[0] ^ X]\n    else:\n        i = 0\n        heapq.heapify(arr)\n        while i < Y:\n            smallest = heapq.heappop(arr)\n            a = smallest ^ X\n            heapq.heappush(arr, a)\n            b = heapq.heappop(arr)\n            i += 1\n            if b == a:\n                if (Y - i) % 2 == 0:\n                    heapq.heappush(arr, b)\n                    break\n                else:\n                    heapq.heappush(arr, smallest)\n                    break\n            else:\n                heapq.heappush(arr, b)\n        arr.sort()\n        return arr\nT = int(input())\nfor _ in range(T):\n    (N, X, Y) = tuple(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    arr.sort()\n    print(*xoring(arr, X, Y, N))", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "class MinHeap(object):\n\n    def __init__(self):\n        self.size = 0\n        self.root = 1\n        self.heap = list()\n        self.heap.append(-1)\n\n    def _ensure_non_empty_heap(self):\n        if self.size < self.root:\n            raise RuntimeError('Empty heap')\n\n    def _ensure_within_bounds(self, pos):\n        if pos > self.size:\n            raise RuntimeError('Position {0} is out of bounds of heap whose size is {1}'.format(pos, self.size))\n\n    def _parent(self, pos):\n        self._ensure_within_bounds(pos)\n        return pos // 2\n\n    def _left_child(self, pos):\n        self._ensure_within_bounds(pos)\n        return 2 * pos\n\n    def _right_child(self, pos):\n        self._ensure_within_bounds(pos)\n        return 2 * pos + 1\n\n    def _is_leaf(self, pos):\n        self._ensure_within_bounds(pos)\n        return 2 * pos > self.size\n\n    def _swap(self, pos_a, pos_b):\n        self._ensure_within_bounds(pos_a)\n        self._ensure_within_bounds(pos_b)\n        (self.heap[pos_a], self.heap[pos_b]) = (self.heap[pos_b], self.heap[pos_a])\n\n    def _heapify(self, pos):\n        if self.size == 0:\n            return\n        if self._is_leaf(pos):\n            return\n        left_child_pos = self._left_child(pos)\n        right_child_pos = self._right_child(pos)\n        if right_child_pos > self.size:\n            if self.heap[left_child_pos] < self.heap[pos]:\n                self._swap(pos, left_child_pos)\n            return\n        if self.heap[pos] <= min(self.heap[left_child_pos], self.heap[right_child_pos]):\n            return\n        if self.heap[left_child_pos] < self.heap[right_child_pos]:\n            self._swap(pos, left_child_pos)\n            self._heapify(left_child_pos)\n        else:\n            self._swap(pos, right_child_pos)\n            self._heapify(right_child_pos)\n\n    def insert(self, value):\n        self.size += 1\n        self.heap.append(value)\n        index = self.size\n        while self.heap[index] < self.heap[self._parent(index)]:\n            self._swap(index, self._parent(index))\n            index = self._parent(index)\n\n    def pop(self):\n        self._ensure_non_empty_heap()\n        popped = self.heap[self.root]\n        self._swap(self.root, self.size)\n        self.size -= 1\n        self._heapify(self.root)\n        self.heap.pop()\n        return popped\n\n    def get_min(self):\n        self._ensure_non_empty_heap()\n        return self.heap[self.root]\nT = int(input())\nwhile T:\n    T -= 1\n    (N, X, Y) = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n    h = MinHeap()\n    for a in A:\n        h.insert(a)\n    to_insert = -1\n    while Y:\n        heap_min = h.pop()\n        heap_min_xor = heap_min ^ X\n        if heap_min_xor < heap_min:\n            if Y & 1:\n                to_insert = heap_min_xor\n            else:\n                to_insert = heap_min\n            break\n        h.insert(heap_min_xor)\n        Y -= 1\n    if to_insert != -1:\n        h.insert(to_insert)\n    for i in range(N):\n        cur = h.pop()\n        print(cur, end=' ')\n    print()", "import heapq as h\nfor _ in range(int(input())):\n    (n, x, y) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if y % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        h.heapify(a)\n        i = 0\n        while i < y:\n            b = h.heappop(a)\n            c = b ^ x\n            h.heappush(a, c)\n            d = h.heappop(a)\n            i += 1\n            if d == c:\n                if (y - i) % 2 == 0:\n                    h.heappush(a, d)\n                    break\n                else:\n                    h.heappush(a, b)\n                    break\n            else:\n                h.heappush(a, d)\n        a.sort()\n        print(*a)", "def app(a, s, i, h):\n    mid = (i + h) // 2\n    if s <= a[0]:\n        return 1\n    if s >= a[h]:\n        return h + 1\n    if s >= a[mid] and s < a[mid + 1]:\n        return mid + 1\n    elif s > a[mid]:\n        return app(a, s, mid + 1, h)\n    else:\n        return app(a, s, i, mid - 1)\nt = int(input())\nwhile t > 0:\n    (n, x, y) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    a.sort()\n    if n == 1:\n        if y % 2 == 0:\n            print(a[0])\n        else:\n            print(a[0] ^ x)\n        t = t - 1\n        continue\n    for i in range(y):\n        if a[0] ^ x < a[1]:\n            if (y - i) % 2 != 0:\n                s = a[0] ^ x\n            else:\n                s = a[0]\n            a[0] = s\n            break\n        else:\n            s = a[0] ^ x\n        k = app(a, s, 0, len(a) - 1)\n        a.insert(k, s)\n        a.remove(a[0])\n    for x in a:\n        print(x, ' ', end='')\n    print('')\n    t = t - 1", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "from heapq import heapify, heappush, heappop\nt = int(input())\nfor _ in range(t):\n    (n, x, y) = map(int, input().split())\n    arr = [int(i) for i in input().split()]\n    repeat = dict()\n    heap = arr[:]\n    heapify(heap)\n    cnt = 0\n    for i in range(y):\n        val = heap[0] ^ x\n        if val in repeat.keys():\n            break\n        temp = heappop(heap)\n        cnt += 1\n        repeat[temp] = 1\n        heappush(heap, temp ^ x)\n    y = y - cnt\n    if y % 2 == 1:\n        temp = heappop(heap)\n        heappush(heap, temp ^ x)\n    heap.sort()\n    for i in heap:\n        print(i, end=' ')\n    print()", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as heap\nfor i in range(int(input())):\n    (n, x, y) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if y % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < y:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i += 1\n            if d == c:\n                if (y - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as hp\nt = int(input())\nfor i in range(t):\n    (n, x, y) = list(map(int, input().split()))\n    if n == 1:\n        a = int(input())\n        if y % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))[:n]\n        hp.heapify(a)\n        i = 0\n        while i < y:\n            b = hp.heappop(a)\n            c = b ^ x\n            hp.heappush(a, c)\n            d = hp.heappop(a)\n            i += 1\n            if d == c:\n                if (y - i) % 2 == 0:\n                    hp.heappush(a, d)\n                    break\n                else:\n                    hp.heappush(a, b)\n                    break\n            else:\n                hp.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\ntry:\n    for _ in range(int(input())):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as heap\ntry:\n    num_of_cases = int(input())\n    for _ in range(num_of_cases):\n        (N, X, Y) = map(int, input().split(' '))\n        A = list(map(int, input().split(' ')))\n        if N == 1:\n            if Y % 2 == 0:\n                print(A[0])\n            else:\n                print(A[0] ^ X)\n        else:\n            heap.heapify(A)\n            i = 0\n            while i < Y:\n                min = heap.heappop(A)\n                xor = min ^ X\n                heap.heappush(A, xor)\n                new_min = heap.heappop(A)\n                i += 1\n                if xor == new_min:\n                    if (Y - i) % 2 == 0:\n                        heap.heappush(A, new_min)\n                        break\n                    else:\n                        heap.heappush(A, min)\n                        break\n                else:\n                    heap.heappush(A, new_min)\n            A.sort()\n            print(*A)\nexcept Exception:\n    pass", "for t in range(int(input())):\n    (n, x, y) = [int(el) for el in input().split()]\n    a = sorted([int(el) for el in input().split()])\n    new = []\n    currentmin = (float('inf'), -1)\n    for (index, el) in enumerate(a):\n        if el < currentmin[0] and y != 0:\n            el ^= x\n            new.append(el)\n            currentmin = min((el, index), currentmin)\n            y -= 1\n        else:\n            index -= 1\n            break\n    newarray = new + a[index + 1:]\n    if y % 2 != 0:\n        newarray[currentmin[1]] ^= x\n    print(*sorted(newarray))", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as heap\nt = int(input())\nfor i in range(t):\n    (n, x, y) = map(int, input().split())\n    if n == 1:\n        A = int(input())\n        if y % 2 == 0:\n            print(A)\n        else:\n            print(A ^ x)\n    else:\n        A = list(map(int, input().split()))\n        heap.heapify(A)\n        for k in range(1, y + 1):\n            s = heap.heappop(A)\n            R = s ^ x\n            heap.heappush(A, R)\n            P = heap.heappop(A)\n            if P == R:\n                if (y - k) % 2 == 0:\n                    heap.heappush(A, P)\n                    break\n                else:\n                    heap.heappush(A, s)\n                    break\n            else:\n                heap.heappush(A, P)\n        A.sort()\n        print(*A)", "import heapq as heap\ntry:\n    t = int(input())\n    for i in range(t):\n        (n, x, y) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if y % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < y:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (y - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as hq\nt = int(input())\ncases = []\nfor u in range(t):\n    cases.append([input().split(), input().split()])\nfor case in cases:\n    N = int(case[0][0])\n    X = int(case[0][1])\n    Y = int(case[0][2])\n    arr = [int(q) for q in case[1]]\n    if len(arr) == 1:\n        if Y & 1:\n            print(arr[0] ^ X)\n        else:\n            print(arr[0])\n    else:\n        hq.heapify(arr)\n        i = 0\n        while i < Y:\n            z1 = hq.heappop(arr)\n            z2 = z1 ^ X\n            hq.heappush(arr, z2)\n            z3 = hq.heappop(arr)\n            i += 1\n            if z3 == z2:\n                if not Y - i & 1:\n                    hq.heappush(arr, z3)\n                    break\n                else:\n                    hq.heappush(arr, z1)\n                    break\n            else:\n                hq.heappush(arr, z3)\n        arr.sort()\n        for g in arr:\n            print(g, end=' ')\n        print('')", "import heapq as heap\nfor _ in range(int(input())):\n    (n, x, t) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if t % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < t:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i += 1\n            if d == c:\n                if (t - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\nn = int(input())\nfor i in range(n):\n    (n, x, t) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if t % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < t:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i += 1\n            if d == c:\n                if (t - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\nn = int(input())\nfor i in range(n):\n    (n, x, t) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if t % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < t:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i += 1\n            if d == c:\n                if (t - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as hp\ntry:\n    x = int(input())\n    for i in range(x):\n        (a, b, c) = map(int, input().split())\n        if a == 1:\n            d = int(input())\n            if c % 2 == 0:\n                print(d)\n            else:\n                print(b ^ d)\n        else:\n            l = list(map(int, input().split()))\n            hp.heapify(l)\n            i = 0\n            while i < c:\n                l1 = hp.heappop(l)\n                y = l1 ^ b\n                hp.heappush(l, y)\n                l2 = hp.heappop(l)\n                i += 1\n                if y == l2:\n                    if (c - i) % 2 == 0:\n                        hp.heappush(l, l2)\n                        break\n                    else:\n                        hp.heappush(l, l1)\n                        break\n                else:\n                    hp.heappush(l, l2)\n            l.sort()\n            print(*l)\nexcept:\n    pass", "from heapq import heapify, heappop, heappush\n\ndef minimum(a, n):\n    m = 1073741825\n    midx = -1\n    for i in range(n):\n        if a[i] < m:\n            m = a[i]\n            midx = i\n    return midx\nt = int(input())\nfor i in range(t):\n    (n, x, y) = [int(k) for k in input().split()]\n    a = [int(k) for k in input().split()]\n    if n == 1:\n        if y % 2 != 0:\n            print(a[0] ^ x)\n        else:\n            print(a[0])\n        continue\n    heapify(a)\n    for j in range(y):\n        b = heappop(a)\n        c = b ^ x\n        heappush(a, c)\n        d = heappop(a)\n        if c == d:\n            if (y - j) % 2 == 0:\n                heappush(a, b)\n            else:\n                heappush(a, d)\n            break\n        else:\n            heappush(a, d)\n    a.sort()\n    for k in a:\n        print(k, end=' ')\n    print()", "import heapq as heap\nfrom secrets import choice\nfor _ in range(int(input())):\n    (n, x, t) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if t % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < t:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i += 1\n            if d == c:\n                if (t - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\nt = int(input())\nfor i in range(t):\n    (n, x, y) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if y % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < y:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i = i + 1\n            if d == c:\n                if (y - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\n\ndef getanswer(l, m, n, k):\n    heap.heapify(k)\n    i = 0\n    while i < n:\n        q = heap.heappop(k)\n        w = q ^ m\n        heap.heappush(k, w)\n        e = heap.heappop(k)\n        i += 1\n        if w == e:\n            if (n - i) % 2 == 0:\n                heap.heappush(k, e)\n                break\n            else:\n                heap.heappush(k, q)\n                break\n        else:\n            heap.heappush(k, e)\n    k.sort()\n    return print(*k)\nt = int(input())\nfor i in range(t):\n    (a, b, c) = map(int, input().strip().split())\n    if a == 1:\n        r = int(input())\n        if c % 2 == 0:\n            print(r)\n        else:\n            print(r ^ b)\n    else:\n        nlist = list(map(int, input().strip().split()))\n        getanswer(a, b, c, nlist)", "import heapq as heap\ntry:\n    z = int(input())\n    for i in range(z):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "t = int(input())\nfor i in range(t):\n    (n, x, y) = map(int, input().split())\n    a = list(map(int, input().strip().split()))[:n]\n    b = sorted(a)\n    u = y\n    p = o = 0\n    min = b[0] ^ x\n    if n <= y:\n        for j in range(n - 1):\n            b[j] = b[j] ^ x\n            u -= 1\n            if min > b[j]:\n                min = b[j]\n                p = j\n            if min <= b[j + 1]:\n                break\n            if j == n - 2:\n                o = 1\n    elif n > y:\n        for j in range(y):\n            b[j] = b[j] ^ x\n            u -= 1\n            if min > b[j]:\n                min = b[j]\n                p = j\n            if min <= b[j + 1]:\n                break\n    if n <= y and u > 0 and (o == 1):\n        b[n - 1] = b[n - 1] ^ x\n        u -= 1\n        if min > b[n - 1]:\n            min = b[n - 1]\n            p = n - 1\n    if u % 2 == 1:\n        b[p] = b[p] ^ x\n    c = sorted(b)\n    print(*c, sep=' ')", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i = i + 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as heap\ntry:\n    N = int(input())\n    for i in range(N):\n        (M, xIN, tES) = map(int, input().split())\n        if M == 1:\n            aI = int(input())\n            if tES % 2 == 0:\n                print(aI)\n            else:\n                print(aI ^ xIN)\n        else:\n            aI = list(map(int, input().split()))\n            heap.heapify(aI)\n            i = 0\n            while i < tES:\n                bB = heap.heappop(aI)\n                cC = bB ^ xIN\n                heap.heappush(aI, cC)\n                dD = heap.heappop(aI)\n                i += 1\n                if dD == cC:\n                    if (tES - i) % 2 == 0:\n                        heap.heappush(aI, dD)\n                        break\n                    else:\n                        heap.heappush(aI, bB)\n                        break\n                else:\n                    heap.heappush(aI, dD)\n            aI.sort()\n            print(*aI)\nexcept:\n    pass", "import heapq as heap\nt = int(input())\nfor i in range(t):\n    (n, x, y) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if y % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < y:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i += 1\n            if d == c:\n                if (y - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "t = int(input())\nfor i in range(t):\n    (n, x, y) = [int(x) for x in input().split()]\n    a = list(map(int, input().split()))\n    b = sorted(a)\n    q = y\n    p = r = 0\n    min = b[0] ^ x\n    if n <= y:\n        for j in range(n - 1):\n            b[j] = b[j] ^ x\n            q -= 1\n            if min > b[j]:\n                min = b[j]\n                p = j\n            if min <= b[j + 1]:\n                break\n            if j == n - 2:\n                r = 1\n    elif n > y:\n        for j in range(y):\n            b[j] = b[j] ^ x\n            q -= 1\n            if min > b[j]:\n                min = b[j]\n                p = j\n            if min <= b[j + 1]:\n                break\n    if n <= y and q > 0 and (r == 1):\n        b[n - 1] = b[n - 1] ^ x\n        q -= 1\n        if min > b[n - 1]:\n            min = b[n - 1]\n            p = n - 1\n    if q % 2 == 1:\n        b[p] = b[p] ^ x\n    c = sorted(b)\n    print(*c, sep=' ')", "import heapq as heap\nt = int(input())\nfor i in range(0, t):\n    (n, x, y) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if y % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < y:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i = i + 1\n            if d == c:\n                if (y - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\nn = int(input())\nfor i in range(n):\n    (n, x, t) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if t % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        i = 0\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        while i < t:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i += 1\n            if c == d:\n                if (t - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import queue\nfor T in range(int(input())):\n    (N, X, Y) = map(int, input().split())\n    L = list(map(int, input().split()))\n    P = queue.PriorityQueue()\n    for v in L:\n        P.put((v, 0))\n    while Y > 0:\n        (v, r) = P.get()\n        newv = 0\n        if r == 1:\n            if Y % 2 == 0:\n                newv = v\n                Y = 0\n            else:\n                newv = v ^ X\n                Y = 0\n        else:\n            newv = v ^ X\n            Y -= 1\n        P.put((newv, 1))\n    newL = []\n    while not P.empty():\n        newL.append(P.get()[0])\n    print(*newL)", "import heapq as heap\nt = int(input())\nfor i in range(0, t):\n    (n, x, y) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if y % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < y:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i = i + 1\n            if d == c:\n                if (y - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\n\ndef hello():\n    print('HELLO')\n\ndef n():\n    print('!23')\n\ndef check(N):\n    print(*N)\n\ndef main(kk):\n    for _ in range(kk):\n        (q, w, e) = map(int, input().split())\n        r = list(map(int, input().split()))\n        if q == 1:\n            if e % 2 != 0:\n                print(r[0] ^ w)\n                continue\n            print(r[0])\n            continue\n        heap.heapify(r)\n        i = 0\n        while e > i:\n            p = heap.heappop(r)\n            a = p ^ w\n            heap.heappush(r, a)\n            k = heap.heappop(r)\n            i += 1\n            if k == a:\n                if (e - i) % 2 == 0:\n                    heap.heappush(r, k)\n                    break\n                elif (e - i) % 2 != 0:\n                    heap.heappush(r, p)\n                    break\n            elif k != a:\n                heap.heappush(r, k)\n        r.sort()\n        check(r)\n        continue\nmain(int(input()))", "import heapq as heap\ntry:\n    n = int(input())\n    for _ in range(n):\n        (n, u, v) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if v % 2 == 0:\n                print(a)\n            else:\n                print(a ^ u)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < v:\n                b = heap.heappop(a)\n                c = b ^ u\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (v - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as heap\nn = int(input())\nfor i in range(n):\n    (n, x, t) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if t % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        i = 0\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        while i < t:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i += 1\n            if c == d:\n                if (t - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\nn = int(input())\nfor i in range(n):\n    (n, x, t) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if t % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < t:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i += 1\n            if d == c:\n                if (t - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as heap\nt = int(input())\nfor i in range(0, t):\n    (n, x, y) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if y % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < y:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i = i + 1\n            if d == c:\n                if (y - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\nt = int(input())\nfor i in range(t):\n    (n, x, y) = map(int, input().split())\n    if n == 1:\n        a = int(input())\n        if y % 2 == 0:\n            print(a)\n        else:\n            print(a ^ x)\n    else:\n        a = list(map(int, input().split()))\n        heap.heapify(a)\n        i = 0\n        while i < y:\n            b = heap.heappop(a)\n            c = b ^ x\n            heap.heappush(a, c)\n            d = heap.heappop(a)\n            i += 1\n            if d == c:\n                if (y - i) % 2 == 0:\n                    heap.heappush(a, d)\n                    break\n                else:\n                    heap.heappush(a, b)\n                    break\n            else:\n                heap.heappush(a, d)\n        a.sort()\n        print(*a)", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq as heap\ntry:\n    n = int(input())\n    for i in range(n):\n        (n, x, t) = map(int, input().split())\n        if n == 1:\n            a = int(input())\n            if t % 2 == 0:\n                print(a)\n            else:\n                print(a ^ x)\n        else:\n            a = list(map(int, input().split()))\n            heap.heapify(a)\n            i = 0\n            while i < t:\n                b = heap.heappop(a)\n                c = b ^ x\n                heap.heappush(a, c)\n                d = heap.heappop(a)\n                i += 1\n                if d == c:\n                    if (t - i) % 2 == 0:\n                        heap.heappush(a, d)\n                        break\n                    else:\n                        heap.heappush(a, b)\n                        break\n                else:\n                    heap.heappush(a, d)\n            a.sort()\n            print(*a)\nexcept:\n    pass", "import heapq\nfor _ in range(int(input())):\n    (n, x, y) = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    heapq.heapify(l)\n    flag = 0\n    for k in range(y):\n        m = heapq.heappop(l)\n        d = m ^ x\n        heapq.heappush(l, d)\n        e = heapq.heappop(l)\n        if d == e:\n            if (y - k) % 2 != 0:\n                heapq.heappush(l, e)\n                break\n            else:\n                heapq.heappush(l, e ^ x)\n                break\n        else:\n            heapq.heappush(l, e)\n    l.sort()\n    print(*l)"]