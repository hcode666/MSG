["import sys, os, io\ninput = sys.stdin.readline\n\ndef is_valid(x, y):\n    if min(x, y) >= 0 and x < n and (y < m) and ((x, y) not in vis) and (a[x][y] != '#'):\n        return 1\nfor _ in range(int(input())):\n    (n, m) = [int(i) for i in input().split()]\n    a = []\n    for i in range(n):\n        a.append(list(input().strip()))\n    vis = set()\n    dx = [1, -1, 0, 0]\n    dy = [0, 0, 1, -1]\n    ans = 0\n    depth = 0\n    stack = [(0, 0)]\n    while len(vis) < n * m:\n        while stack:\n            (x, y) = stack.pop()\n            vis.add((x, y))\n            depth = max(depth, x)\n            for k in range(4):\n                (nx, ny) = (x + dx[k], y + dy[k])\n                if is_valid(nx, ny):\n                    vis.add((nx, ny))\n                    stack.append((nx, ny))\n        if depth != n - 1:\n            ans += 1\n            for i in range(m):\n                a[depth + 1][i] == '.'\n                stack.append((depth + 1, i))\n        elif (n - 1, m - 1) not in vis:\n            ans += 1\n            break\n        else:\n            break\n    print(ans)", "from itertools import product\n\nclass DisJointSets:\n\n    def __init__(self, N):\n        self._parents = [node for node in range(N)]\n        self._ranks = [1 for _ in range(N)]\n\n    def find(self, u):\n        while u != self._parents[u]:\n            self._parents[u] = self._parents[self._parents[u]]\n            u = self._parents[u]\n        return u\n\n    def connected(self, u, v):\n        return self.find(u) == self.find(v)\n\n    def union(self, u, v):\n        (root_u, root_v) = (self.find(u), self.find(v))\n        if root_u == root_v:\n            return True\n        if self._ranks[root_u] > self._ranks[root_v]:\n            self._parents[root_v] = root_u\n        elif self._ranks[root_v] > self._ranks[root_u]:\n            self._parents[root_u] = root_v\n        else:\n            self._parents[root_u] = root_v\n            self._ranks[root_v] += 1\n        return False\n\ndef solve():\n    (N, M) = map(int, input().split(' '))\n    wall = [list(map(lambda x: x == '#', input())) for _ in range(N)]\n    striked = set()\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def biject(r, c):\n        pos = M * r + c\n        if not 0 <= pos < N * M:\n            raise ValueError(r, c, pos, N, M)\n        return pos\n    ds = DisJointSets(N * M)\n\n    def update_ds(r, c):\n        if not (0 <= r < N and 0 <= c < M):\n            return\n        if r not in striked and wall[r][c]:\n            return\n        p1 = biject(r, c)\n        for (dr, dc) in dirs:\n            (nr, nc) = (r + dr, c + dc)\n            if not (0 <= nr < N and 0 <= nc < M):\n                continue\n            if nr not in striked and wall[nr][nc]:\n                continue\n            p2 = biject(nr, nc)\n            ds.union(p1, p2)\n    for (r, c) in product(range(N), range(M)):\n        update_ds(r, c)\n    for r in range(N):\n        if any(map(lambda c: ds.connected(biject(0, 0), biject(r, c)), range(M))):\n            continue\n        striked.add(r)\n        for c in range(M):\n            update_ds(r, c)\n    print(len(striked) if ds.connected(biject(0, 0), biject(N - 1, M - 1)) else len(striked) + 1)\nT = int(input())\nfor _ in range(T):\n    solve()", "from itertools import product\n\nclass DisJointSets:\n\n    def __init__(self, N):\n        self._parents = [node for node in range(N)]\n        self._ranks = [1 for _ in range(N)]\n\n    def find(self, u):\n        while u != self._parents[u]:\n            self._parents[u] = self._parents[self._parents[u]]\n            u = self._parents[u]\n        return u\n\n    def connected(self, u, v):\n        return self.find(u) == self.find(v)\n\n    def union(self, u, v):\n        (root_u, root_v) = (self.find(u), self.find(v))\n        if root_u == root_v:\n            return True\n        if self._ranks[root_u] > self._ranks[root_v]:\n            self._parents[root_v] = root_u\n        elif self._ranks[root_v] > self._ranks[root_u]:\n            self._parents[root_u] = root_v\n        else:\n            self._parents[root_u] = root_v\n            self._ranks[root_v] += 1\n        return False\n\ndef solve():\n    (N, M) = map(int, input().split(' '))\n    wall = [list(map(lambda x: x == '#', input())) for _ in range(N)]\n    striked = set()\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def biject(r, c):\n        pos = M * r + c\n        if not 0 <= pos < N * M:\n            raise ValueError(r, c, pos, N, M)\n        return pos\n    ds = DisJointSets(N * M)\n\n    def update_ds(r, c):\n        if not (0 <= r < N and 0 <= c < M):\n            return\n        if r not in striked and wall[r][c]:\n            return\n        p1 = biject(r, c)\n        for (dr, dc) in dirs:\n            (nr, nc) = (r + dr, c + dc)\n            if not (0 <= nr < N and 0 <= nc < M):\n                continue\n            if nr not in striked and wall[nr][nc]:\n                continue\n            p2 = biject(nr, nc)\n            ds.union(p1, p2)\n    for (r, c) in product(range(N), range(M)):\n        update_ds(r, c)\n    for r in range(N):\n        if any(map(lambda c: ds.connected(biject(0, 0), biject(r, c)), range(M))):\n            continue\n        striked.add(r)\n        for c in range(M):\n            update_ds(r, c)\n    print(len(striked) if ds.connected(biject(0, 0), biject(N - 1, M - 1)) else len(striked) + 1)\nT = int(input())\nfor _ in range(T):\n    solve()", "from itertools import product\n\nclass DisJointSets:\n\n    def __init__(self, N):\n        self._parents = [node for node in range(N)]\n        self._ranks = [1 for _ in range(N)]\n\n    def find(self, u):\n        while u != self._parents[u]:\n            self._parents[u] = self._parents[self._parents[u]]\n            u = self._parents[u]\n        return u\n\n    def connected(self, u, v):\n        return self.find(u) == self.find(v)\n\n    def union(self, u, v):\n        (root_u, root_v) = (self.find(u), self.find(v))\n        if root_u == root_v:\n            return True\n        if self._ranks[root_u] > self._ranks[root_v]:\n            self._parents[root_v] = root_u\n        elif self._ranks[root_v] > self._ranks[root_u]:\n            self._parents[root_u] = root_v\n        else:\n            self._parents[root_u] = root_v\n            self._ranks[root_v] += 1\n        return False\n\ndef solve():\n    (N, M) = map(int, input().split(' '))\n    wall = [list(map(lambda x: x == '#', input())) for _ in range(N)]\n    striked = set()\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def biject(r, c):\n        pos = M * r + c\n        if not 0 <= pos < N * M:\n            raise ValueError(r, c, pos, N, M)\n        return pos\n    ds = DisJointSets(N * M)\n\n    def update_ds(r, c):\n        if not (0 <= r < N and 0 <= c < M):\n            return\n        if r not in striked and wall[r][c]:\n            return\n        p1 = biject(r, c)\n        for (dr, dc) in dirs:\n            (nr, nc) = (r + dr, c + dc)\n            if not (0 <= nr < N and 0 <= nc < M):\n                continue\n            if nr not in striked and wall[nr][nc]:\n                continue\n            p2 = biject(nr, nc)\n            ds.union(p1, p2)\n    for (r, c) in product(range(N), range(M)):\n        update_ds(r, c)\n    for r in range(N):\n        if any(map(lambda c: ds.connected(biject(0, 0), biject(r, c)), range(M))):\n            continue\n        striked.add(r)\n        for c in range(M):\n            update_ds(r, c)\n    print(len(striked) if ds.connected(biject(0, 0), biject(N - 1, M - 1)) else len(striked) + 1)\nT = int(input())\nfor _ in range(T):\n    solve()", "def find(grid, n, m):\n    que = []\n    que.append([0, 0])\n    vis = set()\n    l = 0\n    dr = [-1, 0, 1, 0]\n    dc = [0, 1, 0, -1]\n    for score in range(n):\n        low = l\n        while que:\n            (row, col) = que.pop(0)\n            vis.add((row, col))\n            if row == n - 1 and col == m - 1:\n                return score\n            for i in range(4):\n                nrow = row + dr[i]\n                ncol = col + dc[i]\n                if nrow >= 0 and nrow < n and (ncol >= 0) and (ncol < m) and ((nrow, ncol) not in vis) and (grid[nrow][ncol] != '#'):\n                    que.append([nrow, ncol])\n                    vis.add((nrow, ncol))\n                    low = max(low, nrow)\n        if low == n - 1:\n            return score + 1\n        l = low + 1\n        for i in range(m):\n            que.append([low + 1, i])\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    print(find(grid, n, m))", "def find(g, n, m):\n    q = [(0, 0)]\n    visited = {0, 0}\n    lowest = 0\n    for score in range(n):\n        low = lowest\n        while q:\n            (i, j) = q.pop()\n            visited.add((i, j))\n            if i == n - 1 and j == m - 1:\n                return score\n            for (a, b) in [(i - 1, j), (i, j - 1), (i, j + 1), (i + 1, j)]:\n                if lowest <= a < n and 0 <= b < m and ((a, b) not in visited) and (g[a][b] != '#'):\n                    q.append((a, b))\n                    visited.add((a, b))\n                    low = max(low, a)\n        if low == n - 1:\n            return score + 1\n        lowest = low + 1\n        q = [(low + 1, i) for i in range(m)]\n        visited.update(q)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    g = [input() for _ in range(n)]\n    print(find(g, n, m))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nimport heapq\n\ndef answer():\n    dist = [[[float('inf'), float('inf')] for i in range(m)] for j in range(n)]\n    dist[0][0] = [0, 0]\n    q = []\n    heapq.heappush(q, [0, 0, 0, 0])\n    while len(q):\n        (dis, took, x, y) = heapq.heappop(q)\n        if took == 0:\n            if x + 1 < n:\n                add = a[x + 1][y] == '#'\n                if dist[x + 1][y][add] > dist[x][y][0] + add:\n                    dist[x + 1][y][add] = dist[x][y][0] + add\n                    heapq.heappush(q, [dist[x + 1][y][add], add, x + 1, y])\n            if y + 1 < m:\n                add = a[x][y + 1] == '#'\n                if dist[x][y + 1][add] > dist[x][y][0] + add:\n                    dist[x][y + 1][add] = dist[x][y][0] + add\n                    heapq.heappush(q, [dist[x][y + 1][add], add, x, y + 1])\n            if y - 1 >= 0:\n                add = a[x][y - 1] == '#'\n                if dist[x][y - 1][add] > dist[x][y][0] + add:\n                    dist[x][y - 1][add] = dist[x][y][0] + add\n                    heapq.heappush(q, [dist[x][y - 1][add], add, x, y - 1])\n            if x - 1 >= 0:\n                add = a[x - 1][y] == '#'\n                if dist[x - 1][y][add] > dist[x][y][0] + add:\n                    dist[x - 1][y][add] = dist[x][y][0] + add\n                    heapq.heappush(q, [dist[x - 1][y][add], add, x - 1, y])\n        else:\n            if x + 1 < n:\n                add = a[x + 1][y] == '#'\n                if dist[x + 1][y][add] > dist[x][y][1] + add:\n                    dist[x + 1][y][add] = dist[x][y][1] + add\n                    heapq.heappush(q, [dist[x + 1][y][add], add, x + 1, y])\n            if y + 1 < m:\n                if dist[x][y + 1][1] > dist[x][y][1]:\n                    dist[x][y + 1][1] = dist[x][y][1]\n                    heapq.heappush(q, [dist[x][y + 1][1], 1, x, y + 1])\n            if x - 1 >= 0:\n                add = a[x - 1][y] == '#'\n                if dist[x - 1][y][add] > dist[x][y][1] + add:\n                    dist[x - 1][y][add] = dist[x][y][1] + add\n                    heapq.heappush(q, [dist[x - 1][y][add], add, x - 1, y])\n            if y - 1 >= 0:\n                if dist[x][y - 1][1] > dist[x][y][1]:\n                    dist[x][y - 1][1] = dist[x][y][1]\n                    heapq.heappush(q, [dist[x][y - 1][1], 1, x, y - 1])\n    return min(dist[n - 1][m - 1])\nfor T in range(int(input())):\n    (n, m) = inp()\n    a = [input().strip() for i in range(n)]\n    print(answer())", "def mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return str(input())\n\ndef ni():\n    return int(input())\nfind = lambda n, m, l, u: m * l + u + 1\nfrom heapq import heappop, heappush\n\ndef dijkstra(graph, start, n):\n    (dist, parents) = ([float('inf')] * n, [-1] * n)\n    dist[start] = 0\n    queue = [(0, start)]\n    while queue:\n        (path_len, v) = heappop(queue)\n        if path_len == dist[v]:\n            for (w, edge_len) in graph[v]:\n                if edge_len + path_len < dist[w]:\n                    (dist[w], parents[w]) = (edge_len + path_len, v)\n                    heappush(queue, (edge_len + path_len, w))\n    return (dist, parents)\ng = [[] for i in range(2 * 500000 + 2)]\nfor _ in range(int(input())):\n    (n, m) = mi()\n    total = n * m\n    a = []\n    for i in range(n):\n        a.append(input())\n    for i in range(2 * total + 2):\n        g[i].clear()\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == '.':\n                if i > 0:\n                    x = find(n, m, i, j)\n                    y = find(n, m, i - 1, j)\n                    if a[i - 1][j] == '.':\n                        g[x].append((y, 0))\n                    g[x].append((total + y, 1))\n                if j > 0:\n                    x = find(n, m, i, j)\n                    y = find(n, m, i, j - 1)\n                    if a[i][j - 1] == '.':\n                        g[x].append((y, 0))\n                    g[x].append((total + y, 1))\n                if i < n - 1:\n                    x = find(n, m, i, j)\n                    y = find(n, m, i + 1, j)\n                    if a[i + 1][j] == '.':\n                        g[x].append((y, 0))\n                    g[x].append((total + y, 1))\n                if j < m - 1:\n                    x = find(n, m, i, j)\n                    y = find(n, m, i, j + 1)\n                    if a[i][j + 1] == '.':\n                        g[x].append((y, 0))\n                    g[x].append((total + y, 1))\n            if j > 0:\n                g[total + find(n, m, i, j)].append((total + find(n, m, i, j - 1), 0))\n                if a[i][j - 1] == '.':\n                    g[total + find(n, m, i, j)].append((find(n, m, i, j - 1), 0))\n            if j < m - 1:\n                g[total + find(n, m, i, j)].append((total + find(n, m, i, j + 1), 0))\n                if a[i][j + 1] == '.':\n                    g[total + find(n, m, i, j)].append((find(n, m, i, j + 1), 0))\n            if i > 0:\n                g[total + find(n, m, i, j)].append((total + find(n, m, i - 1, j), 1))\n                if a[i - 1][j] == '.':\n                    g[total + find(n, m, i, j)].append((find(n, m, i - 1, j), 0))\n            if i < n - 1:\n                g[total + find(n, m, i, j)].append((total + find(n, m, i + 1, j), 1))\n                if a[i + 1][j] == '.':\n                    g[total + find(n, m, i, j)].append((find(n, m, i + 1, j), 0))\n    (res, temp) = dijkstra(g, 1, 2 * total + 2)\n    print(min(res[total], res[2 * total]))", "import sys\ninput = sys.stdin.readline\nfrom math import sqrt\nfrom collections import defaultdict, deque\n\ndef I():\n    return list(map(int, input().split()))\nfrom time import time\nst = time()\n\ndef bfs():\n    max_dep = 0\n    stack = [(0, 0)]\n    vis = {}\n    ans = 0\n    while True:\n        if time() - st > 1:\n            exit()\n        while stack:\n            if time() - st > 1:\n                exit()\n            (x, y) = stack.pop()\n            max_dep = max(max_dep, x)\n            if x == n - 1 and y == m - 1:\n                return ans\n            for (r, c) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (X, Y) = (x + r, y + c)\n                if 0 <= X < n and 0 <= Y < m and ((X, Y) not in vis) and (mat[X][Y] == '.'):\n                    stack.append((X, Y))\n                    vis[X, Y] = True\n        if max_dep == n - 1:\n            ans += 1\n            return ans\n        ans += 1\n        for j in range(m):\n            stack.append((max_dep + 1, j))\nfor _ in range(int(input())):\n    (n, m) = I()\n    mat = []\n    for i in range(n):\n        temp = input().strip()\n        mat.append(temp)\n    stack = deque([(0, 0)])\n    print(bfs())", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nimport heapq\n\ndef answer():\n    dist = [[[float('inf'), float('inf')] for i in range(m)] for j in range(n)]\n    dist[0][0] = [0, 0]\n    q = []\n    heapq.heappush(q, [0, 0, 0, 0])\n    while len(q):\n        (dis, took, x, y) = heapq.heappop(q)\n        if took == 0:\n            if x + 1 < n:\n                add = a[x + 1][y] == '#'\n                if dist[x + 1][y][add] > dist[x][y][0] + add:\n                    dist[x + 1][y][add] = dist[x][y][0] + add\n                    heapq.heappush(q, [dist[x + 1][y][add], add, x + 1, y])\n            if y + 1 < m:\n                add = a[x][y + 1] == '#'\n                if dist[x][y + 1][add] > dist[x][y][0] + add:\n                    dist[x][y + 1][add] = dist[x][y][0] + add\n                    heapq.heappush(q, [dist[x][y + 1][add], add, x, y + 1])\n            if y - 1 >= 0:\n                add = a[x][y - 1] == '#'\n                if dist[x][y - 1][add] > dist[x][y][0] + add:\n                    dist[x][y - 1][add] = dist[x][y][0] + add\n                    heapq.heappush(q, [dist[x][y - 1][add], add, x, y - 1])\n            if x - 1 >= 0:\n                add = a[x - 1][y] == '#'\n                if dist[x - 1][y][add] > dist[x][y][0] + add:\n                    dist[x - 1][y][add] = dist[x][y][0] + add\n                    heapq.heappush(q, [dist[x - 1][y][add], add, x - 1, y])\n        else:\n            if x + 1 < n:\n                add = a[x + 1][y] == '#'\n                if dist[x + 1][y][add] > dist[x][y][1] + add:\n                    dist[x + 1][y][add] = dist[x][y][1] + add\n                    heapq.heappush(q, [dist[x + 1][y][add], add, x + 1, y])\n            if y + 1 < m:\n                if dist[x][y + 1][1] > dist[x][y][1]:\n                    dist[x][y + 1][1] = dist[x][y][1]\n                    heapq.heappush(q, [dist[x][y + 1][1], 1, x, y + 1])\n            if x - 1 >= 0:\n                add = a[x - 1][y] == '#'\n                if dist[x - 1][y][add] > dist[x][y][1] + add:\n                    dist[x - 1][y][add] = dist[x][y][1] + add\n                    heapq.heappush(q, [dist[x - 1][y][add], add, x - 1, y])\n            if y - 1 >= 0:\n                if dist[x][y - 1][1] > dist[x][y][1]:\n                    dist[x][y - 1][1] = dist[x][y][1]\n                    heapq.heappush(q, [dist[x][y - 1][1], 1, x, y - 1])\n    return min(dist[n - 1][m - 1])\nfor T in range(int(input())):\n    (n, m) = inp()\n    a = [input().strip() for i in range(n)]\n    print(answer())", "def find(g, n, m):\n    q = [(0, 0)]\n    visited = {0, 0}\n    lowest = 0\n    for score in range(n):\n        low = lowest\n        while q:\n            (i, j) = q.pop()\n            visited.add((i, j))\n            if i == n - 1 and j == m - 1:\n                return score\n            for (a, b) in [(i - 1, j), (i, j - 1), (i, j + 1), (i + 1, j)]:\n                if lowest <= a < n and 0 <= b < m and ((a, b) not in visited) and (g[a][b] != '#'):\n                    q.append((a, b))\n                    visited.add((a, b))\n                    low = max(low, a)\n        if low == n - 1:\n            return score + 1\n        lowest = low + 1\n        q = [(low + 1, i) for i in range(m)]\n        visited.update(q)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    g = [input() for _ in range(n)]\n    print(find(g, n, m))"]