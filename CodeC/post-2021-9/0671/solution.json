["from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nr = cin.readline\nri = lambda : range(int(r()))\nmi = lambda : map(int, r().split())\nfor _ in ri():\n    (n, m, k) = mi()\n    final = n + m\n    xyce = [tuple(mi()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n    batteries.sort(key=itemgetter(0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        if loc != dp[-1][0]:\n            dp.append((-loc, dpval))\n    print(dp[-1][1])", "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nr = cin.readline\nri = lambda : range(int(r()))\nmi = lambda : map(int, r().split())\nfor _ in ri():\n    (n, m, k) = mi()\n    final = n + m\n    xyce = [tuple(mi()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n    batteries.sort(key=itemgetter(0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        if loc != dp[-1][0]:\n            dp.append((-loc, dpval))\n    print(dp[-1][1])", "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nr = cin.readline\nri = lambda : range(int(r()))\nmi = lambda : map(int, r().split())\nfor _ in ri():\n    (n, m, k) = mi()\n    final = n + m\n    xyce = [tuple(mi()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n    batteries.sort(key=itemgetter(0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        if loc != dp[-1][0]:\n            dp.append((-loc, dpval))\n    print(dp[-1][1])", "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nr = cin.readline\nri = lambda : range(int(r()))\nmi = lambda : map(int, r().split())\nfor _ in ri():\n    (n, m, k) = mi()\n    final = n + m\n    xyce = [tuple(mi()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n    batteries.sort(key=itemgetter(0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        if loc != dp[-1][0]:\n            dp.append((-loc, dpval))\n    print(dp[-1][1])", "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nread = cin.readline\nrir = lambda : range(int(read()))\nmir = lambda : map(int, read().split())\nfor _ in rir():\n    (n, m, k) = mir()\n    final = n + m\n    xyce = [tuple(mir()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n    batteries.sort(key=itemgetter(0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        if loc != dp[-1][0]:\n            dp.append((-loc, dpval))\n    print(dp[-1][1])", "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nread = cin.readline\nrir = lambda : range(int(read()))\nmir = lambda : map(int, read().split())\nfor _ in rir():\n    (n, m, k) = mir()\n    final = n + m\n    xyce = [tuple(mir()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n    batteries.sort(key=itemgetter(0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        if loc != dp[-1][0]:\n            dp.append((-loc, dpval))\n    print(dp[-1][1])", "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nread = cin.readline\nrir = lambda : range(int(read()))\nmir = lambda : map(int, read().split())\nfor _ in rir():\n    (n, m, k) = mir()\n    final = n + m\n    xyce = [tuple(mir()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n    batteries.sort(key=itemgetter(0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        if loc != dp[-1][0]:\n            dp.append((-loc, dpval))\n    print(dp[-1][1])", "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nread = cin.readline\nrir = lambda : range(int(read()))\nmir = lambda : map(int, read().split())\nfor _ in rir():\n    (n, m, k) = mir()\n    final = n + m\n    xyce = [tuple(mir()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n    batteries.sort(key=itemgetter(0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        if loc != dp[-1][0]:\n            dp.append((-loc, dpval))\n    print(dp[-1][1])", "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nread = cin.readline\nrir = lambda : range(int(read()))\nmir = lambda : map(int, read().split())\nfor _ in rir():\n    (n, m, k) = mir()\n    final = n + m\n    xyce = [tuple(mir()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n    batteries.sort(key=itemgetter(0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        if loc != dp[-1][0]:\n            dp.append((-loc, dpval))\n    print(dp[-1][1])", "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nread = cin.readline\nrir = lambda : range(int(read()))\nmir = lambda : map(int, read().split())\nfor _ in rir():\n    (n, m, k) = mir()\n    final = n + m\n    xyce = [tuple(mir()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n    batteries.sort(key=itemgetter(0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        if loc != dp[-1][0]:\n            dp.append((-loc, dpval))\n    print(dp[-1][1])", "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nread = cin.readline\nrir = lambda : range(int(read()))\nmir = lambda : map(int, read().split())\nfor _ in rir():\n    (n, m, k) = mir()\n    final = n + m\n    xyce = [tuple(mir()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n    batteries.sort(key=itemgetter(0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        if loc != dp[-1][0]:\n            dp.append((-loc, dpval))\n    print(dp[-1][1])", "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nread = cin.readline\nrir = lambda : range(int(read()))\nmir = lambda : map(int, read().split())\nfor _ in rir():\n    (n, m, k) = mir()\n    final = n + m\n    xyce = [tuple(mir()) for _ in range(k)]\n    batteries = [(x + y, c, e) for (x, y, c, e) in xyce]\n    batteries = [b for b in batteries if b[0] < final]\n    batteries.sort(key=itemgetter(0))\n    batteries.append((final, 0, 0))\n    dp = [(-final, 0)]\n    for (loc, c, e) in reversed(batteries):\n        if loc == final:\n            continue\n        j = bisect(dp, (-(loc + e), -inf))\n        if j == len(dp):\n            continue\n        dpval = c + dp[j][1]\n        while dpval < dp[-1][1]:\n            dp.pop()\n        dp.append((-loc, dpval))\n    res = min((cost for (loc, cost) in dp if loc == 0))\n    print(res)"]