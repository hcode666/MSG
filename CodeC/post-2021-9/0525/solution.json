["MOD = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    n = int(input()) - 1\n    mx = int((2 * n) ** 0.5)\n    if mx * (mx + 1) > 2 * n:\n        mx -= 1\n    (mx_pow, val) = ([], mx)\n    for i in range(5):\n        mx_pow += [val]\n        val *= mx\n    pow_4 = mx * (mx + 1) * (2 * mx + 1) * (3 * mx_pow[1] + 3 * mx - 1) // 30\n    pow_3 = (mx * (mx + 1) // 2) ** 2\n    pow_2 = mx * (mx + 1) * (2 * mx + 1) // 6\n    pow_1 = mx * (mx + 1) // 2\n    ans = (-pow_4 - 2 * pow_3 + (2 * n + 1) * pow_2 + 2 * (n + 1) * pow_1) // 4\n    ans = int(ans)\n    print(ans % MOD)", "MOD = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    n = int(input()) - 1\n    mx = int((2 * n) ** 0.5)\n    if mx * (mx + 1) > 2 * n:\n        mx -= 1\n    (mx_pow, val) = ([], mx)\n    for i in range(5):\n        mx_pow += [val]\n        val *= mx\n    pow_4 = mx * (mx + 1) * (2 * mx + 1) * (3 * mx_pow[1] + 3 * mx - 1) // 30\n    pow_3 = (mx * (mx + 1) // 2) ** 2\n    pow_2 = mx * (mx + 1) * (2 * mx + 1) // 6\n    pow_1 = mx * (mx + 1) // 2\n    ans = (-pow_4 - 2 * pow_3 + (2 * n + 1) * pow_2 + 2 * (n + 1) * pow_1) // 4\n    ans = int(ans)\n    print(ans % MOD)", "import math\nfrom bisect import bisect, bisect_left, bisect_right\nimport heapq\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as ddc\nfrom collections import Counter\n\ndef intin():\n    return int(input())\n\ndef mapin():\n    return map(int, input().split())\n\ndef strin():\n    return input().split()\nINF = 10 ** 20\nmod = 1000000007\n\ndef LIS(arr, n):\n    dp = [10 ** 9] * (n + 1)\n    for ele in arr:\n        dp[bisect_left(dp, ele)] = ele\n    return bisect_left(dp, 10 ** 9)\n\ndef exponentiation(bas, exp, mod=1000000007):\n    t = 1\n    while exp > 0:\n        if exp % 2 != 0:\n            t = t * bas % mod\n        bas = bas * bas % mod\n        exp //= 2\n    return t % mod\n\ndef MOD(p, q=1, mod=1000000007):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\nyes = 'YES'\nno = 'NO'\neven = 'EVEN'\nodd = 'ODD'\nformula = lambda x: (x ** 3 + 3 * x ** 2 + 2 * x) // 6\nsqaure = lambda x: x * (x + 1) // 2\npref = ddc(int)\npref[0] = pref[1] = 0\nfor i in range(2, 100001):\n    pref[i] = pref[i - 1] + i * formula(i - 1)\n\ndef process(arr, n):\n    (l, h) = (1, 100000)\n    while l < h:\n        nex = (l + h + 1) // 2\n        if sqaure(nex) > n:\n            h = nex - 1\n        else:\n            l = nex\n    nex = l\n    ans = 0\n    ans += (n - sqaure(nex)) * formula(nex) + pref[nex]\n    return ans % mod\n\ndef main():\n    for _ in range(int(input())):\n        n = intin()\n        arr = []\n        print(process(arr, n))\nmain()", "import math\nfrom bisect import bisect, bisect_left, bisect_right\nimport heapq\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as ddc\nfrom collections import Counter\n\ndef intin():\n    return int(input())\n\ndef mapin():\n    return map(int, input().split())\n\ndef strin():\n    return input().split()\nINF = 10 ** 20\nmod = 1000000007\n\ndef LIS(arr, n):\n    dp = [10 ** 9] * (n + 1)\n    for ele in arr:\n        dp[bisect_left(dp, ele)] = ele\n    return bisect_left(dp, 10 ** 9)\n\ndef exponentiation(bas, exp, mod=1000000007):\n    t = 1\n    while exp > 0:\n        if exp % 2 != 0:\n            t = t * bas % mod\n        bas = bas * bas % mod\n        exp //= 2\n    return t % mod\n\ndef MOD(p, q=1, mod=1000000007):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\nyes = 'YES'\nno = 'NO'\neven = 'EVEN'\nodd = 'ODD'\nformula = lambda x: (x ** 3 + 3 * x ** 2 + 2 * x) // 6\nsqaure = lambda x: x * (x + 1) // 2\npref = ddc(int)\npref[0] = pref[1] = 0\nfor i in range(2, 100001):\n    pref[i] = pref[i - 1] + i * formula(i - 1)\n\ndef process(arr, n):\n    (l, h) = (1, 100000)\n    while l < h:\n        nex = (l + h + 1) // 2\n        if sqaure(nex) > n:\n            h = nex - 1\n        else:\n            l = nex\n    nex = l\n    ans = 0\n    ans += (n - sqaure(nex)) * formula(nex) + pref[nex]\n    return ans % mod\n\ndef main():\n    for _ in range(int(input())):\n        n = intin()\n        arr = []\n        print(process(arr, n))\nmain()", "MOD = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    n = int(input()) - 1\n    mx = int((2 * n) ** 0.5)\n    if mx * (mx + 1) > 2 * n:\n        mx -= 1\n    (mx_pow, val) = ([], mx)\n    for i in range(5):\n        mx_pow += [val]\n        val *= mx\n    pow_4 = mx * (mx + 1) * (2 * mx + 1) * (3 * mx_pow[1] + 3 * mx - 1) // 30\n    pow_3 = (mx * (mx + 1) // 2) ** 2\n    pow_2 = mx * (mx + 1) * (2 * mx + 1) // 6\n    pow_1 = mx * (mx + 1) // 2\n    ans = (-pow_4 - 2 * pow_3 + (2 * n + 1) * pow_2 + 2 * (n + 1) * pow_1) // 4\n    ans = int(ans)\n    print(ans % MOD)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    lb = 0\n    rb = 1000000000\n    while lb < rb:\n        mb = (lb + rb + 1) // 2\n        if mb * (mb + 1) // 2 <= n:\n            lb = mb\n        else:\n            rb = mb - 1\n    x = lb\n    curr = (x - 1) * x * (x + 1) * (x + 2) * (2 * x + 1) // 60\n    pr = x * (x + 1) // 2\n    rem = n - pr\n    x += 2\n    add = x * (x - 1) * (x - 2) // 6\n    curr += rem * add\n    curr %= 1000000007\n    print(curr)", "import math\n\ndef lower_tri_num_pos(n):\n    return int(0.5 * (-1 + math.sqrt(1 + 8 * n)))\nt = int(input())\nvals = {}\nn = 1000000000\nswitches = lower_tri_num_pos(n)\nremaining = int(n - switches * (switches + 1) / 2)\ntot = 0\nnum = 2\ncursum = 0\nfor i in range(1, switches):\n    cursum += int(i * (i + 1) / 2)\n    tot += num * cursum\n    num += 1\n    vals[i] = (tot, cursum)\nfor _ in range(t):\n    n = int(input())\n    switches = lower_tri_num_pos(n)\n    remaining = int(n - switches * (switches + 1) / 2)\n    (tot, cursum) = vals[switches - 1]\n    cursum += int(switches * (switches + 1) / 2)\n    tot += remaining * cursum\n    print(tot % 1000000007)", "import math\nmod = 1000000007\ntc = int(input())\nls = []\nls2 = []\nn = mod + 100000\nans = 0\nnw = 2\ntemp = 0\nadd2 = 1\nn -= 1\nls.append(0)\nls2.append(0)\nwhile temp + nw <= n:\n    temp += nw\n    ans += nw * (add2 * (add2 + 1) * (add2 + 2)) // 6\n    add2 += 1\n    nw += 1\n    ls.append(ans)\n    ls2.append(temp)\nwhile tc > 0:\n    n = int(input())\n    n -= 1\n    ind = int((math.sqrt(8 * n + 1) - 1) // 2)\n    ind = min(ind + 100, len(ls) - 1)\n    while ind > -1 and ls2[ind] > n:\n        ind -= 1\n    ans = ls[ind]\n    temp = ls2[ind]\n    add2 = ind + 1\n    ans += (n - ls2[ind]) * (add2 * (add2 + 1) * (add2 + 2) // 6)\n    if n == 0:\n        print(0)\n    else:\n        print(int(ans) % mod)\n    tc -= 1", "import math\nmod = 1000000007\ntc = int(input())\nls = []\nls2 = []\nn = mod + 100000\nans = 0\nnw = 2\ntemp = 0\nadd2 = 1\nn -= 1\nls.append(0)\nls2.append(0)\nwhile temp + nw <= n:\n    temp += nw\n    ans += nw * (add2 * (add2 + 1) * (add2 + 2)) // 6\n    add2 += 1\n    nw += 1\n    ls.append(ans)\n    ls2.append(temp)\nwhile tc > 0:\n    n = int(input())\n    n -= 1\n    ind = int((math.sqrt(8 * n + 1) - 1) // 2)\n    ind = min(ind + 100, len(ls) - 1)\n    while ind > -1 and ls2[ind] > n:\n        ind -= 1\n    ans = ls[ind]\n    temp = ls2[ind]\n    add2 = ind + 1\n    ans += (n - ls2[ind]) * (add2 * (add2 + 1) * (add2 + 2) // 6)\n    if n == 0:\n        print(0)\n    else:\n        print(int(ans) % mod)\n    tc -= 1", "import math\nmod = 1000000007\ntc = int(input())\nls = []\nls2 = []\nn = mod + 100000\nans = 0\nnw = 2\ntemp = 0\nadd2 = 1\nn -= 1\nls.append(0)\nls2.append(0)\nwhile temp + nw <= n:\n    temp += nw\n    ans += nw * (add2 * (add2 + 1) * (add2 + 2)) // 6\n    add2 += 1\n    nw += 1\n    ls.append(ans)\n    ls2.append(temp)\nwhile tc > 0:\n    n = int(input())\n    n -= 1\n    ind = int((math.sqrt(8 * n + 1) - 1) // 2)\n    ind = min(ind + 100, len(ls) - 1)\n    while ind > -1 and ls2[ind] > n:\n        ind -= 1\n    ans = ls[ind]\n    temp = ls2[ind]\n    add2 = ind + 1\n    ans += (n - ls2[ind]) * (add2 * (add2 + 1) * (add2 + 2) // 6)\n    if n == 0:\n        print(0)\n    else:\n        print(int(ans) % mod)\n    tc -= 1", "import sys\nimport os\nimport math\nimport collections\n\ndef binary_search(data, elem):\n    low = 0\n    high = len(data) - 1\n    while low <= high:\n        middle = (low + high) // 2\n        if data[middle] == elem:\n            return middle\n        elif data[middle] > elem:\n            high = middle - 1\n        else:\n            low = middle + 1\n    return low\nT = int(input())\nmod = int(1000000000.0 + 7)\nC = []\nfor i in range(1, 100000):\n    d = i * (i - 1) // 2\n    if d > 1000000000.0:\n        break\n    C.append(d)\nA = [0] * len(C)\nB = [0] * len(C)\nfor i in range(1, len(C)):\n    A[i] = A[i - 1] + C[i]\n    B[i] = B[i - 1] + C[i] * C[i]\n    A[i] %= mod\n    B[i] %= mod\nfor _ in range(T):\n    N = int(input())\n    i = binary_search(C, N) - 1\n    print((N * A[i] - B[i]) % mod)", "import sys\nimport os\nimport math\nimport collections\n\ndef binary_search(data, elem):\n    low = 0\n    high = len(data) - 1\n    while low <= high:\n        middle = (low + high) // 2\n        if data[middle] == elem:\n            return middle\n        elif data[middle] > elem:\n            high = middle - 1\n        else:\n            low = middle + 1\n    return low\nT = int(input())\nmod = int(1000000000.0 + 7)\nC = []\nfor i in range(1, 100000):\n    d = i * (i - 1) // 2\n    if d > 1000000000.0:\n        break\n    C.append(d)\nA = [0] * len(C)\nB = [0] * len(C)\nfor i in range(1, len(C)):\n    A[i] = A[i - 1] + C[i]\n    B[i] = B[i - 1] + C[i] * C[i]\n    A[i] %= mod\n    B[i] %= mod\nfor _ in range(T):\n    N = int(input())\n    i = binary_search(C, N) - 1\n    print((N * A[i] - B[i] + mod) % mod)", "tt = int(input())\nfor t in range(tt):\n    N = int(input())\n    n = 0\n    nr = N + 1\n    while n + 1 < nr:\n        m = (n + nr) // 2\n        if m * (m + 1) < 2 * N:\n            n = m\n        else:\n            nr = m\n    s1 = n * (n + 1) // 2\n    s2 = s1 * (2 * n + 1) // 3\n    s3 = s1 * s1\n    s4 = s2 * (3 * n * n + 3 * n - 1) // 5\n    res = N * (s2 + s1) // 2 - (s4 + 2 * s3 + s2) // 4\n    print(res % 1000000007)", "def s1(n):\n    res = 1\n    res *= n\n    res *= n + 1\n    res //= 2\n    return res\n\ndef s2(n):\n    res = 1\n    res *= n\n    res *= n + 1\n    res *= 2 * n + 1\n    res //= 6\n    return res\n\ndef s3(n):\n    res = 1\n    res *= s1(n)\n    res *= s1(n)\n    return res\n\ndef s4(n):\n    res = 1\n    res *= n\n    res *= n + 1\n    res *= 2 * n + 1\n    res *= 3 * n * n + 3 * n - 1\n    res //= 30\n    return res\ntt = int(input())\nfor t in range(tt):\n    N = int(input())\n    n = 0\n    nr = N + 1\n    while n + 1 < nr:\n        m = (n + nr) // 2\n        if m * (m + 1) < 2 * N:\n            n = m\n        else:\n            nr = m\n    res = N * (s2(n) + s1(n)) // 2 - (s4(n) + 2 * s3(n) + s2(n)) // 4\n    print(res % 1000000007)", "import math\n\ndef lower_tri_num_pos(n):\n    return int(0.5 * (-1 + math.sqrt(1 + 8 * n)))\nt = int(input())\nvals = {}\nn = 1000000000\nswitches = lower_tri_num_pos(n)\nremaining = int(n - switches * (switches + 1) / 2)\ntot = 0\nnum = 2\ncursum = 0\nfor i in range(1, switches):\n    cursum += int(i * (i + 1) / 2)\n    tot += num * cursum\n    num += 1\n    vals[i] = (tot, cursum)\nfor _ in range(t):\n    n = int(input())\n    switches = lower_tri_num_pos(n)\n    remaining = int(n - switches * (switches + 1) / 2)\n    (tot, cursum) = vals[switches - 1]\n    cursum += int(switches * (switches + 1) / 2)\n    tot += remaining * cursum\n    print(tot % 1000000007)", "import math\nmod = 1000000007\ntc = int(input())\nls = []\nls2 = []\nn = mod + 100000\nans = 0\nnw = 2\ntemp = 0\nadd2 = 1\nn -= 1\nls.append(0)\nls2.append(0)\nwhile temp + nw <= n:\n    temp += nw\n    ans += nw * (add2 * (add2 + 1) * (add2 + 2)) // 6\n    add2 += 1\n    nw += 1\n    ls.append(ans)\n    ls2.append(temp)\nwhile tc > 0:\n    n = int(input())\n    n -= 1\n    ind = int((math.sqrt(8 * n + 1) - 1) // 2)\n    ind = min(ind + 100, len(ls) - 1)\n    while ind > -1 and ls2[ind] > n:\n        ind -= 1\n    ans = ls[ind]\n    temp = ls2[ind]\n    add2 = ind + 1\n    ans += (n - ls2[ind]) * (add2 * (add2 + 1) * (add2 + 2) // 6)\n    if n == 0:\n        print(0)\n    else:\n        print(int(ans) % mod)\n    tc -= 1", "from bisect import bisect_right\nfrom collections import Counter\na = [n * (n + 1) // 2 for n in range(1, 10 ** 5)]\nprev = [a[0]]\nfor i in a[1:]:\n    prev.append(prev[-1] + i)\nsums = [1]\ni = 1\ncurr = 2\nwhile i < 10 ** 9 + 1:\n    i += curr\n    sums.append(sums[-1] + i * i)\n    curr += 1\n\ndef solve():\n    n = int(input())\n    index = bisect_right(a, n)\n    index -= 1\n    rem = n - a[index]\n    res = 0\n    mod = 10 ** 9 + 7\n    res -= sums[index]\n    res += prev[index] * n\n    print(res % mod)\ntry:\n    for tc in range(int(input())):\n        solve()\nexcept:\n    pass", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    lb = 0\n    rb = 1000000000\n    while lb < rb:\n        mb = (lb + rb + 1) // 2\n        if mb * (mb + 1) // 2 <= n:\n            lb = mb\n        else:\n            rb = mb - 1\n    x = lb\n    curr = (x - 1) * x * (x + 1) * (x + 2) * (2 * x + 1) // 60\n    pr = x * (x + 1) // 2\n    rem = n - pr\n    x += 2\n    add = x * (x - 1) * (x - 2) // 6\n    curr += rem * add\n    curr %= 1000000007\n    print(curr)"]