["from bisect import bisect_right\n\ndef lis(arr):\n    sub = []\n    for (i, x) in enumerate(arr):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\nfor _ in range(int(input())):\n    (N, M) = input().split(' ')\n    N = int(N)\n    M = int(M)\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(lis(A) + lis(B))", "from bisect import bisect_right\n\ndef lis(arr):\n    sub = []\n    for (i, x) in enumerate(arr):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\nfor _ in range(int(input())):\n    (N, M) = input().split(' ')\n    N = int(N)\n    M = int(M)\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(lis(A) + lis(B))", "from bisect import bisect_right\n\ndef lis(arr):\n    sub = []\n    for (i, x) in enumerate(arr):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\nfor _ in range(int(input())):\n    (N, M) = input().split(' ')\n    N = int(N)\n    M = int(M)\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(lis(A) + lis(B))", "from bisect import bisect_right\n\ndef lis(arr):\n    sub = []\n    for (i, x) in enumerate(arr):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\nfor _ in range(int(input())):\n    (N, M) = input().split(' ')\n    N = int(N)\n    M = int(M)\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(lis(A) + lis(B))", "from bisect import bisect_right\n\ndef lis(arr):\n    sub = []\n    for (i, x) in enumerate(arr):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\nt = int(input())\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    array1 = list(map(int, input().split(' ')[:n]))\n    array2 = list(map(int, input().split(' ')[:m]))\n    a = lis(array1)\n    b = lis(array2)\n    print(a + b)\n    t -= 1", "from bisect import bisect_right\n\ndef lis(arr):\n    sub = []\n    for (i, x) in enumerate(arr):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\nfor _ in range(int(input())):\n    (N, M) = input().split(' ')\n    N = int(N)\n    M = int(M)\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(lis(A) + lis(B))", "from bisect import bisect_right\n\ndef LIS(a):\n    L = []\n    for x in a:\n        i = bisect_right(L, x)\n        if i == len(L):\n            L.append(x)\n        else:\n            L[i] = x\n    return len(L)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(LIS(a) + LIS(b))", "def fit(arr, x):\n    (start, end) = (0, len(arr) - 1)\n    while start <= end:\n        mid = (start + end) // 2\n        if x < arr[mid]:\n            end = mid - 1\n        else:\n            start = mid + 1\n        if start > end:\n            break\n    arr[start] = x\n    return\n\ndef lis(arr):\n    aux = [float('inf') for i in range(len(arr))]\n    for i in range(len(arr)):\n        fit(aux, arr[i])\n    maxLen = 0\n    for i in range(len(arr)):\n        if aux[i] == float('inf'):\n            maxLen = i\n            break\n    maxLen = len(arr) if maxLen == 0 else maxLen\n    return maxLen\nans = ''\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ans += str(lis(a) + lis(b)) + '\\n'\nprint(ans)", "from bisect import bisect_right as br\nINF = 1000000000.0 + 1\n\ndef get_ndesc_subs_length(arr, n):\n    d = [INF] * (n + 1)\n    d[0] = 0\n    for el in arr:\n        ind = br(d, el)\n        d[ind] = el\n    ans = 0\n    for i in range(1, n + 1):\n        if d[i] != INF:\n            ans = i\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(get_ndesc_subs_length(a, n) + get_ndesc_subs_length(b, m))", "import sys\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef bs(arr, x):\n    l = 0\n    h = len(arr) - 1\n    while l <= h:\n        m = (l + h) // 2\n        if arr[m] > x:\n            y = m\n            h = m - 1\n        else:\n            l = m + 1\n    return y\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    lnds_a = []\n    lnds_b = []\n    for i in range(n):\n        if len(lnds_a) == 0:\n            lnds_a.append(a[i])\n        elif a[i] >= lnds_a[-1]:\n            lnds_a.append(a[i])\n        else:\n            j = bs(lnds_a, a[i])\n            lnds_a[j] = a[i]\n    for i in range(m):\n        if len(lnds_b) == 0:\n            lnds_b.append(b[i])\n        elif b[i] >= lnds_b[-1]:\n            lnds_b.append(b[i])\n        else:\n            j = bs(lnds_b, b[i])\n            lnds_b[j] = b[i]\n    print(len(lnds_a) + len(lnds_b))", "def bs(a, x):\n    l = 0\n    h = len(a) - 1\n    while l <= h:\n        m = (l + h) // 2\n        if a[m] > x:\n            y = m\n            h = m - 1\n        else:\n            l = m + 1\n    return y\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    t1 = []\n    t2 = []\n    for i in range(n):\n        if len(t1) == 0:\n            t1.append(a[i])\n        elif a[i] >= t1[-1]:\n            t1.append(a[i])\n        else:\n            j = bs(t1, a[i])\n            t1[j] = a[i]\n    for i in range(m):\n        if len(t2) == 0:\n            t2.append(b[i])\n        elif b[i] >= t2[-1]:\n            t2.append(b[i])\n        else:\n            j = bs(t2, b[i])\n            t2[j] = b[i]\n    print(len(t1) + len(t2))", "def lengthOfLIS(array):\n    low = [0] * len(array)\n    total_size = 0\n    for x in array:\n        (i, j) = (0, total_size)\n        while i != j:\n            m = (i + j) // 2\n            if low[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        low[i] = x\n        total_size = max(i + 1, total_size)\n    return total_size\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ar1 = list(map(int, input().split()))\n    ar2 = list(map(int, input().split()))\n    print(lengthOfLIS(ar1) + lengthOfLIS(ar2))", "import math, os, io, heapq\nfrom functools import reduce\nfrom sys import stdin, stdout\nfrom collections import Counter, deque, defaultdict\nfrom itertools import product\nimport bisect\n\ndef getList(method=int):\n    return list(map(method, input().split()))\n\ndef getInt():\n    return int(input())\n\ndef lis(arr: list):\n    (larr, ln) = ([arr[0]], 1)\n    for v in arr[1:]:\n        if v >= larr[-1]:\n            ln += 1\n            larr.append(v)\n        else:\n            ind = bisect.bisect_right(larr, v)\n            larr[ind] = v\n    return ln\n\ndef solve():\n    (m, n) = getList()\n    print(lis(getList()) + lis(getList()))\nfor _ in range(getInt()):\n    solve()", "from bisect import bisect_right\n\ndef ans(c):\n    n = len(c)\n    d = [c[0]]\n    for i in range(1, n):\n        if c[i] >= d[-1]:\n            d.append(c[i])\n        else:\n            index = bisect_right(d, c[i])\n            d[index] = min(d[index], c[i])\n    return len(d)\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = []\n    i = j = 0\n    while i < n and j < m:\n        if a[i] <= b[j]:\n            c.append(a[i])\n            i += 1\n        else:\n            c.append(b[j])\n            j += 1\n    while i < n:\n        c.append(a[i])\n        i += 1\n    while j < m:\n        c.append(b[j])\n        j += 1\n    print(ans(a) + ans(b))", "def rearr(a):\n    ll = [0] * len(a)\n    mx = 0\n    for x in a:\n        (l, r) = (0, mx)\n        while l != r:\n            m = (l + r) // 2\n            if ll[m] <= x:\n                l = m + 1\n            else:\n                r = m\n        ll[l] = x\n        mx = max(mx, l + 1)\n    return mx\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(rearr(a) + rearr(b))", "def bs(key, arr):\n    l = 0\n    r = len(arr) - 1\n    while l < r:\n        mid = (l + r) // 2\n        if arr[mid] > key:\n            r = mid\n        else:\n            l = mid + 1\n    return r\n\ndef longestNonDecreasingSubsequence(a):\n    net = [a[0]]\n    for i in range(1, len(a)):\n        if a[i] >= net[-1]:\n            net.append(a[i])\n        else:\n            k = bs(a[i], net)\n            net[k] = a[i]\n    return len(net)\nt = int(input())\nwhile t != 0:\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))[:n]\n    b = list(map(int, input().split()))[:m]\n    l1 = longestNonDecreasingSubsequence(a)\n    l2 = longestNonDecreasingSubsequence(b)\n    print(l1 + l2)\n    t -= 1", "from bisect import bisect\n\ndef LIS2(x):\n    dp = []\n    ans = []\n    for i in x:\n        y = bisect(dp, i)\n        if y == len(dp):\n            dp.append(i)\n        else:\n            dp[y] = i\n        ans.append(y + 1)\n    return max(ans)\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr1 = list(map(int, input().split()))\n    arr2 = list(map(int, input().split()))\n    print(LIS2(arr1) + LIS2(arr2))", "def bs(tar, net):\n    (low, high) = (0, len(net) - 1)\n    while low < high:\n        mid = (low + high) // 2\n        if net[mid] > tar:\n            high = mid\n        else:\n            low = mid + 1\n    return high\n\ndef longestNonDecreasingSubsequence(a):\n    net = [a[0]]\n    for i in range(1, len(a)):\n        if a[i] >= net[-1]:\n            net.append(a[i])\n        else:\n            k = bs(a[i], net)\n            net[k] = a[i]\n    return len(net)\nt = int(input())\nwhile t != 0:\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))[:n]\n    b = list(map(int, input().split()))[:m]\n    l1 = longestNonDecreasingSubsequence(a)\n    l2 = longestNonDecreasingSubsequence(b)\n    print(l1 + l2)\n    t -= 1", "import bisect\n\ndef lis(A):\n    arr = []\n    for i in A:\n        if len(arr) == 0 or i >= arr[-1]:\n            arr.append(i)\n        else:\n            arr[bisect.bisect_right(arr, i)] = i\n    return len(arr)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(lis(A) + lis(B))", "import bisect\n\ndef lis(A):\n    arr = []\n    for i in A:\n        if len(arr) == 0 or i >= arr[-1]:\n            arr.append(i)\n        else:\n            arr[bisect.bisect_right(arr, i)] = i\n    return len(arr)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(lis(A) + lis(B))", "def lis(nums):\n    tails = [0] * len(nums)\n    size = 0\n    for x in nums:\n        (i, j) = (0, size)\n        while i != j:\n            m = (i + j) // 2\n            if tails[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        tails[i] = x\n        size = max(i + 1, size)\n    return size\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(lis(a) + lis(b))", "from bisect import bisect\n\ndef lis(c, n):\n    ans = [0 for i in range(n + 1)]\n    l = 1\n    ans[0] = c[0]\n    for i in range(1, n):\n        if ans[l - 1] <= c[i]:\n            ans[l] = c[i]\n            l += 1\n        else:\n            ans[bisect(ans, c[i], 0, l - 1)] = c[i]\n    return l\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    k1 = lis(a, n)\n    k2 = lis(b, m)\n    print(k1 + k2)", "from bisect import bisect_left, bisect_right\n\ndef lnds(nums=[]):\n    ax = []\n    ax_len = 0\n    for i in nums:\n        if len(ax) == 0:\n            ax.extend([i])\n            ax_len += 1\n        elif i >= ax[-1]:\n            ax.extend([i])\n            ax_len += 1\n        else:\n            inject = bisect_right(ax, i)\n            ax[inject] = i\n    return ax_len\nt = int(input())\nfor _ in range(t):\n    (n, m) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    la = lnds(a)\n    lb = lnds(b)\n    print(la + lb)", "def lis(arr):\n    temp = [0] * len(arr)\n    res = 0\n    for x in arr:\n        (i, j) = (0, res)\n        while i != j:\n            m = (i + j) // 2\n            if temp[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        temp[i] = x\n        res = max(i + 1, res)\n    return res\nt = int(input())\nwhile t:\n    (n, m) = map(int, input().split(' '))\n    a = list(map(int, input().split(' ')))\n    b = list(map(int, input().split(' ')))\n    print(lis(a) + lis(b))\n    t -= 1", "import bisect\n\ndef lis(nums):\n    tails = [0] * len(nums)\n    size = 0\n    for x in nums:\n        (i, j) = (0, size)\n        while i != j:\n            m = (i + j) // 2\n            if tails[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        tails[i] = x\n        size = max(i + 1, size)\n    return size\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(lis(a) + lis(b))", "import math, bisect, heapq, random, sys, itertools\nints = lambda : list(map(int, input().split()))\nalpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\np = 10 ** 9 + 7\nfrom bisect import bisect_right\nfrom bisect import bisect_left\n\ndef LIS(v):\n    for i in range(len(v)):\n        v[i] = v[i] + i / 1000000\n    if len(v) == 0:\n        return 0\n    tail = [0 for i in range(len(v) + 1)]\n    length = 1\n    tail[0] = v[0]\n    for i in range(1, len(v)):\n        if v[i] > tail[length - 1]:\n            tail[length] = v[i]\n            length += 1\n        else:\n            tail[bisect_left(tail, v[i], 0, length - 1)] = v[i]\n    return length\nfor t in range(int(input())):\n    (n, m) = ints()\n    a = ints()\n    b = ints()\n    print(LIS(a) + LIS(b))", "from math import inf\nfrom bisect import bisect_right\ncase = int(input())\nfor r in range(case):\n    (i, j) = list(map(int, input().split(' ')))\n    a = list(map(int, input().split(' ')))\n    b = list(map(int, input().split(' ')))\n    l1 = [inf] * (len(a) + 1)\n    l1[0] = -inf\n    for z in a:\n        pos = bisect_right(l1, z)\n        l1[pos] = z\n    i = len(a)\n    while l1[i] == inf:\n        i -= 1\n    l2 = [inf] * (len(b) + 1)\n    l2[0] = -inf\n    for s in b:\n        pos = bisect_right(l2, s)\n        l2[pos] = s\n    j = len(b)\n    while l2[j] == inf:\n        j -= 1\n    print(i + j)", "import math\nfrom bisect import bisect_right\n\ndef lengthOfLIS(nums) -> int:\n    h = len(nums) + 1\n    Lis = [math.inf] * h\n    Lis[0] = -math.inf\n    for i in nums:\n        pos = bisect_right(Lis, i, 0, h)\n        Lis[pos] = i\n    for i in range(h - 1, -1, -1):\n        if Lis[i] != math.inf:\n            return i\nT = int(input())\nfor i in range(T):\n    (n, m) = [int(x) for x in input().split()]\n    arr_n = [int(x) for x in input().split()]\n    arr_m = [int(x) for x in input().split()]\n    print(lengthOfLIS(arr_n) + lengthOfLIS(arr_m))", "def CeilIndex(A, l, r, key):\n    while r - l > 1:\n        m = l + (r - l) // 2\n        if A[m] > key:\n            r = m\n        else:\n            l = m\n    return r\n\ndef LongestIncreasingSubsequenceLength(A, size):\n    tailTable = [0 for i in range(size + 1)]\n    len = 0\n    tailTable[0] = A[0]\n    len = 1\n    for i in range(1, size):\n        if A[i] < tailTable[0]:\n            tailTable[0] = A[i]\n        elif A[i] >= tailTable[len - 1]:\n            tailTable[len] = A[i]\n            len += 1\n        else:\n            tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]\n    return len\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ca = LongestIncreasingSubsequenceLength(a, n)\n    cb = LongestIncreasingSubsequenceLength(b, m)\n    print(ca + cb)", "def CeilIndex(A, l, r, key):\n    while r - l > 1:\n        m = l + (r - l) // 2\n        if A[m] > key:\n            r = m\n        else:\n            l = m\n    return r\n\ndef LongestIncreasingSubsequenceLength(A, size):\n    tailTable = [0 for i in range(size + 1)]\n    len = 0\n    tailTable[0] = A[0]\n    len = 1\n    for i in range(1, size):\n        if A[i] < tailTable[0]:\n            tailTable[0] = A[i]\n        elif A[i] >= tailTable[len - 1]:\n            tailTable[len] = A[i]\n            len += 1\n        else:\n            tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]\n    return len\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ca = LongestIncreasingSubsequenceLength(a, n)\n    cb = LongestIncreasingSubsequenceLength(b, m)\n    print(ca + cb)", "def CeilIndex(A, l, r, key):\n    while r - l > 1:\n        m = l + (r - l) // 2\n        if A[m] > key:\n            r = m\n        else:\n            l = m\n    return r\n\ndef LongestIncreasingSubsequenceLength(A, size):\n    tailTable = [0 for i in range(size + 1)]\n    len = 0\n    tailTable[0] = A[0]\n    len = 1\n    for i in range(1, size):\n        if A[i] < tailTable[0]:\n            tailTable[0] = A[i]\n        elif A[i] >= tailTable[len - 1]:\n            tailTable[len] = A[i]\n            len += 1\n        else:\n            tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]\n    return len\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ca = LongestIncreasingSubsequenceLength(a, n)\n    cb = LongestIncreasingSubsequenceLength(b, m)\n    print(ca + cb)", "def LIS(arr, m):\n    size = 0\n    tails = [0] * m\n    for x in arr:\n        (i, j) = (0, size)\n        while i != j:\n            mid = (i + j) // 2\n            if tails[mid] <= x:\n                i = mid + 1\n            else:\n                j = mid\n        tails[i] = x\n        size = max(i + 1, size)\n    return size\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a1 = [int(x) for x in input().split()]\n    a2 = [int(x) for x in input().split()]\n    print(LIS(a1, n) + LIS(a2, m))", "def bs(tar, net):\n    (low, high) = (0, len(net) - 1)\n    while low < high:\n        mid = (low + high) // 2\n        if net[mid] > tar:\n            high = mid\n        else:\n            low = mid + 1\n    return high\n\ndef longestNonDecreasingSubsequence(a):\n    net = [a[0]]\n    for i in range(1, len(a)):\n        if a[i] >= net[-1]:\n            net.append(a[i])\n        else:\n            k = bs(a[i], net)\n            net[k] = a[i]\n    return len(net)\nt = int(input())\nwhile t != 0:\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))[:n]\n    b = list(map(int, input().split()))[:m]\n    l1 = longestNonDecreasingSubsequence(a)\n    l2 = longestNonDecreasingSubsequence(b)\n    print(l1 + l2)\n    t -= 1", "def CeilIndex(A, l, r, key):\n    while r - l > 1:\n        m = l + (r - l) // 2\n        if A[m] > key:\n            r = m\n        else:\n            l = m\n    return r\n\ndef LongestIncreasingSubsequenceLength(A, size):\n    tailTable = [0 for i in range(size + 1)]\n    len = 0\n    tailTable[0] = A[0]\n    len = 1\n    for i in range(1, size):\n        if A[i] < tailTable[0]:\n            tailTable[0] = A[i]\n        elif A[i] >= tailTable[len - 1]:\n            tailTable[len] = A[i]\n            len += 1\n        else:\n            tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]\n    return len\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ca = LongestIncreasingSubsequenceLength(a, n)\n    cb = LongestIncreasingSubsequenceLength(b, m)\n    print(ca + cb)", "def CeilIndex(A, l, r, key):\n    while r - l > 1:\n        m = l + (r - l) // 2\n        if A[m] > key:\n            r = m\n        else:\n            l = m\n    return r\n\ndef LongestIncreasingSubsequenceLength(A, size):\n    tailTable = [0 for i in range(size + 1)]\n    len = 0\n    tailTable[0] = A[0]\n    len = 1\n    for i in range(1, size):\n        if A[i] < tailTable[0]:\n            tailTable[0] = A[i]\n        elif A[i] >= tailTable[len - 1]:\n            tailTable[len] = A[i]\n            len += 1\n        else:\n            tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]\n    return len\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ca = LongestIncreasingSubsequenceLength(a, n)\n    cb = LongestIncreasingSubsequenceLength(b, m)\n    print(ca + cb)", "from bisect import bisect_right\n\ndef lis(A, size):\n    arr = [A[0]]\n    len = 1\n    for i in range(1, size):\n        ind = bisect_right(arr, A[i], 0, len)\n        if ind == len:\n            arr.append(A[i])\n            len += 1\n        else:\n            arr[ind] = A[i]\n    return len\ntry:\n    for tc in range(int(input())):\n        (n, m) = list(map(int, input().split()))\n        arr = list(map(int, input().split()))\n        barr = list(map(int, input().split()))\n        print(lis(arr, n) + lis(barr, m))\nexcept:\n    pass", "t = int(input())\nfrom bisect import bisect_right\n\ndef solve(ar1, ar2):\n\n    def lis(ar):\n        ot = []\n        for i in range(len(ar)):\n            idx = bisect_right(ot, ar[i])\n            if idx == len(ot):\n                ot.append(ar[i])\n            else:\n                ot[idx] = ar[i]\n        return len(ot)\n    return lis(ar1) + lis(ar2)\nfor _ in range(t):\n    (m, n) = list(map(int, input().split()))\n    ar1 = list(map(int, input().split()))\n    ar2 = list(map(int, input().split()))\n    print(solve(ar1, ar2))", "import bisect\nT = int(input())\nfor t in range(T):\n    (n, m) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n\n    def lis(a):\n        x = []\n        n = 0\n        for i in a:\n            j = bisect.bisect_right(x, i)\n            if j == n:\n                x.append(0)\n                n += 1\n            x[j] = i\n        return len(x)\n    print(lis(a) + lis(b))", "from bisect import bisect_right\nt = int(input())\n\ndef lis(arr):\n    sub = []\n    for (i, x) in enumerate(arr):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\nfor _ in range(t):\n    x = [int(i) for i in input().split()]\n    num = [int(i) for i in input().split()]\n    num2 = [int(i) for i in input().split()]\n    x = lis(num)\n    y = lis(num2)\n    print(x + y)", "from bisect import bisect\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    def get_lis(arr):\n        seq = []\n        for val in arr:\n            if not seq or val >= seq[-1]:\n                seq.append(val)\n            else:\n                x = bisect(seq, val)\n                seq[x] = val\n        return len(seq)\n    print(get_lis(A) + get_lis(B))", "import os\nimport sys\nimport sys\nimport os.path\nfrom io import BytesIO, IOBase\nfrom math import cos, e, pi, ceil, pi, tan, floor, gcd, sqrt, log2, factorial, log10\nfrom collections import Counter\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase\nfrom statistics import mean, median, mode\nfrom bisect import *\nalpha = ascii_lowercase\nbeta = ascii_uppercase\n\ndef nextPowerOf2(n):\n    p = 1\n    if n and (not n & n - 1):\n        return n\n    while p < n:\n        p <<= 1\n    return p\n\ndef isComposite(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i = i + 6\n    return False\n\ndef get_Divisors(n):\n    arr = []\n    i = 1\n    while i <= sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                arr.append(i)\n            else:\n                arr.append(i)\n                arr.append(n // i)\n        i = i + 1\n    return arr\n\ndef isprime(n):\n    if n == 1:\n        return 0\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return 0\n        i += 1\n    return 1\n\ndef Sieve(n):\n    prime = [True for i in range(n + 1)]\n    prime[0] = False\n    prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef create_matrix(n, m):\n    mat = [[] for i in range(n)]\n    for i in range(n):\n        for j in range(m):\n            mat[i].append(0)\n    return mat\n\ndef allprimeFactors(n):\n    res = []\n    while n % 2 == 0:\n        res.append(2)\n        n = n // 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            res.append(i)\n            n = n // i\n    if n > 2:\n        res.append(n)\n    return res\n\ndef ispoweroftwo(n):\n    if n == 1:\n        return True\n    elif n % 2 != 0 or n == 0:\n        return False\n    return ispoweroftwo(n / 2)\nif os.path.exists('in.txt'):\n    sys.stdin = open('in.txt', 'r')\n    sys.stdout = open('ot.txt', 'w')\n\ndef solve(arr):\n    sub = []\n    for (i, x) in enumerate(arr):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\n\ndef main():\n    for t in range(int(input())):\n        (n, m) = map(int, input().split())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        print(solve(a) + solve(b))\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            (self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda : self.buffer.read().decode('ascii')\n        self.readline = lambda : self.buffer.readline().decode('ascii')\nmain()", "def lis(arr):\n    q = [0] * len(arr)\n    s = 0\n    for x in arr:\n        (i, j) = (0, s)\n        while i != j:\n            m = (i + j) // 2\n            if q[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        q[i] = x\n        s = max(i + 1, s)\n    return s\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    print(lis(l) + lis(a))", "def lengthOfLIS(nums):\n    tails = [0] * len(nums)\n    size = 0\n    for x in nums:\n        (i, j) = (0, size)\n        while i != j:\n            m = (i + j) // 2\n            if tails[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        tails[i] = x\n        size = max(i + 1, size)\n    return size\nn = int(input())\nfor _ in range(n):\n    (j, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(lengthOfLIS(A) + lengthOfLIS(B))", "from collections import defaultdict\nimport bisect\n\ndef LIS(A):\n    ans = []\n    for x in A:\n        it = bisect.bisect_right(ans, x)\n        if it == len(ans):\n            ans.append(x)\n        else:\n            ans[it] = x\n    return len(ans)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    a1 = LIS(a)\n    a2 = LIS(b)\n    ans = a1 + a2\n    print(ans)", "from bisect import bisect_right\n\ndef LIS(v):\n    if len(v) == 0:\n        return 0\n    tail = [0 for i in range(len(v) + 1)]\n    length = 1\n    tail[0] = v[0]\n    for i in range(1, len(v)):\n        if v[i] >= tail[length - 1]:\n            tail[length] = v[i]\n            length += 1\n        else:\n            tail[bisect_right(tail, v[i], 0, length - 1)] = v[i]\n    return length\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    print(LIS(a) + LIS(b))", "import bisect\n\ndef LIS(nums):\n    dp = []\n    for num in nums:\n        idx = bisect.bisect_right(dp, num)\n        if idx != len(dp):\n            dp[idx] = num\n        else:\n            dp.append(num)\n    return len(dp)\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(LIS(a) + LIS(b))\nfor _ in range(int(input())):\n    solve()", "from math import inf\nfrom bisect import *\nt = int(input())\n\ndef solve(n, m, a, b):\n    alis = [inf]\n    for num in a:\n        if num >= alis[-1]:\n            alis.append(num)\n        else:\n            alis[bisect_right(alis, num)] = num\n    blis = [inf]\n    for num in b:\n        if num >= blis[-1]:\n            blis.append(num)\n        else:\n            blis[bisect_right(blis, num)] = num\n    print(len(blis) + len(alis))\nwhile t:\n    (n, m) = [int(x) for x in input().split(' ')]\n    a = [int(x) for x in input().split(' ')]\n    b = [int(x) for x in input().split(' ')]\n    t -= 1\n    solve(n, m, a, b)", "def merged_lis(array):\n    low = [0] * len(array)\n    total_size = 0\n    for x in array:\n        (i, j) = (0, total_size)\n        while i != j:\n            m = (i + j) // 2\n            if low[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        low[i] = x\n        total_size = max(i + 1, total_size)\n    return total_size\nfor i in range(int(input())):\n    (q, p) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(merged_lis(a) + merged_lis(b))", "from bisect import bisect_left, bisect_right\n\ndef LongestIncreasingSubsequenceLength(v):\n    if len(v) == 0:\n        return 0\n    tail = [0 for i in range(len(v) + 1)]\n    length = 1\n    tail[0] = v[0]\n    for i in range(1, len(v)):\n        if v[i] >= tail[length - 1]:\n            tail[length] = v[i]\n            length += 1\n        else:\n            tail[bisect_right(tail, v[i], 0, length - 1)] = v[i]\n    return length\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    i = 0\n    j = 0\n    c = []\n    flag = 0\n    print(LongestIncreasingSubsequenceLength(a) + LongestIncreasingSubsequenceLength(b))", "def longestNonDecreasingSubSequence(a) -> int:\n    from bisect import bisect_right\n    sub = []\n    for (idx, x) in enumerate(a):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            i = bisect_right(sub, x)\n            sub[i] = x\n    return len(sub)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(longestNonDecreasingSubSequence(a) + longestNonDecreasingSubSequence(b))", "def lis(arr):\n    q = [0] * len(arr)\n    s = 0\n    for x in arr:\n        (i, j) = (0, s)\n        while i != j:\n            m = (i + j) // 2\n            if q[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        q[i] = x\n        s = max(i + 1, s)\n    return s\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    print(lis(l) + lis(a))", "from bisect import bisect_right\n\ndef longestNonDecreasingSubsequence(arr):\n    sub = []\n    for (i, x) in enumerate(arr):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\nfor t in range(int(input())):\n    global maximum\n    (N, M) = map(int, input().split())\n    from math import inf\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(longestNonDecreasingSubsequence(A) + longestNonDecreasingSubsequence(B))", "import bisect\n\ndef ans(arr):\n    t = [arr[0]]\n    for i in arr[1:]:\n        b = bisect.bisect_right(t, i)\n        if b == len(t):\n            t.append(i)\n        else:\n            t[b] = i\n    return len(t)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    aa = ans(A)\n    bb = ans(B)\n    print(aa + bb)", "def lis(arr):\n    q = [0] * len(arr)\n    s = 0\n    for x in arr:\n        (i, j) = (0, s)\n        while i != j:\n            m = (i + j) // 2\n            if q[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        q[i] = x\n        s = max(i + 1, s)\n    return s\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    print(lis(l) + lis(a))", "def merged_lis(array):\n    low = [0] * len(array)\n    total_size = 0\n    for x in array:\n        (i, j) = (0, total_size)\n        while i != j:\n            m = (i + j) // 2\n            if low[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        low[i] = x\n        total_size = max(i + 1, total_size)\n    return total_size\nfor i in range(int(input())):\n    (q, p) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(merged_lis(a) + merged_lis(b))", "from bisect import bisect_left\nfrom typing import DefaultDict\nfrom collections import OrderedDict, defaultdict\nimport math\nfrom math import sqrt\nimport collections\nfrom sys import maxsize\nfrom itertools import combinations_with_replacement\nimport sys\n\ndef sieve_erasthones(n):\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    for p in range(n + 1):\n        if prime[p]:\n            cnt += 1\n    return cnt\n\ndef calculate(p, q):\n    mod = 998244353\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n\ndef count_factors(n):\n    i = 1\n    c = 0\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n // i == i:\n                c += 1\n            else:\n                c += 2\n        i += 1\n    return c\n\ndef ncr_modulo(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef isprime(n):\n    prime_flag = 0\n    if n > 1:\n        for i in range(2, int(sqrt(n)) + 1):\n            if n % i == 0:\n                prime_flag = 1\n                break\n        if prime_flag == 0:\n            return True\n        else:\n            return False\n    else:\n        return True\n\ndef smallestDivisor(n):\n    if n % 2 == 0:\n        return 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return i\n        i += 2\n    return n\n\ndef dict_ele_count(l):\n    d = DefaultDict(lambda : 0)\n    for ele in l:\n        d[ele] += 1\n    return d\n\ndef max_in_dict(d):\n    maxi = 0\n    for ele in d:\n        if d[ele] > maxi:\n            maxi = d[ele]\n    return maxi\n\ndef element_count(s):\n    l = []\n    k = s[0]\n    c = 0\n    for ele in s:\n        if ele == k:\n            c += 1\n        else:\n            l.append([k, c])\n            k = ele\n            c = 1\n    l.append([k, c])\n    return l\n\ndef modular_exponentiation(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 != 0:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef number_of_primefactor(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return len(set(l))\nmod = 10 ** 9 + 7\nans = 0\nvowels = ['a', 'e', 'i', 'o', 'u']\n\ndef CeilIndex(A, l, r, key):\n    while r > l:\n        m = l + (r - l) // 2\n        if A[m] > key:\n            r = m\n        else:\n            l = m + 1\n    return r\n\ndef lis(A, size):\n    tailTable = [0 for i in range(size + 1)]\n    len = 0\n    tailTable[0] = A[0]\n    len = 1\n    for i in range(1, size):\n        if A[i] < tailTable[0]:\n            tailTable[0] = A[i]\n        elif A[i] >= tailTable[len - 1]:\n            tailTable[len] = A[i]\n            len += 1\n        else:\n            tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]\n    return len\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(lis(a, n) + lis(b, m))", "def lis(X):\n    N = len(X)\n    P = [0] * N\n    M = [0] * (N + 1)\n    L = 0\n    for i in range(N):\n        lo = 1\n        hi = L\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if X[M[mid]] <= X[i]:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        newL = lo\n        P[i] = M[newL - 1]\n        M[newL] = i\n        if newL > L:\n            L = newL\n    S = []\n    k = M[L]\n    for i in range(L - 1, -1, -1):\n        S.append(X[k])\n        k = P[k]\n    return len(S[::-1])\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(lis(a) + lis(b))", "def lis(arr):\n    q = [0] * len(arr)\n    s = 0\n    for x in arr:\n        (i, j) = (0, s)\n        while i != j:\n            m = (i + j) // 2\n            if q[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        q[i] = x\n        s = max(i + 1, s)\n    return s\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    print(lis(l) + lis(a))", "def lis(arr):\n    q = [0] * len(arr)\n    s = 0\n    for x in arr:\n        (i, j) = (0, s)\n        while i != j:\n            m = (i + j) // 2\n            if q[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        q[i] = x\n        s = max(i + 1, s)\n    return s\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    print(lis(l) + lis(a))", "def fn(nums):\n    n = len(nums)\n    slots = [0 for _ in range(n)]\n    valid_slot = 0\n    for number in nums:\n        (left, right) = (0, valid_slot)\n        while left < right:\n            mid = (left + right) // 2\n            if number >= slots[mid]:\n                left = mid + 1\n            else:\n                right = mid\n        put_index = left\n        slots[put_index] = number\n        valid_slot = max(put_index + 1, valid_slot)\n    return valid_slot\n\ndef func():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(fn(a) + fn(b))\nt = int(input())\nfor i in range(t):\n    func()", "def CeilIndex(A, l, r, key):\n    while r - l > 1:\n        m = l + (r - l) // 2\n        if A[m] > key:\n            r = m\n        else:\n            l = m\n    return r\n\ndef LIS(A, size):\n    tailTable = [0 for i in range(size + 1)]\n    len = 0\n    tailTable[0] = A[0]\n    len = 1\n    for i in range(1, size):\n        if A[i] < tailTable[0]:\n            tailTable[0] = A[i]\n        elif A[i] >= tailTable[len - 1]:\n            tailTable[len] = A[i]\n            len += 1\n        else:\n            tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]\n    return len\nfor _ in range(int(input())):\n    (o, m) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    print(LIS(a, o) + LIS(b, m))", "from bisect import bisect_right, bisect_left\n\ndef LIS(v):\n    if len(v) == 0:\n        return 0\n    tail = [0 for i in range(len(v) + 1)]\n    length = 1\n    tail[0] = v[0]\n    for i in range(1, len(v)):\n        if v[i] >= tail[length - 1]:\n            tail[length] = v[i]\n            length += 1\n        else:\n            tail[bisect_right(tail, v[i], 0, length - 1)] = v[i]\n    return length\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(LIS(a) + LIS(b))", "from bisect import bisect\nimport bisect\n\ndef fun(a):\n    res = []\n    for i in range(len(a)):\n        p = bisect.bisect_right(res, a[i])\n        if p == len(res):\n            res.append(a[i])\n        res[p] = a[i]\n    return len(res)\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = int(input())\n    for _ in range(how_much_noob_I_am):\n        (n, m) = map(int, input().split())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        print(fun(a) + fun(b))\nmain()", "from sys import stdin\nfrom collections import defaultdict as dd, deque as dq\nfrom heapq import heappush as hpush, heappop as hpop\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom random import randint\nfrom math import sqrt, ceil, floor\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef text():\n    return stdin.readline().rstrip()\n\ndef num():\n    return int(text())\n\ndef mp(dt):\n    return map(dt, stdin.readline().split())\n\ndef array(dt):\n    return list(mp(dt))\n\ndef search(arr, val):\n    beg = 0\n    end = len(arr) - 1\n    ans = -1\n    while beg <= end:\n        mid = (beg + end) // 2\n        if arr[mid] > val:\n            ans = mid\n            end = mid - 1\n        else:\n            beg = mid + 1\n    return ans\nt = num()\nwhile t > 0:\n    (n, m) = mp(int)\n    a = array(int)\n    b = array(int)\n    nums = a\n    dp = [nums[0]]\n    n = len(nums)\n    for i in range(1, len(nums)):\n        if nums[i] < dp[-1]:\n            idx = search(dp, nums[i])\n            dp[idx] = nums[i]\n        else:\n            dp.append(nums[i])\n    al = len(dp)\n    nums = b\n    dp = [nums[0]]\n    n = len(nums)\n    for i in range(1, len(nums)):\n        if nums[i] < dp[-1]:\n            idx = search(dp, nums[i])\n            dp[idx] = nums[i]\n        else:\n            dp.append(nums[i])\n    print(al + len(dp))\n    t -= 1", "from bisect import bisect\n\ndef LIS(x, N):\n    dp = []\n    ans = []\n    for i in x:\n        y = bisect(dp, i)\n        if y == len(dp):\n            dp.append(i)\n        else:\n            dp[y] = i\n        ans.append(y + 1)\n    return ans\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l1 = list(map(int, input().split()))\n    l2 = list(map(int, input().split()))\n    c = LIS(l1, len(l1))\n    d = LIS(l2, len(l2))\n    print(max(c) + max(d))", "def lis(X):\n    N = len(X)\n    P = [0] * N\n    M = [0] * (N + 1)\n    L = 0\n    for i in range(N):\n        lo = 1\n        hi = L\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if X[M[mid]] <= X[i]:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        newL = lo\n        P[i] = M[newL - 1]\n        M[newL] = i\n        if newL > L:\n            L = newL\n    S = []\n    k = M[L]\n    for i in range(L - 1, -1, -1):\n        S.append(X[k])\n        k = P[k]\n    return S[::-1]\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m) = map(int, input().split())\n    l1 = list(map(int, input().split()))\n    l2 = list(map(int, input().split()))\n    print(len(lis(l1)) + len(lis(l2)))", "import math, sys, bisect, heapq, os\nfrom collections import defaultdict, Counter, deque\nfrom itertools import groupby, accumulate\nfrom functools import lru_cache\npr = lambda x: x\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\naj = lambda : list(map(int, input().split()))\n\ndef list3d(a, b, c, d):\n    return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Y(c):\n    print(['NO', 'YES'][c])\n\ndef y(c):\n    print(['no', 'yes'][c])\n\ndef Yy(c):\n    print(['No', 'Yes'][c])\n\ndef lis(A):\n    arr = []\n    for i in A:\n        if len(arr) == 0 or i >= arr[-1]:\n            arr.append(i)\n        else:\n            arr[bisect.bisect_right(arr, i)] = i\n    return len(arr)\nfor _ in range(int(input())):\n    (n, m) = aj()\n    A = aj()\n    B = aj()\n    print(lis(A) + lis(B))", "def longest(nums):\n    tails = [0] * len(nums)\n    size = 0\n    for x in nums:\n        (i, j) = (0, size)\n        while i != j:\n            m = (i + j) // 2\n            if tails[int(m)] <= x:\n                i = m + 1\n            else:\n                j = m\n        tails[i] = x\n        size = max(i + 1, size)\n    return size\nn = int(input())\nfor i in range(n):\n    (a, b) = [int(i) for i in input().split()]\n    l1 = [int(i) for i in input().split()]\n    l2 = [int(i) for i in input().split()]\n    print(longest(l1) + longest(l2))", "from bisect import bisect_right\n\ndef LIS(v):\n    if len(v) == 0:\n        return 0\n    tailTable = [0 for i in range(len(v) + 1)]\n    length = 1\n    tailTable[0] = v[0]\n    for i in range(1, len(v)):\n        if v[i] >= tailTable[length - 1]:\n            tailTable[length] = v[i]\n            length += 1\n        else:\n            tailTable[bisect_right(tailTable, v[i], 0, length - 1)] = v[i]\n    return length\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr1 = list(map(int, input().split()))\n    arr2 = list(map(int, input().split()))\n    l1 = LIS(arr1)\n    l2 = LIS(arr2)\n    print(l1 + l2)", "from bisect import bisect\nglobal maximum\n\ndef LIS(x):\n    dp = []\n    ans = []\n    for i in x:\n        y = bisect(dp, i)\n        if y == len(dp):\n            dp.append(i)\n        else:\n            dp[y] = i\n        ans.append(y + 1)\n    return max(ans)\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, m) = list(map(int, input().split(' ')))\n    arr1 = list(map(int, input().split(' ')))\n    arr2 = list(map(int, input().split(' ')))\n    print(LIS(arr1) + LIS(arr2))", "import bisect\n\ndef lnds(A):\n    INF = int(10000000000.0)\n    dp = [INF] * (len(A) + 1)\n    dp[0] = -INF\n    for i in range(len(A)):\n        j = bisect.bisect_right(dp, A[i])\n        if dp[j - 1] <= A[i] and A[i] < dp[j]:\n            dp[j] = A[i]\n    ans = 0\n    for i in range(1, len(A) + 1):\n        if dp[i] < INF:\n            ans = i\n    return ans\nfor _ in range(int(input())):\n    (N, M) = map(int, input().strip().split())\n    A = list(map(int, input().strip().split()))\n    B = list(map(int, input().strip().split()))\n    print(lnds(A) + lnds(B))", "import heapq\nimport math\nimport sys\nimport collections\nimport bisect\nimport time\nimport random\nimport itertools\nimport string\nfrom collections import Counter, defaultdict\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef CeilIndex(A, l, r, key):\n    while r - l > 1:\n        m = l + (r - l) // 2\n        if A[m] > key:\n            r = m\n        else:\n            l = m\n    return r\n\ndef LongestIncreasingSubsequenceLength(A, size):\n    tailTable = [0 for i in range(size + 1)]\n    tailTable[0] = A[0]\n    len = 1\n    for i in range(1, size):\n        if A[i] < tailTable[0]:\n            tailTable[0] = A[i]\n        elif A[i] >= tailTable[len - 1]:\n            tailTable[len] = A[i]\n            len += 1\n        else:\n            tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]\n    return len\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    a1 = get_list()\n    a2 = get_list()\n    print(LongestIncreasingSubsequenceLength(a1, n) + LongestIncreasingSubsequenceLength(a2, m))", "import bisect\nT = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    (i, j) = (0, 0)\n    res = []\n    count = 0\n    while i < len(A):\n        indx = bisect.bisect_right(res, A[i])\n        if indx == count:\n            res.append(A[i])\n            count += 1\n        else:\n            res[indx] = A[i]\n        i += 1\n    res2 = []\n    count2 = 0\n    while j < len(B):\n        indx = bisect.bisect_right(res2, B[j])\n        if indx == count2:\n            res2.append(B[j])\n            count2 += 1\n        else:\n            res2[indx] = B[j]\n        j += 1\n    print(count + count2)", "def lengthOfLIS(nums):\n    tails = [0] * len(nums)\n    size = 0\n    for x in nums:\n        (i, j) = (0, size)\n        while i != j:\n            m = (i + j) // 2\n            if tails[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        tails[i] = x\n        size = max(i + 1, size)\n    return size\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr1 = list(map(int, input().split()))\n    arr2 = list(map(int, input().split()))\n    l1 = lengthOfLIS(arr1)\n    l2 = lengthOfLIS(arr2)\n    print(l1 + l2)", "def ci(a, l, r, k):\n    while r - l > 1:\n        m = l + (r - l) // 2\n        if a[m] > k:\n            r = m\n        else:\n            l = m\n    return r\n\ndef lon(a, s):\n    tail = [0 for i in range(s + 1)]\n    le = 0\n    tail[0] = a[0]\n    le = 1\n    for i in range(1, s):\n        if a[i] < tail[0]:\n            tail[0] = a[i]\n        elif a[i] >= tail[le - 1]:\n            tail[le] = a[i]\n            le += 1\n        else:\n            tail[ci(tail, -1, le - 1, a[i])] = a[i]\n    return le\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    l1 = list(map(int, input().split()))\n    l2 = list(map(int, input().split()))\n    ans = lon(l1, n) + lon(l2, m)\n    print(ans)", "def lengthOfLIS(nums):\n    tails = [0] * len(nums)\n    size = 0\n    for x in nums:\n        (i, j) = (0, size)\n        while i != j:\n            m = (i + j) // 2\n            if tails[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        tails[i] = x\n        size = max(i + 1, size)\n    return size\nn = int(input())\nfor _ in range(n):\n    (j, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(lengthOfLIS(A) + lengthOfLIS(B))", "import bisect\nimport sys\nip = sys.stdin.readline\n\ndef lis(arr):\n    if len(arr) == 0:\n        return 0\n    l = [arr[0]]\n    for i in range(1, len(arr)):\n        element = arr[i]\n        pos = bisect.bisect(l, element)\n        if pos == len(l):\n            if element > l[pos - 1]:\n                l.append(element)\n        elif element != l[pos - 1]:\n            l[pos] = element\n    return len(l)\nfor _ in range(int(ip())):\n    (n, m) = map(int, ip().split())\n    a = list(map(int, ip().split()))\n    b = list(map(int, ip().split()))\n    a1 = sorted(list(zip(a, [i for i in range(n)])))\n    b1 = sorted(list(zip(b, [i for i in range(m)])))\n    di1 = dict()\n    di2 = dict()\n    for i in range(n):\n        if i == 0:\n            di1[a1[i][1]] = a1[i][0]\n        else:\n            di1[a1[i][1]] = di1[a1[i - 1][1]] + 1\n    for i in range(m):\n        if i == 0:\n            di2[b1[i][1]] = b1[i][0]\n        else:\n            di2[b1[i][1]] = di2[b1[i - 1][1]] + 1\n    a2 = []\n    b2 = []\n    for i in range(n):\n        a2.append(di1[i])\n    for i in range(m):\n        b2.append(di2[i])\n    print(lis(a2) + lis(b2))", "import bisect\nT = int(input())\nfor t in range(T):\n    (n, m) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n\n    def lis(a):\n        x = []\n        n = 0\n        for i in a:\n            j = bisect.bisect_right(x, i)\n            if j == n:\n                x.append(0)\n                n += 1\n            x[j] = i\n        return len(x)\n    print(lis(a) + lis(b))", "import math\n\ndef lis(arr):\n    dp = [0] * len(arr)\n    maxx = 0\n    for x in arr:\n        (i, j) = (0, maxx)\n        while i != j:\n            m = (i + j) // 2\n            if dp[m] <= x:\n                i = m + 1\n            else:\n                j = m\n        dp[i] = x\n        maxx = max(i + 1, maxx)\n    return maxx\n\ndef func(N, M, nums, nums2):\n    return lis(nums) + lis(nums2)\n    pass\nT = int(input())\nfor i in range(T):\n    (N, M) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(func(N, M, A, B))", "from bisect import bisect_right\n\ndef lis(v):\n    if len(v) == 0:\n        return 0\n    tail = [0 for i in range(len(v) + 1)]\n    length = 1\n    tail[0] = v[0]\n    for i in range(1, len(v)):\n        if v[i] >= tail[length - 1]:\n            tail[length] = v[i]\n            length += 1\n        else:\n            tail[bisect_right(tail, v[i], 0, length - 1)] = v[i]\n    return length\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    brr = list(map(int, input().split()))\n    l1 = lis(arr)\n    l2 = lis(brr)\n    print(l1 + l2)", "from sys import stdin\ninput = stdin.readline\nfrom bisect import bisect_right\n\ndef lis(v):\n    if len(v) == 0:\n        return 0\n    tail = [0 for i in range(len(v) + 1)]\n    length = 1\n    tail[0] = v[0]\n    for i in range(1, len(v)):\n        if v[i] >= tail[length - 1]:\n            tail[length] = v[i]\n            length += 1\n        else:\n            ind = bisect_right(tail, v[i], 0, length - 1)\n            tail[ind] = v[i]\n    return length\n\ndef func():\n    print(lis(a) + lis(b))\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    func()", "from bisect import bisect_right\n\ndef LongestIncreasingSubsequenceLength(v):\n    if len(v) == 0:\n        return 0\n    tail = [0 for i in range(len(v) + 1)]\n    length = 1\n    tail[0] = v[0]\n    for i in range(1, len(v)):\n        if v[i] >= tail[length - 1]:\n            tail[length] = v[i]\n            length += 1\n        else:\n            tail[bisect_right(tail, v[i], 0, length - 1)] = v[i]\n    return length\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(LongestIncreasingSubsequenceLength(a) + LongestIncreasingSubsequenceLength(b))", "from bisect import bisect_right\n\ndef LIS(a):\n    L = []\n    for x in a:\n        i = bisect_right(L, x)\n        if i == len(L):\n            L.append(x)\n        else:\n            L[i] = x\n    return len(L)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(LIS(a) + LIS(b))", "from bisect import bisect_right\n\ndef longestNonDecreasingSubsequence(arr):\n    sub = []\n    for (i, x) in enumerate(arr):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ans = longestNonDecreasingSubsequence(a) + longestNonDecreasingSubsequence(b)\n    print(ans)", "from bisect import bisect_left, bisect_right\n\ndef merge(N, M):\n    (i, j) = (0, 0)\n    tm = []\n    while i < len(N) and j < len(M):\n        if N[i] < M[j]:\n            tm.append(N[i])\n            i += 1\n        else:\n            tm.append(M[j])\n            j += 1\n    while i < len(N):\n        tm.append(N[i])\n        i += 1\n    while j < len(M):\n        tm.append(M[j])\n        j += 1\n    return tm\n\ndef lengthOfLIS(nums):\n    tails = [0] * len(nums)\n    size = 0\n    for x in nums:\n        (i, j) = (0, size)\n        while i != j:\n            m = (i + j) // 2\n            if tails[m] < x:\n                i = m + 1\n            else:\n                j = m\n        tails[i] = x\n        size = max(i + 1, size)\n    return size\n\ndef lengthOfLIS_(nums) -> int:\n    sub = []\n    for x in nums:\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\nfor t in range(int(input())):\n    (a, b) = map(int, input().split())\n    N = list(map(int, input().split()))\n    M = list(map(int, input().split()))\n    C = merge(N, M)\n    print(lengthOfLIS_(N) + lengthOfLIS_(M))", "import bisect\n\ndef LIS(nums):\n    dp = []\n    for (i, num) in enumerate(nums):\n        idx = bisect.bisect_right(dp, num)\n        if idx == len(dp):\n            dp.append(num)\n        else:\n            dp[idx] = num\n    return len(dp)\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(LIS(a) + LIS(b))\nfor _ in range(int(input())):\n    solve()", "from bisect import bisect_right\n\ndef longestNonDecreasingSubsequence(arr):\n    sub = []\n    for (i, x) in enumerate(arr):\n        if len(sub) == 0 or sub[-1] <= x:\n            sub.append(x)\n        else:\n            idx = bisect_right(sub, x)\n            sub[idx] = x\n    return len(sub)\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(longestNonDecreasingSubsequence(a) + longestNonDecreasingSubsequence(b))", "import bisect\n\ndef count(lst):\n    best = []\n    for v in lst:\n        pos = bisect.bisect(best, v)\n        if pos < len(best):\n            best[pos] = v\n        else:\n            best.append(v)\n    return len(best)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(count(a) + count(b))", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random\nfrom functools import lru_cache\nfrom itertools import *\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = int(input())\n    for __ in range(how_much_noob_I_am):\n        (n, m) = sep()\n        a = lis()\n        b = lis()\n\n        def fun(a):\n            res = []\n            for i in range(len(a)):\n                p = bisect.bisect_right(res, a[i])\n                if p == len(res):\n                    res.append(a[i])\n                res[p] = a[i]\n            return len(res)\n        print(fun(a) + fun(b))\nmain()", "def CeilIndex(A, l, r, key):\n    while r - l > 1:\n        m = l + (r - l) // 2\n        if A[m] > key:\n            r = m\n        else:\n            l = m\n    return r\n\ndef LongestIncreasingSubsequenceLength(A, size):\n    tailTable = [0 for i in range(size + 1)]\n    len = 0\n    tailTable[0] = A[0]\n    len = 1\n    for i in range(1, size):\n        if A[i] < tailTable[0]:\n            tailTable[0] = A[i]\n        elif A[i] >= tailTable[len - 1]:\n            tailTable[len] = A[i]\n            len += 1\n        else:\n            tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]\n    return len\nfor tt in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr1 = list(map(int, input().split()))\n    arr2 = list(map(int, input().split()))\n    print(LongestIncreasingSubsequenceLength(arr1, n) + LongestIncreasingSubsequenceLength(arr2, m))", "def f(A, n):\n    L = [0 for i in range(n)]\n    count = 0\n    for x in A:\n        i = 0\n        j = count\n        while i != j:\n            y = (i + j) // 2\n            if L[y] <= x:\n                i = y + 1\n            else:\n                j = y\n        L[i] = x\n        count = max(i + 1, count)\n    return count\nT = int(input())\nfor tc in range(T):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(f(A, n) + f(B, m))", "from bisect import *\n\ndef lis(a):\n    ok = [0] * (len(a) + 1)\n    fk = 1\n    ok[0] = a[0]\n    for i in range(1, len(a)):\n        if a[i] >= ok[fk - 1]:\n            ok[fk] = a[i]\n            fk += 1\n        else:\n            ok[bisect_right(ok, a[i], 0, fk - 1)] = a[i]\n    return fk\nt = int(input())\nfor _ in range(t):\n    t -= 1\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(lis(a) + lis(b))"]