["from sys import exit, setrecursionlimit\nfrom functools import reduce\nfrom itertools import *\nfrom collections import defaultdict\nfrom bisect import bisect\n\ndef read():\n    return int(input())\n\ndef reads():\n    return [int(x) for x in input().split()]\nT = read()\nfor _ in range(T):\n    (N, Q) = reads()\n    A = []\n    W = []\n    Scy = []\n    for i in range(N):\n        line = reads()\n        a = line[0]\n        w = line[1:]\n        aa = a * 2\n        scy = [0] * aa\n        for j in range(1, aa):\n            scy[j] = scy[j - 1] + w[(j - 1) % a]\n        Scy.append(scy)\n        A.append(a)\n        W.append(w)\n\n    def smalldistr(k, i, j):\n        scy = Scy[k]\n        a = A[k]\n        return scy[j] - scy[i] if i <= j else scy[j + a] - scy[i]\n\n    def smalldist(k, i, j):\n        return min(smalldistr(k, i, j), smalldistr(k, j, i))\n    NN = N * 2\n    Lcy = [0] * NN\n    Ledges = []\n    Vi = [0] * N\n    Vo = [0] * N\n    for i in range(N):\n        (v1, v2, w) = reads()\n        (v1, v2) = (v1 - 1, v2 - 1)\n        Ledges.append(w)\n        Vo[i] = v1\n        Vi[(i + 1) % N] = v2\n    for i in range(1, NN):\n        imod = (i - 1) % N\n        Lcy[i] = smalldist(imod, Vi[imod], Vo[imod]) + Lcy[i - 1] + Ledges[imod]\n\n    def largedistr(i, j):\n        return Lcy[j] - Lcy[i] if i <= j else Lcy[j + N] - Lcy[i]\n    for i in range(Q):\n        (v1, c1, v2, c2) = reads()\n        (v1, v2, c1, c2) = (v1 - 1, v2 - 1, c1 - 1, c2 - 1)\n        dR = smalldist(c1, v1, Vo[c1]) + largedistr(c1, c2) + smalldist(c2, v2, Vi[c2]) - smalldist(c1, Vi[c1], Vo[c1])\n        dL = smalldist(c2, v2, Vo[c2]) + largedistr(c2, c1) + smalldist(c1, v1, Vi[c1]) - smalldist(c2, Vi[c2], Vo[c2])\n        print(min(dR, dL))", "from sys import exit, setrecursionlimit\nfrom functools import reduce\nfrom itertools import *\nfrom collections import defaultdict\nfrom bisect import bisect\n\ndef read():\n    return int(input())\n\ndef reads():\n    return [int(x) for x in input().split()]\nT = read()\nfor _ in range(T):\n    (N, Q) = reads()\n    A = []\n    W = []\n    Scy = []\n    for i in range(N):\n        line = reads()\n        a = line[0]\n        w = line[1:]\n        aa = a * 2\n        scy = [0] * aa\n        for j in range(1, aa):\n            scy[j] = scy[j - 1] + w[(j - 1) % a]\n        Scy.append(scy)\n        A.append(a)\n        W.append(w)\n\n    def smalldistr(k, i, j):\n        scy = Scy[k]\n        a = A[k]\n        return scy[j] - scy[i] if i <= j else scy[j + a] - scy[i]\n\n    def smalldist(k, i, j):\n        return min(smalldistr(k, i, j), smalldistr(k, j, i))\n    NN = N * 2\n    Lcy = [0] * NN\n    Ledges = []\n    Vi = [0] * N\n    Vo = [0] * N\n    for i in range(N):\n        (v1, v2, w) = reads()\n        (v1, v2) = (v1 - 1, v2 - 1)\n        Ledges.append(w)\n        Vo[i] = v1\n        Vi[(i + 1) % N] = v2\n    for i in range(1, NN):\n        imod = (i - 1) % N\n        Lcy[i] = smalldist(imod, Vi[imod], Vo[imod]) + Lcy[i - 1] + Ledges[imod]\n\n    def largedistr(i, j):\n        return Lcy[j] - Lcy[i] if i <= j else Lcy[j + N] - Lcy[i]\n    for i in range(Q):\n        (v1, c1, v2, c2) = reads()\n        (v1, v2, c1, c2) = (v1 - 1, v2 - 1, c1 - 1, c2 - 1)\n        dR = smalldist(c1, v1, Vo[c1]) + largedistr(c1, c2) + smalldist(c2, v2, Vi[c2]) - smalldist(c1, Vi[c1], Vo[c1])\n        dL = smalldist(c2, v2, Vo[c2]) + largedistr(c2, c1) + smalldist(c1, v1, Vi[c1]) - smalldist(c2, Vi[c2], Vo[c2])\n        print(min(dR, dL))", "def find_distance(parameters, vertex1, cycle1, vertex2, cycle2):\n    if cycle1 == cycle2:\n        return find_distance_within_cycle(parameters['edges'][cycle1 - 1], vertex1, vertex2)\n    else:\n        if cycle1 > cycle2:\n            (cycle1, cycle2) = (cycle2, cycle1)\n            (vertex1, vertex2) = (vertex2, vertex1)\n        clock_path_start = find_distance_within_cycle(parameters['edges'][cycle1 - 1], parameters['cycle_links'][cycle1 - 1][1], vertex1)\n        clock_path_end = find_distance_within_cycle(parameters['edges'][cycle2 - 1], parameters['cycle_links'][cycle2 - 1][0], vertex2)\n        clock_path_cycle = parameters['links'][cycle2 - 1] - parameters['links'][cycle1 - 1]\n        clock_path_inner = parameter['link_inner'][cycle2 - 1] - parameter['link_inner'][cycle1]\n        clock_path = clock_path_start + clock_path_cycle + clock_path_inner + clock_path_end\n        anti_clock_path_start = find_distance_within_cycle(parameters['edges'][cycle1 - 1], parameters['cycle_links'][cycle1 - 1][0], vertex1)\n        anti_clock_path_end = find_distance_within_cycle(parameters['edges'][cycle2 - 1], parameters['cycle_links'][cycle2 - 1][1], vertex2)\n        anti_clock_path_cycle = parameters['links'][-1] - clock_path_cycle\n        anti_clock_path_inner = parameter['link_inner'][-1] - parameter['link_inner'][cycle2] + parameter['link_inner'][cycle1 - 1]\n        anti_clock_path = anti_clock_path_start + anti_clock_path_cycle + anti_clock_path_inner + anti_clock_path_end\n        if clock_path < anti_clock_path:\n            return clock_path\n        return anti_clock_path\n\ndef find_distance_within_cycle(cycle, vertex1, vertex2):\n    dist1 = abs(cycle[vertex2 - 1] - cycle[vertex1 - 1])\n    dist2 = cycle[-1] - dist1\n    if dist1 < dist2:\n        return dist1\n    return dist2\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, q) = map(int, input().strip().split())\n    cnt = []\n    edges = []\n    links = [0]\n    link_vertex = []\n    link_inner = [0]\n    cycle_links = []\n    for i in range(n):\n        inp = list(map(int, input().strip().split()))\n        cnt.append(inp.pop(0))\n        tmp = [0]\n        for j in range(cnt[i]):\n            tmp.append(tmp[j] + inp[j])\n        edges.append(tmp)\n    for i in range(n):\n        link = list(map(int, input().strip().split()))\n        links.append(links[i] + link.pop(2))\n        link_vertex.append(link)\n    start_node = link_vertex[-1][1]\n    for i in range(n):\n        end_node = link_vertex[i][0]\n        dist = find_distance_within_cycle(edges[i], start_node, end_node)\n        link_inner.append(link_inner[i] + dist)\n        cycle_links.append([start_node, end_node])\n        start_node = link_vertex[i][1]\n    parameter = {'edges': edges, 'cycle_links': cycle_links, 'link_inner': link_inner, 'links': links}\n    for _ in range(q):\n        (v1, c1, v2, c2) = map(int, input().strip().split())\n        print(find_distance(parameter, v1, c1, v2, c2))", "t = int(input())\nwhile t > 0:\n    (n, q) = [int(i) for i in input().split()]\n    g = [[int(i) for i in input().split()] for j in range(n)]\n    fg = [0]\n    wfg = [0]\n    edge = [[int(i) for i in input().split()] for j in range(n)]\n    query = [[int(i) for i in input().split()] for j in range(q)]\n    for i in range(0, n):\n        for j in range(2, g[i][0] + 1):\n            g[i][j] = g[i][j] + g[i][j - 1]\n    for i in range(n):\n        fg.append(edge[i][2])\n        s = edge[i - 1][1]\n        e = edge[i][0]\n        if s < e:\n            if s == 1:\n                if s == e:\n                    wfg.append(0)\n                else:\n                    wfg.append(min(g[i][e - 1], g[i][g[i][0]] - g[i][e - 1]))\n            else:\n                wfg.append(min(g[i][e - 1] - g[i][s - 1], g[i][g[i][0]] - g[i][e - 1] + g[i][s - 1]))\n        else:\n            s = s + e\n            e = s - e\n            s = s - e\n            if s == 1:\n                if s == e:\n                    wfg.append(0)\n                else:\n                    wfg.append(min(g[i][e - 1], g[i][g[i][0]] - g[i][e - 1]))\n            else:\n                wfg.append(min(g[i][e - 1] - g[i][s - 1], g[i][g[i][0]] - g[i][e - 1] + g[i][s - 1]))\n    for i in range(1, n + 1):\n        wfg[i] = wfg[i] + wfg[i - 1]\n        fg[i] = fg[i] + fg[i - 1]\n        g[i - 1][0] = 0\n    for i in range(q):\n        source = query[i][0]\n        end = query[i][2]\n        gs = query[i][1]\n        ge = query[i][3]\n        if gs > ge:\n            gs = gs + ge\n            ge = gs - ge\n            gs = gs - ge\n            source = source + end\n            end = source - end\n            source = source - end\n        gs -= 1\n        ge -= 1\n        if gs < ge:\n            Min1 = fg[ge] - fg[gs] + wfg[ge] - wfg[gs + 1]\n            Min2 = fg[n] + wfg[n] - Min1 - (wfg[gs + 1] - wfg[gs] + wfg[ge + 1] - wfg[ge])\n            s = source\n            e = edge[gs][0]\n            if s < e:\n                Min1 += min(g[gs][e - 1] - g[gs][s - 1], g[gs][len(g[gs]) - 1] - g[gs][e - 1] + g[gs][s - 1])\n            else:\n                s = s + e\n                e = s - e\n                s = s - e\n                Min1 += min(g[gs][e - 1] - g[gs][s - 1], g[gs][len(g[gs]) - 1] - g[gs][e - 1] + g[gs][s - 1])\n            s = edge[ge - 1][1]\n            e = end\n            if s < e:\n                Min1 += min(g[ge][e - 1] - g[ge][s - 1], g[ge][len(g[ge]) - 1] - g[ge][e - 1] + g[ge][s - 1])\n            else:\n                s = s + e\n                e = s - e\n                s = s - e\n                Min1 += min(g[ge][e - 1] - g[ge][s - 1], g[ge][len(g[ge]) - 1] - g[ge][e - 1] + g[ge][s - 1])\n            s = source\n            e = edge[gs - 1][1]\n            if s < e:\n                Min2 += min(g[gs][e - 1] - g[gs][s - 1], g[gs][len(g[gs]) - 1] - g[gs][e - 1] + g[gs][s - 1])\n            else:\n                s = s + e\n                e = s - e\n                s = s - e\n                Min2 += min(g[gs][e - 1] - g[gs][s - 1], g[gs][len(g[gs]) - 1] - g[gs][e - 1] + g[gs][s - 1])\n            s = edge[ge][0]\n            e = end\n            if s < e:\n                Min2 += min(g[ge][e - 1] - g[ge][s - 1], g[ge][len(g[ge]) - 1] - g[ge][e - 1] + g[ge][s - 1])\n            else:\n                s = s + e\n                e = s - e\n                s = s - e\n                Min2 += min(g[ge][e - 1] - g[ge][s - 1], g[ge][len(g[ge]) - 1] - g[ge][e - 1] + g[ge][s - 1])\n            print(min(Min1, Min2))\n    t -= 1", "t = int(input())\nfor i in range(t):\n    (n, q) = map(int, input().split())\n    graph = []\n    sizes = []\n    connections = []\n    junctions = []\n    query = []\n    for j in range(n):\n        temp_array = [int(k) for k in input().split()]\n        sizes.append(temp_array[0])\n        for elem in range(2, sizes[j] + 1):\n            temp_array[elem] += temp_array[elem - 1]\n        graph.append(temp_array[1:])\n    for j in range(n):\n        temp_array = [int(k) for k in input().split()]\n        junctions.append([temp_array[0], temp_array[1]])\n        connections.append(temp_array[2])\n    for j in range(1, n):\n        connections[j] += connections[j - 1]\n    for j in range(q):\n        temp_array = [int(k) for k in input().split()]\n        query.append(temp_array)\n    beg = []\n    end = []\n    new_junction = []\n    new_junction.append([junctions[-1][1], junctions[0][0]])\n    for j in range(n - 1):\n        new_junction.append([junctions[j][1], junctions[j + 1][0]])\n    for j in range(n):\n        (s, e) = new_junction[j]\n        temp_array = []\n        if sizes[j] >= 2:\n            for z in range(1, sizes[j] + 1):\n                fixed = s\n                if fixed == z:\n                    temp_array.append(0)\n                    continue\n                if z == 1:\n                    m1 = graph[j][fixed - 2]\n                    m2 = graph[j][-1] - m1\n                    temp_array.append(min(m1, m2))\n                    continue\n                else:\n                    m1 = abs(graph[j][fixed - 2] - graph[j][z - 2])\n                    m2 = abs(graph[j][-1]) - m1\n                    temp_array.append(min(m1, m2))\n                    continue\n        else:\n            temp_array = [0]\n        beg.append(temp_array)\n        temp_array2 = []\n        if sizes[j] >= 2:\n            for z in range(1, sizes[j] + 1):\n                fixed = e\n                if fixed == z:\n                    temp_array2.append(0)\n                    continue\n                if z == 1:\n                    m1 = graph[j][fixed - 2]\n                    m2 = graph[j][-1] - m1\n                    temp_array2.append(min(m1, m2))\n                    continue\n                else:\n                    m1 = abs(graph[j][fixed - 2] - graph[j][z - 2])\n                    m2 = abs(graph[j][-1]) - m1\n                    temp_array2.append(min(m1, m2))\n                    continue\n        else:\n            temp_array2 = [0]\n        end.append(temp_array2)\n    distances = []\n    for j in range(n):\n        distances.append(beg[j][new_junction[j][1] - 1])\n    new_distances = [distances[0]]\n    for j in range(1, n):\n        new_distances.append(distances[j] + new_distances[j - 1])\n    for Q in range(q):\n        if query[Q][1] > query[Q][3]:\n            (c1, c2) = (query[Q][3], query[Q][1])\n            (v1, v2) = (query[Q][2], query[Q][0])\n        else:\n            (v1, v2) = (query[Q][0], query[Q][2])\n            (c1, c2) = (query[Q][1], query[Q][3])\n        if c1 == 1:\n            x1 = connections[c2 - 2]\n            x2 = connections[-1] - x1\n        else:\n            x1 = abs(connections[c2 - 2] - connections[c1 - 2])\n            x2 = abs(connections[-1] - x1)\n        x1 += end[c1 - 1][v1 - 1]\n        x1 += beg[c2 - 1][v2 - 1]\n        x2 += beg[c1 - 1][v1 - 1]\n        x2 += end[c2 - 1][v2 - 1]\n        if n > 2:\n            if c2 - c1 > 1:\n                foo = new_distances[c2 - 2] - new_distances[c1 - 1]\n                x1 += foo\n                bar = new_distances[-1] - (foo + distances[c1 - 1] + distances[c2 - 1])\n                x2 += bar\n            if c2 - c1 == 1:\n                bar = new_distances[-1] - (distances[c2 - 1] + distances[c1 - 1])\n                x2 += bar\n            print(min(x1, x2))\n        else:\n            print(min(x1, x2))", "t = int(input())\nfor test in range(t):\n    (n, q) = map(int, input().split())\n    cycles = [None]\n    for cycle in range(n):\n        tmp = list(map(int, input().split()))\n        tmpPreSum = [None, 0]\n        for i in range(1, tmp[0] + 1):\n            tmpPreSum.append(tmp[i] + tmpPreSum[-1])\n        cycles.append(tmpPreSum)\n    cons = []\n    for con in range(n):\n        (v1, v2, w) = map(int, input().split())\n        cons.append([v1, v2, w])\n    conPreSum = [0]\n    minDisEdgeToEdge = [None]\n    for i in range(n):\n        tmpDis = abs(cycles[i + 1][cons[i - 1][1]] - cycles[i + 1][cons[i][0]])\n        minDis = min(tmpDis, cycles[i + 1][-1] - tmpDis)\n        minDisEdgeToEdge.append(minDis)\n        conPreSum.append(conPreSum[-1] + minDis)\n        conPreSum.append(conPreSum[-1] + cons[i][2])\n    for query in range(q):\n        (v1, c1, v2, c2) = map(int, input().split())\n        if c1 > c2:\n            (v1, v2) = (v2, v1)\n            (c1, c2) = (c2, c1)\n        tmp = abs(cycles[c1][v1] - cycles[c1][cons[c1 - 1][0]])\n        minTmp = min(tmp, cycles[c1][-1] - tmp)\n        dis1 = minTmp\n        way1 = abs(conPreSum[2 * (c2 - 1)] - conPreSum[c1 * 2 - 1])\n        dis1 += way1\n        tmp = abs(cycles[c2][v2] - cycles[c2][cons[c2 - 2][1]])\n        minTmp = min(tmp, cycles[c2][-1] - tmp)\n        dis1 += minTmp\n        tmp = abs(cycles[c1][v1] - cycles[c1][cons[c1 - 2][1]])\n        minTmp = min(tmp, cycles[c1][-1] - tmp)\n        dis2 = minTmp\n        way2 = abs(conPreSum[-1] - way1 - minDisEdgeToEdge[c1] - minDisEdgeToEdge[c2])\n        dis2 += way2\n        tmp = abs(cycles[c2][v2] - cycles[c2][cons[c2 - 1][0]])\n        minTmp = min(tmp, cycles[c2][-1] - tmp)\n        dis2 += minTmp\n        print(min(dis2, dis1))", "t = int(input())\nwhile t > 0:\n    t = t - 1\n    str_arr = input().split(' ')\n    n = int(str_arr[0])\n    q = int(str_arr[1])\n    vec = [[] for i in range(n)]\n    how_far = [[] for i in range(n)]\n    how_far2 = [[] for i in range(n)]\n    for i in range(n):\n        str_arr = input().split(' ')\n        x = int(str_arr[0])\n        for j in range(x):\n            vec[i].append(int(str_arr[j + 1]))\n            how_far[i].append(int(0))\n            how_far2[i].append(int(0))\n    initiate = [int(0) for i in range(n)]\n    end = [int(0) for i in range(n)]\n    worth = [int(0) for i in range(n)]\n    for i in range(n):\n        str_arr = input().split(' ')\n        u = int(str_arr[0])\n        vec3 = int(str_arr[1])\n        w = int(str_arr[2])\n        u = u - 1\n        vec3 = vec3 - 1\n        end[i] = u\n        initiate[(i + 1) % n] = vec3\n        worth[i] = w\n    for i in range(n):\n        siz = len(vec[i])\n        x = initiate[i]\n        y = end[i]\n        temp2 = [int(0) for i in range(siz)]\n        temp1 = [int(0) for i in range(siz)]\n        for j in range(1, siz):\n            temp2[j] = vec[i][j - 1] + temp2[j - 1]\n        for j in range(siz - 1, 0, -1):\n            temp1[j] = vec[i][j] + temp1[(j + 1) % siz]\n        for j in range(siz):\n            if j <= x:\n                how_far[i][j] = min(temp2[x] - temp2[j], temp2[j] + temp1[x])\n            else:\n                how_far[i][j] = min(temp2[j] - temp2[x], temp2[x] + temp1[j])\n        for j in range(siz):\n            if j <= y:\n                how_far2[i][j] = min(temp2[y] - temp2[j], temp2[j] + temp1[y])\n            else:\n                how_far2[i][j] = min(temp2[j] - temp2[y], temp2[y] + temp1[j])\n    movement = [int(0) for i in range(n)]\n    for i in range(n):\n        x = initiate[i]\n        y = end[i]\n        if i == 0:\n            movement[i] = how_far[i][y]\n        else:\n            movement[i] = how_far[i][y] + movement[i - 1]\n    temporary1 = [int(0) for i in range(n)]\n    temporary2 = [int(0) for i in range(n)]\n    for i in range(1, n):\n        temporary1[i] = temporary1[i - 1] + worth[i - 1]\n    for i in range(n - 1, 0, -1):\n        temporary2[i] = temporary2[(i + 1) % n] + worth[i]\n    for i in range(q):\n        str_arr = input().split(' ')\n        vec1 = int(str_arr[0])\n        c1 = int(str_arr[1])\n        vec2 = int(str_arr[2])\n        c2 = int(str_arr[3])\n        vec1 = vec1 - 1\n        c1 = c1 - 1\n        vec2 = vec2 - 1\n        c2 = c2 - 1\n        if c1 > c2:\n            (c1, c2) = (c2, c1)\n            (vec1, vec2) = (vec2, vec1)\n        ans = how_far2[c1][vec1] + movement[c2 - 1] - movement[c1] + temporary1[c2] - temporary1[c1] + how_far[c2][vec2]\n        if c1 > 0:\n            ans = min(ans, how_far[c1][vec1] + movement[c1 - 1] + movement[n - 1] - movement[c2] + temporary1[c1] + temporary2[c2] + how_far2[c2][vec2])\n        else:\n            ans = min(ans, how_far[c1][vec1] + movement[n - 1] - movement[c2] + temporary1[c1] + temporary2[c2] + how_far2[c2][vec2])\n        print(ans)", "t = int(input())\nwhile t:\n    t -= 1\n    (n, q) = list(map(int, input().split()))\n    innersums = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        innersums.append([0])\n        for j in range(temp[0]):\n            innersums[i].append(innersums[i][-1] + temp[j + 1])\n    b = []\n    semicircumferences = [0]\n    outersum = [0]\n    for i in range(n):\n        b.append(list(map(int, input().split())))\n        b[i][0] -= 1\n        b[i][1] -= 1\n        outersum.append(outersum[-1] + b[i][-1])\n        if i > 0:\n            semicircumferences.append(min(abs(innersums[i][b[i][0]] - innersums[i][b[i - 1][1]]), innersums[i][-1] - abs(innersums[i][b[i][0]] - innersums[i][b[i - 1][1]])))\n    semicircumferences[0] = min(abs(innersums[0][b[0][0]] - innersums[0][b[-1][1]]), innersums[0][-1] - abs(innersums[0][b[0][0]] - innersums[0][b[-1][1]]))\n    outersum2 = [semicircumferences[0]]\n    for i in range(1, n):\n        outersum2.append(outersum2[-1] + semicircumferences[i])\n    while q:\n        q -= 1\n        (v1, c1, v2, c2) = list(map(int, input().split()))\n        (v1, c1, v2, c2) = (v1 - 1, c1 - 1, v2 - 1, c2 - 1)\n        if c2 < c1:\n            (c1, v1, c2, v2) = (c2, v2, c1, v1)\n        print(min(outersum[c2] - outersum[c1] + outersum2[c2 - 1] - outersum2[c1] + min(abs(innersums[c2][v2] - innersums[c2][b[c2 - 1][1]]), innersums[c2][-1] - abs(innersums[c2][v2] - innersums[c2][b[c2 - 1][1]])) + min(abs(innersums[c1][v1] - innersums[c1][b[c1][0]]), innersums[c1][-1] - abs(innersums[c1][v1] - innersums[c1][b[c1][0]])), outersum[-1] - (outersum[c2] - outersum[c1]) + outersum2[-1] - (outersum2[c2 - 1] - outersum2[c1]) - semicircumferences[c1] - semicircumferences[c2] + min(abs(innersums[c2][v2] - innersums[c2][b[c2][0]]), innersums[c2][-1] - abs(innersums[c2][v2] - innersums[c2][b[c2][0]])) + min(abs(innersums[c1][v1] - innersums[c1][b[c1 - 1][1]]), innersums[c1][-1] - abs(innersums[c1][v1] - innersums[c1][b[c1 - 1][1]]))))", "t = int(input())\nwhile t > 0:\n    (n, q) = [int(i) for i in input().split()]\n    g = [[int(i) for i in input().split()] for j in range(n)]\n    fg = [0]\n    wfg = [0]\n    edge = [[int(i) for i in input().split()] for j in range(n)]\n    query = [[int(i) for i in input().split()] for j in range(q)]\n    for i in range(0, n):\n        for j in range(2, g[i][0] + 1):\n            g[i][j] = g[i][j] + g[i][j - 1]\n    for i in range(n):\n        fg.append(edge[i][2])\n        s = edge[i - 1][1]\n        e = edge[i][0]\n        if s < e:\n            if s == 1:\n                if s == e:\n                    wfg.append(0)\n                else:\n                    wfg.append(min(g[i][e - 1], g[i][g[i][0]] - g[i][e - 1]))\n            else:\n                wfg.append(min(g[i][e - 1] - g[i][s - 1], g[i][g[i][0]] - g[i][e - 1] + g[i][s - 1]))\n        else:\n            s = s + e\n            e = s - e\n            s = s - e\n            if s == 1:\n                if s == e:\n                    wfg.append(0)\n                else:\n                    wfg.append(min(g[i][e - 1], g[i][g[i][0]] - g[i][e - 1]))\n            else:\n                wfg.append(min(g[i][e - 1] - g[i][s - 1], g[i][g[i][0]] - g[i][e - 1] + g[i][s - 1]))\n    for i in range(1, n + 1):\n        wfg[i] = wfg[i] + wfg[i - 1]\n        fg[i] = fg[i] + fg[i - 1]\n        g[i - 1][0] = 0\n    for i in range(q):\n        source = query[i][0]\n        end = query[i][2]\n        gs = query[i][1]\n        ge = query[i][3]\n        if gs > ge:\n            gs = gs + ge\n            ge = gs - ge\n            gs = gs - ge\n            source = source + end\n            end = source - end\n            source = source - end\n        gs -= 1\n        ge -= 1\n        if gs < ge:\n            Min1 = fg[ge] - fg[gs] + wfg[ge] - wfg[gs + 1]\n            Min2 = fg[n] + wfg[n] - Min1 - (wfg[gs + 1] - wfg[gs] + wfg[ge + 1] - wfg[ge])\n            s = source\n            e = edge[gs][0]\n            if s < e:\n                Min1 += min(g[gs][e - 1] - g[gs][s - 1], g[gs][len(g[gs]) - 1] - g[gs][e - 1] + g[gs][s - 1])\n            else:\n                s = s + e\n                e = s - e\n                s = s - e\n                Min1 += min(g[gs][e - 1] - g[gs][s - 1], g[gs][len(g[gs]) - 1] - g[gs][e - 1] + g[gs][s - 1])\n            s = edge[ge - 1][1]\n            e = end\n            if s < e:\n                Min1 += min(g[ge][e - 1] - g[ge][s - 1], g[ge][len(g[ge]) - 1] - g[ge][e - 1] + g[ge][s - 1])\n            else:\n                s = s + e\n                e = s - e\n                s = s - e\n                Min1 += min(g[ge][e - 1] - g[ge][s - 1], g[ge][len(g[ge]) - 1] - g[ge][e - 1] + g[ge][s - 1])\n            s = source\n            e = edge[gs - 1][1]\n            if s < e:\n                Min2 += min(g[gs][e - 1] - g[gs][s - 1], g[gs][len(g[gs]) - 1] - g[gs][e - 1] + g[gs][s - 1])\n            else:\n                s = s + e\n                e = s - e\n                s = s - e\n                Min2 += min(g[gs][e - 1] - g[gs][s - 1], g[gs][len(g[gs]) - 1] - g[gs][e - 1] + g[gs][s - 1])\n            s = edge[ge][0]\n            e = end\n            if s < e:\n                Min2 += min(g[ge][e - 1] - g[ge][s - 1], g[ge][len(g[ge]) - 1] - g[ge][e - 1] + g[ge][s - 1])\n            else:\n                s = s + e\n                e = s - e\n                s = s - e\n                Min2 += min(g[ge][e - 1] - g[ge][s - 1], g[ge][len(g[ge]) - 1] - g[ge][e - 1] + g[ge][s - 1])\n            print(min(Min1, Min2))\n    t -= 1", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    data = {}\n    conn = [0]\n    cycle = [0]\n    mini = [0]\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        s = 0\n        data[i + 1] = [0]\n        for j in temp[1:]:\n            s += j\n            data[i + 1].append(s)\n\n    def minner(g, x1, x2):\n        (x1, x2) = (min(x1, x2), max(x1, x2))\n        l1 = data[g][x2 - 1] - data[g][x1 - 1]\n        l2 = data[g][-1] - l1\n        return min(l1, l2)\n    for i in range(1, n + 1):\n        (u, v, w) = map(int, input().split())\n        conn.append((u, v, w))\n    mini.append(minner(1, conn[-1][1], conn[1][0]))\n    for i in range(2, n + 1):\n        mini.append(minner(i, conn[i - 1][1], conn[i][0]))\n    s = 0\n    for i in range(1, n + 1):\n        s += mini[i] + conn[i][2]\n        cycle.append(s)\n    for query in range(q):\n        (v1, c1, v2, c2) = map(int, input().split())\n        if c1 > c2:\n            (c1, c2) = (c2, c1)\n            (v1, v2) = (v2, v1)\n        x = cycle[c2 - 1] - cycle[c1 - 1]\n        y = cycle[-1] - x\n        x -= mini[c1]\n        y -= mini[c2]\n        s = minner(c1, v1, conn[c1][0])\n        t1 = n if c2 == 1 else c2 - 1\n        e = minner(c2, conn[t1][1], v2)\n        x += s + e\n        t1 = n if c1 == 1 else c1 - 1\n        s = minner(c1, conn[t1][1], v1)\n        e = minner(c2, v2, conn[c2][0])\n        y += s + e\n        print(min(x, y))", "from itertools import accumulate\n\ndef read_test():\n    (N, nQ) = list(map(int, input().strip().split()))\n    (A, W, WC, Q) = ([], [], [], [])\n    for _ in range(N):\n        w = list(map(int, input().strip().split()))\n        A.append(w[0])\n        W.append(w[1:])\n    for _ in range(N):\n        (v1, v2, w) = list(map(int, input().strip().split()))\n        (v1, v2) = (v1 - 1, v2 - 1)\n        WC.append((v1, v2, w))\n    for _ in range(nQ):\n        (v1, c1, v2, c2) = list(map(int, input().strip().split()))\n        (v1, c1, v2, c2) = (v1 - 1, c1 - 1, v2 - 1, c2 - 1)\n        Q.append((v1, c1, v2, c2))\n    return (N, A, W, WC, Q)\n\ndef solve(N, A, W, WC, Q):\n    sum_sc = list(map(sum, W))\n    p_sum_sc = [list(accumulate(W[i])) for i in range(N)]\n\n    def small_dist(c, x, y):\n        (x, y) = (min(x, y), max(x, y))\n        c1 = (p_sum_sc[c][y - 1] if y > 0 else 0) - (p_sum_sc[c][x - 1] if x > 0 else 0)\n        c2 = sum_sc[c] - c1\n        return min(c1, c2)\n    w_bc = list(map(lambda x: x[2], WC))\n    sum_bc = sum(w_bc)\n    p_sum_bc = list(accumulate(w_bc))\n    v_in = [WC[i - 1][1] for i in range(N)]\n    v_out = [WC[i][0] for i in range(N)]\n    trav_sc = [small_dist(i, v_in[i], v_out[i]) for i in range(N)]\n    sum_trav_sc = sum(trav_sc)\n    p_sum_trav_sc = list(accumulate(trav_sc))\n\n    def big_dist(x, y):\n        if x == y:\n            return sum_bc\n        elif x < y:\n            return (p_sum_bc[y - 1] if y > 0 else 0) - (p_sum_bc[x - 1] if x > 0 else 0)\n        else:\n            return sum_bc - big_dist(y, x)\n\n    def trav_dist(x, y):\n        if x == y:\n            return 0\n        elif x < y:\n            return p_sum_trav_sc[y - 1] - p_sum_trav_sc[x]\n        else:\n            return sum_trav_sc - trav_dist(y, x) - trav_sc[y] - trav_sc[x]\n    for (v1, c1, v2, c2) in Q:\n        if c1 == c2:\n            cost1 = small_dist(c1, v1, v2)\n            cost2 = sum_bc + sum_trav_sc - trav_sc[c1] + small_dist(c1, v1, v_in[c1]) + small_dist(c1, v2, v_out[c1])\n            cost3 = sum_bc + sum_trav_sc - trav_sc[c1] + small_dist(c1, v1, v_out[c1]) + small_dist(c1, v2, v_in[c1])\n            cost = min(cost1, cost2, cost3)\n            print(cost)\n            continue\n        if c1 > c2:\n            (v1, c1, v2, c2) = (v1, c1, v2, c2)\n        cost1 = small_dist(c1, v1, v_out[c1]) + small_dist(c2, v2, v_in[c2]) + big_dist(c1, c2) + trav_dist(c1, c2)\n        cost2 = small_dist(c1, v1, v_in[c1]) + small_dist(c2, v2, v_out[c2]) + big_dist(c2, c1) + trav_dist(c2, c1)\n        print(min(cost1, cost2))\nT = int(input())\nfor _ in range(T):\n    (N, A, W, WC, Q) = read_test()\n    solve(N, A, W, WC, Q)", "for _ in range(int(input())):\n    (N, Q) = map(int, input().split())\n    inSumTable = [0 for i in range(N)]\n    inJTRight = [[] for i in range(N)]\n    MDCTable = [[] for i in range(N)]\n    SizeTable = [0 for i in range(N)]\n    for i in range(N):\n        List = list(map(int, input().split()))\n        SizeTable[i] = List[0]\n        Sum = 0\n        inJTRight[i].append(Sum)\n        for j in range(1, SizeTable[i] + 1):\n            Sum += List[j]\n            inJTRight[i].append(Sum)\n        inSumTable[i] = Sum\n    outJTRight = []\n    LJPts = [0 for i in range(N)]\n    RJPts = [0 for i in range(N)]\n    for i in range(N):\n        (n1, n2, w) = map(int, input().split())\n        outJTRight.append(w)\n        LJPts[(i + 1) % N] = n2 - 1\n        RJPts[i] = n1 - 1\n    for i in range(N):\n        lp = LJPts[i]\n        rp = RJPts[i]\n        lpath = 0\n        rpath = 0\n        for j in range(SizeTable[i]):\n            p1 = int(abs(inJTRight[i][j] - inJTRight[i][lp]))\n            p2 = inSumTable[i] - p1\n            lpath = min(p1, p2)\n            p1 = int(abs(inJTRight[i][j] - inJTRight[i][rp]))\n            p2 = inSumTable[i] - p1\n            rpath = min(p1, p2)\n            MDCTable[i].append(tuple([lpath, rpath]))\n    fullJTable = [0 for i in range(2 * N + 1)]\n    Sum = 0\n    for i in range(N):\n        r = 2 * i + 1\n        l = r + 1\n        Sum += MDCTable[i][LJPts[i]][1]\n        fullJTable[r] = Sum\n        Sum += outJTRight[i]\n        fullJTable[l] = Sum\n    for i in range(Q):\n        (v1, c1, v2, c2) = map(int, input().split())\n        v1 -= 1\n        v2 -= 1\n        c1 -= 1\n        c2 -= 1\n        if c2 < c1:\n            tmp = v1\n            v1 = v2\n            v2 = tmp\n            tmp = c1\n            c1 = c2\n            c2 = tmp\n        path1 = 0\n        path2 = 0\n        path1 += MDCTable[c1][v1][1] + MDCTable[c2][v2][0]\n        path2 += MDCTable[c1][v1][0] + MDCTable[c2][v2][1]\n        path1 += fullJTable[c2 * 2] - fullJTable[c1 * 2 + 1]\n        path2 += fullJTable[c1 * 2] - fullJTable[0] + (fullJTable[-1] - fullJTable[c2 * 2 + 1])\n        minPath = min(path1, path2)\n        print(minPath)", "for t in range(int(input())):\n    (n, q) = map(int, input().split())\n    arr = [[]] * n\n    arr1 = [[]] * n\n    for i in range(n):\n        a = list(map(int, input().split()))\n        arr[i] = a\n        a = a[1:]\n        arr1[i] = a\n    w = [[]] * n\n    for i in range(n):\n        a = list(map(int, input().split()))\n        w[i] = a\n    query = [[]] * q\n    for i in range(q):\n        a = list(map(int, input().split()))\n        query[i] = a\n    main1 = [[]] * n\n    main2 = [[]] * n\n    for i in range(n):\n        v1 = w[i][0]\n        v2 = w[i - 1][1]\n        main = []\n        sum1 = 0\n        for j in range(arr[i][0]):\n            sum1 += arr1[i][j]\n        sum2 = 0\n        for j in range(arr[i][0]):\n            sum2 += arr1[i][(v1 - 1 + j) % arr[i][0]]\n            if sum2 < sum1 - sum2:\n                main.append(sum2)\n            else:\n                main.append(sum1 - sum2)\n        main1[i] = main\n        m = i\n        main = []\n        sum1 = 0\n        sum2 = 0\n        for j in range(arr[i][0]):\n            sum1 += arr1[i][j]\n        for j in range(arr[m][0]):\n            sum2 += arr1[m][(v2 - 1 + j) % arr[m][0]]\n            if sum2 < sum1 - sum2:\n                main.append(sum2)\n            else:\n                main.append(sum1 - sum2)\n        main2[i] = main\n    cycle1 = [0] * n\n    cycle1[0] = w[0][2]\n    v1v2 = [0] * n\n    y = w[-1][1] - w[0][0]\n    x = -1 - y\n    v1v2[0] = main2[0][x]\n    for i in range(1, n - 1):\n        y = w[i - 1][1] - w[i][0]\n        x = -1 - y\n        weight = w[i][2]\n        cycle1[i] = cycle1[i - 1] + main2[i][x] + weight\n        v1v2[i] = main2[i][x]\n        y = w[-2][1] - w[-1][0]\n        x = -1 - y\n        v1v2[n - 1] = main2[-1][x]\n    sumall = cycle1[-2] + w[-1][2] + v1v2[-1] + v1v2[0]\n    for i in range(q):\n        v1 = query[i][0]\n        c1 = query[i][1]\n        v2 = query[i][2]\n        c2 = query[i][3]\n        if c1 > c2:\n            y = v1 - w[c1 - 2][1]\n            x = y - 1\n            sum1 = main2[c1 - 1][x]\n            y = v2 - w[c2 - 1][0]\n            x = y - 1\n            sum1 += main1[c2 - 1][x]\n        else:\n            y = v1 - w[c1 - 1][0]\n            x = y - 1\n            sum1 = main1[c1 - 1][x]\n            y = v2 - w[c2 - 2][1]\n            x = y - 1\n            sum1 += main2[c2 - 1][x]\n        if c1 == 1 or c2 == 1:\n            sum2 = cycle1[abs(c1 - c2) - 1]\n        elif c1 > c2:\n            sum2 = abs(cycle1[c1 - 2] - cycle1[c2 - 2]) - v1v2[c2 - 1]\n        else:\n            sum2 = abs(cycle1[c1 - 2] - cycle1[c2 - 2]) - v1v2[c1 - 1]\n        sum1 += sum2\n        if c1 > c2:\n            y = v1 - w[c1 - 1][0]\n            x = y - 1\n            sum3 = main1[c1 - 1][x]\n            y = v2 - w[c2 - 2][1]\n            x = y - 1\n            sum3 += main2[c2 - 1][x]\n        else:\n            y = v1 - w[c1 - 2][1]\n            x = y - 1\n            sum3 = main2[c1 - 1][x]\n            y = v2 - w[c2 - 1][0]\n            x = y - 1\n            sum3 += main1[c2 - 1][x]\n        sum2 = sumall - sum2 - v1v2[c1 - 1] - v1v2[c2 - 1]\n        sum3 += sum2\n        if sum1 < sum3:\n            print(sum1)\n        else:\n            print(sum3)", "from collections import defaultdict as dd\nfrom random import randint as rad\n\ndef get(a, i, j):\n    ans = 0\n    if i > j:\n        (i, j) = (j, i)\n    if i != j:\n        return min(abs(a[j - 1] - a[i - 1]), abs(a[-1] - a[j - 1] + a[i - 1]))\n    elif i == j:\n        return 0\nfor _ in range(int(input())):\n    (n, q) = [int(i) for i in input().split()]\n    nodes = []\n    c_sum = dd(list)\n    c_left = dd(int)\n    c_right = dd(int)\n    ck = []\n    for j in range(n):\n        a = [int(i) for i in input().split()]\n        ck.append(a)\n        nodes.append(a[0])\n        su = a[1:]\n        for i in range(1, a[0]):\n            su[i] += su[i - 1]\n        c_sum[j] = [0] + su\n    e = []\n    for i in range(1, n + 1):\n        a = [int(j) for j in input().split()]\n        c_right[i] = a[0]\n        c_left[i + 1 if i + 1 <= n else 1] = a[1]\n        e.append(a[2])\n    c_dis = [0] + e[:]\n    diff = [0]\n    for i in range(1, len(e) + 1):\n        c_dis[i] += c_dis[i - 1] + get(c_sum[i % n], c_left[i + 1 if i + 1 <= n else 1], c_right[i + 1 if i + 1 <= n else 1])\n        diff.append(get(c_sum[i % n], c_left[i + 1 if i + 1 <= n else 1], c_right[i + 1 if i + 1 <= n else 1]))\n    diff[0] = diff[-1]\n    for i in range(q):\n        que = [int(i) for i in input().split()]\n        if que[1] > que[3]:\n            (que[0], que[2]) = (que[2], que[0])\n            (que[1], que[3]) = (que[3], que[1])\n        anr = abs(c_dis[que[1] - 1] - c_dis[que[3] - 1]) - diff[que[3] - 1] + (get(c_sum[que[1] - 1], c_right[que[1]], que[0]) + get(c_sum[que[3] - 1], c_left[que[3]], que[2]))\n        anl = abs(c_dis[-1] - c_dis[que[3] - 1]) + c_dis[que[1] - 1] - diff[que[1] - 1] + (get(c_sum[que[3] - 1], c_right[que[3]], que[2]) + get(c_sum[que[1] - 1], c_left[que[1]], que[0]))\n        print(min(anr, anl))", "def main():\n    for t in range(int(input())):\n        (N, Q) = map(int, input().split())\n        E = [list(map(int, input().split()))[1:] for i in range(N)]\n        (L, R, W) = ([0] * N, [0] * N, [0] * N)\n        for i in range(N):\n            (v1, v2, W[i]) = map(int, input().split())\n            (R[i], L[(i + 1) % N]) = (v1 - 1, v2 - 1)\n\n        def filldist(Ei, src, dist):\n            n = len(Ei)\n            nxt = lambda i: i + 1 if i < n - 1 else 0\n            prv = lambda i: i - 1 if i > 0 else n - 1\n            d = 0\n            cur = nxt(src)\n            while cur != src:\n                d += Ei[prv(cur)]\n                dist[cur] = d\n                cur = nxt(cur)\n            d = 0\n            cur = prv(src)\n            while cur != src:\n                d += Ei[cur]\n                dist[cur] = min(dist[cur], d)\n                cur = prv(cur)\n        Ldist = [[0] * len(Ei) for Ei in E]\n        Rdist = [[0] * len(Ei) for Ei in E]\n        for i in range(N):\n            filldist(E[i], L[i], Ldist[i])\n            filldist(E[i], R[i], Rdist[i])\n        jump = [Rdist[i][L[i]] + W[i] for i in range(N)]\n        pre = [0] * (N + 1)\n        for i in range(N):\n            pre[i] = pre[i - 1] + jump[i]\n        for q in range(Q):\n            (v1, c1, v2, c2) = map(int, input().split())\n            (v1, c1, v2, c2) = (v1 - 1, c1 - 1, v2 - 1, c2 - 1)\n            if c2 < c1:\n                (v1, c1, v2, c2) = (v2, c2, v1, c1)\n            dist1 = Rdist[c1][v1] + W[c1] + pre[c2 - 1] - pre[c1] + Ldist[c2][v2]\n            dist2 = Rdist[c2][v2] + W[c2] + pre[N - 1] - pre[c2] + pre[c1 - 1] + Ldist[c1][v1]\n            ans = min(dist1, dist2)\n            print(ans)\nmain()", "def main():\n    for t in range(int(input())):\n        (N, Q) = map(int, input().split())\n        E = [list(map(int, input().split()))[1:] for i in range(N)]\n        (L, R, W) = ([0] * N, [0] * N, [0] * N)\n        for i in range(N):\n            (v1, v2, W[i]) = map(int, input().split())\n            (R[i], L[(i + 1) % N]) = (v1 - 1, v2 - 1)\n\n        def filldist(Ei, src, dist):\n            n = len(Ei)\n            d = 0\n            cur = (src + 1) % n\n            while cur != src:\n                d += Ei[(cur - 1) % n]\n                dist[cur] = d\n                cur = (cur + 1) % n\n            d = 0\n            cur = (src - 1) % n\n            while cur != src:\n                d += Ei[cur]\n                dist[cur] = min(dist[cur], d)\n                cur = (cur - 1) % n\n        Ldist = [[0] * len(Ei) for Ei in E]\n        Rdist = [[0] * len(Ei) for Ei in E]\n        for i in range(N):\n            filldist(E[i], L[i], Ldist[i])\n            filldist(E[i], R[i], Rdist[i])\n        jump = [Rdist[i][L[i]] + W[i] for i in range(N)]\n        pre = [0] * (N + 1)\n        for i in range(N):\n            pre[i] = pre[i - 1] + jump[i]\n        for q in range(Q):\n            (v1, c1, v2, c2) = map(int, input().split())\n            (v1, c1, v2, c2) = (v1 - 1, c1 - 1, v2 - 1, c2 - 1)\n            if c2 < c1:\n                (v1, c1, v2, c2) = (v2, c2, v1, c1)\n            dist1 = Rdist[c1][v1] + W[c1] + pre[c2 - 1] - pre[c1] + Ldist[c2][v2]\n            dist2 = Rdist[c2][v2] + W[c2] + pre[N - 1] - pre[c2] + pre[c1 - 1] + Ldist[c1][v1]\n            ans = min(dist1, dist2)\n            print(ans)\nmain()", "for t in range(int(input())):\n    (N, Q) = map(int, input().split())\n    E = [list(map(int, input().split()))[1:] for i in range(N)]\n    (L, R, W) = ([0] * N, [0] * N, [0] * N)\n    for i in range(N):\n        (v1, v2, W[i]) = map(int, input().split())\n        (R[i], L[(i + 1) % N]) = (v1 - 1, v2 - 1)\n\n    def filldist(Ei, src, dist):\n        n = len(Ei)\n        d = 0\n        cur = (src + 1) % n\n        while cur != src:\n            d += Ei[(cur - 1) % n]\n            dist[cur] = d\n            cur = (cur + 1) % n\n        d = 0\n        cur = (src - 1) % n\n        while cur != src:\n            d += Ei[cur]\n            dist[cur] = min(dist[cur], d)\n            cur = (cur - 1) % n\n    Ldist = [[0] * len(Ei) for Ei in E]\n    Rdist = [[0] * len(Ei) for Ei in E]\n    for i in range(N):\n        filldist(E[i], L[i], Ldist[i])\n        filldist(E[i], R[i], Rdist[i])\n    jump = [Rdist[i][L[i]] + W[i] for i in range(N)]\n    pre = [0] * (N + 1)\n    for i in range(N):\n        pre[i] = pre[i - 1] + jump[i]\n    for q in range(Q):\n        (v1, c1, v2, c2) = map(int, input().split())\n        (v1, c1, v2, c2) = (v1 - 1, c1 - 1, v2 - 1, c2 - 1)\n        if c2 < c1:\n            (v1, c1, v2, c2) = (v2, c2, v1, c1)\n        dist1 = Rdist[c1][v1] + W[c1] + pre[c2 - 1] - pre[c1] + Ldist[c2][v2]\n        dist2 = Rdist[c2][v2] + W[c2] + pre[N - 1] - pre[c2] + pre[c1 - 1] + Ldist[c1][v1]\n        ans = min(dist1, dist2)\n        print(ans)", "import numpy as np\n\ndef solve(a, z, qq):\n    for (i, aa) in enumerate(a):\n        aa = np.array([0] + aa, dtype=np.int64)\n        a[i] = np.cumsum(aa)\n\n    def inDist(c, v, w):\n        if v > w:\n            (v, w) = (w, v)\n        aa = a[c]\n        d = aa[w] - aa[v]\n        rr = min(d, aa[-1] - d)\n        return rr\n    zz = [0]\n    for (i, (v, w, ll)) in enumerate(z):\n        zz += [inDist(i, v, z[i - 1][1])]\n        zz += [ll]\n    zz = np.array(zz, dtype=np.int64)\n    zz = np.cumsum(zz)\n\n    def cDist(c, d):\n        ret = zz[2 * d] - zz[2 * c + 1]\n        if d < c:\n            ret += zz[-1]\n        return ret\n\n    def tDist(v0, c0, v1, c1):\n        if c0 == c1:\n            return inDist(c0, v0, v1)\n        a = cDist(c0, c1) + inDist(c0, v0, z[c0][0]) + inDist(c1, v1, z[c1 - 1][1])\n        b = cDist(c1, c0) + inDist(c1, v1, z[c1][0]) + inDist(c0, v0, z[c0 - 1][1])\n        return min(a, b)\n    ret = []\n    for (v0, c0, v1, c1) in qq:\n        ret += [tDist(v0 - 1, c0 - 1, v1 - 1, c1 - 1)]\n    return ret\nimport sys\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    (n, q) = map(int, f.readline().split())\n    a = []\n    for i in range(n):\n        a += [list(map(int, f.readline().split()))[1:]]\n    z = []\n    for i in range(n):\n        zz = list(map(int, f.readline().split()))\n        zz[0] -= 1\n        zz[1] -= 1\n        z += [zz]\n    qq = []\n    for i in range(q):\n        qq += [list(map(int, f.readline().split()))]\n    sol = solve(a, z, qq)\n    for s in sol:\n        print(s)"]