["from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p):\n    (val, nm) = (0, 1)\n    for i in child[p]:\n        (x, mex) = dfs(i)\n        nm += mex\n        val = max(val, x)\n    return [val + nm, nm]\nfor T in range(int(input())):\n    n = int(input())\n    p = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        child[p[i]].append(i + 2)\n    print(dfs(1)[0])", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p):\n    (val, nm) = (0, 1)\n    for i in child[p]:\n        (x, mex) = dfs(i)\n        nm += mex\n        val = max(val, x)\n    return [val + nm, nm]\nfor T in range(int(input())):\n    n = int(input())\n    p = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        child[p[i]].append(i + 2)\n    print(dfs(1)[0])", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p):\n    (val, nm) = (0, 1)\n    for i in child[p]:\n        (x, mex) = dfs(i)\n        nm += mex\n        val = max(val, x)\n    return [val + nm, nm]\nfor T in range(int(input())):\n    n = int(input())\n    p = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        child[p[i]].append(i + 2)\n    print(dfs(1)[0])", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p):\n    (val, nm) = (0, 1)\n    for i in child[p]:\n        (x, mex) = dfs(i)\n        nm += mex\n        val = max(val, x)\n    return [val + nm, nm]\nfor T in range(int(input())):\n    n = int(input())\n    p = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        child[p[i]].append(i + 2)\n    print(dfs(1)[0])", "from math import log2\nimport sys\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\ninf = float('inf')\n\ndef find_height(node):\n    nodes[node] = 1\n    for i in graph[node]:\n        nodes[node] += find_height(i)\n    return nodes[node]\n\ndef find_sum(node):\n    suma = nodes[node]\n    maxa = 0\n    for i in graph[node]:\n        maxa = max(find_sum(i), maxa)\n    return maxa + suma\nfor i in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    graph = defaultdict(set)\n    for i in range(len(l)):\n        graph[l[i]].add(i + 2)\n    nodes = defaultdict(int)\n    find_height(1)\n    ans = find_sum(1)\n    print(ans)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef max_mex(dept):\n    for i in at_dept[dept]:\n        (m, l) = (0, 0)\n        for j in child[i]:\n            m = max(m, mex[j][1])\n            l += mex[j][0]\n        mex[i] = [l + 1, m + l + 1]\n    if dept > 1:\n        max_mex(dept - 1)\n\ndef all_dept(arr, dept=2):\n    for i in arr:\n        at_dept[dept].append(i)\n        all_dept(child[i], dept + 1)\nfor T in range(int(input())):\n    n = int(input())\n    parent = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        child[parent[i]].append(i + 2)\n    at_dept = [[] for i in range(n + 1)]\n    at_dept[1].append(1)\n    all_dept(child[1])\n    for arr in at_dept[::-1]:\n        if arr == []:\n            at_dept.pop()\n        else:\n            break\n    mex = [0] * (n + 1)\n    for i in at_dept[-1]:\n        mex[i] = [1, 1]\n    max_mex(len(at_dept) - 2)\n    print(mex[1][1])", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef max_mex(dept):\n    for i in at_dept[dept]:\n        (m, l) = (0, 0)\n        for j in child[i]:\n            m = max(m, mex[j][1])\n            l += mex[j][0]\n        mex[i] = [l + 1, m + l + 1]\n    if dept > 1:\n        max_mex(dept - 1)\n\ndef all_dept(arr, dept=2):\n    for i in arr:\n        at_dept[dept].append(i)\n        all_dept(child[i], dept + 1)\nfor T in range(int(input())):\n    n = int(input())\n    parent = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        child[parent[i]].append(i + 2)\n    at_dept = [[] for i in range(n + 1)]\n    at_dept[1].append(1)\n    all_dept(child[1])\n    for arr in at_dept[::-1]:\n        if arr == []:\n            at_dept.pop()\n        else:\n            break\n    mex = [0] * (n + 1)\n    for i in at_dept[-1]:\n        mex[i] = [1, 1]\n    max_mex(len(at_dept) - 2)\n    print(mex[1][1])", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef max_mex(dept):\n    for i in at_dept[dept]:\n        (m, l) = (0, 0)\n        for j in child[i]:\n            m = max(m, mex[j][1])\n            l += mex[j][0]\n        mex[i] = [l + 1, m + l + 1]\n    if dept > 1:\n        max_mex(dept - 1)\n\ndef all_dept(arr, dept=2):\n    for i in arr:\n        at_dept[dept].append(i)\n        all_dept(child[i], dept + 1)\nfor T in range(int(input())):\n    n = int(input())\n    parent = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        child[parent[i]].append(i + 2)\n    at_dept = [[] for i in range(n + 1)]\n    at_dept[1].append(1)\n    all_dept(child[1])\n    for arr in at_dept[::-1]:\n        if arr == []:\n            at_dept.pop()\n        else:\n            break\n    mex = {}\n    for i in at_dept[-1]:\n        mex[i] = [1, 1]\n    max_mex(len(at_dept) - 2)\n    print(mex[1][1])", "from sys import setrecursionlimit\nsetrecursionlimit(999999)\n\ndef createTree(n, par):\n    graph = [[] for i in range(n + 1)]\n    for i in range(len(par)):\n        graph[par[i]].append(i + 2)\n    return graph\n\ndef recurse(graph, root):\n    if len(graph[root]) == 0:\n        return [1, 1]\n    noNodes = 1\n    root_sum = 0\n    for i in range(len(graph[root])):\n        temp = recurse(graph, graph[root][i])\n        noNodes += temp[0]\n        root_sum = max(root_sum, temp[1])\n    return [noNodes, root_sum + noNodes]\nfor i in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    graph = createTree(n, arr)\n    print(recurse(graph, 1)[1])", "import sys\n\ndef eprint(*args):\n    print(*args, file=sys.stderr)\nzz = 1\nsys.setrecursionlimit(10 ** 6)\nif zz:\n    input = sys.stdin.readline\nelse:\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('all.txt', 'w')\ndi = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n\ndef string(s):\n    return ''.join(s)\n\ndef fori(n):\n    return [fi() for i in range(n)]\n\ndef inc(d, c, x=1):\n    d[c] = d[c] + x if c in d else x\n\ndef bo(i):\n    return ord(i) - ord('A')\n\ndef li():\n    return [int(xx) for xx in input().split()]\n\ndef fli():\n    return [float(x) for x in input().split()]\n\ndef comp(a, b):\n    if a > b:\n        return 2\n    return 2 if a == b else 0\n\ndef gi():\n    return [xx for xx in input().split()]\n\ndef cil(n, m):\n    return n // m + int(n % m > 0)\n\ndef fi():\n    return int(input())\n\ndef pro(a):\n    return reduce(lambda a, b: a * b, a)\n\ndef swap(a, i, j):\n    (a[i], a[j]) = (a[j], a[i])\n\ndef si():\n    return list(input().rstrip())\n\ndef mi():\n    return map(int, input().split())\n\ndef gh():\n    sys.stdout.flush()\n\ndef isvalid(i, j, n, m):\n    return 0 <= i < n and 0 <= j < m\n\ndef bo(i):\n    return ord(i) - ord('a')\n\ndef graph(n, m):\n    for i in range(m):\n        (x, y) = mi()\n        a[x].append(y)\n        a[y].append(x)\nt = fi()\nwhile t > 0:\n    t -= 1\n    n = fi()\n    p = li()\n    a = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a[i + 2].append(p[i])\n        a[p[i]].append(i + 2)\n    subtree = [1] * (n + 1)\n\n    def dfs(i, par=-1):\n        for j in a[i]:\n            if j != par:\n                dfs(j, i)\n                subtree[i] += subtree[j]\n    dfs(1, -1)\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if i == 1:\n            ans[i] = n\n        else:\n            ans[i] += subtree[i] + ans[p[i - 2]]\n    print(max(ans))", "from sys import setrecursionlimit\nsetrecursionlimit(999999)\nfrom collections import defaultdict as dd\nfrom collections import deque as dq\n\ndef dfs_rec(g, root):\n    if len(g[1]) == 0:\n        return [1, 1]\n    (sz, mx) = (1, -1)\n    for i in range(len(g[root])):\n        temp = dfs_rec(g, g[root][i])\n        sz += temp[0]\n        mx = max(mx, temp[1])\n    return [sz, mx + sz]\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    g = dd(list)\n    for i in range(n - 1):\n        g[l[i]].append(i + 2)\n    r = dfs_rec(g, 1)[1]\n    print(r + 1)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef recurse(root):\n    if adj[root] == []:\n        return (1, 1)\n    sub = 1\n    max1 = 0\n    for v in adj[root]:\n        (x, y) = recurse(v)\n        sub += x\n        max1 = max(max1, y)\n    return (sub, sub + max1)\nfor _ in range(int(input())):\n    n = int(input())\n    p = list(map(int, input().split()))\n    adj = {}\n    for i in range(1, n + 1):\n        adj[i] = []\n    for i in range(n - 1):\n        (parent, child) = (p[i], i + 2)\n        adj[parent].append(child)\n    (x, y) = recurse(1)\n    print(y)", "for _ in range(int(input())):\n    n = int(input())\n    p = list(map(int, input().strip().split()))\n    ans = [0] * (n + 1)\n    nos = [1] * (n + 1)\n    for i in range(n - 2, -1, -1):\n        nos[p[i]] += nos[i + 2]\n        ans[i + 2] += nos[i + 2]\n        ans[p[i]] = max(ans[p[i]], ans[i + 2])\n    print(ans[1] + nos[1])", "import sys\nsys.setrecursionlimit(int(1000000.0))\n\ndef solve(graph, cur):\n    if not graph[cur]:\n        return (1, 1)\n    tot = 0\n    ans = 0\n    for child in graph[cur]:\n        (prevans, tnodes) = solve(graph, child)\n        tot += tnodes\n        ans = max(ans, prevans)\n    return (tot + 1 + ans, tot + 1)\nfor t in range(int(input())):\n    n = int(input())\n    lis = list(map(int, input().split()))\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        graph[lis[i]].append(i + 2)\n    print(solve(graph, 1)[0])", "import sys\nsys.setrecursionlimit(1000000)\n\ndef dfs(root, graph):\n    retrieval = []\n    try:\n        for i in graph[root]:\n            retrieval.append(dfs(i, graph))\n        if retrieval != []:\n            mx = retrieval[0][0] + retrieval[0][1]\n            totalNodesInSubtree = 0\n            for i in retrieval:\n                totalNodesInSubtree += i[1]\n                if i[0] + i[1] > mx:\n                    mx = i[0] + i[1]\n            return [mx, totalNodesInSubtree + 1]\n        else:\n            return [0, 1]\n    except:\n        return [0, 1]\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    graph = {}\n    for i in range(n - 1):\n        if graph.get(l[i]):\n            graph[l[i]].add(i + 2)\n        else:\n            graph[l[i]] = set([i + 2])\n    ans = dfs(1, graph)\n    print(ans[0] + ans[1])", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\n\nclass Graph:\n\n    def __init__(self, V):\n        self.graph = [[] for i in range(V + 1)]\n        self.Visited = set()\n        self.height = 1\n\n    def addEdges(self):\n        arr = [int(x) for x in input().split()]\n        for i in range(len(arr)):\n            self.graph[i + 1].append(arr[i] - 1)\n            self.graph[arr[i] - 1].append(i + 1)\n\n    def DFS(self, Node):\n        self.Visited.add(Node)\n        if len(self.graph[Node]) == 0:\n            return (1, 1)\n        node = 1\n        mex = 1\n        for each in self.graph[Node]:\n            if each not in self.Visited:\n                (n1, m1) = self.DFS(each)\n                node += n1\n                mex = max(m1, mex)\n        return (node, mex + node)\nfor _ in range(int(input())):\n    V = int(input())\n    gra = Graph(V)\n    gra.addEdges()\n    (x, y) = gra.DFS(0)\n    print(y - 1)", "import sys\n(input, print) = (sys.stdin.readline, sys.stdout.write)\nsys.setrecursionlimit(10 ** 6)\n\ndef ans(dic, n):\n    if dic.get(n) != None:\n        b = []\n        for a in dic[n]:\n            b.append(ans(dic, a))\n        mx = 0\n        node = 0\n        for a in b:\n            if a[0] > mx:\n                mx = a[0]\n            node += a[1]\n        node += len(dic[n])\n        return (mx + node + 1, node)\n    else:\n        return (1, 0)\nfor i in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    dic = {}\n    for j in range(1, n):\n        temp = a[j - 1]\n        if dic.get(temp) == None:\n            dic[temp] = [j + 1]\n        else:\n            dic[temp].append(j + 1)\n    anss = ans(dic, 1)\n    print(str(anss[0]) + '\\n')", "from sys import setrecursionlimit\nsetrecursionlimit(999999)\n\ndef children(g, n, child):\n    if n in g.keys():\n        x = 0\n        for adg in g[n]:\n            x += children(g, adg, child)\n        child[n] = len(g[n]) + x\n        return len(g[n]) + x\n    else:\n        child[n] = 0\n        return 0\n\ndef check(g, n, child):\n    if n in g.keys():\n        x = 0\n        for adg in g[n]:\n            l = check(g, adg, child)\n            if l > x:\n                x = l\n        if x > 0:\n            return child[n] + 1 + x\n    else:\n        return 1\nfor _ in range(int(input())):\n    n = int(input())\n    a = [0] + list(map(int, input().split()))\n    tree = {}\n    for i in range(1, n):\n        tree[a[i]] = tree.setdefault(a[i], [])\n        tree[a[i]].append(i + 1)\n    child = [0] * (n + 1)\n    children(tree, 1, child)\n    print(check(tree, 1, child))", "import sys\nsys.setrecursionlimit(10 ** 7)\nimport math\nfrom collections import Counter\nadj = [[] for i in range(100005)]\n\ndef dfs(node):\n    mex = 0\n    size = 1\n    for i in adj[node]:\n        temp = dfs(i)\n        mex = max(mex, temp[0])\n        size += temp[1]\n    return [mex + size, size]\ntry:\n    for _ in range(int(input())):\n        n = int(input())\n        for i in range(1, n + 1):\n            adj[i].clear()\n        arr = [int(i) for i in input().split()]\n        for i in range(1, n):\n            adj[arr[i - 1]].append(i + 1)\n        ans = dfs(1)\n        print(ans[0])\nexcept EOFError as e:\n    print(e)", "for _ in range(int(input())):\n    n = int(input())\n    con = list(map(int, input().split()))\n    le = [1 for i in range(n)]\n    for i in range(n - 2, -1, -1):\n        le[con[i] - 1] += le[i + 1]\n    ans = [0 for i in range(n)]\n    ma = 0\n    tra = [[] for i in range(n + 1)]\n    no = 2\n    for i in con:\n        tra[i].append(no)\n        no += 1\n    bfs = [1]\n    l = 0\n    while l < len(bfs):\n        go = bfs[l]\n        for i in tra[go]:\n            bfs.append(i)\n        l += 1\n    ans[0] = le[0]\n    for i in range(1, n, 1):\n        ci = bfs[i]\n        va = le[ci - 1] + ans[con[ci - 2] - 1]\n        if va > ma:\n            ma = va\n        ans[ci - 1] = va\n    print(ma)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef recurse(root):\n    if root not in dic:\n        return (1, 1)\n    sum1 = 1\n    max1 = 0\n    for i in dic[root]:\n        (x, y) = recurse(i)\n        sum1 += x\n        max1 = max(max1, y)\n    return (sum1, sum1 + max1)\nfor _ in range(int(input())):\n    n = int(input())\n    dic = {}\n    lis = list(map(int, input().split()))\n    for i in range(len(lis)):\n        if lis[i] not in dic:\n            dic[lis[i]] = [i + 2]\n        else:\n            dic[lis[i]].append(i + 2)\n    (x, y) = recurse(1)\n    print(y)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 6)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        print(1)\n    else:\n        l = list(map(int, input().split()))\n        mex = 0\n        d = defaultdict(lambda : [])\n        for (i, num) in enumerate(l):\n            d[num - 1].append(i + 1)\n\n        def dfs(i):\n            mex = 0\n            size = 1\n            for j in d[i]:\n                if i == j:\n                    continue\n                x = dfs(j)\n                mex = max(mex, x[0])\n                size += x[1]\n            return [mex + size, size]\n        print(dfs(0)[0])", "from sys import stdin as stin, stdout as stout, setrecursionlimit as srl\nfrom collections import defaultdict as dd, Counter, deque as dq\nsrl(10 ** 6)\n\ndef get_ints():\n    return map(int, stin.readline().split())\n\ndef get_list():\n    return list(map(int, stin.readline().split()))\n\ndef get_int():\n    return int(stin.readline())\n\ndef get_str():\n    return stin.readline()\n\ndef dfs(graph, u, parent):\n    (size, max_mex) = (0, 0)\n    for i in graph[u]:\n        if i == parent:\n            continue\n        (tmax, tsize) = dfs(graph, i, u)\n        max_mex = max(max_mex, tmax)\n        size += tsize\n    return (max_mex + size + 1, size + 1)\nfor _ in range(get_int()):\n    n = get_int()\n    nums = get_list()\n    graph = dd(list)\n    for i in range(2, n + 1):\n        graph[nums[i - 2]].append(i)\n    print(dfs(graph, 1, 1)[0])", "import sys, math\nfrom collections import defaultdict as dd\nsys.setrecursionlimit(10 ** 6)\ninput = lambda : sys.stdin.readline().strip()\ninp = lambda : list(map(int, input().split()))\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\nfor _ in range(int(input())):\n    (n,) = inp()\n    a = list(map(int, input().split()))\n    g = dd(lambda : [])\n    for i in range(2, n + 1):\n        g[a[i - 2]].append(i)\n    nodes = [0 for i in range(n + 1)]\n\n    def dfs(node=1):\n        res = 1\n        for to in g[node]:\n            res += dfs(to)\n        nodes[node] = res\n        return res\n    dfs()\n\n    def dfs1(node=1):\n        res = [0]\n        for to in g[node]:\n            res.append(dfs1(to))\n        return max(res) + nodes[node]\n    print(dfs1())", "import sys\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef dfs(n, p, a):\n    count = 0\n    maxval = 0\n    for i in a[n]:\n        if i == p:\n            continue\n        (tmaxval, tcount) = dfs(i, n, a)\n        maxval = max(maxval, tmaxval)\n        count += tcount\n    return (maxval + count + 1, count + 1)\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    for i in range(n + 1):\n        a.append(list())\n    e = list(map(int, input().split()))\n    for i in range(1, n):\n        a[e[i - 1]].append(i + 1)\n    print(dfs(1, 1, a)[0])", "import sys\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef dfs(n, p, a):\n    count = 0\n    maxval = 0\n    for i in a[n]:\n        if i == p:\n            continue\n        (tmaxval, tcount) = dfs(i, n, a)\n        maxval = max(maxval, tmaxval)\n        count += tcount\n    return (maxval + count + 1, count + 1)\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    for i in range(n + 1):\n        a.append(list())\n    e = list(map(int, input().split()))\n    for i in range(1, n):\n        a[e[i - 1]].append(i + 1)\n    print(dfs(1, 1, a)[0])", "from sys import setrecursionlimit\nsetrecursionlimit(999999)\n\ndef createTree(n, par):\n    graph = [[] for i in range(n + 1)]\n    for i in range(len(par)):\n        graph[par[i]].append(i + 2)\n    return graph\n\ndef recurse(graph, root):\n    if len(graph[root]) == 0:\n        return [1, 1]\n    noNodes = 1\n    root_sum = -1\n    for i in range(len(graph[root])):\n        temp = recurse(graph, graph[root][i])\n        noNodes += temp[0]\n        root_sum = max(root_sum, temp[1])\n    return [noNodes, root_sum + noNodes]\nfor i in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    graph = createTree(n, arr)\n    print(recurse(graph, 1)[1])", "from sys import setrecursionlimit\nsetrecursionlimit(999999)\n\ndef createTree(n, par):\n    graph = [[] for i in range(n + 1)]\n    for i in range(len(par)):\n        graph[par[i]].append(i + 2)\n    return graph\n\ndef recurse(graph, root):\n    if len(graph[root]) == 0:\n        return [1, 1]\n    noNodes = 1\n    root_sum = -1\n    for i in range(len(graph[root])):\n        temp = recurse(graph, graph[root][i])\n        noNodes += temp[0]\n        root_sum = max(root_sum, temp[1])\n    return [noNodes, root_sum + noNodes]\nfor i in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    graph = createTree(n, arr)\n    print(recurse(graph, 1)[1])", "from sys import setrecursionlimit\nsetrecursionlimit(999999)\n\ndef createTree(n, par):\n    graph = [[] for i in range(n + 1)]\n    for i in range(len(par)):\n        graph[par[i]].append(i + 2)\n    return graph\n\ndef recurse(graph, root):\n    if len(graph[root]) == 0:\n        return [1, 1]\n    noNodes = 1\n    root_sum = -1\n    for i in range(len(graph[root])):\n        temp = recurse(graph, graph[root][i])\n        noNodes += temp[0]\n        root_sum = max(root_sum, temp[1])\n    return [noNodes, root_sum + noNodes]\nfor i in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    graph = createTree(n, arr)\n    print(recurse(graph, 1)[1])", "from sys import setrecursionlimit\nsetrecursionlimit(999999)\n\ndef createTree(n, par):\n    graph = [[] for i in range(n + 1)]\n    for i in range(len(par)):\n        graph[par[i]].append(i + 2)\n    return graph\n\ndef recurse(graph, root):\n    if len(graph[root]) == 0:\n        return [1, 1]\n    noNodes = 1\n    root_sum = -1\n    for i in range(len(graph[root])):\n        temp = recurse(graph, graph[root][i])\n        noNodes += temp[0]\n        root_sum = max(root_sum, temp[1])\n    return [noNodes, root_sum + noNodes]\nfor i in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    graph = createTree(n, arr)\n    print(recurse(graph, 1)[1])", "from sys import stdin\nimport sys\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict as dd\n\ndef dfs(tree, cur):\n    if cur not in tree:\n        lensub[cur] = 0\n        return 0\n    else:\n        for i in tree[cur]:\n            lensub[cur] += dfs(tree, i) + 1\n        return lensub[cur]\n\ndef fun(tree, cur):\n    if lensub[cur] == 0:\n        return 1\n    mx = None\n    for i in tree[cur]:\n        var = fun(tree, i) + lensub[cur] + 1\n        if mx == None or var > mx:\n            mx = var\n    return mx\nI = stdin.readline\nfor _ in range(int(I())):\n    n = int(I())\n    ar = list(map(int, I().split()))\n    tree = dd(list)\n    for i in range(n - 1):\n        tree[ar[i]].append(i + 2)\n    global lensub\n    lensub = dd(int)\n    dfs(tree, 1)\n    ans = fun(tree, 1)\n    print(ans)", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(node, visited):\n    visited[node] = 1\n    p = 1\n    q = 0\n    for v in g[node]:\n        if visited[v] == 0:\n            m = dfs(v, visited)\n            p = p + m\n    no[node] = p\n    return p\n\ndef dfs2(node, visited, no):\n    visited[node] = 1\n    p = 0\n    for v in g[node]:\n        if visited[v] == 0:\n            p = max(p, dfs2(v, visited, no))\n    no[node] += p\n    return no[node]\nt = int(input())\nan = 0\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = 0\n    g = defaultdict(list)\n    no = [0] * (n + 1)\n    for j in range(n - 1):\n        g[a[j]].append(j + 2)\n        g[j + 2].append(a[j])\n    visited = [0] * (n + 1)\n    dfs(1, visited)\n    visited = [0] * (n + 1)\n    m = dfs2(1, visited, no)\n    print(m)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    d = {i + 1: [] for i in range(n)}\n    for i in range(n - 1):\n        d[l[i]] += [i + 2]\n    ch = {i + 1: 0 for i in range(n)}\n    levels = []\n    queue = [1]\n    while len(queue) != 0:\n        levels.append(queue.copy())\n        nq = len(queue.copy())\n        for i in range(nq):\n            for j in d[queue[i]]:\n                queue.append(j)\n        queue = queue[nq:]\n    for i in range(len(levels) - 1, 0, -1):\n        for node in levels[i]:\n            ch[l[node - 2]] += ch[node] + 1\n    ans = 0\n    lst = list(ch.values())\n    for i in range(n):\n        lst[i] += 1\n    for lev in levels[1:]:\n        for i in lev:\n            parent = l[i - 2]\n            lst[i - 1] += lst[parent - 1]\n    ans = max(lst)\n    print(ans)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef traverse(node):\n    visited[node] = 1\n    for ad in graph[node]:\n        if visited[ad] == 0:\n            traverse(ad)\n    m = 0\n    for ad in graph[node]:\n        node_count[node] += node_count[ad]\n        m = max(m, dp[ad])\n    dp[node] += m + node_count[node]\nfor _ in range(int(input())):\n    n = int(input())\n    p = [0] + [int(x) for x in input().split()]\n    graph = defaultdict(list)\n    for i in range(1, n):\n        graph[p[i]].append(i + 1)\n    dp = [0] * (n + 1)\n    node_count = [1] * (n + 1)\n    visited = defaultdict(int)\n    traverse(1)\n    print(dp[1])", "from sys import setrecursionlimit\nsetrecursionlimit(110000)\n\nclass Node:\n\n    def __init__(self):\n        self.children = []\n        self.subtree_children_count = 0\n\ndef post_order(node):\n    count = 1\n    for child in node.children:\n        child_sub_trees = post_order(child)\n        count += child_sub_trees\n    node.subtree_children_count = count\n    return node.subtree_children_count\n\ndef subtree_count(root):\n    return post_order(root)\n\ndef assign_parents(parents, nodes):\n    for (i, parent) in enumerate(parents, 1):\n        nodes[parent].children.append(nodes[i + 1])\n\ndef get_submex(root):\n    ans = -1\n\n    def maximizer(node, prev=0):\n        nonlocal ans\n        value = node.subtree_children_count + prev\n        ans = max(ans, value)\n        for child in node.children:\n            maximizer(child, value)\n    maximizer(root)\n    return ans\n\ndef solve():\n    for _ in range(int(input())):\n        n = int(input())\n        parents = list(map(int, input().strip().split()))\n        nodes = [Node() for _ in range(n + 1)]\n        assign_parents(parents, nodes)\n        root = nodes[1]\n        subtree_count(root)\n        result = get_submex(root)\n        print(result)\nsolve()", "from sys import setrecursionlimit\nsetrecursionlimit(110000)\n\nclass Node:\n\n    def __init__(self):\n        self.children = []\n        self.subtree_children_count = 0\n\ndef post_order(node):\n    count = 1\n    for child in node.children:\n        child_sub_trees = post_order(child)\n        count += child_sub_trees\n    node.subtree_children_count = count\n    return node.subtree_children_count\n\ndef subtree_count(root):\n    try:\n        return post_order(root)\n    except ArithmeticError:\n        return -1\n\ndef assign_parents(parents, nodes):\n    for (i, parent) in enumerate(parents, 1):\n        nodes[parent].children.append(nodes[i + 1])\n\ndef get_submex(root):\n    ans = -1\n\n    def maximizer(node, prev=0):\n        nonlocal ans\n        value = node.subtree_children_count + prev\n        ans = max(ans, value)\n        for child in node.children:\n            maximizer(child, value)\n    maximizer(root)\n    return ans\n\ndef solve():\n    for _ in range(int(input())):\n        n = int(input())\n        parents = list(map(int, input().strip().split()))\n        nodes = [Node() for _ in range(n + 1)]\n        assign_parents(parents, nodes)\n        root = nodes[1]\n        if subtree_count(root) == -1:\n            print(42)\n            continue\n        result = get_submex(root)\n        print(result)\nsolve()", "def input_int_list():\n    return [int(x) for x in input().split()]\n\ndef dfsnr(node, tree):\n    stack = [node]\n    visited = set()\n    result = dict()\n    while stack.__len__() != 0:\n        item = stack[-1]\n        if item not in visited:\n            visited.add(item)\n            if item in tree.keys():\n                stack += tree[item]\n        else:\n            m = -1\n            count = 1\n            if item in tree.keys():\n                for i in tree[item]:\n                    if m < result[i][0]:\n                        m = result[i][0]\n                    count += result[i][1]\n            else:\n                m = 0\n            result[item] = (m + count, count)\n            stack.pop()\n    print(result[1][0])\n\ndef test_case():\n    N = int(input())\n    L = input_int_list()\n    tree = dict()\n    for i in range(len(L)):\n        if L[i] in tree.keys():\n            tree[L[i]].append(i + 2)\n        else:\n            tree[L[i]] = [i + 2]\n    dfsnr(1, tree)\nT = int(input())\nfor t in range(T):\n    test_case()", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n    n = int(input())\n    from collections import defaultdict\n    g = defaultdict(list)\n    ls = list(map(int, input().split()))\n    for i in range(2, n + 1):\n        g[ls[i - 2]].append(i)\n    sz = [1] * (n + 1)\n    dp = [0] * (n + 1)\n    ans = [0] * (n + 1)\n\n    def dfs(s):\n        for i in g[s]:\n            dfs(i)\n            sz[s] += sz[i]\n            dp[s] = max(dp[s], dp[i] + 1)\n        for i in g[s]:\n            ans[s] = max(ans[i], ans[s])\n        ans[s] += sz[s]\n    dfs(1)\n    for i in range(1, n + 1):\n        g[i].sort(key=lambda k: [-dp[k], -sz[k]])\n    mp = {}\n    s = 1\n    res = 1\n    while g[s]:\n        res += sz[s]\n        s = g[s][0]\n    print(ans[1])", "import sys\nsys.setrecursionlimit(1000000)\n\ndef dfs(root, parent, op):\n    val = 0\n    if root in dic:\n        for child in dic[root]:\n            if child != parent:\n                val += dfs(child, root, op)\n    op[root] = val + 1\n    return op[root]\n\ndef dfs2(root, parent, op):\n    val = -1\n    if root in dic:\n        for child in dic[root]:\n            if child != parent:\n                val = max(val, dfs2(child, root, op), 0)\n    if val == -1:\n        return 1\n    else:\n        return op[root] + val\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    dic = {}\n    for i in range(n - 1):\n        x = arr[i]\n        if x in dic:\n            dic[x].append(i + 2)\n        else:\n            dic[x] = [i + 2]\n        if i + 2 in dic:\n            dic[i + 2].append(x)\n        else:\n            dic[i + 2] = [x]\n    op = [0 for i in range(n + 1)]\n    parent = 0\n    root = 1\n    dfs(root, parent, op)\n    print(dfs2(root, parent, op))", "from collections import deque, defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    p = [int(i) for i in input().split()]\n    graph = [[] for i in range(n)]\n    for i in range(len(p)):\n        graph[p[i] - 1].append(i + 1)\n    count = n\n    vis = [0] * n\n    q = deque()\n    q.append(0)\n    vis[0] = 1\n    dist = [0] * n\n    temp = 2\n    while len(q) != 0:\n        curr = q.popleft()\n        for i in graph[curr]:\n            if vis[i] == 0:\n                dist[i] = dist[curr] + 1\n                vis[i] = 1\n                q.append(i)\n    d = []\n    for i in range(n):\n        d.append([dist[i], i])\n    d.sort(reverse=True)\n    value = defaultdict(lambda : 1)\n    for i in range(n - 1):\n        value[p[d[i][1] - 1] - 1] += value[d[i][1]]\n    vis = [0] * n\n    q = deque()\n    q.append(0)\n    vis[0] = 1\n    dist = [0] * n\n    temp = 2\n    while len(q) != 0:\n        curr = q.popleft()\n        for i in graph[curr]:\n            if vis[i] == 0:\n                value[i] += value[curr]\n                vis[i] = 1\n                q.append(i)\n    ans = 0\n    for i in value:\n        ans = max(ans, value[i])\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\ninput = __import__('sys').stdin.readline\n\ndef number_of_elements(dec, mem, node):\n    if node in mem:\n        return mem[node]\n    res = 1\n    for j in dec[node]:\n        res += number_of_elements(dec, mem, j)\n    mem[node] = res\n    return res\n\ndef solve(dec, mem2, node, mem):\n    if node in mem2:\n        return mem2[node]\n    if not dec[node]:\n        mem2[node] = 1\n        return 1\n    ans = mem[node]\n    p = 1\n    for j in dec[node]:\n        p = max(p, solve(dec, mem2, j, mem))\n    mem2[node] = ans + p\n    return ans + p\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dec = {}\n    for i in range(n - 1):\n        if a[i] in dec:\n            dec[a[i]].append(i + 2)\n        else:\n            dec[a[i]] = [i + 2]\n    for i in range(1, n + 1):\n        if i not in dec:\n            dec[i] = []\n    mem = {}\n    number_of_elements(dec, mem, 1)\n    result = solve(dec, {}, 1, mem)\n    print(result)", "from sys import stdin, setrecursionlimit as srl\nfrom threading import stack_size, Thread\nsrl(int(1000000000.0) + 7)\nstack_size(int(100000000.0))\n\ndef dfs_size(d, root):\n    s = 1\n    for i in d[root]:\n        if vis[i] == 0:\n            vis[i] = 1\n            s += dfs_size(d, i)\n    size[root] = s\n    return s\n\ndef mex(n):\n    x = size[n]\n    if len(d[n]) == 0:\n        return 1\n    p = -1\n    for i in d[n]:\n        p = max(p, mex(i))\n    return x + p\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[i] = []\n    for i in range(1, n):\n        d[p[i - 1] - 1].append(i)\n    vis = [0 for i in range(n)]\n    size = [0 for i in range(n)]\n    vis[0] = 1\n    size[0] = dfs_size(d, 0)\n    print(mex(0))", "import sys\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nt = int(input())\n\ndef dfs(n, p, a):\n    count = 0\n    maxval = 0\n    for i in a[n]:\n        if i == p:\n            continue\n        (tmaxval, tcount) = dfs(i, n, a)\n        maxval = max(maxval, tmaxval)\n        count += tcount\n    return (maxval + count + 1, count + 1)\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for i in range(n + 1):\n        a.append(list())\n    e = list(map(int, input().split()))\n    for i in range(1, n):\n        a[e[i - 1]].append(i + 1)\n    print(dfs(1, 1, a)[0])", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef recurse(root):\n    if root not in dic:\n        return (1, 1)\n    sum1 = 1\n    max1 = 0\n    for i in dic[root]:\n        (x, y) = recurse(i)\n        sum1 += x\n        max1 = max(max1, y)\n    return (sum1, sum1 + max1)\nfor _ in range(int(input())):\n    n = int(input())\n    dic = {}\n    lis = list(map(int, input().split()))\n    for i in range(len(lis)):\n        if lis[i] not in dic:\n            dic[lis[i]] = [i + 2]\n        else:\n            dic[lis[i]].append(i + 2)\n    (x, y) = recurse(1)\n    print(y)"]