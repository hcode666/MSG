["import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef dfs(node):\n    visited.add(node)\n    cur = []\n    cur_sum = 0\n    for child in dct[node]:\n        if child not in visited:\n            a = dfs(child) + 1\n            cur_sum += a\n            cur.append(a)\n    childs_dct[node] = cur\n    return cur_sum\n\ndef soln(dct, childs_dct):\n    mod = 1000000007\n    dfs(1)\n    ans = [0]\n    for i in range(1, n + 1):\n        child_list = childs_dct[i]\n        count = 0\n        for j in range(len(child_list)):\n            a = child_list[j]\n            count += a * 2\n            for k in range(j + 1, len(child_list)):\n                b = child_list[k]\n                count += a * b * 2\n                count %= mod\n        ans.append(count + 1)\n    a = 0\n    for i in range(n + 1):\n        a += i * ans[i]\n        a %= mod\n    print(a)\nfor _ in range(int(input())):\n    n = int(input())\n    dct = {i: [] for i in range(1, n + 1)}\n    childs_dct = dct.copy()\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        dct[a].append(b)\n        dct[b].append(a)\n    soln(dct, childs_dct)", "import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef dfs(node):\n    visited.add(node)\n    cur = []\n    cur_sum = 0\n    for child in dct[node]:\n        if child not in visited:\n            a = dfs(child) + 1\n            cur_sum += a\n            cur.append(a)\n    childs_dct[node] = cur\n    return cur_sum\n\ndef soln(dct, childs_dct):\n    mod = 1000000007\n    dfs(1)\n    ans = [0]\n    for i in range(1, n + 1):\n        child_list = childs_dct[i]\n        count = 0\n        for j in range(len(child_list)):\n            a = child_list[j]\n            count += a * 2\n            for k in range(j + 1, len(child_list)):\n                b = child_list[k]\n                count += a * b * 2\n                count %= mod\n        ans.append(count + 1)\n    a = 0\n    for i in range(n + 1):\n        a += i * ans[i]\n        a %= mod\n    print(a)\nfor _ in range(int(input())):\n    n = int(input())\n    dct = {i: [] for i in range(1, n + 1)}\n    childs_dct = dct.copy()\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        dct[a].append(b)\n        dct[b].append(a)\n    soln(dct, childs_dct)", "import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef dfs(node):\n    visited.add(node)\n    cur = []\n    cur_sum = 0\n    for child in dct[node]:\n        if child not in visited:\n            a = dfs(child) + 1\n            cur_sum += a\n            cur.append(a)\n    childs_dct[node] = cur\n    return cur_sum\n\ndef soln(dct, childs_dct):\n    mod = 1000000007\n    dfs(1)\n    ans = [0]\n    for i in range(1, n + 1):\n        child_list = childs_dct[i]\n        count = 0\n        for j in range(len(child_list)):\n            a = child_list[j]\n            count += a * 2\n            for k in range(j + 1, len(child_list)):\n                b = child_list[k]\n                count += a * b * 2\n                count %= mod\n        ans.append(count + 1)\n    a = 0\n    for i in range(n + 1):\n        a += i * ans[i]\n        a %= mod\n    print(a)\nfor _ in range(int(input())):\n    n = int(input())\n    dct = {i: [] for i in range(1, n + 1)}\n    childs_dct = dct.copy()\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        dct[a].append(b)\n        dct[b].append(a)\n    soln(dct, childs_dct)", "import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef dfs(node):\n    visited.add(node)\n    cur = []\n    cur_sum = 0\n    for child in dct[node]:\n        if child not in visited:\n            a = dfs(child) + 1\n            cur_sum += a\n            cur.append(a)\n    childs_dct[node] = cur\n    return cur_sum\n\ndef soln(dct, childs_dct):\n    mod = 1000000007\n    dfs(1)\n    ans = [0]\n    for i in range(1, n + 1):\n        child_list = childs_dct[i]\n        count = 0\n        for j in range(len(child_list)):\n            a = child_list[j]\n            count += a * 2\n            for k in range(j + 1, len(child_list)):\n                b = child_list[k]\n                count += a * b * 2\n                count %= mod\n        ans.append(count + 1)\n    a = 0\n    for i in range(n + 1):\n        a += i * ans[i]\n        a %= mod\n    print(a)\nfor _ in range(int(input())):\n    n = int(input())\n    dct = {i: [] for i in range(1, n + 1)}\n    childs_dct = dct.copy()\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        dct[a].append(b)\n        dct[b].append(a)\n    soln(dct, childs_dct)", "import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef dfs(node):\n    visited.add(node)\n    cur = []\n    cur_sum = 0\n    for child in dct[node]:\n        if child not in visited:\n            a = dfs(child) + 1\n            cur_sum += a\n            cur.append(a)\n    childs_dct[node] = cur\n    return cur_sum\n\ndef soln(dct, childs_dct):\n    mod = 1000000007\n    dfs(1)\n    ans = [0]\n    for i in range(1, n + 1):\n        child_list = childs_dct[i]\n        count = 0\n        for j in range(len(child_list)):\n            a = child_list[j]\n            count += a * 2\n            for k in range(j + 1, len(child_list)):\n                b = child_list[k]\n                count += a * b * 2\n                count %= mod\n        ans.append(count + 1)\n    a = 0\n    for i in range(n + 1):\n        a += i * ans[i]\n        a %= mod\n    print(a)\nfor _ in range(int(input())):\n    n = int(input())\n    dct = {i: [] for i in range(1, n + 1)}\n    childs_dct = dct.copy()\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        dct[a].append(b)\n        dct[b].append(a)\n    soln(dct, childs_dct)", "import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef dfs(node):\n    visited.add(node)\n    cur = []\n    cur_sum = 0\n    for child in dct[node]:\n        if child not in visited:\n            a = dfs(child) + 1\n            cur_sum += a\n            cur.append(a)\n    childs_dct[node] = cur\n    return cur_sum\n\ndef soln(dct, childs_dct):\n    mod = 1000000007\n    dfs(1)\n    ans = [0]\n    for i in range(1, n + 1):\n        child_list = childs_dct[i]\n        count = 0\n        for j in range(len(child_list)):\n            a = child_list[j]\n            count += a * 2\n            for k in range(j + 1, len(child_list)):\n                b = child_list[k]\n                count += a * b * 2\n                count %= mod\n        ans.append(count + 1)\n    a = 0\n    for i in range(n + 1):\n        a += i * ans[i]\n        a %= mod\n    print(a)\nfor _ in range(int(input())):\n    n = int(input())\n    dct = {i: [] for i in range(1, n + 1)}\n    childs_dct = dct.copy()\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        dct[a].append(b)\n        dct[b].append(a)\n    soln(dct, childs_dct)", "import sys\nsys.setrecursionlimit(100000)\n\ndef dfs(node):\n    if node in visited:\n        childs_dct[node] = []\n        return 0\n    childs = dct[node]\n    count = []\n    s = 0\n    visited.add(node)\n    for child in childs:\n        if child not in visited:\n            a = dfs(child) + 1\n            s += a\n            count.append(a)\n    childs_dct[node] = count\n    return s\n\ndef solve():\n    try:\n        if dct == {}:\n            print(1)\n            return\n        mod = 1000000007\n        dfs(1)\n        ans = [0]\n        for i in range(1, n + 1):\n            child_list = childs_dct[i]\n            count = 0\n            for j in range(len(child_list)):\n                a = child_list[j]\n                count += a * 2\n                for k in range(j + 1, len(child_list)):\n                    b = child_list[k]\n                    count += a * b * 2\n                    count %= mod\n            ans.append(count + 1)\n        a = 0\n        for i in range(n + 1):\n            a += i * ans[i]\n            a %= mod\n        print(a)\n    except Exception as e:\n        print(e)\nfor _ in range(int(input())):\n    n = int(input())\n    dct = {}\n    childs_dct = {i: [] for i in range(1, n + 1)}\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (min(a, b), max(a, b))\n        if a not in dct:\n            dct[a] = [b]\n        else:\n            dct[a].append(b)\n        if b not in dct:\n            dct[b] = [a]\n        else:\n            dct[b].append(a)\n    solve()", "import sys\nsys.setrecursionlimit(100000)\n\ndef dfs(node):\n    if node in visited:\n        childs_dct[node] = []\n        return 0\n    childs = dct[node]\n    count = []\n    s = 0\n    visited.add(node)\n    for child in childs:\n        if child not in visited:\n            a = dfs(child) + 1\n            s += a\n            count.append(a)\n    childs_dct[node] = count\n    return s\n\ndef solve():\n    try:\n        if dct == {}:\n            print(1)\n            return\n        mod = 1000000007\n        dfs(1)\n        ans = [0]\n        for i in range(1, n + 1):\n            child_list = childs_dct[i]\n            count = 0\n            for j in range(len(child_list)):\n                a = child_list[j]\n                count += a * 2\n                for k in range(j + 1, len(child_list)):\n                    b = child_list[k]\n                    count += a * b * 2\n                    count %= mod\n            ans.append(count + 1)\n        a = 0\n        for i in range(n + 1):\n            a += i * ans[i]\n            a %= mod\n        print(a)\n    except Exception as e:\n        print(e)\nfor _ in range(int(input())):\n    n = int(input())\n    dct = {}\n    childs_dct = {i: [] for i in range(1, n + 1)}\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (min(a, b), max(a, b))\n        if a not in dct:\n            dct[a] = [b]\n        else:\n            dct[a].append(b)\n        if b not in dct:\n            dct[b] = [a]\n        else:\n            dct[b].append(a)\n    solve()", "import sys\nsys.setrecursionlimit(100000)\n\ndef dfs(node):\n    if node in visited:\n        childs_dct[node] = []\n        return 0\n    childs = dct[node]\n    count = []\n    s = 0\n    visited.add(node)\n    for child in childs:\n        if child not in visited:\n            a = dfs(child) + 1\n            s += a\n            count.append(a)\n    childs_dct[node] = count\n    return s\n\ndef solve():\n    try:\n        if dct == {}:\n            print(1)\n            return\n        mod = 1000000007\n        dfs(1)\n        ans = [0]\n        for i in range(1, n + 1):\n            child_list = childs_dct[i]\n            count = 0\n            for j in range(len(child_list)):\n                a = child_list[j]\n                count += a * 2\n                for k in range(j + 1, len(child_list)):\n                    b = child_list[k]\n                    count += a * b * 2\n                    count %= mod\n            ans.append(count + 1)\n        a = 0\n        for i in range(n + 1):\n            a += i * ans[i]\n            a %= mod\n        print(a)\n    except Exception as e:\n        print(e)\nfor _ in range(int(input())):\n    n = int(input())\n    dct = {}\n    childs_dct = {i: [] for i in range(1, n + 1)}\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = list(map(int, input().split()))\n        (a, b) = (min(a, b), max(a, b))\n        if a not in dct:\n            dct[a] = [b]\n        else:\n            dct[a].append(b)\n        if b not in dct:\n            dct[b] = [a]\n        else:\n            dct[b].append(a)\n    solve()", "import sys\nsys.setrecursionlimit(100000)\n\ndef integer_list():\n    return list(map(int, input().split()))\n\ndef string_list():\n    return list(map(str, input().split()))\n\ndef hetro_list():\n    return list(input().split())\n\ndef dfs(node):\n    if node in visited:\n        childs_dct[node] = []\n        return 0\n    childs = dct[node]\n    count = []\n    s = 0\n    visited.add(node)\n    for child in childs:\n        if child not in visited:\n            a = dfs(child) + 1\n            s += a\n            count.append(a)\n    childs_dct[node] = count\n    return s\n\ndef main():\n    try:\n        if dct == {}:\n            print(1)\n            return\n        mod = 1000000007\n        dfs(1)\n        ans = [0]\n        for i in range(1, n + 1):\n            child_list = childs_dct[i]\n            count = 0\n            for j in range(len(child_list)):\n                a = child_list[j]\n                count += a * 2\n                for k in range(j + 1, len(child_list)):\n                    b = child_list[k]\n                    count += a * b * 2\n                    count %= mod\n            ans.append(count + 1)\n        a = 0\n        for i in range(n + 1):\n            a += i * ans[i]\n            a %= mod\n        print(a)\n    except Exception as e:\n        print(e)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    dct = {}\n    childs_dct = {i: [] for i in range(1, n + 1)}\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = integer_list()\n        (a, b) = (min(a, b), max(a, b))\n        if a not in dct:\n            dct[a] = [b]\n        else:\n            dct[a].append(b)\n        if b not in dct:\n            dct[b] = [a]\n        else:\n            dct[b].append(a)\n    main()", "import sys\nsys.setrecursionlimit(100000)\n\ndef integer_list():\n    return list(map(int, input().split()))\n\ndef string_list():\n    return list(map(str, input().split()))\n\ndef hetro_list():\n    return list(input().split())\n\ndef dfs(node):\n    if node in visited:\n        childs_dct[node] = []\n        return 0\n    childs = dct[node]\n    count = []\n    s = 0\n    visited.add(node)\n    for child in childs:\n        if child not in visited:\n            a = dfs(child) + 1\n            s += a\n            count.append(a)\n    childs_dct[node] = count\n    return s\n\ndef main():\n    try:\n        if dct == {}:\n            print(1)\n            return\n        mod = 1000000007\n        dfs(1)\n        ans = [0]\n        for i in range(1, n + 1):\n            child_list = childs_dct[i]\n            count = 0\n            for j in range(len(child_list)):\n                a = child_list[j]\n                count += a * 2\n                for k in range(j + 1, len(child_list)):\n                    b = child_list[k]\n                    count += a * b * 2\n                    count %= mod\n            ans.append(count + 1)\n        a = 0\n        for i in range(n + 1):\n            a += i * ans[i]\n            a %= mod\n        print(a)\n    except Exception as e:\n        print(e)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    dct = {}\n    childs_dct = {i: [] for i in range(1, n + 1)}\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = integer_list()\n        (a, b) = (min(a, b), max(a, b))\n        if a not in dct:\n            dct[a] = [b]\n        else:\n            dct[a].append(b)\n        if b not in dct:\n            dct[b] = [a]\n        else:\n            dct[b].append(a)\n    main()", "import sys\nsys.setrecursionlimit(100000)\n\ndef integer_list():\n    return list(map(int, input().split()))\n\ndef string_list():\n    return list(map(str, input().split()))\n\ndef hetro_list():\n    return list(input().split())\n\ndef dfs(node):\n    if node in visited:\n        childs_dct[node] = []\n        return 0\n    childs = dct[node]\n    count = []\n    s = 0\n    visited.add(node)\n    for child in childs:\n        if child not in visited:\n            a = dfs(child) + 1\n            s += a\n            count.append(a)\n    childs_dct[node] = count\n    return s\n\ndef main():\n    try:\n        if dct == {}:\n            print(1)\n            return\n        mod = 1000000007\n        dfs(1)\n        ans = [0]\n        for i in range(1, n + 1):\n            child_list = childs_dct[i]\n            count = 0\n            for j in range(len(child_list)):\n                a = child_list[j]\n                count += a * 2\n                for k in range(j + 1, len(child_list)):\n                    b = child_list[k]\n                    count += a * b * 2\n                    count %= mod\n            ans.append(count + 1)\n        a = 0\n        for i in range(n + 1):\n            a += i * ans[i]\n            a %= mod\n        print(a)\n    except Exception as e:\n        print(e)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    dct = {}\n    childs_dct = {i: [] for i in range(1, n + 1)}\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = integer_list()\n        (a, b) = (min(a, b), max(a, b))\n        if a not in dct:\n            dct[a] = [b]\n        else:\n            dct[a].append(b)\n        if b not in dct:\n            dct[b] = [a]\n        else:\n            dct[b].append(a)\n    main()", "import sys\nsys.setrecursionlimit(100000)\n\ndef integer_list():\n    return list(map(int, input().split()))\n\ndef string_list():\n    return list(map(str, input().split()))\n\ndef hetro_list():\n    return list(input().split())\n\ndef dfs(node):\n    if node in visited:\n        childs_dct[node] = []\n        return 0\n    childs = dct[node]\n    count = []\n    s = 0\n    visited.add(node)\n    for child in childs:\n        if child not in visited:\n            a = dfs(child) + 1\n            s += a\n            count.append(a)\n    childs_dct[node] = count\n    return s\n\ndef main():\n    try:\n        if dct == {}:\n            print(1)\n            return\n        mod = 1000000007\n        dfs(1)\n        ans = [0]\n        for i in range(1, n + 1):\n            child_list = childs_dct[i]\n            count = 0\n            for j in range(len(child_list)):\n                a = child_list[j]\n                count += a * 2\n                for k in range(j + 1, len(child_list)):\n                    b = child_list[k]\n                    count += a * b * 2\n                    count %= mod\n            ans.append(count + 1)\n        a = 0\n        for i in range(n + 1):\n            a += i * ans[i]\n            a %= mod\n        print(a)\n    except Exception as e:\n        print(e)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    dct = {}\n    childs_dct = {i: [] for i in range(1, n + 1)}\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = integer_list()\n        (a, b) = (min(a, b), max(a, b))\n        if a not in dct:\n            dct[a] = [b]\n        else:\n            dct[a].append(b)\n        if b not in dct:\n            dct[b] = [a]\n        else:\n            dct[b].append(a)\n    main()", "import sys\nsys.setrecursionlimit(100000)\n\ndef integer_list():\n    return list(map(int, input().split()))\n\ndef string_list():\n    return list(map(str, input().split()))\n\ndef hetro_list():\n    return list(input().split())\n\ndef dfs(node):\n    if node in visited:\n        childs_dct[node] = []\n        return 0\n    childs = dct[node]\n    count = []\n    s = 0\n    visited.add(node)\n    for child in childs:\n        if child not in visited:\n            a = dfs(child) + 1\n            s += a\n            count.append(a)\n    childs_dct[node] = count\n    return s\n\ndef main():\n    try:\n        if dct == {}:\n            print(1)\n            return\n        mod = 1000000007\n        dfs(1)\n        ans = [0]\n        for i in range(1, n + 1):\n            child_list = childs_dct[i]\n            count = 0\n            for j in range(len(child_list)):\n                a = child_list[j]\n                count += a * 2\n                for k in range(j + 1, len(child_list)):\n                    b = child_list[k]\n                    count += a * b * 2\n                    count %= mod\n            ans.append(count + 1)\n        a = 0\n        for i in range(n + 1):\n            a += i * ans[i]\n            a %= mod\n        print(a)\n    except Exception as e:\n        print(e)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    dct = {}\n    childs_dct = {i: [] for i in range(1, n + 1)}\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = integer_list()\n        (a, b) = (min(a, b), max(a, b))\n        if a not in dct:\n            dct[a] = [b]\n        else:\n            dct[a].append(b)\n        if b not in dct:\n            dct[b] = [a]\n        else:\n            dct[b].append(a)\n    main()", "import sys\nsys.setrecursionlimit(100000)\n\ndef integer_list():\n    return list(map(int, input().split()))\n\ndef string_list():\n    return list(map(str, input().split()))\n\ndef hetro_list():\n    return list(input().split())\n\ndef dfs(node):\n    if node in visited:\n        childs_dct[node] = []\n        return 0\n    childs = dct[node]\n    count = []\n    s = 0\n    visited.add(node)\n    for child in childs:\n        if child not in visited:\n            a = dfs(child) + 1\n            s += a\n            count.append(a)\n    childs_dct[node] = count\n    return s\n\ndef main():\n    try:\n        if dct == {}:\n            print(1)\n            return\n        mod = 1000000007\n        dfs(1)\n        ans = [0]\n        for i in range(1, n + 1):\n            child_list = childs_dct[i]\n            count = 0\n            for j in range(len(child_list)):\n                a = child_list[j]\n                count += a * 2\n                for k in range(j + 1, len(child_list)):\n                    b = child_list[k]\n                    count += a * b * 2\n                    count %= mod\n            ans.append(count + 1)\n        a = 0\n        for i in range(n + 1):\n            a += i * ans[i]\n            a %= mod\n        print(a)\n    except Exception as e:\n        print(e)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    dct = {}\n    childs_dct = {i: [] for i in range(1, n + 1)}\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = integer_list()\n        (a, b) = (min(a, b), max(a, b))\n        if a not in dct:\n            dct[a] = [b]\n        else:\n            dct[a].append(b)\n        if b not in dct:\n            dct[b] = [a]\n        else:\n            dct[b].append(a)\n    main()", "import sys\nsys.setrecursionlimit(100000)\n\ndef integer_list():\n    return list(map(int, input().split()))\n\ndef string_list():\n    return list(map(str, input().split()))\n\ndef hetro_list():\n    return list(input().split())\nimport math\nfrom collections import Counter\n\ndef dfs(node):\n    if node in visited:\n        childs_dct[node] = []\n        return 0\n    childs = dct[node]\n    count = []\n    s = 0\n    for child in childs:\n        if child not in visited:\n            visited.add(node)\n            a = 0\n            a += dfs(child) + 1\n            s += a\n            count.append(a)\n    childs_dct[node] = count\n    return s\n\ndef main():\n    try:\n        if dct == {}:\n            print(1)\n            return\n        mod = 1000000007\n        dfs(1)\n        ans = [0]\n        for i in range(1, n + 1):\n            child_list = childs_dct[i]\n            count = 0\n            for j in range(len(child_list)):\n                a = child_list[j]\n                count += a * 2\n                for k in range(j + 1, len(child_list)):\n                    b = child_list[k]\n                    count += a * b * 2\n                    count %= mod\n                count %= mod\n            ans.append(count + 1)\n        a = 0\n        for i in range(n + 1):\n            a += i * ans[i]\n            a %= mod\n        print(a)\n    except Exception as e:\n        print(e)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    dct = {}\n    childs_dct = {i: [] for i in range(1, n + 1)}\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = integer_list()\n        (a, b) = (min(a, b), max(a, b))\n        if a not in dct:\n            dct[a] = [b]\n        else:\n            dct[a].append(b)\n        if b not in dct:\n            dct[b] = [a]\n        else:\n            dct[b].append(a)\n    main()", "import sys\nsys.setrecursionlimit(100000)\n\ndef integer_list():\n    return list(map(int, input().split()))\n\ndef string_list():\n    return list(map(str, input().split()))\n\ndef hetro_list():\n    return list(input().split())\nimport math\nfrom collections import Counter\n\ndef dfs(node):\n    if node in visited:\n        childs_dct[node] = []\n        return 0\n    childs = dct[node]\n    count = []\n    s = 0\n    for child in childs:\n        if child not in visited:\n            visited.add(node)\n            a = 0\n            a += dfs(child) + 1\n            s += a\n            count.append(a)\n    childs_dct[node] = count\n    return s\n\ndef main():\n    try:\n        if dct == {}:\n            print(1)\n            return\n        mod = 1000000007\n        dfs(1)\n        ans = [0]\n        for i in range(1, n + 1):\n            child_list = childs_dct[i]\n            count = 0\n            for j in range(len(child_list)):\n                a = child_list[j]\n                count += a * 2\n                for k in range(j + 1, len(child_list)):\n                    b = child_list[k]\n                    count += a * b * 2\n                    count %= mod\n                count %= mod\n            ans.append(count + 1)\n        a = 0\n        for i in range(n + 1):\n            a += i * ans[i]\n            a %= mod\n        print(a)\n    except Exception as e:\n        print(e)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    dct = {}\n    childs_dct = {i: [] for i in range(1, n + 1)}\n    visited = set()\n    for i in range(n - 1):\n        (a, b) = integer_list()\n        (a, b) = (min(a, b), max(a, b))\n        if a not in dct:\n            dct[a] = [b]\n        else:\n            dct[a].append(b)\n        if b not in dct:\n            dct[b] = [a]\n        else:\n            dct[b].append(a)\n    main()"]