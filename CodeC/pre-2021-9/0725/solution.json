["def knapSack(W, wt, val, n):\n    if n == 0 or W == 0:\n        return 0\n    if wt[n - 1] > W:\n        return knapSack(W, wt, val, n - 1)\n    else:\n        return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1), knapSack(W, wt, val, n - 1))\nt = int(input())\nwhile t != 0:\n    first = [int(i) for i in input().split()]\n    n = first[0]\n    k = first[1]\n    cost = []\n    weight = []\n    for i in range(n):\n        sec = [int(i) for i in input().split()]\n        cost.append(sec[0])\n        weight.append(sec[1])\n    print(knapSack(k, cost, weight, n))\n    t -= 1", "def solve(W, wt, val, n):\n    if n == 0 or W == 0:\n        return 0\n    if wt[n - 1] > W:\n        return solve(W, wt, val, n - 1)\n    else:\n        return max(val[n - 1] + solve(W - wt[n - 1], wt, val, n - 1), solve(W, wt, val, n - 1))\nfor _ in range(int(input())):\n    wt = []\n    val = []\n    (n, k) = map(int, input().split())\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        wt.append(x)\n        val.append(y)\n    print(solve(k, wt, val, n))", "def solve(W, wt, val, n):\n    if n == 0 or W == 0:\n        return 0\n    if wt[n - 1] > W:\n        return solve(W, wt, val, n - 1)\n    else:\n        return max(val[n - 1] + solve(W - wt[n - 1], wt, val, n - 1), solve(W, wt, val, n - 1))\nfor _ in range(int(input())):\n    wt = []\n    val = []\n    (n, k) = map(int, input().split())\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        wt.append(x)\n        val.append(y)\n    print(solve(k, wt, val, n))", "def solve(W, wt, val, n):\n    if n == 0 or W == 0:\n        return 0\n    if wt[n - 1] > W:\n        return solve(W, wt, val, n - 1)\n    else:\n        return max(val[n - 1] + solve(W - wt[n - 1], wt, val, n - 1), solve(W, wt, val, n - 1))\nfor _ in range(int(input())):\n    wt = []\n    val = []\n    (n, k) = map(int, input().split())\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        wt.append(x)\n        val.append(y)\n    print(solve(k, wt, val, n))", "def solve(W, wt, val, n):\n    if n == 0 or W == 0:\n        return 0\n    if wt[n - 1] > W:\n        return solve(W, wt, val, n - 1)\n    else:\n        return max(val[n - 1] + solve(W - wt[n - 1], wt, val, n - 1), solve(W, wt, val, n - 1))\nfor _ in range(int(input())):\n    wt = []\n    val = []\n    (n, k) = map(int, input().split())\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        wt.append(x)\n        val.append(y)\n    print(solve(k, wt, val, n))", "def search(n, k, c, w):\n    if k == 0:\n        return 0\n    elif n == 0:\n        return 0\n    elif k < c[n - 1]:\n        return search(n - 1, k, c, w)\n    else:\n        return max(search(n - 1, k, c, w), w[n - 1] + search(n - 1, k - c[n - 1], c, w))\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    c = [0 for x in range(n)]\n    w = [0 for y in range(n)]\n    for j in range(n):\n        (c[j], w[j]) = map(int, input().split())\n    print(search(n, k, c, w))", "def search(n, k, c, w):\n    if k == 0:\n        return 0\n    elif n == 0:\n        return 0\n    elif k < c[n - 1]:\n        return search(n - 1, k, c, w)\n    else:\n        return max(search(n - 1, k, c, w), w[n - 1] + search(n - 1, k - c[n - 1], c, w))\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    c = [0 for x in range(n)]\n    w = [0 for y in range(n)]\n    for j in range(n):\n        (c[j], w[j]) = map(int, input().split())\n    print(search(n, k, c, w))", "def bitmask(cost, wt, W, n):\n    s = ''\n    for i in range(n):\n        s += '1'\n    s = int(s, 2)\n    ans = 0\n    for i in range(1, s + 1):\n        curr = i\n        (curr_val, j) = (0, n - 1)\n        curr_cost = W\n        while curr != 0:\n            if curr & 1:\n                if curr_cost - cost[j] >= 0:\n                    curr_val += wt[j]\n                    curr_cost -= cost[j]\n            j -= 1\n            curr = curr >> 1\n        ans = max(curr_val, ans)\n    return ans\nfor _ in range(int(input())):\n    (n, W) = map(int, input().split())\n    (cost, wt) = ([], [])\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        cost.append(a)\n        wt.append(b)\n    ans = bitmask(cost, wt, W, n)\n    print(ans)", "def bitmask(cost, wt, W, n):\n    s = ''\n    for i in range(n):\n        s += '1'\n    s = int(s, 2)\n    ans = 0\n    for i in range(1, s + 1):\n        curr = i\n        (curr_val, j) = (0, n - 1)\n        curr_cost = W\n        while curr != 0:\n            if curr & 1:\n                if curr_cost - cost[j] >= 0:\n                    curr_val += wt[j]\n                    curr_cost -= cost[j]\n            j -= 1\n            curr = curr >> 1\n        ans = max(curr_val, ans)\n    return ans\nfor _ in range(int(input())):\n    (n, W) = map(int, input().split())\n    (cost, wt) = ([], [])\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        cost.append(a)\n        wt.append(b)\n    ans = bitmask(cost, wt, W, n)\n    print(ans)", "def bitmask(cost, wt, W, n):\n    s = ''\n    for i in range(n):\n        s += '1'\n    s = int(s, 2)\n    ans = 0\n    for i in range(1, s + 1):\n        curr = i\n        (curr_val, j) = (0, n - 1)\n        curr_cost = W\n        while curr != 0:\n            if curr & 1:\n                if curr_cost - cost[j] >= 0:\n                    curr_val += wt[j]\n                    curr_cost -= cost[j]\n            j -= 1\n            curr = curr >> 1\n        ans = max(curr_val, ans)\n    return ans\nfor _ in range(int(input())):\n    (n, W) = map(int, input().split())\n    (cost, wt) = ([], [])\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        cost.append(a)\n        wt.append(b)\n    ans = bitmask(cost, wt, W, n)\n    print(ans)", "def bitmask(cost, wt, W, n):\n    s = ''\n    for i in range(n):\n        s += '1'\n    s = int(s, 2)\n    ans = 0\n    for i in range(1, s + 1):\n        curr = i\n        (curr_val, j) = (0, n - 1)\n        curr_cost = W\n        while curr != 0:\n            if curr & 1:\n                if curr_cost - cost[j] >= 0:\n                    curr_val += wt[j]\n                    curr_cost -= cost[j]\n            j -= 1\n            curr = curr >> 1\n        ans = max(curr_val, ans)\n    return ans\nfor _ in range(int(input())):\n    (n, W) = map(int, input().split())\n    (cost, wt) = ([], [])\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        cost.append(a)\n        wt.append(b)\n    ans = bitmask(cost, wt, W, n)\n    print(ans)", "def knapsack(W, cost, wt, n):\n    if n < 0 or W == 0:\n        return 0\n    if cost[n] > W:\n        return knapsack(W, cost, wt, n - 1)\n    else:\n        inc = wt[n] + knapsack(W - cost[n], cost, wt, n - 1)\n        exc = knapsack(W, cost, wt, n - 1)\n        return max(inc, exc)\nfor _ in range(int(input())):\n    (n, W) = map(int, input().split())\n    (cost, wt) = ([], [])\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        cost.append(a)\n        wt.append(b)\n    ans = knapsack(W, cost, wt, n - 1)\n    print(ans)", "def snek(l, a, k, s, b):\n    if a == len(l):\n        return s\n    if b == 0:\n        return max(snek(l, a + 1, k, s, 0), snek(l, a + 1, k, s, 1))\n    if b == 1:\n        if l[a][0] <= k:\n            k -= l[a][0]\n            s += l[a][1]\n            return max(snek(l, a + 1, k, s, 0), snek(l, a + 1, k, s, 1))\n        else:\n            return s\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    l1 = []\n    for j in range(n):\n        l1.append(list(map(int, input().split())))\n    print(max(snek(l1, 0, k, 0, 0), snek(l1, 0, k, 0, 1)))", "def cal(l, a, k, s, b):\n    if a == len(l):\n        return s\n    if b == 0:\n        return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n    if b == 1:\n        if l[a][0] <= k:\n            k -= l[a][0]\n            s += l[a][1]\n            return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n        else:\n            return s\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    list1 = []\n    for i in range(n):\n        list1.append(list(map(int, input().split())))\n    print(max(cal(list1, 0, k, 0, 0), cal(list1, 0, k, 0, 1)))", "def cal(l, a, k, s, b):\n    if a == len(l):\n        return s\n    if b == 0:\n        return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n    if b == 1:\n        if l[a][0] <= k:\n            k -= l[a][0]\n            s += l[a][1]\n            return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n        else:\n            return s\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    list1 = []\n    for i in range(n):\n        list1.append(list(map(int, input().split())))\n    print(max(cal(list1, 0, k, 0, 0), cal(list1, 0, k, 0, 1)))", "def cal(l, a, k, s, b):\n    if a == len(l):\n        return s\n    if b == 0:\n        return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n    if b == 1:\n        if l[a][0] <= k:\n            k -= l[a][0]\n            s += l[a][1]\n            return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n        else:\n            return s\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    list1 = []\n    for i in range(n):\n        list1.append(list(map(int, input().split())))\n    print(max(cal(list1, 0, k, 0, 0), cal(list1, 0, k, 0, 1)))", "def cal(l, a, k, s, b):\n    if a == len(l):\n        return s\n    if b == 0:\n        return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n    if b == 1:\n        if l[a][0] <= k:\n            k -= l[a][0]\n            s += l[a][1]\n            return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n        else:\n            return s\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    list1 = []\n    for i in range(n):\n        list1.append(list(map(int, input().split())))\n    print(max(cal(list1, 0, k, 0, 0), cal(list1, 0, k, 0, 1)))", "def cal(l, a, k, s, b):\n    if a == len(l):\n        return s\n    if b == 0:\n        return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n    if b == 1:\n        if l[a][0] <= k:\n            k -= l[a][0]\n            s += l[a][1]\n            return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n        else:\n            return s\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    list1 = []\n    for i in range(n):\n        list1.append(list(map(int, input().split())))\n    print(max(cal(list1, 0, k, 0, 0), cal(list1, 0, k, 0, 1)))", "from itertools import combinations\nfor _ in range(int(input())):\n    (toranges, trubles) = list(map(int, input().split()))\n    ocost_oweight = []\n    for i in range(toranges):\n        ocost_oweight.append(list(map(int, input().split())))\n    pos_choices = []\n    for i in range(1, toranges + 1):\n        pos_choices.append(list(combinations(ocost_oweight, i)))\n    pos_weights = []\n    for choice_type in pos_choices:\n        for choice in choice_type:\n            weight = 0\n            cost = 0\n            feasible = True\n            for pair in choice:\n                weight += pair[1]\n                cost += pair[0]\n                if cost > trubles:\n                    feasible = False\n                    break\n            if feasible:\n                pos_weights.append(weight)\n    print(max(pos_weights))", "for _ in range(int(input())):\n    (n, k) = [int(c) for c in input().split()]\n    costs = []\n    weights = []\n    for i in range(n):\n        (c, w) = [int(c) for c in input().split()]\n        costs.append(c)\n        weights.append(w)\n    maxweight = 0\n    for i in range(1024):\n        currcost = 0\n        currweight = 0\n        for j in range(n):\n            if i & 1 << j:\n                currcost += costs[j]\n                currweight += weights[j]\n        if currcost <= k:\n            maxweight = max(maxweight, currweight)\n    print(maxweight)", "from itertools import combinations\nfor _ in range(int(input())):\n    (toranges, trubles) = list(map(int, input().split()))\n    ocost_oweight = []\n    for i in range(toranges):\n        ocost_oweight.append(list(map(int, input().split())))\n    pos_choices = []\n    for i in range(1, toranges + 1):\n        pos_choices.append(list(combinations(ocost_oweight, i)))\n    pos_weights = []\n    for choice_type in pos_choices:\n        for choice in choice_type:\n            weight = 0\n            cost = 0\n            feasible = True\n            for pair in choice:\n                weight += pair[1]\n                cost += pair[0]\n                if cost > trubles:\n                    feasible = False\n                    break\n            if feasible:\n                pos_weights.append(weight)\n    print(max(pos_weights))", "from itertools import combinations\nfor _ in range(int(input())):\n    (toranges, trubles) = list(map(int, input().split()))\n    ocost_oweight = []\n    for i in range(toranges):\n        ocost_oweight.append(list(map(int, input().split())))\n    pos_choices = []\n    for i in range(1, toranges + 1):\n        pos_choices.append(list(combinations(ocost_oweight, i)))\n    pos_weights = []\n    for choice_type in pos_choices:\n        for choice in choice_type:\n            weight = 0\n            cost = 0\n            feasible = True\n            for pair in choice:\n                weight += pair[1]\n                cost += pair[0]\n                if cost > trubles:\n                    feasible = False\n                    break\n            if feasible:\n                pos_weights.append(weight)\n    print(max(pos_weights))", "def cal(l, a, k, s, b):\n    if a == len(l):\n        return s\n    if b == 0:\n        return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n    if b == 1:\n        if l[a][0] <= k:\n            k -= l[a][0]\n            s += l[a][1]\n            return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n        else:\n            return s\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    list1 = []\n    for i in range(n):\n        list1.append(list(map(int, input().split())))\n    print(max(cal(list1, 0, k, 0, 0), cal(list1, 0, k, 0, 1)))", "def cal(l, a, k, s, b):\n    if a == len(l):\n        return s\n    if b == 0:\n        return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n    if b == 1:\n        if l[a][0] <= k:\n            k -= l[a][0]\n            s += l[a][1]\n            return max(cal(l, a + 1, k, s, 0), cal(l, a + 1, k, s, 1))\n        else:\n            return s\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    list1 = []\n    for i in range(n):\n        list1.append(list(map(int, input().split())))\n    print(max(cal(list1, 0, k, 0, 0), cal(list1, 0, k, 0, 1)))", "import sys\nfrom itertools import combinations as combn\nstdin = sys.stdin\nfor (i, line) in enumerate(stdin):\n    if i == 0:\n        T = int(line.strip())\n        N = -1\n        oranges = []\n        cur_i = 0\n    elif cur_i > N:\n        (N, K) = [int(s) for s in line.strip().split(' ')]\n        oranges = []\n        cur_i = 1\n    else:\n        oranges += [[int(s) for s in line.strip().split(' ')]]\n        if cur_i == N:\n            oranges = [[cost, weight] for (cost, weight) in oranges if cost <= K]\n            max_weight = 0\n            for size in range(1, len(oranges) + 1):\n                baskets = [basket for basket in combn(oranges, size) if sum((cost for (cost, _) in basket)) <= K]\n                if baskets:\n                    max_weight = max(max_weight, max((sum((weight for (_, weight) in basket)) for basket in baskets)))\n            print(max_weight)\n        cur_i += 1", "def solve(C, W, K):\n    n = len(C)\n    max_ = 0\n    for i in range(1 << n):\n        weight = 0\n        ans = []\n        k = K\n        for j in range(n):\n            if i & 1 << j:\n                ans.append(W[j])\n                if C[j] <= k:\n                    k -= C[j]\n                    weight += W[j]\n        max_ = max(max_, weight)\n    return max_\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    C = []\n    W = []\n    for i in range(n):\n        (c, w) = map(int, input().split())\n        C.append(c)\n        W.append(w)\n    print(solve(C, W, k))", "from itertools import combinations\ntry:\n    t = int(input())\n    for _ in range(t):\n        (n, k) = map(int, input().split())\n        weight = []\n        cost = []\n        ind = []\n        res = 0\n        for i in range(n):\n            (c, w) = map(int, input().split())\n            weight.append(w)\n            cost.append(c)\n            ind.append(i)\n        maxk = -float('inf')\n        for i in range(1, n + 1):\n            for itert in combinations(ind, i):\n                c = 0\n                w = 0\n                for j in itert:\n                    c += cost[j]\n                    w += weight[j]\n                if c <= k:\n                    maxk = max(maxk, w)\n        print(maxk)\nexcept:\n    pass", "def solve(costs, weights, k, n):\n    limit = 2 ** n\n    ans = float('-inf')\n    for i in range(1, limit):\n        rep = '{:0' + str(n) + 'b}'\n        rep = [int(x) for x in rep.format(i)]\n        curr_sum = sum([x * y for (x, y) in zip(weights, rep)])\n        curr_cost = sum([x * y for (x, y) in zip(costs, rep)])\n        if curr_cost <= k:\n            ans = max(ans, curr_sum)\n    return ans\nfor t in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    costs = []\n    weights = []\n    for i in range(n):\n        (a, b) = [int(x) for x in input().split()]\n        costs.append(a)\n        weights.append(b)\n    print(solve(costs, weights, k, n))", "def knapSack(W, wt, val, n):\n    if n == 0 or W == 0:\n        return 0\n    if wt[n - 1] > W:\n        return knapSack(W, wt, val, n - 1)\n    else:\n        return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1), knapSack(W, wt, val, n - 1))\nt = int(input())\nfor i in range(t):\n    wt = []\n    val = []\n    (n, k) = map(int, input().split())\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        wt.append(x)\n        val.append(y)\n    print(knapSack(k, wt, val, n))", "def knapSack(W, wt, val, n):\n    if n == 0 or W == 0:\n        return 0\n    if wt[n - 1] > W:\n        return knapSack(W, wt, val, n - 1)\n    else:\n        return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1), knapSack(W, wt, val, n - 1))\nt = int(input())\nfor i in range(t):\n    (n, W) = map(int, input().split())\n    val = []\n    wt = []\n    for i in range(n):\n        (n1, m1) = map(int, input().split())\n        val.append(m1)\n        wt.append(n1)\n    n = len(val)\n    print(knapSack(W, wt, val, n))", "from itertools import combinations\nfor _ in range(int(input())):\n    (toranges, trubles) = list(map(int, input().split()))\n    ocost_oweight = []\n    for i in range(toranges):\n        ocost_oweight.append(list(map(int, input().split())))\n    pos_choices = []\n    for i in range(1, toranges + 1):\n        pos_choices.append(list(combinations(ocost_oweight, i)))\n    pos_weights = []\n    for choice_type in pos_choices:\n        for choice in choice_type:\n            weight = 0\n            cost = 0\n            feasible = True\n            for pair in choice:\n                weight += pair[1]\n                cost += pair[0]\n                if cost > trubles:\n                    feasible = False\n                    break\n            if feasible:\n                pos_weights.append(weight)\n    print(max(pos_weights))", "ans = []\n\ndef solve(id, remW):\n    if remW <= 0 or id == n:\n        return 0\n    marker = (id, remW)\n    if marker in memo:\n        return memo[marker]\n    ans = solve(id + 1, remW)\n    if remW >= pairs[id][0]:\n        ans = max(ans, solve(id + 1, remW - pairs[id][0]) + pairs[id][1])\n    memo[marker] = ans\n    return ans\nfor t in range(int(input())):\n    [n, k] = [int(i) for i in input().split()]\n    memo = {}\n    pairs = []\n    for i in range(n):\n        pairs.append([int(i) for i in input().split()])\n    ans.append(str(solve(0, k)))\nprint('\\n'.join(ans))", "memo = dict()\n\ndef knpsk(c, w, index, k):\n    if index in memo.keys():\n        if k in memo[index].keys():\n            return memo[index][k]\n    if k == 0 or index == -1:\n        return 0\n    if c[index] > k:\n        return knpsk(c, w, index - 1, k)\n    if index not in memo:\n        memo[index] = dict()\n    memo[index][k] = max(w[index] + knpsk(c, w, index - 1, k - c[index]), knpsk(c, w, index - 1, k))\n    return memo[index][k]\ntcase = int(input())\nwhile tcase > 0:\n    tcase -= 1\n    (c, w) = ([], [])\n    (n, k) = map(int, input().split())\n    for i in range(n):\n        (cost, weight) = map(int, input().split())\n        c.append(cost)\n        w.append(weight)\n    print(knpsk(c, w, n - 1, k))\n    memo = dict()", "memo = dict()\n\ndef knpsk(c, w, index, k):\n    if index in memo.keys():\n        if k in memo[index].keys():\n            return memo[index][k]\n    if k == 0 or index == -1:\n        return 0\n    if c[index] > k:\n        return knpsk(c, w, index - 1, k)\n    if index not in memo:\n        memo[index] = dict()\n    memo[index][k] = max(w[index] + knpsk(c, w, index - 1, k - c[index]), knpsk(c, w, index - 1, k))\n    return memo[index][k]\ntcase = int(input())\nwhile tcase > 0:\n    tcase -= 1\n    (c, w) = ([], [])\n    (n, k) = map(int, input().split())\n    for i in range(n):\n        (cost, weight) = map(int, input().split())\n        c.append(cost)\n        w.append(weight)\n    print(knpsk(c, w, n - 1, k))\n    memo = dict()", "dp = dict()\n\ndef recur(cost, weight, n, k):\n    if n in dp.keys():\n        if k in dp[n].keys():\n            return dp[n][k]\n    if k == 0 or n == -1:\n        return 0\n    if cost[n] > k:\n        return recur(cost, weight, n - 1, k)\n    if n not in dp:\n        dp[n] = dict()\n    dp[n][k] = max(weight[n] + recur(cost, weight, n - 1, k - cost[n]), recur(cost, weight, n - 1, k))\n    return dp[n][k]\ntcase = int(input())\nwhile tcase > 0:\n    tcase -= 1\n    (c, w) = ([], [])\n    (n, k) = map(int, input().split())\n    for _ in range(n):\n        (cost, weight) = map(int, input().split())\n        c.append(cost)\n        w.append(weight)\n    print(recur(c, w, n - 1, k))\n    dp = dict()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    app = []\n    for i in range(n):\n        (cost, weight) = map(int, input().split())\n        app.append([cost, weight])\n    maxi = 0\n\n    def calc(curr):\n        sm = 0\n        ans = 0\n        for i in curr:\n            sm += app[i][0]\n            ans += app[i][1]\n        if sm <= k:\n            return ans\n        return 0\n    tot = 1 << n\n    for i in range(tot):\n        curr = []\n        for j in range(n):\n            if i & 1 << j:\n                curr.append(j)\n        maxi = max(maxi, calc(curr))\n    print(maxi)", "def make_set(arr, l):\n    ans = []\n    for i in range(2 ** l):\n        bits = bin(i)[2:]\n        bits = '0' * (l - len(bits)) + bits\n        temp = []\n        for x in range(l):\n            if bits[x] == '1':\n                temp += [arr[x]]\n        ans += [temp]\n    return ans\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    arr = []\n    for j in range(n):\n        (c, w) = map(int, input().split())\n        arr += [[c, w]]\n    s = make_set(arr, n)\n    maxw = 0\n    for j in s:\n        cost = 0\n        weight = 0\n        for x in j:\n            weight += x[1]\n            cost += x[0]\n        if weight > maxw and cost <= k:\n            maxw = weight\n    print(maxw)", "import itertools\nt = int(input().strip())\nfor i in range(t):\n    [n, k] = map(int, input().strip().split(' '))\n    l = []\n    for j in range(n):\n        s = list(map(int, input().strip().split(' ')))\n        l.append(s)\n    l1 = []\n    for L in range(0, n + 1):\n        for i in itertools.combinations(l, L):\n            l1.append(i)\n    w2 = 0\n    for j in range(len(l1)):\n        p = l1[j]\n        c1 = 0\n        w1 = 0\n        for m in range(len(p)):\n            c1 += p[m][0]\n            w1 += p[m][1]\n        if c1 <= k:\n            w2 = max(w2, w1)\n    print(w2)", "import itertools\nt = int(input().strip())\nfor i in range(t):\n    [n, k] = map(int, input().strip().split(' '))\n    l = []\n    for j in range(n):\n        s = list(map(int, input().strip().split(' ')))\n        l.append(s)\n    l1 = []\n    for L in range(0, n + 1):\n        for i in itertools.combinations(l, L):\n            l1.append(i)\n    w2 = 0\n    for j in range(len(l1)):\n        p = l1[j]\n        c1 = 0\n        w1 = 0\n        for m in range(len(p)):\n            c1 += p[m][0]\n            w1 += p[m][1]\n        if c1 <= k:\n            w2 = max(w2, w1)\n    print(w2)", "def mainstuff(k, cost, weight):\n    global a\n    m = -1\n    for i in range(2 ** len(cost)):\n        t = list(map(int, list(str(format(i, '0' + str(n) + 'b')))))\n        t1 = sum([a * b for (a, b) in zip(cost, t)])\n        t2 = sum([a * b for (a, b) in zip(weight, t)])\n        if t1 <= k:\n            if t2 > m:\n                m = t2\n    print(m)\nt = int(input())\nfor a0 in range(t):\n    (n, k) = map(int, input().strip().split(' '))\n    cost = []\n    weight = []\n    t = {}\n    for a1 in range(n):\n        (t1, t2) = map(int, input().strip().split(' '))\n        cost.append(t1)\n        weight.append(t2)\n    mainstuff(k, cost, weight)", "def knapsack(k, c, w, n):\n    if n == 0 or k == 0:\n        return 0\n    if c[n - 1] > k:\n        return knapsack(k, c, w, n - 1)\n    else:\n        return max(w[n - 1] + knapsack(k - c[n - 1], c, w, n - 1), knapsack(k, c, w, n - 1))\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    cost = []\n    weight = []\n    for _ in range(n):\n        (c, w) = map(int, input().split())\n        cost.append(c)\n        weight.append(w)\n    print(knapsack(k, cost, weight, len(cost)))", "T = int(input())\nfor t in range(T):\n    (n, k) = [int(i) for i in input().split(' ')]\n    C = []\n    W = []\n    for X in range(n):\n        (c, w) = [int(i) for i in input().split(' ')]\n        C.append(c)\n        W.append(w)\n    maxwt = 0\n    for i in range(1 << n):\n        curwt = 0\n        curcost = 0\n        for j in range(n):\n            if i & 1 << j:\n                curcost += C[j]\n                curwt += W[j]\n        if curcost <= k:\n            maxwt = max(maxwt, curwt)\n    print(maxwt)", "from itertools import combinations\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    c = []\n    w = []\n    c1 = list(range(n))\n    for _ in range(n):\n        (a, b) = map(int, input().split())\n        c.append(a)\n        w.append(b)\n    ans = 0\n    for r in range(1, n + 1):\n        x = combinations(c1, r)\n        for i in x:\n            cost = 0\n            weight = 0\n            for j in i:\n                cost += c[j]\n                weight += w[j]\n            if cost <= k and weight > ans:\n                ans = weight\n    print(ans)", "from itertools import combinations\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = []\n    b = []\n    c = list(range(n))\n    for _ in range(n):\n        (d, e) = map(int, input().split())\n        a.append(d)\n        b.append(e)\n    ans = 0\n    for r in range(1, n + 1):\n        x = combinations(c, r)\n        for i in x:\n            cost = 0\n            weight = 0\n            for j in i:\n                cost += a[j]\n                weight += b[j]\n            if cost <= k and weight > ans:\n                ans = weight\n    print(ans)", "import itertools, sys\nT = int(sys.stdin.readline())\nfor _ in range(T):\n    (n, k) = list(map(int, sys.stdin.readline().split()))\n    (cost, weight) = zip(*[list(map(int, sys.stdin.readline().split())) for _ in range(n)])\n    weights = []\n    for seq in itertools.product([0, 1], repeat=n):\n        if sum((x * y for (x, y) in zip(seq, cost))) <= k:\n            weights.append(sum((x * y for (x, y) in zip(seq, weight))))\n    print(max(weights))"]