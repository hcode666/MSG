["t = int(input())\nfor i in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    f = [0] * n\n    for j in range(n):\n        for k in range(j + 1, n):\n            if l[j] > l[k]:\n                f[j] += 1\n                f[k] += 1\n    w = sum(f) // 2\n    p = [False] * (w + 1)\n    p[0] = True\n    for v in f:\n        for z in range(w - v, -1, -1):\n            p[z + v] |= p[z]\n    print('YES' if p[w] else 'NO')", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    f = [0] * n\n    for j in range(n):\n        for k in range(j + 1, n):\n            if l[j] > l[k]:\n                f[j] += 1\n                f[k] += 1\n    w = sum(f) // 2\n    p = [False] * (w + 1)\n    p[0] = True\n    for v in f:\n        for z in range(w - v, -1, -1):\n            p[z + v] |= p[z]\n    print('YES' if p[w] else 'NO')", "for t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    inv = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                inv[i] += 1\n                inv[j] += 1\n    rj = sum(inv) // 2\n    dp = [False] * (rj + 1)\n    dp[0] = True\n    for i in inv:\n        for j in range(rj - i, -1, -1):\n            dp[i + j] |= dp[j]\n    if dp[rj]:\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    inv = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if l[i] > l[j]:\n                inv[i] += 1\n                inv[j] += 1\n    want = sum(inv) // 2\n    poss = [False] * (want + 1)\n    poss[0] = True\n    for v in inv:\n        for i in range(want - v, -1, -1):\n            poss[i + v] |= poss[i]\n    if poss[want]:\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    lst = list(map(int, input().split()))\n    inversionarray = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lst[i] > lst[j]:\n                inversionarray[i] = inversionarray[i] + 1\n                inversionarray[j] = inversionarray[j] + 1\n    var = sum(inversionarray) // 2\n    barr = [0] * (var + 1)\n    barr[0] = 1\n    for x in inversionarray:\n        for i in range(var - x, -1, -1):\n            barr[i + x] |= barr[i]\n    if barr[var]:\n        print('YES')\n    else:\n        print('NO')\n    t = t - 1", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    lst = list(map(int, input().split()))\n    inversionarray = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lst[i] > lst[j]:\n                inversionarray[i] = inversionarray[i] + 1\n                inversionarray[j] = inversionarray[j] + 1\n    var = sum(inversionarray) // 2\n    barr = [0] * (var + 1)\n    barr[0] = 1\n    for x in inversionarray:\n        for i in range(var - x, -1, -1):\n            barr[i + x] |= barr[i]\n    if barr[var]:\n        print('YES')\n    else:\n        print('NO')\n    t = t - 1", "import sys\ninput = sys.stdin.readline\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    lst = list(map(int, input().split()))\n    inversionarray = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lst[i] > lst[j]:\n                inversionarray[i] = inversionarray[i] + 1\n                inversionarray[j] = inversionarray[j] + 1\n    var = sum(inversionarray) // 2\n    barr = [0] * (var + 1)\n    barr[0] = 1\n    for x in inversionarray:\n        for i in range(var - x, -1, -1):\n            barr[i + x] |= barr[i]\n    if barr[var]:\n        print('YES')\n    else:\n        print('NO')\n    t = t - 1", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    inv = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv[i] += 1\n                inv[j] += 1\n    want = sum(inv) // 2\n    dp = [False] * (want + 1)\n    dp[0] = True\n    for i in inv:\n        for j in range(want - i, -1, -1):\n            dp[i + j] |= dp[j]\n    if dp[want]:\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    inv = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv[i] += 1\n                inv[j] += 1\n    want = sum(inv) // 2\n    dp = [False] * (want + 1)\n    dp[0] = True\n    for i in inv:\n        for j in range(want - i, -1, -1):\n            dp[i + j] |= dp[j]\n    if dp[want]:\n        print('YES')\n    else:\n        print('NO')", "import sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    inv = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if l[i] > l[j]:\n                inv[i] += 1\n                inv[j] += 1\n    want = sum(inv) // 2\n    poss = [False] * (want + 1)\n    poss[0] = True\n    for v in inv:\n        for i in range(want - v, -1, -1):\n            poss[i + v] |= poss[i]\n    if poss[want]:\n        print('YES')\n    else:\n        print('NO')", "def knapSack(W, wt, val, n):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    return K[n][W]\nt = int(input())\nfor _ in range(t):\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    delta = 0\n    C = []\n    for i in range(len(A)):\n        for j in range(i + 1, len(A)):\n            if A[i] > A[j]:\n                delta += 1\n    for i in range(len(A)):\n        c = 0\n        for j in range(len(A)):\n            if i > j and A[j] > A[i]:\n                c += 1\n            if i < j and A[i] > A[j]:\n                c += 1\n        C.append(c)\n    W = delta\n    val = C.copy()\n    wt = C.copy()\n    n = len(C)\n    reachable_sum = knapSack(W, wt, val, n)\n    if reachable_sum - delta == 0:\n        print('YES')\n    else:\n        print('NO')", "import numpy as np\n\ndef inversions(P):\n    N = len(P)\n    arr = np.zeros((N, N), dtype=int)\n    for i in range(len(P)):\n        for j in range(len(P)):\n            if i < j and P[i] > P[j]:\n                arr[i, j] = 1\n                arr[j, i] = 1\n    invs = arr.sum(0)\n    res = sorted([x for x in invs if x > 0])\n    return res\n\ndef isSubsetSum(arr, n, tot):\n    subset = [[False for i in range(tot + 1)] for i in range(n + 1)]\n    for i in range(n + 1):\n        subset[i][0] = True\n    for i in range(1, tot + 1):\n        subset[0][i] = False\n    for i in range(1, n + 1):\n        for j in range(1, tot + 1):\n            if j < arr[i - 1]:\n                subset[i][j] = subset[i - 1][j]\n            if j >= arr[i - 1]:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n    return 'YES' if subset[n][tot] else 'NO'\nfor _ in range(int(input())):\n    N = int(input())\n    P = [int(x) for x in input().split()]\n    arr = inversions(P)\n    n = len(arr)\n    tot = sum(arr) // 2\n    print(isSubsetSum(arr, n, tot))", "from sys import stdin, stdout, setrecursionlimit\nimport heapq\nfrom math import gcd, ceil, sqrt\nfrom collections import Counter, deque\nfrom bisect import bisect_left, bisect_right\nfrom itertools import combinations, permutations\nii1 = lambda : int(stdin.readline().strip())\nis1 = lambda : stdin.readline().strip()\niia = lambda : list(map(int, stdin.readline().strip().split()))\nisa = lambda : stdin.readline().strip().split()\nsetrecursionlimit(100000)\nmod = 1000000007\n\ndef get(tot, cnt):\n    dp = [[0 for i in range(tot + 1)] for j in range(len(cnt) + 1)]\n    for i in range(1, len(cnt) + 1):\n        for j in range(tot + 1):\n            if j == 0:\n                dp[i][j] = 1\n            elif j < cnt[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - cnt[i - 1]]\n    return dp[-1][-1]\ntc = ii1()\nfor _ in range(tc):\n    n = ii1()\n    arr = iia()\n    cnt = [0] * n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                cnt[i] += 1\n                cnt[j] += 1\n    req = sum(cnt) // 2\n    if get(req, cnt):\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    n = int(input())\n    p = [int(i) for i in input().split()]\n    c = [0] * n\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] > p[j]:\n                c[i] += 1\n                c[j] += 1\n                total += 1\n    dp = [False] * (total + 1)\n    dp[0] = True\n    for x in c:\n        for i in range(total - x, -1, -1):\n            dp[i + x] |= dp[i]\n    if dp[total]:\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    c = [0] * n\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                c[i] += 1\n                c[j] += 1\n                total += 1\n    dp = [False] * (total + 1)\n    dp[0] = True\n    for x in c:\n        for i in range(total - x, -1, -1):\n            dp[i + x] |= dp[i]\n    if dp[total]:\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    inv = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if l[i] > l[j]:\n                inv[i] += 1\n                inv[j] += 1\n    want = sum(inv) // 2\n    poss = [False] * (want + 1)\n    poss[0] = True\n    for v in inv:\n        for i in range(want - v, -1, -1):\n            poss[i + v] |= poss[i]\n    if poss[want]:\n        print('YES')\n    else:\n        print('NO')", "from sys import stdin, stdout, setrecursionlimit\nimport heapq\nfrom math import gcd, ceil, sqrt\nfrom collections import Counter, deque\nfrom bisect import bisect_left, bisect_right\nfrom itertools import combinations, permutations\nii1 = lambda : int(stdin.readline().strip())\nis1 = lambda : stdin.readline().strip()\niia = lambda : list(map(int, stdin.readline().strip().split()))\nisa = lambda : stdin.readline().strip().split()\nsetrecursionlimit(100000)\nmod = 1000000007\n\ndef get(tot, cnt):\n    dp = [[0 for i in range(tot + 1)] for j in range(len(cnt) + 1)]\n    for i in range(1, len(cnt) + 1):\n        for j in range(tot + 1):\n            if j == 0:\n                dp[i][j] = 1\n            elif j < cnt[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - cnt[i - 1]]\n    return dp[-1][-1]\ntc = ii1()\nfor _ in range(tc):\n    n = ii1()\n    arr = iia()\n    cnt = [0] * n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                cnt[i] += 1\n                cnt[j] += 1\n    req = sum(cnt) // 2\n    if get(req, cnt):\n        print('YES')\n    else:\n        print('NO')"]