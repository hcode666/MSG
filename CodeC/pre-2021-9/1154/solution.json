["def printMinCoins(edges, vertices):\n    edges.sort(reverse=True)\n    vertices.sort(reverse=True)\n    edgeCount = len(edges)\n    minCoins = 0\n    i = 0\n    if vertices[i] >= edges[0]:\n        i += 1\n    else:\n        minCoins += 1\n    for j in range(len(edges)):\n        if vertices[i] >= edges[j]:\n            i += 1\n        else:\n            minCoins += 1\n    print(minCoins)\nT = int(input())\nwhile T > 0:\n    T -= 1\n    N = int(input())\n    edges = []\n    for i in range(N - 1):\n        x = list(map(int, input().split()))\n        edges.append(x[2])\n    vertices = list(map(int, input().split()))\n    printMinCoins(edges, vertices)", "def printMinCoins(edges, vertices):\n    edges.sort(reverse=True)\n    vertices.sort(reverse=True)\n    edgeCount = len(edges)\n    minCoins = 0\n    i = 0\n    if vertices[i] >= edges[0]:\n        i += 1\n    else:\n        minCoins += 1\n    for j in range(len(edges)):\n        if vertices[i] >= edges[j]:\n            i += 1\n        else:\n            minCoins += 1\n    print(minCoins)\nT = int(input())\nwhile T > 0:\n    T -= 1\n    N = int(input())\n    edges = []\n    for i in range(N - 1):\n        x = list(map(int, input().split()))\n        edges.append(x[2])\n    vertices = list(map(int, input().split()))\n    printMinCoins(edges, vertices)", "def printMinCoins(edges, vertices):\n    edges.sort(reverse=True)\n    vertices.sort(reverse=True)\n    edgeCount = len(edges)\n    minCoins = 0\n    i = 0\n    if vertices[i] >= edges[0]:\n        i += 1\n    else:\n        minCoins += 1\n    for j in range(len(edges)):\n        if vertices[i] >= edges[j]:\n            i += 1\n        else:\n            minCoins += 1\n    print(minCoins)\nT = int(input())\nwhile T > 0:\n    T -= 1\n    N = int(input())\n    edges = []\n    for i in range(N - 1):\n        x = list(map(int, input().split()))\n        edges.append(x[2])\n    vertices = list(map(int, input().split()))\n    printMinCoins(edges, vertices)", "def printMinCoins(edges, vertices):\n    edges.sort(reverse=True)\n    vertices.sort(reverse=True)\n    edgeCount = len(edges)\n    minCoins = 0\n    i = 0\n    if vertices[i] >= edges[0]:\n        i += 1\n    else:\n        minCoins += 1\n    for j in range(len(edges)):\n        if vertices[i] >= edges[j]:\n            i += 1\n        else:\n            minCoins += 1\n    print(minCoins)\nT = int(input())\nwhile T > 0:\n    T -= 1\n    N = int(input())\n    edges = []\n    for i in range(N - 1):\n        x = list(map(int, input().split()))\n        edges.append(x[2])\n    vertices = list(map(int, input().split()))\n    printMinCoins(edges, vertices)", "import sys\nT = int(input())\nfor t in range(T):\n    N = int(sys.stdin.readline())\n    nei = [set([]) for _ in range(N + 1)]\n    edge_values = [None] * (N - 1)\n    for n in range(N - 1):\n        (a, b, v) = list(map(int, input().split()))\n        nei[a].add(b)\n        nei[b].add(a)\n        edge_values[n] = v\n    node_values = list(map(int, input().split()))\n    node_values.sort(reverse=True)\n    edge_values.sort(reverse=True)\n    todo = [1]\n    edge_values = [edge_values[0]] + edge_values\n    edgevalidx = 0\n    nodevalidx = 0\n    while todo:\n        node = todo.pop()\n        last_edge = edge_values[edgevalidx]\n        edgevalidx += 1\n        if node_values[nodevalidx] >= last_edge:\n            nodevalidx += 1\n        for neighbour in nei[node]:\n            nei[neighbour].remove(node)\n        todo.extend(nei[node])\n    print(N - nodevalidx)", "import sys\nT = int(input())\nfor t in range(T):\n    N = int(sys.stdin.readline())\n    nei = [set([]) for _ in range(N + 1)]\n    edge_values = [None] * (N - 1)\n    for n in range(N - 1):\n        (a, b, v) = list(map(int, input().split()))\n        nei[a].add(b)\n        nei[b].add(a)\n        edge_values[n] = v\n    node_values = list(map(int, input().split()))\n    node_values.sort(reverse=True)\n    edge_values.sort(reverse=True)\n    visited_nodes = set([])\n    todo = [1]\n    edge_values = [edge_values[0]] + edge_values\n    edgevalidx = 0\n    nodevalidx = 0\n    while todo:\n        node = todo.pop()\n        last_edge = edge_values[edgevalidx]\n        edgevalidx += 1\n        if node_values[nodevalidx] >= last_edge:\n            nodevalidx += 1\n        for neighbour in nei[node]:\n            nei[neighbour].remove(node)\n        todo.extend(nei[node])\n    print(N - nodevalidx)", "T = int(input())\nfor t in range(T):\n    N = int(input())\n    weight = []\n    for i in range(N - 1):\n        weight.append([int(b) for b in input().split()][2])\n    weight.sort(reverse=True)\n    weight = [weight[0]] + weight\n    nodes = [int(b) for b in input().split()]\n    nodes.sort(reverse=True)\n    ans = 0\n    j = 0\n    for i in weight:\n        if i > nodes[j]:\n            ans += 1\n        else:\n            j += 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    weights = []\n    ans = 0\n    for x in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        weights.append(w)\n    weights.sort(reverse=True)\n    weights = [weights[0]] + weights\n    nodes = list(map(int, input().split()))\n    nodes.sort(reverse=True)\n    curr = 0\n    for i in weights:\n        if i > nodes[curr]:\n            ans += 1\n        else:\n            curr += 1\n    print(ans)", "def testcase():\n    n = int(input())\n    edge = []\n    maxx = 0\n    for i in range(n - 1):\n        (u, v, b) = [int(_) for _ in input().split()]\n        edge.append(b)\n        maxx = max(maxx, b)\n    edge.append(maxx)\n    weight = [int(i) for i in input().split()]\n    count = 0\n    edge.sort(reverse=True)\n    weight.sort(reverse=True)\n    j = 0\n    for i in edge:\n        if i > weight[j]:\n            count += 1\n        else:\n            j += 1\n    print(count)\nt = int(input())\nfor test in range(t):\n    testcase()", "def ii():\n    a = int(input())\n    return a\n\ndef ai():\n    a = list(map(int, input().split()))\n    return a\n\ndef mi():\n    a = map(int, input().split())\n    return a\nfor _ in range(ii()):\n    n = ii()\n    e = []\n    for i in range(n - 1):\n        (a, b, c) = mi()\n        e.append(c)\n    v = ai()\n    v.sort(reverse=True)\n    e.sort(reverse=True)\n    ans = 0\n    e.insert(0, e[0])\n    j = 0\n    for i in range(n):\n        ew = e[i]\n        if v[j] < ew:\n            ans += 1\n        else:\n            j += 1\n    print(ans)", "def main(debug=False):\n    for _ in range(int(input())):\n        n = int(input())\n        W = []\n        for i in range(n - 1):\n            (u, v, wi) = map(int, input().split())\n            W.append(wi)\n        N = list(map(int, input().split()))\n        N = sorted(N, reverse=True)\n        W = sorted(W, reverse=True)\n        W.insert(1, W[0])\n        if debug:\n            print('W', W)\n            print('N', N)\n        j = 0\n        cnt = 0\n        for i in W:\n            if debug:\n                print('for W[i]=', i, 'and N[j]=', N[j])\n            if i > N[j]:\n                cnt += 1\n            else:\n                j += 1\n            if debug:\n                print('cnt for this iteration is', cnt)\n        print(cnt)\nmain(debug=False)", "t = int(input())\nfor u in range(t):\n    n = int(input())\n    be = []\n    av = []\n    for i in range(n - 1):\n        (u, v, e) = map(int, input().split())\n        be.append(e)\n    av = [int(x) for x in input().split()]\n    av.sort(reverse=True)\n    be.sort(reverse=True)\n    be.append(be[0])\n    be.sort(reverse=True)\n    j = 0\n    count = 0\n    for i in be:\n        if i > av[j]:\n            count += 1\n        else:\n            j += 1\n    print(count)", "for case in range(int(input())):\n    n = int(input())\n    b = [0] * (n - 1)\n    for i in range(n - 1):\n        st = input().split()\n        b[i] = int(st[-1])\n    a = list(map(int, input().split()))\n    a.sort()\n    b.sort()\n    (vind, eind) = (0, 0)\n    ans = 0\n    while vind < n and eind < n - 1:\n        if a[vind] >= b[eind]:\n            vind += 1\n            eind += 1\n        else:\n            ans += 1\n            vind += 1\n    print(ans)", "T = int(input())\nwhile T:\n    T -= 1\n    N = int(input())\n    e = []\n    for i in range(N - 1):\n        (u, v, w) = map(int, input().split())\n        e.append(w)\n    n = list(map(int, input().split()))\n    n.sort(reverse=True)\n    e.sort(reverse=True)\n    e.insert(1, e[0])\n    count = 0\n    j = 0\n    for i in range(N):\n        if n[j] < e[i]:\n            count += 1\n        else:\n            j += 1\n    print(count)", "for t in range(int(input())):\n    n = int(input())\n    edges = []\n    vertices = []\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split(' '))\n        edges.append(w)\n    vertices = list(map(int, input().split(' ')))\n    edges.sort(key=None, reverse=True)\n    vertices.sort(key=None, reverse=True)\n    edges.insert(0, edges[0])\n    i = 0\n    j = 0\n    ans = 0\n    while i < n and j < n:\n        if vertices[j] >= edges[i]:\n            j += 1\n            i += 1\n        else:\n            ans += 1\n            i += 1\n    print(ans)", "def testcase():\n    n = int(input())\n    node = set()\n    weight = []\n    maximumWeight = 0\n    for i in range(n - 1):\n        (u, v, w) = [int(_) for _ in input().split()]\n        weight.append(w)\n        maximumWeight = max(maximumWeight, w)\n    weight.append(maximumWeight)\n    weight.sort(reverse=True)\n    node = [int(i) for i in input().split()]\n    node.sort(reverse=True)\n    j = 0\n    counter = 0\n    for i in weight:\n        if i > node[j]:\n            counter += 1\n        else:\n            j += 1\n    print(counter)\nt = int(input())\nfor test in range(t):\n    testcase()", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    edges = list(sorted((int(input().split()[-1]) for i in range(n - 1))))\n    nodes = list(sorted(map(int, input().split())))\n    (j, cnt) = (0, 0)\n    for i in range(n - 1):\n        while j < len(nodes) and nodes[j] < edges[i]:\n            j += 1\n            cnt += 1\n        j += 1\n    print(cnt)", "for _ in range(int(input())):\n    n = int(input())\n    a = []\n    for i in range(n - 1):\n        (val1, val2, val3) = list(map(int, input().split()))\n        a.append(val3)\n    a.sort()\n    arr = list(map(int, input().split()))\n    arr.sort()\n    (i, j, ans) = (0, 0, 0)\n    while True:\n        if arr[i] >= a[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n            ans += 1\n        if j == n - 1 or i == n:\n            break\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        (u, v, e) = input().split()\n        edges.append(int(e))\n    vertices = list(map(int, input().split()))\n    vertices.sort()\n    edges.sort()\n    i = 0\n    j = 0\n    cnt = 0\n    while i < n and j < n - 1:\n        if vertices[i] < edges[j]:\n            i += 1\n            cnt += 1\n        else:\n            i += 1\n            j += 1\n    print(cnt)", "t = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    be = []\n    for i in range(n - 1):\n        (ui, vi, bi) = map(int, input().split())\n        be.append(bi)\n    ae = list(map(int, input().split()))\n    be.sort()\n    ae.sort()\n    be = be + [be[-1]]\n    i = len(ae) - 1\n    j = len(be) - 1\n    ans = 0\n    while i >= 0 and j >= 0:\n        if ae[i] < be[j]:\n            ans += 1\n        else:\n            i -= 1\n        j -= 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    b = list()\n    for i in range(n - 1):\n        (u, v, bi) = map(int, input().split())\n        b.append(bi)\n    a = list(map(int, input().split()))\n    a.sort()\n    b.sort()\n    (i, j, ans) = (0, 0, 0)\n    while True:\n        if a[i] >= b[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n            ans += 1\n        if j == n - 1 or i == n:\n            break\n    print(ans)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = []\n    b = []\n    for i in range(n - 1):\n        b.append(int(input().split()[2]))\n    a = list(map(int, input().split()))\n    b.sort(reverse=1)\n    a.sort(reverse=1)\n    ans = 0\n    i = 0\n    j = 0\n    if b[j] > a[i]:\n        ans += 2\n        j += 1\n    else:\n        i += 1\n    while j < n - 1:\n        if b[j] > a[i]:\n            ans += 1\n            j += 1\n        else:\n            i += 1\n            j += 1\n    print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    N = int(input())\n    Adj = defaultdict(list)\n    Ew = []\n    Vertex = defaultdict(int)\n    for i in range(N - 1):\n        (a, b, w) = map(int, input().split())\n        Adj[a].append(b)\n        Adj[b].append(a)\n        Ew.append(w)\n    Vkey = sorted(list(map(int, input().split())))\n    Ew = sorted(Ew)\n    Change = 0\n    if Vkey[-1] < Ew[0]:\n        print(N)\n        continue\n    elif Vkey[0] > Ew[-1]:\n        print('0')\n        continue\n    Start = [1]\n    i = 0\n    while True:\n        NewStart = []\n        if len(Start) == 0:\n            break\n        for x in Start:\n            Neigh = Adj[x]\n            Neighbour = []\n            for ooo in Neigh:\n                if Vertex[ooo] == 0:\n                    Neighbour.append(ooo)\n            for neigh in Neighbour:\n                e = Ew.pop()\n                if Vertex[x] == 0:\n                    if Vkey[-1] >= e:\n                        Vertex[x] = Vkey.pop()\n                    else:\n                        Vertex[x] = e\n                        Change += 1\n                        Vkey[i] = -1\n                        i = i + 1\n                if Vertex[neigh] == 0:\n                    if Vkey[-1] >= e:\n                        Vertex[neigh] = Vkey.pop()\n                    else:\n                        Vertex[neigh] = e\n                        Change += 1\n                        Vkey[i] = -1\n                        i = i + 1\n                if len(Adj[neigh]) > 1:\n                    NewStart.append(neigh)\n        Start = NewStart\n    print(Change)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    ed = []\n    for i in range(n - 1):\n        (l, r, e) = map(int, input().split())\n        ed.append(e)\n    a = list(map(int, input().split()))\n    ed.sort()\n    a.sort()\n    (i, j, res) = (0, 0, 0)\n    while 100:\n        if a[i] >= ed[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n            res += 1\n        if i == n or j == n - 1:\n            break\n    print(res)", "for _ in range(int(input())):\n    N = int(input())\n    V = []\n    E = []\n    k = 0\n    for i in range(N - 1):\n        E.append(int(input().split()[-1]))\n    E.sort(reverse=True)\n    E = [E[0]] + E\n    V = sorted(map(int, input().split()), reverse=True)\n    j = 0\n    for i in E:\n        if V[j] < i:\n            k += 1\n        else:\n            j += 1\n    print(k)", "for _ in range(int(input())):\n    N = int(input())\n    V = []\n    E = []\n    k = 0\n    for i in range(N - 1):\n        E.append(int(input().split()[-1]))\n    E.sort(reverse=True)\n    E = [E[0]] + E\n    V = sorted(map(int, input().split()), reverse=True)\n    j = 0\n    for i in E:\n        if V[j] < i:\n            k += 1\n        else:\n            j += 1\n    print(k)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    vertices = []\n    edges = []\n    for i in range(n - 1):\n        (u, v, b) = map(int, input().split())\n        edges.append(b)\n    vertices = list(map(int, input().split()))\n    edges.sort()\n    vertices.sort()\n    ans = 0\n    (i, j) = (0, 0)\n    while i < n and j < n - 1:\n        if edges[j] <= vertices[i]:\n            j += 1\n            i += 1\n        else:\n            ans += 1\n            i += 1\n    print(ans)", "T = int(input())\nfor t in range(T):\n    N = int(input())\n    edges = []\n    for n in range(N - 1):\n        edges.append(int(input().split()[-1]))\n    vertices = [int(num) for num in input().split()]\n    edges.sort()\n    vertices.sort()\n    edges.append(edges[-1])\n    e = 0\n    v = 0\n    while v < N:\n        if vertices[v] >= edges[e]:\n            e += 1\n        v += 1\n    print(N - e)", "test = int(input())\nfor intnn in range(test):\n    num = int(input())\n    array = []\n    for i in range(num - 1):\n        (val1, val2, val3) = list(map(int, input().split()))\n        array.append(val3)\n    arr = list(map(int, input().split()))\n    arr.sort()\n    array.sort()\n    ar = []\n    for i in range(num):\n        ar.append(i)\n    i = 0\n    j = 0\n    ans = 0\n    while True:\n        if arr[i] >= array[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n            ans += 1\n        if j == num - 1 or i == num:\n            break\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    b = [0] * (n - 1)\n    for i in range(n - 1):\n        (u, v, b[i]) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    b.sort()\n    a.sort()\n    ans = 0\n    (vind, eind) = (0, 0)\n    while vind < n and eind < n - 1:\n        if a[vind] >= b[eind]:\n            vind += 1\n            eind += 1\n        else:\n            ans += 1\n            vind += 1\n    print(ans)", "import numpy as np\ni8 = np.int64\n\ndef solve_core(a, b):\n    i = 0\n    count = 0\n    for j in range(b.shape[0]):\n        while i < a.shape[0]:\n            if a[i] >= b[j]:\n                count += 1\n                i += 1\n                break\n            i += 1\n    if i < a.shape[0]:\n        count += 1\n    return count\n\ndef solve(stdin):\n    N = int(stdin.readline())\n    b = np.empty(N - 1, i8)\n    for i in range(N - 1):\n        (u, v, b[i]) = map(int, stdin.readline().split())\n    a = np.fromstring(stdin.readline(), i8, sep=' ')\n    a.sort()\n    b.sort()\n    res = solve_core(a, b)\n    return N - res\nstdin = open(0)\nT = int(stdin.readline())\nfor _ in range(T):\n    ans = solve(stdin)\n    print(ans)", "from sys import stdin\nt = int(stdin.readline())\n\ndef makeGraph(a, b):\n    idxA = 0\n    idxB = 0\n    k = 0\n    b = [b[0]] + b\n    while idxB < n:\n        node = a[idxA]\n        while idxB < n and node < b[idxB]:\n            k += 1\n            idxB += 1\n        idxA += 1\n        idxB += 1\n    return k\nfor _ in range(t):\n    n = int(stdin.readline())\n    b = []\n    for i in range(n - 1):\n        (ui, vi, bi) = list(map(int, stdin.readline().split()))\n        b.append(bi)\n    a = list(map(int, stdin.readline().split()))\n    a = sorted(a, reverse=True)\n    b = sorted(b, reverse=True)\n    res = makeGraph(a, b)\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    d = {}\n    deg = {}\n    weight = []\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        weight.append(w)\n        if d.get(u) == None:\n            d[u] = [v]\n            deg[u] = 1\n        else:\n            d[u].append(v)\n            deg[u] += 1\n        if d.get(v) == None:\n            d[v] = [u]\n            deg[v] = 1\n        else:\n            d[v].append(u)\n            deg[v] += 1\n    node = list(map(int, input().split()))\n    node.sort(reverse=True)\n    weight.sort(reverse=True)\n    weight.insert(1, weight[0])\n    count = 0\n    j = 0\n    for i in range(n):\n        if weight[i] > node[j]:\n            count += 1\n        else:\n            j += 1\n    print(count)", "for _ in range(int(input())):\n    n = int(input())\n    st = []\n    en = []\n    wt = {}\n    m = []\n    s_e = {}\n    e_s = {}\n    for __ in range(n - 1):\n        (s, e, edj) = map(int, input().split())\n        m.append(edj)\n        s_e[s] = e\n        e_s[e] = s\n    ver = list(map(int, input().split()))\n    m.sort()\n    ver.sort()\n    for i in range(1, n + 1):\n        wt[i] = 0\n    c = 0\n    v = 0\n    e = 0\n    ans = 0\n    while v < n and e < n - 1:\n        i = 1\n        c = 0\n        while i < n + 1 and v < n and (e < n - 1):\n            if v < n and e < n - 1:\n                if wt[i] <= ver[v] and ver[v] >= m[e]:\n                    try:\n                        wt[e_s[i]] = m[e]\n                    except:\n                        wt[s_e[i]] = m[e]\n                    v += 1\n                    e += 1\n                else:\n                    v += 1\n                    ans += 1\n            i += 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    st = []\n    en = []\n    wt = {}\n    m = []\n    s_e = {}\n    e_s = {}\n    for __ in range(n - 1):\n        (s, e, edj) = map(int, input().split())\n        m.append(edj)\n        s_e[s] = e\n        e_s[e] = s\n    ver = list(map(int, input().split()))\n    m.sort()\n    ver.sort()\n    for i in range(1, n + 1):\n        wt[i] = 0\n    c = 0\n    v = 0\n    e = 0\n    ans = 0\n    while v < n and e < n - 1:\n        i = 1\n        c = 0\n        while i < n + 1 and v < n and (e < n - 1):\n            if v < n and e < n - 1:\n                if wt[i] <= ver[v] and ver[v] >= m[e]:\n                    try:\n                        wt[e_s[i]] = m[e]\n                    except:\n                        wt[s_e[i]] = m[e]\n                    v += 1\n                    e += 1\n                else:\n                    v += 1\n                    ans += 1\n            i += 1\n    print(ans)", "from sys import *\n\ndef input():\n    return stdin.readline()\nfor _ in range(int(input())):\n    n = int(input())\n    st = []\n    en = []\n    wt = {}\n    m = []\n    s_e = {}\n    e_s = {}\n    for __ in range(n - 1):\n        (s, e, edj) = map(int, input().split())\n        m.append(edj)\n        s_e[s] = e\n        e_s[e] = s\n    ver = list(map(int, input().split()))\n    m.sort()\n    ver.sort()\n    for i in range(1, n + 1):\n        wt[i] = 0\n    c = 0\n    v = 0\n    e = 0\n    ans = 0\n    while v < n and e < n - 1:\n        i = 1\n        c = 0\n        while i < n + 1 and v < n and (e < n - 1):\n            if v < n and e < n - 1:\n                if wt[i] <= ver[v] and ver[v] >= m[e]:\n                    try:\n                        wt[e_s[i]] = m[e]\n                    except:\n                        wt[s_e[i]] = m[e]\n                    v += 1\n                    e += 1\n                else:\n                    v += 1\n                    ans += 1\n            i += 1\n    print(ans)", "from sys import *\n\ndef input():\n    return stdin.readline()\nfor _ in range(int(input())):\n    n = int(input())\n    st = []\n    en = []\n    cou = {}\n    wt = {}\n    m = []\n    s_e = {}\n    e_s = {}\n    for __ in range(n - 1):\n        (s, e, edj) = map(int, input().split())\n        m.append(edj)\n        s_e[s] = e\n        e_s[e] = s\n        try:\n            cou[s] += 1\n        except:\n            cou[s] = 1\n        try:\n            cou[e] += 1\n        except:\n            cou[e] = 1\n    ver = list(map(int, input().split()))\n    m.sort()\n    ver.sort()\n    for i in range(1, n + 1):\n        wt[i] = 0\n    c = 0\n    v = 0\n    e = 0\n    ans = 0\n    while c != n and v < n and (e < n - 1):\n        i = 1\n        c = 0\n        while i < n + 1 and v < n and (e < n - 1):\n            if v < n and e < n - 1:\n                if wt[i] <= ver[v] and ver[v] >= m[e]:\n                    cou[i] = 0\n                    try:\n                        wt[e_s[i]] = m[e]\n                        cou[e_s[i]] -= 1\n                    except:\n                        wt[s_e[i]] = m[e]\n                        cou[s_e[i]] -= 1\n                    v += 1\n                    e += 1\n                else:\n                    v += 1\n                    ans += 1\n            if cou[i] <= 1:\n                c += 1\n            i += 1\n    print(ans)", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    ew = []\n    for i in range(n - 1):\n        arr = [int(x) for x in input().split()]\n        ew.append(arr[2])\n    vw = [int(x) for x in input().split()]\n    vw.sort()\n    ew.sort()\n    ans = 0\n    vIt = len(vw) - 1\n    eIt = len(ew) - 1\n    req = 2\n    vSize = len(vw)\n    while vSize > 0:\n        if vIt < 0 or eIt < 0:\n            break\n        v1 = vw[vIt]\n        e1 = ew[eIt]\n        if v1 < e1:\n            if req > 0:\n                ans += req\n                vSize -= req\n                req = 0\n            eIt = eIt - 1\n            req = req + 1\n        else:\n            req = req - 1\n            vIt = vIt - 1\n            vSize = vSize - 1\n    print(ans)\n    t = t - 1", "from sys import *\nfrom collections import *\n\ndef input():\n    return stdin.readline()\nfor _ in range(int(input())):\n    n = int(input())\n    b = []\n    for edge in range(n - 1):\n        (x, y, wt) = map(int, input().split())\n        b.append(wt)\n    b.sort()\n    a = deque(sorted([int(i) for i in input().split()]))\n    cnt = 0\n    if a[-1] >= b[-1]:\n        a.pop()\n    else:\n        a.popleft()\n        cnt += 1\n    while len(b) != 0:\n        if a[-1] >= b[-1]:\n            a.pop()\n        else:\n            a.popleft()\n            cnt += 1\n        b.pop()\n    print(cnt)", "for i in range(int(input())):\n    (n, p) = (int(input()), [])\n    for j in range(n - 1):\n        p.append([int(j) for j in input().split()][2])\n    q = sorted([int(j) for j in input().split()])\n    p.sort()\n    (c, j, k) = (n, 0, 0)\n    while k < n:\n        if q[k] >= p[0]:\n            (k, c) = (k + 1, c - 1)\n            break\n        k += 1\n    while k < n and j < n - 2:\n        if q[k] >= p[j] and q[k] >= p[j + 1]:\n            (j, k, c) = (j + 1, k + 1, c - 1)\n        else:\n            k += 1\n    print(c - int(k != n and q[-1] >= p[-1]))", "for i in range(int(input())):\n    n = int(input())\n    p = []\n    for j in range(n - 1):\n        (a, b, c) = [int(j) for j in input().split()]\n        p.append(c)\n    q = [int(j) for j in input().split()]\n    p.sort()\n    q.sort()\n    c = n\n    j = 0\n    k = 0\n    while k < n:\n        if q[k] >= p[0]:\n            k += 1\n            c -= 1\n            break\n        k += 1\n    while k < n and j < n - 2:\n        if q[k] >= p[j] and q[k] >= p[j + 1]:\n            j += 1\n            k += 1\n            c -= 1\n        else:\n            k += 1\n    if k != n:\n        if q[-1] >= p[-1]:\n            c -= 1\n    print(c)", "for _ in range(int(input())):\n    n = int(input())\n    edge_nums = [0] * (n - 1)\n    for i in range(n - 1):\n        (x, y, z) = map(int, input().split())\n        edge_nums[i] = z\n    edge_nums.sort()\n    vertex_nums = list(map(int, input().split()))\n    vertex_nums.sort()\n    j = 0\n    count = 0\n    for i in range(n):\n        if vertex_nums[i] < edge_nums[j]:\n            count += 1\n        else:\n            j += 1\n            if j == n - 1:\n                break\n    print(count)", "T = int(input())\nfor time in range(T):\n    N = int(input())\n    A = []\n    B = []\n    res = 0\n    a1 = 0\n    b1 = 0\n    for itr in range(N - 1):\n        (u, v, b) = map(int, input().split())\n        B.append(b)\n    A = list(map(int, input().split()))\n    A.sort()\n    B.sort()\n    while a1 < N and b1 < N - 1:\n        if A[a1] >= B[b1]:\n            a1 += 1\n            b1 += 1\n        else:\n            a1 += 1\n            res += 1\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    ver = []\n    ed = []\n    for _ in range(n - 1):\n        (a, b, x) = map(int, input().split())\n        ed.append(x)\n    ver = list(map(int, input().split()))\n    ed.sort()\n    ver.sort()\n    answer = 0\n    i = 0\n    j = 0\n    while i < n and j < n - 1:\n        if ver[i] >= ed[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n            answer += 1\n    print(answer)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    vertex = []\n    edge = []\n    l = []\n    for _ in range(n - 1):\n        (a, b, x) = map(int, input().split())\n        l.append([a, b])\n        edge.append(x)\n    vertex = list(map(int, input().split()))\n    edge.sort()\n    vertex.sort()\n    ans = 0\n    i = 0\n    j = 0\n    while i < n and j < n - 1:\n        if vertex[i] >= edge[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n            ans += 1\n    print(ans)", "for t in range(int(input())):\n    n = int(input())\n    e = []\n    for i in range(n - 1):\n        (x, y, z) = map(int, input().split())\n        e.append(z)\n    e.sort()\n    v = list(map(int, input().split()))\n    v.sort()\n    h = [0] * (n - 1)\n    hind = 0\n    vind = 0\n    while hind < n - 1 and vind < n:\n        if v[vind] < e[hind]:\n            vind += 1\n            continue\n        if v[vind] >= e[hind]:\n            h[hind] = vind\n            hind += 1\n            continue\n    if hind < n - 1:\n        for i in range(hind, n - 1):\n            h[i] = vind\n    ans = 0\n    for i in range(n - 1):\n        ans += max(0, h[i] - i - ans)\n    print(ans)", "import collections\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    adj = [[] for i in range(n + 1)]\n    a = []\n    b = []\n    for i in range(n - 1):\n        (x, y, z) = map(int, input().split())\n        adj[x].append(y)\n        b.append(z)\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    (root, x, y) = (1, 0, 0)\n    coins = 0\n    if a[0] >= b[0]:\n        x += 1\n    else:\n        coins = 1\n    queue = collections.deque([root])\n    sz = 1\n    while queue:\n        vertex = queue.popleft()\n        sz -= 1\n        for neighbour in adj[vertex]:\n            queue.append(neighbour)\n        if sz == 0:\n            sz = len(queue)\n            for _ in queue:\n                if a[x] >= b[y]:\n                    x += 1\n                else:\n                    coins += 1\n                y += 1\n    print(coins)", "def DecimalToBinary(num):\n    if num > 1:\n        DecimalToBinary(num // 2)\nfrom math import ceil, log2\n\ndef getMid(s, e):\n    return s + (e - s) // 2\n\ndef getSumUtil(st, ss, se, qs, qe, si):\n    if qs <= ss and qe >= se:\n        return st[si]\n    if se < qs or ss > qe:\n        return 0\n    mid = getMid(ss, se)\n    return getSumUtil(st, ss, mid, qs, qe, 2 * si + 1) + getSumUtil(st, mid + 1, se, qs, qe, 2 * si + 2)\n\ndef updateValueUtil(st, ss, se, i, diff, si):\n    if i < ss or i > se:\n        return\n    st[si] = st[si] + diff\n    if se != ss:\n        mid = getMid(ss, se)\n        updateValueUtil(st, ss, mid, i, diff, 2 * si + 1)\n        updateValueUtil(st, mid + 1, se, i, diff, 2 * si + 2)\n\ndef updateValue(arr, st, n, i, new_val):\n    if i < 0 or i > n - 1:\n        print('Invalid Input', end='')\n        return\n    diff = new_val - arr[i]\n    arr[i] = new_val\n    updateValueUtil(st, 0, n - 1, i, diff, 0)\n\ndef getSum(st, n, qs, qe):\n    if qs < 0 or qe > n - 1 or qs > qe:\n        print('Invalid Input', end='')\n        return -1\n    return getSumUtil(st, 0, n - 1, qs, qe, 0)\n\ndef constructSTUtil(arr, ss, se, st, si):\n    if ss == se:\n        st[si] = arr[ss]\n        return arr[ss]\n    mid = getMid(ss, se)\n    st[si] = constructSTUtil(arr, ss, mid, st, si * 2 + 1) + constructSTUtil(arr, mid + 1, se, st, si * 2 + 2)\n    return st[si]\n\ndef constructST(arr, n):\n    x = int(ceil(log2(n)))\n    max_size = 2 * int(2 ** x) - 1\n    st = [0] * max_size\n    constructSTUtil(arr, 0, n - 1, st, 0)\n    return st\nu1 = 0\nu2 = 113423443243442434\nu3 = u1 + u2\nu1 = 0\nu2 = 113423443243442434\nu3 = u1 + u2\nu1 = 0\nu2 = 113423443243442434\nu3 = u1 + u2\nu1 = 0\nu2 = 113423443243442434\nu3 = u1 + u2\nu1 = 0\nu2 = 113423443243442434\nu3 = u1 + u2\nu1 = 0\nu2 = 113423443243442434\nu3 = u1 + u2\nfor chandrima in range(int(input())):\n    sandeep = []\n    somdutta = []\n    rashmi = int(input())\n    for arnab in range(rashmi - 1):\n        (debanjan, soham, shahid) = [int(x) for x in input().split()]\n        sandeep.append(shahid)\n    somdutta = list(map(int, input().split()))\n    sandeep.sort()\n    somdutta.sort()\n    estrossa = 0\n    meliodas = 0\n    sfnjsjadjadjadjadaash = 0\n    justforfun = 1\n    while estrossa < rashmi - 1 and meliodas < rashmi:\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        justforfun += 1\n        justforfun -= 1\n        while somdutta[meliodas] < sandeep[estrossa]:\n            justforfun += 1\n            justforfun -= 1\n            meliodas += 1\n            sfnjsjadjadjadjadaash += 1\n            if meliodas == rashmi:\n                break\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n                u1 = 0\n                u2 = 113423443243442434\n                u3 = u1 + u2\n        estrossa += 1\n        meliodas += 1\n    u1 = 0\n    u2 = 113423443243442434\n    u3 = u1 + u2\n    u1 = 0\n    u2 = 113423443243442434\n    u3 = u1 + u2\n    u1 = 0\n    u2 = 113423443243442434\n    u3 = u1 + u2\n    print(sfnjsjadjadjadjadaash)\nif False:\n    num = 276768623 + 2112\n    if num % 2 == 0:\n        u1 = 1\n    else:\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2\n        u1 = 0\n        u2 = 113423443243442434\n        u3 = u1 + u2", "T = int(input())\nfor i in range(T):\n    N = int(input())\n    b = []\n    a = []\n    for j in range(N - 1):\n        edge = input().split()\n        b.append(int(edge[2]))\n    vertex_values = input().split()\n    for j in range(N):\n        a.append(int(vertex_values[j]))\n    a.sort()\n    b.sort()\n    great = len(a) * [0]\n    pos_b = 0\n    pos_a = 0\n    while pos_b < N - 1 and pos_a < N:\n        if b[pos_b] <= a[pos_a]:\n            pos_b += 1\n        else:\n            great[pos_a] = pos_b\n            pos_a += 1\n    while pos_a < N:\n        great[pos_a] = N - 1\n        pos_a += 1\n    coins = 0\n    desired = list(range(1, N))\n    desired.append(N - 1)\n    for j in range(0, N):\n        if great[j] < desired[j - coins]:\n            coins += 1\n    print(coins)", "from collections import deque\n\ndef bfs(tree, edges, nodes):\n    coins = 0\n    visited = [False] * len(nodes)\n    (i, j) = (0, len(nodes) - 1)\n    if edges and nodes[i] >= edges[len(edges) - 1]:\n        i += 1\n    else:\n        j -= 1\n        coins += 1\n    q = deque([1])\n    visited[0] = True\n    while q:\n        s = q.popleft()\n        for v in tree[s]:\n            if not visited[v - 1]:\n                if edges and nodes[i] >= edges[len(edges) - 1]:\n                    i += 1\n                else:\n                    j -= 1\n                    coins += 1\n                edges.pop()\n                visited[v - 1] = True\n                q.append(v)\n    return coins\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    graph = dict()\n    edgeWeights = list()\n    for i in range(1, N):\n        (u, v, w) = map(int, input().split())\n        graph.setdefault(u, list()).append(v)\n        graph.setdefault(v, list()).append(u)\n        edgeWeights.append(w)\n    nodeWeights = list(map(int, input().split()))\n    edgeWeights.sort()\n    nodeWeights.sort(reverse=True)\n    print(bfs(graph, edgeWeights, nodeWeights))", "import collections\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    adj = [[] for i in range(n + 1)]\n    a = []\n    b = []\n    for i in range(n - 1):\n        (x, y, z) = map(int, input().split())\n        adj[x].append(y)\n        b.append(z)\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    index = 0\n    mx = 0\n    root = 1\n    coins = 0\n    if a[0] >= b[0]:\n        coins = 0\n        a.pop(0)\n    else:\n        coins = 1\n        a.pop(-1)\n    x = 0\n    y = 0\n    queue = collections.deque([root])\n    sz = 1\n    while queue:\n        vertex = queue.popleft()\n        sz -= 1\n        for neighbour in adj[vertex]:\n            queue.append(neighbour)\n        if sz == 0:\n            sz = len(queue)\n            for _ in queue:\n                if a[x] >= b[y]:\n                    x += 1\n                else:\n                    coins += 1\n                    a.pop()\n                y += 1\n    print(coins)", "from sys import stdin, stdout\ntry:\n    testcase = stdin.readline()\n    for __ in range(0, int(testcase)):\n        m = stdin.readline()\n        m = int(m)\n        b = []\n        for i in range(0, m - 1):\n            b1 = [int(_) for _ in stdin.readline().split()]\n            b.append(b1[2])\n        b = sorted(b)\n        a = [int(_) for _ in stdin.readline().split()]\n        a = sorted(a)\n        (ans, j) = (0, 0)\n        for i in a:\n            if i >= b[j]:\n                j += 1\n            else:\n                ans += 1\n            if j == m - 1:\n                break\n        print(ans)\nexcept:\n    pass", "from sys import stdin, stdout\nn = stdin.readline()\nn = int(n)\nwhile n:\n    n -= 1\n    m = stdin.readline()\n    m = int(m)\n    b = []\n    for i in range(0, m - 1):\n        bb = [int(x) for x in stdin.readline().split()]\n        b.append(bb[2])\n    a = [int(x) for x in stdin.readline().split()]\n    b = sorted(b)\n    a = sorted(a)\n    c = 0\n    j = 0\n    for i in range(0, m):\n        if a[i] >= b[j]:\n            j += 1\n        else:\n            c += 1\n        if j == len(b):\n            break\n    print(c)", "for i in range(int(input())):\n    n = int(input())\n    e = []\n    for i in range(n - 1):\n        l = list(map(int, input().split()))\n        e.append(l[2])\n    v = list(map(int, input().split()))\n    e = sorted(e)\n    v = sorted(v)\n    p = e[-1]\n    q = v[-1]\n    if p > q:\n        ans = 2\n        e.pop()\n        v.pop(0)\n        v.pop(0)\n    elif p > v[-2]:\n        ans = 1\n        e.pop()\n        v.pop(0)\n        v.pop()\n    else:\n        ans = 0\n        e.pop()\n        v.pop()\n        v.pop()\n    a = n - 2\n    while a > 0:\n        a -= 1\n        if e[-1] <= v[-1]:\n            e.pop()\n            v.pop()\n        else:\n            ans += 1\n            e.pop()\n    print(ans)", "T = int(input())\nfor i in range(0, T):\n    N = int(input())\n    e = []\n    r = []\n    v = []\n    h = 0\n    o = 0\n    for j in range(0, N - 1):\n        e = input().split(' ')\n        r.append(int(e[2]))\n    v = list(map(int, input().split()))\n    v.sort()\n    r.sort()\n    wa = N - 2\n    w = N - 2\n    z = r[N - 2]\n    while wa >= 0:\n        if v[w] < r[wa] and v[w + 1] < r[wa]:\n            v.append(z)\n            v.append(z)\n            w = w + 2\n            o += 2\n        elif v[w] < r[wa]:\n            v.append(z)\n            w += 1\n            o += 1\n        w -= 1\n        wa -= 1\n    print(o)", "class doublylinkedlist:\n\n    class _Node:\n        __slots__ = ('data', 'prev', 'next')\n\n        def __init__(self, data, prev, next):\n            self.data = data\n            self.prev = prev\n            self.next = next\n\n    def __init__(self):\n        self.head = self._Node(None, None, None)\n        self.tail = self._Node(None, None, None)\n        self.tail.prev = self.head\n        self.head.next = self.tail\n        self.size = 0\n\n    def is_empty(self):\n        return self.size == 0\n\n    def add_last(self, value):\n        new_node = self._Node(value, None, None)\n        if self.is_empty():\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            new_node.prev = self.tail\n        self.tail = new_node\n        self.size += 1\n\n    def remove_first(self):\n        value = self.head.data\n        self.head = self.head.next\n        self.head.prev = None\n        self.size -= 1\n        if self.is_empty():\n            self.tail = None\n        return value\n\n    def remove_last(self):\n        value = self.tail.data\n        self.tail = self.tail.prev\n        self.tail.next = None\n        self.size -= 1\n        if self.is_empty():\n            self.head = None\n        return value\nfor _ in range(int(input())):\n    n = int(input())\n    edge = list()\n    for i in range(n - 1):\n        (a, b, c) = map(int, input().split())\n        edge.append(c)\n    arr = list(map(int, input().split()))\n    arr.sort()\n    edge.sort()\n    dll = doublylinkedlist()\n    for i in range(n):\n        dll.add_last(arr[i])\n    ans = 0\n    for i in range(n - 2, -1, -1):\n        (t1, t2) = (dll.tail.data, dll.tail.prev.data)\n        if t1 >= edge[i] and t2 >= edge[i]:\n            dll.remove_last()\n            continue\n        else:\n            if t1 < edge[i]:\n                ans += 2\n                dll.remove_first()\n                dll.remove_first()\n                dll.add_last(edge[i])\n                dll.add_last(edge[i])\n            elif t2 < edge[i]:\n                ans += 1\n                dll.remove_first()\n                dll.add_last(edge[i])\n            dll.remove_last()\n    print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    adj = defaultdict(list)\n    edgeWeights = []\n    vertices = defaultdict(int)\n    vertexWeights = []\n    for _ in range(n - 1):\n        (u, v, b) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edgeWeights.append(b)\n    vertexWeights = sorted(map(int, input().split()))\n    edgeWeights.sort()\n    cost = 0\n    initial = 0\n    toVisit = [1]\n    weight = edgeWeights.pop()\n    while toVisit:\n        newToVisit = []\n        for vertex in toVisit:\n            adjs = adj[vertex]\n            notVisited = []\n            for adjVertex in adjs:\n                if not vertices[adjVertex]:\n                    notVisited.append(adjVertex)\n            if not vertices[vertex]:\n                if vertexWeights[-1] >= weight:\n                    vertices[vertex] = vertexWeights.pop()\n                else:\n                    cost += 1\n                    vertices[vertex] = weight\n                    vertexWeights[initial] = 0\n                    initial += 1\n            for adjVertex in notVisited:\n                if vertexWeights[-1] >= weight:\n                    vertices[adjVertex] = vertexWeights.pop()\n                else:\n                    cost += 1\n                    vertices[adjVertex] = weight\n                    vertexWeights[initial] = 0\n                    initial += 1\n                try:\n                    weight = edgeWeights.pop()\n                except:\n                    pass\n                if len(adj[adjVertex]) > 1:\n                    newToVisit.append(adjVertex)\n        toVisit = newToVisit\n    print(cost)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    edge = []\n    for i in range(n - 1):\n        (u, v, b) = [int(i) for i in input().split()]\n        edge.append(b)\n    edge.sort()\n    vertex = [int(i) for i in input().split()]\n    vertex.sort()\n    error = 0\n    vv = 0\n    ee = 0\n    while vv < n and ee < n - 1:\n        while vv < n and vertex[vv] < edge[ee]:\n            error += 1\n            vv += 1\n        ee += 1\n        vv += 1\n    print(error)", "for _ in range(int(input())):\n    n = int(input())\n    if n < 200:\n        deg = [0] * n\n        graph = [[] for i in range(n + 1)]\n        edg = []\n        for i in range(n - 1):\n            (a, b, c) = map(int, input().split())\n            graph[a].append(b)\n            graph[b].append(a)\n            deg[a - 1] += 1\n            deg[b - 1] += 1\n            edg.append(c)\n        ve = list(map(int, input().split()))\n        ve.sort()\n        edg.sort()\n        ep = 0\n        vp = 0\n        ans = 0\n        while True:\n            di = min(deg)\n            if di == 0 or di > 10 ** 9:\n                break\n            fl = 0\n            while fl == 0:\n                k = ep\n                for i in range(di):\n                    if edg[k] > ve[vp]:\n                        fl = 0\n                        break\n                    k += 1\n                    fl = 1\n                if fl == 0:\n                    vp += 1\n                    ve.append(10 ** 9 + 1)\n                    ans += 1\n                else:\n                    ep = k\n                    vp += 1\n            x = deg.index(di)\n            deg[x] = 10 ** 9 + 1\n            for i in graph[x + 1]:\n                deg[i - 1] -= 1\n        print(ans)\n    else:\n        deg = [0] * n\n        graph = [[] for i in range(n + 1)]\n        edg = []\n        for i in range(n - 1):\n            (a, b, c) = map(int, input().split())\n            graph[a].append(b)\n            graph[b].append(a)\n            deg[a - 1] += 1\n            deg[b - 1] += 1\n            edg.append(c)\n        ve = list(map(int, input().split()))\n        ve.sort()\n        edg.sort()\n        op = set()\n        for i in range(n):\n            if deg[i] == 1:\n                op.add(i)\n        ep = 0\n        vp = 0\n        ans = 0\n        while True:\n            if ep == n - 2:\n                break\n            if len(op) == 1:\n                break\n            di = 1\n            if di == 0 or di > 10 ** 9:\n                break\n            fl = 0\n            while fl == 0:\n                k = ep\n                for i in range(di):\n                    if edg[k] > ve[vp]:\n                        fl = 0\n                        break\n                    k += 1\n                    fl = 1\n                if fl == 0:\n                    vp += 1\n                    ve.append(10 ** 9 + 1)\n                    ans += 1\n                else:\n                    ep = k\n                    vp += 1\n        print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    N = int(input())\n    Adj = defaultdict(list)\n    Ew = []\n    Vertex = defaultdict(int)\n    for i in range(N - 1):\n        (a, b, w) = map(int, input().split())\n        Adj[a].append(b)\n        Adj[b].append(a)\n        Ew.append(w)\n    Vkey = sorted(list(map(int, input().split())))\n    Ew = sorted(Ew)\n    Change = 0\n    if Vkey[-1] < Ew[0]:\n        print(N)\n        continue\n    elif Vkey[0] > Ew[-1]:\n        print('0')\n        continue\n    Start = [1]\n    i = 0\n    while True:\n        NewStart = []\n        if len(Start) == 0:\n            break\n        for x in Start:\n            Neigh = Adj[x]\n            Neighbour = []\n            for ooo in Neigh:\n                if Vertex[ooo] == 0:\n                    Neighbour.append(ooo)\n            for neigh in Neighbour:\n                e = Ew.pop()\n                if Vertex[x] == 0:\n                    if Vkey[-1] >= e:\n                        Vertex[x] = Vkey.pop()\n                    else:\n                        Vertex[x] = e\n                        Change += 1\n                        Vkey[i] = -1\n                        i = i + 1\n                if Vertex[neigh] == 0:\n                    if Vkey[-1] >= e:\n                        Vertex[neigh] = Vkey.pop()\n                    else:\n                        Vertex[neigh] = e\n                        Change += 1\n                        Vkey[i] = -1\n                        i = i + 1\n                if len(Adj[neigh]) > 1:\n                    NewStart.append(neigh)\n        Start = NewStart\n    print(Change)", "from collections import defaultdict\nfor _ in range(int(input())):\n    N = int(input())\n    Adj = defaultdict(list)\n    Ew = []\n    Vertex = defaultdict(int)\n    for i in range(N - 1):\n        (a, b, w) = map(int, input().split())\n        Adj[a].append(b)\n        Adj[b].append(a)\n        Ew.append(w)\n    Vkey = sorted(list(map(int, input().split())))\n    Ew = sorted(Ew)\n    Change = 0\n    if Vkey[-1] < Ew[0]:\n        print(N)\n        continue\n    elif Vkey[0] > Ew[-1]:\n        print('0')\n        continue\n    Start = [1]\n    i = 0\n    while True:\n        NewStart = []\n        if len(Start) == 0:\n            break\n        for x in Start:\n            Neigh = Adj[x]\n            Neighbour = []\n            for ooo in Neigh:\n                if Vertex[ooo] == 0:\n                    Neighbour.append(ooo)\n            for neigh in Neighbour:\n                e = Ew.pop()\n                if Vertex[x] == 0:\n                    if Vkey[-1] >= e:\n                        Vertex[x] = Vkey.pop()\n                    else:\n                        Vertex[x] = e\n                        Change += 1\n                        Vkey[i] = -1\n                        i = i + 1\n                if Vertex[neigh] == 0:\n                    if Vkey[-1] >= e:\n                        Vertex[neigh] = Vkey.pop()\n                    else:\n                        Vertex[neigh] = e\n                        Change += 1\n                        Vkey[i] = -1\n                        i = i + 1\n                if len(Adj[neigh]) > 1:\n                    NewStart.append(neigh)\n        Start = NewStart\n    print(Change)", "from collections import defaultdict\nfor _ in range(int(input())):\n    N = int(input())\n    Adj = defaultdict(list)\n    Ew = []\n    Vertex = defaultdict(int)\n    for i in range(N - 1):\n        (a, b, w) = map(int, input().split())\n        Adj[a].append(b)\n        Adj[b].append(a)\n        Ew.append(w)\n    Vkey = sorted(list(map(int, input().split())))\n    Ew = sorted(Ew)\n    Change = 0\n    if Vkey[-1] < Ew[0]:\n        print(N)\n        continue\n    elif Vkey[0] > Ew[-1]:\n        print('0')\n        continue\n    Start = [1]\n    i = 0\n    while True:\n        NewStart = []\n        if len(Start) == 0:\n            break\n        for x in Start:\n            Neigh = Adj[x]\n            Neighbour = []\n            for ooo in Neigh:\n                if Vertex[ooo] == 0:\n                    Neighbour.append(ooo)\n            for neigh in Neighbour:\n                e = Ew.pop()\n                if Vertex[x] == 0:\n                    if Vkey[-1] >= e:\n                        Vertex[x] = Vkey.pop()\n                    else:\n                        Vertex[x] = e\n                        Change += 1\n                        Vkey[i] = -1\n                        i = i + 1\n                if Vertex[neigh] == 0:\n                    if Vkey[-1] >= e:\n                        Vertex[neigh] = Vkey.pop()\n                    else:\n                        Vertex[neigh] = e\n                        Change += 1\n                        Vkey[i] = -1\n                        i = i + 1\n                if len(Adj[neigh]) > 1:\n                    NewStart.append(neigh)\n        Start = NewStart\n    print(Change)", "test = int(input())\nfor k in range(test):\n    vertices = int(input())\n    edges = []\n    vv = []\n    for i in range(vertices - 1):\n        arr = list(map(int, input().split()))\n        edges.append(arr[2])\n    vv = list(map(int, input().split()))\n    vv.sort()\n    edges.sort()\n    coins = 0\n    if vv[vertices - 1] < edges[vertices - 2]:\n        vv[0] = edges[vertices - 2]\n        vv[1] = edges[vertices - 2]\n        coins += 2\n    elif vv[vertices - 1] >= edges[vertices - 2] and edges[vertices - 2] > vv[vertices - 2]:\n        vv[0] = edges[vertices - 2]\n        coins += 1\n    vv.sort()\n    p1 = vertices - 2\n    for p2 in range(vertices - 2, -1, -1):\n        if vv[p1] >= edges[p2]:\n            p1 -= 1\n        else:\n            coins += 1\n    print(coins)", "maxi = None\nans = 0\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n        self.v = 1\n\ndef insertNode(root, data, par):\n    if root is None:\n        if data <= par.data:\n            par.left = Node(data)\n        else:\n            par.right = Node(data)\n        return\n    if data <= root.data:\n        insertNode(root.left, data, root)\n    else:\n        insertNode(root.right, data, root)\n\ndef findJustMax(data, root):\n    global maxi\n    if root is None:\n        return\n    if data >= root.data and root.v == 1:\n        if maxi is None or root.data > maxi.data:\n            maxi = root\n        findJustMax(data, root.right)\n    else:\n        findJustMax(data, root.left)\n\ndef giveAns(root):\n    global ans\n    if root is None:\n        return\n    if root.v == 1:\n        ans += 1\n    giveAns(root.left)\n    giveAns(root.right)\nfor h in range(int(input())):\n    N = int(input())\n    w = []\n    for _ in range(N - 1):\n        w.append(int(input().strip().split()[2]))\n    a = list(map(int, input().strip().split()))\n    req = [max(w)] + w\n    req.sort()\n    a.sort()\n    c = 0\n    j = 0\n    for i in a:\n        if i >= req[j]:\n            j += 1\n        else:\n            c += 1\n    print(c)", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    eWeights = []\n    for i in range(N - 1):\n        eWeights.append([int(x) for x in input().strip().split()])\n    nWeights = [int(x) for x in input().strip().split()]\n    n = len(nWeights)\n    edgeWeights = []\n    nodeWeights = []\n    for (u, v, w) in eWeights:\n        edgeWeights.append(w)\n    INF = 10 ** 10\n    nodeWeights = nWeights\n    edgeWeights.sort()\n    nodeWeights.sort()\n    count = 0\n    i = 0\n    j = 0\n    if n > 1000:\n        while True:\n            if i == len(edgeWeights) - 1:\n                break\n            if i == len(edgeWeights) - 1:\n                if nodeWeights[j] >= edgeWeights[i]:\n                    if nodeWeights[j + 1] >= edgeWeights[i]:\n                        break\n                if nodeWeights[j + 1] < edgeWeights[i]:\n                    count += 2\n                    break\n            if nodeWeights[j] >= edgeWeights[i]:\n                j += 1\n                i += 1\n            else:\n                j += 1\n                nodeWeights.append(10 ** 10)\n                count += 1\n    else:\n        while True:\n            if len(edgeWeights) == 0:\n                break\n            if len(edgeWeights) == 1:\n                if nodeWeights[0] >= edgeWeights[0] or nodeWeights[0] == INF:\n                    if nodeWeights[1] >= edgeWeights[0] or nodeWeights[1] == INF:\n                        break\n                if nodeWeights[1] < edgeWeights[0] and nodeWeights[1] != INF:\n                    count += 2\n                    break\n            if nodeWeights[0] >= edgeWeights[0] or nodeWeights[0] == INF:\n                edgeWeights = edgeWeights[1:]\n                nodeWeights = nodeWeights[1:]\n            else:\n                nodeWeights = nodeWeights[1:]\n                nodeWeights.append(INF)\n                count += 1\n    print(count)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    b = []\n    for i in range(n - 1):\n        (x, y, z) = list(map(int, input().split()))\n        b.append(z)\n    a = list(map(int, input().split()))\n    a.sort()\n    b.sort()\n    i = 0\n    j = 0\n    count = 0\n    while True:\n        if a[i] >= b[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n            count += 1\n        if j == n - 1 or i == n:\n            break\n    print(count)", "from collections import deque\ntest = int(input())\nfor _ in range(test):\n    N = int(input())\n    graph = [[] for i in range(N + 1)]\n    es = []\n    for i in range(N - 1):\n        (u, v, val) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n        es.append(val)\n    vs = [int(x) for x in input().split()]\n    es.sort(reverse=True)\n    vs.sort(reverse=True)\n    coins = 0\n    used = [False for i in range(N + 1)]\n    q = deque([1])\n    used[1] = True\n    max_vals = [0 for i in range(N)]\n    es.insert(0, es[0])\n    e_ind = 0\n    bfs = []\n    while len(q) != 0:\n        v = q[0]\n        q.popleft()\n        max_vals[v - 1] = es[e_ind]\n        e_ind += 1\n        bfs.append(v - 1)\n        for u in graph[v]:\n            if not used[u]:\n                used[u] = True\n                q.append(u)\n    coins = 0\n    v_ind = 0\n    for i in bfs:\n        if max_vals[i] > vs[v_ind]:\n            coins += 1\n        else:\n            v_ind += 1\n    print(coins)", "t = int(input())\nwhile t:\n    n = int(input())\n    b = [0] * (n - 1)\n    for i in range(0, n - 1):\n        (u, v, b[i]) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    a.sort()\n    b.sort()\n    cnt = 0\n    j = 0\n    i = 0\n    while i < n - 1 and j < n:\n        if b[i] > a[j]:\n            cnt += 1\n        else:\n            i += 1\n        j += 1\n    print(cnt)\n    t -= 1", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    u = []\n    v = []\n    b = []\n    l = []\n    ans = 0\n    for k in range(0, n - 1):\n        (p, q, r) = map(int, input().split(' '))\n        u.append(p)\n        v.append(q)\n        b.append(r)\n    a = list(map(int, input().split(' ')))\n    b.sort()\n    a.sort()\n    pa = n - 2\n    p = n - 2\n    j = b[n - 2]\n    while pa >= 0:\n        if a[p] < b[pa] and a[p + 1] < b[pa]:\n            a.append(j)\n            a.append(j)\n            p = p + 2\n            ans = ans + 2\n        elif a[p] < b[pa]:\n            a.append(j)\n            p = p + 1\n            ans = ans + 1\n        p = p - 1\n        pa = pa - 1\n    print(ans)", "for _ in range(int(input())):\n    N = int(input())\n    alist = [[] for i in range(N)]\n    ewt = []\n    for i in range(N - 1):\n        (u, v, b) = [int(j) for j in input().split()]\n        (u, v) = (u - 1, v - 1)\n        ewt.append(b)\n        alist[u].append(v)\n        alist[v].append(u)\n    ewt.sort(reverse=True)\n    ewt_i = 0\n    vwt = sorted([int(i) for i in input().split()], reverse=True)\n    (vwt_start, vwt_end) = (0, len(vwt) - 1)\n    coins = 0\n    (start, __) = max(enumerate(alist), key=lambda x: len(x[1]))\n    q = [start]\n    unvisited = [True] * N\n    nbs = alist\n    unvisited[start] = False\n    if vwt[vwt_start] < ewt[0]:\n        coins += 1\n        vwt_end -= 1\n    else:\n        vwt_start += 1\n    while q:\n        curr = q.pop(0)\n        for v in nbs[curr]:\n            if unvisited[v]:\n                vewt = ewt[ewt_i]\n                ewt_i += 1\n                if vewt <= vwt[vwt_start]:\n                    vvwt = vwt[vwt_start]\n                    vwt_start += 1\n                else:\n                    vvwt = vwt[vwt_end]\n                    vwt_end -= 1\n                coins += vewt > vvwt\n                q.append(v)\n                unvisited[curr] = False\n    print(coins)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    u = []\n    v = []\n    b = []\n    l = []\n    ans = 0\n    for k in range(0, n - 1):\n        (p, q, r) = map(int, input().split(' '))\n        u.append(p)\n        v.append(q)\n        b.append(r)\n    a = list(map(int, input().split(' ')))\n    b.sort()\n    a.sort()\n    pa = n - 2\n    p = n - 2\n    j = b[n - 2]\n    while pa >= 0:\n        if a[p] < b[pa]:\n            if a[p + 1] < b[pa]:\n                a.append(j)\n                a.append(j)\n                p = p + 2\n                ans = ans + 2\n            else:\n                a.append(j)\n                p = p + 1\n                ans = ans + 1\n        p = p - 1\n        pa = pa - 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    edges = []\n    for i in range(n - 1):\n        inp = list(map(int, input().strip().split(' ')))\n        edges.append(inp[2])\n    ver = list(map(int, input().strip().split(' ')))\n    edges.sort()\n    ver.sort()\n    count = 0\n    i = 0\n    j = 0\n    while i < n and j < n - 1:\n        if edges[j] <= ver[i]:\n            j += 1\n            i += 1\n        else:\n            count += 1\n            i += 1\n    print(count)", "T = int(input())\nfor i in range(T):\n    N = int(input())\n    E = []\n    for j in range(N - 1):\n        (a, b, c) = map(int, input().split())\n        E.append(c)\n    V = list(map(int, input().split()))\n    V.sort()\n    E.sort()\n    E.append(0)\n    ans = 0\n    index = 0\n    for j in V:\n        if j >= E[index]:\n            index += 1\n        else:\n            ans += 1\n    print(ans)", "T = int(input())\nwhile T:\n    T = T - 1\n    N = int(input())\n    weight = []\n    for edge in range(N - 1):\n        temp = input()\n        a = temp.split(' ')\n        weight.append(int(a[2]))\n    vertice = []\n    temp = input()\n    b = temp.split(' ')\n    for i in b:\n        vertice.append(int(i))\n    ans = 0\n    weight.sort()\n    vertice.sort()\n    i = N - 2\n    o = N - 2\n    k = 0\n    j = weight[N - 2] + 1\n    while i >= 0:\n        if vertice[o] < weight[i]:\n            if vertice[o + 1] < weight[i]:\n                vertice.append(j)\n                vertice.append(j)\n                o = o + 2\n                ans = ans + 2\n            else:\n                vertice.append(j)\n                o = o + 1\n                ans = ans + 1\n        o = o - 1\n        i = i - 1\n    print(ans)", "t = int(input())\nfor i in range(t):\n    N = int(input())\n    edges = [0 for x in range(N - 1)]\n    for p in range(N - 1):\n        (_, _, edges[p]) = [int(x) for x in input().split()]\n    vertices = [int(x) for x in input().split()]\n    vertices.sort()\n    edges.sort()\n    max1 = 0\n    count = 0\n    for t in range(N - 1):\n        if vertices[t] >= edges[max1]:\n            max1 += 1\n        else:\n            count += 1\n    if max1 < N - 1:\n        if vertices[-1] < edges[max1]:\n            count += 1\n    print(count)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    edge = []\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (a, b, c) = [int(x) for x in input().split()]\n        edge.append(c)\n    vertex = [int(x) for x in input().split()]\n    vertex = sorted(vertex, reverse=True)\n    edge = sorted(edge, reverse=True)\n    j = 1\n    count = 0\n    if vertex[0] < edge[0]:\n        count += 1\n        j = 0\n    for i in range(n - 1):\n        if vertex[j] < edge[i]:\n            count += 1\n            j -= 1\n        j += 1\n    print(count)", "from collections import OrderedDict\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    dict = {}\n    mx = int(0)\n    for i in range(n - 1):\n        (x, y, z) = map(int, input().split())\n        if dict.get(z) == None:\n            dict[z] = -1\n        else:\n            dict[z] -= 1\n        mx = max(mx, z)\n    l = list(map(int, input().split()))\n    for i in range(n):\n        if dict.get(l[i]) == None:\n            dict[l[i]] = 1\n        else:\n            dict[l[i]] += 1\n        mx = max(mx, l[i])\n    pop_ele = dict.pop(mx)\n    z = int(0)\n    c = int(0)\n    for i in sorted(dict.keys()):\n        z += dict[i]\n        c = max(c, z)\n    print(c)", "for _ in range(int(input())):\n    n = int(input())\n    arr_real = []\n    for _ in range(n - 1):\n        (a, b, val) = map(int, input().split())\n        arr_real.append(val)\n    arr_given = list(map(int, input().split()))\n    arr_real.sort(reverse=True)\n    arr_real = [arr_real[0]] + arr_real\n    arr_given.sort(reverse=True)\n    (i, j) = (0, 0)\n    while i != n:\n        if arr_given[j] >= arr_real[i]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n    print(n - j)", "t = int(input())\nfor p in range(t):\n    edges = []\n    n = int(input())\n    for i in range(n - 1):\n        (a, b, c) = input().split()\n        c = int(c)\n        edges.append(c)\n    vertices = [int(x) for x in input().split()]\n    vertices.sort()\n    edges.sort()\n    ans = 0\n    count = 0\n    while count < n:\n        v1 = vertices.pop()\n        e1 = edges.pop()\n        if count == 0:\n            count += 2\n            if v1 < e1:\n                ans += 2\n                vertices.append(v1)\n            else:\n                v2 = vertices.pop()\n                if v2 < e1:\n                    vertices.append(v2)\n                    ans += 1\n        else:\n            count += 1\n            if v1 < e1:\n                vertices.append(v1)\n                ans += 1\n    print(ans)", "t = int(input())\nfor p in range(t):\n    edges = []\n    n = int(input())\n    for i in range(n - 1):\n        (a, b, c) = input().split()\n        c = int(c)\n        edges.append(c)\n    vertices = [int(x) for x in input().split()]\n    vertices.sort()\n    edges.sort()\n    i_start = 0\n    j_start = 0\n    ans = 0\n    count = 0\n    while count < n:\n        v1 = vertices.pop()\n        e1 = edges.pop()\n        if count == 0:\n            count += 2\n            if v1 < e1:\n                ans += 2\n                vertices.append(v1)\n                i_start += 2\n            else:\n                v2 = vertices.pop()\n                if v2 < e1:\n                    vertices.append(v2)\n                    ans += 1\n                    i_start += 1\n        else:\n            count += 1\n            if v1 < e1:\n                vertices.append(v1)\n                ans += 1\n                i_start += 1\n    print(ans)", "import sys\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    B = [0] * (N - 1)\n    for i in range(N - 1):\n        (ui, vi, b) = map(int, sys.stdin.readline().split(' '))\n        B[i] = b\n    A = list(map(int, sys.stdin.readline().split(' ')))\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    count = 0\n    i = 0\n    j = 0\n    if A[0] < B[0]:\n        count += 1\n    else:\n        j = 1\n    while i < N - 1:\n        if B[i] > A[j]:\n            count += 1\n        else:\n            j += 1\n        i += 1\n    print(count)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    edge = []\n    for i in range(n - 1):\n        (u, v, a) = map(int, input().split())\n        edge.append(a)\n    node = [int(i) for i in input().split()]\n    node = sorted(node)\n    edge = sorted(edge)\n    ans = 0\n    i = 0\n    j = 0\n    while i < n and j < n - 1:\n        if edge[j] <= node[i]:\n            j += 1\n            i += 1\n        else:\n            ans += 1\n            i += 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    b = []\n    for i in range(n - 1):\n        b.append(int(input().split()[-1]))\n    a = list(map(int, input().split()))\n    a.sort()\n    b.sort()\n    b.append(b[-1])\n    c = 0\n    j = n - 1\n    for i in range(n - 1, -1, -1):\n        if a[j] < b[i]:\n            c += 1\n            j += 1\n        j -= 1\n    print(c)", "T = int(input())\nfor v in range(T):\n    n = int(input(''))\n    g = []\n    b = []\n    for i in range(n + 1):\n        g.append([])\n    for i in range(n - 1):\n        a = input('').split(' ')\n        u = int(a[0])\n        v = int(a[1])\n        g[u].append(v)\n        g[v].append(u)\n        e = int(a[2])\n        b.append(e)\n    a = list(map(int, input('').split(' ')))\n    b.sort()\n    a.sort()\n    i = 0\n    j = 0\n    pos = []\n    c = 0\n    while i < n and j < n - 1:\n        if b[j] <= a[i]:\n            c = c + 1\n            j = j + 1\n        else:\n            pos.append(c)\n            i = i + 1\n    if j == n - 1:\n        while i < n:\n            pos.append(c)\n            i = i + 1\n    num = [0]\n    for i in range(1, n + 1, 1):\n        num.append(len(g[i]))\n    mn = n\n    cur = 0\n    for i in range(1, n + 1, 1):\n        if num[i] < mn:\n            mn = num[i]\n            cur = i\n    t = 0\n    I = 0\n    ed = 0\n    mn = 1\n    while I < n - 1:\n        p = pos[I]\n        if p - ed >= mn:\n            ed = ed + mn\n        else:\n            t = t + 1\n        I = I + 1\n    if ed == n - 1:\n        print(0)\n    elif ed < n - 1:\n        if pos[-1] - ed >= mn:\n            print(t)\n        else:\n            print(t + 1)", "def solve(V, E):\n    E.sort()\n    V.sort()\n    (edge_ptr, vertex_ptr, coins) = (0, 0, 0)\n    while edge_ptr < len(E) and vertex_ptr < len(V):\n        while vertex_ptr < len(V) and V[vertex_ptr] < E[edge_ptr]:\n            vertex_ptr += 1\n            coins += 1\n        edge_ptr += 1\n        vertex_ptr += 1\n    return coins\nfor _ in range(int(input())):\n    n = int(input())\n    E = []\n    for _ in range(n - 1):\n        (u, v, b) = map(int, input().split())\n        E.append(b)\n    V = [int(x) for x in input().split()]\n    print(solve(V, E))", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    le = []\n    for j in range(1, n):\n        s = input()\n        ls = s.split(' ')\n        le.append(int(ls[2]))\n    le.sort()\n    a = input()\n    lv1 = a.split(' ')\n    lv = []\n    for v in range(n):\n        lv.append(int(lv1[v]))\n    lv.sort()\n    l = []\n    for k in range(2 * n - 1):\n        if k % 2 == 0:\n            l.append(lv[k // 2])\n        else:\n            l.append(le[k // 2])\n    arr1 = []\n    for m in range(0, 2 * n - 1, 2):\n        if 0 < m < 2 * n - 2:\n            if l[m] < l[m + 1] or l[m] < l[m - 1]:\n                if len(arr1) > 0 and arr1[0] <= l[m]:\n                    arr1.pop(0)\n                arr1.append(l[m + 1])\n        elif m == 0 and l[m] < l[m + 1]:\n            arr1.append(l[m + 1])\n        elif m == 2 * n - 2 and l[m] < l[m - 1]:\n            if len(arr1) > 0 and arr1[0] <= l[m]:\n                arr1.pop(0)\n            arr1.append(l[m - 1])\n    print(len(arr1))", "from collections import defaultdict\nfrom heapq import *\nimport itertools, math\n\ndef parse_integer_list():\n    return [int(x) for x in input().split()]\n\ndef handle_input(edges, vertices, N):\n    coins = 0\n    vertex_index = 0\n    if vertices[0] < edges[0]:\n        coins += 1\n    else:\n        vertex_index += 1\n    for i in range(len(edges)):\n        if vertices[vertex_index] < edges[i]:\n            coins += 1\n        else:\n            vertex_index += 1\n    return coins\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    edges = []\n    for i in range(N - 1):\n        (_, _, x) = parse_integer_list()\n        edges.append(x)\n    vertices = parse_integer_list()\n    print(handle_input(sorted(edges, reverse=True), sorted(vertices, reverse=True), N))", "for i in range(int(input())):\n    n = int(input())\n    edg = []\n    for i in range(n - 1):\n        c = int(input().split()[2])\n        edg.append(c)\n    ver = list(map(int, input().split()))\n    edg.sort()\n    ver.sort()\n    a = 0\n    b = 0\n    while a < n and b < n - 1:\n        if ver[a] >= edg[b]:\n            b += 1\n        a += 1\n    if a == n - 1:\n        b += 1\n    print(n - b)", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    C = []\n    for i in range(N - 1):\n        (u, v, b) = map(int, input().split())\n        C.append(b)\n    C.sort()\n    C.append(C[len(C) - 1])\n    B = list(map(int, input().split()))\n    B.sort()\n    coin = 0\n    j = N - 1\n    for i in range(N - 1, -1, -1):\n        if B[j] < C[i]:\n            coin = coin + 1\n        else:\n            j = j - 1\n    print(coin)", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = [0] * N\n    C = []\n    ininode = N\n    for i in range(N - 1):\n        (u, v, b) = map(int, input().split())\n        C.append(b)\n        if A[u - 1] < b:\n            if A[u - 1] != 0:\n                ininode = ininode - 1\n            A[u - 1] = b\n        if A[v - 1] < b:\n            if A[v - 1] != 0:\n                ininode = ininode - 1\n            A[v - 1] = b\n    C.sort()\n    C.append(C[len(C) - 1])\n    B = list(map(int, input().split()))\n    B.sort()\n    coin = 0\n    j = N - 1\n    for i in range(N - 1, -1, -1):\n        if B[j] < C[i]:\n            coin = coin + 1\n        else:\n            j = j - 1\n    print(coin)"]