["mod = 1000000007\n\ndef istrue(st, p, n, lis, lcm):\n    if lcm[st][st][p] != -1 and lis[st] != lcm[st][st][p]:\n        return 0\n    for j in range(1, n + 1):\n        if j == st or lcm[st][j][p] == -1:\n            continue\n        if max(lis[st], lis[j]) != lcm[st][j][p]:\n            return 0\n    return 1\n\ndef getans(st, pr, n, lis, lcm):\n    if st > n:\n        for i in range(1, n + 1):\n            if istrue(i, pr, n, lis, lcm) == 0:\n                return 0\n        return 1\n    (mmax, ans) = (-1, 0)\n    if lcm[st][st][pr] != -1:\n        lis[st] = lcm[st][st][pr]\n    else:\n        for j in range(1, n + 1):\n            if j == st or lcm[st][j][pr] == -1:\n                continue\n            if lis[j] == -2:\n                lis[st] = lcm[st][j][pr]\n            if mmax == -1 or mmax > lcm[st][j][pr]:\n                mmax = lcm[st][j][pr]\n    if lis[st] != -1:\n        ans = getans(st + 1, pr, n, lis, lcm)\n    elif mmax == -1:\n        ans = getans(st + 1, pr, n, lis, lcm)\n        if ans != 0:\n            return -1\n        else:\n            return 0\n    elif mmax == 0:\n        lis[st] = 0\n        ans = getans(st + 1, pr, n, lis, lcm)\n    else:\n        (an1, an2) = (0, 0)\n        lis[st] = -2\n        an1 = getans(st + 1, pr, n, lis, lcm)\n        lis[st] = mmax\n        an2 = getans(st + 1, pr, n, lis, lcm)\n        if an1 == -1 or an2 == -1:\n            ans = -1\n        else:\n            ans = (an1 * mmax + an2) % mod\n    lis[st] = -1\n    return ans\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    (n, m) = map(int, input().split())\n    lcm = [[[-1 for i in range(5)] for j in range(n + 1)] for k in range(n + 1)]\n    ok = 1\n    dicta = {}\n    for i in range(m):\n        ele = list(map(int, input().split()))\n        lis = [0] * 5\n        (x, y, r) = (ele[0], ele[1], ele[2])\n        for j in range(1, r + 1):\n            (p, e) = (ele[2 + 2 * j - 1], ele[2 + 2 * j])\n            if (p in dicta) == False:\n                sz = len(dicta)\n                dicta[p] = sz\n            lis[dicta[p]] += e\n        for j in range(0, 5):\n            if lcm[x][y][j] == -1:\n                (lcm[x][y][j], lcm[y][x][j]) = (lis[j], lis[j])\n            if lcm[x][y][j] != lis[j]:\n                ok = 0\n    if ok == 0:\n        print(0)\n        continue\n    ans = 1\n    for pr in range(0, 5):\n        lis = [-1] * (n + 1)\n        pra = getans(1, pr, n, lis, lcm)\n        if pra == 0:\n            ans = 0\n            break\n        if pra == -1:\n            ans = -1\n        else:\n            ans = pra * ans % mod\n    print(ans)", "mod = 1000000007\n\ndef istrue(st, p, n, lis, lcm):\n    if lcm[st][st][p] != -1 and lis[st] != lcm[st][st][p]:\n        return 0\n    for j in range(1, n + 1):\n        if j == st or lcm[st][j][p] == -1:\n            continue\n        if max(lis[st], lis[j]) != lcm[st][j][p]:\n            return 0\n    return 1\n\ndef getans(st, pr, n, lis, lcm):\n    if st > n:\n        for i in range(1, n + 1):\n            if istrue(i, pr, n, lis, lcm) == 0:\n                return 0\n        return 1\n    (mmax, ans) = (-1, 0)\n    if lcm[st][st][pr] != -1:\n        lis[st] = lcm[st][st][pr]\n    else:\n        for j in range(1, n + 1):\n            if j == st or lcm[st][j][pr] == -1:\n                continue\n            if lis[j] == -2:\n                lis[st] = lcm[st][j][pr]\n            if mmax == -1 or mmax > lcm[st][j][pr]:\n                mmax = lcm[st][j][pr]\n    if lis[st] != -1:\n        ans = getans(st + 1, pr, n, lis, lcm)\n    elif mmax == -1:\n        ans = getans(st + 1, pr, n, lis, lcm)\n        if ans != 0:\n            return -1\n        else:\n            return 0\n    elif mmax == 0:\n        lis[st] = 0\n        ans = getans(st + 1, pr, n, lis, lcm)\n    else:\n        (an1, an2) = (0, 0)\n        lis[st] = -2\n        an1 = getans(st + 1, pr, n, lis, lcm)\n        lis[st] = mmax\n        an2 = getans(st + 1, pr, n, lis, lcm)\n        if an1 == -1 or an2 == -1:\n            ans = -1\n        else:\n            ans = (an1 * mmax + an2) % mod\n    lis[st] = -1\n    return ans\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    (n, m) = map(int, input().split())\n    lcm = [[[-1 for i in range(5)] for j in range(n + 1)] for k in range(n + 1)]\n    ok = 1\n    dicta = {}\n    for i in range(m):\n        ele = list(map(int, input().split()))\n        lis = [0] * 5\n        (x, y, r) = (ele[0], ele[1], ele[2])\n        for j in range(1, r + 1):\n            (p, e) = (ele[2 + 2 * j - 1], ele[2 + 2 * j])\n            if (p in dicta) == False:\n                sz = len(dicta)\n                dicta[p] = sz\n            lis[dicta[p]] += e\n        for j in range(0, 5):\n            if lcm[x][y][j] == -1:\n                (lcm[x][y][j], lcm[y][x][j]) = (lis[j], lis[j])\n            if lcm[x][y][j] != lis[j]:\n                ok = 0\n    if ok == 0:\n        print(0)\n        continue\n    ans = 1\n    for pr in range(0, 5):\n        lis = [-1] * (n + 1)\n        pra = getans(1, pr, n, lis, lcm)\n        if pra == 0:\n            ans = 0\n            break\n        if pra == -1:\n            ans = -1\n        else:\n            ans = pra * ans % mod\n    print(ans)", "mod = 1000000007\n\ndef istrue(st, p, n, lis, lcm):\n    if lcm[st][st][p] != -1 and lis[st] != lcm[st][st][p]:\n        return 0\n    for j in range(1, n + 1):\n        if j == st or lcm[st][j][p] == -1:\n            continue\n        if max(lis[st], lis[j]) != lcm[st][j][p]:\n            return 0\n    return 1\n\ndef getans(st, pr, n, lis, lcm):\n    if st > n:\n        for i in range(1, n + 1):\n            if istrue(i, pr, n, lis, lcm) == 0:\n                return 0\n        return 1\n    (mmax, ans) = (-1, 0)\n    if lcm[st][st][pr] != -1:\n        lis[st] = lcm[st][st][pr]\n    else:\n        for j in range(1, n + 1):\n            if j == st or lcm[st][j][pr] == -1:\n                continue\n            if lis[j] == -2:\n                lis[st] = lcm[st][j][pr]\n            if mmax == -1 or mmax > lcm[st][j][pr]:\n                mmax = lcm[st][j][pr]\n    if lis[st] != -1:\n        ans = getans(st + 1, pr, n, lis, lcm)\n    elif mmax == -1:\n        ans = getans(st + 1, pr, n, lis, lcm)\n        if ans != 0:\n            return -1\n        else:\n            return 0\n    elif mmax == 0:\n        lis[st] = 0\n        ans = getans(st + 1, pr, n, lis, lcm)\n    else:\n        (an1, an2) = (0, 0)\n        lis[st] = -2\n        an1 = getans(st + 1, pr, n, lis, lcm)\n        lis[st] = mmax\n        an2 = getans(st + 1, pr, n, lis, lcm)\n        if an1 == -1 or an2 == -1:\n            ans = -1\n        else:\n            ans = (an1 * mmax + an2) % mod\n    lis[st] = -1\n    return ans\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    (n, m) = map(int, input().split())\n    lcm = [[[-1 for i in range(5)] for j in range(n + 1)] for k in range(n + 1)]\n    ok = 1\n    dicta = {}\n    for i in range(m):\n        ele = list(map(int, input().split()))\n        lis = [0] * 5\n        (x, y, r) = (ele[0], ele[1], ele[2])\n        for j in range(1, r + 1):\n            (p, e) = (ele[2 + 2 * j - 1], ele[2 + 2 * j])\n            if (p in dicta) == False:\n                sz = len(dicta)\n                dicta[p] = sz\n            lis[dicta[p]] += e\n        for j in range(0, 5):\n            if lcm[x][y][j] == -1:\n                (lcm[x][y][j], lcm[y][x][j]) = (lis[j], lis[j])\n            if lcm[x][y][j] != lis[j]:\n                ok = 0\n    if ok == 0:\n        print(0)\n        continue\n    ans = 1\n    for pr in range(0, 5):\n        lis = [-1] * (n + 1)\n        pra = getans(1, pr, n, lis, lcm)\n        if pra == 0:\n            ans = 0\n            break\n        if pra == -1:\n            ans = -1\n        else:\n            ans = pra * ans % mod\n    print(ans)", "def get_power_keys(A):\n    keys = set()\n    for row in A:\n        for item in row:\n            if item == -1:\n                continue\n            else:\n                keys.update(item.keys())\n    return keys\n\ndef give_count(n, constraints):\n    if len(constraints) == 0:\n        return -1\n    A = [([-1] * n).copy() for _ in range(n)]\n    for constraint in constraints:\n        x = constraint[0] - 1\n        y = constraint[1] - 1\n        if x > y:\n            (x, y) = (y, x)\n        powers = get_power_dict(constraint[3:])\n        if len(powers) > 5:\n            raise Exception('Not possible')\n        if A[x][y] != -1 and powers != A[x][y]:\n            return 0\n        else:\n            A[x][y] = powers\n    is_empty = [True] * n\n    for x in range(n):\n        for y in range(x, n):\n            if A[x][y] != -1:\n                is_empty[x] = False\n                is_empty[y] = False\n    for elem in is_empty:\n        if elem:\n            return -1\n    max_possible = [A[x][x] for x in range(n)]\n    for x in range(n):\n        for y in range(x + 1, n):\n            if A[x][y] == -1:\n                continue\n            if max_possible[x] == -1:\n                max_possible[x] = A[x][y]\n            else:\n                max_possible[x] = get_max_possible_powers(A[x][y], max_possible[x])\n            if max_possible[y] == -1:\n                max_possible[y] = A[x][y]\n            else:\n                max_possible[y] = get_max_possible_powers(A[x][y], max_possible[y])\n    min_possible = [{}.copy() for _ in range(n)]\n    for x in range(n):\n        if A[x][x] == -1:\n            continue\n        if is_possible(max_possible[x], A[x][x]):\n            min_possible[x] = A[x][x]\n        else:\n            return 0\n    for x in range(n):\n        for y in range(x + 1, n):\n            if A[x][y] == -1:\n                continue\n            x_possible = is_possible_with_powers(max_possible[x], A[x][y])\n            y_possible = is_possible_with_powers(max_possible[y], A[x][y])\n            min_possible_x = min_possible[x]\n            min_possible_y = min_possible[y]\n            for key in A[x][y]:\n                if x_possible[key] == False and y_possible[key] == False:\n                    return 0\n                elif x_possible[key] == False:\n                    if min_possible_y.get(key) is None:\n                        min_possible_y[key] = A[x][y][key]\n                    elif min_possible_y[key] != A[x][y][key]:\n                        return 0\n                elif y_possible[key] == False:\n                    if min_possible_x.get(key) is None:\n                        min_possible_x[key] = A[x][y][key]\n                    elif min_possible_x[key] != A[x][y][key]:\n                        return 0\n    power_keys = get_power_keys(A)\n    return get_possibilities(min_possible, A, power_keys, max_possible)\n\ndef get_possibilities(min_power, A, power_keys, max_possible):\n    n = len(A)\n    power_possibilities = {}\n    for power in power_keys:\n        if power == 1:\n            power_possibilities[1] = 1\n            continue\n        fixed_elems = [-1] * n\n        for i in range(n):\n            if min_power[i] != -1 and min_power[i].get(power) is not None:\n                fixed_elems[i] = min_power[i][power]\n        power_possibilities[power] = possibilities_helper(0, n, fixed_elems, A, power, max_possible)\n    product = 1\n    for value in power_possibilities.values():\n        product *= value % 1000000007\n    product %= 1000000007\n    return product\n\ndef possibilities_helper(index, n, fixed_elem, A, power, max_possible):\n    if index == n:\n        return 1\n    if fixed_elem[index] != -1 or max_possible[index].get(power) is None:\n        return possibilities_helper(index + 1, n, fixed_elem, A, power, max_possible)\n    for i in range(index):\n        if A[i][index] != -1 and fixed_elem[i] == -1:\n            return possibilities_helper(index + 1, n, fixed_elem, A, power, max_possible)\n    fixed_elem[index] = max_possible[index][power]\n    fixed = possibilities_helper(index + 1, n, fixed_elem, A, power, max_possible)\n    fixed_elem[index] = -1\n    return fixed + max_possible[index][power] * possibilities_helper(index + 1, n, fixed_elem, A, power, max_possible)\n\ndef is_possible(max_possible, lcm):\n    for key in lcm:\n        if key not in max_possible or max_possible[key] < lcm[key]:\n            return False\n    return True\n\ndef is_possible_with_powers(max_possible, lcm):\n    to_return = {}\n    for key in lcm:\n        if key not in max_possible or max_possible[key] < lcm[key]:\n            to_return[key] = False\n        else:\n            to_return[key] = True\n    return to_return\n\ndef get_max_possible_powers(power1, power2):\n    merged = {}\n    for key1 in power1:\n        if key1 in power2:\n            merged[key1] = min(power1[key1], power2[key1])\n    return merged\n\ndef get_power_dict(powers):\n    if len(powers) == 0:\n        return {1: 1}\n    else:\n        to_return = {}\n        for i in range(len(powers) // 2):\n            if to_return.get(powers[2 * i]) is not None:\n                to_return[powers[2 * i]] += powers[2 * i + 1]\n            else:\n                to_return[powers[2 * i]] = powers[2 * i + 1]\n        return to_return\nT = input()\nT = int(T)\nfor _ in range(T):\n    (n, m) = [int(a) for a in input().split(' ')]\n    constraints = []\n    for _ in range(m):\n        constraints.append([int(a) for a in input().split(' ')])\n    print(give_count(n, constraints))", "def calc(lcm_store, range_store, node, prime, mod, history):\n    if node == 1:\n        if range_store[node]['max'][prime] == range_store[node]['min'][prime]:\n            history[node] = [range_store[node]['max'][prime]]\n            ans = calc(lcm_store, range_store, node + 1, prime, mod, history.copy())\n            return ans % mod\n        else:\n            ans = 0\n            history[node] = [range_store[node]['min'][prime], range_store[node]['max'][prime] - 1]\n            ans1 = calc(lcm_store, range_store, node + 1, prime, mod, history.copy())\n            ans = (history[node][1] - history[node][0] + 1) * ans1 % mod\n            history[node] = [range_store[node]['max'][prime]]\n            ans2 = calc(lcm_store, range_store, node + 1, prime, mod, history.copy())\n            ans = (ans + 1 * ans2) % mod\n            return ans\n    else:\n        temp_node = []\n        count_lcm = 0\n        for n in range(1, node):\n            if lcm_store[n][node] is not None:\n                count_lcm = count_lcm + 1\n                exp = lcm_store[n][node].get(p, 0)\n                if exp > history[n][-1]:\n                    if range_store[node]['max'][p] < exp:\n                        return 0\n                    else:\n                        val = exp\n                        if len(temp_node) == 0:\n                            temp_node = [val]\n                        elif temp_node[0] <= val <= temp_node[-1]:\n                            temp_node = [val]\n                        else:\n                            return 0\n                elif exp == history[n][-1]:\n                    val = [range_store[node]['min'][p], range_store[node]['max'][p]]\n                    if len(temp_node) == 1:\n                        if val[0] <= temp_node[0] <= val[1]:\n                            pass\n                        else:\n                            return 0\n                    elif len(temp_node) == 2:\n                        temp_node[0] = max(temp_node[0], val[0])\n                        temp_node[1] = min(temp_node[1], val[1])\n                        if temp_node[0] > temp_node[1]:\n                            temp_node = []\n                    else:\n                        temp_node = [val[0], val[1]]\n        if count_lcm == 0:\n            temp_node = [range_store[node]['min'][prime], range_store[node]['max'][prime]]\n        if len(temp_node) == 0:\n            return 0\n        else:\n            if node == len(range_store):\n                if len(temp_node) == 1:\n                    return 1\n                else:\n                    return (temp_node[1] - temp_node[0] + 1) % mod\n            if len(temp_node) == 1:\n                history[node] = temp_node\n                return calc(lcm_store, range_store, node + 1, prime, mod, history.copy()) % mod\n            elif temp_node[0] == temp_node[1]:\n                history[node] = [temp_node[0]]\n                return calc(lcm_store, range_store, node + 1, prime, mod, history.copy()) % mod\n            else:\n                ans = 0\n                history[node] = [temp_node[0], temp_node[1] - 1]\n                ans1 = calc(lcm_store, range_store, node + 1, prime, mod, history.copy()) % mod\n                ans = (history[node][1] - history[node][0] + 1) * ans1 % mod\n                history[node] = [temp_node[1]]\n                ans2 = calc(lcm_store, range_store, node + 1, prime, mod, history.copy()) % mod\n                ans = (ans + 1 * ans2) % mod\n                return ans\nfor t in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    inconsistency = False\n    lcm_store = [[None for j in range(n + 1)] for i in range(n + 1)]\n    simple_store = []\n    primes = set([])\n    for i in range(m):\n        l = list(map(int, input().split()))\n        (a, b) = l[0:2]\n        no = l[2]\n        if a > b:\n            (a, b) = (b, a)\n        simple_store.append([a, b, no])\n        if a > n or b > n:\n            inconsistency = True\n        if no != 0:\n            stat = l[3:]\n            if len(stat) < 2 * no:\n                inconsistency = True\n            temp_stat = {}\n            for x in range(no):\n                (base, exp) = (stat[2 * x], stat[2 * x + 1])\n                temp_stat[base] = temp_stat.get(base, 0) + exp\n            if lcm_store[a][b] is None:\n                lcm_store[a][b] = {}\n                for base in temp_stat:\n                    exp = temp_stat[base]\n                    lcm_store[a][b][base] = exp\n                    primes.add(base)\n            else:\n                for base in temp_stat:\n                    exp = temp_stat[base]\n                    if lcm_store[a][b].get(base, None) is None:\n                        inconsistency = True\n                    elif lcm_store[a][b].get(base, 0) != exp:\n                        inconsistency = True\n                    else:\n                        pass\n        elif lcm_store[a][b] is None:\n            lcm_store[a][b] = {}\n        elif len(lcm_store[a][b]) > 0:\n            inconsistency = True\n    if m == 0:\n        print('-1')\n        continue\n    if inconsistency:\n        print('0')\n        continue\n    primes = list(primes)\n    range_store = {i: {'min': {p: 0 for p in primes}, 'max': {p: 0 for p in primes}, 'minset': False, 'maxset': False} for i in range(1, n + 1)}\n    inconsistency = False\n    for (a, b, no) in simple_store:\n        if a == b:\n            if range_store[a]['maxset']:\n                for p in primes:\n                    exp = lcm_store[a][b].get(p, 0)\n                    if exp != range_store[a]['max'][p]:\n                        inconsistency = True\n                        break\n                if inconsistency:\n                    break\n            if not range_store[a]['maxset']:\n                for p in primes:\n                    exp = lcm_store[a][b].get(p, 0)\n                    range_store[a]['max'][p] = exp\n                    range_store[a]['min'][p] = exp\n                range_store[a]['maxset'] = True\n            continue\n        if range_store[a]['maxset']:\n            for p in primes:\n                exp = lcm_store[a][b].get(p, 0)\n                range_store[a]['max'][p] = min(range_store[a]['max'][p], exp)\n        if not range_store[a]['maxset']:\n            for p in primes:\n                exp = lcm_store[a][b].get(p, None)\n                if exp is None:\n                    range_store[a]['max'][p] = 0\n                else:\n                    range_store[a]['max'][p] = exp\n            range_store[a]['maxset'] = True\n        if range_store[b]['maxset']:\n            for p in primes:\n                exp = lcm_store[a][b].get(p, 0)\n                range_store[b]['max'][p] = min(range_store[b]['max'][p], exp)\n        if not range_store[b]['maxset']:\n            for p in primes:\n                exp = lcm_store[a][b].get(p, None)\n                if exp is None:\n                    range_store[b]['max'][p] = 0\n                else:\n                    range_store[b]['max'][p] = exp\n            range_store[b]['maxset'] = True\n    if inconsistency:\n        print('0')\n        continue\n    inconsistency = False\n    for (a, b, no) in simple_store:\n        for p in primes:\n            exp = lcm_store[a][b].get(p, 0)\n            (exp_a, exp_b) = (range_store[a]['max'][p], range_store[b]['max'][p])\n            s_exp = max(exp_a, exp_b)\n            if exp != s_exp:\n                inconsistency = True\n                break\n            range_store[a]['min'][p] = max(range_store[a]['min'][p], 0 if exp == exp_b else exp)\n            range_store[b]['min'][p] = max(range_store[b]['min'][p], 0 if exp == exp_a else exp)\n            if range_store[a]['min'][p] > range_store[a]['max'][p] or range_store[b]['min'][p] > range_store[b]['max'][p]:\n                inconsistency = True\n                break\n        if inconsistency:\n            break\n    if inconsistency:\n        print('0')\n        continue\n    mod = 10 ** 9 + 7\n    infinite = False\n    valid_seq = 1\n    for el in range_store:\n        if not range_store[el]['maxset']:\n            infinite = True\n            break\n    if infinite:\n        print('-1')\n        continue\n    for p in primes:\n        valid_seq = valid_seq * calc(lcm_store, range_store, 1, p, mod, [None for i in range(n + 1)]) % mod\n    print(valid_seq)", "mod = 1000000007\n\ndef istrue(st, p, n, lis, lcm):\n    if lcm[st][st][p] != -1 and lis[st] != lcm[st][st][p]:\n        return 0\n    for j in range(1, n + 1):\n        if j == st or lcm[st][j][p] == -1:\n            continue\n        if max(lis[st], lis[j]) != lcm[st][j][p]:\n            return 0\n    return 1\n\ndef getans(st, pr, n, lis, lcm):\n    if st > n:\n        for i in range(1, n + 1):\n            if istrue(i, pr, n, lis, lcm) == 0:\n                return 0\n        return 1\n    (mmax, ans) = (-1, 0)\n    if lcm[st][st][pr] != -1:\n        lis[st] = lcm[st][st][pr]\n    else:\n        for j in range(1, n + 1):\n            if j == st or lcm[st][j][pr] == -1:\n                continue\n            if lis[j] == -2:\n                lis[st] = lcm[st][j][pr]\n            if mmax == -1 or mmax > lcm[st][j][pr]:\n                mmax = lcm[st][j][pr]\n    if lis[st] != -1:\n        ans = getans(st + 1, pr, n, lis, lcm)\n    elif mmax == -1:\n        ans = getans(st + 1, pr, n, lis, lcm)\n        if ans != 0:\n            return -1\n        else:\n            return 0\n    elif mmax == 0:\n        lis[st] = 0\n        ans = getans(st + 1, pr, n, lis, lcm)\n    else:\n        (an1, an2) = (0, 0)\n        lis[st] = -2\n        an1 = getans(st + 1, pr, n, lis, lcm)\n        lis[st] = mmax\n        an2 = getans(st + 1, pr, n, lis, lcm)\n        if an1 == -1 or an2 == -1:\n            ans = -1\n        else:\n            ans = (an1 * mmax + an2) % mod\n    lis[st] = -1\n    return ans\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    (n, m) = map(int, input().split())\n    lcm = [[[-1 for i in range(5)] for j in range(n + 1)] for k in range(n + 1)]\n    ok = 1\n    dicta = {}\n    for i in range(m):\n        ele = list(map(int, input().split()))\n        lis = [0] * 5\n        (x, y, r) = (ele[0], ele[1], ele[2])\n        for j in range(1, r + 1):\n            (p, e) = (ele[2 + 2 * j - 1], ele[2 + 2 * j])\n            if (p in dicta) == False:\n                sz = len(dicta)\n                dicta[p] = sz\n            lis[dicta[p]] += e\n        for j in range(0, 5):\n            if lcm[x][y][j] == -1:\n                (lcm[x][y][j], lcm[y][x][j]) = (lis[j], lis[j])\n            if lcm[x][y][j] != lis[j]:\n                ok = 0\n    if ok == 0:\n        print(0)\n        continue\n    ans = 1\n    for pr in range(0, 5):\n        lis = [-1] * (n + 1)\n        pra = getans(1, pr, n, lis, lcm)\n        if pra == 0:\n            ans = 0\n            break\n        if pra == -1:\n            ans = -1\n        else:\n            ans = pra * ans % mod\n    print(ans)", "def getDisjoint(i, v):\n    disjoint = set()\n    q = {i}\n    while len(q) > 0:\n        pnt = q.pop()\n        disjoint.add(pnt)\n        for (ppnt, _) in link[pnt]:\n            if ppnt not in disjoint:\n                q.add(ppnt)\n    return disjoint\n\ndef validate(i):\n    for (pnt, dic) in link[i]:\n        if v in tlink[pnt] and v in tlink[i]:\n            if max(tlink[pnt].get(v, 0), tlink[i].get(v, 0)) != dic.get(v, 0):\n                return False\n    return True\n\ndef recur(i, v):\n    visited[i] = True\n    ans = 0\n    max_num = float('inf')\n    for (pnt, dic) in link[i]:\n        if v not in dic:\n            max_num = 0\n            break\n        else:\n            max_num = min(max_num, dic[v])\n    if len(disjoint) == 0:\n        tlink[i][v] = 0\n        ans += max_num * validate(i)\n        del tlink[i][v]\n        tlink[i][v] = max_num\n        ans += validate(i)\n        del tlink[i][v]\n        return ans\n    else:\n        pnt = disjoint.pop()\n        tlink[i][v] = 0\n        if validate(i):\n            ans += max_num * recur(pnt, v)\n        del tlink[i][v]\n        tlink[i][v] = max_num\n        if validate(i):\n            ans += recur(pnt, v)\n        del tlink[i][v]\n        disjoint.add(pnt)\n        return ans % mod\nmod = 1000000007\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    link = [[] for _ in range(n)]\n    primes = set()\n    for _ in range(m):\n        (x, y, r, *pe) = map(int, input().split())\n        dic = {}\n        for i in range(0, 2 * r, 2):\n            (p, e) = (pe[i], pe[i + 1])\n            dic[p] = dic.get(p, 0) + e\n            primes.add(p)\n        x -= 1\n        y -= 1\n        link[x].append([y, dic])\n        link[y].append([x, dic])\n    ans = 1\n    for l in link:\n        if len(l) == 0:\n            ans = -1\n            break\n    if ans != -1:\n        for v in primes:\n            tlink = [{} for _ in range(n)]\n            visited = [False for _ in range(n)]\n            for i in range(n):\n                if not visited[i]:\n                    disjoint = getDisjoint(i, v)\n                    disjoint.remove(i)\n                    ans = ans * recur(i, v) % mod\n            if ans == 0:\n                break\n    print(ans)", "t = int(input())\nfor hatt in range(t):\n    lis = input().split()\n    (n, m) = (int(lis[0]), int(lis[1]))\n    pairs = []\n    lcmfac = []\n    primelis = []\n    for hatt in range(m):\n        lis = input().split()\n        (x, y) = (int(lis[0]) - 1, int(lis[1]) - 1)\n        pairs.append((x, y))\n        r = int(lis[2])\n        faclis = {}\n        for i in range(r):\n            (p, e) = (int(lis[2 * i + 3]), int(lis[2 * i + 4]))\n            if p not in primelis:\n                primelis.append(p)\n            if p not in faclis:\n                faclis[p] = e\n            else:\n                faclis[p] += e\n        lcmfac.append(faclis)\n    ans = 1\n    infiniteflag = False\n    zeroflag = False\n    if len(primelis) > 0:\n        for hatu in primelis:\n            fixed = [False] * n\n            a = [-1] * n\n            for i in range(m):\n                (x, y) = pairs[i]\n                if hatu not in lcmfac[i]:\n                    coun = 0\n                else:\n                    coun = lcmfac[i][hatu]\n                if x == y:\n                    if not fixed[x]:\n                        fixed[x] = True\n                        if a[x] != -1 and a[x] < coun:\n                            zeroflag = True\n                        a[x] = coun\n                    elif a[x] != coun:\n                        zeroflag = True\n                else:\n                    if a[x] == -1:\n                        a[x] = coun\n                    if a[y] == -1:\n                        a[y] = coun\n                    if not fixed[x]:\n                        a[x] = min(a[x], coun)\n                    elif a[x] > coun:\n                        zeroflag = True\n                    if not fixed[y]:\n                        a[y] = min(a[y], coun)\n                    elif a[y] > coun:\n                        zeroflag = True\n            if not zeroflag:\n                for i in range(m):\n                    (x, y) = pairs[i]\n                    if hatu not in lcmfac[i]:\n                        coun = 0\n                    else:\n                        coun = lcmfac[i][hatu]\n                    if x != y:\n                        if a[x] < coun:\n                            if a[y] < coun:\n                                zeroflag = True\n                            else:\n                                fixed[y] = True\n                        elif a[y] < coun:\n                            fixed[x] = True\n                if not zeroflag:\n                    dependlis = [[] for i in range(n)]\n                    for i in range(m):\n                        (x, y) = pairs[i]\n                        if x != y:\n                            if not fixed[x] and (not fixed[y]):\n                                (x, y) = (min(x, y), max(x, y))\n                                if y not in dependlis[x]:\n                                    dependlis[x].append(y)\n                    for i in range(n):\n                        if a[i] == -1:\n                            infiniteflag = True\n                    if not infiniteflag:\n                        primemod = 1000000007\n\n                        def finds(currind, banlist):\n                            if fixed[currind]:\n                                if currind == n - 1:\n                                    return 1\n                                else:\n                                    return finds(currind + 1, banlist)\n                            elif currind == n - 1:\n                                if currind in banlist:\n                                    return 1\n                                else:\n                                    return (1 + a[currind]) % primemod\n                            elif currind in banlist:\n                                return finds(currind + 1, banlist)\n                            elif dependlis[currind] and a[currind] > 0:\n                                banlist2 = banlist.copy()\n                                for i in dependlis[currind]:\n                                    if i not in banlist2:\n                                        banlist2.append(i)\n                                return (finds(currind + 1, banlist) + a[currind] * finds(currind + 1, banlist2) % primemod) % primemod\n                            else:\n                                return (1 + a[currind]) * finds(currind + 1, banlist) % primemod\n                        aaa = 0\n                        aaa = finds(0, [])\n                        ans = ans * aaa % primemod\n    else:\n        occur = [0] * n\n        for (x, y) in pairs:\n            occur[x] += 1\n            occur[y] += 1\n        for i in range(n):\n            if occur[i] == 0:\n                infiniteflag = True\n    if zeroflag:\n        print(0)\n    elif infiniteflag or m == 0:\n        print(-1)\n    else:\n        print(ans)"]