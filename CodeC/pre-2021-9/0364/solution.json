["for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    p = l[:n:2]\n    q = l[1:n:2]\n    p.sort(reverse=True)\n    q.sort()\n    for i in range(k):\n        if p[i] <= q[i]:\n            break\n        (p[i], q[i]) = (q[i], p[i])\n    if sum(q) > sum(p):\n        print('YES')\n    else:\n        print('NO')", "for tc in range(int(input())):\n    (m, t) = ([], [])\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    for i in range(n):\n        if i % 2 == 0:\n            m.append(arr[i])\n        else:\n            t.append(arr[i])\n    m.sort(reverse=True)\n    t.sort()\n    totdiff = 0\n    for i in range(min(k, n // 2)):\n        if m[i] > t[i]:\n            totdiff += m[i] - t[i]\n        else:\n            break\n    ms = sum(m)\n    ts = sum(t)\n    if ms - totdiff < ts + totdiff:\n        print('YES')\n    else:\n        print('NO')", "for i in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    p = [l[i] for i in range(0, n, 2)]\n    q = [l[i] for i in range(1, n, 2)]\n    p.sort(reverse=True)\n    q.sort()\n    for i in range(k):\n        if p[i] <= q[i]:\n            break\n        (p[i], q[i]) = (q[i], p[i])\n    s = sum(q) - sum(p)\n    print((s > 0) * 'YES' + (s <= 0) * 'NO')", "for i in range(int(input())):\n    (n, k) = map(int, input().split())\n    list_games = list(map(int, input().split()))\n    if len(set(list_games)) == 1:\n        print('NO')\n    else:\n        list_monu = list_games[::2]\n        list_tomu = list_games[1::2]\n        if sum(list_monu) < sum(list_tomu):\n            print('YES')\n        else:\n            list_tomu.sort()\n            list_monu.sort()\n            for j in range(len(list_tomu)):\n                if sum(list_monu) > sum(list_tomu) and k > 0:\n                    (list_monu[len(list_monu) - j - 1], list_tomu[j]) = (list_tomu[j], list_monu[len(list_monu) - j - 1])\n                    k -= 1\n                else:\n                    break\n            if sum(list_monu) < sum(list_tomu):\n                print('YES')\n            else:\n                print('NO')", "T = int(input())\nfor i in range(T):\n    (N, K) = tuple(input().split())\n    (N, K) = (int(N), int(K))\n    A = input().split()\n    P = [int(A[j]) for j in range(0, N, 2)]\n    Q = [int(A[j]) for j in range(1, N, 2)]\n    for i in range(K):\n        (a, b) = (max(P), min(Q))\n        P.append(b)\n        P.remove(a)\n        Q.append(a)\n        Q.remove(b)\n    if sum(Q) > sum(P):\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nwhile t > 0:\n    (n, k) = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    motu = []\n    tomu = []\n    for i in range(n):\n        if i % 2 == 0:\n            motu.append(l[i])\n        else:\n            tomu.append(l[i])\n    for i in range(k):\n        mx = max(motu)\n        mn = min(tomu)\n        motu.remove(mx)\n        tomu.remove(mn)\n        motu.append(mn)\n        tomu.append(mx)\n    cmot = 0\n    ctom = 0\n    for i in range(len(motu)):\n        cmot += motu[i]\n    for i in range(len(tomu)):\n        ctom += tomu[i]\n    if ctom > cmot:\n        print('YES')\n    else:\n        print('NO')\n    t -= 1", "t = int(input())\nfor q in range(t):\n    (n, k) = map(int, input().split())\n    total = list(map(int, input().split()))\n    tomu = []\n    motu = []\n    for i in range(0, len(total), 2):\n        motu.append(total[i])\n    for i in range(1, len(total), 2):\n        tomu.append(total[i])\n    sumT = sum(tomu)\n    sumM = sum(motu)\n    if sumT > sumM:\n        print('YES')\n    else:\n        motu.sort()\n        tomu.sort()\n        for c in range(k):\n            motu.sort()\n            tomu.sort()\n            if motu[len(motu) - 1] > tomu[0]:\n                t = motu[len(motu) - 1]\n                motu[len(motu) - 1] = tomu[0]\n                tomu[0] = t\n            sumT = sum(tomu)\n            sumM = sum(motu)\n        if sumT > sumM:\n            print('YES')\n        else:\n            print('NO')", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [int(c) for c in input().split()]\n    x = []\n    y = []\n    for i in range(1, n, 2):\n        x.append(a[i - 1])\n        y.append(a[i])\n    try:\n        x.append(a[n // 2 * 2])\n    except:\n        c = 0\n    for i in range(k):\n        n = x.index(max(x))\n        m = y.index(min(y))\n        (x[n], y[m]) = (y[m], x[n])\n    if sum(x) < sum(y):\n        print('YES')\n    else:\n        print('NO')", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "def func():\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    m = []\n    t = []\n    for i in range(1, n, 2):\n        m.append(arr[i - 1])\n        t.append(arr[i])\n    if n % 2 != 0:\n        m.append(arr[n - 1])\n    while k > 0:\n        if sum(t) > sum(m):\n            break\n        h = max(m)\n        l = min(t)\n        if l >= h:\n            break\n        m[m.index(h)] = l\n        t[t.index(l)] = h\n        k -= 1\n    if sum(t) > sum(m):\n        print('YES')\n    else:\n        print('NO')\nfor i in range(int(input())):\n    func()", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "for i in range(int(input())):\n    (s, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    c = sum(l[::2])\n    d = sum(l[1::2])\n    if k == 0:\n        if c < d:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        l1 = l[::2]\n        l2 = l[1::2]\n        while k >= 1:\n            if max(l1) > min(l2):\n                l2.append(max(l1))\n                l1.append(min(l2))\n                l2.remove(min(l2))\n                l1.remove(max(l1))\n            else:\n                break\n            k = k - 1\n        f = sum(l1)\n        g = sum(l2)\n        if g > f:\n            print('YES')\n        else:\n            print('NO')", "t = int(input())\nfor i in range(t):\n    n_k = input().split(' ')\n    (n, k) = (int(n_k[0]), int(n_k[1]))\n    arr = input().split(' ')\n    (l_m, l_t) = ([], [])\n    for j in range(n):\n        if j % 2 == 0:\n            l_m.append(int(arr[j]))\n        else:\n            l_t.append(int(arr[j]))\n    if sum(l_t) > sum(l_m):\n        print('YES')\n    elif sum(l_t) <= sum(l_m) and k == 0:\n        print('NO')\n    else:\n        l_t.sort()\n        l_m.sort()\n        for x in range(k):\n            if l_t[0] < l_m[-1]:\n                (l_t[0], l_m[-1]) = (l_m[-1], l_t[0])\n                l_t.sort()\n                l_m.sort()\n            else:\n                break\n        if sum(l_t) > sum(l_m):\n            print('YES')\n        else:\n            print('NO')", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    motuScore = [A[i] for i in range(len(A)) if not i % 2]\n    tomuScore = [A[i] for i in range(len(A)) if i % 2]\n    motuBest = sorted(motuScore, reverse=True)\n    tomuWorst = sorted(tomuScore)\n    diff = sum([motuBest[i] - tomuWorst[i] for i in range(min(K, len(motuScore), len(tomuScore))) if motuBest[i] - tomuWorst[i] > 0])\n    if sum(tomuScore) + diff > sum(motuScore) - diff:\n        print('YES')\n    else:\n        print('NO')", "def func():\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    m = []\n    t = []\n    for i in range(1, n, 2):\n        m.append(arr[i - 1])\n        t.append(arr[i])\n    if n % 2 != 0:\n        m.append(arr[n - 1])\n    while k > 0:\n        if sum(t) > sum(m):\n            break\n        h = max(m)\n        l = min(t)\n        if l >= h:\n            break\n        m[m.index(h)] = l\n        t[t.index(l)] = h\n        k -= 1\n    if sum(t) > sum(m):\n        print('YES')\n    else:\n        print('NO')\nfor i in range(int(input())):\n    func()", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    for i in range(n):\n        if i & 1:\n            heap.heappush(tomu, l[i])\n        else:\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        k = k - 1\n    if sum(tomu) > -sum(motu):\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    for i in range(n):\n        if i & 1:\n            heap.heappush(tomu, l[i])\n        else:\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        k = k - 1\n    if sum(tomu) > -sum(motu):\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    for i in range(n):\n        if i & 1:\n            heap.heappush(tomu, l[i])\n        else:\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        k = k - 1\n    if sum(tomu) > -sum(motu):\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    for i in range(n):\n        if i & 1 == 1:\n            heap.heappush(tomu, l[i])\n        else:\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        k = k - 1\n    if sum(tomu) > -sum(motu):\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if sum(tomu) > -sum(motu):\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "q = int(input())\nfor i in range(q):\n    w = str(input())\n    w = w + ' '\n    e = ''\n    r = []\n    for i in w:\n        if i == ' ':\n            r.append(int(e))\n            e = ''\n        else:\n            e = e + i\n    t = str(input())\n    t = t + ' '\n    y = ''\n    u = []\n    for i in t:\n        if i == ' ':\n            u.append(int(y))\n            y = ''\n        else:\n            y = y + i\n    o = []\n    for i in range(0, len(u), 2):\n        o.append(u[i])\n    p = []\n    for i in range(1, len(u), 2):\n        p.append(u[i])\n    o.sort()\n    p.sort()\n    if sum(o) < sum(p):\n        print('YES')\n    else:\n        s = 0\n        if len(p) >= r[1]:\n            for i in range(r[1]):\n                a = o[-(i + 1)]\n                o[-(i + 1)] = p[i]\n                p[i] = a\n                if sum(o) < sum(p):\n                    print('YES')\n                    break\n                else:\n                    s = s + 1\n            if s == r[1]:\n                print('NO')\n        if len(p) < r[1]:\n            for i in range(len(p)):\n                a = o[-(i + 1)]\n                o[-(i + 1)] = p[i]\n                p[i] = a\n                if sum(o) < sum(p):\n                    print('YES')\n                    break\n                else:\n                    s = s + 1\n            if s == len(p):\n                print('NO')", "for i in range(int(input())):\n    (s, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    c = sum(l[::2])\n    d = sum(l[1::2])\n    if k == 0:\n        if c < d:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        l1 = l[::2]\n        l2 = l[1::2]\n        while k >= 1:\n            if max(l1) > min(l2):\n                l2.append(max(l1))\n                l1.append(min(l2))\n                l2.remove(min(l2))\n                l1.remove(max(l1))\n            else:\n                break\n            k = k - 1\n        f = sum(l1)\n        g = sum(l2)\n        if g > f:\n            print('YES')\n        else:\n            print('NO')", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "from math import fsum\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    (mot, tom) = ([], [])\n    for (i, val) in enumerate(nums):\n        if i % 2 == 0:\n            mot.append(val)\n        else:\n            tom.append(val)\n    tom.sort()\n    mot.sort()\n    mot_score1 = fsum(mot)\n    tom_score1 = fsum(tom)\n    diff = tom_score1 - mot_score1\n    if diff > 0:\n        print('YES')\n        continue\n    diff = abs(diff)\n    if k == 0:\n        print('NO')\n        continue\n    nada = False\n    for i in range(len(tom)):\n        if i == k:\n            nada = True\n            break\n        t = tom[i]\n        m = mot[len(mot) - 1 - i]\n        if t < m:\n            d = m - t\n            tom_score1 += d\n            mot_score1 -= d\n            if tom_score1 > mot_score1:\n                print('YES')\n                break\n    else:\n        print('NO')\n    if nada == True:\n        print('NO')", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "for i in range(int(input())):\n    (s, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    c = sum(l[::2])\n    d = sum(l[1::2])\n    if k == 0:\n        if c < d:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        l1 = l[::2]\n        l2 = l[1::2]\n        while k >= 1:\n            if max(l1) > min(l2):\n                l2.append(max(l1))\n                l1.append(min(l2))\n                l2.remove(min(l2))\n                l1.remove(max(l1))\n            else:\n                break\n            k = k - 1\n        f = sum(l1)\n        g = sum(l2)\n        if g > f:\n            print('YES')\n        else:\n            print('NO')", "for i in range(int(input())):\n    (s, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    c = sum(l[::2])\n    d = sum(l[1::2])\n    if k == 0:\n        if c < d:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        l1 = l[::2]\n        l2 = l[1::2]\n        while k >= 1:\n            if max(l1) > min(l2):\n                l2.append(max(l1))\n                l1.append(min(l2))\n                l2.remove(min(l2))\n                l1.remove(max(l1))\n            else:\n                break\n            k = k - 1\n        f = sum(l1)\n        g = sum(l2)\n        if g > f:\n            print('YES')\n        else:\n            print('NO')", "for i in range(int(input())):\n    (s, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    c = sum(l[::2])\n    d = sum(l[1::2])\n    if k == 0:\n        if c < d:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        l1 = l[::2]\n        l2 = l[1::2]\n        while k >= 1:\n            if max(l1) > min(l2):\n                l2.append(max(l1))\n                l1.append(min(l2))\n                l2.remove(min(l2))\n                l1.remove(max(l1))\n            else:\n                break\n            k = k - 1\n        f = sum(l1)\n        g = sum(l2)\n        if g > f:\n            print('YES')\n        else:\n            print('NO')", "for t in range(int(input())):\n    (n, k) = map(int, input().split(' '))\n    a = list(map(int, input().split(' ')))\n    m = [a[j] for j in range(0, n, 2)]\n    t = [a[j] for j in range(1, n, 2)]\n    for i in range(k):\n        (m[m.index(max(m))], t[t.index(min(t))]) = (min(t), max(m))\n    if sum(t) > sum(m):\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nwhile t:\n    (n, k) = map(int, input().split(' '))\n    list1 = list(map(int, input().split(' ')))\n    motu = []\n    tomu = []\n    for i in range(0, n, 2):\n        motu.append(list1[i])\n    for i in range(1, n, 2):\n        tomu.append(list1[i])\n    motu.sort(reverse=True)\n    tomu.sort(reverse=True)\n    motusum = sum((i for i in motu))\n    tomusum = sum((i for i in tomu))\n    motulen = len(motu)\n    tomulen = len(tomu)\n    if tomusum > motusum:\n        print('YES')\n        t = t - 1\n        continue\n    else:\n        if k > n / 2:\n            k = int(n / 2)\n        for i in range(k):\n            if tomu[-1 - i] < motu[i]:\n                a = motu[i]\n                motu[i] = tomu[-1 - i]\n                tomu[-1 - i] = a\n    motusum = sum((i for i in motu))\n    tomusum = sum((i for i in tomu))\n    if tomusum > motusum:\n        print('YES')\n    else:\n        print('NO')\n    t = t - 1", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = 0\n    (m, p) = ([], [])\n    for i in input().split():\n        if s % 2 == 0:\n            m.append(int(i))\n        else:\n            p.append(int(i))\n        s += 1\n    m.sort(reverse=True)\n    p.sort()\n    if k > min(len(m), len(p)):\n        k = min(len(m), len(p))\n    for i in range(k):\n        if m[i] > p[i]:\n            (m[i], p[i]) = (p[i], m[i])\n    if sum(p) > sum(m):\n        print('YES')\n    else:\n        print('NO')", "for test in range(int(input())):\n    (num, kum) = map(int, input().split())\n    aum = list(map(int, input().split()))\n    mum = [aum[i] for i in range(num) if i % 2 == 0]\n    tum = [aum[i] for i in range(num) if i % 2 != 0]\n    for i in range(kum):\n        tum.sort()\n        mum.sort(reverse=True)\n        (mum[0], tum[0]) = (tum[0], mum[0])\n    if sum(tum) > sum(mum):\n        print('YES')\n    else:\n        print('NO')", "def sort_inputs(inp1, inp2):\n    inp_arr = inp1.split(' ')\n    (N, K) = (int(inp_arr[0]), int(inp_arr[1]))\n    inp_arr = inp2.split()\n    A = list(map(lambda x: int(x), inp_arr))\n    return (N, K, A)\n\ndef sort_arr(A, N):\n    (motu, tomu) = (list(), list())\n    for i in range(N):\n        if i % 2 == 0:\n            motu.append(A[i])\n        else:\n            tomu.append(A[i])\n    motu.sort()\n    tomu.sort()\n    return (motu, tomu)\n\ndef find_k_diff(motu, tomu, K, actual_diff):\n    length_tomu = len(tomu)\n    length_motu = len(motu)\n    if length_motu > length_tomu:\n        motu = motu[1:]\n        length_motu = len(motu)\n    if K >= length_tomu:\n        K = length_tomu\n    (sum_tomu, sum_motu) = (0, 0)\n    for i in range(K):\n        sum_tomu = sum_tomu + tomu[i]\n        sum_motu = sum_motu + motu[length_motu - 1 - i]\n        K_diff = sum_motu - sum_tomu\n        if actual_diff < 2 * K_diff:\n            return True\n    return False\n\ndef main_logic(N, K, A):\n    (motu, tomu) = sort_arr(A, N)\n    actual_diff = sum(motu) - sum(tomu)\n    if actual_diff < 0:\n        return True\n    K_diff = find_k_diff(motu, tomu, K, actual_diff)\n    if K_diff:\n        return True\n    else:\n        return False\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        inp1 = input()\n        inp2 = input()\n        (N, K, A) = sort_inputs(inp1, inp2)\n        yes_or_no = main_logic(N, K, A)\n        if yes_or_no:\n            print('YES')\n        else:\n            print('NO')\nmain()", "for t in range(int(input())):\n    (n, k) = map(int, input().split(' '))\n    l = list(map(int, input().split(' ')))\n    t = []\n    m = []\n    for i in range(n):\n        if i % 2 == 0:\n            m.append(l[i])\n        else:\n            t.append(l[i])\n    for i in range(k):\n        max_in_motu = max(m)\n        min_in_tomu = min(t)\n        maloc = m.index(max_in_motu)\n        miloc = t.index(min_in_tomu)\n        t[miloc] = max_in_motu\n        m[maloc] = min_in_tomu\n    if sum(t) > sum(m):\n        print('YES')\n    else:\n        print('NO')", "tc = int(input())\nfor _ in range(tc):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    odd = []\n    even = []\n    for i in range(0, n - 1, 2):\n        odd.append(a[i])\n        even.append(a[i + 1])\n    if n % 2 == 1:\n        odd.append(a[n - 1])\n    gorb = False\n    if sum(even) > sum(odd):\n        gorb = True\n    else:\n        for i in range(k):\n            ma = max(odd)\n            odd.remove(ma)\n            mi = min(even)\n            even.remove(mi)\n            if mi == ma:\n                break\n            odd.append(mi)\n            even.append(ma)\n            if sum(even) > sum(odd):\n                gorb = True\n                break\n    print('YES' if gorb else 'NO')", "tc = int(input())\nfor _ in range(tc):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    odd = []\n    even = []\n    for i in range(0, n - 1, 2):\n        odd.append(a[i])\n        even.append(a[i + 1])\n    if n % 2 == 1:\n        odd.append(a[n - 1])\n    gorb = False\n    if sum(even) > sum(odd):\n        gorb = True\n    else:\n        for i in range(k):\n            ma = max(odd)\n            odd.remove(ma)\n            mi = min(even)\n            even.remove(mi)\n            odd.append(mi)\n            even.append(ma)\n            if sum(even) > sum(odd):\n                gorb = True\n                break\n    print('YES' if gorb else 'NO')", "def f(l, n, k):\n    k = min(n // 2, k)\n    a = sorted([l[i] for i in range(0, n, 2)], reverse=True)\n    b = sorted([l[i] for i in range(1, n, 2)])\n    for i in range(k):\n        if a[i] > b[i]:\n            (a[i], b[i]) = (b[i], a[i])\n        else:\n            break\n    return 'YES' if sum(b) > sum(a) else 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    print(f([int(i) for i in input().split()], n, k))", "def f(l, n, k):\n    k = min(n // 2, k)\n    a = sorted([l[i] for i in range(0, n, 2)], reverse=True)\n    b = sorted([l[i] for i in range(1, n, 2)])\n    for i in range(k):\n        if a[i] > b[i]:\n            (a[i], b[i]) = (b[i], a[i])\n        else:\n            break\n    return 'YES' if sum(b) > sum(a) else 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    print(f([int(i) for i in input().split()], n, k))", "def f(l, n, k):\n    k = min(n // 2, k)\n    a = sorted([l[i] for i in range(0, n, 2)], reverse=True)\n    b = sorted([l[i] for i in range(1, n, 2)])\n    t = 0\n    for i in range(k):\n        if a[i] > b[i]:\n            (a[i], b[i]) = (b[i], a[i])\n        else:\n            break\n    return 'YES' if sum(b) > sum(a) else 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    print(f([int(i) for i in input().split()], n, k))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l1 = [l[i] for i in range(0, n, 2)]\n    l2 = [l[i] for i in range(1, n, 2)]\n    if sum(l2) > sum(l1):\n        print('YES')\n    else:\n        l2.sort()\n        l1.sort(reverse=True)\n        for i in range(min(k, len(l2))):\n            (l1[i], l2[i]) = (l2[i], l1[i])\n            if sum(l2) > sum(l1):\n                print('YES')\n                break\n        else:\n            print('NO')", "t = int(input())\nfor _ in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    lst = [int(x) for x in input().split()]\n    l1 = []\n    l2 = []\n    for i in range(0, n, 2):\n        l1.append(lst[i])\n    for i in range(1, n, 2):\n        l2.append(lst[i])\n    l1.sort(reverse=True)\n    l2.sort()\n    tmp = 0\n    for i in range(k):\n        if l1[i] > l2[i] and i < n // 2:\n            tmp = l2[i]\n            l2[i] = l1[i]\n            l1[i] = tmp\n        else:\n            break\n    if sum(l2) > sum(l1):\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    lst = [int(x) for x in input().split()]\n    l1 = []\n    l2 = []\n    for i in range(0, n, 2):\n        l1.append(lst[i])\n    for i in range(1, n, 2):\n        l2.append(lst[i])\n    l1.sort(reverse=True)\n    l2.sort()\n    tmp = 0\n    for i in range(k):\n        if l1[i] > l2[i] and i < n // 2:\n            tmp = l2[i]\n            l2[i] = l1[i]\n            l1[i] = tmp\n        else:\n            break\n    if sum(l2) > sum(l1):\n        print('YES')\n    else:\n        print('NO')", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "for i in range(int(input())):\n    (x, k) = map(int, input().split())\n    y = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in range(x):\n        if i % 2:\n            b.append(y[i])\n        else:\n            a.append(y[i])\n    a.sort(reverse=1)\n    b.sort()\n    s1 = sum(a)\n    s2 = sum(b)\n    if s2 > s1:\n        print('YES')\n    else:\n        for i in range(min(k, len(a), len(b))):\n            s1 = s1 + b[i] - a[i]\n            s2 = s2 + a[i] - b[i]\n            if s2 > s1:\n                print('YES')\n                break\n        else:\n            print('NO')", "t = int(input())\nfor t in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    arr = [int(i) for i in input().split()]\n    (m, t) = ([], [])\n    i = 0\n    j = 1\n    while i < n:\n        if n % 2 == 0:\n            m.append(arr[i])\n            t.append(arr[j])\n        else:\n            m.append(arr[i])\n            if j < n - 1:\n                t.append(arr[j])\n        i += 2\n        j += 2\n    m = sorted(m, reverse=True)\n    t = sorted(t)\n    for i in range(len(t)):\n        if m[i] > t[i] and k > 0:\n            (m[i], t[i]) = (t[i], m[i])\n            k -= 1\n    sum_m = sum(m)\n    sum_t = sum(t)\n    if sum_t > sum_m:\n        print('YES')\n    else:\n        print('NO')", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "for i in range(0, int(input())):\n    (n, k) = map(int, input().split())\n    li = list(map(int, input().split()))\n    ms = 0\n    ts = 0\n    tomu = li[1::2]\n    monu = li[::2]\n    for i in range(k):\n        M = max(monu)\n        m = min(tomu)\n        if M > m:\n            ms += m\n            ts += M\n            tomu.remove(m)\n            monu.remove(M)\n    ts += sum(tomu)\n    ms += sum(monu)\n    print('YES') if ts > ms else print('NO')", "for i in range(0, int(input())):\n    (n, k) = map(int, input().split())\n    li = list(map(int, input().split()))\n    ms = 0\n    ts = 0\n    tomu = li[1::2]\n    monu = li[::2]\n    for i in range(k):\n        M = max(monu)\n        m = min(tomu)\n        if M > m:\n            ms += m\n            ts += M\n            tomu.remove(m)\n            monu.remove(M)\n    ts += sum(tomu)\n    ms += sum(monu)\n    print('YES') if ts > ms else print('NO')", "for i in range(0, int(input())):\n    (n, k) = map(int, input().split())\n    li = list(map(int, input().split()))\n    ms = 0\n    ts = 0\n    tomu = li[1::2]\n    monu = li[::2]\n    for i in range(k):\n        M = max(monu)\n        m = min(tomu)\n        if M > m:\n            ms += m\n            ts += M\n            tomu.remove(m)\n            monu.remove(M)\n    ts += sum(tomu)\n    ms += sum(monu)\n    print('YES') if ts > ms else print('NO')", "for i in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(input().split())\n    a = list(map(int, A))\n    Motu_score = 0\n    Tomu_score = 0\n    Tomu_list = a[1::2]\n    Motu_list = a[::2]\n    for i in range(K):\n        M = max(Motu_list)\n        m = min(Tomu_list)\n        if M > m:\n            Tomu_score += M\n            Motu_score += m\n            Motu_list.remove(M)\n            Tomu_list.remove(m)\n    Motu_score += sum(Motu_list)\n    Tomu_score += sum(Tomu_list)\n    if Motu_score >= Tomu_score:\n        print('NO')\n    else:\n        print('YES')", "T = int(input())\nfor i in range(T):\n    (N, K) = map(int, input().split())\n    A = list(input().split())\n    a = list(map(int, A))\n    Motu_score = 0\n    Tomu_score = 0\n    Tomu_list = a[1::2]\n    Motu_list = a[::2]\n    for i in range(K):\n        M = max(Motu_list)\n        m = min(Tomu_list)\n        if M > m:\n            Tomu_score += M\n            Motu_score += m\n            Motu_list.remove(M)\n            Tomu_list.remove(m)\n    Motu_score += sum(Motu_list)\n    Tomu_score += sum(Tomu_list)\n    if Motu_score >= Tomu_score:\n        print('NO')\n    else:\n        print('YES')", "for i in range(int(input())):\n    (N, K) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    odd_lst = []\n    even_lst = []\n    for i in range(N):\n        if i % 2:\n            odd_lst.append(lst[i])\n        else:\n            even_lst.append(lst[i])\n    even_lst = sorted(even_lst)[::-1]\n    odd_lst = sorted(odd_lst)\n    for i in range(min(K, len(even_lst), len(odd_lst))):\n        if even_lst[i] > odd_lst[i]:\n            (odd_lst[i], even_lst[i]) = (even_lst[i], odd_lst[i])\n    if sum(even_lst) >= sum(odd_lst):\n        print('NO')\n    else:\n        print('YES')", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "t = int(input())\nfor i in range(t):\n    (n, k) = input().split()\n    n = int(n)\n    k = int(k)\n    A = [int(x) for x in input().split()]\n    B = []\n    b = 0\n    c = 0\n    C = []\n    for j in range(n):\n        if j % 2 == 0:\n            B.append(A[j])\n            b += A[j]\n        else:\n            C.append(A[j])\n            c += A[j]\n    B.sort()\n    C.sort()\n    ans = 0\n    if c > b:\n        print('YES')\n    else:\n        for j in range(min(len(C), k)):\n            b = b - B[len(B) - j - 1] + C[j]\n            c = c + B[len(B) - j - 1] - C[j]\n            if c > b:\n                ans = 1\n                break\n        if ans == 1:\n            print('YES')\n        else:\n            print('NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    odd = []\n    even = []\n    for i in range(n):\n        if i % 2:\n            odd.append(l[i])\n        else:\n            even.append(l[i])\n    even = sorted(even)[::-1]\n    odd = sorted(odd)\n    for i in range(min(k, len(even), len(odd))):\n        if even[i] > odd[i]:\n            (odd[i], even[i]) = (even[i], odd[i])\n    if sum(even) >= sum(odd):\n        print('NO')\n    else:\n        print('YES')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    (odds, evens) = ([l[i] for i in range(len(l)) if i % 2 != 0], [l[i] for i in range(len(l)) if i % 2 == 0])\n    odds.sort()\n    evens.sort(reverse=True)\n    for i in range(min(len(evens), len(odds), k)):\n        if odds[i] < evens[i]:\n            (odds[i], evens[i]) = (evens[i], odds[i])\n    print('YES' if sum(odds) > sum(evens) else 'NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    odd = []\n    even = []\n    for i in range(n):\n        if i % 2:\n            odd.append(l[i])\n        else:\n            even.append(l[i])\n    even = sorted(even)[::-1]\n    odd = sorted(odd)\n    for i in range(min(k, len(even), len(odd))):\n        if even[i] > odd[i]:\n            (odd[i], even[i]) = (even[i], odd[i])\n    if sum(even) >= sum(odd):\n        print('NO')\n    else:\n        print('YES')", "for _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = []\n    c = []\n    for i in range(0, n):\n        if i % 2 == 0:\n            b.append(a[i])\n        else:\n            c.append(a[i])\n    for i in range(x):\n        k = max(b)\n        l = min(c)\n        b.remove(k)\n        c.append(k)\n        b.append(l)\n        c.remove(l)\n    if sum(c) > sum(b):\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = []\n    c = []\n    for i in range(0, n):\n        if i % 2 == 0:\n            b.append(a[i])\n        else:\n            c.append(a[i])\n    for i in range(x):\n        k = max(b)\n        l = min(c)\n        b.remove(k)\n        c.append(k)\n        b.append(l)\n        c.remove(l)\n    if sum(c) > sum(b):\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (length, swap) = (int(x) for x in input().split())\n    sequence = [int(x) for x in input().split()]\n    motu = []\n    tomu = []\n    motu_sc = 0\n    tomu_sc = 0\n    for i in range(0, length, 2):\n        motu.append(sequence[i])\n        motu_sc += sequence[i]\n        if i == length - 1 and (length - 1) % 2 == 0:\n            break\n        tomu.append(sequence[i + 1])\n        tomu_sc += sequence[i + 1]\n    if tomu_sc > motu_sc:\n        print('YES')\n        continue\n    elif tomu_sc < motu_sc and swap == 0:\n        print('NO')\n        continue\n    for _ in '.' * swap:\n        (tomu[tomu.index(min(tomu))], motu[motu.index(max(motu))]) = (max(motu), min(tomu))\n        swap -= 1\n        if swap == 0:\n            break\n    if sum(tomu) > sum(motu):\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    l = [int(x) for x in input().split()]\n    l1 = l[0::2]\n    l2 = l[1::2]\n    while k != 0:\n        m = l1.index(max(l1))\n        n = l2.index(min(l2))\n        (l1[m], l2[n]) = (l2[n], l1[m])\n        k -= 1\n    if sum(l1) < sum(l2):\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, S) = [int(x) for x in input().split()]\n    P = [int(x) for x in input().split()]\n    M = [x for (i, x) in enumerate(P) if not i % 2]\n    T = [x for (i, x) in enumerate(P) if i % 2]\n    M.sort()\n    T.sort()\n    i = 0\n    st = sum(T)\n    sm = sum(M)\n    while S > 0 and st <= sm and (i < len(T)):\n        st += M[~i] - T[i]\n        sm += T[i] - M[~i]\n        S -= 1\n        i += 1\n    print('YES' if st > sm else 'NO')", "from math import sqrt, ceil, floor, gcd, log2\nimport sys\nfrom sys import stdin, stdout\nfrom collections import Counter, defaultdict, OrderedDict, deque\nfrom itertools import combinations, groupby\nfrom time import time\nfrom heapq import heappop, heappush, heapify\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    (m, t) = ([], [])\n    for i in range(n):\n        if i % 2:\n            t.append(arr[i])\n        else:\n            m.append(arr[i])\n    if sum(t) > sum(m):\n        print('YES')\n    else:\n        m.sort(reverse=True)\n        t.sort()\n        s = sum(t)\n        ms = sum(m)\n        i = 0\n        flag = 0\n        while k:\n            if i < len(t) and i < len(m):\n                s -= t[i]\n                s += m[i]\n                ms -= m[i]\n                ms += t[i]\n                if s > ms:\n                    print('YES')\n                    flag = 1\n                    break\n            i += 1\n            k -= 1\n        if not flag:\n            print('NO')", "for _ in range(int(input())):\n    (n, swaps) = [int(x) for x in input().split()]\n    points = [int(x) for x in input().split()]\n    motus = [x for (i, x) in enumerate(points) if not i % 2]\n    tomus = [x for (i, x) in enumerate(points) if i % 2]\n    motus.sort()\n    tomus.sort()\n    i = 0\n    st = sum(tomus)\n    sm = sum(motus)\n    while swaps > 0 and st <= sm and (i < len(tomus)):\n        st += motus[~i] - tomus[i]\n        sm += tomus[i] - motus[~i]\n        swaps -= 1\n        i += 1\n    print('YES' if st > sm else 'NO')", "for _ in range(int(input())):\n    (n, swaps) = [int(x) for x in input().split()]\n    points = [int(x) for x in input().split()]\n    motus = [x for (i, x) in enumerate(points) if not i % 2]\n    tomus = [x for (i, x) in enumerate(points) if i % 2]\n    motus.sort()\n    tomus.sort()\n    i = 0\n    while swaps > 0 and sum(tomus) < sum(motus) and (i < len(tomus)):\n        (tomus[i], motus[~i]) = (motus[~i], tomus[i])\n        swaps -= 1\n        i += 1\n    print('YES' if sum(tomus) > sum(motus) else 'NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    (motu, tomu) = ([], [])\n    for i in range(0, n, 2):\n        if i == n - 1:\n            motu.append(arr[i])\n        else:\n            motu.append(arr[i])\n            tomu.append(arr[i + 1])\n    for i in range(k):\n        (high, low) = (max(motu), min(tomu))\n        if high > low:\n            motu.remove(high)\n            motu.append(low)\n            tomu.remove(low)\n            tomu.append(high)\n        else:\n            break\n    print('YES') if sum(tomu) > sum(motu) else print('NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    (motu, tomu) = ([], [])\n    for i in range(0, n, 2):\n        if i == n - 1:\n            motu.append(arr[i])\n        else:\n            motu.append(arr[i])\n            tomu.append(arr[i + 1])\n    for i in range(k):\n        (high, low) = (max(motu), min(tomu))\n        if high > low:\n            motu.remove(high)\n            motu.append(low)\n            tomu.remove(low)\n            tomu.append(high)\n        else:\n            break\n    print('YES') if sum(tomu) > sum(motu) else print('NO')", "t = int(input())\nwhile t > 0:\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l1 = []\n    l2 = []\n    flag = 0\n    for i in range(n):\n        if i % 2 == 0:\n            l1 = l1 + [l[i]]\n        else:\n            l2 = l2 + [l[i]]\n    a = sum(l1)\n    b = sum(l2)\n    if b > a:\n        print('YES')\n        flag = 1\n    else:\n        for i in range(k):\n            x = max(l1)\n            y = min(l2)\n            a -= x\n            b -= y\n            a += y\n            b += x\n            if b > a:\n                print('YES')\n                flag = 1\n                break\n    if flag == 0:\n        print('NO')\n    t -= 1", "t = int(input())\nwhile t > 0:\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l1 = []\n    l2 = []\n    flag = 0\n    for i in range(n):\n        if i % 2 == 0:\n            l1.append(l[i])\n        else:\n            l2.append(l[i])\n    a = sum(l1)\n    b = sum(l2)\n    if b > a:\n        print('YES')\n        flag = 1\n    else:\n        for i in range(k):\n            x = max(l1)\n            y = min(l2)\n            a -= x\n            b -= y\n            a += y\n            b += x\n            if b > a:\n                print('YES')\n                flag = 1\n                break\n    if flag == 0:\n        print('NO')\n    t -= 1", "t = int(input())\nwhile t > 0:\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l1 = []\n    l2 = []\n    flag = 0\n    for i in range(n):\n        if i % 2 == 0:\n            l1.append(l[i])\n        else:\n            l2.append(l[i])\n    if sum(l2) > sum(l1):\n        print('YES')\n        flag = 1\n    else:\n        for i in range(k):\n            x = max(l1)\n            y = min(l2)\n            l1.remove(x)\n            l2.remove(y)\n            l1.append(y)\n            l2.append(x)\n            if sum(l2) > sum(l1):\n                print('YES')\n                flag = 1\n                break\n    if flag == 0:\n        print('NO')\n    t -= 1", "a = int(input(''))\nfor i in range(a):\n    (N, K) = [int(x) for x in input('').split()]\n    t = [int(x) for x in input('').split()]\n    l1 = [t[i] for i in range(0, N, 2)]\n    l2 = [t[j] for j in range(1, N, 2)]\n    for h in range(K):\n        m1 = max(l1)\n        m2 = min(l2)\n        l1.remove(m1)\n        l2.remove(m2)\n        l1.append(m2)\n        l2.append(m1)\n    if sum(l2) > sum(l1):\n        print('YES')\n    else:\n        print('NO')", "a = int(input(''))\nfor i in range(a):\n    (N, K) = [int(x) for x in input('').split()]\n    t = [int(x) for x in input('').split()]\n    l1 = [t[i] for i in range(0, N, 2)]\n    l2 = [t[j] for j in range(1, N, 2)]\n    for h in range(K):\n        m1 = max(l1)\n        m2 = min(l2)\n        l1.remove(m1)\n        l2.remove(m2)\n        l1.append(m2)\n        l2.append(m1)\n    if sum(l1) < sum(l2):\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    lm = []\n    lt = []\n\n    def suml(l):\n        t = 0\n        for i in l:\n            t += i\n        return t\n    for i in range(n):\n        if i % 2 == 0:\n            lm.append(lst[i])\n        else:\n            lt.append(lst[i])\n    lt.sort()\n    lm.sort(reverse=True)\n    for j in range(len(lt)):\n        if lt[j] < lm[j] and k > 0:\n            flag = lt[j]\n            lt[j] = lm[j]\n            lm[j] = flag\n            k -= 1\n    if suml(lt) > suml(lm):\n        print('YES')\n    else:\n        print('NO')", "a = int(input(''))\nfor i in range(a):\n    (N, K) = [int(x) for x in input('').split()]\n    t = [int(x) for x in input('').split()]\n    l1 = [t[i] for i in range(0, N, 2)]\n    l2 = [t[j] for j in range(1, N, 2)]\n    for h in range(K):\n        m1 = max(l1)\n        m2 = min(l2)\n        l1.remove(m1)\n        l2.remove(m2)\n        l1.append(m2)\n        l2.append(m1)\n    if sum(l1) < sum(l2):\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    xm = [lst[i] for i in range(0, n, 2)]\n    xt = [lst[i] for i in range(1, n, 2)]\n    for i in range(k):\n        mx = max(xm)\n        mi = min(xt)\n        xm.remove(mx)\n        xt.remove(mi)\n        xm.append(mi)\n        xt.append(mx)\n    if sum(xm) < sum(xt):\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    xm = [lst[i] for i in range(0, n, 2)]\n    xt = [lst[i] for i in range(1, n, 2)]\n    for i in range(k):\n        mx = max(xm)\n        mi = min(xt)\n        xm.remove(mx)\n        xt.remove(mi)\n        xm.append(mi)\n        xt.append(mx)\n    if sum(xm) < sum(xt):\n        print('YES')\n    else:\n        print('NO')", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "z = int(input())\nwhile z:\n    z -= 1\n    (a, b) = map(int, input().split())\n    l = list(map(int, input().split()))\n    (m, t) = ([], [])\n    for i in range(0, a):\n        if i % 2 == 0:\n            m.append(l[i])\n        else:\n            t.append(l[i])\n    m = sorted(m)\n    t = sorted(t)\n    while b:\n        b -= 1\n        h = m.pop(-1)\n        k = t.pop(0)\n        if h > k:\n            t.append(h)\n            m.insert(0, k)\n        else:\n            t.append(k)\n            m.insert(0, h)\n    if sum(t) > sum(m):\n        print('YES')\n    else:\n        print('NO')", "z = int(input())\nwhile z:\n    z -= 1\n    (a, b) = map(int, input().split())\n    l = list(map(int, input().split()))\n    (m, t) = ([], [])\n    for i in range(0, a):\n        if i % 2 == 0:\n            m.append(l[i])\n        else:\n            t.append(l[i])\n    m = sorted(m)\n    t = sorted(t)\n    while b:\n        b -= 1\n        h = m.pop(-1)\n        k = t.pop(0)\n        if h > k:\n            t.append(h)\n            m.insert(0, k)\n        else:\n            t.append(k)\n            m.insert(0, h)\n    if sum(t) > sum(m):\n        print('YES')\n    else:\n        print('NO')", "for i in range(int(input())):\n    (a, b) = map(int, input().split())\n    x = list(map(int, input().split()))\n    A = sorted(x[0::2])\n    B = sorted(x[1::2])\n    for i in range(min(b, len(A))):\n        if i < len(B) and sum(A) > sum(B):\n            (A[len(A) - i - 1], B[i]) = (B[i], A[len(A) - i - 1])\n    if sum(B) > sum(A):\n        print('YES')\n    else:\n        print('NO')", "z = int(input())\nwhile z:\n    z -= 1\n    (a, b) = map(int, input().split())\n    l = list(map(int, input().split()))\n    (m, t) = ([], [])\n    for i in range(0, a):\n        if i % 2 == 0:\n            m.append(l[i])\n        else:\n            t.append(l[i])\n    m = sorted(m)\n    t = sorted(t)\n    while b:\n        b -= 1\n        h = m.pop(-1)\n        k = t.pop(0)\n        if h > k:\n            t.append(h)\n            m.insert(0, k)\n        else:\n            t.append(k)\n            m.insert(0, h)\n    if sum(t) > sum(m):\n        print('YES')\n    else:\n        print('NO')", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "for i in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    (a1, b1) = ([], [])\n    alternate = True\n    for j in a:\n        if alternate:\n            a1.append(j)\n            alternate = False\n        else:\n            b1.append(j)\n            alternate = True\n    s1 = sum(a1)\n    s2 = sum(b1)\n    if s1 < s2:\n        print('YES')\n    else:\n        a1.sort(reverse=True)\n        b1.sort()\n        for j in range(0, n // 2):\n            if k:\n                k -= 1\n                if a1[j] >= b1[j]:\n                    s1 = s1 - a1[j] + b1[j]\n                    s2 = s2 - b1[j] + a1[j]\n                    (a1[j], b1[j]) = (b1[j], a1[j])\n                else:\n                    break\n        if s1 < s2:\n            print('YES')\n        else:\n            print('NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    (odd, even) = ([], [])\n    for i in range(n):\n        if i & 1 == 0:\n            even.append(arr[i])\n        else:\n            odd.append(arr[i])\n    odd.sort()\n    even.sort(reverse=True)\n    for i in range(len(odd)):\n        if odd[i] < even[i] and k > 0:\n            (odd[i], even[i]) = (even[i], odd[i])\n            k -= 1\n    if sum(odd) > sum(even):\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    (odd, even) = ([], [])\n    for i in range(n):\n        if i & 1 == 0:\n            even.append(arr[i])\n        else:\n            odd.append(arr[i])\n    odd.sort()\n    even.sort(reverse=True)\n    for i in range(len(odd)):\n        if odd[i] < even[i] and k > 0:\n            (odd[i], even[i]) = (even[i], odd[i])\n            k -= 1\n    if sum(odd) > sum(even):\n        print('YES')\n    else:\n        print('NO')", "import heapq\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    tom = []\n    motu = []\n    t_s = 0\n    m_s = 0\n    heapq.heapify(motu)\n    heapq.heapify(tom)\n    for i in range(n):\n        if i & 1 == 1:\n            heapq.heappush(tom, arr[i])\n            t_s += arr[i]\n        else:\n            heapq.heappush(motu, -arr[i])\n            m_s += arr[i]\n    flag = 0\n    while k != 0:\n        k -= 1\n        if t_s > m_s:\n            flag = 1\n            break\n        m_max = -heapq.heappop(motu)\n        t_min = heapq.heappop(tom)\n        heapq.heappush(motu, -t_min)\n        heapq.heappush(tom, m_max)\n        m_s = m_s + t_min - m_max\n        t_s = t_s + m_max - t_min\n    if t_s > m_s:\n        flag = 1\n    if flag == 0:\n        print('NO')\n    else:\n        print('YES')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    (odd, even) = ([], [])\n    for i in range(n):\n        if i & 1 == 0:\n            even.append(arr[i])\n        else:\n            odd.append(arr[i])\n    odd.sort()\n    even.sort(reverse=True)\n    for i in range(len(odd)):\n        if odd[i] < even[i] and k > 0:\n            (odd[i], even[i]) = (even[i], odd[i])\n            k -= 1\n    if sum(odd) > sum(even):\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    fr = list(map(int, input().split()))\n    to = []\n    mo = []\n    for i in range(n):\n        if i % 2 != 0:\n            to.append(fr[i])\n        else:\n            mo.append(fr[i])\n    to.sort()\n    mo.sort(reverse=True)\n    for i in range(len(to)):\n        if to[i] < mo[i] and k > 0:\n            (to[i], mo[i]) = (mo[i], to[i])\n            k -= 1\n    if sum(to) > sum(mo):\n        print('YES')\n    else:\n        print('NO')", "for tc in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    motu = []\n    tomu = []\n    for i in range(n):\n        if i % 2 == 0:\n            motu.append(a[i])\n        else:\n            tomu.append(a[i])\n    motu.sort(reverse=True)\n    tomu.sort()\n    for i in range(len(tomu)):\n        if tomu[i] < motu[i] and k > 0:\n            (tomu[i], motu[i]) = (motu[i], tomu[i])\n            k -= 1\n    if sum(tomu) > sum(motu):\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (N, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    m = 0\n    t = 0\n    mo = sorted(l[0:N:2])\n    to = sorted(l[1:N:2])\n    k = min(len(to), k)\n    for i in range(k):\n        if mo[len(mo) - i - 1] > to[i]:\n            temp = to[i]\n            to[i] = mo[len(mo) - i - 1]\n            mo[len(mo) - i - 1] = temp\n    m = sum(mo)\n    t = sum(to)\n    if t > m:\n        print('YES')\n    else:\n        print('NO')", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "import heapq as heap\n\ndef Solve(l, n, k):\n    (motu, tomu) = ([], [])\n    heap.heapify(motu)\n    heap.heapify(tomu)\n    (motu_score, tomu_score) = (0, 0)\n    for i in range(n):\n        if i & 1 == 1:\n            tomu_score += l[i]\n            heap.heappush(tomu, l[i])\n        else:\n            motu_score += l[i]\n            heap.heappush(motu, -l[i])\n    while k != 0:\n        if tomu_score > motu_score:\n            return 'YES'\n        max_motu = -heap.heappop(motu)\n        min_tomu = heap.heappop(tomu)\n        heap.heappush(motu, -min_tomu)\n        heap.heappush(tomu, max_motu)\n        tomu_score = tomu_score - min_tomu + max_motu\n        motu_score = motu_score - max_motu + min_tomu\n        k = k - 1\n    if tomu_score > motu_score:\n        return 'YES'\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(Solve(l, n, k))", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    m = a[::2]\n    t = a[1::2]\n    for i in range(k):\n        m_v = min(t)\n        t[t.index(min(t))] = max(m)\n        m[m.index(max(m))] = m_v\n    if sum(t) > sum(m):\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    A = [int(x) for x in input().split()]\n    M = A[::2]\n    T = A[1::2]\n    for _ in range(k):\n        minval = min(T)\n        T[T.index(min(T))] = max(M)\n        M[M.index(max(M))] = minval\n    if sum(T) > sum(M):\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    m = [a[i] for i in range(len(a)) if i % 2 == 0]\n    t = [a[i] for i in range(len(a)) if i % 2 != 0]\n    ms = sum(m)\n    ts = sum(t)\n    if ms >= ts:\n        for i in range(k):\n            maxm = max(m)\n            mint = min(t)\n            mindex = m.index(maxm)\n            tindex = t.index(mint)\n            (m[mindex], t[tindex]) = (t[tindex], m[mindex])\n        if sum(m) >= sum(t):\n            print('NO')\n        else:\n            print('YES')\n    else:\n        print('YES')", "T = int(input())\nfor _ in range(T):\n    (N, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    m = 0\n    t = 0\n    mo = sorted(l[0:N:2])\n    to = sorted(l[1:N:2])\n    k = min(len(to), k)\n    for i in range(k):\n        if mo[len(mo) - i - 1] > to[i]:\n            temp = to[i]\n            to[i] = mo[len(mo) - i - 1]\n            mo[len(mo) - i - 1] = temp\n    m = sum(mo)\n    t = sum(to)\n    if t > m:\n        print('YES')\n    else:\n        print('NO')"]