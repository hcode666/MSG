["def knapsack(l, t, n, w):\n    dp = [[0 for j in range(w + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, w + 1):\n            if t[i - 1] <= j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - t[i - 1]] + l[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][w]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    (c, p, t) = ([], [], [])\n    for i in range(n):\n        (x, y, z) = map(int, input().split())\n        c.append(x)\n        p.append(y)\n        t.append(z)\n    l = []\n    for i in range(n):\n        l.append(c[i] * p[i])\n    print(knapsack(l, t, n, w))", "def maximal_points(T, tests):\n    for t in range(T):\n        (N, W) = map(int, input().split())\n        (C, P, T) = ([], [], [])\n        for i in range(N):\n            (c, p, t) = map(int, input().split())\n            C.append(c)\n            P.append(p)\n            T.append(t)\n        dp = [[0 for j in range(W + 1)] for i in range(N + 1)]\n        for i in range(1, N + 1):\n            for j in range(1, W + 1):\n                if j < T[i - 1]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - T[i - 1]] + C[i - 1] * P[i - 1])\n        print(dp[N][W])\nT = int(input())\ntests = [0] * T\nmaximal_points(T, tests)", "T = int(input())\nfor _ in range(T):\n    (N, W) = map(int, input().split())\n    CPT = [tuple(map(int, input().split())) for _ in range(N)]\n    dp = [[0] * (W + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        (c, p, t) = CPT[i - 1]\n        for j in range(W + 1):\n            if j >= t:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - t] + c * p)\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print(dp[N][W])", "T = int(input())\nfor _ in range(T):\n    (N, W) = map(int, input().split())\n    CPT = [tuple(map(int, input().split())) for _ in range(N)]\n    dp = [[0] * (W + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        (c, p, t) = CPT[i - 1]\n        for j in range(W + 1):\n            if j >= t:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - t] + c * p)\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print(dp[N][W])", "for _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    cost = []\n    weight = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        cost.append(c * p)\n        weight.append(t)\n    l = [[-1 for i in range(w + 1)] for j in range(len(weight) + 1)]\n    for i in range(len(weight) + 1):\n        l[i][0] = 0\n    for i in range(1, len(weight) + 1):\n        for j in range(1, w + 1):\n            if weight[i - 1] <= j:\n                if l[i - 1][j - weight[i - 1]] != -1 and l[i - 1][j] != -1:\n                    l[i][j] = max(l[i - 1][j], l[i - 1][j - weight[i - 1]] + cost[i - 1])\n                if l[i - 1][j - weight[i - 1]] == -1 and l[i - 1][j] != -1:\n                    l[i][j] = l[i - 1][j]\n                if l[i - 1][j - weight[i - 1]] != -1 and l[i - 1][j] == -1:\n                    l[i][j] = l[i - 1][j - weight[i - 1]] + cost[i - 1]\n            elif l[i - 1][j] != -1:\n                l[i][j] = l[i - 1][j]\n    print(max(*l[-1]))", "def solve_test_case():\n    (n, w) = map(int, input().split())\n    dp = [[0] * (w + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        (c, p, t) = map(int, input().split())\n        for j in range(1, w + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= t and dp[i - 1][j - t] + c * p > dp[i][j]:\n                dp[i][j] = dp[i - 1][j - t] + c * p\n    return dp[n][w]\nt = int(input())\nfor _ in range(t):\n    print(solve_test_case())", "def solve_test_case():\n    (n, w) = map(int, input().split())\n    dp = [[0] * (w + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        (c, p, t) = map(int, input().split())\n        for j in range(1, w + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= t and dp[i - 1][j - t] + c * p > dp[i][j]:\n                dp[i][j] = dp[i - 1][j - t] + c * p\n    return dp[n][w]\nt = int(input())\nfor _ in range(t):\n    print(solve_test_case())", "def solve_test_case():\n    (n, w) = map(int, input().split())\n    dp = [[0] * (w + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        (c, p, t) = map(int, input().split())\n        for j in range(1, w + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= t and dp[i - 1][j - t] + c * p > dp[i][j]:\n                dp[i][j] = dp[i - 1][j - t] + c * p\n    return dp[n][w]\nt = int(input())\nfor _ in range(t):\n    print(solve_test_case())", "def solve_test_case():\n    (n, w) = map(int, input().split())\n    dp = [[0] * (w + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        (c, p, t) = map(int, input().split())\n        for j in range(1, w + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= t and dp[i - 1][j - t] + c * p > dp[i][j]:\n                dp[i][j] = dp[i - 1][j - t] + c * p\n    return dp[n][w]\nt = int(input())\nfor _ in range(t):\n    print(solve_test_case())", "T = int(input())\nfor t in range(T):\n    (N, W) = map(int, input().split())\n    C = [0] * N\n    P = [0] * N\n    T = [0] * N\n    for i in range(N):\n        (C[i], P[i], T[i]) = map(int, input().split())\n    dp = [[0] * (W + 1) for i in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, W + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= T[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - T[i - 1]] + P[i - 1] * C[i - 1])\n    print(dp[N][W])", "def knapSack(W, wt, val, n):\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if wt[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - wt[i - 1]] + val[i - 1])\n    return dp[W]\n\ndef soln(n, W, c, p, t):\n    res = 0\n    val = [c[i] * p[i] for i in range(n)]\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if t[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - t[i - 1]] + val[i - 1])\n    return dp[W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    c = []\n    p = []\n    t = []\n    for i in range(n):\n        (x, y, z) = map(int, input().split())\n        c.append(x)\n        p.append(y)\n        t.append(z)\n    print(soln(n, w, c, p, t))", "T = int(input())\nfor t in range(T):\n    (N, W) = map(int, input().split())\n    C = [0 for i in range(N)]\n    P = [0 for i in range(N)]\n    T = [0 for i in range(N)]\n    for n in range(N):\n        (C[n], P[n], T[n]) = map(int, input().split())\n    dp = [[0 for j in range(W + 1)] for i in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(W + 1):\n            if j >= T[i - 1]:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - T[i - 1]] + C[i - 1] * P[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print(dp[N][W])", "T = int(input())\nfor t in range(T):\n    (N, W) = map(int, input().split())\n    C = [0 for i in range(N)]\n    P = [0 for i in range(N)]\n    T = [0 for i in range(N)]\n    for n in range(N):\n        (C[n], P[n], T[n]) = map(int, input().split())\n    dp = [[0 for j in range(W + 1)] for i in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(W + 1):\n            if j >= T[i - 1]:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - T[i - 1]] + C[i - 1] * P[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print(dp[N][W])", "T = int(input())\nfor t in range(T):\n    (N, W) = map(int, input().split())\n    C = [0 for i in range(N)]\n    P = [0 for i in range(N)]\n    T = [0 for i in range(N)]\n    for n in range(N):\n        (C[n], P[n], T[n]) = map(int, input().split())\n    dp = [[0 for j in range(W + 1)] for i in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(W + 1):\n            if j >= T[i - 1]:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - T[i - 1]] + C[i - 1] * P[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print(dp[N][W])", "def maxpoint(time, points, i, w, memo):\n    key = (i, w)\n    if key in memo:\n        return memo[key]\n    if w <= 0:\n        return 0\n    if i >= len(time):\n        return 0\n    take = 0\n    if w - time[i] >= 0:\n        take = points[i] + maxpoint(time, points, i + 1, w - time[i], memo)\n    nottake = maxpoint(time, points, i + 1, w, memo)\n    memo[key] = max(take, nottake)\n    return memo[key]\ncase = int(input())\nfor _ in range(case):\n    (n, w) = map(int, input().split(' '))\n    points = []\n    time = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split(' '))\n        points.append(c * p)\n        time.append(t)\n    memo = {}\n    res = maxpoint(time, points, 0, w, memo)\n    print(res)", "NBCASE = int(input())\nfor ncase in range(NBCASE):\n    s = input()\n    T = []\n    Val = []\n    (N, W) = map(int, s.split(' '))\n    for i in range(N):\n        s = input()\n        (c, p, t) = map(int, s.split(' '))\n        T.append(t)\n        Val.append(c * p)\n    DP = [[0 for j in range(1 + W)] for i in range(1 + N)]\n    for i in range(1, N + 1):\n        for j in range(1, W + 1):\n            if T[i - 1] > j:\n                DP[i][j] = DP[i - 1][j]\n            else:\n                DP[i][j] = max(Val[i - 1] + DP[i - 1][j - T[i - 1]], DP[i - 1][j])\n    print(DP[N][W])", "import numpy as np\nt = int(input())\nfor _ in range(t):\n    (n, w) = map(int, input().split())\n    C = []\n    P = []\n    T = []\n    for _ in range(n):\n        (c, p, t) = map(int, input().split())\n        C.append(c)\n        P.append(p)\n        T.append(t)\n    S = np.zeros((n + 1, w + 1), int)\n    for i in range(1, n + 1):\n        time = T[i - 1]\n        total_score = P[i - 1] * C[i - 1]\n        for a in range(w + 1):\n            if a < time:\n                S[i][a] = S[i - 1][a]\n            else:\n                S[i][a] = max(S[i - 1][a], S[i - 1][a - time] + total_score)\n    print(S[n][w])", "def knapsack(l1, l2, W, n):\n    dp = [0 for i in range(W + 1)]\n    for i in range(n):\n        for w in range(W, 0, -1):\n            if l2[i] <= w:\n                dp[w] = max(dp[w], dp[w - l2[i]] + l1[i])\n    return dp[W]\nt = int(input())\nfor i in range(t):\n    (n, w) = map(int, input().split())\n    l1 = []\n    l2 = []\n    for j in range(n):\n        (c, p, t) = map(int, input().split())\n        l1 += [c * p]\n        l2 += [t]\n    ans = knapsack(l1, l2, w, n)\n    print(ans)", "import numpy as np\nimport random\n\ndef polodp(times, points, total_time, total_ques):\n    l = [[0 for _ in range(total_time + 1)] for _ in range(total_ques + 1)]\n    for idx1 in range(total_ques + 1):\n        for idx2 in range(total_time + 1):\n            if idx1 == 0 or idx2 == 0:\n                l[idx1][idx2] = 0\n            elif times[idx1 - 1] <= idx2:\n                l[idx1][idx2] = max(points[idx1 - 1] + l[idx1 - 1][idx2 - times[idx1 - 1]], l[idx1 - 1][idx2])\n            else:\n                l[idx1][idx2] = l[idx1 - 1][idx2]\n    return l[-1][-1]\nfor i in range(int(input())):\n    (n, total_time) = map(int, input().split())\n    (times, points) = ([], [])\n    for _ in range(n):\n        (c, p, t) = map(int, input().split())\n        times.append(t)\n        points.append(c * p)\n    print(polodp(times, points, total_time, n))", "for _ in range(int(input())):\n    (n, w) = list(map(int, input().split()))\n    questions = []\n    for _ in range(n):\n        (c, p, t) = list(map(int, input().split()))\n        questions.append((c * p, t))\n    dp = [[0] * (w + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, w + 1):\n            case1 = dp[i - 1][j]\n            case2 = 0\n            if j >= questions[i - 1][1]:\n                case2 = dp[i - 1][j - questions[i - 1][1]] + questions[i - 1][0]\n            dp[i][j] = max(case1, case2)\n    print(dp[n][w])", "t = int(input())\nfor _ in range(t):\n    (n, w) = map(int, input().split())\n    items = []\n    for _ in range(n):\n        (c, p, t) = map(int, input().split())\n        items.append((c * p, t))\n    dp = [[0 for _ in range(w + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, w + 1):\n            if j < items[i - 1][1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - items[i - 1][1]] + items[i - 1][0])\n    print(dp[n][w])", "def max_points(N, W, C, P, T):\n    dp = [[0] * (W + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, W + 1):\n            case1 = dp[i - 1][j]\n            case2 = 0\n            if j >= T[i - 1]:\n                case2 = dp[i - 1][j - T[i - 1]] + C[i - 1] * P[i - 1]\n            dp[i][j] = max(case1, case2)\n    return dp[N][W]\nT = int(input())\nfor _ in range(T):\n    (N, W) = map(int, input().split())\n    C = []\n    P = []\n    T = []\n    for _ in range(N):\n        (c, p, t) = map(int, input().split())\n        C.append(c)\n        P.append(p)\n        T.append(t)\n    result = max_points(N, W, C, P, T)\n    print(result)", "for _ in range(int(input())):\n    (n, W) = map(int, input().split())\n    p = []\n    q = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        p.append(l[0] * l[1])\n        q.append(l[2])\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if w >= q[i - 1]:\n                dp[w] = max(dp[w], dp[w - q[i - 1]] + p[i - 1])\n    print(dp[W])", "def knapSack(W, wt, val, n):\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if wt[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - wt[i - 1]] + val[i - 1])\n    return dp[W]\n\ndef soln(n, W, c, p, t):\n    res = 0\n    val = [c[i] * p[i] for i in range(n)]\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if t[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - t[i - 1]] + val[i - 1])\n    return dp[W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    c = []\n    p = []\n    t = []\n    for i in range(n):\n        (x, y, z) = map(int, input().split())\n        c.append(x)\n        p.append(y)\n        t.append(z)\n    print(soln(n, w, c, p, t))", "def knapSack(W, wt, val, n):\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if wt[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - wt[i - 1]] + val[i - 1])\n    return dp[W]\n\ndef soln(n, W, c, p, t):\n    res = 0\n    val = [c[i] * p[i] for i in range(n)]\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if t[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - t[i - 1]] + val[i - 1])\n    return dp[W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    c = []\n    p = []\n    t = []\n    for i in range(n):\n        (x, y, z) = map(int, input().split())\n        c.append(x)\n        p.append(y)\n        t.append(z)\n    print(soln(n, w, c, p, t))", "for _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    l = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        l.append([t, c * p])\n    l.sort()\n    score = []\n    time = []\n    for i in l:\n        time.append(i[0])\n        score.append(i[1])\n    m = [[0 for x in range(w + 1)] for y in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, w + 1):\n            if j < time[i - 1]:\n                m[i][j] = m[i - 1][j]\n            else:\n                m[i][j] = max(m[i - 1][j], m[i - 1][j - time[i - 1]] + score[i - 1])\n    print(m[-1][-1])", "t = int(input())\nfor _ in range(t):\n    (m, w) = [int(x) for x in input().split()]\n    score = []\n    weight = []\n    for line in range(m):\n        (a, b, c) = [int(x) for x in input().split()]\n        score.append(a * b)\n        weight.append(c)\n    n = len(score)\n    t = [[-1 for i in range(w + 1)] for j in range(n + 1)]\n\n    def knapsack(wt, val, W, n):\n        if n == 0 or W == 0:\n            return 0\n        if t[n][W] != -1:\n            return t[n][W]\n        if wt[n - 1] <= W:\n            t[n][W] = max(val[n - 1] + knapsack(wt, val, W - wt[n - 1], n - 1), knapsack(wt, val, W, n - 1))\n            return t[n][W]\n        elif wt[n - 1] > W:\n            t[n][W] = knapsack(wt, val, W, n - 1)\n            return t[n][W]\n    print(knapsack(weight, score, w, n))", "for _ in range(int(input())):\n    (N, W) = list(map(int, input().split()))\n    dp = [0] * (W + 1)\n    for i in range(N):\n        (c, p, t) = list(map(int, input().split()))\n        cp = c * p\n        for j in range(W, t - 1, -1):\n            dp[j] = max(dp[j], dp[j - t] + cp)\n    print(dp[-1])", "for _ in range(int(input())):\n    (n, W) = map(int, input().split())\n    data = [[0, 0, 0, 0, 0] for _ in range(n)]\n    m = [[0] * (W + 1) for _ in range(n + 1)]\n    for i in range(n):\n        (data[i][0], data[i][1], data[i][2]) = map(int, input().split())\n        data[i][3] = data[i][0] * data[i][1]\n        data[i][4] = data[i][3] / data[i][2]\n    for k in range(1, n + 1):\n        for w in range(W + 1):\n            if data[k - 1][2] > w:\n                m[k][w] = m[k - 1][w]\n            else:\n                m[k][w] = max(m[k - 1][w], m[k - 1][w - data[k - 1][2]] + data[k - 1][3])\n    i = 0\n    ans = m[n][w]\n    print(int(ans))", "import sys\nfrom collections import deque\nimport math\n\ndef maxPoints(i, arr, time, n, dp):\n    if time == 0 or i == n:\n        return 0\n    if dp[i][time] == -1:\n        q = arr[i]\n        l = 0\n        if time >= q[2]:\n            l = q[0] * q[1] + maxPoints(i + 1, arr, time - q[2], n, dp)\n        r = maxPoints(i + 1, arr, time, n, dp)\n        dp[i][time] = max(l, r)\n    return dp[i][time]\nt = int(input())\nfor i in range(t):\n    (n, w) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        inp = list(map(int, input().split()))\n        arr.append(inp)\n    dp = [[-1] * 101 for _ in range(n)]\n    print(maxPoints(0, arr, w, n, dp))", "def knapSack(W, wt, val, n):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    return K[n][W]\nt = int(input())\nfor _ in range(t):\n    (n, w) = map(int, input().split())\n    score = []\n    time = []\n    for _ in range(n):\n        (ci, pi, ti) = map(int, input().split())\n        score.append(ci * pi)\n        time.append(ti)\n    print(knapSack(w, time, score, n))", "import math\nimport random\nimport statistics\nfrom collections import Counter\nimport heapq\nimport operator\nimport itertools\nimport sys\nimport functools\nimport bisect\nimport copy\nfor _ in range(int(input())):\n    (KPN, KPW) = [int(x) for x in input().split()]\n    KPD = [0] * (KPW + 1)\n    for i in range(KPN):\n        (KPC, KPP, KPT) = [int(x) for x in input().split()]\n        for j in range(KPW, KPT - 1, -1):\n            KPD[j] = max(KPD[j - KPT] + KPC * KPP, KPD[j])\n    print(KPD[-1])", "T = int(input())\nfor i in range(T):\n    (N, W) = map(int, input().split())\n    dp = [0] * (W + 1)\n    for j in range(N):\n        (c_j, p_j, t_j) = map(int, input().split())\n        for k in range(W, t_j - 1, -1):\n            dp[k] = max(dp[k - t_j] + c_j * p_j, dp[k])\n    print(dp[-1])", "for _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    k = []\n    for i in range(n):\n        a = [int(i) for i in input().split()]\n        k.append([a[0] * a[1], a[2]])\n    knap = [[0 for i in range(w + 1)] for j in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(w + 1):\n            if i == 0 or j == 0:\n                knap[i][j] = 0\n            elif k[i - 1][1] <= j:\n                knap[i][j] = max(k[i - 1][0] + knap[i - 1][j - k[i - 1][1]], knap[i - 1][j])\n            else:\n                knap[i][j] = knap[i - 1][j]\n    print(knap[n][w])", "for _ in range(int(input())):\n    (N, W) = map(int, input().split())\n    l = []\n    for i in range(N):\n        (c, p, t) = map(int, input().split())\n        l.append((c, p, t))\n    dp = [0] * (W + 1)\n    for i in range(N):\n        cur = l[i]\n        for j in range(W, -1, -1):\n            if j - cur[2] >= 0:\n                dp[j] = max(dp[j], dp[j - cur[2]] + cur[0] * cur[1])\n    print(dp[W])", "from collections import defaultdict\nnumber_of_testcases = int(input())\nfor _ in range(number_of_testcases):\n    options = defaultdict(int)\n    options[0] = 0\n    best_option_points = 0\n    (n, w) = map(int, input().split(' '))\n    for _ in range(n):\n        (num_tests, points, time) = map(int, input().split(' '))\n        for (option_time, option_points) in options.copy().items():\n            new_time = option_time + time\n            new_points = option_points + num_tests * points\n            if option_time + time <= w:\n                if new_points > options[new_time]:\n                    options[new_time] = new_points\n                    if best_option_points < new_points:\n                        best_option_points = new_points\n    print(best_option_points)", "def soln(n, W, c, p, t):\n    res = 0\n    val = [c[i] * p[i] for i in range(n)]\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if t[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - t[i - 1]] + val[i - 1])\n    return dp[W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    c = []\n    p = []\n    t = []\n    for i in range(n):\n        (x, y, z) = map(int, input().split())\n        c.append(x)\n        p.append(y)\n        t.append(z)\n    print(soln(n, w, c, p, t))", "def soln(n, W, c, p, t):\n    res = 0\n    val = [c[i] * p[i] for i in range(n)]\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if t[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - t[i - 1]] + val[i - 1])\n    return dp[W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    c = []\n    p = []\n    t = []\n    for i in range(n):\n        (x, y, z) = map(int, input().split())\n        c.append(x)\n        p.append(y)\n        t.append(z)\n    print(soln(n, w, c, p, t))", "def knapSack(W, wt, val, n):\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if wt[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - wt[i - 1]] + val[i - 1])\n    return dp[W]\n\ndef soln(n, W, c, p, t):\n    res = 0\n    val = [c[i] * p[i] for i in range(n)]\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if t[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - t[i - 1]] + val[i - 1])\n    return dp[W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    c = []\n    p = []\n    t = []\n    for i in range(n):\n        (x, y, z) = map(int, input().split())\n        c.append(x)\n        p.append(y)\n        t.append(z)\n    print(soln(n, w, c, p, t))", "for _ in range(int(input())):\n    (N, W) = map(int, input().split())\n    SC = [0 for x in range(W + 1)]\n    for i in range(N):\n        (C, P, T) = map(int, input().split())\n        p_ = W\n        m = C * P\n        while p_ >= T:\n            s = SC[p_ - T] + m\n            if s > SC[p_]:\n                SC[p_] = s\n            p_ -= 1\n    print(SC[W])", "for _ in range(int(input())):\n    (n, p) = map(int, input().split())\n    d = [0 for x in range(p + 1)]\n    for l in range(n):\n        (a, b, c) = map(int, input().split())\n        m = a * b\n        k = p\n        while k >= c:\n            s = d[k - c] + m\n            if s > d[k]:\n                d[k] = s\n            k = k - 1\n    print(d[p])", "for _ in range(int(input())):\n    (N, W) = map(int, input().split())\n    SC = [0 for x in range(W + 1)]\n    for i in range(N):\n        (C, P, T) = map(int, input().split())\n        p_ = W\n        m = C * P\n        while p_ >= T:\n            s = SC[p_ - T] + m\n            if s > SC[p_]:\n                SC[p_] = s\n            p_ -= 1\n    print(SC[W])", "for _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    points = []\n    time = []\n    for i in range(n):\n        temp = [int(i) for i in input().split()]\n        points.append(temp[0] * temp[1])\n        time.append(temp[2])\n    dp = [[0 for i in range(k + 1)] for j in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if time[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time[i - 1]] + points[i - 1])\n    print(dp[n][k])", "t = int(input())\nfor _ in range(t):\n    (n, w) = [int(x) for x in input().split()]\n    cp = [0 for i in range(n)]\n    t = [0 for i in range(n)]\n    for i in range(n):\n        (c, p, t[i]) = [int(x) for x in input().split()]\n        cp[i] = c * p\n    dp = [[0 for j in range(w + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, w + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j - t[i - 1] >= 0:\n                dp[i][j] = max(dp[i][j], cp[i - 1] + dp[i - 1][j - t[i - 1]])\n    print(dp[n][w])", "t = int(input())\nfor _ in range(t):\n    (n, w) = [int(x) for x in input().split()]\n    cp = [0 for i in range(n)]\n    t = [0 for i in range(n)]\n    for i in range(n):\n        (c, p, t[i]) = [int(x) for x in input().split()]\n        cp[i] = c * p\n    dp = [[0 for j in range(w + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, w + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j - t[i - 1] >= 0:\n                dp[i][j] = max(dp[i][j], cp[i - 1] + dp[i - 1][j - t[i - 1]])\n    print(dp[n][w])", "for _ in range(int(input())):\n    (N, W) = map(int, input().split())\n    SC = [0 for x in range(W + 1)]\n    for i in range(N):\n        (C, P, T) = map(int, input().split())\n        p_ = W\n        m = C * P\n        while p_ >= T:\n            s = SC[p_ - T] + m\n            if s > SC[p_]:\n                SC[p_] = s\n            p_ -= 1\n    print(SC[W])", "for t in range(int(input())):\n    (n, w) = map(int, input().split())\n    lt = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        lt.append([c, p, t])\n    dp = []\n    for i in range(n + 1):\n        dp.append([0] * (w + 1))\n    for i in range(1, n + 1):\n        for j in range(1, w + 1):\n            if lt[i - 1][2] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                x = j - lt[i - 1][2]\n                dp[i][j] = max(dp[i - 1][j], lt[i - 1][0] * lt[i - 1][1] + dp[i - 1][x])\n    print(dp[-1][-1])", "t = int(input())\nfor _ in range(t):\n    (n, w) = map(int, input().split())\n    time_i = []\n    val = []\n    for i in range(n):\n        (c, p, tim) = map(int, input().split())\n        time_i.append(tim)\n        val.append(c * p)\n    dp = [[-1 for j in range(w + 1)] for i in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(w + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n    for i in range(1, n + 1):\n        for j in range(1, w + 1):\n            if time_i[i - 1] <= j:\n                dp[i][j] = max(val[i - 1] + dp[i - 1][j - time_i[i - 1]], dp[i - 1][j])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print(dp[n][w])", "t = int(input())\n\ndef knapsack(tim_i, value, w, n):\n    if n == 0 or w == 0:\n        return 0\n    elif dp[n][w] != -1:\n        return dp[n][w]\n    elif tim_i[n - 1] <= w:\n        dp[n][w] = max(value[n - 1] + knapsack(tim_i, value, w - tim_i[n - 1], n - 1), knapsack(tim_i, value, w, n - 1))\n        return dp[n][w]\n    else:\n        dp[n][w] = knapsack(tim_i, value, w, n - 1)\n        return dp[n][w]\nfor _ in range(t):\n    (n, w) = map(int, input().split())\n    time_i = []\n    val = []\n    for i in range(n):\n        (c, p, tim) = map(int, input().split())\n        time_i.append(tim)\n        val.append(c * p)\n    dp = [[-1 for i in range(w + 1)] for j in range(n + 1)]\n    ans = knapsack(time_i, val, w, n)\n    print(ans)", "t = int(input())\n\ndef knapsack(tim_i, value, w, n):\n    if n == 0 or w == 0:\n        return 0\n    elif tim_i[n - 1] <= w:\n        if dp[n - 1][w - tim_i[n - 1]] == -1:\n            dp[n - 1][w - tim_i[n - 1]] = knapsack(tim_i, value, w - tim_i[n - 1], n - 1)\n            if dp[n - 1][w] == -1:\n                dp[n - 1][w] = knapsack(tim_i, value, w, n - 1)\n        elif dp[n - 1][w] == -1:\n            dp[n - 1][w] = knapsack(tim_i, value, w, n - 1)\n        return max(value[n - 1] + dp[n - 1][w - tim_i[n - 1]], dp[n - 1][w])\n    else:\n        if dp[n - 1][w] == -1:\n            dp[n - 1][w] = knapsack(tim_i, value, w, n - 1)\n        return dp[n - 1][w]\nfor _ in range(t):\n    (n, w) = map(int, input().split())\n    time_i = []\n    val = []\n    for i in range(n):\n        (c, p, tim) = map(int, input().split())\n        time_i.append(tim)\n        val.append(c * p)\n    dp = [[-1 for i in range(w + 1)] for j in range(n + 1)]\n    ans = knapsack(time_i, val, w, n)\n    print(ans)", "for _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    ans = []\n    for i in range(n + 1):\n        ans.append([0] * (w + 1))\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        value = c * p\n        for j in range(w):\n            if j + 1 < t:\n                ans[i + 1][j + 1] = ans[i][j + 1]\n            else:\n                ans[i + 1][j + 1] = max(ans[i][j + 1], value + ans[i][j + 1 - t])\n    print(int(ans[n][w]))", "for _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    ans = [[0] * (w + 1) for i in range(n + 1)]\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        value = c * p\n        for j in range(w):\n            if j + 1 >= t:\n                ans[i + 1][j + 1] = max(ans[i][j + 1], value + ans[i][j + 1 - t])\n            else:\n                ans[i + 1][j + 1] = ans[i][j + 1]\n    print(int(ans[n][w]))", "def knapSack(W, wt, val, n):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    return K[n][W]\nfor _ in range(int(input())):\n    (n, w) = [int(x) for x in input().split(' ')]\n    v = []\n    t = []\n    for i in range(n):\n        (a, b, c) = [int(x) for x in input().split(' ')]\n        v.append(a * b)\n        t.append(c)\n    print(knapSack(w, t, v, n))", "def knapsack(n, val, T, W):\n    K = [[0 for x in range(W + 1)] for y in range(2)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i % 2][w] = 0\n            elif T[i - 1] <= w:\n                K[i % 2][w] = max(val[i - 1] + K[(i - 1) % 2][w - T[i - 1]], K[(i - 1) % 2][w])\n            else:\n                K[i % 2][w] = K[(i - 1) % 2][w]\n    return K[n % 2][W]\nt = int(input())\nwhile t > 0:\n    (n, w) = map(int, input().split())\n    qList = [list(map(int, input().split())) for i in range(n)]\n    Q = []\n    T = []\n    for i in range(n):\n        v = int(qList[i][0]) * int(qList[i][1])\n        Q.append(v)\n        T.append(int(qList[i][2]))\n    points = knapsack(n, Q, T, w)\n    print(points)\n    t -= 1", "t = int(input())\nfor x in range(t):\n    T = [int(a) for a in input().split()]\n    n = T[0]\n    w = T[1]\n    info = []\n    c = 0\n    for y in range(n):\n        i = [int(a) for a in input().split()]\n        mv = i[0] * i[1]\n        i.insert(0, mv)\n        info.append(i)\n    h = [[0 for a in range(w + 1)] for b in range(n)]\n    for i in range(n):\n        for j in range(w + 1):\n            if i == 0:\n                if j >= info[0][3]:\n                    h[0][j] = info[0][0]\n            elif j >= info[i][3]:\n                h[i][j] = max(info[i][0] + h[i - 1][j - info[i][3]], h[i - 1][j])\n            else:\n                h[i][j] = h[i - 1][j]\n    print(h[n - 1][w])", "def knapSack(W, wt, val, n):\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if wt[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - wt[i - 1]] + val[i - 1])\n    return dp[W]\nfor _ in range(int(input())):\n    (n, limit) = list(map(int, input().split()))\n    arr = [0] * n\n    for i in range(n):\n        arr[i] = list(map(int, input().split()))\n        arr[i] = (arr[i][0] * arr[i][1], arr[i][2])\n    Values = [arr[i][0] for i in range(n)]\n    Weights = [arr[i][1] for i in range(n)]\n    print(knapSack(limit, Weights, Values, n))", "def knapsack(n, item, cost, size):\n    dp = [[None for i in range(size + 1)] for j in range(n + 1)]\n    for x in range(size + 1):\n        for y in range(n + 1):\n            if x == 0:\n                dp[y][0] = 0\n                continue\n            if y == 0:\n                dp[0][x] = 0\n                continue\n            if cost[y - 1] > x:\n                dp[y][x] = dp[y - 1][x]\n            else:\n                dp[y][x] = max(dp[y - 1][x - cost[y - 1]] + item[y - 1], dp[y - 1][x])\n    return dp[n][size]\nt = int(input())\nwhile t > 0:\n    (n, w) = map(int, input().split())\n    qList = [list(map(int, input().split())) for i in range(n)]\n    Q = []\n    T = []\n    for i in range(n):\n        v = int(qList[i][0]) * int(qList[i][1])\n        Q.append(v)\n        T.append(int(qList[i][2]))\n    points = knapsack(n, Q, T, w)\n    print(points)\n    t -= 1", "def knapsack(n, item, cost, size):\n    dp = [[None for i in range(size + 1)] for j in range(n + 1)]\n    for x in range(size + 1):\n        for y in range(n + 1):\n            if x == 0:\n                dp[y][0] = 0\n                continue\n            if y == 0:\n                dp[0][x] = 0\n                continue\n            if cost[y - 1] > x:\n                dp[y][x] = dp[y - 1][x]\n            else:\n                dp[y][x] = max(dp[y - 1][x - cost[y - 1]] + item[y - 1], dp[y - 1][x])\n    return dp[n][size]\nt = int(input())\nwhile t > 0:\n    (n, w) = map(int, input().split())\n    qList = [list(map(int, input().split())) for i in range(n)]\n    Q = []\n    T = []\n    for i in range(n):\n        v = int(qList[i][0]) * int(qList[i][1])\n        Q.append(v)\n        T.append(int(qList[i][2]))\n    points = knapsack(n, Q, T, w)\n    print(points)\n    t -= 1", "for _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    k = []\n    for i in range(n):\n        a = [int(i) for i in input().split()]\n        k.append([a[0] * a[1], a[2]])\n    knap = [[0 for i in range(w + 1)] for j in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(w + 1):\n            if i == 0 or j == 0:\n                knap[i][j] = 0\n            elif k[i - 1][1] <= j:\n                knap[i][j] = max(k[i - 1][0] + knap[i - 1][j - k[i - 1][1]], knap[i - 1][j])\n            else:\n                knap[i][j] = knap[i - 1][j]\n    print(knap[n][w])", "from functools import lru_cache\n\ndef max_points(questions, time):\n\n    @lru_cache(maxsize=None)\n    def mx(qi, time):\n        if time < 0:\n            return -10 ** 8\n        if time == 0:\n            return 0\n        if qi == -1:\n            return 0\n        return max(mx(qi - 1, time - questions[qi][1]) + questions[qi][0], mx(qi - 1, time))\n    return mx(len(questions) - 1, time)\nfor _ in range(int(input())):\n    (n, time) = [int(x) for x in input().split()]\n    questions = []\n    for _ in range(n):\n        (a, b, c) = [int(x) for x in input().split()]\n        questions.append((a * b, c))\n    print(max_points(questions, time))", "def knapsack(w, t, pt, n):\n    knap = [[0 for i in range(w + 1)] for j in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(w + 1):\n            if i == 0 or j == 0:\n                knap[i][j] = 0\n            elif t[i - 1] <= j:\n                knap[i][j] = max(pt[i - 1] + knap[i - 1][j - t[i - 1]], knap[i - 1][j])\n            else:\n                knap[i][j] = knap[i - 1][j]\n    print(knap[n][w])\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    c = []\n    p = []\n    t = []\n    for i in range(n):\n        val = input().split()\n        c.append(int(val[0]))\n        p.append(int(val[1]))\n        t.append(int(val[2]))\n    pt = [c[i] * p[i] for i in range(n)]\n    knapsack(w, t, pt, n)", "t = int(input())\nfor i in range(t):\n    st = input().split()\n    N = int(st[0])\n    W = int(st[1])\n    SC = [0 for x in range(W + 1)]\n    for k in range(N):\n        st = input().split()\n        C = int(st[0])\n        P = int(st[1])\n        T = int(st[2])\n        p = W\n        m = C * P\n        while p >= T:\n            s = SC[p - T] + m\n            if s > SC[p]:\n                SC[p] = s\n            p -= 1\n    print(SC[W])", "def mx_pnt(W, tm, pnt, n):\n    M = [[0 for i in range(W + 1)] for j in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(W + 1):\n            if i == 0 or j == 0:\n                M[i][j] = 0\n            elif tm[i - 1] <= j:\n                M[i][j] = max(pnt[i - 1] + M[i - 1][j - tm[i - 1]], M[i - 1][j])\n            else:\n                M[i][j] = M[i - 1][j]\n    return M[i][W]\nfor _ in range(int(input())):\n    (n, W) = map(int, input().split())\n    c = []\n    p = []\n    t = []\n    for i in range(n):\n        (c1, p1, t1) = list(map(int, input().split()))\n        c.append(c1)\n        p.append(p1)\n        t.append(t1)\n    v = [c[i] * p[i] for i in range(n)]\n    ans = mx_pnt(W, t, v, n)\n    print(ans)", "import math\ntestcase = int(input())\ndp = [-math.inf] * 105\nfor T in range(testcase):\n    (n, w) = map(int, input().split())\n    for i in range(1, w + 1):\n        dp[i] = -math.inf\n    dp[0] = 0\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        for j in range(w, t - 1, -1):\n            if dp[j - t] >= 0:\n                dp[j] = max(dp[j], dp[j - t] + p * c)\n    ans = 0\n    for i in range(1, w + 1):\n        ans = max(ans, dp[i])\n    print(ans)", "def solve(n, w, val, wt, dp):\n    if w == 0 or n == 0:\n        return 0\n    if dp[n][w] != -1:\n        return dp[n][w]\n    if wt[n - 1] <= w:\n        dp[n][w] = max(val[n - 1] + solve(n - 1, w - wt[n - 1], val, wt, dp), solve(n - 1, w, val, wt, dp))\n        return dp[n][w]\n    else:\n        dp[n][w] = solve(n - 1, w, val, wt, dp)\n        return dp[n][w]\nt = int(input())\nwhile t:\n    (N, W) = map(int, input().split())\n    marks = []\n    time = []\n    dp = []\n    for i in range(N + 1):\n        dp.append([-1] * (W + 1))\n    for i in range(N):\n        (ci, pi, ti) = map(int, input().split())\n        marks.append(ci * pi)\n        time.append(ti)\n    print(solve(N, W, marks, time, dp))\n    t -= 1", "for _ in range(int(input())):\n    (n, w) = list(map(int, input().split()))\n    a = [0] + [-1] * w\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        for j in range(w, t - 1, -1):\n            if a[j - t] >= 0:\n                a[j] = max(a[j], a[j - t] + c * p)\n    print(max(a))", "for _ in range(int(input())):\n    (n, w) = list(map(int, input().split()))\n    a = [0] + [-1] * w\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        for j in range(w, t - 1, -1):\n            if a[j - t] >= 0:\n                a[j] = max(a[j], a[j - t] + c * p)\n    print(max(a))", "for _ in range(int(input())):\n    (n, w) = list(map(int, input().split()))\n    a = [0] + [-1] * w\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        for j in range(w, t - 1, -1):\n            if a[j - t] >= 0:\n                a[j] = max(a[j], a[j - t] + c * p)\n    print(max(a))", "for _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    a = [0] + [-1] * w\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        for j in range(w, t - 1, -1):\n            if a[j - t] >= 0:\n                a[j] = max(a[j], a[j - t] + p * c)\n    print(max(a))", "from itertools import combinations\nfor tc in range(int(input())):\n    (a, b) = map(int, input().split())\n    x = []\n    c = []\n    p = []\n    t = []\n    for i in range(a):\n        (q, w, e) = map(int, input().split())\n        c.append(q)\n        p.append(w)\n        t.append(e)\n    for i in range(a):\n        x.append(p[i] * c[i])\n    s = [[0] * (b + 1) for i in range(a + 1)]\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            if t[i - 1] <= j:\n                s[i][j] = max(x[i - 1] + s[i - 1][j - t[i - 1]], s[i - 1][j])\n            else:\n                s[i][j] = s[i - 1][j]\n    print(s[-1][-1])", "from itertools import combinations\nfor tc in range(int(input())):\n    (a, b) = map(int, input().split())\n    x = []\n    c = []\n    p = []\n    t = []\n    for i in range(a):\n        (q, w, e) = map(int, input().split())\n        c.append(q)\n        p.append(w)\n        t.append(e)\n    for i in range(a):\n        x.append(p[i] * c[i])\n    s = [[0] * (b + 1) for i in range(a + 1)]\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            if t[i - 1] <= j:\n                s[i][j] = max(x[i - 1] + s[i - 1][j - t[i - 1]], s[i - 1][j])\n            else:\n                s[i][j] = s[i - 1][j]\n    print(s[-1][-1])", "def solve():\n    lis = list()\n    (n, w) = map(int, input().split())\n    for i in range(n):\n        lis.append(list(map(int, input().split())))\n    dp = [[0] * (w + 1) for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(w + 1):\n            if j >= lis[i - 1][2]:\n                cur_ind = i - 1\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - lis[cur_ind][2]] + lis[cur_ind][0] * lis[cur_ind][1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][w]\nfor _ in range(int(input())):\n    print(solve())", "for _ in range(int(input())):\n    (n, W) = list(map(int, input().split()))\n    c = [-1 for _ in range(n)]\n    p = [-1 for _ in range(n)]\n    t = [-1 for _ in range(n)]\n    for i in range(n):\n        (c[i], p[i], t[i]) = list(map(int, input().split()))\n    dp = [[0 for i in range(W + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for w in range(1, W + 1):\n            if t[i - 1] <= w:\n                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - t[i - 1]] + c[i - 1] * p[i - 1])\n            else:\n                dp[i][w] = dp[i - 1][w]\n    print(dp[n][W])", "def knapsack(wt, val):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif T[i - 1] <= w:\n                K[i][w] = max(C[i - 1] * P[i - 1] + K[i - 1][w - T[i - 1]], K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    return K[n][W]\nt = int(input())\nfor _ in range(t):\n    (n, W) = list(map(int, input().split()))\n    C = [-1 for _ in range(n)]\n    P = [-1 for _ in range(n)]\n    T = [-1 for _ in range(n)]\n    for i in range(n):\n        (C[i], P[i], T[i]) = list(map(int, input().split()))\n    print(knapsack(0, 0))", "mod = 1000000007\nread_int = lambda : int(input().strip())\nread_str = lambda : input().strip()\nread_str_arr = lambda : input().strip().split()\nread_int_arr = lambda : [int(x) for x in input().strip().split()]\n\ndef solve():\n    (n, w) = read_int_arr()\n    c = [0] * n\n    p = [0] * n\n    t = [0] * n\n    for i in range(n):\n        (c[i], p[i], t[i]) = read_int_arr()\n    kp = [[0] * (w + 1) for _ in range(2)]\n    for i in range(n):\n        for j in range(1, w + 1):\n            if j >= t[i]:\n                kp[1][j] = max(kp[0][j], c[i] * p[i] + kp[0][j - t[i]])\n            else:\n                kp[1][j] = kp[0][j]\n        for j in range(1, w + 1):\n            kp[0][j] = kp[1][j]\n    print(kp[0][-1])\nfor _ in range(int(input())):\n    solve()", "T = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    C = []\n    P = []\n    T = []\n    for i in range(N):\n        (a, b, c) = map(int, input().split())\n        C.append(a)\n        P.append(b)\n        T.append(c)\n    val = []\n    for i in range(N):\n        val.append(C[i] * P[i])\n    dp = [[0] * (M + 1) for i in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if T[i - 1] <= j:\n                dp[i][j] = max(val[i - 1] + dp[i - 1][j - T[i - 1]], dp[i - 1][j])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print(dp[-1][-1])", "T = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    C = []\n    P = []\n    T = []\n    for i in range(N):\n        (a, b, c) = map(int, input().split())\n        C.append(a)\n        P.append(b)\n        T.append(c)\n    val = []\n    for i in range(N):\n        val.append(C[i] * P[i])\n    dp = [[0] * (M + 1) for i in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if T[i - 1] <= j:\n                dp[i][j] = max(val[i - 1] + dp[i - 1][j - T[i - 1]], dp[i - 1][j])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print(dp[-1][-1])", "T = int(input())\nfor _ in range(T):\n    (N, W) = map(int, input().split())\n    C = []\n    P = []\n    T = []\n    for i in range(N):\n        (a, b, c) = map(int, input().split())\n        C.append(a)\n        P.append(b)\n        T.append(c)\n    val = []\n    for i in range(N):\n        val.append(C[i] * P[i])\n    dp = [[0] * (W + 1) for i in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, W + 1):\n            if T[i - 1] <= j:\n                dp[i][j] = max(val[i - 1] + dp[i - 1][j - T[i - 1]], dp[i - 1][j])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print(dp[-1][-1])", "t = int(input())\nfor test in range(t):\n    (n, w) = list(map(int, input().split()))\n    time = []\n    points = []\n    for i in range(n):\n        (a, b, c) = list(map(int, input().split()))\n        time.append(c)\n        points.append(a * b)\n    dp = [0 for i in range(w + 1)]\n    for i in range(1, n + 1):\n        temp = [0 for k in range(w + 1)]\n        for j in range(1, w + 1):\n            if time[i - 1] <= j:\n                temp[j] = max(dp[j - time[i - 1]] + points[i - 1], dp[j])\n            else:\n                temp[j] = dp[j]\n        dp = temp[:]\n    print(dp[w])", "def solve(n, val, wt, W):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    return K[n][W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    C = []\n    T = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        C.append(c * p)\n        T.append(t)\n    print(solve(n, C, T, w))", "for _ in range(int(input())):\n    (N, W) = map(int, input().split())\n    V = [[0 for j in range(W + 1)] for k in range(N + 1)]\n    C = [0 for i in range(N + 1)]\n    P = [0 for i in range(N + 1)]\n    T = [0 for i in range(N + 1)]\n    for i in range(1, N + 1):\n        (C[i], P[i], T[i]) = map(int, input().split())\n    for m in range(N + 1):\n        for n in range(W + 1):\n            if m == 0 or n == 0:\n                V[m][n] == 0\n            elif T[m] > n:\n                V[m][n] = V[m - 1][n]\n            else:\n                V[m][n] = max(V[m - 1][n], V[m - 1][n - T[m]] + C[m] * P[m])\n    print(V[m][n])", "def solve(n, w, dp, s, t):\n    if n == 0 or w == 0:\n        return 0\n    if dp[n - 1][w] != -1:\n        return dp[n - 1][w]\n    if w >= t[n - 1]:\n        dp[n - 1][w] = max(s[n - 1] + solve(n - 1, w - t[n - 1], dp, s, t), solve(n - 1, w, dp, s, t))\n        return dp[n - 1][w]\n    else:\n        dp[n - 1][w] = solve(n - 1, w, dp, s, t)\n        return dp[n - 1][w]\n    return dp[n - 1][w]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    C = []\n    T = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        C.append(c * p)\n        T.append(t)\n    dp = [[-1 for j in range(w + 1)] for i in range(n + 1)]\n    print(solve(n, w, dp, C, T))", "def solve(n, val, wt, W):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    return K[n][W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    C = []\n    T = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        C.append(c * p)\n        T.append(t)\n    print(solve(n, C, T, w))", "def knapSack(W, wt, val, n):\n    dp = [0 for i in range(W + 1)]\n    for i in range(1, n + 1):\n        for w in range(W, 0, -1):\n            if wt[i - 1] <= w:\n                dp[w] = max(dp[w], dp[w - wt[i - 1]] + val[i - 1])\n    return dp[W]\nt = int(input())\nfor i in range(t):\n    [N, W] = [int(i) for i in input().split()]\n    val = []\n    weight = []\n    for i in range(N):\n        lst = [int(i) for i in input().split()]\n        val.append(lst[0] * lst[1])\n        weight.append(lst[2])\n    print(knapSack(W, weight, val, N))", "t = int(input())\nfor i in range(t):\n    (N, W) = map(int, input().split())\n    knapsack_table = [[0 for i in range(W + 1)] for k in range(N + 1)]\n    for j in range(N + 1):\n        if j == 0:\n            continue\n        (C, P, T) = [int(n) for n in input().split()]\n        for k in range(W + 1):\n            if T <= k:\n                knapsack_table[j][k] = max(knapsack_table[j - 1][k], knapsack_table[j - 1][k - T] + C * P)\n            else:\n                knapsack_table[j][k] = knapsack_table[j - 1][k]\n    print(knapsack_table[N][W])", "t = int(input())\nfor i in range(t):\n    (N, W) = map(int, input().split())\n    knapsack_table = [[0 for i in range(W + 1)] for k in range(N + 1)]\n    for j in range(N + 1):\n        if j == 0:\n            continue\n        (C, P, T) = [int(n) for n in input().split()]\n        for k in range(W + 1):\n            if T <= k:\n                knapsack_table[j][k] = max(knapsack_table[j - 1][k], knapsack_table[j - 1][k - T] + C * P)\n            else:\n                knapsack_table[j][k] = knapsack_table[j - 1][k]\n    print(knapsack_table[N][W])", "def solve():\n    lis = list()\n    (n, w) = map(int, input().split())\n    for i in range(n):\n        lis.append(list(map(int, input().split())))\n    dp = [[0] * (w + 1) for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(w + 1):\n            if j >= lis[i - 1][2]:\n                cur_ind = i - 1\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - lis[cur_ind][2]] + lis[cur_ind][0] * lis[cur_ind][1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][w]\nfor _ in range(int(input())):\n    print(solve())", "def solve():\n    lis = list()\n    (n, w) = map(int, input().split())\n    for i in range(n):\n        lis.append(list(map(int, input().split())))\n    dp = [[0] * (w + 1) for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(w + 1):\n            if j >= lis[i - 1][2]:\n                cur_ind = i - 1\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - lis[cur_ind][2]] + lis[cur_ind][0] * lis[cur_ind][1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][w]\nfor _ in range(int(input())):\n    print(solve())", "for _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    arr = [[0 for j in range(w + 1)] for i in range(n + 1)]\n    cp = []\n    tn = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        cp.append(c * p)\n        tn.append(t)\n    for i in range(n + 1):\n        for j in range(w + 1):\n            if i == 0 or j == 0:\n                arr[i][j] = 0\n            elif tn[i - 1] <= j:\n                arr[i][j] = max(arr[i - 1][j], cp[i - 1] + arr[i - 1][j - tn[i - 1]])\n            else:\n                arr[i][j] = arr[i - 1][j]\n    print(arr[n][w])", "def solve():\n    lis = list()\n    (n, w) = map(int, input().split())\n    for i in range(n):\n        lis.append(list(map(int, input().split())))\n    dp = [[0] * (w + 1) for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(w + 1):\n            if j >= lis[i - 1][2]:\n                cur_ind = i - 1\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - lis[cur_ind][2]] + lis[cur_ind][0] * lis[cur_ind][1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][w]\nfor _ in range(int(input())):\n    print(solve())", "def solve():\n    lis = list()\n    (n, w) = map(int, input().split())\n    for i in range(n):\n        lis.append(list(map(int, input().split())))\n    dp = [[0] * (w + 1) for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(w + 1):\n            if j >= lis[i - 1][2]:\n                cur_ind = i - 1\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - lis[cur_ind][2]] + lis[cur_ind][0] * lis[cur_ind][1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][w]\nfor _ in range(int(input())):\n    print(solve())", "def solve():\n    lis = list()\n    (n, w) = map(int, input().split())\n    for i in range(n):\n        lis.append(list(map(int, input().split())))\n    dp = [[0] * (w + 1) for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(w + 1):\n            if j >= lis[i - 1][2]:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - lis[i - 1][2]] + lis[i - 1][1] * lis[i - 1][0])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print(dp[n][w])\nfor _ in range(int(input())):\n    solve()", "def solve():\n    lis = list()\n    (n, w) = map(int, input().split())\n    for i in range(n):\n        lis.append(list(map(int, input().split())))\n    dp = [[0] * (w + 1) for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(w + 1):\n            if j >= lis[i - 1][2]:\n                cur_ind = i - 1\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - lis[cur_ind][2]] + lis[cur_ind][0] * lis[cur_ind][1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][w]\nfor _ in range(int(input())):\n    print(solve())", "def solve(n, val, wt, W):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    return K[n][W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    C = []\n    T = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        C.append(c * p)\n        T.append(t)\n    print(solve(n, C, T, w))", "def solve(n, val, wt, W):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    return K[n][W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    C = []\n    T = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        C.append(c * p)\n        T.append(t)\n    print(solve(n, C, T, w))", "def solve(n, val, wt, W):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    return K[n][W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    C = []\n    T = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        C.append(c * p)\n        T.append(t)\n    print(solve(n, C, T, w))", "def solve(n, val, wt, W):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    return K[n][W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    C = []\n    T = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        C.append(c * p)\n        T.append(t)\n    print(solve(n, C, T, w))", "def solve(n, val, wt, W):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    return K[n][W]\nfor _ in range(int(input())):\n    (n, w) = map(int, input().split())\n    C = []\n    T = []\n    for i in range(n):\n        (c, p, t) = map(int, input().split())\n        C.append(c * p)\n        T.append(t)\n    print(solve(n, C, T, w))"]