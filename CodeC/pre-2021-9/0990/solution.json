["import sys\nsys.setrecursionlimit(10 ** 6)\nbook = dict()\na = []\nn = kk = rs0 = 0\n\ndef outc(k, j, v, rs):\n    if (k, j, tuple(v)) in book.keys() and rs == rs0:\n        return book[k, j, tuple(v)]\n    elif rs != 0 and j != n:\n        res = False\n        if not v[j]:\n            if a[j] <= rs:\n                w = v.copy()\n                w[j] = True\n                res = res or outc(k, j + 1, w, rs - a[j])\n        res = res or outc(k, j + 1, v, rs)\n        book[k, j, tuple(v)] = res\n        return res\n    elif rs != 0 and j == n:\n        return False\n    elif rs == 0 and k != kk - 1:\n        return outc(k + 1, 0, v, rs0)\n    else:\n        return True\nT = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    a = A\n    (n, kk) = (N, K)\n    mysum = sum(A)\n    if N < K or mysum % K != 0:\n        print('no')\n    else:\n        rs0 = mysum // K\n        if outc(0, 0, [False] * N, rs0):\n            print('yes')\n        else:\n            print('no')\n    book.clear()", "import sys\nsys.setrecursionlimit(10 ** 6)\nbook = dict()\na = []\nn = kk = rs0 = 0\n\ndef outc(k, j, v, rs):\n    if (k, j, tuple(v)) in book.keys() and rs == rs0:\n        return book[k, j, tuple(v)]\n    elif rs != 0 and j != n:\n        res = False\n        if not v[j]:\n            if a[j] <= rs:\n                w = v.copy()\n                w[j] = True\n                res = res or outc(k, j + 1, w, rs - a[j])\n        res = res or outc(k, j + 1, v, rs)\n        book[k, j, tuple(v)] = res\n        return res\n    elif rs != 0 and j == n:\n        return False\n    elif rs == 0 and k != kk - 1:\n        return outc(k + 1, 0, v, rs0)\n    else:\n        return True\nT = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    a = A\n    (n, kk) = (N, K)\n    mysum = sum(A)\n    if N < K or mysum % K != 0:\n        print('no')\n    else:\n        rs0 = mysum // K\n        if outc(0, 0, [False] * N, rs0):\n            print('yes')\n        else:\n            print('no')\n    book.clear()", "def hasSubsetSum(A, V):\n    if V == 0:\n        return (True, [])\n    if len(A) == 0:\n        return (False, [])\n    if V < A[len(A) - 1]:\n        return hasSubsetSum(A[0:len(A) - 1], V)\n    else:\n        L = [len(A) - 1]\n        TMP = hasSubsetSum(A[0:len(A) - 1], V - A[len(A) - 1])\n        if TMP[0]:\n            TMP[1].append(len(A) - 1)\n            return (True, TMP[1])\n        else:\n            return hasSubsetSum(A[0:len(A) - 1], V)\n\ndef hasPartition(A, SSUM, K):\n    if K == 0:\n        return True\n    TMP = hasSubsetSum(A, SSUM)\n    if TMP[0]:\n        B = [A[j] for j in range(len(A)) if not j in TMP[1]]\n        return hasPartition(B, SSUM, K - 1)\n    else:\n        return False\nT = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    if K > N:\n        print('no')\n        continue\n    SUM = 0\n    for j in range(N):\n        SUM = SUM + A[j]\n    if SUM % K != 0:\n        print('no')\n        continue\n    SSUM = SUM // K\n    if hasPartition(A, SSUM, K):\n        print('yes')\n    else:\n        print('no')", "def ret_res(arr, vis_arr, ind, memo, val):\n    if (ind, val) in memo:\n        return memo[ind, val]\n    elif val < 0:\n        return None\n    elif val == 0:\n        return []\n    elif ind == -1:\n        return None\n    elif not vis_arr[ind]:\n        ret1 = ret_res(arr, vis_arr, ind - 1, memo, val - arr[ind])\n        if ret1 != None:\n            ret1.append(ind)\n            memo[ind, val] = ret1\n            return memo[ind, val]\n        ret2 = ret_res(arr, vis_arr, ind - 1, memo, val)\n        memo[ind, val] = ret2\n        return memo[ind, val]\n    else:\n        ret3 = ret_res(arr, vis_arr, ind - 1, memo, val)\n        memo[ind, val] = ret3\n        return memo[ind, val]\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = sorted(list(map(int, input().split())))\n    tot = sum(arr)\n    if tot % k == 0 and k <= n:\n        val = tot // k\n        vis_arr = [False for _ in range(n)]\n        for i in range(k):\n            path = ret_res(arr, vis_arr, n - 1, {}, val)\n            if path == None:\n                print('no')\n                break\n            else:\n                for j in path:\n                    vis_arr[j] = True\n        else:\n            print('yes')\n    else:\n        print('no')", "def ret_res(arr, vis_arr, ind, memo, val):\n    if (ind, val) in memo:\n        return memo[ind, val]\n    elif val < 0:\n        return None\n    elif val == 0:\n        return []\n    elif ind == -1:\n        return None\n    elif not vis_arr[ind]:\n        ret1 = ret_res(arr, vis_arr, ind - 1, memo, val - arr[ind])\n        if ret1 != None:\n            ret1.append(ind)\n            memo[ind, val] = ret1\n            return memo[ind, val]\n        ret2 = ret_res(arr, vis_arr, ind - 1, memo, val)\n        memo[ind, val] = ret2\n        return memo[ind, val]\n    else:\n        ret3 = ret_res(arr, vis_arr, ind - 1, memo, val)\n        memo[ind, val] = ret3\n        return memo[ind, val]\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = sorted(list(map(int, input().split())))\n    tot = sum(arr)\n    if tot % k == 0 and k <= n:\n        val = tot // k\n        vis_arr = [False for _ in range(n)]\n        for i in range(k):\n            path = ret_res(arr, vis_arr, n - 1, {}, val)\n            if path == None:\n                print('no')\n                break\n            else:\n                for j in path:\n                    vis_arr[j] = True\n        else:\n            print('yes')\n    else:\n        print('no')", "def ret_res(arr, vis_arr, ind, memo, val):\n    if (ind, val) in memo:\n        return memo[ind, val]\n    elif val < 0:\n        return None\n    elif val == 0:\n        return []\n    elif ind == -1:\n        return None\n    elif not vis_arr[ind]:\n        ret1 = ret_res(arr, vis_arr, ind - 1, memo, val - arr[ind])\n        if ret1 != None:\n            ret1.append(ind)\n            memo[ind, val] = ret1\n            return memo[ind, val]\n        ret2 = ret_res(arr, vis_arr, ind - 1, memo, val)\n        memo[ind, val] = ret2\n        return memo[ind, val]\n    else:\n        ret3 = ret_res(arr, vis_arr, ind - 1, memo, val)\n        memo[ind, val] = ret3\n        return memo[ind, val]\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = sorted(list(map(int, input().split())))\n    tot = sum(arr)\n    if tot % k == 0 and k <= n:\n        val = tot // k\n        vis_arr = [False for _ in range(n)]\n        for i in range(k):\n            path = ret_res(arr, vis_arr, n - 1, {}, val)\n            if path == None:\n                print('no')\n                break\n            else:\n                for j in path:\n                    vis_arr[j] = True\n        else:\n            print('yes')\n    else:\n        print('no')", "def divide(l, num, dn):\n    if dn == 0:\n        return True\n    if num == -1:\n        return False\n    if l[num] > dn or l[num] == 0:\n        return divide(l, num - 1, dn)\n    if divide(l, num - 1, dn - l[num]):\n        l[num] = 0\n        return True\n    return divide(l, num - 1, dn)\ntest = int(input())\nfor _ in range(test):\n    (n, k) = map(int, input().split())\n    l = sorted(list(map(int, input().split())))\n    if sum(l) % k != 0 or n < k:\n        print('no')\n        continue\n    dn = sum(l) // k\n    ans = False\n    if l[n - 1] <= dn:\n        ans = True\n    for i in range(k):\n        if not divide(l, n - 1, dn):\n            ans = False\n            break\n    print('yes') if ans == True else print('no')", "def divide(l, num, dn):\n    if dn == 0:\n        return True\n    if num == -1:\n        return False\n    if l[num] > dn or l[num] == 0:\n        return divide(l, num - 1, dn)\n    if divide(l, num - 1, dn - l[num]):\n        l[num] = 0\n        return True\n    return divide(l, num - 1, dn)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = sorted(list(map(int, input().split())))\n    if sum(l) % k != 0 or n < k:\n        print('no')\n        continue\n    dn = sum(l) // k\n    ans = False\n    if l[n - 1] <= dn:\n        ans = True\n    for i in range(k):\n        if not divide(l, n - 1, dn):\n            ans = False\n            break\n    print('yes') if ans == True else print('no')", "def divide(l, num, dn):\n    if dn == 0:\n        return True\n    if num == -1:\n        return False\n    if l[num] > dn or l[num] == 0:\n        return divide(l, num - 1, dn)\n    if divide(l, num - 1, dn - l[num]):\n        l[num] = 0\n        return True\n    return divide(l, num - 1, dn)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort()\n    if sum(l) % k != 0 or n < k:\n        print('no')\n        continue\n    dn = sum(l) // k\n    ans = False\n    if l[n - 1] <= dn:\n        ans = True\n    for i in range(k):\n        if not divide(l, n - 1, dn):\n            ans = False\n            break\n    if ans == True:\n        print('yes')\n    else:\n        print('no')", "import math\nimport bisect\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef inn():\n    return int(input())\n\ndef inl():\n    return list(map(int, input().split()))\n\ndef partition(arr, num, ps):\n    if ps == 0:\n        return True\n    if num == 0:\n        return False\n    if arr[num - 1] > ps or arr[num - 1] == 0:\n        return partition(arr, num - 1, ps)\n    if partition(arr, num - 1, ps - a[num - 1]):\n        arr[num - 1] = 0\n        return True\n    return partition(arr, num - 1, ps)\nMOD = 10 ** 9 + 7\nINF = inf = 10 ** 18 + 5\nfor t in range(int(input())):\n    (n, k) = inl()\n    a = inl()\n    a.sort()\n    s = sum(a)\n    if s % k != 0 or n < k:\n        print('no')\n        continue\n    ans = False\n    ps = s // k\n    if a[n - 1] <= ps:\n        ans = True\n        for i in range(k):\n            if not partition(a, n, ps):\n                ans = False\n                break\n    print('yes') if ans else print('no')", "def getans(arr, k):\n    sm = sum(arr)\n    if sm % k != 0 or k > len(arr):\n        return 'no'\n    if all((i == 0 for i in arr)):\n        return 'yes'\n    req = sm // k\n    visited = [False] * len(arr)\n    retval = compute(arr, 0, k, req, visited, req)\n    if retval:\n        return 'yes'\n    return 'no'\n\ndef compute(arr, idx, k, req, visited, sm):\n    if k == 0:\n        return all(visited)\n    if req == 0:\n        return compute(arr, 0, k - 1, sm, visited, sm)\n    state = False\n    for i in range(idx, len(arr)):\n        if not visited[i] and arr[i] <= req:\n            visited[i] = True\n            state = compute(arr, i + 1, k, req - arr[i], visited, sm)\n            if state:\n                return state\n            visited[i] = False\n    return state\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    arr.sort()\n    print(getans(arr, k))", "import sys\ntests = int(input())\nfor t in range(tests):\n    line = input().split()\n    sanskars = int(line[0])\n    followers = int(line[1])\n    intensities = list(map(int, input().split()))\n    ti = sum(intensities)\n    togive = ti / followers\n    go = 1\n    if followers > sanskars or round(togive) != togive or max(intensities) > togive:\n        print('no')\n        go = 0\n    if go == 1:\n        intensities.sort(reverse=True)\n\n        def give(intensities, runsum, pos):\n            if intensities == [] or intensities[0] == 0:\n                return 1\n            runsum = (runsum + intensities[pos]) % togive\n            intensities.pop(pos)\n            if runsum == 0:\n                return give(intensities, 0, 0)\n            p = pos\n            for i in intensities[pos:]:\n                if runsum + i <= togive:\n                    topass = intensities[:]\n                    if give(topass, runsum, p) == 1:\n                        return 1\n                p += 1\n            return 0\n        print('yes') if give(intensities, 0, 0) == 1 else print('no')", "import sys\n\ndef is_partition(n, tot, count):\n    if tot == 0:\n        for v in range(count):\n            sk.remove(l[v])\n        return True\n    if tot < 0:\n        return False\n    if n < 0 and tot != 0:\n        return False\n    l[count] = sk[n]\n    return is_partition(n - 1, tot - sk[n], count + 1) or is_partition(n - 1, tot, count)\nt = sys.stdin.readline()\nt = int(t)\nfor j in range(t):\n    (n, k) = sys.stdin.readline().split()\n    n = int(n)\n    k = int(k)\n    tot = 0\n    sk = []\n    l = [None] * n\n    p = []\n    flag = False\n    count = 0\n    a = sys.stdin.readline().split()\n    if k > n:\n        print('no')\n        continue\n    for i in range(n):\n        a[i] = int(a[i])\n        sk.append(a[i])\n        tot += a[i]\n    indv = int(tot / k)\n    if tot % k != 0:\n        print('no')\n        continue\n        sk.sort()\n    else:\n        for i in range(k):\n            ans = is_partition(len(sk) - 1, indv, 0)\n            if ans == False:\n                flag = True\n                break\n    if flag == False:\n        print('yes')\n    else:\n        print('no')", "__author__ = 'Rakshak.R.Hegde'\ntarget = 0\nsan = []\n\ndef recurse(i, sum):\n    if sum == target:\n        return True\n    if sum > target or i == len(san):\n        return False\n    if recurse(i + 1, sum + san[i]):\n        del san[i]\n        return True\n    return recurse(i + 1, sum)\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    san = sorted(map(int, input().split()), reverse=True)\n    (target, rem) = divmod(sum(san), k)\n    if rem == 0 and san[0] <= target:\n        if target == 0:\n            print('yes' if n >= k else 'no')\n            continue\n        possible = True\n        for i in range(k - 1):\n            if recurse(1, san[0]):\n                del san[0]\n            else:\n                possible = False\n                break\n        print('yes' if possible else 'no')\n    else:\n        print('no')", "__author__ = 'Rakshak.R.Hegde'\ntarget = 0\nsan = []\n\ndef recurse(i, sum):\n    if sum == target:\n        return True\n    if sum > target or i == len(san):\n        return False\n    if recurse(i + 1, sum + san[i]):\n        del san[i]\n        return True\n    return recurse(i + 1, sum)\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    san = sorted(map(int, input().split()), reverse=True)\n    (target, rem) = divmod(sum(san), k)\n    if rem == 0 and san[0] <= target:\n        if target == 0:\n            print('yes' if n >= k else 'no')\n            continue\n        possible = True\n        for i in range(k):\n            if recurse(1, san[0]):\n                del san[0]\n            else:\n                possible = False\n                break\n        print('yes' if possible else 'no')\n    else:\n        print('no')", "from itertools import chain, combinations\n\ndef list_powerset(lst, k):\n    result = [[]]\n    for x in lst:\n        result.extend([subset + [x] for subset in result if sum(subset) + x <= k])\n    return result\n\ndef powerset(iterable, k):\n    xs = iterable\n    return chain.from_iterable((combinations(xs, n) for n in range(len(xs) - k + 1 + 1)))\n\ndef list_powerset2(lst):\n    return reduce(lambda result, x: result + [subset + [x] for subset in result], lst, [[]])\nT = int(input())\nfor t in range(T):\n    (N, K) = [int(i) for i in input().split()]\n    nums = [int(i) for i in input().split() if int(i) != 0]\n    d = {}\n    for i in nums:\n        try:\n            d[i] += 1\n        except KeyError:\n            d[i] = 1\n    reach = sum(nums)\n    if reach == 0:\n        if N >= K:\n            print('yes')\n        else:\n            print('no')\n        continue\n    if reach % K != 0:\n        print('no')\n        continue\n    reach = int(reach / K)\n    subsets = [i for i in list_powerset(nums, reach) if sum(i) == reach]\n    n_set = 0\n    for i in subsets:\n        flag = True\n        for j in i:\n            if d[j] < 1:\n                flag = False\n                break\n        if flag:\n            for j in i:\n                d[j] -= 1\n            n_set += 1\n    flag = True\n    for key in d.keys():\n        if d[key] > 0:\n            flag = False\n            break\n    if flag and n_set == K:\n        print('yes')\n    else:\n        print('no')"]