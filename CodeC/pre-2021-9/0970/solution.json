["from heapq import heapify, heappush, heappop\nst = 'abcdefghijklmnopqrstuvwxyz'\nd = {}\nd1 = {}\nfor i in range(26):\n    d[st[i]] = i\n    d1[i] = st[i]\nfor _ in range(int(input())):\n    s = input()\n    k = int(input())\n    heap = []\n    heapify(heap)\n    n = len(s)\n    for i in range(n - k + 1):\n        ind = d[s[i]]\n        heappush(heap, [ind, i])\n    a = heappop(heap)\n    fin = d1[a[0]]\n    ind = a[1]\n    for j in range(n - k + 1, n, 1):\n        heappush(heap, [d[s[j]], j])\n        while heap and heap[0][1] < ind:\n            a = heappop(heap)\n        a = heappop(heap)\n        fin += d1[a[0]]\n        ind = a[1]\n    print(fin)", "from heapq import heapify, heappush, heappop\nst = 'abcdefghijklmnopqrstuvwxyz'\nd = {}\nd1 = {}\nfor i in range(26):\n    d[st[i]] = i\n    d1[i] = st[i]\nfor _ in range(int(input())):\n    s = input()\n    k = int(input())\n    heap = []\n    heapify(heap)\n    n = len(s)\n    for i in range(n - k + 1):\n        ind = d[s[i]]\n        heappush(heap, [ind, i])\n    a = heappop(heap)\n    fin = d1[a[0]]\n    ind = a[1]\n    for j in range(n - k + 1, n, 1):\n        heappush(heap, [d[s[j]], j])\n        while heap and heap[0][1] < ind:\n            a = heappop(heap)\n        a = heappop(heap)\n        fin += d1[a[0]]\n        ind = a[1]\n    print(fin)", "from heapq import heapify, heappush, heappop\nst = 'abcdefghijklmnopqrstuvwxyz'\nd = {}\nd1 = {}\nfor i in range(26):\n    d[st[i]] = i\n    d1[i] = st[i]\nfor _ in range(int(input())):\n    s = input()\n    k = int(input())\n    heap = []\n    heapify(heap)\n    n = len(s)\n    for i in range(n - k + 1):\n        ind = d[s[i]]\n        heappush(heap, [ind, i])\n    a = heappop(heap)\n    fin = d1[a[0]]\n    ind = a[1]\n    for j in range(n - k + 1, n, 1):\n        heappush(heap, [d[s[j]], j])\n        while heap and heap[0][1] < ind:\n            a = heappop(heap)\n        a = heappop(heap)\n        fin += d1[a[0]]\n        ind = a[1]\n    print(fin)", "t = int(input())\nfor i in range(t):\n    s = input()\n    n = len(s)\n    k = int(input())\n    c = 0\n    ans = []\n    for j in range(k):\n        ans.append('')\n    for i in range(n):\n        if i == 0:\n            ans[i] = s[i]\n            c += 1\n        else:\n            while s[i] < ans[c - 1] and c + (n - i) > k:\n                ans[c - 1] = ''\n                c -= 1\n            if c < k:\n                ans[c] = s[i]\n                c += 1\n    anss = ''\n    for a in ans:\n        anss += a\n    print(anss)", "t = int(input())\nfor i in range(t):\n    s = input()\n    n = len(s)\n    k = int(input())\n    c = 0\n    ans = []\n    for j in range(k):\n        ans.append('')\n    for i in range(n):\n        if i == 0:\n            ans[i] = s[i]\n            c += 1\n        else:\n            while s[i] < ans[c - 1] and c + (n - i) > k:\n                ans[c - 1] = ''\n                c -= 1\n            if c < k:\n                ans[c] = s[i]\n                c += 1\n    anss = ''\n    for a in ans:\n        anss += a\n    print(anss)", "import sys\nsys.setrecursionlimit(100000)\n\ndef sub(s, k):\n    if k == 0:\n        return ''\n    if len(s) == k:\n        return s\n    if len(s) == 0:\n        return ''\n    d1 = 1\n    if len(s) - 1 >= k:\n        s1 = sub(s[:-1], k)\n    else:\n        d1 = 0\n    s2 = sub(s[:-1], k - 1)\n    if d1 == 0:\n        return s2 + s[-1]\n    if s1 < s2 + s[-1]:\n        return s1\n    return s2 + s[-1]\n\ndef solve(s, k):\n    stack = []\n    left = 0\n    l = len(s)\n    for x in range(l):\n        if left == 0:\n            stack.append(s[x])\n            left += 1\n        else:\n            while left > 0 and stack[-1] > s[x] and (l - x + left - 1 >= k):\n                stack.pop()\n                left -= 1\n            stack.append(s[x])\n            left += 1\n    return ''.join(stack[:k])\nT = int(input())\nfor t in range(T):\n    S = input()\n    K = int(input())\n    print(solve(S, K))", "def smallestSubsequence(s, k):\n    toRem = len(s) - k\n    ind = 0\n    while ind < len(s) - 1 and toRem > 0:\n        if s[ind] > s[ind + 1]:\n            s = s[:ind] + s[ind + 1:]\n            toRem -= 1\n            ind -= 1\n            if ind < 0:\n                ind = 0\n        else:\n            ind += 1\n    s = s[:k]\n    return s\nfor ii in range(int(input())):\n    s = input()\n    k = int(input())\n    print(smallestSubsequence(s, k))", "t = int(input())\n\ndef spush(a, elem):\n    a.append(elem)\n\ndef spop(a, size):\n    j = a.pop(size - 1)\n    return j\nfor i in range(t):\n    s = input()\n    k = int(input())\n    a = []\n    size = 1\n    a.append(s[0])\n    p = len(s)\n    zz = 1\n    while zz < p:\n        ss = s[zz]\n        chm = a[size - 1]\n        while ss < chm and size + (p - zz - 1) >= k:\n            spop(a, size)\n            size -= 1\n            if size == 0:\n                break\n            chm = a[size - 1]\n        if size < k:\n            size += 1\n            spush(a, ss)\n        zz += 1\n    o = ''\n    for t in range(k):\n        o = o + a[t]\n    print(o)", "def segmentTree(arr, segTree, low, high, pos):\n    if low == high:\n        segTree[pos] = (arr[low], low)\n        return\n    mid = (low + high) // 2\n    segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n    segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n    aa = segTree[2 * pos + 1]\n    bb = segTree[2 * pos + 2]\n    if aa[0] != bb[0]:\n        segTree[pos] = aa if aa[0] < bb[0] else bb\n    else:\n        segTree[pos] = aa if aa[1] < bb[1] else bb\n\ndef qr(segTree, qLow, qHigh, low, high, pos):\n    if qLow <= low and qHigh >= high:\n        return segTree[pos]\n    if qLow > high or qHigh < low:\n        return ('zzz', 1000)\n    mid = (low + high) // 2\n    b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n    c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n    if b[0] != c[0]:\n        a = b if b[0] < c[0] else c\n    else:\n        a = b if b[1] < c[1] else c\n    return a\nfor t in range(int(input())):\n    arr = list(input())\n    ans = ''\n    n = int(input())\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while n > 0:\n        end = len(arr) - n\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        n = n - 1\n    print(ans)"]