["for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    vis = set()\n    ans = 0\n    for i in range(30, -1, -1):\n        f = 1\n        h = []\n        for j in range(n):\n            if j in vis:\n                if 1 << i & b[j] == 0:\n                    f = 0\n            elif a[j] & 1 << i == 0:\n                if b[j] & 1 << i and b[j] & ans == ans:\n                    h.append(j)\n                else:\n                    f = 0\n        if f:\n            ans += 1 << i\n            for j in h:\n                vis.add(j)\n    print(ans, len(vis))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    vis = set()\n    ans = 0\n    for i in range(30, -1, -1):\n        f = 1\n        h = []\n        for j in range(n):\n            if j in vis:\n                if 1 << i & b[j] == 0:\n                    f = 0\n            elif a[j] & 1 << i == 0:\n                if b[j] & 1 << i and b[j] & ans == ans:\n                    h.append(j)\n                else:\n                    f = 0\n        if f:\n            ans += 1 << i\n            for j in h:\n                vis.add(j)\n    print(ans, len(vis))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    vis = set()\n    ans = 0\n    for i in range(30, -1, -1):\n        f = 1\n        h = []\n        for j in range(n):\n            if j in vis:\n                if 1 << i & b[j] == 0:\n                    f = 0\n            elif a[j] & 1 << i == 0:\n                if b[j] & 1 << i and b[j] & ans == ans:\n                    h.append(j)\n                else:\n                    f = 0\n        if f:\n            ans += 1 << i\n            for j in h:\n                vis.add(j)\n    print(ans, len(vis))", "for _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    flip = set()\n    band = 0\n    mbits = 0\n    for i in range(N):\n        mbits = max(mbits, len(bin(A[i])[2:]), len(bin(B[i])[2:]))\n    for bit in range(mbits, 0, -1):\n        tbt = 2 ** (bit - 1)\n        rflip = set()\n        aflip = set()\n        for i in range(N):\n            if i in flip:\n                if B[i] & tbt == 0:\n                    if A[i] & tbt != 0 and (band == 0 or A[i] & band == band):\n                        rflip.add(i)\n                    else:\n                        break\n            elif A[i] & tbt == 0:\n                if B[i] & tbt != 0 and (band == 0 or B[i] & band == band):\n                    aflip.add(i)\n                else:\n                    break\n        else:\n            band += tbt\n            for i in aflip:\n                flip.add(i)\n            for i in rflip:\n                flip.remove(i)\n    print(str(band) + ' ' + str(len(flip)))", "for _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    flip = set()\n    band = 0\n    mbits = 0\n    for i in range(N):\n        mbits = max(mbits, len(bin(A[i])[2:]), len(bin(B[i])[2:]))\n    for bit in range(mbits, 0, -1):\n        tbt = 2 ** (bit - 1)\n        rflip = set()\n        aflip = set()\n        for i in range(N):\n            if i in flip:\n                if B[i] & tbt == 0:\n                    if A[i] & tbt != 0 and (band == 0 or A[i] & band == band):\n                        rflip.add(i)\n                    else:\n                        break\n            elif A[i] & tbt == 0:\n                if B[i] & tbt != 0 and (band == 0 or B[i] & band == band):\n                    aflip.add(i)\n                else:\n                    break\n        else:\n            band += tbt\n            for i in aflip:\n                flip.add(i)\n            for i in rflip:\n                flip.remove(i)\n    print(str(band) + ' ' + str(len(flip)))", "for _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    flip = set()\n    band = 0\n    mbits = 0\n    for i in range(N):\n        mbits = max(A[i], B[i], mbits)\n    else:\n        mbits = len(bin(mbits)[2:])\n    for bit in range(mbits, 0, -1):\n        tbt = 2 ** (bit - 1)\n        rflip = set()\n        aflip = set()\n        for i in range(N):\n            if i in flip:\n                if B[i] & tbt == 0:\n                    if A[i] & tbt != 0 and (band == 0 or A[i] & band == band):\n                        rflip.add(i)\n                    else:\n                        break\n            elif A[i] & tbt == 0:\n                if B[i] & tbt != 0 and (band == 0 or B[i] & band == band):\n                    aflip.add(i)\n                else:\n                    break\n        else:\n            band += tbt\n            for i in aflip:\n                flip.add(i)\n            for i in rflip:\n                flip.remove(i)\n    print(str(band) + ' ' + str(len(flip)))", "for _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    flip = set()\n    band = 0\n    mbits = 0\n    for i in range(N):\n        mbits = max(A[i], B[i], mbits)\n    else:\n        mbits = len(bin(mbits)[2:])\n    for bit in range(mbits, 0, -1):\n        tbt = 2 ** (bit - 1)\n        rflip = set()\n        aflip = set()\n        for i in range(N):\n            if i in flip:\n                if B[i] & tbt == 0:\n                    if A[i] & tbt != 0 and (band == 0 or A[i] & band == band):\n                        rflip.add(i)\n                    else:\n                        break\n            elif A[i] & tbt == 0:\n                if B[i] & tbt != 0 and (band == 0 or B[i] & band == band):\n                    aflip.add(i)\n                else:\n                    break\n        else:\n            band += tbt\n            for i in aflip:\n                flip.add(i)\n            for i in rflip:\n                flip.remove(i)\n    print(str(band) + ' ' + str(len(flip)))", "T = int(input())\n\ndef check(bit, setBits, array):\n    for i in range(N):\n        here = 0\n        if front[i] == float('inf') or front[i] & 1 << bit == 0:\n            here = here + 1\n        if back[i] == float('inf') or back[i] & 1 << bit == 0:\n            here = here + 1\n        if here == 2:\n            return False\n    for i in range(N):\n        if front[i] != float('inf') and front[i] & 1 << bit == 0:\n            front[i] = float('inf')\n        if back[i] != float('inf') and back[i] & 1 << bit == 0:\n            back[i] = float('inf')\n    return True\nfor _ in range(T):\n    N = int(input())\n    front = list(map(int, input().split()))\n    back = list(map(int, input().split()))\n    array = []\n    bit = 32\n    ans = 0\n    setBits = set()\n    flips = 0\n    array = [0 for i in range(N)]\n    while bit >= 0:\n        value = check(bit, setBits, array)\n        if value == True:\n            ans = ans + 2 ** bit\n        bit = bit - 1\n    count = 0\n    for i in range(len(front)):\n        if front[i] == float('inf'):\n            count = count + 1\n    print(ans, end=' ')\n    print(count)", "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    state = [-1] * n\n    bit = 1 << 29\n    while bit > 0:\n        poss = True\n        for i in range(n):\n            if state[i] == 0 and (not a[i] & bit):\n                poss = False\n            elif state[i] == 1 and (not b[i] & bit):\n                poss = False\n            elif not a[i] & bit and (not b[i] & bit):\n                poss = False\n        if not poss:\n            bit >>= 1\n            continue\n        for i in range(n):\n            if state[i] != -1:\n                continue\n            if not a[i] & bit:\n                state[i] = 1\n            elif not b[i] & bit:\n                state[i] = 0\n        bit >>= 1\n    ans = (1 << 30) - 1\n    flip = 0\n    for i in range(n):\n        if state[i] == 1:\n            flip += 1\n            ans &= b[i]\n        else:\n            ans &= a[i]\n    print(str(ans) + ' ' + str(flip))\nt = int(input())\nwhile t:\n    solve()\n    t -= 1", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    st = [-1] * n\n    ans = 0\n    for i in range(29, -1, -1):\n        ps = 1\n        bit = 1 << i\n        for i in range(n):\n            if st[i] == 0 and a[i] & bit == 0:\n                ps = 0\n                break\n            elif st[i] == 1 and b[i] & bit == 0:\n                ps = 0\n                break\n            elif st[i] == -1 and b[i] & bit == 0 and (a[i] & bit == 0):\n                ps = 0\n                break\n        if ps:\n            ans += bit\n            for i in range(n):\n                if st[i] == 1 or st[i] == 0:\n                    continue\n                elif a[i] & bit and b[i] & bit:\n                    continue\n                elif a[i] & bit:\n                    st[i] = 0\n                else:\n                    st[i] = 1\n    print(ans, st.count(1))", "for _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    res = [-1 for i in range(n)]\n    bcount = 0\n    abin = [bin(i) for i in a]\n    bbin = [bin(i) for i in b]\n    for i in reversed(range(30)):\n        currentrow = [-1 for k in range(n)]\n        usable = True\n        for j in range(n):\n            if res[j] == -1:\n                aval = a[j] >> i & 1\n                bval = b[j] >> i & 1\n                if aval == 0 and bval == 0:\n                    usable = False\n                    break\n                if aval == 1 and bval == 1:\n                    continue\n                elif aval == 1:\n                    currentrow[j] = 0\n                else:\n                    currentrow[j] = 1\n            else:\n                aval = a[j] >> i & 1\n                bval = b[j] >> i & 1\n                if res[j] == 0:\n                    if aval == 0:\n                        usable = False\n                elif res[j] == 1:\n                    if bval == 0:\n                        usable = False\n        if usable:\n            for l in range(n):\n                if res[l] == -1:\n                    res[l] = currentrow[l]\n    start = 2 ** 30 - 1\n    for i in range(n):\n        if res[i] == 0 or res[i] == -1:\n            start &= a[i]\n        else:\n            start &= b[i]\n            bcount += 1\n    print(start, bcount)", "for _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    flip = set()\n    band = 0\n    mbits = 0\n    for i in range(N):\n        mbits = max(mbits, len(bin(A[i])[2:]), len(bin(B[i])[2:]))\n    for bit in range(mbits, 0, -1):\n        tbt = 2 ** (bit - 1)\n        rflip = set()\n        aflip = set()\n        for i in range(N):\n            if i in flip:\n                if B[i] & tbt == 0:\n                    if A[i] & tbt != 0 and (band == 0 or A[i] & band == band):\n                        rflip.add(i)\n                    else:\n                        break\n            elif A[i] & tbt == 0:\n                if B[i] & tbt != 0 and (band == 0 or B[i] & band == band):\n                    aflip.add(i)\n                else:\n                    break\n        else:\n            band += tbt\n            for i in aflip:\n                flip.add(i)\n            for i in rflip:\n                flip.remove(i)\n    print(str(band) + ' ' + str(len(flip)))", "for _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    flip = set()\n    band = 0\n    mbits = 0\n    for i in range(N):\n        mbits = max(mbits, len(bin(A[i])) - 2, len(bin(B[i])) - 2)\n    for bit in range(mbits, 0, -1):\n        tbt = band + (1 << bit - 1)\n        rflip = set()\n        aflip = set()\n        for i in range(N):\n            if i in flip:\n                if B[i] & tbt != tbt:\n                    if A[i] & tbt == tbt:\n                        rflip.add(i)\n                    else:\n                        break\n            elif A[i] & tbt != tbt:\n                if B[i] & tbt == tbt:\n                    aflip.add(i)\n                else:\n                    break\n        else:\n            band = tbt\n            for i in aflip:\n                flip.add(i)\n            for i in rflip:\n                flip.remove(i)\n    print(str(band) + ' ' + str(len(flip)))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    pos = [-1] * n\n    x = 1 << 29\n    while x:\n        poss = True\n        for y in range(n):\n            if pos[y] == 0 and (not a[y] & x):\n                poss = False\n            elif pos[y] == 1 and (not b[y] & x):\n                poss = False\n            elif not a[y] & x and (not b[y] & x):\n                poss = False\n        for y in range(n):\n            if poss:\n                if not a[y] & x:\n                    pos[y] = 1\n                elif not b[y] & x:\n                    pos[y] = 0\n        x >>= 1\n    ans = 0\n    anf = (1 << 30) - 1\n    for x in range(n):\n        if pos[x] == -1 or pos[x] == 0:\n            anf = anf & a[x]\n        elif pos[x] == 1:\n            anf &= b[x]\n        ans += pos[x] == 1\n    print(anf, ans)", "t = int(input())\n\ndef log(n):\n    x = str(bin(n))[2:]\n    return len(x) - 1\n\ndef check(n, m):\n    x = str(bin(n))[2:]\n    if m < len(x):\n        return x[-m - 1] == '1'\n    return False\nfor _ in range(t):\n    n = int(input())\n    f = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    mix = [[f[i], b[i]] for i in range(n)]\n    m = log(max(f + b))\n    val = 0\n    flips = 0\n    ind = []\n    while m >= 0:\n        av = True\n        tempMix = mix[:]\n        tempFlips = flips\n        for (i, val) in enumerate(mix):\n            if len(val) == 2:\n                x = check(val[0], m)\n                y = check(val[1], m)\n                if not (x or y):\n                    av = False\n                    break\n                elif x and (not y):\n                    tempMix[i] = [val[0]]\n                elif y and (not x):\n                    tempFlips += 1\n                    tempMix[i] = [val[1]]\n            elif not check(val[0], m):\n                av = False\n                break\n        if av:\n            mix = tempMix\n            flips = tempFlips\n            ind.append(m)\n        m -= 1\n    s = 0\n    for i in ind:\n        s += 2 ** i\n    print(s, flips)", "t = int(input())\nfor z in range(t):\n    n = int(input())\n    state = [-1] * n\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    x = 1 << 29\n    while x > 0:\n        chng = True\n        x = x // 2\n        for i in range(n):\n            if state[i] == 0 and (not a[i] & x):\n                chng = False\n            elif state[i] == 1 and (not b[i] & x):\n                chng = False\n            elif not a[i] & x and (not b[i] & x):\n                chng = False\n        if not chng:\n            continue\n        for i in range(n):\n            if state[i] != -1:\n                continue\n            if not a[i] & x:\n                state[i] = 1\n            elif not b[i] & x:\n                state[i] = 0\n    ans = (1 << 30) - 1\n    count = 0\n    for i in range(n):\n        if state[i] == 1:\n            count += 1\n            ans &= b[i]\n        else:\n            ans &= a[i]\n    print(ans, count)", "for tcase in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    (p2, flip, canflip) = (2 ** 29, [0] * n, [True] * n)\n    result = 0\n    while p2 > 0:\n        (i, x) = (0, p2)\n        while x == p2 and i < n:\n            if canflip[i]:\n                x = p2 & (a[i] | b[i])\n            else:\n                x = p2 & a[i]\n            i += 1\n        if x == p2:\n            result += p2\n            for i in range(n):\n                canflip[i] = canflip[i] and p2 & b[i] == p2\n                if canflip[i] and p2 & a[i] == 0:\n                    (a[i], b[i]) = (b[i], a[i])\n                    flip[i] = 1\n                    canflip[i] = False\n        p2 //= 2\n    print(result, sum(flip))", "for tcase in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    (p2, flip, canflip) = (2 ** 29, [0] * n, [True] * n)\n    result = 0\n    while p2 > 0:\n        (i, x) = (0, p2)\n        while x == p2 and i < n:\n            if canflip[i]:\n                x = p2 & (a[i] | b[i])\n            else:\n                x = p2 & a[i]\n            i += 1\n        if x == p2:\n            result += p2\n            for i in range(n):\n                canflip[i] = canflip[i] and flip[i] == 0 and (p2 & b[i] == p2)\n                if canflip[i] and p2 & a[i] == 0:\n                    (a[i], b[i]) = (b[i], a[i])\n                    flip[i] = 1\n                    canflip[i] = False\n        p2 //= 2\n    print(result, sum(flip))", "t = int(input())\nfor xyz in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    m = max(max(A), max(B))\n    b = 0\n    while m > 1:\n        m = m // 2\n        b += 1\n    ans = 0\n    flips = 0\n    while b >= 0:\n        f = True\n        for i in range(n):\n            if (A[i] >> b & 1 == 0 or ans & A[i] != ans) and (B[i] == None or B[i] >> b & 1 == 0 or ans & B[i] != ans):\n                f = False\n                break\n        if f:\n            cur = 0\n            for i in range(n):\n                if A[i] >> b & 1 == 0 and B[i] != None:\n                    A[i] = B[i]\n                    B[i] = None\n                    cur += 1\n            flips += cur\n            ans += 1 << b\n        b -= 1\n    print(ans, flips)", "import sys\nfrom bisect import bisect_right as lb\nfrom collections import deque\nfrom queue import PriorityQueue as pq\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nlii = lambda : list(map(int, list(ip())))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\ninv = lambda x: pow(x, mod - 2, mod)\nmod = 10 ** 9 + 7\nfor _ in range(ii()):\n    n = ii()\n    a = il()\n    b = il()\n    ans = 0\n    t = 0\n    for i in range(29, -1, -1):\n        x = 2 ** i\n        fl = 1\n        y = []\n        for j in range(n):\n            if a[j] & x == x:\n                continue\n            if b[j] & x == x and b[j] & ans == ans:\n                y.append(j)\n                continue\n            else:\n                fl = 0\n                break\n        if fl:\n            ans |= x\n            for j in y:\n                a[j] = b[j]\n                t += 1\n    print(ans, t)", "import sys\nfrom bisect import bisect_right as lb\nfrom collections import deque\nfrom queue import PriorityQueue as pq\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nlii = lambda : list(map(int, list(ip())))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\ninv = lambda x: pow(x, mod - 2, mod)\nmod = 10 ** 9 + 7\nfor _ in range(ii()):\n    n = ii()\n    a = il()\n    b = il()\n    ans = 0\n    t = 0\n    for i in range(29, -1, -1):\n        x = 2 ** i\n        fl = 0\n        y = []\n        for j in range(n):\n            if a[j] & x == x:\n                continue\n            if b[j] & x == x and b[j] & ans == ans:\n                y.append(j)\n                continue\n            else:\n                fl = 1\n                break\n        if fl == 1:\n            continue\n        ans |= x\n        for j in y:\n            a[j] = b[j]\n            t += 1\n    print(ans, t)", "import sys\nimport bisect\ninput = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nsys.setrecursionlimit(10 ** 6)\nflsh = lambda : sys.stdout.flush()\nsa = lambda : input()\nsb = lambda : int(input())\nsc = lambda : input().split()\nsd = lambda : list(map(int, input().split()))\nse = lambda : float(input())\nsf = lambda : list(input())\nmod = 10 ** 9 + 7\n\ndef hnbhai():\n    n = sb()\n    a = sd()\n    b = sd()\n    ans = 0\n    tot = 0\n    for i in range(29, -1, -1):\n        bit = 2 ** i\n        x = 0\n        f = 0\n        temp = []\n        for j in range(n):\n            if a[j] & bit == bit:\n                continue\n            if b[j] & bit == bit and b[j] & ans == ans:\n                x += 1\n                temp.append(j)\n                continue\n            f = 1\n            break\n        if f:\n            continue\n        ans |= bit\n        for j in temp:\n            a[j] = b[j]\n            tot += 1\n    print(ans, tot)\nfor _ in range(sb()):\n    hnbhai()", "T = int(input())\nwhile T != 0:\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    m = max(max(A), max(B))\n    index = 0\n    while m != 1:\n        index += 1\n        m //= 2\n    ans = (1 << index + 1) - 1\n    state = [-1 for t in range(n)]\n    i = 1 << index\n    while i > 0:\n        poss = True\n        for j in range(n):\n            if state[j] == 1 and (not A[j] & i):\n                poss = False\n                break\n            elif state[j] == 0 and (not B[j] & i):\n                poss = False\n                break\n            elif not A[j] & i and (not B[j] & i):\n                poss = False\n                break\n        if poss:\n            for k in range(n):\n                if state[k] != -1:\n                    continue\n                if not A[k] & i:\n                    state[k] = 0\n                elif not B[k] & i:\n                    state[k] = 1\n        i >>= 1\n    flip = 0\n    for p in range(n):\n        if state[p] == 0:\n            flip += 1\n            ans &= B[p]\n        else:\n            ans &= A[p]\n    print(ans, flip, sep=' ')\n    T -= 1", "for tc in range(int(input())):\n    n = int(input())\n    ls = list(map(int, input().split()))\n    lk = list(map(int, input().split()))\n    comb = [-1] * len(ls)\n    res = []\n    for r in range(30, -1, -1):\n        pos = True\n        for x in range(len(ls)):\n            if comb[x] == 0 and ls[x] >> r & 1 == 0:\n                pos = False\n            elif comb[x] == 1 and lk[x] >> r & 1 == 0:\n                pos = False\n            elif ls[x] >> r & 1 == 0 and lk[x] >> r & 1 == 0:\n                pos = False\n        if pos == False:\n            continue\n        for x in range(len(ls)):\n            if comb[x] != -1:\n                pass\n            elif ls[x] >> r & 1 == 0:\n                comb[x] = 1\n            elif lk[x] >> r & 1 == 0:\n                comb[x] = 0\n    flips = 0\n    an = -1\n    for x in range(len(ls)):\n        if comb[x] == 1:\n            flips += 1\n            if an == -1:\n                an = lk[x]\n            else:\n                an &= lk[x]\n        elif an == -1:\n            an = ls[x]\n        else:\n            an &= ls[x]\n    print(an, flips)", "def intinp():\n    return int(input())\n\ndef mapinp():\n    return map(int, list(input().split()))\nT = intinp()\nfor _ in range(T):\n    N = intinp()\n    A = list(mapinp())\n    B = list(mapinp())\n    state = [0] * N\n    flipped = [0] * N\n    for i in range(29, -1, -1):\n        flip = True\n        for j in range(N):\n            if A[j] & 1 << i == 0:\n                if B[j] & 1 << i != 0 and state[j] == 0:\n                    state[j] = 2\n                else:\n                    flip = False\n                    break\n            elif B[j] & 1 << i == 0 and state[j] == 0:\n                state[j] = 3\n        for k in range(N):\n            if flip and state[k] == 2:\n                temp = A[k]\n                A[k] = B[k]\n                B[k] = temp\n                flipped[k] = 1\n                state[k] = 1\n            if flip and state[k] == 3:\n                state[k] = 1\n            if not flip and (state[k] == 2 or state[k] == 3):\n                state[k] = 0\n    bitwiseAnd = A[0]\n    numFlip = 0\n    for i in range(N):\n        bitwiseAnd = bitwiseAnd & A[i]\n        if flipped[i] == 1:\n            numFlip += 1\n    print(bitwiseAnd, end=' ')\n    print(numFlip)", "import sys\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef maps():\n    return [int(i) for i in input().split()]\nfrom collections import defaultdict\nfor _ in range(*maps()):\n    (n,) = maps()\n    a = [*maps()]\n    b = [*maps()]\n    st = [-1] * n\n    ans = (1 << 30) - 1\n    bit = 1 << 30\n    while bit:\n        ok = True\n        for i in range(n):\n            if st[i] == 0 and (not a[i] & bit):\n                ok = False\n            elif st[i] == 1 and (not b[i] & bit):\n                ok = False\n            elif not a[i] & bit and (not b[i] & bit):\n                ok = False\n        if ok:\n            for i in range(n):\n                if st[i] != -1:\n                    continue\n                if not a[i] & bit:\n                    st[i] = 1\n                elif not b[i] & bit:\n                    st[i] = 0\n        bit >>= 1\n    flips = 0\n    for i in range(n):\n        if st[i] == 1:\n            ans &= b[i]\n            flips += 1\n        else:\n            ans &= a[i]\n    if ans == (1 << 30) - 1:\n        print(0, 0)\n        continue\n    print(ans, flips)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    state = [-1] * n\n    bit = 1 << 29\n    while bit > 0:\n        poss = True\n        for j in range(n):\n            if state[j] == 0 and (not a[j] & bit):\n                poss = False\n            elif state[j] == 1 and (not b[j] & bit):\n                poss = False\n            elif not a[j] & bit and (not b[j] & bit):\n                poss = False\n        temp = bit\n        bit >>= 1\n        if not poss:\n            continue\n        for i in range(n):\n            if state[i] != -1:\n                continue\n            if not a[i] & temp:\n                state[i] = 1\n            elif not b[i] & temp:\n                state[i] = 0\n    ans = (1 << 30) - 1\n    flips = 0\n    for i in range(n):\n        if state[i] == 1:\n            flips += 1\n            ans &= b[i]\n        else:\n            ans &= a[i]\n    print(str(ans) + ' ' + str(flips))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ans = 0\n    flips = 0\n    decided = [-1] * n\n    for j in range(29, -1, -1):\n        possible = True\n        make_decided = [-1] * n\n        for i in range(n):\n            if decided[i] != -1:\n                if decided[i] == 0 and a[i] & 1 << j == 1 << j:\n                    continue\n                elif decided[i] == 1 and b[i] & 1 << j == 1 << j:\n                    continue\n                else:\n                    possible = False\n                    break\n            elif a[i] & 1 << j != 1 << j and b[i] & 1 << j != 1 << j:\n                possible = False\n                break\n            elif a[i] & 1 << j == 1 << j and b[i] & 1 << j == 1 << j:\n                pass\n            elif b[i] & 1 << j == 1 << j:\n                make_decided[i] = 1\n            elif a[i] & 1 << j == 1 << j:\n                make_decided[i] = 0\n            else:\n                possible = False\n                break\n        if possible:\n            for k in range(n):\n                if make_decided[k] != -1:\n                    decided[k] = make_decided[k]\n            ans = ans * 10 + 1\n        else:\n            ans = ans * 10\n    anss = 0\n    ans = str(ans)\n    n_ans = len(ans)\n    for i in range(n_ans - 1, -1, -1):\n        if ans[i] == '1':\n            anss += 1 << n_ans - i - 1\n    print(anss, end=' ')\n    for i in range(n):\n        if decided[i] == 1:\n            flips += 1\n    print(flips)", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ans = 0\n    st = [-1] * n\n    for k in range(29, -1, -1):\n        poss = 1\n        for i in range(n):\n            if st[i] == 0:\n                if not 1 << k & a[i]:\n                    poss = 0\n                    break\n            elif st[i] == 1:\n                if not 1 << k & b[i]:\n                    poss = 0\n                    break\n            elif not 1 << k & a[i] and (not 1 << k & b[i]):\n                poss = 0\n                break\n        if not poss:\n            continue\n        else:\n            ans += 1 << k\n            for i in range(n):\n                if st[i] != -1:\n                    continue\n                elif not (a[i] & 1 << k and b[i] & 1 << k):\n                    if a[i] & 1 << k:\n                        st[i] = 0\n                    else:\n                        st[i] = 1\n    print(ans, st.count(1))", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ans = 0\n    st = [-1] * n\n    bit = 1 << 29\n    while bit > 0:\n        poss = 1\n        for i in range(n):\n            if st[i] == 0 and bit & a[i] == 0:\n                poss = 0\n                break\n            elif st[i] == 1 and bit & b[i] == 0:\n                poss = 0\n                break\n            elif st[i] == -1 and bit & (a[i] | b[i]) == 0:\n                poss = 0\n                break\n        if poss:\n            ans += bit\n            for i in range(n):\n                if st[i] != -1:\n                    continue\n                else:\n                    if a[i] & bit and b[i] & bit:\n                        continue\n                    if a[i] & bit:\n                        st[i] = 0\n                    elif b[i] & bit:\n                        st[i] = 1\n        bit >>= 1\n    print(ans, st.count(1))", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ans = 0\n    st = [-1] * n\n    bit = 1 << 29\n    while bit > 0:\n        poss = 1\n        for i in range(n):\n            if st[i] == 0 and bit & a[i] == 0:\n                poss = 0\n                break\n            elif st[i] == 1 and bit & b[i] == 0:\n                poss = 0\n                break\n            elif st[i] == -1 and bit & (a[i] | b[i]) == 0:\n                poss = 0\n                break\n        if poss:\n            ans += bit\n            for i in range(n):\n                if st[i] != -1:\n                    continue\n                else:\n                    if a[i] & bit and b[i] & bit:\n                        continue\n                    if a[i] & bit:\n                        st[i] = 0\n                    elif b[i] & bit:\n                        st[i] = 1\n        bit >>= 1\n    print(ans, st.count(1))", "for tc in range(int(input())):\n    n = int(input())\n    ls = list(map(int, input().split()))\n    lk = list(map(int, input().split()))\n    comb = [-1] * len(ls)\n    res = []\n    for r in range(30, -1, -1):\n        cnt = 0\n        pos = True\n        for x in range(len(ls)):\n            if comb[x] == 0 and ls[x] >> r & 1 == 0:\n                pos = False\n            elif comb[x] == 1 and lk[x] >> r & 1 == 0:\n                pos = False\n            elif ls[x] >> r & 1 == 0 and lk[x] >> r & 1 == 0:\n                pos = False\n        if not pos:\n            continue\n        for x in range(len(ls)):\n            if comb[x] != -1:\n                continue\n            if ls[x] >> r & 1 == 0:\n                comb[x] = 1\n            elif lk[x] >> r & 1 == 0:\n                comb[x] = 0\n    an = -1\n    flips = 0\n    for x in range(len(ls)):\n        if comb[x] == 1:\n            flips += 1\n            if an == -1:\n                an = lk[x]\n            else:\n                an &= lk[x]\n        elif an == -1:\n            an = ls[x]\n        else:\n            an &= ls[x]\n    print(an, flips)", "for tc in range(int(input())):\n    n = int(input())\n    ls = list(map(int, input().split()))\n    lk = list(map(int, input().split()))\n    comb = [-1] * len(ls)\n    res = []\n    for r in range(30, -1, -1):\n        cnt = 0\n        pos = True\n        for x in range(len(ls)):\n            if comb[x] == 0 and ls[x] >> r & 1 == 0:\n                pos = False\n            elif comb[x] == 1 and lk[x] >> r & 1 == 0:\n                pos = False\n            elif ls[x] >> r & 1 == 0 and lk[x] >> r & 1 == 0:\n                pos = False\n        if not pos:\n            continue\n        for x in range(len(ls)):\n            if comb[x] != -1:\n                continue\n            if ls[x] >> r & 1 == 0:\n                comb[x] = 1\n            elif lk[x] >> r & 1 == 0:\n                comb[x] = 0\n    an = -1\n    flips = 0\n    for x in range(len(ls)):\n        if comb[x] == 1:\n            flips += 1\n            if an == -1:\n                an = lk[x]\n            else:\n                an &= lk[x]\n        elif an == -1:\n            an = ls[x]\n        else:\n            an &= ls[x]\n    print(an, flips)", "import sys\nimport math\nimport heapq\nfrom collections import defaultdict as dd\nfrom collections import OrderedDict as od\nfrom collections import deque\nfrom itertools import permutations as pp\nfrom itertools import combinations as cc\nfrom sys import stdin\nfrom functools import cmp_to_key\nfrom functools import lru_cache\nfrom bisect import bisect_left as bs_l\nfrom bisect import bisect_right as bs_r\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 5)\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    brr = list(map(int, input().split()))\n    d = dd(int)\n    ans = 0\n    c = 0\n    for i in range(30, -1, -1):\n        ok = 1\n        flip = []\n        fl = []\n        for j in range(n):\n            if 1 << i & arr[j] and 1 << i & brr[j]:\n                continue\n            elif 1 << i & arr[j] and 1 << i & brr[j] == 0:\n                fl.append(j)\n            elif 1 << i & arr[j] == 0 and 1 << i & brr[j]:\n                if d[j]:\n                    ok = 0\n                    break\n                else:\n                    flip.append(j)\n            else:\n                ok = 0\n                break\n        if ok:\n            for k in flip:\n                if d[k]:\n                    ok = 0\n                    break\n                else:\n                    (arr[k], brr[k]) = (brr[k], arr[k])\n                    d[k] += 1\n                    c += 1\n            for k in fl:\n                d[k] += 1\n            ans |= 1 << i\n        else:\n            ans |= 0\n    print(ans, c)", "def func():\n    turn = [-1 for x in range(n)]\n    for req in range(31, -1, -1):\n        flag = False\n        changed = [False for x in range(n)]\n        swapped = [False for x in range(n)]\n        curr = 1 << req\n        for j in range(n):\n            if turn[j] != -1:\n                if curr & a[j] == 0:\n                    flag = True\n                    break\n                continue\n            if curr & a[j] and curr & b[j]:\n                continue\n            elif curr & a[j] and curr & b[j] == 0:\n                turn[j] = 0\n                changed[j] = True\n            elif curr & a[j] == 0 and curr & b[j]:\n                turn[j] = 1\n                (a[j], b[j]) = (b[j], a[j])\n                swapped[j] = True\n                changed[j] = True\n            else:\n                flag = True\n                break\n        if flag:\n            for j in range(n):\n                if changed[j]:\n                    turn[j] = -1\n                if swapped[j]:\n                    (a[j], b[j]) = (b[j], a[j])\n    calc = (1 << 31) - 1\n    ans = 0\n    for j in range(n):\n        if turn[j] == 1:\n            ans += 1\n        calc = calc & a[j]\n    print(calc, ans)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    func()", "for _ in range(int(input())):\n    n = int(input())\n    ai = list(map(int, input().split()))\n    bi = list(map(int, input().split()))\n    fi = [1] * n\n    for i in range(n):\n        x = str(bin(ai[i])[2:])\n        ai[i] = '0' * (32 - len(x)) + x\n        x = str(bin(bi[i])[2:])\n        bi[i] = '0' * (32 - len(x)) + x\n    fl = 0\n    for i in range(32):\n        f = 1\n        for j in range(n):\n            if ai[j][i] != '1':\n                if fi[j] == 1:\n                    if bi[j][i] != '1':\n                        f = 0\n                        break\n                else:\n                    f = 0\n                    break\n        if f == 1:\n            for j in range(n):\n                if ai[j][i] != '1':\n                    (ai[j], bi[j]) = (bi[j], ai[j])\n                    fi[j] = 0\n                    fl = fl + 1\n                elif bi[j][i] != '1':\n                    fi[j] = -1\n    an = int(ai[0], 2)\n    for ele in ai:\n        an = int(ele, 2) & an\n    print(an, fl)", "INF = pow(2, 31) - 1\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    state = [-1] * n\n    for i in range(31, -1, -1):\n        temp = 1 << i\n        possible = True\n        for i in range(n):\n            if state[i] == 0 and a[i] & temp == 0:\n                possible = False\n            elif state[i] == 1 and b[i] & temp == 0:\n                possible = False\n            elif a[i] & temp == 0 and b[i] & temp == 0:\n                possible = False\n        if possible:\n            for i in range(n):\n                if state[i] == -1:\n                    if a[i] & temp == 0:\n                        state[i] = 1\n                    elif b[i] & temp == 0:\n                        state[i] = 0\n    ans = INF\n    moves = 0\n    for i in range(n):\n        if state[i] == 1:\n            ans &= b[i]\n            moves += 1\n        else:\n            ans &= a[i]\n    print(ans, moves)", "INF = pow(2, 31) - 1\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    state = [-1] * n\n    for i in range(31, -1, -1):\n        temp = 1 << i\n        possible = True\n        for i in range(n):\n            if state[i] == 0 and a[i] & temp == 0:\n                possible = False\n            elif state[i] == 1 and b[i] & temp == 0:\n                possible = False\n            elif a[i] & temp == 0 and b[i] & temp == 0:\n                possible = False\n        if possible:\n            for i in range(n):\n                if state[i] == -1:\n                    if a[i] & temp == 0:\n                        state[i] = 1\n                    elif b[i] & temp == 0:\n                        state[i] = 0\n    ans = INF\n    moves = 0\n    for i in range(n):\n        if state[i] == 1:\n            ans &= b[i]\n            moves += 1\n        else:\n            ans &= a[i]\n    print(ans, moves)", "for _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    flip = [-1] * N\n    for i in range(30, -1, -1):\n        pos = True\n        for j in range(N):\n            if flip[j] == 0 and (not A[j] & 1 << i):\n                pos = False\n                break\n            elif flip[j] == 1 and (not B[j] & 1 << i):\n                pos = False\n                break\n            elif flip[j] == -1 and (not A[j] & 1 << i and (not B[j] & 1 << i)):\n                pos = False\n                break\n        if not pos:\n            continue\n        for j in range(N):\n            if flip[j] == -1:\n                if A[j] & 1 << i and B[j] & 1 << i:\n                    continue\n                elif A[j] & 1 << i:\n                    flip[j] = 0\n                elif B[j] & 1 << i:\n                    flip[j] = 1\n    count = 0\n    if flip[0] == 0 or flip[0] == -1:\n        bit = A[0]\n    else:\n        bit = B[0]\n        count += 1\n    for i in range(1, N):\n        if flip[i] == 0 or flip[i] == -1:\n            bit = A[i] & bit\n        else:\n            bit = B[i] & bit\n            count += 1\n    print(bit, count)", "from heapq import heappop, heappush\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    state = [-1] * n\n    bit = 1 << 29\n    while bit > 0:\n        poss = True\n        for i in range(n):\n            if state[i] == 0 and (not a[i] & bit):\n                poss = False\n            elif state[i] == 1 and (not b[i] & bit):\n                poss = False\n            elif not a[i] & bit and (not b[i] & bit):\n                poss = False\n        if not poss:\n            bit >>= 1\n            continue\n        for i in range(n):\n            if state[i] != -1:\n                continue\n            if not a[i] & bit:\n                state[i] = 1\n            elif not b[i] & bit:\n                state[i] = 0\n        bit >>= 1\n    ans = (1 << 30) - 1\n    flip = 0\n    for i in range(n):\n        if state[i] == 1:\n            flip += 1\n            ans &= b[i]\n        else:\n            ans &= a[i]\n    print(str(ans) + ' ' + str(flip))", "import math, os, io, heapq\nfrom sys import stdin, stdout\nfrom collections import Counter, deque, defaultdict\nfrom itertools import product\nimport bisect\n\ndef getList(method=int):\n    return list(map(method, input().split()))\n\ndef getInt():\n    return int(input())\n\ndef solve():\n    n = getInt()\n    (a, b) = (getList(), getList())\n    (bda, ans) = ([-1] * n, 0)\n    for bit in range(29, -1, -1):\n        mp = dict()\n        possible = True\n        for i in range(n):\n            if bda[i] != -1:\n                arr = b if bda[i] else a\n                if arr[i] & 1 << bit == 0:\n                    possible = False\n                    break\n            (amatch, bmatch) = (a[i] & 1 << bit > 0, b[i] & 1 << bit > 0)\n            if not (amatch or bmatch):\n                possible = False\n                break\n            if amatch and bmatch:\n                continue\n            mp[i] = 0 if amatch else 1\n        if possible:\n            ans ^= 1 << bit\n            for i in mp:\n                bda[i] = mp[i]\n    print(ans, bda.count(1))\nfor _ in range(getInt()):\n    solve()", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ans = 0\n    state = [-1] * n\n    for i in range(30, -1, -1):\n        bit = 2 ** i\n        is_bit_set = True\n        for j in range(n):\n            if a[j] & bit == 0 and b[j] & bit == 0:\n                is_bit_set = False\n            if a[j] & bit == 0 and state[j] == 0:\n                is_bit_set = False\n            if b[j] & bit == 0 and state[j] == 1:\n                is_bit_set = False\n        if is_bit_set:\n            ans += bit\n            for j in range(n):\n                if a[j] & bit == 0:\n                    state[j] = 1\n                if b[j] & bit == 0:\n                    state[j] = 0\n    flip = 0\n    for i in range(n):\n        if state[i] == 1:\n            flip += 1\n    print(ans, flip)\n    t = t - 1", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    totaland = 2 ** 32\n    flag = 0\n    overallflip = []\n    maxi = 0\n    while totaland > 0:\n        localflip = []\n        j = 0\n        while j < n:\n            x = a[j] & totaland\n            y = b[j] & totaland\n            if x == 0 and y == 0:\n                break\n            elif x == 0:\n                localflip.append(1)\n            elif y == 0:\n                localflip.append(0)\n            else:\n                localflip.append(2)\n            j += 1\n        if j == n:\n            if overallflip == []:\n                overallflip = localflip\n                maxi = totaland\n            else:\n                k = 0\n                temp = []\n                while k < n:\n                    if localflip[k] == 2:\n                        temp.append(overallflip[k])\n                    elif overallflip[k] != localflip[k] and overallflip[k] == 2:\n                        temp.append(localflip[k])\n                    elif overallflip[k] == localflip[k]:\n                        temp.append(localflip[k])\n                        k += 1\n                        continue\n                    else:\n                        break\n                    k += 1\n                if k == n:\n                    overallflip = temp\n                    maxi += totaland\n        totaland >>= 1\n    if overallflip == []:\n        print(0, 0)\n    else:\n        print(maxi, overallflip.count(1))", "T = int(input())\n\ndef check(bit, setBits, array):\n    for i in range(N):\n        here = 0\n        if front[i] == float('inf') or front[i] & 1 << bit == 0:\n            here = here + 1\n        if back[i] == float('inf') or back[i] & 1 << bit == 0:\n            here = here + 1\n        if here == 2:\n            return False\n    for i in range(N):\n        if front[i] != float('inf') and front[i] & 1 << bit == 0:\n            front[i] = float('inf')\n        if back[i] != float('inf') and back[i] & 1 << bit == 0:\n            back[i] = float('inf')\n    return True\nfor _ in range(T):\n    N = int(input())\n    front = list(map(int, input().split()))\n    back = list(map(int, input().split()))\n    array = []\n    bit = 32\n    ans = 0\n    setBits = set()\n    flips = 0\n    array = [0 for i in range(N)]\n    while bit >= 0:\n        value = check(bit, setBits, array)\n        if value == True:\n            ans = ans + 2 ** bit\n        bit = bit - 1\n    count = 0\n    for i in range(len(front)):\n        if front[i] == float('inf'):\n            count = count + 1\n    print(ans, end=' ')\n    print(count)", "from bisect import *\nfrom collections import *\nfrom sys import stdin, stdout\nfrom queue import *\nfrom itertools import *\nfrom heapq import *\nfrom random import *\nfrom statistics import *\nfrom math import *\nfrom re import *\nimport array\nimport operator\nfrom copy import *\nlines = stdin.readlines()\nout = stdout.write\nlines.reverse()\n\ndef input():\n    return lines.pop().strip('\\n')\n\ndef readIntList():\n    return list(map(int, input().split()))\n\ndef readStrList():\n    return list(map(str, input().split()))\n\ndef binaryarr(arr):\n    ans = []\n    for i in arr:\n        k = bin(i)[2:]\n        l = '0' * (30 - len(k)) + k\n        ans.append(l)\n    return ans\n\ndef mark(vis, bs, i):\n    ans = True\n    for j in range(i):\n        if vis[j] == 1 and bs[j] == '0':\n            ans = False\n            break\n    return ans\nfor i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    a1 = binaryarr(a)\n    b1 = binaryarr(b)\n    vis = [0] * 30\n    curr = 0\n    minr = 0\n    rep = [0] * (n + 1)\n    for i in range(30):\n        r1 = 0\n        ann = []\n        for j in a1:\n            if j[i] == '1':\n                r1 += 1\n                ann.append(1)\n            else:\n                ann.append(0)\n        r2 = 0\n        for j in range(len(b1)):\n            if rep[j] == 1:\n                ann[j] = int(b1[j][i])\n                continue\n            if b1[j][i] == '1' and mark(vis, b1[j], i):\n                ann[j] = 1\n                r2 += 1\n        if r1 == n:\n            vis[i] = 1\n        elif len(set(ann)) == 1 and ann[0] == 1:\n            arr = []\n            brr = []\n            for j in range(n):\n                if a1[j][i] == '1':\n                    arr.append(a1[j])\n                else:\n                    arr.append(b1[j])\n                    rep[j] = 1\n            a1 = arr[:]\n            vis[i] = 1\n    answer = 0\n    for i in range(30):\n        answer += vis[i] * 2 ** (29 - i)\n    print(answer, rep.count(1))", "from collections import Counter\nimport string\nimport math\nimport bisect\nimport sys\nfrom fractions import Fraction\n\ndef array_int():\n    return [int(i) for i in sys.stdin.readline().split()]\n\ndef vary(arrber_of_variables):\n    if arrber_of_variables == 1:\n        return int(sys.stdin.readline())\n    if arrber_of_variables >= 2:\n        return map(int, sys.stdin.readline().split())\n\ndef makedict(var):\n    return dict(Counter(var))\ntestcases = vary(1)\nfor _ in range(testcases):\n    n = vary(1)\n    num = array_int()\n    num2 = array_int()\n    ans = 0\n    visited = [0] * n\n    value = 0\n    lastset = []\n    for i in range(32, -1, -1):\n        new = 1\n        ct = 0\n        pre = []\n        maxi = -1\n        pos = 0\n        flag = 0\n        flag2 = 0\n        maxi2 = -1\n        for j in range(n):\n            if num[j] & 1 << i:\n                new = 1\n            else:\n                for kt in lastset:\n                    if num2[j] & 1 << kt:\n                        continue\n                    else:\n                        flag = 1\n                        new = 0\n                        break\n                if flag == 1:\n                    ct = 0\n                    break\n                if num2[j] & 1 << i and visited[j] == 0:\n                    new = 1\n                    ct += 1\n                    visited[j] = 1\n                    (num[j], num2[j]) = (num2[j], num[j])\n                    pre.append(j)\n                else:\n                    ct = 0\n                    new = 0\n                    flag = 1\n                    break\n        if flag == 1:\n            for k in pre:\n                visited[k] = 0\n                (num[k], num2[k]) = (num2[k], num[k])\n        if new == 1:\n            lastset.append(i)\n        ans += ct\n        value += 2 ** i if new == 1 else 0\n    print(value, ans)", "t = int(input())\nfor xyz in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    m = max(max(A), max(B))\n    b = 0\n    while m > 1:\n        m = m // 2\n        b += 1\n    ans = 0\n    flips = 0\n    while b >= 0:\n        f = True\n        for i in range(n):\n            if (A[i] >> b & 1 == 0 or ans & A[i] != ans) and (B[i] == None or B[i] >> b & 1 == 0 or ans & B[i] != ans):\n                f = False\n                break\n        if f:\n            cur = 0\n            for i in range(n):\n                if A[i] >> b & 1 == 0 and B[i] != None:\n                    A[i] = B[i]\n                    B[i] = None\n                    cur += 1\n            flips += cur\n            ans += 1 << b\n        b -= 1\n    print(ans, flips)", "t = int(input())\nfor xyz in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    m = max(max(A), max(B))\n    b = 0\n    while m > 1:\n        m = m // 2\n        b += 1\n    ans = 0\n    flips = 0\n    while b >= 0:\n        f = True\n        for i in range(n):\n            if (A[i] >> b & 1 == 0 or ans & A[i] != ans) and (B[i] == None or B[i] >> b & 1 == 0 or ans & B[i] != ans):\n                f = False\n                break\n        if f:\n            cur = 0\n            for i in range(n):\n                if A[i] >> b & 1 == 0 and B[i] != None:\n                    A[i] = B[i]\n                    B[i] = None\n                    cur += 1\n            flips += cur\n            ans += 1 << b\n        b -= 1\n    print(ans, flips)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    mx = max(max(a), max(b))\n    l = len(bin(mx).replace('0b', ''))\n    count = [3] * n\n    flag = False\n    for i in range(l, -1, -1):\n        if not flag:\n            count = [3] * n\n        temp = count[:]\n        cnt = 0\n        for j in range(n):\n            if count[j] == 1:\n                if a[j] & 1 << i == 0:\n                    count[j] = 0\n            elif count[j] == 2:\n                if b[j] & 1 << i == 0:\n                    count[j] = 0\n            elif count[j] == 3:\n                if a[j] & 1 << i == 0 and b[j] & 1 << i == 0:\n                    count[j] = 0\n                elif a[j] & 1 << i == 0:\n                    count[j] = 2\n                elif b[j] & 1 << i == 0:\n                    count[j] = 1\n            if count[j] == 0:\n                cnt += 1\n        if cnt == 0:\n            flag = True\n        elif flag:\n            count = temp[:]\n    ans = []\n    cnt = 0\n    for i in range(n):\n        if count[i] == 1:\n            ans.append(a[i])\n        elif count[i] == 2:\n            ans.append(b[i])\n            cnt += 1\n        elif count[i] == 3:\n            ans.append(a[i])\n    if len(ans) < n:\n        print(0, 0)\n    else:\n        nd = ans[0]\n        for i in ans:\n            nd = nd & i\n        print(nd, cnt)", "mod = 1000000007\nfrom sys import stdin, stdout\nfrom collections import defaultdict, Counter, deque\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    abcd = []\n    flips = 0\n    for i in range(32, -1, -1):\n        shan = 1 << i\n        count1 = 0\n        count2 = 0\n        mps = []\n        for j in range(n):\n            if shan & a[j]:\n                count1 += 1\n            elif shan & b[j]:\n                count2 += 1\n                mps.append(j)\n            else:\n                break\n        if count1 == n:\n            abcd.append(shan)\n        elif count2 + count1 == n:\n            pos = 1\n            for e in mps:\n                v = 0\n                if len(abcd) > 0:\n                    for q in abcd:\n                        if q & b[e]:\n                            v += 1\n                    if v != len(abcd):\n                        pos = 0\n                        break\n            if pos:\n                abcd.append(shan)\n                for e in mps:\n                    flips += 1\n                    (a[e], b[e]) = (b[e], a[e])\n    answer = a[0]\n    for i in range(1, n):\n        answer &= a[i]\n    print(answer, flips)", "mod = 1000000007\nfrom sys import stdin, stdout\nfrom collections import defaultdict, Counter, deque\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    abcd = []\n    flips = 0\n    for i in range(32, -1, -1):\n        shan = 1 << i\n        count1 = 0\n        count2 = 0\n        mps = []\n        for j in range(n):\n            if shan & a[j]:\n                count1 += 1\n            elif shan & b[j]:\n                count2 += 1\n                mps.append(j)\n            else:\n                break\n        if count1 == n:\n            abcd.append(shan)\n        elif count2 + count1 == n:\n            pos = 1\n            for e in mps:\n                v = 0\n                if len(abcd) > 0:\n                    for q in abcd:\n                        if q & b[e]:\n                            v += 1\n                    if v != len(abcd):\n                        pos = 0\n                        break\n            if pos:\n                abcd.append(shan)\n                for e in mps:\n                    flips += 1\n                    (a[e], b[e]) = (b[e], a[e])\n    answer = a[0]\n    for i in range(1, n):\n        answer &= a[i]\n    print(answer, flips)", "mod = 1000000007\nfrom sys import stdin, stdout\n\ndef srt(n, l, r):\n    m = (l + r) // 2\n    if l > r:\n        return m\n    if m * m > n:\n        r = m - 1\n        return srt(n, l, r)\n    elif m * m < n:\n        l = m + 1\n        return srt(n, l, r)\n    else:\n        return m\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    siri = []\n    flips = 0\n    for i in range(32, -1, -1):\n        shan = 1 << i\n        count1 = 0\n        count2 = 0\n        mps = []\n        for j in range(n):\n            if shan & a[j]:\n                count1 += 1\n            elif shan & b[j]:\n                count2 += 1\n                mps.append(j)\n            else:\n                break\n        if count1 == n:\n            siri.append(shan)\n        elif count2 + count1 == n:\n            pos = 1\n            for e in mps:\n                v = 0\n                if len(siri) > 0:\n                    for q in siri:\n                        if q & b[e]:\n                            v += 1\n                    if v != len(siri):\n                        pos = 0\n                        break\n            if pos:\n                siri.append(shan)\n                for e in mps:\n                    flips += 1\n                    (a[e], b[e]) = (b[e], a[e])\n    sreeshanth = a[0]\n    for i in range(1, n):\n        sreeshanth &= a[i]\n    print(sreeshanth, flips)", "def main():\n    n = int(input())\n    a1 = list(map(int, input().split()))\n    b1 = list(map(int, input().split()))\n    m = len(bin(max(max(a1), max(b1)))[2:])\n    arr = [3] * n\n    ans = 0\n    for j in range(m - 1, -1, -1):\n        b2 = pow(2, j)\n        f = True\n        for i in range(n):\n            if arr[i] == 3 and b2 & (a1[i] | b1[i]) == 0:\n                f = False\n                break\n            if arr[i] == 1 and b2 & a1[i] == 0:\n                f = False\n                break\n            if arr[i] == 0 and b2 & b1[i] == 0:\n                f = False\n                break\n        if f == True:\n            ans += b2\n            for i in range(n):\n                first = a1[i] & b2\n                second = b1[i] & b2\n                if arr[i] == 3 and first and second:\n                    continue\n                if arr[i] == 3 and first:\n                    arr[i] = 1\n                if arr[i] == 3 and second:\n                    arr[i] = 0\n    count = 0\n    for i in range(n):\n        if arr[i] == 0:\n            count += 1\n    print(ans, count)\nt = 1\nt = int(input())\nfor i in range(t):\n    main()", "import sys\nfrom heapq import heapify, heappush, heappop\n\ndef get(flips, undecided, idx, a_str, b_str, n):\n    for i in range(n):\n        if i in undecided:\n            if a_str[i][idx] != '1' and b_str[i][idx] != '1':\n                return '0'\n        elif i in flips:\n            if b_str[i][idx] != '1':\n                return '0'\n        elif a_str[i][idx] != '1':\n            return '0'\n    return '1'\nfor _ in range(int(sys.stdin.readline().strip())):\n    n = int(sys.stdin.readline().strip())\n    a = [int(x) for x in sys.stdin.readline().strip().split(' ')]\n    b = [int(x) for x in sys.stdin.readline().strip().split(' ')]\n    a_str = []\n    b_str = []\n    ans = int('1' * 32, 2)\n    max_len = 0\n    undecided = set()\n    flips = set()\n    for i in range(n):\n        a_str.append(bin(a[i])[2:])\n        b_str.append(bin(b[i])[2:])\n        undecided.add(i)\n        max_len = max(max_len, len(a_str[i]), len(b_str[i]))\n    for i in range(n):\n        a_str[i] = '0' * (max_len - len(a_str[i])) + a_str[i]\n        b_str[i] = '0' * (max_len - len(b_str[i])) + b_str[i]\n    for idx in range(max_len):\n        if get(flips, undecided, idx, a_str, b_str, n) == '1':\n            for i in range(n):\n                if i in undecided:\n                    if a_str[i][idx] == '1' and b_str[i][idx] == '0':\n                        undecided.remove(i)\n                    elif a_str[i][idx] == '0' and b_str[i][idx] == '1':\n                        flips.add(i)\n                        undecided.remove(i)\n    for i in range(n):\n        if i in flips:\n            ans &= b[i]\n        else:\n            ans &= a[i]\n    sys.stdout.write(str(ans) + ' ' + str(len(flips)) + '\\n')", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef check(arr, lex, size):\n    j = 0\n    ans = 0\n    k = 0\n    rem = 0\n    while j < len(arr):\n        if k == 0:\n            rem = j\n        if k < size:\n            ans = gcd(ans, arr[j])\n            if ans < lex:\n                j = rem + 1\n                ans = 0\n                k = 0\n                continue\n            j += 1\n            k += 1\n        if k == size:\n            return True\n    else:\n        if k == size and ans >= lex:\n            return True\n        return False\n\ndef bsearch(a):\n    k = 2\n    left = 1\n    right = len(a)\n    ans = 0\n    while left <= right:\n        mid = left + (right - left) // 2\n        if check(a, k, mid):\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return ans\nmod = 10 ** 9 + 7\nfor ii in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = max(max(a), max(b))\n    x = bin(c)[2:]\n    m = len(x)\n    arr = [2] * n\n    ans = [0] * m\n    count = 0\n    for j in range(m - 1, -1, -1):\n        bit = pow(2, j)\n        flag = True\n        for i in range(n):\n            if arr[i] == 2 and bit & (a[i] | b[i]) == 0:\n                flag = False\n                break\n            if arr[i] == 1 and bit & a[i] == 0:\n                flag = False\n                break\n            if arr[i] == 0 and bit & b[i] == 0:\n                flag = False\n                break\n        if flag:\n            count += bit\n            for i in range(n):\n                x = a[i] & bit\n                y = b[i] & bit\n                if arr[i] == 2 and x and y:\n                    continue\n                if arr[i] == 2 and x:\n                    arr[i] = 1\n                if arr[i] == 2 and y:\n                    arr[i] = 0\n    c = 0\n    for i in range(n):\n        if arr[i] == 0:\n            c += 1\n    print(count, c)", "import sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef st():\n    return input().rstrip('\\n')\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\nt = inp()\nwhile t:\n    t -= 1\n    n = inp()\n    a = lis()\n    b = lis()\n    bits = [0] * 30\n    flip = [0] * n\n    fl = [[] for i in range(30)]\n    for i in range(29, -1, -1):\n        can = []\n        can1 = []\n        flag = 0\n        for j in range(n):\n            if a[j] & 1 << i:\n                if b[j] & 1 << i == 0:\n                    can1.append(j)\n                continue\n            if b[j] & 1 << i and flip[j] == 0:\n                can.append(j)\n            else:\n                bits[i] = 1\n                flag = 1\n                break\n        if flag == 0:\n            for j in can1:\n                flip[j] = 1\n            for j in can:\n                flip[j] = 1\n                (a[j], b[j]) = (b[j], a[j])\n                fl[i].append(j)\n    s = 0\n    vis = set()\n    for i in range(30):\n        if bits[i]:\n            continue\n        s += 2 ** i\n        for j in fl[i]:\n            vis.add(j)\n    print(s, len(vis))", "from collections import defaultdict\n\ndef bs(num):\n    s = ['0' for i in range(35)]\n    b = bin(num)[2:]\n    l = len(b)\n    c = 0\n    for j in b[::-1]:\n        s[c] = j\n        c += 1\n    return s\nfor i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    a = [bs(j) for j in a]\n    b = [bs(j) for j in b]\n    maxv = 0\n    resp = ''\n    pos = [-1 for j in range(n)]\n    for bit in range(34, -1, -1):\n        poss = True\n        for j in range(n):\n            if pos[j] == -1:\n                if a[j][bit] == '0' and b[j][bit] == '0':\n                    poss = False\n                    break\n            elif pos[j] == 0:\n                if a[j][bit] == '0':\n                    poss = False\n                    break\n            elif pos[j] == 1:\n                if b[j][bit] == '0':\n                    poss = False\n                    break\n        if poss:\n            for j in range(n):\n                if pos[j] == -1:\n                    if a[j][bit] == '0':\n                        pos[j] = 1\n                    elif b[j][bit] == '0':\n                        pos[j] = 0\n            maxv += 2 ** bit\n            resp += '1'\n        else:\n            resp += '0'\n    ans = 0\n    for j in range(n):\n        if pos[j] == 1:\n            ans += 1\n    print(maxv, ans)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    arr1 = [bin(int(i))[2:] for i in input().split()]\n    arr1 = ['0' * (31 - len(i)) + i for i in arr1]\n    arr2 = [bin(int(i))[2:] for i in input().split()]\n    arr2 = ['0' * (31 - len(i)) + i for i in arr2]\n    count = [-1] * n\n    answer = [0] * 31\n    for i in range(31):\n        flip = [-1] * n\n        ans = True\n        for j in range(n):\n            if count[j] == -1:\n                if arr1[j][i] == '1' and arr2[j][i] == '1':\n                    pass\n                elif arr1[j][i] == '1' and arr2[j][i] != '1':\n                    flip[j] = 0\n                elif arr2[j][i] == '1':\n                    flip[j] = 1\n                else:\n                    ans = False\n                    break\n            elif count[j] == 0:\n                if arr1[j][i] == '1':\n                    pass\n                else:\n                    ans = False\n                    break\n            elif count[j] == 1:\n                if arr2[j][i] == '1':\n                    pass\n                else:\n                    ans = False\n                    break\n        if ans:\n            for j in range(n):\n                if flip[j] != -1:\n                    count[j] = flip[j]\n            answer[i] = 1\n    pow = 30\n    tot = 0\n    for i in range(31):\n        if answer[i] == 1:\n            tot += 2 ** pow\n        pow -= 1\n    flips = 0\n    for i in count:\n        if i == 1:\n            flips += 1\n    print(tot, flips)", "import math\nfrom collections import deque, defaultdict\nfrom math import sqrt, ceil, factorial, floor, inf, gcd\nimport bisect\nimport sys\nimport random\nimport heapq\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef input():\n    return sys.stdin.readline().strip()\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        a = get_array()\n        b = get_array()\n        bit_ind = 29\n        arr = [[0, 1] for i in range(n)]\n        max_ans = 0\n        for i in range(bit_ind, -1, -1):\n            possible_1 = True\n            temp_arr = []\n            for j in range(n):\n                if arr[j][0] == 0:\n                    if len(arr[j]) == 2:\n                        a_val = a[j] >> i & 1\n                        b_val = b[j] >> i & 1\n                        if a_val == b_val == 1:\n                            temp_arr.append([0, 1])\n                        elif a_val == b_val == 0:\n                            temp_arr.append([0, 1])\n                            possible_1 = False\n                            break\n                        elif a_val == 1:\n                            temp_arr.append([0])\n                        else:\n                            temp_arr.append([1])\n                    else:\n                        val = a[j] >> i & 1\n                        if val == 0:\n                            possible_1 = False\n                            break\n                        else:\n                            temp_arr.append([0])\n                else:\n                    val = b[j] >> i & 1\n                    if val == 0:\n                        possible_1 = False\n                        break\n                    else:\n                        temp_arr.append([1])\n            if possible_1:\n                max_ans |= 1 << i\n                arr = temp_arr.copy()\n        k = 0\n        for i in arr:\n            if i[0] == 1:\n                k += 1\n        print(max_ans, k)\nmain()"]