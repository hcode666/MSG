["inf = 10 ** 18\nmod = 10 ** 9 + 7\n\ndef read_line_int():\n    return [int(x) for x in input().split()]\n\ndef getDfsOrder(adj, src):\n    st = [src]\n    ret = []\n    n = len(adj) - 1\n    visited = [False] * (n + 1)\n    visited[src] = True\n    while len(st) > 0:\n        u = st.pop()\n        ret.append(u)\n        for v in adj[u]:\n            if not visited[v]:\n                st.append(v)\n                visited[v] = True\n    return ret\nT = read_line_int()[0]\nfor test in range(T):\n    n = read_line_int()[0]\n    a = read_line_int()\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = read_line_int()\n        adj[u].append(v)\n        adj[v].append(u)\n    if n == 1:\n        print(0)\n        continue\n    if n == 2:\n        print(sum(a) % mod)\n        continue\n    mx_deg = -1\n    root = -1\n    for i in range(1, n + 1):\n        if mx_deg < len(adj[i]):\n            mx_deg = len(adj[i])\n            root = i\n    dfs_order = getDfsOrder(adj, root)\n    sz = [0] * (n + 1)\n    par = [-1] * (n + 1)\n    cnt_leafs = 0\n    for u in dfs_order[::-1]:\n        for v in adj[u]:\n            sz[u] += sz[v]\n            if sz[v] == 0:\n                par[u] = v\n        if len(adj[u]) == 1:\n            sz[u] += 1\n            cnt_leafs += 1\n    coef = [0] * (n + 1)\n    for u in range(1, n + 1):\n        s = 0\n        for v in adj[u]:\n            if v == par[u]:\n                continue\n            coef[u] += s * sz[v]\n            s += sz[v]\n        coef[u] += sz[u] * (cnt_leafs - sz[u])\n    coef = coef[1:]\n    coef = sorted(coef)\n    a = sorted(a)\n    ret = sum([x * y % mod for (x, y) in zip(coef, a)]) % mod\n    print(ret)", "inf = 10 ** 18\nmod = 10 ** 9 + 7\n\ndef read_line_int():\n    return [int(x) for x in input().split()]\n\ndef getDfsOrder(adj, src):\n    st = [src]\n    ret = []\n    n = len(adj) - 1\n    visited = [False] * (n + 1)\n    visited[src] = True\n    while len(st) > 0:\n        u = st.pop()\n        ret.append(u)\n        for v in adj[u]:\n            if not visited[v]:\n                st.append(v)\n                visited[v] = True\n    return ret\nT = read_line_int()[0]\nfor test in range(T):\n    n = read_line_int()[0]\n    a = read_line_int()\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = read_line_int()\n        adj[u].append(v)\n        adj[v].append(u)\n    if n == 1:\n        print(0)\n        continue\n    if n == 2:\n        print(sum(a) % mod)\n        continue\n    mx_deg = -1\n    root = -1\n    for i in range(1, n + 1):\n        if mx_deg < len(adj[i]):\n            mx_deg = len(adj[i])\n            root = i\n    dfs_order = getDfsOrder(adj, root)\n    sz = [0] * (n + 1)\n    par = [-1] * (n + 1)\n    cnt_leafs = 0\n    for u in dfs_order[::-1]:\n        for v in adj[u]:\n            sz[u] += sz[v]\n            if sz[v] == 0:\n                par[u] = v\n        if len(adj[u]) == 1:\n            sz[u] += 1\n            cnt_leafs += 1\n    coef = [0] * (n + 1)\n    for u in range(1, n + 1):\n        s = 0\n        for v in adj[u]:\n            if v == par[u]:\n                continue\n            coef[u] += s * sz[v]\n            s += sz[v]\n        coef[u] += sz[u] * (cnt_leafs - sz[u])\n    coef = coef[1:]\n    coef = sorted(coef)\n    a = sorted(a)\n    ret = sum([x * y % mod for (x, y) in zip(coef, a)]) % mod\n    print(ret)", "T = int(input())\nM = 10 ** 9 + 7\nfor _ in range(T):\n    N = int(input())\n    A = list(map(int, input().split()))\n    if N == 1:\n        print(0)\n        continue\n    B = {}\n    C = {}\n    for i in range(N - 1):\n        (u, v) = input().split()\n        u = int(u) - 1\n        v = int(v) - 1\n        if u not in B:\n            B[u] = []\n        if v not in B:\n            B[v] = []\n        B[u].append(v)\n        B[v].append(u)\n    total_leaves = 0\n    for i in B:\n        if len(B[i]) == 1:\n            total_leaves += 1\n    S = [0]\n    visited = [False] * N\n    parent = [-1] * N\n    total_visits = [0] * N\n    while len(S) > 0:\n        current = S.pop(len(S) - 1)\n        if visited[current]:\n            p = parent[current]\n            if p != -1:\n                total_visits[p] += total_visits[current]\n                if p not in C:\n                    C[p] = {}\n                C[p][current] = total_visits[current]\n                if current not in C:\n                    C[current] = {}\n                C[current][p] = total_leaves - C[p][current]\n        else:\n            S.append(current)\n            visited[current] = True\n            for (i, j) in enumerate(B[current]):\n                if not visited[j]:\n                    parent[j] = current\n                    S.append(j)\n            if len(B[current]) == 1:\n                total_visits[current] = 1\n                p = parent[current]\n                if p != -1:\n                    if p not in C:\n                        C[p] = {}\n                    C[p][current] = 1\n    D = {}\n    for i in C:\n        sum1 = 0\n        for j in C[i]:\n            sum1 += C[i][j]\n        D[i] = sum1\n    E = [0] * N\n    for i in C:\n        sum1 = 0\n        for j in C[i]:\n            D[i] -= C[i][j]\n            sum1 += C[i][j] * D[i]\n        E[i] = sum1\n    for (i, j) in enumerate(E):\n        if j == 0:\n            for k in C[i]:\n                E[i] = C[i][k]\n    E.sort()\n    E.reverse()\n    A.sort()\n    A.reverse()\n    E = [x % M for x in E]\n    A = [x % M for x in A]\n    ans = 0\n    for (i, j) in zip(E, A):\n        a = i * j\n        a %= M\n        ans += a\n        ans %= M\n    print(ans)", "import sys\nsys.setrecursionlimit(10000000)\n\ndef call(node, leaf, al, p):\n    ans = 0\n    for i in al[node]:\n        if i == p:\n            continue\n        ans += max(1, call(i, leaf, al, node))\n    leaf[node] = max(1, ans)\n    return max(1, ans)\n\ndef get(node, sum, al, p, leaf, total_l):\n    ans = leaf[node] * leaf[node]\n    for i in al[node]:\n        if i == p:\n            continue\n        get(i, sum, al, node, leaf, total_l)\n        ans -= leaf[i] * leaf[i]\n    ans = ans // 2\n    ans += leaf[node] * (total_l - leaf[node])\n    sum[node] = ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = map(int, input().split())\n    arr = sorted(arr)\n    al = [0] * n\n    for i in range(n):\n        al[i] = list()\n    for i in range(n - 1):\n        (a, b) = input().split()\n        (a, b) = (int(a) - 1, int(b) - 1)\n        al[a].append(b)\n        al[b].append(a)\n    leaf = [0] * n\n    total_l = 0\n    for i in al:\n        if len(i) <= 1:\n            total_l += 1\n    call(0, leaf, al, -1)\n    sum = [0] * n\n    get(0, sum, al, -1, leaf, total_l)\n    sum = sorted(sum)\n    (answer, mod) = (0, int(1000000000.0 + 7))\n    for i in range(n):\n        answer = (answer + sum[i] * arr[i]) % mod\n    print(answer)"]