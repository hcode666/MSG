["import math\n\ndef next_int(n):\n    if int(n) == n:\n        return int(n + 1)\n    return int(math.ceil(n))\n\ndef prev_int(n):\n    if int(n) == n:\n        return int(n - 1)\n    return int(math.floor(n))\n\ndef get_ranges(h1, s1, h2, s2):\n    infinity = float('inf')\n    if h1 == h2 and s1 == s2:\n        return tuple()\n    if h1 == h2:\n        return (('<' if s1 < s2 else '>', 1, infinity),)\n    initial_relation = '<' if h1 < h2 else '>'\n    if s1 == s2:\n        return ((initial_relation, 0, infinity),)\n    intersect = (h2 - h1) / (s1 - s2)\n    if intersect < 0:\n        return ((initial_relation, 0, infinity),)\n    reversed_relation = '>' if initial_relation == '<' else '<'\n    return ((initial_relation, 0, prev_int(intersect)), (reversed_relation, next_int(intersect), infinity))\n\ndef intersect_ranges(range1, range2):\n    if range1[0] > range2[1] or range2[0] > range1[1]:\n        return None\n    return (max(range1[0], range2[0]), min(range1[1], range2[1]))\n\ndef merge_adjacent_ranges(ranges):\n    if len(ranges) == 0:\n        return []\n    temp = [list(ranges[0])]\n    for i in range(1, len(ranges)):\n        if temp[-1][1] + 1 == ranges[i][0]:\n            temp[-1][1] = ranges[i][1]\n        else:\n            temp.append(ranges[i])\n    return temp\n\ndef get_zig_zag_ranges(ranges1, ranges2):\n    if len(ranges1) == 0 or len(ranges2) == 0:\n        return tuple()\n    result = []\n    for r1 in ranges1:\n        for r2 in ranges2:\n            if r1[0] != r2[0]:\n                intersection = intersect_ranges((r1[1], r1[2]), (r2[1], r2[2]))\n                if intersection:\n                    result.append(intersection)\n    return tuple(result)\n\ndef read_and_run_test():\n    tree_count = int(input())\n    trees = list()\n    for i in range(tree_count):\n        trees.append([int(v) for v in input().split()])\n    if tree_count == 1:\n        print('1\\n0 Inf')\n        return\n    infinity = float('inf')\n    prev_ranges = get_ranges(trees[0][0], trees[0][1], trees[1][0], trees[1][1])\n    results = [(s, e) for (r, s, e) in prev_ranges]\n    for i in range(2, tree_count):\n        curr_ranges = get_ranges(trees[i - 1][0], trees[i - 1][1], trees[i][0], trees[i][1])\n        new_results = []\n        for new_range in get_zig_zag_ranges(prev_ranges, curr_ranges):\n            for existing_range in results:\n                intersection = intersect_ranges(new_range, existing_range)\n                if intersection:\n                    new_results.append(intersection)\n        results = new_results\n        prev_ranges = curr_ranges\n    results = merge_adjacent_ranges(results)\n    print(len(results))\n    for r in results:\n        if r[1] == infinity:\n            print(int(r[0]), 'Inf')\n        else:\n            print(int(r[0]), int(r[1]))\n\ndef main():\n    test_cases_count = int(input())\n    for i in range(test_cases_count):\n        read_and_run_test()\nmain()", "import math\n\ndef next_int(n):\n    if int(n) == n:\n        return int(n + 1)\n    return int(math.ceil(n))\n\ndef prev_int(n):\n    if int(n) == n:\n        return int(n - 1)\n    return int(math.floor(n))\n\ndef get_ranges(h1, s1, h2, s2):\n    infinity = float('inf')\n    if h1 == h2 and s1 == s2:\n        return tuple()\n    if h1 == h2:\n        return (('<' if s1 < s2 else '>', 1, infinity),)\n    initial_relation = '<' if h1 < h2 else '>'\n    if s1 == s2:\n        return ((initial_relation, 0, infinity),)\n    intersect = (h2 - h1) / (s1 - s2)\n    if intersect < 0:\n        return ((initial_relation, 0, infinity),)\n    reversed_relation = '>' if initial_relation == '<' else '<'\n    return ((initial_relation, 0, prev_int(intersect)), (reversed_relation, next_int(intersect), infinity))\n\ndef intersect_ranges(range1, range2):\n    if range1[0] > range2[1] or range2[0] > range1[1]:\n        return None\n    return (max(range1[0], range2[0]), min(range1[1], range2[1]))\n\ndef merge_adjacent_ranges(ranges):\n    if len(ranges) == 0:\n        return []\n    temp = [list(ranges[0])]\n    for i in range(1, len(ranges)):\n        if temp[-1][1] + 1 == ranges[i][0]:\n            temp[-1][1] = ranges[i][1]\n        else:\n            temp.append(ranges[i])\n    return temp\n\ndef get_zig_zag_ranges(ranges1, ranges2):\n    if len(ranges1) == 0 or len(ranges2) == 0:\n        return tuple()\n    result = []\n    for r1 in ranges1:\n        for r2 in ranges2:\n            if r1[0] != r2[0]:\n                intersection = intersect_ranges((r1[1], r1[2]), (r2[1], r2[2]))\n                if intersection:\n                    result.append(intersection)\n    return tuple(result)\n\ndef read_and_run_test():\n    tree_count = int(input())\n    trees = list()\n    for i in range(tree_count):\n        trees.append([int(v) for v in input().split()])\n    if tree_count == 1:\n        print('1\\n0 Inf')\n        return\n    infinity = float('inf')\n    prev_ranges = get_ranges(trees[0][0], trees[0][1], trees[1][0], trees[1][1])\n    results = [(s, e) for (r, s, e) in prev_ranges]\n    for i in range(2, tree_count):\n        curr_ranges = get_ranges(trees[i - 1][0], trees[i - 1][1], trees[i][0], trees[i][1])\n        new_results = []\n        for new_range in get_zig_zag_ranges(prev_ranges, curr_ranges):\n            for existing_range in results:\n                intersection = intersect_ranges(new_range, existing_range)\n                if intersection:\n                    new_results.append(intersection)\n        results = new_results\n        prev_ranges = curr_ranges\n    results = merge_adjacent_ranges(results)\n    print(len(results))\n    for r in results:\n        if r[1] == infinity:\n            print(int(r[0]), 'Inf')\n        else:\n            print(int(r[0]), int(r[1]))\n\ndef main():\n    test_cases_count = int(input())\n    for i in range(test_cases_count):\n        read_and_run_test()\nmain()", "import math\n\ndef next_int(n):\n    if int(n) == n:\n        return int(n + 1)\n    return int(math.ceil(n))\n\ndef prev_int(n):\n    if int(n) == n:\n        return int(n - 1)\n    return int(math.floor(n))\n\ndef get_ranges(h1, s1, h2, s2):\n    infinity = float('inf')\n    if h1 == h2 and s1 == s2:\n        return tuple()\n    if h1 == h2:\n        return (('<' if s1 < s2 else '>', 1, infinity),)\n    initial_relation = '<' if h1 < h2 else '>'\n    if s1 == s2:\n        return ((initial_relation, 0, infinity),)\n    intersect = (h2 - h1) / (s1 - s2)\n    if intersect < 0:\n        return ((initial_relation, 0, infinity),)\n    reversed_relation = '>' if initial_relation == '<' else '<'\n    return ((initial_relation, 0, prev_int(intersect)), (reversed_relation, next_int(intersect), infinity))\n\ndef intersect_ranges(range1, range2):\n    if range1[0] > range2[1] or range2[0] > range1[1]:\n        return None\n    return (max(range1[0], range2[0]), min(range1[1], range2[1]))\n\ndef merge_adjacent_ranges(ranges):\n    if len(ranges) == 0:\n        return []\n    temp = [list(ranges[0])]\n    for i in range(1, len(ranges)):\n        if temp[-1][1] + 1 == ranges[i][0]:\n            temp[-1][1] = ranges[i][1]\n        else:\n            temp.append(ranges[i])\n    return temp\n\ndef get_zig_zag_ranges(ranges1, ranges2):\n    if len(ranges1) == 0 or len(ranges2) == 0:\n        return tuple()\n    result = []\n    for r1 in ranges1:\n        for r2 in ranges2:\n            if r1[0] != r2[0]:\n                intersection = intersect_ranges((r1[1], r1[2]), (r2[1], r2[2]))\n                if intersection:\n                    result.append(intersection)\n    return tuple(result)\n\ndef read_and_run_test():\n    tree_count = int(input())\n    trees = list()\n    for i in range(tree_count):\n        trees.append([int(v) for v in input().split()])\n    if tree_count == 1:\n        print('1\\n0 Inf')\n        return\n    infinity = float('inf')\n    prev_ranges = get_ranges(trees[0][0], trees[0][1], trees[1][0], trees[1][1])\n    results = [(s, e) for (r, s, e) in prev_ranges]\n    for i in range(2, tree_count):\n        curr_ranges = get_ranges(trees[i - 1][0], trees[i - 1][1], trees[i][0], trees[i][1])\n        new_results = []\n        for new_range in get_zig_zag_ranges(prev_ranges, curr_ranges):\n            for existing_range in results:\n                intersection = intersect_ranges(new_range, existing_range)\n                if intersection:\n                    new_results.append(intersection)\n        results = new_results\n        prev_ranges = curr_ranges\n    results = merge_adjacent_ranges(results)\n    print(len(results))\n    for r in results:\n        if r[1] == infinity:\n            print(int(r[0]), 'Inf')\n        else:\n            print(int(r[0]), int(r[1]))\n\ndef main():\n    test_cases_count = int(input())\n    for i in range(test_cases_count):\n        read_and_run_test()\nmain()", "def intersect(iv1, iv2):\n    (b1, e1) = iv1\n    (b2, e2) = iv2\n    if b1 < 0 or b2 < 0:\n        return (-1, 0)\n    b = max(b1, b2)\n    if e1 < 0 or e2 < 0:\n        e = max(e1, e2)\n    else:\n        e = min(e1, e2)\n    if e < 0 or b <= e:\n        return (b, e)\n    else:\n        return (-1, 0)\n\ndef plus(h, m, hi, mi):\n    if m == mi:\n        if h < hi:\n            return (0, -1)\n        else:\n            return (-1, 0)\n    tz = (hi - h) // (m - mi)\n    tu = tz + 1\n    if (m - mi) * tz == hi - h:\n        td = tz - 1\n    else:\n        td = tz\n    if td < 0:\n        d = (-1, 0)\n    else:\n        d = (0, td)\n    if tu < 0:\n        u = (0, -1)\n    else:\n        u = (tu, -1)\n    if m < mi:\n        return u\n    else:\n        return d\n\ndef minus(h, m, hi, mi):\n    if m == mi:\n        if h > hi:\n            return (0, -1)\n        else:\n            return (-1, 0)\n    tz = (hi - h) // (m - mi)\n    tu = tz + 1\n    if (m - mi) * tz == hi - h:\n        td = tz - 1\n    else:\n        td = tz\n    if td < 0:\n        d = (-1, 0)\n    else:\n        d = (0, td)\n    if tu < 0:\n        u = (0, -1)\n    else:\n        u = (tu, -1)\n    if m > mi:\n        return u\n    else:\n        return d\n\ndef prt(iv):\n    (b, e) = iv\n    if b >= 0:\n        print(b, end=' ')\n        if e >= 0:\n            print(e)\n        else:\n            print('Inf')\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    pp = (0, -1)\n    mm = (0, -1)\n    for i in range(N):\n        (hi, mi) = map(int, input().split())\n        if i:\n            pp = intersect(pp, plus(h, m, hi, mi))\n            mm = intersect(mm, minus(h, m, hi, mi))\n            (pp, mm) = (mm, pp)\n        (h, m) = (hi, mi)\n    if pp > mm:\n        (pp, mm) = (mm, pp)\n    if pp == mm:\n        mm = (-1, 0)\n    if pp[0] >= 0 and pp[1] + 1 == mm[0]:\n        pp = (pp[0], mm[1])\n        mm = (-1, 0)\n    if N < 0:\n        pp = (-1, 0)\n        mm = (-1, 0)\n    print((pp[0] >= 0) + (mm[0] >= 0))\n    prt(pp)\n    prt(mm)", "import math\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    h = [0] * n\n    m = [0] * n\n    for i in range(n):\n        (h[i], m[i]) = map(int, input().split())\n    l1 = [0] * (n - 1)\n    r1 = [10 ** 10] * (n - 1)\n    l2 = [0] * (n - 1)\n    r2 = [10 ** 10] * (n - 1)\n    l1max = 0\n    l2max = 0\n    r1min = 10 ** 10\n    r2min = 10 ** 10\n    flag1 = 0\n    flag2 = 0\n    for i in range(n - 1):\n        mdif = m[i + 1] - m[i]\n        hdif = h[i] - h[i + 1]\n        if i % 2 == 0:\n            if mdif != 0:\n                x = hdif / mdif\n                if mdif > 0:\n                    if x < 0:\n                        x = 0\n                    else:\n                        x = int(x + 1)\n                    l1[i] = x\n                    if l1max < l1[i]:\n                        l1max = l1[i]\n                else:\n                    if x <= 0:\n                        r1[i] = -100\n                        r1min = -100\n                        break\n                    elif math.ceil(x) == math.floor(x):\n                        x = int(x - 1)\n                    else:\n                        x = int(x)\n                    r1[i] = x\n                    if r1min > r1[i]:\n                        r1min = r1[i]\n            if mdif == 0:\n                if h[i] >= h[i + 1]:\n                    l1[i] = 10 ** 10 + 10\n                    l1max = 10 ** 10 + 10\n                    break\n        else:\n            if mdif != 0:\n                x = hdif / mdif\n                if mdif > 0:\n                    if x <= 0:\n                        r1[i] = -100\n                        r1min = -100\n                        break\n                    elif math.ceil(x) == math.floor(x):\n                        x = int(x - 1)\n                    else:\n                        x = int(x)\n                    r1[i] = x\n                    if r1min > r1[i]:\n                        r1min = r1[i]\n                else:\n                    if x < 0:\n                        x = 0\n                    else:\n                        x = int(x + 1)\n                    l1[i] = x\n                    if l1max < l1[i]:\n                        l1max = l1[i]\n            if mdif == 0:\n                if h[i] <= h[i + 1]:\n                    l1[i] = 10 ** 10 + 10\n                    l1max = 10 ** 10 + 10\n                    break\n    for i in range(n - 1):\n        mdif = m[i + 1] - m[i]\n        hdif = h[i] - h[i + 1]\n        if i % 2 == 0:\n            if mdif != 0:\n                x = hdif / mdif\n                if mdif > 0:\n                    if x <= 0:\n                        r2[i] = -100\n                        r2min = -100\n                        break\n                    elif math.ceil(x) == math.floor(x):\n                        x = int(x - 1)\n                    else:\n                        x = int(x)\n                    r2[i] = x\n                    if r2min > r2[i]:\n                        r2min = r2[i]\n                else:\n                    if x < 0:\n                        x = 0\n                    else:\n                        x = int(x + 1)\n                    l2[i] = x\n                    if l2max < l2[i]:\n                        l2max = l2[i]\n            if mdif == 0:\n                if h[i] <= h[i + 1]:\n                    l2[i] = 10 ** 10 + 10\n                    l2max = 10 ** 10 + 10\n                    break\n        else:\n            if mdif != 0:\n                x = hdif / mdif\n                if mdif > 0:\n                    if x < 0:\n                        x = 0\n                    else:\n                        x = int(x + 1)\n                    l2[i] = x\n                    if l2max < l2[i]:\n                        l2max = l2[i]\n                else:\n                    if x <= 0:\n                        r2[i] = -100\n                        r2min = -100\n                        break\n                    elif math.ceil(x) == math.floor(x):\n                        x = int(x - 1)\n                    else:\n                        x = int(x)\n                    r2[i] = x\n                    if r2min > r2[i]:\n                        r2min = r2[i]\n            if mdif == 0:\n                if h[i] >= h[i + 1]:\n                    l2[i] = 10 ** 10 + 10\n                    l2max = 10 ** 10 + 10\n                    break\n    ans = 0\n    if l1max <= r1min:\n        flag1 = 1\n        ans = 1\n    if l2max <= r2min:\n        flag2 = 1\n        ans = 1\n    if flag1 == 1 and flag2 == 1:\n        if l1max - r2min > 1 or (l2max - r1min > 1 and l1max != l2max):\n            ans = 2\n        else:\n            ans = 1\n            l1max = min(l1max, l2max)\n            r1min = max(r1min, r2min)\n            flag2 = 0\n    print(ans)\n    if flag1 == 1 and ans == 1:\n        if r1min >= 10 ** 10:\n            r1min = 'Inf'\n        print(l1max, r1min)\n    if flag2 == 1 and ans == 1:\n        if r2min >= 10 ** 10:\n            r2min = 'Inf'\n        print(l2max, r2min)\n    if ans == 2:\n        if r2min >= 10 ** 10:\n            r2min = 'Inf'\n        if r1min >= 10 ** 10:\n            r1min = 'Inf'\n        if l1max < l2max:\n            print(l1max, r1min)\n            print(l2max, r2min)\n        elif l2max < l1max:\n            print(l2max, r2min)\n            print(l1max, r1min)", "def getInterval(x, y):\n    a = y[0] - x[0]\n    d = y[1] - x[1]\n    if a <= 0 and d <= 0:\n        return None\n    if a > 0 and d >= 0:\n        return (0, None)\n    t = int(-a / d) + 1\n    if abs(a) % abs(d) == 0:\n        t = abs(a) // abs(d)\n        if a <= 0:\n            t += 1\n    if a > 0:\n        return (0, t - 1)\n    return (t, None)\n\ndef inter(a, b):\n    if a is None or b is None:\n        return None\n    x = max(a[0], b[0])\n    y = a[1]\n    if a[1] is None:\n        y = b[1]\n    elif b[1] is None:\n        y = a[1]\n    else:\n        y = min(a[1], b[1])\n    if y is not None and y < x:\n        return None\n    return (x, y)\n\ndef pstr(a, b):\n    ret = str(a) + ' ' + ('Inf' if b is None else str(b))\n    return ret\n\ndef solve(x):\n    if len(x) == 1:\n        print(1)\n        print('0 Inf')\n        return\n    up = (0, None)\n    dn = (0, None)\n    for i in range(len(x) - 1):\n        if i % 2 == 0:\n            dn = inter(dn, getInterval(x[i], x[i + 1]))\n            up = inter(up, getInterval(x[i + 1], x[i]))\n        else:\n            up = inter(up, getInterval(x[i], x[i + 1]))\n            dn = inter(dn, getInterval(x[i + 1], x[i]))\n    ret = 0\n    if up is not None:\n        ret += 1\n    if dn is not None:\n        ret += 1\n    if up is not None and dn is not None:\n        if up[0] > dn[0]:\n            (up, dn) = (dn, up)\n        if up[1] == dn[0] - 1:\n            up = (up[0], dn[1])\n            dn = None\n            ret -= 1\n    print(ret)\n    if up is not None:\n        print(pstr(*up))\n    if dn is not None:\n        print(pstr(*dn))\nimport sys\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    n = int(f.readline())\n    x = []\n    for j in range(n):\n        (a, b) = map(int, f.readline().split())\n        x += [(a, b)]\n    solve(x)", "import math\n\ndef test(Inf):\n    (Min_1, Min_0) = (-1, -1)\n    (Max_1, Max_0) = (Inf, Inf)\n    N = int(input().strip())\n    (H_0, M_0) = map(int, input().strip().split(' '))\n    for i in range(1, N):\n        (H_1, M_1) = map(int, input().strip().split(' '))\n        (H, M) = (H_1 - H_0, M_0 - M_1)\n        (H_0, M_0) = (H_1, M_1)\n        if i & 1:\n            if M == 0:\n                if H == 0:\n                    Max_1 = -1\n                    Max_0 = -1\n                if H > 0:\n                    Max_1 = -1\n                if H < 0:\n                    Max_0 = -1\n            if M > 0:\n                Min_1 = max(Min_1, H / M)\n                Max_0 = min(Max_0, H / M)\n            if M < 0:\n                Min_0 = max(Min_0, H / M)\n                Max_1 = min(Max_1, H / M)\n        else:\n            if M == 0:\n                if H == 0:\n                    Max_1 = -1\n                    Max_0 = -1\n                if H > 0:\n                    Max_0 = -1\n                if H < 0:\n                    Max_1 = -1\n            if M > 0:\n                Min_0 = max(Min_0, H / M)\n                Max_1 = min(Max_1, H / M)\n            if M < 0:\n                Min_1 = max(Min_1, H / M)\n                Max_0 = min(Max_0, H / M)\n    if Max_0 < Inf:\n        Max_0 = math.ceil(Max_0) - 1\n    if Max_1 < Inf:\n        Max_1 = math.ceil(Max_1) - 1\n    Min_0 = math.floor(Min_0) + 1\n    Min_1 = math.floor(Min_1) + 1\n    if Min_0 <= Max_0 and Min_1 <= Max_1:\n        if max(Min_0, Min_1) <= min(Max_0, Max_1) + 1:\n            print(1)\n            print(str(min(Min_0, Min_1)) + ' ' + str(max(Max_0, Max_1)).capitalize())\n        else:\n            print(2)\n            print(str(min(Min_0, Min_1)) + ' ' + str(min(Max_0, Max_1)))\n            print(str(max(Min_0, Min_1)) + ' ' + str(max(Max_0, Max_1)).capitalize())\n    elif Min_0 <= Max_0:\n        print(1)\n        print(str(Min_0) + ' ' + str(Max_0).capitalize())\n    elif Min_1 <= Max_1:\n        print(1)\n        print(str(Min_1) + ' ' + str(Max_1).capitalize())\n    else:\n        print(0)\n    return\nT = int(input().strip())\nInf = float('inf')\nfor i in range(T):\n    test(Inf)", "from math import floor, ceil\ninf = 10 ** 20\nfor t in range(int(input())):\n    h = []\n    m = []\n    n = int(input())\n    for i in range(n):\n        (hi, mi) = [int(i) for i in input().split()]\n        h.append(hi)\n        m.append(mi)\n    if n == 1:\n        print(1)\n        print(0, 'Inf')\n        continue\n    lowhigh = []\n    highlow = []\n    for i in range(1, n):\n        if h[i] > h[i - 1] and m[i] >= m[i - 1]:\n            lowhigh.append((0, inf))\n        elif h[i] > h[i - 1] and m[i] < m[i - 1]:\n            top = ceil((h[i] - h[i - 1]) / (m[i - 1] - m[i])) - 1\n            lowhigh.append((0, top))\n        elif m[i] > m[i - 1]:\n            low = floor((h[i] - h[i - 1]) / (m[i - 1] - m[i])) + 1\n            lowhigh.append((low, inf))\n        else:\n            lowhigh.append((0, -1))\n        if h[i] < h[i - 1] and m[i] <= m[i - 1]:\n            highlow.append((0, inf))\n        elif h[i] < h[i - 1] and m[i] > m[i - 1]:\n            top = ceil((h[i - 1] - h[i]) / (m[i] - m[i - 1])) - 1\n            highlow.append((0, top))\n        elif m[i] < m[i - 1]:\n            low = floor((h[i - 1] - h[i]) / (m[i] - m[i - 1])) + 1\n            highlow.append((low, inf))\n        else:\n            highlow.append((0, -1))\n    for i in range(1, n - 1, 2):\n        (lowhigh[i], highlow[i]) = (highlow[i], lowhigh[i])\n    mn1 = max(lowhigh, key=lambda i: i[0])[0]\n    mx1 = min(lowhigh, key=lambda i: i[1])[1]\n    lowhigh = True if mn1 <= mx1 else False\n    mx1 = 'Inf' if mx1 == inf else mx1\n    mn2 = max(highlow, key=lambda i: i[0])[0]\n    mx2 = min(highlow, key=lambda i: i[1])[1]\n    highlow = True if mn2 <= mx2 else False\n    mx2 = 'Inf' if mx2 == inf else mx2\n    if not (lowhigh or highlow):\n        print(0)\n    elif lowhigh and highlow:\n        if type(mx2) == int and mn1 == mx2 + 1 or (type(mx1) == int and mn2 == mx1 + 1):\n            print(1)\n            print(0, 'Inf')\n        else:\n            print(2)\n            if mn1 < mn2:\n                print(mn1, mx1)\n                print(mn2, mx2)\n            else:\n                print(mn2, mx2)\n                print(mn1, mx1)\n    elif lowhigh:\n        print(1)\n        print(mn1, mx1)\n    else:\n        print(1)\n        print(mn2, mx2)"]