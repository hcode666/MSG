["import math\nfrom collections import defaultdict\n\ndef calculate_list_of_primes(n):\n    primes = []\n    isprime = []\n    for i in range(0, n + 1):\n        isprime.append(True)\n    for i in range(2, math.floor(math.sqrt(n)) + 1):\n        if isprime[i] == True:\n            for j in range(i ** 2, n + 1, i):\n                isprime[j] = False\n    for i in range(2, n):\n        if isprime[i] == True:\n            primes.append(i)\n    return primes\nprime_list = calculate_list_of_primes(600)\n\ndef calculate_euler_totient(n):\n    totient = n\n    for i in prime_list:\n        if n % i == 0:\n            totient = totient * (i - 1) // i\n    return totient\n\ndef necklace_count(n, k):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count = count + calculate_euler_totient(i) * k ** (n // i)\n    count = count // n\n    return count\n\ndef bracelet_count(n, k):\n    count = necklace_count(n, k)\n    if n % 2 == 0:\n        count = count + (k + 1) * k ** (n // 2) // 2\n    else:\n        count = count + k ** ((n + 1) // 2)\n    return count // 2\n\ndef modified_manacher(str):\n    odd = [0]\n    radius = []\n    for i in range(1, len(str) + 2):\n        radius.append(0)\n    n = 0\n    i = 1\n    text = '$'\n    delta = 0\n    for c in str:\n        s = i - radius[i] + delta\n        text += c\n        while i + radius[i] <= n:\n            radius[i] = min(radius[s + n - i - delta], n - i)\n            if i + radius[i] == n and text[i - radius[i] - 1 + delta] == c:\n                radius[i] = radius[i] + 1\n                break\n            i = i + 1\n        n = n + 1\n        odd.append(2 * radius[i] + 1 - delta)\n    even = [0]\n    radius = []\n    for i in range(1, len(str) + 2):\n        radius.append(0)\n    n = 0\n    i = 1\n    text = '$'\n    delta = 1\n    for c in str:\n        s = i - radius[i] + delta\n        text += c\n        while i + radius[i] <= n:\n            radius[i] = min(radius[s + n - i - delta], n - i)\n            if i + radius[i] == n and text[i - radius[i] - 1 + delta] == c:\n                radius[i] = radius[i] + 1\n                break\n            i = i + 1\n        n = n + 1\n        even.append(2 * radius[i] + 1 - delta)\n    even_odd = []\n    for i in range(0, len(even)):\n        even_odd.append(max(even[i], odd[i]))\n    left = []\n    right = []\n    for i in range(1, len(even)):\n        left.append(i - even_odd[i])\n        right.append(i - 1)\n    d = defaultdict(list)\n    for i in range(0, len(left)):\n        d[right[i] - left[i] + 1].append([left[i], right[i]])\n    counts = set()\n    answer = 0\n    for (key, value) in d.items():\n        if len(value) > 1:\n            for i in value:\n                counts.add(hash(str[i[0]:i[1] + 1]))\n        else:\n            answer += 1\n    answer += len(counts)\n    return answer\nt = input()\nn = int(input())\nk = modified_manacher(t)\nprint(bracelet_count(n, k))", "import math\nfrom collections import defaultdict\n\ndef calculate_list_of_primes(n):\n    primes = []\n    isprime = []\n    for i in range(0, n + 1):\n        isprime.append(True)\n    for i in range(2, math.floor(math.sqrt(n)) + 1):\n        if isprime[i] == True:\n            for j in range(i ** 2, n + 1, i):\n                isprime[j] = False\n    for i in range(2, n):\n        if isprime[i] == True:\n            primes.append(i)\n    return primes\nprime_list = calculate_list_of_primes(600)\n\ndef calculate_euler_totient(n):\n    totient = n\n    for i in prime_list:\n        if n % i == 0:\n            totient = totient * (i - 1) // i\n    return totient\n\ndef necklace_count(n, k):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count = count + calculate_euler_totient(i) * k ** (n // i)\n    count = count // n\n    return count\n\ndef bracelet_count(n, k):\n    count = necklace_count(n, k)\n    if n % 2 == 0:\n        count = count + (k + 1) * k ** (n // 2) // 2\n    else:\n        count = count + k ** ((n + 1) // 2)\n    return count // 2\n\ndef modified_manacher(str):\n    odd = [0]\n    radius = []\n    for i in range(1, len(str) + 2):\n        radius.append(0)\n    n = 0\n    i = 1\n    text = '$'\n    delta = 0\n    for c in str:\n        s = i - radius[i] + delta\n        text += c\n        while i + radius[i] <= n:\n            radius[i] = min(radius[s + n - i - delta], n - i)\n            if i + radius[i] == n and text[i - radius[i] - 1 + delta] == c:\n                radius[i] = radius[i] + 1\n                break\n            i = i + 1\n        n = n + 1\n        odd.append(2 * radius[i] + 1 - delta)\n    even = [0]\n    radius = []\n    for i in range(1, len(str) + 2):\n        radius.append(0)\n    n = 0\n    i = 1\n    text = '$'\n    delta = 1\n    for c in str:\n        s = i - radius[i] + delta\n        text += c\n        while i + radius[i] <= n:\n            radius[i] = min(radius[s + n - i - delta], n - i)\n            if i + radius[i] == n and text[i - radius[i] - 1 + delta] == c:\n                radius[i] = radius[i] + 1\n                break\n            i = i + 1\n        n = n + 1\n        even.append(2 * radius[i] + 1 - delta)\n    even_odd = []\n    for i in range(0, len(even)):\n        even_odd.append(max(even[i], odd[i]))\n    left = []\n    right = []\n    for i in range(1, len(even)):\n        left.append(i - even_odd[i])\n        right.append(i - 1)\n    d = defaultdict(list)\n    for i in range(0, len(left)):\n        d[right[i] - left[i] + 1].append([left[i], right[i]])\n    counts = set()\n    answer = 0\n    for (key, value) in d.items():\n        if len(value) > 1:\n            for i in value:\n                counts.add(hash(str[i[0]:i[1] + 1]))\n        else:\n            answer += 1\n    answer += len(counts)\n    return answer\nt = input()\nn = int(input())\nk = modified_manacher(t)\nprint(bracelet_count(n, k))", "import string\n\ndef gcd(a, b):\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef fastExp(a, n):\n    ans = 1\n    while n != 0:\n        if n & 1:\n            ans *= a\n        a *= a\n        n >>= 1\n    return ans\n\ndef polya(n, m):\n    sum = 0\n    for i in range(n):\n        sum += fastExp(m, gcd(i, n))\n    adj = n * [-1]\n    for i in range(n):\n        for j in range(n):\n            adj[j] = (n + i - j) % n\n        cnt = 0\n        mark = n * [False]\n        for j in range(n):\n            if not mark[j]:\n                cnt += 1\n                k = j\n                while True:\n                    mark[k] = True\n                    k = adj[k]\n                    if k == j:\n                        break\n        sum += fastExp(m, cnt)\n    return sum // (n << 1)\nsigma = string.ascii_lowercase\n\nclass Node:\n\n    def __init__(self, sz):\n        self.sz = sz\n        self.adj = [None for _ in sigma]\n        self.suf = None\n\n    def __getitem__(self, label):\n        return self.adj[ord(label) - ord('a')]\n\n    def __setitem__(self, label, x):\n        self.adj[ord(label) - ord('a')] = x\n\nclass PalindromeTree:\n\n    def __init__(self):\n        self.odd = Node(-1)\n        self.even = Node(0)\n        self.even.suf = self.odd.suf = self.odd\n        self.count = 0\n\n    def build(self, s):\n        last = self.odd\n        for (i, ch) in enumerate(s):\n            cur = last\n            while s[i - cur.sz - 1] != ch:\n                cur = cur.suf\n            if cur[ch] is None:\n                self.count += 1\n                new = cur[ch] = Node(cur.sz + 2)\n                deep = cur.suf\n                while s[i - deep.sz - 1] != ch:\n                    deep = deep.suf\n                new.suf = self.even if cur is deep else deep[ch]\n            else:\n                new = cur[ch]\n            last = new.suf if new.sz == i + 1 else new\n\n    def __len__(self):\n        return self.count\ns = input()\nn = int(input())\ntree = PalindromeTree()\ntree.build(s)\nprint(polya(n, len(tree)))", "import string\n\ndef gcd(a, b):\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef fastExp(a, n):\n    ans = 1\n    while n != 0:\n        if n & 1:\n            ans *= a\n        a *= a\n        n >>= 1\n    return ans\n\ndef polya(n, m):\n    sum = 0\n    for i in range(n):\n        sum += fastExp(m, gcd(i, n))\n    adj = n * [-1]\n    for i in range(n):\n        for j in range(n):\n            adj[j] = (n + i - j) % n\n        cnt = 0\n        mark = n * [False]\n        for j in range(n):\n            if not mark[j]:\n                cnt += 1\n                k = j\n                while True:\n                    mark[k] = True\n                    k = adj[k]\n                    if k == j:\n                        break\n        sum += fastExp(m, cnt)\n    return sum // (n << 1)\nsigma = string.ascii_lowercase\n\nclass Node:\n\n    def __init__(self, sz):\n        self.sz = sz\n        self.adj = [None for _ in sigma]\n        self.suf = None\n\n    def __getitem__(self, label):\n        return self.adj[ord(label) - ord('a')]\n\n    def __setitem__(self, label, x):\n        self.adj[ord(label) - ord('a')] = x\n\nclass PalindromeTree:\n\n    def __init__(self):\n        self.odd = Node(-1)\n        self.even = Node(0)\n        self.even.suf = self.odd.suf = self.odd\n        self.count = 0\n\n    def build(self, s):\n        last = self.odd\n        for (i, ch) in enumerate(s):\n            cur = last\n            while s[i - cur.sz - 1] != ch:\n                cur = cur.suf\n            if cur[ch] is None:\n                self.count += 1\n                new = cur[ch] = Node(cur.sz + 2)\n                deep = cur.suf\n                while s[i - deep.sz - 1] != ch:\n                    deep = deep.suf\n                new.suf = self.even if cur is deep else deep[ch]\n            else:\n                new = cur[ch]\n            last = new.suf if new.sz == i + 1 else new\n\n    def __len__(self):\n        return self.count\ns = input()\nn = int(input())\ntree = PalindromeTree()\ntree.build(s)\nprint(polya(n, len(tree)))", "import string\n\ndef gcd(a, b):\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef fastExp(a, n):\n    ans = 1\n    while n != 0:\n        if n & 1:\n            ans *= a\n        a *= a\n        n >>= 1\n    return ans\n\ndef polya(n, m):\n    sum = 0\n    for i in range(n):\n        sum += fastExp(m, gcd(i, n))\n    adj = n * [-1]\n    for i in range(n):\n        for j in range(n):\n            adj[j] = (n + i - j) % n\n        cnt = 0\n        mark = n * [False]\n        for j in range(n):\n            if not mark[j]:\n                cnt += 1\n                k = j\n                while True:\n                    mark[k] = True\n                    k = adj[k]\n                    if k == j:\n                        break\n        sum += fastExp(m, cnt)\n    return sum // (n << 1)\nsigma = string.ascii_lowercase\n\nclass Node:\n\n    def __init__(self, sz):\n        self.sz = sz\n        self.adj = [None for _ in sigma]\n        self.suf = None\n\n    def __getitem__(self, label):\n        return self.adj[ord(label) - ord('a')]\n\n    def __setitem__(self, label, x):\n        self.adj[ord(label) - ord('a')] = x\n\nclass PalindromeTree:\n\n    def __init__(self):\n        self.odd = Node(-1)\n        self.even = Node(0)\n        self.even.suf = self.odd.suf = self.odd\n        self.count = 0\n\n    def build(self, s):\n        last = self.odd\n        for (i, ch) in enumerate(s):\n            cur = last\n            while s[i - cur.sz - 1] != ch:\n                cur = cur.suf\n            if cur[ch] is None:\n                self.count += 1\n                new = cur[ch] = Node(cur.sz + 2)\n                deep = cur.suf\n                while s[i - deep.sz - 1] != ch:\n                    deep = deep.suf\n                new.suf = self.even if cur is deep else deep[ch]\n            else:\n                new = cur[ch]\n            last = new.suf if new.sz == i + 1 else new\n\n    def __len__(self):\n        return self.count\ns = input()\nn = int(input())\ntree = PalindromeTree()\ntree.build(s)\nprint(polya(n, len(tree)))", "import string\n\ndef gcd(a, b):\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef fastExp(a, n):\n    ans = 1\n    while n != 0:\n        if n & 1:\n            ans *= a\n        a *= a\n        n >>= 1\n    return ans\n\ndef polya(n, m):\n    sum = 0\n    for i in range(n):\n        sum += fastExp(m, gcd(i, n))\n    adj = n * [-1]\n    for i in range(n):\n        for j in range(n):\n            adj[j] = (n + i - j) % n\n        cnt = 0\n        mark = n * [False]\n        for j in range(n):\n            if not mark[j]:\n                cnt += 1\n                k = j\n                while True:\n                    mark[k] = True\n                    k = adj[k]\n                    if k == j:\n                        break\n        sum += fastExp(m, cnt)\n    return sum // (n << 1)\nsigma = string.ascii_lowercase\n\nclass Node:\n\n    def __init__(self, sz):\n        self.sz = sz\n        self.adj = [None for _ in sigma]\n        self.suf = None\n\n    def __getitem__(self, label):\n        return self.adj[ord(label) - ord('a')]\n\n    def __setitem__(self, label, x):\n        self.adj[ord(label) - ord('a')] = x\n\nclass PalindromeTree:\n\n    def __init__(self):\n        self.odd = Node(-1)\n        self.even = Node(0)\n        self.even.suf = self.odd.suf = self.odd\n        self.count = 0\n\n    def build(self, s):\n        last = self.odd\n        for (i, ch) in enumerate(s):\n            cur = last\n            while s[i - cur.sz - 1] != ch:\n                cur = cur.suf\n            if cur[ch] is None:\n                self.count += 1\n                new = cur[ch] = Node(cur.sz + 2)\n                deep = cur.suf\n                while s[i - deep.sz - 1] != ch:\n                    deep = deep.suf\n                new.suf = self.even if cur is deep else deep[ch]\n            else:\n                new = cur[ch]\n            last = new.suf if new.sz == i + 1 else new\n\n    def __len__(self):\n        return self.count\ns = input()\nn = int(input())\ntree = PalindromeTree()\ntree.build(s)\nprint(polya(n, len(tree)))", "import math\nfrom collections import defaultdict\n\ndef calculate_list_of_primes(n):\n    primes = []\n    isprime = []\n    for i in range(0, n + 1):\n        isprime.append(True)\n    for i in range(2, math.floor(math.sqrt(n)) + 1):\n        if isprime[i] == True:\n            for j in range(i ** 2, n + 1, i):\n                isprime[j] = False\n    for i in range(2, n):\n        if isprime[i] == True:\n            primes.append(i)\n    return primes\nprime_list = calculate_list_of_primes(600)\n\ndef calculate_euler_totient(n):\n    totient = n\n    for i in prime_list:\n        if n % i == 0:\n            totient = totient * (i - 1) // i\n    return totient\n\ndef necklace_count(n, k):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count = count + calculate_euler_totient(i) * k ** (n // i)\n    count = count // n\n    return count\n\ndef bracelet_count(n, k):\n    count = necklace_count(n, k)\n    if n % 2 == 0:\n        count = count + (k + 1) * k ** (n // 2) // 2\n    else:\n        count = count + k ** ((n + 1) // 2)\n    return count // 2\n\ndef modified_manacher(str):\n    odd = [0]\n    radius = []\n    for i in range(1, len(str) + 2):\n        radius.append(0)\n    n = 0\n    i = 1\n    text = '$'\n    delta = 0\n    for c in str:\n        s = i - radius[i] + delta\n        text += c\n        while i + radius[i] <= n:\n            radius[i] = min(radius[s + n - i - delta], n - i)\n            if i + radius[i] == n and text[i - radius[i] - 1 + delta] == c:\n                radius[i] = radius[i] + 1\n                break\n            i = i + 1\n        n = n + 1\n        odd.append(2 * radius[i] + 1 - delta)\n    even = [0]\n    radius = []\n    for i in range(1, len(str) + 2):\n        radius.append(0)\n    n = 0\n    i = 1\n    text = '$'\n    delta = 1\n    for c in str:\n        s = i - radius[i] + delta\n        text += c\n        while i + radius[i] <= n:\n            radius[i] = min(radius[s + n - i - delta], n - i)\n            if i + radius[i] == n and text[i - radius[i] - 1 + delta] == c:\n                radius[i] = radius[i] + 1\n                break\n            i = i + 1\n        n = n + 1\n        even.append(2 * radius[i] + 1 - delta)\n    even_odd = []\n    for i in range(0, len(even)):\n        even_odd.append(max(even[i], odd[i]))\n    left = []\n    right = []\n    for i in range(1, len(even)):\n        left.append(i - even_odd[i])\n        right.append(i - 1)\n    d = defaultdict(list)\n    for i in range(0, len(left)):\n        d[right[i] - left[i] + 1].append([left[i], right[i]])\n    counts = set()\n    answer = 0\n    for (key, value) in d.items():\n        if len(value) > 1:\n            for i in value:\n                counts.add(hash(str[i[0]:i[1] + 1]))\n        else:\n            answer += 1\n    answer += len(counts)\n    return answer\nt = input()\nn = int(input())\nk = modified_manacher(t)\nprint(bracelet_count(n, k))"]