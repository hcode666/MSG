["def bsearch(arr, size, ind):\n    mid = 0\n    left = 0\n    right = size - 1\n    reqToGrt = 0\n    reqToLess = 0\n    changeToGrt = 0\n    changeToLess = 0\n    while left <= right:\n        mid = (left + right) // 2\n        if ind == mid:\n            break\n        if ind < mid:\n            if arr[ind] > arr[mid]:\n                changeToGrt += 1\n            reqToGrt += 1\n            right = mid - 1\n        else:\n            if arr[ind] < arr[mid]:\n                changeToLess += 1\n            reqToLess += 1\n            left = mid + 1\n    return (reqToGrt, reqToLess, changeToGrt, changeToLess)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, q) = tuple(map(int, input().split()))\n        pos = {}\n        rank = {}\n        arr = list(map(int, input().split()))\n        b = sorted(arr)\n        for i in range(n):\n            pos[arr[i]] = i\n            rank[b[i]] = i\n        for i in range(q):\n            x = int(input())\n            cnt_less = rank[x]\n            cnt_grt = n - rank[x] - 1\n            (reqToGrt, reqToLess, changeToGrt, changeToLess) = bsearch(arr, n, pos[x])\n            if reqToGrt > cnt_grt or reqToLess > cnt_less:\n                ans = -1\n            else:\n                ans = min(changeToLess, changeToGrt) + abs(changeToGrt - changeToLess)\n            print(ans)\nmain()", "def bsearch(arr, size, ind):\n    mid = 0\n    left = 0\n    right = size - 1\n    reqToGrt = 0\n    reqToLess = 0\n    changeToGrt = 0\n    changeToLess = 0\n    while left <= right:\n        mid = (left + right) // 2\n        if ind == mid:\n            break\n        if ind < mid:\n            if arr[ind] > arr[mid]:\n                changeToGrt += 1\n            reqToGrt += 1\n            right = mid - 1\n        else:\n            if arr[ind] < arr[mid]:\n                changeToLess += 1\n            reqToLess += 1\n            left = mid + 1\n    return (reqToGrt, reqToLess, changeToGrt, changeToLess)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, q) = tuple(map(int, input().split()))\n        pos = {}\n        rank = {}\n        arr = list(map(int, input().split()))\n        b = sorted(arr)\n        for i in range(n):\n            pos[arr[i]] = i\n            rank[b[i]] = i\n        for i in range(q):\n            x = int(input())\n            cnt_less = rank[x]\n            cnt_grt = n - rank[x] - 1\n            (reqToGrt, reqToLess, changeToGrt, changeToLess) = bsearch(arr, n, pos[x])\n            if reqToGrt > cnt_grt or reqToLess > cnt_less:\n                ans = -1\n            else:\n                ans = min(changeToLess, changeToGrt) + abs(changeToGrt - changeToLess)\n            print(ans)\nmain()", "def bsearch(arr, size, ind):\n    mid = 0\n    left = 0\n    right = size - 1\n    reqToGrt = 0\n    reqToLess = 0\n    changeToGrt = 0\n    changeToLess = 0\n    while left <= right:\n        mid = (left + right) // 2\n        if ind == mid:\n            break\n        if ind < mid:\n            if arr[ind] > arr[mid]:\n                changeToGrt += 1\n            reqToGrt += 1\n            right = mid - 1\n        else:\n            if arr[ind] < arr[mid]:\n                changeToLess += 1\n            reqToLess += 1\n            left = mid + 1\n    return (reqToGrt, reqToLess, changeToGrt, changeToLess)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, q) = tuple(map(int, input().split()))\n        pos = {}\n        rank = {}\n        arr = list(map(int, input().split()))\n        b = sorted(arr)\n        for i in range(n):\n            pos[arr[i]] = i\n            rank[b[i]] = i\n        for i in range(q):\n            x = int(input())\n            cnt_less = rank[x]\n            cnt_grt = n - rank[x] - 1\n            (reqToGrt, reqToLess, changeToGrt, changeToLess) = bsearch(arr, n, pos[x])\n            if reqToGrt > cnt_grt or reqToLess > cnt_less:\n                ans = -1\n            else:\n                ans = min(changeToLess, changeToGrt) + abs(changeToGrt - changeToLess)\n            print(ans)\nmain()", "def bsearch(arr, size, ind):\n    mid = 0\n    left = 0\n    right = size - 1\n    reqToGrt = 0\n    reqToLess = 0\n    changeToGrt = 0\n    changeToLess = 0\n    while left <= right:\n        mid = (left + right) // 2\n        if ind == mid:\n            break\n        if ind < mid:\n            if arr[ind] > arr[mid]:\n                changeToGrt += 1\n            reqToGrt += 1\n            right = mid - 1\n        else:\n            if arr[ind] < arr[mid]:\n                changeToLess += 1\n            reqToLess += 1\n            left = mid + 1\n    return (reqToGrt, reqToLess, changeToGrt, changeToLess)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, q) = tuple(map(int, input().split()))\n        pos = {}\n        rank = {}\n        arr = list(map(int, input().split()))\n        b = sorted(arr)\n        for i in range(n):\n            pos[arr[i]] = i\n            rank[b[i]] = i\n        for i in range(q):\n            x = int(input())\n            cnt_less = rank[x]\n            cnt_grt = n - rank[x] - 1\n            (reqToGrt, reqToLess, changeToGrt, changeToLess) = bsearch(arr, n, pos[x])\n            if reqToGrt > cnt_grt or reqToLess > cnt_less:\n                ans = -1\n            else:\n                ans = min(changeToLess, changeToGrt) + abs(changeToGrt - changeToLess)\n            print(ans)\nmain()", "def minswaps(A, A2, D, n, x):\n    (g, s, cg, cs) = (0, 0, 0, 0)\n    (si, li) = (0, n - 1)\n    while si <= li:\n        mid = (si + li) // 2\n        if mid == D[x]:\n            break\n        elif mid < D[x]:\n            if A[mid] < x:\n                cg += 1\n            g += 1\n            si = mid + 1\n        else:\n            if A[mid] > x:\n                cs += 1\n            s += 1\n            li = mid - 1\n    smaller = A2[x]\n    larger = n - A2[x] - 1\n    if s - cs == g - cg:\n        return s - cs\n    elif s - cs > g - cg:\n        if larger - cs >= s - cs:\n            return s - cs\n        else:\n            return -1\n    elif smaller - cg >= g - cg:\n        return g - cg\n    else:\n        return -1\n\ndef solve():\n    (n, q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    A2 = sorted(A)\n    Dict1 = {}\n    Dict2 = {}\n    for i in range(n):\n        Dict1[A[i]] = i\n    for j in range(n):\n        Dict2[A2[j]] = j\n    for que in range(q):\n        Q = int(input())\n        ans = minswaps(A, Dict2, Dict1, n, Q)\n        print(ans)\nt = int(input())\nfor _ in range(t):\n    solve()", "t = int(input())\nwhile t != 0:\n    t -= 1\n    (n, q) = [int(x) for x in input().strip().split()]\n    a = [int(x) for x in input().strip().split()]\n    sorted_a = sorted(a)\n    indexOf = {}\n    index = 0\n    for ele in a:\n        indexOf[ele] = index\n        index += 1\n    index = 0\n    countlessthan = {}\n    countgreaterthan = {}\n    for ele in sorted_a:\n        countlessthan[ele] = index\n        countgreaterthan[ele] = n - 1 - index\n        index += 1\n    while q != 0:\n        q = q - 1\n        x = int(input())\n        low = 0\n        high = n - 1\n        swapGreaterYes = 0\n        swapGreaterNo = 0\n        swapLesserYes = 0\n        swapLesserNo = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if a[mid] == x:\n                break\n            elif a[mid] < x and indexOf[x] > mid:\n                low = mid + 1\n                swapLesserNo += 1\n            elif a[mid] < x and indexOf[x] < mid:\n                high = mid - 1\n                swapGreaterYes += 1\n            elif a[mid] > x and indexOf[x] < mid:\n                swapGreaterNo += 1\n                high = mid - 1\n            elif a[mid] > x and indexOf[x] > mid:\n                swapLesserYes += 1\n                low = mid + 1\n        neededswaps = max(swapLesserYes, swapGreaterYes)\n        ans = neededswaps\n        if swapLesserYes > countlessthan[x] - swapLesserNo or swapGreaterYes > countgreaterthan[x] - swapGreaterNo:\n            ans = -1\n        print(ans)", "t = int(input())\nwhile t != 0:\n    t -= 1\n    (n, q) = [int(x) for x in input().strip().split()]\n    a = [int(x) for x in input().strip().split()]\n    sorted_a = sorted(a)\n    indexOf = {}\n    index = 0\n    for ele in a:\n        indexOf[ele] = index\n        index += 1\n    index = 0\n    countlessthan = {}\n    countgreaterthan = {}\n    for ele in sorted_a:\n        countlessthan[ele] = index\n        countgreaterthan[ele] = n - 1 - index\n        index += 1\n    while q != 0:\n        q = q - 1\n        x = int(input())\n        low = 0\n        high = n - 1\n        swapGreaterYes = 0\n        swapGreaterNo = 0\n        swapLesserYes = 0\n        swapLesserNo = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if a[mid] == x:\n                break\n            elif a[mid] < x and indexOf[x] > mid:\n                low = mid + 1\n                swapLesserNo += 1\n            elif a[mid] < x and indexOf[x] < mid:\n                high = mid - 1\n                swapGreaterYes += 1\n            elif a[mid] > x and indexOf[x] < mid:\n                swapGreaterNo += 1\n                high = mid - 1\n            elif a[mid] > x and indexOf[x] > mid:\n                swapLesserYes += 1\n                low = mid + 1\n        neededswaps = max(swapLesserYes, swapGreaterYes)\n        ans = neededswaps\n        if swapLesserYes > countlessthan[x] - swapLesserNo or swapGreaterYes > countgreaterthan[x] - swapGreaterNo:\n            ans = -1\n        print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = []\n    b1 = {}\n    for y in range(q):\n        k = int(input())\n        b.append(k)\n        b1[k] = [0, 0]\n    for i in range(n):\n        if a[i] in b1:\n            b1[a[i]][0] = i\n    p = a.copy()\n    p.sort()\n    for i in range(n):\n        if p[i] in b1:\n            b1[p[i]][1] = i\n    for i in range(q):\n        s = b1[b[i]][1]\n        pos = b1[b[i]][0]\n        e = n - s - 1\n        l = 0\n        r = n - 1\n        s1 = 0\n        e1 = 0\n        s2 = 0\n        e2 = 0\n        while l <= r:\n            m = (l + r) // 2\n            if m == pos:\n                break\n            elif m < pos:\n                s1 += 1\n                if a[m] > a[pos]:\n                    s2 += 1\n                l = m + 1\n            else:\n                e1 += 1\n                if a[m] < a[pos]:\n                    e2 += 1\n                r = m - 1\n        if s1 <= s and e1 <= e:\n            print(max(s2, e2))\n        else:\n            print(-1)", "def f(a, y, index, sorted_pos):\n    n = len(a)\n    low = 0\n    high = n - 1\n    (L, R) = (0, 0)\n    (l, r) = (0, 0)\n    while low <= high:\n        mid = (low + high) // 2\n        if a[mid] == y:\n            break\n        elif mid > index[y]:\n            high = mid - 1\n            L += 1\n            if a[mid] < y:\n                l += 1\n        else:\n            low = mid + 1\n            R += 1\n            if a[mid] > y:\n                r += 1\n    x = sorted_pos[y]\n    if R > x or L > n - x - 1:\n        print('-1')\n    else:\n        print(max(l, r))\n\ndef fun():\n    test = int(input())\n    for t in range(test):\n        (n, q) = map(int, input().split())\n        arr = list(map(int, input().split()))\n        index = dict()\n        for i in range(n):\n            index[arr[i]] = i\n        sorted_pos = dict()\n        a = sorted(arr)\n        for i in range(n):\n            sorted_pos[a[i]] = i\n        for x in range(q):\n            y = int(input())\n            f(arr, y, index, sorted_pos)\nfun()", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    l = [int(i) for i in input().split()]\n    d = {}\n    ind = {}\n    for i in range(n):\n        ind[l[i]] = i\n    dup = sorted(l)\n    for i in range(n):\n        chote = i\n        bade = n - i - 1\n        d[dup[i]] = [chote, bade]\n    for _ in range(q):\n        chotewale_swap = 0\n        badewale_swap = 0\n        x = int(input())\n        d1 = {}\n        d1[0] = d[x][0]\n        d1[1] = d[x][1]\n        f = 1\n        low = 0\n        high = n - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if ind[x] == mid:\n                break\n            elif ind[x] > mid and x > l[mid]:\n                if d1[0] == 0:\n                    f = -1\n                    break\n                d1[0] -= 1\n                low = mid + 1\n            elif ind[x] > mid and x < l[mid]:\n                if d1[0] == 0:\n                    f = -1\n                    break\n                d1[0] -= 1\n                chotewale_swap += 1\n                low = mid + 1\n            elif ind[x] < mid and x < l[mid]:\n                if d1[1] == -1:\n                    f = -1\n                    break\n                d1[1] -= 1\n                high = mid - 1\n            elif ind[x] < mid and x > l[mid]:\n                if d1[1] == 0:\n                    f = -1\n                    break\n                d1[1] -= 1\n                badewale_swap += 1\n                high = mid - 1\n        if f == -1:\n            print(-1)\n        else:\n            print(max(chotewale_swap, badewale_swap))", "def f(a, y, index, sorted_pos):\n    n = len(a)\n    low = 0\n    high = n - 1\n    (L, R) = (0, 0)\n    (l, r) = (0, 0)\n    while low <= high:\n        mid = (low + high) // 2\n        if a[mid] == y:\n            break\n        elif mid > index[y]:\n            high = mid - 1\n            L += 1\n            if a[mid] < y:\n                l += 1\n        else:\n            low = mid + 1\n            R += 1\n            if a[mid] > y:\n                r += 1\n    x = sorted_pos[y]\n    if R > x or L > n - x - 1:\n        print('-1')\n    else:\n        print(max(l, r))\n\ndef fun():\n    test = int(input())\n    for t in range(test):\n        (n, q) = map(int, input().split())\n        arr = list(map(int, input().split()))\n        index = dict()\n        for i in range(n):\n            index[arr[i]] = i\n        sorted_pos = dict()\n        a = sorted(arr)\n        for i in range(n):\n            sorted_pos[a[i]] = i\n        for x in range(q):\n            y = int(input())\n            f(arr, y, index, sorted_pos)\nfun()", "t = int(input())\nwhile t > 0:\n    t -= 1\n    (n, q) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    tarr = sorted(arr)\n    d = {}\n    inddir = {}\n    for i in range(len(arr)):\n        inddir[arr[i]] = i\n    tarrlen = len(tarr)\n    for i in range(len(tarr)):\n        d[tarr[i]] = [i, tarrlen - i - 1]\n    for _ in range(q):\n        k = int(input())\n        find = inddir[k]\n        (l, r) = (1, tarrlen)\n        gs = 0\n        ls = 0\n        sw = 0\n        tempc = d[k].copy()\n        while l <= r:\n            mid = (l + r) // 2\n            if mid - 1 == find:\n                break\n            elif mid - 1 < find:\n                if arr[mid - 1] < k:\n                    if tempc[0] > 0:\n                        tempc[0] -= 1\n                    else:\n                        sw = -1\n                        break\n                elif tempc[0] > 0:\n                    tempc[0] -= 1\n                    sw += 1\n                    ls += 1\n                else:\n                    sw = -1\n                    break\n                l = mid + 1\n            else:\n                if arr[mid - 1] > k:\n                    if tempc[1] > 0:\n                        tempc[1] -= 1\n                    else:\n                        sw = -1\n                        break\n                elif tempc[1] > 0:\n                    tempc[1] -= 1\n                    sw += 1\n                    gs += 1\n                else:\n                    sw = -1\n                    break\n                r = mid - 1\n        print(max(ls, gs) if sw != -1 else -1)", "t = int(input())\nfor a0 in range(t):\n    (n, q) = input().strip().split(' ')\n    (n, q) = (int(n), int(q))\n    arr1 = list(map(int, input().strip().split(' ')))\n    arr = list(arr1)\n    arr1.sort()\n    ltgt = {}\n    ind = {}\n    for i in range(len(arr)):\n        ind[arr[i]] = i\n    for i in range(len(arr1)):\n        ltgt[arr1[i]] = [i, n - 1 - i]\n    for a1 in range(q):\n        x = int(input(''))\n        low = 0\n        high = n - 1\n        smallerreplaced = 0\n        largerreplaced = 0\n        smallernotreplaced = 0\n        largernotreplaced = 0\n        while True:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                break\n            elif x < arr[mid] and ind[x] < mid:\n                high = mid - 1\n                largernotreplaced += 1\n            elif x < arr[mid] and ind[x] > mid:\n                low = mid + 1\n                smallerreplaced += 1\n            elif x > arr[mid] and ind[x] > mid:\n                low = mid + 1\n                smallernotreplaced += 1\n            elif x > arr[mid] and ind[x] < mid:\n                high = mid - 1\n                largerreplaced += 1\n        anstillnow = max(largerreplaced, smallerreplaced)\n        if largerreplaced + largernotreplaced > ltgt[x][1] or smallerreplaced + smallernotreplaced > ltgt[x][0]:\n            ans = -1\n        else:\n            ans = anstillnow\n        print(ans)", "def mergeSort(alist, a):\n    b = []\n    if len(alist) > 1:\n        mid = len(alist) // 2\n        lefthalf = alist[:mid]\n        righthalf = alist[mid:]\n        la = a[:mid]\n        ra = a[mid:]\n        mergeSort(lefthalf, la)\n        mergeSort(righthalf, ra)\n        i = 0\n        j = 0\n        k = 0\n        while i < len(lefthalf) and j < len(righthalf):\n            if lefthalf[i] < righthalf[j]:\n                alist[k] = lefthalf[i]\n                a[k] = la[i]\n                i = i + 1\n            else:\n                alist[k] = righthalf[j]\n                a[k] = ra[j]\n                j = j + 1\n            k = k + 1\n        while i < len(lefthalf):\n            alist[k] = lefthalf[i]\n            a[k] = la[i]\n            i = i + 1\n            k = k + 1\n        while j < len(righthalf):\n            alist[k] = righthalf[j]\n            a[k] = ra[j]\n            j = j + 1\n            k = k + 1\n\ndef index(a, x):\n    for i in range(1, len(a) + 1):\n        if x == a[i]:\n            return i\n            break\n\ndef cc(a, low, high, x):\n    j = 0\n    while j < len(a) // 2:\n        mid = (low + high) // 2\n        if x == a[mid]:\n            return mid\n            break\n        elif x > a[mid]:\n            j += 1\n            low = mid + 1\n        else:\n            j += 1\n            high = mid - 1\n\ndef chalega(a, x, i, si, low, high, b, c, j):\n    gx = len(a) - 1 - si\n    lx = si - 1\n    l = 0\n    r = 0\n    while j < len(a):\n        mid = (low + high) // 2\n        if l > lx or r > gx:\n            c = -1\n            break\n        elif i == mid:\n            c += 0\n            break\n        elif i < mid:\n            if x > a[mid]:\n                r += 1\n                high = mid - 1\n                j += 1\n            elif x < a[mid]:\n                gx -= 1\n                high = mid - 1\n                j += 1\n        elif i > mid:\n            if x > a[mid]:\n                low = mid + 1\n                j += 1\n                lx -= 1\n            else:\n                l += 1\n                low = mid + 1\n                j += 1\n    if c != -1:\n        if l >= r:\n            c = l\n        else:\n            c = r\n    return c\nt = int(input())\nfor i in range(t):\n    nq = input().split()\n    n = int(nq[0]) + 1\n    q = int(nq[1])\n    nn = input().split()\n    a = [0]\n    aa = [0]\n    b = [0]\n    dic = {}\n    for j in range(n - 1):\n        dic[int(nn[j])] = j + 1\n        a.append(int(nn[j]))\n        b.append(int(nn[j]))\n    b.sort()\n    for k in range(q):\n        x = int(input())\n        z = cc(b, 1, len(b) - 1, x)\n        y = dic[x]\n        print(chalega(a, x, y, z, 1, len(a) - 1, b, 0, 0))", "t = int(input())\nwhile t != 0:\n    t -= 1\n    (n, q) = [int(x) for x in input().strip().split()]\n    a = [int(x) for x in input().strip().split()]\n    sorted_a = sorted(a)\n    indexOf = {}\n    index = 0\n    for ele in a:\n        indexOf[ele] = index\n        index += 1\n    index = 0\n    countlessthan = {}\n    countgreaterthan = {}\n    for ele in sorted_a:\n        countlessthan[ele] = index\n        countgreaterthan[ele] = n - 1 - index\n        index += 1\n    while q != 0:\n        q = q - 1\n        x = int(input())\n        low = 0\n        high = n - 1\n        swapGreaterYes = 0\n        swapGreaterNo = 0\n        swapLesserYes = 0\n        swapLesserNo = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if a[mid] == x:\n                break\n            elif a[mid] < x and indexOf[x] > mid:\n                low = mid + 1\n                swapLesserNo += 1\n            elif a[mid] < x and indexOf[x] < mid:\n                high = mid - 1\n                swapGreaterYes += 1\n            elif a[mid] > x and indexOf[x] < mid:\n                swapGreaterNo += 1\n                high = mid - 1\n            elif a[mid] > x and indexOf[x] > mid:\n                swapLesserYes += 1\n                low = mid + 1\n        neededswaps = max(swapLesserYes, swapGreaterYes)\n        ans = neededswaps\n        if swapLesserYes > countlessthan[x] - swapLesserNo or swapGreaterYes > countgreaterthan[x] - swapGreaterNo:\n            ans = -1\n        else:\n            ans = neededswaps\n        print(ans)", "import copy\n\ndef binary_search(a, n, x):\n    low = 1\n    high = n\n    mid = (low + high) / 2\n    mid = int(mid)\n    swpl = 0\n    swph = 0\n    cntl = 0\n    cnth = 0\n    while low <= high:\n        mid = (low + high) / 2\n        mid = int(mid)\n        if mid == x:\n            break\n        elif mid < x:\n            low = mid + 1\n            cntl = cntl + 1\n            if a[mid] >= a[x]:\n                swpl = swpl + 1\n        else:\n            high = mid - 1\n            cnth = cnth + 1\n            if a[mid] < a[x]:\n                swph = swph + 1\n    ss = [swpl, swph, cntl, cnth]\n    return ss\nT = int(input())\nfor i1 in range(T):\n    arr = input()\n    lo = list(map(int, arr.split()))\n    n = lo[0]\n    q = lo[1]\n    arr1 = input()\n    l1 = list(map(int, arr1.split()))\n    a = 0\n    l1 = [a] + l1\n    l2 = copy.deepcopy(l1)\n    d = dict()\n    for i in range(1, n + 1):\n        d[l2[i]] = i\n    l1.sort()\n    d1 = dict()\n    for z in range(1, n + 1):\n        d1[l1[z]] = z - 1\n    for isa in range(q):\n        k = int(input())\n        k_pos = d[k]\n        pp = binary_search(l2, n, k_pos)\n        if pp[2] > d1[k] or pp[3] > n - 1 - d1[k]:\n            print(-1)\n        else:\n            print(max(pp[0], pp[1]))", "def bin(arr, x, l, r):\n    while l <= r:\n        mid = (r + l) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            l = mid + 1\n        else:\n            r = mid - 1\n\ndef sol(index, sindex, arr, l, r, x):\n    count1 = 0\n    count2 = 0\n    smr = 0\n    gtr = 0\n    smlr = sindex - l\n    grtr = r - sindex\n    while l <= r:\n        mid = (r + l) // 2\n        if mid == index:\n            break\n        elif mid < index:\n            if arr[mid] > x:\n                count1 += 1\n            else:\n                smr += 1\n            l = mid + 1\n        else:\n            if arr[mid] < x:\n                count2 += 1\n            else:\n                gtr += 1\n            r = mid - 1\n    if count1 + smr <= smlr and count2 + gtr <= grtr:\n        print(max(count2, count1))\n    else:\n        print(-1)\nt = int(input())\nfor i in range(t):\n    (N, Q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    k = list(a)\n    index = list(sorted(range(len(a)), key=lambda x: a[x]))\n    list.sort(a)\n    for j in range(Q):\n        x = int(input())\n        q = bin(a, x, 0, N - 1)\n        z = index[q]\n        sol(z, q, k, 0, N - 1, x)", "T = int(input())\nfor xs in range(T):\n    (N, Q) = [int(o) for o in input().split()]\n    a = [int(o) for o in input().split()]\n    b = sorted(a)\n    Di = {}\n    for i in range(len(a)):\n        Di[a[i]] = [i]\n    for i in range(len(b)):\n        Di[b[i]].append(i)\n    r = []\n    qu = [int(input()) for j in range(Q)]\n    for q in qu:\n        low = 1\n        high = N\n        ind = Di[q][0] + 1\n        b = []\n        f = []\n        s = 0\n        maxs = N - Di[q][1] - 1\n        mins = N - maxs - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if mid == ind:\n                break\n            elif mid < ind:\n                low = mid + 1\n                if a[mid - 1] > q:\n                    b.append(a[mid - 1])\n                else:\n                    mins -= 1\n            elif mid > ind:\n                high = mid - 1\n                if a[mid - 1] < q:\n                    f.append(a[mid - 1])\n                else:\n                    maxs -= 1\n        lenf = len(f)\n        lenb = len(b)\n        sw = min(lenf, lenb)\n        rs = max(lenf, lenb) - sw\n        (mins, maxs) = (mins - sw, maxs - sw)\n        ex = min(mins, maxs)\n        if ex < rs:\n            r.append(-1)\n            s = 1\n        else:\n            sw += rs\n        if not s:\n            r.append(sw)\n    for ans in r:\n        print(ans)", "import copy\nfor t in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = copy.deepcopy(a)\n    b.sort()\n    d = dict()\n    d1 = dict()\n    for i in range(n):\n        d[a[i]] = i\n    for i in range(n):\n        d1[b[i]] = i\n    for que in range(q):\n        x = int(input())\n        x_a_index = d[x]\n        x_b_index = d1[x]\n        swaplwr = 0\n        swapgrt = 0\n        cnth = 0\n        cntl = 0\n        low = 0\n        high = n - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if mid == x_a_index:\n                break\n            elif mid > x_a_index:\n                high = mid - 1\n                cnth += 1\n                if a[mid] < x:\n                    swaplwr += 1\n            else:\n                low = mid + 1\n                cntl += 1\n                if a[mid] > x:\n                    swapgrt += 1\n        if cntl > x_b_index or cnth > n - (x_b_index + 1):\n            print(-1)\n        else:\n            print(max(swapgrt, swaplwr))", "from operator import itemgetter\nR = lambda : map(int, input().split())\nt = int(input())\nfor _ in range(t):\n    (n, q) = R()\n    a = list(R())\n    b = sorted(enumerate(a), key=itemgetter(1))\n    d = dict(((x, (i, j)) for (j, (i, x)) in enumerate(b)))\n    for _ in range(q):\n        x = int(input())\n        (i, j) = d[x]\n        (l, h) = (0, n - 1)\n        a1 = a2 = b1 = b2 = 0\n        while True:\n            m = (l + h) // 2\n            if m == i:\n                break\n            if m < i:\n                l = m + 1\n                a1 += 1\n                if a[m] > x:\n                    a2 += 1\n            else:\n                h = m - 1\n                b1 += 1\n                if a[m] < x:\n                    b2 += 1\n        if a1 > j or b1 > n - 1 - j:\n            print(-1)\n        else:\n            print(max(a2, b2))", "from copy import *\n\ndef BinarySearch(a, low, high, x, index, minn, maxx, smaller, larger, f):\n    low += 1\n    minmax = 0\n    maxmin = 0\n    s = 0\n    l = 0\n    high += 1\n    while high - low >= 0:\n        mid = (low + high) // 2\n        if mid - index == 0:\n            break\n        elif mid - index < 0:\n            s += 1\n            if a[mid - 1] - a[index - 1] < 0:\n                if f:\n                    minmax += 1\n            low = mid + 1\n        elif mid - index > 0:\n            l += 1\n            if a[mid - 1] - a[index - 1] > 0:\n                if f:\n                    maxmin += 1\n            high = mid - 1\n    ans = 0\n    if s - smaller <= 0:\n        if l - larger <= 0:\n            a = s - minmax\n            b = l - maxmin\n            ans = max(a, b)\n            return ans\n        else:\n            ans = -1\n            return ans\n    else:\n        ans = -1\n        return ans\nT = int(input())\nfor t in range(T):\n    (N, Q) = map(int, input().split())\n    l = list(map(int, input().split()))\n    D = {}\n    E = {}\n    sortedd = sorted(l)\n    for i in range(len(l)):\n        D[l[i]] = i\n    i = 0\n    while i < len(l):\n        E[sortedd[i]] = i\n        i += 1\n    minn = sortedd[0]\n    maxx = sortedd[-1]\n    for q in range(Q):\n        x = int(input())\n        smaller = E[x]\n        larger = len(l) - E[x]\n        larger -= 1\n        print(BinarySearch(l, 0, len(l) - 1, x, D[x] + 1, minn, maxx, smaller, larger, True))", "import copy\n\ndef binary_search(a, n, x):\n    low = 1\n    high = n\n    mid = (low + high) / 2\n    mid = int(mid)\n    swpl = 0\n    swph = 0\n    cntl = 0\n    cnth = 0\n    while low <= high:\n        mid = (low + high) / 2\n        mid = int(mid)\n        if mid == x:\n            break\n        elif mid < x:\n            low = mid + 1\n            cntl = cntl + 1\n            if a[mid] >= a[x]:\n                swpl = swpl + 1\n        else:\n            high = mid - 1\n            cnth = cnth + 1\n            if a[mid] < a[x]:\n                swph = swph + 1\n    ss = [swpl, swph, cntl, cnth]\n    return ss\nT = int(input())\nfor i1 in range(T):\n    arr = input()\n    lo = list(map(int, arr.split()))\n    n = lo[0]\n    q = lo[1]\n    arr1 = input()\n    l1 = list(map(int, arr1.split()))\n    a = 0\n    l1 = [a] + l1\n    l2 = copy.deepcopy(l1)\n    d = dict()\n    for i in range(1, n + 1):\n        d[l2[i]] = i\n    l1.sort()\n    d1 = dict()\n    for z in range(1, n + 1):\n        d1[l1[z]] = z - 1\n    for isa in range(q):\n        k = int(input())\n        k_pos = d[k]\n        pp = binary_search(l2, n, k_pos)\n        if pp[2] > d1[k] or pp[3] > n - 1 - d1[k]:\n            print(-1)\n        else:\n            print(max(pp[0], pp[1]))", "def bsc(a, di, dn, x, n):\n    xi = dn[x]\n    c = 0\n    (s1, s2, l1, l2) = (0, 0, 0, 0)\n    (l, h) = (0, n - 1)\n    while l <= h:\n        m = int((l + h) / 2)\n        if a[m] == x:\n            xj = di[x]\n            if xj - s2 >= s1 and n - xj - 1 - l2 >= l1:\n                return max(s1, l1)\n            else:\n                return -1\n        elif a[m] < x and xi < m:\n            l1 += 1\n        elif a[m] > x and xi > m:\n            s1 += 1\n        elif a[m] > x and xi < m:\n            l2 += 1\n        elif a[m] < x and xi > m:\n            s2 += 1\n        if xi > m:\n            (l, h) = (m + 1, h)\n        else:\n            (l, h) = (l, m - 1)\n    xj = di[x]\n    if xj - s2 >= s1 and n - xj - 1 - l2 >= l1:\n        return max(s1, l1)\n    else:\n        return -1\nt = int(input())\nfor i in range(t):\n    n = input().split()\n    (n, q) = (int(n[0]), int(n[1]))\n    a = list(map(int, input().split()))\n    l = list(a)\n    l.sort()\n    (di, dn) = (dict(), dict())\n    for i in range(n):\n        di[l[i]] = i\n        dn[a[i]] = i\n    for j in range(q):\n        x = int(input())\n        print(bsc(a, di, dn, x, n))", "from collections import OrderedDict\nT = int(input())\nfor test_case in range(T):\n    (N, Q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    d = {a[i]: i + 1 for i in range(N)}\n    a_sort = sorted(a)\n    d_sort = OrderedDict()\n    for i in range(N):\n        d_sort[a_sort[i]] = i\n    for query in range(Q):\n        x = int(input())\n        (cntl, cnth) = (0, 0)\n        (l, h) = (d_sort[x], N - 1 - d_sort[x])\n        low = 1\n        high = N\n        while low <= high:\n            mid = (low + high) // 2\n            if a[mid - 1] == x:\n                break\n            elif a[mid - 1] < x:\n                if d[x] < mid:\n                    cnth += 1\n                    h -= 1\n                    high = mid - 1\n                else:\n                    l -= 1\n                    low = mid + 1\n            elif d[x] > mid:\n                cntl += 1\n                l -= 1\n                low = mid + 1\n            else:\n                h -= 1\n                high = mid - 1\n        if l < 0 or h < 0:\n            print(-1)\n        else:\n            print(max(cnth, cntl))", "t = int(input())\nfor i in range(t):\n    y = [int(i) for i in input().split()]\n    n = y[0]\n    q = y[1]\n    a = [int(j) for j in input().split()]\n    b = sorted(a)\n    dic = {}\n    dic1 = {}\n    for j in range(n):\n        dic[a[j]] = j\n    for j in range(n):\n        dic1[b[j]] = j\n    for j in range(q):\n        x = int(input())\n        ind = dic[x] + 1\n        low = 1\n        high = n\n        small = 0\n        sdone = 0\n        ldone = 0\n        large = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if mid == ind:\n                break\n            elif mid < ind:\n                small += 1\n                if a[mid - 1] < a[ind - 1]:\n                    sdone += 1\n                low = mid + 1\n            else:\n                large += 1\n                if a[mid - 1] > a[ind - 1]:\n                    ldone += 1\n                high = mid - 1\n        shave = dic1[x]\n        lhave = n - dic1[x] - 1\n        if small <= shave and large <= lhave:\n            print(max(small - sdone, large - ldone))\n        else:\n            print(-1)", "from collections import defaultdict\nt = int(input())\nfor z in range(t):\n    (n, q) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    fg = sorted(a)\n    b = {a[i]: i for i in range(len(a))}\n    bs = {fg[i]: i for i in range(len(a))}\n    b = defaultdict(int, b)\n    bs = defaultdict(int, bs)\n    debug = False\n    if debug:\n        print(b)\n        print(bs)\n    for zy in range(q):\n        x = int(input())\n        xidx = b[x]\n        xsidx = bs[x]\n        ch = len(a) - xsidx - 1\n        cl = xsidx\n        low = 0\n        high = len(a) - 1\n        swaps = 0\n        cls = 0\n        chs = 0\n        if debug:\n            print(xidx, xsidx)\n        while low <= high:\n            mid = (low + high) // 2\n            if a[mid] == x:\n                break\n            elif mid < xidx:\n                cl -= 1\n                if a[mid] > x:\n                    cls += 1\n                    swaps += 1\n                low = mid + 1\n            else:\n                ch -= 1\n                if a[mid] < x:\n                    chs += 1\n                    swaps += 1\n                high = mid - 1\n            if debug:\n                print('mid:', mid, 'low:', low, 'high:', high, 'swaps:', swaps)\n                print('ch', ch, 'cl', cl)\n        swaps = max(cls, chs)\n        if ch < 0 or cl < 0:\n            swaps = -1\n        print(swaps)", "for t in range(int(input())):\n    (n, q) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    brr = []\n    pos = {}\n    bpos = {}\n    for i in range(n):\n        pos[arr[i]] = i\n        brr.append(arr[i])\n    brr.sort()\n    for j in range(n):\n        bpos[brr[j]] = j\n    for i in range(q):\n        x = int(input())\n        low = 0\n        high = n - 1\n        il = ir = cl = cr = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                break\n            elif x < arr[mid] and pos[x] < mid:\n                cl += 1\n                high = mid - 1\n            elif x < arr[mid] and pos[x] > mid:\n                ir += 1\n                low = mid + 1\n            elif x > arr[mid] and pos[x] > mid:\n                cr += 1\n                low = mid + 1\n            else:\n                il += 1\n                high = mid - 1\n        indx = bpos[x]\n        elemLessThan = indx\n        elemMoreThan = n - indx - 1\n        if cr + ir <= elemLessThan and cl + il <= elemMoreThan:\n            print(max(ir, il))\n        else:\n            print(-1)", "def search(arr, l, r, x, index, small, SMALL, large, LARGE):\n    mid = int((l + r) / 2)\n    if index == mid:\n        return (small, SMALL, large, LARGE)\n    elif index < mid:\n        if arr[mid] < x:\n            large += 1\n        else:\n            LARGE += 1\n        return search(arr, l, mid - 1, x, index, small, SMALL, large, LARGE)\n    else:\n        if arr[mid] < x:\n            SMALL += 1\n        else:\n            small += 1\n        return search(arr, mid + 1, r, x, index, small, SMALL, large, LARGE)\n\ndef SIndex_Index(Sorted, l, r, x):\n    mid = int((l + r) / 2)\n    if Sorted[mid][1] == x:\n        return (mid, Sorted[mid][0])\n    elif Sorted[mid][1] < x:\n        return SIndex_Index(Sorted, mid + 1, r, x)\n    else:\n        return SIndex_Index(Sorted, l, mid - 1, x)\nT = int(input())\nfor l in range(T):\n    (N, Q) = input().split(' ')\n    N = int(N)\n    Q = int(Q)\n    arr = input().split(' ')\n    for p in range(N):\n        arr[p] = int(arr[p])\n    Sorted = sorted(enumerate(arr), key=lambda x: x[1])\n    for k in range(Q):\n        x = int(input())\n        (SIndex, Index) = SIndex_Index(Sorted, 0, N - 1, x)\n        (small, SMALL, large, LARGE) = search(arr, 0, N - 1, x, Index, 0, 0, 0, 0)\n        leftS = SIndex - SMALL\n        leftL = N - SIndex - 1 - LARGE\n        if leftS >= small and leftL >= large:\n            print(max(small, large))\n        else:\n            print(-1)", "T = int(input())\nfor t in range(T):\n    (N, Q) = map(int, input().split())\n    if N > 10:\n        L1 = list(map(int, input().split()))\n        L1.insert(0, -1)\n        L2 = L1[:]\n        L2.sort()\n        D2 = dict()\n        for i in range(1, N + 1):\n            D2[L2[i]] = i\n        D = dict()\n        for i in range(1, N + 1):\n            D[L1[i]] = i\n        for q in range(Q):\n            ctr = 0\n            A = int(input())\n            K = D[A]\n            low = 1\n            high = N\n            flag = True\n            lr = 0\n            ld = 0\n            sr = 0\n            sd = 0\n            while low <= high:\n                mid = (high + low) // 2\n                if L1[mid] == A:\n                    flag = False\n                    break\n                elif L1[mid] > A and K > mid:\n                    ld += 1\n                    sr += 1\n                    low = mid + 1\n                elif L1[mid] > A and K < mid:\n                    ld += 1\n                    high = mid - 1\n                elif L1[mid] < A and K > mid:\n                    sd += 1\n                    low = mid + 1\n                elif L1[mid] < A and K < mid:\n                    sd += 1\n                    lr += 1\n                    high = mid - 1\n            if flag == True or ld + lr > N - D2[A] or sd + sr >= D2[A]:\n                print(-1)\n            elif lr == sr:\n                print(sr)\n            else:\n                print(max(sr, lr))\n    else:\n        L1 = list(map(int, input().split()))\n        L1.insert(0, -1)\n        L2 = []\n        for i in L1:\n            L2.append(i)\n        L2.sort()\n        D2 = dict()\n        for i in range(1, N + 1):\n            D2[L2[i]] = i\n        D = dict()\n        for i in range(1, N + 1):\n            D[L1[i]] = i\n        for q in range(Q):\n            ctr = 0\n            A = int(input())\n            K = D[A]\n            low = 1\n            high = N\n            flag = True\n            lctr = 0\n            rctr = 0\n            lctr2 = 0\n            rctr2 = 0\n            while low <= high:\n                mid = (high + low) // 2\n                if L1[mid] == A:\n                    flag = False\n                    break\n                elif L1[mid] > A and K > mid:\n                    ctr += 1\n                    rctr += 1\n                    rctr2 += 1\n                    low = mid + 1\n                elif L1[mid] > A and K < mid:\n                    lctr += 1\n                    high = mid - 1\n                elif L1[mid] < A and K > mid:\n                    low = mid + 1\n                    rctr += 1\n                elif L1[mid] < A and K < mid:\n                    ctr += 1\n                    lctr2 += 1\n                    high = mid - 1\n                    lctr += 1\n            if flag == True or lctr > N - D2[A] or rctr >= D2[A]:\n                print(-1)\n            elif lctr2 == rctr2:\n                print(lctr2)\n            else:\n                print(abs(lctr2 - rctr2))", "def binary(arr, x, check, lowcount, upcount):\n    lcount = 0\n    ucount = 0\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            break\n        if low == high and arr[mid] != x:\n            break\n        elif arr[mid] < x and mid < check:\n            if lowcount == 0:\n                ucount = -1\n                break\n            lowcount -= 1\n            low = mid + 1\n        elif arr[mid] > x and mid > check:\n            if upcount == 0:\n                lcount = -1\n                break\n            upcount -= 1\n            high = mid - 1\n        elif arr[mid] > x and mid < check:\n            if lowcount == 0:\n                lcount = -1\n                break\n            else:\n                lowcount -= 1\n                lcount += 1\n                low = mid + 1\n        elif arr[mid] < x and mid > check:\n            if upcount == 0:\n                ucount = -1\n                break\n            else:\n                upcount -= 1\n                ucount += 1\n                high = mid - 1\n        else:\n            lcount = -1\n            ucount = -1\n            break\n    return (lcount, ucount)\ntotal = int(input())\nfor _ in range(total):\n    mn = list(map(int, input().split()))\n    n = mn[0]\n    q = mn[1]\n    arr = list(map(int, input().split()))\n    arr2 = {}\n    arr_sorted = sorted(arr)\n    arr2_sorted = {}\n    for i in range(len(arr)):\n        arr2_sorted[arr_sorted[i]] = i\n        arr2[arr[i]] = i\n    for _ in range(q):\n        x = int(input())\n        check = arr2[x]\n        check2 = arr2_sorted[x]\n        lowcount = check2\n        upcount = len(arr2) - check2 - 1\n        lowcount2 = lowcount\n        upcount2 = upcount\n        (lcount, ucount) = binary(arr, x, check, lowcount, upcount)\n        if lcount > lowcount2 or ucount > upcount2:\n            print(-1)\n        elif lcount == -1 or ucount == -1:\n            print(-1)\n        elif lcount + ucount > 0 and (lowcount == 0 or upcount == 0):\n            print(-1)\n        else:\n            print(max(lcount, ucount))", "T = int(input())\nfor i in range(T):\n    (N, Q) = list(map(int, input().split()))\n    nums = list(map(int, input().split()))\n    sorted_nums = sorted(nums)\n    sorted_index_map = {}\n    index_map = {}\n    for ind in range(N):\n        sorted_index_map[sorted_nums[ind]] = ind\n        index_map[nums[ind]] = ind\n    for j in range(Q):\n        X = int(input())\n        index_X = index_map[X]\n        low = 0\n        high = N - 1\n        count_low_needed = 0\n        count_high_needed = 0\n        count_low_minus = 0\n        count_high_minus = 0\n        total = 0\n        while low <= high:\n            mid = int((low + high) / 2)\n            if nums[mid] == X:\n                break\n            elif index_X > mid:\n                if nums[mid] > X:\n                    count_low_needed += 1\n                else:\n                    count_low_minus += 1\n                low = mid + 1\n            else:\n                if nums[mid] < X:\n                    count_high_needed += 1\n                else:\n                    count_high_minus += 1\n                high = mid - 1\n        if count_low_needed == 0 and count_high_needed == 0:\n            total = 0\n        else:\n            total_lows = sorted_index_map[X] - count_low_minus\n            total_highs = N - sorted_index_map[X] - 1 - count_high_minus\n            if count_low_needed - total_lows > 0 or count_high_needed - total_highs > 0:\n                total = -1\n            else:\n                total = max(count_low_needed, count_high_needed)\n        print(total)", "import copy\nt = int(input())\nfor j in range(t):\n    ans = []\n    inp = input().split()\n    n = int(inp[0])\n    q = int(inp[1])\n    arr = input().split()\n    arr = [int(x) for x in arr]\n    sorted = copy.deepcopy(arr)\n    sorted.sort()\n    index = {}\n    sortedIndex = {}\n    for i in range(n):\n        index[arr[i]] = i\n        sortedIndex[sorted[i]] = i\n    for i in range(q):\n        up = 0\n        down = 0\n        left = 0\n        right = 0\n        ele = int(input())\n        low = 0\n        high = n - 1\n        while low < high:\n            mid = int((low + high) / 2)\n            if arr[mid] == ele:\n                break\n            if arr[mid] > ele and mid < index[ele]:\n                up += 1\n                low = mid + 1\n            elif arr[mid] > ele and mid > index[ele]:\n                high = mid - 1\n                right += 1\n            elif arr[mid] < ele and mid < index[ele]:\n                left += 1\n                low = mid + 1\n            elif arr[mid] < ele and mid > index[ele]:\n                high = mid - 1\n                down += 1\n        if up > down:\n            if up + left <= sortedIndex[ele]:\n                ans.append(up)\n            else:\n                ans.append(-1)\n        elif down > up:\n            if down + right <= n - 1 - sortedIndex[ele]:\n                ans.append(down)\n            else:\n                ans.append(-1)\n        else:\n            ans.append(down)\n    for i in range(q):\n        print(ans[i])", "import copy\n\ndef binsearch(l, x, n):\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if l[mid][0] < x:\n            low = mid + 1\n        elif l[mid][0] > x:\n            high = mid - 1\n        else:\n            break\n    return mid\n\ndef fakebs(b, x, n, fakeindex, smallerElements, greaterElements):\n    low = 0\n    high = n - 1\n    smallerswap = 0\n    greaterswap = 0\n    check = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if b[mid] < x:\n            if fakeindex > mid:\n                low = mid + 1\n                smallerElements -= 1\n            else:\n                high = mid - 1\n                greaterswap += 1\n        elif b[mid] > x:\n            if fakeindex < mid:\n                high = mid - 1\n                greaterElements -= 1\n            else:\n                low = mid + 1\n                smallerswap += 1\n        else:\n            check = 1\n            break\n    if check == 0:\n        return 1\n    swaps = greaterswap - smallerswap\n    if swaps > 0:\n        greaterElements -= smallerswap\n        smallerElements -= smallerswap\n        if greaterElements >= swaps:\n            swaps += smallerswap\n        else:\n            swaps = -1\n    elif swaps < 0:\n        swaps *= -1\n        smallerElements -= greaterswap\n        greaterElements -= greaterswap\n        if smallerElements >= swaps:\n            swaps += greaterswap\n        else:\n            swaps = -1\n    else:\n        swaps = greaterswap\n    return swaps\nt = int(input())\nfor i in range(t):\n    (n, q) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = copy.deepcopy(a)\n    l = []\n    for k in range(n):\n        l.append([a[k], k])\n    l = sorted(l, key=lambda x: x[0])\n    for j in range(q):\n        x = int(input())\n        ix = binsearch(l, x, n)\n        fakeindex = l[ix][1]\n        smallerElements = ix\n        greaterElements = n - ix - 1\n        print(fakebs(b, x, n, fakeindex, smallerElements, greaterElements))", "import copy\n\ndef binsearch(l, x, n):\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if l[mid][0] < x:\n            low = mid + 1\n        elif l[mid][0] > x:\n            high = mid - 1\n        else:\n            break\n    return mid\n\ndef fakebs(b, x, n, fakeindex, smallerElements, greaterElements):\n    low = 0\n    high = n - 1\n    smallerswap = 0\n    greaterswap = 0\n    check = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if b[mid] < x:\n            if fakeindex > mid:\n                low = mid + 1\n                smallerElements -= 1\n            else:\n                high = mid - 1\n                greaterswap += 1\n        elif b[mid] > x:\n            if fakeindex < mid:\n                high = mid - 1\n                greaterElements -= 1\n            else:\n                low = mid + 1\n                smallerswap += 1\n        else:\n            check = 1\n            break\n    if check == 0:\n        return -2\n    swaps = greaterswap - smallerswap\n    if swaps > 0:\n        greaterElements -= smallerswap\n        smallerElements -= smallerswap\n        if greaterElements >= swaps:\n            swaps += smallerswap\n        else:\n            swaps = -1\n    elif swaps < 0:\n        swaps *= -1\n        smallerElements -= greaterswap\n        greaterElements -= greaterswap\n        if smallerElements >= swaps:\n            swaps += greaterswap\n        else:\n            swaps = -1\n    else:\n        swaps = greaterswap\n    return swaps\nt = int(input())\nfor i in range(t):\n    (n, q) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = copy.deepcopy(a)\n    l = []\n    for k in range(n):\n        l.append([a[k], k])\n    l = sorted(l, key=lambda x: x[0])\n    for j in range(q):\n        x = int(input())\n        ix = binsearch(l, x, n)\n        fakeindex = l[ix][1]\n        smallerElements = ix\n        greaterElements = n - ix - 1\n        print(fakebs(b, x, n, fakeindex, smallerElements, greaterElements))", "import copy\n\ndef binsearch(l, x, n):\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if l[mid][0] < x:\n            low = mid + 1\n        elif l[mid][0] > x:\n            high = mid - 1\n        else:\n            break\n    return mid\n\ndef fakebs(b, x, n, fakeindex, smallerElements, greaterElements):\n    low = 0\n    high = n - 1\n    smallerswap = 0\n    greaterswap = 0\n    check = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if b[mid] < x:\n            if fakeindex > mid:\n                low = mid + 1\n                smallerElements -= 1\n            else:\n                high = mid - 1\n                greaterswap += 1\n        elif b[mid] > x:\n            if fakeindex < mid:\n                high = mid - 1\n                greaterElements -= 1\n            else:\n                low = mid + 1\n                smallerswap += 1\n        else:\n            check = 1\n            break\n    if check == 0:\n        return -2\n    swaps = greaterswap - smallerswap\n    if swaps > 0:\n        greaterElements -= smallerswap\n        smallerElements -= smallerswap\n        if greaterElements >= swaps:\n            swaps += smallerswap\n        else:\n            swaps = -1\n    elif swaps < 0:\n        swaps *= -1\n        smallerElements -= greaterswap\n        greaterElements -= greaterswap\n        if smallerElements >= swaps:\n            swaps += greaterswap\n        else:\n            swaps = -1\n    else:\n        swaps = greaterswap\n    return swaps\nt = int(input())\nfor i in range(t):\n    (n, q) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = copy.deepcopy(a)\n    l = []\n    for k in range(n):\n        l.append([a[k], k])\n    l = sorted(l, key=lambda x: x[0])\n    for j in range(q):\n        x = int(input())\n        ix = binsearch(l, x, n)\n        fakeindex = l[ix][1]\n        smallerElements = ix\n        greaterElements = n - ix - 1\n        print(fakebs(b, x, n, fakeindex, smallerElements, greaterElements))", "def modified_binary(a, key, l, u):\n    while l <= u:\n        mid = (l + u) // 2\n        if a[mid][0] == key:\n            break\n        elif a[mid][0] > key:\n            u = mid - 1\n        else:\n            l = mid + 1\n    return [a[mid][1], mid]\nfor _ in range(int(input())):\n    (n, q) = [int(x) for x in input().split()]\n    a1 = input().split()\n    a = [[int(a1[x]), x] for x in range(n)]\n    e = sorted(a, key=lambda x: x[0])\n    m = []\n    for x in range(q):\n        m.append(int(input()))\n    for key in m:\n        p = 0\n        (index, left) = modified_binary(e, key, 0, n - 1)\n        right = n - 1 - left\n        ini = 0\n        last = n - 1\n        (l, r, h, u1, u2) = (0, 0, 0, 0, 0)\n        while last >= ini:\n            mid = (ini + last) // 2\n            if mid == index:\n                break\n            elif mid > index:\n                if a[mid][0] < key:\n                    r += 1\n                else:\n                    u2 += 1\n                last = mid - 1\n            else:\n                if a[mid][0] > key:\n                    l += 1\n                else:\n                    u1 += 1\n                ini = mid + 1\n            h += 1\n        if right - u2 >= r and left - u1 >= l:\n            swap = h - min(l, r) - u1 - u2\n            p = 1\n        if p == 1:\n            print(swap)\n        else:\n            print(-1)", "import collections\nT = int(input())\nfor _ in range(T):\n    (N, Q) = [int(i) for i in input().split()]\n    list = [int(i) for i in input().split()]\n    sorted_list = sorted(list)\n    numbers = {}\n    sorted_numbers = {}\n    j = 0\n    for i in list:\n        numbers.update({i: j})\n        j += 1\n    j = 0\n    for i in sorted_list:\n        sorted_numbers.update({i: j})\n        j += 1\n    for k in range(Q):\n        count1 = 0\n        count2 = 0\n        more = 0\n        less = 0\n        X = int(input())\n        index = numbers[X]\n        found = -1\n        a = 0\n        b = N - 1\n        while True:\n            mid = a + (b - a) // 2\n            if list[mid] == X:\n                break\n            elif index > mid and list[mid] > X:\n                count1 += 1\n                a = mid + 1\n                more += 1\n            elif index < mid and list[mid] < X:\n                count2 += 1\n                b = mid - 1\n                less += 1\n            elif index > mid and list[mid] < X:\n                less += 1\n                a = mid + 1\n            elif index < mid and list[mid] > X:\n                more += 1\n                b = mid - 1\n        index_sort = sorted_numbers[X]\n        check = False\n        if count2 > count1:\n            if count2 - count1 <= N - 1 - index_sort - more:\n                check = True\n        elif count2 < count1:\n            if count1 - count2 <= index_sort - less:\n                check = True\n        else:\n            check = True\n        if check:\n            print(max([count1, count2]))\n        else:\n            print('-1')", "t = int(input())\nfor i in range(t):\n    a = input()\n    b = a.split()\n    n = int(b[0])\n    q = int(b[1])\n    c = input()\n    d = c.split()\n    e = {}\n    ff = []\n    for j in range(n):\n        d[j] = int(d[j])\n        ff.append(int(d[j]))\n        e[int(d[j])] = j\n    d.sort()\n    g = {}\n    for l in range(n):\n        g[int(d[l])] = l\n    for k in range(q):\n        f = int(input())\n        low = 0\n        high = n - 1\n        swaps = 0\n        s1 = 0\n        s2 = 0\n        o = 0\n        big = n - g[f] - 1\n        small = g[f]\n        p = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if mid == e[f]:\n                break\n            elif ff[mid] > f and e[f] < mid:\n                big -= 1\n                high = mid - 1\n            elif ff[mid] < f and mid < e[f]:\n                small -= 1\n                low = mid + 1\n            elif ff[mid] > f and e[f] > mid:\n                s1 += 1\n                low = mid + 1\n            elif ff[mid] < f and e[f] < mid:\n                s2 += 1\n                high = mid - 1\n        swaps = min(s1, s2) + (max(s1, s2) - min(s1, s2))\n        if swaps <= min(small, big):\n            print(swaps)\n        else:\n            print(-1)", "import copy\n\ndef b_search(a, x, b, d_a, d_b, min_swap, max_swap, min_elem, max_elem):\n    low = 0\n    high = len(a) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if a[mid] == x:\n            break\n        elif a[mid] < x:\n            if d_a[x] >= mid + 1 and d_a[x] <= high:\n                low = mid + 1\n                min_elem += 1\n            else:\n                max_swap += 1\n                high = mid - 1\n        elif d_a[x] >= low and d_a[x] <= mid - 1:\n            high = mid - 1\n            max_elem += 1\n        else:\n            min_swap += 1\n            low = mid + 1\n    if d_b[x] - min_swap - min_elem >= 0 and d_b[x] + max_swap + max_elem <= len(a) - 1:\n        if min_swap >= max_swap:\n            return min_swap\n        else:\n            return max_swap\n    else:\n        return -1\nT = int(input())\nfor t in range(T):\n    [N, Q] = [int(i) for i in input().split(' ')]\n    a = [int(j) for j in input().split(' ')]\n    b = copy.deepcopy(a)\n    b.sort()\n    d_b = {}\n    for x in range(len(a)):\n        d_b[b[x]] = x\n    d_a = {}\n    for y in range(len(a)):\n        d_a[a[y]] = y\n    for q in range(Q):\n        X = int(input())\n        print(b_search(a, X, b, d_a, d_b, 0, 0, 0, 0))", "from collections import defaultdict\nT = int(input())\nfor t in range(T):\n    (n, Q) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    sorted_arr = sorted(arr)\n    indexes = defaultdict(list)\n    for i in range(n):\n        if arr[i] not in indexes:\n            indexes[arr[i]] = [-1, -1]\n        if sorted_arr[i] not in indexes:\n            indexes[sorted_arr[i]] = [-1, -1]\n        indexes[arr[i]][0] = i\n        indexes[sorted_arr[i]][1] = i\n    for q in range(Q):\n        x = int(input())\n        swaps = 0\n        indx = indexes[x][0]\n        need_large = 0\n        need_small = 0\n        safe_large = 0\n        safe_small = 0\n        low = 0\n        high = n - 1\n        while low <= high:\n            mid = int(low + (high - low) / 2)\n            if arr[mid] == x:\n                break\n            elif arr[mid] < x:\n                if indx < mid:\n                    need_large += 1\n                    high = mid - 1\n                else:\n                    safe_small += 1\n                    low = mid + 1\n            elif indx > mid:\n                need_small += 1\n                low = mid + 1\n            else:\n                safe_large += 1\n                high = mid - 1\n        swaps += min(need_large, need_small)\n        safe_small += swaps\n        safe_large += swaps\n        if need_large > need_small:\n            need = need_large - need_small\n            available = n - indexes[x][1] - 1 - safe_large\n            if available >= need:\n                swaps += need\n            else:\n                swaps = -1\n        elif need_large < need_small:\n            need = need_small - need_large\n            available = indexes[x][1] - safe_small\n            if available >= need:\n                swaps += need\n            else:\n                swaps = -1\n        print(swaps)", "from collections import defaultdict\nT = int(input())\nfor t in range(T):\n    (n, Q) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    if n <= 1000:\n        for q in range(Q):\n            x = int(input())\n            swaps = 0\n            indx = arr.index(x)\n            need_large = set()\n            need_small = set()\n            safe = set()\n            low = 0\n            high = n - 1\n            while low <= high:\n                mid = int(low + (high - low) / 2)\n                if arr[mid] == x:\n                    safe.add(mid)\n                    break\n                elif arr[mid] < x:\n                    if indx < mid:\n                        need_large.add(mid)\n                        high = mid - 1\n                    else:\n                        safe.add(mid)\n                        low = mid + 1\n                elif indx > mid:\n                    need_small.add(mid)\n                    low = mid + 1\n                else:\n                    safe.add(mid)\n                    high = mid - 1\n            while len(need_small) != 0 and len(need_large) != 0:\n                safe.add(need_small.pop())\n                safe.add(need_large.pop())\n                swaps += 1\n            else:\n                if len(need_small) == 0 and len(need_large) == 0:\n                    print(swaps)\n                    continue\n            large_available = set()\n            small_available = set()\n            for i in range(n):\n                if i not in safe:\n                    if arr[i] < x:\n                        if len(need_small) != 0:\n                            need_small.pop()\n                            swaps += 1\n                        elif len(need_large) == 0:\n                            break\n                    elif len(need_large) != 0:\n                        need_large.pop()\n                        swaps += 1\n                    elif len(need_small) == 0:\n                        break\n            if len(need_small) == 0 and len(need_large) == 0:\n                print(swaps)\n            else:\n                print(-1)\n    else:\n        sorted_arr = sorted(arr)\n        indexes = defaultdict(list)\n        for i in range(n):\n            if arr[i] not in indexes:\n                indexes[arr[i]] = [-1, -1]\n            if sorted_arr[i] not in indexes:\n                indexes[sorted_arr[i]] = [-1, -1]\n            indexes[arr[i]][0] = i\n            indexes[sorted_arr[i]][1] = i\n        for q in range(Q):\n            x = int(input())\n            swaps = 0\n            indx = indexes[x][0]\n            need_large = 0\n            need_small = 0\n            safe_large = 0\n            safe_small = 0\n            low = 0\n            high = n - 1\n            while low <= high:\n                mid = int(low + (high - low) / 2)\n                if arr[mid] == x:\n                    break\n                elif arr[mid] < x:\n                    if indx < mid:\n                        need_large += 1\n                        high = mid - 1\n                    else:\n                        safe_small += 1\n                        low = mid + 1\n                elif indx > mid:\n                    need_small += 1\n                    low = mid + 1\n                else:\n                    safe_large += 1\n                    high = mid - 1\n            swaps += min(need_large, need_small)\n            if need_large > need_small:\n                need = need_large - need_small\n                available = n - indexes[x][1] - 1 - safe_large\n                if available >= need:\n                    swaps += need\n                else:\n                    swaps = -1\n            elif need_large < need_small:\n                need = need_small - need_large\n                available = indexes[x][1] - safe_small\n                if available >= need:\n                    swaps += need\n                else:\n                    swaps = -1\n            print(swaps)", "for t in range(int(input())):\n    (N, Q) = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n    B = sorted(A)\n    D = {}\n    for i in range(len(A)):\n        D[A[i]] = [i]\n    for i in range(len(B)):\n        D[B[i]].append(i)\n    results = []\n    queries = [int(input()) for q in range(Q)]\n    for q in queries:\n        (low, high) = (1, N)\n        index = D[q][0] + 1\n        (back, forward) = ([], [])\n        maxswap = N - D[q][1] - 1\n        minswap = N - maxswap - 1\n        stop = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if mid == index:\n                break\n            elif mid > index:\n                high = mid - 1\n                if A[mid - 1] < q:\n                    forward.append(A[mid - 1])\n                else:\n                    maxswap -= 1\n            elif mid < index:\n                low = mid + 1\n                if A[mid - 1] > q:\n                    back.append(A[mid - 1])\n                else:\n                    minswap -= 1\n        (lenf, lenb) = (len(forward), len(back))\n        swap = min(lenf, lenb)\n        rest = max(lenf, lenb) - swap\n        (minswap, maxswap) = (minswap - swap, maxswap - swap)\n        swapspace = min(minswap, maxswap)\n        if swapspace < rest:\n            results.append(-1)\n            stop = 1\n        elif swapspace >= rest:\n            swap += rest\n        if not stop:\n            results.append(swap)\n    for result in results:\n        print(result)", "from copy import *\nt = int(input())\nfor i in range(t):\n    yoar = list(map(int, input().split()))\n    n = yoar[0]\n    q = yoar[1]\n    arr = list(map(int, input().split()))\n    dic = {}\n    for j in range(n):\n        dic[arr[j]] = j\n    sorarr = deepcopy(arr)\n    sorarr.sort()\n    dic1 = {}\n    for j in range(n):\n        dic1[sorarr[j]] = j\n    for j in range(q):\n        x = int(input())\n        if x not in dic:\n            print(0)\n            continue\n        ind = dic[x]\n        ind1 = dic1[x]\n        leftcont = ind1\n        rightcount = n - ind1 - 1\n        low = 0\n        high = n - 1\n        countbig = 0\n        countsmall = 0\n        ans = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if mid == ind:\n                break\n            elif mid < ind:\n                if arr[mid] > x:\n                    countsmall += 1\n                else:\n                    leftcont = leftcont - 1\n                low = mid + 1\n            elif mid > ind:\n                if arr[mid] < x:\n                    countbig += 1\n                else:\n                    rightcount = rightcount - 1\n                high = mid - 1\n        if countbig > rightcount:\n            ans = -1\n        elif countsmall > leftcont:\n            ans = -1\n        else:\n            ans = max(countbig, countsmall)\n        print(ans)", "import copy\n\ndef binary_search(a, b, C, n, k, x):\n    low = 0\n    z = n - k - 1\n    high = n - 1\n    c1 = 0\n    c2 = 0\n    flag = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if a[mid] == x:\n            break\n        elif a[mid] > x:\n            if mid < b[x]:\n                low = mid + 1\n                c1 += 1\n            else:\n                high = mid - 1\n                z -= 1\n        elif a[mid] < x:\n            if mid > b[x]:\n                high = mid - 1\n                c2 += 1\n            else:\n                low = mid + 1\n                k -= 1\n    if c1 <= k and c2 <= z:\n        return max(c1, c2)\n    else:\n        return -1\nT = int(input())\nfor t in range(T):\n    (N, Q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = {}\n    D = {}\n    C = sorted(A)\n    for n in range(N):\n        B[A[n]] = n\n        D[C[n]] = n\n    for q in range(Q):\n        X = int(input())\n        print(binary_search(A, B, C, N, D[X], X))", "def bs(a, n, x):\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if a[mid] == x:\n            break\n        elif a[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return mid\nt = int(input())\nfor _ in range(t):\n    (n, q) = input().split()\n    n = int(n)\n    q = int(q)\n    a = list(map(int, input().split()))\n    arr = list()\n    for i in range(n):\n        al = list()\n        al.append(a[i])\n        al.append(i)\n        arr.append(al)\n    b = list(a)\n    b.sort()\n    barr = list(arr)\n    barr.sort(key=lambda barr: barr[0])\n    for p in range(q):\n        qu = int(input())\n        index_sorted = bs(b, n, qu)\n        s = index_sorted\n        os = s\n        l = n - s - 1\n        ol = l\n        index_unsorted = barr[index_sorted][1]\n        low = 0\n        high = n - 1\n        flag = 0\n        sc = lc = 0\n        mid = (low + high) // 2\n        while low <= high:\n            if s == -1 or l == -1:\n                flag = 1\n                break\n            mid = (low + high) // 2\n            if mid == index_unsorted:\n                break\n            elif mid < index_unsorted:\n                if a[mid] > qu:\n                    sc = sc + 1\n                s = s - 1\n                low = mid + 1\n            else:\n                if a[mid] < qu:\n                    lc = lc + 1\n                l = l - 1\n                high = mid - 1\n        if flag == 1:\n            print(-1)\n        elif sc > lc:\n            print(sc)\n        else:\n            print(lc)", "t = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    ls = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[ls[i]] = i\n    sl = sorted(ls)\n    ds = {}\n    for i in range(n):\n        ds[sl[i]] = i\n    for __ in range(q):\n        x = int(input())\n        ind = d[x]\n        h = n - 1\n        l = 0\n        il = []\n        while h >= l:\n            m = h + l >> 1\n            il.append(m)\n            if m == ind:\n                break\n            elif m < ind:\n                l = m + 1\n            else:\n                h = m - 1\n        g = 0\n        l = 0\n        G = 0\n        L = 0\n        for i in range(len(il) - 1):\n            if il[i] > il[i + 1] and ls[il[i]] < x:\n                g += 1\n            elif il[i] > il[i + 1]:\n                G += 1\n            elif il[i] < il[i + 1] and ls[il[i]] > x:\n                l += 1\n            elif il[i] < il[i + 1]:\n                L += 1\n        ix = ds[x]\n        if ix >= l + L and n - ix - 1 >= g + G:\n            print(max(l, g))\n        else:\n            print(-1)", "t = int(input())\nfor a0 in range(t):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    dicta = {}\n    for i in range(n):\n        dicta[a[i]] = i\n    c = []\n    b = []\n    for i in range(n):\n        b.append(i)\n    d = []\n    for i in a:\n        d.append(i)\n    d.sort()\n    dictd = {}\n    for i in range(n):\n        dictd[d[i]] = i\n    for i in range(q):\n        num = int(input())\n        pos = dicta[num]\n        c = []\n        low = 0\n        high = n - 1\n        while low <= high:\n            mid = (low + high) // 2\n            c.append(b[mid])\n            if b[mid] == pos:\n                break\n            elif b[mid] < pos:\n                low = mid + 1\n            else:\n                high = mid - 1\n        ct1 = ct2 = ct3 = ct4 = 0\n        for i in range(len(c) - 1):\n            if c[i] < c[i + 1]:\n                if a[c[i]] > num:\n                    ct1 += 1\n                ct3 += 1\n            else:\n                if a[c[i]] < num:\n                    ct2 += 1\n                ct4 += 1\n        if ct3 <= dictd[num] and ct4 <= n - dictd[num] - 1:\n            print(max(ct1, ct2))\n        else:\n            print(-1)", "for i in range(0, int(input())):\n    lookUp = {}\n    lookUpSorted = {}\n    (N, Q) = map(int, input().split())\n    A = [int(i) for i in input().split()]\n    for (count, i) in enumerate(A):\n        lookUp[int(i)] = count\n    for (count, i) in enumerate(sorted(A)):\n        lookUpSorted[i] = count\n    B = [int(input()) for _ in range(Q)]\n    for snum in B:\n        ll = 0\n        ul = len(A) - 1\n        smallerSwapable = lookUpSorted[snum]\n        largerSwapable = len(A) - (lookUpSorted[snum] + 1)\n        incorrectRight = 0\n        incorrectLeft = 0\n        output = None\n        while ul >= ll:\n            mid = int((ul + ll) / 2)\n            if largerSwapable < 0 or smallerSwapable < 0:\n                output = -1\n                break\n            elif A[mid] == snum:\n                break\n            elif A[mid] > snum and mid > lookUp[snum]:\n                ul = mid - 1\n                largerSwapable -= 1\n            elif A[mid] > snum and mid < lookUp[snum]:\n                ll = mid + 1\n                smallerSwapable -= 1\n                incorrectLeft += 1\n            elif A[mid] < snum and mid < lookUp[snum]:\n                ll = mid + 1\n                smallerSwapable -= 1\n            elif A[mid] < snum and mid > lookUp[snum]:\n                ul = mid - 1\n                largerSwapable -= 1\n                incorrectRight += 1\n        if output == None:\n            print(abs(incorrectRight - incorrectLeft) + min(incorrectRight, incorrectLeft))\n        else:\n            print(output)", "def main():\n    t = int(input())\n    for _ in range(t):\n        (n, q) = map(int, input().split())\n        a = list(map(int, input().split()))\n        A = [*a]\n        mapp = dict()\n        for i in range(n):\n            mapp[a[i]] = [i]\n        a.sort()\n        for i in range(n):\n            mapp[a[i]].append(i)\n            mapp[a[i]].append(n - i - 1)\n        for _ in range(q):\n            x = int(input())\n            (mid, ans, low, high, Xi, g, l, L, G) = (0, 0, 0, n - 1, mapp[x][0], 0, 0, mapp[x][1], mapp[x][2])\n            while low <= high:\n                mid = low + (high - low) // 2\n                if Xi < mid:\n                    if A[mid] < x:\n                        if G > 0:\n                            g += 1\n                            G -= 1\n                        else:\n                            ans = -1\n                            break\n                    else:\n                        G -= 1\n                        if G < 0:\n                            ans = -1\n                            break\n                    high = mid - 1\n                elif Xi > mid:\n                    if A[mid] > x:\n                        if L > 0:\n                            l += 1\n                            L -= 1\n                        else:\n                            ans = -1\n                            break\n                    else:\n                        L -= 1\n                        if L < 0:\n                            ans = -1\n                            break\n                    low = mid + 1\n                else:\n                    break\n            if ans == -1:\n                print(-1)\n            else:\n                print(g if g > l else l)\nmain()", "T = int(input())\nfor cases in range(T):\n    (N, Q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    Asorted = A[:]\n    Asorted.sort()\n    pos = {}\n    Sortpos = {}\n    for i in range(N):\n        pos[A[i]] = i\n    for i in range(N):\n        Sortpos[Asorted[i]] = i\n    for i in range(Q):\n        X = int(input())\n        low = 0\n        high = N - 1\n        mid = (low + high) // 2\n        cg = 0\n        cl = 0\n        a = 0\n        b = 0\n        while low <= high and A[mid] != X:\n            mid = (low + high) // 2\n            if A[mid] > X:\n                if pos[X] > mid:\n                    cg += 1\n                    low = mid + 1\n                if pos[X] < mid:\n                    high = mid - 1\n                    b += 1\n            elif A[mid] < X:\n                if pos[X] > mid:\n                    low = mid + 1\n                    a += 1\n                if pos[X] < mid:\n                    cl += 1\n                    high = mid - 1\n        p = Sortpos[X]\n        if cg == cl:\n            print(cl)\n        elif cl > cg:\n            if cl + b <= N - p - 1:\n                print(cl)\n            else:\n                print(-1)\n        elif cg + a <= p:\n            print(cg)\n        else:\n            print(-1)", "import math\n\ndef binary_search(index, X, N, A, sortedA):\n    (lo, hi) = (1, N)\n    sortedIndex = -1\n    while lo <= hi:\n        mid = int((lo + hi) / 2)\n        if sortedA[mid] == X:\n            sortedIndex = mid\n            break\n        elif sortedA[mid] > X:\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    (lo, hi) = (1, N)\n    (lessThanXAvailableCount, largerThanXAvailableCount) = (sortedIndex - 1, N - sortedIndex)\n    (lessThanXRequiredCount, largerThanXRequiredCount) = (0, 0)\n    while lo <= hi:\n        mid = int((lo + hi) / 2)\n        if mid == index:\n            break\n        elif mid < index:\n            if A[mid] < X:\n                lessThanXAvailableCount -= 1\n            elif A[mid] > X:\n                lessThanXRequiredCount += 1\n            else:\n                print('CRAP')\n            lo = mid + 1\n        else:\n            if A[mid] > X:\n                largerThanXAvailableCount -= 1\n            elif A[mid] < X:\n                largerThanXRequiredCount += 1\n            else:\n                print('CRAP')\n            hi = mid - 1\n    if lessThanXRequiredCount <= lessThanXAvailableCount and largerThanXRequiredCount <= largerThanXAvailableCount:\n        return min(lessThanXRequiredCount, largerThanXRequiredCount) + (lessThanXRequiredCount - min(lessThanXRequiredCount, largerThanXRequiredCount)) + (largerThanXRequiredCount - min(lessThanXRequiredCount, largerThanXRequiredCount))\n    else:\n        return -1\nT = int(input())\nfor t in range(T):\n    (N, Q) = list(map(int, input().split()))\n    A = [0] + list(map(int, input().split()))\n    invA = dict()\n    for i in range(1, N + 1):\n        invA[A[i]] = i\n    sortedA = sorted(A)\n    for q in range(Q):\n        sol = -1\n        X = int(input())\n        index = -1\n        if X in invA:\n            index = invA[X]\n        if index >= 1 and index <= N:\n            sol = binary_search(index, X, N, A, sortedA)\n        print(sol)", "def inde(x, sarr):\n    (low, high) = (1, len(sarr))\n    while low <= high:\n        mid = (low + high) // 2\n        if sarr[mid][1] == x:\n            break\n        elif sarr[mid][1] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return mid\n\ndef swapcount(low, high, k, arr, grtmark, lessmark):\n    mid = (low + high) // 2\n    if mid == k or low > high:\n        return [0, 0, grtmark, lessmark]\n    elif mid > k and arr[mid] > x:\n        return swapcount(low, mid - 1, k, arr, grtmark + 1, lessmark)\n    elif mid > k and arr[mid] < x:\n        temp = swapcount(low, mid - 1, k, arr, grtmark, lessmark)\n        return [temp[0], temp[1] + 1, temp[2], temp[3]]\n    elif mid < k and arr[mid] < x:\n        return swapcount(mid + 1, high, k, arr, grtmark, lessmark + 1)\n    elif mid < k and arr[mid] > x:\n        temp = swapcount(mid + 1, high, k, arr, grtmark, lessmark)\n        return [temp[0] + 1, temp[1], temp[2], temp[3]]\nt = int(input())\nwhile t:\n    t -= 1\n    arr = [0]\n    sarr = list()\n    (n, q) = [int(nag) for nag in input().split()]\n    sat = [int(satish) for satish in input().split()]\n    arr += sat\n    for i2 in range(0, n + 1):\n        ltem = [i2, arr[i2]]\n        sarr.append(ltem)\n    sarr.sort(key=lambda x: x[1])\n    while q:\n        q -= 1\n        x = int(input())\n        pos = inde(x, sarr)\n        k = sarr[pos][0]\n        ans = swapcount(1, n, k, arr, 0, 0)\n        uless = pos - 1 - ans[3]\n        uhigh = n - pos - ans[2]\n        if uless >= ans[0] and uhigh >= ans[1]:\n            print(max(ans[0], ans[1]))\n        else:\n            print('-1')", "from sys import stdin\n\ndef binary_count(a, dorg, dinc, n, x):\n    low = 0\n    high = n - 1\n    smalln = dinc[x]\n    bign = n - 1 - dinc[x]\n    smallu = 0\n    bigu = 0\n    pos = dorg[x]\n    while low <= high:\n        mid = (low + high) // 2\n        if mid == pos:\n            return max(bigu, smallu)\n        elif a[mid] < x:\n            if mid < pos:\n                if smalln > 0:\n                    low = mid + 1\n                    smalln -= 1\n                else:\n                    break\n            elif bign > 0:\n                bigu += 1\n                bign -= 1\n                high = mid - 1\n            else:\n                break\n        elif mid > pos:\n            if bign > 0:\n                high = mid - 1\n                bign -= 1\n            else:\n                break\n        elif smalln > 0:\n            smallu += 1\n            smalln -= 1\n            low = mid + 1\n        else:\n            break\n    return -1\nfor _ in range(int(stdin.readline().strip())):\n    (n, q) = tuple(map(int, stdin.readline().split()))\n    a = list(map(int, stdin.readline().split()))\n    x = [int(stdin.readline().strip()) for i in range(q)]\n    da = {n: i for (i, n) in enumerate(a)}\n    a2 = sorted(a)\n    d2 = {n: i for (i, n) in enumerate(a2)}\n    print('\\n'.join([str(binary_count(a, da, d2, n, c)) for c in x]))", "for i in range(int(input())):\n    (n, q) = map(int, input().split())\n    l = list(map(int, input().split()))\n    d2 = {}\n    for j in range(n):\n        d2[l[j]] = j\n    arr = list(l)\n    arr.sort()\n    d1 = {}\n    for j in range(n):\n        d1[arr[j]] = j\n    for j in range(q):\n        x = int(input())\n        (g1, g3, l1, l3, start, end, index) = (0, 0, 0, 0, 0, n - 1, d2[x])\n        while start <= end:\n            mid = (start + end) // 2\n            if mid == index:\n                break\n            elif index > mid:\n                if l[mid] > x:\n                    l3 += 1\n                    g1 += 1\n                else:\n                    l1 += 1\n                start = mid + 1\n            else:\n                if l[mid] > x:\n                    g1 += 1\n                else:\n                    l1 += 1\n                    g3 += 1\n                end = mid - 1\n        g2 = n - 1 - d1[x] - g1\n        l2 = d1[x] - l1\n        ans = 0\n        f = 0\n        if g3 > 0 and l3 > 0:\n            x = min(g3, l3)\n            g3 -= x\n            l3 -= x\n            ans += x\n        if g3 > 0:\n            if g3 > g2:\n                f = 1\n            else:\n                ans += g3\n        if l3 > 0:\n            if l3 > l2:\n                f = 1\n            else:\n                ans += l3\n        if f == 0:\n            print(ans)\n        else:\n            print(-1)", "def fakebfs(orig_array, sorted_array, indices, sorted_indices, x, n, index):\n    index_in_sorted = sorted_indices[x]\n    small = index_in_sorted - 1\n    large = index_in_sorted + 1\n    low = 0\n    high = n - 1\n    count = 0\n    num_greater = 0\n    num_lesser = 0\n    while low <= high:\n        mid = int((low + high) / 2)\n        elem = orig_array[mid]\n        if elem == x:\n            if small < -1:\n                print(-1)\n                break\n            if large > n:\n                print(-1)\n                break\n            print(max(num_lesser, num_greater))\n            break\n        if index > mid:\n            low = mid + 1\n            if elem < x:\n                small -= 1\n                pass\n            elif small > -1:\n                small -= 1\n                num_lesser += 1\n            else:\n                small -= 1\n                pass\n        else:\n            high = mid - 1\n            if elem > x:\n                large += 1\n                pass\n            elif large < n:\n                num_greater += 1\n                large += 1\n            else:\n                large += 1\n                pass\ntest = int(input())\nfor t in range(test):\n    (n, q) = map(int, input().split())\n    orig_array = list(map(int, input().split()))\n    sorted_array = orig_array[:]\n    sorted_array.sort()\n    indices = dict()\n    sorted_indices = dict()\n    for i in range(len(sorted_array)):\n        indices[orig_array[i]] = i\n        sorted_indices[sorted_array[i]] = i\n    for i in range(q):\n        x = int(input())\n        fakebfs(orig_array, sorted_array, indices, sorted_indices, x, n, indices[x])", "def bst2(B, n, number):\n    l = 0\n    h = n - 1\n    while l <= h:\n        m = l + h >> 1\n        if B[m] == number:\n            return m\n        elif B[m] > number:\n            h = m - 1\n        else:\n            l = m + 1\n\ndef BST(A, n, index, i):\n    (l, h) = (0, n - 1)\n    lm = ln = 0\n    lm1 = ln1 = 0\n    while l <= h:\n        m = l + h >> 1\n        if m == index:\n            break\n        elif m < index:\n            l = m + 1\n            if A[m] > A[index]:\n                ln += 1\n            else:\n                ln1 += 1\n        else:\n            h = m - 1\n            if A[m] < A[index]:\n                lm += 1\n            else:\n                lm1 += 1\n    if ln <= i - ln1 and lm <= n - i - 1 - lm1:\n        return max(lm, ln)\n    return -1\nfor _ in range(int(input())):\n    memo = {}\n    (n, q) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = sorted(A)\n    for i in range(n):\n        memo[A[i]] = i\n    for _ in range(q):\n        x = int(input())\n        i = bst2(B, n, x)\n        print(BST(A, n, memo[x], i))", "def bst2(B, n, number):\n    l = 0\n    h = n - 1\n    while l <= h:\n        m = l + h >> 1\n        if B[m] == number:\n            return m\n        elif B[m] > number:\n            h = m - 1\n        else:\n            l = m + 1\n\ndef BST(A, n, index, i):\n    (l, h) = (0, n - 1)\n    lm = ln = 0\n    lm1 = ln1 = 0\n    while l <= h:\n        m = l + h >> 1\n        if m == index:\n            break\n        elif m < index:\n            l = m + 1\n            if A[m] > A[index]:\n                ln += 1\n            else:\n                ln1 += 1\n        else:\n            h = m - 1\n            if A[m] < A[index]:\n                lm += 1\n            else:\n                lm1 += 1\n    if ln <= i - ln1 and lm <= n - i - 1 - lm1:\n        return max(lm, ln)\n    return -1\nfor _ in range(int(input())):\n    memo = {}\n    (n, q) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = sorted(A)\n    for i in range(n):\n        memo[A[i]] = i\n    for _ in range(q):\n        x = int(input())\n        i = bst2(B, n, x)\n        print(BST(A, n, memo[x], i))", "t = int(input())\nfor m in range(t):\n    (n, q) = map(int, input().split())\n    arr = [int(x) for x in input().split()]\n    grap = {}\n    for i in range(n):\n        grap[arr[i]] = i\n    arr2 = sorted(arr)\n    grap2 = {}\n    for i in range(n):\n        grap2[arr2[i]] = i\n    for l in range(q):\n        x = int(input())\n        low = 0\n        high = n - 1\n        left = 0\n        right = 0\n        flag = 0\n        swap = 0\n        mini_ele = grap2[x]\n        maxi_ele = n - 1 - grap2[x]\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                break\n            elif grap[x] > mid:\n                if arr[mid] < x:\n                    low = mid + 1\n                else:\n                    if right == 0:\n                        swap += 1\n                        left += 1\n                    else:\n                        right -= 1\n                    low = mid + 1\n                mini_ele -= 1\n                if mini_ele < 0:\n                    flag = 1\n                    break\n            else:\n                if arr[mid] > x:\n                    high = mid - 1\n                else:\n                    if left == 0:\n                        swap += 1\n                        right += 1\n                    else:\n                        left -= 1\n                    high = mid - 1\n                maxi_ele -= 1\n                if maxi_ele < 0:\n                    flag = 1\n                    break\n        if flag == 1:\n            print(-1)\n        else:\n            print(swap)", "def binary(a, n, x):\n    low = 0\n    high = n - 1\n    pos = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if a[mid] == x:\n            pos = 1\n            break\n        elif a[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return (mid, pos)\n\ndef spbinary(a, a1, n, x, x1):\n    low = 0\n    high = n - 1\n    small = []\n    great = []\n    cs = 0\n    cg = 0\n    cis = 0\n    cig = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if a[mid] == x:\n            pos = 1\n            break\n        elif a[mid] < x:\n            low = mid + 1\n            if a1[mid] < x1:\n                cis += 1\n            else:\n                cs += 1\n        else:\n            high = mid - 1\n            if a1[mid] > x1:\n                cig += 1\n            else:\n                cg += 1\n    return (cg, cs, cig, cis)\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    s = []\n    for i in range(1, n + 1):\n        s.append(i)\n    a = list(map(int, input().split()))\n    d = {}\n    index = []\n    sorte = sorted(a)\n    dsorte = {}\n    for i in range(n):\n        d[a[i]] = i\n        index.append(i)\n        dsorte[sorte[i]] = i\n    for b in range(q):\n        x = int(input())\n        (mid, pos) = binary(a, n, x)\n        if pos == 1:\n            print(0)\n        else:\n            ptr = d[x]\n            smaller = []\n            greater = []\n            (cg, cs, cig, cis) = spbinary(index, a, n, ptr, x)\n            big = n - dsorte[x] - 1\n            less = dsorte[x]\n            big -= cig\n            less -= cis\n            if less >= cs and big >= cg:\n                if max(cs, cg) <= min(less, big):\n                    res = max(cs, cg)\n                    print(res)\n                else:\n                    print('-1')\n            else:\n                print('-1')", "def Bin(arr, lo, hi, x):\n    res = False\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] == x:\n            res = True\n            break\n        elif arr[mid] < x:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return res\n\ndef Function(arr, new, dict, low, high, x):\n    count = 0\n    count_1 = 0\n    count_2 = 0\n    count_3 = 0\n    count_4 = 0\n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] > x and mid < new[x]:\n            low = mid + 1\n            count_1 += 1\n        elif arr[mid] < x and mid > new[x]:\n            high = mid - 1\n            count_2 += 1\n        elif arr[mid] > x and mid > new[x]:\n            high = mid - 1\n            count_4 += 1\n        elif arr[mid] < x and mid < new[x]:\n            low = mid + 1\n            count_3 += 1\n        else:\n            break\n    ans = max(count_1, count_2)\n    if count_1 > dict[x] - count_3 or count_2 > n - dict[x] - 1 - count_4:\n        ans = -1\n    return ans\nt = int(input())\nfor i1 in range(t):\n    (n, q) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    new = {}\n    t1 = 0\n    for i in arr:\n        new[i] = t1\n        t1 += 1\n    dict = {}\n    index = 0\n    y = arr[:]\n    y = sorted(y)\n    for i in y:\n        dict[i] = index\n        index += 1\n    for i in range(q):\n        x = int(input())\n        r1 = Bin(y, 0, n - 1, x)\n        r2 = Bin(arr, 0, n - 1, x)\n        if r1 == r2:\n            print('0')\n        elif r1 == True and r2 == False:\n            print(Function(arr, new, dict, 0, n - 1, x))", "t = int(input())\nfor _ in range(t):\n    (n, q) = input().split()\n    n = int(n)\n    q = int(q)\n    a = list(map(int, input().split()))\n    b = list(a)\n    b.sort()\n    d = {}\n    small = {}\n    big = {}\n    for i in range(n):\n        d[a[i]] = i\n        small[b[i]] = i\n        big[b[i]] = n - i - 1\n    for test in range(q):\n        x = int(input())\n        low = 0\n        high = n - 1\n        count_small = 0\n        count_big = 0\n        check_small = 0\n        check_big = 0\n        flag = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if a[mid] == x:\n                break\n            elif x > a[mid] and d[x] > d[a[mid]]:\n                if small[x] > check_small:\n                    check_small += 1\n                    low = mid + 1\n                else:\n                    flag = 1\n                    break\n            elif x < a[mid] and d[x] < d[a[mid]]:\n                if big[x] > check_big:\n                    check_big += 1\n                    high = mid - 1\n                else:\n                    flag = 1\n                    break\n            elif x > a[mid] and d[x] < d[a[mid]]:\n                if big[x] > check_big:\n                    high = mid - 1\n                    count_big += 1\n                    check_big += 1\n                else:\n                    flag = 1\n                    break\n            elif x < a[mid] and d[x] > d[a[mid]]:\n                if small[x] > check_small:\n                    low = mid + 1\n                    count_small += 1\n                    check_small += 1\n                else:\n                    flag = 1\n                    break\n        if flag == 1:\n            print('-1')\n        else:\n            print(max(count_big, count_small))", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = []\n    for i in a:\n        b.append(i)\n    b.sort()\n    les = {}\n    p = 0\n    for i in b:\n        les[i] = p\n        p += 1\n    di = {}\n    for i in range(n):\n        di[a[i]] = i\n    for i in range(q):\n        x = int(input())\n        (k1, k2, k3, k4) = (0, 0, 0, 0)\n        actual = di[x]\n        start = 0\n        end = n - 1\n        while start < end:\n            mid = (start + end) // 2\n            if mid == actual:\n                break\n            elif mid < actual:\n                if a[mid] > x:\n                    k1 += 1\n                else:\n                    k3 += 1\n                start = mid + 1\n            else:\n                if a[mid] < x:\n                    k2 += 1\n                else:\n                    k4 += 1\n                end = mid - 1\n        k = max(k1, k2)\n        if k1 > les[x] - k3 or k2 > n - les[x] - 1 - k4:\n            k = -1\n        print(k)", "def createParentArray(a, l, r, root, p):\n    if l > r:\n        return\n    mid = (l + r) // 2\n    p[mid] = root\n    createParentArray(a, l, mid - 1, mid, p)\n    createParentArray(a, mid + 1, r, mid, p)\n\ndef getAns(a, p, idx, left, right):\n    i = idx\n    base = a[idx]\n    cnt = 0\n    lt_base = 0\n    gt_base = 0\n    while p[i] != -1:\n        if i < p[i]:\n            if base > a[p[i]]:\n                lt_base += 1\n                left -= 1\n            else:\n                right -= 1\n        elif i > p[i]:\n            if base < a[p[i]]:\n                gt_base += 1\n                right -= 1\n            else:\n                left -= 1\n        i = p[i]\n    cnt += min(lt_base, gt_base)\n    lt_base -= cnt\n    gt_base -= cnt\n    if lt_base <= right:\n        cnt += lt_base\n    else:\n        return -1\n    if gt_base <= left:\n        cnt += gt_base\n    else:\n        return -1\n    return cnt\n\ndef solve():\n    (n, q) = [int(x) for x in input().strip().split()]\n    a = [int(x) for x in input().strip().split()]\n    p = [0 for x in range(n)]\n    createParentArray(a, 0, n - 1, -1, p)\n    b = sorted(a)\n    h = dict()\n    for i in range(n):\n        h[a[i]] = i\n    for i in range(n):\n        h[b[i]] = (h[b[i]], i, n - 1 - i)\n    ans = dict()\n    for i in range(q):\n        x = int(input())\n        if x in ans:\n            print(ans[x])\n            continue\n        (idx, left, right) = h[x]\n        ans[x] = getAns(a, p, idx, left, right)\n        print(ans[x])\n\ndef main():\n    t = int(input())\n    while t > 0:\n        solve()\n        t -= 1\nmain()", "def createParentArray(a, l, r, root, p):\n    if l > r:\n        return\n    mid = (l + r) // 2\n    p[mid] = root\n    createParentArray(a, l, mid - 1, mid, p)\n    createParentArray(a, mid + 1, r, mid, p)\n\ndef getAns(a, p, idx, left, right):\n    i = idx\n    base = a[idx]\n    cnt = 0\n    lt_base = 0\n    gt_base = 0\n    while p[i] != -1:\n        if i < p[i]:\n            if base > a[p[i]]:\n                lt_base += 1\n                left -= 1\n            else:\n                right -= 1\n        elif i > p[i]:\n            if base < a[p[i]]:\n                gt_base += 1\n                right -= 1\n            else:\n                left -= 1\n        i = p[i]\n    cnt += min(lt_base, gt_base)\n    lt_base -= cnt\n    gt_base -= cnt\n    if lt_base <= right:\n        cnt += lt_base\n    else:\n        return -1\n    if gt_base <= left:\n        cnt += gt_base\n    else:\n        return -1\n    return cnt\n\ndef solve():\n    (n, q) = [int(x) for x in input().strip().split()]\n    a = [int(x) for x in input().strip().split()]\n    p = [0 for x in range(n)]\n    createParentArray(a, 0, n - 1, -1, p)\n    b = sorted(a)\n    h = dict()\n    for i in range(n):\n        h[a[i]] = i\n    for i in range(n):\n        h[b[i]] = (h[b[i]], i, n - 1 - i)\n    for i in range(q):\n        x = int(input())\n        (idx, left, right) = h[x]\n        ans = getAns(a, p, idx, left, right)\n        print(ans)\n\ndef main():\n    t = int(input())\n    while t > 0:\n        solve()\n        t -= 1\nmain()", "def binary_search(a, n, x):\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if a[mid][0] == x:\n            break\n        elif a[mid][0] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return mid\n\ndef fake_binary_search(a, b, n, x):\n    low = 0\n    high = n - 1\n    swap = 0\n    swap1 = 0\n    swap2 = 0\n    t2 = binary_search(b, n, x)\n    t1 = t2\n    t = b[t2][1]\n    while low <= high:\n        mid = (low + high) // 2\n        if a[mid][0] == x:\n            break\n        elif a[mid][0] < x:\n            if mid > t:\n                if swap2 > 0:\n                    swap2 -= 1\n                else:\n                    swap += 1\n                    swap1 += 1\n                high = mid - 1\n            else:\n                t2 -= 1\n                low = mid + 1\n        elif mid < t:\n            if swap1 > 0:\n                swap1 -= 1\n            else:\n                swap2 += 1\n                swap += 1\n            low = mid + 1\n        else:\n            t1 += 1\n            high = mid - 1\n    if swap > t2 or swap > n - 1 - t1:\n        swap = -1\n    return swap\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    for i in range(n):\n        A[i] = [A[i], i]\n    B = sorted(A)\n    for i in range(q):\n        x = int(input())\n        print(fake_binary_search(A, B, n, x))", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    hm1 = {}\n    arr = []\n    brr = []\n    arr = list(map(int, input().split()))\n    brr = arr[:]\n    brr.sort()\n    for i in range(n):\n        hm1[arr[i]] = [0, 0]\n    for i in range(n):\n        hm1[arr[i]][0] = i\n        hm1[brr[i]][1] = i\n    for i in range(q):\n        inp = int(input())\n        x = hm1[inp][0]\n        st = 0\n        en = n - 1\n        count = 0\n        al = []\n        while st <= en:\n            mid = (en + st) // 2\n            al.append(mid)\n            if mid == x:\n                break\n            elif x > mid:\n                st = mid + 1\n            else:\n                en = mid - 1\n        al.sort()\n        val1 = arr[x]\n        ind1 = hm1[val1][1]\n        ind2 = 0\n        flag = 0\n        c1 = 0\n        c2 = 0\n        for j in range(len(al)):\n            if arr[al[j]] == val1:\n                ind2 = j\n                flag = 1\n                continue\n            if flag == 0 and arr[al[j]] > val1:\n                c1 += 1\n            elif flag == 1 and arr[al[j]] < val1:\n                c2 += 1\n        if c1 > c2:\n            count += c1\n        else:\n            count += c2\n        if ind1 >= ind2 and len(arr) - ind1 >= len(al) - ind2:\n            print(count)\n        else:\n            print(-1)", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    hm1 = {}\n    arr = []\n    brr = []\n    arr = list(map(int, input().split()))\n    brr = arr[:]\n    brr.sort()\n    for i in range(n):\n        hm1[arr[i]] = [0, 0]\n    for i in range(n):\n        hm1[arr[i]][0] = i\n        hm1[brr[i]][1] = i\n    for i in range(q):\n        inp = int(input())\n        x = hm1[inp][0]\n        st = 0\n        en = n - 1\n        count = 0\n        al = []\n        while st <= en:\n            mid = (en + st) // 2\n            al.append(mid)\n            if mid == x:\n                break\n            elif x > mid:\n                st = mid + 1\n            else:\n                en = mid - 1\n        al.sort()\n        val1 = arr[x]\n        ind1 = hm1[val1][1]\n        ind2 = 0\n        flag = 0\n        c1 = 0\n        c2 = 0\n        for j in range(len(al)):\n            if arr[al[j]] == val1:\n                ind2 = j\n                flag = 1\n                continue\n            if flag == 0 and arr[al[j]] > val1:\n                c1 += 1\n            elif flag == 1 and arr[al[j]] < val1:\n                c2 += 1\n        if c1 > c2:\n            count += c1\n        else:\n            count += c2\n        if ind1 >= ind2 and len(arr) - ind1 >= len(al) - ind2:\n            print(count)\n        else:\n            print(-1)", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    hm1 = {}\n    arr = []\n    brr = []\n    arr = list(map(int, input().split()))\n    brr = arr[:]\n    brr.sort()\n    for i in range(n):\n        hm1[arr[i]] = [0, 0]\n    for i in range(n):\n        hm1[arr[i]][0] = i\n        hm1[brr[i]][1] = i\n    for i in range(q):\n        inp = int(input())\n        x = hm1[inp][0]\n        st = 0\n        en = n - 1\n        count = 0\n        al = []\n        while st <= en:\n            mid = (en + st) // 2\n            al.append(mid)\n            if mid == x:\n                break\n            elif x > mid:\n                st = mid + 1\n            else:\n                en = mid - 1\n        al.sort()\n        val1 = arr[x]\n        ind1 = hm1[val1][1]\n        ind2 = 0\n        flag = 0\n        c1 = 0\n        c2 = 0\n        for j in range(len(al)):\n            if arr[al[j]] == val1:\n                ind2 = j\n                flag = 1\n                continue\n            if flag == 0 and arr[al[j]] > val1:\n                c1 += 1\n            elif flag == 1 and arr[al[j]] < val1:\n                c2 += 1\n        if c1 > c2:\n            count += c1\n        else:\n            count += c2\n        if ind1 >= ind2 and len(arr) - ind1 >= len(al) - ind2:\n            print(count)\n        else:\n            print(-1)", "def binarySearchMain(sm, value, num):\n    l = 0\n    r = num - 1\n    m = 0\n    while l <= r:\n        m = (l + r) // 2\n        if sm[m] == value:\n            return m\n        elif sm[m] > value:\n            r = m - 1\n        elif sm[m] < value:\n            l = m + 1\n\ndef binarySearch(value, num):\n    l = 0\n    r = num - 1\n    countL = 0\n    countR = 0\n    rightL = 0\n    rightR = 0\n    while l <= r:\n        m = (l + r) // 2\n        if m + 1 == value:\n            break\n        elif m + 1 > value:\n            if array[m] > qi:\n                rightL += 1\n            countL += 1\n            r = m - 1\n        elif m + 1 < value:\n            if array[m] < qi:\n                rightR += 1\n            countR += 1\n            l = m + 1\n    return [countL, countR, rightL, rightR]\ntc = int(input())\nwhile tc > 0:\n    (n, q) = map(int, input().split())\n    array = list(map(int, input().split()))\n    d = {}\n    for k in range(n):\n        d[array[k]] = k + 1\n    array2 = sorted(array)\n    if n <= 10:\n        pos1 = -1\n        while q > 0:\n            qi = int(input())\n            pos1 = d[qi]\n            a = binarySearch(pos1, n)\n            flag = 1\n            i = binarySearchMain(array2, qi, n)\n            if a[0] > n - i - 1 or a[2] > n - i - 1 or a[1] > i or (a[3] > i):\n                flag = 0\n            if flag == 0:\n                print(-1)\n            else:\n                print(max(a[0] - a[2], a[1] - a[3]))\n            q -= 1\n    else:\n        pos = -1\n        while q > 0:\n            qi = int(input())\n            pos1 = d[qi]\n            a = binarySearch(pos1, n)\n            flag = 1\n            i = binarySearchMain(array2, qi, n)\n            if a[0] > n - i - 1 or a[2] > n - i - 1 or a[1] > i or (a[3] > i):\n                flag = 0\n            if flag == 0:\n                print(-1)\n            else:\n                print(max(a[0] - a[2], a[1] - a[3]))\n            q -= 1\n    tc -= 1", "def path(arr, n, x):\n    l = 0\n    h = n - 1\n    left = []\n    right = []\n    while l <= h:\n        m = (l + h) // 2\n        if arr[m] == x:\n            break\n        elif arr[m] > x:\n            left.append(arr[m])\n            h = m - 1\n        else:\n            right.append(arr[m])\n            l = m + 1\n    return (left, right)\nt = int(input())\nfor z in range(t):\n    l = [int(a) for a in input().split()]\n    n = l[0]\n    q = l[1]\n    ad = [int(s) for s in input().split()]\n    arr = [-1] * n\n    dict2 = {}\n    b = sorted(ad)\n    for i in range(n):\n        dict2[b[i]] = i\n        arr[i] = i\n    swaps = [-1] * n\n    for i in range(n):\n        x = ad[i]\n        pos = i\n        ps = dict2[x]\n        pl = ps\n        ph = n - 1 - ps\n        l = 0\n        h = n - 1\n        kl = 0\n        kh = 0\n        can = 1\n        (left, right) = path(arr, n, pos)\n        nl = len(left)\n        nr = len(right)\n        if nl > ph or nr > pl:\n            can = 0\n        while l <= h:\n            m = (l + h) // 2\n            if pos == m:\n                break\n            if pos > m:\n                if x < ad[m]:\n                    kl += 1\n                l = m + 1\n            else:\n                if x > ad[m]:\n                    kh += 1\n                h = m - 1\n        if can == 0:\n            swaps[ps] = -1\n        else:\n            swaps[ps] = max(kh, kl)\n    for y in range(q):\n        z = int(input())\n        print(swaps[dict2[z]])", "def path(arr, n, x):\n    l = 0\n    h = n - 1\n    left = []\n    right = []\n    while l <= h:\n        m = (l + h) // 2\n        if arr[m] == x:\n            break\n        elif arr[m] > x:\n            left.append(arr[m])\n            h = m - 1\n        else:\n            right.append(arr[m])\n            l = m + 1\n    return (left, right)\nt = int(input())\nfor z in range(t):\n    l = [int(a) for a in input().split()]\n    n = l[0]\n    q = l[1]\n    ad = [int(s) for s in input().split()]\n    arr = [-1] * n\n    dict2 = {}\n    b = sorted(ad)\n    for i in range(n):\n        dict2[b[i]] = i\n        arr[i] = i\n    swaps = [-1] * n\n    for i in range(n):\n        x = ad[i]\n        pos = i\n        ps = dict2[x]\n        pl = ps\n        ph = n - 1 - ps\n        l = 0\n        h = n - 1\n        kl = 0\n        kh = 0\n        can = 1\n        (left, right) = path(arr, n, pos)\n        nl = len(left)\n        nr = len(right)\n        if nl > ph or nr > pl:\n            can = 0\n        while l <= h:\n            m = (l + h) // 2\n            if pos == m:\n                break\n            if pos > m:\n                if x < ad[m]:\n                    kl += 1\n                l = m + 1\n            else:\n                if x > ad[m]:\n                    kh += 1\n                h = m - 1\n        if can == 0:\n            swaps[ps] = -1\n        else:\n            swaps[ps] = kh + kl - min(kh, kl)\n    for y in range(q):\n        z = int(input())\n        print(swaps[dict2[z]])", "for t in range(int(input())):\n    (n, q) = [int(x) for x in input().strip().split()]\n    a = [int(x) for x in input().strip().split()]\n    d = {ai: i for (i, ai) in enumerate(a)}\n    b = {ai: i for (i, ai) in enumerate(sorted(a))}\n    for query in range(q):\n        x = int(input())\n        need_above = 0\n        need_below = 0\n        used_above = 0\n        used_below = 0\n        low = 1\n        high = n\n        while True:\n            mid = (low + high) // 2\n            if a[mid - 1] == x:\n                break\n            elif a[mid - 1] < x:\n                if d[x] > mid - 1:\n                    low = mid + 1\n                    used_below += 1\n                else:\n                    high = mid - 1\n                    need_above += 1\n            elif d[x] > mid - 1:\n                low = mid + 1\n                need_below += 1\n            else:\n                high = mid - 1\n                used_above += 1\n        if need_below + used_below > b[x] or need_above + used_above > n - 1 - b[x]:\n            print(-1)\n        else:\n            print(max(need_below, need_above))", "def path(arr, n, x):\n    l = 0\n    h = n - 1\n    left = []\n    right = []\n    while l <= h:\n        m = (l + h) // 2\n        if arr[m] == x:\n            break\n        elif arr[m] > x:\n            left.append(arr[m])\n            h = m - 1\n        else:\n            right.append(arr[m])\n            l = m + 1\n    return (left, right)\nt = int(input())\nfor z in range(t):\n    l = [int(a) for a in input().split()]\n    n = l[0]\n    q = l[1]\n    ad = [int(s) for s in input().split()]\n    arr = [-1] * n\n    dict2 = {}\n    b = sorted(ad)\n    for i in range(n):\n        dict2[b[i]] = i\n        arr[i] = i\n    swaps = [-1] * n\n    for i in range(n):\n        x = ad[i]\n        pos = i\n        ps = dict2[x]\n        pl = ps\n        ph = n - 1 - ps\n        l = 0\n        h = n - 1\n        kl = 0\n        kh = 0\n        can = 1\n        (left, right) = path(arr, n, pos)\n        nl = len(left)\n        nr = len(right)\n        if nl > ph or nr > pl:\n            can = 0\n        while l <= h:\n            m = (l + h) // 2\n            if pos == m:\n                break\n            if pos > m:\n                if x < ad[m]:\n                    kl += 1\n                l = m + 1\n            else:\n                if x > ad[m]:\n                    kh += 1\n                h = m - 1\n        if can == 0:\n            swaps[ps] = -1\n        else:\n            swaps[ps] = kh + kl - min(kh, kl)\n    for y in range(q):\n        z = int(input())\n        print(swaps[dict2[z]])", "def path(arr, n, x):\n    l = 0\n    h = n - 1\n    left = []\n    right = []\n    while l <= h:\n        m = (l + h) // 2\n        if arr[m] == x:\n            break\n        elif arr[m] > x:\n            left.append(arr[m])\n            h = m - 1\n        else:\n            right.append(arr[m])\n            l = m + 1\n    return (left, right)\nt = int(input())\nfor z in range(t):\n    l = [int(a) for a in input().split()]\n    n = l[0]\n    q = l[1]\n    ad = [int(s) for s in input().split()]\n    arr = [-1] * n\n    dict2 = {}\n    b = sorted(ad)\n    for i in range(n):\n        dict2[b[i]] = i\n        arr[i] = i\n    swaps = [-1] * n\n    for i in range(n):\n        x = ad[i]\n        pos = i\n        ps = dict2[x]\n        pl = ps\n        ph = n - 1 - ps\n        l = 0\n        h = n - 1\n        kl = 0\n        kh = 0\n        can = 1\n        (left, right) = path(arr, n, pos)\n        nl = len(left)\n        nr = len(right)\n        if nl > ph or nr > pl:\n            can = 0\n        while l <= h:\n            m = (l + h) // 2\n            if pos == m:\n                break\n            if pos > m:\n                if x < ad[m]:\n                    kl += 1\n                l = m + 1\n            else:\n                if x > ad[m]:\n                    kh += 1\n                h = m - 1\n        if can == 0:\n            swaps[ps] = -1\n        else:\n            swaps[ps] = kh + kl - min(kh, kl)\n    for y in range(q):\n        z = int(input())\n        print(swaps[dict2[z]])", "def path(arr, n, x):\n    l = 0\n    h = n - 1\n    left = []\n    right = []\n    while l <= h:\n        m = (l + h) // 2\n        if arr[m] == x:\n            break\n        elif arr[m] > x:\n            left.append(arr[m])\n            h = m - 1\n        else:\n            right.append(arr[m])\n            l = m + 1\n    return (left, right)\nt = int(input())\nfor z in range(t):\n    l = [int(a) for a in input().split()]\n    n = l[0]\n    q = l[1]\n    ad = [int(s) for s in input().split()]\n    arr = [-1] * n\n    dict2 = {}\n    b = sorted(ad)\n    for i in range(n):\n        dict2[b[i]] = i\n        arr[i] = i\n    swaps = [-1] * n\n    for i in range(n):\n        x = ad[i]\n        pos = i\n        ps = dict2[x]\n        pl = ps\n        ph = n - 1 - ps\n        l = 0\n        h = n - 1\n        kl = 0\n        kh = 0\n        can = 1\n        (left, right) = path(arr, n, pos)\n        nl = len(left)\n        nr = len(right)\n        if nl > ph or nr > pl:\n            can = 0\n        while l <= h:\n            m = (l + h) // 2\n            if pos == m:\n                break\n            if pos > m:\n                if x < ad[m]:\n                    kl += 1\n                l = m + 1\n            else:\n                if x > ad[m]:\n                    kh += 1\n                h = m - 1\n        if can == 0:\n            swaps[ps] = -1\n        else:\n            swaps[ps] = kh + kl - min(kh, kl)\n    for y in range(q):\n        z = int(input())\n        print(swaps[dict2[z]])", "def path(arr, n, x):\n    l = 0\n    h = n - 1\n    left = []\n    right = []\n    while l <= h:\n        m = (l + h) // 2\n        if arr[m] == x:\n            break\n        elif arr[m] > x:\n            left.append(arr[m])\n            h = m - 1\n        else:\n            right.append(arr[m])\n            l = m + 1\n    return (left, right)\nt = int(input())\nfor z in range(t):\n    l = [int(a) for a in input().split()]\n    n = l[0]\n    q = l[1]\n    ad = [int(s) for s in input().split()]\n    arr = [-1] * n\n    dict2 = {}\n    b = sorted(ad)\n    for i in range(n):\n        dict2[b[i]] = i\n        arr[i] = i\n    swaps = [-1] * n\n    for i in range(n):\n        x = ad[i]\n        pos = i\n        ps = dict2[x]\n        pl = ps\n        ph = n - 1 - ps\n        l = 0\n        h = n - 1\n        kl = 0\n        kh = 0\n        can = 1\n        (left, right) = path(arr, n, pos)\n        nl = len(left)\n        nr = len(right)\n        if nl > ph or nr > pl:\n            can = 0\n        while l <= h:\n            m = (l + h) // 2\n            if pos == m:\n                break\n            if pos > m:\n                if x < ad[m]:\n                    kl += 1\n                l = m + 1\n            else:\n                if x > ad[m]:\n                    kh += 1\n                h = m - 1\n        if can == 0:\n            swaps[ps] = -1\n        else:\n            swaps[ps] = kh + kl - min(kh, kl)\n    for y in range(q):\n        z = int(input())\n        print(swaps[dict2[z]])", "def path(arr, n, x):\n    l = 0\n    h = n - 1\n    left = []\n    right = []\n    while l <= h:\n        m = (l + h) // 2\n        if arr[m] == x:\n            break\n        elif arr[m] > x:\n            left.append(arr[m])\n            h = m - 1\n        else:\n            right.append(arr[m])\n            l = m + 1\n    return (left, right)\nt = int(input())\nfor z in range(t):\n    l = [int(a) for a in input().split()]\n    n = l[0]\n    q = l[1]\n    ad = [int(s) for s in input().split()]\n    arr = [-1] * n\n    dict2 = {}\n    b = sorted(ad)\n    for i in range(n):\n        dict2[b[i]] = i\n        arr[i] = i\n    swaps = [-1] * n\n    for i in range(n):\n        x = ad[i]\n        pos = i\n        ps = dict2[x]\n        pl = ps\n        ph = n - 1 - ps\n        l = 0\n        h = n - 1\n        kl = 0\n        kh = 0\n        can = 1\n        (left, right) = path(arr, n, pos)\n        nl = len(left)\n        nr = len(right)\n        if nl > ph or nr > pl:\n            can = 0\n        while l <= h:\n            m = (l + h) // 2\n            if pos == m:\n                break\n            if pos > m:\n                if x < ad[m]:\n                    kl += 1\n                l = m + 1\n            else:\n                if x > ad[m]:\n                    kh += 1\n                h = m - 1\n        if can == 0:\n            swaps[ps] = -1\n        else:\n            swaps[ps] = kh + kl - min(kh, kl)\n    for y in range(q):\n        z = int(input())\n        print(swaps[dict2[z]])", "def main():\n    T = int(input())\n    for t in range(T):\n        inp = input().split()\n        N = int(inp[0])\n        Q = int(inp[1])\n        inp = input().split()\n        A = [int(i) for i in inp]\n        d = {}\n        for i in range(N):\n            d[A[i]] = i\n        As = sorted(A)\n        ds = {}\n        for i in range(N):\n            ds[As[i]] = i\n        for q in range(Q):\n            X = int(input())\n            ind = d[X]\n            low = 0\n            high = N - 1\n            gl = 0\n            gg = 0\n            lg = 0\n            ll = 0\n            while low <= high:\n                mid = int((low + high) / 2)\n                if mid == ind:\n                    break\n                if mid > ind:\n                    if A[mid] < X:\n                        gl += 1\n                    else:\n                        gg += 1\n                    high = mid - 1\n                else:\n                    if A[mid] > X:\n                        lg += 1\n                    else:\n                        ll += 1\n                    low = mid + 1\n            swaps = min(lg, gl)\n            l = ds[X]\n            g = N - l - 1\n            if lg > gl:\n                if lg - gl <= l - ll - gl:\n                    print(swaps + lg - gl)\n                else:\n                    print(-1)\n            elif gl > lg:\n                if gl - lg <= g - lg - gg:\n                    print(swaps + gl - lg)\n                else:\n                    print(-1)\n            else:\n                print(swaps)\nmain()", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(sorted(a))\n    d = {}\n    dd = {}\n    ddd = {}\n    for i in range(n):\n        d[a[i]] = i\n        dd[b[i]] = i\n        ddd[b[i]] = n - i - 1\n    for __ in range(q):\n        x = int(input())\n        pos = d[x]\n        left = 0\n        right = n - 1\n        wg = 0\n        wl = 0\n        cg = 0\n        cl = 0\n        while True:\n            mid = int((left + right) / 2)\n            if mid == pos:\n                break\n            elif mid > pos:\n                if a[mid] < a[pos]:\n                    wg += 1\n                else:\n                    cg += 1\n                right = mid - 1\n            elif mid < pos:\n                if a[mid] > a[pos]:\n                    wl += 1\n                else:\n                    cl += 1\n                left = mid + 1\n        if wl <= dd[x] - cl and wg <= ddd[x] - cg:\n            print(max(wl, wg))\n        else:\n            print('-1')", "def Query(A, x, index, n, X):\n    y = n - x - 1\n    stepL = 0\n    stepH = 0\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if mid == index:\n            break\n        elif index > mid:\n            low = mid + 1\n            if A[mid] > X:\n                if x > 0:\n                    stepL += 1\n                    x -= 1\n                else:\n                    return -1\n            elif x > 0:\n                x -= 1\n            else:\n                return -1\n        else:\n            high = mid - 1\n            if A[mid] < X:\n                if y > 0:\n                    stepH += 1\n                    y -= 1\n                else:\n                    return -1\n            elif y > 0:\n                y -= 1\n            else:\n                return -1\n    return max(stepL, stepH)\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = sorted(A)\n    D1 = {}\n    D2 = {}\n    for i in range(n):\n        D1[A[i]] = i\n        D2[B[i]] = i\n    for i in range(q):\n        x = int(input())\n        print(Query(A, D2[x], D1[x], n, x))", "t = int(input())\n\ndef binSearch(data, n, x, pos, avai):\n    low = 0\n    high = n - 1\n    replaceLow = 0\n    replaceHigh = 0\n    lowUsed = 0\n    highUsed = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if mid < pos:\n            if data[mid] < x:\n                lowUsed += 1\n                low = mid + 1\n            else:\n                replaceLow += 1\n                low = mid + 1\n        elif mid > pos:\n            if data[mid] > x:\n                highUsed += 1\n                high = mid - 1\n            else:\n                replaceHigh += 1\n                high = mid - 1\n        else:\n            break\n    if replaceHigh + highUsed > n - avai - 1 or replaceLow + lowUsed > avai:\n        return -1\n    else:\n        return min(replaceHigh, replaceLow) + abs(replaceLow - replaceHigh)\nfor _ in range(t):\n    temp = input().split()\n    n = int(temp[0])\n    q = int(temp[1])\n    data = list(map(int, input().split()))\n    realPos = {}\n    for i in range(0, len(data)):\n        realPos[data[i]] = i\n    newD = sorted(data)\n    posi = {}\n    for i in range(0, len(newD)):\n        posi[newD[i]] = i\n    for __ in range(q):\n        ele = int(input())\n        print(binSearch(data, n, ele, realPos[ele], posi[ele]))", "t = int(input())\nfor tc in range(t):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ac = sorted(a)\n    fa = {}\n    indices = {}\n    for i in range(n):\n        indices[a[i]] = i\n    for query in range(q):\n        x = int(input())\n        if fa.get(x, -2) == -2:\n            realI = indices[x]\n            lo = 0\n            hi = n - 1\n            mid = lo + (hi - lo) // 2\n            while lo <= hi:\n                mid = lo + (hi - lo) // 2\n                if ac[mid] == x:\n                    break\n                elif ac[mid] < x:\n                    lo = mid + 1\n                else:\n                    hi = mid - 1\n            ic = mid\n            ndts = 0\n            ndtl = 0\n            bigneed = 0\n            smallneed = 0\n            lo = 0\n            hi = n - 1\n            while lo <= hi:\n                mid = lo + (hi - lo) // 2\n                if a[mid] == x:\n                    break\n                elif mid < realI:\n                    lo = mid + 1\n                    if a[mid] < x:\n                        ndts += 1\n                    else:\n                        smallneed += 1\n                elif mid > realI:\n                    hi = mid - 1\n                    if a[mid] > x:\n                        ndtl += 1\n                    else:\n                        bigneed += 1\n            bigpresent = n - ic - 1 - ndtl\n            smallpresent = ic - ndts\n            if bigneed <= bigpresent and smallneed <= smallpresent:\n                swaps = 0\n                mn = min(bigneed, smallneed)\n                swaps += mn\n                swaps += bigneed + smallneed - 2 * mn\n                fa[x] = swaps\n                print(swaps)\n            else:\n                fa[x] = -1\n                print(-1)\n        else:\n            print(fa[x])", "indexdict = {}\n\ndef binsearch(key):\n    (low, high) = (0, len(temp) - 1)\n    while low <= high:\n        mid = (low + high) // 2\n        if temp[mid] == key:\n            return mid\n        elif temp[mid] < key:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return None\n\ndef fakebinsearch(key):\n    low = 0\n    high = len(arr) - 1\n    ind = indexdict[key]\n    smaller = bigger = 0\n    t = binsearch(key)\n    (sm, lg) = (t, len(temp) - t - 1)\n    while low <= high:\n        mid = (low + high) // 2\n        if mid == ind:\n            break\n        elif mid > ind:\n            if arr[mid] < key:\n                smaller += 1\n            else:\n                lg -= 1\n            high = mid - 1\n        else:\n            if arr[mid] > key:\n                bigger += 1\n            else:\n                sm -= 1\n            low = mid + 1\n    mn = min(smaller, bigger)\n    sm -= mn\n    lg -= mn\n    diff = abs(smaller - bigger)\n    if smaller == bigger:\n        return smaller\n    elif smaller > bigger:\n        if lg >= diff:\n            return smaller\n        else:\n            return -1\n    elif sm >= diff:\n        return bigger\n    else:\n        return -1\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    temp = sorted(arr)\n    for i in range(n):\n        indexdict[arr[i]] = i\n    for _1 in range(q):\n        x = int(input())\n        print(fakebinsearch(x))", "def bySearch(arr, l, r, x):\n    if r >= l:\n        mid = (l + r) // 2\n        if arr[mid][0] == x:\n            return int(mid)\n        elif arr[mid][0] > x:\n            return int(bySearch(arr, l, mid - 1, x))\n        else:\n            return int(bySearch(arr, mid + 1, r, x))\n\ndef merge(arr, l, m, r):\n    n1 = m - l + 1\n    n2 = r - m\n    L = arr[l:m + 1]\n    R = arr[m + 1:r + 1]\n    i = 0\n    j = 0\n    k = l\n    while i < n1 and j < n2:\n        if L[i][0] <= R[j][0]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n\ndef mergeSort(arr, l, r):\n    if l < r:\n        m = (l + r) // 2\n        mergeSort(arr, l, m)\n        mergeSort(arr, m + 1, r)\n        merge(arr, l, m, r)\nt = int(input())\nfor e in range(t):\n    (n, q) = [int(x) for x in input().split()]\n    a = [[int(x), i] for (i, x) in enumerate(input().split())]\n    b = a[:]\n    mergeSort(a, 0, n - 1)\n    d = {x[0]: i for (i, x) in enumerate(a)}\n    for p in range(q):\n        x = int(input())\n        j = d[x]\n        i = a[j][1]\n        (l, h, g, s, s1, g1) = (0, n - 1, 0, 0, 0, 0)\n        m = h // 2\n        while m != i:\n            if i > m:\n                l = m + 1\n                if b[m][0] > x:\n                    s += 1\n                s1 += 1\n            else:\n                h = m - 1\n                if b[m][0] < x:\n                    g += 1\n                g1 += 1\n            m = (h + l) // 2\n        if s1 <= j and g1 <= n - 1 - j:\n            print(max(s, g))\n        else:\n            print(-1)", "t = int(input().strip())\n\ndef binary_search(a, val):\n    index = dic[val]\n    n_lo_val = dic2[val]\n    n_high_val = n - 1 - dic2[val]\n    mutual_swap1 = []\n    mutual_swap2 = []\n\n    def checktruepath(n_lo_val, n_high_val):\n        low1 = 0\n        high1 = n - 1\n        while low1 <= high1:\n            mid = (low1 + high1) // 2\n            if a[mid] == val:\n                break\n            elif a[mid] < val:\n                if index > mid:\n                    n_lo_val -= 1\n                    low1 = mid + 1\n                else:\n                    mutual_swap1.append(a[mid])\n                    high1 = mid - 1\n            elif index < mid:\n                n_high_val -= 1\n                high1 = mid - 1\n            else:\n                mutual_swap2.append(a[mid])\n                low1 = mid + 1\n        return (n_lo_val, n_high_val)\n    (n_lo_val, n_high_val) = checktruepath(n_lo_val, n_high_val)\n    low = 0\n    high = n - 1\n    swaps = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if a[mid] == val:\n            break\n        elif a[mid] < val:\n            if index > mid:\n                low = mid + 1\n            elif n_high_val:\n                swaps += 1\n                n_high_val -= 1\n                high = mid - 1\n            else:\n                swaps = -1\n                break\n        elif index < mid:\n            high = mid - 1\n        elif n_lo_val:\n            swaps += 1\n            n_lo_val -= 1\n            low = mid + 1\n        else:\n            swaps = -1\n            break\n    if swaps == -1:\n        return swaps\n    else:\n        return swaps - min(len(mutual_swap2), len(mutual_swap1))\nfor i in range(t):\n    (n, q) = [int(i) for i in input().strip().split(' ')]\n    lis1 = [int(i) for i in input().strip().split(' ')]\n    dic = {}\n    for i in range(n):\n        dic[lis1[i]] = i\n    lis2 = []\n    for i in lis1:\n        lis2.append(i)\n    dic2 = {}\n    lis2.sort()\n    for i in range(n):\n        dic2[lis2[i]] = i\n    for i in range(q):\n        quer = int(input())\n        swaps = binary_search(lis1, quer)\n        print(swaps)", "from bisect import bisect_left as bl\n\ndef bs(arr, less, idx, num):\n    large = len(arr) - less - 1\n    p = less\n    low = 0\n    high = len(a) - 1\n    ans = 0\n    (large_swap, less_swap) = (0, 0)\n    while True:\n        mid = (low + high) // 2\n        if arr[mid] == num:\n            return ans\n        elif mid > idx and arr[mid] < num:\n            if large <= 0 and less_swap <= 0:\n                return -1\n            elif less_swap:\n                less_swap -= 1\n                large -= 1\n                high = mid - 1\n                continue\n            ans += 1\n            large -= 1\n            large_swap += 1\n            high = mid - 1\n        elif mid < idx and arr[mid] > num:\n            if less <= 0 and large_swap <= 0:\n                return -1\n            elif large_swap:\n                large_swap -= 1\n                less -= 1\n                low = mid + 1\n                continue\n            ans += 1\n            less -= 1\n            less_swap += 1\n            low = mid + 1\n        elif arr[mid] < num and mid < idx:\n            if less <= 0 and large_swap <= 0:\n                return -1\n            less -= 1\n            low = mid + 1\n        elif arr[mid] > num and mid > idx:\n            if large <= 0 and less_swap <= 0:\n                return -1\n            large -= 1\n            high = mid - 1\n\ndef solve(a, num, arr):\n    num_lesser = bl(a, num)\n    num_idx = dic[num]\n    return bs(arr, num_lesser, num_idx, num)\nfor i in range(int(input())):\n    (n, q) = [int(x) for x in input().split()]\n    arr = [int(x) for x in input().split()]\n    dic = {}\n    for i in range(n):\n        dic[arr[i]] = i\n    a = sorted(arr)\n    for i in range(q):\n        num = int(input())\n        if n == 1:\n            print(0)\n            continue\n        ans = solve(a, num, arr)\n        print(ans)", "def bs(l, x, i, n, si):\n    low = 1\n    high = n\n    lc = 0\n    gc = 0\n    l1 = 0\n    g1 = 0\n    mid = (low + high) // 2\n    while mid != i:\n        if i > mid:\n            l1 = l1 + 1\n            low = mid + 1\n            if l[mid] > x:\n                lc = lc + 1\n        if i < mid:\n            g1 = g1 + 1\n            high = mid - 1\n            if l[mid] < x:\n                gc = gc + 1\n        mid = (low + high) // 2\n    g1 = g1 - (n - si - 1)\n    l1 = l1 - si\n    if g1 > 0 or l1 > 0:\n        return -1\n    else:\n        return max(lc, gc)\nt = int(input())\nfor k in range(t):\n    r = input().split()\n    n = int(r[0])\n    q = int(r[1])\n    l = [int(x) for x in input().split()]\n    l.insert(0, -1000)\n    d1 = {}\n    for i in range(1, n + 1):\n        d1[l[i]] = i\n    s = l[0:n + 1]\n    s.sort()\n    d2 = {}\n    for i in range(1, n + 1):\n        d2[s[i]] = i\n    for j in range(q):\n        x = int(input())\n        index = d1[x]\n        print(bs(l, x, index, n, d2[x] - 1))", "T = int(input())\nD = [None] * 10000001\nwhile T > 0:\n    D1 = [0] * 10000001\n    D2 = [0] * 10000001\n    (N, Q) = input().strip().split(' ')\n    (N, Q) = [int(N), int(Q)]\n    A = list()\n    A = list(map(int, input().strip().split(' ')))\n    B = [None] * N\n    E = [None] * N\n    z = 0\n    C = [None] * Q\n    for i in range(0, N):\n        B[i] = A[i]\n    for i in range(0, Q):\n        C[i] = int(input())\n    B.sort()\n    t = 0\n    for i in range(0, N):\n        x = A[i]\n        low = 0\n        high = N - 1\n        flag = 0\n        swapl = 0\n        swapr = 0\n        l1 = 0\n        r1 = 0\n        while high >= 0:\n            mid = int((low + high) // 2)\n            if A[mid] == x:\n                break\n            if A[mid] < x:\n                if mid > i:\n                    if B[N - 1 - l1] > x:\n                        swapl = swapl + 1\n                    else:\n                        flag = 1\n                        break\n                    high = mid - 1\n                    l1 = l1 + 1\n                else:\n                    low = mid + 1\n                    r1 = r1 + 1\n            elif mid < i:\n                if B[r1] < x:\n                    swapr = swapr + 1\n                else:\n                    flag = 1\n                    break\n                low = mid + 1\n                r1 = r1 + 1\n            else:\n                high = mid - 1\n                l1 = l1 + 1\n        if l1 > 0 and B[N - l1] <= x:\n            flag = 1\n        if r1 > 0 and B[r1 - 1] >= x:\n            flag = 1\n        if x >= 10000000:\n            x1 = x\n            x = x % 10000000\n            x1 = (x1 - x) // 10000000\n            if D1[x] == 0:\n                D1[x] = t * 100\n                t = t + 1\n            if flag == 0:\n                if swapl > swapr:\n                    D2[x1 + D1[x]] = swapl\n                else:\n                    D2[x1 + D1[x]] = swapr\n            else:\n                D2[x1 + D1[x]] = -1\n        elif flag == 0:\n            if swapl > swapr:\n                D[x] = swapl\n            else:\n                D[x] = swapr\n        else:\n            D[x] = -1\n    for i in range(0, Q):\n        x = C[i]\n        if x >= 10000000:\n            x1 = x\n            x = x % 10000000\n            x1 = (x1 - x) // 10000000\n            print(D2[x1 + D1[x]])\n        else:\n            print(D[x])\n    T = T - 1", "def binary_search(a, n, x, d, ls):\n    low = 0\n    high = n - 1\n    l = ls[x]\n    h = ls[x]\n    li = 0\n    lh = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if a[mid] == x:\n            break\n        elif a[mid] < x:\n            if d[x] < mid:\n                high = mid - 1\n                h = h + 1\n                lh = lh + 1\n            else:\n                low = mid + 1\n                l = l - 1\n        elif d[x] > mid:\n            low = mid + 1\n            l = l - 1\n            li = li + 1\n        else:\n            high = mid - 1\n            h = h + 1\n    if h > n - 1 or l < 0:\n        return -1\n    return max(li, lh)\nT = int(input())\nfor t in range(T):\n    (n, q) = map(int, input().split())\n    l = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[l[i]] = i\n    k = sorted(l)\n    ls = {}\n    for i in range(n):\n        ls[k[i]] = i\n    for i in range(q):\n        x = int(input())\n        s = binary_search(l, n, x, d, ls)\n        print(s)", "def BSearch(array, n, x):\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if array[mid] == x:\n            break\n        elif array[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return mid\n\ndef indexSearch(array, n, i, less, more):\n    low = 0\n    high = n - 1\n    lessbad = 0\n    morebad = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if mid == i:\n            break\n        elif mid < i:\n            if array[mid] < array[i]:\n                less -= 1\n            else:\n                morebad += 1\n            low = mid + 1\n        else:\n            if array[mid] > array[i]:\n                more -= 1\n            else:\n                lessbad += 1\n            high = mid - 1\n    if lessbad == morebad:\n        return lessbad\n    elif lessbad < morebad:\n        if less >= morebad:\n            return morebad\n        else:\n            return -1\n    elif more >= lessbad:\n        return lessbad\n    else:\n        return -1\nT = int(input())\nfor i in range(T):\n    (N, Q) = map(int, input().split())\n    Alist = list(map(int, input().split()))\n    index = []\n    for j in range(N):\n        index.append(j)\n    Asorted = list(Alist)\n    (Asorted, index) = (list(x) for x in zip(*sorted(zip(Asorted, index))))\n    for j in range(Q):\n        X = int(input())\n        a = BSearch(Asorted, N, X)\n        inda = index[a]\n        less1 = a\n        more1 = N - a - 1\n        ans = indexSearch(Alist, N, inda, less1, more1)\n        print(ans)", "def bs(arr, n, x):\n    low = 0\n    high = n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            break\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return mid\n\ndef mbs(arr, n, x, ltX, oI):\n    low = 0\n    high = n\n    acG = 0\n    need2G = 0\n    needG = 0\n    needL = 0\n    mtX = n - ltX\n    swaps = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            break\n        elif arr[mid] < x and oI < mid:\n            needG += 1\n            need2G += 1\n            high = mid - 1\n            swaps += 1\n        elif arr[mid] < x:\n            low = mid + 1\n            needL += 1\n        elif arr[mid] > x and oI > mid:\n            acG += 1\n            needL += 1\n            low = mid + 1\n            swaps += 1\n        else:\n            high = mid - 1\n            needG += 1\n    interior_swaps = min(need2G, acG)\n    if needG > mtX or needL > ltX:\n        return -1\n    else:\n        return swaps - interior_swaps\nfor i in range(int(input())):\n    (n, q) = list(map(int, input().split()))\n    arr = []\n    arr2 = []\n    d = dict()\n    arr = list(map(int, input().split()))\n    arr2 = list(arr)\n    for i1 in range(n):\n        d[arr[i1]] = i1\n    arr2.sort()\n    for k in range(q):\n        x = int(input())\n        oI = d[x]\n        nltX = bs(arr2, n - 1, x)\n        print(mbs(arr, n - 1, x, nltX, oI))", "def fake_bs(inputs, n, dest_idx, elements_before_q, elements_after_q, res):\n    if dest_idx in res:\n        return res[dest_idx]\n    l = 0\n    h = n - 1\n    before_swaps = 0\n    after_swaps = 0\n    while l <= h:\n        mid = (l + h) // 2\n        if mid == dest_idx:\n            res[dest_idx] = max(before_swaps, after_swaps)\n            break\n        elif dest_idx > mid and elements_before_q > 0:\n            if inputs[mid] > inputs[dest_idx]:\n                before_swaps += 1\n            elements_before_q -= 1\n            l = mid + 1\n        elif dest_idx < mid and elements_after_q > 0:\n            if inputs[mid] < inputs[dest_idx]:\n                after_swaps += 1\n            elements_after_q -= 1\n            h = mid - 1\n        else:\n            res[dest_idx] = -1\n            break\n    return res[dest_idx]\nt = int(input())\nwhile t:\n    t -= 1\n    inputs = list(map(int, input().split()))\n    (n, q) = (inputs[0], inputs[1])\n    inputs = list(map(int, input().split()))\n    res = {}\n    is_sorted = True\n    index_of = {}\n    for i in range(n):\n        index_of[inputs[i]] = i\n        if is_sorted and i > 0 and (inputs[i - 1] > inputs[i]):\n            is_sorted = False\n    sorted_index_of = {}\n    if not is_sorted:\n        sorted_inputs = sorted(inputs)\n        for i in range(n):\n            sorted_index_of[sorted_inputs[i]] = i\n    for i in range(q):\n        num = int(input())\n        if is_sorted:\n            print(0)\n            continue\n        print(fake_bs(inputs, n, index_of[num], sorted_index_of[num], n - 1 - sorted_index_of[num], res))"]