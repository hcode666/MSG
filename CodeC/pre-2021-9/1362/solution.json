["import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\nfor _ in range(int(input())):\n    (n, p) = map(int, input().split())\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    print(nst)", "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return np.asarray([1, en])\n    else:\n        m = st + (en - st) // 2\n        ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n        return np.mod(ret, p)\nfor _ in range(int(input())):\n    (n, p) = map(int, input().split())\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    print(nst)", "import numpy as np\n\ndef poly(n, p):\n    a = np.array([[1, i] for i in range(1, n + 1)])\n    while n != 1:\n        b = []\n        for i in range(0, n // 2):\n            b.append(np.polymul(a[2 * i], a[2 * i + 1]))\n            for j in range(len(b[i])):\n                b[i][j] = b[i][j] % p\n        if len(a) % 2 == 1:\n            b.append(a[n - 1])\n        n = (n + 1) // 2\n        a = np.array(b)\n    return a\n\ndef hola(n, p):\n    ho = poly(n, p)\n    hol = 0\n    for i in range(0, len(ho[0])):\n        if ho[0][i] % p != 0:\n            hol = hol + 1\n    return hol\nt = int(input())\nwhile t > 0:\n    (n, p) = [int(x) for x in input().split()]\n    t = t - 1\n    n = n + 1\n    b = n % p\n    if b > 1:\n        ans = hola(b - 1, p)\n    else:\n        ans = 1\n    a = 1\n    mod = 1000000007\n    while n > 0:\n        n = n // p\n        a = a * (n % p + 1) % mod\n    print(a * ans % mod)", "import numpy as np\n\ndef poly(n, p):\n    a = np.array([[1, i] for i in range(1, n + 1)])\n    while n != 1:\n        b = []\n        for i in range(0, int(n / 2)):\n            b.append(np.polymul(a[2 * i], a[2 * i + 1]))\n            for j in range(len(b[i])):\n                b[i][j] = b[i][j] % p\n        if len(a) % 2 == 1:\n            b.append(a[n - 1])\n        n = int((n + 1) / 2)\n        a = np.array(b)\n    return a\n\ndef hola(n, p):\n    ho = poly(n, p)\n    hol = 0\n    for i in range(0, len(ho[0])):\n        if ho[0][i] % p != 0:\n            hol = hol + 1\n    return hol\nt = int(input())\nwhile t > 0:\n    (n, p) = list(map(int, input().split()))\n    t = t - 1\n    b = n % p\n    if b != p - 1 and b != 0:\n        ans = hola(b, p)\n    else:\n        ans = 1\n    a = 1\n    mod = 1000000007\n    n = n + 1\n    while n > 0:\n        n = n // p\n        a = a * (n % p + 1) % mod\n    print(a * ans % mod)", "import numpy as np\nmod = 10 ** 9 + 7\n\ndef fn(alist, p):\n    if len(alist) > 1:\n        mid = len(alist) // 2\n        lefthalf = alist[:mid]\n        righthalf = alist[mid:]\n        p1 = fn(lefthalf, p)\n        p2 = fn(righthalf, p)\n        p3 = p1 * p2\n        for x in range(p3.order + 1):\n            p3[x] = p3[x] % p\n        return p3\n    elif len(alist) == 1:\n        pp = np.poly1d(alist[0])\n        return pp\n    else:\n        alist = [1]\n        return np.poly1d(alist)\nt = int(input())\nwhile t > 0:\n    (n, p) = map(int, input().split())\n    ans = 1\n    N = (n + 1) % p\n    n = (n + 1) // p\n    while n > 0:\n        ans = ans * ((n % p + 1) % mod) % mod\n        n = n // p\n    l = []\n    for i in range(N):\n        temp = []\n        temp.append(1)\n        temp.append(i)\n        l.append(temp)\n    mul = fn(l, p)\n    mul1 = 0\n    for x in range(mul.order + 1):\n        if mul[x] % p != 0:\n            mul1 = mul1 + 1\n    print(ans * mul1 % mod)\n    t = t - 1", "import math\nmod = 10 ** 9 + 7\nfrom numpy import polymul\n\ndef ro(x):\n    while x & x - 1:\n        x = (x | x >> 1) + 1\n    return max(x, 1)\n\ndef bas(a, p):\n    (r1, r2) = divmod(a, p)\n    k = r2\n    ad = 1\n    while r1 > 0:\n        (r1, r2) = divmod(r1, p)\n        ad = ad * (r2 + 1) % mod\n    return ([k], ad)\n\ndef mul(a, b):\n    fin = polymul(a, b)\n    fin = [i % p for i in fin]\n    return fin\n\ndef repmul(k):\n    while len(k) != 1:\n        temp = []\n        i = 0\n        while i < len(k):\n            if i + 1 < len(k):\n                temp.append(mul(k[i], k[i + 1]))\n                i += 2\n            else:\n                temp.append(k[i])\n                i += 1\n        k = temp[:]\n    return k[0]\nfor _ in range(int(input())):\n    (nn, p) = [int(i) for i in input().split()]\n    mil = []\n    ck = 1\n    ans = 1\n    (lk, ans) = bas(nn + 1, p)\n    if lk[0] == 0 or lk[0] == 1:\n        print(ans)\n        continue\n    rg = lk[0] - 1\n    nn = rg\n    k = [[1, (i + 1) % p] for i in range(nn)]\n    k = repmul(k)\n    c = 0\n    for i in k:\n        if i % p != 0:\n            c += 1\n    ans = ans * c % mod\n    print(ans)", "import numpy\nimport sys\nosszes = []\ntry:\n    while True:\n        currs_ = input().split(' ')\n        currs = []\n        for i in currs_:\n            if len(i) == 0 or not i[0].isdigit():\n                continue\n            else:\n                currs.append(i)\n        osszes += currs\nexcept EOFError as e:\n    a = 0\nszamok = [int(i) for i in osszes]\nmod = 1000000000.0 + 7\nt = szamok[0]\nT = 0\nit = 1\nwhile T < t:\n    n = szamok[it]\n    p = szamok[it + 1]\n    it += 2\n    n += 1\n    pinary = []\n    tmp = n\n    while tmp > 0:\n        pinary.append(tmp % p)\n        tmp //= p\n\n    def szorzo(L, R):\n        if L > R:\n            return [0]\n        if L == R:\n            return [1, L]\n        mid = (L + R) // 2\n        (res1, res2) = (szorzo(L, mid), szorzo(mid + 1, R))\n        res = numpy.polymul(res1, res2)\n        for i in range(0, len(res)):\n            res[i] = int(res[i]) % p\n        return res\n    ans = 1\n    if pinary[0] > 1:\n        cnt = 0\n        res = szorzo(1, pinary[0] - 1)\n        for i in range(0, len(res)):\n            if res[i] > 0:\n                cnt += 1\n        ans = cnt\n    for i in range(1, len(pinary)):\n        ans = ans * (pinary[i] + 1) % mod\n    print(int(ans))\n    T += 1", "from itertools import combinations\n\ndef mult_polynom(polynom, number, prime):\n    for elem_idx in range(len(polynom)):\n        polynom[elem_idx] *= number\n    polynom.append(0)\n    for elem_idx in range(len(polynom) - 1, 0, -1):\n        polynom[elem_idx] += polynom[elem_idx - 1] // number\n        polynom[elem_idx] %= prime\n    polynom[0] %= prime\n\ndef solve_tail(tail, prime):\n    ans = 0\n    curr_product = [1]\n    for i in range(1, tail + 1):\n        mult_polynom(curr_product, i, prime)\n    for el in curr_product:\n        if el != 0:\n            ans += 1\n    return ans\n\ndef solve(number=1, prime=2):\n    mod = 10 ** 9 + 7\n    (number, prime) = (int(x) for x in input().split())\n    p_numeric = []\n    num = number\n    if number % prime == prime - 1:\n        number //= prime\n        number += 1\n        p_numeric.append(0)\n    while number > 0:\n        p_numeric.append(number % prime)\n        number //= prime\n    ans = 1\n    for digit in p_numeric[1:]:\n        ans *= digit + 1\n        ans %= mod\n    if p_numeric[0] < 10003:\n        ans *= solve_tail(p_numeric[0], prime)\n    elif prime - p_numeric[0] > prime // 2:\n        ans *= p_numeric[0]\n    else:\n        ans *= p_numeric[0] + 1\n    ans %= mod\n    print(ans)\n    return ans\n\ndef naive_solve(number, prime):\n    sums = []\n    for amount in range(0, number + 1):\n        curr_sum = 0\n        for comb in combinations(range(1, number + 1), amount):\n            curr_prod = 1\n            for elem in comb:\n                curr_prod *= elem\n            curr_sum += curr_prod\n        curr_sum %= prime\n        sums.append(curr_sum)\n    ans = 0\n    for el in sums:\n        if el != 0:\n            ans += 1\n    return ans\n\ndef test():\n    primes = [2, 3, 5, 7, 11, 13, 17, 19]\n    was = []\n    for number in range(1, 21):\n        for prime in primes:\n            naiv_ans = naive_solve(number, prime)\n            ans = solve(number, prime)\n            if naiv_ans != ans:\n                print('WA', number, prime)\n                print(ans, ' != ', naiv_ans)\n                was.append((number, prime, ans, naiv_ans))\n            else:\n                print('OK')\n    print(*was, sep='\\n')\nreqs_nr = int(input())\nfor req in range(reqs_nr):\n    solve()", "import sys\nimport numpy as np\n\ndef getints():\n    return map(int, sys.stdin.readline().split())\n\ndef fftconv(l0, l1, thr=512):\n    n0 = len(l0)\n    n1 = len(l1)\n    if n0 < thr or n1 < thr:\n        return np.mod(np.convolve(l0, l1), p)\n    n = max(n0, n1)\n    k = 0\n    while 1 << k < 2 * n - 1:\n        k += 1\n    N = 1 << k\n    h = p // 2\n    l0 = np.append((l0 + h) % p - h, np.zeros(N - n0, dtype=np.float64))\n    l1 = np.append((l1 + h) % p - h, np.zeros(N - n1, dtype=np.float64))\n    t0 = np.fft.rfft(l0)\n    t1 = np.fft.rfft(l1)\n    aa = np.fft.irfft(t0 * t1)\n    return np.floor(aa[:2 * n - 1] + 0.5).astype(int) % p\n\ndef nnz(N):\n\n    def cr(a, b):\n        d = b - a\n        if d == 0:\n            return np.array([1])\n        if d == 1:\n            return np.array([a, 1])\n        if d == 2:\n            return np.array([a * (a + 1) % p, 2 * a + 1, 1])\n        if d == 3:\n            return np.array([a * (a + 1) * (a + 2) % p, (3 * a * (a + 2) + 2) % p, 3 * a + 3, 1])\n        m = (a + b) // 2\n        return fftconv(cr(a, m), cr(m, b))\n    l0 = cr(1, N + 1)\n    if N < 10:\n        l0 = np.mod(l0, p)\n    s = 0\n    for k in range(N + 1):\n        s += l0[k] != 0\n    return s\n\ndef basep(n, p):\n    l = []\n    while n > 0:\n        l.append(n % p)\n        n //= p\n    return l\n\ndef prod(l, M=None):\n    t = 1\n    for x in l:\n        t *= x\n        if M != None:\n            t = t % M\n    return t\n(T,) = getints()\nM = 10 ** 9 + 7\nfor _ in range(T):\n    (n, p) = getints()\n    bb = basep(n, p)\n    r = 0\n    while r < len(bb) and bb[r] == p - 1:\n        r += 1\n    if r == 0:\n        b = nnz(bb[0]) * prod([x + 1 for x in bb[1:]], M)\n    else:\n        bb.append(0)\n        bb[r] += 1\n        b = prod([x + 1 for x in bb[r:]], M)\n    print(b % M)", "import numpy as np\n\ndef get_poly(le, ri, p):\n    if le == ri:\n        return np.poly1d(np.array([le, 1]).astype(np.int64))\n    mi = (le + ri) // 2\n    p0 = get_poly(le, mi, p)\n    p1 = get_poly(mi + 1, ri, p)\n    pol = np.polymul(p0, p1).c\n    pol = [x % p for x in pol]\n    return np.poly1d(pol)\n\ndef get_nnz(n, p):\n    if n == 0:\n        return 1\n    pol = get_poly(1, n, p)\n    return sum([x != 0 for x in pol])\n\ndef main():\n    mod = 1000000000 + 7\n    n_case = int(input())\n    for _ in range(n_case):\n        (n, p) = map(int, input().split())\n        r = n % p\n        n //= p\n        if r == p - 1:\n            r = 0\n            n = n + 1\n        ans = int(get_nnz(r, p))\n        while n != 0:\n            r = n % p\n            ans = ans * (r + 1) % mod\n            n //= p\n        print(ans)\nmain()"]