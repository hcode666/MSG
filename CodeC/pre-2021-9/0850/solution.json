["def gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    operations = [list(map(int, input().split())) for i in range(m)]\n    operations.sort(key=lambda x: x[0], reverse=True)\n    ans = 0\n    running_lcm = 1\n    empty_spots = n\n    for (x, y) in operations:\n        running_lcm = lcm(running_lcm, y)\n        ans += (empty_spots - n // running_lcm) * x\n        empty_spots -= empty_spots - n // running_lcm\n        if not empty_spots:\n            break\n    print(ans)", "def gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    operations = [list(map(int, input().split())) for i in range(m)]\n    operations.sort(key=lambda x: x[0], reverse=True)\n    ans = 0\n    running_lcm = 1\n    empty_spots = n\n    for (x, y) in operations:\n        running_lcm = lcm(running_lcm, y)\n        ans += (empty_spots - n // running_lcm) * x\n        empty_spots -= empty_spots - n // running_lcm\n        if not empty_spots:\n            break\n    print(ans)", "def gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    operations = [list(map(int, input().split())) for i in range(m)]\n    operations.sort(key=lambda x: x[0], reverse=True)\n    ans = 0\n    running_lcm = 1\n    empty_spots = n\n    for (x, y) in operations:\n        running_lcm = lcm(running_lcm, y)\n        ans += (empty_spots - n // running_lcm) * x\n        empty_spots -= empty_spots - n // running_lcm\n        if not empty_spots:\n            break\n    print(ans)", "import math\nT = int(input())\nfor i in range(T):\n    (N, M) = map(int, input().split())\n    (x, y, b, s, l, n, m, lc, nu, D, f) = ([], [], 0, 0, 1, 0, 0, 1, N, 0, 0)\n    for j in range(M):\n        (z, a) = map(int, input().split())\n        x.append(z)\n        y.append(a)\n    li = []\n    for i in range(M):\n        li.append([x[i], i])\n    li.sort()\n    while D < M:\n        m = li[-1][0]\n        n = y[li[-1][1]]\n        lc = lc * n // math.gcd(lc, n)\n        s = s + m * (nu - N // lc)\n        nu = N // lc\n        if nu == 0:\n            break\n        li.pop(-1)\n        D += 1\n    print(s)", "import math\nT = int(input())\nfor i in range(T):\n    (N, M) = map(int, input().split())\n    (x, y, b, s, l, n, m, lc, nu, D, f) = ([], [], 0, 0, 1, 0, 0, 1, N, 0, 0)\n    for j in range(M):\n        (z, a) = map(int, input().split())\n        x.append(z)\n        y.append(a)\n    li = []\n    for i in range(M):\n        li.append([x[i], i])\n    li.sort()\n    while D < M:\n        m = li[-1][0]\n        n = y[li[-1][1]]\n        lc = lc * n // math.gcd(lc, n)\n        s = s + m * (nu - N // lc)\n        nu = N // lc\n        if nu == 0:\n            break\n        li.pop(-1)\n        D += 1\n    print(s)", "import math\nT = int(input())\nfor i in range(T):\n    (N, M) = map(int, input().split())\n    (x, y, b, s, l, n, m, lc, nu, D, f) = ([], [], 0, 0, 1, 0, 0, 1, N, 0, 0)\n    for j in range(M):\n        (z, a) = map(int, input().split())\n        x.append(z)\n        y.append(a)\n    li = []\n    for i in range(M):\n        li.append([x[i], i])\n    li.sort()\n    while D < M:\n        m = li[-1][0]\n        n = y[li[-1][1]]\n        lc = lc * n // math.gcd(lc, n)\n        s = s + m * (nu - N // lc)\n        nu = N // lc\n        if nu == 0:\n            break\n        li.pop(-1)\n        D += 1\n    print(s)", "import math\nT = int(input())\nfor i in range(T):\n    (N, M) = map(int, input().split())\n    (x, y, b, s, l, n, m, lc, nu, D, f) = ([], [], 0, 0, 1, 0, 0, 1, N, 0, 0)\n    for j in range(M):\n        (z, a) = map(int, input().split())\n        x.append(z)\n        y.append(a)\n    li = []\n    for i in range(M):\n        li.append([x[i], i])\n    li.sort()\n    while D < M:\n        m = li[-1][0]\n        n = y[li[-1][1]]\n        lc = lc * n // math.gcd(lc, n)\n        s = s + m * (nu - N // lc)\n        nu = N // lc\n        if nu == 0:\n            break\n        li.pop(-1)\n        D += 1\n    print(s)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for k in range(m):\n        (a, b) = map(int, input().split())\n        arr.append([a, b])\n    arr.sort(key=lambda x: x[0], reverse=True)\n    (low, res, high) = (1, 0, n)\n    for j in range(0, m):\n        if high > 0:\n            low = lcm(arr[j][1], low)\n            high = high // low * low\n            temp = high // low\n            res += (n - temp) * arr[j][0]\n            n = temp\n    print(res)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for k in range(m):\n        (a, b) = map(int, input().split())\n        arr.append([a, b])\n    arr.sort(key=lambda x: x[0], reverse=True)\n    (low, res, high) = (1, 0, n)\n    for j in range(0, m):\n        if high > 0:\n            low = lcm(arr[j][1], low)\n            high = high // low * low\n            temp = high // low\n            res += (n - temp) * arr[j][0]\n            n = temp\n    print(res)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for k in range(m):\n        (a, b) = map(int, input().split())\n        arr.append([a, b])\n    arr.sort(key=lambda x: x[0], reverse=True)\n    (low, res, high) = (1, 0, n)\n    for j in range(0, m):\n        if high > 0:\n            low = lcm(arr[j][1], low)\n            high = high // low * low\n            temp = high // low\n            res += (n - temp) * arr[j][0]\n            n = temp\n    print(res)", "from math import gcd\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    query = []\n    for i in range(m):\n        query.append(list(map(int, input().split())))\n    query.sort(reverse=True)\n    ans = 0\n    pp = 1\n    z = n\n    for (x, y) in query:\n        if z == 0:\n            break\n        pp = pp * y // gcd(pp, y)\n        number_of_x = z - n // pp\n        ans += number_of_x * x\n        z -= number_of_x\n    print(ans)", "t = int(input())\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef MyFunc(n):\n    return n[0]\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(m):\n        arr.append([int(x) for x in input().split()])\n    arr.sort(key=MyFunc, reverse=True)\n    l = 1\n    rem = n\n    res = 0\n    i = 0\n    while i < m and rem > 0:\n        a = arr[i][0]\n        b = arr[i][1]\n        l = l * b // gcd(l, b)\n        res += (rem - n // l) * a\n        rem = n // l\n        i += 1\n    print(int(res))", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef LCM(a, b):\n    return a * b // gcd(a, b)\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(0, m):\n        (x, y) = map(int, input().split())\n        a = []\n        a.append(x)\n        a.append(y)\n        l.append(a)\n    l.sort(reverse=True)\n    i = 0\n    sum1 = 0\n    rem = n\n    lcm = 1\n    while rem > 0 and i < m:\n        x = l[i][0]\n        y = l[i][1]\n        if i == 0:\n            sum1 += (n - n // y) * x\n            rem = n // y\n            lcm = y\n        else:\n            lcm = LCM(lcm, y)\n            sum1 += max(0, (rem - n // lcm) * x)\n            rem = n // lcm\n        i += 1\n    print(sum1)", "def gdc(a, b):\n    if b == 0:\n        return a\n    else:\n        return gdc(b, a % b)\n\ndef lcm(a, b):\n    return a // gdc(a, b) * b\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    Arr = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        Arr.append([x, y])\n    Arr.sort(key=lambda x: x[0], reverse=True)\n    temp = 1\n    sum = 0\n    val = n\n    for j in range(m):\n        if val > 0:\n            temp = lcm(temp, Arr[j][1])\n            remaining = n // temp\n            filled_this_time = val - remaining\n            sum += filled_this_time * Arr[j][0]\n            val -= filled_this_time\n    print(sum)", "def read_int():\n    return int(input())\n\ndef read_ints():\n    return map(int, input().split(' '))\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\nt = read_int()\nfor case_num in range(t):\n    (n, m) = read_ints()\n    ops = []\n    for i in range(m):\n        (x, y) = read_ints()\n        ops.append((x, y))\n    ops.sort(reverse=True)\n    ans = 0\n    g = 1\n    rem = n\n    for (x, y) in ops:\n        g1 = g * y // gcd(g, y)\n        if g1 == g:\n            continue\n        drem = rem - n // g1\n        rem = n // g1\n        ans += drem * x\n        if g1 > n:\n            break\n        g = g1\n    print(ans)", "from math import gcd\nt = int(input())\nfor test in range(t):\n    (n, m) = list(map(int, input().split()))\n    l = []\n    for i in range(m):\n        num = list(map(int, input().split()))\n        l.append(num)\n    l.sort(reverse=True)\n    li = 1\n    s = 0\n    pos = n\n    for i in l:\n        li = li * i[1] // gcd(li, i[1])\n        if pos > 0:\n            pos = pos - n // li\n            s += pos * i[0]\n            pos = n // li\n        else:\n            break\n    print(s)", "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = sorted([list(map(int, input().split())) for k in range(m)], key=lambda x: x[0], reverse=True)\n    (low, res, high) = (1, 0, n)\n    for j in range(m):\n        if high > 0:\n            low = lcm(arr[j][1], low)\n            high = high // low * low\n            temp = high // low\n            res += (n - temp) * arr[j][0]\n            n = temp\n    print(res)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return int(a / gcd(a, b) * b)\nT = int(input())\nfor _ in range(T):\n    (N, M) = [int(n) for n in input().split()]\n    left_out = N\n    xy = []\n    for _ in range(M):\n        xy.append([int(n) for n in input().split()])\n    xy = sorted(xy, key=lambda x: x[0])\n    xy.reverse()\n    mul = 1\n    sum = 0\n    for item in xy:\n        mul = lcm(mul, item[1])\n        sum += (left_out - N // mul) * item[0]\n        left_out = N // mul\n        if left_out == 0:\n            break\n    print(sum)", "import math as mt\nMAXN = 100001\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getPrimesFromSpf():\n    p = set()\n    for x in spf:\n        if x not in p:\n            p.add(x)\n    p.remove(0)\n    p.remove(1)\n    return sorted(list(p))\n\ndef getFactorization(x):\n    ret = list()\n    while x >= MAXN:\n        sqrt_x = int(x ** 0.5)\n        divisible = False\n        for p in primes:\n            if p > sqrt_x:\n                break\n            if not x % p:\n                ret.append(p)\n                x //= p\n                divisible = True\n                break\n        if not divisible:\n            ret.append(x)\n            x //= x\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\nspf = [0 for i in range(MAXN)]\nsieve()\nprimes = getPrimesFromSpf()\n\ndef temp():\n    sum_A = 0\n    n = N\n    gcd = {}\n    XY.sort(reverse=True)\n    for (x, y) in XY:\n        factors = getFactorization(y)\n        fact_dic = {}\n        for factor in factors:\n            if factor in fact_dic:\n                fact_dic[factor] += 1\n            else:\n                fact_dic[factor] = 1\n        new_fact = {}\n        for fact in fact_dic:\n            if fact in gcd:\n                if fact_dic[fact] > gcd[fact]:\n                    new_fact[fact] = fact_dic[fact] - gcd[fact]\n                    gcd[fact] = fact_dic[fact]\n            else:\n                gcd[fact] = fact_dic[fact]\n                new_fact[fact] = fact_dic[fact]\n        yy = 1\n        for fact in new_fact:\n            yy *= fact * new_fact[fact]\n        temp = n // yy\n        sum_A += (n - temp) * x\n        n = temp\n        mul_gcd = 1\n        for fact in gcd:\n            mul_gcd *= fact * gcd[fact]\n        if mul_gcd > N:\n            break\n    return sum_A\nfor _ in range(int(input())):\n    (N, M) = [int(x) for x in input().split()]\n    XY = [[int(x) for x in input().split()] for i in range(M)]\n    XY = [[x, y] for [x, y] in XY if y != 1]\n    print(temp())", "import math\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    ar = []\n    for i in range(M):\n        (x, y) = map(int, input().split())\n        ar.append([x, y])\n    ar.sort(reverse=True)\n    l = 1\n    rem = N\n    res = 0\n    for i in range(M):\n        if rem > 0:\n            a = ar[i][0]\n            b = ar[i][1]\n            l = l * b // math.gcd(l, b)\n            res += (rem - N // l) * a\n            rem = N // l\n    print(int(res))", "from math import *\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = []\n    for __ in range(m):\n        (X, Y) = map(int, input().split())\n        A.append([X, Y])\n    A.sort(reverse=True)\n    myLCM = 1\n    sum = 0\n    myN = n\n    for (x, y) in A:\n        myLCM = lcm(myLCM, y)\n        if myN > 0:\n            sum += (myN - n // myLCM) * x\n            myN = n // myLCM\n        else:\n            break\n    print(sum)", "import math\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    ar = []\n    for i in range(M):\n        (x, y) = map(int, input().split())\n        ar.append([x, y])\n    ar.sort(reverse=True)\n    l = 1\n    rem = N\n    res = 0\n    for i in range(M):\n        if rem > 0:\n            a = ar[i][0]\n            b = ar[i][1]\n            l = l * b // math.gcd(l, b)\n            res += (rem - N // l) * a\n            rem = N // l\n    print(int(res))", "import math\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    ar = []\n    for i in range(M):\n        (x, y) = map(int, input().split())\n        ar.append([x, y])\n    ar.sort(reverse=True)\n    l = 1\n    rem = N\n    res = 0\n    for i in range(M):\n        if rem > 0:\n            a = ar[i][0]\n            b = ar[i][1]\n            l = l * b // math.gcd(l, b)\n            res += (rem - N // l) * a\n            rem = N // l\n    print(int(res))", "from math import *\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = []\n    for __ in range(m):\n        (X, Y) = map(int, input().split())\n        A.append([X, Y])\n    A.sort(reverse=True)\n    myLCM = 1\n    sum = 0\n    myN = n\n    for (x, y) in A:\n        myLCM = lcm(myLCM, y)\n        if myN > 0:\n            sum += (myN - n // myLCM) * x\n            myN = n // myLCM\n        else:\n            break\n    print(sum)", "import math\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    ar = []\n    for i in range(M):\n        (x, y) = map(int, input().split())\n        ar.append([x, y])\n    ar.sort(reverse=True)\n    l = 1\n    rem = N\n    res = 0\n    for i in range(M):\n        if rem > 0:\n            a = ar[i][0]\n            b = ar[i][1]\n            l = l * b // math.gcd(l, b)\n            res += (rem - N // l) * a\n            rem = N // l\n    print(int(res))", "from math import *\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    M = []\n    for __ in range(m):\n        (X, Y) = map(int, input().split())\n        M.append([X, Y])\n    M.sort(reverse=True)\n    myLCM = 1\n    sum = 0\n    myN = n\n    for (x, y) in M:\n        myLCM = lcm(myLCM, y)\n        if myN > 0:\n            sum += (myN - n // myLCM) * x\n            myN = n // myLCM\n        else:\n            break\n    print(sum)", "from math import *\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = []\n    for __ in range(m):\n        (X, Y) = map(int, input().split())\n        A.append([X, Y])\n    A.sort(reverse=True)\n    myLCM = 1\n    sum = 0\n    myN = n\n    for (x, y) in A:\n        myLCM = lcm(myLCM, y)\n        if myN > 0:\n            sum += (myN - n // myLCM) * x\n            myN = n // myLCM\n        else:\n            break\n    print(sum)", "import math\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    ar = []\n    for i in range(M):\n        (x, y) = map(int, input().split())\n        ar.append([x, y])\n    ar.sort(reverse=True)\n    l = 1\n    rem = N\n    res = 0\n    for i in range(M):\n        if rem > 0:\n            a = ar[i][0]\n            b = ar[i][1]\n            l = l * b // math.gcd(l, b)\n            res += (rem - N // l) * a\n            rem = N // l\n    print(int(res))", "import math\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    ar = []\n    for i in range(M):\n        (x, y) = map(int, input().split())\n        ar.append([x, y])\n    ar.sort(reverse=True)\n    l = 1\n    rem = N\n    res = 0\n    for i in range(M):\n        if rem > 0:\n            a = ar[i][0]\n            b = ar[i][1]\n            l = l * b // math.gcd(l, b)\n            res += (rem - N // l) * a\n            rem = N // l\n    print(int(res))", "from math import *\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    M = []\n    for __ in range(m):\n        (X, Y) = map(int, input().split())\n        M.append([X, Y])\n    M.sort(reverse=True)\n    myLCM = 1\n    sum = 0\n    myN = n\n    for (x, y) in M:\n        myLCM = lcm(myLCM, y)\n        if myN > 0:\n            sum += (myN - n // myLCM) * x\n            myN = n // myLCM\n        else:\n            break\n    print(sum)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for k in range(m):\n        (a, b) = map(int, input().split())\n        arr.append([a, b])\n    arr.sort(key=lambda x: x[0], reverse=True)\n    (low, res, high) = (1, 0, n)\n    for j in range(0, m):\n        if high > 0:\n            low = lcm(arr[j][1], low)\n            high = high // low * low\n            temp = high // low\n            res += (n - temp) * arr[j][0]\n            n = temp\n    print(res)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for k in range(m):\n        (a, b) = map(int, input().split())\n        arr.append([a, b])\n    arr.sort(key=lambda x: x[0], reverse=True)\n    (low, res, high) = (1, 0, n)\n    for j in range(m):\n        if high > 0:\n            low = lcm(arr[j][1], low)\n            high = high // low * low\n            temp = high // low\n            res += (n - temp) * arr[j][0]\n            n = temp\n    print(res)", "def gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    pairs = []\n    for _ in range(M):\n        (x, y) = map(int, input().split())\n        pairs.append((x, y))\n    pairs.sort(reverse=True)\n    zero_gap = 1\n    total = 0\n    for (x, y) in pairs:\n        if zero_gap > N:\n            break\n        new_zero_gap = lcm(zero_gap, y)\n        total += x * (N // zero_gap - N // new_zero_gap)\n        zero_gap = new_zero_gap\n    print(total)", "from collections import Counter\nimport math\nfrom bisect import bisect\nMOD = pow(10, 9) + 7\nMAX = pow(10, 20)\nMIN = -pow(10, 20)\n\nclass get:\n\n    def int():\n        return list(map(int, input().split()))\n\n    def str():\n        return input().split()\n\n    def float():\n        return list(map(float, input().split()))\n\n    def map():\n        return map(int, input().split())\n\ndef sqrt(x):\n    return int(math.sqrt(x)) + 1\n\ndef LCM(a, b):\n    return a * b // math.gcd(a, b)\n\ndef solve():\n    (n, m) = get.map()\n    mylist = [0] * m\n    for i in range(m):\n        (x, y) = get.map()\n        mylist[i] = [x, y]\n    mylist.sort(reverse=True)\n    lcm = 1\n    sum_ = 0\n    for i in range(m):\n        vacant_space = n // lcm\n        if not vacant_space:\n            break\n        lcm = LCM(lcm, mylist[i][1])\n        sum_ += (vacant_space - n // lcm) * mylist[i][0]\n    print(sum_)\nfor _ in range(int(input())):\n    solve()", "from collections import Counter\nimport math\nfrom bisect import bisect\nMOD = pow(10, 9) + 7\nMAX = pow(10, 20)\nMIN = -pow(10, 20)\n\nclass get:\n\n    def int():\n        return list(map(int, input().split()))\n\n    def str():\n        return input().split()\n\n    def float():\n        return list(map(float, input().split()))\n\n    def map():\n        return map(int, input().split())\n\ndef sqrt(x):\n    return int(math.sqrt(x)) + 1\n\ndef LCM(a, b):\n    return a * b // math.gcd(a, b)\n\ndef solve():\n    (n, m) = get.map()\n    mylist = [0] * m\n    for i in range(m):\n        (x, y) = get.map()\n        mylist[i] = [x, y]\n    mylist.sort(reverse=True)\n    lcm = 1\n    sum_ = 0\n    for i in range(m):\n        vacant_space = n // lcm\n        if not vacant_space:\n            break\n        lcm = LCM(lcm, mylist[i][1])\n        sum_ += (vacant_space - n // lcm) * mylist[i][0]\n    print(sum_)\nfor _ in range(int(input())):\n    solve()", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for k in range(m):\n        (a, b) = map(int, input().split())\n        arr.append([a, b])\n    arr.sort(key=lambda x: x[0], reverse=True)\n    (low, res, high) = (1, 0, n)\n    for j in range(0, m):\n        if high > 0:\n            low = lcm(arr[j][1], low)\n            high = high // low * low\n            temp = high // low\n            res += (n - temp) * arr[j][0]\n            n = temp\n    print(res)", "from math import *\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    M = []\n    for __ in range(m):\n        (X, Y) = map(int, input().split())\n        M.append([X, Y])\n    M.sort(reverse=True)\n    myLCM = 1\n    sum = 0\n    myN = n\n    for (x, y) in M:\n        myLCM = lcm(myLCM, y)\n        if myN > 0:\n            sum += (myN - n // myLCM) * x\n            myN = n // myLCM\n        else:\n            break\n    print(sum)", "def gcd(a, b):\n    if a == 0:\n        return b\n    else:\n        return gcd(b % a, a)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef prog_name():\n    (n, m) = map(int, input().split())\n    operations = []\n    for x in range(m):\n        temp = list(map(int, input().split()))\n        operations.append(temp)\n    operations.sort(reverse=True)\n    ans = 0\n    ll = 1\n    temp = n\n    for x in operations:\n        if temp > 0:\n            ll = lcm(ll, x[1])\n            ans += (temp - n // ll) * x[0]\n            temp = n // ll\n        else:\n            break\n    print(ans)\nT = int(input())\nfor unique in range(T):\n    prog_name()", "def GCD(a, b):\n    if a == 0:\n        return b\n    return GCD(b % a, a)\n\ndef LCM(a, b):\n    return int(a / GCD(a, b) * b)\nT = int(input())\nfor _ in range(T):\n    (N, M) = list(map(int, input().split()))\n    Opr_list = []\n    for i in range(M):\n        (x, y) = list(map(int, input().split()))\n        Opr_list.append([x, y])\n    Opr_list = sorted(Opr_list, key=lambda x: x[0], reverse=True)\n    ans = 0\n    Prev_Empyt = N\n    product = 1\n    for j in range(M):\n        (x, y) = Opr_list[j]\n        if Prev_Empyt == 0:\n            break\n        if product % y == 0:\n            continue\n        product = LCM(product, y)\n        Cur_Empty = N // product\n        SUM = (Prev_Empyt - Cur_Empty) * x\n        Prev_Empyt = Cur_Empty\n        ans = ans + SUM\n    print(ans)", "T = int(input())\n\ndef lcm(a, b):\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    return int(a * b // gcd(a, b))\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    if a == 0:\n        return b\n    r = a % b\n    while r:\n        a = b\n        b = r\n        r = a % b\n    return b\nfor t in range(T):\n    (N, M) = map(int, input().split(' '))\n    ops = []\n    for m in range(M):\n        (x, y) = map(int, input().split(' '))\n        ops.append((x, y))\n    ops.sort(key=lambda o: o[0], reverse=True)\n    (xi, yi) = ops[0]\n    zeros = N // yi\n    tot = (N - zeros) * xi\n    prev = yi\n    zeros_up = zeros\n    for (xi, yi) in ops[1:]:\n        cm = lcm(yi, prev)\n        zeros_up = N // cm\n        tot += (zeros - zeros_up) * xi\n        zeros = zeros_up\n        prev = cm\n        if not zeros_up:\n            break\n    print(tot)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nfor k in range(int(input())):\n    (n, m) = map(int, input().split())\n    l1 = []\n    for j in range(m):\n        lj = list(map(int, input().split()))\n        l1.append(lj)\n    l1.sort(reverse=True)\n    i = 0\n    sum = 0\n    j = n\n    lcm = 1\n    while i < m and j > 0:\n        a = l1[i][0]\n        b = l1[i][1]\n        lcm = lcm * b // gcd(lcm, b)\n        sum += (j - n // lcm) * a\n        j = n // lcm\n        i += 1\n    print(int(sum))", "import math\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        l.append([x, y])\n    l.sort(key=lambda p: p[0], reverse=True)\n    ans = 0\n    rem = n\n    ans += (rem - n // l[0][1]) * l[0][0]\n    prev = l[0][1]\n    rem = n // l[0][1]\n    for i in range(1, m):\n        if rem == 0:\n            break\n        kk = l[i][1]\n        z = math.gcd(prev, kk)\n        if False:\n            ans += rem * l[i][0]\n            break\n        else:\n            lcm = prev * kk // z\n            ans += (rem - n // lcm) * l[i][0]\n            rem = n // lcm\n            prev = lcm\n    print(ans)", "import math\nimport operator\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split(' '))\n    x = []\n    z = []\n    for i in range(m):\n        (a, b) = map(int, input().split(' '))\n        x.append([a, b])\n    x.sort(reverse=True)\n    sum = 0\n    div = n\n    l = 1\n    for i in range(m):\n        if div <= 0:\n            break\n        x1 = x[i][0]\n        x2 = x[i][1]\n        l = l * x2 // math.gcd(l, x2)\n        sum += (div - n // l) * x1\n        div = n // l\n    print(sum)", "import math\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    ar = []\n    for i in range(M):\n        (x, y) = map(int, input().split())\n        ar.append([x, y])\n    ar.sort(reverse=True)\n    l = 1\n    rem = N\n    res = 0\n    for i in range(M):\n        if rem > 0:\n            a = ar[i][0]\n            b = ar[i][1]\n            l = l * b // math.gcd(l, b)\n            res += (rem - N // l) * a\n            rem = N // l\n    print(int(res))", "import math\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(m):\n        l.append(list(map(int, input().split())))\n    l.sort(reverse=True)\n    temp = 1\n    rem = n\n    tot = 0\n    i = 0\n    while i < m and rem > 0:\n        x = l[i][0]\n        y = l[i][1]\n        temp = temp * y // math.gcd(temp, y)\n        tot += (rem - n // temp) * x\n        rem = n // temp\n        i += 1\n    print(tot)", "from math import gcd\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(m):\n        (t1, t2) = map(int, input().split())\n        arr.append([t1, t2])\n    arr.sort(reverse=True)\n    (temp1, temp2, ans) = (1, n, 0)\n    for i in range(m):\n        temp1 = temp1 * arr[i][1] // gcd(temp1, arr[i][1])\n        ans += (temp2 - n // temp1) * arr[i][0]\n        temp2 = n // temp1\n        if temp2 <= 0:\n            break\n    print(ans)", "from math import gcd\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(m):\n        (t1, t2) = map(int, input().split())\n        arr.append([t1, t2])\n    arr.sort(reverse=True)\n    (temp1, temp2, ans) = (1, n, 0)\n    for i in range(m):\n        t1 = arr[i][0]\n        t2 = arr[i][1]\n        temp1 = temp1 * t2 // gcd(temp1, t2)\n        ans += (temp2 - n // temp1) * t1\n        temp2 = n // temp1\n        if temp2 <= 0:\n            break\n    print(ans)", "import math\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        a.append((x, y))\n    a.sort(reverse=True)\n    ans = 0\n    t = 1\n    d = 0\n    for i in range(m):\n        t = t * a[i][1] // math.gcd(t, a[i][1])\n        k = n // t\n        d2 = n - k\n        d1 = d2 - d\n        d = d2\n        ans += a[i][0] * d1\n        if d == n:\n            break\n    print(ans)", "import math\nfor _ in range(int(input())):\n    arr1 = []\n    (n, m) = map(int, input().split())\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        arr1.append([x, y])\n    arr1.sort(reverse=True)\n    (c, rem, out) = (1, n, 0)\n    i = 0\n    while i < m and rem > 0:\n        (a, b) = (arr1[i][0], arr1[i][1])\n        c = c * b // math.gcd(c, b)\n        out += (rem - n // c) * a\n        rem = n // c\n        i += 1\n    print(out)", "import math\nfor _ in range(int(input())):\n    arr1 = []\n    (n, m) = map(int, input().split())\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        arr1.append([x, y])\n    arr1.sort(reverse=True)\n    (c, rem, out) = (1, n, 0)\n    i = 0\n    while i < m and rem > 0:\n        (a, b) = (arr1[i][0], arr1[i][1])\n        c = c * b // math.gcd(c, b)\n        out += (rem - n // c) * a\n        rem = n // c\n        i += 1\n    print(out)", "import math\nfor _ in range(int(input())):\n    arr1 = []\n    (n, m) = map(int, input().split())\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        arr1.append([x, y])\n    arr1.sort(reverse=True)\n    (c, rem, out) = (1, n, 0)\n    i = 0\n    while i < m and rem > 0:\n        (a, b) = (arr1[i][0], arr1[i][1])\n        c = c * b // math.gcd(c, b)\n        out += (rem - n // c) * a\n        rem = n // c\n        i += 1\n    print(out)", "import math\n\ndef pos(y, n):\n    temp = n - n % y\n    new = n - temp // y\n    return new\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        l.append((x, y))\n    l.sort(reverse=True)\n    empty = n\n    x1 = l[0][0]\n    y1 = l[0][1]\n    tot = x1 * pos(y1, n)\n    empty -= pos(y1, n)\n    for i in range(1, m):\n        x = l[i][0]\n        y = l[i][1]\n        lcm = y1 * y // math.gcd(y1, y)\n        new = n - pos(lcm, n)\n        tot += (empty - new) * x\n        empty = new\n        y1 = lcm\n        if not empty:\n            break\n    print(tot)", "import math\nt = int(input())\nfor i in range(0, t):\n    L = []\n    (n, m) = map(int, input().split())\n    maxi = -1\n    pos = -1\n    s = 0\n    for j in range(0, m):\n        (x, y) = map(int, input().split())\n        L.append((-1 * x, y))\n    L.sort()\n    for j in range(0, m):\n        L[j] = (abs(L[j][0]), abs(L[j][1]))\n    l = 1\n    l1 = 1\n    u = 0\n    while u < len(L) and l <= n:\n        l = l * L[u][1] // math.gcd(l, L[u][1])\n        s += L[u][0] * (n // l1 - n // l)\n        l1 = l\n        u += 1\n    print(s)", "import math\nt = int(input())\nfor i in range(0, t):\n    L = []\n    (n, m) = map(int, input().split())\n    maxi = -1\n    pos = -1\n    s = 0\n    for j in range(0, m):\n        (x, y) = map(int, input().split())\n        L.append((-1 * x, y))\n    L.sort()\n    for j in range(0, m):\n        L[j] = (abs(L[j][0]), abs(L[j][1]))\n    l = 1\n    l1 = 1\n    u = 0\n    while u < len(L) and l <= n:\n        l = l * L[u][1] // math.gcd(l, L[u][1])\n        s += L[u][0] * (n // l1 - n // l)\n        l1 = l\n        u += 1\n    print(s)", "from math import gcd\nt = int(input())\nwhile t:\n    (n, m) = map(int, input().split())\n    operations = []\n    for i in range(0, m):\n        operations.append(list(map(int, input().split())))\n    operations = sorted(operations, reverse=True)\n    lcmY = 1\n    maxSum = 0\n    remainingZeros = n\n    i = 0\n    while i < m and remainingZeros > 0:\n        x = operations[i][0]\n        y = operations[i][1]\n        lcmY *= y // gcd(lcmY, y)\n        maxSum += (remainingZeros - n // lcmY) * x\n        remainingZeros = n // lcmY\n        i += 1\n    print(maxSum)\n    t -= 1", "import math\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    d = {}\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        if y in d:\n            if x > d[y]:\n                d[y] = x\n        else:\n            d[y] = x\n    arr = list(d.items())\n    arr.sort(reverse=True, key=lambda x: x[1])\n    m = len(arr)\n    p = n\n    k = 1\n    ans = 0\n    i = 0\n    while i < m and n > 0:\n        a = arr[i][1]\n        b = arr[i][0]\n        k = k * b // math.gcd(k, b)\n        ans += a * (n - p // k)\n        n = p // k\n        i += 1\n    print(ans)", "import math\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    xa = []\n    yb = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        xa.append(x)\n        yb.append(y)\n    v = sorted(list(zip(xa, yb)))\n    v = v[::-1]\n    lcm = 1\n    r = n\n    res = 0\n    for i in range(m):\n        if r <= 0:\n            break\n        a = v[i][0]\n        b = v[i][1]\n        lcm = lcm * b // math.gcd(lcm, b)\n        res = res + (r - n // lcm) * a\n        r = n // lcm\n    print(res)", "import math\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = []\n    b = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        a.append(x)\n        b.append(y)\n    c = zip(a, b)\n    c = list(c)\n    c = sorted(c)\n    c = c[::-1]\n    lcm = 1\n    rem = n\n    res = 0\n    for i in range(m):\n        if rem <= 0:\n            break\n        p = c[i][0]\n        q = c[i][1]\n        lcm = lcm * q // math.gcd(lcm, q)\n        res = res + (rem - n // lcm) * p\n        rem = n // lcm\n    print(res)\nt = int(input())\nfor i in range(t):\n    solve()", "def gcd(a, b):\n    if a > b:\n        (a, b) = (b, a)\n    while b % a != 0:\n        (a, b) = (b % a, a)\n    return a\nT = int(input())\nfor iter in range(T):\n    (n, m) = map(int, input().split())\n    li = []\n    for temp in range(m):\n        (x, y) = map(int, input().split())\n        li.append((x, y))\n    li.sort(reverse=True)\n    sum = 0\n    lcm = 1\n    unfilled = n\n    j = 0\n    while unfilled > 0 and j < m:\n        x = li[j][0]\n        y = li[j][1]\n        lcm = lcm * y // gcd(lcm, y)\n        value = unfilled - n // lcm\n        unfilled = n // lcm\n        sum += x * value\n        j += 1\n    print(sum)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return a / gcd(a, b) * b\nt = input()\nt = int(t)\nfor i in range(t):\n    (n, m) = input().split(' ')\n    n = int(n)\n    m = int(m)\n    d = []\n    for j in range(m):\n        (x, y) = input().split(' ')\n        x = int(x)\n        y = int(y)\n        d.append([x, y])\n    d = sorted(d, key=lambda x: x[0], reverse=True)\n    sk = 1\n    r = n\n    s = 0\n    j = 0\n    while n > 0 and j < len(d):\n        sk = int(sk * d[j][1]) / gcd(sk, d[j][1])\n        s = s + d[j][0] * (n - int(r / sk))\n        n = int(r / sk)\n        j = j + 1\n    print(s)", "def gcd(p, q):\n    if p == 0:\n        return q\n    return gcd(q % p, p)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = dict()\n    for s in range(m):\n        (x, y) = map(int, input().split())\n        if y in d:\n            d[y] = max(d[y], x)\n        else:\n            d[y] = x\n    p = sorted(d.items(), key=lambda l: (l[1], l[0]), reverse=True)\n    t = n\n    ans = 0\n    c = 1\n    for i in range(len(p)):\n        c = c * p[i][0] // gcd(c, p[i][0])\n        g = n - t // c\n        n = t // c\n        ans += g * p[i][1]\n        if n <= 0:\n            break\n    print(ans)", "import math\n\ndef lcm(a, b):\n    return abs(a * b) // math.gcd(a, b)\nt = int(input())\nfor _ in range(t):\n    (n, k) = list(map(int, str(input()).split()))\n    ar = [0] * k\n    for i in range(k):\n        ar[i] = list(map(int, str(input()).split()))\n    ar.sort(reverse=True)\n    rem = n\n    l = 1\n    cou = 0\n    for i in range(k):\n        if rem <= 0:\n            break\n        a = ar[i][0]\n        b = ar[i][1]\n        l = lcm(l, b)\n        cou += (rem - n // l) * a\n        rem = n // l\n    print(cou)", "import math\nfor _ in range(int(input())):\n    arr1 = []\n    (n, m) = map(int, input().split())\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        arr1.append([x, y])\n    arr1.sort(reverse=True)\n    (c, rem, out) = (1, n, 0)\n    i = 0\n    while i < m and rem > 0:\n        (a, b) = (arr1[i][0], arr1[i][1])\n        c = c * b // math.gcd(c, b)\n        out += (rem - n // c) * a\n        rem = n // c\n        i += 1\n    print(out)", "import math\nfor _ in range(int(input())):\n    arr = []\n    (n, m) = map(int, input().split())\n    for i in range(m):\n        l = list(map(int, input().split()))\n        arr.append(l)\n    arr.sort(reverse=True)\n    ans = 0\n    length = n\n    mul = 1\n    for i in range(0, m):\n        if length <= 0:\n            break\n        mul = mul * arr[i][1] // math.gcd(mul, arr[i][1])\n        ans += (length - n // mul) * arr[i][0]\n        length = n // mul\n    print(ans)", "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\nt1 = int(input())\nwhile t1 > 0:\n    (n, M) = tuple(map(int, input().split(' ')))\n    dt = dict()\n    for mi in range(1, M + 1):\n        (x, y) = tuple(map(int, input().split(' ')))\n        if y in dt.keys():\n            if dt[y] < x:\n                dt[y] = x\n        else:\n            dt[y] = x\n    yx = sorted(dt.items(), key=lambda x: x[1], reverse=True)\n    suma = 0\n    mul = dd = 1\n    rn = n\n    for (y, x) in yx:\n        hcf = gcd(dd, y)\n        dd = int(dd * y / hcf)\n        t = rn - n // dd\n        suma = suma + t * x\n        rn = rn - t\n        if rn < 1:\n            break\n    print(suma)\n    t1 = t1 - 1", "import math\nxiyi = []\ntestcases = int(input())\nfor i in range(testcases):\n    (N, M) = map(int, input().split())\n    for j in range(M):\n        xiyi.append(list(map(int, input().split())))\n    xiyi.sort(reverse=True)\n    y_prod = int(1)\n    sum1 = int(N * xiyi[0][0])\n    for k in range(M):\n        y_prod *= xiyi[k][1] // math.gcd(y_prod, xiyi[k][1])\n        if N // y_prod == 0:\n            break\n        if k < M - 1:\n            sum1 += (xiyi[k + 1][0] - xiyi[k][0]) * (N // y_prod)\n        else:\n            sum1 += (0 - xiyi[k][0]) * (N // y_prod)\n    print(sum1)\n    xiyi.clear()", "import math\nt1 = int(input())\nwhile t1 > 0:\n    (n, m) = tuple(map(int, input().split(' ')))\n    mdict = dict()\n    for mi in range(1, m + 1):\n        (x, y) = tuple(map(int, input().split(' ')))\n        if y in mdict.keys():\n            if mdict[y] < x:\n                mdict[y] = x\n        else:\n            mdict[y] = x\n    yx = sorted(mdict.items(), key=lambda x: x[1], reverse=True)\n    suma = 0\n    mul = 1\n    z = 1\n    rn = n\n    for (y, x) in yx:\n        z = int(z * y / math.gcd(z, y))\n        t = rn - n // z\n        suma = suma + t * x\n        rn = rn - t\n        if rn < 1:\n            break\n    print(suma)\n    t1 = t1 - 1", "t = int(input())\nfor _ in range(t):\n    inp1 = input()\n    l1 = inp1.split(' ')\n    n = int(l1[0])\n    m = int(l1[1])\n    ops = []\n    for i in range(m):\n        inp2 = input()\n        l2 = inp2.split(' ')\n        ops.append([int(l2[0]), int(l2[1])])\n    ops = sorted(ops, reverse=True)\n    lcm = 1\n    k = n\n    s = 0\n    for i in range(m):\n        if k > 0:\n            num1 = ops[i][0]\n            num2 = ops[i][1]\n            a = max(lcm, num2)\n            b = min(lcm, num2)\n            r = 1\n            while r != 0:\n                r = a % b\n                if r == 0:\n                    gcd = b\n                    break\n                (a, b) = (b, r)\n            lcm = lcm * num2 // gcd\n            s = s + (k - n // lcm) * num1\n            k = n // lcm\n    print(s)", "import sys\nI = lambda x=' ': map(int, sys.stdin.readline().split(x))\npr = lambda *x, ch=' ': sys.stdout.write(f'{ch.join(map(str, x))}\\n')\nfrom math import gcd\n\ndef solve():\n    (n, m) = I()\n    a = []\n    for _ in range(m):\n        tmp = [*I()]\n        a.append(tmp)\n    a.sort(key=lambda x: x[0], reverse=True)\n    prev = a[0][1]\n    s = a[0][0] * (n - n // a[0][1])\n    for i in range(1, m):\n        if prev % a[i][1] == 0:\n            continue\n        if prev > n:\n            break\n        x = n // prev\n        factor = a[i][1] // gcd(a[i][1], prev)\n        s += a[i][0] * (x - x // factor)\n        prev *= factor\n    pr(s)\n\ndef main():\n    (t,) = I()\n    for _ in range(t):\n        solve()\nmain()", "import sys\nI = lambda x=' ': map(int, sys.stdin.readline().split(x))\npr = lambda *x, ch=' ': sys.stdout.write(f'{ch.join(map(str, x))}\\n')\nfrom math import gcd\n\ndef solve():\n    (n, m) = I()\n    a = []\n    for _ in range(m):\n        tmp = [*I()]\n        tmp.append(tmp[0] * (n - n // tmp[1]))\n        a.append(tmp)\n    a.sort(key=lambda x: x[0], reverse=True)\n    prev = a[0][1]\n    s = a[0][2]\n    for i in range(1, m):\n        if prev % a[i][1] == 0:\n            continue\n        if prev > n:\n            break\n        x = n // prev\n        factor = a[i][1] // gcd(a[i][1], prev)\n        s += a[i][0] * (x - x // factor)\n        prev *= factor\n    pr(s)\n\ndef main():\n    (t,) = I()\n    for _ in range(t):\n        solve()\nmain()", "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\nt = int(input())\nfor _ in range(t):\n    lis = []\n    (n, q1) = map(int, input().split())\n    for _ in range(q1):\n        lis.append(list(map(int, input().split())))\n    lis.sort()\n    q = n // lis[-1][1]\n    su = lis[-1][0] * (n - q)\n    va = lis[-1][1]\n    re = q\n    la = q * lis[-1][1]\n    for i1 in range(q1 - 2, -1, -1):\n        if re == 0:\n            break\n        elif va % lis[i1][1] == 0:\n            pass\n        elif lis[i1][1] % va == 0:\n            q = la // lis[i1][1]\n            su += lis[i1][0] * (re - q)\n            re = q\n            va = lis[i1][1]\n            la = q * va\n        else:\n            gc = gcd(va, lis[i1][1])\n            lcm = va * lis[i1][1] // gc\n            q = la // lcm\n            su += lis[i1][0] * (re - q)\n            re = q\n            va = lcm\n            la = q * va\n    print(su)", "def compute_gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef compute_lcm(x, y):\n    lcm = x * y // compute_gcd(x, y)\n    return lcm\n\ndef function():\n    (size, num) = map(int, input().split())\n    lst = []\n    for _ in range(num):\n        (x, y) = map(int, input().split())\n        lst.append([x, y])\n    lst.sort(key=lambda x: x[0], reverse=True)\n    rem = size\n    lcm = 1\n    res = 0\n    i = 0\n    while i < num and rem > 0:\n        a = lst[i][0]\n        b = lst[i][1]\n        lcm = compute_lcm(lcm, b)\n        res += (rem - size // lcm) * a\n        rem = size // lcm\n        i += 1\n    print(res)\ntest = int(input())\nwhile test != 0:\n    function()\n    test -= 1", "import sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nT = int(sys.stdin.readline())\nfor x in range(T):\n    (N, M) = map(int, sys.stdin.readline().split())\n    B = []\n    for i in range(M):\n        B.append(list(map(int, sys.stdin.readline().split())))\n    B = sorted(B, key=lambda x: x[0])\n    key = B[M - 1][1]\n    count = N // key\n    ans = (N - count) * B[M - 1][0]\n    op = M - 2\n    while count != 0 and op >= 0:\n        if key % B[op][1] == 0:\n            op -= 1\n            continue\n        else:\n            newkey = lcm(key, B[op][1])\n            newcount = count * key // newkey\n            ans += B[op][0] * (count - count * key // newkey)\n            key = newkey\n            count = newcount\n            op -= 1\n    sys.stdout.write(str(ans) + '\\n')", "import math\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for j in range(m):\n        (x, y) = map(int, input().split())\n        a.append((x, y))\n    a.sort()\n    a.reverse()\n    lcm = 1\n    ans = 0\n    d = n\n    for j in range(m):\n        if n <= 0:\n            break\n        g = a[j][0]\n        h = a[j][1]\n        lcm = lcm * h // math.gcd(lcm, h)\n        ans += g * (n - d // lcm)\n        n = d // lcm\n        if n <= 0:\n            break\n    print(ans)", "import math\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for j in range(m):\n        (x, y) = map(int, input().split())\n        a.append((x, y))\n    a.sort()\n    a.reverse()\n    lcm = 1\n    ans = 0\n    d = n\n    for j in range(m):\n        if n <= 0:\n            break\n        g = a[j][0]\n        h = a[j][1]\n        lcm = lcm * h // math.gcd(lcm, h)\n        ans += g * (n - d // lcm)\n        n = d // lcm\n        if n <= 0:\n            break\n    print(ans)", "from math import gcd\nimport operator\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    x = []\n    res = 0\n    lcm = 1\n    rem = n\n    for j in range(m):\n        (a, b) = map(int, input().split())\n        x.append([a, b])\n    x.sort(reverse=True, key=operator.itemgetter(0))\n    for i in range(m):\n        if rem <= 0:\n            break\n        (a, b) = (x[i][0], x[i][1])\n        lcm = int(lcm * b / gcd(lcm, b))\n        res += int((rem - int(n / lcm)) * a)\n        rem = int(n / lcm)\n    print(res)", "import math\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    (m1, x, y, total) = (m, [], [], 0)\n    while m != 0:\n        (a, b) = map(int, input().split())\n        x.append(a)\n        y.append(b)\n        m -= 1\n    (x, y) = map(list, zip(*sorted(zip(x, y))))\n    lcm = y[-1]\n    left = n // lcm\n    r = n - left\n    total += r * x[-1]\n    for i in range(m1 - 2, -1, -1):\n        gcd = math.gcd(lcm, y[i])\n        lcm = lcm * y[i] // gcd\n        r = left - n // lcm\n        left = n // lcm\n        total += r * x[i]\n        if left == 0:\n            break\n    print(total)", "import math\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, m) = map(int, input().strip().split())\n    a = []\n    b = []\n    lcmm = 0\n    d = defaultdict(lambda : [])\n    total = 0\n    preremaining = 0\n    heap_1 = []\n    for i in range(m):\n        (x, y) = map(int, input().strip().split())\n        a.append(x)\n        b.append(y)\n    for i in range(len(a)):\n        d[a[i]].append(b[i])\n    xx = sorted(d.keys())\n    for i in range(len(xx)):\n        for j in d[xx[i]]:\n            heap_1.append([xx[i], j])\n    for i in range(len(heap_1) - 1, -1, -1):\n        x = heap_1[i][0]\n        y = heap_1[i][1]\n        if lcmm == 0:\n            total += (n - n // y) * x\n            preremaining = n // y\n            lcmm = y\n        else:\n            if preremaining == 0:\n                break\n            lcmm = lcmm * y // math.gcd(lcmm, y)\n            postremaining = n // lcmm\n            total += (preremaining - postremaining) * x\n            preremaining = postremaining\n    print(int(total))", "from collections import defaultdict\nfrom math import gcd\nimport sys\nfor _ in range(int(sys.stdin.readline())):\n    (n, m) = map(int, sys.stdin.readline().split())\n    d = defaultdict(lambda : 0)\n    for i in range(m):\n        (x, y) = map(int, sys.stdin.readline().split())\n        d[y] = max(d[y], x)\n    l = []\n    for (x, y) in d.items():\n        l.append([y, x])\n    l.sort(reverse=True)\n    lcm = l[0][-1]\n    left = n // lcm\n    ans = (n - left) * l[0][0]\n    for i in range(1, len(l)):\n        if left <= 0:\n            break\n        lcm = lcm * l[i][1] // gcd(lcm, l[i][1])\n        ans += (left - n // lcm) * l[i][0]\n        left = n // lcm\n    sys.stdout.write(str(ans) + '\\n')", "from collections import defaultdict\nfrom math import gcd\nimport sys\nfor _ in range(int(sys.stdin.readline())):\n    (n, m) = map(int, sys.stdin.readline().split())\n    d = defaultdict(lambda : 0)\n    for i in range(m):\n        (x, y) = map(int, sys.stdin.readline().split())\n        d[y] = max(d[y], x)\n    l = []\n    for (x, y) in d.items():\n        l.append([y, x])\n    l.sort(reverse=True)\n    lcm = l[0][-1]\n    left = n // lcm\n    ans = (n - left) * l[0][0]\n    for i in range(1, len(l)):\n        if left <= 0:\n            break\n        lcm = lcm * l[i][1] // gcd(lcm, l[i][1])\n        ans += (left - n // lcm) * l[i][0]\n        left = n // lcm\n    sys.stdout.write(str(ans) + '\\n')", "from collections import defaultdict\nfrom math import gcd\nimport sys\nfor _ in range(int(sys.stdin.readline())):\n    (n, m) = map(int, sys.stdin.readline().split())\n    d = defaultdict(lambda : 0)\n    for i in range(m):\n        (x, y) = map(int, sys.stdin.readline().split())\n        d[y] = max(d[y], x)\n    l = []\n    for (x, y) in d.items():\n        l.append([y, x])\n    l.sort(reverse=True)\n    lcm = l[0][-1]\n    left = n // lcm\n    ans = (n - left) * l[0][0]\n    for i in range(1, len(l)):\n        if left <= 0:\n            break\n        lcm = lcm * l[i][1] // gcd(lcm, l[i][1])\n        ans += (left - n // lcm) * l[i][0]\n        left = n // lcm\n    sys.stdout.write(str(ans) + '\\n')", "import math\nT = int(input())\nfor _ in range(T):\n    inps = [int(z) for z in input().split()]\n    (N, M) = (inps[0], inps[1])\n    store_op = []\n    for i in range(M):\n        temp_inp = [int(z) for z in input().split()]\n        store_op.append(temp_inp)\n    store_op = sorted(store_op, reverse=True)\n    lcm = 1\n    Sum = 0\n    for ele in store_op:\n        (x, y) = (ele[0], ele[1])\n        if lcm % y == 0:\n            continue\n        if lcm > N:\n            break\n        temp_lcm = int(lcm * y / math.gcd(lcm, y))\n        Sum += x * (int(N / lcm) - int(N / temp_lcm))\n        lcm = temp_lcm\n    print(Sum)", "import sys\nfrom math import gcd\ninput = sys.stdin.readline\nt = int(input().rstrip())\nfor __ in range(t):\n    (n, m) = map(int, input().rstrip().split(' '))\n    arr = []\n    for __ in range(m):\n        (x, y) = map(int, input().rstrip().split(' '))\n        arr.append((x, y))\n    res = 0\n    curr_factor = 1\n    arr.sort(key=lambda x: (-x[0], x[1]))\n    for (x, y) in arr:\n        curr_y = gcd(curr_factor, y)\n        curr_y = y // curr_y\n        if not n:\n            break\n        res += x * (n - n // curr_y)\n        n //= curr_y\n        curr_factor *= curr_y\n    print(res)", "import math\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    query = []\n    for i in range(m):\n        query.append(list(map(int, input().split())))\n    query.sort(reverse=True)\n    res = 0\n    curr_product = 1\n    curr_size = n\n    for (x, y) in query:\n        if curr_size < 1:\n            break\n        curr_product = curr_product * y // math.gcd(curr_product, y)\n        count_x = curr_size - n // curr_product\n        res += count_x * x\n        curr_size -= count_x\n    print(res)", "import operator\nimport collections\nimport math\nt = int(input())\nwhile t:\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        l.append((x, y))\n    sorted_d = sorted(l, key=lambda x: x[0], reverse=True)\n    count = 0\n    p = 1\n    s = 0\n    for (x, y) in sorted_d:\n        p = p * y // math.gcd(p, y)\n        temp = n // p\n        num_avail = n - count - temp\n        s += num_avail * x\n        count += num_avail\n        if count == n:\n            break\n    print(s)\n    t -= 1", "import math\nt = int(input().strip())\nfor _ in range(0, t):\n    [N, M] = list(map(int, input().strip().split()))\n    l = []\n    for _ in range(0, M):\n        [x, y] = list(map(int, input().strip().split()))\n        l.append((x, y))\n    l = sorted(l, key=lambda x: x[0], reverse=True)\n    count = 0\n    s = 0\n    p = 1\n    for (x, y) in l:\n        p = p * y // math.gcd(p, y)\n        temp = N // p\n        num_avail = N - count - temp\n        s += num_avail * x\n        count += num_avail\n        if count == N:\n            break\n    print(s)", "import operator\nimport collections\nimport math\nt = int(input())\nwhile t:\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        l.append((x, y))\n    sorted_d = sorted(l, key=lambda x: x[0], reverse=True)\n    count = 0\n    p = 1\n    s = 0\n    for (x, y) in sorted_d:\n        p = p * y // math.gcd(p, y)\n        temp = n // p\n        num_avail = n - count - temp\n        s += num_avail * x\n        count += num_avail\n        if count == n:\n            break\n    print(s)\n    t -= 1", "import operator\nimport collections\nimport math\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        l.append((x, y))\n    sorted_d = sorted(l, key=lambda x: x[0], reverse=True)\n    count = 0\n    p = 1\n    s = 0\n    for (x, y) in sorted_d:\n        p = p * y // math.gcd(p, y)\n        temp = n // p\n        num_avail = n - count - temp\n        s += num_avail * x\n        count += num_avail\n        if count == n:\n            break\n    print(s)", "def find(x, y):\n    while y != 0:\n        temp = y\n        y = x % y\n        x = temp\n    return x\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    temp = n\n    l = []\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        l.append([x, y])\n    l.sort(reverse=True)\n    ans = 0\n    lcm = 1\n    for i in l:\n        lcm = lcm * i[1] // find(lcm, i[1])\n        ans = ans + i[0] * (n - temp // lcm)\n        n = temp // lcm\n        if n == 0:\n            break\n    print(ans)", "import math\n\ndef ans(arr, s, m, size, n):\n    a = arr[0][1]\n    lcm = arr[0][1]\n    for i in range(1, m):\n        if size <= 0:\n            print(s)\n            return\n        b = arr[i][1]\n        x = arr[i][0]\n        gcd = math.gcd(a, b)\n        lcm = a // gcd * b\n        a = lcm\n        if lcm > n:\n            s += x * size\n            print(s)\n            return\n        size -= n // lcm\n        q = n // lcm\n        n = q * lcm\n        s += x * size\n        size = q\n    print(s)\nt = int(input())\nfor k in range(t):\n    nm = input().split()\n    n = int(nm[0])\n    m = int(nm[1])\n    arr = []\n    flag = 0\n    for o in range(m):\n        arr.append(list(map(int, input().rstrip().split())))\n    arr.sort(key=lambda list: list[0], reverse=True)\n    size = n // arr[0][1]\n    s = arr[0][0] * n - arr[0][0] * size\n    ans(arr, s, m, size, n)", "def hello():\n    t = int(input())\n    answer = []\n    if t >= 1 and t <= 12600:\n        for x in range(t):\n            list1 = list(map(int, input().split(' ')))\n            n = list1[0]\n            m = list1[1]\n            if n >= 1 and n <= 10 ** 9:\n                if m >= 1 and m <= 10 ** 5:\n                    list1 = []\n                    for i in range(m):\n                        list1.append(list(map(int, input().split(' '))))\n                    flag = True\n                    for i in list1:\n                        if i[0] < 1 or i[0] > 10 ** 9:\n                            flag = False\n                            break\n                        if i[1] < 2 or i[1] > 10 ** 9:\n                            flag = False\n                            break\n                    if flag == False:\n                        continue\n                    list1.sort(key=lambda x: x[0])\n                    list1 = list1[::-1]\n                    Dict = {}\n                    k = 1\n                    c = n\n                    summ = 0\n                    for i in list1:\n                        if Dict.get(i[1]):\n                            continue\n                        k = k // gcd(k, i[1]) * i[1]\n                        summ = summ + (c - n // k) * i[0]\n                        c = n // k\n                        if c <= 0:\n                            break\n                        Dict[i[1]] = 0\n            answer.append(summ)\n        for i in answer:\n            print(i)\n\ndef gcd(A, B):\n    if A == 0:\n        return B\n    return gcd(B % A, A)\nhello()"]