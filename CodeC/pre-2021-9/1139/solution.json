["N = 100000\nprime = [-1 for i in range(N + 1)]\ni = 2\nwhile i <= N:\n    if prime[i] == -1:\n        prime[i] = i\n        for j in range(2 * i, N + 1, i):\n            if prime[j] == -1:\n                prime[j] = i\n    i += 1\nfrom math import gcd\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    range_p = [[-1, -1] for i in range(N + 1)]\n    for i in range(n):\n        a = arr[i]\n        while a > 1:\n            x = prime[a]\n            if range_p[x][0] == -1:\n                range_p[x][0] = i\n                range_p[x][1] = i\n            else:\n                range_p[x][1] = i\n            a = a // x\n    mark = [0 for i in range(n)]\n    for i in range(2, N + 1):\n        if range_p[i][0] != -1:\n            l = range_p[i][0]\n            r = range_p[i][1]\n            mark[l] += 1\n            mark[r] -= 1\n    for i in range(1, n):\n        mark[i] += mark[i - 1]\n    for i in range(n):\n        if mark[i] == 0:\n            print(i + 1)\n            break", "N = 100000\nprime = [-1 for i in range(N + 1)]\ni = 2\nwhile i <= N:\n    if prime[i] == -1:\n        prime[i] = i\n        for j in range(2 * i, N + 1, i):\n            if prime[j] == -1:\n                prime[j] = i\n    i += 1\nfrom math import gcd\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    range_p = [[-1, -1] for i in range(N + 1)]\n    for i in range(n):\n        a = arr[i]\n        while a > 1:\n            x = prime[a]\n            if range_p[x][0] == -1:\n                range_p[x][0] = i\n                range_p[x][1] = i\n            else:\n                range_p[x][1] = i\n            a = a // x\n    mark = [0 for i in range(n)]\n    for i in range(2, N + 1):\n        if range_p[i][0] != -1:\n            l = range_p[i][0]\n            r = range_p[i][1]\n            mark[l] += 1\n            mark[r] -= 1\n    for i in range(1, n):\n        mark[i] += mark[i - 1]\n    for i in range(n):\n        if mark[i] == 0:\n            print(i + 1)\n            break", "N = 100000\nprime = [-1 for i in range(N + 1)]\ni = 2\nwhile i <= N:\n    if prime[i] == -1:\n        prime[i] = i\n        for j in range(2 * i, N + 1, i):\n            if prime[j] == -1:\n                prime[j] = i\n    i += 1\nfrom math import gcd\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    range_p = [[-1, -1] for i in range(N + 1)]\n    for i in range(n):\n        a = arr[i]\n        while a > 1:\n            x = prime[a]\n            if range_p[x][0] == -1:\n                range_p[x][0] = i\n                range_p[x][1] = i\n            else:\n                range_p[x][1] = i\n            a = a // x\n    mark = [0 for i in range(n)]\n    for i in range(2, N + 1):\n        if range_p[i][0] != -1:\n            l = range_p[i][0]\n            r = range_p[i][1]\n            mark[l] += 1\n            mark[r] -= 1\n    for i in range(1, n):\n        mark[i] += mark[i - 1]\n    for i in range(n):\n        if mark[i] == 0:\n            print(i + 1)\n            break", "x = 10 ** 5 + 1\np = [0] * x\np[0] = p[1] = 0\nfor i in range(2, x):\n    if not p[i]:\n        for j in range(i, x, i):\n            p[j] = i\nt = int(input())\nimport random\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    e = {}\n    for i in l:\n        x = p[i]\n        d = i\n        while d > 1:\n            try:\n                e[x] += 1\n            except:\n                e[x] = 1\n            d = d // x\n            x = p[d]\n    dp = {}\n    ans = 0\n    v = 1\n    for i in l:\n        x = p[i]\n        d = i\n        while d > 1:\n            e[x] -= 1\n            if e[x] == 0:\n                ans += 1\n            try:\n                dp[x] += 1\n            except:\n                dp[x] = 1\n            d = d // x\n            x = p[d]\n        if len(dp) == ans:\n            print(v)\n            break\n        v += 1", "x = 10 ** 5 + 1\np = [0] * x\np[0] = p[1] = 0\nfor i in range(2, x):\n    if not p[i]:\n        for j in range(i, x, i):\n            p[j] = i\nt = int(input())\nimport random\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    e = {}\n    for i in l:\n        x = p[i]\n        d = i\n        while d > 1:\n            try:\n                e[x] += 1\n            except:\n                e[x] = 1\n            d = d // x\n            x = p[d]\n    dp = {}\n    ans = 0\n    v = 1\n    for i in l:\n        x = p[i]\n        d = i\n        while d > 1:\n            e[x] -= 1\n            if e[x] == 0:\n                ans += 1\n            try:\n                dp[x] += 1\n            except:\n                dp[x] = 1\n            d = d // x\n            x = p[d]\n        if len(dp) == ans:\n            print(v)\n            break\n        v += 1", "import math\ntry:\n\n    def primefactors(n):\n        arr = []\n        while n % 2 == 0:\n            arr.append(2)\n            n = n / 2\n        for i in range(3, int(math.sqrt(n)) + 1, 2):\n            while n % i == 0:\n                arr.append(i)\n                n = n / i\n        if n > 2:\n            arr.append(n)\n        return arr\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        lst = list(map(int, input().split()))\n        (start, ending) = ({}, {})\n        for (k, i) in enumerate(lst):\n            arr = primefactors(i)\n            for num in arr:\n                if num not in start:\n                    start[num] = k + 1\n                    ending[num] = k + 1\n                else:\n                    ending[num] = k + 1\n        diffarr = [0 for i in range(n + 1)]\n        for i in start:\n            diffarr[start[i]] += 1\n        for i in ending:\n            diffarr[ending[i]] -= 1\n        for i in range(1, n):\n            diffarr[i] += diffarr[i - 1]\n            if diffarr[i] == 0:\n                print(i)\n                break\nexcept EOFError as t:\n    pass", "from collections import Counter\nn = 10 ** 5\nfac = [[] for i in range(n + 1)]\ni = 2\nwhile i < n:\n    if fac[i] == []:\n        fac[i].append(i)\n        j = 2 * i\n        while j < n:\n            fac[j].append(i)\n            j += i\n    i += 1\nfor _ in range(int(input())):\n    q = int(input())\n    a = list(map(int, input().split()))\n    c = set()\n    qw = Counter()\n    for i in range(q):\n        for j in fac[a[i]]:\n            qw[j] += 1\n            c.add(j)\n    d = set()\n    for i in range(q):\n        for j in fac[a[i]]:\n            qw[j] -= 1\n            if qw[j] == 0:\n                del qw[j]\n                c.discard(j)\n            d.add(j)\n        f = 1\n        for z in c:\n            if z in d:\n                f = 0\n                break\n        if f:\n            print(i + 1)\n            break", "import sys\nimport math\nfrom collections import defaultdict, Counter\ninput = sys.stdin.readline\n\ndef print(x):\n    sys.stdout.write(str(x) + '\\n')\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for j in range(n):\n        if a[j] % 2 == 0:\n            if d.get(2) == None:\n                d[2] = [j, j]\n            else:\n                d[2][1] = j\n            while a[j] % 2 == 0:\n                a[j] //= 2\n        for k in range(3, int(math.sqrt(a[j])) + 1, 2):\n            if a[j] % k == 0:\n                if d.get(k) == None:\n                    d[k] = [j, j]\n                else:\n                    d[k][1] = j\n                while a[j] % k == 0:\n                    a[j] //= k\n        if a[j] > 2:\n            if d.get(a[j]) == None:\n                d[a[j]] = [j, j]\n            else:\n                d[a[j]][1] = j\n    good = [0] * n\n    for j in d:\n        good[d[j][0]] += 1\n        good[d[j][1]] -= 1\n    for j in range(n):\n        if j > 0:\n            good[j] += good[j - 1]\n        if good[j] == 0:\n            print(j + 1)\n            break", "import sys\nimport math\nfrom collections import defaultdict, Counter\ninput = sys.stdin.readline\n\ndef print(x):\n    sys.stdout.write(str(x) + '\\n')\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for j in range(n):\n        if a[j] % 2 == 0:\n            if d.get(2) == None:\n                d[2] = [j, j]\n            else:\n                d[2][1] = j\n            while a[j] % 2 == 0:\n                a[j] //= 2\n        for k in range(3, int(math.sqrt(a[j])) + 1, 2):\n            if a[j] % k == 0:\n                if d.get(k) == None:\n                    d[k] = [j, j]\n                else:\n                    d[k][1] = j\n                while a[j] % k == 0:\n                    a[j] //= k\n        if a[j] > 2:\n            if d.get(a[j]) == None:\n                d[a[j]] = [j, j]\n            else:\n                d[a[j]][1] = j\n    good = [0] * n\n    for j in d:\n        good[d[j][0]] += 1\n        good[d[j][1]] -= 1\n    for j in range(1, n):\n        good[j] += good[j - 1]\n    for j in range(n):\n        if good[j] == 0:\n            print(j + 1)\n            break", "from sys import stdin, stdout, maxsize\ntup = lambda : map(int, stdin.readline().split())\nI = lambda : int(stdin.readline())\nlint = lambda : [int(x) for x in stdin.readline().split()]\nstpr = lambda x: stdout.write(f'{x}' + '\\n')\nstar = lambda x: print(' '.join(map(str, x)))\nfrom _collections import defaultdict\n\ndef count(n):\n    d = defaultdict(int)\n    while n % 2 == 0:\n        d[2] += 1\n        n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            n //= i\n            d[i] += 1\n    if n > 2:\n        d[n] += 1\n    return d\nfor _ in range(I()):\n    n = I()\n    ls = lint()\n    (l, r) = (set(count(ls[0])), set())\n    ans = 1\n    for i in range(1, n):\n        p = count(ls[i])\n        r.update(p)\n        if len(l.intersection(p)) > 0:\n            l.update(r)\n            r.clear()\n            ans = i + 1\n    print(ans)", "import math\n\ndef primeFactors(n):\n    arr = []\n    while n % 2 == 0:\n        arr.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            arr.append(i)\n            n = n / i\n    if n > 2:\n        arr.append(n)\n    return arr\nfor t in range(int(input())):\n    n = int(input())\n    lis = list(map(int, input().split()))\n    (st, en) = ({}, {})\n    allP = set()\n    for (k, i) in enumerate(lis):\n        arr = primeFactors(i)\n        for nums in arr:\n            allP.add(nums)\n            if nums not in st:\n                st[nums] = k + 1\n                en[nums] = k + 1\n            else:\n                en[nums] = k + 1\n    diffarr = [0 for i in range(n + 1)]\n    for i in st:\n        diffarr[st[i]] += 1\n    for i in en:\n        diffarr[en[i]] -= 1\n    for i in range(1, n):\n        diffarr[i] += diffarr[i - 1]\n        if diffarr[i] == 0:\n            print(i)\n            break", "maxn = 100001\nprime = [x for x in range(maxn)]\ni = 2\nwhile i * i < maxn:\n    if prime[i] == i:\n        j = i\n        while i * j < maxn:\n            if prime[i * j] == i * j:\n                prime[i * j] = i\n            j += 1\n    i += 1\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    l = 0\n    for i in range(n):\n        x = a[i]\n        while x > 1:\n            p = prime[x]\n            if p in d and d[p] <= l:\n                l = i\n            d[p] = i\n            x //= p\n    print(l + 1)", "import math\n\ndef prime_factors(n):\n    p = set()\n    while n % 2 == 0:\n        p.add(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            p.add(i)\n            n = n / i\n    if n > 2:\n        p.add(n)\n    return p\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = 1\n    temp = prime_factors(l[0])\n    l1 = set()\n    for i in range(0, n):\n        fac = prime_factors(l[i])\n        l1.update(fac)\n        if len(temp.intersection(fac)) > 0:\n            temp.update(l1)\n            l1 = set()\n            ans = i + 1\n    print(ans)", "from sys import stdin\nfrom collections import Counter\ninput = stdin.readline\nMAX = 10 ** 5 + 10\np = [i for i in range(MAX)]\nfor i in range(2, int(MAX ** 0.5) + 1):\n    if p[i] == i:\n        for j in range(i * i, MAX, i):\n            p[j] = i\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    c1 = Counter()\n    for i in range(n):\n        x = a[i]\n        while x != 1:\n            c1[p[x]] += 1\n            x //= p[x]\n    c2 = Counter()\n    for i in range(n):\n        x = a[i]\n        while x != 1:\n            c1[p[x]] -= 1\n            c2[p[x]] += 1\n            x //= p[x]\n        for j in c1:\n            if c1[j] > 0 and c2[j] > 0:\n                break\n        else:\n            print(i + 1)\n            break", "import math as mt\nMAXN = 100001\nspf = [0 for i in range(MAXN)]\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = list()\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\nsieve()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    prime_factors_map = {}\n    for i in range(len(arr)):\n        prime_factors = getFactorization(arr[i])\n        for j in prime_factors:\n            if j not in prime_factors_map.keys():\n                prime_factors_map[j] = {'first_index': i, 'last_index': i}\n            else:\n                prime_factors_map[j]['last_index'] = i\n    diff_array = [0] * n\n    for (key, value) in prime_factors_map.items():\n        diff_array[prime_factors_map[key]['first_index']] += 1\n        diff_array[prime_factors_map[key]['last_index']] -= 1\n    count_array = [0] * n\n    for i in range(n):\n        count_array[i] = count_array[i - 1] + diff_array[i] if i - 1 >= 0 else diff_array[i]\n    print(count_array.index(0) + 1)", "import math as mt\nfrom functools import lru_cache\nMAXN = 100001\nspf = [0 for i in range(MAXN)]\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n\n@lru_cache(None)\ndef getFactorization(x):\n    ret = list()\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\nsieve()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ls = list(map(int, input().split()))\n    d = {}\n    sup = {}\n    al = set([])\n    for i in range(0, n):\n        d[i] = set(getFactorization(ls[i]))\n    streak = {}\n    count = -1\n    for i in d:\n        count += 1\n        for j in d[i]:\n            if j in streak:\n                streak[j][1] = count\n            else:\n                streak[j] = [count, count]\n    arr = [0] * n\n    for i in streak:\n        start = streak[i][0]\n        end = streak[i][1]\n        arr[start] += 1\n        arr[end] -= 1\n    prefix = arr[0]\n    if prefix == 0:\n        print(1)\n        continue\n    for i in range(1, n):\n        prefix += arr[i]\n        if prefix == 0:\n            print(i + 1)\n            break", "minPrime = [0] * 100001\n(minPrime[1], minPrime[2]) = (1, 2)\ni = 4\nwhile i < 100001:\n    minPrime[i] = 2\n    i += 2\nfor i in range(3, 100001, 2):\n    if minPrime[i] == 0:\n        minPrime[i] = i\n        j = i + i\n        while j < 100001:\n            minPrime[j] = i\n            j += i\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    dl = {}\n    dr = {}\n    for i in range(n - 1, -1, -1):\n        j = l[i]\n        while j > 1:\n            try:\n                dr[minPrime[j]] += 1\n            except:\n                dr[minPrime[j]] = 1\n            j //= minPrime[j]\n    for i in range(n):\n        j = l[i]\n        while j > 1:\n            dr[minPrime[j]] -= 1\n            try:\n                dl[minPrime[j]] += 1\n            except:\n                dl[minPrime[j]] = 1\n            j //= minPrime[j]\n        f = True\n        for k in dl:\n            if dr[k]:\n                f = False\n                break\n        if f:\n            print(i + 1)\n            break", "from sys import stdin as stin, stdout as stout, setrecursionlimit as srl\nimport math as mt\n\ndef get_ints():\n    return map(int, stin.readline().split())\n\ndef get_list():\n    return list(map(int, stin.readline().split()))\n\ndef get_int():\n    return int(stin.readline())\n\ndef get_str():\n    return stin.readline()\nmaxm = 100001\nspf = [0] * maxm\n\ndef seive():\n    spf[1] = 1\n    for i in range(2, maxm):\n        spf[i] = i\n    for i in range(4, maxm, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(maxm ** 0.5)):\n        if spf[i] == i:\n            for j in range(i ** 2, maxm, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef get_factorization(x):\n    m = {}\n    while x != 1:\n        m[spf[x]] = 1\n        x //= spf[x]\n    return list(m)\nseive()\nfor _ in range(get_int()):\n    n = get_int()\n    nums = get_list()\n    prime = {}\n    for (i, c) in enumerate(nums):\n        k = get_factorization(c)\n        for j in k:\n            if j in prime:\n                prime[j][1] = i\n            else:\n                prime[j] = [i, i]\n    cover = [0] * n\n    for i in prime:\n        cover[prime[i][0]] += 1\n        cover[prime[i][1]] -= 1\n    if cover[0] == 0:\n        print(1)\n        continue\n    for i in range(1, n):\n        cover[i] += cover[i - 1]\n        if cover[i] == 0:\n            print(i + 1)\n            break", "import math as mt\nMAXN = 100001\nspf = [0 for i in range(MAXN)]\ninput = __import__('sys').stdin.readline\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = {}\n    while x != 1:\n        ret[spf[x]] = 1\n        x = x // spf[x]\n    return list(ret)\n\ndef solve(c, n):\n    if c[0] == 0:\n        return 1\n    for i in range(1, n):\n        c[i] += c[i - 1]\n        if c[i] == 0:\n            return i + 1\nsieve()\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    prime = {}\n    for i in range(n):\n        q = getFactorization(a[i])\n        for k in q:\n            if k in prime:\n                prime[k][1] = i\n            else:\n                prime[k] = [i, i]\n    c = [0] * n\n    for i in prime:\n        c[prime[i][0]] += 1\n        c[prime[i][1]] -= 1\n    print(solve(c, n))", "import math\n\ndef prime_factors(n):\n    prime = set()\n    while n % 2 == 0:\n        prime.add(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            prime.add(i)\n            n = n / i\n    if n > 2:\n        prime.add(n)\n    return prime\nfor _ in range(int(input())):\n    n = int(input())\n    seq = list(map(int, input().split()))\n    l = 1\n    left = prime_factors(seq[0])\n    right = set()\n    for i in range(1, n):\n        factors = prime_factors(seq[i])\n        right.update(factors)\n        if len(left.intersection(factors)) > 0:\n            left.update(right)\n            right = set()\n            l = i + 1\n    print(l)", "mpr = [0 for x in range(100001)]\nfor i in range(2, 100001):\n    if mpr[i] == 0:\n        k = i\n        for j in range(k, 100001, i):\n            mpr[j] = i\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d1 = {}\n    d2 = {}\n    for i in range(n - 1, -1, -1):\n        k = a[i]\n        while k > 1:\n            try:\n                d2[mpr[k]] += 1\n            except:\n                d2[mpr[k]] = 1\n            k = k // mpr[k]\n    for i in range(n):\n        k = a[i]\n        while k > 1:\n            d2[mpr[k]] -= 1\n            try:\n                d1[mpr[k]] += 1\n            except:\n                d1[mpr[k]] = 1\n            k = k // mpr[k]\n        stat = 1\n        for k in d1:\n            if d2[k] > 0:\n                stat = 0\n                break\n        if stat == 1:\n            print(i + 1)\n            break", "import sys\nfrom math import gcd\nfrom collections import defaultdict\n\ndef factor(a):\n    factors = defaultdict(int)\n    while a % 2 == 0:\n        factors[2] += 1\n        a //= 2\n    f = 3\n    while f * f <= a:\n        if a % f == 0:\n            factors[f] += 1\n            a //= f\n        else:\n            f += 2\n    if a != 1:\n        factors[a] = 1\n    return factors\n\ndef add_factors_to(fto, ffrom):\n    for (k, v) in ffrom.items():\n        fto[k] += v\n\ndef sub_factors_from(ffrom, ff):\n    for (k, v) in ff.items():\n        ffrom[k] -= v\n        assert ffrom[k] >= 0\n        if ffrom[k] == 0:\n            del ffrom[k]\n\ndef is_coprime(a, b):\n    g = 1\n    if any((k in b for k in a)):\n        return False\n    return True\n\ndef solve(B):\n    N = len(B)\n    left = defaultdict(int)\n    add_factors_to(left, B[0])\n    right = defaultdict(int)\n    for b in B[1:]:\n        add_factors_to(right, b)\n    split_at = 0\n    while not is_coprime(left, right):\n        split_at += 1\n        add_factors_to(left, B[split_at])\n        sub_factors_from(right, B[split_at])\n    return split_at + 1\n\ndef main():\n    test_cases = int(sys.stdin.readline())\n    for _ in range(test_cases):\n        N = int(sys.stdin.readline())\n        A = [int(i) for i in sys.stdin.readline().split()]\n        B = [factor(a) for a in A]\n        print(solve(B))\nmain()", "import math\n\ndef prime_factors(n):\n    prime = set()\n    while n % 2 == 0:\n        prime.add(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            prime.add(i)\n            n = n / i\n    if n > 2:\n        prime.add(n)\n    return prime\nfor _ in range(int(input())):\n    n = int(input())\n    seq = list(map(int, input().split()))\n    l = 1\n    left = prime_factors(seq[0])\n    right = set()\n    for i in range(1, n):\n        factors = prime_factors(seq[i])\n        right.update(factors)\n        if len(left.intersection(factors)) > 0:\n            left.update(right)\n            right = set()\n            l = i + 1\n    print(l)", "import math as mt\nMAXN = 100001\nspf = [0 for i in range(MAXN)]\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = list()\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\nsieve()\n\ndef testcase():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    if n > 1000:\n        first = dict()\n        last = dict()\n        for i in range(n):\n            fs = getFactorization(arr[i])\n            for f in fs:\n                if f not in first:\n                    first[f] = i + 1\n                last[f] = i + 1\n        fs = getFactorization(arr[0])\n        ans = 0\n        for f in fs:\n            ans = max(ans, last[f])\n        for f in first:\n            if first[f] < ans:\n                ans = max(ans, last[f])\n        print(ans)\n        return\n    ls = [0 for a in arr]\n    ls[0] = set(getFactorization(arr[0]))\n    for i in range(1, n):\n        fs = getFactorization(arr[i])\n        fs = set(fs)\n        ls[i] = set(ls[i - 1])\n        ls[i] |= fs\n    rs = [0 for a in arr]\n    rs[-1] = set(getFactorization(arr[-1]))\n    for i in range(n - 2, -1, -1):\n        fs = getFactorization(arr[i])\n        fs = set(fs)\n        rs[i] = set(rs[i + 1])\n        rs[i] |= fs\n    for i in range(n - 1):\n        l = ls[i]\n        r = rs[i + 1]\n        if len(l & r) == 0:\n            print(i + 1)\n            return\n    return\nimport sys, os\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\nsys.setrecursionlimit(10 ** 5)\nt = int(input())\nfor _ in range(t):\n    testcase()", "minPrime = [0] * 100001\n(minPrime[1], minPrime[2]) = (1, 2)\ni = 4\nwhile i < 100001:\n    minPrime[i] = 2\n    i += 2\nfor i in range(3, 100001, 2):\n    if minPrime[i] == 0:\n        minPrime[i] = i\n        j = i + i\n        while j < 100001:\n            minPrime[j] = i\n            j += i\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    dl = {}\n    dr = {}\n    for i in range(n - 1, -1, -1):\n        j = l[i]\n        while j > 1:\n            try:\n                dr[minPrime[j]] += 1\n            except:\n                dr[minPrime[j]] = 1\n            j //= minPrime[j]\n    for i in range(n):\n        j = l[i]\n        while j > 1:\n            dr[minPrime[j]] -= 1\n            try:\n                dl[minPrime[j]] += 1\n            except:\n                dl[minPrime[j]] = 1\n            j //= minPrime[j]\n        f = True\n        for k in dl:\n            if dr[k]:\n                f = False\n                break\n        if f:\n            print(i + 1)\n            break", "import sys\nimport math\nimport collections\nfrom sys import stdin, stdout, setrecursionlimit\nimport bisect as bs\nsetrecursionlimit(2 ** 20)\nM = 10 ** 9 + 7\nT = int(stdin.readline())\n\ndef primeFactors(n):\n    h = {}\n    while n % 2 == 0:\n        if 2 not in h:\n            h[2] = 0\n        h[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            if i not in h:\n                h[i] = 0\n            h[i] += 1\n            n = n / i\n    if n > 2:\n        if n not in h:\n            h[n] = 1\n        h[n] += 1\n    return h\nfor _ in range(T):\n    f = {}\n    fac = []\n    b = {}\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    for i in range(n):\n        d = primeFactors(a[i])\n        for k in d:\n            if k not in f:\n                f[k] = 0\n            f[k] += d[k]\n        fac.append(d)\n    for i in range(n):\n        res = True\n        d = fac[i]\n        for k in d:\n            if k not in b:\n                b[k] = 0\n            b[k] += d[k]\n            f[k] -= d[k]\n        for k in b:\n            if f[k] != 0:\n                res = False\n                break\n        if res:\n            print(i + 1)\n            break", "n = 10 ** 5 + 5\nseive = [0 for i in range(n)]\nfor i in range(2, n):\n    if seive[i] == 0:\n        seive[i] = i\n        for j in range(i * i, n, i):\n            seive[j] = i\nt = int(input())\nfor you in range(t):\n    n = int(input())\n    l = input().split()\n    li = [int(i) for i in l]\n    hashi = dict()\n    for i in li:\n        z = i\n        while z > 1:\n            if seive[z] in hashi:\n                hashi[seive[z]] += 1\n            else:\n                hashi[seive[z]] = 1\n            z = z // seive[z]\n    start = dict()\n    k = len(hashi)\n    for i in range(n):\n        z = li[i]\n        while z > 1:\n            hashi[seive[z]] -= 1\n            start[seive[z]] = 1\n            if hashi[seive[z]] == 0:\n                del hashi[seive[z]]\n            z = z // seive[z]\n        if len(hashi) + len(start) == k:\n            ans = i\n            break\n    print(ans + 1)"]