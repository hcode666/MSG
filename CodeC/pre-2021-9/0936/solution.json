["from collections import defaultdict\nt = int(input())\nfor i in range(t):\n    N = int(input())\n    st = input().split()\n    L = [[]]\n    D = defaultdict(int)\n    S = set()\n    p = 0\n    for x in st:\n        n = int(x)\n        if n in S:\n            q = D[n]\n        else:\n            S.add(n)\n            q = len(L)\n            L.append([])\n            D[n] = q\n        L[q].append(p)\n        p += 1\n    SL = list(S)\n    SL.sort()\n    p = 0\n    M = 1\n    for n in SL:\n        q = D[n]\n        if len(L[q]) == 1:\n            z = L[q][0]\n            if z < p:\n                M += 1\n            p = z\n        else:\n            v = L[q][-1]\n            if v > p:\n                k = 0\n                while L[q][k] < p:\n                    k += 1\n                p = L[q][k]\n            else:\n                M += 1\n                p = L[q][0]\n    print(M)", "from collections import defaultdict\nt = int(input())\nfor i in range(t):\n    N = int(input())\n    st = input().split()\n    L = [[]]\n    D = defaultdict(int)\n    S = set()\n    p = 0\n    for x in st:\n        n = int(x)\n        if n in S:\n            q = D[n]\n        else:\n            S.add(n)\n            q = len(L)\n            L.append([])\n            D[n] = q\n        L[q].append(p)\n        p += 1\n    SL = list(S)\n    SL.sort()\n    p = 0\n    M = 1\n    for n in SL:\n        q = D[n]\n        if len(L[q]) == 1:\n            z = L[q][0]\n            if z < p:\n                M += 1\n            p = z\n        else:\n            v = L[q][-1]\n            if v > p:\n                k = 0\n                while L[q][k] < p:\n                    k += 1\n                p = L[q][k]\n            else:\n                M += 1\n                p = L[q][0]\n    print(M)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = 1\n    d = defaultdict(list)\n    for i in range(n):\n        d[arr[i]].append(i + 1)\n    ind = -10 ** 10\n    uno = list(set(arr))\n    uno.sort()\n    for i in uno:\n        f = 0\n        f2 = 0\n        k = 0\n        op = d[i]\n        for j in op:\n            if f2 == 0:\n                f2 = 1\n                ck = j\n            if j > ind:\n                ind = j\n                f = 1\n                break\n        if f == 0:\n            ind = ck\n            ans += 1\n    print(ans)", "def bs(x, prev, pict):\n    l = 0\n    r = len(pict[x]) - 1\n    while l <= r:\n        if r - l < 5:\n            for i in range(l, r + 1):\n                if pict[x][i] > prev:\n                    return pict[x][i]\n            return -1\n        mid = (l + r) // 2\n        if pict[x][mid] < prev:\n            l = mid + 1\n        else:\n            r = mid\n    return -1\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = list(map(int, input().split()))\n    li = []\n    pict = {}\n    for i in range(len(s)):\n        if pict.get(s[i]) is None:\n            pict[s[i]] = []\n            li.append(s[i])\n        pict[s[i]].append(i + 1)\n    li.sort()\n    count = 1\n    prev = 0\n    i = len(li)\n    for i in range(len(li)):\n        x = bs(li[i], prev, pict)\n        if x != -1:\n            prev = x\n        else:\n            count += 1\n            prev = pict[li[i]][0]\n    print(count)", "from collections import defaultdict as dd\nfrom bisect import insort as ins, bisect_right as br, bisect_left as bl\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().strip().split()))\n    d = dd(list)\n    for i in range(n):\n        ins(d[l[i]], i)\n    ct = 1\n    j = 0\n    for i in sorted(list(set(l))):\n        ind = bl(d[i], j)\n        if ind == len(d[i]):\n            ct += 1\n            j = d[i][0]\n        else:\n            j = d[i][ind]\n    print(ct)", "for t in range(int(input().strip())):\n    n = int(input().strip())\n    arr = tuple(map(int, input().strip().split()))\n    d = dict()\n    for i in range(n):\n        a = arr[i]\n        if a not in d:\n            d[a] = []\n        d[a].append(i)\n    s = sorted(d.keys())\n    pos = -1\n    m = 1\n    for a in s:\n        p = d[a]\n        mpos = p[0]\n        isfound = False\n        for i in p:\n            if pos < i:\n                isfound = True\n                pos = i\n                break\n        if not isfound:\n            pos = mpos\n            m += 1\n    print(m)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    d = {}\n    for i in range(n):\n        try:\n            d[a[i]].append(i)\n        except:\n            d[a[i]] = [i]\n    p = -1\n    ans = 1\n    for i in sorted(d.keys()):\n        f = 1\n        for j in d[i]:\n            if j > p:\n                p = j\n                f = 0\n                break\n        if f:\n            p = d[i][0]\n            ans = ans + 1\n    print(ans)", "from collections import defaultdict\nt = int(input())\nwhile t:\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(n):\n        d[a[i]].append(i)\n    id = -1\n    m = 1\n    for i in sorted(d):\n        f = 0\n        for j in d[i]:\n            if j > id:\n                f = 1\n                id = j\n                break\n        if f == 0:\n            m += 1\n            id = d[i][0]\n    print(m)\n    t -= 1", "from collections import defaultdict\nfrom bisect import bisect_right\nfor _ in range(int(input())):\n    int(input())\n    d = defaultdict(list)\n    for (i, x) in enumerate(map(int, input().split())):\n        d[x].append(i)\n    (i, m) = (-1, 1)\n    for x in sorted(d):\n        l = d[x]\n        j = bisect_right(l, i)\n        i = l[j % len(l)]\n        m += j // len(l)\n    print(m)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (b, m) = ([], 1)\n    for i in range(len(a)):\n        b.append([a[i], i])\n    b.sort()\n    i = 0\n    while b[i][0] < b[n - 1][0]:\n        j = i + 1\n        while j < n and b[j][0] == b[i][0]:\n            j += 1\n        k = j + 1\n        while k < n and b[k][0] == b[j][0]:\n            k += 1\n        y = j\n        while y < k:\n            if b[i][1] < b[y][1]:\n                break\n            y += 1\n        if y == k:\n            i = j\n            m += 1\n        else:\n            i = y\n    print(m)", "for _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    sett = list(set(ar))\n    sett.sort()\n    index = {i: [] for i in sett}\n    for i in range(n):\n        index[ar[i]].append(i)\n    prv = None\n    ans = 0\n    for i in index:\n        if prv == None:\n            prv = min(index[i])\n            ans += 1\n            continue\n        temp = max(index[i])\n        if temp < prv:\n            ans += 1\n            prv = index[i][0]\n            continue\n        for j in index[i]:\n            if prv < j:\n                prv = j\n                break\n    print(ans)", "from collections import *\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    s = list(set(a))\n    s.sort()\n    d = defaultdict(list)\n    for i in range(n):\n        d[a[i]].append(i)\n    ans = 1\n    curpos = min(d[s[0]])\n    for i in range(1, len(s)):\n        if curpos > max(d[s[i]]):\n            ans += 1\n            curpos = min(d[s[i]])\n        else:\n            for j in d[s[i]]:\n                if j > curpos:\n                    curpos = j\n                    break\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    list1 = list(map(int, input().split()))\n    listset = list(set(list1))\n    listset.sort()\n    dict1 = {}\n    for i in listset:\n        dict1[i] = []\n    for i in range(n):\n        dict1[list1[i]].append(i)\n    f = dict1[listset[0]][0]\n    ans = 1\n    for p in range(1, len(listset)):\n        if dict1[listset[p]][-1] > f:\n            for j in dict1[listset[p]]:\n                if j > f:\n                    f = j\n                    break\n        else:\n            ans += 1\n            f = dict1[listset[p]][0]\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    sr = list(set(a))\n    sr.sort()\n    for i in range(n):\n        if a[i] in d:\n            d[a[i]].append(i)\n        else:\n            d[a[i]] = [i]\n    ans = 1\n    st = d[sr[0]][0]\n    for i in range(1, len(sr)):\n        flag = 0\n        for j in d[sr[i]]:\n            if j > st:\n                st = j\n                flag = 1\n                break\n        if flag == 0:\n            st = d[sr[i]][0]\n            ans += 1\n    print(ans)", "def abc(l, m):\n    i = 0\n    j = len(l) - 1\n    ans = -1\n    while i <= j:\n        mid = i + (j - i) // 2\n        if l[mid] > m:\n            ans = mid\n            j = mid - 1\n        else:\n            i = mid + 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ans = 0\n    l = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        try:\n            d[l[i]] += [i]\n        except:\n            d[l[i]] = [i]\n    x = list(d.keys())\n    x.sort()\n    m = d[x[0]][0]\n    for i in x[1:]:\n        c = abc(d[i], m)\n        if c == -1:\n            ans += 1\n            m = d[i][0]\n        else:\n            m = d[i][c]\n    print(ans + 1)", "from collections import defaultdict\nt = int(input())\nwhile t:\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(n):\n        d[a[i]].append(i)\n    id = -1\n    m = 1\n    for i in sorted(d):\n        f = 0\n        for j in d[i]:\n            if j > id:\n                f = 1\n                id = j\n                break\n        if f == 0:\n            m += 1\n            id = d[i][0]\n    print(m)\n    t -= 1", "from bisect import bisect_left\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = sorted(a)\n    d = dict()\n    for i in range(n):\n        if not d.get(a[i], None):\n            d[a[i]] = []\n        d[a[i]].append(i)\n    i = 0\n    ans = 0\n    pos = 0\n    pre = -1\n    while i < len(b):\n        if pre == b[i]:\n            i += 1\n            continue\n        pre = b[i]\n        ind = bisect_left(d[b[i]], pos)\n        if ind == len(d[b[i]]):\n            ans += 1\n            pos = d[b[i]][0]\n        else:\n            pos = d[b[i]][ind]\n    print(ans + 1)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(n):\n        d[a[i]].append(i)\n    st = -100\n    m = 1\n    for i in sorted(d):\n        for j in d[i]:\n            if j > st:\n                st = j\n                break\n        else:\n            st = d[i][0]\n            m += 1\n    print(m)", "def getNext(l, prev):\n    if l[-1] < prev:\n        return l[0]\n    for x in l:\n        if x > prev:\n            return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        if a[i] in d:\n            d[a[i]].append(i)\n        else:\n            d[a[i]] = [i]\n    keys = sorted(d)\n    answer = 1\n    prev = min(d[keys[0]])\n    for i in range(1, len(keys)):\n        nextid = getNext(d[keys[i]], prev)\n        if nextid < prev:\n            answer += 1\n        prev = nextid\n    print(answer)", "def getNext(l, prev):\n    if l[-1] < prev:\n        return l[0]\n    for x in l:\n        if x > prev:\n            return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        if a[i] in d:\n            d[a[i]].append(i)\n        else:\n            d[a[i]] = [i]\n    keys = sorted(d)\n    answer = 1\n    prev = min(d[keys[0]])\n    for i in range(1, len(keys)):\n        nextid = getNext(d[keys[i]], prev)\n        if nextid < prev:\n            answer += 1\n        prev = nextid\n    print(answer)", "def getNext(l, prev):\n    x = max(l)\n    if x < prev:\n        return min(l)\n    for i in range(0, len(l)):\n        if l[i] > prev:\n            return l[i]\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        if a[i] in d:\n            d[a[i]].append(i)\n        else:\n            d[a[i]] = [i]\n    keys = sorted(d)\n    answer = 1\n    prev = min(d[keys[0]])\n    for i in range(1, len(keys)):\n        nextid = getNext(d[keys[i]], prev)\n        if nextid < prev:\n            answer += 1\n        prev = nextid\n    print(answer)", "def getNext(l, prev):\n    if l[-1] < prev:\n        return l[0]\n    for x in l:\n        if x > prev:\n            return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        if a[i] in d:\n            d[a[i]].append(i)\n        else:\n            d[a[i]] = [i]\n    keys = sorted(d)\n    answer = 1\n    prev = min(d[keys[0]])\n    for i in range(1, len(keys)):\n        nextid = getNext(d[keys[i]], prev)\n        if nextid < prev:\n            answer += 1\n        prev = nextid\n    print(answer)", "from sys import stdin, stdout\nimport math\nfrom itertools import permutations, combinations\nfrom collections import defaultdict\nfrom bisect import bisect_left\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\nfor t in range(I()):\n    n = I()\n    arr = L()\n    dict1 = {}\n    for i in range(n):\n        if arr[i] in dict1.keys():\n            dict1[arr[i]].append(i)\n        else:\n            dict1[arr[i]] = [i]\n    keys = sorted(dict1.keys())\n    l = len(keys)\n    flag = 0\n    ix = -1\n    count = 0\n    for i in range(l - 1):\n        if not flag:\n            ix = dict1[keys[i]][0]\n            for j in dict1[keys[i + 1]]:\n                if j > ix:\n                    ix = j\n                    flag = 1\n                    count += 1\n                    break\n        else:\n            flag = 0\n            for j in dict1[keys[i + 1]]:\n                if j > ix:\n                    ix = j\n                    flag = 1\n                    count += 1\n                    break\n    print(l - count)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = defaultdict(list)\n    for i in range(n):\n        q[a[i]].append(i)\n    p = list(set(a))\n    p.sort()\n    ans = 1\n    ind = -1\n    for i in p:\n        fg = 0\n        x = q[i]\n        for j in x:\n            if j > ind:\n                ind = j\n                fg = 1\n                break\n        if fg == 0:\n            ans += 1\n            ind = q[i][0]\n    print(ans)", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    nums = list(map(int, input().split()))\n    d = {}\n    l = []\n    for i in range(n):\n        if nums[i] in d:\n            d[nums[i]].append(i)\n        else:\n            d[nums[i]] = [i]\n            l.append(nums[i])\n    l.sort()\n    k = n\n    m = 0\n    for i in range(len(l)):\n        if d[l[i]][-1] < k:\n            m += 1\n            k = d[l[i]][0]\n        else:\n            p = d[l[i]]\n            s = len(p)\n            lo = 0\n            hi = s - 1\n            res = p[-1]\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                if p[mid] >= k:\n                    res = p[mid]\n                    hi = mid - 1\n                else:\n                    lo = mid + 1\n            k = res\n    print(m)\n    t -= 1", "import bisect\nmod = 1000000007\nfrom math import gcd\nimport sys\ninput = sys.stdin.readline\nfrom collections import defaultdict as dd, deque as dq\nt = int(input())\nwhile t:\n    n = int(input())\n    l = list(map(int, input().split()))\n    d = dd(list)\n    for i in range(n):\n        d[l[i]].append(i)\n    ls = sorted(list(set(l)))\n    n = len(ls)\n    pre = d[ls[0]][0]\n    mx = -1\n    le = 1\n    ii = 1\n    lol = 0\n    cou = 1\n    while ii < n:\n        ind = bisect.bisect_left(d[ls[ii]], pre)\n        if ind < len(d[ls[ii]]):\n            le += 1\n            pre = d[ls[ii]][ind]\n            ii += 1\n        else:\n            cou += 1\n            le = 1\n            pre = d[ls[ii]][0]\n            ii += 1\n    print(cou)\n    t -= 1", "import collections\nfrom sys import *\nimport bisect as bs\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = 1\n    d = {}\n    for i in range(n):\n        if a[i] not in d:\n            d[a[i]] = []\n        d[a[i]].append(i)\n    l = list(d.keys())\n    l.sort()\n    c = 0\n    for j in l:\n        ln = len(d[j])\n        v = bs.bisect_left(d[j], c)\n        if v == ln:\n            c = d[j][0] + 1\n            s += 1\n            continue\n        c = d[j][v] + 1\n    print(s)", "import math\nimport sys\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter, defaultdict, deque\nfrom functools import lru_cache, reduce\nfrom heapq import heapify, heappop, heappush\nfrom itertools import chain, combinations, permutations, product\nfrom typing import List, Dict\nsys.setrecursionlimit(10 ** 5 + 1)\ninput = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef read_int() -> int:\n    return int(input())\n\ndef read_n_int() -> list:\n    return [int(s) for s in input().split()]\n\ndef list2d(row, col, init=0) -> List[list]:\n    return [[init] * col for _ in range(row)]\nMOD = 10 ** 9 + 7\nT = read_int()\nfor _ in range(T):\n    N = read_int()\n    nums = read_n_int()\n    num_to_idx = defaultdict(list)\n    for (i, num) in enumerate(nums):\n        num_to_idx[num].append(i)\n    pre_idx = N\n    ans = 0\n    for num in sorted(num_to_idx.keys()):\n        cur_indices = num_to_idx[num]\n        if cur_indices[-1] < pre_idx:\n            pre_idx = num_to_idx[num][0]\n            ans += 1\n        else:\n            pre_idx = cur_indices[bisect_right(cur_indices, pre_idx)]\n    print(ans)", "def findM(A, n):\n    elemIdxMap = dict()\n    for i in range(n):\n        if A[i] in elemIdxMap:\n            elemIdxMap[A[i]].append(i)\n        else:\n            elemIdxMap[A[i]] = [i]\n    keys = sorted(elemIdxMap.keys())\n    connected = False\n    count = 0\n    prevIdx = -1\n    nKeys = len(keys)\n    for i in range(nKeys - 1):\n        if not connected:\n            prevIdx = elemIdxMap[keys[i]][0]\n            for idx in elemIdxMap[keys[i + 1]]:\n                if idx > prevIdx:\n                    connected = True\n                    count += 1\n                    prevIdx = idx\n                    break\n        else:\n            connected = False\n            for idx in elemIdxMap[keys[i + 1]]:\n                if idx > prevIdx:\n                    connected = True\n                    count += 1\n                    prevIdx = idx\n                    break\n    return nKeys - count\nfor _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    print(findM(A, n))", "T = int(input())\nfor _ in range(T):\n    n = int(input())\n    l = list(map(int, input().split()))\n    fin = list(set(l))\n    fin.sort()\n    ans = 1\n    dic = dict()\n    for i in range(len(l)):\n        if l[i] not in dic.keys():\n            dic[l[i]] = [i]\n        else:\n            dic[l[i]].append(i)\n    prev = dic[fin[0]][0]\n    for i in range(1, len(fin)):\n        flag = 0\n        for ind in dic[fin[i]]:\n            if ind > prev:\n                prev = ind\n                flag = 1\n                break\n        if flag == 0:\n            ans += 1\n            prev = dic[fin[i]][0]\n    print(ans)", "T = int(input())\nfor _ in range(T):\n    n = int(input())\n    l = list(map(int, input().split()))\n    fin = list(set(l))\n    fin.sort()\n    ans = 1\n    dic = dict()\n    for i in range(len(l)):\n        if l[i] not in dic.keys():\n            dic[l[i]] = [i]\n        else:\n            dic[l[i]].append(i)\n    prev = dic[fin[0]][0]\n    for i in range(1, len(fin)):\n        flag = 0\n        for ind in dic[fin[i]]:\n            if ind > prev:\n                prev = ind\n                flag = 1\n                break\n        if flag == 0:\n            ans += 1\n            prev = dic[fin[i]][0]\n    print(ans)", "import bisect\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    count = 0\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(n):\n        d[a[i]].append(i)\n    x = list(d.keys())\n    x.sort()\n    p = d[x[0]][0]\n    for i in range(1, len(x)):\n        l = bisect.bisect_right(d[x[i]], p)\n        if l == len(d[x[i]]):\n            p = d[x[i]][0]\n            count += 1\n        else:\n            p = d[x[i]][l]\n    print(count + 1)", "import bisect\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    count = 0\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(n):\n        d[a[i]].append(i)\n    x = list(d.keys())\n    x.sort()\n    p = d[x[0]][0]\n    for i in range(1, len(x)):\n        l = bisect.bisect_right(d[x[i]], p)\n        if l == len(d[x[i]]):\n            p = d[x[i]][0]\n            count += 1\n        else:\n            p = d[x[i]][l]\n    print(count + 1)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = 1\n    d = defaultdict(list)\n    for i in range(n):\n        d[arr[i]].append(i + 1)\n    ind = -10 ** 10\n    uno = list(set(arr))\n    uno.sort()\n    for i in uno:\n        f = 0\n        f2 = 0\n        k = 0\n        op = d[i]\n        for j in op:\n            if f2 == 0:\n                f2 = 1\n                ck = j\n            if j > ind:\n                ind = j\n                f = 1\n                break\n        if f == 0:\n            ind = ck\n            ans += 1\n    print(ans)", "def mForMaxSeq(arr, n):\n    eim = dict()\n    for i in range(n):\n        if arr[i] in eim:\n            eim[arr[i]].append(i)\n        else:\n            eim[arr[i]] = [i]\n    keys = sorted(eim.keys())\n    connected = False\n    count = 0\n    pI = -1\n    nKeys = len(keys)\n    for i in range(nKeys - 1):\n        if not connected:\n            pI = eim[keys[i]][0]\n            for idx in eim[keys[i + 1]]:\n                if idx > pI:\n                    connected = True\n                    count += 1\n                    pI = idx\n                    break\n        else:\n            connected = False\n            for idx in eim[keys[i + 1]]:\n                if idx > pI:\n                    connected = True\n                    count += 1\n                    pI = idx\n                    break\n    return nKeys - count\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(mForMaxSeq(arr, n))", "import collections\nfrom sys import *\nimport bisect as bs\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = 1\n    d = {}\n    for i in range(n):\n        if a[i] not in d:\n            d[a[i]] = []\n        d[a[i]].append(i)\n    l = list(d.keys())\n    l.sort()\n    c = 0\n    for j in l:\n        ln = len(d[j])\n        v = bs.bisect_left(d[j], c)\n        if v == ln:\n            c = d[j][0] + 1\n            s += 1\n            continue\n        c = d[j][v] + 1\n    print(s)", "def findM(A, n):\n    elemIdxMap = dict()\n    for i in range(n):\n        if A[i] in elemIdxMap:\n            elemIdxMap[A[i]].append(i)\n        else:\n            elemIdxMap[A[i]] = [i]\n    keys = sorted(elemIdxMap.keys())\n    connected = False\n    count = 0\n    prevIdx = -1\n    nKeys = len(keys)\n    for i in range(nKeys - 1):\n        if not connected:\n            prevIdx = elemIdxMap[keys[i]][0]\n            for idx in elemIdxMap[keys[i + 1]]:\n                if idx > prevIdx:\n                    connected = True\n                    count += 1\n                    prevIdx = idx\n                    break\n        else:\n            connected = False\n            for idx in elemIdxMap[keys[i + 1]]:\n                if idx > prevIdx:\n                    connected = True\n                    count += 1\n                    prevIdx = idx\n                    break\n    return nKeys - count\nfor _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    print(findM(A, n))", "t = int(input())\nfor j in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    s = list(set(l))\n    s.sort()\n    dic = {}\n    le = {}\n    for j in s:\n        dic[j] = []\n        le[j] = 0\n    for j in range(n):\n        dic[l[j]].append(j + 1)\n        le[l[j]] += 1\n    stack = [dic[s[0]][0]]\n    z = 0\n    m = 1\n    x = len(s)\n    for j in range(1, x):\n        flag = 0\n        for k in range(le[s[j]]):\n            if dic[s[j]][k] + (m - 1) * n > stack[z]:\n                stack.append(dic[s[j]][k] + (m - 1) * n)\n                z += 1\n                flag = 1\n                break\n        if flag == 0:\n            m += 1\n            stack.append(dic[s[j]][0] + (m - 1) * n)\n            z += 1\n    print(m)", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    u = list(set(l))\n    u.sort()\n    d = {}\n    for i in u:\n        d[i] = []\n    for i in range(n):\n        d[l[i]].append(i)\n    f = d[u[0]][0]\n    p = 1\n    m = 1\n    while p < len(u):\n        if d[u[p]][-1] > f:\n            for j in d[u[p]]:\n                if j > f:\n                    f = j\n                    p += 1\n                    break\n        else:\n            m += 1\n            f = d[u[p]][0]\n            p += 1\n    print(m)", "from collections import defaultdict\nfrom bisect import bisect_right\nI = input\nt = int(I())\nfor _ in range(t):\n    I()\n    d = defaultdict(list)\n    for (i, x) in enumerate(map(int, I().split())):\n        d[x].append(i)\n    (i, m) = (-1, 1)\n    for x in sorted(d):\n        l = d[x]\n        j = bisect_right(l, i)\n        if j == len(l):\n            m += 1\n            j = 0\n        i = l[j]\n    print(m)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    s = [int(i) for i in input().split()]\n    w = defaultdict(list)\n    for i in range(n):\n        w[s[i]].append(i)\n    typ = len(w)\n    keys = sorted(list(w.keys()))\n    length = len(keys)\n    ele_count = 1\n    i = 1\n    rnd = 0\n    val = keys[0]\n    pos = w[keys[0]][0]\n    while ele_count < typ:\n        if w[keys[ele_count]][-1] < pos:\n            rnd += 1\n            pos = w[keys[ele_count]][0]\n        else:\n            i = 0\n            while i < len(w[keys[ele_count]]) and w[keys[ele_count]][i] <= pos:\n                i += 1\n            pos = w[keys[ele_count]][i]\n        ele_count += 1\n    print(rnd + 1)", "from collections import defaultdict\nfrom bisect import bisect_right\nI = input\nt = int(I())\nfor _ in range(t):\n    I()\n    d = defaultdict(list)\n    for (i, x) in enumerate(map(int, I().split())):\n        d[x].append(i)\n    (i, m) = (-1, 1)\n    for x in sorted(d):\n        l = d[x]\n        j = bisect_right(l, i)\n        i = l[j % len(l)]\n        m += j // len(l)\n    print(m)", "import collections\nimport bisect\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = collections.defaultdict(list)\n    (c, find, ans, l) = (0, 0, 0, [])\n    for i in range(n):\n        if a[i] not in d:\n            l.append(a[i])\n            c += 1\n        d[a[i]].append(i)\n    l.sort()\n    for i in range(c):\n        if i == 0:\n            ans += 1\n            find = d[l[i]][0] + 1\n        else:\n            k = bisect.bisect_left(d[l[i]], find)\n            if k == 0:\n                find = d[l[i]][k] + 1\n            elif k == len(d[l[i]]):\n                find = d[l[i]][0] + 1\n                ans += 1\n            else:\n                find = d[l[i]][k] + 1\n    print(ans)", "from sys import stdin\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    final = {}\n    m = sorted(list(set(arr)))\n    count = 0\n    d = {}\n    for i in range(n):\n        if arr[i] in d:\n            d[arr[i]].append(i)\n        else:\n            d[arr[i]] = [i]\n    pos = d[m[0]][0]\n    j = 1\n    while j < len(m):\n        k = None\n        for item in d[m[j]]:\n            if item > pos:\n                k = item\n                break\n        if k != None:\n            j += 1\n            pos = k\n        else:\n            count += 1\n            pos = -1\n    print(count + 1)", "import collections\nimport bisect\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = collections.defaultdict(list)\n    c = 0\n    l = []\n    for i in range(n):\n        if a[i] not in d:\n            l.append(a[i])\n            c += 1\n        d[a[i]].append(i)\n    l.sort()\n    find = 0\n    ans = 0\n    for i in range(c):\n        if i == 0:\n            ans += 1\n            find = d[l[i]][0] + 1\n        else:\n            k = bisect.bisect_left(d[l[i]], find)\n            if k == 0:\n                find = d[l[i]][k] + 1\n            elif k == len(d[l[i]]):\n                find = d[l[i]][0] + 1\n                ans += 1\n            else:\n                find = d[l[i]][k] + 1\n    print(ans)", "from collections import defaultdict\nfrom bisect import bisect_right\nI = input\nt = int(I())\nfor _ in range(t):\n    I()\n    d = defaultdict(list)\n    for (i, x) in enumerate(map(int, I().split())):\n        d[x].append(i)\n    (i, m) = (-1, 1)\n    for x in sorted(d):\n        l = d[x]\n        j = bisect_right(l, i)\n        if j < len(l):\n            i = l[j]\n        else:\n            m += 1\n            i = l[0]\n    print(m)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = 1\n    d = defaultdict(list)\n    for i in range(n):\n        d[arr[i]].append(i + 1)\n    ind = -10 ** 10\n    uno = list(set(arr))\n    uno.sort()\n    for i in uno:\n        f = 0\n        f2 = 0\n        k = 0\n        op = d[i]\n        for j in op:\n            if f2 == 0:\n                f2 = 1\n                ck = j\n            if j > ind:\n                ind = j\n                f = 1\n                break\n        if f == 0:\n            ind = ck\n            ans += 1\n    print(ans)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = list(set(a))\n    s.sort()\n    ind = dict()\n    for i in range(n):\n        if a[i] in ind:\n            ind[a[i]].append(i)\n        else:\n            ind[a[i]] = [i]\n    s1 = 1\n    ref = -1\n    for i in s:\n        flag = 0\n        for j in ind[i]:\n            if j > ref:\n                ref = j\n                flag = 1\n                break\n        if flag == 0:\n            s1 += 1\n            ref = ind[i][0]\n    print(s1)", "def bs(x, prev, pict):\n    l = 0\n    r = len(pict[x]) - 1\n    while l <= r:\n        if r - l < 5:\n            for i in range(l, r + 1):\n                if pict[x][i] > prev:\n                    return pict[x][i]\n            return -1\n        mid = (l + r) // 2\n        if pict[x][mid] < prev:\n            l = mid + 1\n        else:\n            r = mid\n    return -1\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = list(map(int, input().split()))\n    li = []\n    pict = {}\n    for i in range(len(s)):\n        if pict.get(s[i]) is None:\n            pict[s[i]] = []\n            li.append(s[i])\n        pict[s[i]].append(i + 1)\n    li.sort()\n    count = 1\n    prev = 0\n    i = len(li)\n    for i in range(len(li)):\n        x = bs(li[i], prev, pict)\n        if x != -1:\n            prev = x\n        else:\n            count += 1\n            prev = pict[li[i]][0]\n    print(count)", "for T in range(int(input())):\n    N = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    elements = []\n    for i in range(N):\n        if a[i] not in d:\n            d[a[i]] = [i]\n            elements.append(a[i])\n        else:\n            d[a[i]].append(i)\n    elements.sort()\n    M = 1\n    prev_index = d[elements[0]][0]\n    for i in range(1, len(elements)):\n        flag = True\n        for j in range(len(d[elements[i]])):\n            if prev_index < d[elements[i]][j]:\n                flag = False\n                prev_index = d[elements[i]][j]\n                break\n        if flag:\n            M += 1\n            prev_index = d[elements[i]][0]\n    print(M)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = set(a)\n    b = list(b)\n    b.sort()\n    c = dict()\n    for i in range(n):\n        if a[i] in c:\n            c[a[i]].append(i)\n        else:\n            c[a[i]] = [i]\n    index = -1\n    count = 0\n    for i in range(len(b)):\n        r = c[b[i]]\n        flag = 0\n        for j in range(len(r)):\n            if r[j] > index:\n                flag = 1\n                index = r[j]\n                break\n        if flag != 1:\n            index = r[0]\n            count += 1\n    print(count + 1)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    s = list(map(int, input().split()))\n    r = defaultdict(list)\n    for i in range(n):\n        r[s[i]].append(i)\n    t = sorted(r.keys())\n    N = len(t)\n    l = r[t[0]][0]\n    ans = 1\n    for i in range(1, N):\n        flag = 0\n        for j in r[t[i]]:\n            if j >= l:\n                l = j\n                flag = 1\n                break\n        if flag == 0:\n            ans += 1\n            l = r[t[i]][0]\n    print(ans)", "def main():\n    from bisect import bisect_left as bl, bisect_right as br, insort\n    import sys\n    import heapq\n    from collections import defaultdict as dd, deque\n\n    def data():\n        return sys.stdin.readline().strip()\n\n    def mdata():\n        return list(map(int, data().split()))\n    out = sys.stdout.write\n    INF = int(1000000000.0)\n    mod = int(1000000000.0) + 7\n    for t in range(int(data())):\n        n = int(data())\n        A = mdata()\n        d = dd(list)\n        for i in range(n):\n            d[A[i]].append(i)\n        l = sorted(d.keys())\n        cnt = 1\n        ind = d[l[0]][0]\n        for i in range(1, len(l)):\n            k = bl(d[l[i]], ind)\n            if k == len(d[l[i]]):\n                cnt += 1\n                ind = d[l[i]][0]\n            else:\n                ind = d[l[i]][k]\n        print(cnt)\nmain()", "from sys import stdin\ninput = stdin.readline\nfrom bisect import bisect_right\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {i: [] for i in a}\n    for (i, j) in enumerate(a):\n        d[j].append(i)\n    ans = 1\n    l = tuple((r[1] for r in sorted(d.items())))\n    p = 0\n    for i in range(len(l) - 1):\n        x = bisect_right(l[i + 1], l[i][p])\n        if x == len(l[i + 1]):\n            ans += 1\n            p = 0\n        else:\n            p = x\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().strip().split()]\n    a = [(a[i], i) for i in range(n)]\n    a.sort()\n    res = 1\n    prev = 0\n    prev_ind = -1\n    i = 0\n    while i < n:\n        if a[i][1] > prev_ind:\n            prev_ind = a[i][1]\n            prev = a[i][0]\n            while i < n and a[i][0] == prev:\n                i += 1\n        else:\n            prev = a[i][0]\n            flag = False\n            mn = a[i][1]\n            while i < n and a[i][0] == prev:\n                if a[i][1] > prev_ind:\n                    prev_ind = a[i][1]\n                    flag = True\n                    break\n                i += 1\n            if flag:\n                while i < n and a[i][0] == prev:\n                    i += 1\n            else:\n                res += 1\n                prev_ind = mn\n    print(res)", "import bisect\n\ndef solve(arr, n, ans):\n    indices = {}\n    dist_vals = []\n    for i in range(n):\n        if arr[i] not in indices.keys():\n            indices[arr[i]] = []\n            dist_vals.append(arr[i])\n        indices[arr[i]].append(i)\n    dist_vals.sort()\n    m = 1\n    index = -1\n    i = 0\n    while i < len(dist_vals):\n        x = dist_vals[i]\n        index = bisect.bisect(indices[x], index)\n        if index == len(indices[x]):\n            m += 1\n            index = -1\n        else:\n            index = indices[x][index]\n            i += 1\n    ans.append(m)\n\ndef main():\n    t = int(input())\n    ans = []\n    for i in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        solve(arr, n, ans)\n    for i in ans:\n        print(i)\nmain()", "import math\nimport collections\nfrom sys import *\nimport bisect as bs\nT = int(stdin.readline())\nfor _ in range(T):\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    ans = 1\n    d = {}\n    for i in range(n):\n        if a[i] not in d:\n            d[a[i]] = []\n        d[a[i]].append(i)\n    dk = list(d.keys())\n    dk.sort()\n    cur = 0\n    for k in dk:\n        l = len(d[k])\n        v = bs.bisect_left(d[k], cur)\n        if v == l:\n            cur = d[k][0] + 1\n            ans += 1\n            continue\n        cur = d[k][v] + 1\n    print(ans)", "from collections import defaultdict\nimport bisect\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    A = [int(j) for j in input().split()]\n    d = defaultdict(list)\n    for (j, i) in enumerate(A):\n        d[i].append(j)\n    keys = sorted(d.keys())\n    pk = 0\n    ans = 1\n    prev = None\n    for i in keys:\n        pos = bisect.bisect_left(d[i], pk)\n        if pos == len(d[i]):\n            pos = 0\n            ans += 1\n        pos = d[i][pos]\n        pk = pos\n    print(ans)", "import sys\nfrom collections import defaultdict\nfrom copy import copy\nMOD = 998244353\nR = lambda t=int: t(input())\nRL = lambda t=int: [t(x) for x in input().split()]\nRLL = lambda n, t=int: [RL(t) for _ in range(n)]\n\ndef solve():\n    n = R()\n    A = RL()\n    r = 1\n    x = sorted(set(A))\n    P = {}\n    i = 0\n    for a in A:\n        if a not in P:\n            P[a] = []\n        P[a] += [i]\n        i += 1\n    l = len(x)\n    i = 0\n    p = -1\n    r = 1\n    for a in x:\n        moved = False\n        for x in P[a]:\n            if x > p:\n                p = x\n                moved = True\n                break\n        if not moved:\n            p = P[a][0]\n            r += 1\n    print(r)\nT = R()\nfor _ in range(T):\n    solve()"]