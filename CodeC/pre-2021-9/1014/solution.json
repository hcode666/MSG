["def backtrack(k, A, ans):\n    if k == 7:\n        return True\n    if ans[k] != -1:\n        return backtrack(k + 1, A, ans)\n    for i in range(1, 7):\n        if A[k][i] and ans[k] == -1 and (ans[i] == -1):\n            ans[k] = i\n            ans[i] = k\n            solved = backtrack(k + 1, A, ans)\n            if solved:\n                return True\n            else:\n                ans[k] = -1\n                ans[i] = -1\n    return False\n\ndef solution():\n    n = int(input())\n    P = [[True for x in range(7)] for x in range(7)]\n    for i in range(1, 7):\n        P[i][i] = False\n    A = list(map(int, input().split()))\n    no_solution = False\n    last_num = A[0]\n    for i in range(1, n):\n        num = A[i]\n        if last_num == num:\n            no_solution = True\n        P[last_num][num] = False\n        P[num][last_num] = False\n        last_num = num\n    if no_solution:\n        print(-1)\n        return\n    ans = [-1 for x in range(7)]\n    if backtrack(1, P, ans):\n        print(' '.join(map(str, ans[1:])))\n    else:\n        print(-1)\nT = int(input())\nwhile T > 0:\n    T = T - 1\n    solution()", "def backtrack(k, A, ans):\n    if k == 7:\n        return True\n    if ans[k] != -1:\n        return backtrack(k + 1, A, ans)\n    for i in range(1, 7):\n        if A[k][i] and ans[k] == -1 and (ans[i] == -1):\n            ans[k] = i\n            ans[i] = k\n            solved = backtrack(k + 1, A, ans)\n            if solved:\n                return True\n            else:\n                ans[k] = -1\n                ans[i] = -1\n    return False\n\ndef solution():\n    n = int(input())\n    P = [[True for x in range(7)] for x in range(7)]\n    for i in range(1, 7):\n        P[i][i] = False\n    A = list(map(int, input().split()))\n    no_solution = False\n    last_num = A[0]\n    for i in range(1, n):\n        num = A[i]\n        if last_num == num:\n            no_solution = True\n        P[last_num][num] = False\n        P[num][last_num] = False\n        last_num = num\n    if no_solution:\n        print(-1)\n        return\n    ans = [-1 for x in range(7)]\n    if backtrack(1, P, ans):\n        print(' '.join(map(str, ans[1:])))\n    else:\n        print(-1)\nT = int(input())\nwhile T > 0:\n    T = T - 1\n    solution()", "def backtrack(k, A, ans):\n    if k == 7:\n        return True\n    if ans[k] != -1:\n        return backtrack(k + 1, A, ans)\n    for i in range(1, 7):\n        if A[k][i] and ans[k] == -1 and (ans[i] == -1):\n            ans[k] = i\n            ans[i] = k\n            solved = backtrack(k + 1, A, ans)\n            if solved:\n                return True\n            else:\n                ans[k] = -1\n                ans[i] = -1\n    return False\n\ndef solution():\n    n = int(input())\n    P = [[True for x in range(7)] for x in range(7)]\n    for i in range(1, 7):\n        P[i][i] = False\n    A = list(map(int, input().split()))\n    no_solution = False\n    last_num = A[0]\n    for i in range(1, n):\n        num = A[i]\n        if last_num == num:\n            no_solution = True\n        P[last_num][num] = False\n        P[num][last_num] = False\n        last_num = num\n    if no_solution:\n        print(-1)\n        return\n    ans = [-1 for x in range(7)]\n    if backtrack(1, P, ans):\n        print(' '.join(map(str, ans[1:])))\n    else:\n        print(-1)\nT = int(input())\nwhile T > 0:\n    T = T - 1\n    solution()", "from itertools import permutations\n\ndef solve(n, a):\n    ans = []\n    for des in desire:\n        check = 1\n        for i in range(n - 1):\n            if a[i] == a[i + 1]:\n                return [-1]\n            if a[i + 1] == des[a[i] - 1]:\n                check = 0\n                break\n        if check:\n            ans = des\n            break\n    if ans:\n        return ans\n    return [-1]\nper = permutations([1, 2, 3, 4, 5, 6])\ndesire = []\nfor p in per:\n    check = 1\n    for i in range(1, 7):\n        if p[i - 1] == i:\n            check = 0\n            break\n    if check:\n        doublecheck = 1\n        for i in range(6):\n            if p[p[i] - 1] != i + 1:\n                doublecheck = 0\n                break\n        if doublecheck:\n            desire.append(p)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(*solve(n, a))", "from itertools import permutations\n\ndef solve(n, a):\n    ans = []\n    for des in desire:\n        check = 1\n        for i in range(n - 1):\n            if a[i] == a[i + 1]:\n                return [-1]\n            if a[i + 1] == des[a[i] - 1]:\n                check = 0\n                break\n        if check:\n            ans = des\n            break\n    if ans:\n        return ans\n    return [-1]\nper = permutations([1, 2, 3, 4, 5, 6])\ndesire = []\nfor p in per:\n    check = 1\n    for i in range(1, 7):\n        if p[i - 1] == i:\n            check = 0\n            break\n    if check:\n        doublecheck = 1\n        for i in range(6):\n            if p[p[i] - 1] != i + 1:\n                doublecheck = 0\n                break\n        if doublecheck:\n            desire.append(p)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(*solve(n, a))", "t = int(input())\ndi = []\nfor i in range(15):\n    ab = [2, 3, 4, 5, 6]\n    te = [0, 0, 0, 0, 0, 0]\n    te[0] = i // 3 + 2\n    te[i // 3 + 1] = 1\n    ab.remove(i // 3 + 2)\n    x1 = ab.pop(0)\n    te[x1 - 1] = ab[i % 3]\n    te[ab[i % 3] - 1] = x1\n    ab.pop(i % 3)\n    te[ab[0] - 1] = ab[1]\n    te[ab[1] - 1] = ab[0]\n    di.append(te)\nfor i in range(t):\n    flag = 0\n    n = int(input())\n    a = list(map(int, input().strip().split()))\n    for j in range(15):\n        f = 0\n        for k in range(n - 1):\n            if di[j][a[k] - 1] == a[k + 1] or a[k] == a[k + 1]:\n                f = 1\n                break\n        if f == 1:\n            continue\n        else:\n            for z in di[j]:\n                print(z, end=' ')\n            print()\n            flag = 1\n            break\n    if flag == 0:\n        print(-1)", "def getmintuple(a, b):\n    if a > b:\n        (a, b) = (b, a)\n    return (a, b)\n\ndef generatepairs(b):\n    p = []\n    for j in range(1, 7):\n        if j not in sol and j != b:\n            if getmintuple(b, j) not in q:\n                p.append(j)\n    return p\n\ndef unusedfromsol():\n    for i in range(1, 7):\n        if i not in sol:\n            return i\ntc = int(input())\nfor case in range(tc):\n    n = int(input())\n    arr = [int(x) for x in input().split(' ')]\n    q = {}\n    solution = 0\n    for i in range(1, n):\n        a = arr[i - 1]\n        b = arr[i]\n        (a, b) = getmintuple(a, b)\n        if a == b:\n            solution = -1\n        q[a, b] = True\n    if solution == -1:\n        print(-1)\n        continue\n    i = 1\n    turns = 0\n    sol = [-1] * 7\n    sol[0] = False\n    nextinp = False\n    for turns in range(3):\n        a1 = unusedfromsol()\n        for blvl1 in generatepairs(a1):\n            sol[blvl1] = a1\n            sol[a1] = blvl1\n            a2 = unusedfromsol()\n            for blvl2 in generatepairs(a2):\n                sol[blvl2] = a2\n                sol[a2] = blvl2\n                a3 = unusedfromsol()\n                for blvl3 in generatepairs(a3):\n                    sol[blvl3] = a3\n                    sol[a3] = blvl3\n                    if -1 not in sol:\n                        for k in range(1, 7):\n                            print(sol[k], end=' ')\n                        print()\n                        nextinp = True\n                        break\n                if nextinp:\n                    break\n                sol[blvl2] = -1\n                sol[a2] = -1\n            if nextinp:\n                break\n            sol[blvl1] = -1\n            sol[a1] = -1\n        if nextinp:\n            break\n    if not nextinp:\n        print(-1)", "ori = [[2, 1, 4, 3, 6, 5], [2, 1, 5, 6, 3, 4], [2, 1, 6, 5, 4, 3], [3, 4, 1, 2, 6, 5], [3, 5, 1, 6, 2, 4], [3, 6, 1, 5, 4, 2], [4, 3, 2, 1, 6, 5], [4, 5, 6, 1, 2, 3], [4, 6, 5, 1, 3, 2], [5, 3, 2, 6, 1, 4], [5, 4, 6, 2, 1, 3], [5, 6, 4, 3, 1, 2], [6, 3, 2, 5, 4, 1], [6, 4, 5, 2, 3, 1], [6, 5, 4, 3, 2, 1]]\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    d = [[] for i in range(7)]\n    lol = False\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            print('-1')\n            lol = True\n            break\n        d[a[i - 1]].append(a[i])\n        d[a[i]].append(a[i - 1])\n    if lol:\n        continue\n    for x in ori:\n        for i in range(1, 6):\n            if d[i].count(x[i - 1]) > 0:\n                break\n        else:\n            print(*x)\n            break\n    else:\n        print('-1')", "from itertools import permutations\nfor _ in range(int(input())):\n    flag1 = True\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    d = {k: set(range(1, 7)) for k in range(1, 7)}\n    for k in range(1, 7):\n        d[k].discard(k)\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            flag1 = False\n            print(-1)\n            break\n        d[a[i]].discard(a[i + 1])\n        d[a[i + 1]].discard(a[i])\n    if flag1:\n        flag2 = True\n        for p in permutations(range(1, 7)):\n            flag3 = True\n            for i in range(1, 7):\n                b = p[i - 1]\n                if p[b - 1] != i or b not in d[i]:\n                    flag3 = False\n                    break\n            if flag3:\n                flag2 = False\n                print(*p)\n                break\n        if flag2:\n            print(-1)", "def dfs(src, vis):\n    vis.remove(src)\n    for dst in D[src]:\n        if dst in vis:\n            vis.remove(dst)\n            if len(vis) == 0:\n                vis.add(src)\n                vis.add(dst)\n                return (True, [(src, dst)])\n            e = vis.pop()\n            vis.add(e)\n            (val, ret) = dfs(e, vis)\n            if val:\n                vis.add(src)\n                vis.add(dst)\n                ret.append((src, dst))\n                return (val, ret)\n            vis.add(dst)\n    vis.add(src)\n    return (False, None)\nT = int(input().strip())\nwhile T:\n    N = int(input().strip())\n    B = True\n    E = [0] * 7\n    A = [int(x) for x in input().strip().split()]\n    C = {1, 2, 3, 4, 5, 6}\n    D = {1: C - {1}, 2: C - {2}, 3: C - {3}, 4: C - {4}, 5: C - {5}, 6: C - {6}}\n    for i in range(1, N):\n        if A[i] == A[i - 1]:\n            B = False\n            break\n        if A[i - 1] in D[A[i]]:\n            D[A[i]].remove(A[i - 1])\n            D[A[i - 1]].remove(A[i])\n        if len(D[A[i]]) == 0 or len(D[A[i - 1]]) == 0:\n            B = False\n            break\n    if B:\n        (val, vis) = dfs(1, C)\n        if val:\n            E[vis[0][0]] = vis[0][1]\n            E[vis[0][1]] = vis[0][0]\n            E[vis[1][0]] = vis[1][1]\n            E[vis[1][1]] = vis[1][0]\n            E[vis[2][0]] = vis[2][1]\n            E[vis[2][1]] = vis[2][0]\n            print(E[1], E[2], E[3], E[4], E[5], E[6])\n        else:\n            print(-1)\n    else:\n        print(-1)\n    T -= 1", "def allPairs(n):\n    if len(n) == 2:\n        return [[tuple(n)]]\n    ret = []\n    for y in n[1:]:\n        ret0 = allPairs([z for z in n[1:] if z != y])\n        ret0 = [[(n[0], y)] + z for z in ret0]\n        ret += ret0\n    return ret\nallp = allPairs(list(range(1, 7)))\n\ndef getOpposites(a):\n    ret = [0] * 6\n    for (x, y) in a:\n        ret[x - 1] = str(y)\n        ret[y - 1] = str(x)\n    return ret\n\ndef getResult(x):\n    aa = allp\n    for (i, y) in enumerate(x[:-1]):\n        z = x[i + 1]\n        q = tuple(sorted([y, z]))\n        if y == z:\n            return '-1'\n        aa = [a for a in aa if q not in a]\n        if not aa:\n            return '-1'\n    return ' '.join(getOpposites(aa[0]))\nimport sys\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    n = int(f.readline())\n    x = list(map(int, f.readline().split()))\n    print(getResult(x))", "T = int(input())\n\ndef findSolution(currentSolution, adj):\n    if len(currentSolution) == 6:\n        return currentSolution\n    for i in range(1, 7):\n        if i in currentSolution:\n            continue\n        for a in range(1, 7):\n            if a not in currentSolution and a != i and (a not in adj[i]):\n                copy = dict(currentSolution)\n                copy[i] = a\n                copy[a] = i\n                r = findSolution(copy, adj)\n                if r != -1:\n                    return r\n        break\n    return -1\nfor TCN in range(T):\n    N = int(input())\n    adj = {x: set() for x in range(1, 7)}\n    wk = True\n    ins = [int(i) for i in input().split()]\n    for (a, b) in zip(ins, ins[1:]):\n        adj[a].add(b)\n        adj[b].add(a)\n    for die in range(1, 7):\n        if die in adj[die]:\n            wk = False\n            print(-1)\n            break\n        if len(adj[die]) > 4:\n            wk = False\n            print(-1)\n            break\n    if not wk:\n        continue\n    sol = findSolution(dict(), adj)\n    if sol == -1:\n        print(-1)\n    else:\n        print(' '.join([str(sol[i]) for i in range(1, 7)]))", "from itertools import permutations\ncases = int(input())\n\ndef is_valid(p):\n    for index in range(6):\n        if index + 1 != p[p[index] - 1] or index + 1 == p[index]:\n            return False\n    return True\n\ndef satisfies(p, opps):\n    for index in range(6):\n        if p[index] in opps[index]:\n            return False\n    return True\nfor _ in range(cases):\n    rolls = int(input())\n    array = list(map(int, input().split()))\n    opps = [set() for k in range(1, 7)]\n    if len(array) >= 2:\n        opps[array[0] - 1].add(array[1])\n        opps[array[-1] - 1].add(array[-2])\n    for index in range(1, rolls - 1):\n        opps[array[index] - 1].add(array[index - 1])\n        opps[array[index] - 1].add(array[index + 1])\n    poss = True\n    for index in range(6):\n        for item in opps[index]:\n            if item == index + 1:\n                poss = False\n                break\n        if len(opps[index]) == 5:\n            poss = False\n            break\n    o = False\n    for p in permutations((1, 2, 3, 4, 5, 6)):\n        if poss and is_valid(p) and satisfies(p, opps):\n            o = True\n            print(' '.join(list(map(str, p))))\n            break\n    if not o:\n        print(-1)"]