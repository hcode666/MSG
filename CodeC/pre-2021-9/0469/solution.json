["def binary_search(s_l, c):\n    low = 0\n    high = len(s_l) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if s_l[mid] == c:\n            return -1\n        elif s_l[mid] > c:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low\n(a, b) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(b):\n    c = int(input())\n    a = binary_search(l, c)\n    if a == -1:\n        print(0)\n    elif a > len(l):\n        print('POSITIVE')\n    elif (len(l) - a) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def binary_search(s_l, c):\n    low = 0\n    high = len(s_l) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if s_l[mid] == c:\n            return -1\n        elif s_l[mid] > c:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low\n(a, b) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(b):\n    c = int(input())\n    a = binary_search(l, c)\n    if a == -1:\n        print(0)\n    elif a > len(l):\n        print('POSITIVE')\n    elif (len(l) - a) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def binary_search(s_l, c):\n    low = 0\n    high = len(s_l) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if s_l[mid] == c:\n            return -1\n        elif s_l[mid] > c:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low\n(a, b) = map(int, input().split())\nl = list(map(int, input().split()))\ns_l = sorted(l)\nfor i in range(b):\n    c = int(input())\n    a = binary_search(s_l, c)\n    if a == -1:\n        print(0)\n    elif a > len(s_l):\n        print('POSITIVE')\n    elif (len(s_l) - a) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nfor q in range(k):\n    x = int(input())\n    inde = -2\n    l = 0\n    r = n - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if arr[mid] == x:\n            inde = 'found'\n            break\n        elif arr[mid] < x and (mid == n - 1 or arr[mid + 1] > x):\n            inde = mid + 1\n            break\n        elif arr[mid] > x and mid == 0:\n            inde = mid\n            break\n        elif arr[mid] > x:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if inde == 'found':\n        print(0)\n    elif inde % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nfor q in range(k):\n    x = int(input())\n    index = -2\n    l = 0\n    r = n - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if arr[mid] == x:\n            index = 'found'\n            break\n        elif arr[mid] < x and (mid == n - 1 or arr[mid + 1] > x):\n            index = mid + 1\n            break\n        elif arr[mid] > x and mid == 0:\n            index = mid\n            break\n        elif arr[mid] > x:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if index == 'found':\n        print(0)\n    elif index % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nfor q in range(k):\n    x = int(input())\n    inde = -2\n    l = 0\n    r = n - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if arr[mid] == x:\n            inde = 'found'\n            break\n        elif arr[mid] < x and (mid == n - 1 or arr[mid + 1] > x):\n            inde = mid + 1\n            break\n        elif arr[mid] > x and mid == 0:\n            inde = mid\n            break\n        elif arr[mid] > x:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if inde == 'found':\n        print(0)\n    elif inde % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nfor q in range(k):\n    x = int(input())\n    inde = -2\n    l = 0\n    r = n - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if arr[mid] == x:\n            inde = 'found'\n            break\n        elif arr[mid] < x and (mid == n - 1 or arr[mid + 1] > x):\n            inde = mid + 1\n            break\n        elif arr[mid] > x and mid == 0:\n            inde = mid\n            break\n        elif arr[mid] > x:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if inde == 'found':\n        print(0)\n    elif inde % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nfor q in range(k):\n    x = int(input())\n    inde = -2\n    l = 0\n    r = n - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if arr[mid] == x:\n            inde = 'found'\n            break\n        elif arr[mid] < x and (mid == n - 1 or arr[mid + 1] > x):\n            inde = mid + 1\n            break\n        elif arr[mid] > x and mid == 0:\n            inde = mid\n            break\n        elif arr[mid] > x:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if inde == 'found':\n        print(0)\n    elif inde % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nfor q in range(k):\n    x = int(input())\n    inde = -2\n    l = 0\n    r = n - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if arr[mid] == x:\n            inde = 'found'\n            break\n        elif arr[mid] < x and (mid == n - 1 or arr[mid + 1] > x):\n            inde = mid + 1\n            break\n        elif arr[mid] > x and mid == 0:\n            inde = mid\n            break\n        elif arr[mid] > x:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if inde == 'found':\n        print(0)\n    elif inde % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nfor q in range(k):\n    x = int(input())\n    inde = -2\n    l = 0\n    r = n - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if arr[mid] == x:\n            inde = 'found'\n            break\n        elif arr[mid] < x and (mid == n - 1 or arr[mid + 1] > x):\n            inde = mid + 1\n            break\n        elif arr[mid] > x and mid == 0:\n            inde = mid\n            break\n        elif arr[mid] > x:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if inde == 'found':\n        print(0)\n    elif inde % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "(N, Q) = [int(x) for x in input().split()]\narr = [int(x) for x in input().split()]\narr = sorted(arr)\nsigns = [(-1) ** n for n in range(N + 1)]\nif signs[-1] == -1:\n    signs = [-1 * x for x in signs]\nsigns = ['POSITIVE' if x is 1 else 'NEGATIVE' for x in signs]\nfor _ in range(Q):\n    x = int(input())\n    mid = N // 2\n    high = N - 1\n    low = 0\n    flag = -2\n    while high - low >= 1 and mid >= 0 and (high <= N - 1) and (high >= 0) and (low >= 0) and (low <= N - 1):\n        if high == low + 1 or high == low:\n            break\n        if arr[mid] < x and mid >= 1:\n            low = mid + 1\n        if arr[mid] > x and mid < N - 1:\n            high = mid - 1\n        if arr[mid] == x:\n            flag = 1\n            break\n        mid = (high + low) // 2\n    if flag == 1:\n        print(0)\n    else:\n        if x > arr[low] and x < arr[high] and (high != N - 1):\n            print(signs[high])\n        if x > arr[low] and x > arr[high] and (high < N - 1):\n            print(signs[high + 1])\n        if x > arr[high] and high == N - 1:\n            print(signs[N])\n        if x < arr[low] and x < arr[high]:\n            print(signs[low])\n        if x == arr[low] or x == arr[high]:\n            print(0)", "(N, Q) = [int(x) for x in input().split()]\narr = [int(x) for x in input().split()]\narr = sorted(arr)\nsigns = [(-1) ** n for n in range(N + 1)]\nif signs[-1] == -1:\n    signs = [-1 * x for x in signs]\nsigns = ['POSITIVE' if x is 1 else 'NEGATIVE' for x in signs]\nfor _ in range(Q):\n    x = int(input())\n    mid = N // 2\n    high = N - 1\n    low = 0\n    flag = -2\n    while high - low >= 1 and mid >= 0 and (high <= N - 1) and (high >= 0) and (low >= 0) and (low <= N - 1):\n        if high == low + 1 or high == low:\n            break\n        if arr[mid] < x and mid >= 1:\n            low = mid + 1\n        if arr[mid] > x and mid < N - 1:\n            high = mid - 1\n        if arr[mid] == x:\n            flag = 1\n            break\n        mid = (high + low) // 2\n    if flag == 1:\n        print(0)\n    else:\n        if x > arr[low] and x < arr[high] and (high != N - 1):\n            print(signs[high])\n        if x > arr[low] and x > arr[high] and (high < N - 1):\n            print(signs[high + 1])\n        if x > arr[high] and high == N - 1:\n            print(signs[N])\n        if x < arr[low] and x < arr[high]:\n            print(signs[low])\n        if x == arr[low] or x == arr[high]:\n            print(0)", "def b(arr, x):\n    l = 0\n    r = len(arr)\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] == x:\n            return -1\n        elif x > arr[m]:\n            l = m + 1\n        else:\n            r = m - 1\n        if l == len(arr):\n            return l\n    return l\n(n, q) = map(int, input().split(' '))\nar = [int(x) for x in input().split(' ')]\nar = sorted(ar)\nfor i in range(q):\n    a = b(ar, int(input()))\n    if a == -1:\n        print(0)\n    else:\n        print('POSITIVE' if a % 2 == 0 else 'NEGATIVE')", "(N, Q) = [int(x) for x in input().split()]\narr = [int(x) for x in input().split()]\narr = sorted(arr)\nsigns = [(-1) ** n for n in range(N + 1)]\nif signs[-1] == -1:\n    signs = [-1 * x for x in signs]\nsigns = ['POSITIVE' if x is 1 else 'NEGATIVE' for x in signs]\nfor _ in range(Q):\n    x = int(input())\n    mid = N // 2\n    high = N - 1\n    low = 0\n    flag = -2\n    while high - low >= 1 and mid >= 0 and (high <= N - 1) and (high >= 0) and (low >= 0) and (low <= N - 1):\n        if high == low + 1 or high == low:\n            break\n        if arr[mid] < x and mid >= 1:\n            low = mid + 1\n        if arr[mid] > x and mid < N - 1:\n            high = mid - 1\n        if arr[mid] == x:\n            flag = 1\n            break\n        mid = (high + low) // 2\n    if flag == 1:\n        print(0)\n    else:\n        if x > arr[low] and x < arr[high] and (high != N - 1):\n            print(signs[high])\n        if x > arr[low] and x > arr[high] and (high < N - 1):\n            print(signs[high + 1])\n        if x > arr[high] and high == N - 1:\n            print(signs[N])\n        if x < arr[low] and x < arr[high]:\n            print(signs[low])\n        if x == arr[low] or x == arr[high]:\n            print(0)", "(N, Q) = [int(x) for x in input().split()]\narr = [int(x) for x in input().split()]\narr = sorted(arr)\nsigns = [(-1) ** n for n in range(N + 1)]\nif signs[-1] == -1:\n    signs = [-1 * x for x in signs]\nsigns = ['POSITIVE' if x is 1 else 'NEGATIVE' for x in signs]\nfor _ in range(Q):\n    x = int(input())\n    mid = N // 2\n    high = N - 1\n    low = 0\n    flag = -2\n    while high - low >= 1 and mid >= 0 and (high <= N - 1) and (high >= 0) and (low >= 0) and (low <= N - 1):\n        if high == low + 1 or high == low:\n            break\n        if arr[mid] < x and mid >= 1:\n            low = mid + 1\n        if arr[mid] > x and mid < N - 1:\n            high = mid - 1\n        if arr[mid] == x:\n            flag = 1\n            break\n        mid = (high + low) // 2\n    if flag == 1:\n        print(0)\n    else:\n        if x > arr[low] and x < arr[high] and (high != N - 1):\n            print(signs[high])\n        if x > arr[low] and x > arr[high] and (high < N - 1):\n            print(signs[high + 1])\n        if x > arr[high] and high == N - 1:\n            print(signs[N])\n        if x < arr[low] and x < arr[high]:\n            print(signs[low])\n        if x == arr[low] or x == arr[high]:\n            print(0)", "(N, Q) = [int(x) for x in input().split()]\narr = [int(x) for x in input().split()]\narr = sorted(arr)\nsigns = [(-1) ** n for n in range(N + 1)]\nif signs[-1] == -1:\n    signs = [-1 * x for x in signs]\nsigns = ['POSITIVE' if x is 1 else 'NEGATIVE' for x in signs]\nfor _ in range(Q):\n    x = int(input())\n    mid = N // 2\n    high = N - 1\n    low = 0\n    flag = -2\n    while high - low >= 1 and mid >= 0 and (high <= N - 1) and (high >= 0) and (low >= 0) and (low <= N - 1):\n        if high == low + 1 or high == low:\n            break\n        if arr[mid] < x and mid >= 1:\n            low = mid + 1\n        if arr[mid] > x and mid < N - 1:\n            high = mid - 1\n        if arr[mid] == x:\n            flag = 1\n            break\n        mid = (high + low) // 2\n    if flag == 1:\n        print(0)\n    else:\n        if x > arr[low] and x < arr[high] and (high != N - 1):\n            print(signs[high])\n        if x > arr[low] and x > arr[high] and (high < N - 1):\n            print(signs[high + 1])\n        if x > arr[high] and high == N - 1:\n            print(signs[N])\n        if x < arr[low] and x < arr[high]:\n            print(signs[low])\n        if x == arr[low] or x == arr[high]:\n            print(0)", "(N, Q) = [int(x) for x in input().split()]\narr = [int(x) for x in input().split()]\narr = sorted(arr)\nsigns = [(-1) ** n for n in range(N + 1)]\nif signs[-1] == -1:\n    signs = [-1 * x for x in signs]\nsigns = ['POSITIVE' if x is 1 else 'NEGATIVE' for x in signs]\nfor _ in range(Q):\n    x = int(input())\n    mid = N // 2\n    high = N - 1\n    low = 0\n    flag = -2\n    while high - low >= 1 and mid >= 0 and (high <= N - 1) and (high >= 0) and (low >= 0) and (low <= N - 1):\n        if high == low + 1 or high == low:\n            break\n        if arr[mid] < x and mid >= 1:\n            low = mid + 1\n        if arr[mid] > x and mid < N - 1:\n            high = mid - 1\n        if arr[mid] == x:\n            flag = 1\n            break\n        mid = (high + low) // 2\n    if flag == 1:\n        print(0)\n    else:\n        if x > arr[low] and x < arr[high] and (high != N - 1):\n            print(signs[high])\n        if x > arr[low] and x > arr[high] and (high < N - 1):\n            print(signs[high + 1])\n        if x > arr[high] and high == N - 1:\n            print(signs[N])\n        if x < arr[low] and x < arr[high]:\n            print(signs[low])\n        if x == arr[low] or x == arr[high]:\n            print(0)", "def bs(a, x):\n    l = 0\n    r = len(a)\n    while l <= r:\n        m = (l + r) // 2\n        if a[m] == x:\n            return -1\n        elif a[m] < x:\n            l = m + 1\n        else:\n            r = m - 1\n        if l == len(a):\n            return l\n    return l\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(k):\n    x = int(input())\n    c = bs(a, x)\n    if c == -1:\n        print(0)\n    elif c % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "import bisect\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    c = bisect.bisect_left(l, x)\n    if c < n:\n        p = n - c\n        if l[c] == x:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    c = bisect.bisect_left(l, x)\n    if c < n:\n        p = n - c\n        if l[c] == x:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "def bs(a, b):\n    l = 0\n    r = len(a)\n    while l <= r:\n        m = (l + r) // 2\n        if a[m] == b:\n            return -1\n        elif a[m] < b:\n            l = m + 1\n        else:\n            r = m - 1\n        if l == len(a):\n            return l\n    return l\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(k):\n    b = int(input())\n    c = bs(a, b)\n    if c == -1:\n        print(0)\n    elif c % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def bs(a, x):\n    l = 0\n    r = len(a)\n    while l <= r:\n        m = (l + r) // 2\n        if a[m] == x:\n            return -1\n        elif a[m] < x:\n            l = m + 1\n        else:\n            r = m - 1\n        if l == len(a):\n            return l\n    return l\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(k):\n    x = int(input())\n    c = bs(a, x)\n    if c == -1:\n        print(0)\n    elif c % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def bs(a, x):\n    l = 0\n    r = len(a)\n    while l <= r:\n        m = (l + r) // 2\n        if a[m] == x:\n            return -1\n        elif a[m] < x:\n            l = m + 1\n        else:\n            r = m - 1\n        if l == len(a):\n            return l\n    return l\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(k):\n    x = int(input())\n    c = bs(a, x)\n    if c == -1:\n        print(0)\n    elif c % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def bs(a, x):\n    l = 0\n    r = len(a)\n    while l <= r:\n        m = (l + r) // 2\n        if a[m] == x:\n            return -1\n        elif a[m] < x:\n            l = m + 1\n        else:\n            r = m - 1\n        if l == len(a):\n            return l\n    return l\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(k):\n    x = int(input())\n    c = bs(a, x)\n    if c == -1:\n        print(0)\n    elif c % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def bs(a, x):\n    l = 0\n    r = len(a)\n    while l <= r:\n        m = (l + r) // 2\n        if a[m] == x:\n            return -1\n        elif a[m] < x:\n            l = m + 1\n        else:\n            r = m - 1\n        if l == len(a):\n            return l\n    return l\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(k):\n    x = int(input())\n    c = bs(a, x)\n    if c == -1:\n        print(0)\n    elif c % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def bs(a, x):\n    l = 0\n    r = len(a)\n    while l <= r:\n        m = (l + r) // 2\n        if a[m] == x:\n            return -1\n        elif a[m] < x:\n            l = m + 1\n        else:\n            r = m - 1\n        if l == len(a):\n            return l\n    return l\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(k):\n    x = int(input())\n    c = bs(a, x)\n    if c == -1:\n        print(0)\n    elif c % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def greater(l, k):\n    n = len(l)\n    low = 0\n    high = n - 1\n    while low < high:\n        m = (low + high) // 2\n        if l[m] >= k:\n            high = m\n        elif l[m] < k:\n            low = m + 1\n    return low\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nwhile q > 0:\n    a = int(input())\n    b = greater(l, a)\n    if l[b] == a:\n        print('0')\n    elif a > l[-1] or b & 1 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')\n    q = q - 1", "def find(arr, x):\n    (low, high) = (0, len(arr) - 1)\n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] >= x:\n            high = mid\n        elif arr[mid] < x:\n            low = mid + 1\n    return low\n(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(m):\n    x = int(input())\n    temp = find(l, x)\n    if l[temp] == x:\n        print('0')\n    elif x > l[-1] or temp % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def find(arr, x):\n    (low, high) = (0, len(arr) - 1)\n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] >= x:\n            high = mid\n        elif arr[mid] < x:\n            low = mid + 1\n    return low\n(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(m):\n    x = int(input())\n    temp = find(l, x)\n    if l[temp] == x:\n        print('0')\n    elif x > l[-1] or temp % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def find(arr, x):\n    (low, high) = (0, len(arr) - 1)\n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] >= x:\n            high = mid\n        elif arr[mid] < x:\n            low = mid + 1\n    return low\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    i = find(l, x)\n    if l[i] == x:\n        print('0')\n    elif x > l[-1] or i % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def find(arr, x):\n    (low, high) = (0, len(arr) - 1)\n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] >= x:\n            high = mid\n        elif arr[mid] < x:\n            low = mid + 1\n    return low\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    i = find(l, x)\n    if l[i] == x:\n        print('0')\n    elif x > l[-1] or i % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "import bisect\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(q):\n    x = int(input())\n    c = bisect.bisect_left(a, x)\n    p = n - c\n    if c < n:\n        if a[c] == x:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "def find(arr, x):\n    (low, high) = (0, len(arr) - 1)\n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] >= x:\n            high = mid\n        elif arr[mid] < x:\n            low = mid + 1\n    return low\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    i = find(l, x)\n    if l[i] == x:\n        print('0')\n    elif x > l[-1] or i % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def wave(x, a):\n    (p, q) = (0, n - 1)\n    while p <= q:\n        avg = (p + q) // 2\n        if a[avg] < x:\n            p = avg + 1\n        else:\n            q = avg - 1\n    return p\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(q):\n    x = int(input())\n    res = wave(x, a)\n    if res >= n:\n        print('POSITIVE')\n    elif x == a[res]:\n        print('0')\n    elif n - res & 1:\n        print('NEGATIVE')\n    else:\n        print('POSITIVE')", "def wave(x, a):\n    (p, q) = (0, n - 1)\n    while p <= q:\n        avg = (p + q) // 2\n        if a[avg] < x:\n            p = avg + 1\n        else:\n            q = avg - 1\n    return p\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(q):\n    x = int(input())\n    res = wave(x, a)\n    if res >= n:\n        print('POSITIVE')\n    elif x == a[res]:\n        print('0')\n    elif n - res & 1:\n        print('NEGATIVE')\n    else:\n        print('POSITIVE')", "def wave(x, a):\n    (p, q) = (0, n - 1)\n    while p <= q:\n        avg = (p + q) // 2\n        if a[avg] < x:\n            p = avg + 1\n        else:\n            q = avg - 1\n    return p\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(q):\n    x = int(input())\n    res = wave(x, a)\n    if res >= n:\n        print('POSITIVE')\n    elif x == a[res]:\n        print('0')\n    elif n - res & 1:\n        print('NEGATIVE')\n    else:\n        print('POSITIVE')", "(n, q) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(q):\n    x = int(input())\n    s = d = f = 0\n    e = len(a) - 1\n    mid = s + (e - s) // 2\n    while s <= e:\n        if a[mid] == x:\n            print('0')\n            f = 1\n            break\n        elif x > a[mid]:\n            d = mid + 1\n            s = mid + 1\n        else:\n            e = mid - 1\n        mid = s + (e - s) // 2\n    if f == 0:\n        if (len(a) - d) % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')", "(a, b) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(b):\n    c = int(input())\n    s = d = f = 0\n    e = len(l) - 1\n    mid = s + (e - s) // 2\n    while s <= e:\n        if l[mid] == c:\n            print('0')\n            f = 1\n            break\n        elif c > l[mid]:\n            d = mid + 1\n            s = mid + 1\n        else:\n            e = mid - 1\n        mid = s + (e - s) // 2\n    if f == 0:\n        if (len(l) - d) % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')", "import bisect\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    c = bisect.bisect_left(l, x)\n    if c < n:\n        p = n - c\n        if l[c] == x:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    c = bisect.bisect_left(l, x)\n    if c < n:\n        p = n - c\n        if l[c] == x:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    c = bisect.bisect_left(l, x)\n    if c < n:\n        p = n - c\n        if l[c] == x:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    c = bisect.bisect_left(l, x)\n    if c < n:\n        p = n - c\n        if l[c] == x:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    c = bisect.bisect_left(l, x)\n    if c < n:\n        p = n - c\n        if l[c] == x:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\nfrom bisect import bisect_left\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nl1 = []\nfor i in range(q):\n    l1.append(int(input()))\nfor i in l1:\n    p = bisect_left(l, i)\n    if p < n and l[p] == i:\n        print(0)\n    elif p & 1 == 0:\n        print('POSITIVE')\n    elif p & 1 == 1:\n        print('NEGATIVE')", "import bisect\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    c = bisect.bisect_left(l, x)\n    if c < n:\n        p = n - c\n        if l[c] == x:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    c = bisect.bisect_left(l, x)\n    if c < n:\n        p = n - c\n        if l[c] == x:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    c = bisect.bisect_left(l, x)\n    if c < n:\n        p = n - c\n        if l[c] == x:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(a, b) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(b):\n    q = int(input())\n    c = bisect.bisect_left(l, q)\n    if c < a:\n        p = a - c\n        if l[c] == q:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(a, b) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(b):\n    q = int(input())\n    c = bisect.bisect_left(l, q)\n    if c < a:\n        p = a - c\n        if l[c] == q:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(a, b) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(b):\n    q = int(input())\n    c = bisect.bisect_left(l, q)\n    if c < a:\n        p = a - c\n        if l[c] == q:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(a, b) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(b):\n    q = int(input())\n    c = bisect.bisect_left(l, q)\n    if c < a:\n        p = a - c\n        if l[c] == q:\n            print(0)\n        elif p % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\nfrom bisect import bisect_left, bisect_right\n(n, m) = map(int, input().split(' '))\na = list(map(int, input().split(' ')))\na.sort()\nq = []\nfor _ in range(m):\n    q.append(int(input()))\nfor p in q:\n    pos = bisect_left(a, p)\n    if pos < n and a[pos] == p:\n        print('0')\n    elif pos % 2 == 0:\n        print('POSITIVE')\n    elif pos % 2 != 0:\n        print('NEGATIVE')", "from bisect import bisect_left, bisect_right\n(n, m) = map(int, input().split(' '))\narr = list(map(int, input().split(' ')))\narr.sort()\nq = []\nfor _ in range(m):\n    q.append(int(input()))\nfor p in q:\n    pos = bisect_left(arr, p)\n    if pos < n and arr[pos] == p:\n        print('0')\n    elif pos % 2 == 0:\n        print('POSITIVE')\n    elif pos % 2 != 0:\n        print('NEGATIVE')", "from bisect import bisect_right\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(q):\n    d = int(input())\n    p = bisect_right(a, d, 0, n)\n    if a[p - 1] == d:\n        print('0')\n    elif p % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "import bisect\nfrom bisect import bisect_left, bisect_right\n(n, m) = map(int, input().split(' '))\narr = list(map(int, input().split(' ')))\narr.sort()\nq = []\nfor _ in range(m):\n    q.append(int(input()))\nfor p in q:\n    pos = bisect_left(arr, p)\n    if pos < n and arr[pos] == p:\n        print('0')\n    elif pos % 2 == 0:\n        print('POSITIVE')\n    elif pos % 2 != 0:\n        print('NEGATIVE')", "import os, sys, io, math\nfrom array import array\nfrom math import *\nfrom bisect import *\nfrom heapq import *\nfrom functools import *\nfrom itertools import *\nfrom collections import Counter, defaultdict\nI = lambda : [*map(int, sys.stdin.readline().split())]\nIS = lambda : input()\nIN = lambda : int(input())\nIF = lambda : float(input())\n(n, k) = map(int, input().split())\nl = I()\nl.sort()\nfor i in range(k):\n    (i, a) = (IN(), 0)\n    p = bisect(l, i)\n    if l[p - 1] == i:\n        print(0)\n    else:\n        print('NEGATIVE' if n - p & 1 else 'POSITIVE')", "import bisect\nfrom bisect import bisect_left, bisect_right\n(n, m) = map(int, input().split(' '))\narr = list(map(int, input().split(' ')))\narr.sort()\nq = []\nfor _ in range(m):\n    q.append(int(input()))\nfor p in q:\n    pos = bisect_left(arr, p)\n    if pos < n and arr[pos] == p:\n        print('0')\n    elif pos % 2 == 0:\n        print('POSITIVE')\n    elif pos % 2 != 0:\n        print('NEGATIVE')", "from bisect import bisect\n(n, m) = map(int, input().split())\nL = list(map(int, input().split()))\nL.sort()\nfor _ in range(m):\n    q = int(input())\n    pos = bisect(L, q)\n    if L[pos - 1] == q:\n        print(0)\n    elif n - pos & 1 == 1:\n        print('NEGATIVE')\n    else:\n        print('POSITIVE')", "from bisect import bisect, insort\n(nd, qd) = map(int, input().split())\nard = list(map(int, input().split()))\nard.sort()\nfor _ in range(qd):\n    xd = int(input())\n    kd = bisect(ard, xd)\n    if ard[kd - 1] == xd:\n        print(0)\n    elif nd - kd & 1 == 1:\n        print('NEGATIVE')\n    else:\n        print('POSITIVE')", "from bisect import bisect, insort\n(n, q) = map(int, input().split())\nar = list(map(int, input().split()))\nar.sort()\nfor _ in range(q):\n    x = int(input())\n    k = bisect(ar, x)\n    if ar[k - 1] == x:\n        print(0)\n    elif n - k & 1 == 1:\n        print('NEGATIVE')\n    else:\n        print('POSITIVE')", "def binary_search(A, l, r, x):\n    if abs(r - l) <= 1 and l > r:\n        if A[l] <= x:\n            return l\n        else:\n            return r\n    if r >= l:\n        mid = l + (r - l) // 2\n        if x == A[mid]:\n            return mid\n        elif x < A[mid]:\n            return binary_search(A, l, mid - 1, x)\n        else:\n            return binary_search(A, mid + 1, r, x)\n(N, Q) = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA.sort()\nfor i in range(Q):\n    x = int(input())\n    if N == 1:\n        if x == A[0]:\n            print(0)\n        elif x < A[0]:\n            print('NEGATIVE')\n            continue\n        else:\n            print('POSITIVE')\n            continue\n    if x < A[0]:\n        if N % 2 == 0:\n            print('POSITIVE')\n            continue\n        else:\n            print('NEGATIVE')\n            continue\n    if x > A[N - 1]:\n        print('POSITIVE')\n        continue\n    index = binary_search(A, 0, N - 1, x)\n    if x - A[index] == 0:\n        print(0)\n    elif (N - index - 1) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def binary_search(A, l, r, x):\n    if abs(r - l) <= 1 and l > r:\n        if A[l] <= x:\n            return l\n        else:\n            return r\n    if r >= l:\n        mid = l + (r - l) // 2\n        if x == A[mid]:\n            return mid\n        elif x < A[mid]:\n            return binary_search(A, l, mid - 1, x)\n        else:\n            return binary_search(A, mid + 1, r, x)\n(N, Q) = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA.sort()\nfor i in range(Q):\n    x = int(input())\n    if N == 1:\n        if x == A[0]:\n            print(0)\n        elif x < A[0]:\n            print('NEGATIVE')\n            continue\n        else:\n            print('POSITIVE')\n            continue\n    if x < A[0]:\n        if N % 2 == 0:\n            print('POSITIVE')\n            continue\n        else:\n            print('NEGATIVE')\n            continue\n    if x > A[N - 1]:\n        print('POSITIVE')\n        continue\n    index = binary_search(A, 0, N - 1, x)\n    if x - A[index] == 0:\n        print(0)\n    elif (N - index - 1) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def floor(l, x):\n    ans = -1\n    (low, high) = (0, len(l) - 1)\n    while low <= high:\n        mid = (low + high) // 2\n        if l[mid] == x:\n            return -2\n        elif l[mid] > x:\n            high = mid - 1\n        else:\n            ans = mid\n            low = mid + 1\n    return ans\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    f = floor(l, x)\n    if f == -1:\n        if n & 1:\n            print('NEGATIVE')\n        else:\n            print('POSITIVE')\n    elif f == -2:\n        print(0)\n    elif n - f + 1 & 1:\n        print('NEGATIVE')\n    else:\n        print('POSITIVE')", "(n, q) = map(int, input().split())\ninput_arr = list(map(int, input().split()))\ninput_arr.sort()\n\ndef search_num(num):\n    start = 0\n    end = n - 1\n    while start <= end:\n        middle = (start + end) // 2\n        if input_arr[middle] < num:\n            start = middle + 1\n        else:\n            end = middle - 1\n    return start\nfor i in range(q):\n    num = int(input())\n    neg_count = 0\n    index = search_num(num)\n    if index >= n:\n        print('POSITIVE')\n    elif num == input_arr[index]:\n        print('0')\n    elif n - index & 1:\n        print('NEGATIVE')\n    else:\n        print('POSITIVE')", "(n, q) = map(int, input().split())\ninput_arr = list(map(int, input().split()))\npos_arr = []\nneg_arr = []\nfor j in input_arr:\n    if j < 0:\n        neg_arr.append(j)\n    else:\n        pos_arr.append(j)\nneg_arr_len = len(neg_arr)\npos_arr_len = len(pos_arr)\nneg_arr.sort()\npos_arr.sort()\n\ndef search_num(num):\n    if num < 0:\n        arr = neg_arr\n    else:\n        arr = pos_arr\n    start = 0\n    end = len(arr) - 1\n    while start <= end:\n        middle = (start + end) // 2\n        if arr[middle] == num or (arr[middle] > num and arr[middle - 1] < num):\n            return [middle, arr[middle]]\n        elif arr[middle] < num:\n            start = middle + 1\n        else:\n            end = middle - 1\nfor i in range(q):\n    num = int(input())\n    return_num = 10 ** 9 + 7\n    neg_count = 0\n    if num < 0:\n        if neg_arr_len > 0:\n            if num < neg_arr[0]:\n                neg_count = neg_arr_len\n            elif neg_arr[0] <= num <= neg_arr[-1]:\n                (neg_start, return_num) = search_num(num)\n                neg_count = neg_arr_len - neg_start\n        neg_count += pos_arr_len\n    elif pos_arr_len > 0:\n        if num < pos_arr[0]:\n            neg_count = pos_arr_len\n        elif pos_arr[0] <= num <= pos_arr[-1]:\n            (neg_start, return_num) = search_num(num)\n            neg_count = pos_arr_len - neg_start\n    if num == return_num:\n        print('0')\n    elif neg_count & 1:\n        print('NEGATIVE')\n    else:\n        print('POSITIVE')", "def search(arr, x):\n    high = len(arr)\n    low = 0\n    while low < high:\n        mid = (low + high) // 2\n        if x > arr[mid]:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n(n, q) = map(int, input().split(' '))\nroots = sorted(map(int, input().split(' ')))\nqueries = [int(input()) for _ in range(q)]\nfor q in queries:\n    i = search(roots, q)\n    if i >= len(roots):\n        print('POSITIVE')\n    elif q == roots[i]:\n        print(0)\n    elif (len(roots) - i) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def search(arr, x):\n    high = len(arr) - 1\n    low = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if x > arr[mid]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n(n, q) = map(int, input().split(' '))\nroots = sorted(map(int, input().split(' ')))\nqueries = [int(input()) for _ in range(q)]\nfor q in queries:\n    i = search(roots, q)\n    if i >= len(roots):\n        print('POSITIVE')\n    elif q == roots[i]:\n        print(0)\n    elif (len(roots) - i) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def search(arr, x):\n    high = len(arr)\n    low = 0\n    while low < high:\n        mid = (low + high) // 2\n        if x > arr[mid]:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n(n, q) = map(int, input().split(' '))\nroots = sorted(map(int, input().split(' ')))\nqueries = [int(input()) for _ in range(q)]\nfor q in queries:\n    i = search(roots, q)\n    if i >= len(roots):\n        print('POSITIVE')\n    elif q == roots[i]:\n        print(0)\n    elif (len(roots) - i) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "import bisect\n(n, q) = map(int, input().split())\npoly = list(map(int, input().split()[:n]))\npoly.sort()\nfor i in range(q):\n    n1 = int(input())\n    bisector = bisect.bisect_left(poly, n1)\n    if bisector < n:\n        k = n - bisector\n        if poly[bisector] == n1:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\npoly = list(map(int, input().split()[:n]))\npoly.sort()\nfor i in range(q):\n    n1 = int(input())\n    bisector = bisect.bisect_left(poly, n1)\n    if bisector < n:\n        k = n - bisector\n        if poly[bisector] == n1:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "def bisect(roots, n, x):\n    l = 0\n    r = n - 1\n    while r >= l:\n        m = (l + r) // 2\n        if x == roots[m]:\n            return -2\n            break\n        elif x > roots[m]:\n            l = m + 1\n        else:\n            r = m - 1\n    return l\n(n, q) = map(int, input().split())\nroots = list(map(int, input().split()))\nroots.sort()\nfor _ in range(q):\n    x = int(input())\n    if x < roots[0]:\n        print('POSITIVE')\n    elif x > roots[-1]:\n        if n % 2 == 1:\n            print('NEGATIVE')\n        else:\n            print('POSITIVE')\n    else:\n        l = bisect(roots, n, x)\n        if l == -2:\n            print(0)\n        elif l % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')", "def bisect(roots, n, x):\n    l = 0\n    r = n - 1\n    while r >= l:\n        m = (l + r) // 2\n        if x == roots[m]:\n            return -2\n            break\n        elif x > roots[m]:\n            l = m + 1\n        else:\n            r = m - 1\n    return l\n(n, q) = map(int, input().split())\nroots = list(map(int, input().split()))\nroots.sort()\nfor _ in range(q):\n    x = int(input())\n    if x < roots[0]:\n        print('POSITIVE')\n    elif x > roots[-1]:\n        if n % 2 == 1:\n            print('NEGATIVE')\n        else:\n            print('POSITIVE')\n    else:\n        l = bisect(roots, n, x)\n        if l == -2:\n            print(0)\n        elif l % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')", "(N, Q) = (int(x) for x in input().split(' '))\na = [int(x) for x in input().split(' ')]\na.sort()\nfor t in range(Q):\n    flag = 1\n    q = int(input())\n    i = 0\n    j = N - 1\n    while j > i:\n        mid = (i + j) // 2\n        if a[mid] == q:\n            print('0')\n            flag = 0\n            break\n        elif a[mid] > q:\n            j = mid - 1\n        else:\n            i = mid + 1\n    if flag == 1:\n        if a[i] == q:\n            print('0')\n        elif a[i] < q:\n            if (N - i - 1) % 2 == 0:\n                print('POSITIVE')\n            else:\n                print('NEGATIVE')\n        elif (N - i) % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')", "def find(arr, x):\n    (low, high) = (0, len(arr) - 1)\n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] >= x:\n            high = mid\n        elif arr[mid] < x:\n            low = mid + 1\n    return low\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    i = find(l, x)\n    if l[i] == x:\n        print('0')\n    elif x > l[-1] or i % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def find(ar, x):\n    (low, high) = (0, len(ar) - 1)\n    while low < high:\n        mid = (low + high) // 2\n        if ar[mid] >= x:\n            high = mid\n        elif ar[mid] < x:\n            low = mid + 1\n    return low\n(n, q) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(q):\n    x = int(input())\n    i = find(l, x)\n    if l[i] == x:\n        print('0')\n    elif x > l[-1] or i % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "(N, Q) = (int(x) for x in input().split(' '))\na = [int(x) for x in input().split(' ')]\na.sort()\nfor t in range(Q):\n    flag = 1\n    q = int(input())\n    i = 0\n    j = N - 1\n    while j > i:\n        mid = (i + j) // 2\n        if a[mid] == q:\n            print('0')\n            flag = 0\n            break\n        elif a[mid] > q:\n            j = mid - 1\n        else:\n            i = mid + 1\n    if flag == 1:\n        if a[i] == q:\n            print('0')\n        elif a[i] < q:\n            if (N - i - 1) % 2 == 0:\n                print('POSITIVE')\n            else:\n                print('NEGATIVE')\n        elif (N - i) % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')", "import sys\nfrom bisect import bisect\n[n, q] = list(map(lambda x: int(x), sys.stdin.readline().rstrip('\\n').split(' ')))\nais = list(map(lambda x: int(x), sys.stdin.readline().rstrip('\\n').split(' ')))\nais.sort()\nfor _ in range(q):\n    xi = int(sys.stdin.readline().rstrip('\\n'))\n    b = bisect(ais, xi)\n    if ais[b - 1] == xi:\n        print('0')\n    elif (len(ais) - b) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "def find_index(arr, n, K):\n    start = 0\n    end = n - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] == K:\n            return mid\n        elif arr[mid] < K:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return end + 1\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(0, q):\n    q1 = int(input())\n    ind = find_index(a, n, q1)\n    if ind != n and a[ind] == q1:\n        print(0)\n    elif n % 2 == 0:\n        if ind % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    elif ind % 2 == 0:\n        print('NEGATIVE')\n    else:\n        print('POSITIVE')", "(N, Q) = (int(x) for x in input().split(' '))\na = [int(x) for x in input().split(' ')]\na.sort()\nfor t in range(Q):\n    flag = 1\n    q = int(input())\n    i = 0\n    j = N - 1\n    while j > i:\n        mid = (i + j) // 2\n        if a[mid] == q:\n            print('0')\n            flag = 0\n            break\n        elif a[mid] > q:\n            j = mid - 1\n        else:\n            i = mid + 1\n    if flag == 1:\n        if a[i] == q:\n            print('0')\n        elif a[i] < q:\n            if (N - i - 1) % 2 == 0:\n                print('POSITIVE')\n            else:\n                print('NEGATIVE')\n        elif (N - i) % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')", "import bisect\n(n, q) = [int(x) for x in input().split()]\narr = [int(x) for x in input().split()]\nmini = min(arr)\nmaxi = max(arr)\narr.sort()\nfor i in range(q):\n    pin = int(input())\n    bisector = bisect.bisect_left(arr, pin)\n    if bisector < n:\n        k = n - bisector\n        if arr[bisector] == pin:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "from math import gcd, sqrt, ceil, floor, log10, log2\nfrom heapq import heapify, heappop, heappush, nsmallest, nlargest\nfrom collections import Counter, deque, OrderedDict, defaultdict\nfrom itertools import combinations, permutations, zip_longest\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache, reduce\nimport sys\nimport time\nimport string\nimport operator\nRECURSION_LIMIT = int(10000000.0)\nINT_MAX = float('inf')\nINT_MIN = float('-inf')\nMOD = int(10000000.0) + 9\nNEWLINE = '\\n'\nSPACE = ' '\nsys.setrecursionlimit(RECURSION_LIMIT)\ninp = lambda fn: fn(input())\ninp_vars = lambda fn, delim, convert_to=list: convert_to(map(fn, input().split(delim)))\nenum = lambda itr, start: enumerate(itr, start)\n\ndef toposort(graph, n):\n    degree = [0] * n\n    for node in graph:\n        for adj in graph[node]:\n            degree[adj] += 1\n    bfs_queue = [node for node in range(n) if not degree[node]]\n    for node in bfs_queue:\n        for adj in graph[node]:\n            degree[adj] -= 1\n            if not degree[adj]:\n                bfs_queue.append(adj)\n    return (bfs_queue, degree)\n\ndef dfs(graph, node, visited):\n    visited.add(node)\n    for adj in graph[node]:\n        if adj in visited:\n            continue\n        dfs(graph, adj, visited)\n\ndef seive(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n    return is_prime[n]\n\ndef get_negatives(arr, val):\n    (l, r) = (0, len(arr) - 1)\n    res = -1\n    while l <= r:\n        mid = (l + r) // 2\n        if arr[mid] - val == 0:\n            return -1\n        if val - arr[mid] < 0:\n            res = mid\n            r -= 1\n        else:\n            l += 1\n    return len(arr) - l\n\ndef solve(*args, **kwargs):\n    (n, q, arr1, arr2) = args\n    arr1.sort()\n    res = []\n    for val in arr2:\n        positives = bisect_left(arr1, val)\n        negatives = n - positives\n        if positives < n:\n            if arr1[positives] == val:\n                res.append('0')\n            elif negatives & 1:\n                res.append('NEGATIVE')\n            else:\n                res.append('POSITIVE')\n        else:\n            res.append('POSITIVE')\n    return res\n\ndef main(*args, **kwargs):\n    arg1 = inp_vars(int, SPACE)\n    arg3 = inp_vars(int, SPACE)\n    arg4 = [inp(int) for _ in range(arg1[1])]\n    res = solve(*(*arg1, arg3, arg4))\n    if type(res) in {list, tuple, set}:\n        print(*res, sep='\\n')\n    else:\n        print(res)\nmain()", "import bisect\n(N, Q) = map(int, input().split())\nNi = sorted(list(map(int, input().split())))\nfor _ in range(Q):\n    X = int(input())\n    g = bisect.bisect_left(Ni, X)\n    if g < N:\n        k = N - g\n        if Ni[g] == X:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\nm1 = min(a)\nm2 = max(a)\na.sort()\nfor i in range(q):\n    p = int(input())\n    g = bisect.bisect_left(a, p)\n    if g < n:\n        k = n - g\n        if a[g] == p:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(N, Q) = map(int, input().split(' '))\nfactors = list(map(int, input().split(' ')))\nfactors.sort()\nfor i in range(Q):\n    x = int(input())\n    idx = bisect.bisect_left(factors, x)\n    if idx == N:\n        print('POSITIVE')\n    elif factors[idx] == x:\n        print(0)\n    else:\n        (l, r) = (idx, N - idx)\n        if r % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')", "class SortedList:\n\n    def __init__(self, iterable=[], _load=200):\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return (0, k)\n        if k >= self._len - _list_lens[-1]:\n            return (len(_list_lens) - 1, k + _list_lens[-1] - self._len)\n        if self._rebuild:\n            self._fen_build()\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return (idx + 1, k)\n\n    def _delete(self, pos, idx):\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (lo, pos) = (-1, len(_lists) - 1)\n        while lo + 1 < pos:\n            mi = lo + pos >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def _loc_right(self, value):\n        if not self._len:\n            return (0, 0)\n        _lists = self._lists\n        _mins = self._mins\n        (pos, hi) = (0, len(_lists))\n        while pos + 1 < hi:\n            mi = pos + hi >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n        _list = _lists[pos]\n        (lo, idx) = (-1, len(_list))\n        while lo + 1 < idx:\n            mi = lo + idx >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n        return (pos, idx)\n\n    def add(self, value):\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n        self._len += 1\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        (pos, idx) = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        (pos, idx) = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        return self._len\n\n    def __getitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        (pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        _lists = self._lists\n        if _lists:\n            (pos, idx) = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        return 'SortedList({0})'.format(list(self))\n(n, q) = map(int, input().split())\nroots = list(map(int, input().split()))\nroots = SortedList(roots)\nfor i in range(q):\n    negative_count = 0\n    point = int(input())\n    if point in roots:\n        print(0)\n    elif roots.bisect_right(point) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "import bisect\n(N, Q) = input().split()\nroots = [int(x) for x in input().split()]\nroots.sort()\nN = int(N)\nQ = int(Q)\nfor _ in range(Q):\n    ip = int(input())\n    idx = bisect.bisect_left(roots, ip)\n    if idx == N:\n        print('POSITIVE')\n    elif roots[idx] == ip:\n        print(0)\n    else:\n        (l, r) = (idx, N - idx)\n        if r % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')", "def search(arr, x):\n    high = len(arr)\n    low = 0\n    while low < high:\n        mid = (low + high) // 2\n        if x > arr[mid]:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n(n, q) = map(int, input().split(' '))\nroots = sorted(map(int, input().split(' ')))\nqueries = [int(input()) for _ in range(q)]\nfor q in queries:\n    i = search(roots, q)\n    if i >= len(roots):\n        print('POSITIVE')\n    elif q == roots[i]:\n        print(0)\n    elif (len(roots) - i) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "import bisect\n(N, Q) = map(int, input().split())\nNi = sorted(list(map(int, input().split())))\nfor _ in range(Q):\n    X = int(input())\n    g = bisect.bisect_left(Ni, X)\n    if g < N:\n        k = N - g\n        if Ni[g] == X:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\nm1 = min(a)\nm2 = max(a)\na.sort()\nfor i in range(q):\n    p = int(input())\n    g = bisect.bisect_left(a, p)\n    if g < n:\n        k = n - g\n        if a[g] == p:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\nm1 = min(a)\nm2 = max(a)\na.sort()\nfor i in range(q):\n    p = int(input())\n    g = bisect.bisect_left(a, p)\n    if g < n:\n        k = n - g\n        if a[g] == p:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\nm1 = min(a)\nm2 = max(a)\na.sort()\nfor i in range(q):\n    p = int(input())\n    g = bisect.bisect_left(a, p)\n    if g < n:\n        k = n - g\n        if a[g] == p:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\nm1 = min(a)\nm2 = max(a)\na.sort()\nfor i in range(q):\n    p = int(input())\n    g = bisect.bisect_left(a, p)\n    if g < n:\n        k = n - g\n        if a[g] == p:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "import bisect\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\nm1 = min(a)\nm2 = max(a)\na.sort()\nfor i in range(q):\n    p = int(input())\n    g = bisect.bisect_left(a, p)\n    if g < n:\n        k = n - g\n        if a[g] == p:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')", "def search(a, v):\n    hi = len(a)\n    lo = 0\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if v > a[mid]:\n            lo = mid + 1\n        else:\n            hi = mid\n    return lo\n(n, q) = map(int, input().split(' '))\nroots = sorted(map(int, input().split(' ')))\nqueries = [int(input()) for _ in range(q)]\nfor q in queries:\n    i = search(roots, q)\n    if i >= len(roots):\n        print('POSITIVE')\n    elif q == roots[i]:\n        print(0)\n    elif (len(roots) - i) % 2 == 0:\n        print('POSITIVE')\n    else:\n        print('NEGATIVE')", "import bisect\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\nm1 = min(a)\nm2 = max(a)\na.sort()\nfor i in range(q):\n    p = int(input())\n    g = bisect.bisect_left(a, p)\n    if g < n:\n        k = n - g\n        if a[g] == p:\n            print(0)\n        elif k % 2 == 0:\n            print('POSITIVE')\n        else:\n            print('NEGATIVE')\n    else:\n        print('POSITIVE')"]