["import sys\nsys.setrecursionlimit(1000000)\n\ndef rec(a, arr, i, j, n, m):\n    if arr[i][j] == 1:\n        return\n    arr[i][j] = 1\n    if i - 1 >= 0:\n        if a[i - 1][j] == a[i][j]:\n            rec(a, arr, i - 1, j, n, m)\n    if i + 1 < n:\n        if a[i + 1][j] == a[i][j]:\n            rec(a, arr, i + 1, j, n, m)\n    if j - 1 >= 0:\n        if a[i][j - 1] == a[i][j]:\n            rec(a, arr, i, j - 1, n, m)\n    if j + 1 < m:\n        if a[i][j + 1] == a[i][j]:\n            rec(a, arr, i, j + 1, n, m)\nfor x in range(int(input())):\n    (n, m) = [int(i) for i in input().strip().split()]\n    a = [[int(i) for i in input().strip().split()] for j in range(n)]\n    arr = [[0] * m for i in range(n)]\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            if arr[i][j] == 0:\n                if i - 1 >= 0:\n                    if a[i - 1][j] > a[i][j]:\n                        rec(a, arr, i, j, n, m)\n                        continue\n                if i + 1 < n:\n                    if a[i + 1][j] > a[i][j]:\n                        rec(a, arr, i, j, n, m)\n                        continue\n                if j - 1 >= 0:\n                    if a[i][j - 1] > a[i][j]:\n                        rec(a, arr, i, j, n, m)\n                        continue\n                if j + 1 < m:\n                    if a[i][j + 1] > a[i][j]:\n                        rec(a, arr, i, j, n, m)\n                        continue\n    for i in range(n):\n        for j in range(m):\n            if arr[i][j] == 0:\n                rec(a, arr, i, j, n, m)\n                ans += 1\n    print(ans)", "import sys\nsys.setrecursionlimit(1000000)\n\ndef rec(a, arr, i, j, n, m):\n    if arr[i][j] == 1:\n        return\n    arr[i][j] = 1\n    if i - 1 >= 0:\n        if a[i - 1][j] == a[i][j]:\n            rec(a, arr, i - 1, j, n, m)\n    if i + 1 < n:\n        if a[i + 1][j] == a[i][j]:\n            rec(a, arr, i + 1, j, n, m)\n    if j - 1 >= 0:\n        if a[i][j - 1] == a[i][j]:\n            rec(a, arr, i, j - 1, n, m)\n    if j + 1 < m:\n        if a[i][j + 1] == a[i][j]:\n            rec(a, arr, i, j + 1, n, m)\nfor x in range(int(input())):\n    (n, m) = [int(i) for i in input().strip().split()]\n    a = [[int(i) for i in input().strip().split()] for j in range(n)]\n    arr = [[0] * m for i in range(n)]\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            if arr[i][j] == 0:\n                if i - 1 >= 0:\n                    if a[i - 1][j] > a[i][j]:\n                        rec(a, arr, i, j, n, m)\n                        continue\n                if i + 1 < n:\n                    if a[i + 1][j] > a[i][j]:\n                        rec(a, arr, i, j, n, m)\n                        continue\n                if j - 1 >= 0:\n                    if a[i][j - 1] > a[i][j]:\n                        rec(a, arr, i, j, n, m)\n                        continue\n                if j + 1 < m:\n                    if a[i][j + 1] > a[i][j]:\n                        rec(a, arr, i, j, n, m)\n                        continue\n    for i in range(n):\n        for j in range(m):\n            if arr[i][j] == 0:\n                rec(a, arr, i, j, n, m)\n                ans += 1\n    print(ans)", "def solve(x, n, m):\n\n    def nbrs(i, j):\n        ret = []\n        for a in [i - 1, i + 1]:\n            if a >= 0 and a < n:\n                ret += [(a, j)]\n        for a in [j - 1, j + 1]:\n            if a >= 0 and a < m:\n                ret += [(i, a)]\n        return ret\n\n    def islmax(i, j):\n        h = x[i][j]\n        for (a, b) in nbrs(i, j):\n            if x[a][b] > h:\n                return False\n        return True\n\n    def fill(ii, jj):\n        q = [(ii, jj)]\n        bb[ii][jj] = 1\n        while q:\n            (i, j) = q[0]\n            q = q[1:]\n            h = x[i][j]\n            for (a, b) in nbrs(i, j):\n                if bb[a][b]:\n                    continue\n                h0 = x[a][b]\n                if h0 <= h:\n                    bb[a][b] = 1\n                    q += [(a, b)]\n    bb = [[0 for i in range(m)] for j in range(n)]\n    pts = [(x[i][j], i, j) for i in range(n) for j in range(m)]\n    pts = sorted(pts)[::-1]\n    ret = 0\n    for (z, i, j) in pts:\n        if bb[i][j]:\n            continue\n        if islmax(i, j):\n            ret += 1\n            fill(i, j)\n    return ret\nimport sys\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    (n, m) = map(int, f.readline().split())\n    x = []\n    for j in range(n):\n        x += [list(map(int, f.readline().split()))]\n    print(solve(x, n, m))", "T = int(input())\nmove = [[1, 0], [0, 1], [-1, 0], [0, -1]]\nfor _ in range(T):\n    (N, M) = [int(c) for c in input().strip().split()]\n    S = []\n    for i in range(N):\n        row = [int(c) for c in input().strip().split()]\n        S.append(row)\n    visited = []\n    for i in range(N):\n        visited.append([0] * M)\n    nbSol = 0\n    while True:\n        maxindex = []\n        maxrow = []\n        for i in range(N):\n            m = max(S[i])\n            maxrow.append(m)\n            maxindex.append(S[i].index(m))\n        m = max(maxrow)\n        r = maxrow.index(m)\n        c = maxindex[r]\n        if m == -1:\n            break\n        tovisit = []\n        tovisit.append([r, c])\n        while len(tovisit) != 0:\n            (x, y) = tovisit.pop(0)\n            h = S[x][y]\n            S[x][y] = -1\n            for (ix, iy) in move:\n                nx = x + ix\n                ny = y + iy\n                if nx >= 0 and nx < N and (ny >= 0) and (ny < M) and (visited[nx][ny] == 0) and (S[nx][ny] <= h):\n                    visited[nx][ny] = 1\n                    tovisit.append([nx, ny])\n        nbSol = nbSol + 1\n    print(nbSol)", "from time import time\nstartTime = time()\nT = int(input())\nfor _ in range(T):\n    (H, W) = [int(x) for x in input().split()]\n    A = [[int(x) for x in input().split()] for row in range(H)]\n    peaksChosen = 0\n    peaksToCheck = []\n    tilesLeft = H * W\n    while tilesLeft > 0:\n        if len(peaksToCheck) == 0:\n            (bestPeakHeight, bestPeakLocation) = (-1, (None, None))\n            for R in range(H):\n                if max(A[R]) > bestPeakHeight:\n                    (bestPeakHeight, bestPeakLocation) = (max(A[R]), (R, A[R].index(max(A[R]))))\n            peaksToCheck.append((bestPeakLocation[0], bestPeakLocation[1], bestPeakHeight))\n            peaksChosen += 1\n            A[bestPeakLocation[0]][bestPeakLocation[1]] = 0\n            tilesLeft -= 1\n        while len(peaksToCheck) > 0:\n            (R, C, V) = peaksToCheck.pop(0)\n            if R != 0 and V >= A[R - 1][C] > 0:\n                peaksToCheck.append((R - 1, C, A[R - 1][C]))\n                A[R - 1][C] = 0\n                tilesLeft -= 1\n            if C != W - 1 and V >= A[R][C + 1] > 0:\n                peaksToCheck.append((R, C + 1, A[R][C + 1]))\n                A[R][C + 1] = 0\n                tilesLeft -= 1\n            if R != H - 1 and V >= A[R + 1][C] > 0:\n                peaksToCheck.append((R + 1, C, A[R + 1][C]))\n                A[R + 1][C] = 0\n                tilesLeft -= 1\n            if C != 0 and V >= A[R][C - 1] > 0:\n                peaksToCheck.append((R, C - 1, A[R][C - 1]))\n                A[R][C - 1] = 0\n                tilesLeft -= 1\n    print(peaksChosen)"]