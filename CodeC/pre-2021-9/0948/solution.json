["M = 1000000007\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nd = {}\nfor i in a:\n    if i not in d:\n        d[i] = 1\n    else:\n        d[i] += 1\ns = set(a)\nl = []\nfor i in d:\n    if len(l) == 0:\n        l.append(d[i])\n    else:\n        l.append(d[i] + l[-1])\nans = 1 + n\nst = l[-1]\nb = list(d.keys())\nk = min(k, n)\nfor i in range(2, k + 1):\n    t = 0\n    for j in range(len(s)):\n        if j + i > len(s):\n            break\n        if st - l[j] >= 0:\n            l[j] = d[b[j]] * (st - l[j]) % M\n        else:\n            l[j] = d[b[j]] * (st - l[j] + M) % M\n        t = (t + l[j]) % M\n        l[j] = t\n    st = t\n    ans = (ans + st) % M\nprint(ans)", "M = 1000000007\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nd = {}\nfor i in a:\n    if i not in d:\n        d[i] = 1\n    else:\n        d[i] += 1\ns = set(a)\nl = []\nfor i in d:\n    if len(l) == 0:\n        l.append(d[i])\n    else:\n        l.append(d[i] + l[-1])\nans = 1 + n\nst = l[-1]\nb = list(d.keys())\nk = min(k, n)\nfor i in range(2, k + 1):\n    t = 0\n    for j in range(len(s)):\n        if j + i > len(s):\n            break\n        if st - l[j] >= 0:\n            l[j] = d[b[j]] * (st - l[j]) % M\n        else:\n            l[j] = d[b[j]] * (st - l[j] + M) % M\n        t = (t + l[j]) % M\n        l[j] = t\n    st = t\n    ans = (ans + st) % M\nprint(ans)", "import sys\nfrom collections import Counter\nfrom functools import reduce\nm = 10 ** 9 + 7\n\ndef solve(n, k, arr):\n    count = list(Counter(arr).values())\n    k = min(k, len(count))\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for i in range(1, len(count) + 1):\n        for j in range(min(i, k), 0, -1):\n            dp[j] = (dp[j] + dp[j - 1] * count[i - 1] % m) % m\n    return reduce(lambda x, y: (x + y) % m, dp)\n(n, k) = map(int, sys.stdin.readline().split())\nprint(solve(n, k, list(map(int, sys.stdin.readline().split()))))", "from collections import Counter\n\ndef coefficients(a):\n    coeff = [1] * (len(a) + 1)\n    for i in range(len(a)):\n        cr = a[i]\n        for j in range(i, -1, -1):\n            if j == 0:\n                coeff[j] = coeff[j] * -cr\n            else:\n                coeff[j] = coeff[j] * -cr + coeff[j - 1]\n    return coeff\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nc = Counter(a)\nz = coefficients(list(c.values()))\nz = z[::-1]\ns = 0\nfor i in range(min(k + 1, len(z))):\n    s = (s + abs(z[i])) % 1000000007\nprint(s)", "from collections import defaultdict\n(n, k0) = map(int, input().split())\na = list(map(int, input().split()))\nd = defaultdict(int)\nfor i in a:\n    d[i] += 1\nk = list(d.keys())\nk.sort()\ndp = [0] * (len(k) + 1)\ndp[0] = 1\nm = 10 ** 9 + 7\nfor (j, key) in enumerate(k):\n    for i in range(len(k), 0, -1):\n        dp[i] = (dp[i] % m + dp[i - 1] * d[key] % m) % m\ns = 0\nfor i in range(min(k0, len(k)) + 1):\n    s = (s + dp[i]) % m\nprint(s)", "from collections import Counter\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nmod = 10 ** 9 + 7\nunique_arr = list(set(arr))\nfreq = Counter(arr)\nn = len(unique_arr)\nk = min(k, n)\ndp = [[0] * (k + 1) for i in range(n + 1)]\nfor i in range(n + 1):\n    dp[i][0] = 1\nfor i in range(1, n + 1):\n    for j in range(1, k + 1):\n        dp[i][j] = (dp[i - 1][j] + freq[unique_arr[i - 1]] * dp[i - 1][j - 1]) % mod\n        dp[i][j] = dp[i][j] % mod\nans = 0\nfor i in range(0, k + 1):\n    ans += dp[n][i]\nprint(ans % mod)", "from collections import Counter\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nmod = 10 ** 9 + 7\nunique_arr = list(set(arr))\nfreq = Counter(arr)\nn = len(unique_arr)\nk = min(k, n)\ndp = [[0] * (k + 1) for i in range(n + 1)]\nfor i in range(n + 1):\n    dp[i][0] = 1\nfor i in range(1, n + 1):\n    for j in range(1, k + 1):\n        dp[i][j] = (dp[i - 1][j] + freq[unique_arr[i - 1]] * dp[i - 1][j - 1]) % mod\n        dp[i][j] = dp[i][j] % mod\nans = 0\nfor i in range(0, k + 1):\n    ans += dp[n][i]\nprint(ans % mod)", "from collections import Counter\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nmod = 10 ** 9 + 7\nunique_arr = list(set(arr))\nfreq = Counter(arr)\nn = len(unique_arr)\nk = min(k, n)\ndp = [[0] * (k + 1) for i in range(n + 1)]\nfor i in range(n + 1):\n    dp[i][0] = 1\nfor i in range(1, n + 1):\n    for j in range(1, k + 1):\n        dp[i][j] = (dp[i - 1][j] + freq[unique_arr[i - 1]] * dp[i - 1][j - 1]) % mod\n        dp[i][j] = dp[i][j] % mod\nans = 0\nfor i in range(0, k + 1):\n    ans += dp[n][i]\nprint(ans % mod)", "def compute_coeff(roots, k):\n    mod = 10 ** 9 + 7\n    res = [1 for i in range(len(roots) + 1)]\n    for i in range(len(roots)):\n        cur_root = roots[i]\n        for j in range(i, -1, -1):\n            if j == 0:\n                res[j] *= -cur_root\n            else:\n                res[j] = res[j - 1] - res[j] * cur_root\n            if res[j] >= mod:\n                res[j] %= mod\n    for i in range(len(res)):\n        res[i] = abs(res[i]) % mod\n    return res\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\n(d, a) = (dict(), 0)\nfor i in arr:\n    if i not in d.keys():\n        d[i] = 1\n    else:\n        d[i] += 1\nans = compute_coeff(list(d.values()), k)\nans = ans[::-1]\nprint(sum(ans[:k + 1]) % (10 ** 9 + 7))", "MOD = int(10 ** 9 + 7)\n\ndef solve(A, N, K):\n    (frequency, ans) = ({}, 0)\n    for i in A:\n        if i not in frequency:\n            frequency[i] = 0\n        frequency[i] += 1\n    A = list(set(A))\n    N = len(A)\n    K = min(N, K)\n    dp = [[0 for i in range(K + 1)] for j in range(N + 1)]\n    for i in range(0, N + 1):\n        dp[i][0] = 1\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * frequency[A[i - 1]]\n            dp[i][j] %= MOD\n    for i in range(0, K + 1):\n        ans += dp[N][i]\n        ans %= MOD\n    print(ans)\n(N, K) = map(int, input().split())\nA = list(map(int, input().split()))\nsolve(A, N, K)", "import collections\nmod = 10 ** 9 + 7\n(N, K) = map(int, input().split())\narr = list(map(int, input().split()))\ncount = collections.Counter(arr)\nctr = len(count)\n_map = sorted(set(arr))\nattach = {}\nfor i in range(1, ctr + 1):\n    attach[_map[i - 1]] = i\nfor i in range(N):\n    arr[i] = attach[arr[i]]\nnew_count = collections.Counter(arr)\ndp = [[0] * (K + 1) for _ in range(ctr + 1)]\nfor i in range(ctr + 1):\n    dp[i][0] = 1\nfor i in range(1, ctr + 1):\n    for j in range(1, min(i + 1, K + 1)):\n        dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * new_count[i]\n        dp[i][j] %= mod\nans = 0\nfor j in range(K + 1):\n    ans += dp[ctr][j]\n    ans %= mod\nprint(ans)", "import collections\nmod = 10 ** 9 + 7\n(N, K) = map(int, input().split())\narr = list(map(int, input().split()))\ncount = collections.Counter(arr)\nctr = len(count)\n_map = sorted(set(arr))\nattach = {}\nfor i in range(1, ctr + 1):\n    attach[_map[i - 1]] = i\nfor i in range(N):\n    arr[i] = attach[arr[i]]\nnew_count = collections.Counter(arr)\ndp = [[0] * (K + 1) for _ in range(ctr + 1)]\nfor i in range(ctr + 1):\n    dp[i][0] = 1\nfor i in range(1, ctr + 1):\n    for j in range(1, min(i + 1, K + 1)):\n        dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * new_count[i]\n        dp[i][j] %= mod\nprint(sum(dp[ctr]) % mod)", "import collections\nmod = 10 ** 9 + 7\n(N, K) = map(int, input().split())\narr = list(map(int, input().split()))\ncount = collections.Counter(arr)\nctr = len(count)\n_map = sorted(set(arr))\nattach = {}\nfor i in range(1, ctr + 1):\n    attach[_map[i - 1]] = i\nfor i in range(N):\n    arr[i] = attach[arr[i]]\nnew_count = collections.Counter(arr)\ndp = [[0] * (K + 1) for _ in range(ctr + 1)]\nfor i in range(ctr + 1):\n    dp[i][0] = 1\nfor i in range(1, ctr + 1):\n    for j in range(1, min(i + 1, K + 1)):\n        dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * new_count[i]\nprint(sum(dp[ctr]) % mod)", "from collections import defaultdict\n\ndef solve(arr, k):\n    k = min(k, 1007)\n    mod = pow(10, 9) + 7\n    s = set(arr)\n    count = defaultdict(lambda : 0)\n    for ele in arr:\n        count[ele] += 1\n    dp = [[0 for _ in range(k + 1)] for _ in range(len(s) + 1)]\n    for i in range(len(dp)):\n        dp[i][0] = 1\n    temp = list(s)\n    temp = [0] + temp\n    for i in range(1, len(dp)):\n        for j in range(1, k + 1):\n            if j > i:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = (dp[i - 1][j] + count[temp[i]] * dp[i - 1][j - 1] % mod) % mod\n    ans = 0\n    for i in range(0, k + 1):\n        ans = (ans + dp[-1][i]) % mod\n    return ans\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nans = solve(arr, k)\nprint(ans)", "D = 1000000007\n(N, K) = map(int, input().split())\ns = list(map(int, input().split()))\nS = set()\nM = [0 for x in range(8000)]\nfor x in s:\n    n = x\n    M[n] += 1\n    S.add(n)\nL = list(S)\nsz = len(L)\nif sz > K:\n    R = [0 for x in range(K + 1)]\n    R[0] = 1\n    mx = 1\n    for x in L:\n        n = M[x]\n        p = mx\n        while p > 0:\n            R[p] = (R[p] + n * R[p - 1]) % D\n            p -= 1\n        mx = min(K, mx + 1)\n    r = 0\n    for x in R:\n        r += x\n    r = r % D\nelse:\n    r = 1\n    for x in L:\n        n = M[x]\n        r = r * (n + 1) % D\nprint(r)", "D = 1000000007\n(N, K) = map(int, input().split())\ns = list(map(int, input().split()))\nS = set()\nM = [0 for x in range(8000)]\nfor x in s:\n    n = x\n    M[n] += 1\n    S.add(n)\nL = list(S)\nsz = len(L)\nif sz > K:\n    R = [0 for x in range(K + 1)]\n    R[0] = 1\n    mx = 1\n    for x in L:\n        n = M[x]\n        p = mx\n        while p > 0:\n            R[p] = (R[p] + n * R[p - 1]) % D\n            p -= 1\n        mx = min(K, mx + 1)\n    r = 0\n    for x in R:\n        r += x\n    r = r % D\nelse:\n    r = 1\n    for x in L:\n        n = M[x]\n        r = r * (n + 1) % D\nprint(r)", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nx = []\nx = dict()\nfor i in range(0, n):\n    try:\n        x[a[i]] += 1\n    except:\n        x[a[i]] = 1\nx = list(x.values())\nx = [1] + x\nn = len(x)\nk = min(1007, k)\ndp = []\nte = []\nte = [0] * (k + 1)\nfor i in range(n + 1):\n    dp.append(te[:])\ndp[0][0] = 1\nm = 1000000007\nfor i in range(1, n):\n    dp[i][0] = 1\n    for j in range(1, k + 1):\n        dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * x[i] % m) % m\nans = 0\nfor i in range(0, k + 1):\n    ans = (ans + dp[n - 1][i]) % m\nprint(ans)", "import numpy as np\nMOD = 1000000007\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nd = {}\nfor x in a:\n    d[x] = d.get(x, 0) + 1\nc = len(d.keys())\nfreq = list(d.values())\nk = min(k, c)\ndp = np.zeros((k + 1, c + 1), dtype=int)\nfor i in range(1, k + 1):\n    for j in range(1, c + 1):\n        if i == 1:\n            dp[i][j] = (dp[i][j - 1] + freq[j - 1]) % MOD\n        elif j >= i:\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1] * freq[j - 1]) % MOD\nans = 1\nfor i in range(1, k + 1):\n    ans += dp[i][c]\n    ans %= MOD\nprint(ans)", "def count(arr, k):\n    large = 1000000000.0 + 7\n    ans = [1] * (len(arr) + 1)\n    for i in range(len(arr)):\n        curr = arr[i]\n        for j in range(i, -1, -1):\n            if j == 0:\n                ans[j] *= -curr\n            else:\n                ans[j] = ans[j - 1] - ans[j] * curr\n            if ans[j] >= large:\n                ans[j] %= large\n    for i in range(len(ans)):\n        ans[i] = abs(ans[i]) % large\n    return ans\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\n(dic, a) = ({}, 0)\nfor i in arr:\n    if i not in dic:\n        dic[i] = 1\n    else:\n        dic[i] += 1\nans = count(list(dic.values()), k)\nans = ans[::-1]\nprint(int(sum(ans[:k + 1]) % (1000000000.0 + 7)))", "from collections import Counter\n(n, k) = map(int, input().split())\na = [int(k) for k in input().split()]\ndd = [-1]\nc1 = Counter(a)\nmod = int(1000000000.0 + 7)\nfor i in range(8001):\n    if c1[i] > 0:\n        dd.append(c1[i])\ndp = [[0 for i in range(1100)] for i in range(1100)]\nk = min(k, len(dd))\ndp[0][0] = 1\nfor i in range(1, len(dd)):\n    dp[i][0] = 1\n    for j in range(1, k + 1):\n        dp[i][j] = (dp[i - 1][j] + dd[i] * dp[i - 1][j - 1]) % mod\nr = 0\nfor i in range(k + 1):\n    r = (r + dp[len(dd) - 1][i]) % mod\nprint(r)", "from collections import Counter\n\ndef solve(arr, n, k):\n    ans = 0\n    dict1 = {}\n    mod = 1000000007\n    for i in range(n):\n        if arr[i] in dict1:\n            dict1[arr[i]] += 1\n        else:\n            dict1[arr[i]] = 1\n    l1 = [0] + list(dict1.keys())\n    v = min(k, len(l1))\n    dp = [[0 for _ in range(v + 1)] for _ in range(len(l1))]\n    dp[0][0] = 1\n    for i in range(1, len(l1)):\n        dp[i][0] = 1\n        for j in range(1, v + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * dict1[l1[i]]\n    for i in range(v + 1):\n        ans += dp[len(l1) - 1][i]\n        ans = ans % mod\n    return ans\n(n, k) = map(int, input().strip().split())\narr = list(map(int, input().strip().split()))\nprint(solve(arr, n, k))", "from collections import Counter\n\ndef solve(arr, n, k):\n    ans = 0\n    dict1 = {}\n    mod = 1000000007\n    for i in range(n):\n        if arr[i] in dict1:\n            dict1[arr[i]] += 1\n        else:\n            dict1[arr[i]] = 1\n    l1 = [0] + list(dict1.keys())\n    v = min(k, len(l1))\n    dp = [[0 for _ in range(v + 1)] for _ in range(len(l1))]\n    dp[0][0] = 1\n    for i in range(1, len(l1)):\n        dp[i][0] = 1\n        for j in range(1, v + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * dict1[l1[i]]\n    for i in range(v + 1):\n        ans += dp[len(l1) - 1][i]\n        ans = ans % mod\n    return ans\n(n, k) = list(map(int, input().strip().split()))\narr = list(map(int, input().strip().split()))\nprint(solve(arr, n, k))", "from collections import Counter\n\ndef solve(arr, n, k):\n    ans = 0\n    dict1 = {}\n    mod = 1000000007\n    for i in range(n):\n        if arr[i] in dict1:\n            dict1[arr[i]] += 1\n        else:\n            dict1[arr[i]] = 1\n    l1 = [0] + list(dict1.keys())\n    v = min(k, len(l1))\n    dp = [[0 for _ in range(v + 1)] for _ in range(len(l1))]\n    dp[0][0] = 1\n    for i in range(1, len(l1)):\n        dp[i][0] = 1\n        for j in range(1, v + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * dict1[l1[i]]\n    for i in range(v + 1):\n        ans += dp[len(l1) - 1][i]\n        ans = ans % mod\n    return ans\n(n, k) = list(map(int, input().strip().split()))\narr = list(map(int, input().strip().split()))\nprint(solve(arr, n, k))", "from collections import Counter\n\ndef solve(arr, n, k):\n    ans = 0\n    dict1 = {}\n    mod = 1000000007\n    for i in range(n):\n        if arr[i] in dict1:\n            dict1[arr[i]] += 1\n        else:\n            dict1[arr[i]] = 1\n    l1 = [-2] + list(dict1.keys())\n    v = min(k, len(l1))\n    dp = [[0 for _ in range(v + 1)] for _ in range(len(l1))]\n    dp[0][0] = 1\n    for i in range(1, len(l1)):\n        dp[i][0] = 1\n        for j in range(1, v + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * dict1[l1[i]]\n    for i in range(v + 1):\n        ans += dp[len(l1) - 1][i]\n        ans = ans % mod\n    return ans\n(n, k) = list(map(int, input().strip().split()))\narr = list(map(int, input().strip().split()))\nprint(solve(arr, n, k))", "from collections import Counter\n\ndef solve(arr, n, k):\n    ans = 0\n    dict1 = {}\n    mod = 1000000007\n    for i in range(n):\n        if arr[i] in dict1:\n            dict1[arr[i]] += 1\n        else:\n            dict1[arr[i]] = 1\n    l1 = [-1] + list(dict1.keys())\n    v = min(k, len(l1))\n    dp = [[0 for _ in range(v + 1)] for _ in range(len(l1))]\n    dp[0][0] = 1\n    for i in range(1, len(l1)):\n        dp[i][0] = 1\n        for j in range(1, v + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * dict1[l1[i]]\n    for i in range(v + 1):\n        ans += dp[len(l1) - 1][i]\n        ans = ans % mod\n    return ans\n(n, k) = list(map(int, input().strip().split()))\narr = list(map(int, input().strip().split()))\nprint(solve(arr, n, k))", "from collections import Counter\n\ndef solve(arr, n, k):\n    ans = 0\n    dict1 = {}\n    mod = 1000000007\n    for i in range(n):\n        if arr[i] in dict1:\n            dict1[arr[i]] += 1\n        else:\n            dict1[arr[i]] = 1\n    l1 = [-1] + list(dict1.keys())\n    v = min(k, len(l1))\n    dp = [[0 for _ in range(v + 1)] for _ in range(len(l1))]\n    dp[0][0] = 1\n    for i in range(1, len(l1)):\n        dp[i][0] = 1\n        for j in range(1, v + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * dict1[l1[i]]\n    for i in range(v + 1):\n        ans += dp[len(l1) - 1][i]\n        ans = ans % mod\n    return ans\n(n, k) = list(map(int, input().strip().split()))\narr = list(map(int, input().strip().split()))\nprint(solve(arr, n, k))", "from sys import stdin, stdout\nimport math\nfrom itertools import permutations, combinations\nfrom collections import defaultdict\nfrom bisect import bisect_left\nfrom bisect import bisect_right\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\n\ndef main():\n    (n, k) = In()\n    arr = L()\n    ans = 0\n    dict1 = {}\n    for i in range(n):\n        if arr[i] in dict1.keys():\n            dict1[arr[i]] += 1\n        else:\n            dict1[arr[i]] = 1\n    l1 = [-1] + list(dict1.keys())\n    v = min(k, len(l1))\n    dp = [[0 for i in range(v + 1)] for i in range(len(l1))]\n    dp[0][0] = 1\n    for i in range(1, len(l1)):\n        dp[i][0] = 1\n        for j in range(1, v + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * dict1[l1[i]]\n    for i in range(v + 1):\n        ans += dp[len(l1) - 1][i]\n        ans = ans % P\n    print(ans)\nmain()", "(n, k) = map(int, input().split())\nx = list(map(int, input().split()))\nl = [0 for i in range(100001)]\nfor i in x:\n    l[i] += 1\nl = list(filter(lambda a: a != 0, l))\nk = min(k, len(l))\ndp = [[0 for i in range(len(l) + 1)] for j in range(k)]\nfor i in range(1, len(l) + 1):\n    dp[0][i] = dp[0][i - 1] + l[i - 1]\nans = dp[0][len(l)] + 1\nfor i in range(1, k):\n    for j in range(1, len(l) + 1):\n        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1] * l[j - 1]) % 1000000007\n    ans = (ans + dp[i][len(l)]) % 1000000007\nprint(ans)", "(n, k) = map(int, input().split())\nx = list(map(int, input().split()))\nl = [0 for i in range(100001)]\nfor i in x:\n    l[i] += 1\nl = list(filter(lambda a: a != 0, l))\nk = min(k, len(l))\ndp = [[0 for i in range(len(l) + 1)] for j in range(k)]\nfor i in range(1, len(l) + 1):\n    dp[0][i] = dp[0][i - 1] + l[i - 1]\nans = dp[0][len(l)] + 1\nfor i in range(1, k):\n    for j in range(1, len(l) + 1):\n        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1] * l[j - 1]) % 1000000007\n    ans = (ans + dp[i][len(l)]) % 1000000007\nprint(ans)", "def compute_coeff(roots, k):\n    mod = 10 ** 9 + 7\n    res = [1 for i in range(len(roots) + 1)]\n    for i in range(len(roots)):\n        cur_root = roots[i]\n        for j in range(i, -1, -1):\n            if j == 0:\n                res[j] *= -cur_root\n            else:\n                res[j] = res[j - 1] - res[j] * cur_root\n            if res[j] >= mod:\n                res[j] %= mod\n    for i in range(len(res)):\n        res[i] = abs(res[i]) % mod\n    return res\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\n(d, a) = (dict(), 0)\nfor i in arr:\n    if i not in d.keys():\n        d[i] = 1\n    else:\n        d[i] += 1\nans = compute_coeff(list(d.values()), k)\nans = ans[::-1]\nprint(sum(ans[:k + 1]) % (10 ** 9 + 7))", "mod = int(1000000000.0) + 7\n\ndef modulus(n):\n    if n < 0:\n        n += mod\n    else:\n        n = n % mod\n    return n\n(n, k) = list(map(int, input().strip().split()))\narray = list(map(int, input().strip().split()))\nfreak = []\nfor i in list(set(array)):\n    freak.append(array.count(i))\nif k > len(freak):\n    k = len(freak)\ndp = [[0] * len(freak) for _ in range(k)]\nfor i in range(len(freak)):\n    dp[0][i] = freak[i]\nfor row in range(1, k):\n    for col in range(0, len(freak) - row):\n        dp[row][col] = modulus(freak[col] * modulus(sum(dp[row - 1][col + 1:])))\nans = 1\nfor i in dp:\n    ans += sum(i)\nans = modulus(ans)\nprint(ans)", "(n, k) = map(int, input().split())\narray = list(map(int, input().split()))\nd = dict()\nfor v in array:\n    if v not in d:\n        d[v] = 1\n    else:\n        d[v] += 1\nprime = 10 ** 9 + 7\ncount = len(d)\ndp = [[0 for i in range(count)] for j in range(count)]\nfreq = list()\nfor x in d:\n    freq.append(d[x])\nj = 0\ntotal = 0\nfor v in d:\n    if j == 0:\n        dp[0][j] = d[v] % prime\n    else:\n        dp[0][j] = (d[v] + dp[0][j - 1]) % prime\n    j += 1\nfor i in range(1, count):\n    for j in range(count):\n        if j == 0:\n            dp[i][j] = 0\n        else:\n            dp[i][j] = (dp[i - 1][j - 1] * freq[j] + dp[i][j - 1]) % prime\nif k == 0:\n    print(1)\nelse:\n    for i in range(count):\n        if i < k:\n            total = (total + dp[i][-1]) % prime\n        else:\n            break\n    print(total + 1)", "(n, k) = map(int, input().split())\narray = list(map(int, input().split()))\nd = dict()\nfor v in array:\n    if v not in d:\n        d[v] = 1\n    else:\n        d[v] += 1\nprime = 10 ** 9 + 7\ncount = len(d)\ndp = [[0 for i in range(count)] for j in range(count)]\nfreq = list()\nfor x in d:\n    freq.append(d[x])\nj = 0\ntotal = 0\nfor v in d:\n    if j == 0:\n        dp[0][j] = d[v] % prime\n    else:\n        dp[0][j] = (d[v] + dp[0][j - 1]) % prime\n    j += 1\nfor i in range(1, count):\n    for j in range(count):\n        if j == 0:\n            dp[i][j] = 0\n        else:\n            dp[i][j] = (dp[i - 1][j - 1] * freq[j] + dp[i][j - 1]) % prime\nif k == 0:\n    print(1)\nelse:\n    for i in range(count):\n        if i < k:\n            total = (total + dp[i][count - 1]) % prime\n        else:\n            break\n    print(total + 1)", "def compute_coeff(roots, k):\n    mod = 10 ** 9 + 7\n    res = [1 for i in range(len(roots) + 1)]\n    for i in range(len(roots)):\n        cur_root = roots[i]\n        for j in range(i, -1, -1):\n            if j == 0:\n                res[j] *= -cur_root\n            else:\n                res[j] = res[j - 1] - res[j] * cur_root\n            if res[j] >= mod:\n                res[j] %= mod\n    for i in range(len(res)):\n        res[i] = abs(res[i]) % mod\n    return res\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\n(d, a) = (dict(), 0)\nfor i in arr:\n    if i not in d.keys():\n        d[i] = 1\n    else:\n        d[i] += 1\nans = compute_coeff(list(d.values()), k)\nans = ans[::-1]\nprint(sum(ans[:k + 1]) % (10 ** 9 + 7))", "def compute_coeff(roots, k):\n    mod = 10 ** 9 + 7\n    res = [1 for i in range(len(roots) + 1)]\n    for i in range(len(roots)):\n        cur_root = roots[i]\n        for j in range(i, -1, -1):\n            if j == 0:\n                res[j] *= -cur_root\n            else:\n                res[j] = res[j - 1] - res[j] * cur_root\n            if res[j] >= mod:\n                res[j] %= mod\n    for i in range(len(res)):\n        res[i] = abs(res[i]) % mod\n    return res\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\n(d, a) = (dict(), 0)\nfor i in arr:\n    if i not in d.keys():\n        d[i] = 1\n    else:\n        d[i] += 1\nans = compute_coeff(list(d.values()), k)\nans = ans[::-1]\nprint(sum(ans[:k + 1]) % (10 ** 9 + 7))", "def compute_coeff(roots, k):\n    mod = 10 ** 9 + 7\n    res = [1 for i in range(len(roots) + 1)]\n    for i in range(len(roots)):\n        cur_root = roots[i]\n        for j in range(i, -1, -1):\n            if j == 0:\n                res[j] *= -cur_root\n            else:\n                res[j] = res[j - 1] - res[j] * cur_root\n            if res[j] >= mod:\n                res[j] %= mod\n    for i in range(len(res)):\n        res[i] = abs(res[i]) % mod\n    return res\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\n(d, a) = (dict(), 0)\nfor i in arr:\n    if i not in d.keys():\n        d[i] = 1\n    else:\n        d[i] += 1\nans = compute_coeff(list(d.values()), k)\nans = ans[::-1]\nprint(sum(ans[:k + 1]) % (10 ** 9 + 7))", "from collections import defaultdict\nd = defaultdict(int)\n(n, k) = map(int, input().split())\narray = list(map(int, input().split()))\nfor v in array:\n    d[v] += 1\nprime = 10 ** 9 + 7\ncount = len(d)\ndp = [[(0, 0) for i in range(count)] for j in range(count)]\nj = 0\ntotal = 0\nfor v in d:\n    if j == 0:\n        dp[0][j] = (d[v], d[v] % prime)\n    else:\n        dp[0][j] = (d[v], (d[v] + dp[0][j - 1][1]) % prime)\n    j += 1\nfor i in range(1, count):\n    for j in range(count):\n        if j == 0:\n            dp[i][j] = (0, 0)\n        else:\n            dp[i][j] = (dp[i - 1][j - 1][1] * dp[0][j][0], (dp[i - 1][j - 1][1] * dp[0][j][0] + dp[i][j - 1][1]) % prime)\nif k == 0:\n    print(1)\nelse:\n    for i in range(count):\n        if i < k:\n            total = (total + dp[i][count - 1][1]) % prime\n        else:\n            break\n    print(total + 1)", "import numpy as np\nfrom collections import defaultdict\nimport sys\nMOD = 1000000000.0 + 7\n(n, k) = map(int, sys.stdin.readline().split(' '))\narr = [int(x) for x in sys.stdin.readline().split(' ')]\nA = []\nd = defaultdict(int)\nfor ele in arr:\n    d[ele] += 1\nfor key in d.keys():\n    A.append(d[key])\nkk = min(len(A), k) + 1\nresult = np.zeros(kk, dtype=int)\nresult[0] = 1\nfor a in A:\n    result[1:kk] = (result[1:kk] + a * result[0:kk - 1] % MOD) % MOD\nans = 0\nfor r in result:\n    ans = (ans + r) % MOD\nprint(int(ans % MOD))", "(N, K) = map(int, input().split())\na = list(map(int, input().split()))\ndic = {}\nfor i in range(len(a)):\n    if a[i] not in dic:\n        dic[a[i]] = 1\n    else:\n        dic[a[i]] += 1\nfreq = list()\nfor x in dic:\n    freq.append(dic[x])\n(Na, Ka) = (len(freq), min(K, len(freq)))\ndp = [[0 for _ in range(Ka + 1)] for _ in range(Na + 1)]\nfor n in range(Na + 1):\n    for k in range(Ka + 1):\n        if n == 0 and k != 0:\n            dp[n][k] = 0\n        elif k == 0:\n            dp[n][k] = 1\n        else:\n            dp[n][k] = freq[n - 1] * dp[n - 1][k - 1] % 1000000007 + dp[n - 1][k] % 1000000007\nprint(sum(dp[Na]) % 1000000007)", "(N, K) = map(int, input().split())\na = list(map(int, input().split()))\ndic = {}\nfor i in range(len(a)):\n    if a[i] not in dic:\n        dic[a[i]] = 1\n    else:\n        dic[a[i]] += 1\nfreq = list()\nfor x in dic:\n    freq.append(dic[x])\n(Na, Ka) = (len(freq), min(K, len(freq)))\ndp = [[0 for _ in range(Ka + 1)] for _ in range(Na + 1)]\nfor n in range(Na + 1):\n    for k in range(Ka + 1):\n        if n == 0 or k == 0:\n            dp[n][k] = 1\n        else:\n            dp[n][k] = freq[n - 1] * dp[n - 1][k - 1] % 1000000007 + dp[n - 1][k] % 1000000007\nprint(dp[Na][Ka] % 1000000007)", "from collections import Counter\nfrom itertools import accumulate\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nctr = Counter(a)\nst = list(set(a))\nl = len(st)\nk = min(k, l)\nm = list(accumulate([ctr[i] for i in st]))\nans = 0\nfor i in range(2, k + 1):\n    temp = []\n    for j in range(l):\n        if j >= i - 1:\n            ans += m[j - 1] * ctr[st[j]]\n            temp.append(m[j - 1] * ctr[st[j]] + temp[-1])\n        else:\n            temp.append(0)\n    m = temp\nprint((ans + sum(ctr.values()) + 1) % (10 ** 9 + 7))", "from collections import Counter\nfrom itertools import accumulate\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nctr = Counter(a)\nst = list(set(a))\nl = len(st)\nk = min(k, l)\nm = list(accumulate([ctr[i] for i in st]))\nans = 0\nfor i in range(2, k + 1):\n    temp = []\n    for j in range(l):\n        if j >= i - 1:\n            ans += m[j - 1] * ctr[st[j]]\n            temp.append(m[j - 1] * ctr[st[j]] + temp[-1])\n        else:\n            temp.append(0)\n    m = temp\nprint((ans + sum(ctr.values()) + 1) % (10 ** 9 + 7))", "from collections import Counter\nfrom itertools import accumulate\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nctr = Counter(a)\nst = list(set(a))\nl = len(st)\nk = min(k, l)\nm = list(accumulate([ctr[i] for i in st]))\nans = 0\nfor i in range(2, k + 1):\n    temp = []\n    for j in range(l):\n        if j >= i - 1:\n            ans += m[j - 1] * ctr[st[j]]\n            temp.append(m[j - 1] * ctr[st[j]] + temp[-1])\n        else:\n            temp.append(0)\n    m = temp\nprint((ans + sum(ctr.values()) + 1) % (10 ** 9 + 7))", "mod = 10 ** 9 + 7\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nl = [0]\na.sort()\nfor i in range(0, n):\n    if a[i] == a[i - 1]:\n        l[-1] += 1\n    else:\n        l.append(1)\nmaxxl = min(k, len(l))\narray = []\nfor i in range(maxxl + 1):\n    temp = [0] * len(l)\n    array.append(temp)\nfor i in range(1, maxxl + 1):\n    temp = 0\n    for j in range(1, len(l)):\n        if i == 1:\n            array[i][j] = l[j]\n        elif j >= i:\n            temp += array[i - 1][j - 1]\n            array[i][j] = temp * l[j] % mod\nans = 0\nfor i in range(len(array)):\n    for j in range(len(array[i])):\n        ans = (ans + array[i][j]) % mod\nans += 1\nprint(ans % mod)", "import sys\nfrom functools import reduce\nfrom collections import Counter\nfrom numpy import convolve\n(N, K) = map(int, input().split())\nA = Counter(list(map(int, input().split()))[:N])\nO = [[1, c] for c in A.values()]\nans = sum(reduce(lambda x, y: convolve(x, y) % 1000000007, O)[:K + 1])\nprint(ans % 1000000007, end='')", "(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\no = 10 ** 9 + 7\nh = {}\nfor i in l:\n    try:\n        h[i] = h[i] + 1\n    except:\n        h[i] = 1\nu = []\nfor i in h:\n    u.append(h[i])\nz = u[:]\na = 0\nfor i in range(1, len(u)):\n    s = 0\n    v = [0] * len(u)\n    if m == 1:\n        break\n    for j in range(i, len(u)):\n        s = (s + u[j - 1] % o) % o\n        v[j] = s * z[j] % o\n    a = (a + sum(v) % o) % o\n    m = m - 1\n    u = v\nprint((a + (1 + sum(z))) % o)", "from collections import Counter\nfrom itertools import accumulate\nimport numpy as np\n(n, k) = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nc = Counter(a)\ndis_ele = c.keys()\ndis_ele_count = len(dis_ele)\nmod = 1000000007\nans = n + 1\narr = np.zeros((dis_ele_count, k + 1))\narr[:, 0] = list(dis_ele)\narr[:, 1] = list(accumulate(c.values()))\nfor i in range(2, k + 1):\n    for j in range(i - 1, dis_ele_count):\n        arr[j][i] = arr[j - 1][i - 1] % mod * c[arr[j][0]] % mod % mod + arr[j - 1][i]\n    ans = (ans % mod + arr[j][i] % mod) % mod\nprint(int(ans) % mod)", "import numpy as np\nmod = 1000000007\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nfre = [0] * 10000\nA = []\nfor i in range(0, n):\n    fre[a[i]] += 1\nfor i in range(0, 8001):\n    if fre[i] > 0:\n        A.append(fre[i])\nkk = min(len(A), k) + 1\nS = np.zeros(kk, dtype=int)\nS[0] = 1\nfor a in A:\n    S[1:kk] = (S[1:kk] + a * S[0:kk - 1] % mod) % mod\nans = 0\nfor s in S:\n    ans = (ans + s) % mod\nprint(ans)", "mod = 1000000007\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\ndic = {}\ns = 0\ntemp = []\narr2 = []\narr2.append([])\nfor x in arr:\n    dic[x] = 0\nfor x in arr:\n    dic[x] = dic[x] + 1\nfor x in dic:\n    arr2[0].append(dic[x])\n    s = s + dic[x]\n    temp.append(s)\nfor x in range(1, k):\n    arr2.append([])\n    cc = 0\n    for y in range(len(arr2[0]) - x):\n        v = arr2[0][y] * (temp[-x] - temp[y])\n        arr2[x].append(v)\n        s = s + v\n        cc = cc + v\n        temp[y] = cc\nprint((s + 1) % mod)", "import sys\nimport numpy as np\nmod = 1000000007\n(n, k) = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nfre = [0] * 10000\nA = []\nfor i in range(0, n):\n    fre[a[i]] += 1\nfor i in range(0, 8001):\n    if fre[i] > 0:\n        A.append(fre[i])\nkk = min(len(A), k) + 1\nS = np.zeros(kk, dtype=int)\nS[0] = 1\nfor a in A:\n    S[1:kk] = (S[1:kk] + a * S[0:kk - 1] % mod) % mod\nans = 0\nfor s in S:\n    ans = (ans + s) % mod\nprint(ans)", "(n, k) = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n(d, s, temp, arr) = ({}, 0, [], [])\narr.append([])\nfor i in a:\n    d[i] = 0\nfor i in a:\n    d[i] += 1\nfor i in d:\n    arr[0].append(d[i])\n    s += d[i]\n    temp.append(s)\nfor i in range(1, k):\n    arr.append([])\n    val = 0\n    for j in range(len(arr[0]) - i):\n        v = arr[0][j] * (temp[-i] - temp[j])\n        arr[i].append(v)\n        s += v\n        val += v\n        temp[j] = val\nprint((s + 1) % 1000000007)", "def pr_sum(dp, row, n):\n    pre = []\n    ssf = 0\n    for i in range(n):\n        ssf += dp[row - 1][i]\n        pre.append(ssf)\n    return pre\n(n, k) = map(int, input().split())\nlst = list(map(int, input().split()))\ncnt = [0] * 8000\nfor ele in lst:\n    cnt[ele] += 1\ncounter = []\nfor ele in cnt:\n    if ele:\n        counter.append(ele)\nn = min(1007, k)\na = len(counter)\ndp = [[0 for i in range(a)] for i in range(n)]\ndp[0] = counter\nans = 1\nfor i in range(1, n):\n    prefix_sum = pr_sum(dp, i, a)\n    ans += prefix_sum[-1]\n    for j in range(1, a):\n        cell_val = prefix_sum[j - 1] * counter[j]\n        dp[i][j] = cell_val\nans += sum(dp[-1])\nprint(ans % 1000000007)", "import collections\nimport math\n\ndef CountFrequency(a):\n    return collections.Counter(a)\n\ndef nCr(n, r):\n    return fact(n) // (fact(r) * fact(n - r))\n\ndef fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\n\ndef sub(a, k, n):\n    f = [0] * n\n    f[0] = n\n    for i in range(1, n, 1):\n        for h in range(i, 0, -1):\n            f[h] = f[h] + a[i] * f[h - 1]\n    return f\n\ndef su(n, k, a, dp, hell, heave):\n    if k == -1:\n        return 1\n    if n == -1:\n        return 0\n    if n <= hell and k <= heave:\n        if dp[n][k] != -1:\n            return dp[n][k]\n    else:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = a[n] * su(n - 1, k - 1, a, dp, hell, heave)\n    ans2 = su(n - 1, k, a, dp, hell, heave)\n    if n <= hell and k <= heave:\n        dp[n][k] = int(ans1 + ans2)\n    sol = ans2 + ans1\n    return int(sol)\n\ndef vi(roots, n, k):\n    coeff = [0] * (n + 1)\n    coeff[n] = 1\n    for i in range(1, n + 1):\n        for j in range(n - i - 1, n):\n            coeff[j] += -1 * roots[i - 1] * coeff[j + 1]\n    coeff = coeff[::-1]\n    ans = 0\n    for i in range(k + 1):\n        ans += abs(coeff[i])\n    return int(ans)\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nst = set(a)\nhug = len(st)\nif hug != n:\n    freq = CountFrequency(a)\n    an = [0] * hug\n    star = 0\n    for (key, value) in freq.items():\n        an[star] = value\n        star += 1\n    siz = hug\n    if k > hug:\n        k = hug\n    ans = vi(an, hug, k)\n    print(int(ans) % 1000000007)\nelse:\n    ans = int(math.pow(2, n))\n    r = n\n    while r > k:\n        ans -= int(nCr(n, r))\n        r -= 1\n    print(int(ans) % 1000000007)", "(N, K) = [int(i) for i in input().split(' ')]\narr = [int(i) for i in input().split(' ')]\nmap = {}\nmod = 10 ** 9 + 7\nfor i in arr:\n    if i in map:\n        map[i] = (map[i] + 1) % mod\n    else:\n        map[i] = 1\ncount = list(map.keys())\nK = min(len(count), K)\ndp = [1] * (K + 1)\nprev = [1] * (K + 1)\nfor i in count:\n    for j in range(K + 1):\n        if j == 0:\n            continue\n        else:\n            dp[j] = (prev[j] + prev[j - 1] * map[i] % mod) % mod\n    for i in range(K + 1):\n        prev[i] = dp[i]\nprint(dp[K])", "(N, K) = [int(i) for i in input().split(' ')]\narr = [int(i) for i in input().split(' ')]\nmap = {}\nmod = 10 ** 9 + 7\nfor i in arr:\n    if i in map:\n        map[i] = (map[i] + 1) % mod\n    else:\n        map[i] = 1\ncount = list(map.keys())\nK = min(len(count), K)\ndp = [[0] * (K + 1) for i in range(len(count) + 1)]\nfor i in range(len(count) + 1):\n    for j in range(K + 1):\n        if j == 0 or i == 0:\n            dp[i][j] = 1\n        else:\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * map[count[i - 1]] % mod) % mod\nprint(dp[len(count)][K])", "import collections\nimport numpy\nmo = 10 ** 9 + 7\n\ndef nCr(n, r):\n    return fact(n) // (fact(r) * fact(n - r))\n\ndef fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\ntry:\n    (x, y) = map(int, input().split())\n    l = list(map(int, input().split()))\n    k = collections.Counter(l)\n    o = list(k.values())\n    m = min(y, len(o))\n    p = [1] + [0] * m\n    s = 0\n    for _ in o:\n        for i in range(m, 0, -1):\n            p[i] += p[i - 1] * _\n    print(sum(p) % mo)\nexcept:\n    pass", "from collections import Counter\n(N, K) = (int(x) for x in input().split(' '))\nA = (int(x) for x in input().split(' '))\nC = Counter(A)\nR = [1]\nfor (n, c) in C.items():\n    R.append(0)\n    for i in range(len(R) - 1, 0, -1):\n        R[i] += R[i - 1] * c\n        R[i] = R[i] % 1000000007\nprint(sum(R[:K + 1]) % 1000000007)", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\nss = {}\nfor i in l:\n    try:\n        ss[i] += 1\n    except:\n        ss[i] = 1\ndp = [0] * (n + 1)\ndp[0] = 1\ndp1 = dp[:]\nj = 0\nfor a in ss:\n    f = ss[a]\n    for i in range(j + 1):\n        dp1[i + 1] = dp1[i + 1] + dp[i] * f\n    dp = dp1[:]\n    j = j + 1\nans = sum(dp[:k + 1]) % (10 ** 9 + 7)\nprint(ans)", "(nn, kk) = map(int, input().split())\nit = list(map(int, input().split()))\nss = {}\nfor i in it:\n    try:\n        ss[i] += 1\n    except:\n        ss[i] = 1\nj = 0\ndp = [0] * (nn + 1)\ndp[0] = 1\nmod = 10 ** 9 + 7\nfor i in ss:\n    f = ss[i]\n    dp2 = dp[:]\n    for k in range(j + 1):\n        dp2[k + 1] += dp[k] * f\n    dp = dp2[:]\n    j += 1\n    dp = [i % mod for i in dp]\nprint(sum(dp[:kk + 1]) % (10 ** 9 + 7))", "from collections import Counter\nmodu = 10 ** 9 + 7\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nm = Counter(arr)\nl = min(len(m), k)\ndp = [[0 for i in range(len(m) + 1)] for j in range(len(m) + 1)]\nun = list(m.values())\nfor i in range(1, len(m) + 1):\n    for j in range(i, len(m) + 1):\n        if i == 1:\n            dp[i][j] = (dp[i][j - 1] % modu + un[j - 1] % modu) % modu\n        else:\n            dp[i][j] = (dp[i - 1][j - 1] % modu * (un[j - 1] % modu) % modu + dp[i][j - 1] % modu) % modu\nans = 1\nfor i in range(1, l + 1):\n    ans = (ans % modu + dp[i][len(m)] % modu) % modu\nprint(ans % modu)", "import sys\nfrom functools import reduce\nfrom collections import Counter\nfrom numpy import convolve\n(N, K) = map(int, sys.stdin.readline().split())\nA = Counter(list(map(int, sys.stdin.readline().split()))[:N])\nO = [[1, c] for c in A.values()]\nans = sum(reduce(lambda x, y: convolve(x, y) % 1000000007, O)[:K + 1])\nprint(ans % 1000000007, end='')", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nd = {}\nmod = 1000000007\nfor i in arr:\n    try:\n        d[i] += 1\n    except:\n        d[i] = 1\narr = [d[i] for i in d.keys()]\nz = len(arr) - 1\nmat = [[0 for i in range(z + 1)] for i in range(k + 1)]\nmat[1] = arr[:]\nfor i in range(1, z + 1):\n    mat[1][i] += mat[1][i - 1]\nsu = sum(arr)\nfor i in range(2, k + 1):\n    if i > len(arr):\n        break\n    for j in range(z - i + 2):\n        x = arr[j] * (mat[i - 1][z - i + 2] - mat[i - 1][j]) % mod\n        try:\n            mat[i][j] = mat[i][j - 1] + x\n        except:\n            mat[i][j] = x\n    su = (su + mat[i][z - i + 1]) % mod\nprint(su + 1)", "(n, kk) = map(int, input().split())\nit = list(map(int, input().split()))\nss = {}\nfor i in it:\n    try:\n        ss[i] += 1\n    except:\n        ss[i] = 1\nj = 0\ndp = [0] * (n + 1)\ndp[0] = 1\nmod = 10 ** 9 + 7\nfor i in ss:\n    f = ss[i]\n    dp2 = dp[:]\n    for k in range(j + 1):\n        dp2[k + 1] += dp[k] * f\n    dp = dp2[:]\n    j += 1\n    dp = [i % mod for i in dp]\nprint(sum(dp[:kk + 1]) % (10 ** 9 + 7))", "import sys\nimport numpy as np\nmod = 1000000007\n(n, k) = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nfre = [0] * 10000\nA = []\nfor i in range(0, n):\n    fre[a[i]] += 1\nfor i in range(0, 8001):\n    if fre[i] > 0:\n        A.append(fre[i])\nkk = min(len(A), k) + 1\nS = np.zeros(kk, dtype=int)\nS[0] = 1\nfor a in A:\n    S[1:kk] = (S[1:kk] + a * S[0:kk - 1] % mod) % mod\nans = 0\nfor s in S:\n    ans = (ans + s) % mod\nprint(ans)", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\ncount = [0] * 8001\nfor i in l:\n    count[i] += 1\narr = []\nfor i in count:\n    if i != 0:\n        arr.append(i)\narr.sort()\nn = len(arr)\nk = min(k, n)\ndp = [[0 for i in range(n)] for i in range(k)]\nsum = 0\nfor i in range(n):\n    dp[0][i] = arr[i]\n    sum += arr[i]\nfor i in range(1, k):\n    S = dp[i - 1][0]\n    s = 1\n    ns = 0\n    for j in range(n - s):\n        z = sum - S\n        dp[i][j] = dp[0][j] * z\n        ns = ns + dp[i][j]\n        S = S + dp[i - 1][j + 1]\n        s += 1\n    sum = ns\nans = 0\nfor i in range(k):\n    for j in dp[i]:\n        ans = ans + j\nprint((ans + 1) % 1000000007)", "from collections import Counter\nimport math\nmod = 1000000007\ncnt = 1\nj = 0\n(n, k) = map(int, input().split())\nSUM = 1 + n\nsum2 = 0\narr1 = [int(i) for i in input().split()]\narr2 = Counter(arr1)\nfor (key, value) in arr2.items():\n    j = j + 1\n    if value != 1:\n        cnt = 0\nif cnt == 1:\n    for i in range(2, k + 1):\n        c = math.factorial(n) // math.factorial(n - i) // math.factorial(i)\n        SUM = (SUM % mod + c % mod) % mod\n    print(SUM)\nelse:\n    (r, c) = (j + 1, j + 1)\n    arr = [[0 for i in range(c)] for j in range(r)]\n    if j == 1:\n        print(SUM)\n    else:\n        if k >= j:\n            k = j\n        i = 0\n        for (key, value) in arr2.items():\n            arr[0][i] = value\n            sum2 = (sum2 % mod + value % mod) % mod\n            i = i + 1\n        i = 1\n        while i < j and i < k:\n            sum1 = 0\n            sum3 = 0\n            x = 0\n            while x < j - i:\n                sum1 = sum1 + arr[i - 1][x]\n                arr[i][x] = arr[0][x] * (sum2 - sum1)\n                sum3 = sum3 + arr[i][x]\n                x = x + 1\n            sum2 = sum3\n            SUM = (SUM % mod + sum3 % mod) % mod\n            i = i + 1\n        print(SUM)", "import numpy as np\nmod = 1000000007\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nfre = [0] * 10000\nA = []\nfor i in range(0, n):\n    fre[a[i]] += 1\nfor i in range(0, 8001):\n    if fre[i] > 0:\n        A.append(fre[i])\nkk = min(len(A), k) + 1\nS = np.zeros(kk, dtype=int)\nS[0] = 1\nfor a in A:\n    S[1:kk] = (S[1:kk] + a * S[0:kk - 1] % mod) % mod\nans = 0\nfor s in S:\n    ans = (ans + s) % mod\nprint(ans)", "import collections\n\ndef prepare_nck(n, k):\n    ncr = [0] * (k + 1)\n    for i in range(k + 1):\n        if ncr[i] != 0:\n            break\n        if i == 0:\n            nxt = 1\n        else:\n            nxt = ncr[i - 1] * (n - (i - 1)) // i\n        ncr[i] = nxt\n        if n - i <= k:\n            ncr[n - i] = nxt\n    return ncr\n\ndef sum_ncr_mod(n, k, mod):\n    ncr = prepare_nck(n, k)\n    result = 0\n    for ncr_val in ncr:\n        result = (result + ncr_val) % mod\n    return result\n\ndef count_frequency(arr):\n    freq = {}\n    for item in arr:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq\n\ndef cal_result(a, n, k, mod):\n    a_set = set(a)\n    freq = count_frequency(a)\n    k = min(k, len(a_set))\n    cf = [0] * (len(a_set) + 1)\n    freq_val = list(freq.values())\n    cf[0] = 1\n    cf[1] = freq_val[0] % mod\n    index = 2\n    for i in range(1, len(freq_val)):\n        val = freq_val[i]\n        for j in range(index, 0, -1):\n            cf[j] = (cf[j] + val * cf[j - 1]) % mod\n        index += 1\n    result = 0\n    for i in range(k + 1):\n        result = (result + cf[i]) % mod\n    return result\n\ndef solve():\n    mod = 10 ** 9 + 7\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a_set = set(a)\n    if n == len(a_set):\n        print(sum_ncr_mod(n, k, mod))\n        return\n    print(cal_result(a, n, k, mod))\nsolve()", "mod = 1000000007\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\ndic = {}\ns = 0\ntemp = []\narr2 = []\narr2.append([])\nfor x in arr:\n    dic[x] = 0\nfor x in arr:\n    dic[x] = dic[x] + 1\nfor x in dic:\n    arr2[0].append(dic[x])\n    s = s + dic[x]\n    temp.append(s)\nfor x in range(1, k):\n    arr2.append([])\n    cc = 0\n    for y in range(len(arr2[0]) - x):\n        v = arr2[0][y] * (temp[-x] - temp[y])\n        arr2[x].append(v)\n        s = s + v\n        cc = cc + v\n        temp[y] = cc\nprint((s + 1) % mod)", "import collections\nimport math\n\ndef CountFreq(arr):\n    return collections.Counter(arr)\n\ndef nCr(n, i):\n    npr = math.factorial(n) // math.factorial(n - i)\n    ncr = npr // math.factorial(i)\n    return ncr\nl = 1000000007\nc = 0\nj = 0\n(n, k) = map(int, input().split())\nm = math.factorial(n)\nlist1 = [int(i) for i in input().split()]\nlist2 = CountFreq(list1)\nfor (key, value) in list2.items():\n    j = j + 1\n    if value != 1:\n        c = 1\ns1 = 1 + n\nif c == 0:\n    for i in range(2, k + 1):\n        npr = m // math.factorial(n - i)\n        ncr = npr // math.factorial(i)\n        s1 = (s1 % l + ncr % l) % l\n    print(s1)\nelse:\n    s2 = 0\n    (rows, cols) = (j + 1, j + 1)\n    arr = [[0 for i in range(cols)] for j in range(rows)]\n    if j == 1:\n        print(s1)\n    else:\n        if k >= j:\n            k = j\n        i = 0\n        for (key, value) in list2.items():\n            arr[0][i] = value\n            s2 = (s2 % l + value % l) % l\n            i = i + 1\n        i = 1\n        while i < j and i < k:\n            sm1 = 0\n            s3 = 0\n            z = 0\n            while z < j - i:\n                sm1 = sm1 + arr[i - 1][z]\n                arr[i][z] = arr[0][z] * (s2 - sm1)\n                s3 = s3 + arr[i][z]\n                z = z + 1\n            s2 = s3\n            s1 = (s1 % l + s3 % l) % l\n            i = i + 1\n        print(s1)", "def SOE(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\ndef dp(arr):\n    i = 1\n    while i <= prime[max_num]:\n        j = 1\n        while j <= min(i, k):\n            if j == 1:\n                arr[i][j] = (arr[i - 1][j] + f[i]) % (10 ** 9 + 7)\n            else:\n                arr[i][j] = arr[i - 1][j - 1] * f[i] % (10 ** 9 + 7) + arr[i - 1][j]\n            j = j + 1\n        i = i + 1\n(n, k) = [int(x) for x in input().split()]\nnum = [int(x) for x in input().split()]\nprime = SOE(8000)\nprime_count = 1\nfor i in range(2, 8000):\n    if prime[i] == True:\n        prime[i] = prime_count\n        prime_count = prime_count + 1\nf = [0 for x in range(1008)]\nmax_num = -1\nfor j in range(len(num)):\n    f[prime[num[j]]] += 1\n    if num[j] > max_num:\n        max_num = num[j]\narr = [[0 for x in range(1008)] for p in range(1008)]\ndp(arr)\nprint(sum(arr[prime[max_num]]) % (10 ** 9 + 7) + 1)", "(n, k) = input().split(' ')\nk = int(k)\nn = int(n)\nM = 1000000007\na = input().split(' ')\nfor i in range(len(a)):\n    a[i] = int(a[i])\na.sort()\nfreq = {}\nfor item in a:\n    if item in freq:\n        freq[item] += 1\n    else:\n        freq[item] = 1\na2 = []\nfor (key, value) in freq.items():\n    a2.append(value % M)\ncoeff = [0] * (len(a2) + 1)\ncoeff[len(a2)] = 1\nfor i in range(1, len(a2) + 1):\n    for j in range(len(a2) - i - 1, len(a2)):\n        coeff[j] += -1 * a2[i - 1] * coeff[j + 1]\n        abs(coeff[j]) % M\ncoeff = coeff[::-1]\nsum = 0\nfor i in range(min(k + 1, len(a2) + 1)):\n    sum = (sum % M + abs(coeff[i])) % M\nprint(sum)", "def vietaFormula(freq, n):\n    coeff = [0] * (n + 1)\n    coeff[n] = 1\n    for i in range(1, n + 1):\n        for j in range(n - i - 1, n):\n            coeff[j] += -1 * freq[i - 1] * coeff[j + 1]\n    coeff = coeff[::-1]\n    return coeff\n\ndef print_ans(n, k, a):\n    dic = dict()\n    for i in a:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    n = len(dic)\n    freq = [dic[x] for x in dic]\n    del a\n    coeff = vietaFormula(freq, n)\n    st = 1\n    for x in range(1, min(k + 1, len(coeff))):\n        if x % 2 == 1:\n            st += -1 * coeff[x]\n        else:\n            st += coeff[x]\n    print(st // coeff[0] % 1000000007)\n(n, k) = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nprint_ans(n, k, a)", "from collections import Counter\nBIGN = 1000000007\n\ndef calcans(m: Counter, k: int):\n    nums = list(m.values())\n    pref = []\n    c = 0\n    buff = 0\n    for i in nums:\n        buff += i\n        pref.append(buff)\n        c += 1\n    if k == 1:\n        return pref[c - 1] % BIGN\n    ans = 0\n    pref2 = [0] * c\n    i = c - 1\n    while i > 0:\n        ans += nums[i] * pref[i - 1]\n        pref2[i] = ans\n        i -= 1\n    ans = ans + pref[c - 1]\n    if k == 2:\n        return ans % BIGN\n    idx = 1\n    while k > 2:\n        buffans = 0\n        i = c - 1\n        while i > idx:\n            buffans += nums[i] * (pref2[idx] - pref2[i])\n            pref2[i] = buffans\n            i -= 1\n        ans += buffans\n        idx += 1\n        k -= 1\n    return ans % BIGN\n(n, k) = tuple([int(x) for x in str(input()).split(' ')])\na = [int(x) for x in str(input()).split(' ')]\nc = Counter(a)\nkey = list(c.keys())\nval = list(c.values())\nans = calcans(c, k)\nprint((ans + 1) % BIGN)", "import collections\nimport numpy\nmo = 10 ** 9 + 7\n\ndef nCr(n, r):\n    return fact(n) // (fact(r) * fact(n - r))\n\ndef fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\ntry:\n    (x, y) = map(int, input().split())\n    l = list(map(int, input().split()))\n    k = collections.Counter(l)\n    o = list(k.values())\n    m = min(y, len(o))\n    p = [1] + [0] * m\n    s = 0\n    for _ in o:\n        for i in range(m, 0, -1):\n            p[i] += p[i - 1] * _\n    print(sum(p) % mo)\nexcept:\n    pass", "from collections import Counter\nmod = 1000000007\n(n, k) = map(int, input().split())\narr = [int(i) for i in input().split()]\ndic = Counter(arr)\narr1 = []\narr1.append(0)\nfor value in dic.values():\n    arr1.append(value)\narr2 = [0 for i in range(len(arr1))]\narr2[0] = 1\nfor i in range(1, len(arr1)):\n    for j in range(i, 0, -1):\n        arr2[j] += arr1[i] * arr2[j - 1] % mod\nif k > len(arr1) - 1:\n    k = len(arr1) - 1\ngoodsub = 0\nfor i in range(k + 1):\n    goodsub = (goodsub + arr2[i]) % mod\nprint(goodsub)", "import itertools\nimport math\nimport string\nfrom collections import Counter\nM = 10 ** 9 + 7\n\ndef ans(a, k):\n    kk = 0\n    if len(a) < k:\n        kk = len(a) + 1\n    else:\n        kk = k + 1\n    s = [0] * kk\n    s[0] = 1\n    s1 = s[:]\n    for i in range(0, len(a)):\n        for j in range(1, kk):\n            s[j] = (s[j] % M + a[i] * s1[j - 1] % M) % M\n        s1 = s[:]\n    su = 0\n    for i in range(0, kk):\n        su = (su % M + s[i] % M) % M\n    print(su % M)\n(n, k) = map(int, input().split())\na = [int(x) for x in input().split()]\nc = list(Counter(a).values())\nans(c, k)", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\ndic = {}\nfor i in a:\n    if i not in dic:\n        dic[i] = 1\n    else:\n        dic[i] += 1\nli = list(dic.values())\nans = 1 + n\nmi = min(k, len(li))\nte = []\nfor i in range(len(li)):\n    t = 0\n    for j in range(i + 1, len(li)):\n        t += li[i] * li[j]\n    if i > 0 and t > 0:\n        te.append(t)\n    ans += t\nfor i in range(2, mi):\n    dummy = []\n    tesum = sum(te)\n    for j in range(len(te)):\n        if j > 0:\n            tesum -= te[j - 1]\n        t = li[j] * tesum\n        ans += t\n        if j > 0:\n            dummy.append(t)\n    te = dummy\nprint(ans % (10 ** 9 + 7))", "from collections import Counter\nfrom functools import reduce\n\ndef main():\n    (n, k) = [int(ele) for ele in input().strip().split()]\n    a = [int(ele) for ele in input().strip().split()]\n    freqArray = list(Counter(a).values())\n    n = len(freqArray)\n    sum1 = sum(freqArray, 1) % 1000000007\n    fre = [[0 for i in range(n)] for j in range(n)]\n    for j in range(n):\n        fre[0][j] = freqArray[j]\n    for i in range(1, k):\n        sum2 = 0\n        for j in range(1, n - i + 1):\n            sum2 += fre[i - 1][j]\n        for j in range(0, n - i):\n            fre[i][j] = freqArray[j] * sum2\n            sum2 -= fre[i - 1][j + 1]\n            sum1 = (sum1 % 1000000007 + fre[i][j] % 1000000007) % 1000000007\n    print(sum1)\nmain()", "(n, k) = input().split()\nn = int(n)\nk = int(k)\ns = 0\narr = list(map(int, input().split()))\narr1 = [0 for i in range(8001)]\narr2 = []\nfor i in arr:\n    arr1[i] += 1\nfor i in arr1:\n    if i >= 1:\n        arr2.append(i)\np = len(arr2)\narr2.sort()\nflist = [[0 for i in range(p)] for j in range(k)]\nsum1 = 0\nfor i in range(p):\n    flist[0][i] = arr2[i]\n    sum1 += arr2[i]\nfsum = sum1\nfor i in range(1, k):\n    sum2 = 0\n    for j in range(p):\n        sum1 -= flist[i - 1][j]\n        flist[i][j] = arr2[j] * sum1\n        sum2 = sum2 + flist[i][j]\n        if sum1 <= 0:\n            break\n    sum1 = sum2\n    fsum += sum2\nprint((fsum + 1) % 1000000007)", "import numpy as np\nimport collections\nnk = list(map(int, input().split()))\ninp = list(map(int, input().split()))\ncounter = collections.Counter(inp)\nA = list(counter.values())\nk = nk[1]\np = 10 ** 9 + 7\nkk = min(len(A), k) + 1\nS = np.zeros(kk, dtype=int)\nS[0] = 1\nfor a in A:\n    S[1:kk] = S[1:kk] % p + a % p * S[0:kk - 1] % p % p\nprint(S.sum() % p)", "try:\n    from collections import Counter\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    c = Counter(l)\n    k = min(k, len(c))\n    ar = [0] * (k + 1)\n    ar[0] = 1\n    for _ in c:\n        for i in range(k, 0, -1):\n            ar[i] = (ar[i] + ar[i - 1] * c[_] % 1000000007) % 1000000007\n    ans = 0\n    for _ in ar:\n        ans = (ans + _) % 1000000007\n    print(ans % 1000000007)\nexcept:\n    pass", "mod = 10 ** 9 + 7\n\ndef fact():\n    f = [1]\n    for i in range(1, 8008):\n        f.append(f[-1] * i)\n    return f\nf = fact()\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nA = [0 for i in range(8080)]\nfor i in a:\n    A[i] += 1\ns = list(set(a))\nm = len(s)\nnf = f[m]\nif k == n:\n    ans = 1\n    for i in s:\n        ans *= A[i] + 1\n        ans %= mod\n    print(ans % mod)\n    exit(0)\nif n == m:\n    ans = 1\n    for i in range(1, k + 1):\n        ans += nf // (f[i] * f[n - i])\n        ans = ans % mod\n    print(ans % mod)\nelse:\n    freq = []\n    for i in A:\n        if i != 0:\n            freq.append(i % mod)\n    z = len(freq)\n    dp = [[0 for i in range(8080)] for j in range(8080)]\n    for i in range(z):\n        dp[i][0] = 1\n    for i in range(1, z + 1):\n        for j in range(z + 1):\n            dp[i][j] = dp[i - 1][j] % mod + freq[i - 1] * dp[i - 1][j - 1] % mod\n            dp[i][j] %= mod\n    ans = 0\n    for i in range(k + 1):\n        ans += dp[len(freq)][i]\n        ans %= mod\n    print(ans % mod)", "M = 1000000007\nimport sys\n\nclass recursionlimit:\n\n    def __init__(self, limit):\n        self.limit = limit\n        self.old_limit = sys.getrecursionlimit()\n\n    def __enter__(self):\n        sys.setrecursionlimit(self.limit)\n\n    def __exit__(self, type, value, tb):\n        sys.setrecursionlimit(self.old_limit)\nwith recursionlimit(100005):\n\n    def SOP(n, k, a, dp):\n        if k == -1:\n            return 1\n        if n == -1:\n            return 0\n        if dp[n][k] != -1:\n            return dp[n][k]\n        ans1 = a[n] * SOP(n - 1, k - 1, a, dp) % M\n        ans2 = SOP(n - 1, k, a, dp)\n        dp[n][k] = (ans1 + ans2) % M\n        return dp[n][k]\n    (N, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a_set = list(set(a))\n    a_count = []\n    for x in a_set:\n        a_count.append(a.count(x))\n    len_a_count = len(a_count)\n    k = min(len(a_set), k)\n    dp = [[-1 for i in range(k)] for j in range(len_a_count)]\n    final_ans = 0\n    for i in range(k + 1):\n        final_ans = (final_ans + SOP(len_a_count - 1, i - 1, a_count, dp)) % M\n    print(final_ans)", "def multiply(A, B, m, n):\n    prod = [0] * (m + n - 1)\n    for i in range(m):\n        for j in range(n):\n            x = A[i] * B[j] % 1000000007\n            prod[i + j] = (prod[i + j] + x) % 1000000007\n    return prod\n(n, k) = [int(x) for x in input().split(' ')]\nif n != 1:\n    s = [int(x) for x in input().split(' ')]\n    arr = [0] * 1000000\n    m = 0\n    for i in s:\n        arr[i] += 1\n        if m < i:\n            m = i\n    A = [1, 0]\n    B = [1]\n    for i in range(2, m + 1):\n        if arr[i] != 0:\n            B.append(arr[i])\n            A = multiply(A, B, len(A), len(B))\n            B = [1]\n    out = 0\n    for i in range(k + 1):\n        if i < len(A):\n            out = (out + A[i]) % 1000000007\n    print(out)\nelse:\n    s = int(input())\n    print(pow(2, 0))", "from itertools import chain\n(n, k) = map(int, input().split())\nd = {}\ncount = 0\nl = list(map(int, input().split()))\nfor i in l:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\nl = []\nfor x in d.values():\n    if x == 1:\n        count += 1\n    else:\n        l.append(x)\nd = {}\npr = [1]\nfor i in l:\n    pr = [a + b * i for (a, b) in zip(chain([0], pr), chain(pr, [0]))]\na = min(count, k)\ncomb = [[0 for x in range(a + 1)] for y in range(count + 1)]\nfor i in range(count + 1):\n    for j in range(min(i, a) + 1):\n        if j == 0 or j == i:\n            comb[i][j] = 1\n        else:\n            comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j]\npr.reverse()\nsum = 0\nfor i in range(a + 1):\n    for j in range(min(len(pr) - 1, k - i) + 1):\n        sum = (sum + pr[j] * comb[count][i]) % 1000000007\nprint(sum)", "from itertools import chain\n(N, K) = map(int, input().split())\nA = list(map(int, input().split()))\nl = {}\nfor i in A:\n    if i in l:\n        l[i] += 1\n    else:\n        l[i] = 1\nq = list(l.values())\nx = [1]\nfor i in q:\n    x = [a + b * i for (a, b) in zip(chain([0], x), chain(x, [0]))]\nanswer = 0\nx = x[::-1]\nanswer = sum(x[:K + 1])\nprint(answer % 1000000007)", "import sys\nfrom functools import reduce\nimport numpy\ninput = sys.stdin.readline\nfrom collections import Counter\nPUKS = 1000000007\n(n, k) = map(int, input().split())\ns = list(map(int, list(input().split())))\nset1 = set(s)\nrl = []\nc1 = Counter(s)\nfor i in set1:\n    rl.append(c1[i])\nSIZE = len(rl)\nrow = SIZE + 1\ncol = SIZE + 1\nmat = [[0 for x in range(col)] for y in range(row)]\nmat[0][0] = 1\nfor i in range(1, row):\n    mat[i][0] = 1\n    j = 1\n    while j <= i and j <= k:\n        mat[i][j] = mat[i - 1][j] + mat[i - 1][j - 1] * rl[i - 1]\n        j = j + 1\nadd = sum(mat[SIZE][:k + 1]) % PUKS\nprint(add % PUKS)", "(n, k) = map(int, input().strip().split())\narr = [int(i) for i in input().strip().split()]\n\ndef countFreq(arr):\n    d = dict()\n    for i in range(len(arr)):\n        if arr[i] in d.keys():\n            d[arr[i]] += 1\n        else:\n            d[arr[i]] = 1\n        list = []\n    for x in d:\n        list.append(d[x])\n    return list\nc = countFreq(arr)\nn = 100000\na = [0] * n\nb = [0] * n\na[1] = c[0]\na[0] = 1\nb[1] = c[0]\nb[0] = 1\np = 1\nfor i in range(1, len(c)):\n    while i >= 0:\n        a[i + 1] = a[i] * c[p] + b[i + 1]\n        a[i + 1] = a[i + 1] % 1000000007\n        b[i + 1] = a[i + 1]\n        i = i - 1\n    p = p + 1\nif k <= p:\n    p = k\nans = 0\nfor i in range(p + 1):\n    ans = ans + b[i] % 1000000007\nprint(ans % 1000000007)", "import collections\nimport gc\nfrom itertools import combinations\nmod = 1000000007\n\ndef finalans(a, k1):\n    sizeA = len(a)\n    sumArray = [0] * (sizeA + 1)\n    totalSum = sum(a)\n    sumArray[0] = totalSum\n    for i in range(1, sizeA + 1):\n        sumArray[i] = sumArray[i - 1] - a[i - 1]\n    summ = 0\n    productArray1 = sumArray[:-1]\n    productArray = []\n    for k in range(k1 + 1):\n        if k == 0:\n            summ += 1\n        elif k == 1:\n            summ += totalSum\n        elif k == 2:\n            xx = len(productArray1)\n            for i in range(1, xx):\n                productArray.append(productArray1[i] * a[i - 1])\n            productArray1 = productArray[:]\n            summ = (summ + sum(productArray)) % mod\n        else:\n            xx = len(productArray1)\n            productArray.clear()\n            temp = sum(productArray1[1:])\n            for i in range(1, xx):\n                productArray.append(temp * a[i - 1])\n                temp -= productArray1[i]\n            productArray1 = productArray[:]\n            summ = (summ + sum(productArray)) % mod\n    return summ\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n(n, k) = map(int, str(input()).split(' '))\nl = list(map(int, str(input()).split(' ')))\ntemp = collections.Counter(l)\nres = 0\ns = set(l)\nlis = list(s)\nlens = len(s)\nif lens == n:\n    for j in range(k + 1):\n        res = (res + ncr(n, j, mod)) % mod\n    print(res)\nelif lens <= k:\n    t1 = list(temp.values())\n    pro = 1\n    for ele in t1:\n        pro = pro * (ele + 1) % mod\n    print(pro)\nelse:\n    a = list(temp.values())\n    s = 0\n    s = finalans(a, k)\n    print(s)", "def s(K):\n    dp = [[0 for i in range(8010)] for j in range(8010)]\n    for i in range(len(v)):\n        dp[i][0] = 1\n    for i in range(1, len(v) + 1):\n        for j in range(len(v) + 1):\n            dp[i][j] = dp[i - 1][j] % M + v[i - 1] * dp[i - 1][j - 1] % M\n            dp[i][j] %= M\n    ans = 0\n    for k in range(K + 1):\n        ans += dp[len(v)][k]\n        ans %= M\n    return ans\n\ndef precalc():\n    facts = [1]\n    for i in range(1, 8008):\n        facts.append(facts[-1] * i)\n    return facts\nfacts = precalc()\nM = 1000000007\n(n, K) = map(int, input().split())\na = list(map(int, input().split()))\nA = [0 for i in range(8008)]\nfor i in a:\n    A[i] += 1\nans = 1\nb = list(set(a))\nm = len(b)\nnf = facts[m]\nans = 1\nif K == n:\n    for i in b:\n        ans *= A[i] + 1\n        ans %= M\n    print(ans % M)\n    exit(0)\nif n == m:\n    for k in range(1, K + 1):\n        ans += nf // (facts[k] * facts[n - k])\n        ans = ans % M\n    print(ans % M)\nelse:\n    v = []\n    for i in A:\n        if i != 0:\n            v.append(i % M)\n    print(s(K) % M)", "(n, k) = map(int, input().split())\na = [int(n) for n in input().split()]\nd = dict()\nfor i in range(n):\n    if a[i] in d:\n        d[a[i]] += 1\n    else:\n        d[a[i]] = 1\nb = list(d.values())\nb.sort()\npost = []\nsu = 0\nfor i in range(len(b)):\n    su += b[len(b) - 1 - i]\n    post += [su]\ntemp = len(b)\nif temp < k:\n    k = temp\nsu = 0\nt = len(post)\nmod = 10 ** 9 + 7\nfor j in range(1, k):\n    ct = 0\n    for i in range(temp - j):\n        ct += post[i] * b[temp - j - i - 1]\n        su += post[i] * b[temp - j - i - 1]\n        post[i] = ct\nsu += n + 1\nprint(su % mod)", "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nnums = {}\nfor i in range(n):\n    if arr[i] in nums:\n        nums[arr[i]] += 1\n    else:\n        nums[arr[i]] = 1\nnewArr = [0] * len(nums)\ni = 0\nres = 1\nfor z in nums:\n    newArr[i] = nums[z]\n    i += 1\ntemp = list(newArr)\nfor i in range(len(newArr)):\n    res += newArr[i]\ncnt = len(newArr)\nsums = res - 1\nif cnt < k:\n    k = cnt\nfor K in range(1, k):\n    nsum = 0\n    temp[cnt - K] = 0\n    for i in range(cnt - K):\n        t = sums - temp[i]\n        sums = t\n        temp[i] = newArr[i] * t\n        res += temp[i]\n        nsum += temp[i]\n    sums = nsum\nprint(res % 1000000007)", "import sys\ninput = sys.stdin.readline\nM = 1000000007\nnk = input().strip().split(' ')\nnums = input().strip().split(' ')\nn = int(nk[0])\nk = int(nk[1])\nnum_dict = {}\nuniq_nums = []\nfor i in range(n):\n    v = int(nums[i])\n    if v not in num_dict:\n        num_dict[v] = 1\n        uniq_nums.append(v)\n    else:\n        num_dict[v] += 1\nnu = len(uniq_nums)\ngo = min(nu, k)\nxx = [[0 for j in range(nu)] for j in range(go)]\nfor i in range(nu - 1, -1, -1):\n    if i == nu - 1:\n        xx[0][i] = num_dict[uniq_nums[i]]\n    else:\n        xx[0][i] = (xx[0][i + 1] + num_dict[uniq_nums[i]]) % M\ncount = 1 + xx[0][0]\nfor i in range(1, go):\n    for j in range(nu - i - 1, -1, -1):\n        xx[i][j] = (num_dict[uniq_nums[j]] * xx[i - 1][j + 1] + xx[i][j + 1]) % M\n        if j == 0:\n            count = (count + xx[i][j]) % M\nprint(count)", "def postfix(arr1, k):\n    for i in range(k - 1, 0, -1):\n        arr1[i - 1] = arr1[i - 1] + arr1[i]\n\ndef modify(arr1, k, a):\n    for i in range(1, k):\n        arr1[i - 1] = a[i - 1] * arr1[i]\n\ndef allcombination(arr1, k):\n    s = 0\n    a = arr1[:]\n    for i in range(1, k):\n        postfix(arr1, len(arr1) - i + 1)\n        s1 = 0\n        for j in range(1, len(arr1) - i + 1):\n            s1 += a[j - 1] * arr1[j]\n        s += s1\n        modify(arr1, len(arr1), a)\n    return s\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nd = {}\nfor i in arr:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\ns = 1 + n\narr1 = list(d.values())\narr1.sort(reverse=False)\nif k > len(arr1):\n    k = len(arr1)\ns += allcombination(arr1, k)\nprint(s % 1000000007)", "def nkmethod(d):\n    modval = 10 ** 9 + 7\n    val = 1\n    for i in d:\n        val *= d[i] + 1\n    val = val % modval\n    return val\n\ndef nlkmethod(n, k, l, d):\n    modval = 10 ** 9 + 7\n    if k == 0:\n        return 1\n    elif k == 1:\n        return n\n    else:\n        val = 1 + n\n        lv = [d[i] for i in d]\n        lv = sorted(lv)\n        lvlen = len(d)\n        dp2d = [j for j in lv]\n        sumdp2d = []\n        vv = 0\n        for i in dp2d[:0:-1]:\n            vv += i\n            sumdp2d = [vv] + sumdp2d\n        for i in range(2, k + 1):\n            if lvlen - i + 1 == 0:\n                break\n            dp2d = []\n            for j in range(lvlen - i + 1):\n                tempv = lv[j] * sumdp2d[j]\n                dp2d.append(tempv)\n                val += tempv\n            sumdp2d = []\n            vv = 0\n            for j in dp2d[:0:-1]:\n                vv += j\n                sumdp2d = [vv] + sumdp2d\n        val = val % modval\n        return val\n(n, k) = [int(i) for i in input().split()]\nl = [int(i) for i in input().split()]\nd = {}\nfor i in l:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\nif n == k:\n    print(nkmethod(d))\nelse:\n    print(nlkmethod(n, k, l, d))", "def postfix(arr1, k):\n    for i in range(k - 1, 0, -1):\n        arr1[i - 1] = arr1[i - 1] + arr1[i]\n\ndef modify(arr1, k, a):\n    for i in range(1, k):\n        arr1[i - 1] = a[i - 1] * arr1[i]\n\ndef allcombination(arr1, k):\n    s = 0\n    a = arr1[:]\n    for i in range(1, k):\n        postfix(arr1, len(arr1) - i + 1)\n        s1 = 0\n        for j in range(1, len(arr1) - i + 1):\n            s1 += a[j - 1] * arr1[j]\n        s += s1\n        modify(arr1, len(arr1), a)\n    return s\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nd = {}\nfor i in arr:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\ns = 1 + n\narr1 = list(d.values())\narr1.sort(reverse=False)\nif k > len(arr1):\n    k = len(arr1)\ns += allcombination(arr1, k)\nprint(s % 1000000007)"]