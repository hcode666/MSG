["(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nw1 = float('inf')\nw2 = float('inf')\nfor i in range(0, k + 1):\n    for j in range(n - 1, n - 2 - k + i, -1):\n        l = i\n        r = j\n        d = int((a[r] - a[l]) / (r - l))\n        s = a[l] - d * l\n        c = 0\n        for z in range(n):\n            if a[z] != s + d * z:\n                c += 1\n        if c <= k:\n            if s < w1 or (s == w1 and d < w2):\n                w1 = int(s)\n                w2 = int(d)\nfor x in range(n):\n    a[x] = str(w1 + x * w2)\nprint(' '.join(a))", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nw1 = float('inf')\nw2 = float('inf')\nfor i in range(0, k + 1):\n    for j in range(n - 1, n - 2 - k + i, -1):\n        l = i\n        r = j\n        d = int((a[r] - a[l]) / (r - l))\n        s = a[l] - d * l\n        c = 0\n        for z in range(n):\n            if a[z] != s + d * z:\n                c += 1\n        if c <= k:\n            if s < w1 or (s == w1 and d < w2):\n                w1 = int(s)\n                w2 = int(d)\nfor x in range(n):\n    a[x] = str(w1 + x * w2)\nprint(' '.join(a))", "def main():\n    (n, k) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    w_a = float('inf')\n    w_d = float('inf')\n    for i in range(0, k + 1):\n        for j in range(n - 1, n - 2 - k + i, -1):\n            L = i\n            R = j\n            D = int((a[R] - a[L]) / (R - L))\n            a_0 = a[L] - D * L\n            chg = 0\n            for l in range(0, n):\n                if a[l] != a_0 + D * l:\n                    chg += 1\n            if chg <= k:\n                if a_0 < w_a or (a_0 == w_a and D < w_d):\n                    w_a = int(a_0)\n                    w_d = int(D)\n    for i in range(n):\n        a[i] = str(w_a + i * w_d)\n    print(' '.join(a))\nmain()", "(n, k) = map(int, input().split())\nl = [int(i) for i in input().split()]\ncds = [0] * n\nfor i in range(1, n):\n    cds[i] = l[i] - l[i - 1]\nfrom collections import Counter\nc = Counter(cds)\nmaxi = 0\nmaxic = 0\nfor i in c:\n    if c[i] > maxic:\n        maxic = c[i]\n        maxi = i\n    elif c[i] == maxic:\n        if i > maxi:\n            maxi = i\nreq = 0\nfor i in range(1, n):\n    if l[i] - l[i - 1] != maxi:\n        curr = maxi - (l[i] - l[i - 1])\n        req += curr\nst = l[0] - req\nl = [0] * n\nl[0] = st\nfor i in range(1, n):\n    l[i] = l[i - 1] + maxi\nprint(*l)", "import sys\nimport math\nfrom time import time\nfrom itertools import permutations, combinations\nimport collections\nimport functools\nfrom fractions import gcd, Fraction\nimport string\nimport operator\nimport bisect\n\nclass timed(object):\n\n    def __init__(self, func):\n        self.func = func\n\n    def __call__(self, *args):\n        t1 = time()\n        ret = self.func(*args)\n        dif_time = time() - t1\n        print('%s: returned %s in %f seconds' % (self.func.__name__, ret, dif_time))\n        return ret\n\ndef comp(f1, f2, *args):\n    t1 = time()\n    r1 = f1(*args) if f1 is not None else None\n    t2 = time()\n    r2 = f2(*args) if f2 is not None else None\n    t3 = time()\n    res = '%5s: %s in %f\\n%5s: %s in %f' % (f1.__name__ if f1 is not None else None, r1, t2 - t1, f2.__name__ if f2 is not None else None, r2, t3 - t2)\n    if r1 != r2:\n        dr = '!! DIFFERENT RESULTS !!'\n        res = dr + '\\n' + res + '\\n' + dr\n    print(res)\n\ndef alg(L, K):\n    length = len(L)\n    cur_best = None\n    best_res = []\n    for fixed1 in range(K + 2):\n        for fixed2 in range(fixed1 + 1, K + 2):\n            dnum = L[fixed2] - L[fixed1]\n            dden = fixed2 - fixed1\n            if dnum % dden != 0:\n                continue\n            d = dnum // dden\n            a0 = L[fixed1] - d * fixed1\n            if cur_best is None or cur_best[0] > a0 or (cur_best[0] == a0 and cur_best[1] > d):\n                changes = 0\n                i_list = 0\n                a = a0\n                valid = True\n                cur_res = []\n                while True:\n                    if a != L[i_list]:\n                        changes += 1\n                        if changes > K:\n                            valid = False\n                            break\n                    cur_res.append(a)\n                    a += d\n                    i_list += 1\n                    if i_list == length:\n                        break\n                if valid:\n                    cur_best = (a0, d)\n                    best_res = cur_res\n    if len(best_res) == 0:\n        print('invalid case')\n    return ' '.join((str(a) for a in best_res))\n\ndef main():\n    data = sys.stdin\n    (n, k) = map(int, data.readline().split())\n    L = list(map(int, data.readline().split()))\n    res = alg(L, k)\n    print(res)\nmain()", "from collections import defaultdict\n\ndef eval(A, dictR, r):\n    l = dictR[r]\n    nbToChange = 0\n    newVal = A[l[-1]]\n    for iR in range(l[-1], len(A) - 1):\n        newVal += r\n        if newVal != A[iR + 1]:\n            nbToChange += 1\n    lastVal = newVal\n    newVal = A[l[0]]\n    for iR in range(l[0], 0, -1):\n        newVal -= r\n        if newVal != A[iR - 1]:\n            nbToChange += 1\n    return (newVal, r, lastVal, nbToChange)\n\ndef solve(A, K):\n    dictR = defaultdict(list)\n    for i in range(1, len(A)):\n        r = A[i] - A[i - 1]\n        dictR[r].append(i)\n    maxEff = max((len(v) for v in dictR.values()))\n    rMaxEff = [key for key in dictR if len(dictR[key]) == maxEff]\n    results = []\n    for r in dictR:\n        results.append(eval(A, dictR, r))\n    possibles = [t for t in results if t[3] <= K]\n    possibles.sort(key=lambda x: (x[0], x[1]), reverse=False)\n    (a0, r, an, _) = possibles[0]\n    return ' '.join(list(map(str, range(a0, an + 1, r))))\n(N, K) = map(int, input().split())\nA = list(map(int, input().split()))\nprint(solve(A, K))"]