["(MOD, p) = (10 ** 9 + 7, 10 ** 6 + 5)\nfact = [0] * p\nfact[0] = 1\nfor i in range(1, p):\n    fact[i] = fact[i - 1] * i % MOD\n\ndef MI(a, MOD):\n    return pow(a, MOD - 2, MOD)\n\ndef nck(n, k):\n    if n == k or k == 0:\n        return 1\n    if n < k:\n        return 0\n    return fact[n] * MI(fact[k], MOD) % MOD * MI(fact[n - k], MOD) % MOD % MOD\nMOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    (l, f) = ([int(i) for i in input().split()], 0)\n    if 0 in l:\n        f = 1\n    (n, ans) = (n - l.count(0), 0)\n    for x in range(0, min(n + 1, k + 1)):\n        if (k - x) % 2 == 0 or f:\n            ans = (ans + nck(n, x)) % MOD\n    print(ans)", "(MOD, p) = (10 ** 9 + 7, 10 ** 6 + 5)\nfact = [0] * p\nfact[0] = 1\nfor i in range(1, p):\n    fact[i] = fact[i - 1] * i % MOD\n\ndef MI(a, MOD):\n    return pow(a, MOD - 2, MOD)\n\ndef nck(n, k):\n    if n == k or k == 0:\n        return 1\n    if n < k:\n        return 0\n    return fact[n] * MI(fact[k], MOD) % MOD * MI(fact[n - k], MOD) % MOD % MOD\nMOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    (l, f) = ([int(i) for i in input().split()], 0)\n    if 0 in l:\n        f = 1\n    (n, ans) = (n - l.count(0), 0)\n    for x in range(0, min(n + 1, k + 1)):\n        if (k - x) % 2 == 0 or f:\n            ans = (ans + nck(n, x)) % MOD\n    print(ans)", "(MOD, p) = (10 ** 9 + 7, 10 ** 6 + 5)\nfact = [0] * p\nfact[0] = 1\nfor i in range(1, p):\n    fact[i] = fact[i - 1] * i % MOD\n\ndef MI(a, MOD):\n    return pow(a, MOD - 2, MOD)\n\ndef nck(n, k):\n    if n == k or k == 0:\n        return 1\n    if n < k:\n        return 0\n    return fact[n] * MI(fact[k], MOD) % MOD * MI(fact[n - k], MOD) % MOD % MOD\nMOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    (l, f) = ([int(i) for i in input().split()], 0)\n    if 0 in l:\n        f = 1\n    (n, ans) = (n - l.count(0), 0)\n    for x in range(0, min(n + 1, k + 1)):\n        if (k - x) % 2 == 0 or f:\n            ans = (ans + nck(n, x)) % MOD\n    print(ans)", "MOD = 10 ** 9 + 7\np = 10 ** 6 + 5\nfact = [0] * p\nfact[0] = 1\nfor i in range(1, p):\n    fact[i] = fact[i - 1] * i % MOD\n\ndef MI(a, MOD):\n    return pow(a, MOD - 2, MOD)\n\ndef nck(n, k):\n    if n == k or k == 0:\n        return 1\n    if n < k:\n        return 0\n    return fact[n] * MI(fact[k], MOD) % MOD * MI(fact[n - k], MOD) % MOD % MOD\nMOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = [int(i) for i in input().split()]\n    f = 0\n    if 0 in l:\n        f = 1\n    ans = 0\n    n = n - l.count(0)\n    for x in range(0, min(n + 1, k + 1)):\n        if (k - x) % 2 == 0 or f:\n            ans = (ans + nck(n, x)) % MOD\n    print(ans)", "def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    return (x % m + m) % m\nl = []\nfor i in range(100001):\n    t = modinv(i + 1, 1000000007)\n    l.append(t)\nt = int(input())\nm = 1\nwhile m <= t:\n    (n, k) = map(int, input().split(' '))\n    a = list(map(int, input().split(' ')))\n    flag = 0\n    zero = 0\n    for (i, val) in enumerate(a):\n        if val == 0:\n            flag = 1\n            zero += 1\n        else:\n            continue\n    if flag == 1:\n        if zero == len(a):\n            print(1)\n        else:\n            n -= zero\n            if k >= n:\n                p = 1\n                for i in range(n):\n                    p = p % 1000000007 * (2 % 1000000007) % 1000000007\n                print(p)\n            else:\n                c = 1\n                val = 1\n                for i in range(k):\n                    c = c % 1000000007 * ((n - (i + 1) + 1) % 1000000007) % 1000000007\n                    c = c * l[i] % 1000000007\n                    val += c\n                    val %= 1000000007\n                print(val % 1000000007)\n    elif k >= n - 1:\n        p = 1\n        for i in range(n - 1):\n            p = p % 1000000007 * (2 % 1000000007) % 1000000007\n        print(p)\n    else:\n        c = 1\n        val = 1\n        n -= 1\n        for i in range(k):\n            c = c % 1000000007 * ((n - (i + 1) + 1) % 1000000007) % 1000000007\n            c = c * l[i] % 1000000007\n            val += c\n            val %= 1000000007\n        print(val % 1000000007)\n    m += 1", "const = 1000000007\nking_dict = {}\nT = int(input())\nfor _ in range(T):\n    (N, K) = [int(x) for x in input().split()]\n    mas = [int(x) for x in input().split()]\n    zero_count = 0\n    for x in mas:\n        zero_count += x == 0\n    N -= zero_count\n    is_zero = zero_count != 0\n    if N in king_dict:\n        dct = king_dict[N]\n    else:\n        dct = {}\n    if is_zero and K >= N:\n        print(pow(2, N, const))\n    else:\n        if K % 2 == 0:\n            ans = soch = 1\n            i = 0\n        else:\n            ans = soch = N\n            i = 1\n            ans += is_zero\n        dct[i] = soch\n        dct[N - i] = soch\n        while i < K and i < N:\n            if i + 1 not in dct:\n                soch *= N - i\n                soch %= const\n                soch *= pow(i + 1, const - 2, const)\n                soch %= const\n                dct[i + 1] = soch\n                dct[N - i - 1] = soch\n            else:\n                soch = dct[i + 1]\n            if is_zero:\n                ans += soch\n                ans %= const\n            if i + 2 not in dct:\n                soch *= N - i - 1\n                soch %= const\n                soch *= pow(i + 2, const - 2, const)\n                soch %= const\n                dct[i + 2] = soch\n                dct[N - i - 2] = soch\n            else:\n                soch = dct[i + 2]\n            ans += soch\n            ans %= const\n            i += 2\n        print(ans)\n        king_dict[N] = dct", "t = int(input())\nprecalcodd = True\nprecalceven = True\npresumodd = 0\npresumeven = 0\npreprododd = 1\npreprodeven = 1\n\ndef comb(n, kk):\n    global precalcodd, precalceven, presumodd, presumeven, preprododd, preprodeven\n    sum = 0\n    k = 1\n    prod = 1\n    flag = n % 2 == 0\n    flag2 = kk % 2 == 0\n    flag3 = n // 2 % 2 == 0\n    nby2 = n // 2\n    if kk >= 80000 and n == 100000:\n        if precalcodd == True and kk % 2 != 0:\n            precalcodd = False\n            sum = 2 ** (n - 1)\n            prod = n\n            n -= 1\n            k += 1\n            sum -= prod\n            while k < 15000:\n                prod = prod * n * (n - 1) // (k * (k + 1))\n                sum -= prod\n                n -= 2\n                k += 2\n            presumodd = sum % (10 ** 9 + 7)\n            preprododd = prod\n        if precalceven == True and kk % 2 == 0:\n            precalceven = False\n            sum = 2 ** (n - 1)\n            sum -= prod\n            while k < 15000:\n                prod = prod * n * (n - 1) // (k * (k + 1))\n                sum -= prod\n                n -= 2\n                k += 2\n            presumeven = sum % (10 ** 9 + 7)\n            preprodeven = prod\n        if kk % 2 != 0:\n            sum = presumodd\n            k = 15000\n            n = 85001\n            prod = preprododd\n        else:\n            sum = presumeven\n            k = 15001\n            n = 85000\n            prod = preprodeven\n        kkk = 100000 - kk - 2\n        while k <= kkk:\n            prod = prod * n * (n - 1) // (k * (k + 1))\n            sum -= prod\n            n -= 2\n            k += 2\n    elif kk > n // 2 and flag == True:\n        if flag2 == False:\n            prod = n\n            n -= 1\n            k += 1\n        sum += prod\n        while k + kk < nby2 * 2 - 1:\n            prod = prod * n * (n - 1) // (k * (k + 1))\n            sum += prod\n            n -= 2\n            k += 2\n        while k + 2 < nby2:\n            prod = prod * n * (n - 1) // (k * (k + 1))\n            sum += prod * 2\n            n -= 2\n            k += 2\n        prod = prod * n * (n - 1) // (k * (k + 1))\n        if flag2 ^ flag3:\n            sum += prod * 2\n        else:\n            sum += prod\n    else:\n        if kk % 2 != 0:\n            prod = n // k\n            n -= 1\n            k += 1\n        sum += prod\n        while k <= kk:\n            prod = prod * n * (n - 1) // (k * (k + 1))\n            sum += prod\n            n -= 2\n            k += 2\n    return sum\n\ndef comb2(n, kk):\n    sum = 1\n    k = 1\n    prod = 1\n    while k <= kk:\n        prod = prod * n // k\n        sum += prod\n        n -= 1\n        k += 1\n    return sum\nwhile t > 0:\n    a = input().split(' ')\n    b = list(map(int, input().split(' ')))\n    n = int(a[0])\n    k = int(a[1])\n    if 0 in b:\n        b = list(filter(0 .__ne__, b))\n        n = len(b)\n        if k >= n:\n            print(2 ** n % (10 ** 9 + 7))\n        else:\n            print(int(comb2(n, k)) % (10 ** 9 + 7))\n    elif k > n - 2:\n        print(2 ** (n - 1) % (10 ** 9 + 7))\n    else:\n        print(int(comb(n, k)) % (10 ** 9 + 7))\n    t -= 1", "M = 1000000007\ns = []\ns += [1, 1]\nf = 1\nfor i in range(2, 100001):\n    f = f * i % M\n    s += [f]\n\ndef computeit(n, k):\n    c = [1 for i in range(k + 1)]\n    res = 0\n    if k <= int((n - 1) / 2) or k < 50000:\n        res = c[0]\n        for i in range(k):\n            c[i + 1] = int(s[n - 1] * pow(s[n - i - 2] * s[i + 1] % M, M - 2, M)) % M\n            res = (res + c[i + 1]) % M\n    else:\n        k = n - k - 2\n        res = (pow(2, n - 1, M) - c[0]) % M\n        for i in range(k):\n            c[i + 1] = int(s[n - 1] * pow(s[n - i - 2] * s[i + 1] % M, M - 2, M)) % M\n            res = (res - c[i + 1]) % M\n    return res % M\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    o = x.count(0)\n    if o == 0:\n        if k >= n:\n            u = pow(2, n - 1, M)\n            print(u)\n        else:\n            print(computeit(n, k))\n    else:\n        n = n - o\n        if k >= n:\n            u = pow(2, n, M)\n            print(u)\n        else:\n            print(computeit(n + 1, k))", "def sumallbinomialCoeffuptok(n, k):\n    s = 0\n    while k >= 0:\n        s += int(fact[n] * pow(fact[k] * fact[n - k] % Mod, Mod - 2, Mod))\n        if s >= Mod:\n            s %= Mod\n        k -= 1\n    return s\n\ndef sumselectedbinomialCoeffuptok(n, k):\n    rem = k % 2\n    s = 0\n    while k >= 0:\n        if k % 2 == rem:\n            s += int(fact[n] * pow(fact[k] * fact[n - k] % Mod, Mod - 2, Mod))\n            if s >= Mod:\n                s %= Mod\n        k -= 2\n    return s\nMod = 10 ** 9 + 7\nfact = [1]\nfor i in range(1, 10 ** 5 + 1):\n    fact.append(fact[-1] * i % Mod)\nT = int(input())\nwhile T > 0:\n    T -= 1\n    (N, K) = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n    dec = 2\n    if 0 in A:\n        dec = 1\n        N -= A.count(0)\n    del A[:]\n    if K >= N:\n        print(pow(2, N - (dec - 1)) % Mod)\n    elif dec == 1:\n        print(sumallbinomialCoeffuptok(N, K))\n    else:\n        print(sumselectedbinomialCoeffuptok(N, K))", "from math import *\nprime = 10 ** 9 + 7\n\ndef gen():\n    a = [1, 1]\n    for i in range(2, 10 ** 5 + 5):\n        a.append(a[i - 1] * i % prime)\n    return a\nf = gen()\n\ndef gen1():\n    a = [1, 1]\n    for i in range(2, 10 ** 5 + 5):\n        a.append(a[i - 1] * mul_inv(i, prime) % prime)\n    return a\n\ndef mul_inv(a, b):\n    b0 = b\n    x0 = 0\n    x1 = 1\n    if b == 1:\n        return 1\n    while a > 1:\n        q = int(a / b)\n        t = b\n        b = a % b\n        a = t\n        t = x0\n        x0 = x1 - q * x0\n        x1 = t\n    if x1 < 0:\n        x1 += b0\n    return x1\nifact = gen1()\n\ndef c(n, k):\n    return f[n] * ifact[k] * ifact[n - k] % prime\nt = int(input())\nfor i in range(t):\n    count = 0\n    s = input().split()\n    n = int(s[0])\n    k = int(s[1])\n    a = [int(j) for j in input().strip().split()]\n    flag = False\n    for j in a:\n        if j == 0:\n            flag = True\n        else:\n            count += 1\n    if k > count and flag == False:\n        if (k - count) % 2 == 0:\n            k = count\n        else:\n            k = count - 1\n    if flag == True:\n        k = min(count, k)\n    ans = 0\n    while k >= 0:\n        ans += c(count, k)\n        if flag == True:\n            k -= 1\n        else:\n            k -= 2\n    ans = ans % (10 ** 9 + 7)\n    print(ans)", "def inv(a):\n    n = 1000000007\n    (t, newt) = (0, 1)\n    (r, newr) = (n, a)\n    while newr != 0:\n        q = r // newr\n        (t, newt) = (newt, t - q * newt)\n        (r, newr) = (newr, r - q * newr)\n    if t < 0:\n        t += n\n    return t\n\ndef PowMod(n):\n    (ret, a) = (1, 2)\n    while n > 0:\n        if n & 1:\n            ret = ret * a % 1000000007\n        a = a * a % 1000000007\n        n >>= 1\n    return ret\n\ndef binSum(n, k, z):\n    n1 = n - z\n    if k >= n1:\n        return PowMod(n1)\n    (n1Ci, ans) = (1, 1)\n    for i in range(1, k + 1):\n        n1Ci = n1Ci * (n1 - i + 1) * inv(i) % 1000000007\n        ans = ans + n1Ci\n    return ans % 1000000007\n\ndef binSum2(n, k):\n    if k >= n:\n        return PowMod(n - 1)\n    if k & 1 == 0:\n        (ans, nCi, start) = (1, 1, 2)\n    else:\n        (ans, nCi, start) = (n, n, 3)\n    for i in range(start, k + 1, 2):\n        nCi *= (n - (i - 1) + 1) * inv(i - 1)\n        nCi %= 1000000007\n        nCi *= (n - i + 1) * inv(i)\n        nCi %= 1000000007\n        ans += nCi\n    return ans % 1000000007\nt = int(input())\nfor _t in range(t):\n    (N, K) = map(int, input().split())\n    A = input()\n    z = A.count(' 0') + (1 if A[0] == '0' else 0)\n    if z > 0:\n        print(binSum(N, K, z))\n    else:\n        print(binSum2(N, K))", "NL = 100100\nMOD = 1000000007\nfact = [0] * NL\ninvfact = [0] * NL\n\ndef pre():\n    fact[0] = invfact[0] = 1\n    for i in range(1, NL):\n        fact[i] = fact[i - 1] * i % MOD\n        invfact[i] = pow(fact[i], MOD - 2, MOD)\n\ndef solve():\n    inp = input().split()\n    N = int(inp[0])\n    K = int(inp[1])\n    zc = 0\n    inp = input().split()\n    A = [0] * NL\n    for i in range(0, N):\n        A[i] = int(inp[i])\n        if A[i] == 0:\n            zc += 1\n    if N - zc <= K:\n        if zc == 0:\n            print(pow(2, N - 1, MOD))\n        else:\n            print(pow(2, N - zc, MOD))\n    elif zc == 0:\n        ans = 0\n        for k in range(K, -1, -2):\n            ans += invfact[N - k] * invfact[k] % MOD\n        ans = ans * fact[N] % MOD\n        print(ans)\n    else:\n        ans = 0\n        for k in range(K, -1, -1):\n            ans += invfact[N - zc - k] * invfact[k] % MOD\n        ans = ans * fact[N - zc] % MOD\n        print(ans)\npre()\nT = int(input())\nfor t in range(0, T):\n    solve()", "f = []\nmod = 1000000007\nfor i in range(1, 100001):\n    f.append(pow(i, mod - 2, mod))\n\ndef containsZero(n, k):\n    if k is 1:\n        print(n + 1)\n    elif n - k is 1:\n        ans = pow(2, n, mod)\n        print((ans - 1).__mod__(mod))\n    elif n - k <= 0:\n        ans = pow(2, n, mod)\n        print(ans.__mod__(mod))\n    elif n - k >= 2:\n        ans = 0\n        current = 1\n        for i in range(1, k + 1):\n            current = current * (n - i + 1) * f[i - 1] % mod\n            ans = (ans + current).__mod__(mod)\n        print((ans + 1).__mod__(mod))\n\ndef poweroftwo(n):\n    ans = pow(2, n, mod)\n    return ans\nt = int(input())\nfor q in range(t):\n    s = input().strip().split(' ')\n    (n, k) = (int(s[0]), int(s[1]))\n    (num, numb) = (n, n)\n    str = input().strip().split(' ')\n    for x in range(n):\n        if int(str[x]) is 0:\n            numb -= 1\n    if numb is not n:\n        if numb is 0:\n            print('1')\n            continue\n        elif numb is 1:\n            print('2')\n            continue\n        else:\n            containsZero(numb, k)\n            continue\n    if num is 1:\n        print('1')\n        continue\n    elif k is 1:\n        print(num)\n        continue\n    elif num - k <= 1:\n        ans = poweroftwo(num - 1)\n        print(ans % mod)\n    elif num - k is 2:\n        ans = poweroftwo(num - 1) - 1\n        print(ans)\n    else:\n        ans = 0\n        curr = 1\n        if k % 2 is not 0:\n            for i in range(1, k + 1, 2):\n                if i is 1:\n                    curr = num\n                else:\n                    curr = curr * (num - i + 1) * (num - i + 2) * f[i - 2] * f[i - 1] % mod\n                ans = (ans + curr) % mod\n            print(ans)\n        else:\n            ans = 0\n            curr = 1\n            for i in range(0, k + 1, 2):\n                if i is 0:\n                    curr = 1\n                else:\n                    curr = curr * (num - i + 1) * (num - i + 2) * f[i - 2] * f[i - 1] % mod\n                ans = (ans + curr) % mod\n            print(ans)", "import sys\nimport numpy as np\nmod = 10 ** 9 + 7\n\ndef gcd(p, q):\n    if q == 0:\n        return (p, 1, 0)\n    (d, b, a) = gcd(q, p % q)\n    return (d, a, b - p // q * a)\n\ndef inv(x):\n    return gcd(mod, x)[2] % mod\nmx = 10 ** 5 + 1\nfact = np.ones(mx, dtype=np.int64)\nifact = np.ones(mx, dtype=np.int64)\nfor i in range(2, mx):\n    fact[i] = fact[i - 1] * i % mod\n    ifact[i] = ifact[i - 1] * inv(i) % mod\n\ndef choose(a, b):\n    if b > a:\n        return 0\n    return fact[a] * ifact[a - b] % mod * ifact[b] % mod\n\ndef solve(n, m, k):\n    if m > 0:\n        return sum((choose(n - m, i) for i in range(k + 1))) % mod\n    return sum((choose(n, i) for i in range(k, -1, -2))) % mod\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    (n, k) = map(int, f.readline().split())\n    m = sum((1 for z in map(int, f.readline().split()) if z == 0))\n    print(solve(n, m, k))", "def gcd(a, b):\n    if a < b:\n        (q, w, e) = gcd(b, a)\n        return (q, e, w)\n    elif b == 0:\n        return (a, 1, 0)\n    else:\n        (x, y, z) = gcd(b, a % b)\n        return (x, z, y - z * (a // b))\n\ndef a(n, k, w):\n    if w == 0:\n        if k > n:\n            op = (k - n) // 2 + (k - n) % 2\n            k -= op * 2\n        i = k % 2\n        ans = 0\n        if i == 0:\n            c = 1\n        else:\n            c = n\n        ans += c\n        while i < k:\n            (k1, k2) = (gcd(i + 1, 1000000007)[1], gcd(i + 2, 1000000007)[1])\n            c *= (n - i) * (n - i - 1) * k1 * k2\n            c = c % 1000000007\n            i += 2\n            ans = (ans + c) % 1000000007\n        return ans\n    elif k >= n - w:\n        return 2 ** (n - w) % 1000000007\n    else:\n        n -= w\n        ans = 0\n        c = 1\n        ans += c\n        i = 1\n        while i <= k:\n            kkk = gcd(i, 1000000007)[1]\n            c *= (n - i + 1) * kkk\n            c = c % 1000000007\n            i += 1\n            ans = (ans + c) % 1000000007\n        return ans\nt = int(input())\nwhile t != 0:\n    t -= 1\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    w = l.count(0)\n    print(a(n, k, w))", "N = 10 ** 5 + 5\nM = 10 ** 9 + 7\nF = [0] * N\nIF = [0] * N\n\ndef init():\n    F[0] = IF[0] = 1\n    for i in range(1, N):\n        F[i] = F[i - 1] * i % M\n        IF[i] = pow(F[i], M - 2, M)\n\ndef C(n, r):\n    ans = F[n] * IF[r] * IF[n - r] % M\n    return ans\n\ndef solveZero(n, k):\n    ans = 0\n    if k >= n:\n        ans = pow(2, n, M)\n    else:\n        for i in range(k, -1, -1):\n            ans += C(n, i)\n    return ans % M\n\ndef solveNonZero(n, k):\n    if k > n:\n        if (k + n) % 2 == 0:\n            k = n\n        else:\n            k = n - 1\n    ans = 0\n    for i in range(k, -1, -2):\n        ans += C(n, i)\n    return ans % M\ninit()\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    zero = 0\n    for i in a:\n        if i == 0:\n            zero += 1\n    print(solveZero(n - zero, k) if zero else solveNonZero(n, k))", "M = 1000000007\nA = [pow(i, M - 2, M) for i in range(0, 100001)]\nt = int(input())\nwhile t > 0:\n    t -= 1\n    count = 0\n    (n, k) = map(int, input().strip().split())\n    L = list(map(int, input().strip().split()))\n    for l in L:\n        if l == 0:\n            count += 1\n    if count == 0:\n        if k % 2 == 0:\n            ans = 1\n            i = 2\n            cur = 1\n        else:\n            ans = n\n            i = 3\n            cur = n\n        while i <= n and i <= k:\n            cur = cur * (n - i + 1) * (n - i + 2) * (A[i] * A[i - 1]) % M % M\n            ans = (ans + cur) % M\n            i += 2\n    else:\n        ans = 1\n        cur = 1\n        i = 1\n        n -= count\n        while i <= n and i <= k:\n            cur = cur * (n - i + 1) * A[i] % M\n            ans = (ans + cur) % M\n            i += 1\n    print(ans)", "mod = 1000000007\nP = [pow(i, mod - 2, mod) for i in range(100001)]\nT = int(input())\nfor t in range(T):\n    (N, K) = map(int, input().strip().split())\n    A = list(map(int, input().strip().split()))\n    zero = A.count(0)\n    if zero == 0:\n        jump = 2\n        start = 2\n        ans = 1\n        if K & 1:\n            start = 3\n            ans = N\n        cur = ans\n        for i in range(start, min(N, K) + 1, jump):\n            nxt = cur * (N - i + 1) * (N - i + 2) * P[i] * P[i - 1] % mod\n            ans = (ans + nxt) % mod\n            cur = nxt\n    else:\n        jump = 1\n        N -= zero\n        start = 1\n        ans = 1\n        cur = 1\n        for i in range(start, min(N, K) + 1, jump):\n            nxt = cur * (N - i + 1) * P[i] % mod\n            ans = (ans + nxt) % mod\n            cur = nxt\n    ans %= mod\n    print(ans)", "mod = 10 ** 9 + 7\nlim = 10 ** 5\npowm = [pow(i, mod - 2, mod) for i in range(lim + 1)]\nt = int(input())\nip = lambda : [int(i) for i in input().split()]\nfor _ in range(t):\n    (n, k) = ip()\n    L = ip()\n    zcount = L.count(0)\n    n = n - zcount\n    C = [1 for _ in range(n + 1)]\n    for i in range(n):\n        C[i + 1] = C[i] * (n - i) % mod * powm[i + 1] % mod\n    if zcount > 0:\n        ans = sum((C[i] for i in range(min(n, k) + 1))) % mod\n    else:\n        ans = sum((C[i] for i in range(k % 2, min(n, k) + 1, 2))) % mod\n    print(ans)", "f = [1]\nm = 1000000007\ninv = [0, 1]\nfor i in range(2, 100005):\n    inv.append(m - m // i * inv[m % i] % m)\nf_inv = [1]\nfor i in range(1, 100005):\n    f.append(f[i - 1] * i % m)\nfor i in range(1, 100005):\n    f_inv.append(f_inv[i - 1] * inv[i] % m)\n\ndef comb(a, b):\n    return f[a] * f_inv[b] % m * f_inv[a - b] % m\nfor t in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    n1 = n\n    for i in a:\n        if i == 0:\n            n1 -= 1\n    if n == n1:\n        if k % 2 == 0:\n            j = 0\n            sum = 1\n        else:\n            j = 1\n            sum = n\n        for i in range(j + 2, k + 1, 2):\n            if i > n:\n                break\n            sum = (sum + comb(n, i)) % m\n    else:\n        sum = com = 1\n        for i in range(1, k + 1):\n            if i > n1:\n                break\n            sum = (sum + comb(n1, i)) % m\n    print(sum % m)", "mod = 1000000007\nP = [pow(i, mod - 2, mod) for i in range(100001)]\nT = int(input())\nfor t in range(T):\n    (N, K) = map(int, input().strip().split())\n    A = list(map(int, input().strip().split()))\n    zero = A.count(0)\n    if zero == 0:\n        jump = 2\n        start = 2\n        ans = 1\n        if K & 1:\n            start = 3\n            ans = N\n        cur = ans\n        for i in range(start, min(N, K) + 1, jump):\n            nxt = cur * (N - i + 1) * (N - i + 2) * P[i] * P[i - 1] % mod\n            ans = (ans + nxt) % mod\n            cur = nxt\n    else:\n        jump = 1\n        N -= zero\n        if N != 0:\n            start = 2\n            ans = N + 1\n            cur = N\n        else:\n            start = 1\n            ans = 1\n            cur = 1\n        for i in range(start, min(N, K) + 1, jump):\n            nxt = cur * (N - i + 1) * P[i] % mod\n            ans = (ans + nxt) % mod\n            cur = nxt\n    ans %= mod\n    print(ans)", "mod = 10 ** 9 + 7\nMOD = mod\nfuck_torial = [1]\ni = 1\nmul = 1\ninv = [1, 1]\nfact_inv = [1]\nfor i in range(2, 10 ** 5 + 1):\n    inv.append(MOD - MOD // i * inv[MOD % i] % MOD)\nfor i in range(1, 10 ** 5 + 1):\n    fuck_torial.append(fuck_torial[i - 1] * i % MOD)\nfor i in range(1, 10 ** 5 + 1):\n    fact_inv.append(fact_inv[i - 1] * inv[i] % MOD)\n\ndef ncr(a, b):\n    return fuck_torial[a] * fact_inv[b] % MOD * fact_inv[a - b] % MOD\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    arr = [int(i) for i in input().split()]\n    cnt_zero = 0\n    for i in arr:\n        if i == 0:\n            cnt_zero += 1\n    if cnt_zero > 0:\n        arr = [i for i in range(0, min(n - cnt_zero, k) + 1)]\n        n -= cnt_zero\n    elif k % 2 != 0:\n        arr = [i for i in range(1, min(n, k) + 1, 2)]\n    else:\n        arr = [i for i in range(0, min(n, k) + 1, 2)]\n    sumi = 0\n    for i in arr:\n        sumi += ncr(n, i)\n    print(sumi % mod)"]