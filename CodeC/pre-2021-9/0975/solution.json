["from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    dp = [[] for i in range(n + 1)]\n    dp[0].append(0)\n    for i in range(1, n + 1):\n        dp[i].extend(dp[i - 1])\n        for j in range(i, 0, -1):\n            x = 0\n            for l in range(j, i + 1):\n                for r in range(l, i + 1):\n                    x += value[l][r]\n            if j == 1:\n                dp[i].append(x)\n            else:\n                for val in dp[j - 2]:\n                    dp[i].append(val + x)\n        dp[i].sort(reverse=True)\n        while len(dp[i]) > k:\n            dp[i].pop()\n    return dp[n]\nfor T in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    g = list(map(int, input().split()))\n    value = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    for i in range(m):\n        (x, y, val) = map(int, input().split())\n        value[x][y] = val\n    for i in range(n):\n        value[i + 1][i + 1] = g[i]\n    print(*answer())", "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    dp = [[] for i in range(n + 1)]\n    dp[0].append(0)\n    for i in range(1, n + 1):\n        dp[i].extend(dp[i - 1])\n        for j in range(i, 0, -1):\n            x = 0\n            for l in range(j, i + 1):\n                for r in range(l, i + 1):\n                    x += value[l][r]\n            if j == 1:\n                dp[i].append(x)\n            else:\n                for val in dp[j - 2]:\n                    dp[i].append(val + x)\n        dp[i].sort(reverse=True)\n        while len(dp[i]) > k:\n            dp[i].pop()\n    return dp[n]\nfor T in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    g = list(map(int, input().split()))\n    value = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    for i in range(m):\n        (x, y, val) = map(int, input().split())\n        value[x][y] = val\n    for i in range(n):\n        value[i + 1][i + 1] = g[i]\n    print(*answer())", "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    dp = [[] for i in range(n + 1)]\n    dp[0].append(0)\n    for i in range(1, n + 1):\n        dp[i].extend(dp[i - 1])\n        for j in range(i, 0, -1):\n            x = 0\n            for l in range(j, i + 1):\n                for r in range(l, i + 1):\n                    x += value[l][r]\n            if j == 1:\n                dp[i].append(x)\n            else:\n                for val in dp[j - 2]:\n                    dp[i].append(val + x)\n        dp[i].sort(reverse=True)\n        while len(dp[i]) > k:\n            dp[i].pop()\n    return dp[n]\nfor T in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    g = list(map(int, input().split()))\n    value = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    for i in range(m):\n        (x, y, val) = map(int, input().split())\n        value[x][y] = val\n    for i in range(n):\n        value[i + 1][i + 1] = g[i]\n    print(*answer())", "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n    dp = [[] for i in range(n + 1)]\n    dp[0].append(0)\n    for i in range(1, n + 1):\n        dp[i].extend(dp[i - 1])\n        for j in range(i, 0, -1):\n            x = 0\n            for l in range(j, i + 1):\n                for r in range(l, i + 1):\n                    x += value[l][r]\n            if j == 1:\n                dp[i].append(x)\n            else:\n                for val in dp[j - 2]:\n                    dp[i].append(val + x)\n        dp[i].sort(reverse=True)\n        while len(dp[i]) > k:\n            dp[i].pop()\n    return dp[n]\nfor T in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    g = list(map(int, input().split()))\n    value = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    for i in range(m):\n        (x, y, val) = map(int, input().split())\n        value[x][y] = val\n    for i in range(n):\n        value[i + 1][i + 1] = g[i]\n    print(*answer())", "for T in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    g = list(map(int, input().split()))\n    value = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    for i in range(m):\n        (x, y, val) = map(int, input().split())\n        value[x][y] = val\n    for i in range(n):\n        value[i + 1][i + 1] = g[i]\n    dp = [[] for i in range(n + 1)]\n    dp[0].append(0)\n    for i in range(1, n + 1):\n        dp[i].extend(dp[i - 1])\n        for j in range(i, 0, -1):\n            x = 0\n            for l in range(j, i + 1):\n                for r in range(l, i + 1):\n                    x += value[l][r]\n            if j == 1:\n                dp[i].append(x)\n            else:\n                for val in dp[j - 2]:\n                    dp[i].append(val + x)\n        dp[i].sort(reverse=True)\n        while len(dp[i]) > k:\n            dp[i].pop()\n    print(*dp[n])", "for test in range(int(input())):\n    (n, m, k1) = map(int, input().split())\n    g = [0]\n    gt = list(map(int, input().split()))\n    g.extend(gt)\n    pos = [[] for x in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        pos[u].append([i, d])\n        pos[v].append([i, d])\n    dp = [[] for x in range(n + 1)]\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        temp = []\n        temp.extend(dp[i - 1])\n        cur = 0\n        mask = 0\n        open1 = {}\n        for j in range(i, 0, -1):\n            cur += g[j]\n            mask = mask ^ 1 << j\n            for k in pos[j]:\n                if k[0] in open1:\n                    cur += k[1]\n                else:\n                    open1[k[0]] = 1\n            if j > 1:\n                for k in dp[j - 2]:\n                    temp.append([k[0] + cur, mask ^ k[1]])\n            else:\n                temp.append([cur, mask])\n        temp.sort()\n        temp = temp[::-1]\n        sel = {}\n        filled = 0\n        j = 0\n        while j < len(temp) and filled < k1:\n            if temp[j][1] in sel:\n                j += 1\n            else:\n                dp[i].append(temp[j])\n                filled += 1\n                sel[temp[j][1]] = 1\n                j += 1\n    dp[n].sort(reverse=True)\n    for i in range(k1):\n        print(dp[n][i][0], end=' ')\n    print()", "for test in range(int(input())):\n    (n, m, k1) = map(int, input().split())\n    g = [0]\n    gt = list(map(int, input().split()))\n    g.extend(gt)\n    pos = [[] for x in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        pos[u].append([i, d])\n        pos[v].append([i, d])\n    dp = [[] for x in range(n + 1)]\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        temp = []\n        temp.extend(dp[i - 1])\n        cur = 0\n        mask = 0\n        open1 = {}\n        for j in range(i, 0, -1):\n            cur += g[j]\n            mask = mask ^ 1 << j\n            for k in pos[j]:\n                if k[0] in open1:\n                    cur += k[1]\n                else:\n                    open1[k[0]] = 1\n            if j > 1:\n                for k in dp[j - 2]:\n                    temp.append([k[0] + cur, mask ^ k[1]])\n            else:\n                temp.append([cur, mask])\n        temp.sort()\n        temp = temp[::-1]\n        sel = {}\n        filled = 0\n        j = 0\n        while j < len(temp) and filled < k1:\n            if temp[j][1] in sel:\n                j += 1\n            else:\n                dp[i].append(temp[j])\n                filled += 1\n                sel[temp[j][1]] = 1\n                j += 1\n    dp[n].sort(reverse=True)\n    for i in range(k1):\n        print(dp[n][i][0], end=' ')\n    print()", "t = int(input())\nfor test in range(t):\n    (n, m, k1) = map(int, input().split())\n    g = [0]\n    gt = list(map(int, input().split()))\n    g.extend(gt)\n    pos = [[] for x in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        pos[u].append([i, d])\n        pos[v].append([i, d])\n    dp = [[] for x in range(n + 1)]\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        temp = []\n        temp.extend(dp[i - 1])\n        cur = 0\n        mask = 0\n        open1 = {}\n        for j in range(i, 0, -1):\n            cur += g[j]\n            mask = mask ^ 1 << j\n            for k in pos[j]:\n                if k[0] in open1:\n                    cur += k[1]\n                else:\n                    open1[k[0]] = 1\n            if j > 1:\n                for k in dp[j - 2]:\n                    temp.append([k[0] + cur, mask ^ k[1]])\n            else:\n                temp.append([cur, mask])\n        temp.sort()\n        temp = temp[::-1]\n        sel = {}\n        filled = 0\n        j = 0\n        while j < len(temp) and filled < k1:\n            if temp[j][1] in sel:\n                j += 1\n            else:\n                dp[i].append(temp[j])\n                filled += 1\n                sel[temp[j][1]] = 1\n                j += 1\n    dp[n].sort(reverse=True)\n    for i in range(k1):\n        print(dp[n][i][0], end=' ')\n    print()", "for test in range(int(input())):\n    (n, m, k1) = map(int, input().split())\n    g = [0]\n    gt = list(map(int, input().split()))\n    g.extend(gt)\n    pos = [[] for x in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        pos[u].append([i, d])\n        pos[v].append([i, d])\n    dp = [[] for x in range(n + 1)]\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        temp = []\n        temp.extend(dp[i - 1])\n        cur = 0\n        mask = 0\n        open1 = {}\n        for j in range(i, 0, -1):\n            cur += g[j]\n            mask = mask ^ 1 << j\n            for k in pos[j]:\n                if k[0] in open1:\n                    cur += k[1]\n                else:\n                    open1[k[0]] = 1\n            if j > 1:\n                for k in dp[j - 2]:\n                    temp.append([k[0] + cur, mask ^ k[1]])\n            else:\n                temp.append([cur, mask])\n        temp.sort()\n        temp = temp[::-1]\n        sel = {}\n        filled = 0\n        j = 0\n        while j < len(temp) and filled < k1:\n            if temp[j][1] in sel:\n                j += 1\n            else:\n                dp[i].append(temp[j])\n                filled += 1\n                sel[temp[j][1]] = 1\n                j += 1\n    dp[n].sort(reverse=True)\n    for i in range(k1):\n        print(dp[n][i][0], end=' ')\n    print()", "for test in range(int(input())):\n    (n, m, k1) = map(int, input().split())\n    g = [0]\n    gt = list(map(int, input().split()))\n    g.extend(gt)\n    pos = [[] for x in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        pos[u].append([i, d])\n        pos[v].append([i, d])\n    dp = [[] for x in range(n + 1)]\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        temp = []\n        temp.extend(dp[i - 1])\n        cur = 0\n        mask = 0\n        open1 = {}\n        for j in range(i, 0, -1):\n            cur += g[j]\n            mask = mask ^ 1 << j\n            for k in pos[j]:\n                if k[0] in open1:\n                    cur += k[1]\n                else:\n                    open1[k[0]] = 1\n            if j > 1:\n                for k in dp[j - 2]:\n                    temp.append([k[0] + cur, mask ^ k[1]])\n            else:\n                temp.append([cur, mask])\n        temp.sort()\n        temp = temp[::-1]\n        sel = {}\n        filled = 0\n        j = 0\n        while j < len(temp) and filled < k1:\n            if temp[j][1] in sel:\n                j += 1\n            else:\n                dp[i].append(temp[j])\n                filled += 1\n                sel[temp[j][1]] = 1\n                j += 1\n    dp[n].sort(reverse=True)\n    for i in range(k1):\n        print(dp[n][i][0], end=' ')\n    print()", "t = int(input())\nfor test in range(t):\n    (n, m, k1) = map(int, input().split())\n    g = [0]\n    gt = list(map(int, input().split()))\n    g.extend(gt)\n    pos = [[] for x in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        pos[u].append([i, d])\n        pos[v].append([i, d])\n    dp = [[] for x in range(n + 1)]\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        temp = []\n        temp.extend(dp[i - 1])\n        cur = 0\n        mask = 0\n        open1 = {}\n        for j in range(i, 0, -1):\n            cur += g[j]\n            mask = mask ^ 1 << j\n            for k in pos[j]:\n                if k[0] in open1:\n                    cur += k[1]\n                else:\n                    open1[k[0]] = 1\n            if j > 1:\n                for k in dp[j - 2]:\n                    temp.append([k[0] + cur, mask ^ k[1]])\n            else:\n                temp.append([cur, mask])\n        temp.sort()\n        temp = temp[::-1]\n        sel = {}\n        filled = 0\n        j = 0\n        while j < len(temp) and filled < k1:\n            if temp[j][1] in sel:\n                j += 1\n            else:\n                dp[i].append(temp[j])\n                filled += 1\n                sel[temp[j][1]] = 1\n                j += 1\n    dp[n].sort(reverse=True)\n    for i in range(k1):\n        print(dp[n][i][0], end=' ')\n    print()", "def solve():\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    av = [[] for j in range(n + 1)]\n    res = [[] for j in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        av[u].append((i, d))\n        av[v].append((i, d))\n    res[0].append((0, 0))\n    for i in range(1, n + 1):\n        temp = []\n        temp += res[i - 1]\n        cur = 0\n        mask = 0\n        o = []\n        for j in reversed(range(1, i + 1)):\n            cur += a[j - 1]\n            mask ^= 1 << j\n            for x in av[j]:\n                if x[0] in o:\n                    cur += x[1]\n                else:\n                    o.append(x[0])\n            if j > 1:\n                for x in res[j - 2]:\n                    temp.append((x[0] + cur, mask ^ x[1]))\n            else:\n                temp.append((cur, mask))\n        temp = sorted(temp, key=lambda x: (x[0], x[1]), reverse=True)\n        selected = []\n        fill = 0\n        for j in range(len(temp)):\n            if k <= fill:\n                break\n            if temp[j][1] in selected:\n                print('yes')\n                continue\n            res[i].append(temp[j])\n            fill += 1\n            selected.append(temp[j][1])\n    return ''.join((str(res[n][i][0]) + ' ' for i in range(k)))\nfor z in range(int(input())):\n    print(solve())", "def solve():\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    av = [[] for j in range(n + 1)]\n    res = [[] for j in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        av[u].append((i, d))\n        av[v].append((i, d))\n    res[0].append((0, 0))\n    for i in range(1, n + 1):\n        temp = []\n        temp += res[i - 1]\n        cur = 0\n        mask = 0\n        o = []\n        for j in reversed(range(1, i + 1)):\n            cur += a[j - 1]\n            mask ^= 1 << j\n            for x in av[j]:\n                if x[0] in o:\n                    cur += x[1]\n                else:\n                    o.append(x[0])\n            if j > 1:\n                for x in res[j - 2]:\n                    temp.append((x[0] + cur, mask ^ x[1]))\n            else:\n                temp.append((cur, mask))\n        temp = sorted(temp, key=lambda x: (x[0], x[1]), reverse=True)\n        selected = []\n        fill = 0\n        for j in range(len(temp)):\n            if k <= fill:\n                break\n            if temp[j][1] in selected:\n                print('yes')\n                continue\n            res[i].append(temp[j])\n            fill += 1\n            selected.append(temp[j][1])\n    sol = ''\n    for i in range(k):\n        sol += str(res[n][i][0]) + ' '\n    return sol\nfor z in range(int(input())):\n    print(solve())", "def solve():\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    av = [[] for j in range(n + 1)]\n    res = [[] for j in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        av[u].append((i, d))\n        av[v].append((i, d))\n    res[0].append((0, 0))\n    for i in range(1, n + 1):\n        temp = []\n        temp += res[i - 1]\n        cur = 0\n        mask = 0\n        o = []\n        for j in reversed(range(1, i + 1)):\n            cur += a[j - 1]\n            mask ^= 1 << j\n            for x in av[j]:\n                if x[0] in o:\n                    cur += x[1]\n                else:\n                    o.append(x[0])\n            if j > 1:\n                for x in res[j - 2]:\n                    temp.append((x[0] + cur, mask ^ x[1]))\n            else:\n                temp.append((cur, mask))\n        temp = sorted(temp, key=lambda x: (x[0], x[1]), reverse=True)\n        selected = []\n        fill = 0\n        for j in range(len(temp)):\n            if k <= fill:\n                break\n            if temp[j][1] in selected:\n                print('yes')\n                continue\n            res[i].append(temp[j])\n            fill += 1\n            selected.append(temp[j][1])\n    sol = ''\n    for i in range(k):\n        sol += str(res[n][i][0]) + ' '\n    return sol\nt = int(input())\nfor z in range(t):\n    ans = solve()\n    print(ans)", "import functools\n\ndef compare(i, j):\n    if i[0] > j[0]:\n        return -1\n    elif i[0] < j[0]:\n        return 1\n    elif i[1] > j[1]:\n        return -1\n    elif i[1] < j[1]:\n        return 1\n    else:\n        return 0\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = list(map(int, input().strip().split()))\n    g = list(map(int, input().strip().split()))\n    g.insert(0, 0)\n    arr = [[] for i in range(n + 1)]\n    dp = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = list(map(int, input().strip().split()))\n        arr[u].append([i, d])\n        arr[v].append([i, d])\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        yo = []\n        for aa in dp[i - 1]:\n            yo.append(aa)\n        cu = 0\n        ma = 0\n        o = set()\n        for j in range(i, 0, -1):\n            cu += g[j]\n            ma = ma ^ 1 << j\n            for p in arr[j]:\n                if p[0] in o:\n                    cu += p[1]\n                else:\n                    o.add(p[0])\n            if j > 1:\n                for p in dp[j - 2]:\n                    yo.append([p[0] + cu, ma ^ p[1]])\n            else:\n                yo.append([cu, ma])\n        yo.sort(key=functools.cmp_to_key(compare))\n        sel = set()\n        f = 0\n        for j in range(len(yo)):\n            if f >= k:\n                break\n            if yo[j][1] in sel:\n                continue\n            dp[i].append(yo[j])\n            f += 1\n            sel.add(yo[j][1])\n    for i in range(k):\n        print(dp[n][i][0], end=' ')\n    print()", "def build_temp_cache(G, ind, Dscore, cache, prev_cache, curr_ind):\n    temp_cache = []\n    for cache_element in cache:\n        temp_cache.append(cache_element)\n    simple_score = 0\n    mp = {}\n    two_pw = 0\n    for j in range(curr_ind, 0, -1):\n        simple_score += G[j]\n        two_pw = two_pw ^ 2 ** j\n        for l in range(len(Dscore[j])):\n            if ind[j][l] in mp:\n                simple_score += Dscore[j][l]\n            else:\n                mp[ind[j][l]] = 1\n        if j > 1:\n            for cache_element in prev_cache[j - 2]:\n                temp_cache.append((cache_element[0] + simple_score, two_pw ^ cache_element[1]))\n        else:\n            temp_cache.append((simple_score, two_pw))\n    return temp_cache\n\ndef build_cache(temp_cache, k):\n    mp = {}\n    cnt = 0\n    j = 0\n    cache = []\n    temp_cache.sort()\n    temp_cache.reverse()\n    while j < len(temp_cache) and cnt < k:\n        if temp_cache[j][1] not in mp:\n            cache.append(temp_cache[j])\n            cnt += 1\n            mp[temp_cache[j][1]] = 1\n        j += 1\n    return cache\nT = int(input())\nfor t in range(T):\n    (n, m, k) = map(int, input().split())\n    G = [0] + list(map(int, input().split()))\n    (ind, Dscore) = ([], [])\n    for i in range(n + 1):\n        ind.append([])\n        Dscore.append([])\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        Dscore[u].append(d)\n        Dscore[v].append(d)\n        ind[u].append(i)\n        ind[v].append(i)\n    cache = [(0, 0)]\n    prev_cache = []\n    for i in range(1, n + 1):\n        temp_cache = build_temp_cache(G, ind, Dscore, cache, prev_cache, i)\n        prev_cache.append([])\n        for each_c in cache:\n            prev_cache[i - 1].append(each_c)\n        cache = build_cache(temp_cache, k)\n    for i in range(k):\n        print(cache[i][0], end=' ')\n    print('')", "t = int(input())\nfor test in range(t):\n    (n, m, k1) = map(int, input().split())\n    g = [0]\n    gt = list(map(int, input().split()))\n    g.extend(gt)\n    pos = [[] for x in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        pos[u].append([i, d])\n        pos[v].append([i, d])\n    dp = [[] for x in range(n + 1)]\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        temp = []\n        temp.extend(dp[i - 1])\n        cur = 0\n        mask = 0\n        open1 = {}\n        for j in range(i, 0, -1):\n            cur += g[j]\n            mask = mask ^ 1 << j\n            for k in pos[j]:\n                if k[0] in open1:\n                    cur += k[1]\n                else:\n                    open1[k[0]] = 1\n            if j > 1:\n                for k in dp[j - 2]:\n                    temp.append([k[0] + cur, mask ^ k[1]])\n            else:\n                temp.append([cur, mask])\n        temp.sort()\n        temp = temp[::-1]\n        sel = {}\n        filled = 0\n        j = 0\n        while j < len(temp) and filled < k1:\n            if temp[j][1] in sel:\n                j += 1\n            else:\n                dp[i].append(temp[j])\n                filled += 1\n                sel[temp[j][1]] = 1\n                j += 1\n    dp[n].sort(reverse=True)\n    for i in range(k1):\n        print(dp[n][i][0], end=' ')\n    print()", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    g = list(map(int, input().split()))\n    g.insert(0, 0)\n    lis = []\n    dp = []\n    for _ in range(n + 1):\n        lis.append([])\n        dp.append([])\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        lis[u].append([i, d])\n        lis[v].append([i, d])\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        temp_lis = []\n        for j in dp[i - 1]:\n            temp_lis.append(j)\n        curr = 0\n        mask = 0\n        s = set()\n        for j in range(i, 0, -1):\n            curr += g[j]\n            mask = mask ^ 1 << j\n            for pointer in lis[j]:\n                if pointer[0] in s:\n                    curr += pointer[1]\n                else:\n                    s.add(pointer[0])\n            if j > 1:\n                for pointer in dp[j - 2]:\n                    temp_lis.append([pointer[0] + curr, mask ^ pointer[1]])\n            else:\n                temp_lis.append([curr, mask])\n        temp_lis.sort(key=lambda x: x[0])\n        temp_lis = temp_lis[::-1]\n        sel = set()\n        filled = 0\n        j = 0\n        while j < len(temp_lis) and filled < k:\n            if temp_lis[j][1] in sel:\n                j += 1\n                continue\n            dp[i].append(temp_lis[j])\n            filled += 1\n            sel.add(temp_lis[j][1])\n            j += 1\n    ans = []\n    for i in range(k):\n        ans.append(dp[n][i][0])\n    print(*ans)", "def printAns(k, dp):\n    for i in range(k):\n        print(dp[n][i][0], end=' ')\n    print()\n\ndef solve(n, m, k1, l, dp):\n    dp[0].append((0, 0))\n    for i in range(1, n + 1):\n        tmp = []\n        for j in dp[i - 1]:\n            tmp.append(j)\n        cr = 0\n        mk = 0\n        opn = set()\n        for j in range(i, 0, -1):\n            cr += g[j]\n            mk ^= 1 << j\n            for ptr in l[j]:\n                if ptr[0] in opn:\n                    cr += ptr[1]\n                else:\n                    opn.add(ptr[0])\n            if j > 1:\n                for ptr in dp[j - 2]:\n                    tmp.append((ptr[0] + cr, mk ^ ptr[1]))\n            else:\n                tmp.append((cr, mk))\n        tmp.sort(key=lambda tmp: tmp[0])\n        tmp.reverse()\n        slt = set()\n        j = 0\n        fl = 0\n        while j < len(tmp) and fl < k1:\n            if tmp[j][1] in slt:\n                j += 1\n                continue\n            dp[i].append(tmp[j])\n            fl += 1\n            slt.add(tmp[j][1])\n    printAns(k1, dp)\nfor _ in range(int(input())):\n    (n, m, k1) = map(int, input().split())\n    g = list(map(int, input().split()))\n    g.insert(0, 0)\n    l = []\n    dp = []\n    for i in range(n + 1):\n        l.append([])\n        dp.append([])\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        l[u].append((i, d))\n        l[v].append((i, d))\n    solve(n, m, k1, l, dp)", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ndepth = 1000005\nmod = 1000000007\nsys.setrecursionlimit(depth)\nfrom collections import defaultdict\nfrom math import inf\nfrom heapq import heapify, merge, nlargest\na = b = c = n = m = None\n\ndef compute(index, curr):\n    r = index\n    l = index - curr\n    res = a[index]\n    for i in range(1, m + 1):\n        e = b[i]\n        if e[0] >= l and e[1] == r:\n            res += e[2]\n    return res\n\ndef solve(index, curr):\n    if index == n:\n        return sorted([0, compute(index, curr)])\n    if dp[index, curr] != -1:\n        return dp[index, curr]\n    s1 = solve(index + 1, 0)\n    s2 = solve(index + 1, curr + 1)\n    val = compute(index, curr)\n    s2 = [e + val for e in s2]\n    ans = list(merge(s1, s2))\n    if len(ans) > k:\n        ans = list(nlargest(k, ans))\n    dp[index, curr] = ans\n    return dp[index, curr]\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = [0] + list(map(int, input().split()))\n    b = [0 for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        (u, v, w) = map(int, input().split())\n        b[i] = (u, v, w)\n    dp = defaultdict(lambda : -1)\n    ans = solve(1, 0)\n    ans.sort(reverse=True)\n    ans = ans[:k]\n    print(*ans)", "import io, sys\n\ndef inpt():\n    return sys.stdin.readline()\n\ndef getints():\n    return map(int, sys.stdin.readline().split())\n\ndef getlist():\n    return list(getints())\n\ndef prnt(val):\n    sys.stdout.write(str(val) + '\\n')\n\ndef solve():\n    (n, m, k) = getints()\n    grr = [0] + getlist()\n    mr = [getlist() for i in range(m)]\n    (mrr, dp) = ({i: [] for i in range(n + 1)}, {i: [] for i in range(n + 1)})\n    for i in range(m):\n        mrr[mr[i][0]].append([i, mr[i][2]])\n        mrr[mr[i][1]].append([i, mr[i][2]])\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        temp = []\n        for val in dp[i - 1]:\n            temp.append(val)\n        (curr, mask) = (0, 0)\n        op = set()\n        for j in range(i, 0, -1):\n            curr += grr[j]\n            mask ^= 2 ** j\n            for val in mrr[j]:\n                if val[0] in op:\n                    curr += val[1]\n                else:\n                    op.add(val[0])\n            if j > 1:\n                for valj in dp[j - 2]:\n                    temp.append([valj[0] + curr, valj[1] ^ mask])\n            else:\n                temp.append([curr, mask])\n        temp.sort(reverse=True)\n        (sel, filled) = (set(), 0)\n        j = 0\n        while j < len(temp) and filled < k:\n            if temp[j][1] in sel:\n                j += 1\n                continue\n            dp[i].append(temp[j])\n            filled += 1\n            sel.add(temp[j][1])\n            j += 1\n    for val in dp[n]:\n        sys.stdout.write(str(val[0]) + ' ')\n    sys.stdout.write('\\n')\nfor _ in range(int(inpt())):\n    solve()", "INF = 1e+18\nt = int(input())\nfor _ in range(t):\n    all_ans = []\n    (n, m, K) = list(map(int, input().split()))\n    g = [0] * (n + 1)\n    temp = list(map(int, input().split()))\n    for i in range(0, n):\n        g[i + 1] = temp[i]\n    intervals = []\n    arr = [[] for _ in range(n + 1)]\n    dp = [[] for _ in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = list(map(int, input().split()))\n        arr[u].append((i, d))\n        arr[v].append((i, d))\n    dp[0].append((0, 0))\n    for i in range(1, n + 1):\n        temp = []\n        for j in dp[i - 1]:\n            temp.append(j)\n        open = set()\n        curr = 0\n        mask = 0\n        for k in range(i, 0, -1):\n            curr += g[k]\n            mask = mask ^ 1 << k\n            for xyz in arr[k]:\n                if xyz[0] in open:\n                    curr += xyz[1]\n                else:\n                    open.add(xyz[0])\n            if k > 1:\n                for xyzj in dp[k - 2]:\n                    temp.append((xyzj[0] + curr, mask ^ xyzj[1]))\n            else:\n                temp.append((curr, mask))\n        temp.sort()\n        temp = temp[::-1]\n        sel = set()\n        filled = 0\n        for j in range(0, len(temp)):\n            if filled == K:\n                break\n            if temp[j][1] in sel:\n                continue\n            dp[i].append(temp[j])\n            filled += 1\n            sel.add(temp[j][1])\n    ans = []\n    for i in range(K):\n        ans.append(dp[n][i][0])\n    print(*ans)", "t = int(input())\ntt = 0\nfor tt in range(0, t):\n    ans = 0\n    num5 = []\n    num = input().split(' ')\n    outcome = 0\n    n = int(num[0])\n    num5.append(n)\n    m = int(num[1])\n    num5.append(m)\n    k = int(num[2])\n    num5.append(k)\n    g = input().split(' ')\n    for find in range(0, len(num5)):\n        if num[find] == n:\n            ans = find\n            break\n        elif num[find] == k:\n            num[find] = n\n            continue\n        else:\n            outcome = n\n            break\n    g = [int(i) for i in g]\n    for find in range(0, len(num5)):\n        if num[find] == n:\n            ans = find\n            break\n        elif num[find] == k:\n            num[find] = n\n            continue\n        else:\n            outcome = n\n            break\n    g.insert(0, 0)\n    for find in range(0, len(num5)):\n        if num[find] == n:\n            ans = find\n            break\n        elif num[find] == k:\n            num[find] = n\n            continue\n        else:\n            outcome = n\n            break\n    arr = []\n    for find in range(0, len(num5)):\n        if num[find] == n:\n            ans = find\n            break\n        elif num[find] == k:\n            num[find] = n\n            continue\n        else:\n            outcome = n\n            break\n    for i in range(0, n + 1):\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        a = []\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        arr.append(a)\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n    for i in range(0, m):\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        num1 = input().split(' ')\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        u = int(num1[0])\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        v = int(num1[1])\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        d = int(num1[2])\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        arr[u].append([i, d])\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        arr[v].append([i, d])\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n    dynamic = []\n    for find in range(0, len(num5)):\n        if num[find] == n:\n            ans = find\n            break\n        elif num[find] == k:\n            num[find] = n\n            continue\n        else:\n            outcome = n\n            break\n    for i in range(0, n + 1):\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        a = []\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        dynamic.append(a)\n    for find in range(0, len(num5)):\n        if num[find] == n:\n            ans = find\n            break\n        elif num[find] == k:\n            num[find] = n\n            continue\n        else:\n            outcome = n\n            break\n    dynamic[0].append([0, 0])\n    for find in range(0, len(num5)):\n        if num[find] == n:\n            ans = find\n            break\n        elif num[find] == k:\n            num[find] = n\n            continue\n        else:\n            outcome = n\n            break\n    for i in range(1, n + 1):\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n\n        def Cloning(li1):\n            li_copy = li1[:]\n            return li_copy\n        num4 = []\n        num4.extend(dynamic[i - 1])\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        current = 0\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        normal = 0\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        open = set()\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        for j in range(i, 0, -1):\n            for find in range(0, len(num5)):\n                if num[find] == n:\n                    ans = find\n                    break\n                elif num[find] == k:\n                    num[find] = n\n                    continue\n                else:\n                    outcome = n\n                    break\n            current = current + g[j]\n            for find in range(0, len(num5)):\n                if num[find] == n:\n                    ans = find\n                    break\n                elif num[find] == k:\n                    num[find] = n\n                    continue\n                else:\n                    outcome = n\n                    break\n            normal = normal ^ 1 << j\n            for find in range(0, len(num5)):\n                if num[find] == n:\n                    ans = find\n                    break\n                elif num[find] == k:\n                    num[find] = n\n                    continue\n                else:\n                    outcome = n\n                    break\n            for x in arr[j]:\n                for find in range(0, len(num5)):\n                    if num[find] == n:\n                        ans = find\n                        break\n                    elif num[find] == k:\n                        num[find] = n\n                        continue\n                    else:\n                        outcome = n\n                        break\n                num2 = x[0]\n                for find in range(0, len(num5)):\n                    if num[find] == n:\n                        ans = find\n                        break\n                    elif num[find] == k:\n                        num[find] = n\n                        continue\n                    else:\n                        outcome = n\n                        break\n                num3 = x[1]\n                for find in range(0, len(num5)):\n                    if num[find] == n:\n                        ans = find\n                        break\n                    elif num[find] == k:\n                        num[find] = n\n                        continue\n                    else:\n                        outcome = n\n                        break\n                if num2 in open:\n                    for find in range(0, len(num5)):\n                        if num[find] == n:\n                            ans = find\n                            break\n                        elif num[find] == k:\n                            num[find] = n\n                            continue\n                        else:\n                            outcome = n\n                            break\n                    current = current + num3\n                else:\n                    open.add(num2)\n            if j > 1:\n                for find in range(0, len(num5)):\n                    if num[find] == n:\n                        ans = find\n                        break\n                    elif num[find] == k:\n                        num[find] = n\n                        continue\n                    else:\n                        outcome = n\n                        break\n                for x in dynamic[j - 2]:\n                    for find in range(0, len(num5)):\n                        if num[find] == n:\n                            ans = find\n                            break\n                        elif num[find] == k:\n                            num[find] = n\n                            continue\n                        else:\n                            outcome = n\n                            break\n                    value = x[0]\n                    for find in range(0, len(num5)):\n                        if num[find] == n:\n                            ans = find\n                            break\n                        elif num[find] == k:\n                            num[find] = n\n                            continue\n                        else:\n                            outcome = n\n                            break\n                    previous = x[1]\n                    for find in range(0, len(num5)):\n                        if num[find] == n:\n                            ans = find\n                            break\n                        elif num[find] == k:\n                            num[find] = n\n                            continue\n                        else:\n                            outcome = n\n                            break\n                    num4.append([value + current, normal ^ previous])\n                    for find in range(0, len(num5)):\n                        if num[find] == n:\n                            ans = find\n                            break\n                        elif num[find] == k:\n                            num[find] = n\n                            continue\n                        else:\n                            outcome = n\n                            break\n            else:\n                for find in range(0, len(num5)):\n                    if num[find] == n:\n                        ans = find\n                        break\n                    elif num[find] == k:\n                        num[find] = n\n                        continue\n                    else:\n                        outcome = n\n                        break\n                num4.append([current, normal])\n                for find in range(0, len(num5)):\n                    if num[find] == n:\n                        ans = find\n                        break\n                    elif num[find] == k:\n                        num[find] = n\n                        continue\n                    else:\n                        outcome = n\n                        break\n        num4.sort(reverse=True)\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        dump = set()\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        space = 0\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        for j in range(0, len(num4)):\n            for find in range(0, len(num5)):\n                if num[find] == n:\n                    ans = find\n                    break\n                elif num[find] == k:\n                    num[find] = n\n                    continue\n                else:\n                    outcome = n\n                    break\n            if space < k:\n                for find in range(0, len(num5)):\n                    if num[find] == n:\n                        ans = find\n                        break\n                    elif num[find] == k:\n                        num[find] = n\n                        continue\n                    else:\n                        outcome = n\n                        break\n                if num4[j][1] in dump:\n                    for find in range(0, len(num5)):\n                        if num[find] == n:\n                            ans = find\n                            break\n                        elif num[find] == k:\n                            num[find] = n\n                            continue\n                        else:\n                            outcome = n\n                            break\n                    continue\n                dynamic[i].append(num4[j])\n                for find in range(0, len(num5)):\n                    if num[find] == n:\n                        ans = find\n                        break\n                    elif num[find] == k:\n                        num[find] = n\n                        continue\n                    else:\n                        outcome = n\n                        break\n                space = space + 1\n                for find in range(0, len(num5)):\n                    if num[find] == n:\n                        ans = find\n                        break\n                    elif num[find] == k:\n                        num[find] = n\n                        continue\n                    else:\n                        outcome = n\n                        break\n                dump.add(num4[j][1])\n                for find in range(0, len(num5)):\n                    if num[find] == n:\n                        ans = find\n                        break\n                    elif num[find] == k:\n                        num[find] = n\n                        continue\n                    else:\n                        outcome = n\n                        break\n            else:\n                for find in range(0, len(num5)):\n                    if num[find] == n:\n                        ans = find\n                        break\n                    elif num[find] == k:\n                        num[find] = n\n                        continue\n                    else:\n                        outcome = n\n                        break\n                break\n    for i in range(0, k):\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n        print(dynamic[n][i][0], end=' ')\n        for find in range(0, len(num5)):\n            if num[find] == n:\n                ans = find\n                break\n            elif num[find] == k:\n                num[find] = n\n                continue\n            else:\n                outcome = n\n                break\n    print()", "t = int(input())\nfor i in range(t):\n    (n, m, k1) = map(int, input().split())\n    g = list(map(int, input().split()))\n    g.insert(0, 0)\n    wer = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        wer[u].append([i, d])\n        wer[v].append([i, d])\n    dp = [[] for i in range(n + 1)]\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        lcal = []\n        for p in dp[i - 1]:\n            lcal.append(p)\n        (curr, mask) = (0, 0)\n        pot = set()\n        for j in range(i, 0, -1):\n            curr += g[j]\n            mask ^= 1 << j\n            for k in wer[j]:\n                idx = k[0]\n                w = k[1]\n                if idx in pot:\n                    curr += w\n                else:\n                    pot.add(idx)\n            if j > 1:\n                for a in dp[j - 2]:\n                    val = a[0]\n                    old_mask = a[1]\n                    lcal.append([val + curr, mask ^ old_mask])\n            else:\n                lcal.append([curr, mask])\n        lcal = [ele for ele in lcal if ele != []]\n        lcal.sort(key=lambda x: x[0], reverse=True)\n        zxcv = set()\n        uio = 0\n        v = 0\n        while v < len(lcal) and uio < k1:\n            if lcal[v][1] in zxcv:\n                continue\n            dp[i].append(lcal[v])\n            uio += 1\n            zxcv.add(lcal[v][1])\n            v += 1\n    for i in range(k1):\n        print(dp[n][i][0], end=' ')\n    print('')", "t = int(input())\nfor i in range(t):\n    (n, m, k1) = map(int, input().split())\n    g = list(map(int, input().split()))\n    g.insert(0, 0)\n    arr = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        arr[u].append([i, d])\n        arr[v].append([i, d])\n    dp = [[] for i in range(n + 1)]\n    dp[0].append([0, 0])\n    for i in range(1, n + 1):\n        temp = []\n        for p in dp[i - 1]:\n            temp.append(p)\n        (curr, mask) = (0, 0)\n        open1 = set()\n        for j in range(i, 0, -1):\n            curr += g[j]\n            mask ^= 1 << j\n            for k in arr[j]:\n                idx = k[0]\n                w = k[1]\n                if idx in open1:\n                    curr += w\n                else:\n                    open1.add(idx)\n            if j > 1:\n                for a in dp[j - 2]:\n                    val = a[0]\n                    old_mask = a[1]\n                    temp.append([val + curr, mask ^ old_mask])\n            else:\n                temp.append([curr, mask])\n        temp = [ele for ele in temp if ele != []]\n        temp.sort(key=lambda x: x[0], reverse=True)\n        sel = set()\n        filled = 0\n        v = 0\n        while v < len(temp) and filled < k1:\n            if temp[v][1] in sel:\n                continue\n            dp[i].append(temp[v])\n            filled += 1\n            sel.add(temp[v][1])\n            v += 1\n    for i in range(k1):\n        print(dp[n][i][0], end=' ')\n    print('')", "import numpy\nT = int(input())\nfor _ in range(T):\n    (N, M, K) = map(int, input().split())\n    weights = list(map(int, input().split()))\n    weights = [0] + weights\n    weight_interval = [[] for i in range(N + 1)]\n    for i in range(M):\n        (u, v, w) = map(int, input().split())\n        if u == v:\n            weighs[u] += w\n        else:\n            weight_interval[v].append([u, w])\n    ans = [[] for i in range(N + 1)]\n    for i in range(1, N + 1):\n        merged_list = []\n        for j in range(i):\n            merged_list.extend(ans[j])\n        if len(merged_list) == 0:\n            merged_list = [0]\n        merged_list.sort(reverse=True)\n        merged_list = merged_list[:K]\n        ans[i] = merged_list.copy()\n        value_to_add = weights[i]\n        for j in range(0, i):\n            value_to_add_interval = 0\n            if len(weight_interval[i]) > 0:\n                for (interval_begin, weight) in weight_interval[i]:\n                    if interval_begin > j:\n                        value_to_add_interval += weight\n            if len(ans[j]) == 0:\n                ans[j] = [value_to_add_interval + value_to_add]\n            else:\n                ans[j] = [val + value_to_add_interval + value_to_add for val in ans[j]]\n    merged_list = []\n    for j in range(i + 1):\n        merged_list.extend(ans[j])\n    if len(merged_list) == 0:\n        merged_list = [0]\n    merged_list.sort(reverse=True)\n    merged_list = merged_list[:K]\n    print(*merged_list)", "t = int(input())\nfor x in range(t):\n    (n, m, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    tri = []\n    tri.append(l)\n    for i in range(1, n):\n        tri.append([])\n        for j in range(n - i):\n            tri[i].append(0)\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        tri[v - u][u - 1] += d\n    for i in range(1, n):\n        for j in range(n - i):\n            if i == 1:\n                tri[i][j] += tri[i - 1][j] + tri[i - 1][j + 1]\n            else:\n                tri[i][j] += tri[i - 1][j] + tri[i - 1][j + 1] - tri[i - 2][j + 1]\n    fl = []\n    for i in range(n):\n        fl.append([])\n    fl.append([0])\n    fl.append([0])\n    for j in range(n - 1, -1, -1):\n        templ = []\n        for i in range(n - j):\n            for z in fl[j + 2 + i]:\n                templ.append(tri[i][j] + z)\n        cl = 0\n        re = len(templ) + len(fl[j + 1])\n        m1 = templ[0]\n        m2 = fl[j + 1][0]\n        p1 = 0\n        p2 = 0\n        mb = min(min(templ), min(fl[j + 1]))\n        cfl = []\n        for i in fl[j + 1]:\n            cfl.append(i)\n        while cl < k and re > 0:\n            for i in range(len(templ)):\n                if templ[i] >= m1:\n                    m1 = templ[i]\n                    p1 = i\n            for i in range(len(fl[j + 1])):\n                if cfl[i] >= m2:\n                    m2 = cfl[i]\n                    p2 = i\n            if m1 > m2:\n                fl[j].append(m1)\n                templ[p1] = mb\n                m1 = mb\n            else:\n                fl[j].append(m2)\n                cfl[p2] = mb\n                m2 = mb\n            cl += 1\n            re -= 1\n    for i in fl[0]:\n        print(i, end=' ')\n    print()", "import heapq\nimport copy\n\ndef solve(G, n, D, m, k):\n    GPrefixSums = [0]\n    gPrefixSum = 0\n    for i in range(n):\n        gPrefixSum += G[i]\n        GPrefixSums.append(gPrefixSum)\n    Sums = [[0] * (n + 1)]\n    for i in range(1, n + 1):\n        Sums.append([0] * (n + 1))\n        for j in range(i, n + 1):\n            Sums[i][j] = GPrefixSums[j] - GPrefixSums[i - 1]\n    for (u, v, d) in D:\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                if i <= u and j >= v:\n                    Sums[i][j] += d\n    Solution = []\n    heapq.heappush(Solution, (0, ()))\n    SolutionSet = set([()])\n    SolutionValFreq = {0: 1}\n    BestSolutionSoFar = [copy.deepcopy(Solution)]\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            s = Sums[j][i]\n            t = tuple([index for index in range(j, i + 1)])\n            heapq.heappush(Solution, (s, t))\n            SolutionSet.add(t)\n            SolutionValFreq[s] = SolutionValFreq.get(s, 0) + 1\n            if len(Solution) - SolutionValFreq[Solution[0][0]] >= k:\n                val = Solution[0][0]\n                while Solution[0][0] == val:\n                    (pVal, pAssignment) = heapq.heappop(Solution)\n                    SolutionSet.remove(pAssignment)\n                    SolutionValFreq[pVal] -= 1\n            if j > 2:\n                for (assignmentVal, assignment) in BestSolutionSoFar[j - 2]:\n                    newAssignment = assignment + t\n                    if newAssignment in SolutionSet:\n                        continue\n                    newAssignmentVal = assignmentVal + s\n                    if len(Solution) >= k and newAssignmentVal < Solution[0][0]:\n                        continue\n                    heapq.heappush(Solution, (newAssignmentVal, newAssignment))\n                    SolutionSet.add(newAssignment)\n                    SolutionValFreq[newAssignmentVal] = SolutionValFreq.get(newAssignmentVal, 0) + 1\n                    if len(Solution) - SolutionValFreq[Solution[0][0]] >= k:\n                        val = Solution[0][0]\n                        while Solution[0][0] == val:\n                            (pVal, pAssignment) = heapq.heappop(Solution)\n                            SolutionSet.remove(pAssignment)\n                            SolutionValFreq[pVal] -= 1\n        BestSolutionSoFar.append(copy.deepcopy(Solution))\n    result = []\n    while len(Solution):\n        result.append(heapq.heappop(Solution)[0])\n    result.reverse()\n    result = result[0:k]\n    return result\nt = int(input())\nfor tc in range(t):\n    (n, m, k) = map(int, input().split())\n    G = list(map(int, input().split()))\n    D = []\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        D.append((u, v, d))\n    result = solve(G, n, D, m, k)\n    print(*result)", "from collections import Counter\nfrom collections import defaultdict as dd\nimport sys\nimport heapq\n\nclass Heap:\n\n    def __init__(self, K):\n        self.cap = K\n        self.li = []\n        heapq.heapify(self.li)\n\n    def insert(self, item):\n        heapq.heappush(self.li, item)\n        if len(self.li) > self.cap:\n            heapq.heappop(self.li)\n\n    def show(self):\n        li = self.li[:]\n        li.sort(reverse=True)\n        print(*li)\n\ndef getRan(n, ed, G):\n    pref = [0]\n    for it in G:\n        pref.append(pref[-1] + it)\n    dp = [[0] * (n + 1) for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            dp[i][j] = pref[j] - pref[i - 1]\n    li = []\n    Id = 0\n    (beg, end) = (dd(list), dd(list))\n    val = dd(int)\n    for ((u, v), d) in ed.items():\n        beg[u].append(Id)\n        end[v].append(Id)\n        val[Id] = d\n        Id += 1\n    for j in range(1, n + 1):\n        cur = 0\n        seen = {}\n        for i in range(j, 0, -1):\n            for Id in end[i]:\n                seen[Id] = 1\n            for Id in beg[i]:\n                if Id in seen:\n                    cur += val[Id]\n            dp[i][j] += cur\n    return dp\n\ndef solve(n, m, k, ed, G):\n    dp = getRan(n, ed, G)\n    tot = [Heap(k) for i in range(n + 1)]\n    tot[0].insert(0)\n    tot[1].insert(dp[1][1])\n    tot[1].insert(0)\n    for i in range(2, n + 1):\n        tot[i].insert(dp[1][i])\n        for it in tot[i - 1].li:\n            tot[i].insert(it)\n        for j in range(i - 1, 0, -1):\n            for it in tot[j - 1].li:\n                tot[i].insert(dp[j + 1][i] + it)\n    tot[n].show()\nfor case in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    G = list(map(int, input().split()))\n    ed = Counter()\n    for i in range(m):\n        (u, v, d) = map(int, input().split())\n        ed[u, v] = d\n    dp = solve(n, m, k, ed, G)", "def readInt():\n    return int(input())\n\ndef readInts():\n    return [int(x) for x in input().split()]\n\ndef readString():\n    return input().rstrip()\n\ndef readStrings():\n    return input().split()\n\ndef print_list(l):\n    print(' '.join((str(x) for x in l)))\n\ndef readCase():\n    (n, m, k) = readInts()\n    bit_scores = readInts()\n    ranges = [readInts() for _ in range(m)]\n    return (n, m, k, bit_scores, ranges)\n\ndef solve(n, m, k, bit_scores, ranges):\n    interval_scores = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    base_score = sum(bit_scores)\n    for (u, v, d) in ranges:\n        base_score += d\n        for a in range(-1, u - 1):\n            for b in range(u - 1, v):\n                interval_scores[a][b] -= d\n    best = [[base_score] for _ in range(n + 1)]\n    for right_bit in range(n):\n        cur_best = []\n        for prev_bit in range(-1, right_bit):\n            offset = interval_scores[prev_bit][right_bit] - bit_scores[right_bit]\n            next_best = [x + offset for x in best[prev_bit]]\n            cur_best += next_best\n            cur_best.sort(reverse=True)\n            cur_best = cur_best[:k]\n        best[right_bit] = cur_best\n    total_best = sum(best, [])\n    total_best.sort(reverse=True)\n    return total_best[:k]\ncases = readInt()\nfor case in range(cases):\n    print_list(solve(*readCase()))", "import math\n\ndef ints():\n    return map(int, input().split())\n\ndef merge(with0, with1, d):\n    ans = []\n    (i, j) = (0, 0)\n    with1 = [x + d for x in with1]\n    while i < len(with0) and j < len(with1):\n        if with0[i] > with1[j]:\n            ans.append(with0[i])\n            i += 1\n        else:\n            ans.append(with1[j])\n            j += 1\n    if i == len(with0):\n        ans.extend(with1[j:])\n    if j == len(with1):\n        ans.extend(with0[i:])\n    return ans[:k]\n\ndef find(i, tups):\n    if (i, tups) in dp:\n        return dp[i, tups]\n    if i == 0:\n        ans = g[0]\n        for tup in tups:\n            ans += tup[2]\n        dp[0, tups] = merge([ans], [0], 0)\n        return dp[0, tups]\n    toadd = g[i]\n    coll = []\n    for tup in tups:\n        if i < tup[0]:\n            continue\n        if i == tup[0]:\n            toadd += tup[2]\n        else:\n            coll.append(tup)\n    coll.sort()\n    with1 = find(i - 1, tuple(coll))\n    coll2 = []\n    for tup in tups:\n        if i < tup[0]:\n            continue\n        if tup[0] <= i <= tup[1]:\n            continue\n        else:\n            coll2.append(tup)\n    coll2.sort()\n    with0 = find(i - 1, tuple(coll2))\n    dp[i, tups] = merge(with0, with1, toadd)\n    return dp[i, tups]\nt = int(input())\nfor _ in range(t):\n    dp = {}\n    (n, m, k) = ints()\n    g = list(ints())\n    tups = []\n    for i in range(m):\n        (u, v, d) = ints()\n        tups.append((u - 1, v - 1, d))\n    tups.sort()\n    ans = find(n - 1, tuple(tups))\n    print(' '.join(map(str, ans)))"]