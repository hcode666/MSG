["import heapq\n\ndef dijkstra(graph, start):\n    distances = {vertex: float('inf') for vertex in range(len(graph))}\n    distances[start] = 0\n    heap = [(0, start)]\n    while heap:\n        (current_distance, current_vertex) = heapq.heappop(heap)\n        if current_distance > distances[current_vertex]:\n            continue\n        for neighbor in graph[current_vertex]:\n            distance = current_distance + 1\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances\nfor _ in range(int(input())):\n    g = int(input())\n    graph = []\n    for i in range(g):\n        graph.append([int(x) - 1 for x in input().split()])\n    (m, i) = (10 ** 10, 0)\n    for start in range(g):\n        distances = dijkstra(graph, start)\n        minimal_distance = sum(distances.values())\n        if minimal_distance < m:\n            m = minimal_distance\n            i = start + 1\n    print(i, '{:.6f}'.format(m / g))", "from collections import deque\n\ndef getavg(s, al):\n    tot = 0\n    q = deque([[s, 0]])\n    vis = set([s])\n    while q:\n        (h, d) = q.popleft()\n        tot += d\n        for fri in al[h]:\n            if fri not in vis:\n                q.append([fri, d + 1])\n                vis.add(fri)\n    return tot\nfor tc in range(int(input())):\n    num = int(input())\n    adjlist = [0]\n    pop = -1\n    avgdist = 10000000\n    for i in range(num):\n        fri = list(map(int, input().split()))\n        adjlist.append(fri)\n    for i in range(1, num + 1):\n        avg = getavg(i, adjlist)\n        avg = avg / num\n        if avg < avgdist:\n            avgdist = avg\n            pop = i\n    print(pop, end=' ')\n    print('%.6f' % avgdist)", "g = int(input())\nfor _ in range(g):\n    n = int(input())\n    connections = {}\n    visitas = {}\n    distancia_a_amigos = {}\n    for i in range(1, n + 1):\n        connections[i] = list(map(int, input().split()))\n        visitas[i] = False\n        distancia_a_amigos[i] = 0\n    amigo_mas_popular = 1\n    promedio_mas_bajo = False\n    for i in range(1, n + 1):\n        visitas_i = visitas.copy()\n        visitas_i[i] = True\n        distancia_a_amigos_i = distancia_a_amigos.copy()\n        cola = [i]\n        suma = 0\n        suma_total = 0\n        while len(cola) > 0:\n            actual = cola.pop(0)\n            for j in connections[actual]:\n                if not visitas_i[j]:\n                    visitas_i[j] = True\n                    distancia_a_amigos_i[j] = distancia_a_amigos_i[actual] + 1\n                    suma_total += distancia_a_amigos_i[j]\n                    cola.append(j)\n        import decimal\n        promedio = decimal.Decimal(suma_total) / decimal.Decimal(n)\n        if promedio_mas_bajo == False or promedio < promedio_mas_bajo:\n            promedio_mas_bajo = promedio\n            amigo_mas_popular = i\n    print(amigo_mas_popular, round(promedio_mas_bajo, 6))", "from sys import stdin\nfrom collections import defaultdict, deque\nT = int(input())\nfor t in range(T):\n    g = {}\n    N = int(input())\n    for i in range(N):\n        g[i + 1] = list(map(int, input().split()))\n    popular = 1\n    popularcount = 1000000\n    for i in range(1, N + 1):\n        dist = [None for i in range(N)]\n        q = deque()\n        q.append(i)\n        dist[i - 1] = 0\n        while len(q) > 0:\n            current = q.popleft()\n            for neigh in g[current]:\n                if dist[neigh - 1] is None:\n                    dist[neigh - 1] = dist[current - 1] + 1\n                    q.append(neigh)\n        notiority = sum(dist) / N\n        if notiority < popularcount:\n            popularcount = notiority\n            popular = i\n    print(popular, end=' ')\n    print('%.6f' % popularcount)", "from sys import stdin\nfrom collections import defaultdict, deque\nT = int(input())\nfor t in range(T):\n    g = {}\n    N = int(input())\n    for i in range(N):\n        g[i + 1] = list(map(int, input().split()))\n    popular = 1\n    popularcount = 1000000\n    for i in range(1, N + 1):\n        dist = [None for i in range(N)]\n        q = deque()\n        q.append(i)\n        dist[i - 1] = 0\n        while len(q) > 0:\n            current = q.popleft()\n            for neigh in g[current]:\n                if dist[neigh - 1] is None:\n                    dist[neigh - 1] = dist[current - 1] + 1\n                    q.append(neigh)\n        notiority = sum(dist) / N\n        if notiority < popularcount:\n            popularcount = notiority\n            popular = i\n    print(popular, end=' ')\n    print('%.6f' % popularcount)", "from sys import stdin\nfrom collections import defaultdict, deque\nT = int(input())\nfor t in range(T):\n    g = {}\n    N = int(input())\n    for i in range(N):\n        g[i + 1] = list(map(int, input().split()))\n    popular = 1\n    popularcount = 1000000\n    for i in range(1, N + 1):\n        dist = [None for i in range(N)]\n        q = deque()\n        q.append(i)\n        dist[i - 1] = 0\n        while len(q) > 0:\n            current = q.popleft()\n            for neigh in g[current]:\n                if dist[neigh - 1] is None:\n                    dist[neigh - 1] = dist[current - 1] + 1\n                    q.append(neigh)\n        notiority = sum(dist) / N\n        if notiority < popularcount:\n            popularcount = notiority\n            popular = i\n    print(popular, end=' ')\n    print('%.6f' % popularcount)", "from sys import stdin\nfrom collections import defaultdict, deque\nT = int(input())\nfor t in range(T):\n    g = {}\n    N = int(input())\n    for i in range(N):\n        g[i + 1] = list(map(int, input().split()))\n    popular = 1\n    popularcount = 1000000\n    for i in range(1, N + 1):\n        dist = [None for i in range(N)]\n        q = deque()\n        q.append(i)\n        dist[i - 1] = 0\n        while len(q) > 0:\n            current = q.popleft()\n            for neigh in g[current]:\n                if dist[neigh - 1] is None:\n                    dist[neigh - 1] = dist[current - 1] + 1\n                    q.append(neigh)\n        notiority = sum(dist) / N\n        if notiority < popularcount:\n            popularcount = notiority\n            popular = i\n    print(popular, '{0:.6f}'.format(popularcount))", "from sys import stdin\nfrom collections import defaultdict, deque\ng = int(input())\n\ndef getDistancesToFriends(graph, start):\n    distances = [None] * (len(graph) + 1)\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        for neigh in graph[current]:\n            if distances[neigh] is None:\n                distances[neigh] = distances[current] + 1\n                queue.append(neigh)\n    return distances\nfor t in range(g):\n    n = int(input())\n    g = {}\n    for i in range(n):\n        g[i + 1] = list(map(int, input().split()))\n    frnd = 1\n    minDist = float('inf')\n    for i in range(1, n + 1):\n        dist = getDistancesToFriends(g, i)[1:]\n        avg = sum(dist) / len(dist)\n        if avg < minDist:\n            minDist = avg\n            frnd = i\n    print(frnd, '{0:.6f}'.format(minDist))", "def getDist(graph, start):\n    distances = [None] * (len(graph) + 1)\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        for neigh in graph[current]:\n            if distances[neigh] is None:\n                distances[neigh] = distances[current] + 1\n                queue.append(neigh)\n    return distances\nfor t in range(int(input())):\n    n = int(input())\n    gr = {}\n    for i in range(n):\n        gr[i + 1] = list(map(int, input().split()))\n    frnd = 1\n    minDist = float('inf')\n    for i in range(1, n + 1):\n        dist = getDist(gr, i)[1:]\n        avg = sum(dist) / len(dist)\n        if avg < minDist:\n            minDist = avg\n            frnd = i\n    print(frnd, '{0:.6f}'.format(minDist))", "def getDist(graph, start):\n    distances = [None] * (len(graph) + 1)\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        for neigh in graph[current]:\n            if distances[neigh] is None:\n                distances[neigh] = distances[current] + 1\n                queue.append(neigh)\n    return distances\nfor t in range(int(input())):\n    n = int(input())\n    gr = {}\n    for i in range(n):\n        gr[i + 1] = list(map(int, input().split()))\n    frnd = 1\n    minDist = float('inf')\n    for i in range(1, n + 1):\n        dist = getDist(gr, i)[1:]\n        avg = sum(dist) / len(dist)\n        if avg < minDist:\n            minDist = avg\n            frnd = i\n    print(frnd, '{0:.6f}'.format(minDist))", "tn = int(input())\nfor _ in range(tn):\n    n = int(input())\n    ar = dict()\n    for i in range(1, n + 1):\n        ar[i] = list(map(int, input().split()))\n    (mvsm, midx) = (-1, -1)\n    for i in range(1, n + 1):\n        visli = {i}\n        tdis = 0\n        queue = [(i, 0)]\n        while queue:\n            (nd, dis) = queue.pop(0)\n            tdis += dis\n            for x in ar[nd]:\n                if x not in visli:\n                    visli.add(x)\n                    queue.append((x, dis + 1))\n        if mvsm == -1:\n            mvsm = tdis\n            midx = i\n        elif mvsm > tdis:\n            mvsm = tdis\n            midx = i\n    print(midx, '{:.6f}'.format(mvsm / n))", "def getDistancesToFriends(graph, start):\n    distances = [None] * (len(graph) + 1)\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        for neigh in graph[current]:\n            if distances[neigh] is None:\n                distances[neigh] = distances[current] + 1\n                queue.append(neigh)\n    return distances\nt = input()\nfor c in range(0, int(t)):\n    n = int(input())\n    g = {}\n    for i in range(n):\n        g[i + 1] = list(map(int, input().split()))\n    frnd = 1\n    minDist = float('inf')\n    for i in range(1, n + 1):\n        dist = getDistancesToFriends(g, i)[1:]\n        avg = sum(dist) / len(dist)\n        if avg < minDist:\n            minDist = avg\n            frnd = i\n    print(frnd, '{0:.6f}'.format(minDist))", "g = int(input())\n\ndef getDistancesToFriends(graph, start):\n    distances = [None] * (len(graph) + 1)\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        for neigh in graph[current]:\n            if distances[neigh] is None:\n                distances[neigh] = distances[current] + 1\n                queue.append(neigh)\n    return distances\nfor t in range(g):\n    n = int(input())\n    g = {}\n    for i in range(n):\n        g[i + 1] = list(map(int, input().split()))\n    frnd = 1\n    minDist = float('inf')\n    for i in range(1, n + 1):\n        dist = getDistancesToFriends(g, i)[1:]\n        avg = sum(dist) / len(dist)\n        if avg < minDist:\n            minDist = avg\n            frnd = i\n    print(frnd, '{0:.6f}'.format(minDist))", "g = int(input())\n\ndef getDistancesToFriends(graph, start):\n    distances = [None] * (len(graph) + 1)\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        for neigh in graph[current]:\n            if distances[neigh] is None:\n                distances[neigh] = distances[current] + 1\n                queue.append(neigh)\n    return distances\nfor t in range(g):\n    n = int(input())\n    g = {}\n    for i in range(n):\n        g[i + 1] = list(map(int, input().split()))\n    frnd = 1\n    minDist = float('inf')\n    for i in range(1, n + 1):\n        dist = getDistancesToFriends(g, i)[1:]\n        avg = sum(dist) / len(dist)\n        if avg < minDist:\n            minDist = avg\n            frnd = i\n    print(frnd, '{0:.6f}'.format(minDist))", "g = int(input())\n\ndef getDistancesToFriends(graph, start):\n    distances = [None] * (len(graph) + 1)\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        for neighbor in graph[current]:\n            if distances[neighbor] is None:\n                distances[neighbor] = distances[current] + 1\n                queue.append(neighbor)\n    return distances\nfor t in range(g):\n    n = int(input())\n    g = {}\n    for i in range(n):\n        g[i + 1] = list(map(int, input().split()))\n    imin = 1\n    min = 2000\n    for i in range(1, n + 1):\n        a = getDistancesToFriends(g, i)[1:]\n        avg = sum(a) / len(a)\n        if avg < min:\n            min = avg\n            imin = i\n    print(imin, '{0:.6f}'.format(min))", "g = int(input())\n\ndef getDistancesToFriends(graph, start):\n    distances = [None] * (len(graph) + 1)\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        for neighbor in graph[current]:\n            if distances[neighbor] is None:\n                distances[neighbor] = distances[current] + 1\n                queue.append(neighbor)\n    return distances\nfor t in range(g):\n    n = int(input())\n    g = {}\n    for i in range(n):\n        g[i + 1] = list(map(int, input().split()))\n    imin = 1\n    min = 2000\n    for i in range(1, n + 1):\n        a = getDistancesToFriends(g, i)[1:]\n        avg = sum(a) / len(a)\n        if avg < min:\n            min = avg\n            imin = i\n    print(imin, '{0:.6f}'.format(min))", "g = int(input())\n\ndef getDistancesToFriends(graph, start):\n    distances = [None] * (len(graph) + 1)\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        for neighbor in graph[current]:\n            if distances[neighbor] is None:\n                distances[neighbor] = distances[current] + 1\n                queue.append(neighbor)\n    return distances\nfor t in range(g):\n    n = int(input())\n    g = {}\n    for i in range(n):\n        g[i + 1] = list(map(int, input().split()))\n    imin = 1\n    min = 2000\n    for i in range(1, n + 1):\n        a = getDistancesToFriends(g, i)[1:]\n        avg = sum(a) / len(a)\n        if avg < min:\n            min = avg\n            imin = i\n    print(imin, '{0:.6f}'.format(min))", "import math\n\ndef getShortestDistance(adjList, popularNode):\n    queue = [popularNode]\n    visited = [False for i in range(len(adjList))]\n    distance = [-1 for i in range(len(adjList))]\n    curr = 0\n    while len(queue) > 0:\n        size = len(queue)\n        for i in range(size):\n            frontNode = queue.pop(0)\n            distance[frontNode] = curr\n            visited[frontNode] = True\n            for node in adjList[frontNode]:\n                if not visited[node]:\n                    visited[node] = True\n                    queue.append(node)\n        curr += 1\n    return distance\ngroups = int(input())\nwhile groups > 0:\n    groups -= 1\n    nodes = int(input())\n    adjList = [[] for i in range(nodes + 1)]\n    popularNode = -1\n    minAvg = math.inf\n    for i in range(1, nodes + 1):\n        adjList[i] = list(map(int, input().split()))\n    for i in range(1, nodes + 1):\n        distance = getShortestDistance(adjList, i)\n        avg = sum(distance[1:]) / nodes\n        if avg < minAvg:\n            minAvg = avg\n            popularNode = i\n    print(popularNode, '{:.6f}'.format(minAvg))", "g = int(input())\n\ndef getDistancesToFriends(graph, start):\n    distances = [None] * (len(graph) + 1)\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        for neighbor in graph[current]:\n            if distances[neighbor] is None:\n                distances[neighbor] = distances[current] + 1\n                queue.append(neighbor)\n    return distances\nfor t in range(g):\n    n = int(input())\n    g = {}\n    for i in range(n):\n        g[i + 1] = list(map(int, input().split()))\n    imin = 1\n    min = 2000\n    for i in range(1, n + 1):\n        a = getDistancesToFriends(g, i)[1:]\n        avg = sum(a) / len(a)\n        if avg < min:\n            min = avg\n            imin = i\n    print(imin, '{0:.6f}'.format(min))", "import sys\nif len(sys.argv) >= 2:\n    sys.stdin = open(sys.argv[1])\n\ndef dijkstra(adj, src):\n    n = len(adj)\n    dist = [float('inf')] * n\n    dist[src] = 0\n    q = [src]\n    while q:\n        u = q.pop(0)\n        for v in adj[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    return dist\n\ndef avg(adj, src):\n    dist = dijkstra(adj, src)\n    _sum = 0\n    for i in range(1, len(dist)):\n        _sum += dist[i]\n    return _sum / (len(dist) - 1)\n\ndef solve():\n    n = int(input())\n    adj = [set() for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        a = input().split()\n        adj[i] = set(map(int, a))\n    _min = 1000000000.0\n    friend = 1\n    for i in range(1, n + 1):\n        val = avg(adj, i)\n        if val < _min:\n            _min = val\n            friend = i if friend else friend\n    print(friend, f'{_min:.6f}')\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "G = int(input())\ntf = [0] * G\nm = []\nfor g in range(0, G):\n    tf[g] = int(input())\n    m.append({})\n    for i in range(0, tf[g]):\n        m[g].update({i + 1: [int(p) for p in input().split()]})\nfor grp in range(0, G):\n    dict1 = m[grp]\n    u = []\n    mmember = 1\n    for member in range(0, tf[grp]):\n        visited = [0] * tf[grp]\n        visited[member] = 1\n        dist = 0\n        q = []\n        time = 1\n        q.append([member, time])\n        while 0 in visited:\n            (o, y) = q.pop(0)\n            for v in dict1[o + 1]:\n                if visited[v - 1] == 0:\n                    visited[v - 1] = 1\n                    q.append([v - 1, y + 1])\n                    dist = dist + y\n        u.append(dist)\n    ans = u.index(min(u)) + 1\n    print(ans, '{:.6f}'.format(round(min(u) / tf[grp], 6)))", "from collections import deque\n\ndef bfs(i, adj, vis, n):\n    q = deque()\n    q.append(i)\n    vis[i] = 1\n    dist = 0\n    notoreity = 0\n    while len(q) != 0:\n        for i in range(len(q)):\n            t = q.popleft()\n            notoreity += dist\n            for val in adj[t]:\n                if not vis[val]:\n                    vis[val] = 1\n                    q.append(val)\n        dist += 1\n    return notoreity / n\n\ndef solve(adj, n):\n    vis = [0 for _ in range(n)]\n    nototreity = bfs(0, adj, vis, n)\n    fr = 1\n    for i in range(1, n):\n        vis = [0 for _ in range(n)]\n        _notoreity = bfs(i, adj, vis, n)\n        if _notoreity < nototreity:\n            nototreity = _notoreity\n            fr = i + 1\n    print(fr, '%.6f' % nototreity)\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        l = list(map(int, input().split()))\n        for val in l:\n            adj[i].append(val - 1)\n    solve(adj, n)", "T = int(input())\nfor x in range(T):\n    n = int(input())\n    ar = dict()\n    for i in range(1, n + 1):\n        ar[i] = list(map(int, input().split()))\n    (mvsm, midx) = (-1, -1)\n    for i in range(1, n + 1):\n        visli = {i}\n        tdis = 0\n        queue = [(i, 0)]\n        while queue:\n            (nd, dis) = queue.pop(0)\n            tdis += dis\n            for j in ar[nd]:\n                if j not in visli:\n                    visli.add(j)\n                    queue.append((j, dis + 1))\n        if mvsm == -1:\n            mvsm = tdis\n            midx = i\n        elif mvsm > tdis:\n            mvsm = tdis\n            midx = i\n    print(midx, '{:.6f}'.format(mvsm / n))", "tn = int(input())\nfor _ in range(tn):\n    n = int(input())\n    ar = dict()\n    for i in range(1, n + 1):\n        ar[i] = list(map(int, input().split()))\n    (mvsm, midx) = (-1, -1)\n    for i in range(1, n + 1):\n        visli = {i}\n        tdis = 0\n        queue = [(i, 0)]\n        while queue:\n            (nd, dis) = queue.pop(0)\n            tdis += dis\n            for x in ar[nd]:\n                if x not in visli:\n                    visli.add(x)\n                    queue.append((x, dis + 1))\n        if mvsm == -1:\n            mvsm = tdis\n            midx = i\n        elif mvsm > tdis:\n            mvsm = tdis\n            midx = i\n    print(midx, '{:.6f}'.format(mvsm / n))", "tn = int(input())\nfor _ in range(tn):\n    n = int(input())\n    ar = dict()\n    for i in range(1, n + 1):\n        ar[i] = list(map(int, input().split()))\n    (mvsm, midx) = (-1, -1)\n    for i in range(1, n + 1):\n        visli = {i}\n        tdis = 0\n        queue = [(i, 0)]\n        while queue:\n            (nd, dis) = queue.pop(0)\n            tdis += dis\n            for x in ar[nd]:\n                if x not in visli:\n                    visli.add(x)\n                    queue.append((x, dis + 1))\n        if mvsm == -1:\n            mvsm = tdis\n            midx = i\n        elif mvsm > tdis:\n            mvsm = tdis\n            midx = i\n    print(midx, '{:.6f}'.format(mvsm / n))", "tn = int(input())\nfor _ in range(tn):\n    n = int(input())\n    ar = dict()\n    for i in range(1, n + 1):\n        ar[i] = list(map(int, input().split()))\n    (mvsm, midx) = (-1, -1)\n    for i in range(1, n + 1):\n        visli = {i}\n        tdis = 0\n        queue = [(i, 0)]\n        while queue:\n            (nd, dis) = queue.pop(0)\n            tdis += dis\n            for x in ar[nd]:\n                if x not in visli:\n                    visli.add(x)\n                    queue.append((x, dis + 1))\n        if mvsm == -1:\n            mvsm = tdis\n            midx = i\n        elif mvsm > tdis:\n            mvsm = tdis\n            midx = i\n    print(midx, '{:.6f}'.format(mvsm / n))", "tn = int(input())\nfor _ in range(tn):\n    n = int(input())\n    ar = dict()\n    for i in range(1, n + 1):\n        ar[i] = list(map(int, input().split()))\n    (mvsm, midx) = (-1, -1)\n    for i in range(1, n + 1):\n        visli = {i}\n        tdis = 0\n        queue = [(i, 0)]\n        while queue:\n            (nd, dis) = queue.pop(0)\n            tdis += dis\n            for x in ar[nd]:\n                if x not in visli:\n                    visli.add(x)\n                    queue.append((x, dis + 1))\n        if mvsm == -1:\n            mvsm = tdis\n            midx = i\n        elif mvsm > tdis:\n            mvsm = tdis\n            midx = i\n    print(midx, '{:.6f}'.format(mvsm / n))", "import sys\nif len(sys.argv) >= 2:\n    sys.stdin = open(sys.argv[1])\n\ndef dijkstra(adj, src):\n    n = len(adj)\n    dist = [float('inf')] * n\n    dist[src] = 0\n    q = [src]\n    while q:\n        u = q.pop(0)\n        for v in adj[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    return dist\n\ndef avg(adj, src):\n    dist = dijkstra(adj, src)\n    _sum = 0\n    for i in range(1, len(dist)):\n        _sum += dist[i]\n    return _sum / (len(dist) - 1)\n\ndef solve():\n    n = int(input())\n    adj = [set() for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        a = input().split()\n        adj[i] = set(map(int, a))\n    _min = 1000000000.0\n    friend = 1\n    for i in range(1, n + 1):\n        val = avg(adj, i)\n        if val < _min:\n            _min = val\n            friend = i if friend else friend\n    print(friend, f'{_min:.6f}')\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nif len(sys.argv) >= 2:\n    sys.stdin = open(sys.argv[1])\n\ndef dijkstra(adj, src):\n    n = len(adj)\n    dist = [float('inf')] * n\n    dist[src] = 0\n    q = [src]\n    visited = [False] * n\n    visited[src] = True\n    while q:\n        u = q.pop(0)\n        for v in adj[u]:\n            if visited[v]:\n                continue\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n                visited[v] = True\n    return dist\n\ndef avg(adj, src):\n    dist = dijkstra(adj, src)\n    _sum = 0\n    for i in range(1, len(dist)):\n        _sum += dist[i]\n    return _sum / (len(dist) - 1)\n\ndef solve():\n    n = int(input())\n    adj = [set() for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        a = input().split()\n        adj[i] = set(map(int, a))\n    _min = 1000000000.0\n    friend = 1\n    for i in range(1, n + 1):\n        val = avg(adj, i)\n        if val < _min:\n            _min = val\n            friend = i if friend else friend\n    print(friend, f'{_min:.6f}')\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import deque\n\ndef find_avg_dist(adj, u):\n    adj_size = len(adj)\n    visited = [0] * adj_size\n    distance = [0] * adj_size\n    Q = deque([u])\n    visited[u] = 1\n    while len(Q):\n        x = Q.popleft()\n        for e in adj[x]:\n            if not visited[e]:\n                distance[e] = distance[x] + 1\n                visited[e] = 1\n                Q.append(e)\n    return sum(distance)\nfor _ in range(int(input())):\n    N = int(input())\n    adj = {}\n    for i in range(N):\n        adj[i] = list(map(lambda x: int(x) - 1, input().split()))\n    avg_vals = [find_avg_dist(adj, i) for i in range(N)]\n    a = min(avg_vals)\n    print('{} {:.6f}'.format(avg_vals.index(a) + 1, a / N))", "from collections import deque\n\ndef solve(adj, i):\n    seen = {i: 0}\n    queue = deque([i])\n    total = 0\n    while len(queue) > 0:\n        node = queue.popleft()\n        dist = seen[node]\n        for n in adj[node]:\n            if n not in seen:\n                seen[n] = dist + 1\n                total += dist + 1\n                queue.append(n)\n    return total\ngroups = int(input())\nfor _ in range(groups):\n    n = int(input())\n    adj = dict()\n    for i in range(1, n + 1):\n        adj[i] = list(map(int, input().split()))\n    distances = [solve(adj, i) for i in range(1, n + 1)]\n    min_dist = min(distances)\n    min_index = distances.index(min_dist) + 1\n    print(min_index, f'{min_dist / n:.6f}')", "from collections import deque\n\ndef solve(adj, i):\n    seen = {i: 0}\n    queue = deque([i])\n    total = 0\n    while len(queue) > 0:\n        node = queue.popleft()\n        dist = seen[node]\n        for n in adj[node]:\n            if n not in seen:\n                seen[n] = dist + 1\n                total += dist + 1\n                queue.append(n)\n    return total\ngroups = int(input())\nfor _ in range(groups):\n    n = int(input())\n    adj = dict()\n    for i in range(1, n + 1):\n        adj[i] = list(map(int, input().split()))\n    distances = [solve(adj, i) for i in range(1, n + 1)]\n    min_dist = min(distances)\n    min_index = distances.index(min_dist) + 1\n    print(min_index, f'{round(min_dist / n, 6):.6f}')", "def bfs(source, adj):\n    visted = set()\n    visted.add(source)\n    queue = []\n    queue.append((source, 0))\n    s = 0\n    while queue:\n        (src, dist) = queue.pop(0)\n        for k in adj[src]:\n            if k not in visted:\n                visted.add(k)\n                queue.append((k, dist + 1))\n                s += dist + 1\n    return s\ngroup = int(input())\nfor i in range(group):\n    N = int(input())\n    friends = {}\n    for j in range(1, N + 1):\n        friends[j] = list(map(int, input().split(' ')))\n    distance = []\n    for j in range(1, N + 1):\n        distance.append(bfs(j, friends))\n    ans = distance.index(min(distance)) + 1\n    mindistavg = min(distance) / N\n    avg = round(mindistavg, 6)\n    print(ans, '{:.6f}'.format(mindistavg))", "def bfs(start, friend_dict):\n    visited = set()\n    queue = [(start, 0)]\n    visited.add(start)\n    s = 0\n    while queue:\n        (friend, dist) = queue.pop(0)\n        s += dist\n        for x in friend_dict[friend]:\n            if x not in visited:\n                queue.append((x, dist + 1))\n                visited.add(x)\n    return s\nfor _ in range(int(input())):\n    n = int(input())\n    friend_dict = {}\n    for i in range(1, n + 1):\n        li = list(map(int, input().split()))\n        friend_dict[i] = li\n    mini = float('inf')\n    at_source = None\n    for i in range(1, n + 1):\n        if bfs(i, friend_dict) < mini:\n            mini = bfs(i, friend_dict)\n            at_source = i\n    res = mini / n\n    res = round(res, 6)\n    print(at_source, f'{res:.6f}')", "def bfs(source, adj):\n    visted = set()\n    visted.add(source)\n    queue = []\n    queue.append((source, 0))\n    s = 0\n    while queue:\n        (src, dist) = queue.pop(0)\n        for k in adj[src]:\n            if k not in visted:\n                visted.add(k)\n                queue.append((k, dist + 1))\n                s += dist + 1\n    return s\ngroup = int(input())\nfor i in range(group):\n    N = int(input())\n    friends = {}\n    for j in range(1, N + 1):\n        friends[j] = list(map(int, input().split(' ')))\n    distance = []\n    for j in range(1, N + 1):\n        distance.append(bfs(j, friends))\n    ans = distance.index(min(distance)) + 1\n    mindistavg = min(distance) / N\n    avg = round(mindistavg, 6)\n    print(ans, '{:.6f}'.format(mindistavg))", "def bfs(source, adj):\n    visted = set()\n    visted.add(source)\n    queue = []\n    queue.append((source, 0))\n    s = 0\n    while queue:\n        (src, dist) = queue.pop(0)\n        for k in adj[src]:\n            if k not in visted:\n                visted.add(k)\n                queue.append((k, dist + 1))\n                s += dist + 1\n    return s\ngroup = int(input())\nfor i in range(group):\n    N = int(input())\n    friends = {}\n    for j in range(1, N + 1):\n        friends[j] = list(map(int, input().split(' ')))\n    distance = []\n    for j in range(1, N + 1):\n        distance.append(bfs(j, friends))\n    ans = distance.index(min(distance)) + 1\n    mindistavg = min(distance) / N\n    avg = round(mindistavg, 6)\n    print(ans, '{:.6f}'.format(mindistavg))", "def bfs(source, adj):\n    visted = set()\n    visted.add(source)\n    queue = []\n    queue.append((source, 0))\n    s = 0\n    while queue:\n        (src, dist) = queue.pop(0)\n        for k in adj[src]:\n            if k not in visted:\n                visted.add(k)\n                queue.append((k, dist + 1))\n                s += dist + 1\n    return s\ngroup = int(input())\nfor i in range(group):\n    N = int(input())\n    friends = {}\n    for j in range(1, N + 1):\n        friends[j] = list(map(int, input().split(' ')))\n    distance = []\n    for j in range(1, N + 1):\n        distance.append(bfs(j, friends))\n    ans = distance.index(min(distance)) + 1\n    mindistavg = min(distance) / N\n    avg = round(mindistavg, 6)\n    print(ans, '{:.6f}'.format(mindistavg))", "def vamsi(adj, n, i):\n    q = []\n    used = [0] * (n + 1)\n    d = [0] * (n + 1)\n    p = [0] * (n + 1)\n    s = i\n    q.append(s)\n    used[s] = 1\n    p[s] = -1\n    while len(q) != 0:\n        v = q[0]\n        del q[0]\n        for u in adj[v]:\n            if used[u] == 0:\n                used[u] = 1\n                q.append(u)\n                d[u] = d[v] + 1\n                p[u] = v\n    return d\nimport math\nfor _ in range(int(input())):\n    n = int(input())\n    adj = {}\n    for i in range(1, n + 1):\n        l = list(map(int, input().split()))\n        adj[i] = l\n    s = math.inf\n    s1 = 0\n    for i in range(1, n + 1):\n        k = vamsi(adj, n, i)\n        if k.count(0) == 2 and sum(k) / n < s:\n            s = min(s, sum(k) / n)\n            s1 = i\n    print('{} {:.6f}'.format(s1, s))", "def bfs(source, adj):\n    visted = set()\n    visted.add(source)\n    queue = []\n    queue.append((source, 0))\n    s = 0\n    while queue:\n        (src, dist) = queue.pop(0)\n        for k in adj[src]:\n            if k not in visted:\n                visted.add(k)\n                queue.append((k, dist + 1))\n                s += dist + 1\n    return s\ngroup = int(input())\nfor i in range(group):\n    N = int(input())\n    friends = {}\n    for j in range(1, N + 1):\n        friends[j] = list(map(int, input().split(' ')))\n    distance = []\n    for j in range(1, N + 1):\n        distance.append(bfs(j, friends))\n    ans = distance.index(min(distance)) + 1\n    mindistavg = min(distance) / N\n    print(ans, '{:.6f}'.format(mindistavg))", "def bfs(source, adj):\n    visted = set()\n    visted.add(source)\n    queue = []\n    queue.append((source, 0))\n    s = 0\n    while queue:\n        (src, dist) = queue.pop(0)\n        for k in adj[src]:\n            if k not in visted:\n                visted.add(k)\n                queue.append((k, dist + 1))\n                s += dist + 1\n    return s\ngroup = int(input())\nfor i in range(group):\n    N = int(input())\n    friends = {}\n    for j in range(1, N + 1):\n        friends[j] = list(map(int, input().split(' ')))\n    distance = []\n    for j in range(1, N + 1):\n        distance.append(bfs(j, friends))\n    ans = distance.index(min(distance)) + 1\n    mindistavg = min(distance) / N\n    avg = round(mindistavg, 6)\n    print(ans, '{:.6f}'.format(mindistavg))", "def check(visited):\n    for i in visited:\n        if i == 0:\n            return False\n    return True\nG = int(input())\ntf = [0] * G\nm = []\nfor g in range(0, G):\n    tf[g] = int(input())\n    m.append({})\n    for i in range(0, tf[g]):\n        m[g].update({i + 1: [int(p) for p in input().split()]})\nfor grp in range(0, G):\n    dict1 = m[grp]\n    u = []\n    mmember = 1\n    for member in range(0, tf[grp]):\n        visited = [0] * tf[grp]\n        visited[member] = 1\n        dist = 0\n        q = []\n        time = 1\n        q.append([member, time])\n        while check(visited) == False:\n            (o, y) = q.pop(0)\n            for v in dict1[o + 1]:\n                if visited[v - 1] == 0:\n                    visited[v - 1] = 1\n                    q.append([v - 1, y + 1])\n                    dist = dist + y\n        u.append(dist)\n    ans = u.index(min(u)) + 1\n    print(ans, '{:.6f}'.format(round(min(u) / tf[grp], 6)))", "def bfs(source, adj):\n    visited = set()\n    visited.add(source)\n    queue = []\n    queue.append((source, 0))\n    s = 0\n    while queue:\n        (curr, dist) = queue.pop(0)\n        for node in adj[curr]:\n            if node not in visited:\n                visited.add(node)\n                queue.append((node, dist + 1))\n                s += dist + 1\n    return s\nfor _ in range(int(input())):\n    n = int(input())\n    friends = {}\n    for i in range(1, n + 1):\n        friends[i] = tuple(map(int, input().split()))\n    distance = []\n    for i in range(1, n + 1):\n        distance.append(bfs(i, friends))\n    most_popular = distance.index(min(distance)) + 1\n    f = min(distance) / n\n    average = round(f, 6)\n    print(most_popular, '{:.6f}'.format(f))", "def bfs(source, adj):\n    visited = set()\n    visited.add(source)\n    queue = []\n    queue.append((source, 0))\n    s = 0\n    while queue:\n        (curr, dist) = queue.pop(0)\n        for node in adj[curr]:\n            if node not in visited:\n                visited.add(node)\n                queue.append((node, dist + 1))\n                s += dist + 1\n    return s\nfor _ in range(int(input())):\n    n = int(input())\n    friends = {}\n    for i in range(1, n + 1):\n        friends[i] = tuple(map(int, input().split()))\n    distance = []\n    for i in range(1, n + 1):\n        distance.append(bfs(i, friends))\n    most_popular = distance.index(min(distance)) + 1\n    f = min(distance) / n\n    average = round(f, 6)\n    print(most_popular, '{:.6f}'.format(f))", "class Connections:\n\n    def __init__(self, n):\n        self.num = n\n        self.friends = {}\n        self.lst = []\n        self.social()\n        self.length()\n\n    def social(self):\n        for i in range(1, self.num + 1):\n            self.friends[i] = tuple(map(int, input().split()))\n\n    def search(self, vec):\n        visited = set()\n        visited.add(vec)\n        queue = [(vec, 0)]\n        s = 0\n        while queue:\n            q = queue[0]\n            queue.pop(0)\n            for i in self.friends[q[0]]:\n                if i not in visited:\n                    queue.append((i, q[1] + 1))\n                    visited.add(i)\n                    s += q[1] + 1\n        return s\n\n    def length(self):\n        for i in range(1, self.num + 1):\n            self.lst.append(self.search(i))\nT = int(input())\nfor _ in range(T):\n    con = Connections(int(input()))\n    x = min(con.lst)\n    i = con.lst.index(x) + 1\n    print(i, '{:.6f}'.format(round(x / con.num, 6)))", "class Connections:\n\n    def __init__(self, n):\n        self.num = n\n        self.friends = {}\n        self.lst = []\n        self.social()\n        self.length()\n\n    def social(self):\n        for i in range(1, self.num + 1):\n            self.friends[i] = tuple(map(int, input().split()))\n\n    def search(self, vec):\n        visited = set()\n        visited.add(vec)\n        queue = [(vec, 0)]\n        s = 0\n        while queue:\n            q = queue[0]\n            queue.pop(0)\n            for i in self.friends[q[0]]:\n                if i not in visited:\n                    queue.append((i, q[1] + 1))\n                    visited.add(i)\n                    s += q[1] + 1\n        return s\n\n    def length(self):\n        for i in range(1, self.num + 1):\n            self.lst.append(self.search(i))\nT = int(input())\nfor _ in range(T):\n    con = Connections(int(input()))\n    x = min(con.lst)\n    i = con.lst.index(x) + 1\n    print(i, '{:.6f}'.format(round(x / con.num, 6)))", "class Graph:\n\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for i in range(V + 1)]\n\n    def addEdge(self, v, w):\n        self.adj[v].append(w)\n        self.adj[w].append(v)\n\n    def BFS(self, i):\n        level = ['useless']\n        for j in range(1, self.V + 1):\n            level.append(-1)\n        Q = []\n        level[i] = 0\n        Q.append(i)\n        while Q:\n            j = Q[0]\n            del Q[0]\n            for k in self.adj[j]:\n                if level[k] == -1:\n                    level[k] = 1 + level[j]\n                    Q.append(k)\n        return level\nt = int(input())\nfor i in range(t):\n    N = int(input())\n    g = Graph(N)\n    for i in range(1, N + 1):\n        arr = [int(p) for p in input().split()]\n        g.adj[i] = arr\n    countarr = ['useless']\n    for i in range(1, N + 1):\n        countarr.append(0)\n    for i in range(1, N + 1):\n        arrlist = g.BFS(i)\n        countarr[i] = sum(arrlist[1:]) / N\n    maxx = min(countarr[1:])\n    ind = countarr.index(maxx)\n    arr2 = g.BFS(ind)\n    ans = sum(arr2[1:]) / N\n    print(ind, '{:.6f}'.format(ans))", "def check(visited):\n    for i in visited:\n        if i == 0:\n            return False\n    return True\nG = int(input())\ntf = [0] * G\nm = []\nfor g in range(0, G):\n    tf[g] = int(input())\n    m.append({})\n    for i in range(0, tf[g]):\n        m[g].update({i + 1: [int(p) for p in input().split()]})\nfor grp in range(0, G):\n    dict1 = m[grp]\n    u = []\n    mmember = 1\n    for member in range(0, tf[grp]):\n        visited = [0] * tf[grp]\n        visited[member] = 1\n        dist = 0\n        q = []\n        time = 1\n        q.append([member, time])\n        while check(visited) == False:\n            (o, y) = q.pop(0)\n            for v in dict1[o + 1]:\n                if visited[v - 1] == 0:\n                    visited[v - 1] = 1\n                    q.append([v - 1, y + 1])\n                    dist = dist + y\n        u.append(dist)\n    ans = u.index(min(u)) + 1\n    print(ans, '{:.6f}'.format(round(min(u) / tf[grp], 6)))", "class Connections:\n\n    def __init__(self, n):\n        self.num = n\n        self.friends = {}\n        self.lst = []\n        self.social()\n        self.length()\n\n    def social(self):\n        for i in range(1, self.num + 1):\n            self.friends[i] = tuple(map(int, input().split()))\n\n    def search(self, vec):\n        visited = set()\n        visited.add(vec)\n        queue = [(vec, 0)]\n        s = 0\n        while queue:\n            q = queue[0]\n            queue.pop(0)\n            for i in self.friends[q[0]]:\n                if i not in visited:\n                    queue.append((i, q[1] + 1))\n                    visited.add(i)\n                    s += q[1] + 1\n        return s\n\n    def length(self):\n        for i in range(1, self.num + 1):\n            self.lst.append(self.search(i))\nT = int(input())\nfor _ in range(T):\n    con = Connections(int(input()))\n    x = min(con.lst)\n    i = con.lst.index(x) + 1\n    print(i, '{:.6f}'.format(round(x / con.num, 6)))", "class Connections:\n\n    def __init__(self, n):\n        self.num = n\n        self.friends = {}\n        self.lst = []\n        self.social()\n        self.length()\n\n    def social(self):\n        for i in range(1, self.num + 1):\n            self.friends[i] = tuple(map(int, input().split()))\n\n    def search(self, vec):\n        visited = set()\n        visited.add(vec)\n        queue = [(vec, 0)]\n        s = 0\n        while queue:\n            q = queue[0]\n            queue.pop(0)\n            for i in self.friends[q[0]]:\n                if i not in visited:\n                    queue.append((i, q[1] + 1))\n                    visited.add(i)\n                    s += q[1] + 1\n        return s\n\n    def length(self):\n        for i in range(1, self.num + 1):\n            self.lst.append(self.search(i))\nT = int(input())\nfor _ in range(T):\n    con = Connections(int(input()))\n    x = min(con.lst)\n    i = con.lst.index(x) + 1\n    print(i, '{:.6f}'.format(round(x / con.num, 6)))", "class Connections:\n\n    def __init__(self, n):\n        self.num = n\n        self.friends = {}\n        self.lst = []\n        self.social()\n        self.length()\n\n    def social(self):\n        for i in range(1, self.num + 1):\n            self.friends[i] = tuple(map(int, input().split()))\n\n    def search(self, vec):\n        visited = set()\n        visited.add(vec)\n        queue = [(vec, 0)]\n        s = 0\n        while queue:\n            q = queue[0]\n            queue.pop(0)\n            for i in self.friends[q[0]]:\n                if i not in visited:\n                    queue.append((i, q[1] + 1))\n                    visited.add(i)\n                    s += q[1] + 1\n        return s\n\n    def length(self):\n        for i in range(1, self.num + 1):\n            self.lst.append(self.search(i))\nT = int(input())\nfor _ in range(T):\n    con = Connections(int(input()))\n    x = min(con.lst)\n    i = con.lst.index(x) + 1\n    print(i, '{:.6f}'.format(round(x / con.num, 6)))", "class Connections:\n\n    def __init__(self, n):\n        self.num = n\n        self.friends = {}\n        self.lst = []\n        self.social()\n        self.length()\n\n    def social(self):\n        for i in range(1, self.num + 1):\n            self.friends[i] = tuple(map(int, input().split()))\n\n    def search(self, vec):\n        visited = set()\n        visited.add(vec)\n        queue = [(vec, 0)]\n        s = 0\n        while queue:\n            q = queue[0]\n            queue.pop(0)\n            for i in self.friends[q[0]]:\n                if i not in visited:\n                    queue.append((i, q[1] + 1))\n                    visited.add(i)\n                    s += q[1] + 1\n        return s\n\n    def length(self):\n        for i in range(1, self.num + 1):\n            self.lst.append(self.search(i))\nT = int(input())\nfor _ in range(T):\n    con = Connections(int(input()))\n    x = min(con.lst)\n    i = con.lst.index(x) + 1\n    print(i, '{:.6f}'.format(round(x / con.num, 6)))", "from typing import List\nfrom collections import deque\n\nclass Node:\n    value: int\n    friends: 'List[Node]'\n\n    def __init__(self, value: int):\n        self.value = value\n        self.friends = []\n\ndef bfs(nodes: List[Node], start_node: int, n: int):\n    queue = deque([nodes[start_node]])\n    distances = [-1 for _ in range(n)]\n    distances[start_node] = 0\n    while queue:\n        node = queue.popleft()\n        for friend in node.friends:\n            if distances[friend.value] < 0:\n                distances[friend.value] = distances[node.value] + 1\n                queue.append(friend)\n    return distances\n\ndef find_most_popular(nodes: List[Node], n: int) -> (int, float):\n    min_distance: float = 1000000000.0\n    min_distance_idx: int = -1\n    for i in range(1, n):\n        node = nodes[i]\n        distances = bfs(nodes, i, n)\n        distance = sum(distances[1:]) / (n - 1)\n        if distance < min_distance:\n            min_distance = distance\n            min_distance_idx = i\n    return (min_distance_idx, min_distance)\n\ndef main():\n    groups = int(input())\n    for _ in range(groups):\n        n = int(input())\n        if n > 1:\n            n += 1\n            nodes = [Node(i) for i in range(n)]\n            for i in range(1, n):\n                friends = [int(f) for f in input().split()]\n                nodes[i].friends.extend([nodes[f] for f in friends])\n            (popular_node, min_distance) = find_most_popular(nodes, n)\n            print(f'{popular_node} {min_distance:.6f}')\n        else:\n            input()\n            print('1 0')\nmain()", "class Connections:\n\n    def __init__(self, n):\n        self.num = n\n        self.friends = {}\n        self.lst = []\n        self.social()\n        self.length()\n\n    def social(self):\n        for i in range(1, self.num + 1):\n            self.friends[i] = tuple(map(int, input().split()))\n\n    def search(self, vec):\n        visited = set()\n        visited.add(vec)\n        queue = [(vec, 0)]\n        s = 0\n        while queue:\n            q = queue[0]\n            queue.pop(0)\n            for i in self.friends[q[0]]:\n                if i not in visited:\n                    queue.append((i, q[1] + 1))\n                    visited.add(i)\n                    s += q[1] + 1\n        return s\n\n    def length(self):\n        for i in range(1, self.num + 1):\n            self.lst.append(self.search(i))\nT = int(input())\nfor _ in range(T):\n    con = Connections(int(input()))\n    x = min(con.lst)\n    i = con.lst.index(x) + 1\n    print(i, '{:.6f}'.format(round(x / con.num, 6)))"]