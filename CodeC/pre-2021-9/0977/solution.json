["import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    heap = list(map(int, input().split()))\n    dic = {}\n    ans = 0\n    for i in heap:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    temp = []\n    for i in dic:\n        heapq.heappush(temp, [-dic[i], i])\n    while temp:\n        if len(temp) > 1:\n            mx = heapq.heappop(temp)\n            mx2 = heapq.heappop(temp)\n            if mx[0] != -1:\n                if mx2[0] != -1:\n                    heapq.heappush(temp, [mx2[0] + 1, mx2[1]])\n                heapq.heappush(temp, [mx[0] + 1, mx[1]])\n                ans += 1\n            else:\n                ans += 1\n        else:\n            mn = heapq.heappop(temp)\n            if mn[0] != -1:\n                heapq.heappush(temp, [mn[0] + 1, mn[1]])\n                ans += 1\n            else:\n                ans += 1\n    print(ans)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    heap = list(map(int, input().split()))\n    dic = {}\n    ans = 0\n    for i in heap:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    temp = []\n    for i in dic:\n        heapq.heappush(temp, [-dic[i], i])\n    while temp:\n        if len(temp) > 1:\n            mx = heapq.heappop(temp)\n            mx2 = heapq.heappop(temp)\n            if mx[0] != -1:\n                if mx2[0] != -1:\n                    heapq.heappush(temp, [mx2[0] + 1, mx2[1]])\n                heapq.heappush(temp, [mx[0] + 1, mx[1]])\n                ans += 1\n            else:\n                ans += 1\n        else:\n            mn = heapq.heappop(temp)\n            if mn[0] != -1:\n                heapq.heappush(temp, [mn[0] + 1, mn[1]])\n                ans += 1\n            else:\n                ans += 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    count = 1\n    flag = 0\n    for i in range(len(arr) - 1):\n        if arr[i] == arr[i + 1]:\n            count += 1\n        else:\n            flag = max(flag, count)\n            count = 1\n    flag = max(flag, count)\n    print(max(flag, int((n + 1) // 2)))", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    count = 1\n    flag = 0\n    for i in range(len(arr) - 1):\n        if arr[i] == arr[i + 1]:\n            count += 1\n        else:\n            flag = max(flag, count)\n            count = 1\n    flag = max(flag, count)\n    print(max(flag, int((n + 1) // 2)))", "from math import ceil\ntest = int(input())\nwhile test:\n    test -= 1\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    dic = {}\n    for i in a:\n        dic[i] = 0\n    for i in a:\n        dic[i] += 1\n    ans = 0\n    maxi = max(dic.values())\n    if len(a) - maxi >= maxi:\n        print(ceil(len(a) / 2))\n    else:\n        ans = len(a) - maxi\n        maxi = maxi - ans\n        ans += maxi\n        print(ans)", "from math import ceil\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    dic = {}\n    for i in a:\n        dic[i] = 0\n    for i in a:\n        dic[i] += 1\n    ans = 0\n    maxi = max(dic.values())\n    if len(a) - maxi >= maxi:\n        print(ceil(len(a) / 2))\n    else:\n        ans = len(a) - maxi\n        maxi = maxi - ans\n        ans += maxi\n        print(ans)", "from math import ceil\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    dic = {}\n    for i in a:\n        dic[i] = 0\n    for i in a:\n        dic[i] += 1\n    ans = 0\n    maxi = max(dic.values())\n    if len(a) - maxi >= maxi:\n        print(ceil(len(a) / 2))\n    else:\n        ans = len(a) - maxi\n        maxi = maxi - ans\n        ans += maxi\n        print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    m = 0\n    c = 1\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            c += 1\n        else:\n            m = max(m, c)\n            c = 1\n    m = max(m, c)\n    print(max(m, (n + 1) // 2))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    m = 0\n    c = 1\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            c += 1\n        else:\n            m = max(m, c)\n            c = 1\n    m = max(m, c)\n    print(max(m, (n + 1) // 2))", "import heapq as heap\nfrom collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    c = Counter()\n    for v in h:\n        c[v] += 1\n    h = []\n    for v in c:\n        h.append(-1 * c[v])\n    heap.heapify(h)\n    ans = 0\n    while h:\n        try:\n            last = h[1]\n        except:\n            ans += -1 * h[0]\n            break\n        e1 = -1 * heap.heappop(h)\n        e2 = -1 * heap.heappop(h)\n        ans += 1\n        e1 -= 1\n        e2 -= 1\n        if e1:\n            heap.heappush(h, -1 * e1)\n        if e2:\n            heap.heappush(h, -1 * e2)\n    print(ans)", "class MaxHeap:\n\n    def __init__(self, collection=None):\n        self._heap = []\n        if collection is not None:\n            for el in collection:\n                self.push(el)\n\n    def push(self, value):\n        self._heap.append(value)\n        _sift_up(self._heap, len(self) - 1)\n\n    def pop(self):\n        _swap(self._heap, len(self) - 1, 0)\n        el = self._heap.pop()\n        _sift_down(self._heap, 0)\n        return el\n\n    def __len__(self):\n        return len(self._heap)\n\n    def print(self, idx=1, indent=0):\n        print('\\t' * indent, f'{self._heap[idx - 1]}')\n        (left, right) = (2 * idx, 2 * idx + 1)\n        if left <= len(self):\n            self.print(left, indent=indent + 1)\n        if right <= len(self):\n            self.print(right, indent=indent + 1)\n\ndef _swap(L, i, j):\n    (L[i], L[j]) = (L[j], L[i])\n\ndef _sift_up(heap, idx):\n    parent_idx = (idx - 1) // 2\n    if parent_idx < 0:\n        return\n    if heap[idx] > heap[parent_idx]:\n        _swap(heap, idx, parent_idx)\n        _sift_up(heap, parent_idx)\n\ndef _sift_down(heap, idx):\n    child_idx = 2 * idx + 1\n    if child_idx >= len(heap):\n        return\n    if child_idx + 1 < len(heap) and heap[child_idx] < heap[child_idx + 1]:\n        child_idx += 1\n    if heap[child_idx] > heap[idx]:\n        _swap(heap, child_idx, idx)\n        _sift_down(heap, child_idx)\n\ndef heap_sort(collection):\n    heap = MaxHeap(collection)\n    sorted_arr = []\n    while len(heap) > 0:\n        sorted_arr.append(heap.pop())\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    d = {}\n    for i in l:\n        try:\n            d[i] += 1\n        except:\n            d[i] = 1\n    x = MaxHeap()\n    for i in d.values():\n        x.push(i)\n    ans = 0\n    while len(x) > 1:\n        a = x.pop()\n        b = x.pop()\n        ans += 1\n        a -= 1\n        b -= 1\n        if a > 0:\n            x.push(a)\n        if b > 0:\n            x.push(b)\n    while len(x) > 0:\n        ans += x.pop()\n    print(ans)", "from math import ceil\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    hash = {}\n    for i in l:\n        try:\n            hash[i]\n        except:\n            hash[i] = 1\n        else:\n            hash[i] += 1\n    ans = []\n    for i in hash.keys():\n        ans.append(hash[i])\n    ans.sort(reverse=True)\n    print(max((ans[0], ceil(n / 2))))", "import heapq\nfrom collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    c = Counter(a)\n    p = [-j for (i, j) in c.items()]\n    heapq.heapify(p)\n    count = 0\n    while p[0] < 0:\n        a = heapq.heappop(p)\n        if len(p) > 0:\n            b = heapq.heappop(p)\n            heapq.heappush(p, a + 1)\n            heapq.heappush(p, b + 1)\n        else:\n            heapq.heappush(p, a + 1)\n        count += 1\n    print(count)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    m = 0\n    c = 1\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            c += 1\n        else:\n            m = max(m, c)\n            c = 1\n    m = max(m, c)\n    print(max(m, (n + 1) // 2))", "from heapq import *\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    freq = {}\n    for i in arr:\n        freq[i] = freq.get(i, 0) + 1\n    h = []\n    for i in freq:\n        heappush(h, -freq[i])\n    ans = 0\n    while h:\n        v2 = None\n        v1 = -heappop(h)\n        if h:\n            v2 = -heappop(h)\n        if v2 is None:\n            ans += v1\n        else:\n            ans += 1\n            v1 -= 1\n            v2 -= 1\n            if v1 > 0:\n                heappush(h, -v1)\n            if v2 > 0:\n                heappush(h, -v2)\n    print(ans)", "import heapq\nfor t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(1)\n        continue\n    d = dict()\n    heap = []\n    for i in range(n):\n        try:\n            d[a[i]] -= 1\n        except:\n            d[a[i]] = -1\n    ans = 0\n    for pair in d:\n        heapq.heappush(heap, [d[pair], pair])\n    while heap:\n        x = heapq.heappop(heap)\n        if heap:\n            y = heapq.heappop(heap)\n            x[0] += 1\n            y[0] += 1\n            ans += 1\n            if x[0] != 0:\n                heapq.heappush(heap, x)\n            if y[0] != 0:\n                heapq.heappush(heap, y)\n        else:\n            x[0] *= -1\n            ans += x[0]\n            break\n    print(ans)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    d = {}\n    for i in a:\n        d[i] = d.setdefault(i, 0) - 1\n    hp = []\n    for i in d:\n        heapq.heappush(hp, (d[i], i))\n    ans = 0\n    while len(hp) > 1:\n        x = heapq.heappop(hp)\n        y = heapq.heappop(hp)\n        ans += 1\n        if x[0] + 1 < 0:\n            heapq.heappush(hp, (x[0] + 1, x[1]))\n        if y[0] + 1 < 0:\n            heapq.heappush(hp, (y[0] + 1, y[1]))\n    if len(hp) == 1:\n        x = heapq.heappop(hp)\n        ans += -x[0]\n    print(ans)", "from collections import Counter\nfor t in range(int(input())):\n    n = int(input())\n    a = Counter(map(int, input().split()))\n    m = max((n + 1) // 2, a.most_common(1)[0][1])\n    print(m)", "from collections import Counter\nfor t in range(int(input())):\n    (n, c) = (int(input()), Counter(map(int, input().split())))\n    print(max((n + 1) // 2, c.most_common(1)[0][1]))"]