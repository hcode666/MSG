["for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    stack = []\n    res = []\n    for i in range(n):\n        while len(stack) != 0 and stack[-1] <= arr[i]:\n            temp = stack.pop()\n            res.append(abs(arr[i] - temp))\n        if len(stack) != 0:\n            res.append(abs(stack[-1] - arr[i]))\n        stack.append(arr[i])\n    print(len(list(set(res))))", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    stack = []\n    res = []\n    for i in range(n):\n        while len(stack) != 0 and stack[-1] <= arr[i]:\n            temp = stack.pop()\n            res.append(abs(arr[i] - temp))\n        if len(stack) != 0:\n            res.append(abs(stack[-1] - arr[i]))\n        stack.append(arr[i])\n    print(len(list(set(res))))", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    stack = []\n    res = []\n    for i in range(n):\n        while len(stack) != 0 and stack[-1] <= arr[i]:\n            temp = stack.pop()\n            res.append(abs(arr[i] - temp))\n        if len(stack) != 0:\n            res.append(abs(stack[-1] - arr[i]))\n        stack.append(arr[i])\n    print(len(list(set(res))))", "T = int(input())\nfor i in range(T):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = []\n    stack = []\n    for i in range(n):\n        if not stack:\n            stack.append(arr[i])\n        elif stack[-1] > arr[i]:\n            ans.append(stack[-1] - arr[i])\n            stack.append(arr[i])\n        else:\n            while stack and stack[-1] <= arr[i]:\n                p = stack.pop()\n                ans.append(arr[i] - p)\n            if stack:\n                ans.append(abs(arr[i] - stack[-1]))\n            stack.append(arr[i])\n    print(len(list(set(ans))))", "T = int(input())\nfor i in range(T):\n    b = int(input())\n    arr = list(map(int, input().split()))\n    ans = []\n    stack = []\n    for i in range(b):\n        if not stack:\n            stack.append(arr[i])\n        elif stack[-1] > arr[i]:\n            ans.append(stack[-1] - arr[i])\n            stack.append(arr[i])\n        else:\n            while stack and stack[-1] <= arr[i]:\n                p = stack.pop()\n                ans.append(arr[i] - p)\n            if stack:\n                ans.append(abs(arr[i] - stack[-1]))\n            stack.append(arr[i])\n    print(len(list(set(ans))))", "for _ in range(int(input())):\n    b = int(input())\n    a = list(map(int, input().split()))\n    stack = []\n    result = []\n    for i in range(b):\n        while stack and stack[-1] <= a[i]:\n            tmp = stack.pop()\n            result.append(abs(a[i] - tmp))\n        if stack:\n            result.append(stack[-1] - a[i])\n        stack.append(a[i])\n    print(len(list(set(result))))", "for _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()][:n]\n    (st, result) = ([], [])\n    for i in range(n):\n        while st and st[-1] <= a[i]:\n            tmp = st.pop()\n            result.append(a[i] - tmp)\n        if st:\n            result.append(st[-1] - a[i])\n        st.append(a[i])\n    print(len(list(set(result))))", "for t in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    stack = []\n    res = []\n    for i in range(n):\n        while len(stack) != 0 and stack[-1] <= arr[i]:\n            temp = stack.pop()\n            res.append(abs(arr[i] - temp))\n        if len(stack) != 0:\n            res.append(stack[-1] - arr[i])\n        stack.append(arr[i])\n    print(len(list(set(res))))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    stack = []\n    result = []\n    for i in range(n):\n        while stack and stack[-1] <= a[i]:\n            tmp = stack.pop()\n            result.append(abs(a[i] - tmp))\n        if stack:\n            result.append(stack[-1] - a[i])\n        stack.append(a[i])\n    print(len(list(set(result))))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    stack = []\n    result = []\n    for i in range(n):\n        while stack and stack[-1] <= a[i]:\n            tmp = stack.pop()\n            result.append(abs(a[i] - tmp))\n        if stack:\n            result.append(stack[-1] - a[i])\n        stack.append(a[i])\n    print(len(list(set(result))))", "from sys import stdin, stdout\nfrom collections import deque\nnmbr = lambda : int(input())\nlst = lambda : list(map(int, input().split()))\nfor _ in range(nmbr()):\n    n = nmbr()\n    a = lst()\n    biggest = deque()\n    ngr = [n] * n\n    for i in range(n - 1, -1, -1):\n        v = a[i]\n        while biggest and v > a[biggest[-1]]:\n            biggest.pop()\n        if biggest:\n            ngr[i] = biggest[-1]\n        biggest.append(i)\n    smallest = deque()\n    nsr = [n] * n\n    for i in range(n - 1, -1, -1):\n        v = a[i]\n        while smallest and a[smallest[-1]] > v:\n            smallest.pop()\n        if smallest:\n            nsr[i] = smallest[-1]\n        smallest.append(i)\n    biggest = deque()\n    ngl = [-1] * n\n    for i in range(n):\n        v = a[i]\n        while biggest and v > a[biggest[-1]]:\n            biggest.pop()\n        if biggest:\n            ngl[i] = biggest[-1]\n        biggest.append(i)\n    smallest = deque()\n    nsl = [-1] * n\n    for i in range(n):\n        v = a[i]\n        while smallest and a[smallest[-1]] > v:\n            smallest.pop()\n        if smallest:\n            nsl[i] = smallest[-1]\n        smallest.append(i)\n    ans = set()\n    for i in range(n):\n        v = a[i]\n        if ngl[i] != -1:\n            ans.add(a[ngl[i]] - v)\n        if ngr[i] != n:\n            ans.add(a[ngr[i]] - v)\n    print(len(ans))", "T = int(input())\nfor i in range(T):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = []\n    stack = []\n    for i in range(n):\n        if not stack:\n            stack.append(arr[i])\n        elif stack[-1] > arr[i]:\n            ans.append(stack[-1] - arr[i])\n            stack.append(arr[i])\n        else:\n            while stack and stack[-1] <= arr[i]:\n                p = stack.pop()\n                ans.append(arr[i] - p)\n            if stack:\n                ans.append(abs(arr[i] - stack[-1]))\n            stack.append(arr[i])\n    print(len(list(set(ans))))", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = []\n    stack = []\n    for i in range(n):\n        if not stack:\n            stack.append(arr[i])\n        elif stack[-1] > arr[i]:\n            ans.append(stack[-1] - arr[i])\n            stack.append(arr[i])\n        else:\n            while stack and stack[-1] <= arr[i]:\n                p = stack.pop()\n                ans.append(arr[i] - p)\n            if stack:\n                ans.append(abs(arr[i] - stack[-1]))\n            stack.append(arr[i])\n    print(len(list(set(ans))))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    stack = []\n    result = []\n    for i in range(n):\n        while stack and stack[-1] <= a[i]:\n            tmp = stack.pop()\n            result.append(abs(a[i] - tmp))\n        if stack:\n            result.append(stack[-1] - a[i])\n        stack.append(a[i])\n    print(len(list(set(result))))", "def NGE(arr, n):\n    st = []\n    ans = []\n    for i in range(n):\n        while len(st) > 0 and st[-1] <= arr[i]:\n            ans.append(arr[i] - st[-1])\n            st.pop()\n        st.append(arr[i])\n    return ans\ntcs = int(input())\nfor _ in range(tcs):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a1 = NGE(a, n)\n    a2 = NGE(a[::-1], n)[::-1]\n    an = set(a1 + a2)\n    print(len(an))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    stack = []\n    result = []\n    for i in range(n):\n        while stack and stack[-1] <= a[i]:\n            tmp = stack.pop()\n            result.append(abs(a[i] - tmp))\n        if stack:\n            result.append(stack[-1] - a[i])\n        stack.append(a[i])\n    print(len(list(set(result))))", "import sys, math, itertools, random, bisect\nfrom collections import defaultdict\nINF = 10 ** 18\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\ntest = 1\ntest = int(input())\nfor _ in range(test):\n    (n,) = get_ints()\n    a = get_array()\n    ans = set()\n    (left, right) = ([-1] * n, [-1] * n)\n    st = []\n    for i in range(n):\n        while st and st[-1] < a[i]:\n            st.pop()\n        if st:\n            left[i] = st[-1]\n        st.append(a[i])\n    st = []\n    for i in range(n - 1, -1, -1):\n        while st and st[-1] < a[i]:\n            st.pop()\n        if st:\n            right[i] = st[-1]\n        st.append(a[i])\n    for i in range(n):\n        if left[i] != -1:\n            ans.add(left[i] - a[i])\n        if right[i] != -1:\n            ans.add(right[i] - a[i])\n    print(len(ans))", "import sys\nintinp = lambda : int(input())\n\ndef listinp(func=int):\n    return list(map(func, input().split()))\n\ndef nsepline(n, func=str):\n    return [func(input()) for _ in range(n)]\n\ndef printlist(li, glue=' '):\n    return glue.join(list(map(str, li)))\n\ndef fop(s, end='\\n'):\n    sys.stdout.write(str(s) + end)\n\ndef fip():\n    return sys.stdin.readline().strip()\nfintinp = lambda : int(fip())\n\ndef flistinp(func=int):\n    return list(map(func, fip().split()))\n\ndef fnsepline(n, func=str):\n    return [func(fip()) for _ in range(n)]\ntest_cases = fintinp()\nfor _ in range(test_cases):\n    n = fintinp()\n    l = flistinp()\n    anss = set()\n    mx_ltr = [-1] * n\n    st = []\n    for i in range(n):\n        while st and l[st[-1]] <= l[i]:\n            mx_ltr[st.pop()] = l[i]\n        st.append(i)\n    st.clear()\n    mx_rtl = [-1] * n\n    l.reverse()\n    for i in range(n):\n        while st and l[st[-1]] <= l[i]:\n            mx_rtl[st.pop()] = l[i]\n        st.append(i)\n    mx_rtl.reverse()\n    l.reverse()\n    for i in range(n):\n        if mx_ltr[i] != -1:\n            anss.add(mx_ltr[i] - l[i])\n        if mx_rtl[i] != -1:\n            anss.add(mx_rtl[i] - l[i])\n    print(len(anss))", "t = int(input())\nfor test in range(t):\n    n = int(input())\n    l = [int(j) for j in input().split()]\n    lm = [-1 for j in range(n)]\n    rm = [-1 for j in range(n)]\n    st = []\n    for i in range(n):\n        if len(st) == 0:\n            st.append(i)\n        else:\n            while l[st[-1]] <= l[i]:\n                z = st.pop()\n                rm[z] = l[i]\n                if len(st) == 0:\n                    break\n            st.append(i)\n    l = l[::-1]\n    st = []\n    for i in range(n):\n        if len(st) == 0:\n            st.append(i)\n        else:\n            while l[st[-1]] <= l[i]:\n                z = st.pop()\n                lm[z] = l[i]\n                if len(st) == 0:\n                    break\n            st.append(i)\n    l = l[::-1]\n    lm = lm[::-1]\n    ans = 0\n    z = set()\n    for i in range(n):\n        if lm[i] != -1:\n            if lm[i] - l[i] not in z:\n                z.add(lm[i] - l[i])\n        if rm[i] != -1:\n            if rm[i] - l[i] not in z:\n                z.add(rm[i] - l[i])\n    print(len(z))", "from sys import stdin, stdout\ninput = stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    nge = [-1 for i in range(n)]\n    pge = [-1 for i in range(n)]\n    stack1 = []\n    stack2 = []\n    for i in range(n):\n        if not len(stack1):\n            stack1.append(i)\n        elif a[i] < a[stack1[-1]]:\n            stack1.append(i)\n        else:\n            while 1:\n                if not len(stack1):\n                    break\n                if a[stack1[-1]] <= a[i]:\n                    nge[stack1.pop()] = a[i]\n                else:\n                    break\n            stack1.append(i)\n    a = a[::-1]\n    for i in range(n):\n        if not len(stack2):\n            stack2.append(i)\n        elif a[i] < a[stack2[-1]]:\n            stack2.append(i)\n        else:\n            while 1:\n                if not len(stack2):\n                    break\n                if a[stack2[-1]] <= a[i]:\n                    pge[n - stack2.pop() - 1] = a[i]\n                else:\n                    break\n            stack2.append(i)\n    a = a[::-1]\n    s = set()\n    for i in range(n):\n        if nge[i] != -1:\n            s.add(nge[i] - a[i])\n        if pge[i] != -1:\n            s.add(pge[i] - a[i])\n    print(len(s))", "for test in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = set()\n    st = [a[0]]\n    for i in range(1, n):\n        pp = st[-1]\n        while pp < a[i]:\n            ans.add(a[i] - pp)\n            st.pop()\n            if len(st):\n                pp = st[-1]\n            else:\n                pp = -1\n                break\n        if pp != -1:\n            st.append(pp)\n            ans.add(pp - a[i])\n        st.append(a[i])\n    print(len(ans))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    s = set()\n    leftst = [a[0]]\n    for i in range(1, len(a)):\n        while leftst and a[i] >= leftst[-1]:\n            leftst.pop()\n        if leftst:\n            s.add(leftst[-1] - a[i])\n        leftst.append(a[i])\n    rightst = [a[len(a) - 1]]\n    for i in range(len(a) - 2, -1, -1):\n        while rightst and a[i] > rightst[-1]:\n            rightst.pop()\n        if rightst:\n            s.add(rightst[-1] - a[i])\n        rightst.append(a[i])\n    print(len(s))", "from sys import stdin, stdout\ninput = stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    nge = [-1 for i in range(n)]\n    pge = [-1 for i in range(n)]\n    stack1 = []\n    stack2 = []\n    for i in range(n):\n        if not len(stack1):\n            stack1.append(i)\n        elif a[i] < a[stack1[-1]]:\n            stack1.append(i)\n        else:\n            while 1:\n                if not len(stack1):\n                    break\n                if a[stack1[-1]] <= a[i]:\n                    nge[stack1.pop()] = a[i]\n                else:\n                    break\n            stack1.append(i)\n    a = a[::-1]\n    for i in range(n):\n        if not len(stack2):\n            stack2.append(i)\n        elif a[i] < a[stack2[-1]]:\n            stack2.append(i)\n        else:\n            while 1:\n                if not len(stack2):\n                    break\n                if a[stack2[-1]] <= a[i]:\n                    pge[n - stack2.pop() - 1] = a[i]\n                else:\n                    break\n            stack2.append(i)\n    a = a[::-1]\n    s = set()\n    for i in range(n):\n        if nge[i] != -1:\n            s.add(nge[i] - a[i])\n        if pge[i] != -1:\n            s.add(pge[i] - a[i])\n    print(len(s))", "def answer():\n    r = [-1] * n\n    s = []\n    for i in range(n):\n        if s == []:\n            s.append(i)\n            continue\n        while s != [] and a[s[-1]] <= a[i]:\n            r[s[-1]] = a[i]\n            s.pop()\n        s.append(i)\n    l = [-1] * n\n    s = []\n    for i in range(n - 1, -1, -1):\n        if s == []:\n            s.append(i)\n            continue\n        while s != [] and a[s[-1]] <= a[i]:\n            l[s[-1]] = a[i]\n            s.pop()\n        s.append(i)\n    ans = set()\n    for i in range(n):\n        if r[i] != -1:\n            ans.add(r[i] - a[i])\n        if l[i] != -1:\n            ans.add(l[i] - a[i])\n    return len(ans)\nfor T in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(answer())", "import sys, io, os, time\nfrom collections import defaultdict\nfrom collections import Counter\nfrom collections import deque\nfrom itertools import combinations\nfrom itertools import permutations\nimport bisect, math, heapq\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\ndef ceil(num, denom):\n    return (num + denom - 1) // denom\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    st = []\n    pairs = set()\n    st.append(a[0])\n    for i in range(1, n):\n        while len(st) and a[i] > st[-1]:\n            pairs.add(abs(st[-1] - a[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.add(abs(min(st[-1], a[i]) - max(st[-1], a[i])))\n        st.append(a[i])\n    print(len(pairs))", "from sys import stdin\ninput = stdin.readline\n\ndef pairs(arr):\n    st = []\n    ans = set()\n    st.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(st) != 0 and arr[i] > st[-1]:\n            ans.add(arr[i] - st[-1])\n            st.pop()\n        if len(st) != 0:\n            ans.add(abs(arr[i] - st[-1]))\n        st.append(arr[i])\n    return len(ans)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(pairs(a))", "def solve(arr):\n    st = list()\n    pairs = set()\n    st.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(st) != 0 and arr[i] > st[-1]:\n            pairs.add(abs(st[-1] - arr[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.add(abs(min(st[-1], arr[i]) - max(st[-1], arr[i])))\n        st.append(arr[i])\n    return len(pairs)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(a))", "def pairs(arr):\n    st = []\n    l = []\n    st.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(st) != 0 and arr[i] > st[-1]:\n            l.append(arr[i] - st[-1])\n            st.pop()\n        if len(st) != 0:\n            val1 = min(st[-1], arr[i])\n            val2 = max(st[-1], arr[i])\n            l.append(val2 - val1)\n        st.append(arr[i])\n    return len(set(l))\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = pairs(l)\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    st = []\n    pairs = set()\n    st.append(a[0])\n    for i in range(1, n):\n        while len(st) and a[i] >= st[-1]:\n            pairs.add(abs(st[-1] - a[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.add(abs(st[-1] - a[i]))\n        st.append(a[i])\n    print(len(pairs))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    st = []\n    pairs = set()\n    st.append(a[0])\n    for i in range(1, n):\n        while len(st) and a[i] >= st[-1]:\n            pairs.add(abs(st[-1] - a[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.add(abs(st[-1] - a[i]))\n        st.append(a[i])\n    print(len(pairs))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    st = []\n    pairs = set()\n    st.append(a[0])\n    for i in range(1, n):\n        while len(st) and a[i] > st[-1]:\n            pairs.add(abs(st[-1] - a[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.add(abs(st[-1] - a[i]))\n        st.append(a[i])\n    print(len(pairs))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    st = [a[0]]\n    s = set()\n    for i in range(1, n):\n        while len(st) != 0 and a[i] >= st[-1]:\n            s.add(abs(a[i] - st[-1]))\n            st.pop()\n        if len(st) != 0:\n            s.add(abs(a[i] - st[-1]))\n        st.append(a[i])\n    print(len(s))", "from sys import stdin, stdout\nstdin.readline\n\ndef mp():\n    return list(map(int, stdin.readline().strip().split()))\n\ndef it():\n    return int(stdin.readline().strip())\n\ndef pairs(arr):\n    stack = []\n    pairs = []\n    stack.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(stack) != 0 and arr[i] > stack[-1]:\n            pairs.append([stack[-1], arr[i]])\n            stack.pop()\n        if len(stack):\n            pairs.append([min(stack[-1], arr[i]), max(stack[-1], arr[i])])\n        stack.append(arr[i])\n    s = set()\n    for i in pairs:\n        s.add(abs(i[0] - i[1]))\n    return s\nfor _ in range(it()):\n    n = it()\n    l = mp()\n    print(len(pairs(l)))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ls = list(map(int, input().split()))\n    set_diff = set()\n    stack = [ls[0]]\n    new_ls = ls[1:]\n    for i in new_ls:\n        while stack and i >= stack[-1]:\n            set_diff.add(i - stack[-1])\n            stack.pop()\n        stack.append(i)\n    rev_ls = ls[::-1]\n    stack = [rev_ls[0]]\n    new_ls = rev_ls[1:]\n    for i in new_ls:\n        while stack and i >= stack[-1]:\n            set_diff.add(i - stack[-1])\n            stack.pop()\n        stack.append(i)\n    print(len(set_diff))", "from collections import defaultdict, OrderedDict, Counter\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom queue import Queue, PriorityQueue\nfrom heapq import heapify, heappop, heappush\nfrom statistics import median, mean\nfrom math import gcd, sqrt, floor, factorial, ceil, log2, log10, log\nimport fractions\nimport copy\nfrom copy import deepcopy\nimport sys\nimport io\nsys.setrecursionlimit(10 ** 8)\nimport math\nimport os\nimport bisect\nimport collections\nmod = pow(10, 9) + 7\nimport random\nfrom random import random, randint, randrange\nfrom time import time\n\ndef ncr(n, r, p=mod):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef normalncr(n, r):\n    r = min(r, n - r)\n    count = 1\n    for i in range(n - r, n + 1):\n        count *= i\n    for i in range(1, r + 1):\n        count //= i\n    return count\ninf = float('inf')\nadj = defaultdict(set)\nvisited = defaultdict(int)\n\ndef addedge(a, b):\n    adj[a].add(b)\n    adj[b].add(a)\n\ndef bfs(v):\n    q = Queue()\n    q.put(v)\n    visited[v] = 1\n    while q.qsize() > 0:\n        s = q.get_nowait()\n        print(s)\n        for i in adj[s]:\n            if visited[i] == 0:\n                q.put(i)\n                visited[i] = 1\n\ndef dfs(v, visited):\n    if visited[v] == 1:\n        return\n    visited[v] = 1\n    print(v)\n    for i in adj[v]:\n        dfs(i, visited)\n\ndef reverse_bisect_right(a, x, lo=0, hi=None):\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if x > a[mid]:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo\n\ndef reverse_bisect_left(a, x, lo=0, hi=None):\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if x >= a[mid]:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo\n\ndef get_list():\n    return list(map(int, input().split()))\n\ndef get_str_list_in_int():\n    return [int(i) for i in list(input())]\n\ndef get_str_list():\n    return list(input())\n\ndef get_map():\n    return map(int, input().split())\n\ndef input_int():\n    return int(input())\n\ndef matrix(a, b):\n    return [[0 for i in range(b)] for j in range(a)]\n\ndef swap(a, b):\n    return (b, a)\n\ndef find_gcd(l):\n    a = l[0]\n    for i in range(len(l)):\n        a = gcd(a, l[i])\n    return a\n\ndef is_prime(n):\n    sqrta = int(sqrt(n))\n    for i in range(2, sqrta + 1):\n        if n % i == 0:\n            return 0\n    return 1\n\ndef prime_factors(n):\n    sqrta = int(sqrt(n))\n    for i in range(2, sqrta + 1):\n        if n % i == 0:\n            return [i] + prime_factors(n // i)\n    return [n]\n\ndef p(a):\n    if type(a) == str:\n        print(a + '\\n')\n    else:\n        print(str(a) + '\\n')\n\ndef ps(a):\n    if type(a) == str:\n        print(a)\n    else:\n        print(str(a))\n\ndef kth_no_not_div_by_n(n, k):\n    return k + (k - 1) // (n - 1)\n\ndef forward_array(l):\n    stack = []\n    forward = [0] * n\n    for i in range(len(l) - 1, -1, -1):\n        while len(stack) and l[stack[-1]] < l[i]:\n            stack.pop()\n        if len(stack) == 0:\n            forward[i] = len(l)\n        else:\n            forward[i] = stack[-1]\n        stack.append(i)\n    return forward\n\ndef backward_array(l):\n    stack = []\n    backward = [0] * n\n    for i in range(len(l)):\n        while len(stack) and l[stack[-1]] < l[i]:\n            stack.pop()\n        if len(stack) == 0:\n            backward[i] = -1\n        else:\n            backward[i] = stack[-1]\n        stack.append(i)\n    return backward\nnc = 'NO'\nyc = 'YES'\nns = 'No'\nys = 'Yes'\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    l = get_list()\n    dict = defaultdict(int)\n    forward = forward_array(l)\n    backward = backward_array(l)\n    for i in range(n):\n        j = forward[i]\n        if j != n:\n            dict[l[j] - l[i]] = 1\n    for i in range(n):\n        j = backward[i]\n        if j != -1:\n            dict[l[j] - l[i]] = 1\n    print(len(dict))", "import sys, math, itertools, random, bisect\nfrom collections import defaultdict\nINF = sys.maxsize\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    a = get_array()\n    ans = set()\n    (left, right) = ([-1] * n, [-1] * n)\n    stack = []\n    for i in range(n):\n        while stack and stack[-1] < a[i]:\n            stack.pop()\n        if stack:\n            left[i] = stack[-1]\n        stack.append(a[i])\n    while stack:\n        stack.pop()\n    for i in range(n - 1, -1, -1):\n        while stack and stack[-1] < a[i]:\n            stack.pop()\n        if stack:\n            right[i] = stack[-1]\n        stack.append(a[i])\n    for i in range(n):\n        if left[i] != -1:\n            ans.add(left[i] - a[i])\n        if right[i] != -1:\n            ans.add(right[i] - a[i])\n    print(len(ans))", "from collections import defaultdict, OrderedDict, Counter\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom queue import Queue, PriorityQueue\nfrom heapq import heapify, heappop, heappush\nfrom statistics import median, mean\nfrom math import gcd, sqrt, floor, factorial, ceil, log2, log10, log\nimport fractions\nimport copy\nfrom copy import deepcopy\nimport sys\nimport io\nsys.setrecursionlimit(10 ** 8)\nimport math\nimport os\nimport bisect\nimport collections\nmod = pow(10, 9) + 7\nimport random\nfrom random import random, randint, randrange\nfrom time import time\n\ndef ncr(n, r, p=mod):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef normalncr(n, r):\n    r = min(r, n - r)\n    count = 1\n    for i in range(n - r, n + 1):\n        count *= i\n    for i in range(1, r + 1):\n        count //= i\n    return count\ninf = float('inf')\nadj = defaultdict(set)\nvisited = defaultdict(int)\n\ndef addedge(a, b):\n    adj[a].add(b)\n    adj[b].add(a)\n\ndef bfs(v):\n    q = Queue()\n    q.put(v)\n    visited[v] = 1\n    while q.qsize() > 0:\n        s = q.get_nowait()\n        print(s)\n        for i in adj[s]:\n            if visited[i] == 0:\n                q.put(i)\n                visited[i] = 1\n\ndef dfs(v, visited):\n    if visited[v] == 1:\n        return\n    visited[v] = 1\n    print(v)\n    for i in adj[v]:\n        dfs(i, visited)\n\ndef reverse_bisect_right(a, x, lo=0, hi=None):\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if x > a[mid]:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo\n\ndef reverse_bisect_left(a, x, lo=0, hi=None):\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if x >= a[mid]:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo\n\ndef get_list():\n    return list(map(int, input().split()))\n\ndef get_str_list_in_int():\n    return [int(i) for i in list(input())]\n\ndef get_str_list():\n    return list(input())\n\ndef get_map():\n    return map(int, input().split())\n\ndef input_int():\n    return int(input())\n\ndef matrix(a, b):\n    return [[0 for i in range(b)] for j in range(a)]\n\ndef swap(a, b):\n    return (b, a)\n\ndef find_gcd(l):\n    a = l[0]\n    for i in range(len(l)):\n        a = gcd(a, l[i])\n    return a\n\ndef is_prime(n):\n    sqrta = int(sqrt(n))\n    for i in range(2, sqrta + 1):\n        if n % i == 0:\n            return 0\n    return 1\n\ndef prime_factors(n):\n    sqrta = int(sqrt(n))\n    for i in range(2, sqrta + 1):\n        if n % i == 0:\n            return [i] + prime_factors(n // i)\n    return [n]\n\ndef p(a):\n    if type(a) == str:\n        print(a + '\\n')\n    else:\n        print(str(a) + '\\n')\n\ndef ps(a):\n    if type(a) == str:\n        print(a)\n    else:\n        print(str(a))\n\ndef kth_no_not_div_by_n(n, k):\n    return k + (k - 1) // (n - 1)\nnc = 'NO'\nyc = 'YES'\nns = 'No'\nys = 'Yes'\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    l = get_list()\n    dict = defaultdict(int)\n    forward = [0] * n\n    backward = [0] * n\n    stack = []\n    for i in range(len(l) - 1, -1, -1):\n        while len(stack) and l[stack[-1]] < l[i]:\n            stack.pop()\n        if len(stack) == 0:\n            forward[i] = n\n        else:\n            forward[i] = stack[-1]\n        stack.append(i)\n    stack = []\n    for i in range(len(l)):\n        while len(stack) and l[stack[-1]] < l[i]:\n            stack.pop()\n        if len(stack) == 0:\n            backward[i] = -1\n        else:\n            backward[i] = stack[-1]\n        stack.append(i)\n    for i in range(n):\n        j = forward[i]\n        if j != n:\n            dict[l[j] - l[i]] = 1\n    for i in range(n):\n        j = backward[i]\n        if j != -1:\n            dict[l[j] - l[i]] = 1\n    print(len(dict))", "import heapq\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef prime(n):\n    arr = [True] * (n + 1)\n    arr[0] = False\n    arr[1] = False\n    for i in range(n + 1):\n        if arr[i]:\n            for j in range(i * i, n + 1, i):\n                arr[j] = False\n    return arr[n]\n\ndef nextLargerElement(arr):\n    st = []\n    ans = [-1] * len(arr)\n    for i in range(len(arr)):\n        while st and arr[st[-1]] <= arr[i]:\n            ans[st.pop()] = arr[i]\n        st.append(i)\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = set()\n    ansr = nextLargerElement(arr)\n    ansl = nextLargerElement(arr[::-1])[::-1]\n    for i in range(len(arr)):\n        if ansr[i] != -1:\n            ans.add(ansr[i] - arr[i])\n        if ansl[i] != -1:\n            ans.add(ansl[i] - arr[i])\n    print(len(ans))", "from collections import defaultdict, OrderedDict, Counter\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom queue import Queue, PriorityQueue\nfrom heapq import heapify, heappop, heappush\nfrom statistics import median, mean\nfrom math import gcd, sqrt, floor, factorial, ceil, log2, log10, log\nimport fractions\nimport copy\nfrom copy import deepcopy\nimport sys\nimport io\nsys.setrecursionlimit(10 ** 8)\nimport math\nimport os\nimport bisect\nimport collections\nmod = pow(10, 9) + 7\nimport random\nfrom random import random, randint, randrange\nfrom time import time\n\ndef ncr(n, r, p=mod):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef normalncr(n, r):\n    r = min(r, n - r)\n    count = 1\n    for i in range(n - r, n + 1):\n        count *= i\n    for i in range(1, r + 1):\n        count //= i\n    return count\ninf = float('inf')\nadj = defaultdict(set)\nvisited = defaultdict(int)\n\ndef addedge(a, b):\n    adj[a].add(b)\n    adj[b].add(a)\n\ndef bfs(v):\n    q = Queue()\n    q.put(v)\n    visited[v] = 1\n    while q.qsize() > 0:\n        s = q.get_nowait()\n        print(s)\n        for i in adj[s]:\n            if visited[i] == 0:\n                q.put(i)\n                visited[i] = 1\n\ndef dfs(v, visited):\n    if visited[v] == 1:\n        return\n    visited[v] = 1\n    print(v)\n    for i in adj[v]:\n        dfs(i, visited)\n\ndef reverse_bisect_right(a, x, lo=0, hi=None):\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if x > a[mid]:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo\n\ndef reverse_bisect_left(a, x, lo=0, hi=None):\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if x >= a[mid]:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo\n\ndef get_list():\n    return list(map(int, input().split()))\n\ndef get_str_list_in_int():\n    return [int(i) for i in list(input())]\n\ndef get_str_list():\n    return list(input())\n\ndef get_map():\n    return map(int, input().split())\n\ndef input_int():\n    return int(input())\n\ndef matrix(a, b):\n    return [[0 for i in range(b)] for j in range(a)]\n\ndef swap(a, b):\n    return (b, a)\n\ndef find_gcd(l):\n    a = l[0]\n    for i in range(len(l)):\n        a = gcd(a, l[i])\n    return a\n\ndef is_prime(n):\n    sqrta = int(sqrt(n))\n    for i in range(2, sqrta + 1):\n        if n % i == 0:\n            return 0\n    return 1\n\ndef prime_factors(n):\n    sqrta = int(sqrt(n))\n    for i in range(2, sqrta + 1):\n        if n % i == 0:\n            return [i] + prime_factors(n // i)\n    return [n]\n\ndef p(a):\n    if type(a) == str:\n        print(a + '\\n')\n    else:\n        print(str(a) + '\\n')\n\ndef ps(a):\n    if type(a) == str:\n        print(a)\n    else:\n        print(str(a))\n\ndef kth_no_not_div_by_n(n, k):\n    return k + (k - 1) // (n - 1)\nnc = 'NO'\nyc = 'YES'\nns = 'No'\nys = 'Yes'\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    l = get_list()\n    dict = defaultdict(int)\n    forward = [0] * n\n    backward = [0] * n\n    stack = []\n    for i in range(len(l) - 1, -1, -1):\n        while len(stack) and l[stack[-1]] < l[i]:\n            stack.pop()\n        if len(stack) == 0:\n            forward[i] = n\n        else:\n            forward[i] = stack[-1]\n        stack.append(i)\n    stack = []\n    for i in range(len(l)):\n        while len(stack) and l[stack[-1]] < l[i]:\n            stack.pop()\n        if len(stack) == 0:\n            backward[i] = -1\n        else:\n            backward[i] = stack[-1]\n        stack.append(i)\n    for i in range(n):\n        j = forward[i]\n        if j == n:\n            continue\n        else:\n            dict[abs(l[j] - l[i])] = 1\n    for i in range(n):\n        j = backward[i]\n        if j == -1:\n            continue\n        else:\n            dict[abs(l[j] - l[i])] = 1\n    print(len(dict))", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    stack = []\n    s = set()\n    for i in l:\n        f = 0\n        while len(stack) > 0 and f == 0:\n            if stack[-1] > i:\n                f = 1\n                break\n            x = stack.pop()\n            s.add(i - x)\n        stack.append(i)\n    j = n - 1\n    stack = []\n    while j > -1:\n        i = l[j]\n        f = 0\n        while len(stack) > 0 and f == 0:\n            if stack[-1] > i:\n                f = 1\n                break\n            x = stack.pop()\n            s.add(i - x)\n        stack.append(i)\n        j = j - 1\n    sys.stdout.write(str(len(s)) + '\\n')", "from os import path\nfrom io import BytesIO, IOBase\nimport sys\nfrom heapq import heappush, heappop\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, Counter, defaultdict as dd\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\n\ndef ii():\n    return int(input())\n\ndef si():\n    return input().rstrip()\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\n\ndef bo(i):\n    return ord(i) - ord('0')\nfile = 1\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\ndef solve():\n    for _ in range(ii()):\n        n = ii()\n        a = li()\n        s = set()\n        for i in range(2):\n            nxt_gre = [0] * n\n            mx = 0\n            st = []\n            for i in range(n):\n                while len(st) > 0 and st[-1] < a[i]:\n                    st.pop()\n                if len(st) > 0:\n                    s.add(st[-1] - a[i])\n                while len(st) > 0 and st[-1] == a[i]:\n                    st.pop()\n                st.append(a[i])\n            a.reverse()\n        print(len(s))\nif file:\n    if path.exists('tmp/input.txt'):\n        sys.stdin = open('tmp/input.txt', 'r')\n        sys.stdout = open('tmp/output.txt', 'w')\n    else:\n        input = sys.stdin.readline\nsolve()", "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    (s, ans, stack) = (set(), 0, [])\n    for num in a:\n        while len(stack) and stack[-1] < num:\n            stack.pop()\n        if len(stack):\n            diff = abs(num - stack[-1])\n            if diff not in s:\n                ans += 1\n                s.add(diff)\n        stack.append(num)\n    stack.clear()\n    for num in reversed(a):\n        while len(stack) and stack[-1] < num:\n            stack.pop()\n        if len(stack):\n            diff = abs(num - stack[-1])\n            if diff not in s:\n                ans += 1\n                s.add(diff)\n        stack.append(num)\n    print(ans)\ntc = int(input())\nfor i in range(tc):\n    solve()", "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    (s, ans) = (set(), 0)\n    stack = []\n    for num in a:\n        while len(stack) and stack[-1] < num:\n            stack.pop()\n        if len(stack):\n            diff = abs(num - stack[-1])\n            if diff not in s:\n                ans += 1\n                s.add(diff)\n        stack.append(num)\n    stack.clear()\n    for num in reversed(a):\n        while len(stack) and stack[-1] < num:\n            stack.pop()\n        if len(stack):\n            diff = abs(num - stack[-1])\n            if diff not in s:\n                ans += 1\n                s.add(diff)\n        stack.append(num)\n    print(ans)\ntc = int(input())\nfor i in range(tc):\n    solve()", "import math, sys\nfrom collections import defaultdict, Counter, deque\nfrom bisect import bisect_left, bisect_right\nINF = float('inf')\nMOD = int(1000000000.0) + 7\nMAX = int(2000000.0) + 1\n\ndef solve():\n    n = int(input())\n    arr = array()\n    ans = set()\n    q = deque()\n    left = [-1 for i in range(n)]\n    right = [-1 for i in range(n)]\n    for i in range(n):\n        while q and q[-1][0] < arr[i]:\n            q.pop()\n        if q:\n            left[i] = q[-1][1]\n        q.append((arr[i], i))\n    q = deque()\n    for i in range(n - 1, -1, -1):\n        while q and q[-1][0] < arr[i]:\n            q.pop()\n        if q:\n            right[i] = q[-1][1]\n        q.append((arr[i], i))\n    for i in range(n):\n        tmp = left[i]\n        if tmp != -1:\n            ans.add(abs(arr[i] - arr[tmp]))\n        tmp = right[i]\n        if tmp != -1:\n            ans.add(abs(arr[tmp] - arr[i]))\n    print(len(ans))\n\ndef main():\n    t = 1\n    t = int(input())\n    for _ in range(t):\n        solve()\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef input():\n    return sys.stdin.readline().rstrip('\\n').strip()\n\ndef print(*args, sep=' ', end='\\n'):\n    first = True\n    for arg in args:\n        if not first:\n            sys.stdout.write(sep)\n        sys.stdout.write(str(arg))\n        first = False\n    sys.stdout.write(end)\nprimes = [1 for i in range(MAX)]\n\ndef sieve():\n    global primes\n    primes[0] = primes[1] = 0\n    i = 2\n    while i <= MAX ** 0.5:\n        j = i * i\n        while primes[i] and j < MAX:\n            if j % i == 0:\n                primes[j] = 0\n            j += i\n        i += 1\n\ndef vars():\n    return map(int, input().split())\n\ndef array():\n    return list(vars())\nmain()", "from sys import stdin, stdout\ninput = stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    nge = [-1 for i in range(n)]\n    pge = [-1 for i in range(n)]\n    stack1 = []\n    stack2 = []\n    for i in range(n):\n        if not len(stack1):\n            stack1.append(i)\n        elif a[i] < a[stack1[-1]]:\n            stack1.append(i)\n        else:\n            while 1:\n                if not len(stack1):\n                    break\n                if a[stack1[-1]] <= a[i]:\n                    nge[stack1.pop()] = a[i]\n                else:\n                    break\n            stack1.append(i)\n    a = a[::-1]\n    for i in range(n):\n        if not len(stack2):\n            stack2.append(i)\n        elif a[i] < a[stack2[-1]]:\n            stack2.append(i)\n        else:\n            while 1:\n                if not len(stack2):\n                    break\n                if a[stack2[-1]] <= a[i]:\n                    pge[n - stack2.pop() - 1] = a[i]\n                else:\n                    break\n            stack2.append(i)\n    a = a[::-1]\n    s = set()\n    for i in range(n):\n        if nge[i] != -1:\n            s.add(nge[i] - a[i])\n        if pge[i] != -1:\n            s.add(pge[i] - a[i])\n    print(len(s))", "def sedMax(N, a):\n    s = list()\n    k = set()\n    left = [-1 for _ in range(N)]\n    right = [-1 for _ in range(N)]\n    for i in range(N):\n        while len(s) > 0 and s[-1] < a[i]:\n            s.pop()\n        if len(s) == 0:\n            left[i] = ' '\n        else:\n            left[i] = s[-1]\n        s.append(a[i])\n    s = list()\n    for i in range(N - 1, -1, -1):\n        while len(s) > 0 and s[-1] < a[i]:\n            s.pop()\n        if len(s) == 0:\n            right[i] = ' '\n        else:\n            right[i] = s[-1]\n        s.append(a[i])\n    for i in range(N):\n        if left[i] != ' ':\n            k.add(left[i] - a[i])\n        if right[i] != ' ':\n            k.add(right[i] - a[i])\n    return len(k)\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(sedMax(N, A))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    costs = set()\n    for i in range(2):\n        stack = []\n        for j in range(n):\n            while len(stack) > 0 and stack[-1] <= a[j]:\n                costs.add(a[j] - stack[-1])\n                stack.pop()\n            stack.append(a[j])\n        a.reverse()\n    print(len(costs))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    st = []\n    pairs = []\n    st.append(a[0])\n    for i in range(1, len(a)):\n        while len(st) != 0 and a[i] > st[-1]:\n            pairs.append((st[-1], a[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.append((min(st[-1], a[i]), max(st[-1], a[i])))\n        st.append(a[i])\n    s = set()\n    for i in pairs:\n        s.add(i[1] - i[0])\n    print(len(s))", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = []\n    for j in range(0, 2):\n        stack = []\n        for i in range(0, n):\n            while len(stack) != 0 and stack[-1] <= l[i]:\n                ans.append(l[i] - stack[-1])\n                stack.pop()\n            stack.append(l[i])\n        l.reverse()\n    print(len(set(ans)))\n    t = t - 1", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = []\n    for j in range(0, 2):\n        stack = []\n        for i in range(0, n):\n            while len(stack) != 0 and stack[-1] <= l[i]:\n                ans.append(l[i] - stack[-1])\n                stack.pop()\n            stack.append(l[i])\n        l.reverse()\n    print(len(set(ans)))\n    t = t - 1", "from math import *\nfrom bisect import *\nfrom collections import *\nfrom random import *\nfrom decimal import *\nimport sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef st():\n    return input().rstrip('\\n')\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\nt = inp()\nwhile t:\n    t -= 1\n    n = inp()\n    a = lis()\n    st = [a[0]]\n    f = set()\n    for i in range(1, n):\n        while st and a[i] > st[-1]:\n            f.add(abs(a[i] - st[-1]))\n            st.pop()\n        if st:\n            f.add(abs(st[-1] - a[i]))\n        st.append(a[i])\n    print(len(f))", "def pairs(arr):\n    st = []\n    pairs = []\n    st.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(st) != 0 and arr[i] > st[-1]:\n            pairs.append((st[-1], arr[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.append((min(st[-1], arr[i]), max(st[-1], arr[i])))\n        st.append(arr[i])\n    return pairs\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    x = pairs(a)\n    ans = set()\n    for i in x:\n        ans.add(abs(i[0] - i[1]))\n    print(len(ans))", "import sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\ninp = lambda : list(map(int, sys.stdin.readline().rstrip('\\r\\n').split()))\nmod = 10 ** 9 + 7\nMod = 998244353\nINF = float('inf')\ntc = 1\n(tc,) = inp()\nfor _ in range(tc):\n    (n,) = inp()\n    a = inp()\n    left = []\n    stack = []\n    for i in range(n):\n        while stack and stack[-1] < a[i]:\n            stack.pop()\n        if stack:\n            left.append(stack[-1])\n        else:\n            left.append(-1)\n        stack.append(a[i])\n    stack = []\n    right = []\n    for i in range(n - 1, -1, -1):\n        while stack and stack[-1] < a[i]:\n            stack.pop()\n        if stack:\n            right.append(stack[-1])\n        else:\n            right.append(-1)\n        stack.append(a[i])\n    right.reverse()\n    s = set()\n    for i in range(n):\n        if left[i] != -1:\n            s.add(abs(left[i] - a[i]))\n        if right[i] != -1:\n            s.add(abs(right[i] - a[i]))\n    print(len(s))", "def pairs(arr):\n    st = []\n    pairs = []\n    d = 0\n    st.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(st) != 0 and arr[i] > st[-1]:\n            pairs.append((st[-1], arr[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.append((min(st[-1], arr[i]), max(st[-1], arr[i])))\n        st.append(arr[i])\n    return pairs\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    l = [int(x) for x in input().split()]\n    k = pairs(l)\n    d = len(k)\n    c = []\n    for i in range(d):\n        c.append(abs(k[i][0] - k[i][1]))\n    print(len(set(c)))\n    t -= 1", "def pairs(arr):\n    st = []\n    pairs = []\n    st.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(st) != 0 and arr[i] > st[-1]:\n            pairs.append((st[-1], arr[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.append((min(st[-1], arr[i]), max(st[-1], arr[i])))\n        st.append(arr[i])\n    return pairs\nfor _ in range(int(input())):\n    N = int(input())\n    vec = list(map(int, input().split()))\n    sts = set()\n    st = pairs(vec)\n    for x in st:\n        sts.add(abs(x[0] - x[1]))\n    print(len(sts))", "def pairs(arr):\n    st = []\n    pairs = []\n    st.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(st) != 0 and arr[i] > st[-1]:\n            pairs.append(abs(st[-1] - arr[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.append(min(abs(st[-1] - arr[i]), abs(st[-1] - arr[i])))\n        st.append(arr[i])\n    return pairs\nfrom collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = pairs(l)\n    ans = set(ans)\n    print(len(ans))", "def pairs(arr):\n    st = []\n    pairs = []\n    st.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(st) != 0 and arr[i] > st[-1]:\n            pairs.append((st[-1], arr[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.append((min(st[-1], arr[i]), max(st[-1], arr[i])))\n        st.append(arr[i])\n    return pairs\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    save = pairs(l)\n    s = set()\n    for i in save:\n        s.add(i[1] - i[0])\n    print(len(s))", "def myfunc(arr):\n    stack = []\n    group = set()\n    stack.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(stack) != 0 and arr[i] > stack[-1]:\n            group.add(abs(stack[-1] - arr[i]))\n            stack.pop()\n        if len(stack) != 0:\n            group.add(abs(stack[-1] - arr[i]))\n        stack.append(arr[i])\n    return len(group)\nfor gg in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    s = myfunc(l)\n    print(s)", "def pairs(arr):\n    st = []\n    pairs = []\n    st.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(st) != 0 and arr[i] > st[-1]:\n            pairs.append((st[-1], arr[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.append((min(st[-1], arr[i]), max(st[-1], arr[i])))\n        st.append(arr[i])\n    return pairs\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        A = list(map(int, input().split()))\n        G = {}\n        cnt = 0\n        par = pairs(A)\n        for i in par:\n            (x, y) = i\n            if abs(x - y) not in G:\n                G[abs(x - y)] = 1\n                cnt = cnt + 1\n        print(cnt)\nmain()", "for i in range(int(input())):\n    N = int(input())\n    arr = list((int(i) for i in input().split()))\n    cost = {}\n    j = 1\n    stack = [arr[0]]\n    while j <= N - 1:\n        while stack != []:\n            if stack[-1] <= arr[j]:\n                cost[arr[j] - stack.pop()] = 1\n            else:\n                cost[stack[-1] - arr[j]] = 1\n                break\n        stack.append(arr[j])\n        j += 1\n    print(len(cost))", "def pairs(arr):\n    st = []\n    pairs = []\n    st.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(st) != 0 and arr[i] > st[-1]:\n            pairs.append(abs(st[-1] - arr[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.append(min(abs(st[-1] - arr[i]), abs(st[-1] - arr[i])))\n        st.append(arr[i])\n    return pairs\nfrom collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = pairs(l)\n    ans = set(ans)\n    print(len(ans))", "from sys import stdin, stdout\ninput = stdin.readline\nfrom random import sample\nt = int(input())\nfrom collections import Counter\nfrom math import sqrt, ceil\n\ndef pairs(arr):\n    st = []\n    pairs = []\n    st.append(arr[0])\n    for i in range(1, len(arr)):\n        while len(st) != 0 and arr[i] > st[-1]:\n            pairs.append((st[-1], arr[i]))\n            st.pop()\n        if len(st) != 0:\n            pairs.append((min(st[-1], arr[i]), max(st[-1], arr[i])))\n        st.append(arr[i])\n    return pairs\n\ndef f(arr, i, j, d, dist):\n    if i == j:\n        return\n    nn = max(arr[i:j])\n    for tl in range(i, j):\n        if arr[tl] == nn:\n            dist[tl] = d\n            f(arr, i, tl, d + 1, dist)\n            f(arr, tl + 1, j, d + 1, dist)\n\ndef ps(n):\n    cp = 0\n    while n % 2 == 0:\n        n = n // 2\n        cp += 1\n    for ps in range(3, ceil(sqrt(n)) + 1, 2):\n        while n % ps == 0:\n            n = n // ps\n            cp += 1\n    if n != 1:\n        return False\n    return True\n\ndef find_gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef factorials(n, r):\n    slr = n\n    dpr = r\n    qlr = 1\n    qs = 1\n    mod = 10 ** 9 + 7\n    for ip in range(n - r + 1, n + 1):\n        qlr = qlr * ip % mod\n    for ij in range(1, r + 1):\n        qs = qs * ij % mod\n    ans = qlr * modInverse(qs) % mod\n    return ans\n\ndef modInverse(b):\n    qr = 10 ** 9 + 7\n    return pow(b, qr - 2, qr)\ntt = [xa ** 3 for xa in range(0, 10 ** 4 + 1)]\nqq = set(tt)\nfor jj in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().strip().split()]\n    brr = pairs(arr)\n    skp = set()\n    for xy in brr:\n        skp.add(xy[1] - xy[0])\n    print(len(skp))\n    continue\n    l = 0\n    while l <= n - 2:\n        maxi = arr[l]\n        smaxi = arr[l]\n        for ij in range(l + 1, n):\n            if arr[ij] >= maxi:\n                smaxi = maxi\n                maxi = arr[ij]\n            elif arr[ij] >= smaxi or ij == l + 1:\n                smaxi = arr[ij]\n            skp.add(maxi - smaxi)\n        l += 1\n    print(len(skp))", "def pairs(a):\n    s = []\n    pairs = set()\n    s.append(a[0])\n    for i in range(1, len(a)):\n        while len(s) != 0 and a[i] > s[-1]:\n            pairs.add(abs(s[-1] - a[i]))\n            s.pop()\n        if len(s) != 0:\n            pairs.add(abs(min(s[-1], a[i]) - max(s[-1], a[i])))\n        s.append(a[i])\n    return pairs\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(len(pairs(a)))", "def solve(A, n):\n    possibleValues = set()\n    prevGreaterElemIndices = [-1] * n\n    for i in range(1, n):\n        possibleValues.add(abs(A[i] - A[i - 1]))\n        if A[i] > A[i - 1]:\n            index = i - 1\n            while index >= 0 and prevGreaterElemIndices[index] != -1 and (A[prevGreaterElemIndices[index]] <= A[i]):\n                possibleValues.add(abs(A[i] - A[prevGreaterElemIndices[index]]))\n                index = prevGreaterElemIndices[index]\n            if prevGreaterElemIndices[index] != -1:\n                possibleValues.add(abs(A[i] - A[prevGreaterElemIndices[index]]))\n            prevGreaterElemIndices[i] = prevGreaterElemIndices[index]\n        elif A[i] == A[i - 1]:\n            prevGreaterElemIndices[i] = prevGreaterElemIndices[i - 1]\n        else:\n            prevGreaterElemIndices[i] = i - 1\n    return len(possibleValues)\nt = int(input())\nfor tc in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    result = solve(A, n)\n    print(result)", "from sys import stdin\n\ndef input():\n    return stdin.readline()\nfor _ in range(int(input())):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    temp_list = [nums[0]]\n    sum_set = set()\n    for i in range(1, n):\n        if nums[i] < temp_list[-1]:\n            sum_set.add(temp_list[-1] - nums[i])\n            temp_list.append(nums[i])\n        else:\n            while temp_list and nums[i] >= temp_list[-1]:\n                sum_set.add(nums[i] - temp_list.pop())\n            if temp_list:\n                sum_set.add(temp_list[-1] - nums[i])\n            temp_list.append(nums[i])\n    print(len(sum_set))", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = set()\n    for arr in [arr, arr[::-1]]:\n        s = []\n        for i in arr:\n            while s and s[-1] <= i:\n                ans.add(i - s.pop(-1))\n            s.append(i)\n    print(len(ans))", "from collections import deque\nfor _ in range(int(input())):\n    input()\n    arr = list(map(int, input().split()))\n    d = deque([arr[0]])\n    s = set()\n    for i in range(1, len(arr)):\n        if len(d) < 2:\n            s.add(abs(d[-1] - arr[i]))\n            d.append(arr[i])\n        else:\n            while len(d) > 1 and d[-1] >= d[0]:\n                d.popleft()\n            while len(d) > 1 and arr[i] >= d[-1]:\n                s.add(arr[i] - d.pop())\n            while len(d) > 1 and d[0] <= arr[i]:\n                d.popleft()\n            s.add(abs(d[-1] - arr[i]))\n            d.append(arr[i])\n    print(len(s))", "I = lambda : list(map(int, input().split()))\n(t,) = I()\nfor _ in range(t):\n    (n,) = I()\n    l = I()\n    st = set()\n    stack = []\n    for i in range(n):\n        while stack and stack[-1] < l[i]:\n            st.add(abs(l[i] - stack.pop()))\n        stack.append(l[i])\n        try:\n            cr = len(stack)\n            st.add(abs(stack[0] - stack[1]))\n            st.add(abs(stack[-1] - stack[-2]))\n        except:\n            pass\n    cr = len(stack)\n    if cr > 1:\n        st.add(abs(stack[0] - stack[1]))\n        st.add(abs(stack[-1] - stack[-2]))\n    print(len(st))"]