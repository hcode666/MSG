["import os, sys\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return input().split()\n\ndef getInts():\n    return list(map(int, input().split()))\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\ndef getMat(n):\n    return [getInts() for _ in range(n)]\n\ndef getBin():\n    return list(map(int, list(input())))\n\ndef isInt(s):\n    return '0' <= s[0] <= '9'\n\ndef ceil_(a, b):\n    return a // b + (a % b > 0)\nMOD = 10 ** 9 + 7\n\ndef solve():\n    (N, M, L) = getInts()\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    S = listStr()\n    vertex = listStr()\n    U = [u - 1 for u in getInts()]\n    V = [v - 1 for v in getInts()]\n    orda = ord('a')\n    extras_ = [dd(int)] * 26\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            extras_[ord(vertex[u]) - orda][min(u, v), max(u, v)] += 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts)\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n    return ans % MOD\nfor _ in range(getInt()):\n    print(solve())", "from collections import defaultdict as dd\nimport sys\ninput = sys.stdin.readline\nmod = 1000000007\nfor _ in range(int(input())):\n    (n, m, l) = map(int, input().split())\n    s = input().strip()\n    f = 1\n    for i in range(1, l):\n        if s[i] != s[0]:\n            f = 0\n            break\n    c = input().strip()\n    adj = dd(list)\n    if f:\n        cnt = [[0 for i in range(n)] for j in range(n)]\n    u = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    for i in range(m):\n        (_u, _v) = (u[i], v[i])\n        _u -= 1\n        _v -= 1\n        adj[_u].append(_v)\n        adj[_v].append(_u)\n        if f:\n            if _u > _v:\n                (_u, _v) = (_v, _u)\n            cnt[_u][_v] += 1\n    dp = [[0 for i in range(l)] for i in range(n)]\n    for i in range(n):\n        if c[i] == s[l - 1]:\n            dp[i][l - 1] = 1\n    for j in range(l - 2, -1, -1):\n        for i in range(n):\n            if s[j] != c[i]:\n                continue\n            for x in adj[i]:\n                dp[i][j] += dp[x][j + 1]\n                dp[i][j] %= mod\n    ans = 0\n    for i in range(n):\n        ans += dp[i][0]\n        ans %= mod\n    if f:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if c[i] == c[j] and c[i] == s[0]:\n                    ans -= pow(cnt[i][j], l - 1, mod)\n                    ans %= mod\n    while ans < 0:\n        ans += mod\n    print(ans)", "t = int(input())\nmod = 1000000007\nfor _ in range(t):\n    (n, m, l) = list(map(int, input().split()))\n    s = input()\n    v = input()\n    e1 = list(map(int, input().split()))\n    e2 = list(map(int, input().split()))\n    adj = [[] for _ in range(n + 1)]\n    count = {}\n    for i in range(m):\n        adj[e1[i] - 1].append(e2[i] - 1)\n        adj[e2[i] - 1].append(e1[i] - 1)\n        temp = [e1[i] - 1, e2[i] - 1]\n        temp.sort()\n        if tuple(temp) not in count:\n            count[tuple(temp)] = 0\n        count[tuple(temp)] += 1\n    dp = [[0 for _ in range(l)] for _ in range(n)]\n    for j in range(0, n):\n        if s[0] == v[j]:\n            dp[j][0] = 1\n    for j in range(1, l):\n        for i in range(0, n):\n            if s[j] != v[i]:\n                continue\n            for k in adj[i]:\n                dp[i][j] = (dp[i][j] + dp[k][j - 1]) % mod\n    ans = 0\n    for i in range(0, n):\n        ans = (ans + dp[i][l - 1]) % mod\n    if min(s) == max(s):\n        for i in range(0, n):\n            for j in range(i + 1, n):\n                if v[i] == v[j] and (i, j) in count:\n                    ans = (ans - pow(count[i, j], l - 1, mod) + mod) % mod\n    print(ans)", "import sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\ninp = lambda : list(map(int, sys.stdin.readline().rstrip('\\r\\n').split()))\nmod = 10 ** 9 + 7\nMod = 998244353\nINF = float('inf')\ntc = 1\ntc = int(input())\nfor test in range(1, tc + 1):\n    (n, m, l) = inp()\n    s = str(input())\n    a = str(input())\n    g = [[] for i in range(n)]\n    dp = [[0] * l for i in range(n)]\n    (b, c) = (inp(), inp())\n    for (i, j) in zip(b, c):\n        i -= 1\n        j -= 1\n        g[i].append(j)\n        g[j].append(i)\n    for i in range(n):\n        if a[i] == s[0]:\n            dp[i][0] = 1\n    for i in range(1, l):\n        for node in range(n):\n            if a[node] == s[i]:\n                for edge in g[node]:\n                    dp[node][i] += dp[edge][i - 1]\n                    dp[node][i] %= mod\n    ans = 0\n    for i in range(n):\n        ans += dp[i][-1]\n        ans %= mod\n    if len(set(s)) == 1:\n        mat = [[0] * n for i in range(n)]\n        for i in range(m):\n            mat[b[i] - 1][c[i] - 1] += 1\n            mat[c[i] - 1][b[i] - 1] += 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                if mat[i][j] > 0 and a[i] == s[0] and (a[j] == s[0]):\n                    ans = (ans + mod - pow(mat[i][j], l - 1, mod)) % mod\n    print(ans)", "from collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef solve():\n    (N, M, L) = map(int, input().split())\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    S = list(input())\n    vertex = list(input())\n    U = [u - 1 for u in list(map(int, input().split()))]\n    V = [v - 1 for v in list(map(int, input().split()))]\n    orda = ord('a')\n    extras_ = [defaultdict(int)] * 26\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            extras_[ord(vertex[u]) - orda][min(u, v), max(u, v)] += 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts)\n    if len(set(S)) == 1:\n        ans -= sum([pow(val, L - 1, MOD) for (key, val) in extras_[ord(S[0]) - orda].items()])\n    return ans % MOD\nfor _ in range(int(input())):\n    print(solve())", "from collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef solve():\n    (N, M, L) = map(int, input().split())\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    S = list(input())\n    vertex = list(input())\n    U = [u - 1 for u in list(map(int, input().split()))]\n    V = [v - 1 for v in list(map(int, input().split()))]\n    orda = ord('a')\n    extras_ = [defaultdict(int)] * 26\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            extras_[ord(vertex[u]) - orda][min(u, v), max(u, v)] += 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts)\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n    return ans % MOD\nfor _ in range(int(input())):\n    print(solve())", "import os, sys\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport math, string\nimport heapq as h, time\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return input().split()\n\ndef getInts():\n    return list(map(int, input().split()))\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\ndef getMat(n):\n    return [getInts() for _ in range(n)]\n\ndef getBin():\n    return list(map(int, list(input())))\n\ndef isInt(s):\n    return '0' <= s[0] <= '9'\n\ndef ceil_(a, b):\n    return a // b + (a % b > 0)\nMOD = 10 ** 9 + 7\n\ndef solve():\n    (N, M, L) = getInts()\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    S = listStr()\n    vertex = listStr()\n    U = [u - 1 for u in getInts()]\n    V = [v - 1 for v in getInts()]\n    orda = ord('a')\n    extras_ = [dd(int)] * 26\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            extras_[ord(vertex[u]) - orda][min(u, v), max(u, v)] += 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts)\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n    return ans % MOD\nfor _ in range(getInt()):\n    print(solve())"]