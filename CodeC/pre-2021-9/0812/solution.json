["from bisect import bisect\nfrom math import sqrt, floor\nprime = []\nisprime = [True] * (10 ** 6 + 2)\nisprime[0] = False\nisprime[1] = False\nfor x in range(2, 10 ** 6 + 2):\n    if isprime[x]:\n        prime.append(x)\n        for i in range(2 * x, 10 ** 6 + 2, x):\n            isprime[i] = False\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    sq_rt = floor(sqrt(b)) + 1\n    index = bisect(prime, sq_rt)\n    arr = prime[:index]\n    ans = 0\n    if a <= 1:\n        a = 2\n    isprime = [True] * (b - a + 1)\n    for x in arr:\n        st = floor(a / x) * x\n        if st < a:\n            st += x\n        if st == x:\n            st += x\n        st = st - a\n        for y in range(st, b - a + 1, x):\n            if isprime[y] == True:\n                isprime[y] = [x]\n            else:\n                isprime[y].append(x)\n    for x in range(b - a + 1):\n        if isprime[x] == True:\n            ans += 1\n        else:\n            temp = 1\n            val = a + x\n            if sqrt(val) == int(sqrt(val)):\n                c = 0\n                while val > 1 and c < len(isprime[x]):\n                    elem = isprime[x][c]\n                    t = 0\n                    while val % elem == 0:\n                        t += 1\n                        val = val // elem\n                    temp *= 1 + t\n                    c += 1\n                pos = bisect(prime, temp) - 1\n                if prime[pos] == temp:\n                    ans += 1\n            else:\n                continue\n    print(ans)", "from bisect import bisect\nfrom math import sqrt, floor\nprime = []\nisprime = [True] * (10 ** 6 + 2)\nisprime[0] = False\nisprime[1] = False\nfor x in range(2, 10 ** 6 + 2):\n    if isprime[x]:\n        prime.append(x)\n        for i in range(2 * x, 10 ** 6 + 2, x):\n            isprime[i] = False\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    sq_rt = floor(sqrt(b)) + 1\n    index = bisect(prime, sq_rt)\n    arr = prime[:index]\n    ans = 0\n    if a <= 1:\n        a = 2\n    isprime = [True] * (b - a + 1)\n    for x in arr:\n        st = floor(a / x) * x\n        if st < a:\n            st += x\n        if st == x:\n            st += x\n        st = st - a\n        for y in range(st, b - a + 1, x):\n            if isprime[y] == True:\n                isprime[y] = [x]\n            else:\n                isprime[y].append(x)\n    for x in range(b - a + 1):\n        if isprime[x] == True:\n            ans += 1\n        else:\n            temp = 1\n            val = a + x\n            if sqrt(val) == int(sqrt(val)):\n                c = 0\n                while val > 1 and c < len(isprime[x]):\n                    elem = isprime[x][c]\n                    t = 0\n                    while val % elem == 0:\n                        t += 1\n                        val = val // elem\n                    temp *= 1 + t\n                    c += 1\n                pos = bisect(prime, temp) - 1\n                if prime[pos] == temp:\n                    ans += 1\n            else:\n                continue\n    print(ans)", "from bisect import bisect\nfrom math import sqrt, floor\nprime = []\nisprime = [True] * (10 ** 6 + 2)\nisprime[0] = False\nisprime[1] = False\nfor x in range(2, 10 ** 6 + 2):\n    if isprime[x]:\n        prime.append(x)\n        for i in range(2 * x, 10 ** 6 + 2, x):\n            isprime[i] = False\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    sq_rt = floor(sqrt(b)) + 1\n    index = bisect(prime, sq_rt)\n    arr = prime[:index]\n    ans = 0\n    if a <= 1:\n        a = 2\n    isprime = [True] * (b - a + 1)\n    for x in arr:\n        st = floor(a / x) * x\n        if st < a:\n            st += x\n        if st == x:\n            st += x\n        st = st - a\n        for y in range(st, b - a + 1, x):\n            if isprime[y] == True:\n                isprime[y] = [x]\n            else:\n                isprime[y].append(x)\n    for x in range(b - a + 1):\n        if isprime[x] == True:\n            ans += 1\n        else:\n            temp = 1\n            val = a + x\n            if sqrt(val) == int(sqrt(val)):\n                c = 0\n                while val > 1 and c < len(isprime[x]):\n                    elem = isprime[x][c]\n                    t = 0\n                    while val % elem == 0:\n                        t += 1\n                        val = val // elem\n                    temp *= 1 + t\n                    c += 1\n                pos = bisect(prime, temp) - 1\n                if prime[pos] == temp:\n                    ans += 1\n            else:\n                continue\n    print(ans)", "import bisect\nimport itertools\n\nclass Main:\n\n    def __init__(self):\n        iterable = self.__standard()\n        self.__solution(iterable)\n\n    def __solution(self, iterable):\n        (cases,) = map(int, next(iterable).split())\n        one = 10 ** 6\n        two = 10 ** 3\n        primes0 = [number for (number, really) in enumerate(self.__sieve(one)) if really]\n        primes = set(primes0)\n        for _test in range(cases):\n            (low, high) = map(int, next(iterable).split())\n            total = 0\n            for number in range(two):\n                if number not in primes:\n                    continue\n                value = number\n                exponent = 2\n                while not value > high:\n                    if not value < low and exponent in primes:\n                        total += 1\n                    value *= number\n                    exponent += 1\n            linear = bisect.bisect_right(primes0, high) - bisect.bisect_left(primes0, max(low, two))\n            if linear > 0:\n                total += linear\n            for number in range(two + 1, min(high + 1, one), 2):\n                if number not in primes:\n                    continue\n                square = number * number\n                if square > high:\n                    break\n                if not square < low:\n                    total += 1\n            sieveLow = max(one, low)\n            sieveHigh = high + 1\n            if sieveHigh > sieveLow:\n                sieve = [True] * (sieveHigh - sieveLow)\n                for prime in primes0:\n                    first = -sieveLow % prime\n                    count = (len(sieve) - first - 1) // prime + 1\n                    sieve[first::prime] = [False] * count\n                total += sum(sieve)\n            print(total)\n\n    def __sieve(self, limit):\n        size = limit + 1\n        sieve = [True]\n        head = []\n        for prime in self.__generator():\n            previous = len(sieve)\n            count = previous * prime\n            if not count < size:\n                break\n            sieve *= prime\n            sieve[::prime] = [False] * previous\n            head.append(prime)\n        sieve *= (size - 1) // len(sieve) + 1\n        del sieve[size:]\n        sieve[1] = False\n        for last in head:\n            sieve[last] = True\n        first = last + 2\n        for prime in itertools.count(first, 2):\n            square = prime * prime\n            if square > limit:\n                break\n            if not sieve[prime]:\n                continue\n            step = prime << 1\n            count = (size - square - 1) // step + 1\n            sieve[square::step] = [False] * count\n        return sieve\n\n    def __generator(self):\n        yield 2\n        for candidate in itertools.count(3, 2):\n            for divisor in itertools.count(3, 2):\n                if divisor * divisor > candidate:\n                    yield candidate\n                    break\n                if not candidate % divisor:\n                    break\n\n    def __test(self):\n        yield '1'\n        yield '1 10'\n\n    def __standard(self):\n        try:\n            while True:\n                yield input()\n        except EOFError:\n            pass\nMain()"]