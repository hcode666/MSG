["from sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(2 ** 27)\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\nclass MergeFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            (a, b) = (b, a)\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + '\\n')\n\ndef prime_factors(n):\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return factors\n\ndef all_factors(n):\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\ndef fibonacci_modP(n, MOD):\n    if n < 2:\n        return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n, p):\n    if p <= n:\n        return 0\n    res = p - 1\n    for i in range(n + 1, p):\n        res = res * cached_fn(InverseEuler, i, p) % p\n    return res\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\ndef is_prime(n):\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\nfactorial_modP = []\n\ndef warm_up_fac(MOD):\n    global factorial_modP, fac_warm_up\n    if fac_warm_up:\n        return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = factorial_modP[i - 1] * i % MOD\n    fac_warm_up = True\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\ndef nCr(n, r, MOD):\n    global fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return factorial_modP[n] * (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD) % MOD) % MOD\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nmemory = dict()\n\ndef clear_cache():\n    global memory\n    memory = dict()\n\ndef cached_fn(fn, *args):\n    global memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:\n            x += b\n        b = b // 2\n    return x\nTestCases = True\noptimise_for_recursion = True\nfrom functools import cmp_to_key\n\nclass SubTree:\n\n    def __init__(self, zeros, ones, inversions):\n        self.zeros = zeros\n        self.ones = ones\n        self.inversions = inversions\n\n    def __str__(self):\n        return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\ndef dfs(root):\n    global visited, adj, weights\n    visited[root] = True\n    child = [vertex for vertex in adj[root] if not visited[vertex]]\n    if len(child) == 0:\n        return SubTree(weights[root] ^ 1, weights[root], 0)\n    results = [dfs(i) for i in child]\n    results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n    (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n    factor = weights[root]\n    for sub_tree in results:\n        zeros += sub_tree.zeros\n        ones += sub_tree.ones\n        inversions += factor * sub_tree.zeros + sub_tree.inversions\n        factor += sub_tree.ones\n    return SubTree(zeros, ones, inversions)\n\ndef main():\n    global visited, adj, weights\n    n = get_int()\n    weights = get_list()\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (x, y) = get_tuple()\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False for _ in range(n)]\n    print(dfs(0).inversions)\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()", "from sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(2 ** 27)\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\nclass MergeFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            (a, b) = (b, a)\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + '\\n')\n\ndef prime_factors(n):\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return factors\n\ndef all_factors(n):\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\ndef fibonacci_modP(n, MOD):\n    if n < 2:\n        return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n, p):\n    if p <= n:\n        return 0\n    res = p - 1\n    for i in range(n + 1, p):\n        res = res * cached_fn(InverseEuler, i, p) % p\n    return res\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\ndef is_prime(n):\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\nfactorial_modP = []\n\ndef warm_up_fac(MOD):\n    global factorial_modP, fac_warm_up\n    if fac_warm_up:\n        return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = factorial_modP[i - 1] * i % MOD\n    fac_warm_up = True\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\ndef nCr(n, r, MOD):\n    global fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return factorial_modP[n] * (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD) % MOD) % MOD\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nmemory = dict()\n\ndef clear_cache():\n    global memory\n    memory = dict()\n\ndef cached_fn(fn, *args):\n    global memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:\n            x += b\n        b = b // 2\n    return x\nTestCases = True\noptimise_for_recursion = True\nfrom functools import cmp_to_key\n\nclass SubTree:\n\n    def __init__(self, zeros, ones, inversions):\n        self.zeros = zeros\n        self.ones = ones\n        self.inversions = inversions\n\n    def __str__(self):\n        return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\ndef dfs(root):\n    global visited, adj, weights\n    visited[root] = True\n    child = [vertex for vertex in adj[root] if not visited[vertex]]\n    if len(child) == 0:\n        return SubTree(weights[root] ^ 1, weights[root], 0)\n    results = [dfs(i) for i in child]\n    results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n    (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n    factor = weights[root]\n    for sub_tree in results:\n        zeros += sub_tree.zeros\n        ones += sub_tree.ones\n        inversions += factor * sub_tree.zeros + sub_tree.inversions\n        factor += sub_tree.ones\n    return SubTree(zeros, ones, inversions)\n\ndef main():\n    global visited, adj, weights\n    n = get_int()\n    weights = get_list()\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (x, y) = get_tuple()\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False for _ in range(n)]\n    print(dfs(0).inversions)\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()", "from abc import ABC, abstractmethod\nimport numpy as np\n\ndef get_int(source):\n    return int(source())\n\ndef get_ints(source):\n    return [int(x) for x in source().split(' ')]\n\ndef getline_from_std():\n    return input()\n\nclass IOProcessing(ABC):\n\n    @abstractmethod\n    def read_test_case(self, source):\n        pass\n\n    @abstractmethod\n    def process_test_case(self, tcase):\n        pass\n\n    def solve(self, input_type='from_std', output_type='to_std', input_path='', output_path='output.txt', tcase_handling='all'):\n        ans = []\n        if input_type == 'from_file':\n            with open(input_path, 'r') as in_file:\n                t = int(in_file.readline())\n                for _ in range(t):\n                    tcase = self.read_test_case(in_file.readline)\n                    ans.append(self.process_test_case(tcase))\n                    if tcase_handling == 'single' and output_type == 'to_std':\n                        print(ans[-1])\n        elif input_type == 'from_std':\n            t = int(getline_from_std())\n            for _ in range(t):\n                tcase = self.read_test_case(getline_from_std)\n                ans.append(self.process_test_case(tcase))\n                if tcase_handling == 'single' and output_type == 'to_std':\n                    print(ans[-1])\n        if output_type == 'to_file':\n            with open(output_path, 'w') as output:\n                for a in ans:\n                    output.write(a)\n        elif output_type == 'to_std' and tcase_handling == 'all':\n            for a in ans:\n                print(a)\nimport numpy as np\nimport sys\n\nclass Ex_1_io(IOProcessing):\n\n    def read_test_case(self, source):\n        n = get_int(source)\n        w = get_ints(source)\n        edges = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (p, q) = get_ints(source)\n            edges[p - 1].append(q - 1)\n            edges[q - 1].append(p - 1)\n        return (n, w, edges)\n\n    def process_test_case(self, tcase):\n        n = tcase[0]\n        w = tcase[1]\n        edges = tcase[2]\n        inv = [0] * n\n        wcount = [np.array([0, 0])] * n\n        visited = [False] * n\n\n        def dfs(v):\n            visited[v] = True\n            ans = 0\n            wcount_new = np.array([1 - w[v], w[v]])\n            wcount_children = []\n            for v0 in edges[v]:\n                if not visited[v0]:\n                    dfs(v0)\n                    ans += inv[v0]\n                    wcount_new += wcount[v0]\n                    wcount_children.append(wcount[v0])\n            wcount_children.sort(key=lambda wc: -wc[0] / (wc[0] + wc[1]))\n            sum_of_ones = 0\n            sum_of_zeroes = 0\n            for wc in wcount_children:\n                ans += wc[0] * sum_of_ones\n                sum_of_ones += wc[1]\n                sum_of_zeroes += wc[0]\n            if w[v] == 1:\n                ans += sum_of_zeroes\n            inv[v] = ans\n            wcount[v] = wcount_new\n        dfs(0)\n        return inv[0]\nsys.setrecursionlimit(1000000)\nsolution = Ex_1_io()\nsolution.solve(input_type='from_std', output_type='to_std', input_path='input.txt', output_path='output.txt', tcase_handling='all')"]