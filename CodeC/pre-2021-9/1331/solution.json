["mod = 10 ** 9 + 7\nfrom math import gcd\n\ndef fac50():\n    f = [0] * 51\n    (f[0], f[1]) = (1, 1)\n    for i in range(1, 51):\n        f[i] = f[i - 1] * i % mod\n    return f\n\ndef gcd110():\n    gc = [[0] * 111 for i in range(111)]\n    for i in range(111):\n        for j in range(111):\n            gc[i][j] = gcd(i, j)\n    return gc\n(factorials, gcds) = (fac50(), gcd110())\n\ndef rule_asc(n, l):\n    (a, k) = ([0 for i in range(n + 1)], 1)\n    a[1] = n\n    while k != 0:\n        (x, y) = (a[k - 1] + 1, a[k] - 1)\n        k -= 1\n        while x <= y and k < l - 1:\n            (a[k], y) = (x, y - x)\n            k += 1\n        a[k] = x + y\n        yield a[:k + 1]\n\ndef niceness(s):\n    t = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            t = (t + gcds[s[i]][s[j]]) % mod\n    return t\n\ndef permcount(s, c):\n    (f, p) = ([s.count(x) for x in set(s)], factorials[c])\n    for e in f:\n        p = p * pow(factorials[e], mod - 2, mod) % mod\n    return p\n\ndef main():\n    for i in range(int(input())):\n        (n, s) = [int(item) for item in input().split()]\n        a = [int(item) for item in input().split()]\n        b = [i for i in a if i != -1]\n        (s, ones) = (s - sum(b), a.count(-1))\n        if s < 0:\n            print(0)\n        elif s == 0 and ones == 0:\n            print(niceness(a) % mod)\n        elif s > 0 and ones == 0:\n            print(0)\n        else:\n            t = 0\n            for seq in rule_asc(s, ones):\n                if len(seq) == ones:\n                    t = (t + permcount(seq, ones) % mod * (niceness(b + seq) % mod) % mod) % mod\n            print(t)\nmain()", "mod = 10 ** 9 + 7\nfrom math import gcd\n\ndef fac50():\n    f = [0] * 51\n    (f[0], f[1]) = (1, 1)\n    for i in range(1, 51):\n        f[i] = f[i - 1] * i % mod\n    return f\n\ndef gcd110():\n    gc = [[0] * 111 for i in range(111)]\n    for i in range(111):\n        for j in range(111):\n            gc[i][j] = gcd(i, j)\n    return gc\n(factorials, gcds) = (fac50(), gcd110())\n\ndef rule_asc(n, l):\n    (a, k) = ([0 for i in range(n + 1)], 1)\n    a[1] = n\n    while k != 0:\n        (x, y) = (a[k - 1] + 1, a[k] - 1)\n        k -= 1\n        while x <= y and k < l - 1:\n            (a[k], y) = (x, y - x)\n            k += 1\n        a[k] = x + y\n        yield a[:k + 1]\n\ndef niceness(s):\n    t = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            t = (t + gcds[s[i]][s[j]]) % mod\n    return t\n\ndef permcount(s, c):\n    (f, p) = ([s.count(x) for x in set(s)], factorials[c])\n    for e in f:\n        p = p * pow(factorials[e], mod - 2, mod) % mod\n    return p\n\ndef main():\n    for i in range(int(input())):\n        (n, s) = [int(item) for item in input().split()]\n        a = [int(item) for item in input().split()]\n        b = [i for i in a if i != -1]\n        (s, ones) = (s - sum(b), a.count(-1))\n        if s < 0:\n            print(0)\n        elif s == 0 and ones == 0:\n            print(niceness(a) % mod)\n        elif s > 0 and ones == 0:\n            print(0)\n        else:\n            t = 0\n            for seq in rule_asc(s, ones):\n                if len(seq) == ones:\n                    t = (t + permcount(seq, ones) % mod * (niceness(b + seq) % mod) % mod) % mod\n            print(t)\nmain()", "mod = 10 ** 9 + 7\nfrom math import gcd\n\ndef fac50():\n    f = [0] * 51\n    (f[0], f[1]) = (1, 1)\n    for i in range(1, 51):\n        f[i] = f[i - 1] * i % mod\n    return f\n\ndef gcd110():\n    gc = [[0] * 111 for i in range(111)]\n    for i in range(111):\n        for j in range(111):\n            gc[i][j] = gcd(i, j)\n    return gc\n(factorials, gcds) = (fac50(), gcd110())\n\ndef rule_asc(n, l):\n    (a, k) = ([0 for i in range(n + 1)], 1)\n    a[1] = n\n    while k != 0:\n        (x, y) = (a[k - 1] + 1, a[k] - 1)\n        k -= 1\n        while x <= y and k < l - 1:\n            (a[k], y) = (x, y - x)\n            k += 1\n        a[k] = x + y\n        yield a[:k + 1]\n\ndef niceness(s):\n    t = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            t = (t + gcds[s[i]][s[j]]) % mod\n    return t\n\ndef permcount(s, c):\n    (f, p) = ([s.count(x) for x in set(s)], factorials[c])\n    for e in f:\n        p = p * pow(factorials[e], mod - 2, mod) % mod\n    return p\n\ndef main():\n    for i in range(int(input())):\n        (n, s) = [int(item) for item in input().split()]\n        a = [int(item) for item in input().split()]\n        b = [i for i in a if i != -1]\n        (s, ones) = (s - sum(b), a.count(-1))\n        if s < 0:\n            print(0)\n        elif s == 0 and ones == 0:\n            print(niceness(a) % mod)\n        elif s > 0 and ones == 0:\n            print(0)\n        else:\n            t = 0\n            for seq in rule_asc(s, ones):\n                if len(seq) == ones:\n                    t = (t + permcount(seq, ones) % mod * (niceness(b + seq) % mod) % mod) % mod\n            print(t)\nmain()", "mod = 10 ** 9 + 7\nfrom math import gcd\n\ndef fac50():\n    f = [0] * 51\n    (f[0], f[1]) = (1, 1)\n    for i in range(1, 51):\n        f[i] = f[i - 1] * i % mod\n    return f\n\ndef gcd110():\n    gc = [[0] * 111 for i in range(111)]\n    for i in range(111):\n        for j in range(111):\n            gc[i][j] = gcd(i, j)\n    return gc\n(factorials, gcds) = (fac50(), gcd110())\n\ndef rule_asc(n, l):\n    (a, k) = ([0 for i in range(n + 1)], 1)\n    a[1] = n\n    while k != 0:\n        (x, y) = (a[k - 1] + 1, a[k] - 1)\n        k -= 1\n        while x <= y and k < l - 1:\n            (a[k], y) = (x, y - x)\n            k += 1\n        a[k] = x + y\n        yield a[:k + 1]\n\ndef niceness(s):\n    t = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            t = (t + gcds[s[i]][s[j]]) % mod\n    return t\n\ndef permcount(s, c):\n    (f, p) = ([s.count(x) for x in set(s)], factorials[c])\n    for e in f:\n        p = p * pow(factorials[e], mod - 2, mod) % mod\n    return p\n\ndef main():\n    for i in range(int(input())):\n        (n, s) = [int(item) for item in input().split()]\n        a = [int(item) for item in input().split()]\n        b = [i for i in a if i != -1]\n        (s, ones) = (s - sum(b), a.count(-1))\n        if s < 0:\n            print(0)\n        elif s == 0 and ones == 0:\n            print(niceness(a) % mod)\n        elif s > 0 and ones == 0:\n            print(0)\n        else:\n            t = 0\n            for seq in rule_asc(s, ones):\n                if len(seq) == ones:\n                    t = (t + permcount(seq, ones) % mod * (niceness(b + seq) % mod) % mod) % mod\n            print(t)\nmain()", "mod = 10 ** 9 + 7\nfrom math import gcd\n\ndef fac50():\n    f = [0] * 51\n    (f[0], f[1]) = (1, 1)\n    for i in range(1, 51):\n        f[i] = f[i - 1] * i % mod\n    return f\n\ndef gcd110():\n    gc = [[0] * 111 for i in range(111)]\n    for i in range(111):\n        for j in range(111):\n            gc[i][j] = gcd(i, j)\n    return gc\n(factorials, gcds) = (fac50(), gcd110())\n\ndef rule_asc(n, l):\n    (a, k) = ([0 for i in range(n + 1)], 1)\n    a[1] = n\n    while k != 0:\n        (x, y) = (a[k - 1] + 1, a[k] - 1)\n        k -= 1\n        while x <= y and k < l - 1:\n            (a[k], y) = (x, y - x)\n            k += 1\n        a[k] = x + y\n        yield a[:k + 1]\n\ndef niceness(s):\n    t = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            t = (t + gcds[s[i]][s[j]]) % mod\n    return t\n\ndef permcount(s, c):\n    (f, p) = ([s.count(x) for x in set(s)], factorials[c])\n    for e in f:\n        p = p * pow(factorials[e], mod - 2, mod) % mod\n    return p\n\ndef main():\n    for i in range(int(input())):\n        (n, s) = [int(item) for item in input().split()]\n        a = [int(item) for item in input().split()]\n        b = [i for i in a if i != -1]\n        (s, ones) = (s - sum(b), a.count(-1))\n        if s < 0:\n            print(0)\n        elif s == 0 and ones == 0:\n            print(niceness(a) % mod)\n        elif s > 0 and ones == 0:\n            print(0)\n        else:\n            t = 0\n            for seq in rule_asc(s, ones):\n                if len(seq) == ones:\n                    t = (t + permcount(seq, ones) % mod * (niceness(b + seq) % mod) % mod) % mod\n            print(t)\nmain()", "mod = 10 ** 9 + 7\n\ndef gcd(a, b):\n    return b and gcd(b, a % b) or a\n\ndef fac50():\n    f = [0] * 51\n    f[0] = 1\n    f[1] = 1\n    for i in range(1, 51):\n        f[i] = f[i - 1] * i % mod\n    return f\n\ndef gcd110():\n    gc = [[0] * 111 for i in range(111)]\n    for i in range(111):\n        for j in range(111):\n            gc[i][j] = gcd(i, j)\n    return gc\nfactorials = fac50()\ngcds = gcd110()\n\ndef rule_asc(n, l):\n    a = [0 for i in range(n + 1)]\n    k = 1\n    a[1] = n\n    while k != 0:\n        x = a[k - 1] + 1\n        y = a[k] - 1\n        k -= 1\n        while x <= y and k < l - 1:\n            a[k] = x\n            y -= x\n            k += 1\n        a[k] = x + y\n        yield a[:k + 1]\n\ndef niceness(s):\n    t = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            t = (t + gcds[s[i]][s[j]]) % mod\n    return t\n\ndef permcount(s, c):\n    f = [s.count(x) for x in set(s)]\n    p = factorials[c]\n    for e in f:\n        p = p * pow(factorials[e], mod - 2, mod) % mod\n    return p\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        (n, s) = [int(item) for item in input().split()]\n        a = [int(item) for item in input().split()]\n        b = [i for i in a if i != -1]\n        s -= sum(b)\n        ones = a.count(-1)\n        if s < 0:\n            print(0)\n        elif s == 0 and ones == 0:\n            print(niceness(a) % mod)\n        elif s > 0 and ones == 0:\n            print(0)\n        else:\n            t = 0\n            for seq in rule_asc(s, ones):\n                if len(seq) == ones:\n                    p = permcount(seq, ones)\n                    t = (t + p % mod * (niceness(b + seq) % mod) % mod) % mod\n            print(t)\nmain()"]