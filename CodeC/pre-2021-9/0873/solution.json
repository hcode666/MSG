["import heapq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    ans = 0\n    pri1 = list(map(int, input().split()))\n    pri = [-x for x in pri1]\n    heapq.heapify(pri)\n    if b >= z:\n        print('RIP')\n        continue\n    p = (z - 1 - b) // y\n    a = a + x * p\n    while a < z:\n        mx = -heapq.heappop(pri)\n        if mx == 0:\n            break\n        else:\n            a += mx\n            ans += 1\n            heapq.heappush(pri, -(mx // 2))\n    if a >= z:\n        print(ans)\n    else:\n        print('RIP')", "import heapq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    ans = 0\n    pri1 = list(map(int, input().split()))\n    pri = [-x for x in pri1]\n    heapq.heapify(pri)\n    if b >= z:\n        print('RIP')\n        continue\n    p = (z - 1 - b) // y\n    a = a + x * p\n    while a < z:\n        mx = -heapq.heappop(pri)\n        if mx == 0:\n            break\n        else:\n            a += mx\n            ans += 1\n            heapq.heappush(pri, -(mx // 2))\n    if a >= z:\n        print(ans)\n    else:\n        print('RIP')", "import heapq as hq\nfrom math import floor\nT = int(input())\nfor i in range(T):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = [-int(i) for i in input().split()]\n    days = (z - b - 1) // y\n    ans = 0\n    hq.heapify(arr)\n    curr = a + days * x\n    while curr < z:\n        u = hq.heappop(arr)\n        u = -u\n        if u == 0:\n            break\n        else:\n            curr += u\n            ans += 1\n            hq.heappush(arr, -(u // 2))\n    if curr >= z:\n        print(ans)\n    else:\n        print('RIP')", "import heapq as hq\nfrom math import floor\nT = int(input())\nfor i in range(T):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = [-int(i) for i in input().split()]\n    days = (z - b - 1) // y\n    ans = 0\n    hq.heapify(arr)\n    curr = a + days * x\n    while curr < z:\n        u = hq.heappop(arr)\n        u = -u\n        if u == 0:\n            break\n        else:\n            curr += u\n            ans += 1\n            hq.heappush(arr, -(u // 2))\n    if curr >= z:\n        print(ans)\n    else:\n        print('RIP')", "import heapq as hq\nfrom math import floor\nT = int(input())\nfor i in range(T):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = [-int(i) for i in input().split()]\n    days = (z - b - 1) // y\n    ans = 0\n    hq.heapify(arr)\n    curr = a + days * x\n    while curr < z:\n        u = hq.heappop(arr)\n        u = -u\n        if u == 0:\n            break\n        else:\n            curr += u\n            ans += 1\n            hq.heappush(arr, -(u // 2))\n    if curr >= z:\n        print(ans)\n    else:\n        print('RIP')", "import heapq as hq\nfrom math import floor\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = [-int(i) for i in input().split()]\n    days = (z - b - 1) // y\n    ans = 0\n    hq.heapify(arr)\n    curr = a + days * x\n    while curr < z:\n        u = hq.heappop(arr)\n        u = -u\n        if u == 0:\n            break\n        else:\n            curr += u\n            ans += 1\n            hq.heappush(arr, -(u // 2))\n    if curr >= z:\n        print(ans)\n    else:\n        print('RIP')", "import heapq as hq\nfrom math import floor\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = [-int(i) for i in input().split()]\n    days = (z - b - 1) // y\n    ans = 0\n    hq.heapify(arr)\n    curr = a + days * x\n    while curr < z:\n        u = hq.heappop(arr)\n        u = -u\n        if u == 0:\n            break\n        else:\n            curr += u\n            ans += 1\n            hq.heappush(arr, -(u // 2))\n    if curr >= z:\n        print(ans)\n    else:\n        print('RIP')", "import heapq as hq\nfrom math import floor\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = [-int(i) for i in input().split()]\n    days = (z - b - 1) // y\n    ans = 0\n    hq.heapify(arr)\n    curr = a + days * x\n    while curr < z:\n        u = hq.heappop(arr)\n        u = -u\n        if u == 0:\n            break\n        else:\n            curr += u\n            ans += 1\n            hq.heappush(arr, -(u // 2))\n    if curr >= z:\n        print(ans)\n    else:\n        print('RIP')", "import heapq as hq\nfrom math import floor\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = [-int(i) for i in input().split()]\n    days = floor((z - b - 1) / y)\n    ans = 0\n    hq.heapify(arr)\n    curr = a + days * x\n    while curr < z:\n        u = hq.heappop(arr)\n        u = -u\n        if u == 0:\n            break\n        else:\n            curr += u\n            ans += 1\n            hq.heappush(arr, -(u // 2))\n    if curr >= z:\n        print(ans)\n    else:\n        print('RIP')", "import heapq as hq\nfrom math import floor\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = [-int(i) for i in input().split()]\n    days = floor((z - b) / y)\n    if b + y * days == z:\n        z += 1\n    ans = 0\n    hq.heapify(arr)\n    curr = a + days * x\n    while curr < z:\n        u = hq.heappop(arr)\n        u = -u\n        if u == 0:\n            break\n        else:\n            curr += u\n            ans += 1\n            hq.heappush(arr, -(u // 2))\n    if curr >= z:\n        print(ans)\n    else:\n        print('RIP')", "import heapq\nfrom math import ceil, floor\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    s = [-int(i) for i in input().split()]\n    days = floor((z - b) / y)\n    current = a + days * x\n    if b + days * y == z:\n        z += 1\n    count = 0\n    heapq.heapify(s)\n    while current < z:\n        ret = heapq.heappop(s)\n        ret = -ret\n        if ret == 0:\n            break\n        else:\n            current += ret\n            heapq.heappush(s, -(ret // 2))\n        count += 1\n    print(count) if current >= z else print('RIP')", "import heapq\nfrom math import ceil, floor\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    s = [-int(i) for i in input().split()]\n    days = floor((z - b) / y)\n    current = a + days * x\n    if b + days * y == z:\n        z += 1\n    count = 0\n    heapq.heapify(s)\n    while current < z:\n        ret = heapq.heappop(s)\n        ret = -ret\n        if ret == 0:\n            break\n        else:\n            current += ret\n            heapq.heappush(s, -(ret // 2))\n        count += 1\n    print(count) if current >= z else print('RIP')", "import heapq\nimport math\nfor i in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    cntrbtns = list(map(int, input().split()))\n    t = math.ceil((z - b) / y)\n    sumy = a + x * (t - 1)\n    if sum(cntrbtns) * 2 + sumy < z:\n        print('RIP')\n        continue\n    c = 0\n    for i in range(n):\n        cntrbtns[i] = -cntrbtns[i]\n    heapq.heapify(cntrbtns)\n    ele = 0\n    while True:\n        if sumy >= z:\n            print(c)\n            break\n        ele = heapq.heappushpop(cntrbtns, math.ceil(ele / 2))\n        if ele == 0:\n            print('RIP')\n            break\n        sumy -= ele\n        c += 1", "import heapq\nimport math\nfor i in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    cntrbtns = list(map(int, input().split()))\n    t = math.ceil((z - b) / y)\n    sumy = a + x * (t - 1)\n    if sum(cntrbtns) * 2 + sumy < z:\n        print('RIP')\n        continue\n    c = 0\n    for i in range(n):\n        cntrbtns[i] = -cntrbtns[i]\n    heapq.heapify(cntrbtns)\n    ele = 0\n    while True:\n        if sumy >= z:\n            print(c)\n            break\n        ele = heapq.heappushpop(cntrbtns, math.ceil(ele / 2))\n        if ele == 0:\n            print('RIP')\n            break\n        sumy -= ele\n        c += 1", "import heapq\n\ndef func(a):\n    return -int(a)\nT = int(input())\nfor i in range(T):\n    (N, A, B, X, Y, Z) = list(map(int, input().split()))\n    c = list(map(func, input().split()))\n    heapq.heapify(c)\n    day = (Z - B) // Y\n    if (Z - B) % Y != 0:\n        day += 1\n    dif = Z - (A + (day - 1) * X)\n    ans = 0\n    if -2 * sum(c) < dif:\n        print('RIP')\n        continue\n    while dif > 0:\n        m = heapq.heappop(c)\n        m = -m\n        if m == 0:\n            break\n        heapq.heappush(c, -(m // 2))\n        dif -= m\n        ans += 1\n    if dif > 0:\n        print('RIP')\n    else:\n        print(ans)", "import heapq\n\ndef func(a):\n    return -int(a)\nT = int(input())\nfor i in range(T):\n    (N, A, B, X, Y, Z) = list(map(int, input().split()))\n    c = list(map(func, input().split()))\n    heapq.heapify(c)\n    day = (Z - B) // Y\n    if (Z - B) % Y != 0:\n        day += 1\n    dif = Z - (A + (day - 1) * X)\n    ans = 0\n    while dif > 0:\n        m = heapq.heappop(c)\n        m = -m\n        if m == 0:\n            break\n        heapq.heappush(c, -(m // 2))\n        dif -= m\n        ans += 1\n    if dif > 0:\n        print('RIP')\n    else:\n        print(ans)", "import heapq\nfrom math import ceil\nfor i in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    cntrbtns = [-int(x) for x in input().split()]\n    if b >= z:\n        print('RIP')\n        continue\n    sum = a + x * (ceil((z - b) / y) - 1)\n    c = 0\n    heapq.heapify(cntrbtns)\n    ele = 0\n    while sum < z and any(cntrbtns):\n        ele = -heapq.heappop(cntrbtns)\n        sum += ele\n        heapq.heappush(cntrbtns, -(ele >> 1))\n        c += 1\n    print(['RIP', c][sum >= z])", "import heapq\nfrom math import ceil\nfor i in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    cntrbtns = [-int(x) for x in input().split()]\n    if b >= z:\n        print('RIP')\n        continue\n    sum = a + x * (ceil((z - b) / y) - 1)\n    c = 0\n    heapq.heapify(cntrbtns)\n    ele = 0\n    while sum < z and any(cntrbtns):\n        ele = -heapq.heappushpop(cntrbtns, -(ele >> 1))\n        sum += ele\n        c += 1\n    print(['RIP', c][sum >= z])", "import heapq\nfrom math import ceil\nfor i in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    cntrbtns = [-int(x) for x in input().split()]\n    if b >= z:\n        print('RIP')\n        continue\n    sum = a + x * (ceil((z - b) / y) - 1)\n    c = 0\n    heapq.heapify(cntrbtns)\n    ele = 0\n    while True:\n        if sum >= z:\n            print(c)\n            break\n        ele = -ele\n        ele = heapq.heappushpop(cntrbtns, -(ele >> 1))\n        if ele == 0:\n            print('RIP')\n            break\n        sum -= ele\n        c += 1", "import heapq\nfrom math import ceil\nfor i in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    cntrbtns = [-int(x) for x in input().split()]\n    if b >= z:\n        print('RIP')\n        continue\n    t = ceil((z - b) / y)\n    sum = a + x * (t - 1)\n    c = 0\n    heapq.heapify(cntrbtns)\n    ele = 0\n    while True:\n        if sum >= z:\n            print(c)\n            break\n        ele = -ele\n        ele = heapq.heappushpop(cntrbtns, -(ele >> 1))\n        if ele == 0:\n            print('RIP')\n            break\n        sum -= ele\n        c += 1", "import heapq\nfrom math import ceil\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = [int(i) for i in input().split()]\n    A = [-int(i) for i in input().split()]\n    heapq.heapify(A)\n    days = ceil((z - b) / y)\n    pig = z - a\n    if ceil((pig + 2 * sum(A)) / x) >= days:\n        print('RIP')\n    else:\n        ans = 0\n        while ceil(pig / x) >= days and any(A):\n            use = -heapq.heappop(A)\n            pig -= use\n            heapq.heappush(A, -(use >> 1))\n            ans += 1\n        print(['RIP', ans][ceil(pig / x) < days])", "import heapq\nimport math\nfor i in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    cntrbtns = [-int(x) for x in input().split()]\n    if b >= z:\n        print('RIP')\n        continue\n    t = math.ceil((z - b) / y)\n    sum = a + x * (t - 1)\n    c = 0\n    heapq.heapify(cntrbtns)\n    ele = 0\n    while True:\n        if sum >= z:\n            print(c)\n            break\n        ele = -ele\n        ele = heapq.heappushpop(cntrbtns, -(ele >> 1))\n        if ele == 0:\n            print('RIP')\n            break\n        sum -= ele\n        c += 1", "from collections import deque\nimport math\n\ndef solve(nums, d, z):\n    q1 = deque(sorted(nums, reverse=True))\n    q2 = deque()\n    c = 0\n    if d >= z:\n        return c\n    while True:\n        if len(q1) == 0 and len(q2) == 0:\n            break\n        if not q2 or q1[0] > q2[0]:\n            ele = q1.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 1:\n                q2.append(ele)\n        else:\n            ele = q2.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 2:\n                q2.append(ele)\n        if not q1:\n            (q1, q2) = (q2, q1)\n    if d >= z:\n        return c\n    return 'RIP'\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    queries = set([])\n    c = z - b\n    c = math.ceil(c / y) - 1\n    d = a + x * c\n    if d >= z:\n        print(0)\n    else:\n        print(solve(nums, d, z))", "from collections import deque\nimport math\n\ndef solve(nums, d, z):\n    q1 = deque(sorted(nums, reverse=True))\n    q2 = deque()\n    c = 0\n    if d >= z:\n        return c\n    while True:\n        if len(q1) == 0 and len(q2) == 0:\n            break\n        if not q2 or q1[0] > q2[0]:\n            ele = q1.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 1:\n                q2.append(ele)\n        else:\n            ele = q2.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 2:\n                q2.append(ele)\n        if not q1:\n            (q1, q2) = (q2, q1)\n    if d >= z:\n        return c\n    return 'RIP'\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    queries = set([])\n    c = z - b\n    c = math.ceil(c / y) - 1\n    d = a + x * c\n    if d >= z:\n        print(0)\n    else:\n        print(solve(nums, d, z))", "import heapq\nimport math\nfor i in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    cntrbtns = [-int(x) for x in input().split()]\n    if b >= z:\n        print('RIP')\n        continue\n    t = math.ceil((z - b) / y)\n    sum = a + x * (t - 1)\n    c = 0\n    heapq.heapify(cntrbtns)\n    ele = 0\n    while True:\n        if sum >= z:\n            print(c)\n            break\n        ele = -ele\n        ele = heapq.heappushpop(cntrbtns, -(ele // 2))\n        if ele == 0:\n            print('RIP')\n            break\n        sum -= ele\n        c += 1", "import heapq\nimport math\nfor i in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    cntrbtns = list(map(int, input().split()))\n    if b >= z:\n        print('RIP')\n        continue\n    t = math.ceil((z - b) / y)\n    sum = a + x * (t - 1)\n    c = 0\n    for i in range(n):\n        cntrbtns[i] = -cntrbtns[i]\n    heapq.heapify(cntrbtns)\n    ele = 0\n    while True:\n        if sum >= z:\n            print(c)\n            break\n        ele = -ele\n        ele = heapq.heappushpop(cntrbtns, -(ele // 2))\n        if ele == 0:\n            print('RIP')\n            break\n        sum -= ele\n        c += 1", "import heapq\nimport math\nfor i in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    cntrbtns = list(map(int, input().split()))\n    if b >= z:\n        print('RIP')\n        continue\n    t = math.ceil((z - b) / y)\n    sum = a + x * (t - 1)\n    c = 0\n    for i in range(n):\n        cntrbtns[i] = -cntrbtns[i]\n    heapq.heapify(cntrbtns)\n    ele = 0\n    while True:\n        if sum >= z:\n            print(c)\n            break\n        ele = heapq.heappushpop(cntrbtns, math.ceil(ele / 2))\n        if ele == 0:\n            print('RIP')\n            break\n        sum -= ele\n        c += 1", "import heapq\nfrom math import ceil\nt = int(input())\nfor k in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = list(map(int, input().split()))\n    cont = [-int(x) for x in c]\n    days = int((z - b) / y)\n    p_user = days * x + a\n    need = z - p_user\n    flag = 0\n    heapq.heapify(cont)\n    count = 0\n    if ceil((z - a - 2 * sum(c)) / x) >= days + 1:\n        print('RIP')\n    elif p_user > z:\n        print(0)\n    else:\n        while p_user < z:\n            key = heapq.heappop(cont)\n            if key == 0:\n                flag = 1\n                break\n            count += 1\n            p_user += -key\n            heapq.heappush(cont, int(key / 2))\n        if flag == 0:\n            print(count)\n        else:\n            print('RIP')", "import heapq\nfrom math import ceil\nfor _ in range(int(input())):\n    (N, A, B, X, Y, Z) = map(int, input().split())\n    C = list(map(int, input().split()))\n    heap = [-contrib for contrib in C]\n    heapq.heapify(heap)\n    hooli_days = ceil((Z - B) / Y)\n    piper_init_gap = Z - A\n    if ceil((piper_init_gap - 2 * sum(C)) / X) >= hooli_days:\n        print('RIP')\n    else:\n        num_contribs = 0\n        while ceil(piper_init_gap / X) >= hooli_days and any(heap):\n            contrib = -heapq.heappop(heap)\n            piper_init_gap -= contrib\n            heapq.heappush(heap, -(contrib >> 1))\n            num_contribs += 1\n        if ceil(piper_init_gap / X) < hooli_days:\n            print(num_contribs)\n        else:\n            print('RIP')", "import heapq\nfrom math import ceil\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = list(map(int, input().split()))\n    c = [-int(i) for i in input().split()]\n    heapq.heapify(c)\n    days = ceil((z - b) / y)\n    pig = z - a\n    if ceil((pig + 2 * sum(c)) / x) >= days:\n        print('RIP')\n    else:\n        ans = 0\n        while ceil(pig / x) >= days and any(c):\n            use = -heapq.heappop(c)\n            pig -= use\n            heapq.heappush(c, -(use >> 1))\n            ans += 1\n        if ceil(pig / x) >= days:\n            print('RIP')\n        else:\n            print(ans)", "import heapq as heap\nfor t in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    h = list(map(int, input().split()))\n    for i in range(n):\n        h[i] *= -1\n    heap.heapify(h)\n    extra = (z - b - 1) // y\n    a += x * extra\n    b += y * extra\n    ans = 0\n    while a < z and h:\n        maximum = -1 * heap.heappop(h)\n        a += maximum\n        ans += 1\n        maximum //= 2\n        if maximum:\n            heap.heappush(h, -1 * maximum)\n    if a < z:\n        print('RIP')\n    else:\n        print(ans)", "import sys\nimport math\nimport heapq\nRI = lambda : [int(x) for x in sys.stdin.readline().split()]\nrw = lambda : sys.stdin.readline().strip()\nts = int(input())\nwhile ts > 0:\n    (n, a, b, x, y, z) = RI()\n    con = RI()\n    con = [-i for i in con]\n    heapq.heapify(con)\n    if z - b <= 0:\n        print('RIP')\n        ts -= 1\n        continue\n    elif z - a <= 0:\n        print(0)\n        ts -= 1\n        continue\n    rema = z - a\n    remb = z - b\n    daya = math.ceil(rema / x)\n    dayb = math.ceil(remb / y)\n    if dayb > daya:\n        print(0)\n        ts -= 1\n        continue\n    flag = True\n    cnt = 0\n    temp = (dayb - 1) * x\n    rema -= temp\n    while rema > 0:\n        temp = heapq.heappop(con)\n        temp = -temp\n        if temp == 0:\n            flag = not flag\n            break\n        rema -= temp\n        temp = temp // 2\n        temp = -temp\n        heapq.heappush(con, temp)\n        cnt += 1\n    if not flag:\n        print('RIP')\n        ts -= 1\n        continue\n    else:\n        print(cnt)\n    ts -= 1", "import sys\nfrom math import ceil, floor\nimport heapq\nRI = lambda : [int(x) for x in sys.stdin.readline().split()]\nrw = lambda : sys.stdin.readline().strip()\nts = int(input())\nwhile ts > 0:\n    (n, a, b, x, y, z) = RI()\n    con = RI()\n    con = [-i for i in con]\n    heapq.heapify(con)\n    if z - b <= 0:\n        print('RIP')\n        ts -= 1\n        continue\n    elif z - a <= 0:\n        print(0)\n        ts -= 1\n        continue\n    rema = z - a\n    remb = z - b\n    daya = ceil(rema / x)\n    dayb = ceil(remb / y)\n    if dayb > daya:\n        print(0)\n        ts -= 1\n        continue\n    flag = True\n    cnt = 0\n    temp = (dayb - 1) * x\n    rema -= temp\n    while rema > 0:\n        temp = heapq.heappop(con)\n        temp = -temp\n        if temp == 0:\n            flag = not flag\n            break\n        rema -= temp\n        temp = temp // 2\n        temp = -temp\n        heapq.heappush(con, temp)\n        cnt += 1\n    if not flag:\n        print('RIP')\n        ts -= 1\n        continue\n    else:\n        print(cnt)\n    ts -= 1", "import sys\nfrom math import ceil, floor\nimport heapq\nRI = lambda : [int(x) for x in sys.stdin.readline().split()]\nrw = lambda : sys.stdin.readline().strip()\nts = int(input())\nwhile ts > 0:\n    (n, a, b, x, y, z) = RI()\n    con = RI()\n    con = [-i for i in con]\n    heapq.heapify(con)\n    if z - b <= 0:\n        print('RIP')\n        ts -= 1\n        continue\n    elif z - a <= 0:\n        print(0)\n        ts -= 1\n        continue\n    rema = z - a\n    remb = z - b\n    daya = ceil(rema / x)\n    dayb = ceil(remb / y)\n    if dayb > daya:\n        print(0)\n        ts -= 1\n        continue\n    flag = True\n    cnt = 0\n    temp = (dayb - 1) * x\n    rema -= temp\n    while rema > 0:\n        temp = heapq.heappop(con)\n        temp = -temp\n        if temp == 0:\n            flag = not flag\n            break\n        rema -= temp\n        temp = temp // 2\n        temp = -temp\n        heapq.heappush(con, temp)\n        cnt += 1\n    if not flag:\n        print('RIP')\n        ts -= 1\n        continue\n    else:\n        print(cnt)\n    ts -= 1", "import heapq\nimport math\n\ndef isLose(a, b, x, y, z):\n    t1 = math.ceil((z - a) / x)\n    t2 = math.ceil((z - b) / y)\n    return t1 >= t2\nt = int(input())\nfor i in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = [-int(x) for x in input().split()]\n    heapq.heapify(arr)\n    ans = 0\n    if b >= z:\n        print('RIP')\n    elif a >= z:\n        print(0)\n    else:\n        t1 = math.ceil((z - a) / x)\n        t2 = math.ceil((z - b) / y)\n        if t1 < t2:\n            print(0)\n        elif math.ceil((z - a + 2 * sum(arr)) / x) >= t2:\n            print('RIP')\n        else:\n            while arr[0] != 0 and isLose(a, b, x, y, z):\n                ans += 1\n                top = -1 * heapq.heappop(arr)\n                a += top\n                heapq.heappush(arr, -1 * (top // 2))\n            if isLose(a, b, x, y, z):\n                print('RIP')\n            else:\n                print(ans)", "import heapq as heap\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    h = list(map(int, input().split()))\n    for i in range(n):\n        h[i] = -1 * h[i]\n    heap.heapify(h)\n    extra = (z - b - 1) // y\n    a += x * extra\n    b += y * extra\n    ans = 0\n    while a < z and h:\n        maximum = -1 * heap.heappop(h)\n        a += maximum\n        ans += 1\n        maximum = maximum // 2\n        if maximum:\n            heap.heappush(h, -1 * maximum)\n    if a < z:\n        print('RIP')\n    else:\n        print(ans)", "import math\nimport heapq\nt = int(input())\nwhile t:\n    (n, a, b, x, y, z) = [int(x) for x in input().split()]\n    c = [-int(x) for x in input().split()]\n    hooli = math.ceil((z - b) / y)\n    heapq.heapify(c)\n    count = 0\n    temp_sum = a + (hooli - 1) * x\n    while temp_sum < z and c[0] != 0:\n        temp = heapq.heappop(c)\n        temp_sum += -1 * temp\n        heapq.heappush(c, math.ceil(temp / 2))\n        count += 1\n    if temp_sum < z:\n        print('RIP')\n    else:\n        print(count)\n    t -= 1", "import math\nimport heapq\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = [-int(n) for n in input().split()]\n    dh = math.ceil((z - b) / y)\n    m = a + (dh - 1) * x\n    need = z - m\n    extra = 0\n    z = heapq.heapify(arr)\n    c = 0\n    r = 0\n    while extra < need:\n        if arr[0] == 0:\n            r = 1\n            break\n        temp = heapq.heappop(arr)\n        extra = extra - temp\n        heapq.heappush(arr, math.ceil(temp / 2))\n        c = c + 1\n    if r:\n        print('RIP')\n    else:\n        print(c)", "import heapq\nt = int(input())\nfor z in range(t):\n    (n, bal1, bal2, inc1, inc2, target) = map(int, input().split())\n    arr = [-int(x) for x in input().split()]\n    req2 = target - bal2\n    count = 0\n    flag = 0\n    multiplyer = int(req2 / inc2)\n    bal1 += multiplyer * inc1\n    if bal1 >= target:\n        print(count)\n        flag = 1\n        continue\n    heapq.heapify(arr)\n    while len(arr):\n        temp = heapq.heappop(arr)\n        bal1 += -temp\n        if temp == 0:\n            break\n        count += 1\n        temp = int(temp / 2)\n        heapq.heappush(arr, temp)\n        if bal1 > target:\n            print(count)\n            flag = 1\n            break\n    if flag == 0:\n        print('RIP')", "import heapq\nfor _ in range(int(input())):\n    (N, A, B, X, Y, Z) = map(int, input().split())\n    L = [-int(j) for j in input().split()]\n    heapq.heapify(L)\n    Di = A - B\n    Dr = X - Y\n    Fd = (Z - B) / Y\n    if Fd == int(Fd):\n        Fd = int(Fd - 1)\n    else:\n        Fd = int(Fd)\n    Rem = Z - (A + X * Fd)\n    S = 0\n    n = 0\n    while L != []:\n        if S >= Rem:\n            print(n)\n            break\n        Sup = heapq.heappop(L)\n        n += 1\n        S += -Sup\n        if -Sup // 2 != 0:\n            heapq.heappush(L, -(-Sup // 2))\n    else:\n        if S >= Rem:\n            print(n)\n        else:\n            print('RIP')", "import heapq\nimport math\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = [-1 * int(x) for x in input().split()]\n    if math.ceil((z - a) / x) - math.ceil((z - b) / y) < 0:\n        print(0)\n        continue\n    elif 1:\n        req = z - (a + x * (math.ceil((z - b) / y) - 1))\n        temp = 0\n        heapq.heapify(c)\n        while req > 0:\n            temp += 1\n            te = heapq.heappop(c)\n            if te == 0:\n                print('RIP')\n                break\n            req += te\n            heapq.heappush(c, math.ceil(te / 2))\n        if te != 0:\n            print(temp)", "import heapq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    l = list(map(int, input().split()))\n    dho = (z - b) // y\n    a += dho * x\n    l = [-x for x in l]\n    heapq.heapify(l)\n    f = 0\n    c = 0\n    while a < z:\n        k = abs(heapq.heappop(l))\n        if k == 0:\n            break\n        a += k\n        c += 1\n        heapq.heappush(l, -(k // 2))\n    if a < z:\n        print('RIP')\n    else:\n        print(c)", "import heapq\nfor t in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    pat = list(map(lambda x: int(x) * -1, input().split()))\n    heapq.heapify(pat)\n    ndays = (z - b) // y\n    rem = z - (a + x * ndays)\n    count = 0\n    while rem > 0 and pat:\n        temp = -1 * heapq.heappop(pat)\n        rem -= temp\n        count += 1\n        temp //= 2\n        temp *= -1\n        if temp:\n            heapq.heappush(pat, temp)\n    if rem > 0:\n        print('RIP')\n    else:\n        print(count)", "import math, heapq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = list(map(int, input().split()))\n    C = [-i for i in c]\n    heapq.heapify(C)\n    ta = z - a\n    tb = z - b\n    ta = math.ceil(ta / x)\n    tb = math.ceil(tb / y)\n    ans = 0\n    if ta < tb:\n        print('0')\n    else:\n        vala = a + (tb - 1) * x\n        valb = b + (tb - 1) * y\n        remain = z - vala\n        while remain >= 0:\n            temp = heapq.heappop(C)\n            if temp == 0:\n                break\n            temp = -temp\n            remain -= temp\n            heapq.heappush(C, -(temp // 2))\n            ans += 1\n        if remain >= 0:\n            print('RIP')\n        else:\n            print(ans)", "from collections import deque\nimport heapq as hq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = list(map(int, input().split()))\n    t2 = (z - b) // y\n    t1 = a + x * t2\n    c = [-x for x in c]\n    hq.heapify(c)\n    s = 0\n    ans = 0\n    while t1 + s < z:\n        temp = hq.heappop(c)\n        s += abs(temp)\n        if temp == 0:\n            break\n        ans += 1\n        temp = -temp\n        temp = -(temp // 2)\n        hq.heappush(c, temp)\n    if s + t1 < z:\n        print('RIP')\n    else:\n        print(ans)", "from collections import deque\nimport heapq as hq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = list(map(int, input().split()))\n    t2 = (z - b) // y\n    t1 = a + x * t2\n    c = [-x for x in c]\n    hq.heapify(c)\n    s = 0\n    ans = 0\n    while t1 + s < z:\n        temp = hq.heappop(c)\n        s += abs(temp)\n        if temp == 0:\n            break\n        ans += 1\n        temp = -temp\n        temp = -(temp // 2)\n        hq.heappush(c, temp)\n    if s + t1 < z:\n        print('RIP')\n    else:\n        print(ans)", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = [-int(x) for x in input().split()]\n    heapq.heapify(c)\n    k = int((z - b) / y)\n    ans = 0\n    if a + k * x > z:\n        print(ans)\n    elif a + k * x != z:\n        a += k * x\n        while a < z:\n            temp = heapq.heappop(c)\n            if temp == 0:\n                break\n            a += -temp\n            ans += 1\n            heapq.heappush(c, int(temp / 2))\n        if a < z:\n            print('RIP')\n        else:\n            print(ans)\n    else:\n        print('RIP')", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = [-int(i) for i in input().split() if int(i) > 0]\n    heapq.heapify(c)\n    count = 0\n    bd = (z - b) // y\n    a += x * bd\n    if a > z:\n        print(count)\n        continue\n    while True:\n        temp = -heapq.heappop(c)\n        a += temp\n        count += 1\n        heapq.heappush(c, -(temp // 2))\n        if a > z or temp == 0:\n            break\n    if a > z:\n        print(count)\n    else:\n        print('RIP')", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = input().split()\n    a = int(a)\n    b = int(b)\n    x = int(x)\n    y = int(y)\n    z = int(z)\n    c = [-int(i) for i in input().split() if int(i) > 0]\n    heapq.heapify(c)\n    count = 0\n    bd = (z - b) // y\n    a += x * bd\n    if a > z:\n        print(count)\n        continue\n    while True:\n        temp = -heapq.heappop(c)\n        if a > z or temp == 0:\n            break\n        a += temp\n        count += 1\n        heapq.heappush(c, -(temp // 2))\n    if a > z:\n        print(count)\n    else:\n        print('RIP')", "import math\nimport heapq\nfor z in range(int(input())):\n    (n, a, b, x, y, z) = tuple(map(int, input().split()))\n    c = list(map(int, input().split()))\n    d_day = math.ceil((z - b) / y)\n    own_score = a + x * (d_day - 1)\n    short = z - own_score\n    c = [-x for x in c]\n    heapq.heapify(c)\n    cnt = 0\n    while short >= 0 and len(c) > 0:\n        num = abs(heapq.heappop(c))\n        short -= num\n        cnt += 1\n        num //= 2\n        if num > 0:\n            heapq.heappush(c, -num)\n    if short >= 0:\n        print('RIP')\n    else:\n        print(cnt)", "import heapq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    time = (z - b) // y\n    ua = a + x * time\n    ub = b + y * time\n    arr = [-x for x in arr]\n    heapq.heapify(arr)\n    cnt = 0\n    hlp = 0\n    while z > ua + hlp:\n        chotu = heapq.heappop(arr)\n        hlp += -chotu\n        cnt += 1\n        chotu = -chotu\n        chotu = -(chotu // 2)\n        if chotu == 0:\n            break\n        else:\n            heapq.heappush(arr, chotu)\n    if ua + hlp < z:\n        print('RIP')\n    else:\n        print(cnt)", "import heapq\nfrom math import ceil\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = [int(i) for i in input().split()]\n    A = [-int(i) for i in input().split()]\n    heapq.heapify(A)\n    days = ceil((z - b) / y)\n    pig = z - a\n    if ceil((pig + 2 * sum(A)) / x) >= days:\n        print('RIP')\n    else:\n        ans = 0\n        while ceil(pig / x) >= days and any(A):\n            use = -heapq.heappop(A)\n            pig -= use\n            heapq.heappush(A, -(use >> 1))\n            ans += 1\n        print(['RIP', ans][ceil(pig / x) < days])", "import heapq\n\ndef m():\n    t = int(input())\n    while t > 0:\n        (n, a, b, x, y, z) = map(int, input().split())\n        l = list(map(int, input().split()))\n        for i in range(n):\n            l[i] = -l[i]\n        val1 = z - a\n        val2 = z - b\n        day1 = val1 / x\n        if day1 == int(day1):\n            day1 = int(day1)\n        else:\n            day1 = int(day1) + 1\n        day2 = val2 / y\n        if day2 == int(day2):\n            day2 = int(day2)\n        else:\n            day2 = int(day2) + 1\n        k = min(day1, day2)\n        k -= 1\n        final1 = a + x * k\n        final2 = b + y * k\n        count = 0\n        if day1 < day2:\n            print(0)\n        else:\n            heapq.heapify(l)\n            while final1 <= z:\n                try:\n                    a = heapq.heappop(l)\n                    final1 += -a\n                    if a != 0:\n                        count += 1\n                        heapq.heappush(l, int(a / 2))\n                except IndexError:\n                    break\n            if final1 > z:\n                print(count)\n            elif z >= final1:\n                print('RIP')\n        t -= 1\nm()", "import heapq as heap\nt = int(input())\nwhile t:\n    (n, a, b, x, y, z) = map(int, input().split())\n    l = list(map(int, input().split()))\n    days = (z - b) // y\n    new = a + x * days\n    l = [-x for x in l]\n    heap.heapify(l)\n    s = 0\n    c = 0\n    while new + s < z:\n        temp = heap.heappop(l)\n        s = s + abs(temp)\n        if temp == 0:\n            break\n        c += 1\n        temp = -temp\n        temp = -(temp // 2)\n        heap.heappush(l, temp)\n    if new + s < z:\n        print('RIP')\n    else:\n        print(c)\n    t -= 1", "import copy\nfrom collections import *\nimport math\n\ndef solve(W, d, z):\n    W.sort(reverse=True)\n    C = deque(W)\n    Q = deque()\n    n = 0\n    if d >= z:\n        return n\n    while True:\n        if len(C) == 0 and len(Q) == 0:\n            break\n        if not Q or C[0] > Q[0]:\n            contr = C.popleft()\n            d = d + contr\n            n += 1\n            if d >= z:\n                return n\n            if contr // 2 >= 1:\n                Q.append(contr // 2)\n        else:\n            contr = Q.popleft()\n            d = d + contr\n            n += 1\n            if d >= z:\n                return n\n            if contr // 2 >= 1:\n                Q.append(contr // 2)\n        if not C:\n            (C, Q) = (Q, C)\n    if d >= z:\n        return n\n    return 'RIP'\nT = int(input())\nfor t in range(T):\n    riga = input().split()\n    riga = [int(a) for a in riga]\n    N = riga[0]\n    A = riga[1]\n    B = riga[2]\n    X = riga[3]\n    Y = riga[4]\n    Z = riga[5]\n    riga = input().split()\n    W = [int(a) for a in riga]\n    timeB = math.ceil((Z - B) / Y)\n    g = timeB - 1\n    pied = A + g * X\n    if pied >= Z:\n        print(0)\n    else:\n        print(solve(W, pied, Z))", "import heapq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    days = (z - b + y - 1) // y - 1\n    reqcont = z - a - days * x\n    l = list(map(int, input().split()))\n    for i in range(n):\n        l[i] = -l[i]\n    heapq.heapify(l)\n    c = 0\n    rem = 0\n    while reqcont > 0:\n        if not l:\n            print('RIP')\n            break\n        rem = heapq.heappop(l)\n        if -rem // 2 > 0:\n            heapq.heappush(l, -(-rem // 2))\n        reqcont += rem\n        c += 1\n    else:\n        print(c)", "from collections import deque\nimport math\n\ndef solve(nums, d, z):\n    q1 = deque(sorted(nums, reverse=True))\n    q2 = deque()\n    c = 0\n    if d >= z:\n        return c\n    while True:\n        if len(q1) == 0 and len(q2) == 0:\n            break\n        if not q2 or q1[0] > q2[0]:\n            ele = q1.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 1:\n                q2.append(ele)\n        else:\n            ele = q2.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 1:\n                q2.append(ele)\n        if not q1:\n            (q1, q2) = (q2, q1)\n    if d >= z:\n        return c\n    return 'RIP'\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    queries = set([])\n    c = z - b\n    c = math.ceil(c / y) - 1\n    d = a + x * c\n    if d >= z:\n        print(0)\n    else:\n        print(solve(nums, d, z))", "import heapq as hq\nt = int(input())\nwhile t:\n    t -= 1\n    (n, a, b, x, y, z) = map(int, input().strip().split(' '))\n    l = list(map(int, input().strip().split(' ')))\n    for i in range(n):\n        l[i] = -l[i]\n    hq.heapify(l)\n    days = (z - b) // y\n    if b + days * y == z:\n        days -= 1\n    done = a + days * x\n    count = 0\n    while len(l) != 0 and done < z:\n        tmp = hq.heappop(l)\n        tmp = -tmp\n        done += tmp\n        count += 1\n        tmp = tmp // 2\n        if tmp > 0:\n            hq.heappush(l, -tmp)\n    if done < z:\n        print('RIP')\n    else:\n        print(count)", "import heapq\nfrom math import ceil\nfor _ in range(int(input())):\n    (N, A, B, X, Y, Z) = map(int, input().split())\n    C = list(map(int, input().split()))\n    heap = [-contrib for contrib in C]\n    heapq.heapify(heap)\n    hd = ceil((Z - B) / Y)\n    rd = ceil((Z - A) / X)\n    if rd < hd:\n        print('0')\n    else:\n        num_contribs = 0\n        piper_init_gap = Z - A - (hd - 1) * X\n        while piper_init_gap > 0 and any(heap):\n            contrib = -heapq.heappop(heap)\n            piper_init_gap -= contrib\n            heapq.heappush(heap, -(contrib >> 1))\n            num_contribs += 1\n        if piper_init_gap <= 0:\n            print(num_contribs)\n        else:\n            print('RIP')", "from heapq import heapify, heappop, heappush\ntest = int(input())\nfor i in range(test):\n    (cNo, a, b, x, y, z) = map(int, input().split())\n    cl1 = list(map(int, input().split()))\n    heapify(cl1)\n    cl1 = [-i for i in cl1]\n    heapify(cl1)\n    day = int((z - b) // y)\n    a += x * day\n    count = 0\n    while a <= z:\n        ele = heappop(cl1)\n        if ele == 0:\n            break\n        a = a + -ele\n        count = count + 1\n        heappush(cl1, int(ele / 2))\n    if a > z:\n        print(count)\n    else:\n        print('RIP')", "from heapq import heapify, heappop, heappush\nfrom math import ceil, floor\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    l = list(map(int, input().split()))\n    heap = [-i for i in l]\n    days_p = ceil((z - a) / x)\n    days_h = ceil((z - b) / y)\n    heapify(heap)\n    mul = (z - b) // y\n    a += x * mul\n    b += y * mul\n    count = 0\n    while a <= z:\n        ext = heappop(heap)\n        if ext == 0:\n            break\n        a += -ext\n        heappush(heap, int(ext / 2))\n        count += 1\n    if a <= z:\n        print('RIP')\n    else:\n        print(count)", "import heapq\nfrom math import ceil\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = list(map(int, input().split()))\n    for i in range(n):\n        c[i] *= -1\n    heapq.heapify(c)\n    if b >= z:\n        print('RIP')\n    elif a >= z:\n        print(0)\n    else:\n        da = ceil((z - a) / x)\n        db = ceil((z - b) / y)\n        if da < db:\n            print(0)\n        else:\n            cont = 0\n            da = db - 1\n            a += da * x\n            while a < z and c[0]:\n                cont += 1\n                a += abs(heapq.heapreplace(c, -1 * (-1 * c[0] // 2)))\n            if a < z:\n                print('RIP')\n            else:\n                print(cont)", "from collections import deque\nimport heapq as hq\nfrom math import ceil\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    val = (z - b) // y\n    newVal = a + x * val\n    arr = [-x for x in arr]\n    hq.heapify(arr)\n    support = 0\n    count = 0\n    while newVal + support < z:\n        temp = hq.heappop(arr)\n        support += abs(temp)\n        if temp == 0:\n            break\n        count += 1\n        temp = -temp\n        temp = -(temp // 2)\n        hq.heappush(arr, temp)\n    if support + newVal < z:\n        print('RIP')\n    else:\n        print(count)", "import heapq\n\ndef func(a):\n    return -int(a)\nT = int(input())\nfor i in range(T):\n    (N, A, B, X, Y, Z) = list(map(int, input().split()))\n    c = list(map(func, input().split()))\n    heapq.heapify(c)\n    day = (Z - B) // Y\n    if (Z - B) % Y != 0:\n        day += 1\n    dif = Z - (A + (day - 1) * X)\n    ans = 0\n    if -2 * sum(c) < dif:\n        print('RIP')\n        continue\n    while dif > 0:\n        m = heapq.heappop(c)\n        m = -m\n        if m == 0:\n            break\n        heapq.heappush(c, -(m // 2))\n        dif -= m\n        ans += 1\n    if dif > 0:\n        print('RIP')\n    else:\n        print(ans)", "import heapq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = []\n    for ele in map(int, input().split()):\n        c.append(0 - ele)\n    heapq.heapify(c)\n    factor = (z - b) // y\n    pieds = a + factor * x\n    count = 0\n    while pieds < z and len(c) > 0:\n        contrib = heapq.heappop(c)\n        pieds -= contrib\n        contrib = -(-contrib // 2)\n        count += 1\n        if contrib is not 0:\n            heapq.heappush(c, contrib)\n    if pieds < z:\n        print('RIP')\n    else:\n        print(count)", "import numpy as np\nimport heapq as h\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    l = input().split(' ')\n    n = int(l[0])\n    a = int(l[1])\n    b = int(l[2])\n    x = int(l[3])\n    y = int(l[4])\n    z = int(l[5])\n    count = 0\n    cont = []\n    c = input().split(' ')\n    for i in range(n):\n        h.heappush(cont, -int(c[i]))\n    j = 1\n    deadline = (z - b) // y\n    rem = z - (a + deadline * x)\n    while rem > 0:\n        q = rem\n        p = h.heappop(cont)\n        h.heappush(cont, -(-p // 2))\n        rem = rem + p\n        count = count + 1\n        if q == rem:\n            j = 0\n            break\n    if j == 1:\n        print(count)\n    else:\n        print('RIP')", "import numpy as np\nimport heapq as h\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    l = input().split(' ')\n    n = int(l[0])\n    a = int(l[1])\n    b = int(l[2])\n    x = int(l[3])\n    y = int(l[4])\n    z = int(l[5])\n    count = 0\n    cont = []\n    c = input().split(' ')\n    for i in range(n):\n        h.heappush(cont, -int(c[i]))\n    j = 1\n    deadline = (z - b) // y\n    rem = z - (a + deadline * x)\n    while rem > 0:\n        q = rem\n        p = h.heappop(cont)\n        h.heappush(cont, -(-p // 2))\n        rem = rem + p\n        count = count + 1\n        if q == rem:\n            j = 0\n            break\n    if j == 1:\n        print(count)\n    else:\n        print('RIP')", "import numpy as np\nimport heapq as h\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    l = input().split(' ')\n    n = int(l[0])\n    a = int(l[1])\n    b = int(l[2])\n    x = int(l[3])\n    y = int(l[4])\n    z = int(l[5])\n    count = 0\n    cont = []\n    c = input().split(' ')\n    for i in range(n):\n        h.heappush(cont, -int(c[i]))\n    j = 1\n    deadline = (z - b) // y\n    rem = z - (a + deadline * x)\n    while rem > 0:\n        q = rem\n        p = h.heappop(cont)\n        h.heappush(cont, -(-p // 2))\n        rem = rem + p\n        count = count + 1\n        if q == rem:\n            j = 0\n            break\n    if j == 1:\n        print(count)\n    else:\n        print('RIP')", "import heapq\nfor t in range(int(input())):\n    (N, a, b, x, y, z) = map(int, input().split())\n    c = list(map(int, input().split()))\n    c = [-x for x in c]\n    heapq.heapify(c)\n    if (z - b) % y == 0:\n        n = (z - b) // y - 1\n    else:\n        n = (z - b) // y\n    contrib = z - (a + n * x)\n    ans = 0\n    while contrib > 0:\n        mx = heapq.heappop(c)\n        if mx == 0:\n            break\n        contrib += mx\n        ans += 1\n        mx *= -1\n        mx //= 2\n        mx *= -1\n        heapq.heappush(c, mx)\n    if contrib <= 0:\n        print(ans)\n    else:\n        print('RIP')", "from collections import deque\nimport math\n\ndef solve(nums, d, z):\n    q1 = deque(sorted(nums, reverse=True))\n    q2 = deque()\n    c = 0\n    if d >= z:\n        return c\n    while True:\n        if len(q1) == 0 and len(q2) == 0:\n            break\n        if not q2 or q1[0] > q2[0]:\n            ele = q1.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 1:\n                q2.append(ele)\n        else:\n            ele = q2.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 1:\n                q2.append(ele)\n        if not q1:\n            (q1, q2) = (q2, q1)\n    if d >= z:\n        return c\n    return 'RIP'\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    queries = set([])\n    c = z - b\n    c = math.ceil(c / y) - 1\n    d = a + x * c\n    if d >= z:\n        print(0)\n    else:\n        print(solve(nums, d, z))", "from collections import deque\nimport heapq as hq\nfrom math import ceil\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    val = (z - b) // y\n    newVal = a + x * val\n    arr.sort(reverse=True)\n    d1 = deque(arr)\n    d2 = deque([])\n    support = 0\n    count = 0\n    while support + newVal < z:\n        t = support\n        if len(d1) == 0:\n            break\n        if not d2 or d1[0] >= d2[0]:\n            temp = d1.popleft()\n            if temp == 0:\n                break\n            count += 1\n            support += temp\n            temp = temp // 2\n            d2.append(temp)\n        else:\n            temp = d2.popleft()\n            count += 1\n            support += temp\n            temp = temp // 2\n            d2.append(temp)\n        if len(d1) == 0:\n            (d1, d2) = (d2, d1)\n    if support + newVal < z:\n        print('RIP')\n    else:\n        print(count)", "from collections import deque\nimport heapq as hq\nfrom math import ceil\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    val = (z - b) // y\n    newVal = a + x * val\n    arr = [-x for x in arr]\n    hq.heapify(arr)\n    support = 0\n    count = 0\n    while newVal + support < z:\n        temp = hq.heappop(arr)\n        support += abs(temp)\n        if temp == 0:\n            break\n        count += 1\n        temp = -temp\n        temp = -(temp // 2)\n        hq.heappush(arr, temp)\n    if support + newVal < z:\n        print('RIP')\n    else:\n        print(count)", "import heapq\nT = int(input())\nwhile T > 0:\n    (N, A, B, X, Y, Z) = [int(x) for x in input().split()]\n    C = [-int(x) for x in input().strip().split()]\n    heapq.heapify(C)\n    days = (Z - B) // Y\n    pp = A + X * days\n    if pp >= Z:\n        print(0)\n    else:\n        count = 0\n        max_c = -heapq.heappop(C)\n        while max_c > 0 and pp < Z:\n            count += 1\n            pp += max_c\n            heapq.heappush(C, -(max_c >> 1))\n            max_c = -heapq.heappop(C)\n        if pp >= Z:\n            print(count)\n        else:\n            print('RIP')\n    T -= 1", "import heapq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    l = [-int(i) for i in input().split()]\n    diff = y - x\n    base = b - a\n    gotillz = 0\n    piedz = 0\n    from math import ceil\n    z1 = z - 1\n    hooliz = (z - b) / y\n    if hooliz == int(hooliz):\n        days = hooliz - 1\n    else:\n        days = int(hooliz)\n    piedz = a + days * x\n    if piedz >= z:\n        print(0)\n        continue\n    else:\n        req = z - piedz\n        heapq.heapify(l)\n        cnt = 0\n        c = 0\n        while l and c < req:\n            curr = -heapq.heappop(l)\n            c += curr\n            cnt += 1\n            if curr // 2 == 0:\n                pass\n            else:\n                heapq.heappush(l, -(curr // 2))\n        if c >= req:\n            print(cnt)\n        else:\n            print('RIP')", "from collections import deque\nt = int(input())\nwhile t:\n    (n, a, b, x, y, z) = map(int, input().split())\n    l = list(map(int, input().split()))\n    ll = deque\n    l = deque(sorted(l, reverse=True))\n    ll = deque()\n    cd = (z - b) // y\n    le = cd * x + a\n    c = 0\n    if le <= 0:\n        print(c)\n    else:\n        while le < z:\n            if len(ll) == 0 and len(l) == 0:\n                break\n            if not ll or l[0] > ll[0]:\n                le += l[0]\n                c += 1\n                v = l.popleft()\n                if v // 2 >= 1:\n                    ll.append(v // 2)\n            else:\n                le += ll[0]\n                c += 1\n                v = ll.popleft()\n                if v // 2 >= 1:\n                    ll.append(v // 2)\n            if not l:\n                (l, ll) = (ll, l)\n            if le >= z:\n                break\n        if le >= z:\n            print(c)\n        else:\n            print('RIP')\n    t -= 1", "from collections import deque\nimport math\n\ndef solve(nums, d, z):\n    q1 = deque(sorted(nums, reverse=True))\n    q2 = deque()\n    c = 0\n    if d >= z:\n        return c\n    while True:\n        if len(q1) == 0 and len(q2) == 0:\n            break\n        if not q2 or q1[0] > q2[0]:\n            ele = q1.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 1:\n                q2.append(ele)\n        else:\n            ele = q2.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 1:\n                q2.append(ele)\n        if not q1:\n            (q1, q2) = (q2, q1)\n    if d >= z:\n        return c\n    return 'RIP'\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    queries = set([])\n    c = z - b\n    c = math.ceil(c / y) - 1\n    d = a + x * c\n    if d >= z:\n        print(0)\n    else:\n        print(solve(nums, d, z))", "import bisect as bs\nfrom collections import deque\nimport heapq as hp\nimport math\n\ndef check1(a, b, x, y, z, val):\n    if math.ceil((z - a - val) / x) < math.ceil((z - b) / y):\n        return True\n    return False\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    val = 0\n    arr.sort(reverse=True)\n    c = 0\n    q1 = deque(arr)\n    q2 = deque()\n    while q1 or q2:\n        if check1(a, b, x, y, z, val):\n            print(c)\n            break\n        if not q2 or q1[0] > q2[0]:\n            p = q1.popleft()\n            val += p\n            c += 1\n            if p // 2:\n                q2.append(p // 2)\n        elif q2 and q2[0] >= q1[0]:\n            p = q2.popleft()\n            val += p\n            c += 1\n            if p // 2:\n                q2.append(p // 2)\n        if not q1 and q2:\n            (q1, q2) = (q2, q1)\n    else:\n        print('RIP')", "import math\nimport heapq\nt = int(input())\nfor itrg in range(t):\n    (n, a, b, x, y, z) = [int(x) for x in input().split()]\n    arr = [int(x) for x in input().split()]\n    p = z - b\n    p = math.ceil(p / y)\n    if p <= 0:\n        print('RIP')\n        continue\n    p -= 1\n    p = p * x\n    p = z - p\n    p = p - a\n    if p <= 0:\n        print(0)\n        continue\n    c = p\n    arc = n\n    for i in arr:\n        if i == 0:\n            arc -= 1\n    for i in range(n):\n        arr[i] = -arr[i]\n    heapq.heapify(arr)\n    ans = 0\n    flag = 0\n    while 1:\n        if c <= 0:\n            break\n        ans += 1\n        ele = heapq.heappop(arr)\n        ele = -ele\n        c -= ele\n        ele = ele // 2\n        if ele == 0:\n            arc -= 1\n        if arc == 0:\n            flag = 1\n            break\n        heapq.heappush(arr, -ele)\n    if flag == 1:\n        print('RIP')\n    else:\n        print(ans)", "from math import ceil, floor\nimport heapq\nt = int(input())\nwhile t:\n    t -= 1\n    (n, a, b, x, y, z) = map(int, input().split())\n    li = [-int(x) for x in input().split()]\n    i = ceil((z - b) / y - 1)\n    a = a + i * x\n    b = b + i * y\n    c = 0\n    heapq.heapify(li)\n    while a < z and n != 0:\n        f = -li[0]\n        a += f\n        c += 1\n        y = floor(f / 2)\n        if y != 0:\n            heapq.heappushpop(li, -y)\n        else:\n            heapq.heappop(li)\n            n -= 1\n    if a >= z:\n        print(c)\n    else:\n        print('RIP')", "import heapq\nR = lambda : map(int, input().split())\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = R()\n    c = [-x for x in R()]\n    heapq.heapify(c)\n    a -= (b - z) // y * x + x\n    i = 0\n    while a < z and c[0]:\n        a -= c[0]\n        heapq.heapreplace(c, (c[0] + 1) // 2)\n        i += 1\n    print((i, 'RIP')[a < z])", "import heapq\nR = lambda : map(int, input().split())\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = R()\n    c = [-x for x in R()]\n    heapq.heapify(c)\n    a -= (b - z) // y * x + x\n    i = 0\n    while a < z and c[0]:\n        a -= c[0]\n        heapq.heapreplace(c, (c[0] + 1) // 2)\n        i += 1\n    print((i, 'RIP')[a < z])", "import heapq\nR = lambda : map(int, input().split())\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = R()\n    c = [-x for x in R()]\n    heapq.heapify(c)\n    a -= (b - z) // y * x + x\n    i = 0\n    while a < z and c[0]:\n        m = heapq.heappop(c)\n        a -= m\n        heapq.heappush(c, (m + 1) // 2)\n        i += 1\n    print((i, 'RIP')[a < z])", "import heapq\nR = lambda : map(int, input().split())\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = R()\n    c = [-x for x in R()]\n    heapq.heapify(c)\n    a -= (b - z) // y * x + x\n    i = 0\n    while a < z and c[0]:\n        m = -heapq.heappop(c)\n        a += m\n        heapq.heappush(c, -(m // 2))\n        i += 1\n    print((i, 'RIP')[a < z])", "import math\nimport heapq\nfor test in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = list(map(int, input().split()))\n    c = [-x for x in c]\n    heapq.heapify(c)\n    d = math.ceil((z - b) / y) - 1\n    rem = z - (a + x * d)\n    count = 0\n    prev = -1000000\n    for i in range(31 * n):\n        if rem <= 0:\n            break\n        if rem == prev:\n            break\n        prev = rem\n        e = -heapq.heappop(c)\n        rem -= e\n        e = 0 - e // 2\n        heapq.heappush(c, e)\n        count += 1\n    if rem > 0:\n        print('RIP')\n    else:\n        print(count)", "import heapq\nt = int(input().strip())\nfor tc in range(t):\n    (n, a, b, x, y, z) = map(int, input().strip().split())\n    c = list(map(int, input().strip().split()))\n    for i in range(n):\n        c[i] = -1 * c[i]\n    heapq.heapify(c)\n    num_days_left = (z - b) // y\n    a_gained_users = a + x * num_days_left\n    b_gained_users = b + y * num_days_left\n    if a_gained_users > z:\n        print('0')\n    else:\n        if b_gained_users == z:\n            users_required = z + 1\n        else:\n            users_required = z\n        cnt = 0\n        while a_gained_users < users_required and len(c) > 0:\n            contrib_from_supporter = -1 * heapq.heappop(c)\n            a_gained_users += contrib_from_supporter\n            cnt += 1\n            if contrib_from_supporter != 1:\n                heapq.heappush(c, -1 * (contrib_from_supporter // 2))\n        if a_gained_users < users_required:\n            print('RIP')\n        else:\n            print(cnt)", "import math\nimport heapq as h\nt = int(input())\nwhile t:\n    t -= 1\n    (n, a, b, x, y, z) = map(int, input().strip().split())\n    l = list(map(int, input().strip().split()))\n    pd = z - a\n    hd = math.ceil((z - b) / y)\n    l = [-x for x in l]\n    h.heapify(l)\n    ct = 0\n    while math.ceil(pd / x) >= hd and any(l):\n        mx = -h.heappop(l)\n        pd -= mx\n        ct += 1\n        h.heappush(l, -(mx // 2))\n    if math.ceil(pd / x) >= hd:\n        print('RIP')\n    else:\n        print(ct)", "import heapq\nt = int(input())\nwhile t > 0:\n    (n, a, b, x, y, z) = map(int, input().split())\n    l = [-int(x) for x in input().split()]\n    heapq.heapify(l)\n    u = (z - b) // y\n    a = a + x * u\n    s1 = 0\n    if a > z:\n        print('0')\n    elif a != z:\n        sum1 = 0\n        while a < z:\n            h = heapq.heappop(l)\n            if h == 0:\n                break\n            a = a + -h\n            s1 = s1 + 1\n            heapq.heappush(l, int(h / 2))\n        if a < z:\n            print('RIP')\n        else:\n            print(s1)\n    else:\n        print('RIP')\n    t = t - 1", "t = int(input())\nimport heapq\nimport sys\nfrom math import ceil\nfor i in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    l = list(map(int, input().split()))\n    for i in range(n):\n        l[i] = -1 * l[i]\n    z1 = ceil((z - a) / x) + 1\n    z2 = ceil((z - b) / y) + 1\n    ba = []\n    if z1 < z2:\n        print(0)\n    else:\n        k = z2 - 1\n        f = a + (k - 1) * x\n        count1 = 0\n        flag = 0\n        heapq.heapify(l)\n        while True:\n            if f >= z:\n                flag = 1\n                break\n            if l == []:\n                break\n            u = heapq.heappop(l)\n            if u // 2 != 0:\n                heapq.heappush(l, -1 * (abs(u) // 2))\n            f += abs(u)\n            count1 += 1\n        if flag == 0:\n            print('RIP')\n        else:\n            print(count1)", "import heapq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = [int(x) for x in input().split()]\n    h = [-int(x) for x in input().split()]\n    timeA = 0\n    timeB = (z - b) // y + (0 if (z - b) % y == 0 else 1)\n    total = a\n    totalB = b\n    diff = (z - b) // y * x\n    if total + diff > z:\n        print(0)\n    elif total + diff != z:\n        total += diff\n        heapq.heapify(h)\n        while total < z and n > 0:\n            max_user = -h[0]\n            timeA += 1\n            if max_user // 2 != 0:\n                heapq.heappushpop(h, -(max_user // 2))\n            else:\n                heapq.heappop(h)\n                n -= 1\n            total += max_user\n        print(timeA if total >= z else 'RIP')", "import sys\nfrom bisect import bisect_left, bisect_right, insort\nfrom collections import deque, Counter\nfrom math import gcd, sqrt, factorial, ceil, log10\nfrom itertools import permutations\nfrom heapq import heappush, heappop, heapify\ninf = float('inf')\nmod = 1000000007\nmini = 1000000007\n\ndef ncr(n, r):\n    d = 10 ** 9 + 7\n    num = fact(n)\n    den = fact(r) * fact(n - r) % d\n    den = pow(den, d - 2, d)\n    return num * den % d\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    lst = []\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p = p + 1\n    for i in range(2, n + 1):\n        if prime[i]:\n            lst.append(i)\n    return lst\n\ndef binary(number):\n    result = 0\n    while number:\n        result = result + 1\n        number = number & number - 1\n    return result\n\ndef calculate_factors(n):\n    hh = [1] * (n + 1)\n    p = 2\n    while p * p < n:\n        if hh[p] == 1:\n            for i in range(p * 2, n, p):\n                hh[i] = 0\n        p += 1\n    total = 1\n    for p in range(2, n + 1):\n        if hh[p] == 1:\n            count = 0\n            if n % p == 0:\n                while n % p == 0:\n                    n = int(n / p)\n                    count += 1\n                total *= count + 1\n    return total\n\ndef prime_factors(n):\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            factors.add(n // i)\n            n = n // i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors\n\ndef isPrime(n):\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n < 2:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve(n):\n    if n == 1:\n        return 1\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            return n // p\n        p = p + 1\n    return False\n\ndef expo(x, n):\n    result = 1\n    while n > 1:\n        if n & 1:\n            n = n - 1\n            result = result * x\n        else:\n            n = n // 2\n            x = x * x\n    return result * x\n\ndef change(a):\n    return chr(ord(a) + 1)\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef input():\n    return sys.stdin.readline().strip()\nT = int(input())\nwhile T > 0:\n    (n, a, b, c, d, z) = get_ints()\n    heap = []\n    Arr = get_array()\n    min_a = ceil((z - a) / c)\n    min_b = ceil((z - b) / d)\n    for i in Arr:\n        heappush(heap, -1 * i)\n    if min_a < min_b:\n        print(0)\n    else:\n        trick = min_b - 1\n        effort = a + trick * c\n        flag = 0\n        count = 0\n        while heap != []:\n            k = -1 * heappop(heap)\n            count += 1\n            effort += k\n            if effort > z:\n                flag = 1\n                break\n            k = k // 2\n            if k != 0:\n                heappush(heap, -1 * k)\n        if flag == 0:\n            print('RIP')\n        else:\n            print(count)\n    T = T - 1", "from collections import deque\nimport math\n\ndef solve(nums, d, z):\n    q1 = deque(sorted(nums, reverse=True))\n    q2 = deque()\n    c = 0\n    if d >= z:\n        return c\n    while True:\n        if len(q1) == 0 and len(q2) == 0:\n            break\n        if not q2 or q1[0] > q2[0]:\n            ele = q1.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 1:\n                q2.append(ele)\n        else:\n            ele = q2.popleft()\n            c += 1\n            d += ele\n            if d >= z:\n                return c\n            ele = ele // 2\n            if ele >= 1:\n                q2.append(ele)\n        if not q1:\n            (q1, q2) = (q2, q1)\n    if d >= z:\n        return c\n    return 'RIP'\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    queries = set([])\n    c = z - b\n    c = math.ceil(c / y) - 1\n    d = a + x * c\n    if d >= z:\n        print(0)\n    else:\n        print(solve(nums, d, z))", "import heapq\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = [int(x) for x in input().split()]\n    h = [-int(x) for x in input().split()]\n    timeA = 0\n    timeB = (z - b) // y + (0 if (z - b) % y == 0 else 1)\n    total = a\n    totalB = b\n    diff = (z - b) // y * x\n    if total + diff > z:\n        print(0)\n    elif total + diff != z:\n        total += diff\n        heapq.heapify(h)\n        while total < z and n > 0:\n            max_user = -h[0]\n            timeA += 1\n            if max_user // 2 != 0:\n                heapq.heappushpop(h, -(max_user // 2))\n            else:\n                heapq.heappop(h)\n                n -= 1\n            total += max_user\n        print(timeA if total >= z else 'RIP')", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = [-int(x) for x in input().split()]\n    heapq.heapify(c)\n    k = int((z - b) / y)\n    ans = 0\n    if a + k * x > z:\n        print(ans)\n    elif a + k * x != z:\n        a += k * x\n        while a < z:\n            temp = heapq.heappop(c)\n            if temp == 0:\n                break\n            a += -temp\n            ans += 1\n            heapq.heappush(c, int(temp / 2))\n        if a < z:\n            print('RIP')\n        else:\n            print(ans)\n    else:\n        print('RIP')", "import math\nimport heapq\nfor test in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    c = list(map(int, input().split()))\n    c = [-x for x in c]\n    heapq.heapify(c)\n    d = math.ceil((z - b) / y) - 1\n    rem = z - (a + x * d)\n    count = 0\n    prev = -1000000\n    for i in range(31 * n):\n        if rem <= 0:\n            break\n        if rem == prev:\n            break\n        prev = rem\n        e = -heapq.heappop(c)\n        rem -= e\n        e = 0 - e // 2\n        heapq.heappush(c, e)\n        count += 1\n    if rem > 0:\n        print('RIP')\n    else:\n        print(count)", "import heapq\nfor _ in range(int(input())):\n    (N, A, B, X, Y, Z) = map(int, input().split())\n    C = list(map(int, input().split()))\n    asdf = []\n    for ty in C:\n        heapq.heappush(asdf, -1 * ty)\n    e = Z - A\n    r = Z - B\n    ans = 0\n    t = int(r / Y)\n    if r % Y == 0:\n        t -= 1\n    e -= t * X\n    qwer = []\n    qwerty = 1\n    hoga = 0\n    if e <= 0:\n        print('0')\n        continue\n    else:\n        while qwerty != 0:\n            qwerty = -1 * heapq.heappop(asdf)\n            heapq.heappush(asdf, -1 * int(qwerty / 2))\n            e -= qwerty\n            ans += 1\n            if e <= 0:\n                hoga = 1\n                break\n        if hoga == 0:\n            print('RIP')\n        else:\n            print(ans)", "import heapq\nt = int(input().strip())\nfor _ in range(t):\n    (n, a, b, x, y, z) = map(int, input().strip().split())\n    c = list(map(int, input().strip().split()))\n    for i in range(n):\n        c[i] = -1 * c[i]\n    heapq.heapify(c)\n    days = (z - b) // y\n    anew = a + x * days\n    bnew = b + y * days\n    if anew > z:\n        print('0')\n    else:\n        if bnew == z:\n            goal = z + 1\n        else:\n            goal = z\n        cnt = 0\n        while anew < goal and len(c) > 0:\n            temp = -1 * heapq.heappop(c)\n            anew += temp\n            cnt += 1\n            if temp != 1:\n                heapq.heappush(c, -1 * (temp // 2))\n        if anew < goal:\n            print('RIP')\n        else:\n            print(cnt)", "import heapq\n\ndef hpush(h, e):\n    h.append(e)\n    heapq._siftdown_max(h, 0, len(h) - 1)\n\ndef getCount(z, pp, cont):\n    heapq._heapify_max(cont)\n    count = 0\n    while pp < z:\n        e = heapq._heappop_max(cont)\n        if e == 0:\n            return -1\n        pp = pp + e\n        hpush(cont, e // 2)\n        count = count + 1\n    return count\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    cont = list(map(int, input().split()))\n    d = (z - b) // y\n    pp = a + d * x\n    res = getCount(z, pp, cont)\n    if res == -1:\n        print('RIP')\n    else:\n        print(res)", "import heapq as h\nfor _ in range(int(input())):\n    (n, a, x, b, y, z) = map(int, input().split())\n    p = list(map(int, input().split()))\n    p = [-i for i in p]\n    h.heapify(p)\n    if x > z:\n        print('RIP')\n        continue\n    d = (z - x) // y\n    a += b * d\n    if a > z:\n        print(0)\n        continue\n    c = 0\n    while True:\n        t = -h.heappop(p)\n        if t == 0 or a > z:\n            break\n        c += 1\n        a += t\n        h.heappush(p, -(t // 2))\n    if a > z:\n        print(c)\n    else:\n        print('RIP')", "import heapq\nfrom math import ceil, floor\nfor _ in range(int(input())):\n    (n, a, b, x, y, z) = map(int, input().split())\n    s = [-int(i) for i in input().split()]\n    days = floor((z - b) / y)\n    current = a + days * x\n    if b + days * y == z:\n        z += 1\n    count = 0\n    heapq.heapify(s)\n    while current < z:\n        ret = heapq.heappop(s)\n        ret = -ret\n        if ret == 0:\n            break\n        else:\n            current += ret\n            heapq.heappush(s, -(ret // 2))\n        count += 1\n    print(count) if current >= z else print('RIP')", "import math, heapq\nT = int(input())\nwhile T:\n    (N, A, B, X, Y, Z) = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    k1 = math.ceil((Z - A) / X)\n    k2 = math.ceil((Z - B) / Y)\n    if k1 < k2:\n        print(0)\n    else:\n        k3 = k2 - 1\n        users_still_required = Z - (A + k3 * X)\n        C_mod = [-C[i] for i in range(N)]\n        heapq.heapify(C_mod)\n        count = 0\n        is_not_possible = False\n        while users_still_required > 0:\n            max_contribution_value = -heapq.heappop(C_mod)\n            if max_contribution_value == 0:\n                is_not_possible = True\n                break\n            users_still_required -= max_contribution_value\n            heapq.heappush(C_mod, -math.floor(max_contribution_value / 2))\n            count += 1\n        if is_not_possible == True:\n            print('RIP')\n        else:\n            print(count)\n    T -= 1"]