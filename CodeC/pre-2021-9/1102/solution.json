["class Dsu:\n\n    def __init__(self, v, s):\n        self.par = s\n        self.v = v\n        self.dr = [1] * v\n        self.zero = [False] * v\n        self.speed = []\n        for i in range(v):\n            self.speed.append([])\n            self.speed[i].append(i)\n\n    def find(self, i):\n        if i != self.par[i][0]:\n            org = self.par[i][0]\n            self.par[i][0] = self.find(self.par[i][0])\n            if self.zero[i] or self.zero[self.par[i][0]] or self.zero[org]:\n                self.zero[i] = self.zero[self.par[i][0]] = self.zero[org] = True\n            if org != self.par[i][0]:\n                self.speed[self.par[i][0]].append(i)\n        return self.par[i][0]\n\n    def union(self, x, y):\n        self.rx = self.find(x)\n        self.ry = self.find(y)\n        self.sign = -self.dr[x] * self.dr[y]\n        if self.rx != self.ry:\n            if self.par[self.rx][1] < self.par[self.ry][1]:\n                mx = self.ry\n                mn = self.rx\n            if self.par[self.rx][1] > self.par[self.ry][1]:\n                mx = self.rx\n                mn = self.ry\n            if self.par[self.rx][1] != self.par[self.ry][1]:\n                self.par[mn][0] = mx\n                if self.zero[mn] or self.zero[mx] or self.zero[x] or self.zero[y]:\n                    self.zero[mn] = self.zero[mx] = self.zero[x] = self.zero[y] = True\n                else:\n                    for i in range(len(self.speed[mn])):\n                        self.dr[self.speed[mn][i]] *= self.sign\n                        org = self.par[self.speed[mn][i]][0]\n                        if org != mx:\n                            self.par[self.speed[mn][i]][0] = mx\n                            self.speed[mx].append(self.speed[mn][i])\n                self.speed[mx].append(mn)\n            else:\n                self.par[self.ry][0] = self.rx\n                self.par[self.rx][1] += 1\n                if self.zero[self.rx] or self.zero[self.ry] or self.zero[x] or self.zero[y]:\n                    self.zero[self.rx] = self.zero[self.ry] = self.zero[x] = self.zero[y] = True\n                else:\n                    for i in range(len(self.speed[self.ry])):\n                        self.dr[self.speed[self.ry][i]] *= self.sign\n                        org = self.par[self.speed[self.ry][i]][0]\n                        if org != self.rx:\n                            self.par[self.speed[self.ry][i]][0] = self.rx\n                            self.speed[self.rx].append(self.speed[self.ry][i])\n                self.speed[self.rx].append(self.ry)\n        else:\n            return\n\ndef optwo(x, y, D):\n    if D.find(x) == D.find(y) and D.dr[x] == D.dr[y]:\n        D.zero[x] = D.zero[y] = True\n    D.union(x, y)\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    else:\n        return gcd(b % a, a)\n\ndef opthree(x, y, v, D):\n    if D.find(x) != D.find(y) or D.zero[D.par[y][0]]:\n        print(0)\n    else:\n        g = gcd(v * speed[x], speed[y])\n        flag = D.dr[x] * D.dr[y] // abs(D.dr[x] * D.dr[y])\n        print(str(flag * v * speed[x] // g) + '/' + str(speed[y] // g))\n(n, M) = map(int, input().split())\nspeed = list(map(int, input().split()))\ns = []\nfor i in range(n):\n    s.append([i, 0])\nD = Dsu(n, s)\nfor i in range(M):\n    T = list(map(int, input().split()))\n    if T[0] == 1:\n        speed[T[1] - 1] = T[2]\n    elif T[0] == 2:\n        optwo(T[1] - 1, T[2] - 1, D)\n    elif T[0] == 3:\n        opthree(T[1] - 1, T[2] - 1, T[3], D)", "class Dsu:\n\n    def __init__(self, v, s):\n        self.par = s\n        self.v = v\n        self.dr = [1] * v\n        self.zero = [False] * v\n        self.speed = []\n        for i in range(v):\n            self.speed.append([])\n            self.speed[i].append(i)\n\n    def find(self, i):\n        if i != self.par[i][0]:\n            org = self.par[i][0]\n            self.par[i][0] = self.find(self.par[i][0])\n            if self.zero[i] or self.zero[self.par[i][0]] or self.zero[org]:\n                self.zero[i] = self.zero[self.par[i][0]] = self.zero[org] = True\n            if org != self.par[i][0]:\n                self.speed[self.par[i][0]].append(i)\n        return self.par[i][0]\n\n    def union(self, x, y):\n        self.rx = self.find(x)\n        self.ry = self.find(y)\n        self.sign = -self.dr[x] * self.dr[y]\n        if self.rx != self.ry:\n            if self.par[self.rx][1] < self.par[self.ry][1]:\n                mx = self.ry\n                mn = self.rx\n            if self.par[self.rx][1] > self.par[self.ry][1]:\n                mx = self.rx\n                mn = self.ry\n            if self.par[self.rx][1] != self.par[self.ry][1]:\n                self.par[mn][0] = mx\n                if self.zero[mn] or self.zero[mx] or self.zero[x] or self.zero[y]:\n                    self.zero[mn] = self.zero[mx] = self.zero[x] = self.zero[y] = True\n                else:\n                    for i in range(len(self.speed[mn])):\n                        self.dr[self.speed[mn][i]] *= self.sign\n                        org = self.par[self.speed[mn][i]][0]\n                        if org != mx:\n                            self.par[self.speed[mn][i]][0] = mx\n                            self.speed[mx].append(self.speed[mn][i])\n                self.speed[mx].append(mn)\n            else:\n                self.par[self.ry][0] = self.rx\n                self.par[self.rx][1] += 1\n                if self.zero[self.rx] or self.zero[self.ry] or self.zero[x] or self.zero[y]:\n                    self.zero[self.rx] = self.zero[self.ry] = self.zero[x] = self.zero[y] = True\n                else:\n                    for i in range(len(self.speed[self.ry])):\n                        self.dr[self.speed[self.ry][i]] *= self.sign\n                        org = self.par[self.speed[self.ry][i]][0]\n                        if org != self.rx:\n                            self.par[self.speed[self.ry][i]][0] = self.rx\n                            self.speed[self.rx].append(self.speed[self.ry][i])\n                self.speed[self.rx].append(self.ry)\n        else:\n            return\n\ndef optwo(x, y, D):\n    if D.find(x) == D.find(y) and D.dr[x] == D.dr[y]:\n        D.zero[x] = D.zero[y] = True\n    D.union(x, y)\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    else:\n        return gcd(b % a, a)\n\ndef opthree(x, y, v, D):\n    if D.find(x) != D.find(y) or D.zero[D.par[y][0]]:\n        print(0)\n    else:\n        g = gcd(v * speed[x], speed[y])\n        flag = D.dr[x] * D.dr[y] // abs(D.dr[x] * D.dr[y])\n        print(str(flag * v * speed[x] // g) + '/' + str(speed[y] // g))\n(n, M) = map(int, input().split())\nspeed = list(map(int, input().split()))\ns = []\nfor i in range(n):\n    s.append([i, 0])\nD = Dsu(n, s)\nfor i in range(M):\n    T = list(map(int, input().split()))\n    if T[0] == 1:\n        speed[T[1] - 1] = T[2]\n    elif T[0] == 2:\n        optwo(T[1] - 1, T[2] - 1, D)\n    elif T[0] == 3:\n        opthree(T[1] - 1, T[2] - 1, T[3], D)", "import math\nimport sys\n\ndef reduceSpeed(speed):\n    if speed[1] == 0:\n        return\n    gcd = math.gcd(speed[0], speed[1])\n    speed[0] //= gcd\n    speed[1] //= gcd\n    if speed[1] < 0:\n        (speed[0], speed[1]) = (-speed[0], -speed[1])\n\ndef calcSpeed(dest_num_teeth, source_num_teeth, source_speed):\n    speed = source_speed.copy()\n    speed[0] *= -source_num_teeth\n    speed[1] *= dest_num_teeth\n    return speed\n\nclass Gear:\n    num_teeth = 0\n    direction = 1\n    connections = []\n\n    def __init__(self, num_teeth):\n        self.num_teeth = num_teeth\n        self.direction = 1\n        self.connections = [self]\n\n    def isStopped(self):\n        return self.direction == 0\n\nclass GearSet:\n    gears = []\n\n    def __init__(self, teeth):\n        self.gears = [Gear(t) for (i, t) in enumerate(teeth)]\n\n    def makeStoppedGears(connections):\n        for g in connections:\n            g.direction = 0\n\n    def reverseDirections(connections):\n        for g in connections:\n            g.direction = -g.direction\n\n    def mergeConnections(connections1, connections2):\n        for g in connections1:\n            g.connections = connections2\n        connections2.extend(connections1)\n\n    def UpdateNumTeeth(self, gear, num_teeth):\n        self.gears[gear].num_teeth = num_teeth\n\n    def addConnection(self, gear1, gear2):\n        g1 = self.gears[gear1]\n        g2 = self.gears[gear2]\n        c1 = g1.connections\n        c2 = g2.connections\n        if c1 is c2:\n            if g1.isStopped():\n                return\n            if not g1.direction == -g2.direction:\n                GearSet.makeStoppedGears(c1)\n            return\n        if len(c1) > len(c2):\n            (g1, c1, g2, c2) = (g2, c2, g1, c1)\n        if g1.isStopped() or g2.isStopped():\n            if not g1.isStopped():\n                GearSet.makeStoppedGears(c1)\n            if not g2.isStopped():\n                GearSet.makeStoppedGears(c2)\n        elif not g1.direction == -g2.direction:\n            GearSet.reverseDirections(c1)\n        GearSet.mergeConnections(c1, c2)\n\n    def calcRotation(self, dest_gear, source_gear, source_speed):\n        dg = self.gears[dest_gear]\n        sg = self.gears[source_gear]\n        if dg.isStopped():\n            return [0, 0]\n        if not dg.connections == sg.connections:\n            return [0, 0]\n        s = calcSpeed(dg.num_teeth, sg.num_teeth, [sg.direction * source_speed, -dg.direction])\n        reduceSpeed(s)\n        return s\n(n, m) = map(int, input().split())\ngears = [0]\ngears.extend(list(map(int, input().split())))\ngear_set = GearSet(gears)\n\ndef processQuery(query):\n    query = list(map(int, query.split()))\n    if query[0] == 1:\n        gear_set.UpdateNumTeeth(query[1], query[2])\n    elif query[0] == 2:\n        gear_set.addConnection(query[1], query[2])\n    else:\n        speed = gear_set.calcRotation(query[2], query[1], query[3])\n        if speed[0] == 0 or speed[1] == 0:\n            print(0)\n        else:\n            print('%d/%d' % (speed[0], speed[1]))\nlist(map(processQuery, sys.stdin.readlines()))", "class Dsu:\n\n    def __init__(self, v, s):\n        self.par = s\n        self.v = v\n        self.dr = [1] * v\n        self.zero = [False] * v\n        self.speed = []\n        for i in range(v):\n            self.speed.append([])\n            self.speed[i].append(i)\n\n    def find(self, i):\n        if i != self.par[i][0]:\n            org = self.par[i][0]\n            self.par[i][0] = self.find(self.par[i][0])\n            if self.zero[i] or self.zero[self.par[i][0]] or self.zero[org]:\n                self.zero[i] = self.zero[self.par[i][0]] = self.zero[org] = True\n            if org != self.par[i][0]:\n                self.speed[self.par[i][0]].append(i)\n        return self.par[i][0]\n\n    def union(self, x, y):\n        self.rx = self.find(x)\n        self.ry = self.find(y)\n        self.sign = -self.dr[x] * self.dr[y]\n        if self.rx != self.ry:\n            if self.par[self.rx][1] < self.par[self.ry][1]:\n                mx = self.ry\n                mn = self.rx\n            if self.par[self.rx][1] > self.par[self.ry][1]:\n                mx = self.rx\n                mn = self.ry\n            if self.par[self.rx][1] != self.par[self.ry][1]:\n                self.par[mn][0] = mx\n                if self.zero[mn] or self.zero[mx] or self.zero[x] or self.zero[y]:\n                    self.zero[mn] = self.zero[mx] = self.zero[x] = self.zero[y] = True\n                else:\n                    for i in range(len(self.speed[mn])):\n                        self.dr[self.speed[mn][i]] *= self.sign\n                        org = self.par[self.speed[mn][i]][0]\n                        if org != mx:\n                            self.par[self.speed[mn][i]][0] = mx\n                            self.speed[mx].append(self.speed[mn][i])\n                self.speed[mx].append(mn)\n            else:\n                self.par[self.ry][0] = self.rx\n                self.par[self.rx][1] += 1\n                if self.zero[self.rx] or self.zero[self.ry] or self.zero[x] or self.zero[y]:\n                    self.zero[self.rx] = self.zero[self.ry] = self.zero[x] = self.zero[y] = True\n                else:\n                    for i in range(len(self.speed[self.ry])):\n                        self.dr[self.speed[self.ry][i]] *= self.sign\n                        org = self.par[self.speed[self.ry][i]][0]\n                        if org != self.rx:\n                            self.par[self.speed[self.ry][i]][0] = self.rx\n                            self.speed[self.rx].append(self.speed[self.ry][i])\n                self.speed[self.rx].append(self.ry)\n        else:\n            return\n\ndef optwo(x, y, D):\n    if D.find(x) == D.find(y) and D.dr[x] == D.dr[y]:\n        D.zero[x] = D.zero[y] = True\n    D.union(x, y)\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    else:\n        return gcd(b % a, a)\n\ndef opthree(x, y, v, D):\n    if D.find(x) != D.find(y) or D.zero[D.par[y][0]]:\n        print(0)\n    else:\n        g = gcd(v * speed[x], speed[y])\n        flag = D.dr[x] * D.dr[y] // abs(D.dr[x] * D.dr[y])\n        print(str(flag * v * speed[x] // g) + '/' + str(speed[y] // g))\n(n, M) = map(int, input().split())\nspeed = list(map(int, input().split()))\ns = []\nfor i in range(n):\n    s.append([i, 0])\nD = Dsu(n, s)\nfor i in range(M):\n    T = list(map(int, input().split()))\n    if T[0] == 1:\n        speed[T[1] - 1] = T[2]\n    elif T[0] == 2:\n        optwo(T[1] - 1, T[2] - 1, D)\n    elif T[0] == 3:\n        opthree(T[1] - 1, T[2] - 1, T[3], D)", "class Node:\n\n    def __init__(self, i, v, p):\n        self.data = i\n        self.val = v\n        self.parent = p\n\ndef gcd(a, b):\n    if a > b:\n        a = a % b\n        if a == 0:\n            return b\n    else:\n        b = b % a\n        if b == 0:\n            return a\n    return gcd(a, b)\n(n, m) = map(int, input().split())\narr = list(map(int, input().split()))\ngear = [0] * (n + 1)\nblocked = [0] * (n + 1)\nst = [0] * (n + 1)\nfor i in range(n + 1):\n    gear[i] = Node(i, -1, -1)\n    st[i] = []\nqr = [0] * 4\nfor i in range(m):\n    qr = list(map(int, input().split()))\n    if qr[0] == 1:\n        arr[qr[1] - 1] = qr[2]\n    elif qr[0] == 2:\n        if gear[qr[1]].parent == -1 and gear[qr[2]].parent == -1:\n            gear[qr[2]].parent = qr[1]\n            gear[qr[2]].val = 1\n            gear[qr[1]].parent = qr[1]\n            gear[qr[1]].val = 0\n            st[qr[1]].append(gear[qr[1]].data)\n            st[qr[1]].append(gear[qr[2]].data)\n        elif gear[qr[1]].parent == -1:\n            gear[qr[1]].parent = gear[qr[2]].parent\n            gear[qr[1]].val = 1\n            if gear[qr[2]].val == 1:\n                gear[qr[1]].val = 0\n            st[gear[qr[2]].parent].append(gear[qr[1]].data)\n        elif gear[qr[2]].parent == -1:\n            gear[qr[2]].parent = gear[qr[1]].parent\n            gear[qr[2]].val = 1\n            if gear[qr[1]].val == 1:\n                gear[qr[2]].val = 0\n            st[gear[qr[1]].parent].append(gear[qr[2]].data)\n        elif gear[qr[1]].parent == gear[qr[2]].parent:\n            if gear[qr[2]].val == gear[qr[1]].val:\n                blocked[gear[qr[1]].parent] = 1\n        else:\n            a = gear[qr[1]].parent\n            b = gear[qr[2]].parent\n            if len(st[a]) < len(st[b]):\n                b = gear[qr[1]].parent\n                a = gear[qr[2]].parent\n            if gear[qr[1]].val == gear[qr[2]].val:\n                for i in range(len(st[b])):\n                    if gear[st[b][i]].val == 0:\n                        gear[st[b][i]].val = 1\n                    else:\n                        gear[st[b][i]].val = 0\n                    gear[st[b][i]].parent = a\n                st[a].extend(st[b])\n            else:\n                for i in range(len(st[b])):\n                    gear[st[b][i]].parent = a\n                st[a].extend(st[b])\n    else:\n        f = gear[qr[1]]\n        s = gear[qr[2]]\n        if f.parent == -1 or s.parent == -1 or f.parent != s.parent or (blocked[f.parent] == 1) or (blocked[s.parent] == 1):\n            print('0')\n        else:\n            g = gcd(qr[3] * arr[qr[1] - 1], arr[qr[2] - 1])\n            if f.val != s.val:\n                print('-', end='')\n            print(qr[3] * arr[qr[1] - 1] // g, end='/')\n            print(arr[qr[2] - 1] // g)", "import queue\n\ndef find(parent, i, distance):\n    root = i\n    while parent[root] != root:\n        root = parent[root]\n        distance[i] += distance[root]\n    return root\n\ndef find2(parent, i, distance):\n    root = i\n    while parent[root] != root:\n        root = parent[root]\n    return root\n\ndef update(parent, des, distance, dis, new_parent):\n    root = des\n    while parent[root] != new_parent:\n        root = parent[root]\n        temp = distance[root]\n        distance[root] = dis + distance[des]\n        dis = temp\n        des = root\n\ndef union(parent, size, x, y, cycle, distance, parent1, parent2):\n    parent_x = parent1\n    parent_y = parent2\n    if parent_x != parent_y:\n        if cycle[parent_x] == 1:\n            size[parent_x] += size[parent_y]\n            parent[parent_y] = parent_x\n        elif cycle[parent_y] == 1:\n            size[parent_y] += size[parent_x]\n            parent[parent_x] = parent_y\n        elif size[parent_x] < size[parent_y]:\n            size[parent_y] += size[parent_x]\n            parent[parent_x] = parent_y\n        else:\n            size[parent_x] += size[parent_y]\n            parent[parent_y] = parent_x\n\ndef bfs(edges, visited, distance, color, source, cycle, parent, count, connections):\n    q = queue.Queue(100000)\n    q.put(source)\n    visited[source] = count\n    distance[source] = 0\n    color[source] = 1\n    while q.empty() == False:\n        source = q.get()\n        parent[source] = find(parent, source)\n        c = 1\n        j = 0\n        while c <= connections[source]:\n            if visited[edges[source][j]] != count:\n                visited[edges[source][j]] = count\n                distance[edges[source][j]] = distance[source] + 1\n                color[edges[source][j]] = 1 - color[source]\n                q.put(edges[source][j])\n            elif visited[edges[source][j]] == count and color[edges[source][j]] == color[source]:\n                cycle[parent[source]] = 1\n                break\n            j += 1\n            c += 1\n        if cycle[parent[source]] == 1:\n            break\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    else:\n        return gcd(b % a, a)\ns = list(map(int, input().split()))\nn = s[0]\nm = s[1]\nnum = input().split()\nnum = list(map(int, num))\nedges = []\nparent = []\nsize = []\nvisited = []\ndistance = []\ncolor = []\ncycle = []\nconnections = []\ncount = 0\nfor i in range(0, n + 1):\n    edges.append([])\n    parent.append(i)\n    size.append(1)\n    color.append(-1)\n    visited.append(0)\n    distance.append(0)\n    cycle.append(0)\n    connections.append(0)\ni = 1\nwhile i <= m:\n    st = input().split()\n    st = list(map(int, st))\n    type = st[0]\n    if type == 1:\n        index = st[1]\n        teeth = st[2]\n        num[index - 1] = teeth\n    elif type == 2:\n        src = st[1]\n        des = st[2]\n        parent[src] = find(parent, src, distance)\n        parent[des] = find(parent, des, distance)\n        if src != des:\n            if parent[src] == parent[des]:\n                d1 = distance[des] - distance[src]\n                if d1 % 2 == 0:\n                    cycle[parent[src]] = 1\n            else:\n                prev1 = parent[src]\n                prev2 = parent[des]\n                dis = distance[src]\n                dis1 = distance[des]\n                union(parent, size, src, des, cycle, distance, parent[src], parent[des])\n                new1 = find2(parent, src, distance)\n                new2 = find2(parent, des, distance)\n                if new1 == prev1:\n                    distance[des] = distance[src] + 1\n                    if prev2 != des:\n                        update(parent, des, distance, dis1, new1)\n                    parent[des] = find2(parent, des, distance)\n                else:\n                    distance[src] = distance[des] + 1\n                    if prev1 != src:\n                        update(parent, src, distance, dis, new1)\n                    parent[src] = find2(parent, src, distance)\n    else:\n        count += 1\n        src = st[1]\n        des = st[2]\n        speed = st[3]\n        parent[src] = find(parent, src, distance)\n        parent[des] = find(parent, des, distance)\n        if parent[src] != parent[des]:\n            print(0)\n        elif parent[src] == parent[des]:\n            if cycle[parent[src]] == 1:\n                print(0)\n            else:\n                d = distance[des] - distance[src]\n                if cycle[parent[src]] == 1:\n                    print(0)\n                elif d % 2 == 0:\n                    numerator = num[src - 1]\n                    denominator = num[des - 1]\n                    numerator *= speed\n                    g = gcd(numerator, denominator)\n                    numerator //= g\n                    denominator //= g\n                    print(str(numerator) + '/' + str(denominator))\n                else:\n                    numerator = num[src - 1]\n                    denominator = num[des - 1]\n                    numerator *= speed\n                    g = gcd(numerator, denominator)\n                    numerator //= g\n                    denominator //= g\n                    print('-' + str(numerator) + '/' + str(denominator))\n    i += 1", "import math\nimport sys\n\ndef gcd(x, y):\n    if y == 0:\n        return x\n    return gcd(y, x % y)\n\ndef union(x, y, par, node, child):\n    x1 = x\n    while par[x1] >= 0:\n        x1 = par[x1]\n    y1 = y\n    while par[y1] >= 0:\n        y1 = par[y1]\n    if x1 == y1:\n        print(1 / 0)\n        sys.exit()\n    if len(child[x1]) < len(child[y1]) and y1 != 0 or y1 == 0:\n        smr = x1\n        lgr = y1\n    else:\n        smr = y1\n        lgr = x1\n    tovisit = [smr]\n    mulby = node[x] * node[y] * -1\n    while len(tovisit) > 0:\n        x = tovisit.pop()\n        child[lgr].append(x)\n        node[x] *= mulby\n        tovisit += child[x]\n        child[x] = []\n        par[x] = lgr\n\ndef findpar(x, par, child):\n    x1 = x\n    if par[x] < 0:\n        return x\n    while par[par[x]] >= 0:\n        x = par[x]\n    tovisit = child[x]\n    x1 = par[x]\n    while len(tovisit) > 0:\n        x = tovisit.pop()\n        child[x1].append(x)\n        tovisit += child[x]\n        child[x] = []\n        par[x] = x1\n    return x1\n\ndef setblock(x, par, node, child):\n    if findpar(x, par, child) == 0:\n        return\n    union(x, 0, par, node, child)\n(n, m) = map(int, input().split())\na = [0] + list(map(int, input().split()))\nchild = [[] for i in range(n + 1)]\npar = [-math.inf] + [-1 for i in range(n)]\nnode = [0] + [1 for i in range(n)]\nfor i in range(m):\n    cmd = list(map(int, input().split()))\n    if cmd[0] == 1:\n        a[cmd[1]] = cmd[2]\n    elif cmd[0] == 2:\n        if findpar(cmd[1], par, child) == findpar(cmd[2], par, child):\n            if node[cmd[1]] == node[cmd[2]]:\n                setblock(cmd[1], par, node, child)\n        else:\n            union(cmd[1], cmd[2], par, node, child)\n    elif findpar(cmd[1], par, child) == findpar(cmd[2], par, child) and findpar(cmd[2], par, child) != 0:\n        num = a[cmd[1]] * cmd[3]\n        den = a[cmd[2]]\n        gcd1 = gcd(num, den)\n        num //= gcd1\n        den //= gcd1\n        num *= node[cmd[1]] * node[cmd[2]]\n        print(str(num) + '/' + str(den))\n    else:\n        print(0)", "import math\n\nclass Set_Node:\n\n    def __init__(self, value, rank):\n        self.value = value\n        self.parent = self\n        self.rank = rank\n        self.color = None\n        self.arr = [self]\n        self.block = 0\n        self.total = 1\n\nclass Set:\n\n    def makeset(self, val):\n        t = Set_Node(val, 0)\n        return t\n\n    def findset(self, ptr):\n        if ptr == None:\n            return None\n        else:\n            if ptr == ptr.parent:\n                return ptr\n            ptr.parent = self.findset(ptr.parent)\n            return ptr.parent\n\n    def union(self, ptr_x, ptr_y):\n        x = self.findset(ptr_x)\n        y = self.findset(ptr_y)\n        if x.rank > y.rank:\n            y.parent = x\n            x.arr += y.arr[:]\n            x.total += y.total\n        elif x.rank < y.rank:\n            x.parent = y\n            y.arr += x.arr[:]\n            y.total += x.total\n        else:\n            y.parent = x\n            x.rank += 1\n            x.arr += y.arr[:]\n            x.total += y.total\nS = Set()\n(n, m) = map(int, input().split())\narr = [int(x) for x in input().split()]\nptr = [0] * n\nfor i in range(n):\n    ptr[i] = S.makeset(i)\nfor i in range(m):\n    arr2 = [int(x) for x in input().split()]\n    if arr2[0] == 1:\n        arr[arr2[1] - 1] = arr2[2]\n    elif arr2[0] == 2:\n        x = arr2[1] - 1\n        y = arr2[2] - 1\n        l = S.findset(ptr[x])\n        m = S.findset(ptr[y])\n        if l != m:\n            if ptr[x].color == None and ptr[y].color == None:\n                ptr[x].color = 0\n                ptr[y].color = 1\n                S.union(ptr[x], ptr[y])\n            elif ptr[x].color == None:\n                ptr[x].color = (ptr[y].color + 1) % 2\n                S.union(ptr[x], ptr[y])\n            elif ptr[y].color == None:\n                ptr[y].color = (ptr[x].color + 1) % 2\n                S.union(ptr[x], ptr[y])\n            elif ptr[y].color == ptr[x].color:\n                if l.total > m.total:\n                    for j in m.arr:\n                        j.color = (j.color + 1) % 2\n                else:\n                    for j in l.arr:\n                        j.color = (j.color + 1) % 2\n                S.union(ptr[x], ptr[y])\n            else:\n                S.union(ptr[x], ptr[y])\n        elif ptr[x].color == ptr[y].color:\n            l.block = 1\n    else:\n        x = arr2[1] - 1\n        y = arr2[2] - 1\n        v = arr2[3]\n        l = S.findset(ptr[x])\n        m = S.findset(ptr[y])\n        if l != m or l.block == 1 or m.block == 1:\n            print(0)\n        else:\n            num = arr[x] * v\n            den = arr[y]\n            g = math.gcd(num, den)\n            num = num // g\n            den = den // g\n            if ptr[x].color != ptr[y].color:\n                print('-' + str(num) + '/' + str(den))\n            else:\n                print(str(num) + '/' + str(den))", "import sys\nfrom collections import defaultdict as dd\nfrom itertools import permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nmod = 10 ** 9 + 7\n(n, m) = [int(i) for i in input().split()]\na = [0] + [int(i) for i in input().split()]\ndis = [0 for i in range(n + 1)]\n\ndef MakeSet(x):\n    x.parent = x\n    x.rank = 0\n    x.size = 1\n    x.nouse = 0\n\ndef Union(x, y):\n    xRoot = Find(x)\n    yRoot = Find(y)\n    if xRoot.rank > yRoot.rank:\n        yRoot.parent = xRoot\n        xRoot.size += yRoot.size\n        xRoot.nouse = max(xRoot.nouse, yRoot.nouse)\n    elif xRoot.rank < yRoot.rank:\n        xRoot.parent = yRoot\n        yRoot.size += xRoot.size\n        yRoot.nouse = max(xRoot.nouse, yRoot.nouse)\n    elif xRoot != yRoot:\n        yRoot.parent = xRoot\n        xRoot.size += yRoot.size\n        xRoot.rank = xRoot.rank + 1\n        xRoot.nouse = max(xRoot.nouse, yRoot.nouse)\n\ndef Find(x):\n    if x.parent == x:\n        return x\n    else:\n        x.parent = Find(x.parent)\n        return x.parent\nimport itertools\n\nclass Node:\n\n    def __init__(self, label):\n        self.label = label\n\n    def __str__(self):\n        return self.label\ng = [Node(str(ch)) for ch in range(n + 1)]\n[MakeSet(ch) for ch in g]\ngraph = dd(list)\nvis = [0 for i in range(n + 1)]\n\ndef changedis(s):\n    rechange = [s]\n    start = s\n    bfs = [s]\n    vis[s] = 1\n    while bfs:\n        k = bfs.pop(0)\n        dis[k] ^= 1\n        for i in graph[k]:\n            if vis[i] == 0:\n                bfs.append(i)\n                vis[i] = 1\n                rechange.append(i)\n    for i in rechange:\n        vis[i] = 0\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\nfor i in range(m):\n    qu = [int(i) for i in input().split()]\n    (ch, x, y) = (qu[0], qu[1], qu[2])\n    if ch == 1:\n        a[x] = y\n    if ch == 2:\n        xx = Find(g[x])\n        yy = Find(g[y])\n        if xx == yy:\n            if dis[x] != dis[y]:\n                pass\n            else:\n                xx.nouse = 1\n        else:\n            Union(g[x], g[y])\n            if dis[x] == dis[y]:\n                if xx.size > yy.size:\n                    changedis(y)\n                else:\n                    changedis(x)\n        graph[x].append(y)\n        graph[y].append(x)\n    if ch == 3:\n        v = qu[3]\n        xx = Find(g[x])\n        yy = Find(g[y])\n        if xx != yy:\n            print(0)\n        elif xx.nouse == 1:\n            print(0)\n        else:\n            num = v * a[x]\n            den = a[y]\n            div = gcd(num, den)\n            num = num // div\n            den = den // div\n            if dis[x] == dis[y]:\n                print(str(num) + '/' + str(den))\n            else:\n                print('-' + str(num) + '/' + str(den))", "class disjointsets:\n\n    def __init__(self, n):\n        self.arr = [0] * n\n        self.size = [1] * n\n        for i in range(n):\n            self.arr[i] = i\n\n    def find(self, i):\n        if self.arr[i] == i:\n            return i\n        else:\n            self.arr[i] = self.find(self.arr[i])\n            return self.arr[i]\n\n    def union(self, i, j):\n        f1 = self.find(i)\n        f2 = self.find(j)\n        if f1 == f2:\n            return\n        elif self.size[f1] > self.size[f2]:\n            self.arr[f2] = f1\n            self.size[f1] += self.size[f2]\n        else:\n            self.arr[f1] = f2\n            self.size[f2] += self.size[f1]\n\ndef gcd(a, b):\n    if a < b:\n        temp = a\n        a = b\n        b = temp\n    while b > 0:\n        r = a % b\n        a = b\n        b = r\n    return a\na = [int(i) for i in input().split()]\nn = a[0]\nm = a[1]\nd1 = disjointsets(n)\nd2 = disjointsets(n)\nflag = [0] * n\narr = [-1] * n\ncolorarr = [0] * n\nteeth = [int(i) for i in input().split()]\nfor i in range(m):\n    a = [int(i) for i in input().split()]\n    if a[0] == 1:\n        teeth[a[1] - 1] = a[2]\n    elif a[0] == 2:\n        f1 = d1.find(a[1] - 1)\n        f2 = d1.find(a[2] - 1)\n        if f1 == f2:\n            c1 = d2.find(a[1] - 1)\n            c2 = d2.find(a[2] - 1)\n            x = a[1] - 1\n            y = a[2] - 1\n            if c1 == c2:\n                flag[f1] = 1\n        else:\n            fl1 = flag[f1]\n            fl2 = flag[f2]\n            x = a[1] - 1\n            y = a[2] - 1\n            neighx = arr[x]\n            neighy = arr[y]\n            d1.union(x, y)\n            if neighx == neighy and neighx == -1:\n                colorarr[x] = 1\n                colorarr[y] = 2\n            elif neighx == -1:\n                c = colorarr[d2.find(neighy)]\n                d2.union(x, neighy)\n                colorarr[d2.find(x)] = c\n            elif neighy == -1:\n                c = colorarr[d2.find(neighx)]\n                d2.union(neighx, y)\n                colorarr[d2.find(y)] = c\n            else:\n                c1 = colorarr[d2.find(neighx)]\n                c2 = colorarr[d2.find(neighy)]\n                d2.union(neighx, y)\n                d2.union(neighy, x)\n                colorarr[d2.find(x)] = c2\n                colorarr[d2.find(y)] = c1\n            arr[x] = y\n            arr[y] = x\n            if fl1 == 1 or fl2 == 1:\n                flag[d1.find(x)] = 1\n    else:\n        p = teeth[a[1] - 1] * a[3]\n        q = teeth[a[2] - 1]\n        g = gcd(p, q)\n        p = p // g\n        q = q // g\n        f1 = d1.find(a[1] - 1)\n        f2 = d1.find(a[2] - 1)\n        if f1 == f2 and flag[f1] != 1:\n            c1 = d2.find(a[1] - 1)\n            c2 = d2.find(a[2] - 1)\n            s = str(p) + '/' + str(q)\n            if c1 == c2:\n                print(s)\n            else:\n                print('-' + s)\n        else:\n            print(0)", "from fractions import Fraction\n[N, M] = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\nA = [0] + B[:]\np = [i for i in range(N + 1)]\nrank = [0] * (N + 1)\nisit = [0] * (N + 1)\nrot = [True] * (N + 1)\nadj = {}\nfor i in range(1, N + 1):\n    adj[i] = []\n\ndef bfs(s, val):\n    level = {s: 0}\n    vd = val\n    rot[s] = vd\n    i = 1\n    frontier = [s]\n    while frontier:\n        nexte = []\n        vd = not vd\n        for u in frontier:\n            for v in adj[u]:\n                if not v in level:\n                    level[v] = i\n                    rot[v] = vd\n                    nexte.append(v)\n        frontier = nexte\n        i += 1\n\ndef find_set(x):\n    if x != p[x]:\n        p[x] = find_set(p[x])\n    return p[x]\n\ndef link(x, y):\n    pX = find_set(x)\n    pY = find_set(y)\n    if isit[pX] == -1:\n        isit[pY] = -1\n    elif isit[pY] == -1:\n        isit[pX] = -1\n    elif pX != pY:\n        if rank[pX] > rank[pY]:\n            bfs(y, not rot[x])\n            p[pY] = pX\n        else:\n            bfs(x, not rot[y])\n            p[pX] = pY\n        if rank[pX] == rank[pY]:\n            rank[pY] += 1\n        adj[x].append(y)\n        adj[y].append(x)\n    elif pX == pY:\n        if rot[x] == rot[y]:\n            isit[pX] = -1\nfor _ in range(M):\n    T = [int(x) for x in input().split()]\n    if T[0] == 1:\n        A[T[1]] = T[2]\n    elif T[0] == 2:\n        link(T[1], T[2])\n    elif T[0] == 3:\n        pX = find_set(T[1])\n        pY = find_set(T[2])\n        if pX != pY:\n            print('0')\n        elif isit[pX] == -1:\n            print('0')\n        else:\n            num = T[3] * A[T[1]]\n            den = A[T[2]]\n            if rot[T[1]] != rot[T[2]]:\n                num *= -1\n            t1 = Fraction(num, den)\n            print(str(t1.numerator) + '/' + str(t1.denominator))", "def gcd(a, b):\n    if a == 0:\n        return b\n    else:\n        return gcd(b % a, a)\n\ndef dsfind(parent, i):\n    if parent[i] == i:\n        return i\n    return dsfind(parent, parent[i])\n\ndef dsunion(parent, rank, x, y, chn):\n    xroot = dsfind(parent, x)\n    yroot = dsfind(parent, y)\n    sx = dssign(parent, x, chn)\n    sy = dssign(parent, y, chn)\n    if rank[xroot] < rank[yroot]:\n        if sx == sy:\n            chn[xroot] = -1\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        if sx == sy:\n            chn[yroot] = -1\n        parent[yroot] = xroot\n    else:\n        if sx == sy:\n            chn[yroot] = -1\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef dssign(parent, i, chn):\n    a = 1\n    while parent[i] != i:\n        a *= chn[i]\n        i = parent[i]\n    a *= chn[i]\n    return a\n(n, m) = [int(x) for x in input().split()]\narr = [int(x) for x in input().split()]\nparent = []\nrank = []\nblock = []\nchn = []\nfor i in range(n):\n    parent.append(i)\n    rank.append(0)\n    block.append(0)\n    chn.append(1)\nfor i in range(m):\n    l = [int(x) for x in input().split()]\n    t = l[0]\n    if t == 1:\n        x = l[1] - 1\n        c = l[2]\n        arr[x] = c\n    if t == 2:\n        x = l[1] - 1\n        y = l[2] - 1\n        xroot = dsfind(parent, x)\n        yroot = dsfind(parent, y)\n        if xroot == yroot:\n            if block[xroot] == 0:\n                d1 = dssign(parent, x, chn)\n                d2 = dssign(parent, y, chn)\n                if d1 == d2:\n                    block[xroot] = 1\n            continue\n        if block[xroot] == 0 and block[yroot] == 1:\n            block[xroot] = 1\n        if block[yroot] == 0 and block[xroot] == 1:\n            block[yroot] = 1\n        dsunion(parent, rank, x, y, chn)\n    if t == 3:\n        x = l[1] - 1\n        y = l[2] - 1\n        v = l[3]\n        xroot = dsfind(parent, x)\n        yroot = dsfind(parent, y)\n        if xroot != yroot:\n            print(0)\n            continue\n        if block[xroot] == 1:\n            print(0)\n            continue\n        temp = gcd(v * arr[x], arr[y])\n        a1 = v * arr[x] // temp\n        a2 = arr[y] // temp\n        d1 = dssign(parent, x, chn)\n        d2 = dssign(parent, y, chn)\n        if d1 == d2:\n            s = str(a1) + '/' + str(a2)\n            print(s)\n        else:\n            s = str(-a1) + '/' + str(a2)\n            print(s)", "import math\n\nclass Node:\n\n    def __init__(self, k):\n        self.value = k\n        self.children = [self.value]\n        self.parent = self\n        self.rank = 0\n        self.link = 0\n        self.incycle = 0\n\nclass Disjoint:\n\n    def __init__(self, n):\n        self.lst = [None] * n\n        for i in range(n):\n            self.lst[i] = self.makeset(i)\n\n    def makeset(self, i):\n        return Node(i)\n\n    def findset(self, x):\n        if x.parent != x:\n            x.parent = self.findset(x.parent)\n        return x.parent\n\n    def union(self, a, b):\n        p = self.findset(self.lst[a])\n        q = self.findset(self.lst[b])\n        if self.lst[a].link == 0 and self.lst[b].link == 0:\n            self.lst[a].link = 1\n            self.lst[b].link = 2\n        elif self.lst[a].link == 0:\n            if self.lst[b].link == 1:\n                self.lst[a].link = 2\n            else:\n                self.lst[a].link = 1\n        elif self.lst[b].link == 0:\n            if self.lst[a].link == 1:\n                self.lst[b].link = 2\n            else:\n                self.lst[b].link = 1\n        else:\n            if p == q:\n                if self.lst[a].link == self.lst[b].link:\n                    self.lst[b].parent.incycle = 1\n                return\n            if p.incycle == 1 or q.incycle == 1:\n                self.lst[a].parent.incycle = 1\n                self.lst[b].parent.incycle = 1\n            elif self.lst[a].link == self.lst[b].link:\n                if len(self.lst[q.value].children) < len(self.lst[p.value].children):\n                    for i in range(len(self.lst[q.value].children)):\n                        if self.lst[self.lst[q.value].children[i]].link == 1:\n                            self.lst[self.lst[q.value].children[i]].link = 2\n                        else:\n                            self.lst[self.lst[q.value].children[i]].link = 1\n                else:\n                    for i in range(len(self.lst[p.value].children)):\n                        if self.lst[self.lst[p.value].children[i]].link == 1:\n                            self.lst[self.lst[p.value].children[i]].link = 2\n                        else:\n                            self.lst[self.lst[p.value].children[i]].link = 1\n            else:\n                count = 0\n        if p.rank > q.rank:\n            for i in range(len(self.lst[q.value].children)):\n                self.lst[self.lst[q.value].children[i]].parent = p\n                self.lst[p.value].children.append(self.lst[q.value].children[i])\n        elif p.rank < q.rank:\n            for i in range(len(self.lst[p.value].children)):\n                self.lst[self.lst[p.value].children[i]].parent = q\n                self.lst[q.value].children.append(self.lst[p.value].children[i])\n        else:\n            for i in range(len(self.lst[q.value].children)):\n                self.lst[self.lst[q.value].children[i]].parent = p\n                self.lst[p.value].children.append(self.lst[q.value].children[i])\n            p.rank += 1\n\ndef test3(Z, x, y, v, teeth):\n    if Z.lst[x].parent.incycle == 1 or Z.lst[y].parent.incycle == 1 or Z.lst[x].parent != Z.lst[y].parent:\n        print(0)\n        return\n    p = int(teeth[x]) * v\n    q = int(teeth[y])\n    r = math.gcd(p, q)\n    if Z.lst[x].link == Z.lst[y].link:\n        print(int(p / r), end='')\n        print('/', end='')\n        print(int(q / r))\n    else:\n        print(int(-p / r), end='')\n        print('/', end='')\n        print(int(q / r))\n\ndef main():\n    t = 1\n    for p in range(t):\n        (n, m) = input().split()\n        (n, m) = (int(n), int(m))\n        teeth = input().split()\n        Z = Disjoint(n)\n        for i in range(m):\n            lst = input().split()\n            if int(lst[0]) == 1:\n                teeth[int(lst[1]) - 1] = int(lst[2])\n            elif int(lst[0]) == 2:\n                Z.union(int(lst[1]) - 1, int(lst[2]) - 1)\n            else:\n                test3(Z, int(lst[1]) - 1, int(lst[2]) - 1, int(lst[3]), teeth)\nmain()", "from math import gcd\nimport numpy as np\n\ndef main():\n    (n, m) = [int(x) for x in input().split()]\n    teeth = np.array([int(x) for x in input().split()], dtype='int32')\n    group = np.zeros(n, dtype='int32')\n    rotation = np.zeros(n, dtype='int32')\n    group_count = 0\n    groups = np.zeros(10 ** 6, dtype='int32')\n    for _ in range(m):\n        q = [int(x) for x in input().split()]\n        if q[0] == 1:\n            teeth[q[1] - 1] = q[2]\n        elif q[0] == 3:\n            (x, y, v) = q[1:]\n            (x, y) = (x - 1, y - 1)\n            ans = 0\n            movable = group[x] > 0 and group[x] == group[y]\n            if movable:\n                numerator = teeth[x] * v\n                denominator = teeth[y]\n                reducer = gcd(numerator, denominator)\n                numerator //= reducer\n                denominator //= reducer\n                ans = ''\n                if rotation[x] * rotation[y] < 0:\n                    ans = '-'\n                ans = ans + '{}/{}'.format(numerator, denominator)\n            print(ans)\n        elif q[0] == 2:\n            (x, y) = q[1:]\n            (x, y) = (x - 1, y - 1)\n            if group[x] == 0 and group[y] == 0:\n                group_count += 1\n                groups[group_count] = 2\n                group[x] = group[y] = group_count\n                rotation[x] = 1\n                rotation[y] = -1\n            elif group[x] != 0 and group[y] != 0:\n                if group[x] == group[y]:\n                    if rotation[x] == rotation[y]:\n                        temp = group[x]\n                        group[group == temp] = -1\n                elif group[x] < 0:\n                    temp = group[y]\n                    group[group == temp] = -1\n                elif group[y] < 0:\n                    temp = group[x]\n                    group[group == temp] = -1\n                else:\n                    temp = group[y]\n                    temp2 = group[x]\n                    if groups[group[y]] > groups[group[x]]:\n                        (temp, temp2) = (temp2, temp)\n                    if rotation[x] == rotation[y]:\n                        rotation[group == temp] *= -1\n                    group[group == temp] = temp2\n                    groups[temp2] += groups[temp]\n            elif group[x] == 0:\n                group[x] = group[y]\n                groups[group[y]] += 1\n                rotation[x] = -rotation[y]\n            elif group[y] == 0:\n                group[y] = group[x]\n                groups[group[x]] += 1\n                rotation[y] = -rotation[x]\nmain()", "(N, M) = map(int, input().split())\n(*A,) = map(int, input().split())\n\ndef gcd(m, n):\n    r = m % n\n    return gcd(n, r) if r else n\nblk = [0] * N\nF = [0] * N\n(*p,) = range(N)\n\ndef root(x):\n    if p[x] == x:\n        return x\n    z = p[x]\n    p[x] = y = root(p[x])\n    if F[z]:\n        F[x] ^= 1\n        A[x] = -A[x]\n    return y\n\ndef unite(x, y):\n    px = root(x)\n    py = root(y)\n    if px < py:\n        if blk[py]:\n            blk[px] = 1\n        assert A[py] >= 0 and F[py] == 0\n        if A[x] * A[y] >= 0:\n            A[py] = -A[py]\n            F[py] ^= 1\n        p[py] = px\n    else:\n        if blk[px]:\n            blk[py] = 1\n        assert A[px] >= 0 and F[px] == 0\n        if A[x] * A[y] >= 0:\n            A[px] = -A[px]\n            F[px] ^= 1\n        p[px] = py\nans = []\nfor i in range(M):\n    (T, *CS) = map(int, input().split())\n    if T == 1:\n        (X, C) = CS\n        X -= 1\n        if A[X] >= 0:\n            A[X] = C\n        else:\n            A[X] = -C\n    elif T == 2:\n        (X, Y) = CS\n        X -= 1\n        Y -= 1\n        if root(X) == root(Y):\n            if A[X] * A[Y] >= 0:\n                blk[root(X)] = 1\n        else:\n            unite(X, Y)\n    else:\n        (X, Y, V) = CS\n        X -= 1\n        Y -= 1\n        if root(X) != root(Y):\n            ans.append('0')\n            continue\n        if blk[root(X)]:\n            ans.append('0')\n            continue\n        root(X)\n        root(Y)\n        a = A[X] * V\n        b = A[Y]\n        if b < 0:\n            a = -a\n            b = -b\n        g = gcd(abs(a), abs(b))\n        ans.append('%d/%d' % (a // g, b // g))\nprint(*ans, sep='\\n')"]