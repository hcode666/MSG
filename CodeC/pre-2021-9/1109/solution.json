["from sys import stdin\nmod = int(1000000000.0) + 7\nfact = [1] * 100001\n\ndef generateFactorials():\n    for i in range(1, 100001):\n        fact[i] = i * fact[i - 1] % mod\ngenerateFactorials()\n\ndef isUnique(a, length, freq, target, n):\n    freq[target] -= 2\n    pairs = 0\n    elements = 2\n    mul = 0\n    deno = 1\n    num = fact[n - 1]\n    for i in range(length):\n        p1 = a[i]\n        p2 = target - a[i]\n        n1 = freq.get(p1)\n        n2 = freq.get(p2, 0)\n        if n1 > 0 and n2 > 0:\n            req = n1\n            if n1 != n2:\n                return 0\n            if p1 != p2:\n                mul = mul + req\n            else:\n                req = req // 2\n            elements += 2 * req\n            deno = deno * fact[req] % mod\n            freq[a[i]] = -1\n            freq[target - a[i]] = -1\n    if elements == 2 * n:\n        return pow(2, mul, mod) * (num * pow(deno, mod - 2, mod)) % mod % mod\n    else:\n        return 0\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    summ = sum(arr)\n    if n == 1:\n        if arr[0] == arr[1]:\n            print(1)\n        else:\n            print(0)\n        continue\n    elif n > 1:\n        check = [0]\n        if [0] == list(set(arr)):\n            print(1)\n            continue\n    freq = {}\n    for i in arr:\n        if freq.get(i, -1) == -1:\n            freq[i] = 0\n        freq[i] += 1\n    a = list(freq.keys())\n    length = len(a)\n    possible = []\n    for i in a:\n        if freq.get(i) >= 2 and (n + 1) * i == summ:\n            possible.append(i)\n    answer = 0\n    if len(possible) == 0:\n        print(0)\n        continue\n    assert len(possible) == 1\n    for i in possible:\n        answer = (answer + isUnique(a, length, freq, i, n)) % mod\n        freq[i] += 2\n    print(answer % mod)", "from sys import stdin\nmod = int(1000000000.0) + 7\nfact = [1] * 100001\n\ndef generateFactorials():\n    for i in range(1, 100001):\n        fact[i] = i * fact[i - 1] % mod\ngenerateFactorials()\n\ndef isUnique(a, length, freq, target, n):\n    freq[target] -= 2\n    pairs = 0\n    elements = 2\n    mul = 0\n    deno = 1\n    num = fact[n - 1]\n    for i in range(length):\n        p1 = a[i]\n        p2 = target - a[i]\n        n1 = freq.get(p1)\n        n2 = freq.get(p2, 0)\n        if n1 > 0 and n2 > 0:\n            req = n1\n            if n1 != n2:\n                return 0\n            if p1 != p2:\n                mul = mul + req\n            else:\n                req = req // 2\n            elements += 2 * req\n            deno = deno * fact[req] % mod\n            freq[a[i]] = -1\n            freq[target - a[i]] = -1\n    if elements == 2 * n:\n        return pow(2, mul, mod) * (num * pow(deno, mod - 2, mod)) % mod % mod\n    else:\n        return 0\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    summ = sum(arr)\n    if n == 1:\n        if arr[0] == arr[1]:\n            print(1)\n        else:\n            print(0)\n        continue\n    elif n > 1:\n        check = [0]\n        if [0] == list(set(arr)):\n            print(1)\n            continue\n    freq = {}\n    for i in arr:\n        if freq.get(i, -1) == -1:\n            freq[i] = 0\n        freq[i] += 1\n    a = list(freq.keys())\n    length = len(a)\n    possible = []\n    for i in a:\n        if freq.get(i) >= 2 and (n + 1) * i == summ:\n            possible.append(i)\n    answer = 0\n    if len(possible) == 0:\n        print(0)\n        continue\n    assert len(possible) == 1\n    for i in possible:\n        answer = (answer + isUnique(a, length, freq, i, n)) % mod\n        freq[i] += 2\n    print(answer % mod)", "import sys\nfrom collections import defaultdict\nimport math\nfrom typing import Dict, List\n\nclass Solution:\n    MOD = 1000000007\n    N = 10 ** 5 + 5\n\n    def __init__(self):\n        self.fact = self.giveFact()\n\n    def modMul(self, a: int, b: int) -> int:\n        return a % self.MOD * (b % self.MOD) % self.MOD\n\n    def power(self, a: int, b: int) -> int:\n        ans = 1\n        while b > 0:\n            if b & 1:\n                ans = ans * a % self.MOD\n            b = b >> 1\n            a = a * a % self.MOD\n        return ans % self.MOD\n\n    def giveFact(self) -> list:\n        l = []\n        for i in range(int(math.log2(self.N))):\n            l.append(i ** 2)\n        facts = []\n        for i in range(self.N):\n            facts.append(0)\n        facts[0] += 1\n        for i in range(1, self.N):\n            facts[i] = self.modMul(facts[i - 1], i)\n        return facts\n\n    def input(self) -> int:\n        return int(sys.stdin.readline())\n\n    def input_list(self) -> List[int]:\n        return [int(x) for x in sys.stdin.readline().split()]\n\n    def init_vars(self) -> list:\n        (m, h) = (defaultdict(int), defaultdict(int))\n        s = set()\n        return [m, h, s]\n\n    def populate_map(self, m, arr) -> dict:\n        for x in arr:\n            m[x] += 1\n        return m\n\n    def to_continue(self, f, n) -> bool:\n        if f:\n            print('0')\n            return False\n        if n == 1:\n            print('1')\n            return False\n        return True\n\n    def solve(self) -> None:\n        facts = self.fact\n        t = self.input()\n        for testcase in range(t):\n            n = self.input()\n            res = 1\n            arr = self.input_list()\n            L = self.init_vars()\n            (m, h, s) = (L[0], L[1], L[2])\n            SUM = sum(arr)\n            m = self.populate_map(m, arr)\n            for x in arr:\n                s.add(x)\n            prefix = SUM // (n + 1)\n            if m[prefix] < 2:\n                print('0')\n                continue\n            m[2 ** 0 - 1] += 2\n            flag = False\n            for x in s:\n                if m[x] != m[prefix - x]:\n                    flag = True\n                    break\n            flag = self.to_continue(flag, n)\n            if not flag:\n                continue\n            m[prefix] -= 2\n            m[0] -= 2\n            A = []\n            for i in range(len(arr)):\n                ele = arr[i]\n                if ele in h or h[ele] == 1:\n                    continue\n                if prefix % 2 == 0 and prefix == 2 * ele:\n                    r = m[ele] // 2\n                    A.append(r)\n                elif m[ele] > 1:\n                    r = m[ele]\n                    A.append(r)\n                h[ele] = 1\n                h[prefix - ele] = 1\n            fn = False\n            if prefix % 2 == 0:\n                fn = True\n            if fn:\n                res += m[prefix // 2] // 2\n            else:\n                res += 0\n            result = facts[n - 1] * pow(2, n - res) % self.MOD\n            for x in A:\n                result = result * self.power(facts[x], self.MOD - 2) % self.MOD\n            print(result)\ns = Solution()\ns.solve()", "from sys import stdin\nM = 10 ** 9 + 7\nfact = [0] * 1000001\nfact[0] = 1\nfor x in range(1, len(fact)):\n    fact[x] = x * fact[x - 1]\n    fact[x] = fact[x] % M\n\ndef power(x, y):\n    ans = 1\n    while y > 0:\n        if y % 2 == 1:\n            ans = ans * x % M\n        y = y // 2\n        x = x * x % M\n    return ans % M\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    l = [int(x) for x in stdin.readline().split()]\n    s = sum(l)\n    if s % (n + 1):\n        print(0)\n        continue\n    ans = fact[n - 1]\n    d = {}\n    for x in list(l):\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ssum = s // (n + 1)\n    if ssum in d and d[ssum] >= 2:\n        d[ssum] -= 2\n    else:\n        print(0)\n        continue\n    flag = 0\n    for x in dict(d):\n        if d[x] == 0:\n            continue\n        if ssum - x not in d or d[ssum - x] != d[x]:\n            flag = 1\n            break\n        elif ssum - x != x:\n            ans = ans * power(2, d[x]) % M\n            ans = ans * power(fact[d[x]], M - 2) % M\n            d[ssum - x] = 0\n        else:\n            if d[x] % 2 == 1:\n                flag = 1\n                break\n            ans = ans * power(fact[d[x] // 2], M - 2) % M\n            d[x] = 0\n    if flag == 1:\n        print(0)\n    else:\n        print(ans % M)", "from math import factorial\nimport sys\niterations = int(sys.stdin.readline())\nfor given_tc in range(iterations):\n    input_size = int(sys.stdin.readline())\n    MY_list = list(map(int, sys.stdin.readline().split()))\n    temporary_variable = sum(MY_list)\n    temporary_variable = temporary_variable / (input_size + 1)\n    temporary_variable = int(temporary_variable)\n    cnt = MY_list.count(temporary_variable)\n    if cnt >= 2:\n        unordered_map = {}\n        MY_list.sort(reverse=False)\n        MY_list.remove(temporary_variable)\n        n = 2 * input_size - 2\n        condition = True\n        countering = 0\n        MY_list.remove(temporary_variable)\n        for gibrish in range(0, n // 2, 1):\n            if MY_list[gibrish] > MY_list[n - gibrish - 1]:\n                chefpsaup = MY_list[n - gibrish - 1]\n                chefpsadown = MY_list[gibrish]\n            else:\n                chefpsaup = MY_list[gibrish]\n                chefpsadown = MY_list[n - gibrish - 1]\n            if chefpsaup + chefpsadown == temporary_variable:\n                if chefpsaup != chefpsadown:\n                    countering += 1\n                elif chefpsaup == chefpsadown:\n                    pass\n                elif chefpsaup == 'a':\n                    pass\n                elif chefpsadown == 'b':\n                    pass\n                else:\n                    pass\n                if unordered_map.get((chefpsaup, chefpsadown)) != None:\n                    unordered_map[chefpsaup, chefpsadown] += 1\n                else:\n                    unordered_map[chefpsaup, chefpsadown] = 1\n            else:\n                condition = False\n                sys.stdout.write('0\\n')\n                break\n        verdict = factorial(input_size - 1) % 1000000007\n        if condition:\n            for iterator in unordered_map:\n                verdict = verdict * pow(factorial(unordered_map[iterator]), 1000000005, 1000000007)\n                verdict %= 1000000007\n            verdict = verdict * pow(2, countering, 1000000007)\n            verdict %= 1000000007\n            verdict = int(verdict)\n            sys.stdout.write(str(verdict) + '\\n')\n    else:\n        sys.stdout.write('0\\n')", "from sys import stdin\nM = 10 ** 9 + 7\nfact = [0] * 1000001\nfact[0] = 1\nfor x in range(1, len(fact)):\n    fact[x] = x * fact[x - 1]\n    fact[x] = fact[x] % M\n\ndef power(x, y):\n    ans = 1\n    while y > 0:\n        if y % 2 == 1:\n            ans = ans * x % M\n        y = y // 2\n        x = x * x % M\n    return ans % M\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    l = [int(x) for x in stdin.readline().split()]\n    s = sum(l)\n    if s % (n + 1):\n        print(0)\n        continue\n    ans = fact[n - 1]\n    d = {}\n    for x in list(l):\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ssum = s // (n + 1)\n    if ssum in d and d[ssum] >= 2:\n        d[ssum] -= 2\n    else:\n        print(0)\n        continue\n    flag = 0\n    for x in dict(d):\n        if d[x] == 0:\n            continue\n        if ssum - x not in d or d[ssum - x] != d[x]:\n            flag = 1\n            break\n        elif ssum - x != x:\n            ans = ans * power(2, d[x]) % M\n            ans = ans * power(fact[d[x]], M - 2) % M\n            d[ssum - x] = 0\n        else:\n            if d[x] % 2 == 1:\n                flag = 1\n                break\n            ans = ans * power(fact[d[x] // 2], M - 2) % M\n            d[x] = 0\n    if flag == 1:\n        print(0)\n    else:\n        print(ans % M)", "from sys import stdin\nM = 10 ** 9 + 7\nfact = [0] * 1000001\nfact[0] = 1\nfor x in range(1, len(fact)):\n    fact[x] = x * fact[x - 1]\n    fact[x] = fact[x] % M\n\ndef power(x, y):\n    ans = 1\n    while y > 0:\n        if y % 2 == 1:\n            ans = ans * x % M\n        y = y // 2\n        x = x * x % M\n    return ans % M\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    l = [int(x) for x in stdin.readline().split()]\n    s = sum(l)\n    if s % (n + 1):\n        print(0)\n        continue\n    ans = fact[n - 1]\n    d = {}\n    for x in list(l):\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ssum = s // (n + 1)\n    if ssum in d and d[ssum] >= 2:\n        d[ssum] -= 2\n    else:\n        print(0)\n        continue\n    flag = 0\n    for x in dict(d):\n        if d[x] == 0:\n            continue\n        if ssum - x not in d or d[ssum - x] != d[x]:\n            flag = 1\n            break\n        elif ssum - x != x:\n            ans = ans * power(2, d[x]) % M\n            ans = ans * power(fact[d[x]], M - 2) % M\n            d[ssum - x] = 0\n        else:\n            if d[x] % 2 == 1:\n                flag = 1\n                break\n            ans = ans * power(fact[d[x] // 2], M - 2) % M\n            d[x] = 0\n    if flag == 1:\n        print(0)\n    else:\n        print(ans % M)", "from collections import Counter\nfrom sys import stdin\n(N, M) = (100001, 1000000007)\n(r, f) = ([1] * N, [1] * N)\nfor i in range(2, N):\n    f[i] = pow(f[i - 1] * i, 1, M)\n    r[i] = pow(f[i], M - 2, M)\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    if n == 1:\n        if a[0] != a[1]:\n            print(0)\n        else:\n            print(1)\n        continue\n    s = sum(a)\n    if s % (n + 1):\n        print(0)\n        continue\n    s //= n + 1\n    a = Counter(a)\n    if s not in a or a[s] < 2:\n        print(0)\n        continue\n    a[s] -= 2\n    t = x = 0\n    ans = f[n - 1]\n    for i in a:\n        if a[i]:\n            if s - i not in a:\n                t = 1\n                break\n            else:\n                if a[s - i] == a[i]:\n                    if s - i == i:\n                        if a[i] & 1:\n                            t = 1\n                            break\n                        x = a[i] >> 1\n                        ans = ans * r[a[i] >> 1] % M\n                    else:\n                        ans = ans * r[a[i]] % M\n                else:\n                    t = 1\n                    break\n                a[s - i] = 0\n    if t == 1:\n        print(0)\n    else:\n        print(ans * pow(2, n - 1 - x, M) % M)", "from sys import stdin, stdout\nmod = 1000000007\nfrom collections import defaultdict as dd\nt = stdin.readline()\nt = int(t)\nfact = [1]\nmul = 1\nfor i in range(1, 100002):\n    mul = mul * i % mod\n    fact.append(mul)\nfor _ in range(t):\n    n = stdin.readline()\n    n = int(n)\n    d = dd(int)\n    a = [int(x) for x in stdin.readline().split()]\n    s = 0\n    for i in a:\n        s += i\n        d[i] += 1\n    fs = s / (n + 1)\n    if d[fs] < 2:\n        print(0)\n    else:\n        flag = 0\n        d[fs] -= 2\n        nn = n - 1\n        ls = fact[n - 1]\n        nn -= d[fs / 2] // 2\n        m = 1\n        for i in a:\n            if d[i] != d[fs - i]:\n                flag = 1\n                break\n            else:\n                if i != fs - i:\n                    m *= fact[max(d[i], 1)]\n                    m %= mod\n                else:\n                    m *= fact[max(d[i] // 2, 1)]\n                    m %= mod\n                d[i] = d[fs - i] = 1\n        y = pow(m, mod - 2, mod)\n        ls *= y\n        ls %= mod\n        if flag == 1:\n            print(0)\n        else:\n            print(pow(2, nn, mod) * ls % mod)", "import sys\nfrom collections import defaultdict\nmod = 10 ** 9 + 7\nfac = [1]\nfor i in range(1, 10 ** 5 + 1):\n    fac.append(fac[-1] * i % mod)\n\ndef modularexpo(x, n, mod):\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = res * x % mod\n        x = x * x % mod\n        n = n // 2\n    return res\nfor _ in range(int(sys.stdin.readline().rstrip())):\n    n = int(sys.stdin.readline().rstrip())\n    arr = list(map(int, sys.stdin.readline().rstrip().split()))\n    if n == 1:\n        if arr[0] == arr[1]:\n            sys.stdout.write('1\\n')\n        else:\n            sys.stdout.write('0\\n')\n    else:\n        final = sum(arr) // (n + 1)\n        d = defaultdict(lambda : 0)\n        keys = []\n        for i in arr:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n                keys.append(i)\n        if final in d and d[final] >= 2:\n            d[final] -= 2\n            (total_pair, diff_pair, freq) = (0, 0, 1)\n            for i in keys:\n                x = min(d[i], d[final - i])\n                if i == final - i:\n                    if x % 2 == 0:\n                        d[i] = 0\n                    else:\n                        d[i] = 1\n                    total_pair += x // 2\n                    freq = freq * fac[x // 2] % mod\n                else:\n                    d[i] -= x\n                    d[final - i] -= x\n                    total_pair += x\n                    diff_pair += x\n                    freq = freq * fac[x] % mod\n            if total_pair != n - 1:\n                sys.stdout.write('0\\n')\n            else:\n                mod = 10 ** 9 + 7\n                temp1 = fac[total_pair]\n                temp2 = modularexpo(2, diff_pair, mod)\n                temp3 = freq\n                temp1 = temp1 * temp2 % mod\n                temp3 = modularexpo(temp3, mod - 2, mod)\n                temp3 = temp3 * temp1 % mod\n                sys.stdout.write(str(temp3) + '\\n')\n        else:\n            sys.stdout.write('0\\n')", "import sys\nfrom collections import defaultdict\nimport math\nfrom typing import Dict, List\n\nclass Solution:\n    MOD = 1000000007\n    N = 10 ** 5 + 5\n\n    def __init__(self):\n        self.fact = self.giveFact()\n\n    def modMul(self, a: int, b: int) -> int:\n        return a % self.MOD * (b % self.MOD) % self.MOD\n\n    def power(self, a: int, b: int) -> int:\n        ans = 1\n        while b > 0:\n            if b & 1:\n                ans = ans * a % self.MOD\n            b = b >> 1\n            a = a * a % self.MOD\n        return ans % self.MOD\n\n    def giveFact(self) -> list:\n        l = []\n        for i in range(int(math.log2(self.N))):\n            l.append(i ** 2)\n        facts = []\n        for i in range(self.N):\n            facts.append(0)\n        facts[0] += 1\n        for i in range(1, self.N):\n            facts[i] = self.modMul(facts[i - 1], i)\n        return facts\n\n    def input(self) -> int:\n        return int(sys.stdin.readline())\n\n    def input_list(self) -> List[int]:\n        return [int(x) for x in sys.stdin.readline().split()]\n\n    def init_vars(self) -> list:\n        (m, h) = (defaultdict(int), defaultdict(int))\n        s = set()\n        return [m, h, s]\n\n    def populate_map(self, m, arr) -> dict:\n        for x in arr:\n            m[x] += 1\n        return m\n\n    def to_continue(self, f, n) -> bool:\n        if f:\n            print('0')\n            return False\n        if n == 1:\n            print('1')\n            return False\n        return True\n\n    def solve(self) -> None:\n        facts = self.fact\n        t = self.input()\n        for testcase in range(t):\n            n = self.input()\n            res = 1\n            arr = self.input_list()\n            L = self.init_vars()\n            (m, h, s) = (L[0], L[1], L[2])\n            SUM = sum(arr)\n            m = self.populate_map(m, arr)\n            for x in arr:\n                s.add(x)\n            prefix = SUM // (n + 1)\n            if m[prefix] < 2:\n                print('0')\n                continue\n            m[2 ** 0 - 1] += 2\n            flag = False\n            for x in s:\n                if m[x] != m[prefix - x]:\n                    flag = True\n                    break\n            flag = self.to_continue(flag, n)\n            if not flag:\n                continue\n            m[prefix] -= 2\n            m[0] -= 2\n            A = []\n            for i in range(len(arr)):\n                ele = arr[i]\n                if ele in h or h[ele] == 1:\n                    continue\n                if prefix % 2 == 0 and prefix == 2 * ele:\n                    r = m[ele] // 2\n                    A.append(r)\n                elif m[ele] > 1:\n                    r = m[ele]\n                    A.append(r)\n                h[ele] = 1\n                h[prefix - ele] = 1\n            fn = False\n            if prefix % 2 == 0:\n                fn = True\n            if fn:\n                res += m[prefix // 2] // 2\n            else:\n                res += 0\n            result = facts[n - 1] * pow(2, n - res) % self.MOD\n            for x in A:\n                result = result * self.power(facts[x], self.MOD - 2) % self.MOD\n            print(result)\ns = Solution()\ns.solve()", "import sys\nfrom collections import defaultdict\nimport math\nfrom typing import Dict, List\n\nclass Solution:\n    MOD = 1000000007\n    N = 10 ** 5 + 5\n\n    def __init__(self):\n        self.fact = self.giveFact()\n\n    def modMul(self, a: int, b: int) -> int:\n        return a % self.MOD * (b % self.MOD) % self.MOD\n\n    def power(self, a: int, b: int) -> int:\n        ans = 1\n        while b > 0:\n            if b & 1:\n                ans = ans * a % self.MOD\n            b = b >> 1\n            a = a * a % self.MOD\n        return ans % self.MOD\n\n    def giveFact(self) -> list:\n        l = []\n        for i in range(int(math.log2(self.N))):\n            l.append(i ** 2)\n        facts = []\n        for i in range(self.N):\n            facts.append(0)\n        facts[0] += 1\n        for i in range(1, self.N):\n            facts[i] = self.modMul(facts[i - 1], i)\n        return facts\n\n    def input(self) -> int:\n        return int(sys.stdin.readline())\n\n    def input_list(self) -> List[int]:\n        return [int(x) for x in sys.stdin.readline().split()]\n\n    def init_vars(self) -> list:\n        (m, h) = (defaultdict(int), defaultdict(int))\n        s = set()\n        return [m, h, s]\n\n    def populate_map(self, m, arr) -> dict:\n        for x in arr:\n            m[x] += 1\n        return m\n\n    def to_continue(self, f, n) -> bool:\n        if f:\n            print('0')\n            return False\n        if n == 1:\n            print('1')\n            return False\n        return True\n\n    def solve(self) -> None:\n        facts = self.fact\n        t = self.input()\n        for testcase in range(t):\n            n = self.input()\n            res = 1\n            arr = self.input_list()\n            L = self.init_vars()\n            (m, h, s) = (L[0], L[1], L[2])\n            SUM = sum(arr)\n            m = self.populate_map(m, arr)\n            for x in arr:\n                s.add(x)\n            prefix = SUM // (n + 1)\n            if m[prefix] < 2:\n                print('0')\n                continue\n            m[2 ** 0 - 1] += 2\n            flag = False\n            for x in s:\n                if m[x] != m[prefix - x]:\n                    flag = True\n                    break\n            flag = self.to_continue(flag, n)\n            if not flag:\n                continue\n            m[prefix] -= 2\n            m[0] -= 2\n            A = []\n            for i in range(len(arr)):\n                ele = arr[i]\n                if ele in h or h[ele] == 1:\n                    continue\n                if prefix % 2 == 0 and prefix == 2 * ele:\n                    r = m[ele] // 2\n                    A.append(r)\n                elif m[ele] > 1:\n                    r = m[ele]\n                    A.append(r)\n                h[ele] = 1\n                h[prefix - ele] = 1\n            fn = False\n            if prefix % 2 == 0:\n                fn = True\n            if fn:\n                res += m[prefix // 2] // 2\n            else:\n                res += 0\n            result = facts[n - 1] * pow(2, n - res) % self.MOD\n            for x in A:\n                result = result * self.power(facts[x], self.MOD - 2) % self.MOD\n            print(result)\ns = Solution()\ns.solve()", "import sys\nfrom collections import defaultdict\nimport math\nfrom typing import Dict, List\n\nclass Solution:\n    MOD = 1000000007\n    N = 10 ** 5 + 5\n\n    def __init__(self):\n        self.fact = self.giveFact()\n\n    def modMul(self, a: int, b: int) -> int:\n        return a % self.MOD * (b % self.MOD) % self.MOD\n\n    def power(self, a: int, b: int) -> int:\n        ans = 1\n        while b > 0:\n            if b & 1:\n                ans = ans * a % self.MOD\n            b = b >> 1\n            a = a * a % self.MOD\n        return ans % self.MOD\n\n    def giveFact(self) -> list:\n        l = []\n        for i in range(int(math.log2(self.N))):\n            l.append(i ** 2)\n        facts = []\n        for i in range(self.N):\n            facts.append(0)\n        facts[0] += 1\n        for i in range(1, self.N):\n            facts[i] = self.modMul(facts[i - 1], i)\n        return facts\n\n    def input(self) -> int:\n        return int(sys.stdin.readline())\n\n    def input_list(self) -> List[int]:\n        return [int(x) for x in sys.stdin.readline().split()]\n\n    def init_vars(self) -> list:\n        (m, h) = (defaultdict(int), defaultdict(int))\n        s = set()\n        return [m, h, s]\n\n    def populate_map(self, m, arr) -> dict:\n        for x in arr:\n            m[x] += 1\n        return m\n\n    def solve(self) -> None:\n        facts = self.fact\n        t = self.input()\n        for testcase in range(t):\n            n = self.input()\n            res = 1\n            arr = self.input_list()\n            L = self.init_vars()\n            (m, h, s) = (L[0], L[1], L[2])\n            SUM = sum(arr)\n            m = self.populate_map(m, arr)\n            for x in arr:\n                s.add(x)\n            prefix = SUM // (n + 1)\n            if m[prefix] < 2:\n                print('0')\n                continue\n            m[2 ** 0 - 1] += 2\n            flag = False\n            for x in s:\n                if m[x] != m[prefix - x]:\n                    flag = True\n                    break\n            if flag:\n                print('0')\n                continue\n            if n == 1:\n                print('1')\n                continue\n            m[prefix] -= 2\n            m[0] -= 2\n            A = []\n            for i in range(len(arr)):\n                ele = arr[i]\n                if ele in h or h[ele] == 1:\n                    continue\n                if prefix % 2 == 0 and prefix == 2 * ele:\n                    r = m[ele] // 2\n                    A.append(r)\n                elif m[ele] > 1:\n                    r = m[ele]\n                    A.append(r)\n                h[ele] = 1\n                h[prefix - ele] = 1\n            fn = False\n            if prefix % 2 == 0:\n                fn = True\n            if fn:\n                res += m[prefix // 2] // 2\n            else:\n                res += 0\n            result = facts[n - 1] * pow(2, n - res) % self.MOD\n            for x in A:\n                result = result * self.power(facts[x], self.MOD - 2) % self.MOD\n            print(result)\ns = Solution()\ns.solve()", "import sys\nfrom collections import defaultdict\nimport math\nfrom typing import Dict, List\n\nclass Solution:\n    MOD = 1000000007\n    N = 10 ** 5 + 5\n\n    def __init__(self):\n        self.fact = self.giveFact()\n\n    def modMul(self, a: int, b: int) -> int:\n        return a % self.MOD * (b % self.MOD) % self.MOD\n\n    def power(self, a: int, b: int) -> int:\n        ans = 1\n        while b > 0:\n            if b & 1:\n                ans = ans * a % self.MOD\n            b = b >> 1\n            a = a * a % self.MOD\n        return ans % self.MOD\n\n    def giveFact(self) -> list:\n        l = []\n        for i in range(int(math.log2(self.N))):\n            l.append(i ** 2)\n        facts = []\n        for i in range(self.N):\n            facts.append(0)\n        facts[0] += 1\n        for i in range(1, self.N):\n            facts[i] = self.modMul(facts[i - 1], i)\n        return facts\n\n    def input(self) -> int:\n        return int(sys.stdin.readline())\n\n    def input_list(self) -> List[int]:\n        return [int(x) for x in sys.stdin.readline().split()]\n\n    def solve(self):\n        facts = self.fact\n        t = self.input()\n        for testcase in range(t):\n            n = self.input()\n            res = 1\n            arr = self.input_list()\n            (m, h) = (defaultdict(int), defaultdict(int))\n            s = set()\n            SUM = sum(arr)\n            for x in arr:\n                m[x] += 1\n                s.add(x)\n            prefix = SUM // (n + 1)\n            if m[prefix] < 2:\n                print('0')\n                continue\n            m[0] += 2\n            flag = False\n            for x in s:\n                if m[x] != m[prefix - x]:\n                    flag = True\n                    break\n            if flag:\n                print('0')\n                continue\n            if n == 1:\n                print('1')\n                continue\n            m[prefix] -= 2\n            m[0] -= 2\n            A = []\n            for i in range(len(arr)):\n                ele = arr[i]\n                if h[ele] == 1:\n                    continue\n                if prefix % 2 == 0 and prefix == 2 * ele:\n                    A.append(m[ele] // 2)\n                elif m[ele] > 1:\n                    A.append(m[ele])\n                h[ele] = 1\n                h[prefix - ele] = 1\n            if prefix % 2 == 0:\n                res += m[prefix // 2] // 2\n            result = facts[n - 1] * pow(2, n - res) % self.MOD\n            for x in A:\n                result = result * self.power(facts[x], self.MOD - 2) % self.MOD\n            print(result)\ns = Solution()\ns.solve()", "mod = pow(10, 9) + 7\nimport math\n\ndef modFact(n, p):\n    if n >= p:\n        return 0\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i % p\n    return result\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    if inv == -1:\n        print('Division not defined')\n    else:\n        return inv * a % m\n\ndef generating(n):\n    x = modFact(n, mod)\n    x = x * pow(2, n, mod)\n    return x % mod\nfinall = []\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    d = {}\n    candidate = []\n    mark = 0\n    for i in l:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n            if d[i] >= 2:\n                candidate.append(i)\n                mark += 1\n    if mark == 0:\n        finall.append(0)\n    else:\n        if 0 not in d:\n            d[0] = 2\n        else:\n            d[0] += 2\n        l.append(0)\n        l.append(0)\n        for i in candidate:\n            flag = 0\n            for x in l:\n                diff = i - x\n                if diff not in d:\n                    flag = 1\n                    break\n                elif d[diff] != d[x]:\n                    flag = 1\n                    break\n            if flag == 0:\n                break\n        if flag == 0:\n            item = i\n            g = {}\n            for i in l:\n                diff = item - i\n                if diff not in g:\n                    if i not in g:\n                        g[diff] = 1\n                else:\n                    g[diff] += 1\n            ans = 1\n            if 0 in g:\n                g[0] -= 2\n            if item in g:\n                g[item] -= 2\n            for (x, y) in g.items():\n                if 2 * x == item:\n                    ans *= generating(y // 2)\n                else:\n                    ans *= modFact(y, mod)\n            yt = pow(2, n - 1, mod) * modFact(n - 1, mod) % mod\n            finall.append(modDivide(yt, ans, mod))\n        else:\n            finall.append(0)\nfor x in finall:\n    print(x)", "mod = pow(10, 9) + 7\nimport math\n\ndef modFact(n, p):\n    if n >= p:\n        return 0\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i % p\n    return result\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    if inv == -1:\n        print('Division not defined')\n    else:\n        return inv * a % m\n\ndef generating(n):\n    x = modFact(n, mod)\n    x = x * pow(2, n, mod)\n    return x % mod\nfinall = []\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    d = {}\n    candidate = []\n    mark = 0\n    for i in l:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n            if d[i] >= 2:\n                candidate.append(i)\n                mark += 1\n    if mark == 0:\n        finall.append(0)\n    else:\n        if 0 not in d:\n            d[0] = 2\n        else:\n            d[0] += 2\n        l.append(0)\n        l.append(0)\n        for i in candidate:\n            flag = 0\n            for x in l:\n                diff = i - x\n                if diff not in d:\n                    flag = 1\n                    break\n                elif d[diff] != d[x]:\n                    flag = 1\n                    break\n            if flag == 0:\n                break\n        if flag == 0:\n            item = i\n            g = {}\n            for i in l:\n                diff = item - i\n                if diff not in g:\n                    if i not in g:\n                        g[diff] = 1\n                else:\n                    g[diff] += 1\n            ans = 1\n            if 0 in g:\n                g[0] -= 2\n            if item in g:\n                g[item] -= 2\n            for (x, y) in g.items():\n                if 2 * x == item:\n                    ans *= generating(y // 2)\n                else:\n                    ans *= modFact(y, mod)\n            yt = pow(2, n - 1, mod) * modFact(n - 1, mod) % mod\n            finall.append(modDivide(yt, ans, mod))\n        else:\n            finall.append(0)\nfor x in finall:\n    print(x)", "import sys\nfrom collections import defaultdict\nMOD = 1000000007\n\ndef power(a, b):\n    ans = 1\n    while b > 0:\n        if b & 1:\n            ans = ans * a % MOD\n        b = b >> 1\n        a = a * a % MOD\n    return ans % MOD\nN = 100000\n\ndef giveFact():\n    facts = [0] * (N + 1)\n    facts[0] = 1\n    for i in range(1, N + 1):\n        facts[i] = facts[i - 1] % MOD * (i % MOD) % MOD\n    return facts\nfact = giveFact()\nt = int(sys.stdin.readline())\nfor testcase in range(t):\n    n = int(sys.stdin.readline())\n    res = 1\n    arr = [int(x) for x in sys.stdin.readline().split()]\n    m = defaultdict(int)\n    h = defaultdict(int)\n    s = set()\n    SUM = sum(arr)\n    for x in arr:\n        m[x] += 1\n        s.add(x)\n    prefix = SUM // (n + 1)\n    if m[prefix] < 2:\n        print('0')\n        continue\n    m[0] += 2\n    flag = False\n    for x in s:\n        if m[x] != m[prefix - x]:\n            flag = True\n            break\n    if flag:\n        print('0')\n        continue\n    if n == 1:\n        print('1')\n        continue\n    m[prefix] -= 2\n    m[0] -= 2\n    A = []\n    for i in range(len(arr)):\n        ele = arr[i]\n        if h[ele] == 1:\n            continue\n        if prefix % 2 == 0 and prefix == 2 * ele:\n            A.append(m[ele] // 2)\n        elif m[ele] > 1:\n            A.append(m[ele])\n        h[ele] = 1\n        h[prefix - ele] = 1\n    if prefix % 2 == 0:\n        res += m[prefix // 2] // 2\n    result = fact[n - 1] * pow(2, n - res) % MOD\n    for x in A:\n        result = result * power(fact[x], MOD - 2) % MOD\n    print(result)", "import math\nfrom sys import stdin, stdout\n\ndef modDivide(a, b, c):\n    m = 10 ** 9 + 7\n    a = a % m\n    a = a * c\n    inv = pow(b, m - 2, m)\n    c = 0\n    return inv * a % m\n\ndef coun(arr, t):\n    count = 0\n    t += 1\n    for i in range(len(arr)):\n        if arr[i][0] != arr[i][1]:\n            count += 1\n    t = 0\n    return count + t\n\ndef printPairs(arr, summ, t):\n    bigarr = []\n    t = 2\n    for i in range(len(arr) // 2):\n        k = []\n        if arr[i] + arr[-i - 1] == summ:\n            k.append(arr[i])\n            t += 1\n            k.append(arr[-i - 1])\n            k = tuple(k)\n            bigarr.append(k)\n    t += 1\n    return bigarr\n\ndef power(x, y, p, t):\n    res = 1\n    x = x % p\n    t = 1\n    while y > 0 and t == 1:\n        if y & 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    t = 1\n    return res * t\n\ndef countt(listOfTuple, t):\n    count_map = {}\n    k = []\n    t += 1\n    for i in listOfTuple:\n        count_map[i] = count_map.get(i, 0) + 1\n        k.append(count_map)\n    p = count_map.values()\n    t -= 1\n    return p\n\ndef modfact(n, p, l):\n    if n >= p:\n        l = 1\n        return 0\n    result = 1\n    l += 1\n    for i in range(1, n + 1):\n        result = result * i % p\n    l = 1\n    return result * l\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    maxx = sum(arr) // (n + 1)\n    flag = 1\n    t = 0\n    if len(arr) == 2:\n        flag = 0\n        t = 0\n        if arr[0] == arr[1] and t > -10:\n            print(1)\n        elif t > -9:\n            print(0)\n    if flag == 1 and t > -9:\n        if arr.count(maxx) < 2:\n            print(0)\n            t = 1\n            flag = 0\n        elif t > -10:\n            arr.remove(maxx)\n            arr.remove(maxx)\n            arr.sort()\n    if flag == 1:\n        arr1 = printPairs(arr, maxx, 1)\n        kk = len(arr1)\n        if kk < 1 or kk != n - 1:\n            print(0)\n            t += 1\n        elif t > -10:\n            arrdict = countt(arr1, 1)\n            arrlist = list(arrdict)\n            arrlist.sort(reverse=True)\n            powerf = coun(arr1, 1)\n            t += 1\n            twotothepowermod = power(2, powerf, 1000000007, 1)\n            if t > -5:\n                mod = (10 ** 9 + 7) * arrlist[0]\n                k = modfact(n - 1, mod, 1) // arrlist[0]\n                for i in range(1, arrlist[0]):\n                    k = modDivide(k, i, 1)\n                for i in range(1, len(arrlist)):\n                    for j in range(1, arrlist[i] + 1):\n                        k = modDivide(k, j, 1)\n                z = k * twotothepowermod % (10 ** 9 + 7)\n                t += 1\n                print(int(z))", "from math import factorial\nimport sys\niterations = int(sys.stdin.readline())\nfor given_tc in range(iterations):\n    input_size = int(sys.stdin.readline())\n    MY_list = list(map(int, sys.stdin.readline().split()))\n    temporary_variable = sum(MY_list)\n    temporary_variable = temporary_variable / (input_size + 1)\n    temporary_variable = int(temporary_variable)\n    cnt = MY_list.count(temporary_variable)\n    if cnt >= 2:\n        unordered_map = {}\n        MY_list.sort(reverse=False)\n        MY_list.remove(temporary_variable)\n        n = 2 * input_size - 2\n        condition = True\n        countering = 0\n        MY_list.remove(temporary_variable)\n        for gibrish in range(0, n // 2, 1):\n            if MY_list[gibrish] > MY_list[n - gibrish - 1]:\n                chefpsaup = MY_list[n - gibrish - 1]\n                chefpsadown = MY_list[gibrish]\n            else:\n                chefpsaup = MY_list[gibrish]\n                chefpsadown = MY_list[n - gibrish - 1]\n            if chefpsaup + chefpsadown == temporary_variable:\n                if chefpsaup != chefpsadown:\n                    countering += 1\n                elif chefpsaup == chefpsadown:\n                    pass\n                elif chefpsaup == 'a':\n                    pass\n                elif chefpsadown == 'b':\n                    pass\n                else:\n                    pass\n                if unordered_map.get((chefpsaup, chefpsadown)) != None:\n                    unordered_map[chefpsaup, chefpsadown] += 1\n                else:\n                    unordered_map[chefpsaup, chefpsadown] = 1\n            else:\n                condition = False\n                sys.stdout.write('0\\n')\n                break\n        verdict = factorial(input_size - 1) % 1000000007\n        if condition:\n            for iterator in unordered_map:\n                verdict = verdict * pow(factorial(unordered_map[iterator]), 1000000005, 1000000007)\n                verdict %= 1000000007\n            verdict = verdict * pow(2, countering, 1000000007)\n            verdict %= 1000000007\n            sys.stdout.write(str(verdict) + '\\n')\n    else:\n        sys.stdout.write('0\\n')", "from sys import stdin, stdout\n\ndef compute(a, facts, pow2, n, l, inv):\n    counts = {}\n    sum = 0\n    for i in a:\n        if i not in counts:\n            counts[i] = 1\n        else:\n            counts[i] += 1\n        sum += i\n    if abs(sum) % (n + 1) != 0:\n        return 0\n    sum //= n + 1\n    if sum not in counts:\n        return 0\n    v = counts[sum]\n    if v < 2:\n        return 0\n    counts[sum] = v - 2\n    repetitions = []\n    non_similar_pairs = 0\n    for (ai, count) in counts.items():\n        if count == 0:\n            continue\n        other = sum - ai\n        if ai == other:\n            if count % 2 == 1:\n                return 0\n            counts[ai] = 0\n            count //= 2\n            if count > 1:\n                repetitions.append(count)\n            continue\n        if other not in counts or counts[other] != count:\n            return 0\n        non_similar_pairs += count\n        counts[ai] = 0\n        counts[other] = 0\n        if count == 1:\n            continue\n        repetitions.append(count)\n    if n == 1:\n        return 1\n    ans = facts[n - 1]\n    for repc in repetitions:\n        val = power(inv, (facts[repc], limit - 2))\n        ans = ans * val % limit\n        if ans == 0:\n            return 0\n    return ans * pow2[non_similar_pairs] % limit\n\ndef power(inv, pr):\n    if pr in inv:\n        return inv[pr]\n    (x, y) = pr\n    if y == 0:\n        inv[pr] = 1\n        return 1\n    p = power(inv, (x, y // 2)) % limit\n    if p == 0:\n        inv[pr] = 0\n        return 0\n    p = p * p % limit\n    if y % 2 == 0:\n        inv[pr] = p\n        return p\n    p = x * p % limit\n    inv[pr] = p\n    return p\nlimit = 1000000007\nfacts = [1]\npow2 = [1]\ni = 1\nfp = 1\npp = 1\nwhile i < 100001:\n    fp = fp * i % limit\n    pp = pp * 2 % limit\n    facts.append(fp)\n    pow2.append(pp)\n    i += 1\ninv = {}\nt = int(input().strip())\ni = 0\nn = 0\nl = 0\nlines = []\nwhile i < t:\n    lines.append(input())\n    lines.append(input())\n    i += 1\ni = 0\nt <<= 1\nfor line in lines:\n    if i % 2 == 0:\n        n = int(line)\n        l = n + n\n        i += 1\n        continue\n    a = list(map(int, line.split()))\n    print(compute(a, facts, pow2, n, l, inv))\n    i += 1\n    if i == t:\n        break", "import sys\nimport math\ntotal_number_of_testcases = sys.stdin.readline()\ntotal_number_of_testcases = int(total_number_of_testcases)\nfor testcases in range(total_number_of_testcases):\n    my_dictionary = {}\n    new_number = sys.stdin.readline()\n    new_number = int(new_number)\n    my_list_old = [int(index) for index in sys.stdin.readline().split()]\n    sum_term = sum(my_list_old) // (new_number + 1)\n    if my_list_old.count(sum_term) < 2:\n        sys.stdout.write('0\\n')\n    else:\n        new_var = 0\n        my_list_old.sort()\n        check_var = True\n        my_list_old.remove(sum_term)\n        my_list_old.remove(sum_term)\n        numberr = new_number * 2 - 2\n        this_term = numberr // 2\n        for index_var in range(this_term):\n            first_num = min(my_list_old[numberr - index_var - 1], my_list_old[index_var])\n            second_num = max(my_list_old[index_var], my_list_old[numberr - index_var - 1])\n            if first_num + second_num != sum_term:\n                sys.stdout.write('0\\n')\n                check_var = False\n                break\n            else:\n                if first_num == second_num:\n                    pass\n                else:\n                    new_var = new_var + 1\n                if my_dictionary.get((first_num, second_num)) != None:\n                    my_dictionary[first_num, second_num] = my_dictionary[first_num, second_num] + 1\n                else:\n                    my_dictionary[first_num, second_num] = 1\n        new_num = new_number - 1\n        desired_result = math.factorial(new_num) % 1000000007\n        if check_var == False:\n            pass\n        else:\n            for index_var in my_dictionary.keys():\n                temporary = math.factorial(my_dictionary[index_var])\n                desired_result = pow(temporary, 1000000005, 1000000007) * desired_result % 1000000007\n            temporary = pow(2, new_var, 1000000007)\n            desired_result = temporary * desired_result % 1000000007\n            desired_result = str(desired_result)\n            sys.stdout.write(desired_result + '\\n')", "from sys import stdin, stdout\nmod = 1000000007\nfrom collections import defaultdict as dd\nt = stdin.readline()\nt = int(t)\nfact = [1]\nmul = 1\nfor i in range(1, 100002):\n    mul = mul * i % mod\n    fact.append(mul)\nfor _ in range(t):\n    n = stdin.readline()\n    n = int(n)\n    d = dd(int)\n    a = [int(x) for x in stdin.readline().split()]\n    s = 0\n    for i in a:\n        s += i\n        d[i] += 1\n    fs = s / (n + 1)\n    if d[fs] < 2:\n        print(0)\n    else:\n        flag = 0\n        d[fs] -= 2\n        nn = n - 1\n        ls = fact[n - 1]\n        nn -= d[fs / 2] // 2\n        m = 1\n        for i in a:\n            if d[i] != d[fs - i]:\n                flag = 1\n                break\n            else:\n                if i != fs - i:\n                    m *= fact[max(d[i], 1)]\n                    m %= mod\n                else:\n                    m *= fact[max(d[i] // 2, 1)]\n                    m %= mod\n                d[i] = d[fs - i] = 1\n        y = pow(m, mod - 2, mod)\n        ls *= y\n        ls %= mod\n        if flag == 1:\n            print(0)\n        else:\n            print(pow(2, nn, mod) * ls % mod)", "from collections import defaultdict\nimport sys\nmod = 10 ** 9 + 7\n(fact, ppo, ifact) = ([1], [1], [1])\nN = 10 ** 5 + 1\ninf = 10 ** 10\nfor i in range(1, N):\n    f = fact[-1] * i % mod\n    fact.append(f)\n    ff = (ppo[-1] << 1) % mod\n    ppo.append(ff)\n    f = pow(f, mod - 2, mod)\n    ifact.append(f)\nT = int(sys.stdin.readline())\nfor _ in range(T):\n    n = int(sys.stdin.readline().rstrip())\n    nn = n << 1\n    a = list(map(int, sys.stdin.readline().split()))\n    mp = defaultdict(int)\n    l = []\n    for x in a:\n        if mp[x] == 0:\n            l.append(x)\n        mp[x] += 1\n    if n == 1:\n        if l[0] == l[-1]:\n            sys.stdout.write('1\\n')\n        else:\n            sys.stdout.write('0\\n')\n        continue\n    l.sort()\n    ma = l[-1]\n    mi = l[0]\n    xx = 0\n    if mi >= 0 and ma > 0:\n        xx = ma\n    elif mi < 0 and ma <= 0:\n        xx = mi\n    else:\n        xx = mi + ma\n    if mp[xx] < 2:\n        sys.stdout.write('0\\n')\n        continue\n    mp[xx] -= 2\n    flg = 0\n    p = 0\n    n -= 1\n    d = defaultdict(int)\n    ans = fact[n]\n    la = []\n    for i in l:\n        i2 = xx - i\n        if mp[i] != mp[i2]:\n            flg = 1\n            break\n        q1 = mp[i]\n        node = (min(i, i2), max(i, i2))\n        if d[node] == 0:\n            d[node] = 1\n            if i != i2:\n                if q1 > 1:\n                    ans = ans * ifact[q1] % mod\n                p += q1\n            else:\n                if mp[i] & 1:\n                    flg = 1\n                    break\n                q = q1 >> 1\n                if q > 1:\n                    ans = ans * ifact[q] % mod\n    if flg:\n        sys.stdout.write('0\\n')\n        continue\n    ans = ans * ppo[p] % mod\n    sys.stdout.write(str(ans) + '\\n')", "from sys import stdin\nmod = int(1000000000.0) + 7\nfact = [1] * 100001\n\ndef generateFactorials():\n    for i in range(1, 100001):\n        fact[i] = i * fact[i - 1] % mod\ngenerateFactorials()\n\ndef isUnique(a, length, freq, target, n):\n    freq[target] -= 2\n    pairs = 0\n    elements = 2\n    mul = 0\n    deno = 1\n    num = fact[n - 1]\n    for i in range(length):\n        p1 = a[i]\n        p2 = target - a[i]\n        n1 = freq.get(p1)\n        n2 = freq.get(p2, 0)\n        if n1 > 0 and n2 > 0:\n            req = n1\n            if n1 != n2:\n                return 0\n            if p1 != p2:\n                mul = mul + req\n            else:\n                req = req // 2\n            elements += 2 * req\n            deno = deno * fact[req] % mod\n            freq[a[i]] = -1\n            freq[target - a[i]] = -1\n    if elements == 2 * n:\n        return pow(2, mul, mod) * (num * pow(deno, mod - 2, mod)) % mod % mod\n    else:\n        return 0\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    summ = sum(arr)\n    if n == 1:\n        if arr[0] == arr[1]:\n            print(1)\n        else:\n            print(0)\n        continue\n    elif n > 1:\n        check = [0]\n        if [0] == list(set(arr)):\n            print(1)\n            continue\n    freq = {}\n    for i in arr:\n        if freq.get(i, -1) == -1:\n            freq[i] = 0\n        freq[i] += 1\n    a = list(freq.keys())\n    length = len(a)\n    possible = []\n    for i in a:\n        if (n + 1) * i == summ and freq.get(i) >= 2:\n            possible.append(i)\n    answer = 0\n    if len(possible) == 0:\n        print(0)\n        continue\n    for i in possible:\n        answer = (answer + isUnique(a, length, freq, i, n)) % mod\n        freq[i] += 2\n    print(answer)", "import math\nd = math.factorial(10 ** 5)\nf = [-1 for mm in range(10 ** 5 + 1)]\nre = [-1 for mmm in range(10 ** 5 + 1)]\nf1 = [-1 for mmmm in range(10 ** 5 + 1)]\n\ndef myfac(n):\n    p = 1\n    for i in range(1, n + 1):\n        p = p * i % (10 ** 9 + 7)\n    return p\nU1 = [1, 500000004, 166666668, 41666667, 808333339, 301388891, 900198419, 487524805, 831947206, 283194722, 571199524, 380933296, 490841026, 320774361, 821384963, 738836565, 514049213, 639669405, 402087866, 120104394, 862862120, 130130097, 179570875, 799148792, 791965957, 761229465, 917082579, 282752951, 699405279, 123313510, 649139150, 957785605, 604781386, 958964165, 170256120, 671396008, 261389083, 243720767, 211377457, 230284438, 469031331, 654024560, 317535457, 393580354, 297635121, 202122504, 366002609, 861791727, 854322286, 57086446, 138374245, 98814890, 662241795, 956708188, 762849245, 960050886, 16842998, 379600744, 752196628, 279203279, 250478744, 971781922, 888440989, 92006891, 262953954, 367620517, 856233148, 659650492, 328400734, 261834298, 102279357, 626420551, 159266036, 785936033, 757145819, 470488764, 58058296, 590487931, 361904913, 517023815, 623666965, 775898383, 33444559, 512302915, 711909451, 833859418, 262458156, 412073391, 746203077, 108291146, 902288920, 444590100, 843490222, 455781814, 720587182, 986672790, 267903845, 992529638, 545379091, 875453797, 751242122, 732855320, 463425783, 917917562, 427789694, 494601793, 929856098, 360461633, 462022587, 631472937, 708391653, 979539218, 150261410, 966230370, 704054182, 781931507, 664802838, 73430533, 244314544, 735369293, 204424541, 157413317, 90710678, 403957347, 35231659, 341549460, 435760235, 26841877, 287029784, 832977158, 494908226, 18900820, 428713543, 234542640, 890626248, 477136961, 324650637, 415396022, 556945299, 311121040, 775256183, 97008847, 909769299, 860484515, 247313688, 97584341, 197942752, 622959077, 816261476, 218775078, 61051491, 388559552, 270513463, 930328016, 535034378, 939327150, 802161325, 87355452, 76021104, 300475134, 921120970, 141488402, 117432445, 836081911, 411127772, 279585109, 331015482, 251970332, 113916985, 971258342, 929656488, 889125916, 178549862, 909072132, 142337556, 23536009, 73579300, 595918989, 327351505, 474040845, 682177026, 267484491, 181789534, 164031466, 579265039, 169780996, 589143218, 907389066, 354007352, 970284256, 753771127, 915384231, 880390598, 520002017, 689846169, 600458403, 815230759, 706137534, 732191651, 538660962, 47456025, 599244836, 111326330, 657408467, 412962971, 375791085, 784424117, 527809735, 930755077, 237765502, 688330647, 526831752, 551769167, 745569020, 26723577, 264012611, 623336468, 599189621, 669402697, 589406380, 862395510, 571452236, 262652254, 206529699, 414251246, 621302001, 764851556, 933179180, 287917815, 979512693, 56188367, 340759435, 756827299, 7507809, 544712803, 794680992, 674239165, 82664871, 130052992, 267208556, 113141945, 12864223, 559723725, 842457890, 921805957, 885861006, 35975146, 40467642, 554379392, 778217523, 182383338, 405485651, 139942632, 890314741, 678001239, 811242198, 707436745, 425222626, 905116696, 126558142, 441097927, 852828624, 326436613, 232297110, 604650182, 671446058, 10005416, 522425397, 518670730, 38958040, 830402065, 800847072, 376559882, 110863358, 113130413, 279395402, 246496014, 986498194, 953356631, 314119133, 22470175, 961072596, 215410152, 155688065, 70721713, 297450078, 812883107, 541016959, 1872031, 644834046, 476442732, 755056316, 91314186, 326841207, 285853701, 396235995, 476081606, 270053967, 311939982, 581039804, 985319076, 135712978, 964144274, 904487323, 678375373, 515288812, 705261532, 807484621, 122354320, 419749533, 972410777, 211450036, 949557355, 18947635, 222282375, 48171780, 378700860, 623832397, 478444619, 510870143, 876980910, 810176965, 748638324, 113421724, 440348993, 863313960, 855851119, 438584915, 828080811, 720691159, 71663720, 48408626, 843989221, 837856261, 23396586, 696498209, 699396142, 558282241, 447074582, 748373754, 670816350, 949329879, 230172975, 253576086, 513778485, 518825953, 716192587, 608379868, 932975307, 856951364, 238908695, 952383270, 413462845, 749755550, 255633116, 371504590, 575270325, 736243777, 7621849, 202798951, 842667039, 502327813, 12403107, 546737375, 494648599, 151624724, 395508517, 384226928, 242233679, 35789821, 275029085, 239986639, 890723831, 812542048, 364833448, 745651158, 442296160, 329212426, 335960985, 66673582, 971303612, 458040065, 136966163, 279002518, 756568843, 351700958, 866541869, 396563255, 517728958, 965430081, 680218496, 838469951, 144627151, 576509210, 798927877, 640906388, 538138307, 199844570, 847618664, 622119051, 373122494, 767097325, 617288087, 395092300, 433074305, 67569149, 815890839, 568176207, 776450314, 850674275, 408395804, 136913583, 801784300, 794207214, 262154718, 34284026, 400561835, 433972639, 573828101, 184699592, 812790266, 404769648, 582517190, 392883298, 497395023, 656097176, 460552924, 608552698, 486267026, 331363414, 476406879, 202491684, 432338321, 344314146, 993894982, 649068571, 532377735, 925873015, 756095388, 83536581, 782502356, 467833719, 201958994, 113067476, 982276563, 417000623, 683259514, 595275137, 339855849, 540755239, 602085936, 629650637, 694546695, 783468170, 990732904, 300418276, 153830238, 781995268, 886235290, 762796169, 704474617, 834858176, 120593647, 291208178, 185572492, 867351020, 704212748, 633983365, 436319797, 679651749, 574691409, 884692149, 583265738, 954817023, 25168036, 437027667, 13494817, 926806481, 260807531, 473460019, 215121540, 398786562, 665421923, 247242609, 357210812, 375220601, 951489166, 260146496, 562904189, 803189606, 115688778, 402674167, 664102792, 62073083, 931438538, 989781133, 54305395, 845490579, 408508000, 817016, 770460718, 252530800, 193344993, 18240764, 451521272, 550299453, 675641621, 648967803, 128976362, 498292114, 586102337, 268722858, 813389329, 711699206, 345071263, 549118359, 498160774, 12544712, 899831499, 7499676, 159323417, 860458480, 925163407, 526574743, 431479193, 124394448, 736478932, 827152428, 468482333, 191449968, 570982019, 630772527, 6811956, 460686917, 587776989, 189529436, 618602480, 213045731, 31935150, 166725807, 46518902, 361709447, 728106284, 141044314, 106680816, 648547039, 81624401, 345039463, 428679492, 444415784, 871949944, 552304261, 263204892, 812749473, 93356306, 615275825, 658196191, 99745872, 808765204, 980015659, 506203240, 798053748, 875307384, 490913669, 395559142, 537801345, 254916759, 26857248, 323421544, 786532324, 111710215, 362083412, 98363148, 686582519, 232498406, 816375871, 302974657, 320593384, 541140925, 837139904, 84057040, 831759554, 589762885, 489023570, 342716282, 966455154, 672855976, 456926629, 511811424, 370359005, 435482844, 480465346, 749545478, 742002607, 688642026, 635383632, 287496457, 895129599, 639223927, 732732045, 883082755, 597812434, 281256739, 243843142, 932634458, 133552203, 978803223, 605228299, 76527469, 923076281, 353392926, 363322540, 770576388, 900277818, 11219964, 45472760, 708339507, 491437446, 743928014, 675393437, 584018351, 629556304, 639854830, 305512590, 408488823, 110876181, 497784495, 617034693, 851537422, 102938949, 385266150, 668331122, 814641919, 630622468, 978945869, 28268783, 357972167, 146329111, 973624935, 149958790, 433931296, 25598024, 447940280, 354732829, 764891064, 685394573, 585294277, 465409408, 469130064, 920721745, 182673921, 284022508, 597678446, 416816025, 588422624, 98457962, 240636924, 36839874, 300511140, 182273503, 581213731, 455560749, 864940520, 856724314, 261438685, 740632796, 674273817, 942626165, 174802133, 374887767, 194299387, 742848665, 907493095, 441999251, 492506669, 611675310, 290416066, 970929824, 883609623, 223358251, 807963821, 422005815, 659475855, 461490465, 664907290, 263359925, 173600234, 665950005, 716496304, 824226812, 899890349, 390028746, 771125588, 145203352, 452007490, 325362082, 146808268, 736600017, 245688986, 146065271, 957412368, 898799739, 278661168, 704941285, 610928999, 81601883, 483849511, 959722958, 846205539, 512459448, 477514011, 94771790, 785546670, 950680044, 61469483, 942823288, 676349828, 399270685, 202224300, 83614201, 27855221, 178708942, 736070142, 898806733, 147446631, 252269212, 554679879, 911476215, 87670064, 942585856, 185967971, 834953514, 366759830, 422843000, 170643325, 93981853, 572719111, 985870900, 598086433, 218375794, 859943833, 859649526, 91331965, 695015236, 607644320, 732718027, 917982226, 747216559, 979635810, 561306185, 34036360, 223449518, 94586255, 423202372, 442944642, 611697021, 200279654, 277309078, 618283679, 820550379, 353246455, 521460957, 68835467, 668938271, 630939793, 166620027, 751195077, 59571869, 663276431, 490471791, 292464946, 386389206, 728831039, 100424847, 231097324, 77617394, 253639149, 723976405, 560621283, 219949516, 322944880, 693507607, 78791198, 119998459, 265121019, 385833490, 175839688, 127126701, 357575575, 462477947, 523972795, 85257542, 474256318, 882209397, 465260644, 945308123, 444097002, 744917420, 375150087, 199218939, 962795536, 153320195, 574288074, 366385933, 970641480, 460261345, 165378268, 54660122, 796112070, 75056929, 684432874, 318576890, 508386937, 736496795, 933419021, 301388996, 795962538, 981413164, 518902828, 825023058, 764707707, 274652931, 632168477, 715573025, 516018880, 296024238, 427201967, 100757491, 425935778, 453525227, 714143838, 325377579, 154052075, 164453301, 661274799, 281891479, 854578132, 707463702, 54478503, 560779145, 542878457, 842687510, 21165703, 595996646, 257510057, 793448599, 603061927, 924060221, 392136705, 100461338, 471328395, 891398279, 205030949, 652464912, 835850842, 87425060, 823905986, 380913646, 278673941, 927068232, 520240501, 876473603, 136589194, 511732167, 687296805, 683241687, 350269024, 968145478, 892943787, 218267753, 631708693, 575265725, 844874308, 490669196, 539989340, 283721451, 422216333, 634877244, 154305891, 30857166, 70409600, 192823595, 593649861, 218997343, 408157062, 510618691, 46798894, 349151803, 787794327, 112121118, 212247051, 734542883, 558493333, 135971470, 553224553, 555304942, 877988083, 353984399, 287379295, 128097089, 213238733, 686489183, 584370424, 478522537, 386164116, 728903056, 854166382, 496535429, 200766267, 471649197, 622910706, 125683017, 956326056, 20739963, 301662013, 197927580, 561829805, 470110929, 409651919, 25445274, 530972257, 693634465, 812235796, 433779479, 246955439, 273484835, 533196859, 434841810, 150091327, 794785050, 966482053, 130865325, 820075960, 424860898, 894572050, 601383094, 45465724, 85336318, 672082365, 48587322, 356055887, 859189025, 162098823, 439790362, 893587086, 428005909, 694221764, 21829348, 71677376, 928496509, 456286540, 290395261, 680262749, 924193154, 292067220, 171853628, 296940288, 150623112, 455840069, 180683168, 811842548, 508120422, 642272196, 544234726, 650304911, 229451663, 921643700, 798472778, 749018037, 226545381, 765423842, 718894474, 717080061, 749196186, 489999179, 806854513, 378512648, 701818525, 88561613, 592947516, 719258871, 280773178, 426531817, 513644853, 265496088, 511425456, 854621511, 704306302, 284837521, 431600849, 280960245, 932742910, 291976581, 677356118, 77062670, 110519140, 832608350, 207247104, 180387636]\nser = ''\nfor yt in range(1000, 10 ** 5 + 1):\n    U1.append(-1)\n\ndef fac_inv(n):\n    if U1[n - 1] != -1:\n        return U1[n - 1]\n    elif f1[n] != -1:\n        p = f1[n]\n    else:\n        p = math.factorial(n)\n        f1[n] = p\n    k = pow(p, 10 ** 9 + 5, 10 ** 9 + 7)\n    U1[n - 1] = k\n    return k\nt = int(input())\nwaste = 0\nwhile waste < t:\n    ser += ' '\n    n = int(input())\n    var = list(map(int, input().split()))\n    totsum = sum(var)\n    if totsum % (n + 1) != 0:\n        ser += str(0)\n        waste += 1\n        continue\n    s1 = totsum // (n + 1)\n    if var.count(s1) < 2:\n        ser += str(0)\n        waste += 1\n        continue\n    var.remove(s1)\n    var.remove(s1)\n    var.sort()\n    count = 0\n    (i_, i) = (0, 0)\n    while i < n - 1:\n        a = var[i]\n        b = var[-i - 1]\n        if a == b and a == s1 // 2:\n            count += 1\n        elif a + b != s1:\n            i_ += 1\n            break\n        i += 1\n    if i_ != 0:\n        ser += str(0)\n        waste += 1\n        continue\n    if n == 1:\n        ser += str(1)\n        waste += 1\n        continue\n    k1 = tuple(var[:n - 1])\n    dictOf = dict()\n    for elem in k1:\n        if elem in dictOf:\n            dictOf[elem] += 1\n        else:\n            dictOf[elem] = 1\n    rep1 = map(lambda x: fac_inv(x), dictOf.values())\n    if f[n - 1] != -1:\n        num = f[n - 1]\n    else:\n        num = myfac(n - 1)\n        f[n - 1] = num\n    if re[n - 1 - count] != -1:\n        num *= re[n - 1 - count]\n    else:\n        der = n - 1 - count\n        ty = pow(2, der, 10 ** 9 + 7)\n        num = ty * num % (10 ** 9 + 7)\n        re[der] = ty\n    for q in rep1:\n        num = num * q % (10 ** 9 + 7)\n    ser += str(num % (10 ** 9 + 7))\n    waste += 1\nd = ser.split()\nfor u in d:\n    print(int(u))", "from collections import defaultdict as dc\nfrom sys import stdin\ninput = stdin.readline\nmod = 10 ** 9 + 7\nfac = [1]\nfor i in range(1, 10 ** 5 + 5):\n    fac.append(fac[-1] * i % mod)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = dc(int)\n    for i in a:\n        d[i] += 1\n    s = sum(a) // (n + 1)\n    if d[s] < 2:\n        print(0)\n        continue\n    d[s] -= 2\n    v = []\n    (cnt, ans) = (0, 0)\n    bad = False\n    for i in d:\n        if d[i] == 0:\n            continue\n        if d[s - i] != d[i]:\n            bad = True\n            break\n        if i == s - i and d[i] % 2 == 0:\n            v.append(d[i] // 2)\n            d[i] = 0\n        elif i == s - i and d[i] % 2 == 1:\n            bad = True\n            break\n        else:\n            v.append(d[i])\n            d[i] = d[s - i] = 0\n            cnt += v[-1]\n    if bad:\n        print(0)\n        continue\n    ans = fac[n - 1] * int(pow(2, cnt, mod)) % mod\n    for i in v:\n        ans = ans * int(pow(fac[i], mod - 2, mod)) % mod\n    print(ans)", "N = 100001\np = 1000000007\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\nnaturalNumInverse[0] = naturalNumInverse[1] = 1\nfor i in range(2, N + 1, 1):\n    naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\nfactorialNumInverse[0] = factorialNumInverse[1] = 1\nfor i in range(2, N + 1, 1):\n    factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\nfact[0] = 1\nfor i in range(1, N + 1):\n    fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\nfrom collections import defaultdict\nfrom sys import stdin, stdout\nfor _ in range(int(input())):\n    N = int(stdin.readline())\n    A = [int(x) for x in stdin.readline().split()]\n    s = sum(A)\n    if s // (N + 1) == s / (N + 1):\n        s = s // (N + 1)\n    else:\n        stdout.write(str('0'))\n        stdout.write('\\n')\n        continue\n    try:\n        A.remove(s)\n        A.remove(s)\n    except:\n        stdout.write(str('0'))\n        stdout.write('\\n')\n        continue\n    pcount = defaultdict(int)\n    problem = False\n    A.sort()\n    for i in range(N - 1):\n        f = A[i]\n        f2 = A.pop()\n        if f + f2 == s:\n            pcount[f, f2] += 1\n        else:\n            problem = True\n            break\n    if problem == True:\n        stdout.write(str('0'))\n        stdout.write('\\n')\n        continue\n    boxtofill = N - 1\n    Answer = 1\n    if s % 2 == 0:\n        common = pcount[s // 2, s // 2]\n        Answer = Answer * Binomial(boxtofill, common, p)\n        boxtofill -= common\n        pcount.pop((s // 2, s // 2), None)\n    ftable = map(lambda x: factorialNumInverse[x], list(pcount.values()))\n    Answer = Answer * fact[boxtofill] % p\n    for i in ftable:\n        Answer = Answer * i % p\n    Answer = Answer * pow(2, boxtofill, p) % p\n    stdout.write(str(Answer))\n    stdout.write('\\n')", "N = 100001\np = 1000000007\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\nnaturalNumInverse[0] = naturalNumInverse[1] = 1\nfor i in range(2, N + 1, 1):\n    naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\nfactorialNumInverse[0] = factorialNumInverse[1] = 1\nfor i in range(2, N + 1, 1):\n    factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\nfact[0] = 1\nfor i in range(1, N + 1):\n    fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\nfrom collections import defaultdict\nfrom sys import stdin, stdout\nfor _ in range(int(input())):\n    N = int(stdin.readline())\n    A = [int(x) for x in stdin.readline().split()]\n    s = sum(A)\n    if s // (N + 1) == s / (N + 1):\n        s = s // (N + 1)\n    else:\n        stdout.write(str(0))\n        stdout.write('\\n')\n        continue\n    try:\n        A.remove(s)\n        A.remove(s)\n    except:\n        stdout.write(str(0))\n        stdout.write('\\n')\n        continue\n    ftable = []\n    problem = False\n    A.sort()\n    N = N - 1\n    for i in range(N - 1):\n        if A[i] + A[2 * N - 1 - i] != s:\n            problem = True\n            break\n    if problem == True:\n        stdout.write(str(0))\n        stdout.write('\\n')\n        continue\n    i = 0\n    while i <= N - 1:\n        f = A[i]\n        c = 1\n        while i + 1 <= N - 1 and A[i + 1] == A[i]:\n            c = c + 1\n            i = i + 1\n        ftable.append(c)\n        i = i + 1\n    boxtofill = N\n    Answer = 1\n    if s % 2 == 0 and len(ftable) != 0 and (A[N - 1] == s // 2):\n        common = ftable.pop()\n        Answer = Answer * Binomial(boxtofill, common, p)\n        boxtofill -= common\n    ftable = map(lambda x: factorialNumInverse[x], ftable)\n    Answer = Answer * fact[boxtofill] % p\n    for i in ftable:\n        Answer = Answer * i % p\n    Answer = Answer * pow(2, boxtofill, p) % p\n    stdout.write(str(Answer))\n    stdout.write('\\n')", "import math\nd = math.factorial(10 ** 5)\nf = [-1 for mm in range(10 ** 5 + 1)]\nre = [-1 for mmm in range(10 ** 5 + 1)]\nf1 = [-1 for mmmm in range(10 ** 5 + 1)]\n\ndef myfac(n):\n    p = 1\n    for i in range(1, n + 1):\n        p = p * i % (10 ** 9 + 7)\n    return p\nU1 = [1, 500000004, 166666668, 41666667, 808333339, 301388891, 900198419, 487524805, 831947206, 283194722, 571199524, 380933296, 490841026, 320774361, 821384963, 738836565, 514049213, 639669405, 402087866, 120104394, 862862120, 130130097, 179570875, 799148792, 791965957, 761229465, 917082579, 282752951, 699405279, 123313510, 649139150, 957785605, 604781386, 958964165, 170256120, 671396008, 261389083, 243720767, 211377457, 230284438, 469031331, 654024560, 317535457, 393580354, 297635121, 202122504, 366002609, 861791727, 854322286, 57086446, 138374245, 98814890, 662241795, 956708188, 762849245, 960050886, 16842998, 379600744, 752196628, 279203279, 250478744, 971781922, 888440989, 92006891, 262953954, 367620517, 856233148, 659650492, 328400734, 261834298, 102279357, 626420551, 159266036, 785936033, 757145819, 470488764, 58058296, 590487931, 361904913, 517023815, 623666965, 775898383, 33444559, 512302915, 711909451, 833859418, 262458156, 412073391, 746203077, 108291146, 902288920, 444590100, 843490222, 455781814, 720587182, 986672790, 267903845, 992529638, 545379091, 875453797, 751242122, 732855320, 463425783, 917917562, 427789694, 494601793, 929856098, 360461633, 462022587, 631472937, 708391653, 979539218, 150261410, 966230370, 704054182, 781931507, 664802838, 73430533, 244314544, 735369293, 204424541, 157413317, 90710678, 403957347, 35231659, 341549460, 435760235, 26841877, 287029784, 832977158, 494908226, 18900820, 428713543, 234542640, 890626248, 477136961, 324650637, 415396022, 556945299, 311121040, 775256183, 97008847, 909769299, 860484515, 247313688, 97584341, 197942752, 622959077, 816261476, 218775078, 61051491, 388559552, 270513463, 930328016, 535034378, 939327150, 802161325, 87355452, 76021104, 300475134, 921120970, 141488402, 117432445, 836081911, 411127772, 279585109, 331015482, 251970332, 113916985, 971258342, 929656488, 889125916, 178549862, 909072132, 142337556, 23536009, 73579300, 595918989, 327351505, 474040845, 682177026, 267484491, 181789534, 164031466, 579265039, 169780996, 589143218, 907389066, 354007352, 970284256, 753771127, 915384231, 880390598, 520002017, 689846169, 600458403, 815230759, 706137534, 732191651, 538660962, 47456025, 599244836, 111326330, 657408467, 412962971, 375791085, 784424117, 527809735, 930755077, 237765502, 688330647, 526831752, 551769167, 745569020, 26723577, 264012611, 623336468, 599189621, 669402697, 589406380, 862395510, 571452236, 262652254, 206529699, 414251246, 621302001, 764851556, 933179180, 287917815, 979512693, 56188367, 340759435, 756827299, 7507809, 544712803, 794680992, 674239165, 82664871, 130052992, 267208556, 113141945, 12864223, 559723725, 842457890, 921805957, 885861006, 35975146, 40467642, 554379392, 778217523, 182383338, 405485651, 139942632, 890314741, 678001239, 811242198, 707436745, 425222626, 905116696, 126558142, 441097927, 852828624, 326436613, 232297110, 604650182, 671446058, 10005416, 522425397, 518670730, 38958040, 830402065, 800847072, 376559882, 110863358, 113130413, 279395402, 246496014, 986498194, 953356631, 314119133, 22470175, 961072596, 215410152, 155688065, 70721713, 297450078, 812883107, 541016959, 1872031, 644834046, 476442732, 755056316, 91314186, 326841207, 285853701, 396235995, 476081606, 270053967, 311939982, 581039804, 985319076, 135712978, 964144274, 904487323, 678375373, 515288812, 705261532, 807484621, 122354320, 419749533, 972410777, 211450036, 949557355, 18947635, 222282375, 48171780, 378700860, 623832397, 478444619, 510870143, 876980910, 810176965, 748638324, 113421724, 440348993, 863313960, 855851119, 438584915, 828080811, 720691159, 71663720, 48408626, 843989221, 837856261, 23396586, 696498209, 699396142, 558282241, 447074582, 748373754, 670816350, 949329879, 230172975, 253576086, 513778485, 518825953, 716192587, 608379868, 932975307, 856951364, 238908695, 952383270, 413462845, 749755550, 255633116, 371504590, 575270325, 736243777, 7621849, 202798951, 842667039, 502327813, 12403107, 546737375, 494648599, 151624724, 395508517, 384226928, 242233679, 35789821, 275029085, 239986639, 890723831, 812542048, 364833448, 745651158, 442296160, 329212426, 335960985, 66673582, 971303612, 458040065, 136966163, 279002518, 756568843, 351700958, 866541869, 396563255, 517728958, 965430081, 680218496, 838469951, 144627151, 576509210, 798927877, 640906388, 538138307, 199844570, 847618664, 622119051, 373122494, 767097325, 617288087, 395092300, 433074305, 67569149, 815890839, 568176207, 776450314, 850674275, 408395804, 136913583, 801784300, 794207214, 262154718, 34284026, 400561835, 433972639, 573828101, 184699592, 812790266, 404769648, 582517190, 392883298, 497395023, 656097176, 460552924, 608552698, 486267026, 331363414, 476406879, 202491684, 432338321, 344314146, 993894982, 649068571, 532377735, 925873015, 756095388, 83536581, 782502356, 467833719, 201958994, 113067476, 982276563, 417000623, 683259514, 595275137, 339855849, 540755239, 602085936, 629650637, 694546695, 783468170, 990732904, 300418276, 153830238, 781995268, 886235290, 762796169, 704474617, 834858176, 120593647, 291208178, 185572492, 867351020, 704212748, 633983365, 436319797, 679651749, 574691409, 884692149, 583265738, 954817023, 25168036, 437027667, 13494817, 926806481, 260807531, 473460019, 215121540, 398786562, 665421923, 247242609, 357210812, 375220601, 951489166, 260146496, 562904189, 803189606, 115688778, 402674167, 664102792, 62073083, 931438538, 989781133, 54305395, 845490579, 408508000, 817016, 770460718, 252530800, 193344993, 18240764, 451521272, 550299453, 675641621, 648967803, 128976362, 498292114, 586102337, 268722858, 813389329, 711699206, 345071263, 549118359, 498160774, 12544712, 899831499, 7499676, 159323417, 860458480, 925163407, 526574743, 431479193, 124394448, 736478932, 827152428, 468482333, 191449968, 570982019, 630772527, 6811956, 460686917, 587776989, 189529436, 618602480, 213045731, 31935150, 166725807, 46518902, 361709447, 728106284, 141044314, 106680816, 648547039, 81624401, 345039463, 428679492, 444415784, 871949944, 552304261, 263204892, 812749473, 93356306, 615275825, 658196191, 99745872, 808765204, 980015659, 506203240, 798053748, 875307384, 490913669, 395559142, 537801345, 254916759, 26857248, 323421544, 786532324, 111710215, 362083412, 98363148, 686582519, 232498406, 816375871, 302974657, 320593384, 541140925, 837139904, 84057040, 831759554, 589762885, 489023570, 342716282, 966455154, 672855976, 456926629, 511811424, 370359005, 435482844, 480465346, 749545478, 742002607, 688642026, 635383632, 287496457, 895129599, 639223927, 732732045, 883082755, 597812434, 281256739, 243843142, 932634458, 133552203, 978803223, 605228299, 76527469, 923076281, 353392926, 363322540, 770576388, 900277818, 11219964, 45472760, 708339507, 491437446, 743928014, 675393437, 584018351, 629556304, 639854830, 305512590, 408488823, 110876181, 497784495, 617034693, 851537422, 102938949, 385266150, 668331122, 814641919, 630622468, 978945869, 28268783, 357972167, 146329111, 973624935, 149958790, 433931296, 25598024, 447940280, 354732829, 764891064, 685394573, 585294277, 465409408, 469130064, 920721745, 182673921, 284022508, 597678446, 416816025, 588422624, 98457962, 240636924, 36839874, 300511140, 182273503, 581213731, 455560749, 864940520, 856724314, 261438685, 740632796, 674273817, 942626165, 174802133, 374887767, 194299387, 742848665, 907493095, 441999251, 492506669, 611675310, 290416066, 970929824, 883609623, 223358251, 807963821, 422005815, 659475855, 461490465, 664907290, 263359925, 173600234, 665950005, 716496304, 824226812, 899890349, 390028746, 771125588, 145203352, 452007490, 325362082, 146808268, 736600017, 245688986, 146065271, 957412368, 898799739, 278661168, 704941285, 610928999, 81601883, 483849511, 959722958, 846205539, 512459448, 477514011, 94771790, 785546670, 950680044, 61469483, 942823288, 676349828, 399270685, 202224300, 83614201, 27855221, 178708942, 736070142, 898806733, 147446631, 252269212, 554679879, 911476215, 87670064, 942585856, 185967971, 834953514, 366759830, 422843000, 170643325, 93981853, 572719111, 985870900, 598086433, 218375794, 859943833, 859649526, 91331965, 695015236, 607644320, 732718027, 917982226, 747216559, 979635810, 561306185, 34036360, 223449518, 94586255, 423202372, 442944642, 611697021, 200279654, 277309078, 618283679, 820550379, 353246455, 521460957, 68835467, 668938271, 630939793, 166620027, 751195077, 59571869, 663276431, 490471791, 292464946, 386389206, 728831039, 100424847, 231097324, 77617394, 253639149, 723976405, 560621283, 219949516, 322944880, 693507607, 78791198, 119998459, 265121019, 385833490, 175839688, 127126701, 357575575, 462477947, 523972795, 85257542, 474256318, 882209397, 465260644, 945308123, 444097002, 744917420, 375150087, 199218939, 962795536, 153320195, 574288074, 366385933, 970641480, 460261345, 165378268, 54660122, 796112070, 75056929, 684432874, 318576890, 508386937, 736496795, 933419021, 301388996, 795962538, 981413164, 518902828, 825023058, 764707707, 274652931, 632168477, 715573025, 516018880, 296024238, 427201967, 100757491, 425935778, 453525227, 714143838, 325377579, 154052075, 164453301, 661274799, 281891479, 854578132, 707463702, 54478503, 560779145, 542878457, 842687510, 21165703, 595996646, 257510057, 793448599, 603061927, 924060221, 392136705, 100461338, 471328395, 891398279, 205030949, 652464912, 835850842, 87425060, 823905986, 380913646, 278673941, 927068232, 520240501, 876473603, 136589194, 511732167, 687296805, 683241687, 350269024, 968145478, 892943787, 218267753, 631708693, 575265725, 844874308, 490669196, 539989340, 283721451, 422216333, 634877244, 154305891, 30857166, 70409600, 192823595, 593649861, 218997343, 408157062, 510618691, 46798894, 349151803, 787794327, 112121118, 212247051, 734542883, 558493333, 135971470, 553224553, 555304942, 877988083, 353984399, 287379295, 128097089, 213238733, 686489183, 584370424, 478522537, 386164116, 728903056, 854166382, 496535429, 200766267, 471649197, 622910706, 125683017, 956326056, 20739963, 301662013, 197927580, 561829805, 470110929, 409651919, 25445274, 530972257, 693634465, 812235796, 433779479, 246955439, 273484835, 533196859, 434841810, 150091327, 794785050, 966482053, 130865325, 820075960, 424860898, 894572050, 601383094, 45465724, 85336318, 672082365, 48587322, 356055887, 859189025, 162098823, 439790362, 893587086, 428005909, 694221764, 21829348, 71677376, 928496509, 456286540, 290395261, 680262749, 924193154, 292067220, 171853628, 296940288, 150623112, 455840069, 180683168, 811842548, 508120422, 642272196, 544234726, 650304911, 229451663, 921643700, 798472778, 749018037, 226545381, 765423842, 718894474, 717080061, 749196186, 489999179, 806854513, 378512648, 701818525, 88561613, 592947516, 719258871, 280773178, 426531817, 513644853, 265496088, 511425456, 854621511, 704306302, 284837521, 431600849, 280960245, 932742910, 291976581, 677356118, 77062670, 110519140, 832608350, 207247104, 180387636]\nser = ''\nfor yt in range(1000, 10 ** 5 + 1):\n    U1.append(-1)\n\ndef facinv(n):\n    if U1[n - 1] != -1:\n        return U1[n - 1]\n    elif f1[n] != -1:\n        p = f1[n]\n    else:\n        p = math.factorial(n)\n        f1[n] = p\n    k = pow(p, 10 ** 9 + 5, 10 ** 9 + 7)\n    U1[n - 1] = k\n    return k\nt = int(input())\nfor t_case in range(t):\n    ser += ' '\n    n = int(input())\n    var = list(map(int, input().split()))\n    totsum = sum(var)\n    if totsum % (n + 1) != 0:\n        ser += str(0)\n        continue\n    s1 = totsum // (n + 1)\n    if var.count(s1) < 2:\n        ser += str(0)\n        continue\n    var.remove(s1)\n    var.remove(s1)\n    var.sort()\n    count = 0\n    i0 = 0\n    for i in range(n - 1):\n        a = var[i]\n        b = var[-i - 1]\n        if a == b and a == s1 // 2:\n            count += 1\n        elif a + b != s1:\n            i0 += 1\n            break\n    if i0 != 0:\n        ser += str(0)\n        continue\n    if n == 1:\n        ser += str(1)\n        continue\n    k1 = tuple(var[:n - 1])\n    dictOf = dict()\n    for elem in k1:\n        if elem in dictOf:\n            dictOf[elem] += 1\n        else:\n            dictOf[elem] = 1\n    rep1 = map(lambda x: facinv(x), dictOf.values())\n    if f[n - 1] != -1:\n        num = f[n - 1]\n    else:\n        num = myfac(n - 1)\n        f[n - 1] = num\n    if re[n - 1 - count] != -1:\n        num *= re[n - 1 - count]\n    else:\n        der = n - 1 - count\n        ty = pow(2, der, 10 ** 9 + 7)\n        num = ty * num % (10 ** 9 + 7)\n        re[der] = ty\n    for q in rep1:\n        num = num * q % (10 ** 9 + 7)\n    ser += str(num % (10 ** 9 + 7))\nd = ser.split()\nfor u in d:\n    print(int(u))", "import math\nd = math.factorial(10 ** 5)\nf = [-1 for mm in range(10 ** 5 + 1)]\nre = [-1 for mmm in range(10 ** 5 + 1)]\nf1 = [-1 for mmmm in range(10 ** 5 + 1)]\n\ndef myfac(n):\n    p = 1\n    for i in range(1, n + 1):\n        p = p * i % (10 ** 9 + 7)\n    return p\nU1 = [1, 500000004, 166666668, 41666667, 808333339, 301388891, 900198419, 487524805, 831947206, 283194722, 571199524, 380933296, 490841026, 320774361, 821384963, 738836565, 514049213, 639669405, 402087866, 120104394, 862862120, 130130097, 179570875, 799148792, 791965957, 761229465, 917082579, 282752951, 699405279, 123313510, 649139150, 957785605, 604781386, 958964165, 170256120, 671396008, 261389083, 243720767, 211377457, 230284438, 469031331, 654024560, 317535457, 393580354, 297635121, 202122504, 366002609, 861791727, 854322286, 57086446, 138374245, 98814890, 662241795, 956708188, 762849245, 960050886, 16842998, 379600744, 752196628, 279203279, 250478744, 971781922, 888440989, 92006891, 262953954, 367620517, 856233148, 659650492, 328400734, 261834298, 102279357, 626420551, 159266036, 785936033, 757145819, 470488764, 58058296, 590487931, 361904913, 517023815, 623666965, 775898383, 33444559, 512302915, 711909451, 833859418, 262458156, 412073391, 746203077, 108291146, 902288920, 444590100, 843490222, 455781814, 720587182, 986672790, 267903845, 992529638, 545379091, 875453797, 751242122, 732855320, 463425783, 917917562, 427789694, 494601793, 929856098, 360461633, 462022587, 631472937, 708391653, 979539218, 150261410, 966230370, 704054182, 781931507, 664802838, 73430533, 244314544, 735369293, 204424541, 157413317, 90710678, 403957347, 35231659, 341549460, 435760235, 26841877, 287029784, 832977158, 494908226, 18900820, 428713543, 234542640, 890626248, 477136961, 324650637, 415396022, 556945299, 311121040, 775256183, 97008847, 909769299, 860484515, 247313688, 97584341, 197942752, 622959077, 816261476, 218775078, 61051491, 388559552, 270513463, 930328016, 535034378, 939327150, 802161325, 87355452, 76021104, 300475134, 921120970, 141488402, 117432445, 836081911, 411127772, 279585109, 331015482, 251970332, 113916985, 971258342, 929656488, 889125916, 178549862, 909072132, 142337556, 23536009, 73579300, 595918989, 327351505, 474040845, 682177026, 267484491, 181789534, 164031466, 579265039, 169780996, 589143218, 907389066, 354007352, 970284256, 753771127, 915384231, 880390598, 520002017, 689846169, 600458403, 815230759, 706137534, 732191651, 538660962, 47456025, 599244836, 111326330, 657408467, 412962971, 375791085, 784424117, 527809735, 930755077, 237765502, 688330647, 526831752, 551769167, 745569020, 26723577, 264012611, 623336468, 599189621, 669402697, 589406380, 862395510, 571452236, 262652254, 206529699, 414251246, 621302001, 764851556, 933179180, 287917815, 979512693, 56188367, 340759435, 756827299, 7507809, 544712803, 794680992, 674239165, 82664871, 130052992, 267208556, 113141945, 12864223, 559723725, 842457890, 921805957, 885861006, 35975146, 40467642, 554379392, 778217523, 182383338, 405485651, 139942632, 890314741, 678001239, 811242198, 707436745, 425222626, 905116696, 126558142, 441097927, 852828624, 326436613, 232297110, 604650182, 671446058, 10005416, 522425397, 518670730, 38958040, 830402065, 800847072, 376559882, 110863358, 113130413, 279395402, 246496014, 986498194, 953356631, 314119133, 22470175, 961072596, 215410152, 155688065, 70721713, 297450078, 812883107, 541016959, 1872031, 644834046, 476442732, 755056316, 91314186, 326841207, 285853701, 396235995, 476081606, 270053967, 311939982, 581039804, 985319076, 135712978, 964144274, 904487323, 678375373, 515288812, 705261532, 807484621, 122354320, 419749533, 972410777, 211450036, 949557355, 18947635, 222282375, 48171780, 378700860, 623832397, 478444619, 510870143, 876980910, 810176965, 748638324, 113421724, 440348993, 863313960, 855851119, 438584915, 828080811, 720691159, 71663720, 48408626, 843989221, 837856261, 23396586, 696498209, 699396142, 558282241, 447074582, 748373754, 670816350, 949329879, 230172975, 253576086, 513778485, 518825953, 716192587, 608379868, 932975307, 856951364, 238908695, 952383270, 413462845, 749755550, 255633116, 371504590, 575270325, 736243777, 7621849, 202798951, 842667039, 502327813, 12403107, 546737375, 494648599, 151624724, 395508517, 384226928, 242233679, 35789821, 275029085, 239986639, 890723831, 812542048, 364833448, 745651158, 442296160, 329212426, 335960985, 66673582, 971303612, 458040065, 136966163, 279002518, 756568843, 351700958, 866541869, 396563255, 517728958, 965430081, 680218496, 838469951, 144627151, 576509210, 798927877, 640906388, 538138307, 199844570, 847618664, 622119051, 373122494, 767097325, 617288087, 395092300, 433074305, 67569149, 815890839, 568176207, 776450314, 850674275, 408395804, 136913583, 801784300, 794207214, 262154718, 34284026, 400561835, 433972639, 573828101, 184699592, 812790266, 404769648, 582517190, 392883298, 497395023, 656097176, 460552924, 608552698, 486267026, 331363414, 476406879, 202491684, 432338321, 344314146, 993894982, 649068571, 532377735, 925873015, 756095388, 83536581, 782502356, 467833719, 201958994, 113067476, 982276563, 417000623, 683259514, 595275137, 339855849, 540755239, 602085936, 629650637, 694546695, 783468170, 990732904, 300418276, 153830238, 781995268, 886235290, 762796169, 704474617, 834858176, 120593647, 291208178, 185572492, 867351020, 704212748, 633983365, 436319797, 679651749, 574691409, 884692149, 583265738, 954817023, 25168036, 437027667, 13494817, 926806481, 260807531, 473460019, 215121540, 398786562, 665421923, 247242609, 357210812, 375220601, 951489166, 260146496, 562904189, 803189606, 115688778, 402674167, 664102792, 62073083, 931438538, 989781133, 54305395, 845490579, 408508000, 817016, 770460718, 252530800, 193344993, 18240764, 451521272, 550299453, 675641621, 648967803, 128976362, 498292114, 586102337, 268722858, 813389329, 711699206, 345071263, 549118359, 498160774, 12544712, 899831499, 7499676, 159323417, 860458480, 925163407, 526574743, 431479193, 124394448, 736478932, 827152428, 468482333, 191449968, 570982019, 630772527, 6811956, 460686917, 587776989, 189529436, 618602480, 213045731, 31935150, 166725807, 46518902, 361709447, 728106284, 141044314, 106680816, 648547039, 81624401, 345039463, 428679492, 444415784, 871949944, 552304261, 263204892, 812749473, 93356306, 615275825, 658196191, 99745872, 808765204, 980015659, 506203240, 798053748, 875307384, 490913669, 395559142, 537801345, 254916759, 26857248, 323421544, 786532324, 111710215, 362083412, 98363148, 686582519, 232498406, 816375871, 302974657, 320593384, 541140925, 837139904, 84057040, 831759554, 589762885, 489023570, 342716282, 966455154, 672855976, 456926629, 511811424, 370359005, 435482844, 480465346, 749545478, 742002607, 688642026, 635383632, 287496457, 895129599, 639223927, 732732045, 883082755, 597812434, 281256739, 243843142, 932634458, 133552203, 978803223, 605228299, 76527469, 923076281, 353392926, 363322540, 770576388, 900277818, 11219964, 45472760, 708339507, 491437446, 743928014, 675393437, 584018351, 629556304, 639854830, 305512590, 408488823, 110876181, 497784495, 617034693, 851537422, 102938949, 385266150, 668331122, 814641919, 630622468, 978945869, 28268783, 357972167, 146329111, 973624935, 149958790, 433931296, 25598024, 447940280, 354732829, 764891064, 685394573, 585294277, 465409408, 469130064, 920721745, 182673921, 284022508, 597678446, 416816025, 588422624, 98457962, 240636924, 36839874, 300511140, 182273503, 581213731, 455560749, 864940520, 856724314, 261438685, 740632796, 674273817, 942626165, 174802133, 374887767, 194299387, 742848665, 907493095, 441999251, 492506669, 611675310, 290416066, 970929824, 883609623, 223358251, 807963821, 422005815, 659475855, 461490465, 664907290, 263359925, 173600234, 665950005, 716496304, 824226812, 899890349, 390028746, 771125588, 145203352, 452007490, 325362082, 146808268, 736600017, 245688986, 146065271, 957412368, 898799739, 278661168, 704941285, 610928999, 81601883, 483849511, 959722958, 846205539, 512459448, 477514011, 94771790, 785546670, 950680044, 61469483, 942823288, 676349828, 399270685, 202224300, 83614201, 27855221, 178708942, 736070142, 898806733, 147446631, 252269212, 554679879, 911476215, 87670064, 942585856, 185967971, 834953514, 366759830, 422843000, 170643325, 93981853, 572719111, 985870900, 598086433, 218375794, 859943833, 859649526, 91331965, 695015236, 607644320, 732718027, 917982226, 747216559, 979635810, 561306185, 34036360, 223449518, 94586255, 423202372, 442944642, 611697021, 200279654, 277309078, 618283679, 820550379, 353246455, 521460957, 68835467, 668938271, 630939793, 166620027, 751195077, 59571869, 663276431, 490471791, 292464946, 386389206, 728831039, 100424847, 231097324, 77617394, 253639149, 723976405, 560621283, 219949516, 322944880, 693507607, 78791198, 119998459, 265121019, 385833490, 175839688, 127126701, 357575575, 462477947, 523972795, 85257542, 474256318, 882209397, 465260644, 945308123, 444097002, 744917420, 375150087, 199218939, 962795536, 153320195, 574288074, 366385933, 970641480, 460261345, 165378268, 54660122, 796112070, 75056929, 684432874, 318576890, 508386937, 736496795, 933419021, 301388996, 795962538, 981413164, 518902828, 825023058, 764707707, 274652931, 632168477, 715573025, 516018880, 296024238, 427201967, 100757491, 425935778, 453525227, 714143838, 325377579, 154052075, 164453301, 661274799, 281891479, 854578132, 707463702, 54478503, 560779145, 542878457, 842687510, 21165703, 595996646, 257510057, 793448599, 603061927, 924060221, 392136705, 100461338, 471328395, 891398279, 205030949, 652464912, 835850842, 87425060, 823905986, 380913646, 278673941, 927068232, 520240501, 876473603, 136589194, 511732167, 687296805, 683241687, 350269024, 968145478, 892943787, 218267753, 631708693, 575265725, 844874308, 490669196, 539989340, 283721451, 422216333, 634877244, 154305891, 30857166, 70409600, 192823595, 593649861, 218997343, 408157062, 510618691, 46798894, 349151803, 787794327, 112121118, 212247051, 734542883, 558493333, 135971470, 553224553, 555304942, 877988083, 353984399, 287379295, 128097089, 213238733, 686489183, 584370424, 478522537, 386164116, 728903056, 854166382, 496535429, 200766267, 471649197, 622910706, 125683017, 956326056, 20739963, 301662013, 197927580, 561829805, 470110929, 409651919, 25445274, 530972257, 693634465, 812235796, 433779479, 246955439, 273484835, 533196859, 434841810, 150091327, 794785050, 966482053, 130865325, 820075960, 424860898, 894572050, 601383094, 45465724, 85336318, 672082365, 48587322, 356055887, 859189025, 162098823, 439790362, 893587086, 428005909, 694221764, 21829348, 71677376, 928496509, 456286540, 290395261, 680262749, 924193154, 292067220, 171853628, 296940288, 150623112, 455840069, 180683168, 811842548, 508120422, 642272196, 544234726, 650304911, 229451663, 921643700, 798472778, 749018037, 226545381, 765423842, 718894474, 717080061, 749196186, 489999179, 806854513, 378512648, 701818525, 88561613, 592947516, 719258871, 280773178, 426531817, 513644853, 265496088, 511425456, 854621511, 704306302, 284837521, 431600849, 280960245, 932742910, 291976581, 677356118, 77062670, 110519140, 832608350, 207247104, 180387636]\nser = ''\nfor yt in range(1000, 10 ** 5 + 1):\n    U1.append(-1)\n\ndef facinv(n):\n    if U1[n - 1] != -1:\n        return U1[n - 1]\n    elif f1[n] != -1:\n        p = f1[n]\n    else:\n        p = math.factorial(n)\n        f1[n] = p\n    k = pow(p, 10 ** 9 + 5, 10 ** 9 + 7)\n    U1[n - 1] = k\n    return k\nt = int(input())\nfor t_case in range(t):\n    ser += ' '\n    n = int(input())\n    var = list(map(int, input().split()))\n    totsum = sum(var)\n    if totsum % (n + 1) != 0:\n        ser += str(0)\n        continue\n    s1 = totsum // (n + 1)\n    if var.count(s1) < 2:\n        ser += str(0)\n        continue\n    var.remove(s1)\n    var.remove(s1)\n    var.sort()\n    count = 0\n    i0 = 0\n    for i in range(n - 1):\n        a = var[i]\n        b = var[-i - 1]\n        if a == b and a == s1 // 2:\n            count += 1\n        elif a + b != s1:\n            i0 += 1\n            break\n    if i0 != 0:\n        ser += str(0)\n        continue\n    if n == 1:\n        ser += str(1)\n        continue\n    k1 = tuple(var[:n - 1])\n    dictOfElems = dict()\n    for elem in k1:\n        if elem in dictOfElems:\n            dictOfElems[elem] += 1\n        else:\n            dictOfElems[elem] = 1\n    rep1 = map(lambda x: facinv(x), dictOfElems.values())\n    if f[n - 1] != -1:\n        num = f[n - 1]\n    else:\n        num = myfac(n - 1)\n        f[n - 1] = num\n    if re[n - 1 - count] != -1:\n        num *= re[n - 1 - count]\n    else:\n        der = n - 1 - count\n        ty = pow(2, der, 10 ** 9 + 7)\n        num = ty * num % (10 ** 9 + 7)\n        re[der] = ty\n    for q in rep1:\n        num = num * q % (10 ** 9 + 7)\n    ser += str(num % (10 ** 9 + 7))\nd = ser.split()\nfor u in d:\n    print(int(u))", "from sys import stdin\nfrom collections import Counter, defaultdict\nfrom math import factorial, ceil\nmod = 10 ** 9 + 7\nfact = [1] * 100000\nfor i in range(1, 100000):\n    fact[i] = i * fact[i - 1] % mod\nt = int(stdin.readline())\nwhile t:\n    t -= 1\n    n = int(stdin.readline())\n    x = list(map(int, stdin.readline().split()))\n    c = Counter(x)\n    if n == 1:\n        if x[0] == x[1]:\n            ans = 1\n        else:\n            ans = 0\n    else:\n        ans = 0\n        flag = 0\n        sumx = sum(x)\n        suma = sumx // (n + 1)\n        if sumx % (n + 1) != 0 or c[suma] < 2:\n            flag = 1\n        for e in c:\n            if e != 0 and e != suma:\n                if c[e] != c[suma - e]:\n                    flag = 1\n                    break\n        if suma != 0 and c[suma] - 2 != c[0]:\n            flag = 1\n        if suma == 0 and c[0] & 1:\n            flag = 1\n        if flag == 0:\n            x.remove(suma)\n            x.remove(suma)\n            x.sort()\n            pair = []\n            for i in range(n - 1):\n                pair.append((x[i], suma - x[i]))\n            dup = Counter(pair)\n            r = 0\n            for j in pair:\n                if j[0] != j[1]:\n                    r += 1\n            num = pow(2, r, mod) * fact[n - 1] % mod\n            den = 1\n            for e in dup:\n                den = den * fact[dup[e]] % mod\n            ans = num % mod * pow(den, mod - 2, mod) % mod\n    print(ans)", "mod = 10 ** 9 + 7\nfactl = []\n\ndef ncr(n, r):\n    num = factl[n]\n    den = factl[r] * factl[n - r] % mod\n    return num * pow(den, mod - 2, mod) % mod\n\ndef solve(l, s, n):\n    if s % (n + 1) != 0:\n        return 0\n    s = s // (n + 1)\n    t = 0\n    for i in range(len(l)):\n        if l[i] == s:\n            l[i] = 10 ** 9 + 2\n            t += 1\n        if t == 2:\n            break\n    if t != 2:\n        return 0\n    res = 1\n    l.sort()\n    t = len(l) - 3\n    t2 = 0\n    curr = l[0]\n    left = n - 1\n    for i in range(n - 1):\n        if l[i] + l[t - i] != s:\n            return 0\n        if l[i] != l[t - i]:\n            res = res * 2\n        if l[i] == curr:\n            t2 += 1\n        else:\n            res = res * ncr(left, t2) % mod\n            left -= t2\n            curr = l[i]\n            t2 = 1\n    if t2:\n        res = res * ncr(left, t2) % mod\n    return res % mod\nt = int(input())\nif t == 10 ** 6:\n    for i in range(t):\n        input()\n        l = input().split()\n        if l[0] == l[1]:\n            print(1)\n        else:\n            print(0)\nelse:\n    factl.append(1)\n    for i in range(10 ** 5):\n        factl.append(factl[-1] * (i + 1) % mod)\n    for i in range(t):\n        n = int(input())\n        l = []\n        s = 0\n        for i in input().split():\n            i = int(i)\n            l.append(i)\n            s += i\n        if n == 1:\n            print(1 if l[0] == l[1] else 0)\n        else:\n            print(solve(l, s, n))", "import copy\nimport sys\nfrom collections import Counter\nmod = 1000000007\n\ndef GCD(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef modInv(s):\n    return power(s, mod - 2, mod)\nfact = [0] * 100005\nfact[0] = 1\nfor i in range(1, len(fact)):\n    fact[i] = i * fact[i - 1] % mod\nfor _ in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    summ = sum(a)\n    a.sort()\n    asum = 0\n    flag = False\n    for i in range(2 * n - 1):\n        if a[i] == a[i + 1]:\n            if a[i] != 0 and summ == a[i] * (n + 1):\n                asum = a[i]\n                a[i] = '$'\n                a[i + 1] = '$'\n                flag = True\n                break\n            if a[i] == 0 and summ == 0:\n                asum = a[i]\n                a[i] = '$'\n                a[i + 1] = '$'\n                flag = True\n                break\n    if flag:\n        l = 0\n        r = 2 * n - 1\n        cnt = 0\n        cnt1 = 0\n        allPair = []\n        while l < r:\n            if a[l] == '$':\n                l += 1\n                continue\n            if a[r] == '$':\n                r -= 1\n                continue\n            if a[l] + a[r] == asum:\n                cnt += 1\n                if a[l] == a[r]:\n                    cnt1 += 1\n                allPair.append((a[l], a[r]))\n                r -= 1\n                l += 1\n            elif a[l] + a[r] > asum:\n                r -= 1\n            else:\n                l += 1\n        if len(allPair) == n - 1:\n            m = dict(Counter(allPair))\n            yy = 1\n            for i in m:\n                yy = yy * fact[m[i]] % mod\n            if n == 1:\n                print(1)\n            else:\n                res = fact[n - 1] * modInv(yy) * power(2, cnt - cnt1, mod) % mod\n                print(res)\n        else:\n            print(0)\n    else:\n        print(0)", "from sys import stdin\nfact = [1]\nfor i in range(1, 10 ** 5 + 1):\n    fact.append(fact[i - 1] * i % 1000000007)\n\ndef modInverse(a, m=1000000007):\n    return power(a, m - 2, m)\n\ndef power(x, y, m=1000000007):\n    if y == 0:\n        return 1\n    if y == 1:\n        return x\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nfor t in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    x = [int(i) for i in stdin.readline().split()]\n    sps = sum(x)\n    if sps % (n + 1) != 0:\n        print(0)\n        continue\n    sa = sps // (n + 1)\n    if x.count(sa) < 2:\n        print(0)\n        continue\n    x.remove(sa)\n    x.remove(sa)\n    d = dict()\n    for i in x:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    t = dict()\n    eq_pair = 0\n    count = 0\n    flag = False\n    l = n - 1\n    den = 1\n    for i in x:\n        if d[i] <= 0:\n            continue\n        if sa - i in d:\n            if d[sa - i] > 0:\n                no = min(d[sa - i], d[i])\n                if i < sa - i:\n                    pair = (i, sa - i)\n                elif sa - i == i:\n                    pair = (i, i)\n                    no //= 2\n                    eq_pair += no\n                else:\n                    pair = (sa - i, i)\n                count += no\n                d[sa - i] -= no\n                d[i] -= no\n                den *= fact[no]\n            else:\n                flag = True\n                break\n        else:\n            flag = True\n            break\n        if count >= l:\n            break\n    if flag:\n        print(0)\n        continue\n    mmiden = modInverse(den)\n    res = fact[l] * power(2, l - eq_pair) * mmiden\n    print(res % (10 ** 9 + 7))", "natinv = []\ninv = []\nf = []\n\ndef InvNumber():\n    natinv.append(1)\n    natinv.append(1)\n    mod = 1000000007\n    for i in range(2, 100001):\n        natinv.append(natinv[mod % i] * (mod - mod // i) % mod)\n\ndef InvFact():\n    inv.append(1)\n    inv.append(1)\n    mod = 1000000007\n    for i in range(2, 100001):\n        inv.append(natinv[i] * inv[i - 1] % mod)\n\ndef fact():\n    f.append(1)\n    mod = 1000000007\n    for i in range(1, 100001):\n        f.append(f[i - 1] * i % mod)\nInvNumber()\nInvFact()\nfact()\nfrom sys import stdin, stdout\nt = int(stdin.readline())\nwhile t:\n    t -= 1\n    n = int(stdin.readline())\n    l = [int(x) for x in stdin.readline().split()]\n    Sum = 0\n    d = {}\n    for x in l:\n        Sum += x\n        if x not in d:\n            d[x] = 1\n        else:\n            d[x] += 1\n    Sum = Sum / (n + 1)\n    if Sum not in d:\n        stdout.write(str(0) + '\\n')\n        continue\n    elif d[Sum] < 2:\n        stdout.write(str(0) + '\\n')\n        continue\n    d[Sum] -= 2\n    diff = 0\n    divi = 1\n    flag = 0\n    for num in d.keys():\n        if d[num] == 0:\n            continue\n        if Sum - num in d.keys():\n            if d[num] == d[Sum - num]:\n                if num == Sum - num:\n                    if d[num] % 2 == 1:\n                        flag = 1\n                        stdout.write(str(0) + '\\n')\n                        break\n                    else:\n                        divi = divi * inv[int(d[num] / 2)] % 1000000007\n                else:\n                    divi = divi * inv[d[num]] % 1000000007\n                    diff += d[num]\n                d[num] = 0\n                d[Sum - num] = 0\n            else:\n                flag = 1\n                stdout.write(str(0) + '\\n')\n                break\n        else:\n            flag = 1\n            stdout.write(str(0) + '\\n')\n            break\n    if flag == 1:\n        continue\n    ans = pow(2, diff)\n    ans = ans % 1000000007 * (f[n - 1] % 1000000007) % 1000000007\n    ans = ans % 1000000007 * (divi % 1000000007) % 1000000007\n    stdout.write(str(ans) + '\\n')", "from sys import stdin, stdout\ntest = int(stdin.readline())\nwhile test:\n    test = test - 1\n    n = int(stdin.readline())\n    l = [int(x) for x in stdin.readline().split()]\n    if n == 1:\n        if l[0] == l[1]:\n            print(1, '\\n', end='')\n        else:\n            print(0, '\\n', end='')\n        continue\n    d = dict()\n    s = 0\n    for it in range(len(l)):\n        s += l[it]\n    s = s // (n + 1)\n    if s not in l or l.count(s) < 2:\n        print(0)\n        continue\n    for i in l:\n        d[str(i)] = d.get(str(i), 0) + 1\n    d[str(s)] -= 2\n    if d[str(s)] == 0:\n        del d[str(s)]\n    ss = 0\n    ds = 0\n    dcount = dict()\n    brk = 0\n    for k in d:\n        pair = 1\n        count = 0\n        t2 = -1\n        if d[k] > 0 and pair == 1:\n            d[k] -= 1\n            temp = int(k)\n            temp = s - temp\n            temp = str(temp)\n            t2 = temp\n            if temp in d and d[temp] > 0:\n                pair = 1\n                d[k] += 1\n                if temp == k:\n                    a = min(d[k] + 1, d[temp])\n                    a = d[k] // 2\n                    d[k] -= 2 * a\n                    ss += a\n                else:\n                    a = min(d[k] + 1, d[temp])\n                    d[temp] -= a\n                    d[k] -= a\n                    ds += a\n                count += a\n            else:\n                pair = 0\n                d[k] += 1\n        if d[k] > 0 or d[temp] > 0 or ds + ss >= n:\n            brk = 1\n            print(0, '\\n', end='')\n            break\n        dcount[count] = dcount.get(count, 0) + 1\n    if brk == 1:\n        continue\n    if ds + ss == 0:\n        print(0, '\\n', end='')\n        continue\n    exp = ds\n    bt = 2\n    x = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            (x, exp) = (x * bt % 1000000007, exp - 1)\n        else:\n            (bt, exp) = (bt * bt % 1000000007, exp // 2)\n    q = x\n    fac = [1]\n    for x in range(2, ds + ss + 1):\n        z = fac[x - 2]\n        z = x * z\n        z %= 1000000007\n        fac.append(z)\n    q = q * fac[ds + ss - 1]\n    q %= 1000000007\n    temp = 1\n    for k in dcount:\n        if k > 1:\n            temp *= pow(fac[k - 1], dcount[k], 1000000007)\n    temp = pow(temp, 1000000007 - 2, 1000000007)\n    q *= temp\n    q %= 1000000007\n    print(q, '\\n', end='')", "import math\nt = int(input())\ngh = []\nfact = [1]\nfor jk in range(1, 100001):\n    qr = fact[-1]\n    fact.append(qr * jk % 1000000007)\nfor wrt in range(t):\n    n = int(input())\n    a = 0\n    l = [int(i) for i in input().split()]\n    for i in l:\n        a = a + i\n    a = a / (n + 1)\n    if l.count(a) < 2 or a != int(a):\n        gh.append(0)\n        continue\n    l.remove(a)\n    l.remove(a)\n    l.sort()\n    k = len(l) // 2\n    kd = 2 * k\n    ans = True\n    for i in range(k):\n        if l[i] + l[kd - 1 - i] != a:\n            ans = False\n            break\n    if ans == False:\n        gh.append(0)\n        continue\n    i = 0\n    j = 1\n    index = 1\n    num = []\n    for r in range(k):\n        if l[i] == l[j] and j < k:\n            i = i + 1\n            j = j + 1\n            index = index + 1\n        else:\n            num.append(math.factorial(index))\n            i = i + 1\n            j = j + 1\n            index = 1\n    pro = 1\n    for i in num:\n        pro = pro * i\n    b = fact[k] * pow(pro, 1000000005, 1000000007)\n    if a % 2 == 0:\n        c = a // 2\n        d = l.count(c) // 2\n        e = k - d\n    else:\n        e = k\n    f = pow(2, e, 1000000007)\n    gh.append(b * f % 1000000007)\nfor we in gh:\n    print(we)", "import sys\ninp = sys.stdin.readline\nout = sys.stdout.write\nflsh = sys.stdout.flush\nsys.setrecursionlimit(10 ** 9)\ninf = 10 ** 20\neps = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\ndef MI():\n    return map(int, inp().strip().split())\n\ndef LI():\n    return list(map(int, inp().strip().split()))\n\ndef LLI():\n    return [list(map(int, l.split())) for l in sys.stdin.readlines().strip()]\n\ndef LI_():\n    return [int(x) - 1 for x in inp().strip().split()]\n\ndef LF():\n    return [float(x) for x in inp().strip().split()]\n\ndef LS():\n    return inp().strip().split()\n\ndef I():\n    return int(inp().strip())\n\ndef F():\n    return float(inp().strip())\n\ndef S():\n    return inp().strip()\n\ndef pf(s):\n    return out(s + '\\n')\n\ndef JA(a, sep):\n    return sep.join(map(str, a))\n\ndef JAA(a, s, t):\n    return s.join((t.join(map(str, b)) for b in a))\n\ndef main():\n    from collections import Counter, deque\n\n    def power(x, y):\n        res = 1\n        x = x % mod\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % mod\n            y = y >> 1\n            x = x * x % mod\n        return res\n    N = 1000001\n    factNumInv = [None] * (N + 1)\n    natNumInv = [None] * (N + 1)\n    fact = [None] * (N + 1)\n\n    def IofNum(p):\n        natNumInv[0] = natNumInv[1] = 1\n        for i in range(2, N + 1, 1):\n            natNumInv[i] = natNumInv[p % i] * (p - int(p / i)) % p\n\n    def IofFactl(p):\n        factNumInv[0] = factNumInv[1] = 1\n        for i in range(2, N + 1, 1):\n            factNumInv[i] = natNumInv[i] * factNumInv[i - 1] % p\n\n    def factl(p):\n        fact[0] = 1\n        for i in range(1, N + 1):\n            fact[i] = fact[i - 1] * i % p\n    mod = 1000000007\n    IofNum(mod)\n    IofFactl(mod)\n    factl(mod)\n    t = I()\n    l = []\n    for _ in range(t):\n        n = I()\n        a = LI()\n        if len(a) == 2 and a[-1] != a[-2]:\n            l.append(0)\n        elif len(a) == 2 and a[-1] == a[-2]:\n            l.append(1)\n        else:\n            s = sum(a) // (n + 1)\n            if a.count(s) >= 2:\n                a.remove(s)\n                a.remove(s)\n                pairs = []\n                d = dict()\n                for i in range(2 * n - 2):\n                    x = s - a[i]\n                    if x in d and d[x] > 0:\n                        ls = [x, a[i]]\n                        ls.sort()\n                        pairs.append(tuple(ls))\n                        d[x] -= 1\n                    elif a[i] in d:\n                        d[a[i]] += 1\n                    else:\n                        d[a[i]] = 1\n                if len(pairs) < n - 1:\n                    l.append(0)\n                else:\n                    z = Counter(pairs)\n                    p = fact[n - 1]\n                    m = 0\n                    for i in z:\n                        if i[0] == i[1]:\n                            m = z[i]\n                        p = p * factNumInv[z[i]] % mod\n                    ans = p * power(2, n - 1 - m)\n                    l.append(ans % mod)\n            else:\n                l.append(0)\n    for i in range(t):\n        print(l[i])\nmain()", "import math\nd = math.factorial(10 ** 5)\nf = [-1 for mm in range(10 ** 5 + 1)]\nre = [-1 for mmm in range(10 ** 5 + 1)]\nf1 = [-1 for mmmm in range(10 ** 5 + 1)]\n\ndef myfac(n):\n    p = 1\n    for i in range(1, n + 1):\n        p = p * i % (10 ** 9 + 7)\n    return p\nU1 = [1, 500000004, 166666668, 41666667, 808333339, 301388891, 900198419, 487524805, 831947206, 283194722, 571199524, 380933296, 490841026, 320774361, 821384963, 738836565, 514049213, 639669405, 402087866, 120104394, 862862120, 130130097, 179570875, 799148792, 791965957, 761229465, 917082579, 282752951, 699405279, 123313510, 649139150, 957785605, 604781386, 958964165, 170256120, 671396008, 261389083, 243720767, 211377457, 230284438, 469031331, 654024560, 317535457, 393580354, 297635121, 202122504, 366002609, 861791727, 854322286, 57086446, 138374245, 98814890, 662241795, 956708188, 762849245, 960050886, 16842998, 379600744, 752196628, 279203279, 250478744, 971781922, 888440989, 92006891, 262953954, 367620517, 856233148, 659650492, 328400734, 261834298, 102279357, 626420551, 159266036, 785936033, 757145819, 470488764, 58058296, 590487931, 361904913, 517023815, 623666965, 775898383, 33444559, 512302915, 711909451, 833859418, 262458156, 412073391, 746203077, 108291146, 902288920, 444590100, 843490222, 455781814, 720587182, 986672790, 267903845, 992529638, 545379091, 875453797, 751242122, 732855320, 463425783, 917917562, 427789694, 494601793, 929856098, 360461633, 462022587, 631472937, 708391653, 979539218, 150261410, 966230370, 704054182, 781931507, 664802838, 73430533, 244314544, 735369293, 204424541, 157413317, 90710678, 403957347, 35231659, 341549460, 435760235, 26841877, 287029784, 832977158, 494908226, 18900820, 428713543, 234542640, 890626248, 477136961, 324650637, 415396022, 556945299, 311121040, 775256183, 97008847, 909769299, 860484515, 247313688, 97584341, 197942752, 622959077, 816261476, 218775078, 61051491, 388559552, 270513463, 930328016, 535034378, 939327150, 802161325, 87355452, 76021104, 300475134, 921120970, 141488402, 117432445, 836081911, 411127772, 279585109, 331015482, 251970332, 113916985, 971258342, 929656488, 889125916, 178549862, 909072132, 142337556, 23536009, 73579300, 595918989, 327351505, 474040845, 682177026, 267484491, 181789534, 164031466, 579265039, 169780996, 589143218, 907389066, 354007352, 970284256, 753771127, 915384231, 880390598, 520002017, 689846169, 600458403, 815230759, 706137534, 732191651, 538660962, 47456025, 599244836, 111326330, 657408467, 412962971, 375791085, 784424117, 527809735, 930755077, 237765502, 688330647, 526831752, 551769167, 745569020, 26723577, 264012611, 623336468, 599189621, 669402697, 589406380, 862395510, 571452236, 262652254, 206529699, 414251246, 621302001, 764851556, 933179180, 287917815, 979512693, 56188367, 340759435, 756827299, 7507809, 544712803, 794680992, 674239165, 82664871, 130052992, 267208556, 113141945, 12864223, 559723725, 842457890, 921805957, 885861006, 35975146, 40467642, 554379392, 778217523, 182383338, 405485651, 139942632, 890314741, 678001239, 811242198, 707436745, 425222626, 905116696, 126558142, 441097927, 852828624, 326436613, 232297110, 604650182, 671446058, 10005416, 522425397, 518670730, 38958040, 830402065, 800847072, 376559882, 110863358, 113130413, 279395402, 246496014, 986498194, 953356631, 314119133, 22470175, 961072596, 215410152, 155688065, 70721713, 297450078, 812883107, 541016959, 1872031, 644834046, 476442732, 755056316, 91314186, 326841207, 285853701, 396235995, 476081606, 270053967, 311939982, 581039804, 985319076, 135712978, 964144274, 904487323, 678375373, 515288812, 705261532, 807484621, 122354320, 419749533, 972410777, 211450036, 949557355, 18947635, 222282375, 48171780, 378700860, 623832397, 478444619, 510870143, 876980910, 810176965, 748638324, 113421724, 440348993, 863313960, 855851119, 438584915, 828080811, 720691159, 71663720, 48408626, 843989221, 837856261, 23396586, 696498209, 699396142, 558282241, 447074582, 748373754, 670816350, 949329879, 230172975, 253576086, 513778485, 518825953, 716192587, 608379868, 932975307, 856951364, 238908695, 952383270, 413462845, 749755550, 255633116, 371504590, 575270325, 736243777, 7621849, 202798951, 842667039, 502327813, 12403107, 546737375, 494648599, 151624724, 395508517, 384226928, 242233679, 35789821, 275029085, 239986639, 890723831, 812542048, 364833448, 745651158, 442296160, 329212426, 335960985, 66673582, 971303612, 458040065, 136966163, 279002518, 756568843, 351700958, 866541869, 396563255, 517728958, 965430081, 680218496, 838469951, 144627151, 576509210, 798927877, 640906388, 538138307, 199844570, 847618664, 622119051, 373122494, 767097325, 617288087, 395092300, 433074305, 67569149, 815890839, 568176207, 776450314, 850674275, 408395804, 136913583, 801784300, 794207214, 262154718, 34284026, 400561835, 433972639, 573828101, 184699592, 812790266, 404769648, 582517190, 392883298, 497395023, 656097176, 460552924, 608552698, 486267026, 331363414, 476406879, 202491684, 432338321, 344314146, 993894982, 649068571, 532377735, 925873015, 756095388, 83536581, 782502356, 467833719, 201958994, 113067476, 982276563, 417000623, 683259514, 595275137, 339855849, 540755239, 602085936, 629650637, 694546695, 783468170, 990732904, 300418276, 153830238, 781995268, 886235290, 762796169, 704474617, 834858176, 120593647, 291208178, 185572492, 867351020, 704212748, 633983365, 436319797, 679651749, 574691409, 884692149, 583265738, 954817023, 25168036, 437027667, 13494817, 926806481, 260807531, 473460019, 215121540, 398786562, 665421923, 247242609, 357210812, 375220601, 951489166, 260146496, 562904189, 803189606, 115688778, 402674167, 664102792, 62073083, 931438538, 989781133, 54305395, 845490579, 408508000, 817016, 770460718, 252530800, 193344993, 18240764, 451521272, 550299453, 675641621, 648967803, 128976362, 498292114, 586102337, 268722858, 813389329, 711699206, 345071263, 549118359, 498160774, 12544712, 899831499, 7499676, 159323417, 860458480, 925163407, 526574743, 431479193, 124394448, 736478932, 827152428, 468482333, 191449968, 570982019, 630772527, 6811956, 460686917, 587776989, 189529436, 618602480, 213045731, 31935150, 166725807, 46518902, 361709447, 728106284, 141044314, 106680816, 648547039, 81624401, 345039463, 428679492, 444415784, 871949944, 552304261, 263204892, 812749473, 93356306, 615275825, 658196191, 99745872, 808765204, 980015659, 506203240, 798053748, 875307384, 490913669, 395559142, 537801345, 254916759, 26857248, 323421544, 786532324, 111710215, 362083412, 98363148, 686582519, 232498406, 816375871, 302974657, 320593384, 541140925, 837139904, 84057040, 831759554, 589762885, 489023570, 342716282, 966455154, 672855976, 456926629, 511811424, 370359005, 435482844, 480465346, 749545478, 742002607, 688642026, 635383632, 287496457, 895129599, 639223927, 732732045, 883082755, 597812434, 281256739, 243843142, 932634458, 133552203, 978803223, 605228299, 76527469, 923076281, 353392926, 363322540, 770576388, 900277818, 11219964, 45472760, 708339507, 491437446, 743928014, 675393437, 584018351, 629556304, 639854830, 305512590, 408488823, 110876181, 497784495, 617034693, 851537422, 102938949, 385266150, 668331122, 814641919, 630622468, 978945869, 28268783, 357972167, 146329111, 973624935, 149958790, 433931296, 25598024, 447940280, 354732829, 764891064, 685394573, 585294277, 465409408, 469130064, 920721745, 182673921, 284022508, 597678446, 416816025, 588422624, 98457962, 240636924, 36839874, 300511140, 182273503, 581213731, 455560749, 864940520, 856724314, 261438685, 740632796, 674273817, 942626165, 174802133, 374887767, 194299387, 742848665, 907493095, 441999251, 492506669, 611675310, 290416066, 970929824, 883609623, 223358251, 807963821, 422005815, 659475855, 461490465, 664907290, 263359925, 173600234, 665950005, 716496304, 824226812, 899890349, 390028746, 771125588, 145203352, 452007490, 325362082, 146808268, 736600017, 245688986, 146065271, 957412368, 898799739, 278661168, 704941285, 610928999, 81601883, 483849511, 959722958, 846205539, 512459448, 477514011, 94771790, 785546670, 950680044, 61469483, 942823288, 676349828, 399270685, 202224300, 83614201, 27855221, 178708942, 736070142, 898806733, 147446631, 252269212, 554679879, 911476215, 87670064, 942585856, 185967971, 834953514, 366759830, 422843000, 170643325, 93981853, 572719111, 985870900, 598086433, 218375794, 859943833, 859649526, 91331965, 695015236, 607644320, 732718027, 917982226, 747216559, 979635810, 561306185, 34036360, 223449518, 94586255, 423202372, 442944642, 611697021, 200279654, 277309078, 618283679, 820550379, 353246455, 521460957, 68835467, 668938271, 630939793, 166620027, 751195077, 59571869, 663276431, 490471791, 292464946, 386389206, 728831039, 100424847, 231097324, 77617394, 253639149, 723976405, 560621283, 219949516, 322944880, 693507607, 78791198, 119998459, 265121019, 385833490, 175839688, 127126701, 357575575, 462477947, 523972795, 85257542, 474256318, 882209397, 465260644, 945308123, 444097002, 744917420, 375150087, 199218939, 962795536, 153320195, 574288074, 366385933, 970641480, 460261345, 165378268, 54660122, 796112070, 75056929, 684432874, 318576890, 508386937, 736496795, 933419021, 301388996, 795962538, 981413164, 518902828, 825023058, 764707707, 274652931, 632168477, 715573025, 516018880, 296024238, 427201967, 100757491, 425935778, 453525227, 714143838, 325377579, 154052075, 164453301, 661274799, 281891479, 854578132, 707463702, 54478503, 560779145, 542878457, 842687510, 21165703, 595996646, 257510057, 793448599, 603061927, 924060221, 392136705, 100461338, 471328395, 891398279, 205030949, 652464912, 835850842, 87425060, 823905986, 380913646, 278673941, 927068232, 520240501, 876473603, 136589194, 511732167, 687296805, 683241687, 350269024, 968145478, 892943787, 218267753, 631708693, 575265725, 844874308, 490669196, 539989340, 283721451, 422216333, 634877244, 154305891, 30857166, 70409600, 192823595, 593649861, 218997343, 408157062, 510618691, 46798894, 349151803, 787794327, 112121118, 212247051, 734542883, 558493333, 135971470, 553224553, 555304942, 877988083, 353984399, 287379295, 128097089, 213238733, 686489183, 584370424, 478522537, 386164116, 728903056, 854166382, 496535429, 200766267, 471649197, 622910706, 125683017, 956326056, 20739963, 301662013, 197927580, 561829805, 470110929, 409651919, 25445274, 530972257, 693634465, 812235796, 433779479, 246955439, 273484835, 533196859, 434841810, 150091327, 794785050, 966482053, 130865325, 820075960, 424860898, 894572050, 601383094, 45465724, 85336318, 672082365, 48587322, 356055887, 859189025, 162098823, 439790362, 893587086, 428005909, 694221764, 21829348, 71677376, 928496509, 456286540, 290395261, 680262749, 924193154, 292067220, 171853628, 296940288, 150623112, 455840069, 180683168, 811842548, 508120422, 642272196, 544234726, 650304911, 229451663, 921643700, 798472778, 749018037, 226545381, 765423842, 718894474, 717080061, 749196186, 489999179, 806854513, 378512648, 701818525, 88561613, 592947516, 719258871, 280773178, 426531817, 513644853, 265496088, 511425456, 854621511, 704306302, 284837521, 431600849, 280960245, 932742910, 291976581, 677356118, 77062670, 110519140, 832608350, 207247104, 180387636]\nser = ''\nfor yt in range(1000, 10 ** 5 + 1):\n    U1.append(-1)\n\ndef facinv(n):\n    if U1[n - 1] != -1:\n        return U1[n - 1]\n    elif f1[n] != -1:\n        p = f1[n]\n    else:\n        p = math.factorial(n)\n        f1[n] = p\n    k = pow(p, 10 ** 9 + 5, 10 ** 9 + 7)\n    U1[n - 1] = k\n    return k\nt = int(input())\nfor t_case in range(t):\n    ser += ' '\n    n = int(input())\n    var = list(map(int, input().split()))\n    totsum = sum(var)\n    if totsum % (n + 1) != 0:\n        ser += str(0)\n        continue\n    s1 = totsum // (n + 1)\n    if var.count(s1) < 2:\n        ser += str(0)\n        continue\n    var.remove(s1)\n    var.remove(s1)\n    var.sort()\n    count = 0\n    i0 = 0\n    for i in range(n - 1):\n        a = var[i]\n        b = var[-i - 1]\n        if a == b and a == s1 // 2:\n            count += 1\n        elif a + b != s1:\n            i0 += 1\n            break\n    if i0 != 0:\n        ser += str(0)\n        continue\n    if n == 1:\n        ser += str(1)\n        continue\n    k1 = tuple(var[:n - 1])\n    dictOfElems = dict()\n    for elem in k1:\n        if elem in dictOfElems:\n            dictOfElems[elem] += 1\n        else:\n            dictOfElems[elem] = 1\n    rep1 = map(lambda x: facinv(x), dictOfElems.values())\n    if f[n - 1] != -1:\n        num = f[n - 1]\n    else:\n        num = myfac(n - 1)\n        f[n - 1] = num\n    if re[n - 1 - count] != -1:\n        num *= re[n - 1 - count]\n    else:\n        der = n - 1 - count\n        ty = pow(2, der, 10 ** 9 + 7)\n        num = ty * num % (10 ** 9 + 7)\n        re[der] = ty\n    for q in rep1:\n        num = num * q % (10 ** 9 + 7)\n    ser += str(num % (10 ** 9 + 7))\nd = ser.split()\nfor u in d:\n    print(int(u))", "from sys import stdin, stdout\ninput = stdin.readline\nmod = 10 ** 9 + 7\nfact = [1]\nfor i in range(1, 10 ** 5 + 1):\n    fact.append(fact[-1] * i % mod)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = sum(a) // (n + 1)\n    d = {}\n    for i in a:\n        d[i] = d.get(i, 0) + 1\n    try:\n        d[s] -= 2\n        if d[s] < 0:\n            print(0)\n            continue\n    except:\n        print(0)\n        continue\n    st = []\n    k = []\n    fl = 0\n    for i in sorted(d.keys()):\n        if d[i] != 0:\n            if not (s % 2 == 0 and i == s // 2):\n                try:\n                    if d[s - i] != d[i]:\n                        fl = 1\n                        break\n                    k.append(d[i])\n                    d[s - i] = 0\n                except:\n                    fl = 1\n                    break\n            elif s % 2 == 0 and i == s // 2:\n                if d[i] % 2 != 0:\n                    fl = 1\n                    break\n                st.append(d[i] // 2)\n    if fl:\n        print(0)\n        continue\n    ans = fact[n - 1]\n    for i in k + st:\n        ans *= pow(fact[i], mod - 2, mod)\n        ans %= mod\n    ans *= pow(2, sum(k), mod)\n    ans %= mod\n    print(ans)", "import copy\nfrom sys import stdin\nmod = int(1000000000.0 + 7)\narr = list()\nhs = set()\ntotal = 0\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    while x < 0:\n        x = x + m0\n    return x\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nfact = [1] * 100001\nfor i in range(2, 100001):\n    fact[i] = i * fact[i - 1] % mod\npow = [1] * 100001\nfor i in range(1, 100001):\n    pow[i] = 2 * pow[i - 1] % mod\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    arr = stdin.readline().split()\n    for i in range(len(arr)):\n        arr[i] = int(arr[i])\n    s = sum(arr)\n    if s % (n + 1) != 0:\n        print(0)\n        continue\n    s = s // (n + 1)\n    hm = dict()\n    for i in arr:\n        if i not in hm:\n            hm[i] = 0\n        hm[i] = hm[i] + 1\n    if s not in hm or hm[s] < 2:\n        print(0)\n        continue\n    if hm[s] == 2:\n        hm.pop(s)\n    else:\n        hm[s] = hm[s] - 2\n    flag = True\n    for i in hm:\n        if hm[i] != hm.get(s - i, 0):\n            flag = False\n    if flag:\n        ans = fact[n - 1]\n        denom = 1\n        for i in hm:\n            if 2 * i > s:\n                continue\n            if 2 * i == s:\n                denom = denom * fact[hm[i] // 2] % mod\n            else:\n                denom = denom * fact[hm[i]] % mod\n        ans = ans * modInverse(denom, mod) % mod\n        if s % 2 == 0 and s // 2 in hm:\n            ans = ans * pow[n - hm[s // 2] // 2 - 1] % mod\n        else:\n            ans = ans * pow[n - 1] % mod\n        print(int(ans % mod))\n    else:\n        print(0)", "from sys import stdin, stdout\nimport math\nfac = []\nt = 1\nfor i in range(1, 100010):\n    t *= i\n    t %= 1000000007\n    fac.append(t)\n\ndef fact(n):\n    if n == 1:\n        return 1\n    return fac[n - 1]\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    if inv == -1:\n        return 1 / 0\n    else:\n        return inv * a % m\nfor tt in range(int(stdin.readline().rstrip())):\n    N = int(stdin.readline().rstrip())\n    xs1 = [int(x) for x in stdin.readline().rstrip().split()]\n    if N == 1:\n        if xs1[0] == xs1[1]:\n            print('1')\n            continue\n        else:\n            print('0')\n            continue\n    sm = int(sum(xs1) / (N + 1))\n    ct = 0\n    xs = []\n    for i in range(len(xs1)):\n        if xs1[i] != sm or ct > 1:\n            xs.append(xs1[i])\n        elif xs1[i] == sm:\n            ct += 1\n    if ct < 2:\n        print('0')\n        continue\n    s2 = int(sum(xs) / (N - 1))\n    if s2 != sm:\n        print('0')\n        continue\n    xs.sort()\n    h2s = 0\n    a1 = []\n    d = dict()\n    for i in range(N - 1):\n        a1.append(sm - xs[i])\n        if xs[i] == sm / 2:\n            h2s += 1\n        if xs[i] in d:\n            d[xs[i]] += 1\n        else:\n            d[xs[i]] = 1\n    a2 = xs[N - 1:]\n    a1.reverse()\n    if a2 != a1:\n        print('0')\n        continue\n    prod = 1\n    for dd in d.keys():\n        prod *= fact(d[dd])\n        prod %= 1000000007\n    ans = modDivide(pow(2, N - 1 - h2s, 1000000007) * fact(N - 1), prod, 1000000007) % 1000000007\n    print(ans)", "from abc import ABC, abstractmethod\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef get_int(source):\n    return int(source())\n\ndef get_ints(source):\n    return [int(x) for x in source().split(' ')]\n\ndef getline_from_std():\n    return input()\n\nclass IOProcessing(ABC):\n\n    @abstractmethod\n    def read_test_case(self, source):\n        pass\n\n    @abstractmethod\n    def process_test_case(self, tcase):\n        pass\n\n    def solve(self, input_type='from_std', output_type='to_std', input_path='', output_path='output.txt', tcase_handling='all'):\n        ans = []\n        if input_type == 'from_file':\n            with open(input_path, 'r') as in_file:\n                t = int(in_file.readline())\n                for _ in range(t):\n                    tcase = self.read_test_case(in_file.readline)\n                    ans.append(self.process_test_case(tcase))\n                    if tcase_handling == 'single' and output_type == 'to_std':\n                        print(ans[-1])\n        elif input_type == 'from_std':\n            t = int(getline_from_std())\n            for _ in range(t):\n                tcase = self.read_test_case(getline_from_std)\n                ans.append(self.process_test_case(tcase))\n                if tcase_handling == 'single' and output_type == 'to_std':\n                    print(ans[-1])\n        if output_type == 'to_file':\n            with open(output_path, 'w') as output:\n                for a in ans:\n                    output.write(str(a) + '\\n')\n        elif output_type == 'to_std' and tcase_handling == 'all':\n            for a in ans:\n                print(a)\n\ndef get_total(a):\n    n = len(a) // 2\n    s = sum(a)\n    if s % (n + 1) != 0:\n        return None\n    else:\n        return s // (n + 1)\nMOD = 10 ** 9 + 7\nfact = {0: 1, 1: 1}\n\ndef inv_MOD(n):\n    return pow(n, MOD - 2, MOD)\n\ndef factorial_MOD(n):\n    if n in fact:\n        return fact[n]\n    res = factorial_MOD(n - 1) * n % MOD\n    fact[n] = res\n    return res\n\ndef compute_res(a):\n    n = len(a) // 2\n    s = get_total(a)\n    counts = dict()\n    for el in a:\n        if el in counts:\n            counts[el] = counts[el] + 1\n        else:\n            counts[el] = 1\n    if s in counts:\n        if counts[s] < 2:\n            return 0\n        counts[s] = counts[s] - 2\n        if counts[s] == 0:\n            counts.pop(s)\n    else:\n        return 0\n    pairs_counts = []\n    total_noneq_pairs = (len(a) - 2) // 2\n    if s % 2 == 0:\n        half = s // 2\n        if half in counts:\n            if counts[half] % 2 == 1:\n                return 0\n            pairs_counts = [counts[half] // 2]\n            total_noneq_pairs -= counts[half] // 2\n    for key in counts.keys():\n        if not s - key in counts:\n            return 0\n        if counts[key] != counts[s - key]:\n            return 0\n        if key >= s - key:\n            continue\n        pairs_counts.append(counts[key])\n    pairs_factorials = 1\n    for pair_count in pairs_counts:\n        pairs_factorials = pairs_factorials * factorial_MOD(pair_count) % MOD\n    return factorial_MOD(n - 1) * inv_MOD(pairs_factorials) * pow(2, total_noneq_pairs, MOD) % MOD\n\nclass Ex_1_io(IOProcessing):\n\n    def read_test_case(self, source):\n        n = get_int(source)\n        a = get_ints(source)\n        return {'n': n, 'a': a}\n\n    def process_test_case(self, tcase):\n        n = tcase['n']\n        a = tcase['a']\n        return compute_res(a)\nsolution = Ex_1_io()\nsolution.solve(input_type='from_std', output_type='to_std', input_path='input.txt', output_path='output.txt', tcase_handling='all')", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    t = int(input())\n    f = [1 for j in range(10 ** 5 + 10)]\n    for wer in range(10 ** 5 + 9):\n        f[wer + 1] = f[wer] * (wer + 1) % 1000000007\n    for qwe in range(t):\n        l = int(input())\n        d = [int(j) for j in input().split()]\n        d.sort()\n        mode = 0\n        if d[0] == 0 and d[-1] == 0:\n            print(1)\n        elif l == 1:\n            if d[0] == d[1]:\n                print(1)\n            else:\n                print(0)\n        else:\n            if d[0] <= 0 and d[-1] <= 0:\n                if d[0] == d[1]:\n                    sum = d[0]\n                    s = d[2:]\n                else:\n                    print(0)\n                    mode = -1\n            elif d[0] >= 0 and d[-1] >= 0:\n                if d[-1] == d[-2]:\n                    sum = d[-1]\n                    s = d[0:2 * l - 2]\n                else:\n                    print(0)\n                    mode = -1\n            else:\n                sum = d[0] + d[-1]\n                s = []\n                for i in range(1, 2 * l - 2):\n                    if d[i] == sum:\n                        if d[i] == d[i + 1]:\n                            s = d[0:i] + d[i + 2:]\n                            break\n                        else:\n                            print(0)\n                            mode = -1\n                            break\n                if mode == 0 and s == []:\n                    print(0)\n                    mode = -1\n            if mode == 0:\n                for i1 in range(l - 1):\n                    if s[i1] + s[-1 - i1] != sum:\n                        print(0)\n                        mode = -1\n                        break\n            if mode == 0:\n                p2 = 0\n                ans = f[l - 1]\n                ans2 = 1\n                temp = 1\n                if s[0] == sum // 2 and sum % 2 == 0:\n                    p2 += 1\n                for i in range(1, l - 1):\n                    if s[i - 1] == s[i]:\n                        temp += 1\n                    else:\n                        ans2 = ans2 * f[temp] % 1000000007\n                        temp = 1\n                    if s[i] == sum // 2 and sum % 2 == 0:\n                        p2 += 1\n                ans2 = ans2 * f[temp] % 1000000007\n                print(ans * pow(ans2, 1000000005, 1000000007) % 1000000007 * pow(2, l - 1 - p2, 1000000007) % 1000000007)\nmain()", "import sys\nfrom collections import defaultdict\nmod = 10 ** 9 + 7\nfac = [1]\nfor i in range(1, 10 ** 5 + 1):\n    fac.append(fac[-1] * i % mod)\n\ndef modularexpo(x, n, mod):\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = res * x % mod\n        x = x * x % mod\n        n = n // 2\n    return res\nfor _ in range(int(sys.stdin.readline().rstrip())):\n    n = int(sys.stdin.readline().rstrip())\n    arr = list(map(int, sys.stdin.readline().rstrip().split()))\n    if n == 1:\n        if arr[0] == arr[1]:\n            sys.stdout.write('1\\n')\n        else:\n            sys.stdout.write('0\\n')\n    else:\n        final = sum(arr) // (n + 1)\n        d = defaultdict(lambda : 0)\n        keys = []\n        for i in arr:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n                keys.append(i)\n        if final in d and d[final] >= 2:\n            d[final] -= 2\n            (total_pair, diff_pair, freq) = (0, 0, 1)\n            for i in keys:\n                x = min(d[i], d[final - i])\n                if i == final - i:\n                    if x % 2 == 0:\n                        d[i] = 0\n                    else:\n                        d[i] = 1\n                    total_pair += x // 2\n                    freq = freq * fac[x // 2] % mod\n                else:\n                    d[i] -= x\n                    d[final - i] -= x\n                    total_pair += x\n                    diff_pair += x\n                    freq = freq * fac[x] % mod\n            if total_pair != n - 1:\n                sys.stdout.write('0\\n')\n            else:\n                mod = 10 ** 9 + 7\n                temp1 = fac[total_pair]\n                temp2 = modularexpo(2, diff_pair, mod)\n                temp3 = freq\n                temp1 = temp1 * temp2 % mod\n                temp3 = modularexpo(temp3, mod - 2, mod)\n                temp3 = temp3 * temp1 % mod\n                sys.stdout.write(str(temp3) + '\\n')\n        else:\n            sys.stdout.write('0\\n')", "from math import gcd\nimport sys\nmd = 10 ** 9 + 7\n\ndef modInverse(b, m):\n    g = gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    return inv * a % m\n\ndef make_pairs(arr, target, size):\n    freq = {}\n    diff = 0\n    pairs = []\n    (l, r) = (0, 2 * size - 1)\n    while l != size:\n        if arr[l] + arr[r] != target:\n            return [False, False, False]\n        else:\n            p = (arr[l], arr[r])\n            pairs.append(p)\n            l += 1\n            r -= 1\n            if p[0] != p[1]:\n                diff += 1\n            if p in freq:\n                freq[p] += 1\n            else:\n                freq[p] = 1\n    return (pairs, freq, diff)\nFACT = [1]\nfor i in range(1, 10 ** 6):\n    FACT.append(FACT[i - 1] % md * (i % md) % md)\nfor _ in range(int(sys.stdin.readline().rstrip())):\n    n = int(sys.stdin.readline().rstrip())\n    arr = list(map(int, sys.stdin.readline().rstrip().split()))\n    arr.sort()\n    target = sum(arr) // (n + 1)\n    if n == 1:\n        if arr[0] == arr[1]:\n            sys.stdout.write('1\\n')\n        else:\n            sys.stdout.write('0\\n')\n    else:\n        found = False\n        for i in range(1, len(arr)):\n            if arr[i] == arr[i - 1] and arr[i] == target:\n                (p, freq, diff_pairs) = make_pairs(arr[:i - 1] + arr[i + 1:], target, n - 1)\n                if type(p) == type([]):\n                    found = True\n                    break\n        if found:\n            total_pairs = n - 1\n            p1 = FACT[total_pairs] % md * (pow(2, diff_pairs, md) % md) % md\n            for i in freq:\n                p1 = modDivide(p1, FACT[freq[i]], md)\n            sys.stdout.write('{}\\n'.format(p1 % md))\n        else:\n            sys.stdout.write('0\\n')", "import math\nfrom sys import stdin\ndpf = {0: 1, 1: 1}\n\ndef fac(a):\n    if a not in dpf:\n        start = len(dpf)\n        for i in range(start, a + 1):\n            dpf[i] = i % (10 ** 9 + 7) * (dpf[i - 1] % (10 ** 9 + 7)) % (10 ** 9 + 7)\n    return dpf[a]\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    x = list(map(int, stdin.readline().split()))\n    d = {}\n    s = 0\n    for i in x:\n        s += i\n        if i not in d:\n            d[i] = 0\n        d[i] += 1\n    su = s // (n + 1)\n    if su not in d:\n        d[su] = -1\n    if su % 2 == 0:\n        if su // 2 in d:\n            if d[su // 2] % 2 == 1:\n                print(0)\n                continue\n    if d[su] < 2 or s % (n + 1) != 0:\n        print(0)\n    else:\n        d[su] -= 2\n        if d[su] == 0:\n            del d[su]\n        count = 0\n        chk = False\n        temp = 1\n        for j in x:\n            if su - j in d and j in d:\n                if d[j] == d[su - j] and j != su - j:\n                    count += d[j]\n                    temp *= fac(d[j]) % (10 ** 9 + 7)\n                    del d[j]\n                    del d[su - j]\n                elif d[j] == d[su - j] and j == su - j:\n                    if d[j] % 2 == 1:\n                        chk = True\n                        break\n                    else:\n                        temp *= fac(d[j] // 2) % (10 ** 9 + 7)\n                        del d[j]\n                else:\n                    chk = True\n                    break\n            elif su - j in d and j not in d or (su - j not in d and j in d):\n                chk = True\n                break\n            elif len(d) == 0:\n                break\n        if len(d) != 0 or chk:\n            print(0)\n            continue\n        ans = pow(2, count, 10 ** 9 + 7) * fac(n - 1)\n        m = 10 ** 9 + 7\n        ans = ans % m\n        inv = pow(temp, m - 2, m)\n        ans = inv * ans % m\n        print(ans % 1000000007)", "from sys import stdin\nt = int(stdin.readline())\nm = 10 ** 9 + 7\nans1 = 1\nfac = [1]\np2 = [1]\nfor i in range(10 ** 5):\n    ans1 = ans1 * (i + 1) % m\n    fac.append(ans1)\nfor v in range(t):\n    n = int(stdin.readline())\n    x = list(map(int, stdin.readline().split()))\n    d = {}\n    su = 0\n    for g in x:\n        su += g\n        if g not in d:\n            d[g] = 0\n        d[g] += 1\n    tot = su / (n + 1)\n    if tot not in d:\n        print(0)\n        continue\n    if d[tot] < 2:\n        print(0)\n        continue\n    d[tot] -= 2\n    if d[tot] == 0:\n        del d[tot]\n    tot = int(tot)\n    res = True\n    ans = 1\n    p = 0\n    inv = 1\n    x = list(d.keys())\n    for e in x:\n        if e not in d:\n            continue\n        if tot - e not in d:\n            res = False\n            break\n        if d[e] != d[tot - e]:\n            res = False\n            break\n        c = d[e]\n        if e != tot - e:\n            p += c\n            del d[tot - e]\n            inv = inv * fac[c] % m\n        else:\n            if c % 2 != 0:\n                res = False\n                break\n            inv = inv * fac[c // 2] % m\n        del d[e]\n    if not res:\n        print(0)\n        continue\n    inv = pow(inv, m - 2, m)\n    ans = pow(2, p, m) * fac[n - 1] % m\n    print(inv * ans % m)", "from sys import stdin\nmod = int(1000000000.0) + 7\nfact = [1] * 100001\n\ndef generateFactorials():\n    for i in range(1, 100001):\n        fact[i] = i * fact[i - 1] % mod\ngenerateFactorials()\n\ndef isUnique(a, length, freq, target, n):\n    freq[target] -= 2\n    pairs = 0\n    elements = 2\n    mul = 0\n    deno = 1\n    num = fact[n - 1]\n    for i in range(length):\n        p1 = a[i]\n        p2 = target - a[i]\n        n1 = freq.get(p1)\n        n2 = freq.get(p2, 0)\n        if n1 > 0 and n2 > 0:\n            req = n1\n            if n1 != n2:\n                return 0\n            if p1 != p2:\n                mul = mul + req\n            else:\n                req = req // 2\n            elements += 2 * req\n            deno = deno * fact[req] % mod\n            freq[a[i]] = -1\n            freq[target - a[i]] = -1\n    if elements == 2 * n:\n        return pow(2, mul, mod) * (num * pow(deno, mod - 2, mod)) % mod % mod\n    else:\n        return 0\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    summ = sum(arr)\n    if n == 1:\n        if arr[0] == arr[1]:\n            print(1)\n        else:\n            print(0)\n        continue\n    elif n > 1:\n        check = [0]\n        if [0] == list(set(arr)):\n            print(1)\n            continue\n    freq = {}\n    for i in arr:\n        if freq.get(i, -1) == -1:\n            freq[i] = 0\n        freq[i] += 1\n    a = list(freq.keys())\n    length = len(a)\n    possible = []\n    for i in a:\n        if (n + 1) * i == summ and freq.get(i) >= 2:\n            possible.append(i)\n    answer = 0\n    if len(possible) == 0:\n        print(0)\n        continue\n    for i in possible:\n        answer = (answer + isUnique(a, length, freq, i, n)) % mod\n        freq[i] += 2\n    print(answer)", "from sys import stdin\nmod = int(1000000000.0) + 7\nfact = [1] * 100001\n\ndef generateFactorials():\n    for i in range(1, 100001):\n        fact[i] = i * fact[i - 1] % mod\ngenerateFactorials()\n\ndef isUnique(a, length, freq, target, n):\n    freq[target] -= 2\n    pairs = 0\n    elements = 2\n    mul = 0\n    deno = 1\n    num = fact[n - 1]\n    for i in range(length):\n        p1 = a[i]\n        p2 = target - a[i]\n        n1 = freq.get(p1)\n        n2 = freq.get(p2, 0)\n        if n1 > 0 and n2 > 0:\n            req = n1\n            if n1 != n2:\n                return 0\n            if p1 != p2:\n                mul = mul + req\n            else:\n                req = req // 2\n            elements += 2 * req\n            deno = deno * fact[req] % mod\n            freq[a[i]] = -1\n            freq[target - a[i]] = -1\n    if elements == 2 * n:\n        return pow(2, mul, mod) * (num * pow(deno, mod - 2, mod)) % mod % mod\n    else:\n        return 0\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    summ = sum(arr)\n    if n == 1:\n        if arr[0] == arr[1]:\n            print(1)\n        else:\n            print(0)\n        continue\n    elif n > 1:\n        check = [0]\n        if [0] == list(set(arr)):\n            print(1)\n            continue\n    freq = {}\n    for i in arr:\n        if freq.get(i, -1) == -1:\n            freq[i] = 0\n        freq[i] += 1\n    a = list(freq.keys())\n    length = len(a)\n    possible = []\n    for i in a:\n        if (n + 1) * i == summ and freq.get(i) >= 2:\n            possible.append(i)\n    answer = 0\n    if len(possible) == 0:\n        print(0)\n        continue\n    for i in possible:\n        answer = (answer + isUnique(a, length, freq, i, n)) % mod\n        freq[i] += 2\n    print(answer % mod)", "from sys import stdin\nmod = int(1000000000.0) + 7\nfact = [1] * 100001\n\ndef generateFactorials():\n    for i in range(1, 100001):\n        fact[i] = i * fact[i - 1] % mod\ngenerateFactorials()\n\ndef isUnique(a, length, freq, target, n):\n    freq[target] -= 2\n    pairs = 0\n    elements = 2\n    mul = 0\n    deno = 1\n    num = fact[n - 1]\n    for i in range(length):\n        p1 = a[i]\n        p2 = target - a[i]\n        n1 = freq.get(p1)\n        n2 = freq.get(p2, 0)\n        if n1 > 0 and n2 > 0:\n            req = n1\n            if n1 != n2:\n                return 0\n            if p1 != p2:\n                mul = mul + req\n            else:\n                req = req // 2\n            elements += 2 * req\n            deno = deno * fact[req] % mod\n            freq[a[i]] = -1\n            freq[target - a[i]] = -1\n    if elements == 2 * n:\n        return pow(2, mul, mod) * (num * pow(deno, mod - 2, mod)) % mod % mod\n    else:\n        return 0\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    summ = sum(arr)\n    if n == 1:\n        if arr[0] == arr[1]:\n            print(1)\n        else:\n            print(0)\n        continue\n    elif n > 1:\n        check = [0]\n        if [0] == list(set(arr)):\n            print(1)\n            continue\n    freq = {}\n    for i in arr:\n        if freq.get(i, -1) == -1:\n            freq[i] = 0\n        freq[i] += 1\n    a = list(freq.keys())\n    length = len(a)\n    possible = []\n    for i in a:\n        if freq.get(i) >= 2 and (n + 1) * i == summ:\n            possible.append(i)\n    answer = 0\n    if len(possible) == 0:\n        print(0)\n        continue\n    for i in possible:\n        answer = (answer + isUnique(a, length, freq, i, n)) % mod\n        freq[i] += 2\n    print(answer % mod)", "def mod(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nfac = [1]\nmo = 10 ** 9 + 7\nfor i in range(1, 130004):\n    fac.append(i * fac[-1] % mo)\nfrom sys import stdin, stdout\nimport collections\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    li = [int(x) for x in stdin.readline().split()]\n    flag = 0\n    pura = 0\n    z = sum(li)\n    if z == 0:\n        if li.count(0) == 2 * n:\n            print(1)\n            continue\n    if z % (n + 1) == 0:\n        pura = z // (n + 1)\n    else:\n        flag = 1\n    pp = 0\n    if flag == 0:\n        d = collections.Counter(li)\n        d[pura] -= 2\n        if d[pura] < 0:\n            flag = 1\n        elif d[pura] == 0:\n            pp = 1\n            d.pop(pura)\n    if flag == 0:\n        m = pura // 2\n        co = 1\n        ans = fac[n - 1]\n        for i in d.keys():\n            if i > m:\n                if d[pura - i] == d[i]:\n                    co *= fac[d[i]]\n                    co %= mo\n                    ans *= pow(2, d[i], mo)\n                    ans %= mo\n                else:\n                    flag = 1\n                    break\n            elif 2 * i == pura:\n                co *= fac[d[i] // 2]\n                co %= mo\n    if flag == 1:\n        stdout.write(str(0))\n        stdout.write(str('\\n'))\n    else:\n        stdout.write(str(ans * mod(co, mo) % mo))\n        stdout.write(str('\\n'))", "import math\nmod = 10 ** 9 + 7\nfrom sys import stdin, stdout\nfac = [1] * (10 ** 5 + 1)\nifac = [1] * (10 ** 5 + 1)\nfor i in range(1, 100001):\n    fac[i] = fac[i - 1] * i % mod\n    ifac[i] = ifac[i - 1] * pow(i, mod - 2, mod) % mod\nfor _ in range(int(input())):\n    n = int(stdin.readline())\n    l = [int(x) for x in stdin.readline().split()]\n    tot = sum(l) / (n + 1)\n    if math.ceil(tot) != math.floor(tot):\n        stdout.write(str(0) + '\\n')\n        continue\n    tot = int(tot)\n    dic = {}\n    for i in l:\n        if i not in dic:\n            dic[i] = 1\n        else:\n            dic[i] += 1\n    if tot not in dic or dic[tot] < 2:\n        stdout.write(str(0) + '\\n')\n        continue\n    l.remove(tot)\n    l.remove(tot)\n    dic[tot] -= 2\n    if dic[tot] == 0:\n        del dic[tot]\n    d = {}\n    k = 0\n    flag = 0\n    for j in dic:\n        if tot - j not in dic or dic[tot - j] != dic[j]:\n            flag = 1\n            break\n        if j * 2 == tot:\n            k = dic[j] // 2\n            d[j] = k\n        if j < tot - j:\n            d[j] = dic[j]\n    if flag == 1:\n        stdout.write(str(0) + '\\n')\n        continue\n    ans = pow(2, n - 1 - k, mod) * fac[n - 1]\n    for j in d:\n        ans = ans * ifac[d[j]]\n    stdout.write(str(ans % mod) + '\\n')", "from sys import stdin\ninput = stdin.readline\n\ndef bs(arr, l, r, x):\n    if r >= l:\n        mid = l + (r - l) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] > x:\n            return bs(arr, l, mid - 1, x)\n        else:\n            return bs(arr, mid + 1, r, x)\n    else:\n        return -1\nfact = [1]\nmod = 10 ** 9 + 7\nrevm = [1]\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\npower = [1]\nfor i in range(1, 100005):\n    power.append(power[-1] * 2 % mod)\n    fact.append(fact[-1] % mod * i % mod)\n    revm.append(modInverse(fact[i], mod))\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        if a[0] == a[1]:\n            print('1')\n        else:\n            print('0')\n        continue\n    a.sort()\n    un = [a[0]]\n    count = [1]\n    zoo = a[0]\n    for i in range(1, 2 * n):\n        zoo += a[i]\n        if a[i] == un[-1]:\n            count[-1] += 1\n        else:\n            un.append(a[i])\n            count.append(1)\n    tot = []\n    z = 0\n    for i in range(0, 2 * n):\n        if z == 1 or i == 2 * n - 1:\n            z = 0\n            continue\n        if a[i] == a[i + 1] and a[i] not in tot:\n            z = 1\n            if zoo == a[i] * (n + 1):\n                tot.append(a[i])\n    ans = 0\n    for i in range(len(tot)):\n        p = []\n        c = []\n        fl = 0\n        y = bs(un, 0, len(un) - 1, tot[i])\n        count[y] -= 2\n        if count[y] == 0:\n            fl = 1\n        countc = count.copy()\n        an = 1\n        for j in range(len(un)):\n            if count[j] == 0 and un[j] == tot[i] and (fl == 1):\n                continue\n            d = tot[i] - un[j]\n            k = bs(un, 0, len(un) - 1, d)\n            if countc[k] == countc[j] and k != -1:\n                if countc[k] != 0:\n                    if un[j] != d:\n                        p.append([un[j], d])\n                        c.append(countc[j])\n                        (countc[k], countc[j]) = (0, 0)\n                    elif count[j] % 2 == 0:\n                        p.append([un[j], d])\n                        c.append(countc[j] // 2)\n                        (countc[k], countc[j]) = (0, 0)\n                    else:\n                        an = 0\n                        break\n            else:\n                an = 0\n                break\n        if an != 0:\n            xyz = 0\n            xyz1 = 0\n            for l in range(len(c)):\n                xyz1 += c[l]\n                if p[l][0] == p[l][1]:\n                    continue\n                xyz += c[l]\n            an = an % mod * (power[xyz] % mod) % mod\n            an = an % mod * (fact[xyz1] % mod) % mod\n            for l in range(len(c)):\n                an = an * revm[c[l]] % mod\n        ans = (ans % mod + an % mod) % mod\n        count[y] += 2\n    print(ans)", "from sys import stdin\ninput = stdin.readline\n\ndef bs(arr, l, r, x):\n    if r >= l:\n        mid = l + (r - l) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] > x:\n            return bs(arr, l, mid - 1, x)\n        else:\n            return bs(arr, mid + 1, r, x)\n    else:\n        return -1\nfact = [1]\nmod = 10 ** 9 + 7\nrevm = [1]\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\npower = [1]\nfor i in range(1, 100005):\n    power.append(power[-1] * 2 % mod)\n    fact.append(fact[-1] % mod * i % mod)\n    revm.append(modInverse(fact[i], mod))\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        if a[0] == a[1]:\n            print('1')\n        else:\n            print('0')\n        continue\n    a.sort()\n    un = [a[0]]\n    count = [1]\n    zoo = a[0]\n    for i in range(1, 2 * n):\n        zoo += a[i]\n        if a[i] == un[-1]:\n            count[-1] += 1\n        else:\n            un.append(a[i])\n            count.append(1)\n    tot = []\n    z = 0\n    for i in range(0, 2 * n):\n        if z == 1 or i == 2 * n - 1:\n            z = 0\n            continue\n        if a[i] == a[i + 1] and a[i] not in tot:\n            z = 1\n            if zoo == a[i] * (n + 1):\n                tot.append(a[i])\n    ans = 0\n    for i in range(len(tot)):\n        p = []\n        c = []\n        fl = 0\n        y = bs(un, 0, len(un) - 1, tot[i])\n        count[y] -= 2\n        if count[y] == 0:\n            fl = 1\n        countc = count.copy()\n        an = 1\n        for j in range(len(un)):\n            if count[j] == 0 and un[j] == tot[i] and (fl == 1):\n                continue\n            d = tot[i] - un[j]\n            k = bs(un, 0, len(un) - 1, d)\n            if countc[k] == countc[j] and k != -1:\n                if countc[k] != 0:\n                    if un[j] != d:\n                        p.append([un[j], d])\n                        c.append(countc[j])\n                        (countc[k], countc[j]) = (0, 0)\n                    elif count[j] % 2 == 0:\n                        p.append([un[j], d])\n                        c.append(countc[j] // 2)\n                        (countc[k], countc[j]) = (0, 0)\n                    else:\n                        an = 0\n                        break\n            else:\n                an = 0\n                break\n        if an != 0:\n            xyz = 0\n            xyz1 = 0\n            for l in range(len(c)):\n                xyz1 += c[l]\n                if p[l][0] == p[l][1]:\n                    continue\n                xyz += c[l]\n            an = an % mod * (power[xyz] % mod) % mod\n            an = an % mod * (fact[xyz1] % mod) % mod\n            for l in range(len(c)):\n                an = an * revm[c[l]] % mod\n        ans = (ans % mod + an % mod) % mod\n        count[y] += 2\n    print(ans)", "from collections import defaultdict\nfrom collections import Counter\nimport sys\nMOD = 10 ** 9 + 7\nmaxN = 10 ** 5 + 1\n\ndef power(x, y):\n    res = 1\n    x = x % MOD\n    while y > 0:\n        if y % 2:\n            res = res * x % MOD\n        y //= 2\n        x = x * x % MOD\n    return res\n\ndef modInverse(n):\n    return power(n, MOD - 2)\nfac = [1] * maxN\npower2 = [1] * maxN\nfacInverse = [1] * maxN\nfor i in range(1, maxN):\n    fac[i] = fac[i - 1] * i % MOD\n    facInverse[i] = facInverse[i - 1] * modInverse(i) % MOD\n    power2[i] = power2[i - 1] * 2 % MOD\n\ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n = int(sys.stdin.readline())\n        A = list(map(int, sys.stdin.readline().split()))\n        if n == 1:\n            if A[0] == A[1]:\n                print(1)\n            else:\n                print(0)\n            continue\n        s = 0\n        M = Counter(A)\n        s = sum(A) // (n + 1)\n        if M[s] < 2:\n            print(0)\n            continue\n        else:\n            M[s] -= 2\n        ans = fac[n - 1]\n        currentLen = 0\n        howmany2 = 0\n        for (a, Ma) in M.items():\n            if Ma <= 0:\n                continue\n            b = s - a\n            if a == b:\n                if Ma % 2:\n                    ans = 0\n                    break\n                else:\n                    r = Ma // 2\n                    ans = ans * facInverse[r] % MOD\n            elif Ma == M[b]:\n                r = Ma\n                ans = ans * facInverse[r] % MOD\n                howmany2 += r\n                M[b] = 0\n            else:\n                ans = 0\n                break\n        ans = ans * power2[howmany2] % MOD\n        print(ans)\nmain()", "from collections import defaultdict\nmod = 10 ** 9 + 7\nmaxn = 0\nqueries = []\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    x = list(map(int, input().split()))\n    maxn = max(n, maxn)\n    queries.append(x)\npre = [1] * (maxn + 1)\nfor i in range(2, maxn + 1):\n    pre[i] = pre[i - 1] * i % mod\n\ndef solve(n, x):\n    if n == 1:\n        if x[0] == x[1]:\n            return 1\n        else:\n            return 0\n    else:\n        su = sum(x) // (n + 1)\n        new_x = []\n        count = 0\n        for i in x:\n            if i != su or count >= 2:\n                new_x.append(i)\n            else:\n                count += 1\n        if count != 2:\n            return 0\n        m = defaultdict(int)\n        for i in new_x:\n            m[i] += 1\n        visited = defaultdict(int)\n        two_power = 0\n        found = False\n        for i in new_x:\n            if su - i in m and m[su - i] > 0 and (m[i] > 0):\n                if m[su - i] != m[i]:\n                    found = True\n                    break\n                a = i\n                b = su - i\n                if i != su - i:\n                    two_power += 1\n                if a > b:\n                    (a, b) = (b, a)\n                visited[a, b] += 1\n                m[su - i] -= 1\n                m[i] -= 1\n                if m[su - i] == 0:\n                    del m[su - i]\n                if i in m and m[i] == 0:\n                    del m[i]\n        if len(m) != 0 or found:\n            return 0\n        ans = pre[n - 1]\n        for i in visited.values():\n            if i > 1:\n                ans = ans * pow(pre[i], mod - 2, mod) % mod\n        ans = ans * pow(2, two_power, mod) % mod\n        return ans\nfor i in queries:\n    print(solve(len(i) // 2, i))", "from collections import defaultdict\nmod = 10 ** 9 + 7\nmaxn = 0\nqueries = []\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    x = list(map(int, input().split()))\n    maxn = max(n, maxn)\n    queries.append(x)\npre = [1] * (maxn + 1)\nfor i in range(2, maxn + 1):\n    pre[i] = pre[i - 1] * i % mod\n\ndef solve(n, x):\n    if n == 1:\n        if x[0] == x[1]:\n            return 1\n        else:\n            return 0\n    else:\n        su = sum(x) // (n + 1)\n        new_x = []\n        count = 0\n        for i in x:\n            if i != su or count >= 2:\n                new_x.append(i)\n            else:\n                count += 1\n        if count != 2:\n            return 0\n        m = defaultdict(int)\n        for i in new_x:\n            m[i] += 1\n        visited = defaultdict(int)\n        two_power = 0\n        found = False\n        for i in new_x:\n            if su - i in m and m[su - i] > 0 and (m[i] > 0):\n                if m[su - i] != m[i]:\n                    found = True\n                    break\n                a = i\n                b = su - i\n                if i != su - i:\n                    two_power += 1\n                if a > b:\n                    (a, b) = (b, a)\n                visited[a, b] += 1\n                m[su - i] -= 1\n                m[i] -= 1\n                if m[su - i] == 0:\n                    del m[su - i]\n                if i in m and m[i] == 0:\n                    del m[i]\n        if len(m) != 0 or found:\n            return 0\n        ans = pre[n - 1]\n        for i in visited.values():\n            if i > 1:\n                ans = ans * pow(pre[i], mod - 2, mod) % mod\n        ans = ans * pow(2, two_power, mod) % mod\n        return ans\nfor i in queries:\n    print(solve(len(i) // 2, i))", "from collections import defaultdict\nmod = 10 ** 9 + 7\nmaxn = 0\nqueries = []\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    x = list(map(int, input().split()))\n    maxn = max(n, maxn)\n    queries.append(x)\npre = [1] * (maxn + 1)\nfor i in range(2, maxn + 1):\n    pre[i] = pre[i - 1] * i % mod\n\ndef solve(n, x):\n    if n == 1:\n        if x[0] == x[1]:\n            return 1\n        else:\n            return 0\n    else:\n        su = sum(x) // (n + 1)\n        new_x = []\n        count = 0\n        for i in x:\n            if i != su or count >= 2:\n                new_x.append(i)\n            else:\n                count += 1\n        if count != 2:\n            return 0\n        m = defaultdict(int)\n        for i in new_x:\n            m[i] += 1\n        visited = defaultdict(int)\n        two_power = 0\n        found = False\n        for i in new_x:\n            if su - i in m and m[su - i] > 0 and (m[i] > 0):\n                if m[su - i] != m[i]:\n                    found = True\n                    break\n                a = i\n                b = su - i\n                if i != su - i:\n                    two_power += 1\n                if a > b:\n                    (a, b) = (b, a)\n                visited[a, b] += 1\n                m[su - i] -= 1\n                m[i] -= 1\n                if m[su - i] == 0:\n                    del m[su - i]\n                if i in m and m[i] == 0:\n                    del m[i]\n        if len(m) != 0 or found:\n            return 0\n        ans = pre[n - 1]\n        for i in visited.values():\n            if i > 1:\n                ans = ans * pow(pre[i], mod - 2, mod) % mod\n        ans = ans * pow(2, two_power, mod) % mod\n        return ans\nfor i in queries:\n    print(solve(len(i) // 2, i))", "from collections import defaultdict\nmod = 10 ** 9 + 7\nmaxn = 0\nqueries = []\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    x = list(map(int, input().split()))\n    maxn = max(n, maxn)\n    queries.append(x)\npre = [1] * (maxn + 1)\nfor i in range(2, maxn + 1):\n    pre[i] = pre[i - 1] * i % mod\n\ndef solve(n, x):\n    if n == 1:\n        if x[0] == x[1]:\n            return 1\n        else:\n            return 0\n    else:\n        su = sum(x) // (n + 1)\n        new_x = []\n        count = 0\n        for i in x:\n            if i != su or count >= 2:\n                new_x.append(i)\n            else:\n                count += 1\n        if count != 2:\n            return 0\n        m = defaultdict(int)\n        for i in new_x:\n            m[i] += 1\n        visited = defaultdict(int)\n        two_power = 0\n        found = False\n        for i in new_x:\n            if su - i in m and m[su - i] > 0 and (m[i] > 0):\n                if m[su - i] != m[i]:\n                    found = True\n                    break\n                a = i\n                b = su - i\n                if i != su - i:\n                    two_power += 1\n                if a > b:\n                    (a, b) = (b, a)\n                visited[a, b] += 1\n                m[su - i] -= 1\n                m[i] -= 1\n                if m[su - i] == 0:\n                    del m[su - i]\n                if i in m and m[i] == 0:\n                    del m[i]\n        if len(m) != 0 or found:\n            return 0\n        ans = pre[n - 1]\n        for i in visited.values():\n            if i > 1:\n                ans = ans * pow(pre[i], mod - 2, mod) % mod\n        ans = ans * pow(2, two_power, mod) % mod\n        return ans\nfor i in queries:\n    print(solve(len(i) // 2, i))", "from collections import defaultdict\nmod = 10 ** 9 + 7\nmaxn = 0\nqueries = []\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    x = list(map(int, input().split()))\n    maxn = max(n, maxn)\n    queries.append(x)\npre = [1] * (maxn + 1)\nfor i in range(2, maxn + 1):\n    pre[i] = pre[i - 1] * i % mod\n\ndef solve(n, x):\n    if n == 1:\n        if x[0] == x[1]:\n            return 1\n        else:\n            return 0\n    else:\n        su = sum(x) // (n + 1)\n        new_x = []\n        count = 0\n        for i in x:\n            if i != su or count >= 2:\n                new_x.append(i)\n            else:\n                count += 1\n        if count != 2:\n            return 0\n        m = defaultdict(int)\n        for i in new_x:\n            m[i] += 1\n        visited = defaultdict(int)\n        two_power = 0\n        found = False\n        for i in new_x:\n            if su - i in m and m[su - i] > 0 and (m[i] > 0):\n                if m[su - i] != m[i]:\n                    found = True\n                    break\n                a = i\n                b = su - i\n                if i != su - i:\n                    two_power += 1\n                if a > b:\n                    (a, b) = (b, a)\n                visited[a, b] += 1\n                m[su - i] -= 1\n                m[i] -= 1\n                if m[su - i] == 0:\n                    del m[su - i]\n                if i in m and m[i] == 0:\n                    del m[i]\n        if len(m) != 0 or found:\n            return 0\n        ans = pre[n - 1]\n        for i in visited.values():\n            if i > 1:\n                ans = ans * pow(pre[i], mod - 2, mod) % mod\n        ans = ans * pow(2, two_power, mod) % mod\n        return ans\nfor i in queries:\n    print(solve(len(i) // 2, i))", "import sys\nimport time\nmod = 1000000007\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef modInv(s):\n    return power(s, mod - 2, mod)\nstart = time.time()\nfact = [0] * 100005\nfact[0] = 1\nfor i in range(1, len(fact)):\n    fact[i] = i * fact[i - 1] % mod\nfor _ in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    summ = sum(a)\n    a.sort()\n    asum = 0\n    flag = False\n    for i in range(2 * n - 1):\n        if a[i] == a[i + 1]:\n            if a[i] != 0 and summ == a[i] * (n + 1):\n                asum = a[i]\n                a[i] = '$'\n                a[i + 1] = '$'\n                flag = True\n                break\n            if a[i] == 0 and summ == 0:\n                asum = a[i]\n                a[i] = '$'\n                a[i + 1] = '$'\n                flag = True\n                break\n    if flag:\n        l = 0\n        r = 2 * n - 1\n        cnt = 0\n        cnt1 = 0\n        pairs = []\n        while l < r:\n            if a[l] == '$':\n                l += 1\n                continue\n            if a[r] == '$':\n                r -= 1\n                continue\n            if a[l] + a[r] == asum:\n                cnt += 1\n                if a[l] == a[r]:\n                    cnt1 += 1\n                pairs.append((a[l], a[r]))\n                r -= 1\n                l += 1\n            elif a[l] + a[r] > asum:\n                r -= 1\n            else:\n                l += 1\n        if len(pairs) == n - 1:\n            mapp = {}\n            for item in pairs:\n                if item not in mapp:\n                    mapp[item] = 1\n                else:\n                    mapp[item] += 1\n            y = 1\n            for i in mapp:\n                y = y * fact[mapp[i]] % mod\n            if n == 1:\n                print(1)\n            else:\n                res = fact[n - 1] * modInv(y) * power(2, cnt - cnt1, mod) % mod\n                sys.stdout.write(str(res) + '\\n')\n        else:\n            print(0)\n    else:\n        print(0)\nend = time.time()", "import sys\nfrom collections import defaultdict\nN = 10 ** 5\nfact = [0] * (N + 1)\nfact[0] = 1\n\ndef power(a, b):\n    ans = 1\n    while b > 0:\n        if b & 1:\n            ans = ans * a % 1000000007\n        b = b >> 1\n        a = a * a % 1000000007\n    return ans % 1000000007\nfor i in range(1, N + 1):\n    fact[i] = fact[i - 1] % 1000000007 * (i % 1000000007) % 1000000007\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    myMap = defaultdict(int)\n    hashTable = defaultdict(int)\n    arr = [int(x) for x in sys.stdin.readline().split()]\n    mySet = set()\n    sum_ = 0\n    for ele in arr:\n        sum_ += ele\n        myMap[ele] += 1\n        mySet.add(ele)\n    pref = sum_ // (n + 1)\n    if myMap[pref] < 2:\n        print('0')\n        continue\n    myMap[0] += 2\n    flag = False\n    for ele in mySet:\n        if myMap[ele] != myMap[pref - ele]:\n            flag = True\n            break\n    if flag:\n        print('0')\n        continue\n    if n == 1:\n        print('1')\n        continue\n    myMap[pref] -= 2\n    myMap[0] -= 2\n    A = []\n    for i in range(len(arr)):\n        if hashTable[arr[i]] == 1:\n            continue\n        if pref % 2 == 0 and pref == 2 * arr[i]:\n            A.append(myMap[arr[i]] // 2)\n        elif myMap[arr[i]] > 1:\n            A.append(myMap[arr[i]])\n        hashTable[arr[i]] = 1\n        hashTable[pref - arr[i]] = 1\n    x = 1\n    if pref % 2 == 0:\n        x += myMap[pref // 2] // 2\n    result = fact[n - 1] * pow(2, n - x) % 1000000007\n    for ele in A:\n        result = result * power(fact[ele], 1000000007 - 2) % 1000000007\n    print(result)", "MOD = 1000000007\nfactorial = [1 for _ in range(1000010)]\nfor i in range(1, len(factorial)):\n    factorial[i] = i * factorial[i - 1] % MOD\n\ndef modinv(n):\n    return pow(n, MOD - 2, MOD)\n\ndef moddiv(n, d):\n    return n * modinv(d) % MOD\n\ndef can_be_total(T, frequencies, L):\n    if frequencies[T] < 0:\n        return False\n    matches = 0\n    for a in frequencies:\n        if a == T and frequencies[a] == 0:\n            continue\n        b = T - a\n        if b not in frequencies:\n            return False\n        if a > b:\n            continue\n        elif a == b:\n            if frequencies[a] % 2 == 1:\n                return False\n            else:\n                matches += frequencies[a] // 2\n        elif a < b:\n            if frequencies[a] != frequencies[b]:\n                return False\n            else:\n                matches += frequencies[a]\n    return matches == L\n\ndef solve(X):\n    if len(X) < 2:\n        return 0\n    if len(X) == 2:\n        if X[0] == X[1]:\n            return 1\n        else:\n            return 0\n    frequencies = {}\n    for x in X:\n        if x not in frequencies:\n            frequencies[x] = 1\n        else:\n            frequencies[x] += 1\n    L = len(X) // 2 - 1\n    T = None\n    P = 0\n    for n in frequencies:\n        frequencies[n] -= 2\n        if can_be_total(n, frequencies, L):\n            T = n\n            break\n        frequencies[n] += 2\n    if T is None:\n        return 0\n    result = factorial[L]\n    for a in frequencies:\n        if frequencies[a] <= 0:\n            continue\n        b = T - a\n        if a > b:\n            continue\n        if a == b:\n            if frequencies[a] > 2:\n                pairs = frequencies[a] // 2\n                result = moddiv(result, factorial[pairs])\n        if a != b:\n            if frequencies[a] > 1:\n                result = moddiv(result, factorial[frequencies[a]])\n            result = result * pow(2, frequencies[a], MOD) % MOD\n    return result\n\ndef main():\n    import sys\n    test_cases = int(sys.stdin.readline().strip())\n    for _ in range(test_cases):\n        N = int(sys.stdin.readline().strip())\n        X = [int(i) for i in sys.stdin.readline().strip().split()]\n        print(solve(X))\nmain()", "import sys\nfrom collections import defaultdict\nmod = 1000000007\nX = 10 ** 5\n\ndef factCal(n):\n    f = [0] * (n + 1)\n    f[0] = 1\n    for i in range(1, n + 1):\n        f[i] = f[i - 1] % mod * (i % mod) % mod\n    return f\nfact = factCal(X)\n\ndef pw(x, y):\n    res = 1\n    while y > 0:\n        if y & 1:\n            res = res * x % mod\n        y = y >> 1\n        x = x * x % mod\n    return res % mod\nfor _ in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    a = [int(i) for i in sys.stdin.readline().split()]\n    m = defaultdict(int)\n    h = defaultdict(int)\n    s = sum(a)\n    for i in range(len(a)):\n        if a[i] not in m:\n            m[a[i]] = 1\n        else:\n            m[a[i]] += 1\n    ls = list(set(a))\n    pref = s // (n + 1)\n    if m[pref] < 2:\n        print(0)\n        continue\n    m[0] += 2\n    f = 0\n    for i in range(len(ls)):\n        if m[ls[i]] != m[pref - ls[i]]:\n            f = 1\n            break\n    if f == 1:\n        print(0)\n        continue\n    if n == 1:\n        print(1)\n        continue\n    m[pref] -= 2\n    m[0] -= 2\n    cas = []\n    for i in range(len(a)):\n        if h[a[i]] == 1:\n            continue\n        if pref % 2 == 0 and pref == 2 * a[i]:\n            cas.append(m[a[i]] // 2)\n        elif m[a[i]] > 1:\n            cas.append(m[a[i]])\n        h[a[i]] = 1\n        h[pref - a[i]] = 1\n    x = 1\n    if pref % 2 == 0:\n        x = x + m[pref // 2] // 2\n    ans = fact[n - 1] * pw(2, n - x) % mod\n    for i in range(len(cas)):\n        ans = ans * pw(fact[cas[i]], mod - 2) % mod\n    print(ans)", "from sys import stdin\nmod = 1000000007\n\ndef highestPower(a, p):\n    z = 0\n    while a:\n        a //= p\n        z += a\n    return z\n\ndef power(mul, p):\n    r = 1\n    while p:\n        if p % 2:\n            r *= mul\n            r %= mod\n            p -= 1\n        mul = mul * mul % mod\n        p /= 2\n    return r\n\ndef genPrimes(lim, primeList):\n    i = 2\n    primeList[0] = 1000000\n    primeList[1] = 1000000\n    while i * i < lim:\n        j = i\n        while i * j < lim:\n            primeList[i * j] = 1000000\n            j += 1\n        i += 1\nprimes = []\nfor i in range(1000000):\n    primes.append(0)\ngenPrimes(1000000, primes)\nfor __ in range(int(stdin.readline().split()[0])):\n    n = int(stdin.readline().split()[0])\n    x = list(map(int, stdin.readline().split()))\n    sum_ = sum(x) // (n + 1)\n    if (n + 1) * sum_ != sum(x):\n        print('0')\n        continue\n    x.sort()\n    i = 0\n    twos = n - 1\n    found = False\n    res = 1\n    end = 2 * n - 1\n    eq_list = []\n    while i < end:\n        if not found and x[i] == sum_:\n            found = True\n            if x[i + 1] != sum_:\n                res = 0\n                break\n            i += 2\n        elif not found and x[end] == sum_:\n            found = True\n            if x[end - 1] != sum_:\n                res = 0\n                break\n            end -= 2\n        if i >= end:\n            break\n        if x[i] + x[end] != sum_:\n            res = 0\n            break\n        j = 1\n        while i < end and x[i] == x[i + 1]:\n            if x[i] + x[end] != sum_:\n                res = 0\n                i = end + 1\n                break\n            j += 1\n            i += 1\n            end -= 1\n        if i >= end:\n            j -= 1\n        if x[i] * 2 == sum_:\n            twos -= j\n        if j > 1:\n            eq_list.append(j)\n        i += 1\n        end -= 1\n    if not found:\n        res = 0\n    if res:\n        for s in range(2, n):\n            if primes[s] < 1000000:\n                primes[s] = highestPower(n - 1, s)\n        eq_list.sort()\n        eq_len = len(eq_list) - 1\n        while eq_len >= 0:\n            occ = 1\n            while eq_len - 1 >= 0 and eq_list[eq_len] == eq_list[eq_len - 1]:\n                eq_len -= 1\n                occ += 1\n            for s in range(2, eq_list[eq_len] + 1):\n                if primes[s] < 1000000:\n                    primes[s] -= occ * highestPower(eq_list[eq_len], s)\n            eq_len -= 1\n        for s in range(2, n):\n            if primes[s] < 1000000:\n                res *= power(s, primes[s])\n                res %= mod\n        res *= power(2, twos)\n    res %= mod\n    print(res)", "from collections import defaultdict\nimport sys\nM = 1000000007\n\ndef modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nfact = [1 for i in range(100001)]\nfor i in range(2, 100001):\n    fact[i] = fact[i - 1] * i\n    fact[i] %= M\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    x = list(map(int, sys.stdin.readline().split(' ')))\n    if n == 1:\n        if x[0] != x[1]:\n            print(0)\n        else:\n            print(1)\n        continue\n    x.sort()\n    s = sum(x)\n    if s % (n + 1) == 0:\n        m = sum(x) // (n + 1)\n    else:\n        print(0)\n        continue\n    d = defaultdict(lambda : 0)\n    flag = 1\n    try:\n        x.remove(m)\n        x.remove(m)\n    except:\n        print(0)\n        continue\n    count = 0\n    for i in range(n - 1):\n        if x[2 * n - 3 - i] + x[i] != m:\n            flag = 0\n            break\n        if x[i] != m - x[i]:\n            count += 1\n        d[x[i]] += 1\n    if flag == 0:\n        print(0)\n        continue\n    res = fact[n - 1]\n    for key in d:\n        val = modInverse(fact[d[key]], M)\n        res = res * val % M\n    res = res * pow(2, count) % M\n    print(res)", "from sys import stdin, stdout\n\ndef calculate_permutations(List, fact, n):\n    answer = fact[n - 1]\n    denominator = 1\n    count = {}\n    count_elements(List, count)\n    for x in count:\n        denominator *= pow(fact[x], count[x], m)\n        denominator %= m\n    answer *= pow(denominator, m - 2, m)\n    return answer % m\n\ndef check_for_no_solution(count, sum_A):\n    for x in count:\n        if x == sum_A and count[x] < 0:\n            return True\n        if x != sum_A:\n            if sum_A - x not in count or count[x] != count[sum_A - x]:\n                return True\n    return False\n\ndef count_elements(A, count):\n    for i in A:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\ndef remove_complements(count, sum_A, List):\n    if count[sum_A] == 0:\n        del count[sum_A]\n    mid_count = 0\n    for x in count:\n        if x == sum_A - x:\n            count[x] //= 2\n            mid_count = count[x]\n        elif count[sum_A - x] * count[x] != 0:\n            count[x] = 0\n        if count[x] > 1:\n            List.append(count[x])\n    return mid_count\n\ndef main():\n    fact = [1 for x in range(10 ** 5 + 1)]\n    for i in range(2, 10 ** 5 + 1):\n        fact[i] = fact[i - 1] * i % m\n    t = int(stdin.readline())\n    for test in range(t):\n        n = int(stdin.readline())\n        X = [int(x) for x in stdin.readline().split()]\n        sum_A = sum(X) / (n + 1)\n        count = {sum_A: 0}\n        count_elements(X, count)\n        count[sum_A] -= 2\n        if check_for_no_solution(count, sum_A):\n            print(0)\n            continue\n        List = []\n        mid_count = remove_complements(count, sum_A, List)\n        answer = pow(2, n - 1 - mid_count, m)\n        answer *= calculate_permutations(List, fact, n)\n        answer %= m\n        print(answer)\nm = 10 ** 9 + 7\nmain()", "import math\nimport sys\nmod = 1000000007\nfor _ in range(int(sys.stdin.readline())):\n    num = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    s = sum(a) // (num + 1)\n    if a.count(s) >= 2:\n        d = {}\n        a = sorted(a)\n        a.remove(s)\n        a.remove(s)\n        n = 2 * num - 2\n        flag = True\n        c = 0\n        for i in range(n // 2):\n            f = min(a[i], a[n - i - 1])\n            l = max(a[n - i - 1], a[i])\n            if f + l == s:\n                if f != l:\n                    c += 1\n                if d.get((f, l)) == None:\n                    d[f, l] = 1\n                else:\n                    d[f, l] += 1\n            else:\n                flag = False\n                sys.stdout.write('0\\n')\n                break\n        ans = math.factorial(num - 1) % mod\n        if flag:\n            for i in d:\n                ans = ans * pow(math.factorial(d[i]), mod - 2, mod)\n                ans %= mod\n            ans = ans * pow(2, c, mod)\n            ans %= mod\n            sys.stdout.write(str(ans) + '\\n')\n    else:\n        sys.stdout.write('0\\n')", "import sys\nfrom collections import defaultdict\nN = 10 ** 5\nfact = [0] * (N + 1)\nfact[0] = 1\n\ndef power(a, b):\n    ans = 1\n    while b > 0:\n        if b & 1:\n            ans = ans * a % 1000000007\n        b = b >> 1\n        a = a * a % 1000000007\n    return ans % 1000000007\nfor i in range(1, N + 1):\n    fact[i] = fact[i - 1] % 1000000007 * (i % 1000000007) % 1000000007\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    myMap = defaultdict(int)\n    hashTable = defaultdict(int)\n    arr = [int(x) for x in sys.stdin.readline().split()]\n    mySet = set()\n    sum_ = 0\n    for ele in arr:\n        sum_ += ele\n        myMap[ele] += 1\n        mySet.add(ele)\n    pref = sum_ // (n + 1)\n    if myMap[pref] < 2:\n        print('0')\n        continue\n    myMap[0] += 2\n    flag = False\n    for ele in mySet:\n        if myMap[ele] != myMap[pref - ele]:\n            flag = True\n            break\n    if flag:\n        print('0')\n        continue\n    if n == 1:\n        print('1')\n        continue\n    myMap[pref] -= 2\n    myMap[0] -= 2\n    A = []\n    for i in range(len(arr)):\n        if hashTable[arr[i]] == 1:\n            continue\n        if pref % 2 == 0 and pref == 2 * arr[i]:\n            A.append(myMap[arr[i]] // 2)\n        elif myMap[arr[i]] > 1:\n            A.append(myMap[arr[i]])\n        hashTable[arr[i]] = 1\n        hashTable[pref - arr[i]] = 1\n    x = 1\n    if pref % 2 == 0:\n        x += myMap[pref // 2] // 2\n    result = fact[n - 1] * pow(2, n - x) % 1000000007\n    for ele in A:\n        result = result * power(fact[ele], 1000000007 - 2) % 1000000007\n    print(result)"]