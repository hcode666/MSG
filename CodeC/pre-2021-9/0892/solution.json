["mod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef ncr(n, r):\n    return mul(fact[n], mul(pow(fact[n - r], mod - 2, mod), pow(fact[r], mod - 2, mod)))\n\ndef answer():\n    ca1 = a.count('1')\n    cb1 = b.count('1')\n    o = abs(ca1 - cb1)\n    stop = abs(min(ca1, cb1) - min(n - ca1, n - cb1))\n    ans = 0\n    for i in range(n - o, stop - 1, -2):\n        ans = add(ans, ncr(n, i))\n    return ans\nfact = [1]\nfor i in range(1, 10 ** 5 + 1):\n    fact.append(mul(fact[-1], i))\nfor T in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    print(answer())", "mod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef ncr(n, r):\n    return mul(fact[n], mul(pow(fact[n - r], mod - 2, mod), pow(fact[r], mod - 2, mod)))\n\ndef answer():\n    ca1 = a.count('1')\n    cb1 = b.count('1')\n    o = abs(ca1 - cb1)\n    stop = abs(min(ca1, cb1) - min(n - ca1, n - cb1))\n    ans = 0\n    for i in range(n - o, stop - 1, -2):\n        ans = add(ans, ncr(n, i))\n    return ans\nfact = [1]\nfor i in range(1, 10 ** 5 + 1):\n    fact.append(mul(fact[-1], i))\nfor T in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    print(answer())", "mod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef ncr(n, r):\n    return mul(fact[n], mul(pow(fact[n - r], mod - 2, mod), pow(fact[r], mod - 2, mod)))\n\ndef answer():\n    ca1 = a.count('1')\n    cb1 = b.count('1')\n    o = abs(ca1 - cb1)\n    stop = abs(min(ca1, cb1) - min(n - ca1, n - cb1))\n    ans = 0\n    for i in range(n - o, stop - 1, -2):\n        ans = add(ans, ncr(n, i))\n    return ans\nfact = [1]\nfor i in range(1, 10 ** 5 + 1):\n    fact.append(mul(fact[-1], i))\nfor T in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    print(answer())", "mod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef ncr(n, r):\n    return mul(fact[n], mul(pow(fact[n - r], mod - 2, mod), pow(fact[r], mod - 2, mod)))\n\ndef answer():\n    ca1 = a.count('1')\n    cb1 = b.count('1')\n    o = abs(ca1 - cb1)\n    stop = abs(min(ca1, cb1) - min(n - ca1, n - cb1))\n    ans = 0\n    for i in range(n - o, stop - 1, -2):\n        ans = add(ans, ncr(n, i))\n    return ans\nfact = [1]\nfor i in range(1, 10 ** 5 + 1):\n    fact.append(mul(fact[-1], i))\nfor T in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    print(answer())", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nmod = 10 ** 9 + 7\nfact = [1]\nfor i in range(1, 10 ** 6 + 1):\n    x = fact[-1]\n    y = x * i % mod\n    fact.append(y)\nfor _ in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    (a1, b1) = (a.count('1'), b.count('1'))\n    a0 = [n - a1, a1]\n    b0 = [n - b1, b1]\n    ma = min(n - a1, b1) + min(n - b1, a1)\n    res = 0\n    for i in range(ma, ma - 2 * min(min(n - a1, b1), min(n - b1, a1)) - 1, -2):\n        p = n\n        q = n - i\n        r = i\n        res += fact[p] % mod * modInverse(fact[q], mod) * modInverse(fact[r], mod)\n        res = res % mod\n    print(res)", "f = []\nf.append(1)\nfor z in range(1, 100001):\n    f.append(z % 1000000007 * (f[z - 1] % 1000000007) % 1000000007)\nT = int(input(''))\nwhile T:\n    n = int(input())\n    A = input()\n    B = input()\n    a1 = int(A.count('1'))\n    b1 = int(B.count('1'))\n    c = int(0)\n    m = 1000000007\n    if a1 == b1:\n        c = 1\n    if a1 == n and b1 == 0 or (a1 == 0 and b1 == n):\n        print(1)\n        continue\n    x = int(a1 + b1)\n    if b1 <= n - a1:\n        x = x\n    else:\n        x = 2 * n - x\n    if (a1 + b1) % 2 == 0:\n        for i in range(max(2, abs(a1 - b1)), x + 1, 2):\n            c = c + f[n] % m * pow(f[n - i] * f[i] % 1000000007, m - 2, m) % m\n            c = c % m\n    else:\n        for i in range(max(1, abs(a1 - b1)), x + 1, 2):\n            c = c + f[n] % m * pow(f[n - i] * f[i] % 1000000007, m - 2, m) % m\n            c = c % m\n    print(c)\n    T = T - 1", "f = []\nf.append(1)\nfor z in range(1, 100001):\n    f.append(z % 1000000007 * (f[z - 1] % 1000000007) % 1000000007)\nT = int(input(''))\nwhile T:\n    n = int(input())\n    A = input()\n    B = input()\n    a1 = int(A.count('1'))\n    b1 = int(B.count('1'))\n    c = int(0)\n    m = 1000000007\n    if a1 == b1:\n        c = 1\n    if a1 == n and b1 == 0 or (a1 == 0 and b1 == n):\n        print(1)\n        continue\n    x = int(a1 + b1)\n    if b1 <= n - a1:\n        x = x\n    else:\n        x = 2 * n - x\n    if (a1 + b1) % 2 == 0:\n        for i in range(max(2, abs(a1 - b1)), x + 1, 2):\n            c = c + f[n] % m * pow(f[n - i] * f[i] % 1000000007, m - 2, m) % m\n            c = c % m\n    else:\n        for i in range(max(1, abs(a1 - b1)), x + 1, 2):\n            c = c + f[n] % m * pow(f[n - i] * f[i] % 1000000007, m - 2, m) % m\n            c = c % m\n    print(c)\n    T = T - 1", "f = []\nf.append(1)\nfor z in range(1, 100001):\n    f.append(z % 1000000007 * (f[z - 1] % 1000000007) % 1000000007)\nT = int(input())\nwhile T:\n    n = int(input())\n    A = input()\n    B = input()\n    a1 = int(A.count('1'))\n    b1 = int(B.count('1'))\n    c = int(0)\n    m = 1000000007\n    if a1 == b1:\n        c = 1\n    if a1 == n and b1 == 0 or (a1 == 0 and b1 == n):\n        print(1)\n        continue\n    x = int(a1 + b1)\n    if b1 <= n - a1:\n        x = x\n    else:\n        x = 2 * n - x\n    if (a1 + b1) % 2 == 0:\n        for i in range(max(2, abs(a1 - b1)), x + 1, 2):\n            c = c + f[n] % m * pow(f[n - i] * f[i] % 1000000007, m - 2, m) % m\n            c = c % m\n    else:\n        for i in range(max(1, abs(a1 - b1)), x + 1, 2):\n            c = c + f[n] % m * pow(f[n - i] * f[i] % 1000000007, m - 2, m) % m\n            c = c % m\n    print(c)\n    T = T - 1", "import math\nimport random\nimport sys\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter, defaultdict, deque\nfrom functools import lru_cache, reduce\nfrom heapq import heapify, heappop, heappush\nfrom itertools import chain, combinations, combinations_with_replacement, permutations\n(MAX_INT, MOD, fact, ifact) = (2 ** 62 - 1, 10 ** 9 + 7, [1] * (10 ** 6 + 1), [1] * (10 ** 6 + 1))\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nwrite = sys.stdout.write\nfor i in range(1, len(fact)):\n    fact[i] = i * fact[i - 1] % MOD\nifact[-1] = pow(fact[-1], MOD - 2, MOD)\nfor i in range(1, len(fact) - 1)[::-1]:\n    ifact[i] = ifact[i + 1] * (i + 1) % MOD\n\ndef nCr(n, i):\n    return fact[n] * ifact[i] % MOD * ifact[n - i] % MOD\n\ndef solve(n, a, b):\n    (a1, b1) = (a.count('1'), b.count('1'))\n    (L, R, ans) = (abs(a1 - b1), n - abs(a1 + b1 - n), 0)\n    for i in range(L, R + 1, 2):\n        ans = (ans + nCr(n, i)) % MOD\n    print(ans)\ntest_num = int(input())\nfor _ in range(test_num):\n    n = int(input())\n    (a, b) = (input(), input())\n    solve(n, a, b)", "import math\nimport random\nimport sys\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter, defaultdict, deque\nfrom functools import lru_cache, reduce\nfrom heapq import heapify, heappop, heappush\nfrom itertools import chain, combinations, combinations_with_replacement, permutations\nMAX_INT = 2 ** 62 - 1\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nwrite = sys.stdout.write\nMOD = 10 ** 9 + 7\nfact = [1] * (10 ** 6 + 1)\nfor i in range(1, len(fact)):\n    fact[i] = i * fact[i - 1] % MOD\nifact = [1] * (10 ** 6 + 1)\nifact[-1] = pow(fact[-1], MOD - 2, MOD)\nfor i in range(1, len(fact) - 1)[::-1]:\n    ifact[i] = ifact[i + 1] * (i + 1) % MOD\n\ndef nCr(n, i):\n    return fact[n] * ifact[i] % MOD * ifact[n - i] % MOD\n\ndef solve(n, a, b):\n    (a1, b1) = (a.count('1'), b.count('1'))\n    (L, R) = (abs(a1 - b1), n - abs(a1 + b1 - n))\n    ans = 0\n    for i in range(L, R + 1, 2):\n        ans = (ans + nCr(n, i)) % MOD\n    print(ans)\ntest_num = int(input())\nfor _ in range(test_num):\n    n = int(input())\n    (a, b) = (input(), input())\n    solve(n, a, b)", "import math, sys\nfrom collections import Counter, defaultdict, deque\nfrom sys import stdin, stdout\ninput = stdin.readline\nlili = lambda : list(map(int, sys.stdin.readlines()))\nli = lambda : list(map(int, input().split()))\nI = lambda : int(input())\nS = lambda : input().strip()\nmod = 1000000007\nfact = 100001 * [0]\n\ndef power(a, b, m):\n    result = 1\n    a = a % m\n    while b > 0:\n        if b & 1:\n            result = (result % mod * a % mod % mod + mod) % mod\n        b = b >> 1\n        a = (a % mod * a % mod % mod + mod) % mod\n    return int(result)\n\ndef modInverse(n, p):\n    return int(power(n, p - 2, p) % mod)\n\ndef NcrModp(n, r, m):\n    if r == 0 or r == n:\n        return 1\n    return fact[n] * (modInverse(fact[r], m) % m * modInverse(fact[n - r], m) % mod) % mod % mod\nt = I()\nfact[0] = 1\nfor i in range(1, 100001):\n    fact[i] = fact[i - 1] * i % mod\nfor i in range(t):\n    n = I()\n    a = S()\n    b = S()\n    c = d = e = f = s = 0\n    for j in range(n):\n        if a[j] == '1':\n            c += 1\n        else:\n            d += 1\n        if b[j] == '1':\n            e += 1\n        else:\n            f += 1\n    mi = abs(c - e)\n    ma = min(c, f) + min(d, e)\n    for j in range(mi, ma + 1, 2):\n        s = (s + NcrModp(n, j, mod) % mod) % mod\n    print(s)", "prime = 1000000007\nfrom functools import reduce\nfrom operator import mul\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    if r == 0:\n        return 1\n    numerator = 1\n    for i in range(n, n - r, -1):\n        numerator = numerator * i % prime\n    denominator = 1\n    for i in range(1, r + 1):\n        denominator = denominator * i % prime\n    return numerator * pow(denominator, prime - 2, prime) % prime\nt = int(input())\nfor test in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    ones_a = a.count('1')\n    ones_b = b.count('1')\n    if ones_a < n - ones_b:\n        maxim = ones_a + ones_b\n        minim = abs(ones_a - ones_b)\n    else:\n        maxim = 2 * n - (ones_a + ones_b)\n        minim = abs(n - ones_a - (n - ones_b))\n    ans = cur = ncr(n, minim)\n    ans = ans % prime\n    for i in range(minim + 2, maxim + 1, 2):\n        cur = cur * (n - minim) % prime\n        cur = cur * (n - minim - 1) % prime\n        tmp = (minim + 1) * (minim + 2) % prime\n        cur = cur * pow(tmp, prime - 2, prime) % prime\n        ans = (ans + cur) % prime\n        minim += 2\n    print(ans)", "pri = 10 ** 9 + 7\nfact = [0 for i in range(10 ** 5 + 1)]\nfact[0] = 1\nfact[1] = 1\nfor i in range(2, len(fact)):\n    fact[i] = i * (fact[i - 1] % pri) % pri\nifact = [0 for i in range(10 ** 5 + 1)]\nifact[1] = 1\nifact[0] = 1\n\ndef mod(a, y, pri):\n    if y == 0:\n        return 1\n    else:\n        p = mod(a, y // 2, pri) % pri\n        p = p * p % pri\n        if y % 2 == 0:\n            return p\n        else:\n            return a * p % pri\nfor i in range(2, 10 ** 5 + 1):\n    ifact[i] = ifact[i - 1] * mod(i, pri - 2, pri) % pri\n\ndef NcR(n, r):\n    ret = ifact[n - r] * ifact[r] % pri\n    ret = ret * fact[n] % pri\n    return ret\np = int(input())\nfor i in range(p):\n    opa = int(input())\n    s1 = input()\n    s2 = input()\n    x = s1.count('1')\n    y = s1.count('0')\n    a = s2.count('1')\n    b = s2.count('0')\n    total = 0\n    kap = min(x, a)\n    kapa = 0\n    for t in range(kap + 1):\n        v = x - t\n        q = b - v\n        l = a - t\n        if 0 <= v <= b and 0 <= q <= b and (0 <= l <= a):\n            w = NcR(opa, t + q)\n            e = NcR(t + q, t)\n            r = NcR(v + l, v)\n            kapa = kapa + w * e * r % (10 ** 9 + 7)\n            kapa = (kapa - w) % (10 ** 9 + 7)\n    w = NcR(opa, x)\n    e = NcR(opa, a)\n    zapa = w * e % (10 ** 9 + 7)\n    print((zapa - kapa) % (10 ** 9 + 7))", "t = int(input())\nMODULO = 10 ** 9 + 7\nfact = [0 for x in range(10 ** 5 + 2)]\nfact[0] = 1\nfor i in range(1, 10 ** 5 + 2):\n    fact[i] = fact[i - 1] * i % MODULO\n\ndef inverse_mult(x, pow, mod):\n    a = 1\n    b = x\n    while pow > 0:\n        if pow % 2 == 1:\n            a *= b\n            if a > mod:\n                a %= mod\n        b **= 2\n        if b > mod:\n            b %= mod\n        pow //= 2\n    return a\n\ndef nCr(n, r, m):\n    return fact[n] * (inverse_mult(fact[r], m - 2, m) * inverse_mult(fact[n - r], m - 2, m)) % m % m\nwhile t > 0:\n    t -= 1\n    m = int(input())\n    a = input().strip()\n    b = input().strip()\n    a1 = sum([1 if x == '1' else 0 for x in a])\n    b1 = sum([1 if x == '1' else 0 for x in b])\n    max1 = min(a1, m - b1) + min(m - a1, b1)\n    min1 = abs(a1 - b1)\n    ans = 0\n    for i in range(min1, max1 + 1, 2):\n        ans += nCr(m, i, MODULO)\n        ans = (ans + MODULO) % MODULO\n    print(int(ans))", "m = 1000000007\nf = [1]\np = 1\nfor i in range(2, 100000):\n    f.append(p)\n    p = p * i % m\nt = int(input())\nfor x in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    s = 0\n    o1 = 0\n    o2 = 0\n    for y in range(n):\n        if a[y] == '1':\n            o1 = o1 + 1\n        if b[y] == '1':\n            o2 = o2 + 1\n    st = abs(o1 - o2)\n    if o1 < o2:\n        o1 = o2\n    en = min(o1 - st, n - o1) * 2\n    en = en + st\n    c = 1\n    e = 0\n    for y in range(st, en + 1, 2):\n        b1 = int(pow(f[y], m - 2, m))\n        b2 = int(pow(f[n - y], m - 2, m))\n        c = f[n] * b1 * b2 % m\n        s = (s + c) % m\n    print(s)", "from math import factorial\nimport math\nmod = 1000000007\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    if inv == -1:\n        print('Division not defined')\n    else:\n        return inv * a % m\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    o1 = a.count('1')\n    o2 = b.count('1')\n    m = n - (o1 + o2)\n    if m > 0:\n        min_int = 0\n    else:\n        min_int = abs(m)\n    max_int = min(o1, o2)\n    res_max = o1 + o2 - 2 * min_int\n    res_min = o1 + o2 - 2 * max_int\n    fact = [1]\n    f = 1\n    for i in range(1, n + 1):\n        f = f * i\n        f = f % mod\n        fact.append(f)\n    c = 0\n    num = fact[n]\n    for i in range(res_min, res_max + 1, 2):\n        c += modDivide(num, fact[i] * fact[n - i] % mod, mod)\n        c = c % mod\n    print(c)", "from math import factorial\nimport math\nmod = 1000000007\n\ndef modInverse(b, m):\n    return pow(b, m - 2, m)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    o1 = a.count('1')\n    o2 = b.count('1')\n    m = n - (o1 + o2)\n    if m > 0:\n        min_int = 0\n    else:\n        min_int = abs(m)\n    max_int = min(o1, o2)\n    res_max = o1 + o2 - 2 * min_int\n    res_min = o1 + o2 - 2 * max_int\n    fact = [1]\n    f = 1\n    for i in range(1, n + 1):\n        f = f * i\n        f = f % mod\n        fact.append(f)\n    c = 0\n    num = fact[n]\n    for i in range(res_min, res_max + 1, 2):\n        c += num * modInverse(fact[i] * fact[n - i], mod) % mod\n        c = c % mod\n    print(c)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    aone = a.count('1')\n    azero = n - aone\n    bone = b.count('1')\n    bzero = n - bone\n    minimum = abs(aone - bone)\n    maximum = min(azero, bone) + min(aone, bzero)\n    mod = 1000000007\n    temp = math.factorial(n) % mod * pow(math.factorial(n - minimum), mod - 2, mod) * pow(math.factorial(minimum), mod - 2, mod) % mod\n    ans = temp\n    for i in range(minimum + 2, maximum + 1, 2):\n        temp = temp * ((n - i + 2) % mod) * ((n - i + 1) % mod) * pow(i - 1, mod - 2, mod) * pow(i, mod - 2, mod) % mod\n        ans += temp\n        ans %= mod\n    print(ans)", "from sys import stdin, stdout\nfact = [1, 1]\nfor k in range(2, 100001):\n    fact.append(k * fact[k - 1] % 1000000007)\n\ndef invMod(number):\n    return pow(number, 1000000005, 1000000007)\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    str1 = stdin.readline()\n    str2 = stdin.readline()\n    p = 1000000007\n    c0A = str1.count('0')\n    c1A = n - c0A\n    c0B = str2.count('0')\n    c1B = n - c0B\n    min1 = abs(c1A - c1B)\n    max1 = min(c1A, c0B) + min(c0A, c1B)\n    nf = fact[n]\n    res = 0\n    for i in range(min1, max1 + 1, 2):\n        res = (res + nf * invMod(fact[i] * fact[n - i]) % p) % p\n    print(res)", "fact = [1, 1]\nfor k in range(2, 100001):\n    fact.append(k * fact[k - 1] % 1000000007)\n\ndef invMod(number):\n    return pow(number, 1000000005, 1000000007)\nfor _ in range(int(input())):\n    n = int(input())\n    str1 = input().strip()\n    str2 = input().strip()\n    p = 1000000007\n    c0A = str1.count('0')\n    c1A = n - c0A\n    c0B = str2.count('0')\n    c1B = n - c0B\n    min1 = abs(c1A - c1B)\n    max1 = min(c1A, c0B) + min(c0A, c1B)\n    nf = fact[n]\n    res = 0\n    for i in range(min1, max1 + 1, 2):\n        res = (res + nf * invMod(fact[i] * fact[n - i]) % p) % p\n    print(res)", "fact = [1, 1]\nfor k in range(2, 100001):\n    fact.append(k * fact[k - 1] % 1000000007)\n\ndef invMod(number):\n    return pow(number, 1000000005, 1000000007)\nfor _ in range(int(input())):\n    n = int(input())\n    str1 = input().strip()\n    str2 = input().strip()\n    p = 1000000007\n    c0A = str1.count('0')\n    c1A = n - c0A\n    c0B = str2.count('0')\n    c1B = n - c0B\n    min1 = abs(c1A - c1B)\n    max1 = min(c1A, c0B) + min(c0A, c1B)\n    nf = fact[n]\n    res = 0\n    for i in range(min1, max1 + 1, 2):\n        res = res + nf * invMod(fact[i] * fact[n - i]) % p\n        res %= p\n    print(res)", "fact = [1, 1]\nfor k in range(2, 100001):\n    fact.append(k * fact[k - 1] % 1000000007)\n\ndef invMod(number):\n    return pow(number, 1000000005, 1000000007)\nfor _ in range(int(input())):\n    n = int(input())\n    str1 = input().strip()\n    str2 = input().strip()\n    p = 1000000007\n    c0A = str1.count('0')\n    c1A = n - c0A\n    c0B = str2.count('0')\n    c1B = n - c0B\n    min1 = abs(c1A - c1B)\n    max1 = min(c1A, c0B) + min(c0A, c1B)\n    nf = fact[n]\n    res = 0\n    for i in range(min1, max1 + 1, 2):\n        res = (res + nf % p * invMod(fact[i] * fact[n - i] % p) % p) % p\n    print(res)", "mod = 1000000007\nfact = [1] * 100001\nfor j in range(1, 100001):\n    fact[j] = fact[j - 1] * j % mod\n\ndef modInv(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef comb(n, x):\n    return fact[n] * modInv(fact[x], mod) % mod * modInv(fact[n - x], mod) % mod % mod\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    a1 = a.count('1')\n    a0 = a.count('0')\n    b1 = b.count('1')\n    b0 = b.count('0')\n    mini = abs(a1 - b1)\n    maxi = min(a0, b1) + min(b0, a1)\n    ans = 0\n    for i in range(mini, maxi + 1, 2):\n        if i == 0 or i == n:\n            ans = ans + 1\n        else:\n            ans = (ans + comb(n, i)) % mod\n    print(ans)", "import atexit\nimport io\nimport sys\nfrom collections import defaultdict\nm = 1000000007\nf = [1]\np = 1\nfor i in range(2, 100000):\n    f.append(p)\n    p = p * i % m\nt = int(input())\nfor x in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    s = 0\n    o1 = 0\n    o2 = 0\n    for y in range(n):\n        if a[y] == '1':\n            o1 = o1 + 1\n        if b[y] == '1':\n            o2 = o2 + 1\n    st = abs(o1 - o2)\n    if o1 < o2:\n        o1 = o2\n    en = min(o1 - st, n - o1) * 2\n    en = en + st\n    c = 1\n    e = 0\n    for y in range(st, en + 1, 2):\n        b1 = int(pow(f[y], m - 2, m))\n        b2 = int(pow(f[n - y], m - 2, m))\n        c = f[n] * b1 * b2 % m\n        s = (s + c) % m\n    print(s)", "m = 1000000007\nf = [1]\np = 1\nfor i in range(2, 100000):\n    f.append(p)\n    p = p * i % m\nt = int(input())\nfor x in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    s = 0\n    o1 = 0\n    o2 = 0\n    for y in range(n):\n        if a[y] == '1':\n            o1 = o1 + 1\n        if b[y] == '1':\n            o2 = o2 + 1\n    st = abs(o1 - o2)\n    if o1 < o2:\n        o1 = o2\n    en = min(o1 - st, n - o1) * 2\n    en = en + st\n    c = 1\n    e = 0\n    for y in range(st, en + 1, 2):\n        b1 = int(pow(f[y], m - 2, m))\n        b2 = int(pow(f[n - y], m - 2, m))\n        c = f[n] * b1 * b2 % m\n        s = (s + c) % m\n    print(s)", "import math\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    a = list(input())\n    b = list(input())\n    n1 = a.count('0')\n    n2 = n - n1\n    n3 = b.count('0')\n    n4 = n - n3\n    if n1 + n3 <= n:\n        diff = abs(n1 - n3)\n        j = n1 + n3\n    else:\n        diff = abs(n2 - n4)\n        j = n2 + n4\n    ct = math.factorial(n) // (math.factorial(diff) * math.factorial(n - diff))\n    ans = ct\n    for i in range(diff + 2, j + 1, 2):\n        ct = ct * (n - i + 2) * (n - i + 1) // ((i - 1) * i)\n        ans = ans + ct\n    print(int(ans % (10 ** 9 + 7)))", "import math\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    a = list(input())\n    b = list(input())\n    n1 = a.count('0')\n    n2 = n - n1\n    n3 = b.count('0')\n    n4 = n - n3\n    if n1 + n3 <= n:\n        diff = abs(n1 - n3)\n        j = n1 + n3\n    else:\n        diff = abs(n2 - n4)\n        j = n2 + n4\n    ct = math.factorial(n) // (math.factorial(diff) * math.factorial(n - diff))\n    ans = ct\n    for i in range(diff + 2, j + 1, 2):\n        ct = ct * (n - i + 2) * (n - i + 1) // ((i - 1) * i)\n        ans = ans + ct\n    print(int(ans % (10 ** 9 + 7)))", "mod = 10 ** 9 + 7\nfact = [1]\nfor i in range(1, 10 ** 5 + 10):\n    fact.append(fact[i - 1] * i % mod)\n\ndef modularExponentiation(x):\n    n = mod - 2\n    result = 1\n    while n > 0:\n        if n % 2 == 1:\n            result = result * x % mod\n        x = x * x % mod\n        n = n // 2\n    return result\nfor _ in range(int(input())):\n    n = int(input())\n    a = input().count('1')\n    b = input().count('1')\n    min1 = abs(a - b)\n    if a + b <= n:\n        max1 = a + b\n    else:\n        max1 = 2 * n - (a + b)\n    count = 0\n    for i in range(min1, max1 + 1, 2):\n        count += modularExponentiation(fact[n - i]) * modularExponentiation(fact[i]) % mod\n    count = fact[n] % mod * count % mod\n    print(int(count))", "def nCk(n, k):\n    result = 1\n    if n - k < k:\n        k = n - k\n    for i in range(0, k):\n        result *= n - i\n        result //= i + 1\n    return result\nt = int(input())\nfor _ in range(t):\n    N = int(input())\n    A = input()\n    B = input()\n    res = 0\n    countA = 0\n    countB = 0\n    for i in range(N):\n        if A[i] == '1':\n            countA += 1\n        if B[i] == '1':\n            countB += 1\n    if countA + countB <= N:\n        max1 = countA + countB\n    elif countB + countA == 2 * N:\n        max1 = 0\n    else:\n        max1 = N - (countA + countB) % N\n    min1 = abs(countA - countB)\n    res += nCk(N, min1)\n    x = res\n    while min1 < max1:\n        x = (N - min1) * (N - min1 - 1) * x // ((min1 + 1) * (min1 + 2))\n        res += x\n        min1 += 2\n    res = res % 1000000007\n    print(int(res))", "mod = 10 ** 9 + 7\n\ndef bicoff(n, r):\n    nu = 1\n    de = 1\n    for i in range(r):\n        nu = nu * (n - i)\n        de = de * (i + 1)\n    return nu // de\nfor t in range(int(input())):\n    n = int(input())\n    a1 = input().count('1')\n    b1 = input().count('1')\n    minbit = abs(a1 - b1)\n    if a1 + b1 <= n:\n        maxbit = a1 + b1\n    else:\n        maxbit = 2 * n - a1 - b1\n    pascal = []\n    pascal.append(bicoff(n, minbit))\n    for i in range(minbit + 1, maxbit + 1):\n        pascal.append(pascal[-1] * (n - i + 1) // i)\n    sum = 0\n    for i in range(0, len(pascal), 2):\n        sum += pascal[i]\n    print(sum % mod)", "from sys import stdin\nfrom collections import Counter\nN = 100001\np = 1000000007\nfactorial = [None] * (N + 1)\nnatural = [None] * (N + 1)\nfact = [None] * (N + 1)\nnatural[0] = natural[1] = 1\nfor i in range(2, N + 1, 1):\n    natural[i] = natural[p % i] * (p - int(p / i)) % p\nfactorial[0] = factorial[1] = 1\nfor i in range(2, N + 1, 1):\n    factorial[i] = natural[i] * factorial[i - 1] % p\nfact[0] = 1\nfor i in range(1, N + 1):\n    fact[i] = fact[i - 1] * i % p\nt = int(stdin.readline())\nwhile t:\n    n = int(stdin.readline())\n    a = stdin.readline().strip()\n    b = stdin.readline().strip()\n    (c1, c2) = (Counter(a), Counter(b))\n    max1 = min(c1['0'] + c2['0'], c1['1'] + c2['1'])\n    min1 = abs(c2['1'] - c1['1'])\n    i = max1\n    ans = 0\n    while i >= min1:\n        ans = (ans + fact[n] * factorial[i] % p * factorial[n - i] % p) % p\n        i -= 2\n    print(ans)\n    t -= 1", "MOD = 10 ** 9 + 7\nfact = [1]\nfor t in range(1, 10 ** 5 + 10):\n    fact.append(t * fact[t - 1] % MOD)\n\ndef go(w, fact):\n    for tt in range(int(input())):\n        if w == 1:\n            n = int(input())\n            l = input()\n            r = input()\n        else:\n            print(1 / 0)\n        nFactMod = fact[n] % MOD\n        l1 = l.count('1')\n        r1 = r.count('1')\n        min1s = max(l1, r1) - min(l1, r1)\n        max1s = l1 + r1\n        if l1 + r1 > n:\n            max1s = 2 * n - max1s\n        ans = 0\n        for y in range(min1s, max1s + 1, 2):\n            ans += pow(fact[n - y], MOD - 2, MOD) * pow(fact[y], MOD - 2, MOD) % MOD\n        ans = nFactMod * ans % MOD\n        print(int(ans))\ngo(1, fact)", "p = 1000000007\nN = 100001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\nMod = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nfor _ in range(int(input())):\n    L = int(input())\n    A = input()\n    B = input()\n    n1 = 0\n    n2 = 0\n    n3 = 0\n    n4 = 0\n    for x in A:\n        if x == '1':\n            n1 += 1\n        else:\n            n2 += 1\n    for x in B:\n        if x == '1':\n            n4 += 1\n        else:\n            n3 += 1\n    m = abs(n1 - n4)\n    M = min(n1, n3) + min(n2, n4)\n    sum = 0\n    Rs = []\n    for k in range(m, M + 1, 2):\n        Rs.append(k)\n    for element in Rs:\n        sum = sum + Binomial(L, element, p)\n    print(int(sum) % Mod)", "fact = [1, 1]\nfor k in range(2, 100001):\n    fact.append(k * fact[k - 1] % 1000000007)\n\ndef invMod(number):\n    return pow(number, 1000000005, 1000000007)\nfor _ in range(int(input())):\n    n = int(input())\n    str1 = input().strip()\n    str2 = input().strip()\n    p = 1000000007\n    c0A = str1.count('0')\n    c1A = n - c0A\n    c0B = str2.count('0')\n    c1B = n - c0B\n    min1 = abs(c1A - c1B)\n    max1 = min(c1A, c0B) + min(c0A, c1B)\n    nf = fact[n]\n    res = 0\n    for i in range(min1, max1 + 1, 2):\n        res = (res + nf % p * invMod(fact[i] * fact[n - i] % p) % p) % p\n    print(res)", "fact = [1, 1]\nfor k in range(2, 100001):\n    fact.append(k * fact[k - 1] % 1000000007)\n\ndef invMod(number):\n    return pow(number, 1000000005, 1000000007)\nfor _ in range(int(input())):\n    n = int(input())\n    str1 = input().strip()\n    str2 = input().strip()\n    p = 1000000007\n    c0A = str1.count('0')\n    c1A = n - c0A\n    c0B = str2.count('0')\n    c1B = n - c0B\n    min1 = abs(c1A - c1B)\n    max1 = min(c1A, c0B) + min(c0A, c1B)\n    nf = fact[n]\n    res = 0\n    for i in range(min1, max1 + 1, 2):\n        res = (res + nf % p * invMod(fact[i] * fact[n - i] % p) % p) % p\n    print(res)", "p = 1000000007\nFacts = []\nFacts.append(1)\nfor z in range(1, 100001):\n    Facts.append(z % 1000000007 * (Facts[z - 1] % 1000000007) % 1000000007)\nfor _ in range(int(input())):\n    n = int(input())\n    A = str(input())\n    B = str(input())\n    ones_A = A.count('1')\n    ones_B = B.count('1')\n    if ones_A == n and ones_B == 0 or (ones_A == 0 and ones_B == n):\n        ans = 1\n    else:\n        ans = 0\n        zeroes_A = n - ones_A\n        zeroes_B = n - ones_B\n        max_ones_A = max(ones_A, ones_B)\n        min_zeroes_A = min(zeroes_A, zeroes_B)\n        min_ones = min(ones_A, ones_B)\n        if min_zeroes_A >= min_ones:\n            for i in range(0, min_ones + 1):\n                r = max_ones_A - i + (min_ones - i)\n                ans = (ans + Facts[n] * pow(Facts[r], p - 2, p) * pow(Facts[n - r], p - 2, p) % p) % p\n        else:\n            temp = min_ones - min_zeroes_A\n            for i in range(temp, min_ones + 1):\n                r = max_ones_A - i + (min_ones - i)\n                ans = (ans + Facts[n] * pow(Facts[r], p - 2, p) * pow(Facts[n - r], p - 2, p) % p) % p\n    print(int(ans))", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom sys import stdin, stdout\nMAXN = 100001\nMOD = 1000000007\nrline = lambda : stdin.readline().strip()\ninverse_mul = lambda x: pow(x, MOD - 2, MOD)\n\ndef comb(n, r):\n    return fact[n] * inverse_mul(fact[r] * fact[n - r]) % MOD\n\ndef solve():\n    global n, a, b\n    a = a.count('1')\n    b = b.count('1')\n    froma = abs(a - b)\n    toa = min(n - a, b) + min(n - b, a)\n    s = 0\n    for i in range(froma, toa + 1, 2):\n        s += comb(n, i)\n    return s % MOD\n\ndef read_input():\n    global n, a, b\n    (n, a, b) = (int(rline()), rline(), rline())\n\ndef write_output(s):\n    stdout.write('\\n'.join(map(str, s)))\n\ndef pre_compute():\n    global fact\n    fact = [1] * MAXN\n    for i in range(1, MAXN):\n        fact[i] = fact[i - 1] * i % MOD\n\ndef main():\n    pre_compute()\n    s = []\n    for _ in range(int(input())):\n        read_input()\n        answer = solve()\n        s.append(answer)\n    write_output(s)\nmain()", "import numpy as np\ni8 = np.int64\nMOD = 1000000007\n\ndef init(fac, inv, finv):\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, fac.shape[0]):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\ndef com(n, k, fac, finv):\n    if n < k:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\ndef solve_core(N, x, y, fac, finv):\n    kmin = abs(x - y)\n    kmax = N - abs(N - x - y)\n    res = 0\n    for i in range(kmin, kmax + 1, 2):\n        res += com(N, i, fac, finv)\n    return res % MOD\n\ndef solve(fac, finv):\n    N = int(input())\n    A = input()\n    B = input()\n    x = A.count('1')\n    y = B.count('1')\n    ans = solve_core(N, x, y, fac, finv)\n    print(ans)\n\ndef main():\n    N = 10 ** 5\n    fac = np.empty(N + 1, i8)\n    inv = np.empty(N + 1, i8)\n    finv = np.empty(N + 1, i8)\n    init(fac, inv, finv)\n    T = int(input())\n    for _ in range(T):\n        solve(fac, finv)\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom sys import stdin, stdout\nMAXN = 100001\nMOD = 1000000007\n\ndef comb(n, r):\n    return fact[n] * pow(fact[r] * fact[n - r], MOD - 2, MOD) % MOD\n\ndef solve():\n    global n, a, b\n    a = a.count('1')\n    b = b.count('1')\n    froma = abs(a - b)\n    toa = min(n - a, b) + min(n - b, a)\n    return sum([comb(n, i) for i in range(froma, toa + 1, 2)]) % MOD\n\ndef read_input():\n    global n, a, b\n    n = int(stdin.readline().strip())\n    a = stdin.readline().strip()\n    b = stdin.readline().strip()\n\ndef write_output(s):\n    stdout.write('\\n'.join(map(str, s)))\n\ndef pre_compute():\n    global fact\n    fact = [1] * MAXN\n    for i in range(1, MAXN):\n        fact[i] = fact[i - 1] * i % MOD\n\ndef main():\n    pre_compute()\n    s = []\n    for _ in range(int(input())):\n        read_input()\n        answer = solve()\n        s.append(answer)\n    write_output(s)\nmain()", "mod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(input())\n    b = list(input())\n    (onea, oneb) = (a.count('1'), b.count('1'))\n    zeroa = n - onea\n    zerob = n - oneb\n    minones = abs(onea - oneb)\n    if onea + oneb > n:\n        maxones = zeroa + zerob\n    else:\n        maxones = onea + oneb\n    ans = 0\n    if minones == 0:\n        ans = 1\n        minones += 2\n    num = [0] * (n + 1)\n    den = [0] * (n + 1)\n    c = [0] * (n + 1)\n    num[0] = den[0] = c[0] = 1\n    for i in range(n):\n        num[i + 1] = num[i] * (n - i) % 1000000007\n        den[i + 1] = den[i] * (i + 1) % 1000000007\n        c[i + 1] = num[i + 1] * pow(den[i + 1], 1000000007 - 2, 1000000007) % 1000000007\n    for i in range(minones, maxones + 1, 2):\n        ans += c[i]\n    print(int(ans % mod))", "import math\np = 1000000007\n\ndef ncr(n, r):\n    res = [1]\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n        res.append(num * pow(den, p - 2, p) % p)\n    return res\n\ndef main():\n    for i in range(int(input())):\n        n = int(input())\n        a = input()\n        b = input()\n        a1 = a.count('1') % p\n        b1 = b.count('1') % p\n        r = abs(a1 - b1) % p\n        m = (a1 + b1) % p\n        s = 0\n        arr = ncr(n, n)\n        if m > n:\n            for i in range(r, 2 * n - m + 1, 2):\n                s = (s + arr[i]) % p\n        elif m == n:\n            for i in range(r, n + 1, 2):\n                s = (s + arr[i]) % p\n        else:\n            for i in range(r, m + 1, 2):\n                s = (s + arr[i]) % p\n        print(s % p)\nmain()", "import math\n\ndef C(n, r):\n    m = 1000000007\n    n_r = int(pow(f[n - r], m - 2, m))\n    r_ = int(pow(f[r], m - 2, m))\n    denom = n_r * r_ % 1000000007\n    num = f[n] * denom % 1000000007\n    return num\np = 1\nf = [1]\nfor u in range(2, 100000):\n    f.append(p)\n    p = p * u % 1000000007\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    A = input()\n    B = input()\n    x = 0\n    y = 0\n    coun = 0\n    ans = 0\n    diff = 0\n    for c in A:\n        if c == '1':\n            x = x + 1\n    for c in B:\n        if c == '1':\n            y = y + 1\n    x2 = n - x\n    y2 = n - y\n    if x > y:\n        diff = x - y\n    else:\n        diff = y - x\n    a1 = min(x, y)\n    a2 = min(y2, x2)\n    a = min(a1, a2)\n    mm = diff + 2 * a\n    while diff <= mm:\n        ans = (ans % 1000000007 + C(n, diff) % 1000000007) % 1000000007\n        diff = diff + 2\n    print(ans)\n    t = t - 1", "p = 1000000007\nfact = [1]\nfor i in range(1, 100001):\n    fact.append(i * fact[-1] % p)\n\ndef nCr(n, r):\n    if r == 0:\n        return 1\n    return fact[n] * pow(fact[r], p - 2, p) % p * pow(fact[n - r], p - 2, p) % p\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    (b1, b2) = (input(), input())\n    (c1, c2) = (sum((1 for c in b1 if c == '1')), sum((1 for c in b2 if c == '1')))\n    low = abs(c2 - c1)\n    high = n - abs(c1 + c2 - n)\n    res = 0\n    for i in range(low, high + 1, 2):\n        res = (res + nCr(n, i)) % p\n    print(res)", "p = 1000000007\nfact = [1]\nfor i in range(1, 100001):\n    fact.append(i * fact[-1] % p)\n\ndef nCr(n, r):\n    if r == 0:\n        return 1\n    return fact[n] * pow(fact[r], p - 2, p) % p * pow(fact[n - r], p - 2, p) % p\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    (b1, b2) = (input(), input())\n    (c1, c2) = (sum((1 for c in b1 if c == '1')), sum((1 for c in b2 if c == '1')))\n    low = abs(c2 - c1)\n    high = min(2 * n - c1 - c2, c1 + c2)\n    res = 0\n    for i in range(low, high + 1, 2):\n        res = (res + nCr(n, i)) % p\n    print(res)", "import operator as op\nfrom functools import reduce\n\ndef nCr(n, r):\n    r = min(r, n - r)\n    numer = reduce(op.mul, range(n, n - r, -1), 1)\n    denom = reduce(op.mul, range(1, r + 1), 1)\n    return numer // denom\nt = int(input())\nfor _ in range(0, t):\n    n = int(input())\n    a = input()\n    b = input()\n    a1 = a.count('1')\n    a0 = a.count('0')\n    b1 = b.count('1')\n    b0 = b.count('0')\n    begin = n - min(a1, b1) - min(a0, b0)\n    end = min(a0, b1) + min(a1, b0)\n    if begin == end:\n        print(nCr(n, begin) % 1000000007)\n    else:\n        lst = [nCr(n, begin)]\n        for m in range(2, end - begin + 1, 2):\n            lst.append(lst[-1] * ((n - begin - m + 1) * (n - begin - m + 2)) // ((begin + m - 1) * (begin + m)))\n        print(sum(lst) % 1000000007)", "def ncr(n, min1, max1, p):\n    res = 0\n    num = 1\n    den = 1\n    if min1 == 0:\n        res = 1\n    for i in range(max1):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n        if i - min1 >= -1 and (i - min1 + 1) % 2 == 0:\n            res = (res + num * pow(den, p - 2, p)) % p\n    return res\nt = int(input())\np = 10 ** 9 + 7\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = input().strip()\n    b = input().strip()\n    a_1 = 0\n    b_1 = 0\n    for i in a:\n        if i == '1':\n            a_1 += 1\n    for i in b:\n        if i == '1':\n            b_1 += 1\n    max1 = n - abs(n - (a_1 + b_1))\n    min1 = max(a_1, b_1) - min(a_1, b_1)\n    print(ncr(n, min1, max1, p))", "def ncr(n, min1, max1, p):\n    res = 0\n    num = 1\n    den = 1\n    if min1 == 0:\n        res = 1\n    for i in range(max1):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n        if i - min1 >= -1 and (i - min1 + 1) % 2 == 0:\n            res = (res + num * pow(den, p - 2, p)) % p\n    return res\nt = int(input())\np = 10 ** 9 + 7\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = input().strip()\n    b = input().strip()\n    a_1 = 0\n    b_1 = 0\n    for i in a:\n        if i == '1':\n            a_1 += 1\n    for i in b:\n        if i == '1':\n            b_1 += 1\n    max1 = min(a_1, n - b_1) + min(b_1, n - a_1)\n    min1 = a_1 - b_1 if a_1 - b_1 > 0 else b_1 - a_1\n    print(ncr(n, min1, max1, p))", "def ncr(n, min1, max1, p):\n    res = 0\n    num = 1\n    den = 1\n    if min1 == 0:\n        res = 1\n    for i in range(max1):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n        if i - min1 >= -1 and (i - min1 + 1) % 2 == 0:\n            res = (res + num * pow(den, p - 2, p)) % p\n    return res\nt = int(input())\np = 10 ** 9 + 7\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = input().strip()\n    b = input().strip()\n    c0A = c1A = c0B = c1B = 0\n    for c in a:\n        if c == '1':\n            c1A += 1\n        elif c == '0':\n            c0A += 1\n    for c in b:\n        if c == '1':\n            c1B += 1\n        elif c == '0':\n            c0B += 1\n    max1 = min(c0A, c1B) + min(c1A, c0B)\n    min1 = n - min(c0B, c0A) - min(c1A, c1B)\n    print(ncr(n, min1, max1, p))", "p = 1000000007\nN = 100001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\nMod = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nfor _ in range(int(input())):\n    L = int(input())\n    A = input()\n    B = input()\n    n1 = 0\n    n2 = 0\n    n3 = 0\n    n4 = 0\n    for x in A:\n        if x == '1':\n            n1 += 1\n        else:\n            n2 += 1\n    for x in B:\n        if x == '1':\n            n4 += 1\n        else:\n            n3 += 1\n    m = abs(n1 - n4)\n    M = min(n1, n3) + min(n2, n4)\n    sum = 0\n    Rs = []\n    for k in range(m, M + 1, 2):\n        Rs.append(k)\n    for element in Rs:\n        sum = sum + Binomial(L, element, p)\n    print(int(sum) % Mod)", "import operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(op.mul, range(n, n - r, -1), 1)\n    denom = reduce(op.mul, range(1, r + 1), 1)\n    return numer // denom\nfor t in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    c1 = a.count('0')\n    c2 = n - c1\n    c3 = b.count('0')\n    c4 = n - c3\n    end = min(c1, c4) + min(c2, c3)\n    begin = n - (min(c1, c3) + min(c2, c4))\n    if begin == end:\n        print(ncr(n, begin) % 1000000007)\n    else:\n        lst = [ncr(n, begin)]\n        for m in range(2, end - begin + 1, 2):\n            lst.append(lst[-1] * ((n - begin - m + 1) * (n - begin - m + 2)) // ((begin + m - 1) * (begin + m)))\n        print(sum(lst) % 1000000007)", "import numpy as np\ni8 = np.int64\nMOD = 1000000007\n\ndef init(fac, inv, finv):\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, fac.shape[0]):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\ndef com(n, k, fac, finv):\n    if n < k:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\ndef solve_core(N, x, y, fac, finv):\n    kmin = abs(x - y)\n    kmax = N - abs(N - x - y)\n    res = 0\n    for i in range(kmin, kmax + 1, 2):\n        res += com(N, i, fac, finv)\n    return res % MOD\n\ndef solve(fac, finv):\n    N = int(input())\n    A = input()\n    B = input()\n    x = A.count('1')\n    y = B.count('1')\n    ans = solve_core(N, x, y, fac, finv)\n    print(ans)\n\ndef main():\n    N = 10 ** 5\n    fac = np.empty(N + 1, i8)\n    inv = np.empty(N + 1, i8)\n    finv = np.empty(N + 1, i8)\n    init(fac, inv, finv)\n    T = int(input())\n    for _ in range(T):\n        solve(fac, finv)\nmain()", "m = 1000000007\nf = [1]\np = 1\nfor i in range(2, 100000):\n    f.append(p)\n    p = p * i % m\nt = int(input())\nfor x in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    s = 0\n    o1 = 0\n    o2 = 0\n    for y in range(n):\n        if a[y] == '1':\n            o1 = o1 + 1\n        if b[y] == '1':\n            o2 = o2 + 1\n    st = abs(o1 - o2)\n    if o1 < o2:\n        o1 = o2\n    en = min(o1 - st, n - o1) * 2\n    en = en + st\n    c = 1\n    e = 0\n    for y in range(st, en + 1, 2):\n        b1 = int(pow(f[y], m - 2, m))\n        b2 = int(pow(f[n - y], m - 2, m))\n        c = f[n] * b1 * b2 % m\n        s = (s + c) % m\n    print(s)", "N = 100001\np = 1000000007\nfactorial = [None] * (N + 1)\nnatural = [None] * (N + 1)\nfact = [None] * (N + 1)\nnatural[0] = natural[1] = 1\nfor i in range(2, N + 1, 1):\n    natural[i] = natural[p % i] * (p - int(p / i)) % p\nfactorial[0] = factorial[1] = 1\nfor i in range(2, N + 1, 1):\n    factorial[i] = natural[i] * factorial[i - 1] % p\nfact[0] = 1\nfor i in range(1, N + 1):\n    fact[i] = fact[i - 1] * i % p\nfor _ in range(int(input())):\n    n = int(input())\n    p = 1000000007\n    a = input()\n    b = input()\n    a1 = a.count('1')\n    a0 = n - a1\n    b0 = b.count('0')\n    b1 = n - b0\n    ans = 0\n    start = n - min(a1, b1) - min(a0, b0)\n    end = min(a0, b1) + min(a1, b0)\n    for i in range(start, end + 1, 2):\n        ans = (ans + fact[n] * factorial[i] % p * factorial[n - i] % p) % p\n    print(ans)", "f = []\nf.append(1)\nfor z in range(1, 100001):\n    f.append(z % 1000000007 * (f[z - 1] % 1000000007) % 1000000007)\nT = int(input())\nwhile T:\n    n = int(input())\n    A = input()\n    B = input()\n    a1 = int(A.count('1'))\n    b1 = int(B.count('1'))\n    c = int(0)\n    m = 1000000007\n    if a1 == b1:\n        c = 1\n    if a1 == n and b1 == 0 or (a1 == 0 and b1 == n):\n        print(1)\n        continue\n    x = int(a1 + b1)\n    if b1 <= n - a1:\n        x = x\n    else:\n        x = 2 * n - x\n    if (a1 + b1) % 2 == 0:\n        for i in range(max(2, abs(a1 - b1)), x + 1, 2):\n            c = c + f[n] % m * pow(f[n - i] * f[i] % 1000000007, m - 2, m) % m\n            c = c % m\n    else:\n        for i in range(max(1, abs(a1 - b1)), x + 1, 2):\n            c = c + f[n] % m * pow(f[n - i] * f[i] % 1000000007, m - 2, m) % m\n            c = c % m\n    print(c)\n    T = T - 1", "def ppp(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef modIn(abca, M):\n    return ppp(abca, M - 2, M)\ntry:\n    t = int(input())\n    l = [1, 1]\n    e = 10 ** 9 + 7\n    for i in range(2, 100001):\n        l.append(i % e * l[i - 1] % e % e)\n    for jj in range(t):\n        n = int(input())\n        a = input()\n        b = input()\n        ac = a.count('1')\n        bc = b.count('1')\n        count = 0\n        c = abs(ac - bc)\n        x = ac + bc\n        if x > n:\n            x = n - (x - n)\n        while c <= x:\n            inv = modIn(l[n - c] * l[c], e)\n            ncr = l[n] % e * (inv % e) % e\n            count = (count + ncr) % e\n            c += 2\n        print(count)\nexcept:\n    pass", "import operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(op.mul, range(n, n - r, -1), 1)\n    denom = reduce(op.mul, range(1, r + 1), 1)\n    return numer // denom\nfor t in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    c1 = a.count('0')\n    c2 = n - c1\n    c3 = b.count('0')\n    c4 = n - c3\n    end = min(c1, c4) + min(c2, c3)\n    begin = n - (min(c1, c3) + min(c2, c4))\n    if begin == end:\n        print(ncr(n, begin) % 1000000007)\n    else:\n        lst = [ncr(n, begin)]\n        for m in range(2, end - begin + 1, 2):\n            lst.append(lst[-1] * ((n - begin - m + 1) * (n - begin - m + 2)) // ((begin + m - 1) * (begin + m)))\n        print(sum(lst) % 1000000007)", "fac = []\n\ndef fact(n):\n    if n == 0:\n        return 1\n    else:\n        return n * fact(n - 1)\n\ndef nCrModp(n, r, p):\n    C = [0 for i in range(r + 1)]\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, r), 0, -1):\n            C[j] = (C[j] + C[j - 1]) % p\n    return C[r]\n\ndef ncr(n, r1, r2, p):\n    num = den = 1\n    sum = 0\n    if r1 == 0:\n        sum += 1\n    for i in range(r2):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n        if i - r1 >= -1 and (i - r1 + 1) % 2 == 0:\n            sum += num * pow(den, p - 2, p) % p\n            sum %= p\n    return sum\nfor _ in range(int(input())):\n    N = int(input())\n    A = input()\n    B = input()\n    c0A = c1A = c0B = c1B = 0\n    for c in A:\n        if c == '1':\n            c1A += 1\n        elif c == '0':\n            c0A += 1\n    for c in B:\n        if c == '1':\n            c1B += 1\n        elif c == '0':\n            c0B += 1\n    max1xor = min(c0A, c1B) + min(c1A, c0B)\n    min1xor = N - min(c0B, c0A) - min(c1A, c1B)\n    pdt = ncr(N, min1xor, max1xor, 10 ** 9 + 7)\n    print(pdt)", "M = 1000000007\nfact = [0] * 2000001\nfact[0] = 1\nfor i in range(1, 2000001):\n    fact[i] = fact[i - 1] % M * (i % M) % M\n\ndef ncr(List, N):\n    Summation = 0\n    for i in List:\n        Summation += fact[N] * pow(fact[i], M - 2, M) * pow(fact[N - i], M - 2, M) % M\n    return Summation % M\nfor _ in range(int(input())):\n    N = int(input())\n    X = input()\n    Y = input()\n    A = X.count('1')\n    B = Y.count('1')\n    if A + B > N:\n        Max = N - A + (N - B)\n    else:\n        Max = A + B\n    Min = abs(A - B)\n    List = []\n    for i in range(Min, Max + 1, 2):\n        List.append(i)\n    print(ncr(List, N))", "def inverse(a, p):\n    if p == 0:\n        return 1\n    x = inverse(a, p // 2) % 1000000007\n    x = x * x % 1000000007\n    if p % 2 == 0:\n        return x\n    else:\n        return a * x % 1000000007\nmod = 1000000007\ninv = [1, 1]\nfor i in range(2, 10 ** 5 + 1):\n    inv.append(inverse(i, mod - 2))\nfact_inv = [1, 1]\ntemp = 1\nfor i in range(2, 10 ** 5 + 1):\n    temp = temp * inv[i] % mod\n    fact_inv.append(temp)\nfacts = [1]\nfor i in range(1, 10 ** 5 + 1):\n    facts.append(facts[i - 1] * i % (10 ** 9 + 7))\nfor _ in range(int(input())):\n    n = int(input())\n    x = input()\n    y = input()\n    y0 = y.count('0')\n    y1 = n - y0\n    x0 = x.count('0')\n    x1 = n - x0\n    maxx = x1 + y1\n    if maxx > n:\n        maxx = 2 * n - maxx\n    factn = facts[n]\n    minn = abs(x1 - y1)\n    ans = 0\n    for i in range(minn, maxx + 1, 2):\n        x = factn\n        v = fact_inv[i] * fact_inv[n - i]\n        v = v % 1000000007\n        x = x * v\n        x = x % 1000000007\n        ans = ans + x\n        ans = ans % 1000000007\n    print(ans)", "import math\n\ndef solve1(x, y, mod):\n    res = 1\n    x = x % mod\n    num = 5\n    ar = []\n    for i in range(num):\n        ar.append(i)\n    while y > 0:\n        if y & 1:\n            res = res * x % mod\n        y = y >> 1\n        x = x * x % mod\n    return res\n\ndef solve2(numm, mod):\n    return solve1(numm, mod - 2, mod)\n\ndef solve3(facatnum, numm, r, mod):\n    if r == 0:\n        return 1\n    return facatnum[numm] * solve2(facatnum[r], mod) % mod * solve2(facatnum[numm - r], mod) % mod % mod\nmod = 10 ** 9 + 7\ntest = int(input())\nfor intr in range(test):\n    numm = int(input())\n    arr1 = list(map(int, input().strip()))\n    arr2 = list(map(int, input().strip()))\n    counta1 = 0\n    countb1 = 0\n    counta2 = 0\n    countb2 = 0\n    for i in range(numm):\n        if arr1[i] == 1:\n            counta1 += 1\n        if arr2[i] == 1:\n            countb1 += 1\n        if arr1[i] == 0:\n            counta2 += 1\n        if arr2[i] == 0:\n            countb2 += 1\n    valueR = abs(counta1 - countb1)\n    MAXI = min(counta1 + countb1, counta2 + countb2)\n    actualans = 0\n    facatnum = [1]\n    for i in range(1, numm + 1):\n        facatnum.append(0)\n    for i in range(1, numm + 1):\n        facatnum[i] = facatnum[i - 1] * i % mod\n    flag = 0\n    while valueR <= MAXI:\n        actualans = (actualans + solve3(facatnum, numm, valueR, mod)) % mod\n        valueR += 2\n        flag += 1\n    print(actualans % mod)", "fact = []\nN = 10 ** 5 + 1\nfact.append(1)\nmod = 10 ** 9 + 7\nfor i in range(1, N):\n    fact.append(fact[i - 1] * i % mod)\nfor _ in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    x1 = a.count('1')\n    x0 = n - x1\n    y1 = b.count('1')\n    y0 = n - y1\n    if x1 == 0 or x0 == 0:\n        qq = fact[n]\n        c1 = y1\n        i1 = int(pow(fact[n - c1], mod - 2, mod))\n        i2 = int(pow(fact[c1], mod - 2, mod))\n        qq = qq * i1 * i2 % mod\n        print(qq)\n        continue\n    if y1 == 0 or y0 == 0:\n        qq = fact[n]\n        c1 = x1\n        i1 = int(pow(fact[n - c1], mod - 2, mod))\n        i2 = int(pow(fact[c1], mod - 2, mod))\n        qq = qq * i1 * i2 % mod\n        print(qq)\n        continue\n    a = x1 * '1'\n    a = a + x0 * '0'\n    b = y0 * '0'\n    b += '1' * y1\n    (c1, c0) = (0, 0)\n    for i in range(n):\n        if a[i] != b[i]:\n            c1 += 1\n        else:\n            c0 += 1\n    d = max(x1, y1) - min(x1, y1)\n    res = 0\n    while c1 >= d:\n        qq = fact[n]\n        i1 = int(pow(fact[n - c1], mod - 2, mod))\n        i2 = int(pow(fact[c1], mod - 2, mod))\n        qq = qq * i1 * i2 % mod\n        c1 -= 2\n        c0 += 2\n        res = (res + qq) % mod\n    print(res)", "def nCr(n, i):\n    if i > n - i:\n        i = n - i\n    res = 1\n    for k in range(i):\n        res = res * (n - k)\n        res = res // (k + 1)\n    return res\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    count1 = a.count('1')\n    count2 = b.count('1')\n    if count1 > count2:\n        mini = count1 - count2\n    else:\n        mini = count2 - count1\n    if count1 + count2 <= n:\n        maxi = count1 + count2\n    else:\n        maxi = 2 * n - (count1 + count2)\n    i = mini\n    if i > n - i:\n        i = n - i\n    count = 1\n    for x in range(i):\n        count = count * (n - x)\n        count = count // (x + 1)\n    count = int(count)\n    temp = count\n    i = mini + 2\n    while i <= maxi:\n        temp = temp * (n - i + 2) * (n - i + 1)\n        temp = temp // i\n        temp = temp // (i - 1)\n        count = count + temp\n        i += 2\n    count = int(count)\n    count = count % 1000000007\n    print(count)", "def nCr(n, i):\n    if i > n - i:\n        i = n - i\n    res = 1\n    for k in range(i):\n        res = res * (n - k)\n        res = res // (k + 1)\n    return res\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    count1 = a.count('1')\n    count2 = b.count('1')\n    if count1 > count2:\n        mini = count1 - count2\n    else:\n        mini = count2 - count1\n    if count1 + count2 <= n:\n        maxi = count1 + count2\n    else:\n        maxi = 2 * n - (count1 + count2)\n    i = mini\n    count = 1\n    count = nCr(n, i)\n    temp = count\n    i = i + 2\n    while i <= maxi:\n        temp = temp * (n - i + 2) * (n - i + 1)\n        temp = temp // i\n        temp = temp // (i - 1)\n        count = count + temp\n        i += 2\n    count = int(count)\n    count = count % 1000000007\n    print(count)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    str1 = input()\n    str2 = input()\n    (n1, n2) = (0, 0)\n    for i in range(n):\n        if str1[i] == '1':\n            n1 += 1\n        if str2[i] == '1':\n            n2 += 1\n    ones = abs(n2 - n1)\n    x = min(min(n1, n2), n - max(n1, n2))\n    tot = 0\n    perm = 1\n    if ones == 0:\n        if x > 0:\n            ones = 2\n            x -= 1\n        tot = 1\n    for i in range(1, ones + 1):\n        perm = perm * (n + 1 - i) // i\n        if i == ones:\n            tot += perm\n    for i in range(ones + 2, ones + x * 2 + 1, 2):\n        perm = perm * (n - i + 2) // (i - 1)\n        perm = perm * (n - i + 1) // i\n        tot += perm\n    print(tot % 1000000007)", "mod = 1000000007\n\ndef findgcd(a, b, i, j):\n    if a == 0:\n        i = 0\n        j = 1\n        return [b, i, j]\n    else:\n        i1 = 0\n        j1 = 0\n        l = findgcd(b % a, a, i1, j1)\n        (gcd, i1, j1) = (l[0], l[1], l[2])\n        i = j1 - b // a * i1\n        j = i1\n        return [gcd, i, j]\n\ndef go3(a, n):\n    i = 0\n    j = 0\n    l = findgcd(a, n, i, j)\n    (gcd, i, j) = (l[0], l[1], l[2])\n    if gcd != 1:\n        return -1\n    else:\n        return (i % n + n) % n\n\ndef go2(a, b):\n    a %= mod\n    i = go3(b, mod)\n    if i == -1:\n        return -1\n    else:\n        return i * a % mod\n\ndef go(a, b, n):\n    a0 = 0\n    b0 = 0\n    a1 = 0\n    b1 = 0\n    for i in range(0, n):\n        if a[i] == '0':\n            a0 += 1\n        else:\n            a1 += 1\n    for i in range(0, n):\n        if b[i] == '0':\n            b0 += 1\n        else:\n            b1 += 1\n    minones = n - (min(a0, b0) + min(a1, b1))\n    maxones = min(a1, b0) + min(a0, b1)\n    ans = 0\n    itr = 1\n    no = 1\n    d = 1\n    for i in range(minones, maxones + 1, 2):\n        if i == minones:\n            for j in range(0, i):\n                no = no * (n - j) % mod\n                d = d * (j + 1) % mod\n            ans = go2(no, d) % mod\n            itr = ans\n        else:\n            no = no * (n - i + 1) % mod\n            no = no * (n - i + 2) % mod\n            d = d * i % mod\n            d = d * (i - 1) % mod\n            itr = itr * (n - i + 1) % mod\n            itr = itr * (n - i + 2) % mod\n            itr = go2(itr, i) % mod\n            itr = go2(itr, i - 1) % mod\n            ans = (ans + go2(no, d)) % mod\n    return ans\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = input()\n    b = input()\n    print(go(a, b, n))", "t = int(input())\n\ndef fact(n):\n    if n == 0 or n == 1:\n        return 1\n    ans = 1\n    for i in range(1, n + 1):\n        ans = ans * i\n    return ans\n\ndef ncr(n, r):\n    p = 10 ** 9 + 7\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return (num, den)\n\ndef find(n, max_0, min_1, max_1, min_0):\n    (num, den) = ncr(n, min_1)\n    p = 10 ** 9 + 7\n    add = num * pow(den, p - 2, p) % p\n    ans = add\n    for x in range(min_1 + 2, max_1 + 1, 2):\n        num = num * (n - (x - 2)) % p * (n - (x - 1)) % p\n        den = den * (x - 1) % p * x % p\n        add = num * pow(den, p - 2, p) % p\n        ans += add\n    return ans\nfor loop in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    x1 = 0\n    y1 = 0\n    x2 = 0\n    y2 = 0\n    for c in a:\n        if c == '1':\n            x1 += 1\n        else:\n            y1 += 1\n    for c in b:\n        if c == '1':\n            x2 += 1\n        else:\n            y2 += 1\n    max_1 = min(x1, y2) + min(x2, y1)\n    max_0 = min(x1, x2) + min(y2, y1)\n    min_0 = n - max_1\n    min_1 = n - max_0\n    ans = find(n, max_0, min_1, max_1, min_0)\n    print(int(ans) % (10 ** 9 + 7))", "import itertools\nimport math\n\ndef gcd(c, d):\n    (reml, rem) = (abs(c), abs(d))\n    (x, xl, y, yl) = (0, 1, 1, 0)\n    while rem:\n        (reml, (q, rem)) = (rem, divmod(reml, rem))\n        (x, xl) = (xl - q * x, x)\n        (y, yl) = (yl - q * y, y)\n    return (reml, xl * (-1 if c < 0 else 1), yl * (-1 if d < 0 else 1))\n\ndef modinv(a, m):\n    (g, x, y) = gcd(a, m)\n    if g != 1:\n        raise ValueError\n    return x % m\nfor _ in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    a = list(a)\n    b = list(b)\n    a1 = a.count('1')\n    a0 = a.count('0')\n    b1 = b.count('1')\n    b0 = b.count('0')\n    mi = n - (min(a1, b1) + min(a0, b0))\n    ma = min(a1, b0) + min(a0, b1)\n    fac = math.factorial(n)\n    count = 0\n    li = []\n    for j in range(mi, ma + 1, 2):\n        li.append(min(j, n - j))\n    li.sort()\n    a1 = li[0]\n    x1 = math.factorial(n) // (math.factorial(a1) * math.factorial(n - a1))\n    result = x1 % (10 ** 9 + 7)\n    for i in range(1, len(li)):\n        if li[i] - li[i - 1] == 1:\n            x1 = x1 * ((n - li[i] + 1) % (10 ** 9 + 7)) % (10 ** 9 + 7) * modinv(li[i], 10 ** 9 + 7) % (10 ** 9 + 7)\n        elif li[i] - li[i - 1] == 2:\n            x1 = x1 * ((n - li[i] + 2) % (10 ** 9 + 7)) % (10 ** 9 + 7) * modinv(li[i] - 1, 10 ** 9 + 7) % (10 ** 9 + 7)\n            x1 = x1 * ((n - li[i] + 1) % (10 ** 9 + 7)) % (10 ** 9 + 7) * modinv(li[i], 10 ** 9 + 7) % (10 ** 9 + 7)\n        result += x1\n        result %= 10 ** 9 + 7\n    print(result)", "s = [0] * 100001\ns[0] = 1\nm = 1000000007\nfor i in range(1, 100001):\n    s[i] = s[i - 1] * i % m\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    a1 = a.count('1')\n    b1 = b.count('1')\n    az = a.count('0')\n    bz = b.count('0')\n    mini = abs(a1 - b1)\n    maxi = a1 + b1\n    if maxi > n:\n        if az < bz:\n            maxi = n - (b1 - az)\n        else:\n            maxi = n - (a1 - bz)\n    ans = 0\n    for j in range(mini, maxi + 1, 2):\n        b = pow(s[j] * s[n - j], m - 2, m)\n        ans = (ans + s[n] % m * b % m) % m\n    print(ans)", "p = 1000000007\nfac = [0] * 150001\nfac[0] = 1\nfor i in range(1, 150001):\n    fac[i] = fac[i - 1] * i % p\nt = int(input())\nfor _ in range(t):\n    ans = 0\n    n = int(input())\n    a = input()\n    b = input()\n    c1 = a.count('1')\n    c2 = b.count('1')\n    if n < c1 + c2:\n        Max = 2 * n - c1 - c2\n    else:\n        Max = c1 + c2\n    Min = abs(c1 - c2)\n    for j in range(Min, Max + 1, 2):\n        ans += fac[n] * pow(fac[j], p - 2, p) * pow(fac[n - j], p - 2, p) % p\n        ans = ans % p\n    print(ans)", "def comb(n, k):\n    if k > n - k:\n        k = n - k\n    val = 1\n    for i in range(k):\n        val = val * (n - i)\n        val = val // (i + 1)\n    return val\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = input()\n    b = input()\n    a1 = a.count('1')\n    b1 = b.count('1')\n    one_diff = abs(a1 - b1)\n    if a1 + b1 <= n:\n        bloo = a1 + b1\n    else:\n        bla = a1 + b1 - n\n        bloo = a1 + b1 - 2 * bla\n    count = comb(n, one_diff)\n    ans = count\n    for i in range(one_diff + 2, bloo + 1, 2):\n        count = count * ((n - i + 1) * (n - i + 2)) // ((i - 1) * i)\n        ans += count\n    print(ans % 1000000007)", "fact = [1] * 10 ** 6\nmod = 10 ** 9 + 7\nfor i in range(1, 10 ** 6):\n    fact[i] = fact[i - 1] * i % mod\nfor _ in range(int(input())):\n    n = int(input())\n    s1 = input()\n    s2 = input()\n    no1 = min(s1.count('1'), s2.count('0')) + min(s1.count('0'), s2.count('1'))\n    nfact = fact[n]\n    st = no1\n    ans = 0\n    st = abs(s1.count('1') - s2.count('1'))\n    while st <= no1:\n        ans += nfact * pow(fact[st], mod - 2, mod) * pow(fact[n - st], mod - 2, mod) % mod\n        ans = ans % mod\n        st += 2\n    print(ans)", "import math as mat\ntest = int(input())\nwhile test != 0:\n    test = test - 1\n    n = int(input())\n    a = input()\n    b = input()\n    ca = 0\n    cb = 0\n    sum = 0\n    temp = 1\n    temp1 = 1\n    for i in range(0, n):\n        if a[i] == '1':\n            ca = ca + 1\n        if b[i] == '1':\n            cb = cb + 1\n    if ca + cb > n:\n        max = 2 * n - (ca + cb)\n        min = abs(ca - cb)\n        for i in range(min, max + 1, 2):\n            if i == min:\n                for j in range(i):\n                    temp = temp * (n - j) % 1000000007\n                    temp1 = temp1 * (j + 1) % 1000000007\n            else:\n                for j in range(i - 2, i):\n                    temp = temp * (n - j) % 1000000007\n                    temp1 = temp1 * (j + 1) % 1000000007\n            sum = (sum % 1000000007 + temp % 1000000007 * (pow(temp1, 1000000005, 1000000007) % 1000000007) % 1000000007) % 1000000007\n        print(int(sum % 1000000007))\n    else:\n        max = ca + cb\n        min = abs(ca - cb)\n        for i in range(min, max + 1, 2):\n            if i == min:\n                for j in range(i):\n                    temp = temp * (n - j) % 1000000007\n                    temp1 = temp1 * (j + 1) % 1000000007\n            else:\n                for j in range(i - 2, i):\n                    temp = temp * (n - j) % 1000000007\n                    temp1 = temp1 * (j + 1) % 1000000007\n            sum = (sum % 1000000007 + temp % 1000000007 * (pow(temp1, 1000000005, 1000000007) % 1000000007) % 1000000007) % 1000000007\n        print(int(sum % 1000000007))", "N = 100001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nT = int(input())\nfor Z in range(T):\n    n = int(input())\n    x = input()\n    y = input()\n    a = x.count('1')\n    b = y.count('1')\n    if a + b <= n:\n        maximum = a + b\n    elif a + b > n:\n        maximum = n - (a + b - n)\n    minimum = max(a, b) - min(a, b)\n    sum = 0\n    for i in range(minimum, maximum + 1, 2):\n        sum = (sum + int(Binomial(n, i, p))) % (10 ** 9 + 7)\n    print(sum)", "import math\n\ndef nCr(n, r, m):\n    res = fact[n] % m * pow(fact[r], m - 2, m) % m % m\n    res = res % m * pow(fact[n - r], m - 2, m) % m % m\n    return res\nfact = [1]\nmul = 1\nm = 1000000007\nfor i in range(1, 100002):\n    mul = mul % m * (i % m) % m\n    fact.append(mul)\nt = int(input())\nfor q in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    n1 = a.count('1')\n    n2 = b.count('1')\n    if n1 == n:\n        n1 = 0\n    if n2 == n:\n        n2 = 0\n    if n1 > math.floor(n / 2):\n        n1 = n // 2 - n1 % math.ceil(n / 2)\n    if n2 > math.floor(n / 2):\n        n2 = n // 2 - n2 % math.ceil(n / 2)\n    e = n1 + n2\n    res = 0\n    while e >= 0 and min(n2, n1) >= 0:\n        res = (res % m + nCr(n, e, m) % m) % m\n        e = e - 2\n        n1 = n1 - 1\n        n2 = n2 - 1\n    print(res)", "import itertools\nimport math\n\ndef extended_gcd(aa, bb):\n    (lastremainder, remainder) = (abs(aa), abs(bb))\n    (x, lastx, y, lasty) = (0, 1, 1, 0)\n    while remainder:\n        (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n        (x, lastx) = (lastx - quotient * x, x)\n        (y, lasty) = (lasty - quotient * y, y)\n    return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\ndef modinv(a, m):\n    (g, x, y) = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError\n    return x % m\nfor _ in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    a = list(a)\n    b = list(b)\n    a1 = a.count('1')\n    a0 = a.count('0')\n    b1 = b.count('1')\n    b0 = b.count('0')\n    min1 = n - (min(a1, b1) + min(a0, b0))\n    max1 = min(a1, b0) + min(a0, b1)\n    nfac = math.factorial(n)\n    c = 0\n    list1 = []\n    for j in range(min1, max1 + 1, 2):\n        list1.append(min(j, n - j))\n    list1.sort()\n    a1 = list1[0]\n    x1 = math.factorial(n) // (math.factorial(a1) * math.factorial(n - a1))\n    ans = x1 % 1000000007\n    for i in range(1, len(list1)):\n        if list1[i] - list1[i - 1] == 1:\n            x1 = x1 * ((n - list1[i] + 1) % 1000000007) % 1000000007 * modinv(list1[i], 1000000007) % 1000000007\n        elif list1[i] - list1[i - 1] == 2:\n            x1 = x1 * ((n - list1[i] + 2) % 1000000007) % 1000000007 * modinv(list1[i] - 1, 1000000007) % 1000000007\n            x1 = x1 * ((n - list1[i] + 1) % 1000000007) % 1000000007 * modinv(list1[i], 1000000007) % 1000000007\n        ans += x1\n        ans %= 1000000007\n    print(ans)", "import itertools\nimport math\n\ndef extended_gcd(aa, bb):\n    (lastremainder, remainder) = (abs(aa), abs(bb))\n    (x, lastx, y, lasty) = (0, 1, 1, 0)\n    while remainder:\n        (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n        (x, lastx) = (lastx - quotient * x, x)\n        (y, lasty) = (lasty - quotient * y, y)\n    return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\ndef modinv(a, m):\n    (g, x, y) = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError\n    return x % m\nfor _ in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    a = list(a)\n    b = list(b)\n    a1 = a.count('1')\n    a0 = a.count('0')\n    b1 = b.count('1')\n    b0 = b.count('0')\n    min1 = n - (min(a1, b1) + min(a0, b0))\n    max1 = min(a1, b0) + min(a0, b1)\n    nfac = math.factorial(n)\n    c = 0\n    list1 = []\n    for j in range(min1, max1 + 1, 2):\n        list1.append(min(j, n - j))\n    list1.sort()\n    a1 = list1[0]\n    x1 = math.factorial(n) // (math.factorial(a1) * math.factorial(n - a1))\n    ans = x1 % 1000000007\n    for i in range(1, len(list1)):\n        if list1[i] - list1[i - 1] == 1:\n            x1 = x1 * ((n - list1[i] + 1) % 1000000007) % 1000000007 * modinv(list1[i], 1000000007) % 1000000007\n        elif list1[i] - list1[i - 1] == 2:\n            x1 = x1 * ((n - list1[i] + 2) % 1000000007) % 1000000007 * modinv(list1[i] - 1, 1000000007) % 1000000007\n            x1 = x1 * ((n - list1[i] + 1) % 1000000007) % 1000000007 * modinv(list1[i], 1000000007) % 1000000007\n        ans += x1\n        ans %= 1000000007\n    print(ans)", "import math\nMM = 1000000007\nfact = []\nfact.append(1)\nfor i in range(1, 1000001):\n    fact.append(fact[i - 1] * i % 1000000007)\nfor _ in range(int(input())):\n    x = int(input())\n    n = list(input())\n    m = list(input())\n    count1 = 0\n    count2 = 0\n    for i in n:\n        if i == '1':\n            count1 += 1\n    for i in m:\n        if i == '1':\n            count2 += 1\n    lf = fact[x]\n    countz1 = x - count1\n    countz2 = x - count2\n    ways = 0\n    if countz1 < countz2:\n        for _ in range(countz1 + 1):\n            if count2 < 0:\n                break\n            c1 = count1 - count2\n            mmi = fact[c1] * fact[x - c1]\n            wd = pow(mmi, MM - 2, MM) * (lf % MM) % MM\n            ways += wd\n            count1 += 1\n            count2 -= 1\n    else:\n        for _ in range(countz2 + 1):\n            if count1 < 0:\n                break\n            c1 = count2 - count1\n            mmi = fact[c1] * fact[x - c1]\n            wd = pow(mmi, MM - 2, MM) * (lf % MM) % MM\n            ways += wd\n            count2 += 1\n            count1 -= 1\n    print(ways % 1000000007)", "l = [1]\ns = pow(10, 9) + 7\nk = pow(10, 5)\nfor i in range(1, k + 1):\n    l.append(l[-1] * i % s)\nmod = [1]\nfor i in range(1, k + 1):\n    mod.append(pow(l[i], s - 2, s))\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    s1 = input()\n    s2 = input()\n    a = 0\n    b = 0\n    c = 0\n    d = 0\n    for k in range(len(s1)):\n        if s1[k] == '0' and s2[k] == '0':\n            d += 1\n        elif s1[k] == '1' and s2[k] == '0':\n            a += 1\n        elif s1[k] == '0' and s2[k] == '1':\n            b += 1\n        else:\n            c += 1\n    max_0 = c + d + 2 * min(a, b)\n    max_1 = a + b + 2 * min(c, d)\n    min_1 = n - max_0\n    ans = 0\n    for z in range(min_1, max_1 + 1, 2):\n        ans += l[n] * mod[z] * mod[n - z] % s\n        ans = ans % s\n    print(ans)", "import math\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    if inv == -1:\n        x = 4 // 0\n    else:\n        return inv * a % m\nfc2 = [1, 1]\nfor i in range(2, 100000 + 2):\n    fc2.append(fc2[i - 1] * i % (10 ** 9 + 7))\nt = int(input())\nfor test in range(t):\n    n = int(input())\n    a = input()\n    b = input()\n    A = {'1': 0, '0': 0}\n    B = {'1': 0, '0': 0}\n    for i in range(n):\n        A[a[i]] += 1\n        B[b[i]] += 1\n    max_1 = min(A['0'], B['1']) + min(A['1'], B['0'])\n    min_1 = n - (min(A['0'], B['0']) + min(A['1'], B['1']))\n    num = 0\n    for x in range(max_1, min_1 - 1, -2):\n        a = fc2[n]\n        b = fc2[x] * fc2[n - x]\n        num += modDivide(a, b, 10 ** 9 + 7)\n        num = num % (10 ** 9 + 7)\n    print(num)", "import math\ntest = int(input())\nn = 1000000\nt = 1\nfactorial = [1]\nMOD = 10 ** 9 + 7\nfor x in range(1, n + 1):\n    t = t * x % MOD\n    factorial.append(t)\n\ndef solve():\n    coll = 0\n    n = int(input())\n    num_A = input()\n    num_B = input()\n    ones_A = num_A.count('1')\n    ones_B = num_B.count('1')\n    add = ones_A + ones_B\n    subs = abs(ones_A - ones_B)\n    if n >= add:\n        for x in range(subs, add + 1, 2):\n            coll = (coll + nCr(n, x)) % MOD\n    else:\n        for x in range(subs, 2 * n - add + 1, 2):\n            coll = (coll + nCr(n, x)) % MOD\n    print(coll)\n\ndef InverseMod(num):\n    return pow(num, MOD - 2, MOD)\n\ndef nCr(n, r):\n    return factorial[n] * InverseMod(factorial[r] * factorial[n - r] % MOD)\nfor x in range(test):\n    solve()", "fact = []\nfact.append(1)\nfor j in range(1, 100001):\n    fact.append(j % 1000000007 * (fact[j - 1] % 1000000007) % 1000000007)\nT = int(input())\nwhile T:\n    n = int(input())\n    a = input()\n    b = input()\n    a1 = int(a.count('1'))\n    b1 = int(b.count('1'))\n    k = int(0)\n    m = 1000000007\n    if a1 == b1:\n        k = 1\n    if a1 == n and b1 == 0 or (a1 == 0 and b1 == n):\n        print(1)\n        continue\n    x = int(a1 + b1)\n    if b1 <= n - a1:\n        x = x\n    else:\n        x = 2 * n - x\n    if (a1 + b1) % 2 == 0:\n        for i in range(max(2, abs(a1 - b1)), x + 1, 2):\n            k = k + fact[n] % m * pow(fact[n - i] * fact[i] % 1000000007, m - 2, m) % m\n            k = k % m\n    else:\n        for i in range(max(1, abs(a1 - b1)), x + 1, 2):\n            k = k + fact[n] % m * pow(fact[n - i] * fact[i] % 1000000007, m - 2, m) % m\n            k = k % m\n    print(k)\n    T = T - 1", "def cones(s):\n    o = 0\n    for i in s:\n        if i == '1':\n            o += 1\n    return o\n\ndef pul(a, b, c):\n    a1 = 1\n    b1 = a\n    while b > 0:\n        if b % 2 == 1:\n            a1 = a1 * b1\n            if a1 > c:\n                a1 = a1 % c\n        b1 = b1 ** 2\n        if b1 > c:\n            b1 = b1 % c\n        b = b // 2\n    return a1\n\ndef nCr(n, t, m):\n    return f[n] * (pul(f[t], m - 2, m) * pul(f[n - t], m - 2, m) % m) % m\nf = [0 for x in range(100004)]\nf[0] = 1\nfor i in range(1, 100002):\n    f[i] = f[i - 1] * i % 1000000007\ntest = int(input())\nwhile test > 0:\n    test -= 1\n    res = 0\n    n = int(input())\n    a = input()\n    b = input()\n    coua = cones(a)\n    coub = cones(b)\n    t = coua + coub\n    if coua == coub:\n        res = 1\n    while t >= abs(coua - coub):\n        if t == n:\n            if t == coua + coub:\n                res = (res + nCr(n, t, 1000000007)) % 1000000007\n        if t < n:\n            if t > 0 and t <= 2 * n - coua - coub:\n                res = (res + nCr(n, t, 1000000007)) % 1000000007\n        t -= 2\n    print(res % 1000000007)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef onesList(a, b, n):\n    maxi = max(a, b)\n    mini = min(a, b)\n    p = 2 * n - (a + b)\n    if a + b <= n:\n        return list(range(maxi - mini, maxi + mini + 1, 2))\n    else:\n        return list(range(maxi - mini, p + 1, 2))\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\ntry:\n    N = 1000001\n    factorialNumInverse = [None] * (N + 1)\n    naturalNumInverse = [None] * (N + 1)\n    fact = [None] * (N + 1)\n    p = 1000000007\n    InverseofNumber(p)\n    InverseofFactorial(p)\n    factorial(p)\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = input()\n        b = input()\n        l = onesList(a.count('1'), b.count('1'), n)\n        ans = 0\n        for i in l:\n            ans += Binomial(n, i, 1000000007) % 1000000007\n        print(ans % 1000000007)\nexcept:\n    pass", "P = 1000000007\nfactorialNumInverse = [None] * (100000 + 2)\nnaturalNumInverse = [None] * (100000 + 2)\nfact = [None] * (100000 + 2)\n\ndef InverseofNumber():\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, 100000 + 2, 1):\n        naturalNumInverse[i] = naturalNumInverse[P % i] * (P - int(P / i)) % P\n\ndef InverseofFactorial():\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, 100000 + 2, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % P\n\ndef factorial():\n    fact[0] = 1\n    for i in range(1, 100000 + 2):\n        fact[i] = fact[i - 1] * i % P\n\ndef Binomial(n, R):\n    ans = fact[n] * factorialNumInverse[R] % P * factorialNumInverse[n - R] % P\n    return ans\nInverseofNumber()\nInverseofFactorial()\nfactorial()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    A = input()\n    B = input()\n    n1a = 0\n    n0a = 0\n    n1b = 0\n    n0b = 0\n    for i in A:\n        if i == '0':\n            n0a += 1\n    n1a = n - n0a\n    for i in B:\n        if i == '0':\n            n0b += 1\n    n1b = n - n0b\n    max_1 = min(n1a, n0b) + min(n0a, n1b)\n    min_1 = n - (min(n1a, n1b) + min(n0a, n0b))\n    sum1 = 0\n    while max_1 >= min_1:\n        sum1 += Binomial(n, max_1)\n        sum1 = sum1 % P\n        max_1 = max_1 - 2\n    print(sum1)", "N = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * 100001\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\ntc = int(input())\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfact[0] = 1\nfor i in range(1, 100000 + 1):\n    fact[i] = fact[i - 1] * i % p\nfor x in range(tc):\n    n = int(input())\n    mod = 1000000007\n    a = input()\n    b = input()\n    a0 = a.count('0')\n    a1 = a.count('1')\n    b0 = b.count('0')\n    b1 = b.count('1')\n    mi = abs(a1 - b1)\n    s = 0\n    ma = min(a0, b1) + min(a1, b0)\n    anss = 0\n    for i in range(mi, ma + 1, 2):\n        s += Binomial(n, i, mod)\n    print(s % mod)", "mod = pow(10, 9) + 7\nf = [1]\np = 1\nfor x in range(2, 100001):\n    f.append(p)\n    p = p * x % mod\nfor x in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    c00 = 0\n    c01 = 0\n    c10 = 0\n    c11 = 0\n    sum1 = 0\n    for x1 in a:\n        if x1 == '0':\n            c00 += 1\n        else:\n            c01 += 1\n    for x1 in b:\n        if x1 == '0':\n            c10 += 1\n        else:\n            c11 += 1\n    m0 = min(c00, c10)\n    m1 = min(c01, c11)\n    r = n - m0 - m1\n    t = f[n] % mod\n    for x in range(r, r + m0 * 2 + 1, 2):\n        if x <= c01 + c11:\n            y = int(pow(f[n - x], mod - 2, mod))\n            y1 = int(pow(f[x], mod - 2, mod))\n            d = y * y1 % mod\n            sum1 = (sum1 + t * d) % mod\n    print(sum1)", "from sys import stdin, stdout\nfrom math import gcd\ntry:\n    N = 1000001\n    factorialNumInverse = [None] * (N + 1)\n    naturalNumInverse = [None] * (N + 1)\n    fact = [None] * (N + 1)\n\n    def InverseofNumber(p):\n        naturalNumInverse[0] = naturalNumInverse[1] = 1\n        for i in range(2, N + 1, 1):\n            naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\n    def InverseofFactorial(p):\n        factorialNumInverse[0] = factorialNumInverse[1] = 1\n        for i in range(2, N + 1, 1):\n            factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\n    def factorial(p):\n        fact[0] = 1\n        for i in range(1, N + 1):\n            fact[i] = fact[i - 1] * i % p\n\n    def Binomial(N, R, p):\n        ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n        return ans\n    p = 1000000007\n    InverseofNumber(p)\n    InverseofFactorial(p)\n    factorial(p)\n    k1 = int(input())\n    for _ in range(k1):\n        k = int(input())\n        a = input()\n        b = input()\n        c1 = 0\n        c1o = 0\n        c2 = 0\n        c2o = 0\n        for i in a:\n            if i == '1':\n                c1 += 1\n            else:\n                c1o += 1\n        for i in b:\n            if i == '1':\n                c2 += 1\n            else:\n                c2o += 1\n        max_bits = min(c2o, c1) + min(c2, c1o)\n        min_bits = abs(c2 - c1)\n        r = max_bits\n        Sum = 0\n        while r >= min_bits:\n            Sum += Binomial(k, r, p) % p\n            r -= 2\n        print(Sum % p)\nexcept:\n    pass", "def ncr(n, mini, maxi):\n    p = 1000000007\n    num = 1\n    den = 1\n    for i in range(mini):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    final = num * pow(den, p - 2, p) % p\n    flag = 1\n    for i in range(mini, maxi):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n        if flag % 2 == 0:\n            final += num * pow(den, p - 2, p) % p\n        flag += 1\n    return final\ntest = int(input())\nfor t in range(test):\n    n = int(input())\n    A = input()\n    B = input()\n    a = 0\n    b = 0\n    for i in range(n):\n        if A[i] == '1':\n            a += 1\n        if B[i] == '1':\n            b += 1\n    if a + b <= n:\n        high = a + b\n    else:\n        high = 2 * n - (a + b)\n    low = abs(b - a)\n    lol = ncr(n, low, high)\n    print(lol % 1000000007)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = input().strip()\n    b = input().strip()\n    na = 0\n    nb = 0\n    for i in a:\n        if i == '1':\n            na += 1\n    for i in b:\n        if i == '1':\n            nb += 1\n    mil = abs(na - nb)\n    mal = min(na, n - nb) + min(nb, n - na)\n    sum = 0\n    p = 1000000007\n    num = den = 1\n    for i in range(mil):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    ini = num * pow(den, p - 2, p) % p\n    sum = ini\n    for i in range(mil + 2, mal + 1, 2):\n        num = num * (n - (i - 2)) % p\n        den = den * (i - 1) % p\n        num = num * (n - i + 1) % p\n        den = den * i % p\n        ini = num * pow(den, p - 2, p) % p\n        sum = (sum + ini) % 1000000007\n    print(sum)", "N = 100001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nfor i in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    c = str(a).count('1')\n    d = str(b).count('1')\n    ct = 0\n    if c + d >= n:\n        k = n - (c + d - n)\n    else:\n        k = c + d\n    k2 = max(c, d) - min(c, d)\n    for i in range(k2, k + 1, 2):\n        ct += Binomial(n, k, p) % p\n        k -= 2\n    print(int(ct) % p)", "from math import *\n\ndef mp(n, a, b):\n    n0 = 0\n    n1 = 0\n    for i in a:\n        if i == '1':\n            n1 += 1\n        elif i == '0':\n            n0 += 1\n    for i in b:\n        if i == '1':\n            n1 += 1\n        elif i == '0':\n            n0 += 1\n    return min(n, n0, n1)\n\ndef p(n, a, b):\n    na1 = 0\n    nb1 = 0\n    for i in range(n):\n        if a[i] == '1':\n            na1 += 1\n        if b[i] == '1':\n            nb1 += 1\n    return abs(na1 - nb1)\n\ndef fill(pe, f, m):\n    n = len(pe) - 1\n    if m % 2 == 0:\n        prev = pe[0]\n        i = 2\n        while i <= m:\n            pe[i] = prev * (n - i + 1) * (n - i + 2) // (i * (i - 1))\n            prev = pe[i]\n            pe[i] = pe[i] % 1000000007\n            i += 2\n    else:\n        prev = pe[1]\n        i = 3\n        while i <= m:\n            pe[i] = prev * (n - i + 1) * (n - i + 2) // (i * (i - 1))\n            prev = pe[i]\n            pe[i] = pe[i] % 1000000007\n            i += 2\n    return pe\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = str(input())\n    b = str(input())\n    max_parity = mp(n, a, b)\n    parity = p(n, a, b)\n    ans = 0\n    series = []\n    all_p = []\n    if parity % 2 == 0:\n        for j in range(n + 1):\n            if j % 2 == 0:\n                all_p.append(j)\n        while parity <= max_parity:\n            series.append(parity)\n            parity += 2\n    else:\n        for j in range(n + 1):\n            if j % 2 == 1:\n                all_p.append(j)\n        while parity <= max_parity:\n            series.append(parity)\n            parity += 2\n    max_ans = 2 ** (n - 1) % 1000000007\n    pe = [0] * (n + 1)\n    pe[0] = 1\n    pe[1] = n\n    pe[n] = 1\n    pe[n - 1] = n\n    if len(series) == len(all_p):\n        ans = max_ans\n    else:\n        pe = fill(pe, parity % 2, series[len(series) - 1])\n        for k in series:\n            ans = (ans + pe[k]) % 1000000007\n    ans = ans % 1000000007\n    print(int(ans))", "from math import *\n\ndef mp(n, a, b):\n    n0 = 0\n    n1 = 0\n    for i in a:\n        if i == '1':\n            n1 += 1\n        elif i == '0':\n            n0 += 1\n    for i in b:\n        if i == '1':\n            n1 += 1\n        elif i == '0':\n            n0 += 1\n    return min(n, n0, n1)\n\ndef p(n, a, b):\n    na1 = 0\n    nb1 = 0\n    for i in range(n):\n        if a[i] == '1':\n            na1 += 1\n        if b[i] == '1':\n            nb1 += 1\n    return abs(na1 - nb1)\n\ndef fill(pe, f, m):\n    n = len(pe) - 1\n    if m % 2 == 0:\n        prev = pe[0]\n        i = 2\n        while i <= m:\n            pe[i] = prev * (n - i + 1) * (n - i + 2) // (i * (i - 1))\n            prev = pe[i]\n            pe[i] = pe[i] % 1000000007\n            i += 2\n    else:\n        prev = pe[1]\n        i = 3\n        while i <= m:\n            pe[i] = prev * (n - i + 1) * (n - i + 2) // (i * (i - 1))\n            prev = pe[i]\n            pe[i] = pe[i] % 1000000007\n            i += 2\n    return pe\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = str(input())\n    b = str(input())\n    max_parity = mp(n, a, b)\n    parity = p(n, a, b)\n    ans = 0\n    series = []\n    all_p = []\n    if parity % 2 == 0:\n        for j in range(n + 1):\n            if j % 2 == 0:\n                all_p.append(j)\n        while parity <= max_parity:\n            series.append(parity)\n            parity += 2\n    else:\n        for j in range(n + 1):\n            if j % 2 == 1:\n                all_p.append(j)\n        while parity <= max_parity:\n            series.append(parity)\n            parity += 2\n    max_ans = 2 ** (n - 1) % 1000000007\n    pe = [0] * (n + 1)\n    pe[0] = 1\n    pe[1] = n\n    pe[n] = 1\n    pe[n - 1] = n\n    if len(series) == len(all_p):\n        ans = max_ans\n    else:\n        pe = fill(pe, parity % 2, series[len(series) - 1])\n        for k in series:\n            ans = (ans + pe[k]) % 1000000007\n    ans = ans % 1000000007\n    print(int(ans))", "from math import *\n\ndef mp(n, a, b):\n    n0 = 0\n    n1 = 0\n    for i in a:\n        if i == '1':\n            n1 += 1\n        elif i == '0':\n            n0 += 1\n    for i in b:\n        if i == '1':\n            n1 += 1\n        elif i == '0':\n            n0 += 1\n    return min(n, n0, n1)\n\ndef p(n, a, b):\n    na1 = 0\n    nb1 = 0\n    for i in range(n):\n        if a[i] == '1':\n            na1 += 1\n        if b[i] == '1':\n            nb1 += 1\n    return abs(na1 - nb1)\n\ndef perm(n, r):\n    p = 1\n    k = 1\n    if n - r < r:\n        r = n - r\n    if r != 0:\n        while r:\n            p *= n\n            k *= r\n            m = gcd(p, k)\n            p //= m\n            k //= m\n            n -= 1\n            r -= 1\n    else:\n        p = 1\n    return p\n\ndef fill(pe, f, m):\n    n = len(pe) - 1\n    if m % 2 == 0:\n        prev = pe[0]\n        i = 2\n        while i <= m:\n            pe[i] = prev * (n - i + 1) * (n - i + 2) // (i * (i - 1))\n            prev = pe[i]\n            pe[i] = pe[i] % 1000000007\n            i += 2\n    else:\n        prev = pe[1]\n        i = 3\n        while i <= m:\n            pe[i] = prev * (n - i + 1) * (n - i + 2) // (i * (i - 1))\n            prev = pe[i]\n            pe[i] = pe[i] % 1000000007\n            i += 2\n    return pe\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = str(input())\n    b = str(input())\n    max_parity = mp(n, a, b)\n    parity = p(n, a, b)\n    ans = 0\n    series = []\n    all_p = []\n    if parity % 2 == 0:\n        for j in range(n + 1):\n            if j % 2 == 0:\n                all_p.append(j)\n        while parity <= max_parity:\n            series.append(parity)\n            parity += 2\n    else:\n        for j in range(n + 1):\n            if j % 2 == 1:\n                all_p.append(j)\n        while parity <= max_parity:\n            series.append(parity)\n            parity += 2\n    max_ans = 2 ** (n - 1) % 1000000007\n    pe = [0] * (n + 1)\n    pe[0] = 1\n    pe[1] = n\n    pe[n] = 1\n    pe[n - 1] = n\n    if len(series) == len(all_p):\n        ans = max_ans\n    else:\n        pe = fill(pe, parity % 2, series[len(series) - 1])\n        for k in series:\n            ans = (ans + pe[k]) % 1000000007\n    ans = ans % 1000000007\n    print(int(ans))", "from math import *\n\ndef mp(n, a, b):\n    n0 = 0\n    n1 = 0\n    for i in a:\n        if i == '1':\n            n1 += 1\n        elif i == '0':\n            n0 += 1\n    for i in b:\n        if i == '1':\n            n1 += 1\n        elif i == '0':\n            n0 += 1\n    return min(n, n0, n1)\n\ndef p(n, a, b):\n    na1 = 0\n    nb1 = 0\n    for i in range(n):\n        if a[i] == '1':\n            na1 += 1\n        if b[i] == '1':\n            nb1 += 1\n    return abs(na1 - nb1)\n\ndef perm(n, r):\n    p = 1\n    k = 1\n    if n - r < r:\n        r = n - r\n    if r != 0:\n        while r:\n            p *= n\n            k *= r\n            m = gcd(p, k)\n            p //= m\n            k //= m\n            n -= 1\n            r -= 1\n    else:\n        p = 1\n    return p\n\ndef fill(pe, f, m):\n    n = len(pe) - 1\n    if m % 2 == 0:\n        prev = pe[0]\n        i = 2\n        while i <= m:\n            pe[i] = prev * (n - i + 1) * (n - i + 2) // (i * (i - 1))\n            prev = pe[i]\n            pe[i] = pe[i] % 1000000007\n            i += 2\n    else:\n        prev = pe[1]\n        i = 3\n        while i <= m:\n            pe[i] = prev * (n - i + 1) * (n - i + 2) // (i * (i - 1))\n            prev = pe[i]\n            pe[i] = pe[i] % 1000000007\n            i += 2\n    return pe\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = str(input())\n    b = str(input())\n    max_parity = mp(n, a, b)\n    parity = p(n, a, b)\n    ans = 0\n    series = []\n    all_p = []\n    if n <= 1000:\n        if parity % 2 == 0:\n            for j in range(n + 1):\n                if j % 2 == 0:\n                    all_p.append(j)\n            while parity <= max_parity:\n                series.append(parity)\n                ans = (ans + perm(n, parity)) % 1000000007\n                parity += 2\n        else:\n            for j in range(n + 1):\n                if j % 2 == 1:\n                    all_p.append(j)\n            while parity <= max_parity:\n                series.append(parity)\n                ans = (ans + perm(n, parity)) % 1000000007\n                parity += 2\n    else:\n        if parity % 2 == 0:\n            for j in range(n + 1):\n                if j % 2 == 0:\n                    all_p.append(j)\n            while parity <= max_parity:\n                series.append(parity)\n                parity += 2\n        else:\n            for j in range(n + 1):\n                if j % 2 == 1:\n                    all_p.append(j)\n            while parity <= max_parity:\n                series.append(parity)\n                parity += 2\n        max_ans = 2 ** (n - 1) % 1000000007\n        pe = [0] * (n + 1)\n        pe[0] = 1\n        pe[1] = n\n        pe[n] = 1\n        pe[n - 1] = n\n        if len(series) == len(all_p):\n            ans = max_ans\n        else:\n            pe = fill(pe, parity % 2, series[len(series) - 1])\n            for k in series:\n                ans = (ans + pe[k]) % 1000000007\n    ans = ans % 1000000007\n    print(int(ans))", "fac = [1] * 1000001\nMod = 1000000007\nfor i in range(2, 1000001):\n    fac[i] = fac[i - 1] * i % Mod\n\ndef nCr(n, r):\n    return fac[n] * pow(fac[r], Mod - 2, Mod) * pow(fac[n - r], Mod - 2, Mod) % Mod\nfor _ in range(int(input())):\n    input()\n    st1 = input()\n    st2 = input()\n    (n1, m1) = (st1.count('1'), st2.count('1'))\n    (n0, m0) = (st1.count('0'), st2.count('0'))\n    min1 = abs(n1 - m1)\n    max1 = min(n1, m0) + min(n0, m1) + 1\n    total = 0\n    for i in range(min1, max1, 2):\n        total += nCr(n1 + n0, i)\n    print(total % Mod)", "N = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\nimport math\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nt = int(input())\nfor c in range(0, t):\n    y = int(input())\n    x = input()\n    ls = []\n    y = input()\n    n = len(x)\n    coun = 0\n    z1 = x.count('0')\n    z2 = x.count('1')\n    z3 = y.count('0')\n    z4 = y.count('1')\n    z5 = z1 + z3\n    z6 = z2 + z4\n    z7 = abs(z4 - z2)\n    z8 = z6 % n\n    if z8 == 0:\n        if z6 == n:\n            z8 = n\n    if z6 > n:\n        z9 = n - z8\n    else:\n        z9 = z8\n    if z7 > z9:\n        (z7, z9) = (z9, z7)\n    coun = 0\n    for u in range(z9, z7 - 1, -2):\n        coun += int(Binomial(n, u, p))\n    if z6 == 2 * n or z6 == 0:\n        coun = 1\n    print(coun % 1000000007)", "for z in range(int(input())):\n    n = int(input())\n    a = input()\n    b = input()\n    (p, q, r) = (0, 0, 0)\n    for c in a:\n        if c == '1':\n            p += 1\n    for c in b:\n        if c == '1':\n            q += 1\n    if p > q:\n        h = p\n        g = q\n        j = n - p\n    else:\n        h = q\n        g = p\n        j = n - q\n    mn = h - g\n    m = min(g, j)\n    num = [0] * (n + 1)\n    den = [0] * (n + 1)\n    c = [0] * (n + 1)\n    num[0] = den[0] = c[0] = 1\n    for i in range(n):\n        num[i + 1] = num[i] * (n - i) % 1000000007\n        den[i + 1] = den[i] * (i + 1) % 1000000007\n        c[i + 1] = num[i + 1] * pow(den[i + 1], 1000000007 - 2, 1000000007) % 1000000007\n    for i in range(m + 1):\n        r += c[mn]\n        mn += 2\n    print(r % 1000000007)"]