["import sys\nsys.setrecursionlimit(5000)\n\ndef findConnections(i, j, visited, connections):\n    if i > 0:\n        if visited[i - 1][j] == False:\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            findConnections(i - 1, j, visited, connections)\n    if i < N - 1:\n        if visited[i + 1][j] == False:\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            findConnections(i + 1, j, visited, connections)\n    if j > 0:\n        if visited[i][j - 1] == False:\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            findConnections(i, j - 1, visited, connections)\n    if j < N - 1:\n        if visited[i][j + 1] == False:\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            findConnections(i, j + 1, visited, connections)\n\ndef countAns(connections):\n    ans = 1\n    for i in connections:\n        if len(i) == 1 and i == ['?']:\n            ans = ans % MOD * 3\n        if len(i) > 1:\n            if i.count('G') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 and i.count('P') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 or i.count('P') > 0:\n                ans *= 1\n            else:\n                ans = ans % MOD * 2\n    return ans % MOD\n\ndef solve(N, land):\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if visited[i][j] == False:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                findConnections(i, j, visited, connections)\n    ans = countAns(connections)\n    return ans\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    land = [[i for i in input()] for j in range(N)]\n    MOD = 10 ** 9 + 7\n    print(solve(N, land))", "import sys\nsys.setrecursionlimit(10000)\n\ndef findConnections(i, j, visited, connections):\n    if i > 0:\n        if visited[i - 1][j] == False:\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            findConnections(i - 1, j, visited, connections)\n    if i < N - 1:\n        if visited[i + 1][j] == False:\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            findConnections(i + 1, j, visited, connections)\n    if j > 0:\n        if visited[i][j - 1] == False:\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            findConnections(i, j - 1, visited, connections)\n    if j < N - 1:\n        if visited[i][j + 1] == False:\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            findConnections(i, j + 1, visited, connections)\n\ndef countAns(connections):\n    ans = 1\n    for i in connections:\n        if len(i) == 1 and i == ['?']:\n            ans = ans % MOD * 3\n        if len(i) > 1:\n            if i.count('G') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 and i.count('P') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 or i.count('P') > 0:\n                ans *= 1\n            else:\n                ans = ans % MOD * 2\n    return ans % MOD\n\ndef solve(N, land):\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if visited[i][j] == False:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                findConnections(i, j, visited, connections)\n    ans = countAns(connections)\n    return ans\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    land = [[i for i in input()] for j in range(N)]\n    MOD = 10 ** 9 + 7\n    print(solve(N, land))", "import sys\nsys.setrecursionlimit(10000)\n\ndef findConnections(i, j, visited, connections):\n    if i > 0:\n        if visited[i - 1][j] == False:\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            findConnections(i - 1, j, visited, connections)\n    if i < N - 1:\n        if visited[i + 1][j] == False:\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            findConnections(i + 1, j, visited, connections)\n    if j > 0:\n        if visited[i][j - 1] == False:\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            findConnections(i, j - 1, visited, connections)\n    if j < N - 1:\n        if visited[i][j + 1] == False:\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            findConnections(i, j + 1, visited, connections)\n\ndef countAns(connections):\n    ans = 1\n    for i in connections:\n        if len(i) == 1 and i == ['?']:\n            ans = ans % MOD * 3\n        if len(i) > 1:\n            if i.count('G') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 and i.count('P') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 or i.count('P') > 0:\n                ans *= 1\n            else:\n                ans = ans % MOD * 2\n    return ans % MOD\n\ndef solve(N, land):\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if visited[i][j] == False:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                findConnections(i, j, visited, connections)\n    ans = countAns(connections)\n    return ans\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    land = [[i for i in input()] for j in range(N)]\n    MOD = 10 ** 9 + 7\n    print(solve(N, land))", "import sys\nsys.setrecursionlimit(100000)\n\ndef findConnections(i, j, visited, connections):\n    if i > 0:\n        if visited[i - 1][j] == False:\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            findConnections(i - 1, j, visited, connections)\n    if i < N - 1:\n        if visited[i + 1][j] == False:\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            findConnections(i + 1, j, visited, connections)\n    if j > 0:\n        if visited[i][j - 1] == False:\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            findConnections(i, j - 1, visited, connections)\n    if j < N - 1:\n        if visited[i][j + 1] == False:\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            findConnections(i, j + 1, visited, connections)\n\ndef countAns(connections):\n    ans = 1\n    for i in connections:\n        if len(i) == 1 and i == ['?']:\n            ans = ans % MOD * 3\n        if len(i) > 1:\n            if i.count('G') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 and i.count('P') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 or i.count('P') > 0:\n                ans *= 1\n            else:\n                ans = ans % MOD * 2\n    return ans % MOD\n\ndef solve(N, land):\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if visited[i][j] == False:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                findConnections(i, j, visited, connections)\n    ans = countAns(connections)\n    return ans\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    land = [[i for i in input()] for j in range(N)]\n    MOD = 10 ** 9 + 7\n    print(solve(N, land))", "import sys\nsys.setrecursionlimit(1000000)\n\ndef findConnections(i, j, visited, connections):\n    if i > 0:\n        if visited[i - 1][j] == False:\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            findConnections(i - 1, j, visited, connections)\n    if i < N - 1:\n        if visited[i + 1][j] == False:\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            findConnections(i + 1, j, visited, connections)\n    if j > 0:\n        if visited[i][j - 1] == False:\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            findConnections(i, j - 1, visited, connections)\n    if j < N - 1:\n        if visited[i][j + 1] == False:\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            findConnections(i, j + 1, visited, connections)\n\ndef countAns(connections):\n    ans = 1\n    for i in connections:\n        if len(i) == 1 and i == ['?']:\n            ans = ans % MOD * 3\n        if len(i) > 1:\n            if i.count('G') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 and i.count('P') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 or i.count('P') > 0:\n                ans *= 1\n            else:\n                ans = ans % MOD * 2\n    return ans % MOD\n\ndef solve(N, land):\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if visited[i][j] == False:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                findConnections(i, j, visited, connections)\n    ans = countAns(connections)\n    return ans\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    land = [[i for i in input()] for j in range(N)]\n    MOD = 10 ** 9 + 7\n    print(solve(N, land))", "import sys\nsys.setrecursionlimit(1000000)\n\ndef findConnections(i, j, visited, connections):\n    if i > 0:\n        if visited[i - 1][j] == False:\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            findConnections(i - 1, j, visited, connections)\n    if i < N - 1:\n        if visited[i + 1][j] == False:\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            findConnections(i + 1, j, visited, connections)\n    if j > 0:\n        if visited[i][j - 1] == False:\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            findConnections(i, j - 1, visited, connections)\n    if j < N - 1:\n        if visited[i][j + 1] == False:\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            findConnections(i, j + 1, visited, connections)\n\ndef countAns(connections):\n    ans = 1\n    for i in connections:\n        if len(i) == 1 and i == ['?']:\n            ans = ans % MOD * 3\n        if len(i) > 1:\n            if i.count('G') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 and i.count('P') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 or i.count('P') > 0:\n                ans *= 1\n            else:\n                ans = ans % MOD * 2\n    return ans % MOD\n\ndef solve(N, land):\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if visited[i][j] == False:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                findConnections(i, j, visited, connections)\n    ans = countAns(connections)\n    return ans\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    land = [[i for i in input()] for j in range(N)]\n    MOD = 10 ** 9 + 7\n    print(solve(N, land))", "import sys\nsys.setrecursionlimit(1000000)\n\ndef findConnections(i, j, visited, connections):\n    if i > 0:\n        if visited[i - 1][j] == False:\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            findConnections(i - 1, j, visited, connections)\n    if i < N - 1:\n        if visited[i + 1][j] == False:\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            findConnections(i + 1, j, visited, connections)\n    if j > 0:\n        if visited[i][j - 1] == False:\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            findConnections(i, j - 1, visited, connections)\n    if j < N - 1:\n        if visited[i][j + 1] == False:\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            findConnections(i, j + 1, visited, connections)\n\ndef countAns(connections):\n    ans = 1\n    for i in connections:\n        if len(i) == 1 and i == ['?']:\n            ans = ans % MOD * 3\n        if len(i) > 1:\n            if i.count('G') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 and i.count('P') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 or i.count('P') > 0:\n                ans *= 1\n            else:\n                ans = ans % MOD * 2\n    return ans % MOD\n\ndef solve(N, land):\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if visited[i][j] == False:\n                connections.append([land[i][j]])\n                findConnections(i, j, visited, connections)\n    ans = countAns(connections)\n    return ans\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    land = [[i for i in input()] for j in range(N)]\n    MOD = 10 ** 9 + 7\n    print(solve(N, land))", "import sys\nsys.setrecursionlimit(10000000)\n\ndef findConnections(i, j, visited, connections):\n    if i > 0:\n        if visited[i - 1][j] == False:\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            findConnections(i - 1, j, visited, connections)\n    if i < N - 1:\n        if visited[i + 1][j] == False:\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            findConnections(i + 1, j, visited, connections)\n    if j > 0:\n        if visited[i][j - 1] == False:\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            findConnections(i, j - 1, visited, connections)\n    if j < N - 1:\n        if visited[i][j + 1] == False:\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            findConnections(i, j + 1, visited, connections)\n\ndef countAns(connections):\n    ans = 1\n    for i in connections:\n        if len(i) == 1 and i == ['?']:\n            ans = ans % MOD * 3\n        if len(i) > 1:\n            if i.count('G') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 and i.count('P') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 or i.count('P') > 0:\n                ans *= 1\n            else:\n                ans = ans % MOD * 2\n    return ans % MOD\n\ndef solve(N, land):\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if visited[i][j] == False:\n                connections.append([land[i][j]])\n                findConnections(i, j, visited, connections)\n    ans = countAns(connections)\n    return ans\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    land = [[i for i in input()] for j in range(N)]\n    MOD = 10 ** 9 + 7\n    print(solve(N, land))", "import sys\nsys.setrecursionlimit(10000000)\n\ndef findConnections(i, j, visited, connections):\n    if i > 0:\n        if visited[i - 1][j] == False:\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            findConnections(i - 1, j, visited, connections)\n    if i < N - 1:\n        if visited[i + 1][j] == False:\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            findConnections(i + 1, j, visited, connections)\n    if j > 0:\n        if visited[i][j - 1] == False:\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            findConnections(i, j - 1, visited, connections)\n    if j < N - 1:\n        if visited[i][j + 1] == False:\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            findConnections(i, j + 1, visited, connections)\n    return connections\n\ndef countAns(connections):\n    ans = 1\n    for i in connections:\n        if len(i) == 1 and i == ['?']:\n            ans = ans % MOD * 3\n        if len(i) > 1:\n            if i.count('G') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 and i.count('P') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 or i.count('P') > 0:\n                ans *= 1\n            else:\n                ans = ans % MOD * 2\n    return ans % MOD\n\ndef solve(N, land):\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if visited[i][j] == False:\n                connections.append([land[i][j]])\n                connections = findConnections(i, j, visited, connections)\n    ans = countAns(connections)\n    return ans\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    land = [[i for i in input()] for j in range(N)]\n    MOD = 10 ** 9 + 7\n    print(solve(N, land))", "import sys\nsys.setrecursionlimit(10000000)\n\ndef findConnections(i, j, visited, connections):\n    if i > 0:\n        if visited[i - 1][j] == False:\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            connections = findConnections(i - 1, j, visited, connections)\n    if i < N - 1:\n        if visited[i + 1][j] == False:\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            connections = findConnections(i + 1, j, visited, connections)\n    if j > 0:\n        if visited[i][j - 1] == False:\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            connections = findConnections(i, j - 1, visited, connections)\n    if j < N - 1:\n        if visited[i][j + 1] == False:\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            connections = findConnections(i, j + 1, visited, connections)\n    return connections\n\ndef countAns(connections):\n    ans = 1\n    for i in connections:\n        if len(i) == 1 and i == ['?']:\n            ans = ans % MOD * 3\n        if len(i) > 1:\n            if i.count('G') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 and i.count('P') > 0:\n                ans = 0\n                break\n            elif i.count('B') > 0 or i.count('P') > 0:\n                ans *= 1\n            else:\n                ans = ans % MOD * 2\n    return ans % MOD\n\ndef solve(N, land):\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if visited[i][j] == False:\n                connections.append([land[i][j]])\n                connections = findConnections(i, j, visited, connections)\n    ans = countAns(connections)\n    return ans\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    land = [[i for i in input()] for j in range(N)]\n    MOD = 10 ** 9 + 7\n    print(solve(N, land))", "import sys\n\nclass Cell:\n\n    def __init__(self, group_id, name):\n        self.group_id = group_id\n        self.name = name\n\n    def getGroupId(self):\n        return self.group_id\n\n    def setGroupId(self, group_id):\n        self.group_id = group_id\n\n    def getName(self):\n        return self.name\n\ndef hashfunction(y, x):\n    return 100 * y + x\n\ndef findCellValue(cells, y, x):\n    if hashfunction(y, x) in cells:\n        return cells[hashfunction(y, x)]\n    return None\n\ndef joinGroups(group_id1, group_id2, groups):\n    if group_id1 == group_id2:\n        return\n    if group_id1 < group_id2:\n        (group_id1, group_id2) = (group_id2, group_id1)\n    group = groups[group_id2]\n    for cell in group:\n        cell.setGroupId(group_id1)\n        groups[group_id1].add(cell)\n    del groups[group_id2]\n\ndef groupCellsBasedOnAdjacency(grid):\n    cells = dict()\n    groups = dict()\n    new_group_id = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] != '.':\n                group_id = None\n                cellAbove = findCellValue(cells, i - 1, j)\n                cellLeft = findCellValue(cells, i, j - 1)\n                if cellAbove is not None:\n                    group_id = cellAbove.getGroupId()\n                if cellLeft is not None:\n                    if group_id is not None:\n                        joinGroups(cellLeft.getGroupId(), group_id, groups)\n                    group_id = cellLeft.getGroupId()\n                if group_id is None:\n                    group_id = new_group_id\n                    groups[group_id] = set()\n                    new_group_id += 1\n                cell = Cell(group_id, grid[i][j])\n                groups[group_id].add(cell)\n                cells[hashfunction(i, j)] = cell\n    return groups\n\ndef calculateNumberOfVariations(groups):\n    result = 1\n    for key in groups.keys():\n        numOfUnknown = 0\n        numOfPolar = 0\n        numOfBrown = 0\n        numOfGrizzly = 0\n        for cell in groups[key]:\n            if cell.getName() == '?':\n                numOfUnknown += 1\n            elif cell.getName() == 'P':\n                numOfPolar += 1\n            elif cell.getName() == 'B':\n                numOfBrown += 1\n            elif cell.getName() == 'G':\n                numOfGrizzly += 1\n            else:\n                raise RuntimeError('Cell ' + cell.getName() + ' should not occur at this stage.')\n        if numOfBrown > 0 and numOfPolar > 0 or (numOfBrown + numOfPolar + numOfUnknown + numOfGrizzly > 1 and numOfGrizzly > 0):\n            print(0)\n            return\n        if numOfUnknown + numOfPolar + numOfBrown + numOfGrizzly == numOfUnknown:\n            if numOfUnknown == 1:\n                result *= 3\n            else:\n                result *= 2\n        else:\n            result *= 1\n    print(result % 1000000007)\n\ndef processGrid(grid):\n    groups = groupCellsBasedOnAdjacency(grid)\n    calculateNumberOfVariations(groups)\n\ndef parseInputIntoGrids(input_data):\n    grids = []\n    input_split = input_data.split('\\n')\n    i = 0\n    T = int(input_split[i])\n    i += 1\n    for _ in range(T):\n        N = int(input_split[i])\n        i += 1\n        grid = []\n        for _ in range(N):\n            grid.append(input_split[i])\n            i += 1\n        grids.append(grid)\n    return grids\ninput_data = sys.stdin.read()\ngrids = parseInputIntoGrids(input_data)\nfor grid in grids:\n    processGrid(grid)", "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\n\ndef Neigh(i, j, N):\n    L = []\n    if i + 1 != N:\n        L.append([i + 1, j])\n    if j + 1 != N:\n        L.append([i, j + 1])\n    if i != 0:\n        L.append([i - 1, j])\n    if j != 0:\n        L.append([i, j - 1])\n    return L\n\ndef chngneigh(Arr, i, j, target):\n    ll = Neigh(i, j, N)\n    next = []\n    for x in ll:\n        if Arr[x[0]][x[1]] == '?':\n            Arr[x[0]][x[1]] = target\n            next.append(x)\n    for x in next:\n        Arr = chngneigh(Arr, x[0], x[1], target)\n    return Arr\nfor _ in range(int(input())):\n    N = int(input())\n    Mat = []\n    for _ in range(N):\n        row = list(input())\n        Mat.append(row)\n    for i in range(N):\n        for j in range(N):\n            if Mat[i][j] == 'P':\n                Mat = chngneigh(Mat, i, j, 'P')\n            elif Mat[i][j] == 'B':\n                Mat = chngneigh(Mat, i, j, 'B')\n    fine = True\n    for i in range(N):\n        for j in range(N):\n            if Mat[i][j] == '.' or Mat[i][j] == '?':\n                pass\n            elif Mat[i][j] == 'G':\n                ll = Neigh(i, j, N)\n                for x in ll:\n                    if Mat[x[0]][x[1]] != '.':\n                        fine = False\n                        break\n            elif Mat[i][j] == 'P':\n                ll = Neigh(i, j, N)\n                for x in ll:\n                    if Mat[x[0]][x[1]] == 'B' or Mat[x[0]][x[1]] == 'G':\n                        fine = False\n                        break\n            elif Mat[i][j] == 'B':\n                ll = Neigh(i, j, N)\n                for x in ll:\n                    if Mat[x[0]][x[1]] == 'P' or Mat[x[0]][x[1]] == 'G':\n                        fine = False\n                        break\n        if fine == False:\n            break\n    if fine == False:\n        print('0')\n        continue\n    else:\n        solo = 0\n        for i in range(N):\n            for j in range(N):\n                if Mat[i][j] == '?':\n                    ll = Neigh(i, j, N)\n                    yup = True\n                    for x in ll:\n                        if Mat[x[0]][x[1]] != '.':\n                            yup = False\n                    if yup == True:\n                        solo += 1\n                        Mat[i][j] = 'D'\n        clustor = 0\n        for i in range(N):\n            for j in range(N):\n                if Mat[i][j] == '?':\n                    Mat = chngneigh(Mat, i, j, 'c')\n                    clustor += 1\n        answer = pow(3, solo, 1000000007) * pow(2, clustor, 1000000007)\n        print(answer % 1000000007)", "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom collections import defaultdict\n\ndef Neigh(i, j, N):\n    L = []\n    if i + 1 != N:\n        L.append([i + 1, j])\n    if j + 1 != N:\n        L.append([i, j + 1])\n    if i != 0:\n        L.append([i - 1, j])\n    if j != 0:\n        L.append([i, j - 1])\n    return L\n\ndef chngneigh(Arr, i, j, target):\n    ll = Neigh(i, j, N)\n    next = []\n    for x in ll:\n        if Arr[x[0]][x[1]] == '?':\n            Arr[x[0]][x[1]] = target\n            next.append(x)\n    for x in next:\n        Arr = chngneigh(Arr, x[0], x[1], target)\n    return Arr\nfor _ in range(int(input())):\n    N = int(input())\n    Mat = []\n    for _ in range(N):\n        row = list(input())\n        Mat.append(row)\n    for i in range(N):\n        for j in range(N):\n            if Mat[i][j] == 'P':\n                Mat = chngneigh(Mat, i, j, 'P')\n            elif Mat[i][j] == 'B':\n                Mat = chngneigh(Mat, i, j, 'B')\n    fine = True\n    for i in range(N):\n        for j in range(N):\n            if Mat[i][j] == '.' or Mat[i][j] == '?':\n                pass\n            elif Mat[i][j] == 'G':\n                ll = Neigh(i, j, N)\n                for x in ll:\n                    if Mat[x[0]][x[1]] != '.':\n                        fine = False\n                        break\n            elif Mat[i][j] == 'P':\n                ll = Neigh(i, j, N)\n                for x in ll:\n                    if Mat[x[0]][x[1]] == 'B' or Mat[x[0]][x[1]] == 'G':\n                        fine = False\n                        break\n            elif Mat[i][j] == 'B':\n                ll = Neigh(i, j, N)\n                for x in ll:\n                    if Mat[x[0]][x[1]] == 'P' or Mat[x[0]][x[1]] == 'G':\n                        fine = False\n                        break\n        if fine == False:\n            break\n    if fine == False:\n        print('0')\n        continue\n    else:\n        solo = 0\n        for i in range(N):\n            for j in range(N):\n                if Mat[i][j] == '?':\n                    ll = Neigh(i, j, N)\n                    yup = True\n                    for x in ll:\n                        if Mat[x[0]][x[1]] != '.':\n                            yup = False\n                    if yup == True:\n                        solo += 1\n                        Mat[i][j] = 'D'\n        clustor = 0\n        for i in range(N):\n            for j in range(N):\n                if Mat[i][j] == '?':\n                    Mat = chngneigh(Mat, i, j, 'c')\n                    clustor += 1\n        answer = pow(3, solo, 1000000007) * pow(2, clustor, 1000000007)\n        print(answer % 1000000007)", "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\n\ndef Neigh(i, j, N):\n    L = []\n    if i + 1 != N:\n        L.append([i + 1, j])\n    if j + 1 != N:\n        L.append([i, j + 1])\n    if i != 0:\n        L.append([i - 1, j])\n    if j != 0:\n        L.append([i, j - 1])\n    return L\n\ndef chngneigh(Arr, i, j, target):\n    ll = Neigh(i, j, N)\n    next = []\n    for x in ll:\n        if Arr[x[0]][x[1]] == '?':\n            Arr[x[0]][x[1]] = target\n            next.append(x)\n    for x in next:\n        Arr = chngneigh(Arr, x[0], x[1], target)\n    return Arr\nfor _ in range(int(input())):\n    N = int(input())\n    Mat = []\n    for _ in range(N):\n        row = list(input())\n        Mat.append(row)\n    for i in range(N):\n        for j in range(N):\n            if Mat[i][j] == 'P':\n                Mat = chngneigh(Mat, i, j, 'P')\n            elif Mat[i][j] == 'B':\n                Mat = chngneigh(Mat, i, j, 'B')\n    fine = True\n    for i in range(N):\n        for j in range(N):\n            if Mat[i][j] == '.' or Mat[i][j] == '?':\n                pass\n            elif Mat[i][j] == 'G':\n                ll = Neigh(i, j, N)\n                for x in ll:\n                    if Mat[x[0]][x[1]] != '.':\n                        fine = False\n                        break\n            elif Mat[i][j] == 'P':\n                ll = Neigh(i, j, N)\n                for x in ll:\n                    if Mat[x[0]][x[1]] == 'B' or Mat[x[0]][x[1]] == 'G':\n                        fine = False\n                        break\n            elif Mat[i][j] == 'B':\n                ll = Neigh(i, j, N)\n                for x in ll:\n                    if Mat[x[0]][x[1]] == 'P' or Mat[x[0]][x[1]] == 'G':\n                        fine = False\n                        break\n        if fine == False:\n            break\n    if fine == False:\n        print('0')\n        continue\n    else:\n        solo = 0\n        for i in range(N):\n            for j in range(N):\n                if Mat[i][j] == '?':\n                    ll = Neigh(i, j, N)\n                    yup = True\n                    for x in ll:\n                        if Mat[x[0]][x[1]] != '.':\n                            yup = False\n                    if yup == True:\n                        solo += 1\n                        Mat[i][j] = 'D'\n        clustor = 0\n        for i in range(N):\n            for j in range(N):\n                if Mat[i][j] == '?':\n                    Mat = chngneigh(Mat, i, j, 'c')\n                    clustor += 1\n        answer = pow(3, solo, 1000000007) * pow(2, clustor, 1000000007)\n        print(answer % 1000000007)", "import sys\n\ndef search(grid, grid_visited, x, y, counters, gridSize):\n    if x not in range(gridSize) or y not in range(gridSize) or grid_visited[x][y] == 'v' or (grid[x][y] == '.'):\n        pass\n    else:\n        grid_visited[x][y] = 'v'\n        if grid[x][y] == 'G':\n            counters['grizzly'] += 1\n        elif grid[x][y] == 'B':\n            counters['brown'] += 1\n        elif grid[x][y] == 'P':\n            counters['polar'] += 1\n        counters['area'] += 1\n        search(grid, grid_visited, x + 1, y, counters, gridSize)\n        search(grid, grid_visited, x, y + 1, counters, gridSize)\n        search(grid, grid_visited, x - 1, y, counters, gridSize)\n        search(grid, grid_visited, x, y - 1, counters, gridSize)\ntestCases = int(sys.stdin.readline())\nfor testCase in range(testCases):\n    gridSize = int(sys.stdin.readline())\n    grid = [list(sys.stdin.readline().strip()) for gridRow in range(gridSize)]\n    possibilities = 1\n    grid_visited = [['' for i in range(gridSize)] for j in range(gridSize)]\n    isValid = True\n    for x in range(gridSize):\n        for y in range(gridSize):\n            try:\n                if grid[x][y] != '.':\n                    counters = {'grizzly': 0, 'brown': 0, 'polar': 0, 'area': 0}\n                    search(grid, grid_visited, x, y, counters, gridSize)\n                    if counters['brown'] * counters['polar'] != 0 or (counters['area'] > 1 and counters['grizzly'] != 0):\n                        isValid = False\n                        break\n                    elif counters['area'] == 1 and counters['grizzly'] + counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 3\n                    elif counters['area'] > 1 and counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 2\n            except Exception:\n                pass\n        if not isValid:\n            possibilities = 0\n            break\n    possibilities = possibilities % (10 ** 9 + 7)\n    print(str(possibilities))", "def BFS(graph, s, b):\n    queue = []\n    queue.append(s)\n    count = 0\n    graph[s][1] = True\n    if b[s[0]][s[1]] == 'P':\n        start = 1\n    elif b[s[0]][s[1]] == 'B':\n        start = 2\n    elif b[s[0]][s[1]] == 'G':\n        if len(graph[s][0]) == 0:\n            return 1\n        else:\n            return 0\n    else:\n        start = 0\n    while len(queue) != 0:\n        v = queue.pop(0)\n        count += 1\n        for i in graph[v][0]:\n            if graph[i][1] == False:\n                if b[i[0]][i[1]] == 'G' and len(graph[i][0]) == 0:\n                    return 1\n                elif b[i[0]][i[1]] == 'G':\n                    return 0\n                elif b[i[0]][i[1]] == 'P':\n                    if start == 0:\n                        start = 1\n                    elif start == 1:\n                        start = 1\n                    else:\n                        return 0\n                elif b[i[0]][i[1]] == 'B':\n                    if start == 0:\n                        start = 2\n                    elif start == 1:\n                        return 0\n                    else:\n                        start = 2\n                graph[i][1] = True\n                queue.append(i)\n    if start != 0:\n        return 1\n    elif count == 1:\n        return 3\n    else:\n        return 2\nt = int(input())\nfor k in range(t):\n    n = int(input())\n    b = []\n    for i in range(n):\n        c = []\n        a = input().rstrip()\n        for i in a:\n            c.append(i)\n        b.append(c)\n    graph = dict()\n    c = 0\n    for i in range(n):\n        for j in range(n):\n            graph[i, j] = [[], False]\n    for i in range(n):\n        for j in range(n):\n            if b[i][j] != '.':\n                k = 0\n                while 1 > k and n > i + 1:\n                    if b[i + 1][j] != '.':\n                        graph[i, j][0].append((i + 1, j))\n                    k += 1\n                k = 0\n                while 1 > k and n > j + 1:\n                    if b[i][j + 1] != '.':\n                        graph[i, j][0].append((i, j + 1))\n                    k += 1\n                k = 0\n                while 1 > k and i - 1 >= 0:\n                    if b[i - 1][j] != '.':\n                        graph[i, j][0].append((i - 1, j))\n                    k += 1\n                k = 0\n                while 1 > k and j - 1 >= 0:\n                    if b[i][j - 1] != '.':\n                        graph[i, j][0].append((i, j - 1))\n                    k += 1\n                k = 0\n            else:\n                graph[i, j][1] = True\n    y = 1\n    for i in range(n):\n        for j in range(n):\n            if graph[i, j][1] == False:\n                x = BFS(graph, (i, j), b)\n                y = y * x % 1000000007\n    print(y)", "from copy import deepcopy\ndc = deepcopy\n\ndef cnt(a, n):\n    ans = 1\n    while True:\n        change = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if a[i][j] == 'G':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G') or (a[i + 1][j] == '?') or (a[i - 1][j] == '?') or (a[i][j - 1] == '?') or (a[i][j + 1] == '?'):\n                        ans = 0\n                elif a[i][j] == 'B':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                        ans = 0\n                elif a[i][j] == '?':\n                    bcnt = gcnt = pcnt = qcnt = dcnt = 0\n                    k = a[i + 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i - 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j - 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j + 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    if pcnt >= 1 and bcnt >= 1:\n                        ans = 0\n                    elif dcnt == 4:\n                        ans *= 3\n                        change = 1\n                        a[i][j] = 'G'\n                    elif pcnt >= 1:\n                        a[i][j] = 'P'\n                        change = 1\n                    elif bcnt >= 1:\n                        a[i][j] = 'B'\n                        change = 1\n        if ans == 0:\n            return 0\n        if change == 0:\n            break\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == '?':\n                if a[i + 1][j] != '?' and a[i - 1][j] != '?' and (a[i][j + 1] != '?') and (a[i][j - 1] != '?'):\n                    a[i][j] = 'B'\n                    total = cnt(dc(a), n)\n                    total *= 3\n                    return ans * total % 1000000007\n                total = 0\n                a[i][j] = 'G'\n                total += cnt(dc(a), n)\n                a[i][j] = 'B'\n                total += cnt(dc(a), n) * 2\n                return ans * total % 1000000007\n    return ans % 1000000007\n\ndef valid(a, n):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == 'G':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G'):\n                    return False\n            elif a[i][j] == 'B':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                    return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    a.append([0] * (n + 2))\n    for i in range(1, n + 1):\n        a.append(list(input()))\n        a[i].insert(0, 0)\n        a[i].append(0)\n    a.append([0] * (n + 2))\n    print(cnt(a, n))", "from copy import deepcopy\ndc = deepcopy\n\ndef cnt(a, n):\n    ans = 1\n    while True:\n        change = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if a[i][j] == 'G':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G') or (a[i + 1][j] == '?') or (a[i - 1][j] == '?') or (a[i][j - 1] == '?') or (a[i][j + 1] == '?'):\n                        ans = 0\n                elif a[i][j] == 'B':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                        ans = 0\n                elif a[i][j] == '?':\n                    bcnt = gcnt = pcnt = qcnt = dcnt = 0\n                    k = a[i + 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i - 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j - 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j + 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    if pcnt >= 1 and bcnt >= 1:\n                        ans = 0\n                    elif dcnt == 4:\n                        ans *= 3\n                        change = 1\n                        a[i][j] = 'G'\n                    elif pcnt >= 1:\n                        a[i][j] = 'P'\n                        change = 1\n                    elif bcnt >= 1:\n                        a[i][j] = 'B'\n                        change = 1\n        if ans == 0:\n            return 0\n        if change == 0:\n            break\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == '?':\n                if a[i + 1][j] != '?' and a[i - 1][j] != '?' and (a[i][j + 1] != '?') and (a[i][j - 1] != '?'):\n                    a[i][j] = 'B'\n                    total = cnt(dc(a), n)\n                    total *= 3\n                    return ans * total % 1000000007\n                total = 0\n                a[i][j] = 'G'\n                total += cnt(dc(a), n)\n                a[i][j] = 'B'\n                total += cnt(dc(a), n) * 2\n                return ans * total % 1000000007\n    return ans % 1000000007\n\ndef valid(a, n):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == 'G':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G'):\n                    return False\n            elif a[i][j] == 'B':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                    return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    a.append([0] * (n + 2))\n    for i in range(1, n + 1):\n        a.append(list(input()))\n        a[i].insert(0, 0)\n        a[i].append(0)\n    a.append([0] * (n + 2))\n    print(cnt(a, n))", "import sys\n\ndef search(grid, grid_visited, x, y, counters, gridSize):\n    if x not in range(gridSize) or y not in range(gridSize) or grid_visited[x][y] == 'v' or (grid[x][y] == '.'):\n        pass\n    else:\n        grid_visited[x][y] = 'v'\n        if grid[x][y] == 'G':\n            counters['grizzly'] += 1\n        elif grid[x][y] == 'B':\n            counters['brown'] += 1\n        elif grid[x][y] == 'P':\n            counters['polar'] += 1\n        counters['area'] += 1\n        search(grid, grid_visited, x + 1, y, counters, gridSize)\n        search(grid, grid_visited, x, y + 1, counters, gridSize)\n        search(grid, grid_visited, x - 1, y, counters, gridSize)\n        search(grid, grid_visited, x, y - 1, counters, gridSize)\ntestCases = int(sys.stdin.readline())\nfor testCase in range(testCases):\n    gridSize = int(sys.stdin.readline())\n    grid = [list(sys.stdin.readline().strip()) for gridRow in range(gridSize)]\n    possibilities = 1\n    grid_visited = [['' for i in range(gridSize)] for j in range(gridSize)]\n    isValid = True\n    for x in range(gridSize):\n        for y in range(gridSize):\n            try:\n                if grid[x][y] != '.':\n                    counters = {'grizzly': 0, 'brown': 0, 'polar': 0, 'area': 0}\n                    search(grid, grid_visited, x, y, counters, gridSize)\n                    if counters['brown'] * counters['polar'] != 0 or (counters['area'] > 1 and counters['grizzly'] != 0):\n                        isValid = False\n                        break\n                    elif counters['area'] == 1 and counters['grizzly'] + counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 3\n                    elif counters['area'] > 1 and counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 2\n            except Exception:\n                pass\n        if not isValid:\n            possibilities = 0\n            break\n    possibilities = possibilities % (10 ** 9 + 7)\n    print(str(possibilities))", "import sys\n\ndef search(grid, grid_visited, x, y, counters, gridSize):\n    if x not in range(gridSize) or y not in range(gridSize) or grid_visited[x][y] == 'v' or (grid[x][y] == '.'):\n        pass\n    else:\n        grid_visited[x][y] = 'v'\n        if grid[x][y] == 'G':\n            counters['grizzly'] += 1\n        elif grid[x][y] == 'B':\n            counters['brown'] += 1\n        elif grid[x][y] == 'P':\n            counters['polar'] += 1\n        counters['area'] += 1\n        search(grid, grid_visited, x + 1, y, counters, gridSize)\n        search(grid, grid_visited, x, y + 1, counters, gridSize)\n        search(grid, grid_visited, x - 1, y, counters, gridSize)\n        search(grid, grid_visited, x, y - 1, counters, gridSize)\ntestCases = int(sys.stdin.readline())\nfor testCase in range(testCases):\n    gridSize = int(sys.stdin.readline())\n    grid = [list(sys.stdin.readline().strip()) for gridRow in range(gridSize)]\n    possibilities = 1\n    grid_visited = [['' for i in range(gridSize)] for j in range(gridSize)]\n    isValid = True\n    for x in range(gridSize):\n        for y in range(gridSize):\n            try:\n                if grid[x][y] != '.':\n                    counters = {'grizzly': 0, 'brown': 0, 'polar': 0, 'area': 0}\n                    search(grid, grid_visited, x, y, counters, gridSize)\n                    if counters['brown'] * counters['polar'] != 0 or (counters['area'] > 1 and counters['grizzly'] != 0):\n                        isValid = False\n                        break\n                    elif counters['area'] == 1 and counters['grizzly'] + counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 3\n                    elif counters['area'] > 1 and counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 2\n            except Exception:\n                pass\n        if not isValid:\n            possibilities = 0\n            break\n    possibilities = possibilities % (10 ** 9 + 7)\n    print(str(possibilities))", "from copy import deepcopy\ndc = deepcopy\n\ndef cnt(a, n):\n    ans = 1\n    while True:\n        change = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if a[i][j] == 'G':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G') or (a[i + 1][j] == '?') or (a[i - 1][j] == '?') or (a[i][j - 1] == '?') or (a[i][j + 1] == '?'):\n                        ans = 0\n                elif a[i][j] == 'B':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                        ans = 0\n                elif a[i][j] == '?':\n                    bcnt = gcnt = pcnt = qcnt = dcnt = 0\n                    k = a[i + 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i - 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j - 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j + 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    if pcnt >= 1 and bcnt >= 1:\n                        ans = 0\n                    elif dcnt == 4:\n                        ans *= 3\n                        change = 1\n                        a[i][j] = 'G'\n                    elif pcnt >= 1:\n                        a[i][j] = 'P'\n                        change = 1\n                    elif bcnt >= 1:\n                        a[i][j] = 'B'\n                        change = 1\n        if ans == 0:\n            return 0\n        if change == 0:\n            break\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == '?':\n                if a[i + 1][j] != '?' and a[i - 1][j] != '?' and (a[i][j + 1] != '?') and (a[i][j - 1] != '?'):\n                    a[i][j] = 'B'\n                    total = cnt(dc(a), n)\n                    total *= 3\n                    return ans * total % 1000000007\n                total = 0\n                a[i][j] = 'G'\n                total += cnt(dc(a), n)\n                a[i][j] = 'B'\n                total += cnt(dc(a), n) * 2\n                return ans * total % 1000000007\n    return ans % 1000000007\n\ndef valid(a, n):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == 'G':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G'):\n                    return False\n            elif a[i][j] == 'B':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                    return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    a.append([0] * (n + 2))\n    for i in range(1, n + 1):\n        a.append(list(input()))\n        a[i].insert(0, 0)\n        a[i].append(0)\n    a.append([0] * (n + 2))\n    print(cnt(a, n))", "import sys\n\ndef search(grid, grid_visited, x, y, counters, gridSize):\n    if x not in range(gridSize) or y not in range(gridSize) or grid_visited[x][y] == 'v' or (grid[x][y] == '.'):\n        pass\n    else:\n        grid_visited[x][y] = 'v'\n        if grid[x][y] == 'G':\n            counters['grizzly'] += 1\n        elif grid[x][y] == 'B':\n            counters['brown'] += 1\n        elif grid[x][y] == 'P':\n            counters['polar'] += 1\n        counters['area'] += 1\n        search(grid, grid_visited, x + 1, y, counters, gridSize)\n        try:\n            search(grid, grid_visited, x, y + 1, counters, gridSize)\n        except Exception:\n            pass\n        search(grid, grid_visited, x - 1, y, counters, gridSize)\n        search(grid, grid_visited, x, y - 1, counters, gridSize)\ntestCases = int(sys.stdin.readline())\nfor testCase in range(testCases):\n    gridSize = int(sys.stdin.readline())\n    grid = [list(sys.stdin.readline().strip()) for gridRow in range(gridSize)]\n    possibilities = 1\n    grid_visited = [['' for i in range(gridSize)] for j in range(gridSize)]\n    isValid = True\n    for x in range(gridSize):\n        for y in range(gridSize):\n            if grid[x][y] != '.':\n                counters = {'grizzly': 0, 'brown': 0, 'polar': 0, 'area': 0}\n                search(grid, grid_visited, x, y, counters, gridSize)\n                if counters['brown'] * counters['polar'] != 0 or (counters['area'] > 1 and counters['grizzly'] != 0):\n                    isValid = False\n                    break\n                elif counters['area'] == 1 and counters['grizzly'] + counters['brown'] + counters['polar'] == 0:\n                    possibilities *= 3\n                elif counters['area'] > 1 and counters['brown'] + counters['polar'] == 0:\n                    possibilities *= 2\n        if not isValid:\n            possibilities = 0\n            break\n    possibilities = possibilities % (10 ** 9 + 7)\n    print(str(possibilities))", "import sys\n\ndef search(grid, grid_visited, x, y, counters, gridSize):\n    if x not in range(gridSize) or y not in range(gridSize) or grid_visited[x][y] == 'v' or (grid[x][y] == '.'):\n        pass\n    else:\n        grid_visited[x][y] = 'v'\n        if grid[x][y] == 'G':\n            counters['grizzly'] += 1\n        elif grid[x][y] == 'B':\n            counters['brown'] += 1\n        elif grid[x][y] == 'P':\n            counters['polar'] += 1\n        counters['area'] += 1\n        search(grid, grid_visited, x + 1, y, counters, gridSize)\n        search(grid, grid_visited, x, y + 1, counters, gridSize)\n        search(grid, grid_visited, x - 1, y, counters, gridSize)\n        search(grid, grid_visited, x, y - 1, counters, gridSize)\ntestCases = int(sys.stdin.readline())\nfor testCase in range(testCases):\n    gridSize = int(sys.stdin.readline())\n    grid = [list(sys.stdin.readline().strip()) for gridRow in range(gridSize)]\n    possibilities = 1\n    grid_visited = [['' for i in range(gridSize)] for j in range(gridSize)]\n    isValid = True\n    for x in range(gridSize):\n        for y in range(gridSize):\n            try:\n                if grid[x][y] != '.':\n                    counters = {'grizzly': 0, 'brown': 0, 'polar': 0, 'area': 0}\n                    search(grid, grid_visited, x, y, counters, gridSize)\n                    if counters['brown'] * counters['polar'] != 0 or (counters['area'] > 1 and counters['grizzly'] != 0):\n                        isValid = False\n                        break\n                    elif counters['area'] == 1 and counters['grizzly'] + counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 3\n                    elif counters['area'] > 1 and counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 2\n            except Exception:\n                pass\n        if not isValid:\n            possibilities = 0\n            break\n    possibilities = possibilities % (10 ** 9 + 7)\n    print(str(possibilities))", "import sys\n\ndef search(grid, grid_visited, x, y, counters):\n    if x not in range(len(grid[0])) or y not in range(len(grid[0])) or grid_visited[x][y] == 'v' or (grid[x][y] == '.'):\n        pass\n    else:\n        grid_visited[x][y] = 'v'\n        if grid[x][y] == 'G':\n            counters['grizzly'] += 1\n        elif grid[x][y] == 'B':\n            counters['brown'] += 1\n        elif grid[x][y] == 'P':\n            counters['polar'] += 1\n        counters['area'] += 1\n        search(grid, grid_visited, x + 1, y, counters)\n        search(grid, grid_visited, x, y + 1, counters)\n        search(grid, grid_visited, x - 1, y, counters)\n        search(grid, grid_visited, x, y - 1, counters)\ntestCases = int(sys.stdin.readline())\nfor testCase in range(testCases):\n    gridSize = int(sys.stdin.readline())\n    grid = [list(sys.stdin.readline().strip()) for gridRow in range(gridSize)]\n    possibilities = 1\n    grid_visited = [['' for i in range(gridSize)] for j in range(gridSize)]\n    isValid = True\n    for x in range(gridSize):\n        for y in range(gridSize):\n            try:\n                if grid[x][y] != '.':\n                    counters = {'grizzly': 0, 'brown': 0, 'polar': 0, 'area': 0}\n                    search(grid, grid_visited, x, y, counters)\n                    if counters['brown'] * counters['polar'] != 0 or (counters['area'] > 1 and counters['grizzly'] != 0):\n                        isValid = False\n                        break\n                    elif counters['area'] == 1 and counters['grizzly'] + counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 3\n                    elif counters['area'] > 1 and counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 2\n            except Exception:\n                pass\n        if not isValid:\n            possibilities = 0\n            break\n    possibilities = possibilities % (10 ** 9 + 7)\n    print(str(possibilities))", "import sys\n\ndef search(grid, grid_visited, x, y, counters):\n    try:\n        if x not in range(len(grid[0])) or y not in range(len(grid[0])) or grid_visited[x][y] == 'v' or (grid[x][y] == '.'):\n            pass\n        else:\n            grid_visited[x][y] = 'v'\n            if grid[x][y] == 'G':\n                counters['grizzly'] += 1\n            elif grid[x][y] == 'B':\n                counters['brown'] += 1\n            elif grid[x][y] == 'P':\n                counters['polar'] += 1\n            counters['area'] += 1\n            search(grid, grid_visited, x + 1, y, counters)\n            search(grid, grid_visited, x, y + 1, counters)\n            search(grid, grid_visited, x - 1, y, counters)\n            search(grid, grid_visited, x, y - 1, counters)\n    except IndexError:\n        pass\ntestCases = int(sys.stdin.readline())\nfor testCase in range(testCases):\n    gridSize = int(sys.stdin.readline())\n    grid = [list(sys.stdin.readline().strip()) for gridRow in range(gridSize)]\n    possibilities = 1\n    grid_visited = [['' for i in range(gridSize)] for j in range(gridSize)]\n    isValid = True\n    for x in range(gridSize):\n        for y in range(gridSize):\n            try:\n                if grid[x][y] != '.':\n                    counters = {'grizzly': 0, 'brown': 0, 'polar': 0, 'area': 0}\n                    search(grid, grid_visited, x, y, counters)\n                    if counters['brown'] * counters['polar'] != 0 or (counters['area'] > 1 and counters['grizzly'] != 0):\n                        isValid = False\n                        break\n                    elif counters['area'] == 1 and counters['grizzly'] + counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 3\n                    elif counters['area'] > 1 and counters['brown'] + counters['polar'] == 0:\n                        possibilities *= 2\n            except Exception:\n                pass\n        if not isValid:\n            possibilities = 0\n            break\n    possibilities = possibilities % (10 ** 9 + 7)\n    print(str(possibilities))", "from copy import deepcopy\ndc = deepcopy\n\ndef cnt(a, n):\n    ans = 1\n    while True:\n        change = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if a[i][j] == 'G':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G') or (a[i + 1][j] == '?') or (a[i - 1][j] == '?') or (a[i][j - 1] == '?') or (a[i][j + 1] == '?'):\n                        ans = 0\n                elif a[i][j] == 'B':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                        ans = 0\n                elif a[i][j] == '?':\n                    bcnt = gcnt = pcnt = qcnt = dcnt = 0\n                    k = a[i + 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i - 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j - 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j + 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    if pcnt >= 1 and bcnt >= 1:\n                        ans = 0\n                    elif dcnt == 4:\n                        ans *= 3\n                        change = 1\n                        a[i][j] = 'G'\n                    elif pcnt >= 1:\n                        a[i][j] = 'P'\n                        change = 1\n                    elif bcnt >= 1:\n                        a[i][j] = 'B'\n                        change = 1\n        if ans == 0:\n            return 0\n        if change == 0:\n            break\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == '?':\n                if a[i + 1][j] != '?' and a[i - 1][j] != '?' and (a[i][j + 1] != '?') and (a[i][j - 1] != '?'):\n                    a[i][j] = 'B'\n                    total = cnt(dc(a), n)\n                    total *= 3\n                    return ans * total % 1000000007\n                total = 0\n                a[i][j] = 'G'\n                total += cnt(dc(a), n)\n                a[i][j] = 'B'\n                total += cnt(dc(a), n) * 2\n                return ans * total % 1000000007\n    return ans % 1000000007\n\ndef valid(a, n):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == 'G':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G'):\n                    return False\n            elif a[i][j] == 'B':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                    return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    a.append([0] * (n + 2))\n    for i in range(1, n + 1):\n        a.append(list(input()))\n        a[i].insert(0, 0)\n        a[i].append(0)\n    a.append([0] * (n + 2))\n    print(cnt(a, n))", "from copy import deepcopy\ndc = deepcopy\n\ndef cnt(a, n):\n    ans = 1\n    while True:\n        change = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if a[i][j] == 'G':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G') or (a[i + 1][j] == '?') or (a[i - 1][j] == '?') or (a[i][j - 1] == '?') or (a[i][j + 1] == '?'):\n                        ans = 0\n                elif a[i][j] == 'B':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                        ans = 0\n                elif a[i][j] == '?':\n                    bcnt = gcnt = pcnt = qcnt = dcnt = 0\n                    k = a[i + 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i - 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j - 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j + 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    if pcnt >= 1 and bcnt >= 1:\n                        ans = 0\n                    elif dcnt == 4:\n                        ans *= 3\n                        change = 1\n                        a[i][j] = 'G'\n                    elif pcnt >= 1:\n                        a[i][j] = 'P'\n                        change = 1\n                    elif bcnt >= 1:\n                        a[i][j] = 'B'\n                        change = 1\n        if ans == 0:\n            return 0\n        if change == 0:\n            break\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == '?':\n                if a[i + 1][j] != '?' and a[i - 1][j] != '?' and (a[i][j + 1] != '?') and (a[i][j - 1] != '?'):\n                    a[i][j] = 'B'\n                    total = cnt(dc(a), n)\n                    total *= 3\n                    return ans * total % 1000000007\n                total = 0\n                a[i][j] = 'G'\n                total += cnt(dc(a), n)\n                a[i][j] = 'B'\n                total += cnt(dc(a), n) * 2\n                return ans * total % 1000000007\n    return ans % 1000000007\n\ndef valid(a, n):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == 'G':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G'):\n                    return False\n            elif a[i][j] == 'B':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                    return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    a.append([0] * (n + 2))\n    for i in range(1, n + 1):\n        a.append(list(input()))\n        a[i].insert(0, 0)\n        a[i].append(0)\n    a.append([0] * (n + 2))\n    print(cnt(a, n))", "import sys\nfrom functools import reduce\nsys.setrecursionlimit(1000000)\n\nclass BearAndSpecies:\n\n    def __init__(self, grid):\n        self.grid = grid\n        self.n = len(grid)\n        self.visited = []\n        for _ in range(self.n):\n            self.visited.append([False] * self.n)\n        self.directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        self.numComponents = [1]\n\n    def isValid(self, x, y):\n        if (x >= 0 and x < self.n) and (y >= 0 and y < self.n):\n            return True\n        return False\n\n    def neighboursIsEmpty(self, x, y):\n        for (x1, y1) in self.directions:\n            dx = x + x1\n            dy = y + y1\n            if self.isValid(dx, dy) and self.grid[dx][dy] != '.':\n                return False\n        return True\n\n    def dfs(self, row, col, v):\n        for (x, y) in self.directions:\n            dx = row + x\n            dy = col + y\n            if self.isValid(dx, dy) and self.grid[dx][dy] != '.' and (self.visited[dx][dy] == False):\n                self.visited[dx][dy] = True\n                if self.grid[dx][dy] != '?':\n                    v.add(self.grid[dx][dy])\n                self.dfs(dx, dy, v)\n        return v\n\n    def fillBearLand(self):\n        for i in range(self.n):\n            for j in range(self.n):\n                if self.grid[i][j] != '.' and self.visited[i][j] == False:\n                    self.visited[i][j] = True\n                    if self.neighboursIsEmpty(i, j):\n                        self.numComponents.append(3 if self.grid[i][j] == '?' else 1)\n                    else:\n                        v = {self.grid[i][j]}\n                        if self.grid[i][j] == '?':\n                            v = set()\n                        result = self.dfs(i, j, v)\n                        self.numComponents.append(0 if 'G' in result or len(result) == 2 else (2, 1)[len(result) > 0])\n        return reduce(lambda x, y: x * y % 1000000007, self.numComponents)\nn = int(input())\nfor _ in range(n):\n    m = int(input())\n    grid = [input().strip() for _ in range(m)]\n    x = BearAndSpecies(grid)\n    result = x.fillBearLand()\n    print(result)", "import sys\nfrom functools import reduce\nsys.setrecursionlimit(1000000)\nmoves = ((0, 1), (0, -1), (1, 0), (-1, 0))\n\ndef is_alone(i, j):\n    for (di, dj) in moves:\n        (ni, nj) = (i + di, j + dj)\n        if 0 <= ni < n and 0 <= nj < n and (b[ni][nj] != '.'):\n            return False\n    return True\n\ndef fill(i, j, met):\n    for (di, dj) in moves:\n        (ni, nj) = (i + di, j + dj)\n        if 0 <= ni < n and 0 <= nj < n:\n            if b[ni][nj] != '.' and (not v[ni][nj]):\n                v[ni][nj] = True\n                if b[ni][nj] != '?':\n                    met.add(b[ni][nj])\n                fill(ni, nj, met)\n    return met\nfor _ in range(int(input())):\n    n = int(input())\n    b = [input().strip() for _ in range(n)]\n    v = [[False for _ in range(n)] for _ in range(n)]\n    ret = [1]\n    for i in range(n):\n        for j in range(n):\n            if b[i][j] != '.' and (not v[i][j]):\n                v[i][j] = True\n                if is_alone(i, j):\n                    ret.append(3 if b[i][j] == '?' else 1)\n                else:\n                    met = fill(i, j, set() if b[i][j] == '?' else set(b[i][j]))\n                    ret.append(0 if 'G' in met or len(met) == 2 else (2, 1)[len(met) > 0])\n    print(reduce(lambda x, y: x * y % 1000000007, ret))", "import sys\nfrom functools import reduce\nsys.setrecursionlimit(1000000)\nmoves = ((0, 1), (0, -1), (1, 0), (-1, 0))\n\ndef is_alone(i, j):\n    for (di, dj) in moves:\n        (ni, nj) = (i + di, j + dj)\n        if 0 <= ni < n and 0 <= nj < n and (b[ni][nj] != '.'):\n            return False\n    return True\n\ndef fill(i, j, met):\n    for (di, dj) in moves:\n        (ni, nj) = (i + di, j + dj)\n        if 0 <= ni < n and 0 <= nj < n:\n            if b[ni][nj] != '.' and (not v[ni][nj]):\n                v[ni][nj] = True\n                if b[ni][nj] != '?':\n                    met.add(b[ni][nj])\n                fill(ni, nj, met)\n    return met\nfor _ in range(int(input())):\n    n = int(input())\n    b = [input().strip() for _ in range(n)]\n    v = [[False for _ in range(n)] for _ in range(n)]\n    ret = [1]\n    for i in range(n):\n        for j in range(n):\n            if b[i][j] != '.' and (not v[i][j]):\n                v[i][j] = True\n                if is_alone(i, j):\n                    ret.append(3 if b[i][j] == '?' else 1)\n                else:\n                    met = fill(i, j, set() if b[i][j] == '?' else set(b[i][j]))\n                    ret.append(0 if 'G' in met or len(met) == 2 else (2, 1)[len(met) > 0])\n    print(reduce(lambda x, y: x * y % 1000000007, ret))", "from copy import deepcopy\ndc = deepcopy\n\ndef cnt(a, n):\n    ans = 1\n    while True:\n        change = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if a[i][j] == 'G':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G') or (a[i + 1][j] == '?') or (a[i - 1][j] == '?') or (a[i][j - 1] == '?') or (a[i][j + 1] == '?'):\n                        ans = 0\n                elif a[i][j] == 'B':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                        ans = 0\n                elif a[i][j] == '?':\n                    bcnt = gcnt = pcnt = qcnt = dcnt = 0\n                    k = a[i + 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i - 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j - 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j + 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    if pcnt >= 1 and bcnt >= 1:\n                        ans = 0\n                    elif dcnt == 4:\n                        ans *= 3\n                        change = 1\n                        a[i][j] = 'G'\n                    elif pcnt >= 1:\n                        a[i][j] = 'P'\n                        change = 1\n                    elif bcnt >= 1:\n                        a[i][j] = 'B'\n                        change = 1\n        if ans == 0:\n            return 0\n        if change == 0:\n            break\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == '?':\n                if a[i + 1][j] != '?' and a[i - 1][j] != '?' and (a[i][j + 1] != '?') and (a[i][j - 1] != '?'):\n                    a[i][j] = 'B'\n                    total = cnt(dc(a), n)\n                    total *= 3\n                    return ans * total % 1000000007\n                total = 0\n                a[i][j] = 'G'\n                total += cnt(dc(a), n)\n                a[i][j] = 'B'\n                total += cnt(dc(a), n) * 2\n                return ans * total % 1000000007\n    return ans % 1000000007\n\ndef valid(a, n):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == 'G':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G'):\n                    return False\n            elif a[i][j] == 'B':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                    return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    a.append([0] * (n + 2))\n    for i in range(1, n + 1):\n        a.append(list(input()))\n        a[i].insert(0, 0)\n        a[i].append(0)\n    a.append([0] * (n + 2))\n    print(cnt(a, n))", "from copy import deepcopy\ndc = deepcopy\n\ndef cnt(a, n):\n    ans = 1\n    while True:\n        change = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if a[i][j] == 'G':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G') or (a[i + 1][j] == '?') or (a[i - 1][j] == '?') or (a[i][j - 1] == '?') or (a[i][j + 1] == '?'):\n                        ans = 0\n                elif a[i][j] == 'B':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                        ans = 0\n                elif a[i][j] == '?':\n                    bcnt = gcnt = pcnt = qcnt = dcnt = 0\n                    k = a[i + 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i - 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j - 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j + 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    if pcnt >= 1 and bcnt >= 1:\n                        ans = 0\n                    elif dcnt == 4:\n                        ans *= 3\n                        change = 1\n                        a[i][j] = 'G'\n                    elif pcnt >= 1:\n                        a[i][j] = 'P'\n                        change = 1\n                    elif bcnt >= 1:\n                        a[i][j] = 'B'\n                        change = 1\n        if ans == 0:\n            return 0\n        if change == 0:\n            break\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == '?':\n                if a[i + 1][j] != '?' and a[i - 1][j] != '?' and (a[i][j + 1] != '?') and (a[i][j - 1] != '?'):\n                    a[i][j] = 'B'\n                    total = cnt(dc(a), n)\n                    total *= 3\n                    return ans * total % 1000000007\n                total = 0\n                a[i][j] = 'G'\n                total += cnt(dc(a), n)\n                a[i][j] = 'B'\n                total += cnt(dc(a), n) * 2\n                return ans * total % 1000000007\n    return ans % 1000000007\n\ndef valid(a, n):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == 'G':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G'):\n                    return False\n            elif a[i][j] == 'B':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                    return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    a.append([0] * (n + 2))\n    for i in range(1, n + 1):\n        a.append(list(input()))\n        a[i].insert(0, 0)\n        a[i].append(0)\n    a.append([0] * (n + 2))\n    print(cnt(a, n))", "import sys\nsys.setrecursionlimit(10000000)\n\ndef display(arr):\n    for i in arr:\n        for j in i:\n            print(j, end=' ')\n        print('')\n\ndef getConnectedComponents(arr):\n    components = []\n    for i in range(n):\n        for j in range(n):\n            if visited[i][j]:\n                continue\n            else:\n                comp = []\n                queue = [(i, j)]\n                visited[i][j] = True\n                while len(queue) != 0:\n                    curr = queue.pop(0)\n                    comp.append(arr[curr[0]][curr[1]])\n                    for (a, b) in [(curr[0] - 1, curr[1]), (curr[0] + 1, curr[1]), (curr[0], curr[1] - 1), (curr[0], curr[1] + 1)]:\n                        if not (a >= 0 and a < n and (b >= 0) and (b < n)) or visited[a][b]:\n                            continue\n                        queue.append((a, b))\n                        visited[a][b] = True\n                components.append(comp)\n    return components\nfor t in range(int(input())):\n    n = int(input())\n    visited = [[False] * n for i in range(n)]\n    arr = []\n    for i in range(n):\n        arr.append(list(input()))\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = arr[i][j] == '.'\n    components = getConnectedComponents(arr)\n    ans = 1\n    for i in components:\n        ques = 0\n        p = 0\n        b = 0\n        g = 0\n        for j in i:\n            if j == '?':\n                ques += 1\n            elif j == 'P':\n                p += 1\n            elif j == 'B':\n                b += 1\n            elif j == 'G':\n                g += 1\n        if g and len(i) > 1:\n            ans = 0\n            break\n        elif p and b:\n            ans = 0\n            break\n        elif p == 0 and b == 0 and (g == 0):\n            if len(i) == 1:\n                ans *= 3\n            else:\n                ans *= 2\n    print(ans % (10 ** 9 + 7))", "from copy import deepcopy\ndc = deepcopy\n\ndef cnt(a, n):\n    ans = 1\n    while True:\n        change = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if a[i][j] == 'G':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G') or (a[i + 1][j] == '?') or (a[i - 1][j] == '?') or (a[i][j - 1] == '?') or (a[i][j + 1] == '?'):\n                        ans = 0\n                elif a[i][j] == 'B':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                        ans = 0\n                elif a[i][j] == '?':\n                    bcnt = gcnt = pcnt = qcnt = dcnt = 0\n                    k = a[i + 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i - 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j - 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j + 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    if pcnt >= 1 and bcnt >= 1:\n                        ans = 0\n                    elif dcnt == 4:\n                        ans *= 3\n                        change = 1\n                        a[i][j] = 'G'\n                    elif pcnt >= 1:\n                        a[i][j] = 'P'\n                        change = 1\n                    elif bcnt >= 1:\n                        a[i][j] = 'B'\n                        change = 1\n        if ans == 0:\n            return 0\n        if change == 0:\n            break\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == '?':\n                if a[i + 1][j] != '?' and a[i - 1][j] != '?' and (a[i][j + 1] != '?') and (a[i][j - 1] != '?'):\n                    a[i][j] = 'B'\n                    total = cnt(dc(a), n)\n                    total *= 3\n                    return ans * total % 1000000007\n                total = 0\n                a[i][j] = 'G'\n                total += cnt(dc(a), n)\n                a[i][j] = 'B'\n                total += cnt(dc(a), n) * 2\n                return ans * total % 1000000007\n    return ans % 1000000007\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    a.append([0] * (n + 2))\n    for i in range(1, n + 1):\n        a.append(list(input()))\n        a[i].insert(0, 0)\n        a[i].append(0)\n    a.append([0] * (n + 2))\n    print(cnt(a, n))", "def getSpecies(arr, n):\n    s = []\n    nghbr = ('B', 'P')\n    count = 1\n    for i in range(n):\n        for j in range(n):\n            if arr[i][j] == '?':\n                c = 'N'\n                l = 0\n                s.append((i, j))\n                while len(s) != 0:\n                    l += 1\n                    (i1, j1) = s.pop()\n                    arr[i1][j1] = 'D'\n                    if i1 != 0:\n                        if arr[i1 - 1][j1] == '?':\n                            s.append((i1 - 1, j1))\n                        if arr[i1 - 1][j1] == 'G':\n                            return 0\n                        elif arr[i1 - 1][j1] in nghbr:\n                            if c == 'N' or c == arr[i1 - 1][j1]:\n                                c = arr[i1 - 1][j1]\n                            else:\n                                return 0\n                    if j1 != 0:\n                        if arr[i1][j1 - 1] == '?':\n                            s.append((i1, j1 - 1))\n                        elif arr[i1][j1 - 1] == 'G':\n                            return 0\n                        elif arr[i1][j1 - 1] in nghbr:\n                            if c == 'N' or c == arr[i1][j1 - 1]:\n                                c = arr[i1][j1 - 1]\n                            else:\n                                return 0\n                    if i1 != n - 1:\n                        if arr[i1 + 1][j1] == '?':\n                            s.append((i1 + 1, j1))\n                        elif arr[i1 + 1][j1] == 'G':\n                            return 0\n                        elif arr[i1 + 1][j1] in nghbr:\n                            if c == 'N' or c == arr[i1 + 1][j1]:\n                                c = arr[i1 + 1][j1]\n                            else:\n                                return 0\n                    if j1 != n - 1:\n                        if arr[i1][j1 + 1] == '?':\n                            s.append((i1, j1 + 1))\n                        elif arr[i1][j1 + 1] == 'G':\n                            return 0\n                        elif arr[i1][j1 + 1] in nghbr:\n                            if c == 'N' or c == arr[i1][j1 + 1]:\n                                c = arr[i1][j1 + 1]\n                            else:\n                                return 0\n                if c == 'N':\n                    if l == 1:\n                        count = count * 3 % (10 ** 9 + 7)\n                    else:\n                        count = count * 2 % (10 ** 9 + 7)\n            elif arr[i][j] == 'G':\n                if i != n - 1 and (arr[i + 1][j] == 'G' or arr[i + 1][j] in nghbr):\n                    return 0\n                elif j != n - 1 and (arr[i][j + 1] == 'G' or arr[i][j + 1] in nghbr):\n                    return 0\n                elif i != 0 and (arr[i - 1][j] == 'G' or arr[i - 1][j] in nghbr):\n                    return 0\n                elif j != 0 and (arr[i][j - 1] == 'G' or arr[i][j - 1] in nghbr):\n                    return 0\n            elif arr[i][j] == 'B':\n                if i != n - 1 and arr[i + 1][j] == 'P':\n                    return 0\n                elif j != n - 1 and arr[i][j + 1] == 'P':\n                    return 0\n                elif i != 0 and arr[i - 1][j] == 'P':\n                    return 0\n                elif j != 0 and arr[i][j - 1] == 'P':\n                    return 0\n            elif arr[i][j] == 'P':\n                if i != n - 1 and arr[i + 1][j] == 'B':\n                    return 0\n                elif j != n - 1 and arr[i][j + 1] == 'B':\n                    return 0\n                elif i != 0 and arr[i - 1][j] == 'B':\n                    return 0\n                elif j != 0 and arr[i][j - 1] == 'B':\n                    return 0\n    return count % (10 ** 9 + 7)\nt = int(input())\nfor t1 in range(t):\n    n = int(input())\n    arr = [None] * n\n    for i in range(n):\n        arr[i] = [ch for ch in input()]\n    print(getSpecies(arr, n) % (10 ** 9 + 7))", "from copy import deepcopy\ndc = deepcopy\n\ndef cnt(a, n):\n    ans = 1\n    while True:\n        change = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if a[i][j] == 'G':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G') or (a[i + 1][j] == '?') or (a[i - 1][j] == '?') or (a[i][j - 1] == '?') or (a[i][j + 1] == '?'):\n                        ans = 0\n                elif a[i][j] == 'B':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                        ans = 0\n                elif a[i][j] == '?':\n                    bcnt = gcnt = pcnt = qcnt = dcnt = 0\n                    k = a[i + 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i - 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j - 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j + 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    if pcnt >= 1 and bcnt >= 1:\n                        ans = 0\n                    elif dcnt == 4:\n                        ans *= 3\n                        change = 1\n                        a[i][j] = 'G'\n                    elif pcnt >= 1:\n                        a[i][j] = 'P'\n                        change = 1\n                    elif bcnt >= 1:\n                        a[i][j] = 'B'\n                        change = 1\n        if ans == 0:\n            return 0\n        if change == 0:\n            break\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == '?':\n                if a[i + 1][j] != '?' and a[i - 1][j] != '?' and (a[i][j + 1] != '?') and (a[i][j - 1] != '?'):\n                    a[i][j] = 'B'\n                    total = cnt(dc(a), n)\n                    total *= 3\n                    return ans * total % 1000000007\n                total = 0\n                a[i][j] = 'G'\n                total += cnt(dc(a), n)\n                a[i][j] = 'B'\n                total += cnt(dc(a), n) * 2\n                return ans * total % 1000000007\n    return ans % 1000000007\n\ndef valid(a, n):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == 'G':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G'):\n                    return False\n            elif a[i][j] == 'B':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                    return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    a.append([0] * (n + 2))\n    for i in range(1, n + 1):\n        a.append(list(input()))\n        a[i].insert(0, 0)\n        a[i].append(0)\n    a.append([0] * (n + 2))\n    print(cnt(a, n))", "import sys\nsys.setrecursionlimit(10000000)\n\ndef display(arr):\n    for i in arr:\n        for j in i:\n            print(j, end=' ')\n        print('')\n\ndef getConnectedComponents(arr):\n    components = []\n    for i in range(n):\n        for j in range(n):\n            if visited[i][j]:\n                continue\n            else:\n                comp = []\n                queue = [(i, j)]\n                visited[i][j] = True\n                while len(queue) != 0:\n                    curr = queue.pop(0)\n                    comp.append(arr[curr[0]][curr[1]])\n                    for (a, b) in [(curr[0] - 1, curr[1]), (curr[0] + 1, curr[1]), (curr[0], curr[1] - 1), (curr[0], curr[1] + 1)]:\n                        if not (a >= 0 and a < n and (b >= 0) and (b < n)) or visited[a][b]:\n                            continue\n                        queue.append((a, b))\n                        visited[a][b] = True\n                components.append(comp)\n    return components\nfor t in range(int(input())):\n    n = int(input())\n    visited = [[False] * n for i in range(n)]\n    arr = []\n    for i in range(n):\n        arr.append(list(input()))\n    for i in range(n):\n        for j in range(n):\n            visited[i][j] = arr[i][j] == '.'\n    components = getConnectedComponents(arr)\n    ans = 1\n    for i in components:\n        ques = 0\n        p = 0\n        b = 0\n        g = 0\n        for j in i:\n            if j == '?':\n                ques += 1\n            elif j == 'P':\n                p += 1\n            elif j == 'B':\n                b += 1\n            elif j == 'G':\n                g += 1\n        if g and len(i) > 1:\n            ans = 0\n            break\n        elif p and b:\n            ans = 0\n            break\n        elif p == 0 and b == 0 and (g == 0):\n            if len(i) == 1:\n                ans *= 3\n            else:\n                ans *= 2\n    print(ans % (10 ** 9 + 7))", "def connectedComponents(board):\n    n = len(board)\n    visited = [[False] * n for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if visited[i][j]:\n                continue\n            if board[i][j] == '?':\n                yield component((i, j), board, visited)\n\ndef component(start, board, visited):\n    size = 0\n    bears = set()\n    queue = [start]\n    while queue:\n        (i, j) = queue.pop()\n        if visited[i][j]:\n            continue\n        what = board[i][j]\n        if what == '.':\n            continue\n        if what == '?':\n            visited[i][j] = True\n            size += 1\n            queue.extend(neighbours((i, j), board))\n        else:\n            bears.add(what)\n    return (size, bears)\n\ndef neighbours(coord, board):\n    (i, j) = coord\n    if i > 0:\n        yield (i - 1, j)\n    if j > 0:\n        yield (i, j - 1)\n    n = len(board) - 1\n    if i < n:\n        yield (i + 1, j)\n    if j < n:\n        yield (i, j + 1)\n\ndef nSolutions(board):\n    n = 1\n    for (size, neighbears) in connectedComponents(board):\n        if 'G' in neighbears or len(neighbears) == 2:\n            return 0\n        if len(neighbears) == 1:\n            continue\n        n = n * (3 if size == 1 else 2) % 1000000007\n    return n\n\ndef stupid(board):\n    n = len(board)\n    bears = frozenset(('B', 'G', 'P'))\n    for i in range(n):\n        for j in range(n):\n            x = board[i][j]\n            if x not in bears:\n                continue\n            neighs = ()\n            if i + 1 < n:\n                neighs += ((i + 1, j),)\n            if j + 1 < n:\n                neighs += ((i, j + 1),)\n            for (k, l) in neighs:\n                y = board[k][l]\n                if y == 'G' or (y in bears and x != y):\n                    return True\n    return False\nfor testIdx in range(int(input())):\n    n = int(input())\n    board = list((input() for i in range(n)))\n    if stupid(board):\n        print('0')\n    else:\n        print(nSolutions(board))", "from copy import deepcopy\ndc = deepcopy\n\ndef cnt(a, n):\n    ans = 1\n    while True:\n        change = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if a[i][j] == 'G':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G') or (a[i + 1][j] == '?') or (a[i - 1][j] == '?') or (a[i][j - 1] == '?') or (a[i][j + 1] == '?'):\n                        ans = 0\n                elif a[i][j] == 'B':\n                    if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                        ans = 0\n                elif a[i][j] == '?':\n                    bcnt = gcnt = pcnt = qcnt = dcnt = 0\n                    k = a[i + 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i - 1][j]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j - 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    k = a[i][j + 1]\n                    if k == 'B':\n                        bcnt += 1\n                    if k == 'G':\n                        gcnt += 1\n                    if k == 'P':\n                        pcnt += 1\n                    if k == '?':\n                        qcnt += 1\n                    if k == '.':\n                        dcnt += 1\n                    if pcnt >= 1 and bcnt >= 1:\n                        ans = 0\n                    elif dcnt == 4:\n                        ans *= 3\n                        change = 1\n                        a[i][j] = 'G'\n                    elif pcnt >= 1:\n                        a[i][j] = 'P'\n                        change = 1\n                    elif bcnt >= 1:\n                        a[i][j] = 'B'\n                        change = 1\n        if ans == 0:\n            return 0\n        if change == 0:\n            break\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == '?':\n                if a[i + 1][j] != '?' and a[i - 1][j] != '?' and (a[i][j + 1] != '?') and (a[i][j - 1] != '?'):\n                    a[i][j] = 'B'\n                    total = cnt(dc(a), n)\n                    total *= 3\n                    return ans * total % 1000000007\n                total = 0\n                a[i][j] = 'G'\n                total += cnt(dc(a), n)\n                a[i][j] = 'B'\n                total += cnt(dc(a), n) * 2\n                return ans * total % 1000000007\n    return ans % 1000000007\n\ndef valid(a, n):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i][j] == 'G':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P') or (a[i + 1][j] == 'B') or (a[i - 1][j] == 'B') or (a[i][j - 1] == 'B') or (a[i][j + 1] == 'B') or (a[i + 1][j] == 'G') or (a[i - 1][j] == 'G') or (a[i][j - 1] == 'G') or (a[i][j + 1] == 'G'):\n                    return False\n            elif a[i][j] == 'B':\n                if a[i + 1][j] == 'P' or a[i - 1][j] == 'P' or a[i][j - 1] == 'P' or (a[i][j + 1] == 'P'):\n                    return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    a.append([0] * (n + 2))\n    for i in range(1, n + 1):\n        a.append(list(input()))\n        a[i].insert(0, 0)\n        a[i].append(0)\n    a.append([0] * (n + 2))\n    print(cnt(a, n))"]