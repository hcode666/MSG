["import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    for _ in range(int(input())):\n        (nodes, queries) = map(int, input().split())\n        cost = list(map(int, input().split()))\n        graph = [[] for _ in range(nodes)]\n\n        def dfs(node, par):\n            if node == 0:\n                parent[0] = -1\n                height[0] = 0\n            else:\n                parent[node] = par\n                height[node] = height[par] + 1\n            for child in graph[node]:\n                if child == par:\n                    continue\n                else:\n                    dfs(child, node)\n        for _ in range(nodes - 1):\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            graph[a].append(b)\n            graph[b].append(a)\n        parent = [0] * nodes\n        height = [0] * nodes\n        dfs(0, -1)\n        for _ in range(queries):\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            if height[a] < height[b]:\n                (a, b) = (b, a)\n            ans = []\n            while height[a] != height[b] and len(ans) <= 100:\n                ans.append(cost[a])\n                a = parent[a]\n            while a != b and len(ans) <= 100:\n                ans.append(cost[a])\n                ans.append(cost[b])\n                a = parent[a]\n                b = parent[b]\n            ans.append(cost[b])\n            if len(ans) > 100:\n                print(0)\n            else:\n                ans.sort()\n                res = float('inf')\n                for i in range(len(ans) - 1):\n                    res = min(res, ans[i + 1] - ans[i])\n                print(res)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    for _ in range(int(input())):\n        (nodes, queries) = map(int, input().split())\n        cost = list(map(int, input().split()))\n        graph = [[] for _ in range(nodes)]\n\n        def dfs(node, par):\n            if node == 0:\n                parent[0] = -1\n                height[0] = 0\n            else:\n                parent[node] = par\n                height[node] = height[par] + 1\n            for child in graph[node]:\n                if child == par:\n                    continue\n                else:\n                    dfs(child, node)\n        for _ in range(nodes - 1):\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            graph[a].append(b)\n            graph[b].append(a)\n        parent = [0] * nodes\n        height = [0] * nodes\n        dfs(0, -1)\n        for _ in range(queries):\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            if height[a] < height[b]:\n                (a, b) = (b, a)\n            ans = []\n            while height[a] != height[b] and len(ans) <= 100:\n                ans.append(cost[a])\n                a = parent[a]\n            while a != b and len(ans) <= 100:\n                ans.append(cost[a])\n                ans.append(cost[b])\n                a = parent[a]\n                b = parent[b]\n            ans.append(cost[b])\n            if len(ans) > 100:\n                print(0)\n            else:\n                ans.sort()\n                res = float('inf')\n                for i in range(len(ans) - 1):\n                    res = min(res, ans[i + 1] - ans[i])\n                print(res)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\n\ndef fop(s, end='\\n'):\n    sys.stdout.write(str(s) + end)\n\ndef fip():\n    return sys.stdin.readline().strip()\n\ndef solve():\n    elements = set()\n    (u, v) = map(int, fip().split())\n    flag = True\n    if depth[u] < depth[v]:\n        (u, v) = (v, u)\n    while depth[u] > depth[v]:\n        if a[u - 1] not in elements:\n            elements.add(a[u - 1])\n        else:\n            return 0\n        u = parent[u]\n    while u != v:\n        if a[u - 1] not in elements:\n            elements.add(a[u - 1])\n        else:\n            return 0\n        if a[v - 1] not in elements:\n            elements.add(a[v - 1])\n        else:\n            return 0\n        u = parent[u]\n        v = parent[v]\n    if a[u - 1] not in elements:\n        elements.add(a[u - 1])\n    else:\n        return 0\n    ans = 100\n    elements = sorted(elements)\n    for i in range(1, len(elements)):\n        ans = min(ans, abs(elements[i] - elements[i - 1]))\n        if ans == 1:\n            return 1\n    return ans\nfrom collections import deque\nt = int(fip())\nwhile t > 0:\n    t -= 1\n    (n, queries) = map(int, fip().split())\n    tree = [set() for i in range(n + 1)]\n    a = [int(x) for x in fip().split()]\n    for i in range(n - 1):\n        (u, v) = map(int, fip().split())\n        tree[u].add(v)\n        tree[v].add(u)\n    depth = [-1 for i in range(n + 1)]\n    parent = [-1 for i in range(n + 1)]\n    parent[1] = 0\n    depth[1] = 0\n    q = deque([1])\n    while len(q) != 0:\n        curr = q.popleft()\n        for child in tree[curr]:\n            if depth[child] < 0:\n                q.append(child)\n                depth[child] = depth[curr] + 1\n                parent[child] = curr\n    for i in range(queries):\n        fop(solve())", "from collections import deque\n\ndef readTree(n):\n    adj = [set() for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    return adj\n\ndef main():\n\n    def solve():\n        (n, q) = map(int, input().split())\n        aa = [int(a) for a in input().split()]\n        adj = readTree(n)\n        dq = deque()\n        dq.append(0)\n        parent = [-2] + [-1] * (n - 1)\n        depth = [0] * n\n        parent[0] = 0\n        while dq:\n            nd = dq.popleft()\n            for a in adj[nd]:\n                if parent[a] < 0:\n                    parent[a] = nd\n                    depth[a] = depth[nd] + 1\n                    dq.append(a)\n\n        def solve1():\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            values = set()\n            if depth[b] > depth[a]:\n                (b, a) = (a, b)\n            while depth[a] > depth[b]:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n            while a != b:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n                if aa[b] in values:\n                    print(0)\n                    return\n                values.add(aa[b])\n                b = parent[b]\n            if aa[a] in values:\n                print(0)\n                return\n            values.add(aa[a])\n            lv = list(values)\n            lv.sort()\n            mn = n\n            for i in range(len(lv) - 1):\n                mn = min(lv[i + 1] - lv[i], mn)\n                if mn == 1:\n                    break\n            print(mn)\n        for _ in range(q):\n            solve1()\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "from collections import defaultdict\nfrom collections import deque\nimport sys\n\ndef fop(s, end='\\n'):\n    sys.stdout.write(str(s) + end)\n\ndef fip():\n    return sys.stdin.readline().strip()\n\ndef find_parent_and_depth(curr: int, prev: int=-1, depth1: int=0) -> None:\n    d = deque()\n    parent[curr] = prev\n    depth[curr] = 0\n    d.append(curr)\n    while d:\n        node = d.popleft()\n        for n in tree[node]:\n            if parent[n] == -2:\n                parent[n] = node\n                depth[n] = depth[node] + 1\n                d.append(n)\n\ndef solve(a: int, b: int) -> int:\n    arr = set()\n    while a != b:\n        if depth[a] > depth[b]:\n            if a_list[a] in arr:\n                return 0\n            arr.add(a_list[a])\n            a = parent[a]\n        else:\n            if a_list[b] in arr:\n                return 0\n            arr.add(a_list[b])\n            b = parent[b]\n    if a_list[a] in arr:\n        return 0\n    arr.add(a_list[a])\n    l = sorted(arr)\n    res = float('inf')\n    for (p, n) in zip(l, l[1:]):\n        res = min(res, abs(p - n))\n    return res\nN = 200005\nt = int(fip())\nfor _ in range(t):\n    tree = [0] * N\n    parent = [-2] * N\n    depth = [-2] * N\n    (n, q) = map(int, fip().split())\n    a_list = list(map(int, fip().split()))\n    for _ in range(n - 1):\n        (u, v) = map(int, fip().split())\n        if tree[u - 1] == 0:\n            tree[u - 1] = set()\n        if tree[v - 1] == 0:\n            tree[v - 1] = set()\n        tree[u - 1].add(v - 1)\n        tree[v - 1].add(u - 1)\n    t = find_parent_and_depth(0)\n    for _ in range(q):\n        (a, b) = map(int, fip().split())\n        res = solve(a - 1, b - 1)\n        fop(res)", "import sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef fop(s, end='\\n'):\n    sys.stdout.write(str(s) + end)\n\ndef fip():\n    return sys.stdin.readline().strip()\n\ndef find_parent_and_depth(curr: int, prev: int=-1, depth1: int=0) -> None:\n    node_check = set()\n    d = deque()\n    parent[curr] = prev\n    depth[curr] = 0\n    d.append(curr)\n    node_check.add(curr)\n    while d:\n        node = d.popleft()\n        for n in tree[node]:\n            if n not in node_check:\n                parent[n] = node\n                depth[n] = depth[node] + 1\n                d.append(n)\n                node_check.add(n)\n\ndef solve(a: int, b: int) -> int:\n    arr = set()\n    while a != b:\n        if depth[a] > depth[b]:\n            if a_list[a] in arr:\n                return 0\n            arr.add(a_list[a])\n            a = parent[a]\n        else:\n            if a_list[b] in arr:\n                return 0\n            arr.add(a_list[b])\n            b = parent[b]\n    if a_list[a] in arr:\n        return 0\n    arr.add(a_list[a])\n    l = sorted(arr)\n    res = float('inf')\n    for (p, n) in zip(l, l[1:]):\n        res = min(res, abs(p - n))\n    return res\ntree = defaultdict(set)\nparent = defaultdict(int)\ndepth = defaultdict(int)\nt = int(fip())\nfor _ in range(t):\n    (n, q) = map(int, fip().split())\n    a_list = list(map(int, fip().split()))\n    tree.clear()\n    parent.clear()\n    depth.clear()\n    for _ in range(n - 1):\n        (u, v) = map(int, fip().split())\n        tree[u - 1].add(v - 1)\n        tree[v - 1].add(u - 1)\n    t = find_parent_and_depth(0)\n    for _ in range(q):\n        (a, b) = map(int, fip().split())\n        res = solve(a - 1, b - 1)\n        fop(res)", "from collections import deque\n\ndef readTree(n):\n    adj = [set() for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    return adj\n\ndef main():\n\n    def solve():\n        (n, q) = map(int, input().split())\n        aa = [int(a) for a in input().split()]\n        adj = readTree(n)\n        dq = deque()\n        dq.append(0)\n        parent = [-2] + [-1] * (n - 1)\n        depth = [0] * n\n        while dq:\n            nd = dq.popleft()\n            for a in adj[nd]:\n                if parent[a] < 0:\n                    parent[a] = nd\n                    depth[a] = depth[nd] + 1\n                    dq.append(a)\n\n        def solve1():\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            values = set()\n            if depth[b] > depth[a]:\n                (b, a) = (a, b)\n            while depth[a] > depth[b]:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n            while a != b:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n                if aa[b] in values:\n                    print(0)\n                    return\n                values.add(aa[b])\n                b = parent[b]\n            if aa[a] in values:\n                print(0)\n                return\n            values.add(aa[a])\n            lv = list(values)\n            lv.sort()\n            mn = n\n            for i in range(len(lv) - 1):\n                mn = min(lv[i + 1] - lv[i], mn)\n                if mn == 1:\n                    break\n            print(mn)\n        for _ in range(q):\n            solve1()\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "from collections import deque\n\ndef solve(parent, depth, aa):\n    (a, b) = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    values = set()\n    if depth[b] > depth[a]:\n        (a, b) = (b, a)\n    while depth[a] > depth[b]:\n        if aa[a] in values:\n            return 0\n        values.add(aa[a])\n        a = parent[a]\n    while a != b:\n        if aa[a] in values:\n            return 0\n        values.add(aa[a])\n        a = parent[a]\n        if aa[b] in values:\n            return 0\n        values.add(aa[b])\n        b = parent[b]\n    if aa[a] in values:\n        return 0\n    values.add(aa[a])\n    l = list(values)\n    l.sort()\n    mn = 1000000.0\n    for i in range(len(l) - 1):\n        mn = min(mn, l[i + 1] - l[i])\n        if mn == 1:\n            break\n    return mn\nfor T in range(int(input())):\n    (n, q) = list(map(int, input().split()))\n    aa = list(map(int, input().split()))\n    adj = [set() for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    parent = [-1] * n\n    parent[0] = 0\n    depth = [0] * n\n    dq = deque()\n    dq.append(0)\n    while dq:\n        p = dq.popleft()\n        for i in adj[p]:\n            if parent[i] < 0:\n                parent[i] = p\n                depth[i] = depth[p] + 1\n                dq.append(i)\n    for i in range(q):\n        v = solve(parent, depth, aa)\n        print(v)", "from collections import deque\n\ndef readTree(n):\n    adj = [set() for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    return adj\n\ndef main():\n\n    def solve():\n        (n, q) = map(int, input().split())\n        aa = [int(a) for a in input().split()]\n        adj = readTree(n)\n        dq = deque()\n        dq.append(0)\n        parent = [-2] + [-1] * (n - 1)\n        depth = [0] * n\n        while dq:\n            nd = dq.popleft()\n            for a in adj[nd]:\n                if parent[a] < 0 and parent[a] != -2:\n                    parent[a] = nd\n                    depth[a] = depth[nd] + 1\n                    dq.append(a)\n\n        def solve1():\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            values = set()\n            if depth[b] > depth[a]:\n                (b, a) = (a, b)\n            while depth[a] > depth[b]:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n            while a != b:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n                if aa[b] in values:\n                    print(0)\n                    return\n                values.add(aa[b])\n                b = parent[b]\n            if aa[a] in values:\n                print(0)\n                return\n            values.add(aa[a])\n            lv = list(values)\n            lv.sort()\n            mn = n\n            for i in range(len(lv) - 1):\n                mn = min(lv[i + 1] - lv[i], mn)\n                if mn == 1:\n                    break\n            print(mn)\n        for _ in range(q):\n            solve1()\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "from collections import deque\n\ndef readTree(n):\n    adj = [set() for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    return adj\n\ndef main():\n\n    def solve():\n        (n, q) = map(int, input().split())\n        aa = [int(a) for a in input().split()]\n        adj = readTree(n)\n        dq = deque()\n        dq.append(0)\n        parent = [-2] + [-1] * (n - 1)\n        depth = [0] * n\n        while dq:\n            nd = dq.popleft()\n            for a in adj[nd]:\n                if parent[a] < 0:\n                    parent[a] = nd\n                    depth[a] = depth[nd] + 1\n                    dq.append(a)\n\n        def solve1():\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            values = set()\n            if depth[b] > depth[a]:\n                (b, a) = (a, b)\n            while depth[a] > depth[b]:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n            while a != b:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n                if aa[b] in values:\n                    print(0)\n                    return\n                values.add(aa[b])\n                b = parent[b]\n            if aa[a] in values:\n                print(0)\n                return\n            values.add(aa[a])\n            lv = list(values)\n            lv.sort()\n            mn = n\n            for i in range(len(lv) - 1):\n                mn = min(lv[i + 1] - lv[i], mn)\n                if mn == 1:\n                    break\n            print(mn)\n        for _ in range(q):\n            solve1()\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "def bfs(length):\n    queue = [1] * (length + 1)\n    pos = 1\n    level[1] = 0\n    while pos >= 1:\n        pushed_node = queue[pos]\n        pos -= 1\n        depth = level[pushed_node] + 1\n        for node in tree[pushed_node]:\n            if level[node] == -1:\n                level[node] = depth\n                parent[node] = pushed_node\n                pos += 1\n                queue[pos] = node\n\ndef addEdge(first, second):\n    tree[first].append(second)\n    tree[second].append(first)\n\ndef treeDiff(node_a, node_b):\n    frequency = [0] * 101\n    while node_a != node_b:\n        if level[node_a] > level[node_b]:\n            if frequency[value[node_a]] == 1:\n                return 0\n            frequency[value[node_a]] += 1\n            node_a = parent[node_a]\n        else:\n            if frequency[value[node_b]] == 1:\n                return 0\n            frequency[value[node_b]] += 1\n            node_b = parent[node_b]\n    if frequency[value[node_a]] == 1:\n        return 0\n    frequency[value[node_a]] += 1\n    diff = 101\n    previous = -101\n    for i in range(1, 101):\n        if frequency[i] == 1:\n            diff = min(diff, i - previous)\n            previous = i\n    return diff\nt = int(input())\nfor i in range(t):\n    (n, q) = map(int, input().split())\n    value = list(map(int, input().split()))\n    value.insert(0, -1)\n    tree = []\n    for i in range(n + 1):\n        tree.append([])\n    parent = [0] * (n + 1)\n    level = [-1] * (n + 1)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        addEdge(u, v)\n    bfs(n)\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        print(treeDiff(u, v))", "def bfs(length):\n    queue = [1] * (length + 1)\n    pos = 1\n    level[1] = 0\n    while pos >= 1:\n        pushed_node = queue[pos]\n        pos -= 1\n        depth = level[pushed_node] + 1\n        for node in tree[pushed_node]:\n            if level[node] == -1:\n                level[node] = depth\n                parent[node] = pushed_node\n                pos += 1\n                queue[pos] = node\n\ndef addEdge(first, second):\n    tree[first].append(second)\n    tree[second].append(first)\n\ndef treeDiff(node_a, node_b):\n    frequency = [0] * 101\n    while node_a != node_b:\n        if level[node_a] > level[node_b]:\n            if frequency[value[node_a]] == 1:\n                return 0\n            frequency[value[node_a]] += 1\n            node_a = parent[node_a]\n        else:\n            if frequency[value[node_b]] == 1:\n                return 0\n            frequency[value[node_b]] += 1\n            node_b = parent[node_b]\n    if frequency[value[node_a]] == 1:\n        return 0\n    frequency[value[node_a]] += 1\n    diff = 101\n    previous = -101\n    for i in range(1, 101):\n        if frequency[i] == 1:\n            diff = min(diff, i - previous)\n            previous = i\n    return diff\nt = int(input())\nfor i in range(t):\n    (n, q) = map(int, input().split())\n    value = list(map(int, input().split()))\n    value.insert(0, -1)\n    tree = []\n    for i in range(n + 1):\n        tree.append([])\n    parent = [0] * (n + 1)\n    level = [-1] * (n + 1)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        addEdge(u, v)\n    bfs(n)\n    for i in range(q):\n        (u, v) = map(int, input().split())\n        print(treeDiff(u, v))", "import sys\n\ndef fop(s, end='\\n'):\n    sys.stdout.write(str(s) + end)\n\ndef fip():\n    return sys.stdin.readline().strip()\nfintinp = lambda : int(fip())\n\ndef flistinp(func=int):\n    return list(map(func, fip().split()))\n\ndef fnsepline(n, func=str):\n    return [func(fip()) for _ in range(n)]\nfrom collections import deque, defaultdict\n\nclass Graph:\n\n    def __init__(self, n=None):\n        self.node_count = n\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, u, v, w=0):\n        if 1:\n            self.adj_list[u].append([v, w])\n            self.adj_list[v].append([u, w])\n\n    def bfs(self, start=1):\n\n        def _bfs(start, graph=self.adj_list):\n            level = defaultdict(lambda : None)\n            level[start] = 0\n            q = deque([])\n            q.append(start)\n            visited = defaultdict(lambda : False)\n            visited[start] = True\n            prev = defaultdict(lambda : None)\n            while q:\n                node = q.popleft()\n                neighbours = graph[node]\n                for (next_v, w) in neighbours:\n                    if not visited[next_v]:\n                        level[next_v] = level[node] + 1\n                        q.append(next_v)\n                        visited[next_v] = True\n                        prev[next_v] = node\n            return (prev, level)\n        return _bfs(start)\n\ndef make_path(start, end, wt, prev, levels):\n    if levels[start] < levels[end]:\n        (start, end) = (end, start)\n    weights = set([])\n    while levels[start] != levels[end]:\n        if wt[start - 1] in weights:\n            fop(0)\n            return\n        weights.add(wt[start - 1])\n        start = prev[start]\n    while start != end:\n        if wt[start - 1] in weights:\n            fop(0)\n            return 0\n        weights.add(wt[start - 1])\n        if wt[end - 1] in weights:\n            print(0)\n            return 0\n        weights.add(wt[end - 1])\n        start = prev[start]\n        end = prev[end]\n    if wt[end - 1] in weights:\n        fop(0)\n        return\n    weights.add(wt[end - 1])\n    weights = list(weights)\n    weights.sort()\n    fop(min([abs(weights[i] - weights[i + 1]) for i in range(len(weights) - 1)]))\n    return\nfor _ in range(fintinp()):\n    (n, q) = map(int, fip().split())\n    wt = flistinp()\n    g = Graph(n=n)\n    for _ in range(n - 1):\n        (u, v) = map(int, fip().split())\n        g.add_edge(u, v, 0)\n    (prev, levels) = g.bfs()\n    for q_ in range(q):\n        (a, b) = map(int, fip().split())\n        make_path(a, b, wt, prev, levels)", "from collections import deque, defaultdict\n\nclass Graph:\n\n    def __init__(self, n=None):\n        self.node_count = n\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, u, v, w=0):\n        if 1:\n            self.adj_list[u].append([v, w])\n            self.adj_list[v].append([u, w])\n\n    def bfs(self, start=1):\n\n        def _bfs(start, graph=self.adj_list):\n            level = defaultdict(lambda : None)\n            level[start] = 0\n            q = deque([])\n            q.append(start)\n            visited = defaultdict(lambda : False)\n            visited[start] = True\n            prev = defaultdict(lambda : None)\n            while q:\n                node = q.popleft()\n                neighbours = graph[node]\n                for (next_v, w) in neighbours:\n                    if not visited[next_v]:\n                        level[next_v] = level[node] + 1\n                        q.append(next_v)\n                        visited[next_v] = True\n                        prev[next_v] = node\n            return (prev, level)\n        return _bfs(start)\n\ndef make_path(start, end, wt, prev, levels):\n    if levels[start] < levels[end]:\n        (start, end) = (end, start)\n    weights = set([])\n    while levels[start] != levels[end]:\n        if wt[start - 1] in weights:\n            print(0)\n            return\n        weights.add(wt[start - 1])\n        start = prev[start]\n    while start != end:\n        if wt[start - 1] in weights:\n            print(0)\n            return 0\n        weights.add(wt[start - 1])\n        if wt[end - 1] in weights:\n            print(0)\n            return 0\n        weights.add(wt[end - 1])\n        start = prev[start]\n        end = prev[end]\n    if wt[end - 1] in weights:\n        print(0)\n        return\n    weights.add(wt[end - 1])\n    weights = list(weights)\n    weights.sort()\n    print(min([abs(weights[i] - weights[i + 1]) for i in range(len(weights) - 1)]))\n    return\nimport sys\n\ndef fop(s, end='\\n'):\n    sys.stdout.write(str(s) + end)\n\ndef fip():\n    return sys.stdin.readline().strip()\nfintinp = lambda : int(fip())\n\ndef flistinp(func=int):\n    return list(map(func, fip().split()))\n\ndef fnsepline(n, func=str):\n    return [func(fip()) for _ in range(n)]\nfor _ in range(fintinp()):\n    (n, q) = flistinp()\n    wt = flistinp()\n    g = Graph(n=n)\n    for _ in range(n - 1):\n        (u, v) = flistinp()\n        g.add_edge(u, v, 0)\n    (prev, levels) = g.bfs()\n    for q_ in range(q):\n        (a, b) = flistinp()\n        make_path(a, b, wt, prev, levels)", "from collections import deque\nfrom sys import stdin\n\ndef II():\n    return int(stdin.readline())\n\ndef MI():\n    return map(int, stdin.readline().split())\n\ndef LI():\n    return list(map(int, stdin.readline().split()))\n\nclass tree:\n\n    def __init__(self, V):\n        self.nodes = V\n        self.adj = [[] for i in range(V)]\n        self.parent = [-1] * V\n        self.level = [-1] * V\n\ndef addEdge(ta, v, w):\n    ta.adj[v].append(w)\n    ta.adj[w].append(v)\n\ndef BFS(ta, s):\n    queue = deque([s])\n    ta.level[s] = 0\n    while queue:\n        x = queue.popleft()\n        for i in ta.adj[x]:\n            if ta.level[i] == -1:\n                ta.level[i] = ta.level[x] + 1\n                ta.parent[i] = x\n                queue.append(i)\n\ndef readUV():\n    (u, v) = MI()\n    (u, v) = (u - 1, v - 1)\n    return (u, v)\n\ndef solve(ta, a, b, aa):\n    if ta.level[a] < ta.level[b]:\n        (a, b) = (b, a)\n    vals = set()\n    while ta.level[b] != ta.level[a]:\n        if aa[a] in vals:\n            print(0)\n            return\n        vals.add(aa[a])\n        a = ta.parent[a]\n    while b != a:\n        if aa[a] in vals:\n            print(0)\n            return\n        vals.add(aa[a])\n        if aa[b] in vals:\n            print(0)\n            return\n        vals.add(aa[b])\n        (a, b) = (ta.parent[a], ta.parent[b])\n    if aa[a] in vals:\n        print(0)\n        return\n    vals.add(aa[a])\n    (ans, x) = (101, len(vals))\n    vals = list(vals)\n    vals.sort()\n    for j in range(1, x):\n        ans = min(ans, vals[j] - vals[j - 1])\n        if ans == 1:\n            break\n    print(ans)\nt = II()\nfor _ in range(t):\n    (n, q) = MI()\n    aa = LI()\n    atree = tree(n)\n    for i in range(n - 1):\n        (u, v) = readUV()\n        addEdge(atree, u, v)\n    BFS(atree, 0)\n    for i in range(q):\n        (a, b) = readUV()\n        solve(atree, a, b, aa)", "from collections import deque\nfrom sys import stdin\n\ndef II():\n    return int(stdin.readline())\n\ndef MI():\n    return map(int, stdin.readline().split())\n\ndef LI():\n    return list(map(int, stdin.readline().split()))\n\nclass tree:\n\n    def __init__(self, V):\n        self.nodes = V\n        self.adj = [[] for i in range(V)]\n        self.parent = [-1] * V\n        self.level = [-1] * V\n\ndef addEdge(ta, v, w):\n    ta.adj[v].append(w)\n    ta.adj[w].append(v)\n\ndef BFS(ta, s):\n    queue = deque([s])\n    ta.level[s] = 0\n    while queue:\n        x = queue.popleft()\n        for i in ta.adj[x]:\n            if ta.level[i] == -1:\n                ta.level[i] = ta.level[x] + 1\n                ta.parent[i] = x\n                queue.append(i)\n\ndef readUV():\n    (u, v) = MI()\n    (u, v) = (u - 1, v - 1)\n    return (u, v)\n\ndef solve(ta, a, b, aa):\n    if ta.level[a] < ta.level[b]:\n        (a, b) = (b, a)\n    vals = set()\n    while ta.level[b] != ta.level[a]:\n        if aa[a] in vals:\n            print(0)\n            return\n        vals.add(aa[a])\n        a = ta.parent[a]\n    while b != a:\n        if aa[a] in vals:\n            print(0)\n            return\n        vals.add(aa[a])\n        if aa[b] in vals:\n            print(0)\n            return\n        vals.add(aa[b])\n        (a, b) = (ta.parent[a], ta.parent[b])\n    if aa[a] in vals:\n        print(0)\n        return\n    vals.add(aa[a])\n    ans = 101\n    x = len(vals)\n    vals = list(vals)\n    vals.sort()\n    for j in range(1, x):\n        ans = min(ans, vals[j] - vals[j - 1])\n        if ans == 1:\n            break\n    print(ans)\nt = II()\nfor _ in range(t):\n    (n, q) = MI()\n    aa = LI()\n    atree = tree(n)\n    for i in range(n - 1):\n        (u, v) = readUV()\n        addEdge(atree, u, v)\n    BFS(atree, 0)\n    for i in range(q):\n        (a, b) = readUV()\n        solve(atree, a, b, aa)", "from collections import deque\nfrom sys import stdin\n\ndef II():\n    return int(stdin.readline())\n\ndef MI():\n    return map(int, stdin.readline().split())\n\ndef LI():\n    return list(map(int, stdin.readline().split()))\n\nclass tree:\n\n    def __init__(self, V):\n        self.nodes = V\n        self.adj = [[] for i in range(V)]\n        self.parent = [-1] * V\n        self.level = [-1] * V\n\ndef addEdge(ta, v, w):\n    ta.adj[v].append(w)\n    ta.adj[w].append(v)\n\ndef BFS(ta, s):\n    queue = deque([s])\n    ta.level[s] = 0\n    while queue:\n        x = queue.popleft()\n        for i in ta.adj[x]:\n            if ta.level[i] == -1:\n                ta.level[i] = ta.level[x] + 1\n                ta.parent[i] = x\n                queue.append(i)\n\ndef readUV():\n    (u, v) = MI()\n    (u, v) = (u - 1, v - 1)\n    return (u, v)\n\ndef solve(ta, a, b, aa):\n    if ta.level[a] < ta.level[b]:\n        (a, b) = (b, a)\n    vals = set()\n    while ta.level[b] != ta.level[a]:\n        if aa[a] in vals:\n            print(0)\n            return\n        vals.add(aa[a])\n        a = ta.parent[a]\n    while b != a:\n        if aa[a] in vals:\n            print(0)\n            return\n        vals.add(aa[a])\n        if aa[b] in vals:\n            print(0)\n            return\n        vals.add(aa[b])\n        (a, b) = (ta.parent[a], ta.parent[b])\n    if aa[a] in vals:\n        print(0)\n        return\n    vals.add(aa[a])\n    ans = 101\n    x = len(vals)\n    vals = list(vals)\n    vals.sort()\n    for j in range(1, x):\n        ans = min(ans, vals[j] - vals[j - 1])\n        if ans == 1:\n            break\n    print(ans)\nt = II()\nfor _ in range(t):\n    (n, q) = MI()\n    aa = LI()\n    atree = tree(n)\n    for i in range(n - 1):\n        (u, v) = readUV()\n        addEdge(atree, u, v)\n    BFS(atree, 0)\n    for i in range(q):\n        (a, b) = readUV()\n        solve(atree, a, b, aa)", "from collections import deque\n\ndef readTree(n):\n    adj = [set() for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    return adj\n\ndef main():\n\n    def solve():\n        (n, q) = map(int, input().split())\n        aa = [int(a) for a in input().split()]\n        adj = readTree(n)\n        dq = deque()\n        dq.append(0)\n        parent = [-2] + [-1] * (n - 1)\n        depth = [0] * n\n        while dq:\n            nd = dq.popleft()\n            for a in adj[nd]:\n                if parent[a] < 0:\n                    parent[a] = nd\n                    depth[a] = depth[nd] + 1\n                    dq.append(a)\n\n        def solve1():\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            values = set()\n            if depth[b] > depth[a]:\n                (b, a) = (a, b)\n            while depth[a] > depth[b]:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n            while a != b:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n                if aa[b] in values:\n                    print(0)\n                    return\n                values.add(aa[b])\n                b = parent[b]\n            if aa[a] in values:\n                print(0)\n                return\n            values.add(aa[a])\n            lv = list(values)\n            lv.sort()\n            mn = n\n            for i in range(len(lv) - 1):\n                mn = min(lv[i + 1] - lv[i], mn)\n                if mn == 1:\n                    break\n            print(mn)\n        for _ in range(q):\n            solve1()\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "from collections import deque\n\ndef readTree(n):\n    adj = [set() for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    return adj\n\ndef main():\n\n    def solve():\n        (n, q) = map(int, input().split())\n        aa = [int(a) for a in input().split()]\n        adj = readTree(n)\n        dq = deque()\n        dq.append(0)\n        parent = [-2] + [-1] * (n - 1)\n        depth = [0] * n\n        while dq:\n            nd = dq.popleft()\n            for a in adj[nd]:\n                if parent[a] < 0:\n                    parent[a] = nd\n                    depth[a] = depth[nd] + 1\n                    dq.append(a)\n\n        def solve1():\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            values = set()\n            if depth[b] > depth[a]:\n                (b, a) = (a, b)\n            while depth[a] > depth[b]:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n            while a != b:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n                if aa[b] in values:\n                    print(0)\n                    return\n                values.add(aa[b])\n                b = parent[b]\n            if aa[a] in values:\n                print(0)\n                return\n            values.add(aa[a])\n            lv = list(values)\n            lv.sort()\n            mn = n\n            for i in range(len(lv) - 1):\n                mn = min(lv[i + 1] - lv[i], mn)\n                if mn == 1:\n                    break\n            print(mn)\n        for _ in range(q):\n            solve1()\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "import sys\nsys.setrecursionlimit(1000000)\nfrom sys import stdin, stdout\nmaxn = 180000\nlevel = 18\nfrom collections import defaultdict\nfrom collections import deque\n\ndef minans(l):\n    l.sort()\n    ans = float('inf')\n    for i in range(len(l) - 1):\n        ans = min(ans, l[i + 1] - l[i])\n    return ans\n\ndef dfs(cur, prev):\n    depth[cur] = depth[prev] + 1\n    parent[cur][0] = prev\n    for i in range(len(tree[cur])):\n        if tree[cur][i] != prev:\n            dfs(tree[cur][i], cur)\n\ndef precomputeSparseMatrix(n):\n    for i in range(1, level):\n        for node in range(1, n + 1):\n            if parent[node][i - 1] != -1:\n                parent[node][i] = parent[parent[node][i - 1]][i - 1]\n\ndef LCA(u, v):\n    if depth[v] < depth[u]:\n        (u, v) = (v, u)\n    diff = depth[v] - depth[u]\n    for i in range(level):\n        if diff >> i & 1:\n            v = parent[v][i]\n    if u == v:\n        return u\n    for i in range(level - 1, -1, -1):\n        if parent[u][i] != parent[v][i]:\n            u = parent[u][i]\n            v = parent[v][i]\n    return parent[u][0]\n\ndef addEdge(u, v):\n    tree[u].append(v)\n    tree[v].append(u)\n\ndef Bfs(src):\n    visited = defaultdict(bool)\n    dist = defaultdict(int)\n    q = deque([])\n    q.append(src)\n    visited[src] = True\n    dist[src] = 1\n    while q:\n        node = q.popleft()\n        for neighbour in tree[node]:\n            if not visited[neighbour]:\n                q.append(neighbour)\n                visited[neighbour] = True\n                dist[neighbour] = dist[node] + 1\n                parent2[neighbour] = node\n    return dist\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    maxn = n + 1\n    arr = list(map(int, stdin.readline().split()))\n    tree = [[] for i in range(n + 1)]\n    parent2 = [-1] * (n + 1)\n    for i in range(n - 1):\n        (x, y) = map(int, stdin.readline().split())\n        if i == 0:\n            root = x\n        addEdge(x, y)\n    parent = [[-1] * level for j in range(maxn)]\n    depth = [None] * maxn\n    depth[0] = 0\n    dfs(root, 0)\n    precomputeSparseMatrix(n)\n    dist = Bfs(root)\n    for i in range(q):\n        (x, y) = map(int, stdin.readline().split())\n        if x == y:\n            ans = 0\n        else:\n            lca = LCA(x, y)\n            if x == lca and y != lca:\n                ch = dist[y] - dist[lca] + 1\n                if ch <= 100:\n                    path = []\n                    temp = y\n                    while temp != lca:\n                        path.append(arr[temp - 1])\n                        temp = parent2[temp]\n                    path.append(arr[lca - 1])\n                    ans = minans(path)\n                else:\n                    ans = 0\n            elif x != lca and y == lca:\n                ch = dist[x] - dist[lca] + 1\n                if ch <= 100:\n                    path = []\n                    temp = x\n                    while temp != lca:\n                        path.append(arr[temp - 1])\n                        temp = parent2[temp]\n                    path.append(arr[lca - 1])\n                    ans = minans(path)\n                else:\n                    ans = 0\n            else:\n                ch = dist[x] - dist[lca] + (dist[y] - dist[lca]) + 1\n                if ch <= 100:\n                    path = []\n                    temp = x\n                    while temp != lca:\n                        path.append(arr[temp - 1])\n                        temp = parent2[temp]\n                    temp = y\n                    while temp != lca:\n                        path.append(arr[temp - 1])\n                        temp = parent2[temp]\n                    path.append(arr[lca - 1])\n                    ans = minans(path)\n                else:\n                    ans = 0\n        stdout.write(str(ans))\n        print()", "import sys\nsys.setrecursionlimit(1000000)\nfrom sys import stdin, stdout\nmaxn = 180000\nlevel = 18\nfrom collections import defaultdict\nfrom collections import deque\n\ndef minans(l):\n    l.sort()\n    ans = float('inf')\n    for i in range(len(l) - 1):\n        ans = min(ans, l[i + 1] - l[i])\n    return ans\n\ndef dfs(cur, prev):\n    depth[cur] = depth[prev] + 1\n    parent[cur][0] = prev\n    for i in range(len(tree[cur])):\n        if tree[cur][i] != prev:\n            dfs(tree[cur][i], cur)\n\ndef precomputeSparseMatrix(n):\n    for i in range(1, level):\n        for node in range(1, n + 1):\n            if parent[node][i - 1] != -1:\n                parent[node][i] = parent[parent[node][i - 1]][i - 1]\n\ndef LCA(u, v):\n    if depth[v] < depth[u]:\n        (u, v) = (v, u)\n    diff = depth[v] - depth[u]\n    for i in range(level):\n        if diff >> i & 1:\n            v = parent[v][i]\n    if u == v:\n        return u\n    for i in range(level - 1, -1, -1):\n        if parent[u][i] != parent[v][i]:\n            u = parent[u][i]\n            v = parent[v][i]\n    return parent[u][0]\n\ndef addEdge(u, v):\n    tree[u].append(v)\n    tree[v].append(u)\n\ndef Bfs(src):\n    visited = defaultdict(bool)\n    dist = defaultdict(int)\n    q = deque([])\n    q.append(src)\n    visited[src] = True\n    dist[src] = 1\n    while q:\n        node = q.popleft()\n        for neighbour in tree[node]:\n            if not visited[neighbour]:\n                q.append(neighbour)\n                visited[neighbour] = True\n                dist[neighbour] = dist[node] + 1\n                parent2[neighbour] = node\n    return dist\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    maxn = n + 1\n    arr = list(map(int, stdin.readline().split()))\n    tree = [[] for i in range(n + 1)]\n    parent2 = [-1] * (n + 1)\n    for i in range(n - 1):\n        (x, y) = map(int, stdin.readline().split())\n        if i == 0:\n            root = x\n        addEdge(x, y)\n    parent = [[-1] * level for j in range(maxn)]\n    depth = [None] * maxn\n    depth[0] = 0\n    dfs(root, 0)\n    precomputeSparseMatrix(n)\n    dist = Bfs(root)\n    for i in range(q):\n        (x, y) = map(int, stdin.readline().split())\n        if x == y:\n            ans = 0\n        else:\n            lca = LCA(x, y)\n            if x == lca and y != lca:\n                ch = dist[y] - dist[lca] + 1\n                if ch <= 100:\n                    path = []\n                    temp = y\n                    while temp != lca:\n                        path.append(arr[temp - 1])\n                        temp = parent2[temp]\n                    path.append(arr[lca - 1])\n                    ans = minans(path)\n                else:\n                    ans = 0\n            elif x != lca and y == lca:\n                ch = dist[x] - dist[lca] + 1\n                if ch <= 100:\n                    path = []\n                    temp = x\n                    while temp != lca:\n                        path.append(arr[temp - 1])\n                        temp = parent2[temp]\n                    path.append(arr[lca - 1])\n                    ans = minans(path)\n                else:\n                    ans = 0\n            else:\n                ch = dist[x] - dist[lca] + (dist[y] - dist[lca]) + 1\n                if ch <= 100:\n                    path = []\n                    temp = x\n                    while temp != lca:\n                        path.append(arr[temp - 1])\n                        temp = parent2[temp]\n                    temp = y\n                    while temp != lca:\n                        path.append(arr[temp - 1])\n                        temp = parent2[temp]\n                    path.append(arr[lca - 1])\n                    ans = minans(path)\n                else:\n                    ans = 0\n        stdout.write(str(ans))\n        print()", "from sys import stdin, stdout\n\ndef find(A, B, dep, par, arr):\n    (A, B) = sorted([A, B], key=lambda x: dep[x])\n    freq = [0] * 101\n    c = 0\n    while dep[A] != dep[B]:\n        freq[arr[B]] += 1\n        if freq[arr[B]] > 1:\n            return 0\n        B = par[B]\n        c += 1\n        if c > 100:\n            return 0\n    while A != B:\n        freq[arr[A]] += 1\n        freq[arr[B]] += 1\n        if freq[arr[B]] > 1 or freq[arr[A]] > 1:\n            return 0\n        (A, B) = (par[A], par[B])\n        c += 2\n        if c > 100:\n            return 0\n    freq[arr[A]] += 1\n    if freq[arr[A]] > 1:\n        return 0\n    k = freq.index(1)\n    m = float('inf')\n    for i in range(k + 1, 101):\n        if freq[i]:\n            m = min(m, i - k)\n            k = i\n    return m\n\ndef main():\n    for _ in range(int(stdin.readline())):\n        (N, M) = list(map(int, stdin.readline().split()))\n        arr = list(map(int, stdin.readline().split()))\n        graph = [[] for _ in range(N)]\n        for __ in range(N - 1):\n            (A, B) = list(map(int, stdin.readline().split()))\n            graph[A - 1].append(B - 1)\n            graph[B - 1].append(A - 1)\n        (dep, par) = ([-1] * N, [-1] * N)\n        que = [0]\n        (par[0], dep[0]) = (0, 0)\n        for root in que:\n            for k in graph[root]:\n                if k == par[root]:\n                    continue\n                par[k] = root\n                dep[k] = dep[root] + 1\n                que.append(k)\n        for __ in range(M):\n            (A, B) = list(map(int, stdin.readline().split()))\n            print(find(A - 1, B - 1, dep, par, arr))\nmain()", "from sys import stdin, stdout\n\ndef find(A, B, dep, par, arr):\n    (A, B) = sorted([A, B], key=lambda x: dep[x])\n    freq = [0] * 101\n    c = 0\n    while dep[A] != dep[B]:\n        freq[arr[B]] += 1\n        if freq[arr[B]] > 1:\n            return 0\n        B = par[B]\n        c += 1\n        if c > 100:\n            return 0\n    while A != B:\n        freq[arr[A]] += 1\n        freq[arr[B]] += 1\n        if freq[arr[B]] > 1 or freq[arr[A]] > 1:\n            return 0\n        (A, B) = (par[A], par[B])\n        c += 2\n        if c > 100:\n            return 0\n    freq[arr[A]] += 1\n    if freq[arr[A]] > 1:\n        return 0\n    k = freq.index(1)\n    m = float('inf')\n    for i in range(k + 1, 101):\n        if freq[i]:\n            m = min(m, i - k)\n            k = i\n    return m\n\ndef main():\n    for _ in range(int(stdin.readline())):\n        (N, M) = list(map(int, stdin.readline().split()))\n        arr = list(map(int, stdin.readline().split()))\n        graph = [[] for _ in range(N)]\n        for __ in range(N - 1):\n            (A, B) = list(map(int, stdin.readline().split()))\n            graph[A - 1].append(B - 1)\n            graph[B - 1].append(A - 1)\n        (dep, par) = ([-1] * N, [-1] * N)\n        que = [0]\n        (par[0], dep[0]) = (0, 0)\n        for root in que:\n            for k in graph[root]:\n                if k == par[root]:\n                    continue\n                par[k] = root\n                dep[k] = dep[root] + 1\n                que.append(k)\n        for __ in range(M):\n            (A, B) = list(map(int, stdin.readline().split()))\n            print(find(A - 1, B - 1, dep, par, arr))\nmain()", "from collections import deque as d\n\ndef readTree(n, adj):\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    return adj\n\ndef main():\n\n    def solve():\n        (n, q) = map(int, input().split())\n        aa = [int(a) for a in input().split()]\n        adj = readTree(n, [set() for _ in range(n)])\n        dq = d()\n        dq.append(0)\n        (parent, depth) = ([-2] + [-1] * (n - 1), [0] * n)\n        while dq:\n            nd = dq.popleft()\n            for a in adj[nd]:\n                if parent[a] < 0:\n                    parent[a] = nd\n                    depth[a] = depth[nd] + 1\n                    dq.append(a)\n\n        def solve1():\n            (a, b) = map(int, input().split())\n            (a, b, values) = (a - 1, b - 1, set())\n            if depth[b] > depth[a]:\n                (b, a) = (a, b)\n            while depth[a] > depth[b]:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n            while a != b:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n                if aa[b] in values:\n                    print(0)\n                    return\n                values.add(aa[b])\n                b = parent[b]\n            if aa[a] in values:\n                print(0)\n                return\n            values.add(aa[a])\n            (lv, mn) = (sorted(list(values)), n)\n            for i in range(len(lv) - 1):\n                mn = min(lv[i + 1] - lv[i], mn)\n                if mn == 1:\n                    break\n            print(mn)\n        for _ in range(q):\n            solve1()\n    for _ in range(int(input())):\n        solve()\nmain()", "from collections import deque as d\n\ndef readTree(n, adj):\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    return adj\n\ndef main():\n\n    def solve():\n        (n, q) = map(int, input().split())\n        aa = [int(a) for a in input().split()]\n        adj = readTree(n, [set() for _ in range(n)])\n        dq = d()\n        dq.append(0)\n        (parent, depth) = ([-2] + [-1] * (n - 1), [0] * n)\n        while dq:\n            nd = dq.popleft()\n            for a in adj[nd]:\n                if parent[a] < 0:\n                    parent[a] = nd\n                    depth[a] = depth[nd] + 1\n                    dq.append(a)\n\n        def solve1():\n            (a, b) = map(int, input().split())\n            (a, b, values) = (a - 1, b - 1, set())\n            if depth[b] > depth[a]:\n                (b, a) = (a, b)\n            while depth[a] > depth[b]:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n            while a != b:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n                if aa[b] in values:\n                    print(0)\n                    return\n                values.add(aa[b])\n                b = parent[b]\n            if aa[a] in values:\n                print(0)\n                return\n            values.add(aa[a])\n            (lv, mn) = (sorted(list(values)), n)\n            for i in range(len(lv) - 1):\n                mn = min(lv[i + 1] - lv[i], mn)\n                if mn == 1:\n                    break\n            print(mn)\n        for _ in range(q):\n            solve1()\n    for _ in range(int(input())):\n        solve()\nmain()", "from collections import deque as d\n\ndef readTree(n, adj):\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    return adj\n\ndef main():\n\n    def solve():\n        (n, q) = map(int, input().split())\n        aa = [int(a) for a in input().split()]\n        adj = readTree(n, [set() for _ in range(n)])\n        dq = d()\n        dq.append(0)\n        (parent, depth) = ([-2] + [-1] * (n - 1), [0] * n)\n        while dq:\n            nd = dq.popleft()\n            for a in adj[nd]:\n                if parent[a] < 0:\n                    parent[a] = nd\n                    depth[a] = depth[nd] + 1\n                    dq.append(a)\n\n        def solve1():\n            (a, b) = map(int, input().split())\n            (a, b, values) = (a - 1, b - 1, set())\n            if depth[b] > depth[a]:\n                (b, a) = (a, b)\n            while depth[a] > depth[b]:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n            while a != b:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n                if aa[b] in values:\n                    print(0)\n                    return\n                values.add(aa[b])\n                b = parent[b]\n            if aa[a] in values:\n                print(0)\n                return\n            values.add(aa[a])\n            (lv, mn) = (sorted(list(values)), n)\n            for i in range(len(lv) - 1):\n                mn = min(lv[i + 1] - lv[i], mn)\n                if mn == 1:\n                    break\n            print(mn)\n        for _ in range(q):\n            solve1()\n    for _ in range(int(input())):\n        solve()\nmain()", "from collections import deque\n\ndef readTree(n):\n    adj = [set() for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    return adj\n\ndef main():\n\n    def solve():\n        (n, q) = map(int, input().split())\n        aa = [int(a) for a in input().split()]\n        adj = readTree(n)\n        dq = deque()\n        dq.append(0)\n        parent = [-2] + [-1] * (n - 1)\n        depth = [0] * n\n        while dq:\n            nd = dq.popleft()\n            for a in adj[nd]:\n                if parent[a] < 0:\n                    parent[a] = nd\n                    depth[a] = depth[nd] + 1\n                    dq.append(a)\n\n        def solve1():\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            values = set()\n            if depth[b] > depth[a]:\n                (b, a) = (a, b)\n            while depth[a] > depth[b]:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n            while a != b:\n                if aa[a] in values:\n                    print(0)\n                    return\n                values.add(aa[a])\n                a = parent[a]\n                if aa[b] in values:\n                    print(0)\n                    return\n                values.add(aa[b])\n                b = parent[b]\n            if aa[a] in values:\n                print(0)\n                return\n            values.add(aa[a])\n            lv = list(values)\n            lv.sort()\n            mn = n\n            for i in range(len(lv) - 1):\n                mn = min(lv[i + 1] - lv[i], mn)\n                if mn == 1:\n                    break\n            print(mn)\n        for _ in range(q):\n            solve1()\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()"]