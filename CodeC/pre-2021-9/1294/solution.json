["from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    print(answ)", "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    print(answ)", "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    print(answ)", "from math import gcd, sqrt\nmodu = 998244353\n\ndef modified_baby_step_giant_step(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modified_baby_step_giant_step(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answe = pow(2, n - 1, modu) * (pow(2, power, modu) - 1 + modu) % modu % modu\n    if answe == 0:\n        if 1 % m != x:\n            answe = -1\n    if answe == 1:\n        if 1 % m != x or n != -1:\n            answe -= 1\n    print(answe)", "from math import gcd, sqrt\nmodu = 998244353\n\ndef modified_baby_step_giant_step(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modified_baby_step_giant_step(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answe = pow(2, n - 1, modu) * (pow(2, power, modu) - 1 + modu) % modu % modu\n    if answe == 0:\n        if 1 % m != x:\n            answe = -1\n    if answe == 1:\n        if 1 % m != x or n != -1:\n            answe -= 1\n    print(answe)", "from math import gcd, sqrt\nmodu = 998244353\n\ndef modified_baby_step_giant_step(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modified_baby_step_giant_step(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answe = pow(2, n - 1, modu) * (pow(2, power, modu) - 1 + modu) % modu % modu\n    if answe == 0:\n        if 1 % m != x:\n            answe = -1\n    if answe == 1:\n        if 1 % m != x or n != -1:\n            answe -= 1\n    print(answe)", "modulo = 998244353\n\ndef mod_inv(a: int, n: int) -> int:\n    (p, q, b) = (1, 0, n)\n    while b:\n        c = a // b\n        (a, b) = (b, a % b)\n        (p, q) = (q, p - c * q)\n    if a != 1:\n        raise ValueError(f'{a} is not invertible modulo {n}')\n    return p if p >= 0 else p + n\n\ndef factorize(n):\n    factors = {}\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        factors[2] = e\n    p = 3\n    while True:\n        if p * p > n:\n            break\n        e = 0\n        while n % p == 0:\n            n //= p\n            e += 1\n        if e:\n            factors[p] = e\n        p += 2\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef bs_gs(a, b, m, phi_m):\n    n = int(phi_m ** 0.5)\n    inv_a = mod_inv(a, m)\n    dp = {}\n    p = b\n    an = pow(a, n, m)\n    for r in range(n):\n        if p not in dp:\n            dp[p] = r\n        p = p * inv_a % m\n    left = 1\n    for q in range(phi_m // n + 1):\n        if left in dp:\n            return q * n + dp[left]\n        left = left * an % m\n    return -1\n\ndef dl(a, b, m):\n    a %= m\n    b %= m\n    if b == 1:\n        return 0\n    factors_m = factorize(m)\n    common_a = {}\n    common_b = {}\n    aa = a\n    bb = b\n    for (p, em) in factors_m.items():\n        ea = 0\n        if aa != 0:\n            while aa % p == 0:\n                ea += 1\n                aa //= p\n        else:\n            ea = em\n        eb = 0\n        if b != 0:\n            while bb % p == 0:\n                eb += 1\n                bb //= p\n        else:\n            eb = em\n        if ea > 0 and eb == 0 or (ea == 0 and eb > 0):\n            return -1\n        if ea:\n            common_a[p] = ea\n        if eb:\n            common_b[p] = eb\n    for (p, eb) in common_b.items():\n        if eb < factors_m[p]:\n            if eb % common_a[p]:\n                return -1\n            x = eb // common_a[p]\n            if pow(a, x, m) != b:\n                return -1\n            return x\n    x_min = 0\n    for (p, ea) in common_a.items():\n        em = factors_m[p]\n        eb = common_b[p]\n        m //= p ** em\n        x_min = max(x_min, (em + ea - 1) // ea)\n    left = pow(aa, x_min, m)\n    right = 1\n    for (p, ea) in common_a.items():\n        em = factors_m.pop(p)\n        eb = common_b[p]\n        left = left * p ** (ea * x_min - em) % m\n        right = right * p ** (eb - em)\n    right %= m\n    b = mod_inv(left, m) * right * bb % m\n    phi_m = 1\n    for (p, e) in factors_m.items():\n        phi_m *= (p - 1) * p ** (e - 1)\n    ret = bs_gs(a, b, m, phi_m)\n    if ret == -1:\n        return -1\n    return ret + x_min\n\ndef solve_v1(n, x, m):\n    y = (pow(2, n, m) - 1) % m\n    p = 1\n    for l in range(m):\n        if p == x:\n            return (pow(2, l, modulo) - 1) * pow(2, n - 1, modulo) % modulo\n        p = p * y % m\n    return -1\n\ndef solve_v2(n, x, m):\n    if m == 1:\n        return 0\n    if x == 0:\n        if n == 1:\n            return -1\n        return 1\n    y = (pow(2, n, m) - 1) % m\n    l = dl(y, x, m)\n    if l == -1:\n        return -1\n    return (pow(2, l, modulo) - 1) * pow(2, (n - 1) % (modulo - 1), modulo) % modulo\nT = int(input())\nfor _ in range(T):\n    (N, X, M) = map(int, input().strip().split())\n    print(solve_v2(N, X, M))", "from math import gcd, sqrt\nmodu = 998244353\n\ndef modified_baby_step_giant_step(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modified_baby_step_giant_step(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answe = pow(2, n - 1, modu) * (pow(2, power, modu) - 1 + modu) % modu % modu\n    if answe == 0:\n        if 1 % m != x:\n            answe = -1\n    if answe == 1:\n        if 1 % m != x or n != -1:\n            answe -= 1\n    print(answe)", "from math import gcd, sqrt\nmodu = 998244353\n\ndef modified_baby_step_giant_step(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modified_baby_step_giant_step(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answe = pow(2, n - 1, modu) * (pow(2, power, modu) - 1 + modu) % modu % modu\n    if answe == 0:\n        if 1 % m != x:\n            answe = -1\n    if answe == 1:\n        if 1 % m != x or n != -1:\n            answe -= 1\n    print(answe)", "from math import gcd, sqrt\nmodu = 998244353\n\ndef modified_baby_step_giant_step(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modified_baby_step_giant_step(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answe = pow(2, n - 1, modu) * (pow(2, power, modu) - 1 + modu) % modu % modu\n    if answe == 0:\n        if 1 % m != x:\n            answe = -1\n    if answe == 1:\n        if 1 % m != x or n != -1:\n            answe -= 1\n    print(answe)", "from math import gcd, sqrt\nmodu = 998244353\n\ndef modified_baby_step_giant_step(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modified_baby_step_giant_step(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answe = pow(2, n - 1, modu) * (pow(2, power, modu) - 1 + modu) % modu % modu\n    if answe == 0:\n        if 1 % m != x:\n            answe = -1\n    if answe == 1:\n        if 1 % m != x or n != -1:\n            answe -= 1\n    print(answe)", "from math import gcd, sqrt\nmodu = 998244353\n\ndef modified_baby_step_giant_step(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modified_baby_step_giant_step(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answe = pow(2, n - 1, modu) * (pow(2, power, modu) - 1 + modu) % modu % modu\n    if answe == 0:\n        if 1 % m != x:\n            answe = -1\n    if answe == 1:\n        if 1 % m != x or n != -1:\n            answe -= 1\n    print(answe)", "from math import gcd, sqrt\nmodu = 998244353\n\ndef modified_baby_step_giant_step(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modified_baby_step_giant_step(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answe = pow(2, n - 1, modu) * (pow(2, power, modu) - 1 + modu) % modu % modu\n    if answe == 0:\n        if 1 % m != x:\n            answe = -1\n    if answe == 1:\n        if 1 % m != x or n != -1:\n            answe -= 1\n    print(answe)", "from math import gcd, sqrt\nmodu = 998244353\n\ndef modified_baby_step_giant_step(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modified_baby_step_giant_step(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    answe = pow(2, n - 1, modu) * (pow(2, power, modu) - 1 + modu) % modu % modu\n    if answe == 0:\n        if 1 % m != x:\n            answe = -1\n    if answe == 1:\n        if 1 % m != x or n != -1:\n            answe -= 1\n    print(answe)", "from math import gcd, sqrt\nmod = 998244353\n\ndef modified_baby_step_giant_step(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    if 1 % m == x:\n        print(0)\n        continue\n    if x == 0 and m == 1:\n        print(0)\n        continue\n    if x == 0 and n != 1:\n        print(1)\n        continue\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modified_baby_step_giant_step(var, x, m)\n    if power == -1:\n        print(-1)\n        continue\n    ans = pow(2, n - 1, mod) * (pow(2, power, mod) - 1 + mod) % mod % mod\n    if ans == 0:\n        if 1 % m != x:\n            ans = -1\n    if ans == 1:\n        if 1 % m != x or n != -1:\n            ans -= 1\n    print(ans)"]