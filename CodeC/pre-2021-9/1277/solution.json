["import sys\nsys.setrecursionlimit(10000000)\n\ndef mergeSortInversions(arr):\n    if len(arr) == 1:\n        return (arr, 0)\n    larr = len(arr)\n    a = arr[:larr // 2]\n    b = arr[larr // 2:]\n    (a, ai) = mergeSortInversions(a)\n    (b, bi) = mergeSortInversions(b)\n    c = []\n    i = 0\n    j = 0\n    inversions = 0 + ai + bi\n    la = len(a)\n    while i < la and j < len(b):\n        if a[i] <= b[j]:\n            c.append(a[i])\n            i += 1\n        else:\n            c.append(b[j])\n            j += 1\n            inversions += la - i\n    c += a[i:]\n    c += b[j:]\n    return (c, inversions)\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = [int(o) for o in input().split()]\n    array = [[] for i in range(d)]\n    flag = 0\n    for i in range(n):\n        array[i % d].append(p[i])\n        if p[i] % (i % d + 1) != 0:\n            flag = 1\n    ans = 0\n    dumarr = [0] * n\n    for i in range(d):\n        (array[i], v) = mergeSortInversions(array[i])\n        for j in range(len(array[i])):\n            dumarr[i + j * d] = array[i][j]\n        ans += v\n    p = sorted(p)\n    if dumarr == p:\n        print(ans)\n    else:\n        print(-1)", "import sys\nsys.setrecursionlimit(10000000)\n\ndef mergeSortInversions(arr):\n    if len(arr) == 1:\n        return (arr, 0)\n    larr = len(arr)\n    a = arr[:larr // 2]\n    b = arr[larr // 2:]\n    (a, ai) = mergeSortInversions(a)\n    (b, bi) = mergeSortInversions(b)\n    c = []\n    i = 0\n    j = 0\n    inversions = 0 + ai + bi\n    la = len(a)\n    while i < la and j < len(b):\n        if a[i] <= b[j]:\n            c.append(a[i])\n            i += 1\n        else:\n            c.append(b[j])\n            j += 1\n            inversions += la - i\n    c += a[i:]\n    c += b[j:]\n    return (c, inversions)\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = [int(o) for o in input().split()]\n    array = [[] for i in range(d)]\n    flag = 0\n    for i in range(n):\n        array[i % d].append(p[i])\n        if p[i] % (i % d + 1) != 0:\n            flag = 1\n    ans = 0\n    dumarr = [0] * n\n    for i in range(d):\n        (array[i], v) = mergeSortInversions(array[i])\n        for j in range(len(array[i])):\n            dumarr[i + j * d] = array[i][j]\n        ans += v\n    p = sorted(p)\n    if dumarr == p:\n        print(ans)\n    else:\n        print(-1)", "import sys\nsys.setrecursionlimit(10000000)\n\ndef mergeSortInversions(arr):\n    if len(arr) == 1:\n        return (arr, 0)\n    larr = len(arr)\n    a = arr[:larr // 2]\n    b = arr[larr // 2:]\n    (a, ai) = mergeSortInversions(a)\n    (b, bi) = mergeSortInversions(b)\n    c = []\n    i = 0\n    j = 0\n    inversions = 0 + ai + bi\n    la = len(a)\n    while i < la and j < len(b):\n        if a[i] <= b[j]:\n            c.append(a[i])\n            i += 1\n        else:\n            c.append(b[j])\n            j += 1\n            inversions += la - i\n    c += a[i:]\n    c += b[j:]\n    return (c, inversions)\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = [int(o) for o in input().split()]\n    array = [[] for i in range(d)]\n    flag = 0\n    for i in range(n):\n        array[i % d].append(p[i])\n        if p[i] % (i % d + 1) != 0:\n            flag = 1\n    ans = 0\n    dumarr = [0] * n\n    for i in range(d):\n        (array[i], v) = mergeSortInversions(array[i])\n        for j in range(len(array[i])):\n            dumarr[i + j * d] = array[i][j]\n        ans += v\n    p = sorted(p)\n    if dumarr == p:\n        print(ans)\n    else:\n        print(-1)", "def mergeSort(arr, n):\n    temp_arr = [0] * n\n    return _mergeSort(arr, temp_arr, 0, n - 1)\n\ndef _mergeSort(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        inv_count = _mergeSort(arr, temp_arr, left, mid)\n        inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\n\ndef merge(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += mid - i + 1\n            k += 1\n            j += 1\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n    return inv_count\n\ndef findout(A, D):\n    dic = {}\n    for i in range(D):\n        dic[i] = []\n    for (i, x) in enumerate(A):\n        dic[x % D] += [(i, x)]\n    ans = 0\n    for i in range(D):\n        temp = dic[i]\n        temp11 = []\n        temp22 = []\n        for (i, x) in temp:\n            temp11 += [i]\n            temp22 += [x]\n        if sorted(temp11) != sorted(temp22):\n            return -1\n        temp33 = [0] * len(temp11)\n        for (i, x) in temp:\n            temp33[i // D] = x // D\n        ans += mergeSort(temp33, len(temp33))\n    return ans\nfor _ in range(int(input())):\n    (N, K) = list(map(int, input().strip().split(' ')))\n    A = list(map(int, input().strip().split(' ')))\n    A = [x - 1 for x in A]\n    print(findout(A, K))", "def merge(arr, temp, left, mid, right):\n    inv_count = 0\n    i = left\n    j = mid\n    k = left\n    while i <= mid - 1 and j <= right:\n        if arr[i] <= arr[j]:\n            temp[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            temp[k] = arr[j]\n            k += 1\n            j += 1\n            inv_count = inv_count + (mid - i)\n    while i <= mid - 1:\n        temp[k] = arr[i]\n        k += 1\n        i += 1\n    while j <= right:\n        temp[k] = arr[j]\n        k += 1\n        j += 1\n    for i in range(left, right + 1, 1):\n        arr[i] = temp[i]\n    return inv_count\n\ndef _mergeSort(arr, temp, left, right):\n    inv_count = 0\n    if right > left:\n        mid = int((right + left) / 2)\n        inv_count = _mergeSort(arr, temp, left, mid)\n        inv_count += _mergeSort(arr, temp, mid + 1, right)\n        inv_count += merge(arr, temp, left, mid + 1, right)\n    return inv_count\n\ndef countSwaps(arr, n):\n    temp = [0 for i in range(n)]\n    return _mergeSort(arr, temp, 0, n - 1)\nfor i in range(int(input())):\n    (n, d) = map(int, input().split())\n    a = [[] * i for i in range(d + 5)]\n    p = list(map(int, input().split()))\n    if d > 1:\n        s = -1\n        for i in p:\n            s = (s + 1) % d\n            a[s].append(i)\n        ans = 0\n        for i in a:\n            ans = ans + countSwaps(i, len(i))\n        i = -1\n        f = [0] * n\n        for i in range(len(a)):\n            for j in range(len(a[i])):\n                f[j * d + i] = a[i][j]\n        p.sort()\n        if f == p:\n            print(ans)\n        else:\n            print('-1')\n    else:\n        print(countSwaps(p, len(p)))", "def mergeSort(arr, n):\n    temp_arr = [0] * n\n    return _mergeSort(arr, temp_arr, 0, n - 1)\n\ndef _mergeSort(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        inv_count = _mergeSort(arr, temp_arr, left, mid)\n        inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\n\ndef merge(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += mid - i + 1\n            k += 1\n            j += 1\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n    return inv_count\n\ndef findout(A, D):\n    dic = {}\n    for i in range(D):\n        dic[i] = []\n    for (i, x) in enumerate(A):\n        dic[x % D] += [(i, x)]\n    ans = 0\n    for i in range(D):\n        temp = dic[i]\n        temp11 = []\n        temp22 = []\n        for (i, x) in temp:\n            temp11 += [i]\n            temp22 += [x]\n        if sorted(temp11) != sorted(temp22):\n            return -1\n        temp33 = [0] * len(temp11)\n        for (i, x) in temp:\n            temp33[i // D] = x // D\n        ans += mergeSort(temp33, len(temp33))\n    return ans\nfor _ in range(int(input())):\n    (N, K) = list(map(int, input().strip().split(' ')))\n    A = list(map(int, input().strip().split(' ')))\n    A = [x - 1 for x in A]\n    print(findout(A, K))"]