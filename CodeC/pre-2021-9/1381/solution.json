["import sys\nimport numpy as np\n\ndef mpow_mod(M, k, mod):\n    ret = np.identity(M.shape[0], dtype=np.int64)\n    while k > 0:\n        if k & 1:\n            ret = ret.dot(M)\n            ret %= mod\n        M = M.dot(M)\n        M %= mod\n        k >>= 1\n    return ret\n\ndef lap(M):\n    n = M.shape[0]\n    L = np.zeros((n, n), dtype=np.int64)\n    L[range(n), range(n)] = np.sum(M, 0)\n    L -= M\n    return L\n\ndef int_array(m):\n    ret = np.array([int(x) for x in m.flat], dtype=object)\n    ret = ret.reshape(m.shape)\n    return ret\n\ndef mred(m):\n    n = m.shape[0]\n    ret = m[1:, 1:]\n    for i in range(n - 1):\n        for j in range(n - 1):\n            ret[i, j] = m[0, 0] * m[i + 1, j + 1] - m[i + 1, 0] * m[0, j + 1]\n    return ret\n\ndef det(m):\n    a = 1\n    while m.shape[0] > 1:\n        b = m[0, 0]\n        if a == 0:\n            return 0\n        m = mred(m) // a\n        a = b\n    return m[0, 0]\n\ndef solve(M, k, x):\n    n = M.shape[0]\n    I = np.identity(n, dtype=np.int64)\n    M0 = np.vstack((np.hstack((M, I)), np.hstack((I * 0, I))))\n    M1 = mpow_mod(M0, k + 1, x)[:n, n:]\n    M1[range(n), range(n)] = 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return M1[0, 1]\n    L = lap(M1)[1:, 1:]\n    return det(int_array(L))\nf = sys.stdin\n(n, m, x, k) = map(int, f.readline().split())\nM = np.zeros((n, n), dtype=np.int64)\nfor i in range(m):\n    (a, b) = map(int, f.readline().split())\n    M[a - 1, b - 1] = M[b - 1, a - 1] = 1\nprint(solve(M, k, x))", "import sys\nimport numpy as np\n\ndef mpow_mod(M, k, mod):\n    ret = np.identity(M.shape[0], dtype=np.int64)\n    while k > 0:\n        if k & 1:\n            ret = ret.dot(M)\n            ret %= mod\n        M = M.dot(M)\n        M %= mod\n        k >>= 1\n    return ret\n\ndef lap(M):\n    n = M.shape[0]\n    L = np.zeros((n, n), dtype=np.int64)\n    L[range(n), range(n)] = np.sum(M, 0)\n    L -= M\n    return L\n\ndef int_array(m):\n    ret = np.array([int(x) for x in m.flat], dtype=object)\n    ret = ret.reshape(m.shape)\n    return ret\n\ndef mred(m):\n    n = m.shape[0]\n    ret = m[1:, 1:]\n    for i in range(n - 1):\n        for j in range(n - 1):\n            ret[i, j] = m[0, 0] * m[i + 1, j + 1] - m[i + 1, 0] * m[0, j + 1]\n    return ret\n\ndef det(m):\n    a = 1\n    while m.shape[0] > 1:\n        b = m[0, 0]\n        if a == 0:\n            return 0\n        m = mred(m) // a\n        a = b\n    return m[0, 0]\n\ndef solve(M, k, x):\n    n = M.shape[0]\n    I = np.identity(n, dtype=np.int64)\n    M0 = np.vstack((np.hstack((M, I)), np.hstack((I * 0, I))))\n    M1 = mpow_mod(M0, k + 1, x)[:n, n:]\n    M1[range(n), range(n)] = 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return M1[0, 1]\n    L = lap(M1)[1:, 1:]\n    return det(int_array(L))\nf = sys.stdin\n(n, m, x, k) = map(int, f.readline().split())\nM = np.zeros((n, n), dtype=np.int64)\nfor i in range(m):\n    (a, b) = map(int, f.readline().split())\n    M[a - 1, b - 1] = M[b - 1, a - 1] = 1\nprint(solve(M, k, x))", "import sys\nimport numpy as np\n\ndef mpow_mod(M, k, mod):\n    ret = np.identity(M.shape[0], dtype=np.int64)\n    while k > 0:\n        if k & 1:\n            ret = ret.dot(M)\n            ret %= mod\n        M = M.dot(M)\n        M %= mod\n        k >>= 1\n    return ret\n\ndef lap(M):\n    n = M.shape[0]\n    L = np.zeros((n, n), dtype=np.int64)\n    L[range(n), range(n)] = np.sum(M, 0)\n    L -= M\n    return L\n\ndef int_array(m):\n    ret = np.array([int(x) for x in m.flat], dtype=object)\n    ret = ret.reshape(m.shape)\n    return ret\n\ndef mred(m):\n    n = m.shape[0]\n    ret = m[1:, 1:]\n    for i in range(n - 1):\n        for j in range(n - 1):\n            ret[i, j] = m[0, 0] * m[i + 1, j + 1] - m[i + 1, 0] * m[0, j + 1]\n    return ret\n\ndef det(m):\n    a = 1\n    while m.shape[0] > 1:\n        b = m[0, 0]\n        if a == 0:\n            return 0\n        m = mred(m) // a\n        a = b\n    return m[0, 0]\n\ndef solve(M, k, x):\n    n = M.shape[0]\n    I = np.identity(n, dtype=np.int64)\n    M0 = np.vstack((np.hstack((M, I)), np.hstack((I * 0, I))))\n    M1 = mpow_mod(M0, k + 1, x)[:n, n:]\n    M1[range(n), range(n)] = 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return M1[0, 1]\n    L = lap(M1)[1:, 1:]\n    return det(int_array(L))\n\ndef prod_span(M):\n    n = M.shape[0]\n    if n == 1:\n        return 1\n    if n == 2:\n        return int(M[0, 1])\n    ret = 0\n    for i in range(1, n):\n        z = M[0, i]\n        if z > 0:\n            M[0, i] = M[i, 0] = 0\n            M0 = np.copy(M[1:, 1:])\n            M0[i - 1, :] += M[0, 1:]\n            M0[:, i - 1] += M[0, 1:]\n            ret += int(z) * prod_span(M0)\n    return ret\nf = sys.stdin\n(n, m, x, k) = map(int, f.readline().split())\nM = np.zeros((n, n), dtype=np.int64)\nfor i in range(m):\n    (a, b) = map(int, f.readline().split())\n    M[a - 1, b - 1] = M[b - 1, a - 1] = 1\nif n <= 5:\n    I = np.identity(n, dtype=np.int64)\n    M0 = np.vstack((np.hstack((M, I)), np.hstack((I * 0, I))))\n    M1 = mpow_mod(M0, k + 1, x)[:n, n:]\n    M1[range(n), range(n)] = 0\n    print(prod_span(np.copy(M1)))\nelse:\n    print(solve(M, k, x))"]