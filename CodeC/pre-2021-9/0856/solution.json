["from bisect import bisect_right\n\ndef Sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n        prime[2] = False\n    lst = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            lst.append(p)\n    return lst\nm = 10 ** 7\nval = Sieve(m)\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print('1')\n    else:\n        ans = bisect_right(val, n) - bisect_right(val, n // 2)\n        print(ans + 1)", "from bisect import bisect_right\n\ndef Sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n        prime[2] = False\n    lst = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            lst.append(p)\n    return lst\nm = 10 ** 7\nval = Sieve(m)\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print('1')\n    else:\n        ans = bisect_right(val, n) - bisect_right(val, n // 2)\n        print(ans + 1)", "try:\n    MAX = 10000000\n    prefix = [0] * (MAX + 1)\n\n    def buildPrefix():\n        prime = [1] * (MAX + 1)\n        p = 2\n        while p * p <= MAX:\n            if prime[p] == 1:\n                i = p * 2\n                while i <= MAX:\n                    prime[i] = 0\n                    i += p\n            p += 1\n        for p in range(2, MAX + 1):\n            prefix[p] = prefix[p - 1]\n            if prime[p] == 1:\n                prefix[p] += 1\n\n    def query(L, R):\n        return prefix[R] - prefix[L - 1]\n    buildPrefix()\n    for t in range(int(input())):\n        N = int(input())\n        if N == 2:\n            print(1)\n            continue\n        primes = query(N // 2 + 1, N)\n        if primes == N - 1:\n            print(primes)\n        else:\n            print(1 + primes)\nexcept:\n    pass", "from bisect import bisect_right\n\ndef Sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n        prime[2] = False\n    lst = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            lst.append(p)\n    return lst\nm = 10 ** 7\nval = Sieve(m)\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print('1')\n    else:\n        ans = bisect_right(val, n) - bisect_right(val, n // 2)\n        print(ans + 1)", "try:\n    MAX = 10000000\n    prefix = [0] * (MAX + 1)\n\n    def buildPrefix():\n        prime = [1] * (MAX + 1)\n        p = 2\n        while p * p <= MAX:\n            if prime[p] == 1:\n                i = p * 2\n                while i <= MAX:\n                    prime[i] = 0\n                    i += p\n            p += 1\n        for p in range(2, MAX + 1):\n            prefix[p] = prefix[p - 1]\n            if prime[p] == 1:\n                prefix[p] += 1\n\n    def query(L, R):\n        return prefix[R] - prefix[L - 1]\n    buildPrefix()\n    for t in range(int(input())):\n        N = int(input())\n        if N == 2:\n            print(1)\n            continue\n        primes = query(N // 2 + 1, N)\n        if primes == N - 1:\n            print(primes)\n        else:\n            print(1 + primes)\nexcept:\n    pass", "try:\n    MAX = 10000000\n    prefix = [0] * (MAX + 1)\n\n    def buildPrefix():\n        prime = [1] * (MAX + 1)\n        p = 2\n        while p * p <= MAX:\n            if prime[p] == 1:\n                i = p * 2\n                while i <= MAX:\n                    prime[i] = 0\n                    i += p\n            p += 1\n        for p in range(2, MAX + 1):\n            prefix[p] = prefix[p - 1]\n            if prime[p] == 1:\n                prefix[p] += 1\n\n    def query(L, R):\n        return prefix[R] - prefix[L - 1]\n    buildPrefix()\n    for t in range(int(input())):\n        N = int(input())\n        if N == 2:\n            print(1)\n            continue\n        primes = query(N // 2 + 1, N)\n        if primes == N - 1:\n            print(primes)\n        else:\n            print(1 + primes)\nexcept:\n    pass", "from bisect import *\nimport sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef st():\n    return input().rstrip('\\n')\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\nt = inp()\nprimes = []\nvis = [0] * (10 ** 7 + 1)\nfor i in range(2, 10 ** 7 + 1):\n    if vis[i]:\n        continue\n    for j in range(i, 10 ** 7 + 1, i):\n        vis[j] = 1\n    primes.append(i)\nwhile t:\n    t -= 1\n    n = inp()\n    if n == 2:\n        print(1)\n        continue\n    elif n == 3:\n        print(2)\n        continue\n    print(bisect_right(primes, n) - bisect_right(primes, n // 2) + 1)", "from math import *\nfrom sys import *\ninput = stdin.readline\nn = 10 ** 7\np = [1] * (n + 1)\n(p[0], p[1]) = (0, 0)\nfor i in range(2, int(sqrt(n + 1)) + 1):\n    if p[i] == 1:\n        for j in range(i * i, n + 1, i):\n            p[j] = 0\nfor i in range(2, n + 1):\n    p[i] = p[i] + p[i - 1]\nfor u in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(p[n] - p[n // 2] + 1)", "def buildPrime():\n    prime = [1] * (MAXIMUM + 1)\n    p = 2\n    while p * p <= MAXIMUM:\n        if prime[p] == 1:\n            i = p * 2\n            while i <= MAXIMUM:\n                prime[i] = 0\n                i += p\n        p += 1\n    for p in range(2, MAXIMUM + 1):\n        prefix[p] = prefix[p - 1]\n        if prime[p] == 1:\n            prefix[p] += 1\n\ndef answer(Left, Rright):\n    return prefix[Rright] - prefix[Left - 1]\nMAXIMUM = 10000000\nprefix = [0] * (MAXIMUM + 1)\nbuildPrime()\nt = int(input())\nfor case in range(t):\n    n = int(input())\n    if n < 4:\n        print(answer(n // 2 + 1, n))\n    else:\n        print(1 + answer(n // 2 + 1, n))", "limit = 10000000\narr = [True] * (limit + 1)\narr[0] = arr[1] = False\nfor i in range(int(limit ** 0.5)):\n    if arr[i]:\n        for j in range(i * 2, len(arr), i):\n            arr[j] = False\nprimes = []\nj = 0\nfor i in range(len(arr)):\n    if arr[i]:\n        j += 1\n    primes.append(j)\nfor i in range(int(input())):\n    n = int(input())\n    if n < 4:\n        print(primes[n] - primes[n // 2 - 1])\n        continue\n    print(primes[n] - primes[n // 2] + 1)", "def buildPrime():\n    prime = [1] * (MAXIMUM + 1)\n    p = 2\n    while p * p <= MAXIMUM:\n        if prime[p] == 1:\n            i = p * 2\n            while i <= MAXIMUM:\n                prime[i] = 0\n                i += p\n        p += 1\n    for p in range(2, MAXIMUM + 1):\n        prefix[p] = prefix[p - 1]\n        if prime[p] == 1:\n            prefix[p] += 1\n\ndef answer(Left, Rright):\n    return prefix[Rright] - prefix[Left - 1]\nMAXIMUM = 10000000\nprefix = [0] * (MAXIMUM + 1)\nbuildPrime()\nt = int(input())\nfor case in range(t):\n    n = int(input())\n    if n < 4:\n        print(answer(n // 2 + 1, n))\n    else:\n        print(1 + answer(n // 2 + 1, n))", "from itertools import accumulate\nmax = 10000000\nsieve = [1 for i in range(max + 1)]\n(sieve[0], sieve[1]) = (0, 0)\np = 2\nwhile p * p <= max:\n    if sieve[p]:\n        for i in range(p * p, max + 1, p):\n            sieve[i] = False\n    p += 1\nprime = list(accumulate(sieve))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(1 + prime[n] - prime[n // 2])", "from itertools import accumulate\nn = 10000000\nprime = [1 for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p]:\n        for i in range(p * p, n + 1, p):\n            prime[i] = False\n    p += 1\nprime[0] = 0\nprime[1] = 0\nprime_number = list(accumulate(prime))\nfor testcase in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(1 + prime_number[n] - prime_number[n // 2])", "from bisect import bisect_right\n\ndef prime(p):\n    count = 0\n    pre = [True for k in range(p + 1)]\n    i = 2\n    while i * i <= p:\n        if pre[i] == True:\n            for j in range(i + i, p + 1, i):\n                pre[j] = False\n        i += 1\n    les = []\n    for i in range(2, p + 1):\n        if pre[i]:\n            les.append(i)\n    return les\ns = pow(10, 7)\nn = prime(s)\nfor i in range(int(input())):\n    c = int(input())\n    if c == 2:\n        print(1)\n    elif c == 3:\n        print(2)\n    else:\n        ans = bisect_right(n, c) - bisect_right(n, c // 2)\n        print(ans + 1)", "from bisect import bisect_right\n\ndef prime(p):\n    count = 0\n    pre = [True for k in range(p + 1)]\n    i = 2\n    while i * i <= p:\n        if pre[i] == True:\n            for j in range(i + i, p + 1, i):\n                pre[j] = False\n        i += 1\n    les = []\n    for i in range(2, p + 1):\n        if pre[i]:\n            les.append(i)\n    return les\ns = pow(10, 7)\nn = prime(s)\nfor i in range(int(input())):\n    c = int(input())\n    if c == 2:\n        print(1)\n    elif c == 3:\n        print(2)\n    else:\n        ans = bisect_right(n, c) - bisect_right(n, c // 2)\n        print(ans + 1)", "from bisect import bisect_right\n\ndef prime(p):\n    count = 0\n    pre = [True for k in range(p + 1)]\n    i = 2\n    while i * i <= p:\n        if pre[i] == True:\n            for j in range(i + i, p + 1, i):\n                pre[j] = False\n        i += 1\n    les = []\n    for i in range(2, p + 1):\n        if pre[i]:\n            les.append(i)\n    return les\ns = pow(10, 7)\nn = prime(s)\nfor i in range(int(input())):\n    c = int(input())\n    if c == 2:\n        print(1)\n    elif c == 3:\n        print(2)\n    else:\n        ans = bisect_right(n, c) - bisect_right(n, c // 2)\n        print(ans + 1)", "from bisect import bisect_right\n\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n        prime[2] = False\n    lst = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            lst.append(p)\n    return lst\nm = 10 ** 7\nnlst = SieveOfEratosthenes(m)\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print('1')\n    else:\n        ans = bisect_right(nlst, n) - bisect_right(nlst, n // 2)\n        print(ans + 1)", "prime = [True] * int(10000000.0 + 2)\nprime[0] = prime[1] = False\nprefix_prime = [0]\n\ndef sieve(N=int(10000000.0 + 1)):\n    N = N + 1\n    i = 2\n    while i * i < N:\n        if prime[i]:\n            for j in range(i ** 2, N, i):\n                prime[j] = False\n        i += 1\nsieve()\n\ndef precount_prime():\n    count = 0\n    for i in range(1, int(10000000.0 + 1)):\n        if prime[i]:\n            count += 1\n        prefix_prime.append(count)\nprecount_prime()\nfor _ in range(int(input())):\n    N = int(input())\n    if N == 2:\n        print(1)\n    elif N == 3:\n        print(2)\n    else:\n        f = 1 + prefix_prime[N] - prefix_prime[N // 2]\n        print(f)", "import bisect\nprimes = [True for i in range(10 ** 7 + 1)]\np = 2\nwhile p * p <= 10 ** 7:\n    if primes[p] == True:\n        for i in range(p * p, 10 ** 7 + 1, p):\n            primes[i] = False\n    p = p + 1\npre = []\nfor i in range(2, 10 ** 7 + 1):\n    if primes[i] == True:\n        pre.append(i)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 2:\n        print(1)\n        continue\n    if n == 3:\n        print(2)\n        continue\n    count = bisect.bisect_right(pre, n) - bisect.bisect_right(pre, n // 2) + 1\n    print(count)", "t = int(input())\nbig = 10 ** 7 + 1\nl = [1 for i in range(big + 1)]\nl[0] = l[1] = 0\nfor i in range(2, int(big ** (1 / 2) + 1)):\n    if l[i]:\n        for j in range(i * i, big, i):\n            l[j] = 0\nc = 0\na = [0 for i in range(big + 1)]\nfor i in range(big + 1):\n    if l[i] == 1:\n        c += 1\n    a[i] = c\nfor co in range(t):\n    q = int(int(input()))\n    v = q // 2\n    if q == 2:\n        print(1)\n    elif q == 3:\n        print(2)\n    else:\n        print(a[q] - a[v] + 1)", "t = int(input())\nbig = 10 ** 7 + 1\nl = [1 for i in range(big + 1)]\nl[0] = l[1] = 0\nfor i in range(2, int(big ** (1 / 2) + 1)):\n    if l[i]:\n        for j in range(i * i, big, i):\n            l[j] = 0\nc = 0\na = []\nfor i in range(big + 1):\n    if l[i] == 1:\n        c += 1\n    a.append(c)\nfor co in range(t):\n    q = int(int(input()))\n    v = q // 2\n    if q == 2:\n        print(1)\n    elif q == 3:\n        print(2)\n    else:\n        print(a[q] - a[v] + 1)", "t = int(input())\nbig = 10 ** 7 + 2\nl = [1 for i in range(big + 1)]\nl[0] = l[1] = 0\nfor i in range(2, int(big ** (1 / 2) + 1)):\n    if l[i]:\n        for j in range(i * i, big, i):\n            l[j] = 0\nc = 0\na = []\nfor i in range(big + 1):\n    if l[i] == 1:\n        c += 1\n    a.append(c)\nfor co in range(t):\n    q = int(int(input()))\n    v = q // 2\n    if q == 2:\n        print(1)\n    elif q == 3:\n        print(2)\n    else:\n        print(a[q] - a[v] + 1)", "from itertools import accumulate\nprimes = [1 for _ in range(pow(10, 7) + 1)]\n(primes[0], primes[1]) = (0, 0)\nfor num in range(2, 4 * pow(10, 3)):\n    if primes[num] == 1:\n        for x in range(2 * num, pow(10, 7) + 1, num):\n            primes[x] = 0\nprimes[2] = 0\nprime_cnt = list(accumulate(primes))\nfor _ in range(int(input())):\n    n = int(input())\n    print(prime_cnt[n] - prime_cnt[n // 2] + 1)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    li = [0, 0]\n    x = 0\n    for i in range(2, n):\n        if prime[i]:\n            x += 1\n        li.append(x)\n    return li\nli = SieveOfEratosthenes(10 ** 7 + 1)\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    ans = 1\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(li[n] - li[n // 2] + 1)", "def SieveOfEratosthenes(N):\n    prime = [True for i in range(N + 1)]\n    prime[0] = prime[1] = 0\n    p = 2\n    while p * p <= N:\n        if prime[p] == True:\n            for i in range(p * p, N + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\ndef pre():\n    p1 = SieveOfEratosthenes(10 ** 7 + 1)\n    prime = [None] * (10 ** 7 + 1)\n    c = 0\n    for i in range(10 ** 7 + 1):\n        if p1[i]:\n            c += 1\n        prime[i] = c\n    return prime\nt = int(input())\nprime = pre()\nfor i in range(1, t + 1):\n    n = int(input())\n    if n == 2:\n        print(1)\n        continue\n    elif n == 3:\n        print(2)\n        continue\n    groups = 1 + prime[n] - prime[n // 2]\n    print(groups)", "def sieve(arr, primes, m):\n    for i in range(2, m + 1):\n        arr[i] = arr[i - 1]\n        if primes[i]:\n            arr[i] += 1\n            for j in range(2 * i, m + 1, i):\n                primes[j] = 0\nt = int(input())\nn = []\nm = 0\nfor i in range(t):\n    n.append(int(input()))\n    m = max(n[-1], m)\narr = [0] * (m + 1)\nprimes = [1] * (m + 1)\n(primes[0], primes[1]) = (0, 0)\nsieve(arr, primes, m)\nfor i in range(t):\n    print(arr[n[i]] - max(1, arr[n[i] // 2]) + 1)", "import math\nsize = 10 ** 7 + 1\nprime = [1] * size\nprime[0] = 0\nprime[1] = 0\nfor i in range(2, math.ceil(math.sqrt(size)) + 1):\n    if prime[i] == 1:\n        for j in range(i * i, size, i):\n            prime[j] = 0\nfor i in range(2, size):\n    prime[i] = prime[i] + prime[i - 1]\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(prime[n] - prime[n // 2] + 1)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    prefixsumprime = [0 for i in range(n + 1)]\n    for i in range(2, 10 ** 7 + 1):\n        if prime[i]:\n            prefixsumprime[i] = prefixsumprime[i - 1] + 1\n        else:\n            prefixsumprime[i] = prefixsumprime[i - 1]\n    return prefixsumprime\nprefixsumprime = SieveOfEratosthenes(10 ** 7)\nfor _ in range(int(input())):\n    n = int(input())\n    if n <= 3:\n        print(n - 1)\n    else:\n        print(prefixsumprime[n] - prefixsumprime[n // 2] + 1)", "query = []\nfor _ in range(int(input())):\n    query.append(int(input()))\nn = max(query)\nprime = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p * p, n + 1, p):\n            prime[i] = False\n    p += 1\ndp = [0 for j in range(n + 1)]\n(dp[1], dp[2]) = (1, 1)\nfor j in range(3, n + 1):\n    if prime[j]:\n        dp[j] = dp[j - 1] + 1\n    else:\n        dp[j] = dp[j - 1]\nfor j in query:\n    print(dp[j] - dp[j // 2] + 1)", "from math import sqrt, floor\n\ndef sieve(h):\n    bl = [True] * (h + 1)\n    a = [0] * (h + 1)\n    for i in range(2, int(floor(sqrt(h))) + 1):\n        if bl[i] == False:\n            continue\n        for j in range(i * i, h + 1, i):\n            bl[j] = False\n    c = 0\n    for i in range(2, h + 1):\n        if bl[i] == True:\n            c += 1\n        a[i] = c\n    return a\nprime = sieve(10000000)\nt = int(input())\nwhile t:\n    m = int(input())\n    if m == 2:\n        print(1)\n        t -= 1\n        continue\n    elif m == 3:\n        print(2)\n        t -= 1\n        continue\n    ans = prime[m] - prime[m // 2] + 1\n    print(ans)\n    t -= 1", "def SieveOfEratosthenes(N):\n    prime = [True for i in range(N + 1)]\n    prime[0] = prime[1] = 0\n    p = 2\n    while p * p <= N:\n        if prime[p] == True:\n            for i in range(p * p, N + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\ndef pre():\n    p1 = SieveOfEratosthenes(10 ** 7 + 1)\n    prime = [None] * (10 ** 7 + 1)\n    c = 0\n    for i in range(10 ** 7 + 1):\n        if p1[i]:\n            c += 1\n        prime[i] = c\n    return prime\nt = int(input())\nprime = pre()\nfor i in range(1, t + 1):\n    n = int(input())\n    if n == 2:\n        print(1)\n        continue\n    elif n == 3:\n        print(2)\n        continue\n    groups = 1 + prime[n] - prime[n // 2]\n    print(groups)", "N = int(10000000.0 + 2)\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    return prime\nprime = sieve(N)\n\ndef pre_count(prime):\n    prefix_prime = []\n    count = 0\n    for i in range(N + 1):\n        if prime[i]:\n            count += 1\n        prefix_prime.append(count)\n    return prefix_prime\nprefix_prime = pre_count(prime)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        lim = int(n / 2)\n        extra = prefix_prime[n] - prefix_prime[lim]\n        print(extra + 1)", "import bisect\nimport sys\n\ndef get_inpt():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef p_str(x):\n    sys.stdout.write(x + '\\n')\n\ndef p_int(x):\n    sys.stdout.write(str(x) + '\\n')\n\ndef p_arr(arr):\n    sys.stdout.write(' '.join(map(str, arr)) + '\\n')\n\ndef SieveOfEratosthenes(n):\n    arr = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for i in range(2, n + 1):\n        if prime[i] == True:\n            arr.append(i)\n    return arr\n\ndef solve(n, sieve):\n    count = 1\n    count += abs(bisect.bisect_right(sieve, n / 2) - bisect.bisect_right(sieve, n))\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    return count\nsieve = SieveOfEratosthenes(10000000)\nfor _ in range(get_int()):\n    n = get_int()\n    print(solve(n, sieve))", "def SieveOfEratosthenes(N):\n    prime = [True for i in range(N + 1)]\n    prime[0] = prime[1] = 0\n    p = 2\n    while p * p <= N:\n        if prime[p] == True:\n            for i in range(p * p, N + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\ndef pre():\n    p1 = SieveOfEratosthenes(10 ** 7 + 1)\n    prime = [None] * (10 ** 7 + 1)\n    c = 0\n    for i in range(10 ** 7 + 1):\n        if p1[i]:\n            c += 1\n        prime[i] = c\n    return prime\nt = int(input())\nprime = pre()\nfor i in range(1, t + 1):\n    n = int(input())\n    if n == 2:\n        print(1)\n        continue\n    elif n == 3:\n        print(2)\n        continue\n    groups = 1 + prime[n] - prime[n // 2]\n    print(groups)", "from sys import stdin\nfrom bisect import bisect\nN = 10 ** 7 + 1\nisprime = [True for i in range(N)]\np = 2\nwhile p * p < N:\n    if isprime[p]:\n        for i in range(p * p, N, p):\n            isprime[i] = False\n    p += 1\nc = 0\nans = [0, 0]\nfor i in range(2, N):\n    if isprime[i] == True:\n        c += 1\n    ans.append(c)\nfor _ in range(int(stdin.readline())):\n    x = int(stdin.readline())\n    a = ans[x // 2]\n    b = ans[x]\n    if a == 0:\n        print(b)\n    else:\n        print(b - a + 1)", "try:\n\n    def sieve_of_eratosthenes():\n        A = [0, 1]\n        pr = 0\n        j = int(10000000.0 + 1)\n        prime = [True for i in range(j + 1)]\n        B = []\n        p = 2\n        while p * p <= j:\n            if prime[p]:\n                for i in range(p * p, j + 1, p):\n                    prime[i] = False\n            p += 1\n        for p in range(2, j + 1):\n            if prime[p]:\n                pr += 1\n            A.append(pr)\n        return A\n    arr = sieve_of_eratosthenes()\n    for _ in range(int(input())):\n        N = int(input())\n        print(arr[N] - arr[int(N / 2)] + 1)\nexcept:\n    pass", "try:\n\n    def seivelist(n):\n        a = [0] * (n + 1)\n        sqrtn = int(n ** 0.5)\n        curprime = 2\n        primesprefixsum = [0] * (n + 1)\n        nextprime = 2\n        while curprime <= sqrtn:\n            j = 2\n            curprime = nextprime\n            primemul = curprime * j\n            while primemul < n + 1:\n                a[primemul] = -1\n                j += 1\n                primemul = j * curprime\n            for i in range(curprime + 1, sqrtn + 1):\n                if a[i] == 0:\n                    nextprime = i\n                    break\n            if nextprime == curprime:\n                break\n        for i in range(2, n + 1):\n            primesprefixsum[i] = primesprefixsum[i - 1]\n            if a[i] == 0:\n                primesprefixsum[i] += 1\n        return primesprefixsum\n    maxn = -1\n    a = []\n    for _ in range(int(input())):\n        n = int(input())\n        a.append(n)\n        maxn = max(n, maxn)\n    pps = seivelist(maxn)\n    for n in a:\n        ans = pps[n] - pps[n // 2] + 1\n        if n < 4:\n            ans -= 1\n        print(ans)\nexcept EOFError:\n    pass", "from sys import stdin, stdout\ninput = stdin.readline\n\ndef im():\n    return map(int, input().split())\n\ndef ii():\n    return int(input())\n\ndef il():\n    return list(map(int, input().split()))\n\ndef ins():\n    return input()[:-1]\nN = int(10000000.0) + 5\nprime = [1] * N\nprime[0] = prime[1] = 0\ni = 2\nwhile i * i < N:\n    if prime[i] == 1:\n        for j in range(i * i, N, i):\n            prime[j] = 0\n    i += 1\nprime[3] = 2\nfor i in range(4, N):\n    prime[i] += prime[i - 1]\nfor _ in range(ii()):\n    n = ii()\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(prime[n] - prime[n // 2] + 1)", "def sieve(n):\n    l = [True for i in range(n + 1)]\n    (l[0], l[1]) = (False, False)\n    for i in range(2, int(n ** 0.5) + 1):\n        if l[i] == True:\n            for i in range(i * i, n + 1, i):\n                l[i] = False\n    return l\nr = sieve(10 ** 7 + 2)\n(c, l) = (0, [])\nfor i in range(0, 10 ** 7 + 1):\n    if r[i] == True:\n        c += 1\n    l.append(c)\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(1 + l[n] - l[n // 2])", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    c = 0\n    prefix = [0 for jk in range(n)]\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n        prefix[p] = c\n    return prefix\nx = SieveOfEratosthenes(int(10000000.0 + 2))\nfor t in range(int(input())):\n    N = int(input())\n    if N == 2:\n        print('1')\n    elif N == 3:\n        print('2')\n    else:\n        l = int(N / 2)\n        tot = x[N] - x[l]\n        print(tot + 1)", "import numpy as np\nt = int(input())\nn = int(10000000.0 + 5)\nprime = np.ones(n, dtype=int)\nprime[0] = 0\nprime[1] = 0\np = 2\nwhile p * p <= n:\n    if prime[p] == 1:\n        indices = np.arange(2 * p, n, p)\n        values = np.zeros(len(indices))\n        np.put(prime, indices, values)\n    p += 1\nprime[2] = 0\nprime = np.cumsum(prime)\nfor _ in range(t):\n    c = int(input())\n    print(prime[c] - prime[c // 2] + 1)", "import sys\nfrom os import path\nimport math\nimport time\nfrom collections import defaultdict\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\nMOD = 10 ** 9 + 7\nINT_MAX = 10 ** 9\nif path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    no_prime = []\n    count = 0\n    for i in range(len(prime)):\n        if prime[i]:\n            count += 1\n        no_prime.append(count)\n    return no_prime\n\ndef test_case():\n    t = int(input())\n    p = SieveOfEratosthenes(10000000 + 2)\n    for _ in range(t):\n        n = int(input())\n        if n > 3:\n            count = p[n] - p[int(n / 2)] + 1\n        else:\n            count = n - 1\n        print(count)\ntest_case()", "def SieveOfEratosthenes(n):\n    halp = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            halp.append(p)\n    return halp\nsa = SieveOfEratosthenes(10 ** 7)\nfrom bisect import bisect_left\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print(1)\n        continue\n    elif n == 3:\n        print(2)\n        continue\n    else:\n        print(bisect_left(sa, n + 1) - bisect_left(sa, n // 2 + 1) + 1)", "def seive(n):\n    prefix_ar = [0 for i in range(n + 1)]\n    ls = [True for i in range(n + 1)]\n    ls[0] = False\n    ls[1] = False\n    for i in range(2, n + 1):\n        val = ls[i]\n        if i * i <= n + 1:\n            if val == True:\n                for j in range(i * i, n + 1, i):\n                    if j % i == 0:\n                        ls[j] = False\n        else:\n            break\n    for i in range(1, n + 1):\n        val = ls[i]\n        if val == True:\n            prefix_ar[i] = prefix_ar[i - 1] + 1\n        else:\n            prefix_ar[i] = prefix_ar[i - 1]\n    return prefix_ar\n\ndef fun(lx, mx):\n    n = mx\n    prefix_ar = seive(n)\n    for i in lx:\n        if i == 2:\n            print(1)\n            continue\n        if i == 3:\n            print(2)\n            continue\n        print(1 + prefix_ar[i] - prefix_ar[i // 2])\nT = int(input())\nmx = 0\nls = []\nfor _ in range(T):\n    n = int(input())\n    ls.append(n)\n    mx = max(mx, n)\nfun(ls, mx)", "def SieveOfEratosthenes(n, d):\n    c = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\nb = []\nd = {}\nb = SieveOfEratosthenes(10000001, d)\np = 0\nfor i in range(2, 10000001):\n    if b[i] == True:\n        p += 1\n        d[i] = p\nt = int(input())\nfor test in range(t):\n    n = int(input())\n    c = 0\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        c = 0\n        x = 0\n        z = n // 2\n        for i in range(n, z, -1):\n            if b[i] == True:\n                x = d[i]\n                break\n        for i in range(z, 1, -1):\n            if b[i] == True:\n                c = d[i]\n                break\n        print(x - c + 1)", "t = int(input())\n\ndef SieveOfEratosthenes(n):\n    prime = [1 for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == 1:\n            for i in range(p * p, n + 1, p):\n                prime[i] = 0\n        p += 1\n    return prime\nc = SieveOfEratosthenes(10 ** 7 + 1)\nfor i in range(3, len(c) // 2):\n    if c[i] == 1:\n        c[2 * i] = -1\n        c[i] = 1\nfor i in range(3, len(c)):\n    c[i] += c[i - 1]\nfor i in range(t):\n    n = int(input())\n    h = 0\n    print(c[n])", "t = int(input())\n\ndef SieveOfEratosthenes(n):\n    prime = [1 for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == 1:\n            for i in range(p * p, n + 1, p):\n                prime[i] = 0\n        p += 1\n    return prime\nc = SieveOfEratosthenes(10 ** 7 + 1)\nfor i in range(3, len(c) // 2):\n    if c[i] == 1:\n        c[2 * i] = -1\n        c[i] = 1\nfor i in range(3, len(c)):\n    c[i] += c[i - 1]\nfor i in range(t):\n    n = int(input())\n    h = 0\n    print(c[n])", "N = int(10000000.0 + 1)\nprime = [True for i in range(N + 1)]\nprefix = [0] * (N + 2)\n\ndef siev():\n    p = 2\n    while p * p <= N:\n        if prime[p] == True:\n            for i in range(p * p, N + 1, p):\n                prime[i] = False\n        p += 1\n\ndef func():\n    prefix[2] = 1\n    prefix[3] = 2\n    prefix[4] = 2\n    count = 2\n    for p in range(5, N + 1):\n        if prime[p]:\n            count += 1\n        elif p % 2 == 0 and prime[p // 2]:\n            count -= 1\n        prefix[p] = count\nsiev()\nfunc()\nfor _ in range(int(input())):\n    n = int(input())\n    print(prefix[n])", "prime = [True for i in range(10000001)]\np = 2\nwhile p * p < 10000001:\n    if prime[p] == True:\n        for i in range(p * p, 10000001, p):\n            prime[i] = False\n    p += 1\ntpr = 0\ntprime = []\nfor i in range(2, 10000001):\n    if prime[i]:\n        tpr += 1\n    tprime.append(tpr)\nfor _ in range(int(input())):\n    n = int(input())\n    start = tprime[n // 2 - 2]\n    end = tprime[n - 2]\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(end - start + 1)", "import math\nsize = 10 ** 7 + 1\nprime = [1] * size\nprime[0] = 0\nprime[1] = 0\nfor i in range(2, math.ceil(math.sqrt(size)) + 1):\n    if prime[i] == 1:\n        for j in range(i * i, size, i):\n            prime[j] = 0\nfor i in range(2, size):\n    prime[i] = prime[i] + prime[i - 1]\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(prime[n] - prime[n // 2] + 1)", "def SieveOfEratosthenes():\n    a = [0] * 10000001\n    n = 10000000\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n        a[p] = cnt\n    return a\nT = int(input())\nnum = SieveOfEratosthenes()\nwhile T > 0:\n    N = int(input())\n    if N == 2:\n        print(1)\n        T -= 1\n        continue\n    if N == 3:\n        print(2)\n        T -= 1\n        continue\n    even = N // 2\n    print(num[N] - (num[N // 2] - 1))\n    T -= 1", "from bisect import bisect_right\n\ndef primes_upto(limit):\n    is_prime = [True] * (limit + 1)\n    for n in range(3, int(limit ** 0.5 + 1.5), 2):\n        if is_prime[n]:\n            for i in range(n * n, limit + 1, 2 * n):\n                is_prime[i] = False\n    for i in range(3, limit + 1, 2):\n        if is_prime[i]:\n            yield i\n    return\np = list(primes_upto(10 ** 7))\n\ndef sol(n):\n    if n == 2:\n        return 1\n    return bisect_right(p, n) - bisect_right(p, n // 2) + 1\nfor _ in range(int(input())):\n    print(sol(int(input())))", "from bisect import bisect_right\n\ndef primes_upto(limit):\n    is_prime = [False, False, True, True] + [False, True] * int((limit - 2) / 2)\n    is_prime = is_prime[:limit + 1]\n    for n in range(3, int(limit ** 0.5 + 1.5), 2):\n        if is_prime[n]:\n            for i in range(n * n, limit + 1, 2 * n):\n                is_prime[i] = False\n    for i in range(3, limit + 1, 2):\n        if is_prime[i]:\n            yield i\n    return\np = list(primes_upto(10 ** 7))\n\ndef sol(n):\n    if n == 2:\n        return 1\n    return bisect_right(p, n) - bisect_right(p, n // 2) + 1\nfor _ in range(int(input())):\n    print(sol(int(input())))", "N = 10000002\nprime = [True] * (N + 1)\nprefixsum = [0] * (N + 1)\n\ndef sieve():\n    prime[0] = prime[1] = False\n    i = 2\n    while i * i < N:\n        if prime[i]:\n            for j in range(i * i, N + 1, i):\n                prime[j] = False\n        i += 1\n\ndef pref():\n    cnt = 0\n    for i in range(1, N + 1):\n        if prime[i]:\n            cnt += 1\n        prefixsum[i] = cnt\nsieve()\npref()\nt = int(input())\nwhile t:\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(1 + prefixsum[n] - prefixsum[n // 2])\n    t -= 1", "import math\nN = 10000002\nprime = [True] * (N + 1)\nprefixsum = [0] * (N + 1)\n\ndef sieve():\n    prime[0] = prime[1] = False\n    i = 2\n    while i * i < N:\n        if prime[i]:\n            for j in range(i * i, N + 1, i):\n                prime[j] = False\n        i += 1\n\ndef pref():\n    cnt = 0\n    for i in range(1, N + 1):\n        if prime[i]:\n            cnt += 1\n        prefixsum[i] = cnt\nsieve()\npref()\nt = int(input())\nwhile t:\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        ans = 1 + prefixsum[n] - prefixsum[n // 2]\n        print(ans)\n    t -= 1", "import bisect\nT = int(input())\nn = 10 ** 7\nprime = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p * p, n + 1, p):\n            prime[i] = False\n    p += 1\nl = []\nfor p in range(2, n + 1):\n    if prime[p]:\n        l.append(p)\nfor i in range(T):\n    n = int(input())\n    r1 = bisect.bisect_right(l, n / 2)\n    r2 = bisect.bisect_right(l, n)\n    if n < 4:\n        print(r2 - r1)\n    else:\n        print(r2 - r1 + 1)", "import math\nn = pow(10, 7) + 2\nar = [1] * n\nar[0] = ar[1] = 0\nar2 = [0] * n\nfor i in range(2, n):\n    if i * i >= n:\n        break\n    if ar[i]:\n        for j in range(i * i, n, i):\n            ar[j] = 0\nc = 0\nfor i in range(1, n):\n    if ar[i]:\n        c += 1\n    ar2[i] = c\nfor i in range(int(input())):\n    n1 = int(input())\n    if n1 == 2:\n        print(1)\n    elif n1 == 3:\n        print(2)\n    else:\n        a = n1 // 2\n        b = ar2[n1] - ar2[a] + 1\n        print(b)", "try:\n\n    def Ss(n):\n        op = []\n        prime = [True for i in range(n + 1)]\n        p = 2\n        while p * p <= n:\n            if prime[p] == True:\n                for i in range(p * 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                op.append(p)\n        return op\n    kl = Ss(10 ** 7)\n    import bisect\n    t = int(input())\n    for i in range(0, t):\n        n = int(input())\n        if n == 2:\n            print(1)\n        elif n == 3:\n            print(2)\n        else:\n            tn = bisect.bisect_right(kl, n) - bisect.bisect_right(kl, n // 2)\n            print(tn + 1)\nexcept:\n    pass", "try:\n\n    def Ss(n):\n        op = []\n        prime = [True for i in range(n + 1)]\n        p = 2\n        while p * p <= n:\n            if prime[p] == True:\n                for i in range(p * 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                op.append(p)\n        return op\n    kl = Ss(10 ** 7)\n    import bisect\n    t = int(input())\n    for i in range(0, t):\n        n = int(input())\n        if n == 2:\n            print(1)\n        elif n == 3:\n            print(2)\n        else:\n            tn = bisect.bisect_right(kl, n) - bisect.bisect_right(kl, n // 2)\n            print(tn + 1)\nexcept:\n    pass", "def buildPrime():\n    prime = [1] * (MAXIMUM + 1)\n    p = 2\n    while p * p <= MAXIMUM:\n        if prime[p] == 1:\n            i = p * 2\n            while i <= MAXIMUM:\n                prime[i] = 0\n                i += p\n        p += 1\n    for p in range(2, MAXIMUM + 1):\n        prefix[p] = prefix[p - 1]\n        if prime[p] == 1:\n            prefix[p] += 1\n\ndef answer(Left, Rright):\n    return prefix[Rright] - prefix[Left - 1]\nMAXIMUM = 10000000\nprefix = [0] * (MAXIMUM + 1)\nbuildPrime()\nfor __ in range(int(input())):\n    n = int(input())\n    print(answer(n // 2 + 1, n)) if n < 4 else print(1 + answer(n // 2 + 1, n))", "t = int(input())\nl = [0] * (10 ** 7 + 1)\n\ndef seive(maxi):\n    prime = [True for i in range(maxi + 1)]\n    p = 2\n    c = 0\n    while p * p <= maxi:\n        if prime[p] == True:\n            for i in range(p * p, maxi + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, maxi + 1):\n        if prime[p]:\n            c += 1\n        l[p] = c\nseive(10 ** 7)\nfor _ in range(t):\n    n = int(input())\n    if n <= 3:\n        print(n - 1)\n    else:\n        ans = l[n] - l[n // 2] + 1\n        print(ans)", "lim = 10000000\nutil = [0] * 10000001\n\ndef helper():\n    isp = [True] * 10000001\n    i = 2\n    while i * i <= lim:\n        if isp[i] == True:\n            j = i * 2\n            while j <= lim:\n                isp[j] = False\n                j += i\n        i += 1\n    util[0] = 0\n    util[1] = 0\n    i = 2\n    while i <= lim:\n        util[i] = util[i - 1]\n        if isp[i]:\n            util[i] += 1\n        i += 1\nhelper()\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3 or n == 4:\n        print(2)\n    else:\n        mid = n // 2\n        res = util[n] - util[mid]\n        print(res + 1)\n    t -= 1", "def SieveOfEratosthenes():\n    a = [0] * 10000001\n    n = 10000000\n    cnt = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            cnt += 1\n        a[p] = cnt\n    return a\nt = int(input())\nnum = SieveOfEratosthenes()\nfor _ in range(t):\n    N = int(input())\n    if N == 2:\n        print(1)\n        continue\n    if N == 3:\n        print(2)\n        continue\n    even = N // 2\n    print(num[N] - (num[N // 2] - 1))", "from math import ceil, sqrt\n\ndef steve(n):\n    global isPrime\n    isPrime = [1] * (n + 1)\n    isPrime[0] = isPrime[1] = 0\n    for i in range(2, int(sqrt(n)) + 1):\n        if isPrime[i]:\n            isPrime[i * i:n + 1:i] = [0] * len(isPrime[i * i:n + 1:i])\nsteve(10000000)\nfor i in range(1, 10000001):\n    isPrime[i] += isPrime[i - 1]\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 2 or n == 3:\n        print(n - 1)\n    else:\n        print(isPrime[n] - isPrime[n // 2] + 1)", "n = 10 ** 7\nseive = [False] * (n + 1)\n(seive[0], seive[1]) = (True, True)\np = 2\nwhile p * p <= n:\n    if seive[p] == False:\n        for i in range(p * p, len(seive), p):\n            seive[i] = True\n    p += 1\n\ndef is_prime(n):\n    return not seive[n]\ntable = [0] * (n + 1)\ntable[2] = 1\nfor i in range(2, len(table)):\n    if is_prime(i):\n        table[i] = table[i - 1] + 1\n    else:\n        table[i] = table[i - 1]\n\ndef solve(n):\n    l = [1, 2, 2, 3]\n    if n < 6:\n        return l[n - 2]\n    else:\n        return table[n] - table[n // 2] + 1\nt = int(input())\nfor tc in range(t):\n    n = int(input())\n    print(solve(n))", "def primeNumbers():\n    prime[0] = prime[1] = False\n    i = 2\n    while i * i < n:\n        if prime[i]:\n            j = i * i\n            while j <= n:\n                prime[j] = False\n                j += i\n        i += 1\n\ndef pre():\n    count = 0\n    for i in range(1, n + 1):\n        if prime[i]:\n            count += 1\n        prefix[i] = count\n\ndef totalComponents(m):\n    if 2 <= m <= 3:\n        return m - 1\n    return prefix[m] - prefix[m // 2] + 1\nt = int(input())\na = [0] * t\nfor i in range(t):\n    a[i] = int(input())\nn = max(a)\nprime = [True] * (n + 1)\nprefix = [0] * (n + 1)\nprimeNumbers()\npre()\nfor i in range(t):\n    print(totalComponents(a[i]))", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    li = [0, 0]\n    x = 0\n    for i in range(2, n):\n        if prime[i]:\n            x += 1\n        li.append(x)\n    return li\nli = SieveOfEratosthenes(10 ** 7 + 1)\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    ans = 1\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(li[n] - li[n // 2] + 1)", "def prime(n):\n    i = 2\n    global l\n    while i * i < n:\n        if arr[i] == True:\n            for j in range(i * i, n, i):\n                arr[j] = False\n        i += 1\n    count = 0\n    for i in range(2, n):\n        if arr[i]:\n            count += 1\n        prime_count[i] = count\nn = 10 ** 7 + 1\narr = [True] * n\nprime_count = [0] * n\nprime(n)\nt = int(input())\nwhile t:\n    N = int(input())\n    if N == 2:\n        print(1)\n    elif N == 3:\n        print(2)\n    else:\n        print(prime_count[N] - prime_count[N // 2] + 1)\n    t -= 1", "from sys import stdin, stdout\nimport math, bisect, heapq\nfrom collections import Counter, deque, defaultdict\nL = lambda : list(map(int, stdin.readline().strip().split()))\nI = lambda : int(stdin.readline().strip())\nS = lambda : stdin.readline().strip()\nC = lambda : stdin.readline().strip().split()\n\ndef pr(a):\n    return '.'.join(list(map(str, a)))\na = []\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    x = 0\n    for i in range(n + 1):\n        if prime[i]:\n            x += 1\n        a.append(x)\n\ndef solve():\n    n = I()\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        print(a[n] - a[n // 2] + 1)\nsieve(10 ** 7)\nfor _ in range(I()):\n    solve()", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\ndef func():\n    MAX = 10 ** 7 + 1\n    prime = SieveOfEratosthenes(MAX)\n    prefix_arr = [0, 0]\n    for i in range(2, MAX):\n        if prime[i]:\n            prefix_arr.append(prefix_arr[-1] + 1)\n        else:\n            prefix_arr.append(prefix_arr[-1])\n    return prefix_arr\nprefix_arr = func()\nfor _ in range(int(input())):\n    N = int(input())\n    if N <= 3:\n        print(prefix_arr[N])\n    else:\n        print(prefix_arr[N] - prefix_arr[N // 2] + 1)", "def seive(n):\n    prefix_ar = [0 for i in range(n + 1)]\n    ls = [True for i in range(n + 1)]\n    ls[0] = False\n    ls[1] = False\n    for i in range(2, n + 1):\n        val = ls[i]\n        if i * i <= n + 1:\n            if val == True:\n                for j in range(i * i, n + 1, i):\n                    if j % i == 0:\n                        ls[j] = False\n        else:\n            break\n    for i in range(1, n + 1):\n        val = ls[i]\n        if val == True:\n            prefix_ar[i] = prefix_ar[i - 1] + 1\n        else:\n            prefix_ar[i] = prefix_ar[i - 1]\n    return prefix_ar\nn = 10 ** 7 + 1\nprefix_ar = seive(n)\nT = int(input())\nmx = 0\nls = []\nfor _ in range(T):\n    i = int(input())\n    if i == 2:\n        print(1)\n        continue\n    if i == 3:\n        print(2)\n        continue\n    print(1 + prefix_ar[i] - prefix_ar[i // 2])", "import math\nn = 10 ** 7 + 1\nprime = [1] * n\nprime[0] = 0\nprime[1] = 0\nfor i in range(2, math.ceil(math.sqrt(n)) + 1):\n    if prime[i] == 1:\n        for j in range(i * i, n, i):\n            prime[j] = 0\nfor i in range(2, n):\n    prime[i] += prime[i - 1]\nt = int(input())\nfor i in range(t):\n    ni = int(input())\n    if ni > 3:\n        c = prime[ni] - prime[ni // 2] + 1\n        print(c)\n    elif ni == 2:\n        print(1)\n    else:\n        print(2)", "primeUpto = [0] * 10000003\nprime = [1] * 10000003\nprime[0] = prime[1] = 0\n\ndef countPrime():\n    n = 10000001\n    p = 2\n    while p * p <= n:\n        if prime[p] == 1:\n            for i in range(p * p, n + 1, p):\n                prime[i] = 0\n        p += 1\n    for i in range(1, 10000002):\n        primeUpto[i] = primeUpto[i - 1] + prime[i]\ncountPrime()\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 3:\n        print(2)\n    elif n == 2:\n        print(1)\n    else:\n        print(primeUpto[n] - primeUpto[n // 2] + 1)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(2 * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    return prime\nprimes = SieveOfEratosthenes(10 ** 7 + 5)\ncount_1 = 0\npricount = [0]\nfor i in range(1, 10 ** 7 + 6):\n    if primes[i]:\n        count_1 += 1\n    pricount.append(count_1)\nfor i in range(int(input())):\n    n = int(input())\n    j = 0\n    x = 1\n    y = 1\n    count = 0\n    if n == 2:\n        print(1)\n        continue\n    elif n == 3:\n        print(2)\n        continue\n    print(pricount[n] - pricount[n // 2] + 1)", "import sys\nfrom math import ceil\ninput = sys.stdin.readline\np = [False] + [True] * 10 ** 7\np[1] = False\np_count = [0] * (10 ** 7 + 1)\nfor i in range(2, 10 ** 7 + 1):\n    p_count[i] = p_count[i - 1]\n    if p[i]:\n        p_count[i] += 1\n        for j in range(i * i, 10 ** 7 + 1, i):\n            p[j] = False\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 2:\n        print(1)\n        continue\n    if n == 3:\n        print(2)\n        continue\n    print(p_count[n] - p_count[n // 2] + 1)", "import math\nn = 10 ** 7 + 1\nprime = [True] * n\nprime_count = [0] * n\np = 2\nwhile p * p < n:\n    if prime[p]:\n        for i in range(p * p, n, p):\n            prime[i] = False\n    p += 1\ncount = 0\nfor i in range(2, n):\n    if prime[i]:\n        count += 1\n    prime_count[i] = count\nt = int(input())\nwhile t:\n    n = int(input())\n    if n == 2:\n        print('1')\n    elif n == 3:\n        print('2')\n    else:\n        print(prime_count[n] - prime_count[n // 2] + 1)\n    t -= 1", "def primeNumbers():\n    prime[0] = prime[1] = False\n    i = 2\n    while i * i < n:\n        if prime[i]:\n            j = i * i\n            while j <= n:\n                prime[j] = False\n                j += i\n        i += 1\n\ndef pre():\n    count = 0\n    for i in range(1, n + 1):\n        if prime[i]:\n            count += 1\n        prefix[i] = count\n\ndef totalComponents(m):\n    if 2 <= m <= 3:\n        return m - 1\n    return prefix[m] - prefix[m // 2] + 1\nt = int(input())\na = [0] * t\nfor i in range(t):\n    a[i] = int(input())\nn = max(a)\nprime = [True] * (n + 1)\nprefix = [0] * (n + 1)\nprimeNumbers()\npre()\nfor i in range(t):\n    print(totalComponents(a[i]))", "import math\nN = 10 ** 7 + 1\nprime = []\nprimecount = [0, 0]\nsieve = [False for i in range(N)]\nk = 2\nwhile k <= int(math.sqrt(N)):\n    if sieve[k] == False:\n        for i in range(k ** 2, N, k):\n            sieve[i] = True\n    k += 1\nfor i in range(2, N):\n    if sieve[i]:\n        primecount.append(primecount[-1])\n    else:\n        prime.append(i)\n        primecount.append(primecount[-1] + 1)\nt = int(input())\nfor testcase in range(t):\n    n = int(input())\n    if n == 2:\n        print(1)\n    elif n == 3:\n        print(2)\n    else:\n        limit = n // 2\n        i = 0\n        print(primecount[n] - primecount[limit] + 1)"]