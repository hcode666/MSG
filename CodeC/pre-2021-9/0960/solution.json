["for q in range(int(input())):\n    (n, m) = map(int, input().split())\n    (l1, l, c, f, r, result) = ([int(x) for x in input().split()], [], [0] * m, 0, 0, 10 ** 10)\n    for i in range(0, n):\n        l2 = []\n        (l2.append(l1[i]), l2.append(i % m))\n        l.append(l2)\n    l.sort()\n    for i in range(n):\n        while r < n and f < m:\n            if c[l[r][1]] == 0:\n                f += 1\n            c[l[r][1]] += 1\n            r += 1\n        if f == m:\n            result = min(result, l[r - 1][0] - l[i][0])\n        c[l[i][1]] -= 1\n        if c[l[i][1]] == 0:\n            f -= 1\n    print(result)", "for q in range(int(input())):\n    (n, m) = map(int, input().split())\n    (l1, l, c, f, r, result) = ([int(x) for x in input().split()], [], [0] * m, 0, 0, 10 ** 10)\n    for i in range(0, n):\n        l2 = []\n        (l2.append(l1[i]), l2.append(i % m))\n        l.append(l2)\n    l.sort()\n    for i in range(n):\n        while r < n and f < m:\n            if c[l[r][1]] == 0:\n                f += 1\n            c[l[r][1]] += 1\n            r += 1\n        if f == m:\n            result = min(result, l[r - 1][0] - l[i][0])\n        c[l[i][1]] -= 1\n        if c[l[i][1]] == 0:\n            f -= 1\n    print(result)", "for q in range(int(input())):\n    (n, m) = map(int, input().split())\n    (l1, l, c, f, r, result) = ([int(x) for x in input().split()], [], [0] * m, 0, 0, 10 ** 10)\n    for i in range(0, n):\n        l2 = []\n        (l2.append(l1[i]), l2.append(i % m))\n        l.append(l2)\n    l.sort()\n    for i in range(n):\n        while r < n and f < m:\n            if c[l[r][1]] == 0:\n                f += 1\n            c[l[r][1]] += 1\n            r += 1\n        if f == m:\n            result = min(result, l[r - 1][0] - l[i][0])\n        c[l[i][1]] -= 1\n        if c[l[i][1]] == 0:\n            f -= 1\n    print(result)", "t = int(input())\n\ndef minDiff1(a, n, m, w):\n    co = [0] * m\n    done = [False] * m\n    doall = [True] * m\n    ca = a[n - 1] - a[0]\n    i = 0\n    j = 0\n    while i < n:\n        done[w[i]] = True\n        co[w[i]] += 1\n        if w[i] == w[j] and i != j:\n            co[w[j]] -= 1\n            j += 1\n        if done == doall:\n            while co[w[j]] > 1:\n                co[w[j]] -= 1\n                j += 1\n            ca = min(a[i] - a[j], ca)\n            co[w[j]] -= 1\n            if co[w[j]] == 0:\n                done[w[j]] = False\n            j += 1\n        i += 1\n    print(ca)\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = [int(i) for i in input().split()]\n    sin = [j[0] for j in sorted(enumerate(a), key=lambda x: x[1])]\n    w = [0] * n\n    for j in range(n):\n        w[j] = sin[j] % m\n    a.sort()\n    ans = 9147483647\n    chk = [int(i) for i in range(m)]\n    if m == n:\n        print(a[n - 1] - a[0])\n    minDiff1(a, n, m, w)", "import sys\n\ndef smallestDifference(colors, arr):\n    color_count = [0] * colors\n    arr_with_color = list(zip(arr, [i for i in range(len(arr))]))\n    arr_with_color.sort(key=lambda x: x[0])\n    (i, j) = (0, 0)\n    mini_diff = sys.maxsize\n    count = 0\n    while i <= len(arr):\n        if count < colors and i < len(arr):\n            color_count[arr_with_color[i][1] % colors] += 1\n            if color_count[arr_with_color[i][1] % colors] == 1:\n                count += 1\n            i += 1\n        elif count >= colors:\n            mini_diff = min(mini_diff, arr_with_color[i - 1][0] - arr_with_color[j][0])\n            color_count[arr_with_color[j][1] % colors] -= 1\n            if color_count[arr_with_color[j][1] % colors] == 0:\n                count -= 1\n            j += 1\n        else:\n            break\n    return mini_diff\ntry:\n    testcases = int(input())\n    for i in range(testcases):\n        (arr_len, colors) = list(map(int, input().strip().split()))\n        arr = list(map(int, input().strip().split()))\n        print(smallestDifference(colors, arr))\nexcept:\n    pass", "for x in range(int(input())):\n    (m, n) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l1 = []\n    l2 = []\n    l3 = [0] * n\n    t = 0\n    flagi = 0\n    for x in range(len(l)):\n        l1.append([l[x], x % n])\n    l1.sort()\n    count = 0\n    for y in range(m):\n        if count != n:\n            if l3[l1[y][1]] == 0:\n                k = 0\n                if flagi != 1:\n                    k = y\n                    flagi = 1\n                l3[l1[y][1]] += 1\n                count += 1\n                if count == n:\n                    t = y + 1\n                    l2.append(abs(l1[y][0] - l1[k][0]))\n                    break\n            else:\n                l3[l1[y][1]] += 1\n    for x in range(m - n):\n        l3[l1[x][1]] -= 1\n        flag = 0\n        if l3[l1[x][1]] == 0:\n            for y in range(t, m):\n                if l1[y][1] == l1[x][1]:\n                    l3[l1[y][1]] += 1\n                    t = y + 1\n                    l2.append(abs(l1[y][0] - l1[x + 1][0]))\n                    flag = 1\n                    break\n                else:\n                    l3[l1[y][1]] += 1\n            if flag == 0:\n                break\n        else:\n            l2.append(abs(l1[t - 1][0] - l1[x + 1][0]))\n    print(min(l2))", "import heapq\n\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n    z = [x for (_, x) in sorted(zipped_pairs)]\n    return z\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    cl = []\n    for i in range(len(l)):\n        cl.append((i + 1) % m)\n    cl = sort_list(cl, l)\n    l.sort()\n    di = {}\n    i = len(l) - 1\n    while i >= 0:\n        co = cl[i]\n        val = l[i]\n        if co in di:\n            li = di[co]\n            li.append(val)\n        else:\n            di[co] = [val]\n        i = i - 1\n    min_heap = []\n    max_heap = []\n    for i in range(m):\n        v = di[i]\n        vf = v[-1]\n        min_heap.append(vf)\n        max_heap.append(-1 * vf)\n    heapq.heapify(min_heap)\n    heapq.heapify(max_heap)\n    midi = {}\n    f = 0\n    i = 0\n    while i < len(l) and f == 0:\n        if i == 0:\n            prev = cl[i]\n            val1 = di[prev]\n            if len(val1) == 0:\n                f = 1\n            else:\n                mi = min_heap[0]\n                ma = max_heap[0]\n                ma = -1 * ma\n                diff = abs(ma - mi)\n                valu = val1[-1]\n                val1.pop()\n                if valu in midi:\n                    gf = midi[valu]\n                    midi[valu] = gf + 1\n                else:\n                    midi[valu] = 1\n            di[prev] = val1\n        else:\n            val2 = di[prev]\n            if len(val2) == 0:\n                f = 1\n            else:\n                chk = val2[-1]\n                heapq.heappush(min_heap, chk)\n                heapq.heappush(max_heap, -1 * chk)\n                mival = min_heap[0]\n                if mival in midi:\n                    if midi[mival] > 0:\n                        heapq.heappop(min_heap)\n                        fr = midi[mival]\n                        fr = fr - 1\n                        midi[mival] = fr\n                maxv = max_heap[0]\n                minv = min_heap[0]\n                maxv = -1 * maxv\n                diff2 = abs(maxv - minv)\n                if diff2 < diff:\n                    diff = diff2\n                prev = cl[i]\n                val1 = di[prev]\n                if len(val1) == 0:\n                    f = 1\n                else:\n                    valu = val1[-1]\n                    val1.pop()\n                    if valu in midi:\n                        gf = midi[valu]\n                        midi[valu] = gf + 1\n                    else:\n                        midi[valu] = 1\n                di[prev] = val1\n        i = i + 1\n    print(diff)", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    final = []\n    final = [j % m for j in sorted([i for i in range(n)], key=lambda x: a[x])]\n    a.sort()\n    found = {}\n    i = 0\n    j = 0\n    ans = a[-1] - a[0]\n    while i < n - m + 1 and j < n:\n        while j < n and len(found.keys()) < m:\n            if final[j] in found:\n                found[final[j]] += 1\n            else:\n                found[final[j]] = 1\n            j += 1\n        while i < n - m + 1 and len(found.keys()) == m:\n            ans = min(ans, a[j - 1] - a[i])\n            found[final[i]] -= 1\n            if found[final[i]] == 0:\n                del found[final[i]]\n            i += 1\n    print(ans)", "from heapq import *\nimport itertools, math, heapq\n\ndef handle_input(M, N, A):\n    heap = []\n    lists = [sorted(A[i::M]) for i in range(M)]\n    curr_max = 0\n    for i in range(M):\n        item = lists[i][0]\n        heapq.heappush(heap, (item, i))\n        if item > curr_max:\n            curr_max = item\n    min_diff = float('inf')\n    indexes = [0 for i in range(M)]\n    min_item = float('inf')\n    while True:\n        (min_item, i) = heapq.heappop(heap)\n        diff = curr_max - min_item\n        if diff < min_diff:\n            min_diff = diff\n        indexes[i] += 1\n        try:\n            item = lists[i][indexes[i]]\n        except:\n            break\n        if item > curr_max:\n            curr_max = item\n        heapq.heappush(heap, (item, i))\n    print(min_diff)\nT = int(input())\nfor i in range(T):\n    (N, M) = map(int, input().split())\n    A = list(map(int, input().split()))\n    handle_input(M, N, A)", "t = int(input())\nfor q in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    l1 = [int(x) for x in input().split()]\n    l = []\n    for i in range(0, n):\n        l2 = []\n        l2.append(l1[i])\n        l2.append(i % m)\n        l.append(l2)\n    l.sort()\n    c = []\n    for i in range(m):\n        c.append(0)\n    f = 0\n    r = 0\n    result = 10 ** 10\n    for i in range(0, n):\n        while r < n and f < m:\n            if c[l[r][1]] == 0:\n                f += 1\n            c[l[r][1]] += 1\n            r += 1\n        if f == m:\n            result = min(result, l[r - 1][0] - l[i][0])\n        c[l[i][1]] -= 1\n        if c[l[i][1]] == 0:\n            f -= 1\n    print(result)", "t = int(input())\nfor q in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    l1 = [int(x) for x in input().split()]\n    l = []\n    for i in range(0, n):\n        l2 = []\n        l2.append(l1[i])\n        l2.append(i % m)\n        l.append(l2)\n    l.sort()\n    c = []\n    for i in range(m):\n        c.append(0)\n    f = m\n    r = 0\n    result = 10 ** 10\n    for i in range(0, n):\n        while r < n and f > 0:\n            if c[l[r][1]] == 0:\n                f -= 1\n            c[l[r][1]] += 1\n            r += 1\n        if f == 0:\n            result = min(result, l[r - 1][0] - l[i][0])\n        c[l[i][1]] -= 1\n        if c[l[i][1]] == 0:\n            f += 1\n    print(result)", "from sys import stdin\nfrom heapq import heapify, heappop, heappush\nt = int(stdin.readline())\nwhile t:\n    (n, m) = [int(x) for x in stdin.readline().split()]\n    a = [(x, int(y)) for (x, y) in enumerate(stdin.readline().split())]\n    a.sort(key=lambda x: x[1])\n    seg_all_col = [[] for x in range(m)]\n    for i in range(n):\n        seg_all_col[a[i][0] % m].append(a[i][1])\n    vis = [[1, len(i)] for i in seg_all_col]\n    (mn, mx) = (float('inf'), float('-inf'))\n    li = []\n    for i in range(m):\n        mx = max(mx, seg_all_col[i][0])\n        li.append([seg_all_col[i][0], i])\n    curMinRange = float('inf')\n    heapify(li)\n    temp = []\n    while True:\n        temp = heappop(li)\n        mn = temp[0]\n        curMinRange = min(curMinRange, mx - mn)\n        if vis[temp[1]][0] == vis[temp[1]][1]:\n            break\n        else:\n            nxt = seg_all_col[temp[1]][vis[temp[1]][0]]\n            mx = max(mx, nxt)\n            vis[temp[1]][0] += 1\n            heappush(li, [nxt, temp[1]])\n    print(curMinRange)\n    t -= 1", "t = int(input())\n\ndef minDiff1(a, n, m, w):\n    co = [0] * m\n    done = [False] * m\n    doall = [True] * m\n    ca = a[n - 1] - a[0]\n    i = 0\n    j = 0\n    while i < n:\n        done[w[i]] = True\n        co[w[i]] += 1\n        if w[i] == w[j] and i != j:\n            co[w[j]] -= 1\n            j += 1\n        if done == doall:\n            while co[w[j]] > 1:\n                co[w[j]] -= 1\n                j += 1\n            ca = min(a[i] - a[j], ca)\n            co[w[j]] -= 1\n            if co[w[j]] == 0:\n                done[w[j]] = False\n            j += 1\n        i += 1\n    print(ca)\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = [int(i) for i in input().split()]\n    sin = [j[0] for j in sorted(enumerate(a), key=lambda x: x[1])]\n    w = [0] * n\n    for j in range(n):\n        w[j] = sin[j] % m\n    a.sort()\n    ans = 9147483647\n    chk = [int(i) for i in range(m)]\n    if m == n:\n        print(a[n - 1] - a[0])\n    minDiff1(a, n, m, w)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    colors = list(range(m)) * (n // m) + list(range(n % m))\n    a = sorted([[x, y] for (x, y) in zip(a, colors)])\n    color_slots = [None] * m\n    min_arr = []\n    min_ind = 0\n    c_cnt = 0\n    res = 10 ** 9 + 10\n    for (val, color) in a:\n        min_arr.append(val)\n        if color_slots[color] is None:\n            c_cnt += 1\n        else:\n            min_arr[color_slots[color]] = None\n        color_slots[color] = len(min_arr) - 1\n        if c_cnt == m:\n            mx = min_arr[-1]\n            while min_arr[min_ind] is None:\n                min_ind += 1\n            mn = min_arr[min_ind]\n            res = min(res, mx - mn)\n    print(res)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    colors = list(range(m)) * (n // m) + list(range(n % m))\n    a = sorted([[x, y] for (x, y) in zip(a, colors)])\n    color_slots = [None] * m\n    min_arr = []\n    min_ind = 0\n    c_cnt = 0\n    res = 10 ** 9 + 10\n    for (val, color) in a:\n        min_arr.append(val)\n        if color_slots[color] is None:\n            c_cnt += 1\n        else:\n            min_arr[color_slots[color]] = None\n        color_slots[color] = len(min_arr) - 1\n        if c_cnt == m:\n            mx = min_arr[-1]\n            while min_arr[min_ind] is None:\n                min_ind += 1\n            mn = min_arr[min_ind]\n            res = min(res, mx - mn)\n    print(res)", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    func = lambda x: (int(x[1]), x[0] % m)\n    arr = list(map(func, enumerate(input().split())))\n    arr.sort()\n    cnt = [0] * m\n    cnt0 = m\n    r = 0\n    ans = float('inf')\n    for l in range(n):\n        while r < n and cnt0 > 0:\n            cnt0 -= cnt[arr[r][1]] == 0\n            cnt[arr[r][1]] += 1\n            r += 1\n        if cnt0 == 0:\n            ans = min(ans, arr[r - 1][0] - arr[l][0])\n        cnt[arr[l][1]] -= 1\n        cnt0 += cnt[arr[l][1]] == 0\n    print(ans)", "from heapq import heappush, heappop, heapify\n\ndef choose(buckets, n, m):\n    chosen = [(buckets[i][0], i, 0) for i in range(m)]\n    heapify(chosen)\n    max_box = max(chosen)[0]\n    ans = float('inf')\n    while chosen:\n        ans = min(ans, max_box - chosen[0][0])\n        (cur_box, i, idx) = heappop(chosen)\n        cur_bucket = buckets[i]\n        if idx + 1 >= len(cur_bucket):\n            break\n        next_box = cur_bucket[idx + 1]\n        heappush(chosen, (next_box, i, idx + 1))\n        max_box = max(max_box, next_box)\n    return ans\ntry:\n    test_num = int(input())\n    get_input = lambda : list(map(int, input().split()))\n    for _ in range(test_num):\n        (n, m) = get_input()\n        boxes = get_input()\n        buckets = [[] for i in range(m)]\n        for (i, num) in enumerate(boxes):\n            buckets[i % m] += [num]\n        for bucket in buckets:\n            bucket.sort()\n        print(choose(buckets, n, m))\nexcept EOFError:\n    pass", "t = int(input())\n\ndef sortSecond(val):\n    return val[1]\n\ndef minDiff(arr, N, K, w, chk, res):\n    wa = res\n    for i in range(N - K + 1):\n        curSeqDiff = arr[i + K - 1] - arr[i]\n        if curSeqDiff < res:\n            yes = set(chk).issubset(set(w[i:i + K]))\n        if curSeqDiff < res and yes:\n            res = curSeqDiff\n        elif curSeqDiff < res and ~yes:\n            wa = curSeqDiff\n    return (res, wa)\n\ndef sol(a, n, m, w, chk, ans):\n    (ca, wa) = minDiff(a, n, m, w, chk, ans)\n    while wa < ca:\n        (c1, wa) = minDiff(a, n, m + 1, w, chk, ca)\n        if c1 < ca:\n            ca = c1\n        if m >= n:\n            break\n        m += 1\n    print(ca)\n\ndef minDiff1(a, n, m, w):\n    co = [0] * m\n    done = [False] * m\n    doall = [True] * m\n    ca = a[n - 1] - a[0]\n    i = 0\n    j = 0\n    while i < n:\n        done[w[i]] = True\n        co[w[i]] += 1\n        if w[i] == w[j] and i != j:\n            co[w[j]] -= 1\n            j += 1\n        if done == doall:\n            while co[w[j]] > 1:\n                co[w[j]] -= 1\n                j += 1\n            ca = min(a[i] - a[j], ca)\n            co[w[j]] -= 1\n            if co[w[j]] == 0:\n                done[w[j]] = False\n            j += 1\n        i += 1\n    print(ca)\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = [int(i) for i in input().split()]\n    sin = [j[0] for j in sorted(enumerate(a), key=lambda x: x[1])]\n    w = [0] * n\n    for j in range(n):\n        w[j] = sin[j] % m\n    a.sort()\n    ans = 9147483647\n    chk = [int(i) for i in range(m)]\n    if m == n:\n        print(a[n - 1] - a[0])\n    minDiff1(a, n, m, w)", "t = int(input())\n\ndef minDiff1(a, n, m, w):\n    co = [0] * m\n    done = [False] * m\n    doall = [True] * m\n    ca = a[n - 1] - a[0]\n    i = 0\n    j = 0\n    while i < n:\n        done[w[i]] = True\n        co[w[i]] += 1\n        if w[i] == w[j] and i != j:\n            co[w[j]] -= 1\n            j += 1\n        if done == doall:\n            while co[w[j]] > 1:\n                co[w[j]] -= 1\n                j += 1\n            ca = min(a[i] - a[j], ca)\n            co[w[j]] -= 1\n            if co[w[j]] == 0:\n                done[w[j]] = False\n            j += 1\n        i += 1\n    print(ca)\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = [int(i) for i in input().split()]\n    sin = [j[0] for j in sorted(enumerate(a), key=lambda x: x[1])]\n    w = [0] * n\n    for j in range(n):\n        w[j] = sin[j] % m\n    a.sort()\n    ans = 9147483647\n    chk = [int(i) for i in range(m)]\n    if m == n:\n        print(a[n - 1] - a[0])\n    minDiff1(a, n, m, w)", "import heapq\ntest = int(input())\n\ndef findMaximumElement(heap):\n    maximumElement = heap[0]\n    for i in range(1, len(heap)):\n        maximumElement = max(maximumElement, heap[i])\n    return maximumElement\nwhile test > 0:\n    test -= 1\n    (n, m) = map(int, input().split())\n    mat = [[] for i in range(m)]\n    arr = list(map(int, input().split()))\n    for i in range(len(arr)):\n        mat[i % m].append(arr[i])\n    for i in range(len(mat)):\n        mat[i].sort()\n    minheap = []\n    for i in range(len(mat)):\n        minheap.append([mat[i][0], i, 0])\n    heapq.heapify(minheap)\n    mindiff = 10 ** 10\n    b = findMaximumElement(minheap)\n    while True:\n        a = heapq.heappop(minheap)\n        diff = b[0] - a[0]\n        if diff < mindiff:\n            mindiff = diff\n        k = a[2] + 1\n        if k > len(mat[a[1]]) - 1:\n            break\n        heapq.heappush(minheap, [mat[a[1]][a[2] + 1], a[1], a[2] + 1])\n        if mat[a[1]][a[2] + 1] > b[0]:\n            b = [mat[a[1]][a[2] + 1], a[1], a[2] + 1]\n    print(mindiff)", "from bisect import insort\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    li = list(map(int, input().split()))\n    li2 = [[] for i in range(m)]\n    for x in range(n):\n        insort(li2[x % m], li[x])\n    val = [[li2[x][0], x] for x in range(m)]\n    val.sort()\n    pt = [0] * m\n    m_x = val[-1][0]\n    m_n = val[0][0]\n    res = m_x - m_n\n    while res:\n        res = min(m_x - m_n, res)\n        ind = val[0][1]\n        try:\n            pt[ind] += 1\n            del val[0]\n            insort(val, [li2[ind][pt[ind]], ind])\n            m_x = max(m_x, val[-1][0])\n        except:\n            break\n        m_n = val[0][0]\n    print(res)", "t = int(input())\n\ndef minDiff1(a, n, m, w):\n    co = [0] * m\n    done = [False] * m\n    doall = [True] * m\n    ca = a[n - 1] - a[0]\n    i = 0\n    j = 0\n    while i < n:\n        done[w[i]] = True\n        co[w[i]] += 1\n        if w[i] == w[j] and i != j:\n            co[w[j]] -= 1\n            j += 1\n        if done == doall:\n            while co[w[j]] > 1:\n                co[w[j]] -= 1\n                j += 1\n            ca = min(a[i] - a[j], ca)\n            co[w[j]] -= 1\n            if co[w[j]] == 0:\n                done[w[j]] = False\n            j += 1\n        i += 1\n    print(ca)\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = [int(i) for i in input().split()]\n    sin = [j[0] for j in sorted(enumerate(a), key=lambda x: x[1])]\n    w = [0] * n\n    for j in range(n):\n        w[j] = sin[j] % m\n    a.sort()\n    ans = 9147483647\n    chk = [int(i) for i in range(m)]\n    if m == n:\n        print(a[n - 1] - a[0])\n    minDiff1(a, n, m, w)", "t = int(input())\n\ndef minDiff1(a, n, m, w):\n    co = [0] * m\n    done = [False] * m\n    doall = [True] * m\n    ca = a[n - 1] - a[0]\n    i = 0\n    j = 0\n    while i < n:\n        done[w[i]] = True\n        co[w[i]] += 1\n        if w[i] == w[j] and i != j:\n            co[w[j]] -= 1\n            j += 1\n        if done == doall:\n            while co[w[j]] > 1:\n                co[w[j]] -= 1\n                j += 1\n            ca = min(a[i] - a[j], ca)\n            co[w[j]] -= 1\n            if co[w[j]] == 0:\n                done[w[j]] = False\n            j += 1\n        i += 1\n    print(ca)\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = [int(i) for i in input().split()]\n    sin = [j[0] for j in sorted(enumerate(a), key=lambda x: x[1])]\n    w = [0] * n\n    for j in range(n):\n        w[j] = sin[j] % m\n    a.sort()\n    ans = 9147483647\n    chk = [int(i) for i in range(m)]\n    if m == n:\n        print(a[n - 1] - a[0])\n    minDiff1(a, n, m, w)", "t = int(input())\n\ndef sortSecond(val):\n    return val[1]\n\ndef minDiff(arr, N, K, w, chk, res):\n    wa = res\n    for i in range(N - K + 1):\n        curSeqDiff = arr[i + K - 1] - arr[i]\n        if curSeqDiff < res:\n            yes = set(chk).issubset(set(w[i:i + K]))\n        if curSeqDiff < res and yes:\n            res = curSeqDiff\n        elif curSeqDiff < res and ~yes:\n            wa = curSeqDiff\n    return (res, wa)\n\ndef sol(a, n, m, w, chk, ans):\n    (ca, wa) = minDiff(a, n, m, w, chk, ans)\n    while wa < ca:\n        (c1, wa) = minDiff(a, n, m + 1, w, chk, ca)\n        if c1 < ca:\n            ca = c1\n        if m >= n:\n            break\n        m += 1\n    print(ca)\n\ndef minDiff1(a, n, m, w):\n    co = [0] * m\n    done = [False] * m\n    doall = [True] * m\n    ca = a[n - 1] - a[0]\n    i = 0\n    j = 0\n    while i < n:\n        done[w[i]] = True\n        co[w[i]] += 1\n        if w[i] == w[j] and i != j:\n            co[w[j]] -= 1\n            j += 1\n        if done == doall:\n            while co[w[j]] > 1:\n                co[w[j]] -= 1\n                j += 1\n            ca = min(a[i] - a[j], ca)\n            co[w[j]] -= 1\n            if co[w[j]] == 0:\n                done[w[j]] = False\n            j += 1\n        i += 1\n    print(ca)\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = [int(i) for i in input().split()]\n    sin = [j[0] for j in sorted(enumerate(a), key=lambda x: x[1])]\n    w = [0] * n\n    for j in range(n):\n        w[j] = sin[j] % m\n    a.sort()\n    ans = 9147483647\n    chk = [int(i) for i in range(m)]\n    if m == n:\n        print(a[n - 1] - a[0])\n    minDiff1(a, n, m, w)", "t = int(input())\n\ndef sortSecond(val):\n    return val[1]\n\ndef minDiff(arr, N, K, w, chk, res):\n    wa = res\n    for i in range(N - K + 1):\n        curSeqDiff = arr[i + K - 1] - arr[i]\n        if curSeqDiff < res:\n            yes = set(chk).issubset(set(w[i:i + K]))\n        if curSeqDiff < res and yes:\n            res = curSeqDiff\n        elif curSeqDiff < res and ~yes:\n            wa = curSeqDiff\n    return (res, wa)\n\ndef sol(a, n, m, w, chk, ans):\n    (ca, wa) = minDiff(a, n, m, w, chk, ans)\n    while wa < ca:\n        (c1, wa) = minDiff(a, n, m + 1, w, chk, ca)\n        if c1 < ca:\n            ca = c1\n        if m >= n:\n            break\n        m += 1\n    print(ca)\n\ndef minDiff1(a, n, m, w):\n    co = [0] * m\n    done = [False] * m\n    doall = [True] * m\n    ca = a[n - 1] - a[0]\n    i = 0\n    j = 0\n    while i < n:\n        done[w[i]] = True\n        co[w[i]] += 1\n        if w[i] == w[j] and i != j:\n            co[w[j]] -= 1\n            j += 1\n        if done == doall:\n            while co[w[j]] > 1:\n                co[w[j]] -= 1\n                j += 1\n            ca = min(a[i] - a[j], ca)\n            co[w[j]] -= 1\n            if co[w[j]] == 0:\n                done[w[j]] = False\n            j += 1\n        i += 1\n    print(ca)\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = [int(i) for i in input().split()]\n    sin = [j[0] for j in sorted(enumerate(a), key=lambda x: x[1])]\n    w = [0] * n\n    for j in range(n):\n        w[j] = sin[j] % m\n    a.sort()\n    ans = 9147483647\n    chk = [int(i) for i in range(m)]\n    if m == n:\n        print(a[n - 1] - a[0])\n    minDiff1(a, n, m, w)", "t = int(input())\n\ndef sortSecond(val):\n    return val[1]\n\ndef minDiff(arr, N, K, w, chk, res):\n    wa = res\n    for i in range(N - K + 1):\n        curSeqDiff = arr[i + K - 1] - arr[i]\n        if curSeqDiff < res:\n            yes = set(chk).issubset(set(w[i:i + K]))\n        if curSeqDiff < res and yes:\n            res = curSeqDiff\n        elif curSeqDiff < res and ~yes:\n            wa = curSeqDiff\n    return (res, wa)\n\ndef sol(a, n, m, w, chk, ans):\n    (ca, wa) = minDiff(a, n, m, w, chk, ans)\n    while wa < ca:\n        (c1, wa) = minDiff(a, n, m + 1, w, chk, ca)\n        if c1 < ca:\n            ca = c1\n        if m >= n:\n            break\n        m += 1\n    print(ca)\n\ndef minDiff1(a, n, m, w):\n    co = [0] * m\n    done = [False] * m\n    doall = [True] * m\n    ca = a[n - 1] - a[0]\n    i = 0\n    j = 0\n    while i < n:\n        done[w[i]] = True\n        co[w[i]] += 1\n        if w[i] == w[j] and i != j:\n            co[w[j]] -= 1\n            j += 1\n        if done == doall:\n            while co[w[j]] > 1:\n                co[w[j]] -= 1\n                j += 1\n            ca = min(a[i] - a[j], ca)\n            co[w[j]] -= 1\n            if co[w[j]] == 0:\n                done[w[j]] = False\n            j += 1\n        i += 1\n    print(ca)\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = [int(i) for i in input().split()]\n    sin = [j[0] for j in sorted(enumerate(a), key=lambda x: x[1])]\n    w = [0] * n\n    for j in range(n):\n        w[j] = sin[j] % m\n    a.sort()\n    ans = 9147483647\n    chk = [int(i) for i in range(m)]\n    if m == n:\n        print(a[n - 1] - a[0])\n    minDiff1(a, n, m, w)", "import bisect as b\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    for i in range(n):\n        l[i] = [l[i], i % m]\n    l.sort()\n    ans = []\n    d = {}\n    min1 = 2 ** 32\n    for i in l:\n        if d.get(i[1], -1) == -1:\n            d[i[1]] = i[0]\n            ans.append(i[0])\n        else:\n            val = d[i[1]]\n            ind = b.bisect(ans, val)\n            del ans[ind - 1]\n            ans.append(i[0])\n            d[i[1]] = i[0]\n        if len(ans) == m:\n            min1 = min(ans[-1] - ans[0], min1)\n    print(min(ans[-1] - ans[0], min1))", "t = int(input())\n\ndef sortSecond(val):\n    return val[1]\n\ndef minDiff(arr, N, K, w, chk, res):\n    wa = res\n    for i in range(N - K + 1):\n        curSeqDiff = arr[i + K - 1] - arr[i]\n        if curSeqDiff < res:\n            yes = set(chk).issubset(set(w[i:i + K]))\n        if curSeqDiff < res and yes:\n            res = curSeqDiff\n        elif curSeqDiff < res and ~yes:\n            wa = curSeqDiff\n    return (res, wa)\n\ndef sol(a, n, m, w, chk, ans):\n    (ca, wa) = minDiff(a, n, m, w, chk, ans)\n    while wa < ca:\n        (c1, wa) = minDiff(a, n, m + 1, w, chk, ca)\n        if c1 < ca:\n            ca = c1\n        if m >= n:\n            break\n        m += 1\n    print(ca)\n\ndef minDiff1(a, n, m, w):\n    co = [0] * m\n    done = [False] * m\n    doall = [True] * m\n    ca = a[n - 1] - a[0]\n    i = 0\n    j = 0\n    while i < n:\n        done[w[i]] = True\n        co[w[i]] += 1\n        if w[i] == w[j] and i != j:\n            co[w[j]] -= 1\n            j += 1\n        if done == doall:\n            while co[w[j]] > 1:\n                co[w[j]] -= 1\n                j += 1\n            ca = min(a[i] - a[j], ca)\n            co[w[j]] -= 1\n            if co[w[j]] == 0:\n                done[w[j]] = False\n            j += 1\n        i += 1\n    print(ca)\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = [int(i) for i in input().split()]\n    sin = [j[0] for j in sorted(enumerate(a), key=lambda x: x[1])]\n    w = [0] * n\n    for j in range(n):\n        w[j] = sin[j] % m\n    a.sort()\n    ans = 9147483647\n    chk = [int(i) for i in range(m)]\n    if m == n:\n        print(a[n - 1] - a[0])\n    minDiff1(a, n, m, w)", "t = int(input())\n\ndef sortSecond(val):\n    return val[1]\n\ndef minDiff(arr, N, K, w, chk, res):\n    wa = res\n    for i in range(N - K + 1):\n        curSeqDiff = arr[i + K - 1] - arr[i]\n        if curSeqDiff < res:\n            yes = set(chk).issubset(set(w[i:i + K]))\n        if curSeqDiff < res and yes:\n            res = curSeqDiff\n        elif curSeqDiff < res and ~yes:\n            wa = curSeqDiff\n    return (res, wa)\n\ndef sol(a, n, m, w, chk, ans):\n    (ca, wa) = minDiff(a, n, m, w, chk, ans)\n    while wa < ca:\n        (c1, wa) = minDiff(a, n, m + 1, w, chk, ca)\n        if c1 < ca:\n            ca = c1\n        if m >= n:\n            break\n        m += 1\n    print(ca)\n\ndef minDiff1(a, n, m, w):\n    co = [0] * m\n    done = [False] * m\n    doall = [True] * m\n    ca = a[n - 1] - a[0]\n    i = 0\n    j = 0\n    while i < n:\n        done[w[i]] = True\n        co[w[i]] += 1\n        if w[i] == w[j] and i != j:\n            co[w[j]] -= 1\n            j += 1\n        if done == doall:\n            while co[w[j]] > 1:\n                co[w[j]] -= 1\n                j += 1\n            ca = min(a[i] - a[j], ca)\n            co[w[j]] -= 1\n            if co[w[j]] == 0:\n                done[w[j]] = False\n            j += 1\n        i += 1\n    print(ca)\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = [int(i) for i in input().split()]\n    sin = [j[0] for j in sorted(enumerate(a), key=lambda x: x[1])]\n    w = [0] * n\n    for j in range(n):\n        w[j] = sin[j] % m\n    a.sort()\n    ans = 9147483647\n    chk = [int(i) for i in range(m)]\n    if m == n:\n        print(a[n - 1] - a[0])\n    elif n > 10 ** 3:\n        minDiff1(a, n, m, w)\n    else:\n        sol(a, n, m, w, chk, ans)", "for tc in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = []\n    temp = []\n    for i in range(m):\n        for j in range(i, n, m):\n            temp.append((a[j], i))\n    temp = sorted(temp, key=lambda x: x[0])\n    start = 0\n    finish = 1\n    res = 10 ** 10\n    dic = {}\n    for i in range(m):\n        dic[i] = 0\n    li = [temp[start][1]]\n    dic[temp[start][1]] = 1\n    flag = 0\n    for i in range(finish, n):\n        dic[temp[i][1]] += 1\n        if flag == 0 and li.count(temp[i][1]) == 0:\n            li.append(temp[i][1])\n            finish = i\n        if flag == 0 and len(li) == m:\n            flag = 1\n            x = abs(temp[start][0] - temp[finish][0])\n            if x < res:\n                res = x\n            start += 1\n            dic[temp[start - 1][1]] -= 1\n        if flag == 1:\n            finish = i\n            while 1:\n                if dic[temp[start - 1][1]] == 0:\n                    break\n                else:\n                    x = abs(temp[start][0] - temp[finish][0])\n                    if x < res:\n                        res = x\n                    start += 1\n                    dic[temp[start - 1][1]] -= 1\n    print(res)", "from bisect import insort\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    li = list(map(int, input().split()))\n    li2 = [[] for i in range(m)]\n    for x in range(n):\n        insort(li2[x % m], li[x])\n    val = [[li2[x][0], x] for x in range(m)]\n    val.sort()\n    pt = [0] * m\n    mx = val[-1][0]\n    mn = val[0][0]\n    result = mx - mn\n    while result:\n        result = min(mx - mn, result)\n        ind = val[0][1]\n        try:\n            pt[ind] += 1\n            del val[0]\n            insort(val, [li2[ind][pt[ind]], ind])\n            mx = max(mx, val[-1][0])\n        except:\n            break\n        mn = val[0][0]\n    print(result)", "t = int(input())\nfor q in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append((a[i], i % m))\n    l.sort()\n    visit = [0] * m\n    m_l = [0] * m\n    c = 0\n    for i in range(n):\n        max_ = l[i][0]\n        if visit[l[i][1]] == 0:\n            c += 1\n            visit[l[i][1]] = 1\n        m_l[l[i][1]] = l[i][0]\n        if c == m:\n            min_ = min(m_l)\n            res = max_ - min_\n            break\n    i += 1\n    while i < n:\n        y = m_l[l[i][1]]\n        max_ = l[i][0]\n        m_l[l[i][1]] = l[i][0]\n        if y == min_:\n            min_ = min(m_l)\n            res = min(res, max_ - min_)\n        i += 1\n    print(res)", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = [int(v) for v in input().split()]\n    s = [[0 for j in range(2)] for i in range(n)]\n    k = 0\n    for j in range(n):\n        s[j][0] = a[j]\n        s[j][1] = k\n        k = k + 1\n        if k == m:\n            k = 0\n    s.sort()\n    v = {}\n    start = 0\n    k = m\n    res = s[n - 1][0] - s[0][0]\n    for j in range(n):\n        if s[j][1] in v:\n            v[s[j][1]] = v[s[j][1]] + 1\n        else:\n            v[s[j][1]] = 1\n        while len(v) == k:\n            an = s[j][0] - s[start][0]\n            if an < res:\n                res = an\n            if s[start][1] in v:\n                if v[s[start][1]] == 1:\n                    del v[s[start][1]]\n                    start = start + 1\n                else:\n                    v[s[start][1]] = v[s[start][1]] - 1\n                    start = start + 1\n    print(res)", "def solve(l):\n    mi = [float('inf'), -1]\n    ma = 0\n    for i in range(len(l)):\n        if l[i] < mi[0]:\n            mi[0] = l[i]\n            mi[1] = i\n        if l[i] > ma:\n            ma = l[i]\n    return (ma - mi[0], mi[1])\nfor t in range(int(input())):\n    (n, m) = [int(i) for i in input().split()]\n    a = [(int(j), i % m) for (i, j) in enumerate(input().split())]\n    a.sort()\n    l = [None for i in range(m)]\n    last = 0\n    index = []\n    diff = float('inf')\n    sel = 0\n    all_sel = 2 ** m - 1\n    for i in range(n):\n        l[a[i][1]] = a[i][0]\n        last = a[i][0]\n        sel = sel | 1 << a[i][1]\n        index.append(a[i][1])\n        if sel == all_sel:\n            (d, val) = solve(l)\n            sel = sel & ~(1 << val)\n            diff = min(diff, d)\n    print(diff)", "t = int(input())\nwhile t > 0:\n    t -= 1\n    (n, m) = input().split()\n    (n, m) = (int(n), int(m))\n    k = list(map(int, input().split()))\n    s = [0] * n\n    j = 0\n    v = [0] * m\n    while j != n:\n        for i in range(m):\n            s[j] = i\n            j += 1\n            if j >= n:\n                break\n    z = [x for (_, x) in sorted(zip(k, s))]\n    h = sorted(k)\n    c = 0\n    a = 0\n    minn = 100000000000000\n    for i in range(n):\n        if v[z[i]] == 0:\n            c += 1\n        v[z[i]] += 1\n        if c == m:\n            while c >= m:\n                temp = abs(h[a] - h[i])\n                if minn > temp:\n                    minn = temp\n                v[z[a]] -= 1\n                if v[z[a]] != 0:\n                    a += 1\n                else:\n                    c -= 1\n                    a += 1\n    print(minn)", "def try3(n, m, pts_s):\n    i = 0\n    mi = 10 ** 10\n    res = [-1] * m\n    tmp = m\n    mi_i = -1\n    while i < n - m - 1:\n        if tmp == 0:\n            mi = min(mi, res[pts_s[i - 1][1]] - min(res))\n            if mi == 0:\n                break\n        if res[pts_s[i][1]] == -1:\n            tmp -= 1\n        res[pts_s[i][1]] = pts_s[i][0]\n        i += 1\n    print(mi)\n\ndef try2():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        k = 0\n        pts = []\n        for i in input().split():\n            pts.append([int(i), k % m])\n            k += 1\n        pts_s = sorted(pts)\n        if m == n:\n            print(pts_s[-1][0] - pts_s[0][0])\n            continue\n        if n > 1000:\n            try3(n, m, pts_s)\n            continue\n        i = 0\n        mi = 10 ** 10\n        while i < n - m:\n            ct = [0] * m\n            tmp = m\n            for j in range(i, n):\n                if ct[pts_s[j][1]] == 0:\n                    tmp -= 1\n                    ct[pts_s[j][1]] = 1\n                if tmp == 0:\n                    mi = min(mi, pts_s[j][0] - pts_s[i][0])\n                    break\n            i += 1\n            if tmp == 0:\n                mi = min(mi, pts_s[-1][0] - pts_s[i - 1][0])\n            if mi == 0:\n                break\n        print(mi)\n\ndef try1():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        a = [int(i) for i in input().split()]\n        ar1 = []\n        if m == n:\n            print(max(a) - min(a))\n            continue\n        mi_v = 10 ** 8\n        mi_i = 0\n        kk = 0\n        for i in range(0, n, m):\n            ar1.append(a[i:i + m])\n            tp = max(ar1[kk]) - min(ar1[kk])\n            if mi_v > tp and len(ar1[kk]) == m:\n                mi_v = tp\n                mi_i = kk\n            kk += 1\n        res = ar1[mi_i]\n        mi = min(res)\n        ma = max(res)\n        for i in range(len(ar1)):\n            if i == kk:\n                continue\n            for j in range(min(len(res), len(ar1[i]))):\n                if ar1[i][j] >= mi and ar1[i][j] <= ma:\n                    res[j] = ar1[i][j]\n                    mi = min(res)\n                    ma = max(res)\n        print(max(res) - min(res))\ntry2()", "t = int(input())\nfor itr in range(t):\n    nm = input().split(' ')\n    (n, m) = (int(nm[0]), int(nm[1]))\n    a = list(map(int, input().split(' ')))\n    collis = {}\n    aa = [[a[i], i % m] for i in range(n)]\n    aa.sort(reverse=True)\n    mini = 1000000000\n    i = 0\n    while len(collis.keys()) < m:\n        if collis.get(aa[i][1]) is None:\n            collis[aa[i][1]] = 1\n        else:\n            collis[aa[i][1]] += 1\n        i += 1\n    j = 0\n    i -= 1\n    while j < n:\n        if aa[j][0] - aa[i][0] < mini:\n            mini = aa[j][0] - aa[i][0]\n        fl = False\n        temp = aa[j][0]\n        while j < n and aa[j][0] == temp:\n            if collis.get(aa[j][1]) is not None:\n                collis[aa[j][1]] -= 1\n                if collis[aa[j][1]] == 0:\n                    del collis[aa[j][1]]\n            j += 1\n        if j >= n:\n            break\n        i = max(i + 1, j)\n        flag = False\n        while len(collis.keys()) < m:\n            if i == n:\n                flag = True\n                break\n            if collis.get(aa[i][1]) is None:\n                collis[aa[i][1]] = 1\n            else:\n                collis[aa[i][1]] += 1\n            i += 1\n        if flag:\n            break\n        i -= 1\n    print(mini)", "def main():\n    from heapq import _heapify_max, heapify, heappop, heappush, _heappop_max\n    t = int(input().strip())\n    for _ in range(t):\n        (n, m) = map(int, input().strip().split())\n        a = list(map(int, input().strip().split()))\n        mlst = []\n        mxhp = []\n        mnhp = []\n        cd = 0\n        for l in range(m):\n            i = l\n            ls = []\n            while i < n:\n                ls.append(a[i])\n                i += m\n            ls.sort(key=lambda x: -x)\n            mxhp.append((-1 * ls[-1], l))\n            mnhp.append((ls[-1], l))\n            mlst.append(ls)\n        heapify(mxhp)\n        heapify(mnhp)\n        (mn, x) = heappop(mnhp)\n        (mx, y) = mxhp[0]\n        cd = -1 * mx - mn\n        mxhp.pop()\n        while len(mlst[x]) > 0:\n            mlst[x].pop()\n            if len(mlst[x]) == 0:\n                break\n            nx = mlst[x][-1]\n            heappush(mxhp, (-1 * nx, x))\n            heappush(mnhp, (nx, x))\n            (mn, x) = heappop(mnhp)\n            (mx, y) = mxhp[0]\n            d = -1 * mx - mn\n            if d < cd:\n                cd = d\n            mxhp.pop()\n        print(cd)\nmain()", "from collections import defaultdict\nfrom heapq import *\nimport itertools, math, heapq\n\ndef parse_integer_list():\n    return [int(x) for x in input().split()]\n\ndef handle_input(M, N, A):\n    heap = []\n    N = len(A)\n    num_of_lists = M\n    lists = [list() for i in range(num_of_lists)]\n    for i in range(N):\n        lists[i % num_of_lists].append(A[i])\n    for l in lists:\n        l.sort()\n    curr_max = 0\n    for i in range(num_of_lists):\n        item = lists[i][0]\n        heapq.heappush(heap, (item, i))\n        if item > curr_max:\n            curr_max = item\n    min_diff = float('inf')\n    indexes = [0 for i in range(num_of_lists)]\n    min_item = float('inf')\n    while True:\n        (min_item, i) = heapq.heappop(heap)\n        diff = curr_max - min_item\n        if diff < min_diff:\n            min_diff = diff\n        indexes[i] += 1\n        try:\n            item = lists[i][indexes[i]]\n        except:\n            break\n        if item > curr_max:\n            curr_max = item\n        heapq.heappush(heap, (item, i))\n    print(min_diff)\nT = int(input())\nfor i in range(T):\n    (N, M) = parse_integer_list()\n    A = parse_integer_list()\n    handle_input(M, N, A)", "import sys\nimport heapq\nt = int(input())\nfor q in range(t):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    color_sets = []\n    for i in range(k):\n        color_set = []\n        j = i\n        while j < n:\n            color_set.append(arr[j])\n            j += k\n        color_set.sort()\n        color_sets.append(color_set)\n    min_diff = sys.maxsize\n    min_heap = []\n    max_value = 0\n    for i in range(k):\n        max_value = max(max_value, color_sets[i][0])\n        heapq.heappush(min_heap, (color_sets[i][0], i))\n        del color_sets[i][0]\n    i = 0\n    while i < 5:\n        (min_value, index) = heapq.heappop(min_heap)\n        min_diff = min(min_diff, max_value - min_value)\n        if len(color_sets[index]) == 0:\n            break\n        heapq.heappush(min_heap, (color_sets[index][0], index))\n        if color_sets[index][0] > max_value:\n            max_value = color_sets[index][0]\n        del color_sets[index][0]\n    print(min_diff)", "import heapq\ntestCase = int(input())\nfor t in range(testCase):\n    (n, m) = [int(x) for x in input().split()]\n    arrayBalls = [int(x) for x in input().split()]\n    listMBalls = []\n    for (index, x) in enumerate(arrayBalls):\n        if len(listMBalls) > index % m:\n            listMBalls[index % m].append(x)\n        else:\n            arr = []\n            arr.append(x)\n            listMBalls.append(arr)\n    heap = []\n    for x in listMBalls:\n        x.sort()\n    maxVal = (0, 0, 0)\n    for (index, x) in enumerate(listMBalls):\n        heap.append((x[0], index, 0))\n        if x[0] > maxVal[0]:\n            maxVal = (x[0], index, 0)\n    heapq.heapify(heap)\n    diff = maxVal[0]\n    while len(heap) > 0:\n        x = heapq.heappop(heap)\n        if maxVal[0] - x[0] < diff:\n            diff = maxVal[0] - x[0]\n        tup = ()\n        if len(listMBalls[x[1]]) > x[2] + 1:\n            tup = (listMBalls[x[1]][x[2] + 1], x[1], x[2] + 1)\n        else:\n            break\n        heapq.heappush(heap, tup)\n        if tup[0] > maxVal[0]:\n            maxVal = tup\n    print(diff)", "from itertools import combinations\nimport sys\n\ndef a_le():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef int_le():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef input():\n    return sys.stdin.readline().strip()\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    A = a_le()\n    B = []\n    if N == M:\n        print(max(A) - min(A))\n    else:\n        for i in range(len(A)):\n            j = i % M + 1\n            B.append([A[i], j])\n        B.sort()\n        C = [0] * M\n        count = 0\n        Res = []\n        for (i, j) in B:\n            if count < M:\n                if C[j - 1] == 0:\n                    count += 1\n                C[j - 1] = i\n                if 0 not in C:\n                    count -= 1\n                    Res.append(max(C) - min(C))\n                    C[C.index(min(C))] = 0\n        print(min(Res))", "from itertools import combinations\nimport sys\n\ndef a_le():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef int_le():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef input():\n    return sys.stdin.readline().strip()\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    A = a_le()\n    B = []\n    if N == M:\n        print(max(A) - min(A))\n    else:\n        for i in range(len(A)):\n            j = i % M + 1\n            B.append([A[i], j])\n        B.sort()\n        C = [0] * M\n        count = 0\n        Res = []\n        for (i, j) in B:\n            if count < M:\n                if C[j - 1] == 0:\n                    count += 1\n                C[j - 1] = i\n                if 0 not in C:\n                    count -= 1\n                    Res.append(max(C) - min(C))\n                    C[C.index(min(C))] = 0\n        print(min(Res))", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    my_list = list(map(int, input().split()))\n    my_list_2 = list(set(my_list))\n    my_dict = {}\n    for i in my_list_2:\n        my_dict[i] = []\n    for i in range(n):\n        jk = i % m\n        my_dict[my_list[i]].append(jk)\n    s = 99 ** 99\n    s1 = 99 ** 99\n    my_list_2 = list(my_dict.keys())\n    my_list_2.sort(reverse=True)\n    j = -1\n    n = []\n    c = [0] * m\n    my_dif_c = 0\n    for i in range(len(my_list_2)):\n        while j + 1 < len(my_list_2) and my_dif_c != m:\n            j = j + 1\n            for k in my_dict[my_list_2[j]]:\n                if c[k] == 0:\n                    my_dif_c += 1\n                c[k] += 1\n            if my_dif_c == m:\n                f = 1\n                break\n        if my_dif_c == m:\n            s1 = abs(my_list_2[i] - my_list_2[j])\n            s = min(s, s1)\n        for k in my_dict[my_list_2[i]]:\n            c[k] -= 1\n            if c[k] == 0:\n                my_dif_c -= 1\n    print(s)", "import sys\nimport heapq\n\ndef getInput(num):\n    if num:\n        inputArr = input().split()\n        if len(inputArr) != num:\n            print(f'The length is {len(inputArr)} not same as asked for {num}')\n            sys.exit(0)\n        for i in range(0, len(inputArr)):\n            inputArr[i] = int(inputArr[i])\n        return inputArr\n    elif num == 0:\n        return int(input())\n    elif num == None:\n        inputArr = input().split()\n        for i in range(0, len(inputArr)):\n            inputArr[i] = int(inputArr[i])\n        return inputArr\nfor test in range(0, getInput(0)):\n    (N, M) = getInput(2)\n    numList = getInput(N)\n    myArr = []\n    for i in range(0, M):\n        myArr.append([])\n    for i in range(0, N):\n        myArr[i % M].append(numList[i])\n    for i in range(0, M):\n        myArr[i].sort()\n    heap = []\n    myMax = 0\n    myDiff = 4294967295\n    for i in range(0, M):\n        myTempVal0 = (myArr[i].pop(0) << 32) + i\n        if myMax < myTempVal0:\n            myMax = myTempVal0\n        heapq.heappush(heap, myTempVal0)\n    while True:\n        myVal0 = heap[0]\n        index = myVal0 & 4294967295\n        currDiff = (myMax >> 32) - (myVal0 >> 32)\n        if currDiff < myDiff:\n            myDiff = currDiff\n        if len(myArr[index]) == 0:\n            break\n        else:\n            val0 = (myArr[index].pop(0) << 32) + index\n            if val0 > myMax:\n                myMax = val0\n            heapq.heapreplace(heap, val0)\n    print(myDiff)", "import heapq\nimport math\n\nclass min_heap_obj:\n\n    def __init__(self, value, index_of_b, index_in_b, len_b, connection):\n        self.value = value\n        self.index_of_b = index_of_b\n        self.index_in_b = index_in_b\n        self.len_b = len_b\n        self.connection = connection\n\n    def __lt__(self, other):\n        return self.value < other.value\n\nclass max_heap_obj:\n\n    def __init__(self, value, index_in_heap):\n        self.value = value\n        self.index_in_heap = index_in_heap\n\n    def __lt__(self, other):\n        return self.value < other.value\n\ndef update_min_heap(min_heap, len_heap):\n    m = len_heap\n    index = 0\n    while True:\n        child_present = False\n        c1 = False\n        if index * 2 + 1 < m:\n            child = min_heap[index * 2 + 1]\n            child_index = index * 2 + 1\n            child_present = True\n        if index * 2 + 2 < m:\n            if min_heap[index * 2 + 2] < child:\n                child = min_heap[index * 2 + 2]\n                child_index = index * 2 + 2\n        if child_present:\n            if min_heap[index] > child:\n                (min_heap[index], min_heap[child_index]) = (child, min_heap[index])\n                index = child_index\n                c1 = True\n        if not child_present:\n            break\n        elif not c1:\n            break\n\ndef update_max_heap(max_heap, target, len_heap):\n    m = len_heap\n    index = target\n    while True:\n        child_present = False\n        c1 = False\n        if index * 2 + 1 < m:\n            child = max_heap[index * 2 + 1]\n            child_index = index * 2 + 1\n            child_present = True\n        if index * 2 + 2 < m:\n            if max_heap[index * 2 + 2] > child:\n                child = max_heap[index * 2 + 2]\n                child_index = index * 2 + 2\n        if child_present:\n            if max_heap[index] < child:\n                (max_heap[index], max_heap[child_index]) = (child, max_heap[index])\n                max_heap[index].index_in_heap = index\n                max_heap[child_index].index_in_heap = child_index\n                index = child_index\n                c1 = True\n        if not child_present:\n            break\n        elif not c1:\n            break\n    while True:\n        c1 = False\n        if index == 0:\n            break\n        if max_heap[index] > max_heap[(index - 1) // 2]:\n            (max_heap[index], max_heap[(index - 1) // 2]) = (max_heap[(index - 1) // 2], max_heap[index])\n            max_heap[index].index_in_heap = index\n            max_heap[(index - 1) // 2].index_in_heap = (index - 1) // 2\n            index = (index - 1) // 2\n            c1 = True\n        if not c1:\n            break\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = []\n    for i in range(m):\n        temp = []\n        for j in range(i, n, m):\n            temp.append(a[j])\n        b.append(sorted(temp))\n    temp = []\n    temp2 = []\n    for i in range(m):\n        temp2.append(max_heap_obj(b[i][0], 'ok'))\n    for i in range(m):\n        temp.append(min_heap_obj(b[i][0], i, 0, len(b[i]), 'temp_obj_max'))\n    for i in range(m):\n        temp[i].connection = temp2[i]\n    heapq.heapify(temp)\n    heapq._heapify_max(temp2)\n    for i in range(m):\n        temp2[i].index_in_heap = i\n    ans = temp2[0].value - temp[0].value\n    while True:\n        temp[0].index_in_b += 1\n        if temp[0].index_in_b == temp[0].len_b:\n            break\n        temp[0].value = b[temp[0].index_of_b][temp[0].index_in_b]\n        temp[0].connection.value = temp[0].value\n        target = temp[0].connection.index_in_heap\n        update_min_heap(temp, m)\n        update_max_heap(temp2, target, m)\n        if temp2[0].value - temp[0].value < ans:\n            ans = temp2[0].value - temp[0].value\n    print(ans)", "def findsub(string, pat):\n    len1 = len(string)\n    len2 = len(pat)\n    hash_pat = [0] * (10 ** 5 + 1)\n    hash_str = [0] * (10 ** 5 + 1)\n    for i in range(0, len2):\n        hash_pat[pat[i]] += 1\n    mindif = 10 ** 10\n    (start, start_index, min_len) = (0, -1, float('inf'))\n    count = 0\n    for j in range(0, len1):\n        hash_str[string[j][1]] += 1\n        if hash_pat[string[j][1]] != 0 and hash_str[string[j][1]] <= hash_pat[string[j][1]]:\n            count += 1\n        if count == len2:\n            while hash_str[string[start][1]] > hash_pat[string[start][1]] or hash_pat[string[start][1]] == 0:\n                if hash_str[string[start][1]] > hash_pat[string[start][1]]:\n                    hash_str[string[start][1]] -= 1\n                start += 1\n            len_window = j - start + 1\n            tmp = string[j][0] - string[start][0]\n            mindif = min(mindif, tmp)\n    return mindif\nfor ii in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    k = [i for i in range(0, m)]\n    cnt = 1\n    s = []\n    for i in p:\n        s.append([i, cnt])\n        cnt = (cnt + 1) % m\n    s.sort()\n    a = findsub(s, k)\n    print(a)", "def findsub(string, pat):\n    len1 = len(string)\n    len2 = len(pat)\n    hash_pat = [0] * (10 ** 5 + 1)\n    hash_str = [0] * (10 ** 5 + 1)\n    for i in range(0, len2):\n        hash_pat[pat[i]] += 1\n    mindif = 10 ** 10\n    (start, start_index, min_len) = (0, -1, float('inf'))\n    count = 0\n    for j in range(0, len1):\n        hash_str[string[j][1]] += 1\n        if hash_pat[string[j][1]] != 0 and hash_str[string[j][1]] <= hash_pat[string[j][1]]:\n            count += 1\n        if count == len2:\n            while hash_str[string[start][1]] > hash_pat[string[start][1]] or hash_pat[string[start][1]] == 0:\n                if hash_str[string[start][1]] > hash_pat[string[start][1]]:\n                    hash_str[string[start][1]] -= 1\n                start += 1\n            len_window = j - start + 1\n            tmp = string[j][0] - string[start][0]\n            mindif = min(mindif, tmp)\n    return mindif\nfor ii in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    k = [i for i in range(0, m)]\n    cnt = 1\n    s = []\n    for i in p:\n        s.append([i, cnt])\n        cnt = (cnt + 1) % m\n    s.sort()\n    a = findsub(s, k)\n    print(a)", "def sortSecond(val):\n    return val[0]\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    temp = []\n    for i in range(n):\n        temp.append([l[i], i % m])\n    temp.sort(key=sortSecond)\n    temp1 = [0] * m\n    st = 0\n    for i in range(n):\n        temp1[temp[i][1]] += 1\n        if not 0 in temp1:\n            end = i\n            break\n    dif = temp[end][0] - temp[st][0]\n    while end < n:\n        if not 0 in temp1:\n            if temp[end][0] - temp[st][0] < dif:\n                dif = temp[end][0] - temp[st][0]\n            temp1[temp[st][1]] -= 1\n            st += 1\n        else:\n            end += 1\n            if end == n:\n                break\n            temp1[temp[end][1]] += 1\n    print(dif)", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    l = list(input().split())\n    a = []\n    for i in range(n):\n        a.append(int(l[i]))\n    ans = []\n    for i in range(m):\n        x = []\n        ans.append(x)\n    for i in range(n):\n        ans[i % m].append(a[i])\n    ptr = []\n    for i in range(m):\n        ans[i].sort()\n        ptr.append(0)\n    min_range = 10000000000\n    minind = 0\n    curr = []\n    maxi = 0\n    for i in range(m):\n        temp = []\n        temp.append(ans[i][0])\n        temp.append(0)\n        temp.append(i)\n        curr.append(temp)\n        if ans[i][0] > maxi:\n            maxi = ans[i][0]\n    heapq.heapify(curr)\n    while 1:\n        mini = heapq.heappop(curr)\n        if maxi - mini[0] < min_range:\n            min_range = maxi - mini[0]\n        if mini[1] + 1 == len(ans[mini[2]]):\n            break\n        temp = []\n        temp.append(ans[mini[2]][mini[1] + 1])\n        temp.append(mini[1] + 1)\n        temp.append(mini[2])\n        heapq.heappush(curr, temp)\n        if ans[mini[2]][mini[1] + 1] > maxi:\n            maxi = ans[mini[2]][mini[1] + 1]\n    print(min_range)", "t = int(input())\nfor _ in range(t):\n    (length, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = [0] * m\n    answer = 10000000000\n    res = [[0, 0] for i in range(length)]\n    lookup = [0] * m\n    for i in range(length):\n        res[i][0] = a[i]\n        res[i][1] = i % m\n    res = sorted(res)\n    for i in range(length):\n        maxi = res[i][0]\n        index = res[i][1]\n        removed = ans[index]\n        ans[index] = res[i][0]\n        lookup.remove(removed)\n        lookup.append(res[i][0])\n        mini = lookup[0]\n        if mini != 0:\n            answer = min(answer, maxi - mini)\n    print(answer)", "import math\nimport time\ntestcases = int(input())\nfor testcase in range(testcases):\n    (n, m) = map(int, input().split())\n    b = list(map(int, input().split()))\n    boxes_dict = {}\n    class_val = 0\n    for box in b:\n        if boxes_dict.get(box):\n            boxes_dict[box].append(class_val)\n        else:\n            boxes_dict[box] = [class_val]\n        class_val = (class_val + 1) % m\n    boxes = []\n    vals = sorted(boxes_dict.keys())\n    for val in vals:\n        boxes.append((val, boxes_dict[val]))\n    counts = [0] * m\n    alive = 0\n    (l, r) = (0, 0)\n    result = math.inf\n    k = len(boxes)\n    while l <= r and r < k:\n        while l <= r and r < k and (alive != m):\n            classes = boxes[r][1]\n            for c in classes:\n                counts[c] += 1\n                if counts[c] == 1:\n                    alive += 1\n            if alive == m:\n                dist = boxes[r][0] - boxes[l][0]\n                result = min(result, dist)\n                break\n            r += 1\n        while l <= r and alive == m:\n            if alive == m:\n                dist = boxes[r][0] - boxes[l][0]\n                result = min(result, dist)\n            classes = boxes[l][1]\n            for c in classes:\n                counts[c] -= 1\n                if counts[c] == 0:\n                    alive -= 1\n            l += 1\n        r += 1\n    print(result)", "for _ in range(int(input().strip())):\n    (n, m) = [int(i) for i in input().strip().split()]\n    old_boxes = [(int(inp), i % m) for (i, inp) in enumerate(input().strip().split())]\n    old_boxes.sort()\n    old_boxes.append((0, m))\n    first = 0\n    boxes = []\n    for i in range(1, n + 1):\n        if old_boxes[first][1] != old_boxes[i][1]:\n            boxes.append((old_boxes[first][0], old_boxes[i - 1][0], old_boxes[first][1]))\n            first = i\n    cnt_colors = [0 for _ in range(m)]\n    unselected_colors = {i for i in range(m)}\n    first = 0\n    mini = 10 ** 10\n    cnt_colors[boxes[first][2]] += 1\n    unselected_colors -= {boxes[first][2]}\n    for i in range(1, len(boxes)):\n        cnt_colors[boxes[i][2]] += 1\n        unselected_colors -= {boxes[i][2]}\n        while not unselected_colors:\n            ball_cnt = boxes[i][0] - boxes[first][1]\n            if ball_cnt < mini:\n                mini = ball_cnt\n            cnt_colors[boxes[first][2]] -= 1\n            if not cnt_colors[boxes[first][2]]:\n                unselected_colors.add(boxes[first][2])\n            first += 1\n    print(mini)", "import heapq\n\nclass ball:\n\n    def __init__(self, value, index, index2):\n        self.value = value\n        self.index = index\n        self.index2 = index2\n\n    def __lt__(self, other):\n        return self.value < other.value\n\ndef update_min(arr, a, mini, maxi, mini_index):\n    i = arr[0].index2\n    if i != len(a[mini_index]) - 1:\n        i += 1\n        if a[mini_index][i] > maxi[0]:\n            maxi[0] = a[mini_index][i]\n        while i < len(a[mini_index]) - 1 and a[mini_index][i + 1] < maxi[0]:\n            i += 1\n        heapq.heapreplace(arr, ball(a[mini_index][i], mini_index, i))\n        return True\n    return False\nfor t in range(int(input())):\n    (n, m) = [int(i) for i in input().split()]\n    x = [int(i) for i in input().split()]\n    a = [[] for i in range(m)]\n    i = 0\n    while i < n:\n        a[i % m].append(x[i])\n        i += 1\n    for i in a:\n        i.sort()\n    arr = [ball(a[i][0], i, 0) for i in range(len(a))]\n    heapq.heapify(arr)\n    mini = arr[0].value\n    maxi = [max(arr).value]\n    result = maxi[0] - mini\n    no_update_min = True\n    while no_update_min:\n        mini = arr[0].value\n        mini_index = arr[0].index\n        if maxi[0] - mini < result:\n            result = maxi[0] - mini\n        no_update_min = update_min(arr, a, mini, maxi, mini_index)\n    print(result)", "def next(mapping, bucket_count, bucket_count_set, colors, start):\n    end = start\n    while end < len(mapping):\n        (ball, bucket) = mapping[end]\n        bucket_count_set.add(bucket)\n        bucket_count[bucket] += 1\n        if len(bucket_count_set) == colors:\n            return (end, bucket_count, bucket_count_set)\n        end += 1\n\ndef next_2(mapping, bucket_count, bucket_count_set, colors, end):\n    if len(bucket_count_set) == colors:\n        return (end, bucket_count, bucket_count_set)\n    end += 1\n    while end < len(mapping):\n        (_, bucket) = mapping[end]\n        bucket_count_set.add(bucket)\n        bucket_count[bucket] += 1\n        if len(bucket_count_set) == colors:\n            return (end, bucket_count, bucket_count_set)\n        end += 1\n\ndef ans(mapping, colors):\n    bucket_count = [0] * colors\n    bucket_count_set = set()\n    start = 0\n    (end, bucket_count, bucket_count_set) = next(mapping, bucket_count, bucket_count_set, colors, start)\n    (start_ball, start_bucket) = mapping[start]\n    (end_ball, end_bucket) = mapping[end]\n    minimax = end_ball - start_ball\n    bucket_count[start_bucket] -= 1\n    start += 1\n    if bucket_count[start_bucket] == 0:\n        bucket_count_set.remove(start_bucket)\n    while start < len(mapping):\n        ne = next_2(mapping, bucket_count, bucket_count_set, colors, end)\n        if ne:\n            (end, bucket_count, bucket_count_set) = ne\n            (start_ball, start_bucket) = mapping[start]\n            (end_ball, _) = mapping[end]\n            minimax = min(minimax, end_ball - start_ball)\n            bucket_count[start_bucket] -= 1\n            start += 1\n            if bucket_count[start_bucket] == 0:\n                bucket_count_set.remove(start_bucket)\n        else:\n            return minimax\ntest = int(input())\nwhile test > 0:\n    test -= 1\n    (buckets, colors) = map(int, input().split())\n    balls = list(map(int, input().split()))\n    mapping = []\n    for i in range(len(balls)):\n        ball = balls[i]\n        bucket = i % colors\n        mapping.append((ball, bucket))\n    mapping.sort()\n    print(ans(mapping, colors))", "try:\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        vis = [0] * m\n        l = list(map(int, input().split()))\n        l = list(([l[i], i % m] for i in range(n)))\n        l.sort()\n        res = l[n - 1][0] - l[0][0]\n        s = 0\n        for i in l:\n            vis[i[1]] += 1\n            if vis.count(0) < 1:\n                while vis[l[s][1]] > 1:\n                    vis[l[s][1]] -= 1\n                    s += 1\n                if res > i[0] - l[s][0]:\n                    res = i[0] - l[s][0]\n        print(res)\nexcept EOFError:\n    print('0')", "INF = 10 ** 9 + 5\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    pl = {}\n    for i in range(N):\n        act = arr[i]\n        if act not in pl:\n            pl[act] = set([i % M])\n        else:\n            pl[act].add(i % M)\n    arr2 = list(pl.keys())\n    arr2.sort()\n    (i1, i2) = (0, 0)\n    acts = [0] * M\n    miss = M\n    bst = INF\n    len2 = len(arr2)\n    while i2 < len2:\n        while i2 < len2 and miss > 0:\n            for idx in pl[arr2[i2]]:\n                if acts[idx] == 0:\n                    miss -= 1\n                acts[idx] += 1\n            if miss > 0:\n                i2 += 1\n        if i2 < len2:\n            while miss == 0:\n                bst = min(bst, arr2[i2] - arr2[i1])\n                for idx in pl[arr2[i1]]:\n                    acts[idx] -= 1\n                    if acts[idx] == 0:\n                        miss += 1\n                i1 += 1\n            i2 += 1\n    print(bst)", "def find(N, M, arr):\n    pos = []\n    for i in range(len(arr)):\n        pos.append([i % M, i])\n    pos.sort(key=lambda x: arr[x[1]])\n    arr.sort()\n    cnt = [0] * M\n    mask = 2 ** M - 1\n    i = 0\n    j = 0\n    while pos[i][0] == pos[j][0]:\n        cnt[pos[j][0]] += 1\n        j += 1\n    cnt[pos[j][0]] += 1\n    chk = 1 << pos[i][0]\n    chk = chk | 1 << pos[j][0]\n    res = float('inf')\n    while j < N:\n        while chk != mask:\n            j += 1\n            if j == N:\n                break\n            chk = chk | 1 << pos[j][0]\n            cnt[pos[j][0]] += 1\n        if j == N:\n            continue\n        flag = False\n        while True:\n            if cnt[pos[i][0]] == 1 and flag:\n                break\n            if cnt[pos[i][0]] == 1:\n                res = min(res, arr[j] - arr[i])\n            cnt[pos[i][0]] -= 1\n            if cnt[pos[i][0]] < 1:\n                chk = chk ^ 1 << pos[i][0]\n                flag = True\n            i += 1\n    return res\n\ndef main():\n    for i in range(int(input())):\n        (N, M) = list(map(int, input().split()))\n        arr = list(map(int, input().split()))\n        print(find(N, M, arr))\nmain()", "import math\nimport bisect\nt = int(input().strip())\nfor _ in range(t):\n    (n, m) = list(map(int, input().strip().split()))\n    a = list(map(int, input().strip().split()))\n    if m == n:\n        print(max(a) - min(a))\n    elif n - m == 1:\n        print(min(max(a[:-1]) - min(a[:-1]), max(a[1:]) - min(a[1:])))\n    else:\n        split = sorted([sorted(a[i::m]) for i in range(m)], key=lambda x: x[-1] - x[0])\n        minimum = math.inf\n        for num in split[0]:\n            val = [num]\n            skipped = []\n            index = bisect.bisect_left(split[1], val[0])\n            if index == 0:\n                bisect.insort(val, split[1][0])\n            elif index == len(split[1]):\n                bisect.insort(val, split[1][-1])\n            elif val[0] - split[1][index - 1] < split[1][index] - val[0]:\n                bisect.insort(val, split[1][index - 1])\n            else:\n                bisect.insort(val, split[1][index])\n            for i in range(2, len(split)):\n                index_1 = bisect.bisect_left(split[i], val[0])\n                if index_1 == len(split[i]):\n                    if split[i][-1] < val[0]:\n                        bisect.insort(val, split[i][-1])\n                elif index_1 == 0:\n                    if split[i][0] > val[-1]:\n                        bisect.insort(val, split[i][0])\n                elif split[i][index_1] > val[-1]:\n                    if val[0] - split[i][index_1 - 1] < split[i][index_1] - val[-1]:\n                        bisect.insort(val, split[i][index_1 - 1])\n                    else:\n                        skipped.append(split[i])\n            for item in skipped:\n                index_1 = bisect.bisect_left(item, val[0])\n                if index_1 == 0:\n                    if item[index_1] > val[-1]:\n                        bisect.insort(val, item[0])\n                elif index_1 == len(item):\n                    if item[-1] < val[0]:\n                        bisect.insort(val, item[-1])\n                elif item[index_1] > val[-1]:\n                    if val[0] - item[index_1 - 1] < item[index_1] - val[-1]:\n                        bisect.insort(val, item[index_1 - 1])\n                    else:\n                        bisect.insort(val, item[index_1])\n            if minimum > val[-1] - val[0]:\n                minimum = val[-1] - val[0]\n            if minimum == 0:\n                break\n        print(minimum)", "import math\nimport bisect\nt = int(input().strip())\nfor _ in range(t):\n    (n, m) = list(map(int, input().strip().split()))\n    a = list(map(int, input().strip().split()))\n    if m == n:\n        print(max(a) - min(a))\n    elif n - m == 1:\n        print(min(max(a[:-1]) - min(a[:-1]), max(a[1:]) - min(a[1:])))\n    else:\n        split = sorted([sorted(a[i::m]) for i in range(m)], key=lambda x: x[-1] - x[0])\n        minimum = math.inf\n        for num in split[0]:\n            val = [num]\n            skipped = []\n            index = bisect.bisect_left(split[1], val[0])\n            if index == 0:\n                bisect.insort(val, split[1][0])\n            elif index == len(split[1]):\n                bisect.insort(val, split[1][-1])\n            elif val[0] - split[1][index - 1] < split[1][index] - val[0]:\n                bisect.insort(val, split[1][index - 1])\n            else:\n                bisect.insort(val, split[1][index])\n            for i in range(2, len(split)):\n                index_1 = bisect.bisect_left(split[i], val[0])\n                if index_1 == len(split[i]):\n                    if split[i][-1] < val[0]:\n                        bisect.insort(val, split[i][-1])\n                elif index_1 == 0:\n                    if split[i][0] > val[-1]:\n                        bisect.insort(val, split[i][0])\n                elif split[i][index_1] > val[-1]:\n                    if val[0] - split[i][index_1 - 1] < split[i][index_1] - val[-1]:\n                        bisect.insort(val, split[i][index_1 - 1])\n                    elif val[0] - split[i][index_1 - 1] < split[i][index_1] - val[-1]:\n                        bisect.insort(val, split[i][index_1])\n                    else:\n                        skipped.append(split[i])\n            for item in skipped:\n                index_1 = bisect.bisect_left(item, val[0])\n                if index_1 == 0:\n                    if item[index_1] > val[-1]:\n                        bisect.insort(val, item[0])\n                elif index_1 == len(item):\n                    if item[-1] < val[0]:\n                        bisect.insort(val, item[-1])\n                elif item[index_1] > val[-1]:\n                    if val[0] - item[index_1 - 1] < item[index_1] - val[-1]:\n                        bisect.insort(val, item[index_1 - 1])\n                    elif val[0] - item[index_1 - 1] < item[index_1] - val[-1]:\n                        bisect.insort(val, item[index_1])\n                    else:\n                        bisect.insort(val, item[index_1])\n            if minimum > val[-1] - val[0]:\n                minimum = val[-1] - val[0]\n            if minimum == 0:\n                break\n        print(minimum)", "from collections import OrderedDict\nt = int(input())\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    n1 = n\n    a = {}\n    b = OrderedDict()\n    m1 = 1\n    ta = map(int, input().split())\n    for ii in ta:\n        try:\n            a[ii].append(m1)\n        except:\n            a[ii] = []\n            a[ii].append(m1)\n        m1 += 1\n        if m1 > m:\n            m1 = 1\n    sor = list(a.keys())\n    sor.sort()\n    mi = sor[-1]\n    inc = 0\n    for i in sor:\n        for j in a[i]:\n            try:\n                del b[j]\n                b[j] = i\n            except:\n                b[j] = i\n                inc += 1\n            if inc >= m:\n                for value in b:\n                    break\n                mi = min(mi, b[j] - b[value])\n    print(mi)\n    t -= 1", "import heapq\nt = int(input())\nfor o in range(t):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    ar = []\n    flags = []\n    for i in range(m):\n        flags.append([])\n    for i in range(m):\n        ar.append([])\n    for i in range(n):\n        ar[i % m].append(a[i])\n        flags[i % m].append(False)\n    for i in range(m):\n        ar[i].sort(reverse=True)\n    minheap = []\n    for i in range(m):\n        minheap.append([ar[i][0], [i, 0]])\n    maxheap = []\n    for i in range(m):\n        maxheap.append([-ar[i][0], [i, 0]])\n    heapq.heapify(minheap)\n    heapq.heapify(maxheap)\n    ans = 1000000000001\n    try:\n        while True:\n            maax = heapq.heappop(maxheap)\n            miin = heapq.heappop(minheap)\n            while flags[miin[1][0]][miin[1][1]] == True:\n                miin = heapq.heappop(minheap)\n            if -maax[0] - miin[0] < ans:\n                ans = -maax[0] - miin[0]\n            heapq.heappush(minheap, miin)\n            heapq.heappush(maxheap, [-ar[maax[1][0]][maax[1][1] + 1], [maax[1][0], maax[1][1] + 1]])\n            heapq.heappush(minheap, [ar[maax[1][0]][maax[1][1] + 1], [maax[1][0], maax[1][1] + 1]])\n            flags[maax[1][0]][maax[1][1]] = True\n    except Exception as e:\n        pass\n    print(ans)", "import heapq\nimport sys\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    minimum = sys.maxsize\n    j = 0\n    temp = [[] for x in range(m)]\n    while j < m:\n        i = j\n        while i < n:\n            temp[j].append(l[i])\n            i += m\n        j += 1\n    for i in temp:\n        i.sort()\n    heap = []\n    mini = [sys.maxsize, -1]\n    maxi = [-sys.maxsize - 1, -1]\n    for i in range(m):\n        temp1 = []\n        temp1.append(temp[i][0])\n        temp1.append(i)\n        if temp[i][0] > maxi[0]:\n            maxi[0] = temp[i][0]\n            maxi[1] = i\n        if temp[i][0] < mini[0]:\n            mini[0] = temp[i][0]\n            mini[1] = i\n        heap.append(temp1)\n    l = [1] * m\n    heapq.heapify(heap)\n    rangeRes = sys.maxsize\n    while True:\n        smallest = heapq.heappop(heap)\n        mini[0] = smallest[0]\n        if maxi[0] - mini[0] < rangeRes:\n            rangeRes = maxi[0] - mini[0]\n        if l[smallest[1]] >= len(temp[smallest[1]]):\n            break\n        temp1 = []\n        temp1.append(temp[smallest[1]][l[smallest[1]]])\n        temp1.append(smallest[1])\n        heapq.heappush(heap, temp1)\n        l[smallest[1]] += 1\n        if temp1[0] > maxi[0]:\n            maxi[0] = temp1[0]\n            maxi[1] = smallest[1]\n    print(rangeRes)", "class Sequence:\n\n    def __init__(self, m):\n        self.m = m\n        self.stack = []\n        self.indexes = []\n        self.present = {}\n        for i in range(self.m):\n            self.present[i] = False\n\n    def isComplete(self):\n        if len(self.stack) == self.m:\n            return True\n        return False\n\n    def isEmpty(self):\n        if len(self.stack) == 0:\n            return True\n        return False\n\n    def push(self, obj):\n        self.stack.append(obj)\n        self.indexes.append(obj.color)\n\n    def pop(self, index):\n        self.stack.pop(index)\n        self.indexes.pop(index)\n\nclass Box:\n\n    def __init__(self, value, color):\n        self.value = value\n        self.color = color\ntests = int(input())\nwhile tests:\n    tests -= 1\n    (n, m) = map(int, input().split())\n    if m > n:\n        m = n\n    l = list(map(int, input().split()))\n    Boxes = []\n    color = 0\n    for i in range(n):\n        if color == m:\n            color = 0\n        Boxes.append(Box(l[i], color))\n        color += 1\n    Boxes.sort(key=lambda x: x.value)\n    prev = Boxes[0]\n    _min = 10 ** 10\n    sequence = Sequence(m)\n    for i in range(n):\n        if sequence.isEmpty():\n            sequence.push(Boxes[i])\n            sequence.present[Boxes[i].color] = True\n            continue\n        if sequence.present[Boxes[i].color]:\n            if not sequence.isComplete():\n                index = sequence.indexes.index(Boxes[i].color)\n                sequence.pop(index)\n                sequence.push(Boxes[i])\n        else:\n            sequence.push(Boxes[i])\n            sequence.present[Boxes[i].color] = True\n        if sequence.isComplete():\n            minBox = sequence.stack[0]\n            maxBox = sequence.stack[m - 1]\n            sequence.pop(0)\n            sequence.present[minBox.color] = False\n            _diff = maxBox.value - minBox.value\n            if _min > _diff:\n                _min = _diff\n    print(_min)", "class Sequence:\n\n    def __init__(self, m):\n        self.m = m\n        self.stack = []\n        self.indexes = []\n        self.present = {}\n        for i in range(self.m):\n            self.present[i] = False\n\n    def isComplete(self):\n        if len(self.stack) == self.m:\n            return True\n        return False\n\n    def isEmpty(self):\n        if len(self.stack) == 0:\n            return True\n        return False\n\n    def push(self, obj):\n        self.stack.append(obj)\n        self.indexes.append(obj.color)\n\n    def pop(self, index):\n        self.stack.pop(index)\n        self.indexes.pop(index)\n\nclass Box:\n\n    def __init__(self, value, color):\n        self.value = value\n        self.color = color\ntests = int(input())\nwhile tests:\n    tests -= 1\n    (n, m) = map(int, input().split())\n    if m > n:\n        m = n\n    l = list(map(int, input().split()))\n    Boxes = []\n    color = 0\n    for i in range(n):\n        if color == m:\n            color = 0\n        Boxes.append(Box(l[i], color))\n        color += 1\n    Boxes.sort(key=lambda x: x.value)\n    prev = Boxes[0]\n    _min = 10 ** 10\n    sequence = Sequence(m)\n    for i in range(n):\n        if sequence.isEmpty():\n            sequence.push(Boxes[i])\n            sequence.present[Boxes[i].color] = True\n            continue\n        if sequence.present[Boxes[i].color]:\n            if not sequence.isComplete():\n                index = sequence.indexes.index(Boxes[i].color)\n                sequence.pop(index)\n                sequence.push(Boxes[i])\n        else:\n            sequence.push(Boxes[i])\n            sequence.present[Boxes[i].color] = True\n        if sequence.isComplete():\n            minBox = sequence.stack[0]\n            maxBox = sequence.stack[m - 1]\n            sequence.pop(0)\n            sequence.present[minBox.color] = False\n            _diff = maxBox.value - minBox.value\n            if _min > _diff:\n                _min = _diff\n    print(_min)", "for case in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    all_boxes = [int(x) for x in input().split()]\n    color_wise_boxes = []\n    for j in range(0, n, m):\n        for i in range(m):\n            try:\n                color_wise_boxes.append([all_boxes[i + j], i])\n            except IndexError:\n                break\n    color_wise_boxes.sort()\n    initials = {}\n    diff = 10000000000.0\n    _min = 10000000000.0\n    _max = 0\n    flag = False\n    for box in color_wise_boxes:\n        min_flag = False\n        try:\n            if initials[box[1]] == _min:\n                min_flag = True\n        except KeyError:\n            pass\n        initials[box[1]] = box[0]\n        if not flag:\n            if len(initials) >= m:\n                flag = True\n        if (initials[box[1]] < _min or initials[box[1]] > _max) and flag:\n            if min_flag or _min == 10000000000.0:\n                _min = min(initials.values())\n            _max = initials[box[1]]\n            diff = min(diff, abs(_max - _min))\n    print(diff)", "import heapq\nt = int(input())\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    mat = []\n    for i in range(m):\n        l = []\n        j = 0\n        while i + m * j < n:\n            l.append(lst[i + m * j])\n            j += 1\n        l.sort()\n        mat.append(l)\n    harr = []\n    for i in range(m):\n        harr.append([mat[i][0], i])\n    heapq.heapify(harr)\n    index = [0 for i in range(m)]\n    lar = max(harr)\n    sma = harr[0]\n    less = lar[0] - sma[0]\n    flag = 1\n    if len(mat[sma[1]]) - 1 > index[sma[1]]:\n        index[sma[1]] += 1\n        sma = heapq.heapreplace(harr, [mat[sma[1]][index[sma[1]]], sma[1]])\n    else:\n        flag = 0\n    count = 0\n    x = m\n    if n / m > m:\n        x = n / m\n    while flag:\n        lar = max(harr)\n        sma = harr[0]\n        least = lar[0] - sma[0]\n        if least < less:\n            less = least\n            count = 0\n        else:\n            count += 1\n        if count >= x:\n            break\n        if len(mat[sma[1]]) - 1 > index[sma[1]]:\n            index[sma[1]] += 1\n            sma = heapq.heapreplace(harr, [mat[sma[1]][index[sma[1]]], sma[1]])\n        else:\n            break\n    print(less)\n    t -= 1", "import heapq\nt = int(input())\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    mat = []\n    for i in range(m):\n        l = []\n        j = 0\n        while i + m * j < n:\n            l.append(lst[i + m * j])\n            j += 1\n        l.sort()\n        mat.append(l)\n    harr = []\n    for i in range(m):\n        harr.append([mat[i][0], i])\n    heapq.heapify(harr)\n    index = [0 for i in range(m)]\n    lar = max(harr)\n    sma = harr[0]\n    less = lar[0] - sma[0]\n    flag = 1\n    if len(mat[sma[1]]) - 1 > index[sma[1]]:\n        index[sma[1]] += 1\n        sma = heapq.heapreplace(harr, [mat[sma[1]][index[sma[1]]], sma[1]])\n    else:\n        flag = 0\n    count = 0\n    x = m\n    if n / m > m:\n        x = n / m\n    while flag:\n        lar = max(harr)\n        sma = harr[0]\n        least = lar[0] - sma[0]\n        if least < less:\n            less = least\n            count = 0\n        else:\n            count += 1\n        if count >= x:\n            break\n        if len(mat[sma[1]]) - 1 > index[sma[1]]:\n            index[sma[1]] += 1\n            sma = heapq.heapreplace(harr, [mat[sma[1]][index[sma[1]]], sma[1]])\n        else:\n            break\n    print(less)\n    t -= 1", "from bisect import insort_left as ins\n\ndef rev(a, x):\n    lo = 0\n    hi = len(a)\n    x.pop()\n    if not bool(x):\n        return True\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if x[-1] > a[mid][-1]:\n            hi = mid\n        else:\n            lo = mid + 1\n    a.insert(lo, x)\n    return False\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, m) = map(int, input().split())\n        a = list(map(int, input().split()))\n        r = list(range(n))\n        mi = 10 ** 9 + 1\n        f = [[] for i in range(m)]\n        for (i, ia) in enumerate(a):\n            ins(a=f[i % m], x=ia)\n            if n - i <= m:\n                f[i % m].reverse()\n        f.sort(reverse=True, key=lambda x: x[-1])\n        min = 10 ** 9 + 1\n        while True:\n            dif = f[0][-1] - f[-1][-1]\n            if dif < min:\n                min = dif\n            x = f.pop()\n            if rev(f, x):\n                break\n        print(min)\nmain()", "import heapq\n\ndef smallestRange(A):\n    pq = [(row[0], i, 0) for (i, row) in enumerate(A)]\n    heapq.heapify(pq)\n    ans = (-1000000000.0, 1000000000.0)\n    right = max((row[0] for row in A))\n    while pq:\n        (left, i, j) = heapq.heappop(pq)\n        if right - left < ans[1] - ans[0]:\n            ans = (left, right)\n        if j + 1 == len(A[i]):\n            return ans\n        v = A[i][j + 1]\n        right = max(right, v)\n        heapq.heappush(pq, (v, i, j + 1))\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    li = list(map(int, input().split()))\n    arr = [[] for j in range(m)]\n    for i in range(n):\n        arr[i % m].append(li[i])\n    for i in arr:\n        i.sort()\n    x = smallestRange(arr)\n    print(abs(x[1] - x[0]))", "for t in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        if a[i] in d.keys():\n            if (i + 1) % m != 0:\n                d[a[i]].append((i + 1) % m)\n            else:\n                d[a[i]].append(m)\n        elif (i + 1) % m != 0:\n            d[a[i]] = [(i + 1) % m]\n        else:\n            d[a[i]] = [m]\n    a.sort()\n    indices = []\n    for i in range(n):\n        indices.append(d[a[i]][0])\n        d[a[i]] = d[a[i]][1:]\n    d = [[] for i in range(m)]\n    for i in range(n):\n        d[indices[i] - 1].append(i)\n    tracker = [0 for i in range(m)]\n    indices_covered = []\n    corr_value = []\n    length = 0\n    min_diff = 0\n    diff = 0\n    check = 'false'\n    index = 0\n    starter = 0\n    lowest = 0\n    lind = 0\n    lcorr = 0\n    for i in range(n):\n        check = 'false'\n        if tracker[indices[i] - 1] == 0:\n            tracker[indices[i] - 1] = 1\n            indices_covered.append(indices[i])\n            lind += 1\n            corr_value.append(a[i])\n            lcorr += 1\n            length += 1\n            if length == m:\n                for j in range(lowest, lcorr):\n                    if corr_value[j] != '-':\n                        min_diff = corr_value[-1] - corr_value[j]\n                        lowest = j\n                        break\n        else:\n            start = indices_covered[lowest]\n            index = -(d[indices[i] - 1][1] - d[indices[i] - 1][0])\n            corr_value[index] = '-'\n            indices_covered[index] = '-'\n            for s in range(lowest, lcorr):\n                if corr_value[s] != '-':\n                    lowest = s\n                    break\n            corr_value.append(a[i])\n            lcorr += 1\n            indices_covered.append(indices[i])\n            lind += 1\n            del d[indices[i] - 1][0]\n            if length != m:\n                continue\n            if start == indices[i]:\n                check = 'true'\n            if check == 'true':\n                diff = a[i] - corr_value[lowest]\n                min_diff = min(min_diff, diff)\n    print(min_diff)", "class Node:\n\n    def __init__(self, value):\n        self.value = value\n        self.max_heap_loc = None\n        self.min_heap_loc = None\n        self.arr_pos = None\n        self.index = None\n        self.arr_max = None\n\nclass MinHeap:\n\n    def __init__(self, arr):\n        self.heap = arr\n        self.size = len(arr)\n\n    def heapify_down(self, pos):\n        left_child = pos * 2 + 1\n        right_child = pos * 2 + 2\n        if right_child >= len(self.heap):\n            if left_child >= len(self.heap):\n                return\n            min_child = left_child\n        else:\n            min_child = left_child if self.heap[left_child].value < self.heap[right_child].value else right_child\n        if self.heap[pos].value > self.heap[min_child].value:\n            self.heap[min_child].min_heap_loc = pos\n            self.heap[pos].min_heap_loc = min_child\n            (self.heap[pos], self.heap[min_child]) = (self.heap[min_child], self.heap[pos])\n            self.heapify_down(min_child)\n\n    def heapify_up(self, pos):\n        if pos == 0:\n            return\n        parent = pos // 2\n        if self.heap[parent].value > self.heap[pos].value:\n            self.heap[parent].min_heap_loc = pos\n            self.heap[pos].min_heap_loc = parent\n            (self.heap[parent], self.heap[pos]) = (self.heap[pos], self.heap[parent])\n            self.heapify_up(parent)\n\n    def construct_heap(self):\n        for i in range((len(self.heap) - 1) // 2, -1, -1):\n            self.heapify_down(i)\n        self.assign_positions()\n\n    def insert(self, node):\n        self.heap.append(node)\n        self.heapify_up(self.size)\n        self.size += 1\n\n    def peek(self):\n        return self.heap[0]\n\n    def show(self):\n        a = [(i.value, i.max_heap_loc) for i in self.heap]\n        print(a)\n\n    def assign_positions(self):\n        for i in range(self.size):\n            self.heap[i].min_heap_loc = i\n\n    def change(self, pos, node_new):\n        self.heap[pos] = node_new\n        if pos == 0:\n            self.heapify_down(pos)\n        elif self.heap[pos // 2].value < node_new.value:\n            self.heapify_down(pos)\n        else:\n            self.heapify_up(pos)\n\nclass MaxHeap:\n\n    def __init__(self, arr):\n        self.heap = arr\n        self.size = len(arr)\n\n    def heapify_down(self, pos):\n        left_child = pos * 2 + 1\n        right_child = pos * 2 + 2\n        if right_child >= len(self.heap):\n            if left_child >= len(self.heap):\n                return\n            max_child = left_child\n        else:\n            max_child = left_child if self.heap[left_child].value > self.heap[right_child].value else right_child\n        if self.heap[pos].value < self.heap[max_child].value:\n            self.heap[max_child].max_heap_loc = pos\n            self.heap[pos].max_heap_loc = max_child\n            (self.heap[pos], self.heap[max_child]) = (self.heap[max_child], self.heap[pos])\n            self.heapify_down(max_child)\n\n    def heapify_up(self, pos):\n        if pos == 0:\n            return\n        parent = pos // 2\n        if self.heap[parent].value < self.heap[pos].value:\n            self.heap[parent].max_heap_loc = pos\n            self.heap[pos].max_heap_loc = parent\n            (self.heap[parent], self.heap[pos]) = (self.heap[pos], self.heap[parent])\n            self.heapify_up(parent)\n\n    def construct_heap(self):\n        for i in range((len(self.heap) - 1) // 2, -1, -1):\n            self.heapify_down(i)\n        self.assign_positions()\n\n    def insert(self, node):\n        self.heap.append(node)\n        self.heapify_up(self.size)\n        self.size += 1\n\n    def change(self, pos, node_new):\n        self.heap[pos] = node_new\n        if pos == 0:\n            self.heapify_down(pos)\n        elif self.heap[pos // 2].value > node_new.value:\n            self.heapify_down(pos)\n        else:\n            self.heapify_up(pos)\n\n    def show(self):\n        a = [(i.value, i.min_heap_loc) for i in self.heap]\n        print(a)\n\n    def assign_positions(self):\n        for i in range(self.size):\n            self.heap[i].max_heap_loc = i\n\n    def peek(self):\n        return self.heap[0]\n\ndef main():\n    for i in range(int(input())):\n        difs = 10 ** 9\n        (n, m) = map(int, input().split())\n        arr = list(map(int, input().split()))\n        arrs = [[] for u in range(m)]\n        j = 0\n        for i in arr:\n            n = Node(i)\n            n.arr_pos = j % m\n            arrs[j % m].append(n)\n            j += 1\n        for ar in arrs:\n            ar.sort(key=lambda x: x.value)\n            x = len(ar)\n            for i in range(x):\n                ar[i].index = i\n                ar[i].arr_max = x\n        minh = MinHeap([k[0] for k in arrs])\n        maxh = MaxHeap([k[0] for k in arrs])\n        minh.construct_heap()\n        maxh.construct_heap()\n        while True:\n            top_min = minh.peek()\n            top_max = maxh.peek()\n            dif = top_max.value - top_min.value\n            if dif < difs:\n                difs = dif\n            if top_min.index >= top_min.arr_max - 1:\n                break\n            next_min = arrs[top_min.arr_pos][top_min.index + 1]\n            (next_min.min_heap_loc, next_min.max_heap_loc) = (top_min.min_heap_loc, top_min.max_heap_loc)\n            minh.change(0, next_min)\n            maxh.change(top_min.max_heap_loc, next_min)\n        print(difs)\nmain()", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = [int(x) for x in input().split()]\n    mat = []\n    for j in range(m):\n        temp = [arr[i] for i in range(j, n, m)]\n        temp.sort()\n        mat.append(temp)\n    mini = 10 ** 10\n    flag = 0\n    temp = [mat[i][0] for i in range(m)]\n    count = 0\n    while flag != 1 and mini != 0 and (count < 2000):\n        count += 1\n        if max(temp) - min(temp) < mini:\n            mini = max(temp) - min(temp)\n        my_index = arr.index(min(temp)) % m\n        arr[arr.index(min(temp))] = -1\n        mat[my_index].pop(0)\n        if len(mat[my_index]) == 0:\n            flag = 1\n            break\n        temp.remove(min(temp))\n        if len(mat[my_index]) != 0:\n            temp.append(mat[my_index][0])\n    print(mini)", "from collections import defaultdict\nimport sys\n\nclass Node:\n\n    def __init__(self, ele, list_i, next_i):\n        self.ele = ele\n        self.list_i = list_i\n        self.next_i = next_i\n\nclass MinHeap:\n\n    def __init__(self, arr, size):\n        self.arr = arr\n        self.size = size\n        i = size // 2\n        while i >= 0:\n            self.MinHeapify(i)\n            i -= 1\n\n    def left(self, i):\n        return 2 * i + 1\n\n    def right(self, i):\n        return 2 * i + 2\n\n    def MinHeapify(self, i):\n        l = self.left(i)\n        r = self.right(i)\n        small = i\n        if l < self.size and self.arr[l].ele < self.arr[i].ele:\n            small = l\n        if r < self.size and self.arr[r].ele < self.arr[small].ele:\n            small = r\n        if small != i:\n            self.swap(small, i)\n            self.MinHeapify(small)\n\n    def swap(self, i, j):\n        temp = self.arr[i]\n        self.arr[i] = self.arr[j]\n        self.arr[j] = temp\n\n    def getMin(self):\n        return self.arr[0]\n\n    def replaceMin(self, x):\n        self.arr[0] = x\n        self.MinHeapify(0)\n\ndef findSmallestRange(boxes, m):\n    minrange = sys.maxsize\n    minV = sys.maxsize\n    maxV = -sys.maxsize - 1\n    (start, end) = (-1, -1)\n    arr = [0] * m\n    for i in range(0, m):\n        node = Node(boxes[i][0], i, 1)\n        arr[i] = node\n        maxV = max(maxV, node.ele)\n    mh = MinHeap(arr, m)\n    while True:\n        root = mh.getMin()\n        minV = root.ele\n        if minrange > maxV - minV:\n            minrange = maxV - minV\n            start = minV\n            end = maxV\n        if root.next_i < len(boxes[root.list_i]):\n            root.ele = boxes[root.list_i][root.next_i]\n            root.next_i += 1\n            if root.ele > maxV:\n                maxV = root.ele\n        else:\n            break\n        mh.replaceMin(root)\n    print(minrange)\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    boxes = defaultdict(list)\n    count = 0\n    for i in range(N):\n        box_index = count % M\n        boxes[box_index].append(arr[i])\n        count += 1\n    for i in range(M):\n        boxes[i].sort()\n    findSmallestRange(boxes, M)", "import heapq\n\ndef smallest_interval(nums):\n    heap = [(row[0], i, 0) for (i, row) in enumerate(nums)]\n    heapq.heapify(heap)\n    local_maximum = max((row[0] for row in nums))\n    ans = [-10 ** 10, 10 ** 10]\n    while heap:\n        (local_minimum, num_list, local_min_index) = heapq.heappop(heap)\n        if local_maximum - local_minimum < ans[1] - ans[0]:\n            ans = [local_minimum, local_maximum]\n        if local_min_index + 1 == len(nums[num_list]):\n            return ans\n        next_val = nums[num_list][local_min_index + 1]\n        local_maximum = max(next_val, local_maximum)\n        heapq.heappush(heap, (next_val, num_list, local_min_index + 1))\nt = int(input())\nfor _ in range(t):\n    [n, m] = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    a = []\n    for i in range(m):\n        k = []\n        a.append(k)\n    i = 0\n    while i < n:\n        count = 0\n        while count < m:\n            if i < n:\n                a[count].append(l[i])\n                count += 1\n                i += 1\n            if i >= n and count < m:\n                a[count].append(10 ** 10)\n                count += 1\n                i += 1\n    for num in a:\n        num.sort()\n    if n % m == 0:\n        N = n // m\n    else:\n        N = n // m + 1\n    ans = smallest_interval(a)\n    print(ans[1] - ans[0])", "import heapq\n\ndef smallest_interval(nums):\n    heap = [(row[0], i, 0) for (i, row) in enumerate(nums)]\n    heapq.heapify(heap)\n    local_maximum = max((row[0] for row in nums))\n    ans = [-10 ** 10, 10 ** 10]\n    while heap:\n        (local_minimum, num_list, local_min_index) = heapq.heappop(heap)\n        if local_maximum - local_minimum < ans[1] - ans[0]:\n            ans = [local_minimum, local_maximum]\n        if local_min_index + 1 == len(nums[num_list]):\n            return ans\n        next_val = nums[num_list][local_min_index + 1]\n        local_maximum = max(next_val, local_maximum)\n        heapq.heappush(heap, (next_val, num_list, local_min_index + 1))\nt = int(input())\nfor _ in range(t):\n    [n, m] = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    a = []\n    for i in range(m):\n        k = []\n        a.append(k)\n    i = 0\n    while i < n:\n        count = 0\n        while count < m:\n            if i < n:\n                a[count].append(l[i])\n                count += 1\n                i += 1\n            if i >= n and count < m:\n                a[count].append(10 ** 10)\n                count += 1\n                i += 1\n    for num in a:\n        num.sort()\n    if n % m == 0:\n        N = n // m\n    else:\n        N = n // m + 1\n    ans = smallest_interval(a)\n    print(ans[1] - ans[0])", "import heapq\n\ndef smallest_interval(nums):\n    heap = [(row[0], i, 0) for (i, row) in enumerate(nums)]\n    heapq.heapify(heap)\n    local_maximum = max((row[0] for row in nums))\n    ans = [-10 ** 10, 10 ** 10]\n    while heap:\n        (local_minimum, num_list, local_min_index) = heapq.heappop(heap)\n        if local_maximum - local_minimum < ans[1] - ans[0]:\n            ans = [local_minimum, local_maximum]\n        if local_min_index + 1 == len(nums[num_list]):\n            return ans\n        next_val = nums[num_list][local_min_index + 1]\n        local_maximum = max(next_val, local_maximum)\n        heapq.heappush(heap, (next_val, num_list, local_min_index + 1))\nt = int(input())\nfor _ in range(t):\n    [n, m] = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    a = []\n    for i in range(m):\n        k = []\n        a.append(k)\n    i = 0\n    while i < n:\n        count = 0\n        while count < m:\n            if i < n:\n                a[count].append(l[i])\n                count += 1\n                i += 1\n            if i >= n and count < m:\n                a[count].append(10 ** 10)\n                count += 1\n                i += 1\n    for num in a:\n        num.sort()\n    if n % m == 0:\n        N = n // m\n    else:\n        N = n // m + 1\n    ans = smallest_interval(a)\n    print(ans[1] - ans[0])", "import bisect\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().strip().split()))\n    l = list(map(int, input().strip().split()))\n    s = [sorted(l[i::m]) for i in range(m)]\n    s2 = sorted(s, key=lambda x: x[-1] - x[0])\n    res = 100000000000\n    for val in s2[0]:\n        small = val\n        ind = bisect.bisect_left(s2[1], small)\n        if ind == 0:\n            large = s2[1][ind]\n        elif ind == len(s2[1]):\n            large = small\n            small = s2[1][-1]\n        elif small - s2[1][ind - 1] < s2[1][ind] - small:\n            large = small\n            small = s2[1][ind - 1]\n        else:\n            large = s2[1][ind]\n        if len(s2) > 2:\n            emptyList = []\n            for i in range(2, len(s2)):\n                indd = bisect.bisect_left(s2[i], small)\n                if indd == len(s2[i]):\n                    if s2[i][-1] < small:\n                        small = s2[i][-1]\n                elif indd == 0:\n                    if s2[i][indd] > large:\n                        large = s2[i][0]\n                elif s2[i][indd] > large:\n                    if small - s2[i][indd - 1] < s2[i][indd] - large:\n                        small = s2[i][indd - 1]\n                    elif small - s2[i][indd - 1] < s2[i][indd] - large:\n                        large = s2[i][indd]\n                    else:\n                        emptyList.append(s2[i])\n            for sel in emptyList:\n                indd = bisect.bisect_left(sel, small)\n                if indd == len(s2[i]):\n                    if sel[-1] < small:\n                        small = sel[-1]\n                elif indd == 0:\n                    if sel[indd] > large:\n                        large = sel[0]\n                elif sel[indd] > large:\n                    if small - sel[indd - 1] < sel[indd] - large:\n                        small = sel[indd - 1]\n                    elif small - sel[indd - 1] < sel[indd] - large:\n                        large = sel[indd]\n                    else:\n                        large = sel[indd]\n        if large - small < res:\n            res = large - small\n        if res == 0:\n            break\n    print(res)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ll = list(map(int, input().split()))\n    a = []\n    for i in range(n):\n        a.append([])\n        a[i].append(ll[i])\n        a[i].append(i % m)\n    l = sorted(a, key=lambda lll: lll[0])\n    a = [0] * m\n    j = 0\n    ans = 0\n    for i in range(n):\n        if a[l[i][1]] == 0:\n            ans += 1\n        a[l[i][1]] += 1\n        if ans == m:\n            j = i\n            ans = l[i][0] - l[0][0]\n            break\n    for i in range(1, n - m + 1):\n        if ans == 0:\n            break\n        index = l[i - 1][1]\n        a[index] -= 1\n        if a[index] != 0:\n            ans = min(ans, l[j][0] - l[i][0])\n        else:\n            for k in range(j + 1, n):\n                a[l[k][1]] += 1\n                if l[k][1] == index:\n                    j = k\n                    ans = min(ans, l[j][0] - l[i][0])\n                    break\n            else:\n                break\n    print(ans)", "import heapq\nimport sys\nsys.setrecursionlimit(100000)\n\nclass Boxes:\n\n    def __init__(self, N, M):\n        self.M = M\n        self.N = N\n        self.A = []\n        heapq.heapify(self.A)\n        self.ChoosenDict = dict()\n        self.Choosen = []\n        heapq.heapify(self.Choosen)\n        self.minVal = None\n        self.maxVal = None\n        self.minDiff = -1\n\n    def input(self, inputArr):\n        index = 0\n        for a in inputArr:\n            w = int(a)\n            ao = [w, index % self.M]\n            heapq.heappush(self.A, (w, ao))\n            index += 1\n\n    def check(self):\n        for _ in range(N):\n            box = heapq.heappop(self.A)[1]\n            self.addInChoise(box)\n        print(self.minDiff)\n\n    def addInChoise(self, box):\n        self.maxVal = box\n        pop = self.minVal is None or (box[1] in self.ChoosenDict and self.ChoosenDict[box[1]] == self.minVal)\n        self.ChoosenDict[box[1]] = box\n        heapq.heappush(self.Choosen, (box[0], box))\n        if pop:\n            self.minVal = heapq.heappop(self.Choosen)[1]\n            while self.ChoosenDict[self.minVal[1]][0] != self.minVal[0]:\n                self.minVal = heapq.heappop(self.Choosen)[1]\n        if len(self.ChoosenDict.keys()) == M:\n            diff = self.maxVal[0] - self.minVal[0]\n            if self.minDiff == -1 or diff < self.minDiff:\n                self.minDiff = diff\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    boxes = Boxes(N, M)\n    boxes.input(input().split())\n    boxes.check()", "from queue import PriorityQueue\nII = lambda : [int(x) for x in input().split()]\nT = int(input())\nfor _ in range(T):\n    (N, M) = II()\n    A = II()\n    matrix = [list() for _ in range(M)]\n    for i in range(N):\n        matrix[i % M].append(A[i])\n    for i in range(M):\n        matrix[i].sort()\n    pointers = [0] * M\n    V = [matrix[j][0] for j in range(M)]\n    (max_c, min_c) = (max(V), min(V))\n    diff = max_c - min_c\n    Q = PriorityQueue()\n    for (j, p) in enumerate(pointers):\n        Q.put((matrix[j][p], (j, p)))\n    while not Q.empty():\n        (min_c, item) = Q.get()\n        if max_c - min_c < diff:\n            diff = max_c - min_c\n        (j, p) = item\n        p += 1\n        if p == len(matrix[j]):\n            break\n        Q.put((matrix[j][p], (j, p)))\n        if matrix[j][p] > max_c:\n            max_c = matrix[j][p]\n    print(diff)", "def inp():\n    t = int(input())\n    while t > 0:\n        (n, m) = map(int, input().split())\n        a = list(map(int, input().split()))\n        count = 0\n        pairs = []\n        for num in a:\n            pairs.append((num, count % m))\n            count += 1\n        pairs.sort()\n        newList = a[:m]\n        maxi = max(newList)\n        mini = min(newList)\n        diff = maxi - mini\n        for i in range(0, n):\n            miniflag = False\n            maxiFlag = False\n            if newList[pairs[i][1]] == mini:\n                miniflag = True\n            if newList[pairs[i][1]] == maxi:\n                maxiFlag = True\n            newList[pairs[i][1]] = pairs[i][0]\n            if miniflag == True or maxiFlag == True:\n                mini = min(newList)\n                maxi = max(newList)\n            else:\n                maxi = max(maxi, pairs[i][0])\n            diff = min(diff, maxi - mini)\n        print(diff)\n        t = t - 1\ninp()", "import bisect\n\ndef insert(l, n):\n    bisect.insort(l, n)\n    return l\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    ins = n // k\n    a = [[] for i in range(k)]\n    for i in range(k):\n        for j in range(i, n, k):\n            a[i].append(arr[j])\n    for i in a:\n        i.sort()\n    heap = [i[0] for i in a]\n    temp = list(heap)\n    temp.sort()\n    minhp = temp[0]\n    maxhp = temp[-1]\n    diff = maxhp - minhp\n    pos = [0] * k\n    ln = [len(i) for i in a]\n    status = True\n    while status:\n        inx = heap.index(minhp)\n        pos[inx] += 1\n        if pos[inx] > ln[inx] - 1:\n            status = False\n            break\n        element = heap[inx]\n        heap[inx] = a[inx][pos[inx]]\n        temp.remove(element)\n        insert(temp, a[inx][pos[inx]])\n        minhp = temp[0]\n        maxhp = temp[-1]\n        diff1 = maxhp - minhp\n        if diff1 < diff:\n            diff = diff1\n    print(diff)", "class MinHeapNode:\n\n    def __init__(self):\n        self.element = 0\n        self.i = 0\n        self.j = 0\n\nclass MinHeap:\n\n    def __init__(self, a, size):\n        self.heap_size = size\n        self.harr = a\n        i = (self.heap_size - 1) // 2\n        while i >= 0:\n            self.MinHeapify(i)\n            i -= 1\n\n    def left(self, i):\n        return 2 * i + 1\n\n    def right(self, i):\n        return 2 * i + 2\n\n    def getMin(self):\n        return self.harr[0]\n\n    def replaceMin(self, x):\n        self.harr[0] = x\n        self.MinHeapify(0)\n\n    def MinHeapify(self, i):\n        l = self.left(i)\n        r = self.right(i)\n        smallest = i\n        if l < self.heap_size and self.harr[l].element < self.harr[i].element:\n            smallest = l\n        if r < self.heap_size and self.harr[r].element < self.harr[smallest].element:\n            smallest = r\n        if smallest != i:\n            temp = self.harr[i]\n            self.harr[i] = self.harr[smallest]\n            self.harr[smallest] = temp\n            self.MinHeapify(smallest)\n\ndef findSmallestRange(arr, k, N):\n    rangee = float('inf')\n    minn = float('inf')\n    maxx = -float('inf')\n    harr = [0 for i in range(k)]\n    for i in range(k):\n        harr[i] = MinHeapNode()\n        harr[i].element = arr[i][0]\n        harr[i].i = i\n        harr[i].j = 1\n        if harr[i].element > maxx:\n            maxx = harr[i].element\n    hp = MinHeap(harr, k)\n    while 1:\n        root = hp.getMin()\n        minn = hp.getMin().element\n        if rangee > maxx - minn + 1:\n            rangee = maxx - minn + 1\n            start = minn\n            end = maxx\n        if root.j < N[root.i]:\n            root.element = arr[root.i][root.j]\n            root.j += 1\n            if root.element > maxx:\n                maxx = root.element\n        else:\n            break\n        hp.replaceMin(root)\n    print(end - start)\nt = int(input())\nfor i in range(t):\n    (n, m) = [int(i) for i in input().split()]\n    temp = [int(i) for i in input().split()]\n    arr = [[] for i in range(m)]\n    N = [0 for i in range(m)]\n    for i in range(n):\n        arr[i % m].append(temp[i])\n        N[i % m] += 1\n    for i in range(m):\n        arr[i].sort()\n    findSmallestRange(arr, m, N)", "def customSort(a):\n    return a[0]\nT = int(input())\nfor t in range(T):\n    (N, M) = list(map(int, input().strip().split(' ')))\n    A_temp = list(map(int, input().strip().split(' ')))\n    A = []\n    for n in range(N):\n        A.append([A_temp[n], n % M])\n    A = sorted(A, key=customSort)\n    colors = set()\n    boxes = dict()\n    diffs = []\n    min_element_index = 0\n    insertedBoxes = []\n    indexOfColors = dict()\n    valuesOfIndex = dict()\n    for i in range(N):\n        max_element = A[i][0]\n        if A[i][1] in indexOfColors:\n            del valuesOfIndex[indexOfColors[A[i][1]]]\n        boxes[A[i][1]] = A[i][0]\n        indexOfColors[A[i][1]] = i\n        insertedBoxes.append(A[i][0])\n        valuesOfIndex[i] = A[i][0]\n        colors.add(A[i][1])\n        if len(colors) == M:\n            min_element = list(valuesOfIndex.values())[0]\n            diffs.append(max_element - min_element)\n    ans = min(diffs)\n    print(ans)", "t = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    currArr = [arr[x] for x in range(m)]\n    arr = [[arr[x], x % m] for x in range(n)]\n    arr = sorted(arr)\n    maxVal = max(currArr)\n    minVal = min(currArr)\n    answer = maxVal - minVal\n    for x in range(0, len(arr)):\n        (a, b) = arr[x]\n        if currArr[b] == maxVal:\n            currArr[b] = a\n            maxVal = max(currArr)\n            minVal = min(currArr)\n        if currArr[b] == minVal:\n            currArr[b] = a\n            minVal = min(currArr)\n            maxVal = max(currArr)\n        currArr[b] = a\n        if maxVal - minVal < answer:\n            answer = maxVal - minVal\n    print(answer)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    colors = list(range(m)) * (n // m) + list(range(n % m))\n    a = sorted([[x, y] for (x, y) in zip(a, colors)])\n    color_slots = [None] * m\n    min_arr = [None] * n\n    min_ind = 0\n    c_cnt = 0\n    res = 10 ** 9 + 10\n    for (val, color) in a:\n        min_arr.append(val)\n        if color_slots[color] is None:\n            c_cnt += 1\n        else:\n            min_arr[color_slots[color]] = None\n        color_slots[color] = len(min_arr) - 1\n        if c_cnt == m:\n            mx = min_arr[-1]\n            while min_arr[min_ind] is None:\n                min_ind += 1\n            mn = min_arr[min_ind]\n            res = min(res, mx - mn)\n    print(res)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    c = 1\n    for v in map(int, input().split()):\n        l += [(v, c)]\n        if c == m:\n            c = 1\n        else:\n            c += 1\n    l = sorted(l, key=lambda x: x[0])\n    a = [0] * (m + 1)\n    s = set()\n    w = []\n    res = 1000000009\n    i = 0\n    while 1:\n        while len(s) != m and i < n:\n            s.add(l[i][1])\n            a[l[i][1]] += 1\n            w += [l[i]]\n            i += 1\n        if len(s) == m:\n            res = min(res, abs(w[0][0] - w[-1][0]))\n        if w[0] == w[-1]:\n            break\n        a[w[0][1]] -= 1\n        if a[w[0][1]] == 0:\n            s.remove(w[0][1])\n        w.pop(0)\n    print(res)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    c = 1\n    for v in map(int, input().split()):\n        l += [(v, c)]\n        if c == m:\n            c = 1\n        else:\n            c += 1\n    l = sorted(l, key=lambda x: x[0])\n    a = [0] * (m + 1)\n    s = set()\n    w = []\n    res = 1000000009\n    i = 0\n    while 1:\n        while len(s) != m and i < n:\n            s.add(l[i][1])\n            a[l[i][1]] += 1\n            w += [l[i]]\n            i += 1\n        if len(s) == m:\n            res = min(res, abs(w[0][0] - w[-1][0]))\n        if len(w) == 1:\n            break\n        a[w[0][1]] -= 1\n        if a[w[0][1]] == 0:\n            s.remove(w[0][1])\n        w.pop(0)\n    print(res)", "for _ in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    l = [int(x) for x in input().split()]\n    a = [i % m for i in range(n)]\n    l1 = []\n    values = []\n    a = [a for (_, a) in sorted(zip(l, a))]\n    l.sort()\n    max_val = 99999999999\n    arr = [-1 for x in range(m)]\n    for i in range(n):\n        arr[a[i]] = i\n        if -1 not in arr:\n            m1 = max(arr)\n            m2 = min(arr)\n            if max_val > l[m1] - l[m2]:\n                max_val = l[m1] - l[m2]\n            arr[arr.index(m2)] = -1\n    print(max_val)", "t = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    ar = list(map(int, input().split()))\n    col = 0\n    arr = []\n    for i in range(n):\n        arr.append([ar[i], col % m])\n        col += 1\n    arr.sort(key=lambda x: x[0])\n    dic = {}\n    i = j = 0\n    ans = float('inf')\n    while j < n:\n        dic[arr[j][1]] = dic.get(arr[j][1], 0) + 1\n        while dic and dic[arr[i][1]] > 1:\n            dic[arr[i][1]] -= 1\n            i += 1\n        if len(dic) == m:\n            ans = min(ans, arr[j][0] - arr[i][0])\n        j += 1\n    print(ans)", "import heapq as heap\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    L = list(map(int, input().split()))\n    arr = [[] for i in range(M)]\n    ind = 0\n    for i in L:\n        arr[ind].append(i)\n        ind = (ind + 1) % M\n    for i in range(len(arr)):\n        arr[i].sort()\n    arr.sort()\n    max_elem = arr[-1][0]\n    H = [(arr[i][0], i, 0) for i in range(len(arr))]\n    heap.heapify(H)\n    min_diff = max_elem - H[0][0]\n    while True:\n        min_diff = min(min_diff, max_elem - H[0][0])\n        rem = heap.heappop(H)\n        if len(arr[rem[1]]) - 1 == rem[2]:\n            break\n        heap.heappush(H, (arr[rem[1]][rem[2] + 1], rem[1], rem[2] + 1))\n        max_elem = max(max_elem, arr[rem[1]][rem[2] + 1])\n    print(min_diff)", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = [(a[i], i % m) for i in range(n)]\n    b.sort()\n    color_index = {}\n    for i in range(m):\n        color_index[i] = []\n    for i in range(n):\n        color_index[b[i][1]].append(b[i])\n    pointers = [0 for i in range(m)]\n    minheap = []\n    maxheap = []\n    for i in range(m):\n        heappush(minheap, color_index[i][0])\n        heappush(maxheap, -color_index[i][0][0])\n    diff = 1000000000\n    while True:\n        minitem = heappop(minheap)\n        maxitem = maxheap[0]\n        x = minitem[1]\n        diff = min(-1 * maxitem - minitem[0], diff)\n        pointers[x] += 1\n        if pointers[x] == len(color_index[x]):\n            break\n        else:\n            item = color_index[x][pointers[x]]\n            heappush(minheap, item)\n            heappush(maxheap, -item[0])\n    print(diff)"]