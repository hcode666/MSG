["from collections import defaultdict\nfrom collections import Counter\nimport math\nimport bisect\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def start(self):\n        for i in range(1, n + 1):\n            self.parent[i] = i\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def treeinput():\n        adj = [[] for i in range(n + 1)]\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            adj[u].append(v)\n            adj[v].append(u)\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef setbit(arr):\n    mask = 1\n    bit = [0] * 32\n    for i in range(32):\n        for k in arr:\n            if k & mask:\n                bit[i] += 1\n        mask <<= 1\n    return bit\n\ndef prefix_sum(nums):\n    prefix = [0]\n    for i in range(len(nums)):\n        prefix.append(prefix[-1] + nums[i])\n    return prefix\n\ndef mx_lensubarray(nums):\n    res = 0\n    j = 0\n    mp = defaultdict(int)\n    prefix = prefixsum(nums)\n    mxSum = 0\n    for i in range(len(nums)):\n        if nums[i] in mp:\n            temp = mp[nums[i]]\n        else:\n            temp = 0\n        j = max(temp, j)\n        mp[nums[i]] = i + 1\n        res = max(res, i - j + 1)\n        mxSum = max(mxSum, prefix[i + 1] - prefix[j])\n    return res\n\ndef lenOfLongSubarr(self, A, N, k):\n    mp = {}\n    sm = 0\n    mxlen = 0\n    for i in range(N):\n        sm += A[i]\n        if sm == k:\n            mxlen = i + 1\n        if sm - k in mp:\n            mxlen = max(mxlen, i - mp[sm - k])\n        if sm not in mp:\n            mp[sm] = i\n    return mxlen\n\ndef no_of_factor(s):\n    cnt = 0\n    x = int(s ** 0.5)\n    for i in range(1, x + 1):\n        if not s % i:\n            cnt = cnt + 1 if s / i == i else cnt + 2\n        i += 1\n    return cnt\n\ndef primes(n):\n    arr = []\n    i = 2\n    while i * i <= n:\n        if not n % i:\n            cnt = 0\n            while not n % i:\n                cnt += 1\n                n //= i\n            arr.append([i, cnt])\n        i += 1\n    if n > 1:\n        arr.append([n, 1])\n    return arr\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    res = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            res.append(i)\n    return res\n\ndef treeinput(n):\n    adj = []\n    for i in range(n):\n        (u, v, w) = map(int, input().split())\n        adj.append([w, u, v])\n    return adj\n\ndef dfs_size(node, parent):\n    sum_size[node] = 1\n    for child in adj[node]:\n        if child != parent:\n            dfs_size(child, node)\n            sum_size[node] += sum_size[child]\n\ndef anda(arr):\n    res = arr[0]\n    for i in arr:\n        res &= i\n    return res\n\ndef ora(arr):\n    res = arr[0]\n    for i in arr:\n        res |= i\n    return res\n\ndef xora(arr):\n    res = 0\n    for i in arr:\n        res ^= i\n    return res\nfor _ in range(int(input())):\n    (n, m1, m2) = map(int, input().split())\n    company_adj = treeinput(m1)\n    company_adj.sort()\n    chef_adj = treeinput(m2)\n    chef_adj.sort(reverse=True)\n    d = dsu(n)\n    (chef_cost, company_cost) = (0, 0)\n    for (w, u, v) in chef_adj:\n        if d.find(u) != d.find(v):\n            d.union(u, v)\n            chef_cost += w\n    for (w, u, v) in company_adj:\n        if d.find(u) != d.find(v):\n            d.union(u, v)\n            company_cost += w\n    if d.check(n):\n        print('Impossible')\n        continue\n    print(chef_cost, company_cost + chef_cost)", "from collections import defaultdict\nfrom collections import Counter\nimport math\nimport bisect\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def start(self):\n        for i in range(1, n + 1):\n            self.parent[i] = i\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def treeinput():\n        adj = [[] for i in range(n + 1)]\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            adj[u].append(v)\n            adj[v].append(u)\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef setbit(arr):\n    mask = 1\n    bit = [0] * 32\n    for i in range(32):\n        for k in arr:\n            if k & mask:\n                bit[i] += 1\n        mask <<= 1\n    return bit\n\ndef prefix_sum(nums):\n    prefix = [0]\n    for i in range(len(nums)):\n        prefix.append(prefix[-1] + nums[i])\n    return prefix\n\ndef mx_lensubarray(nums):\n    res = 0\n    j = 0\n    mp = defaultdict(int)\n    prefix = prefixsum(nums)\n    mxSum = 0\n    for i in range(len(nums)):\n        if nums[i] in mp:\n            temp = mp[nums[i]]\n        else:\n            temp = 0\n        j = max(temp, j)\n        mp[nums[i]] = i + 1\n        res = max(res, i - j + 1)\n        mxSum = max(mxSum, prefix[i + 1] - prefix[j])\n    return res\n\ndef lenOfLongSubarr(self, A, N, k):\n    mp = {}\n    sm = 0\n    mxlen = 0\n    for i in range(N):\n        sm += A[i]\n        if sm == k:\n            mxlen = i + 1\n        if sm - k in mp:\n            mxlen = max(mxlen, i - mp[sm - k])\n        if sm not in mp:\n            mp[sm] = i\n    return mxlen\n\ndef no_of_factor(s):\n    cnt = 0\n    x = int(s ** 0.5)\n    for i in range(1, x + 1):\n        if not s % i:\n            cnt = cnt + 1 if s / i == i else cnt + 2\n        i += 1\n    return cnt\n\ndef primes(n):\n    arr = []\n    i = 2\n    while i * i <= n:\n        if not n % i:\n            cnt = 0\n            while not n % i:\n                cnt += 1\n                n //= i\n            arr.append([i, cnt])\n        i += 1\n    if n > 1:\n        arr.append([n, 1])\n    return arr\n\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    res = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            res.append(i)\n    return res\n\ndef treeinput(n):\n    adj = []\n    for i in range(n):\n        (u, v, w) = map(int, input().split())\n        adj.append([w, u, v])\n    return adj\n\ndef dfs_size(node, parent):\n    sum_size[node] = 1\n    for child in adj[node]:\n        if child != parent:\n            dfs_size(child, node)\n            sum_size[node] += sum_size[child]\n\ndef anda(arr):\n    res = arr[0]\n    for i in arr:\n        res &= i\n    return res\n\ndef ora(arr):\n    res = arr[0]\n    for i in arr:\n        res |= i\n    return res\n\ndef xora(arr):\n    res = 0\n    for i in arr:\n        res ^= i\n    return res\nfor _ in range(int(input())):\n    (n, m1, m2) = map(int, input().split())\n    company_adj = treeinput(m1)\n    company_adj.sort()\n    chef_adj = treeinput(m2)\n    chef_adj.sort(reverse=True)\n    d = dsu(n)\n    (chef_cost, company_cost) = (0, 0)\n    for (w, u, v) in chef_adj:\n        if d.find(u) != d.find(v):\n            d.union(u, v)\n            chef_cost += w\n    for (w, u, v) in company_adj:\n        if d.find(u) != d.find(v):\n            d.union(u, v)\n            company_cost += w\n    if d.check(n):\n        print('Impossible')\n        continue\n    print(chef_cost, company_cost + chef_cost)"]