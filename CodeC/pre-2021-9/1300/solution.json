["l = [0] * (10 ** 5 + 1)\nk = [0] * (10 ** 5 + 1)\nl[0] = l[1] = 1\nk[0] = 0\nk[1] = 1\nm = 10 ** 9 + 7\nm2 = m - 1\nfor i in range(2, 10 ** 5 + 1):\n    k[i] = k[i - 1] + k[i - 2]\n    l[i] = l[i - 1] + l[i - 2]\n    k[i] %= m\n    l[i] %= m2\nfor i in range(int(input())):\n    n = int(input())\n    len = l[n]\n    x = k[n]\n    m = 10 ** 9 + 7\n    y = x * pow(2, (len - 1) % m2, m)\n    print(y % m)", "l = [0] * (10 ** 5 + 1)\nk = [0] * (10 ** 5 + 1)\nl[0] = l[1] = 1\nk[0] = 0\nk[1] = 1\nm = 10 ** 9 + 7\nm2 = m - 1\nfor i in range(2, 10 ** 5 + 1):\n    k[i] = k[i - 1] + k[i - 2]\n    l[i] = l[i - 1] + l[i - 2]\n    k[i] %= m\n    l[i] %= m2\nfor i in range(int(input())):\n    n = int(input())\n    len = l[n]\n    x = k[n]\n    m = 10 ** 9 + 7\n    y = x * pow(2, (len - 1) % m2, m)\n    print(y % m)", "l = [0] * (10 ** 5 + 1)\nk = [0] * (10 ** 5 + 1)\nl[0] = l[1] = 1\nk[0] = 0\nk[1] = 1\nm = 10 ** 9 + 7\nm2 = m - 1\nfor i in range(2, 10 ** 5 + 1):\n    k[i] = k[i - 1] + k[i - 2]\n    l[i] = l[i - 1] + l[i - 2]\n    k[i] %= m\n    l[i] %= m2\nfor i in range(int(input())):\n    n = int(input())\n    len = l[n]\n    x = k[n]\n    m = 10 ** 9 + 7\n    y = x * pow(2, (len - 1) % m2, m)\n    print(y % m)", "l = [0] * (10 ** 5 + 1)\nk = [0] * (10 ** 5 + 1)\nl[0] = l[1] = 1\nk[0] = 0\nk[1] = 1\nm = 10 ** 9 + 7\nm2 = m - 1\nfor i in range(2, 10 ** 5 + 1):\n    k[i] = k[i - 1] + k[i - 2]\n    l[i] = l[i - 1] + l[i - 2]\n    k[i] %= m\n    l[i] %= m2\nfor i in range(int(input())):\n    n = int(input())\n    len = l[n]\n    x = k[n]\n    m = 10 ** 9 + 7\n    y = x * pow(2, (len - 1) % m2, m)\n    print(y % m)", "n = 10 ** 5 + 2\ndp = [0] * n\nm = 10 ** 9 + 7\narr = [0] * n\narr2 = [0] * n\narr[1] = 1\narr2[0] = 1\narr2[1] = 1\nm2 = 1000000006\nfor i in range(2, n):\n    arr[i] = (arr[i - 1] + arr[i - 2]) % m\n    arr2[i] = (arr2[i - 1] + arr2[i - 2]) % m2\nfor i in range(0, n):\n    dp[i] = arr[i] * pow(2, arr2[i] - 1, m) % m\nfor _ in range(int(input())):\n    k = int(input())\n    print(dp[k])", "MAX = 100000\nMOD = 10 ** 9 + 7\nfib_pow = [2, 2] + [0] * MAX\ndp = [0, 1] + [0] * MAX\nfor i in range(2, MAX + 1):\n    fib_pow[i] = fib_pow[i - 1] * fib_pow[i - 2] % MOD\n    dp[i] = (dp[i - 1] * fib_pow[i - 2] % MOD + dp[i - 2] * fib_pow[i - 1] % MOD) % MOD\nfor _ in range(int(input())):\n    print(dp[int(input())])", "dp = [0] * (100000 + 2)\nfibPow = [0] * (100000 + 2)\nfibPow[0] = 2\nfibPow[1] = 2\ndp[1] = 1\nm = 1000000007\nfor i in range(2, 100000 + 2):\n    fibPow[i] = fibPow[i - 1] * fibPow[i - 2] % m\n    dp[i] = (dp[i - 1] * fibPow[i - 2] % m + dp[i - 2] * fibPow[i - 1] % m) % m\nfor _ in range(int(input())):\n    n = int(input())\n    print(dp[n])", "try:\n    n = int(input())\n    fib = [0, 1, 2]\n    po = [1, 2, 4]\n    k = 10 ** 9 + 7\n    li = []\n    for i in range(n):\n        x = int(input())\n        li.append(x)\n        if x < len(fib):\n            y = fib[x]\n        else:\n            for i in range(len(fib), x + 1):\n                c = (fib[i - 1] * po[i - 2] + fib[i - 2] * po[i - 1]) % k\n                po.append(po[i - 2] * po[i - 1] % k)\n                fib.append(c)\n            y = fib[x]\n        print(y)\nexcept:\n    pass", "import itertools\nimport math\nfrom sys import stdin\n\ndef A():\n    a = [int(x) for x in stdin.readline().split()]\n    n = a[0]\n    print(int(n * (n / 2)))\n\ndef B():\n    t = int(input())\n    while t:\n        t -= 1\n        b = [int(x) for x in stdin.readline().split()]\n        (n, a) = (b[0], b[1])\n        res = 0\n        for i in range(n, -1, -1):\n            if math.sqrt(i) * math.sqrt(i) == i:\n                res = max(res, int(math.sqrt(i)) * a)\n                break\n        print(res)\n\ndef C():\n    t = int(input())\n    while t:\n        t -= 1\n        b = [int(x) for x in stdin.readline().split()]\n        (n, m, q) = (b[0], b[1], b[2])\n        res = True\n        cnt = 0\n        dp = [0] * (n + 1)\n        cnt = 0\n        while q:\n            q -= 1\n            b = input().split()\n            i = int(b[1])\n            if b[0] == '+':\n                if dp[i] == 1:\n                    res = False\n                dp[i] = 1\n                cnt += 1\n            else:\n                if dp[i] == 0:\n                    res = False\n                dp[i] = 0\n                cnt -= 1\n            if cnt > m:\n                res = False\n        if res:\n            print('Consistent')\n        else:\n            print('Inconsistent')\n\ndef D():\n    t = int(input())\n    while t:\n        t -= 1\n        (n, k) = [int(x) for x in stdin.readline().split()]\n        s = input()\n        pos = []\n        for i in range(0, len(s)):\n            if s[i] == '1':\n                pos.append(i)\n        cnt = 1\n        if len(pos) == 0:\n            cnt = 0\n        if len(pos) > 0:\n            pos[0] += 1\n        for i in range(1, len(pos)):\n            if pos[i] - pos[i - 1] == k:\n                continue\n            if pos[i] - pos[i - 1] < k:\n                pos[i] += 1\n            elif pos[i] - pos[i - 1] <= k + 1:\n                pos[i] -= 1\n            else:\n                pos[i] += 1\n                cnt += 1\n        print(cnt)\n\ndef E():\n    mod = 1000000007\n    f = [0] * (10 ** 5 + 10)\n    f1 = [0] * (10 ** 5 + 10)\n    f[0] = 0\n    f[1] = 1\n    f1[0] = 1\n    f1[1] = 1\n\n    def power(base, pow):\n        res = 1\n        while pow:\n            if pow & 1:\n                res *= base\n            pow >>= 1\n            base *= base\n            base %= mod\n            res % mod\n        return res\n    for i in range(2, 10 ** 5 + 10):\n        f[i] = (f[i - 1] + f[i - 2]) % mod\n        f1[i] = (f1[i - 1] + f1[i - 2]) % (mod - 1)\n    t = int(input())\n    while t:\n        t -= 1\n        n = int(input())\n        ans = f[n] * power(2, f1[n] - 1) % mod\n        print(ans)\nE()", "mod = 10 ** 9 + 7\nf = [[0, 1], [1, 1]]\nfor i in range(10 ** 5):\n    a = f[-1][0] + f[-2][0]\n    b = f[-1][1] + f[-2][1]\n    f.append([a, b])\nfor _ in range(int(input())):\n    n = int(input())\n    ans = f[n][0] % mod * pow(2, (f[n][1] - 1) % (mod - 1), mod) % mod\n    print(ans)", "dp = [0] * (100000 + 2)\nfibPow = [0] * (100000 + 2)\nfibPow[0] = 2\nfibPow[1] = 2\ndp[1] = 1\nm = 1000000007\nfor i in range(2, 100000 + 2):\n    fibPow[i] = fibPow[i - 1] * fibPow[i - 2] % m\n    dp[i] = (dp[i - 1] * fibPow[i - 2] % m + dp[i - 2] * fibPow[i - 1] % m) % m\nfor _ in range(int(input())):\n    n = int(input())\n    print(dp[n])", "up = 10 ** 5 + 1\nmod = 10 ** 9 + 7\ndig = [0] * up\nones = [0] * up\ndig[0] = 1\ndig[1] = 1\nones[0] = 0\nones[1] = 1\nfor i in range(2, up):\n    dig[i] = 2 * dig[i - 1] * dig[i - 2] % mod\n    ones[i] = (ones[i - 1] + ones[i - 2]) % mod\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ans = dig[n] * ones[n] % mod\n    print(ans)", "MOD = int(1000000000.0 + 7)\nt = int(input())\nones = [0] * (10 ** 5 + 1)\nsize = [0] * (10 ** 5 + 1)\nones[1] = size[0] = size[1] = 1\nfor i in range(2, 10 ** 5 + 1):\n    ones[i] = ones[i - 1] + ones[i - 2]\n    size[i] = size[i - 1] + size[i - 2]\nfor _ in range(t):\n    n = int(input())\n    number_ones = ones[n] % MOD\n    exponent = (size[n] - 1) % (MOD - 1)\n    ans = number_ones * pow(2, exponent, MOD)\n    print(int(ans % MOD))", "from sys import stdin\n\ndef mkres(lim, m):\n    (f_pre, f_cur) = (0, 1)\n    (e_pre, e_cur) = (1, 1)\n    r = [0, 1]\n    while len(r) <= lim:\n        (f_pre, f_cur) = (f_cur, (f_cur + f_pre) % m)\n        (e_pre, e_cur) = (e_cur, e_cur * e_pre * 2 % m)\n        r.append(f_cur * e_cur % m)\n    return r\nlim = 100000\nres = mkres(lim, 1000000007)\nT = int(input())\nprint(*(res[int(stdin.readline())] for _ in range(T)), sep='\\n')", "MOD = 1000000007\nsubseq_cnt = [2, 2]\ndp = [0, 1]\nfor i in range(2, 100001):\n    dp.append((dp[i - 1] * subseq_cnt[i - 2] % MOD + dp[i - 2] * subseq_cnt[i - 1] % MOD) % MOD)\n    subseq_cnt.append(subseq_cnt[i - 1] * subseq_cnt[i - 2] % MOD)\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    print(dp[n])\n    t = t - 1", "from sys import stdin\n\ndef mkfib(lim, m):\n    e = [1, 1]\n    f = [0, 1]\n    while len(f) <= lim:\n        e.append(e[-1] * e[-2] * 2 % m)\n        f.append((f[-1] + f[-2]) % m)\n    return (e, f)\nlim = 100000\n(els, fibs) = mkfib(lim, 1000000007)\nT = int(input())\nres = []\nfor tx in range(T):\n    N = int(stdin.readline())\n    el_subseq = els[N]\n    res.append(fibs[N] * el_subseq % 1000000007)\nprint(*res, sep='\\n')", "MOD = int(1000000000.0 + 7)\nt = int(input())\nones = [0] * (10 ** 5 + 1)\nsize = [0] * (10 ** 5 + 1)\nones[1] = 1\nsize[0] = 1\nsize[1] = 1\nfor i in range(2, 10 ** 5 + 1):\n    ones[i] = ones[i - 1] + ones[i - 2]\n    size[i] = size[i - 1] + size[i - 2]\nfor _ in range(t):\n    n = int(input())\n    number_ones = ones[n] % MOD\n    exponent = (size[n] - 1) % (MOD - 1)\n    ans = number_ones * pow(2, exponent, MOD)\n    ans = ans % MOD\n    print(int(ans))", "f = [0] * (10 ** 5 + 5)\nf[0] = 0\nf[1] = 1\nl = [0] * (10 ** 5 + 5)\nl[0] = 1\nl[1] = 1\nm2 = 1000000006\nm = 10 ** 9 + 7\nfor i in range(2, 10 ** 5 + 4):\n    f[i] += (f[i - 1] + f[i - 2]) % m\n    l[i] = (l[i - 1] + l[i - 2]) % m2\nfor t in range(int(input())):\n    n = int(input())\n    m = 10 ** 9 + 7\n\n    def be(b, p):\n        r = 1\n        b = b % m\n        if b == 0:\n            return 0\n        while p > 0:\n            if p % 2:\n                r = r * b % m\n                p -= 1\n            p = p >> 1\n            b = b * b % m\n        return r\n    k = be(2, (l[n] - 1) % m2) % m\n    d = f[n]\n    print(d * k % m)", "import itertools\nimport math\nfrom sys import stdin\n\ndef A():\n    a = [int(x) for x in stdin.readline().split()]\n    n = a[0]\n    print(int(n * (n / 2)))\n\ndef B():\n    t = int(input())\n    while t:\n        t -= 1\n        b = [int(x) for x in stdin.readline().split()]\n        (n, a) = (b[0], b[1])\n        res = 0\n        for i in range(n, -1, -1):\n            if math.sqrt(i) * math.sqrt(i) == i:\n                res = max(res, int(math.sqrt(i)) * a)\n                break\n        print(res)\n\ndef C():\n    t = int(input())\n    while t:\n        t -= 1\n        b = [int(x) for x in stdin.readline().split()]\n        (n, m, q) = (b[0], b[1], b[2])\n        res = True\n        cnt = 0\n        dp = [0] * (n + 1)\n        cnt = 0\n        while q:\n            q -= 1\n            b = input().split()\n            i = int(b[1])\n            if b[0] == '+':\n                if dp[i] == 1:\n                    res = False\n                dp[i] = 1\n                cnt += 1\n            else:\n                if dp[i] == 0:\n                    res = False\n                dp[i] = 0\n                cnt -= 1\n            if cnt > m:\n                res = False\n        if res:\n            print('Consistent')\n        else:\n            print('Inconsistent')\n\ndef D():\n    t = int(input())\n    while t:\n        t -= 1\n        (n, k) = [int(x) for x in stdin.readline().split()]\n        s = input()\n        pos = []\n        for i in range(0, len(s)):\n            if s[i] == '1':\n                pos.append(i)\n        cnt = 1\n        if len(pos) == 0:\n            cnt = 0\n        if len(pos) > 0:\n            pos[0] += 1\n        for i in range(1, len(pos)):\n            if pos[i] - pos[i - 1] == k:\n                continue\n            if pos[i] - pos[i - 1] < k:\n                pos[i] += 1\n            elif pos[i] - pos[i - 1] <= k + 1:\n                pos[i] -= 1\n            else:\n                pos[i] += 1\n                cnt += 1\n        print(cnt)\n\ndef E():\n    mod = 1000000007\n    f = [0] * (10 ** 5 + 10)\n    f1 = [0] * (10 ** 5 + 10)\n    f[0] = 0\n    f[1] = 1\n    f1[0] = 1\n    f1[1] = 1\n\n    def power(base, pow):\n        res = 1\n        while pow:\n            if pow & 1:\n                res *= base\n            pow >>= 1\n            base *= base\n            base %= mod\n            res % mod\n        return res\n    for i in range(2, 10 ** 5 + 10):\n        f[i] = (f[i - 1] + f[i - 2]) % mod\n        f1[i] = (f1[i - 1] + f1[i - 2]) % (mod - 1)\n    t = int(input())\n    while t:\n        t -= 1\n        n = int(input())\n        ans = f[n] * power(2, f1[n] - 1) % mod\n        print(ans)\nE()", "dp = [0] * (100000 + 2)\nfibPow = [0] * (100000 + 2)\nfibPow[0] = 2\nfibPow[1] = 2\ndp[1] = 1\nm = 1000000007\nfor i in range(2, 100000 + 2):\n    fibPow[i] = fibPow[i - 1] * fibPow[i - 2] % m\n    dp[i] = (dp[i - 1] * fibPow[i - 2] % m + dp[i - 2] * fibPow[i - 1] % m) % m\nfor _ in range(int(input())):\n    n = int(input())\n    print(dp[n])", "import sys\nimport math\nimport heapq\nfrom collections import defaultdict as dd\nfrom collections import OrderedDict as od\nfrom collections import deque\nfrom itertools import permutations as pp\nfrom itertools import combinations as cc\nfrom sys import stdin\nfrom functools import cmp_to_key\nfrom functools import lru_cache\nfrom bisect import bisect_left as bs_l\nfrom bisect import bisect_right as bs_r\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 5)\ndp = [0] * (10 ** 5 + 1)\ndp[0] = [1, 0]\ndp[1] = [1, 1]\ndp1 = [-1] * (10 ** 5 + 1)\nfor i in range(2, 10 ** 5 + 1):\n    dp[i] = [dp[i - 1][0] + dp[i - 2][0], dp[i - 1][1] + dp[i - 2][1]]\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    if dp1[n] != -1:\n        ans = dp1[n]\n    else:\n        xx = (dp[n][0] - 1) % (mod - 1)\n        ans = pow(2, xx, mod) * dp[n][1] % mod\n        dp1[n] = ans\n    print(ans)", "import sys\nimport math\nimport heapq\nfrom collections import defaultdict as dd\nfrom collections import OrderedDict as od\nfrom collections import deque\nfrom itertools import permutations as pp\nfrom itertools import combinations as cc\nfrom sys import stdin\nfrom functools import cmp_to_key\nfrom functools import lru_cache\nfrom bisect import bisect_left as bs_l\nfrom bisect import bisect_right as bs_r\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 5)\ndp = [0] * (10 ** 5 + 1)\ndp[0] = [1, 0]\ndp[1] = [1, 1]\ndp1 = [-1] * (10 ** 5 + 1)\nfor i in range(2, 10 ** 5 + 1):\n    dp[i] = [dp[i - 1][0] + dp[i - 2][0], dp[i - 1][1] + dp[i - 2][1]]\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    if dp1[n] != -1:\n        ans = dp1[n]\n    else:\n        xx = (dp[n][0] - 1) % (mod - 1)\n        ans = pow(2, xx, mod) * dp[n][1] % mod\n        dp1[n] = ans\n    print(ans)", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ndepth = 1000005\nsys.setrecursionlimit(depth)\nfrom math import inf, ceil\nfrom collections import defaultdict\n\ndef fibonacci(n, mod):\n    if n < 0:\n        raise ValueError('Negative arguments not implemented')\n    return _fib(n, mod)[0]\n\ndef _fib(n, mod):\n    if n == 0:\n        return (0, 1)\n    else:\n        (a, b) = _fib(n // 2, mod)\n        c = a * ((b * 2 - a) % mod) % mod\n        d = (a * a % mod + b * b % mod) % mod\n        if n % 2 == 0:\n            return (c, d)\n        else:\n            return (d, (c + d) % mod)\n\ndef power(a, b):\n    a %= mod\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % mod\n        a = a * a % mod\n        b >>= 1\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    mod = 1000000007\n    k = fibonacci(n, mod)\n    l = fibonacci(n + 1, mod - 1)\n    if l == 0:\n        l = mod - 2\n    else:\n        l = l - 1\n    ans = k * power(2, l) % mod\n    print(ans)", "def power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nt = int(input())\nfibo = [[0, 0] for i in range(100001)]\nfibo[0][0] = 0\nfibo[0][1] = 1\nfibo[1][0] = 1\nfibo[1][1] = 1\nfor i in range(2, 100001):\n    fibo[i][0] = fibo[i - 1][0] + fibo[i - 2][0]\n    fibo[i][1] = fibo[i - 1][1] + fibo[i - 2][1]\nfor _ in range(t):\n    n = int(input())\n    p = 1000000007\n    exp = power(2, (fibo[n][1] - 1) % (p - 1), p)\n    ans = fibo[n][0] % p * (exp % p) % p\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef st():\n    return input().rstrip('\\n')\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\nt = inp()\np = 10 ** 9 + 7\nf = [1, 2]\nfi = 1\nsi = 1\nfi1 = 1\nsi1 = 1\nfor i in range(3, 10 ** 5 + 1):\n    tt = si + fi\n    tt1 = si1 + fi1\n    tt1 %= p - 1\n    tt %= p\n    fi = si % p\n    si = tt\n    fi1 = si1\n    si1 = tt1\n    xx = tt * pow(2, (tt1 + fi1 - 1) % (p - 1), p)\n    xx %= p\n    f.append(xx)\nwhile t:\n    t -= 1\n    n = inp()\n    print(f[n - 1])", "m = 1000000007\nn = 100001\nf = [0] * n\nf[1] = 1\na = [0] * n\nb = [0] * n\na[0] = 1\nb[1] = 1\na[1] = 1\n\ndef power(x, y):\n    temp = 0\n    if y == 0:\n        return 1\n    temp = power(x, int(y / 2)) % m\n    if y % 2 == 0:\n        return temp * temp % m\n    else:\n        return x * temp % m * temp % m\nfor i in range(2, n):\n    a[i] = a[i - 1] + a[i - 2]\n    b[i] = b[i - 1] + b[i - 2]\n    a[i] %= m - 1\n    b[i] %= m\n    f[i] = b[i] * power(2, (a[i] - 1) % (m - 1)) % m\n\ndef solve():\n    x = int(input())\n    print(f[x])\nt = 1\nt = int(input())\nfor _ in range(t):\n    solve()", "n = 10 ** 5\na = [0] * (n + 1)\na[1] = 1\nb = [0] * (n + 1)\nb[0] = 1\nb[1] = 1\nmod = 10 ** 9 + 7\nfor i in range(2, n + 1):\n    a[i] = (a[i - 1] + a[i - 2]) % mod\n    b[i] = b[i - 1] * b[i - 2] * 2 % mod\nfor _ in range(int(input())):\n    n = int(input())\n    x = a[n]\n    y = b[n]\n    print(x * y % mod)", "n = 100000\ndp = [0] * (n + 1)\n(dp[0], dp[1]) = (1, 1)\nfor i in range(2, n + 1):\n    dp[i] = dp[i - 1] + dp[i - 2]\nseen = {1: 1}\nmod = 10 ** 9 + 7\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    if n in seen:\n        print(seen[n])\n        continue\n    (ones, total) = (dp[n - 1], dp[n])\n    ans = ones * pow(2, (total - 1) % (mod - 1), mod) % mod\n    seen[n] = ans\n    print(ans)", "n = 10 ** 5\ndp = [0 for _ in range(n + 1)]\ndp[1] = 1\ndp2 = [0 for _ in range(n + 1)]\ndp2[0] = 1\ndp2[1] = 1\nmod = 10 ** 9 + 7\nans = [0, 1]\nfor i in range(2, n + 1):\n    dp[i] = dp[i - 1] + dp[i - 2]\n    dp2[i] = dp2[i - 1] * dp2[i - 2] * 2\n    dp[i] %= mod\n    dp2[i] %= mod\nfor _ in range(int(input())):\n    n = int(input())\n    a = dp[n]\n    b = dp2[n]\n    print(a * b % mod)", "mod = 10 ** 9 + 7\nf = [[0, 1], [1, 1]]\nfor i in range(10 ** 5):\n    a = f[-1][0] + f[-2][0]\n    b = f[-1][1] + f[-2][1]\n    f.append([a, b])\nfor _ in range(int(input())):\n    n = int(input())\n    ans = f[n][0] % mod * pow(2, (f[n][1] - 1) % (mod - 1), mod) % mod\n    print(ans)", "from sys import stdin, stdout\ninput = stdin.readline\nmod = 10 ** 9 + 7\nN = 10 ** 5 + 5\ndp = [0 for i in range(N + 1)]\ndp[1] = 1\ndp2 = [0 for i in range(N + 1)]\ndp2[1] = 1\ndp2[0] = 1\nfor i in range(2, N + 1):\n    dp[i] = dp[i - 1] + dp[i - 2]\n    dp2[i] = dp2[i - 1] * dp2[i - 2] * 2\n    dp[i] %= mod\n    dp2[i] %= mod\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = dp[n]\n    b = dp2[n]\n    print(a * b % mod)", "t = int(input())\narr = [0] * 100002\narr[1] = 1\nM = 10 ** 9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nfor i in range(2, 100002):\n    arr[i] = arr[i - 1] + arr[i - 2]\nfor test in range(t):\n    n = int(input())\n    if n == 1:\n        print('1')\n        continue\n    n_d = (arr[n + 1] - 1) % (M - 1)\n    n_1 = arr[n]\n    n_d = n_d % (M - 1)\n    ans = power(2, n_d, M)\n    ans = ans * n_1 % M\n    print(ans)", "def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nt = int(input())\nmodulo = 1000000007\ncases = []\nfor _ in range(t):\n    cases.append(int(input()))\nmax_known = 1\nmax_n = max(cases)\nones = [0] * (max_n + 1)\ndigits = [2] * (max_n + 1)\nones[1] = 1\nfor n in cases:\n    for i in range(max_known + 1, n + 1):\n        ones[i] = (ones[i - 1] + ones[i - 2]) % modulo\n        digits[i] = digits[i - 1] * digits[i - 2] % modulo\n    max_known = max(n, max_known)\n    print(ones[n] * digits[n] * modinv(2, modulo) % modulo)", "dp = [0] * (100000 + 2)\nfibPow = [0] * (100000 + 2)\nfibPow[0] = 2\nfibPow[1] = 2\ndp[1] = 1\nm = 1000000007\nfor i in range(2, 100000 + 2):\n    fibPow[i] = fibPow[i - 1] * fibPow[i - 2] % m\n    dp[i] = (dp[i - 1] * fibPow[i - 2] % m + dp[i - 2] * fibPow[i - 1] % m) % m\nfor _ in range(int(input())):\n    n = int(input())\n    print(dp[n])", "from sys import stdin, stdout\ninput = stdin.readline\nmod = 10 ** 9 + 7\nN = 10 ** 5 + 5\nmod2 = 1000000006\ndp = [0 for i in range(N + 1)]\ndp[1] = 1\ndp2 = [0 for i in range(N + 1)]\ndp2[1] = 1\ndp2[0] = 1\nfor i in range(2, N + 1):\n    dp[i] = dp[i - 1] + dp[i - 2]\n    dp2[i] = dp2[i - 1] + dp2[i - 2]\n    dp[i] %= mod\n    dp2[i] %= mod2\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = dp[n]\n    b = pow(2, (dp2[n] - 1) % mod2, mod)\n    print(a * b % mod)", "T = int(input())\nmemo = [1, 1]\ntotal = [0, 1]\nmod = 1000000007\nfor t in range(T):\n    N = int(input())\n    for i in range(len(memo), N + 1):\n        memo.append(memo[-1] * memo[-2] * 2 % mod)\n        total.append((total[-1] + total[-2]) % mod)\n    print(memo[N] * total[N] % mod)", "import sys\nfrom bisect import bisect_left as lb\nfrom collections import deque\nfrom queue import PriorityQueue as pq\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\ninv = lambda x: pow(x, mod - 2, mod)\nmod = 10 ** 9 + 7\nmx = 10 ** 6 + 10\nans = [0 for i in range(mx)]\nans[0] = 0\nans[1] = 1\n(o, z) = (1, 0)\n(o1, z1) = (0, 1)\n(t, t1) = (2, 2)\nflag = pow(2, mod - 2, mod)\nfor i in range(2, mx):\n    (fl, fl1) = (o, z)\n    o += o1\n    z += z1\n    o %= mod\n    z %= mod\n    o1 = fl\n    z1 = fl1\n    fl = t\n    t = t * t1 % mod\n    t1 = fl\n    ans[i] = t * flag % mod * o % mod\nfor _ in range(ii()):\n    n = ii()\n    print(ans[n])", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\n\ndef dfs(a, b, p, c):\n    if a == b:\n        return c\n    for (i, j) in adj[a]:\n        if i == p:\n            continue\n        temp = dfs(i, b, a, c + j)\n        if dfs(i, b, a):\n            mx = max(i, mx)\n            return 1\n    return tot\nans = [0] * 100005\nans[0] = 0\nans[1] = 1\n(one, zero) = (1, 0)\n(one1, zero1) = (0, 1)\n(tt1, tt2) = (2, 2)\nfor i in range(2, 100004):\n    (temp1, temp2) = (one, zero)\n    one += one1\n    one %= mod\n    zero += zero1\n    zero %= mod\n    one1 = temp1\n    zero1 = temp2\n    temp = tt1\n    tt1 = tt1 * tt2 % mod\n    tt2 = temp\n    ans[i] = tt1 * 500000004 % mod * one\n    ans[i] %= mod\n\ndef hnbhai(tc):\n    n = sb()\n    print(ans[n])\nfor _ in range(sb()):\n    hnbhai(_ + 1)", "mod = 10 ** 9 + 7\nfib = [(1, 0), (1, 1)]\nfor _ in range(10 ** 5):\n    fib.append((2 * fib[-2][0] * fib[-1][0] % mod, (fib[-2][1] + fib[-1][1]) % mod))\nfor _ in range(int(input())):\n    n = int(input())\n    (val, uns) = fib[n]\n    print(uns * val % mod)", "dp = [0] * (100000 + 2)\nfibPow = [0] * (100000 + 2)\nfibPow[0] = 2\nfibPow[1] = 2\ndp[1] = 1\nm = 1000000007\nfor i in range(2, 100000 + 2):\n    fibPow[i] = fibPow[i - 1] * fibPow[i - 2] % m\n    dp[i] = (dp[i - 1] * fibPow[i - 2] % m + dp[i - 2] * fibPow[i - 1] % m) % m\nfor _ in range(int(input())):\n    n = int(input())\n    print(dp[n])", "dp = [0] * (100000 + 2)\nfibPow = [0] * (100000 + 2)\nfibPow[0] = 2\nfibPow[1] = 2\ndp[1] = 1\nm = 1000000007\nfor i in range(2, 100000 + 2):\n    fibPow[i] = fibPow[i - 1] * fibPow[i - 2] % m\n    dp[i] = (dp[i - 1] * fibPow[i - 2] % m + dp[i - 2] * fibPow[i - 1] % m) % m\nfor _ in range(int(input())):\n    n = int(input())\n    print(dp[n])", "MOD = 10 ** 9 + 7\n\ndef fib(n):\n    f = [0, 1]\n    pc = [1, 2]\n    (a, b) = (0, 1)\n    (c, d) = (1, 2)\n    for i in range(2, n):\n        (a, b) = (b, a + b)\n        (c, d) = (d, c * d % MOD)\n        f.append(b)\n        pc.append(d)\n    return (pc, f)\n(PC, F) = fib(10 ** 5 + 2)\n\ndef calc3(n):\n    (z, o) = (F[n - 1], F[n])\n    j = o % MOD * PC[n + 1]\n    if j & 1:\n        j += MOD\n    return j // 2 % MOD\nfor _ in range(int(input())):\n    n = int(input())\n    print(calc3(n))", "from sys import stdin\ninput = stdin.readline\nmod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef div(a, b):\n    return mul(a, pow(b, mod - 2, mod))\n\ndef pre():\n    size = 10 ** 5 + 1\n    for i in range(2, size):\n        dp1.append(add(dp1[-1], dp1[-2]))\n        dp.append(mul(dp[-1], dp[-2]))\n        x = div(dp[-1], 2)\n        ans.append(mul(dp1[-1], x))\nans = [0, 1]\ndp1 = [0, 1]\ndp = [2, 2]\npre()\n\ndef answer():\n    return ans[n]\nfor T in range(int(input())):\n    n = int(input())\n    print(answer())"]