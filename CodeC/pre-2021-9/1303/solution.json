["import heapq\nt = int(input())\n\ndef f(arr, n, k, c):\n    ans = 0\n    i = 0\n    while arr[i] == c and i < n:\n        ans += 1\n        i += 1\n    if i >= n:\n        return n\n    j = n - 1\n    while arr[j] == c:\n        ans += 1\n        j -= 1\n    if k == 0 and ans != n:\n        return -1\n    if k == 1:\n        return ans\n    h = []\n    heapq.heapify(h)\n    index = i\n    temp = 0\n    for m in range(i, j + 1):\n        if arr[m] == c:\n            temp += 1\n        else:\n            if temp > 0:\n                heapq.heappush(h, -1 * temp)\n            temp = 0\n    while k > 1 and len(h) > 0:\n        ans += -1 * heapq.heappop(h)\n        k -= 1\n    if ans == 0:\n        return -1\n    else:\n        return ans\nfor i in range(t):\n    (n, k) = [int(i) for i in input().strip().split()]\n    arr = input().strip()\n    if arr == arr[0] * n:\n        print(n)\n        continue\n    if k == 0:\n        print(-1)\n        continue\n    print(max([f(arr, n, k, chr(j)) for j in range(ord('A'), ord('Z') + 1)]))", "import heapq\nt = int(input())\n\ndef f(arr, n, k, c):\n    ans = 0\n    i = 0\n    while arr[i] == c and i < n:\n        ans += 1\n        i += 1\n    if i >= n:\n        return n\n    j = n - 1\n    while arr[j] == c:\n        ans += 1\n        j -= 1\n    if k == 0 and ans != n:\n        return -1\n    if k == 1:\n        return ans\n    h = []\n    heapq.heapify(h)\n    index = i\n    temp = 0\n    for m in range(i, j + 1):\n        if arr[m] == c:\n            temp += 1\n        else:\n            if temp > 0:\n                heapq.heappush(h, -1 * temp)\n            temp = 0\n    while k > 1 and len(h) > 0:\n        ans += -1 * heapq.heappop(h)\n        k -= 1\n    if ans == 0:\n        return -1\n    else:\n        return ans\nfor i in range(t):\n    (n, k) = [int(i) for i in input().strip().split()]\n    arr = input().strip()\n    if arr == arr[0] * n:\n        print(n)\n        continue\n    if k == 0:\n        print(-1)\n        continue\n    print(max([f(arr, n, k, chr(j)) for j in range(ord('A'), ord('Z') + 1)]))", "import heapq\nt = int(input())\n\ndef f(arr, n, k, c):\n    ans = 0\n    i = 0\n    while arr[i] == c and i < n:\n        ans += 1\n        i += 1\n    if i >= n:\n        return n\n    j = n - 1\n    while arr[j] == c:\n        ans += 1\n        j -= 1\n    if k == 0 and ans != n:\n        return -1\n    if k == 1:\n        return ans\n    h = []\n    heapq.heapify(h)\n    index = i\n    temp = 0\n    for m in range(i, j + 1):\n        if arr[m] == c:\n            temp += 1\n        else:\n            if temp > 0:\n                heapq.heappush(h, -1 * temp)\n            temp = 0\n    while k > 1 and len(h) > 0:\n        ans += -1 * heapq.heappop(h)\n        k -= 1\n    if ans == 0:\n        return -1\n    else:\n        return ans\nfor i in range(t):\n    (n, k) = [int(i) for i in input().strip().split()]\n    arr = input().strip()\n    if arr == arr[0] * n:\n        print(n)\n        continue\n    if k == 0:\n        print(-1)\n        continue\n    print(max([f(arr, n, k, chr(j)) for j in range(ord('A'), ord('Z') + 1)]))", "import heapq\nt = int(input())\n\ndef f(arr, n, k, c):\n    ans = 0\n    i = 0\n    while arr[i] == c and i < n:\n        ans += 1\n        i += 1\n    if i >= n:\n        return n\n    j = n - 1\n    while arr[j] == c:\n        ans += 1\n        j -= 1\n    if k == 0 and ans != n:\n        return -1\n    if k == 1:\n        return ans\n    h = []\n    heapq.heapify(h)\n    index = i\n    temp = 0\n    for m in range(i, j + 1):\n        if arr[m] == c:\n            temp += 1\n        else:\n            if temp > 0:\n                heapq.heappush(h, -1 * temp)\n            temp = 0\n    while k > 1 and len(h) > 0:\n        ans += -1 * heapq.heappop(h)\n        k -= 1\n    if ans == 0:\n        return -1\n    else:\n        return ans\nfor i in range(t):\n    (n, k) = [int(i) for i in input().strip().split()]\n    arr = input().strip()\n    if arr == arr[0] * n:\n        print(n)\n        continue\n    if k == 0:\n        print(-1)\n        continue\n    print(max([f(arr, n, k, chr(j)) for j in range(ord('A'), ord('Z') + 1)]))", "import heapq\nt = int(input())\n\ndef f(arr, n, k, c):\n    ans = 0\n    i = 0\n    while arr[i] == c and i < n:\n        ans += 1\n        i += 1\n    if i >= n:\n        return n\n    j = n - 1\n    while arr[j] == c:\n        ans += 1\n        j -= 1\n    if k == 0 and ans != n:\n        return -1\n    if k == 1:\n        return ans\n    h = []\n    heapq.heapify(h)\n    index = i\n    temp = 0\n    for m in range(i, j + 1):\n        if arr[m] == c:\n            temp += 1\n        else:\n            if temp > 0:\n                heapq.heappush(h, -1 * temp)\n            temp = 0\n    while k > 1 and len(h) > 0:\n        ans += -1 * heapq.heappop(h)\n        k -= 1\n    if ans == 0:\n        return -1\n    else:\n        return ans\nfor i in range(t):\n    (n, k) = [int(i) for i in input().strip().split()]\n    arr = input().strip()\n    if arr == arr[0] * n:\n        print(n)\n        continue\n    if k == 0:\n        print(-1)\n        continue\n    print(max([f(arr, n, k, chr(j)) for j in range(ord('A'), ord('Z') + 1)]))", "import heapq\nt = int(input())\n\ndef f(arr, n, k, c):\n    ans = 0\n    i = 0\n    while arr[i] == c and i < n:\n        ans += 1\n        i += 1\n    if i >= n:\n        return n\n    j = n - 1\n    while arr[j] == c:\n        ans += 1\n        j -= 1\n    if k == 0 and ans != n:\n        return -1\n    if k == 1:\n        return ans\n    h = []\n    heapq.heapify(h)\n    index = i\n    temp = 0\n    for m in range(i, j + 1):\n        if arr[m] == c:\n            temp += 1\n        else:\n            if temp > 0:\n                heapq.heappush(h, -1 * temp)\n            temp = 0\n    while k > 1 and len(h) > 0:\n        ans += -1 * heapq.heappop(h)\n        k -= 1\n    if ans == 0:\n        return -1\n    else:\n        return ans\nfor i in range(t):\n    (n, k) = [int(i) for i in input().strip().split()]\n    arr = input().strip()\n    if arr == arr[0] * n:\n        print(n)\n        continue\n    if k == 0:\n        print(-1)\n        continue\n    print(max([f(arr, n, k, chr(j)) for j in range(ord('A'), ord('Z') + 1)]))", "from heapq import heapify, heappush, heappop\n\ndef f(arr, n, k, c):\n    ans = 0\n    i = 0\n    while arr[i] == c and i < n:\n        ans += 1\n        i += 1\n    if i >= n:\n        return n\n    j = n - 1\n    while arr[j] == c:\n        ans += 1\n        j -= 1\n    if not k and ans != n:\n        return -1\n    if k == 1:\n        return ans\n    h = []\n    heapify(h)\n    index = i\n    temp = 0\n    for m in range(i, j + 1):\n        if arr[m] == c:\n            temp += 1\n        else:\n            if temp > 0:\n                heappush(h, -1 * temp)\n            temp = 0\n    while k > 1 and len(h):\n        ans += -1 * heappop(h)\n        k -= 1\n    return -1 if not ans else ans\nfor i in range(int(input())):\n    (n, k) = [int(i) for i in input().strip().split()]\n    arr = input().strip()\n    if len(set(arr)) == 1:\n        print(n)\n        continue\n    if not k:\n        print(-1)\n        continue\n    print(max([f(arr, n, k, chr(j)) for j in range(ord('A'), ord('Z') + 1)]))", "import heapq\nt = int(input())\n\ndef f(arr, n, k, c):\n    ans = 0\n    i = 0\n    while arr[i] == c and i < n:\n        ans += 1\n        i += 1\n    if i >= n:\n        return n\n    j = n - 1\n    while arr[j] == c:\n        ans += 1\n        j -= 1\n    if k == 0 and ans != n:\n        return -1\n    if k == 1:\n        return ans\n    h = []\n    heapq.heapify(h)\n    index = i\n    temp = 0\n    for m in range(i, j + 1):\n        if arr[m] == c:\n            temp += 1\n        else:\n            if temp > 0:\n                heapq.heappush(h, -1 * temp)\n            temp = 0\n    while k > 1 and len(h) > 0:\n        ans += -1 * heapq.heappop(h)\n        k -= 1\n    if ans == 0:\n        return -1\n    else:\n        return ans\nfor i in range(t):\n    (n, k) = [int(i) for i in input().strip().split()]\n    arr = input().strip()\n    if arr == arr[0] * n:\n        print(n)\n        continue\n    if k == 0:\n        print(-1)\n        continue\n    print(max([f(arr, n, k, chr(j)) for j in range(ord('A'), ord('Z') + 1)]))", "from collections import defaultdict\n\ndef ret():\n    return []\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    d = defaultdict(ret)\n    s = list(input())\n    ans = 0\n    start = 0\n    (prev, cnt) = (s[0], 0)\n    for i in range(1, n):\n        if s[i] != prev:\n            if start:\n                d[prev].append(i - cnt)\n            else:\n                start = i - cnt\n            (prev, cnt) = (s[i], i)\n    end = n - cnt\n    l = [chr(i) for i in range(65, 65 + 26)]\n    for i in l:\n        cnt = 0\n        d[i].sort(reverse=True)\n        if i == s[0] and i == s[n - 1]:\n            cnt = end + start\n        elif i == s[n - 1]:\n            cnt = end\n        elif i == s[0]:\n            cnt = start\n        if k > 0:\n            temp = k - 1\n            if temp >= len(d[i]):\n                cnt = cnt + sum(d[i])\n            else:\n                cnt = cnt + sum(d[i][:temp])\n            ans = max(ans, cnt)\n    s = set(s)\n    if len(s) == 1:\n        ans = n\n    if ans == 0:\n        print(-1)\n    else:\n        print(ans)", "from collections import defaultdict\n\ndef ret():\n    return []\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    d = defaultdict(ret)\n    s = list(input())\n    ans = 0\n    start = 0\n    (prev, cnt) = (s[0], 0)\n    for i in range(1, n):\n        if s[i] != prev:\n            if start:\n                d[prev].append(i - cnt)\n            else:\n                start = i - cnt\n            (prev, cnt) = (s[i], i)\n    end = n - cnt\n    l = [chr(i) for i in range(65, 65 + 26)]\n    for i in l:\n        cnt = 0\n        d[i].sort(reverse=True)\n        if i == s[0] and i == s[n - 1]:\n            cnt = end + start\n        elif i == s[n - 1]:\n            cnt = end\n        elif i == s[0]:\n            cnt = start\n        if k > 0:\n            temp = k - 1\n            if temp >= len(d[i]):\n                cnt = cnt + sum(d[i])\n            else:\n                cnt = cnt + sum(d[i][:temp])\n            ans = max(ans, cnt)\n    s = set(s)\n    if len(s) == 1:\n        ans = n\n    if ans == 0:\n        print(-1)\n    else:\n        print(ans)", "import sys\n\ndef read():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read())\n\ndef read_arr():\n    return read().split()\n\ndef read_int_arr():\n    return list(map(int, read_arr()))\n\ndef out_str_list(l):\n    sys.stdout.write(' '.join(l) + '\\n')\n\ndef out_nonstr_list(l):\n    sys.stdout.write(' '.join(list(map(str, l))) + '\\n')\n\ndef out_str(s):\n    sys.stdout.write(s + '\\n')\n\ndef out_nonstr(i):\n    sys.stdout.write(str(i) + '\\n')\nfor _ in range(int(read())):\n    (n, k) = read_int_arr()\n    pants = read()\n    if k == 0 and pants != pants[0] * n:\n        out_nonstr(-1)\n        continue\n    elif pants == pants[0] * n:\n        out_nonstr(n)\n        continue\n    all_colors = {}\n    prev = -1\n    for p in pants:\n        if p != prev:\n            try:\n                all_colors[p].append(0)\n            except KeyError:\n                all_colors[p] = [0]\n            count = 0\n            prev = p\n        try:\n            all_colors[p][-1] += 1\n        except KeyError:\n            all_colors[p] = [0]\n    front_bonus = [pants[0], all_colors[pants[0]][0]]\n    end_bonus = [pants[-1], all_colors[pants[-1]][-1]]\n    colors = list(all_colors.keys())\n    m = 0\n    for color in colors:\n        count = 0\n        s = all_colors[color]\n        s.sort()\n        if front_bonus[0] == color:\n            count = front_bonus[1]\n            s.remove(front_bonus[1])\n        if end_bonus[0] == color:\n            count += end_bonus[1]\n            s.remove(end_bonus[1])\n        available = k - 1\n        if len(s) <= available:\n            count += sum(s)\n        else:\n            count += sum(s[len(s) - available:len(s)])\n        if count > m:\n            m = count\n    out_nonstr(m)", "import heapq\nt = int(input())\n\ndef f(arr, n, k, c):\n    ans = 0\n    i = 0\n    while arr[i] == c and i < n:\n        ans += 1\n        i += 1\n    if i >= n:\n        return n\n    j = n - 1\n    while arr[j] == c:\n        ans += 1\n        j -= 1\n    if k == 0 and ans != n:\n        return -1\n    if k == 1:\n        return ans\n    h = []\n    heapq.heapify(h)\n    index = i\n    temp = 0\n    for m in range(i, j + 1):\n        if arr[m] == c:\n            temp += 1\n        else:\n            if temp > 0:\n                heapq.heappush(h, -1 * temp)\n            temp = 0\n    while k > 1 and len(h) > 0:\n        ans += -1 * heapq.heappop(h)\n        k -= 1\n    if ans == 0:\n        return -1\n    else:\n        return ans\nfor i in range(t):\n    (n, k) = [int(i) for i in input().strip().split()]\n    arr = input().strip()\n    if arr == arr[0] * n:\n        print(n)\n        continue\n    if k == 0:\n        print(-1)\n        continue\n    ans = -1\n    for j in range(ord('A'), ord('Z') + 1):\n        c = chr(j)\n        ans = max(f(arr, n, k, c), ans)\n    print(ans)", "import math\nfrom heapq import heappush, heappop, heapify\nimport random\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000000 + 7\nmod2 = 998244353\nfor _ in range(I()):\n    (n, k) = M()\n    s = S()\n    m = -1\n    if k == 0:\n        if s != s[0] * n:\n            print(-1)\n        else:\n            print(n)\n        continue\n    for i in range(26):\n        c = chr(i + 65)\n        if s == c * n:\n            m = n\n            break\n        r = j = 0\n        if s[0] == c:\n            while j < n and s[j] == c:\n                j += 1\n        r += j\n        t1 = j\n        j = n - 1\n        q = []\n        while j >= 0 and s[j] == c:\n            j -= 1\n        r += n - j - 1\n        t2 = j\n        j = t1\n        while j <= t2:\n            if s[j] != c:\n                j += 1\n                continue\n            p = j\n            while p < t2 and s[p] == c:\n                p += 1\n            q.append(p - j)\n            j = p\n        if len(q) + 1 <= k:\n            m = max(m, s.count(c))\n        else:\n            m = max(m, sum(sorted(q, reverse=True)[:k - 1]) + r)\n    print(m)", "from math import *\nimport sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    s = input()\n    ans = 0\n    if s[0] * n == s:\n        print(n)\n    elif k == 0:\n        print(-1)\n    else:\n        dist_pant = list(set(list(s)))\n        for _same in dist_pant:\n            l = [0] * n\n            for i in range(n):\n                if s[i] == _same:\n                    l[i] = 1\n            cur_ans = 0\n            diff_start = -1\n            diff_end = -1\n            for i in range(n):\n                if s[i] != _same:\n                    diff_start = i\n                    break\n                else:\n                    cur_ans += 1\n            for i in range(n - 1, -1, -1):\n                if s[i] != _same:\n                    diff_end = i\n                    break\n                else:\n                    cur_ans += 1\n            block = []\n            cur = 0\n            for j in range(diff_start, diff_end + 1):\n                if l[j] == 1:\n                    cur += 1\n                else:\n                    if cur != 0:\n                        block.append(cur)\n                    cur = 0\n            if cur != 0:\n                block.append(cur)\n            block.sort()\n            if k != 1:\n                cur_ans += sum(block[-(k - 1):])\n            ans = max(ans, cur_ans)\n        if ans == 0:\n            print(-1)\n        else:\n            print(ans)", "import collections\nT = int(input())\nfor t in range(T):\n    (N, K) = map(int, input().split())\n    S = input().strip()\n    if len(set(S)) == 1:\n        print(N)\n        continue\n    if K == 0:\n        print(-1)\n        continue\n    cnt2 = collections.defaultdict(list)\n    x = S[0]\n    i = 0\n    for (j, c) in enumerate(S):\n        if c != x:\n            cnt2[x].append((i, j - 1))\n            i = j\n        x = c\n    cnt2[x].append((i, N - 1))\n    for color in cnt2:\n        cnt2[color] = sorted(cnt2[color], key=lambda x: x[1] - x[0])\n    ans = 0\n    for (color, groups) in cnt2.items():\n        ans1 = 0\n        if color == S[0]:\n            flag = False\n            for (i, j) in groups:\n                if i == 0:\n                    flag = True\n                    break\n            if flag:\n                ans1 += j - i + 1\n                groups.remove((i, j))\n        if color == S[-1]:\n            flag = False\n            for (i, j) in groups:\n                if j == N - 1:\n                    flag = True\n                    break\n            if flag:\n                ans1 += j - i + 1\n                groups.remove((i, j))\n        ans1 += sum(map(lambda x: x[1] - x[0] + 1, groups[-1:-K:-1]))\n        ans = max(ans, ans1)\n    print(ans)", "T = int(input())\nfor i in range(T):\n    (N, K) = map(int, input().split(' '))\n    S = list(str(input()))\n    ascii_code_A = 65\n    if N == 1:\n        print(N)\n    elif K == 0:\n        r = S[0]\n        if S.count(r) != N:\n            print(-1)\n        else:\n            print(N)\n    elif K == 1:\n        lr = 0\n        tc1 = 0\n        while lr < N and S[lr] == S[0]:\n            lr += 1\n            tc1 += 1\n        rr = N - 1\n        tc2 = 0\n        while rr > -1 and S[rr] == S[N - 1]:\n            rr -= 1\n            tc2 += 1\n        if rr == -1:\n            print(N)\n        elif S[0] == S[N - 1]:\n            print(tc1 + tc2)\n        else:\n            print(max(tc1, tc2))\n    else:\n        blocks = [[] for theta in range(26)]\n        spec_val_left = ord(S[0]) - 65\n        spec_val_right = ord(S[N - 1]) - 65\n        lval_spec = 0\n        rval_spec = 0\n        counter = 0\n        cur = S[0]\n        cur_block_size = 0\n        yval = False\n        while counter < N:\n            if S[counter] == cur:\n                cur_block_size += 1\n                counter += 1\n            elif yval:\n                val = ord(cur) - 65\n                blocks[val].append(cur_block_size)\n                cur_block_size = 0\n                cur = S[counter]\n            else:\n                yval = True\n                lval_spec = cur_block_size\n                cur_block_size = 0\n                cur = S[counter]\n        rval_spec = cur_block_size\n        tc = [0 for gamma in range(26)]\n        for kappa in range(26):\n            l = len(blocks[kappa])\n            blocks[kappa].sort(reverse=True)\n            temp_count = 0\n            while temp_count < l and temp_count < K - 1:\n                tc[kappa] += blocks[kappa][temp_count]\n                temp_count += 1\n            if kappa == spec_val_left:\n                tc[kappa] += lval_spec\n            if kappa == spec_val_right:\n                tc[kappa] += rval_spec\n        print(max(tc))", "from sys import stdin\ninput = stdin.readline\n\ndef solve(ch, moves):\n    ans = 0\n    (i, count) = (0, 0)\n    while i < n and a[i] == ch:\n        count += 1\n        i += 1\n    ans += count\n    if i == n:\n        return ans\n    (end, count) = (n - 1, 0)\n    while end >= 0 and a[end] == ch:\n        count += 1\n        end -= 1\n    ans += count\n    if moves == 0:\n        return -1\n    moves -= 1\n    take = []\n    while i < end:\n        count = 0\n        while i < end and a[i] == ch:\n            count += 1\n            i += 1\n        if count:\n            take.append(count)\n        i += 1\n    take.sort(reverse=True)\n    for opp in range(min(len(take), moves)):\n        ans += take[opp]\n    return ans\n\ndef answer():\n    ans = -1\n    for i in range(26):\n        ans = max(ans, solve(chr(65 + i), k))\n    return ans\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = input().strip()\n    print(answer())", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    if k == 0:\n        f = 0\n        for i in range(n - 1):\n            if s[i] != s[i + 1]:\n                f = 1\n                break\n        if f == 0:\n            print(n)\n        else:\n            print(-1)\n    else:\n        li = []\n        for i in range(26):\n            a = chr(i + 65)\n            ci = []\n            c = 0\n            f = 0\n            for i in range(n):\n                if s[i] == a:\n                    c = c + 1\n                else:\n                    if c != 0:\n                        ci.append(c)\n                    c = 0\n            ci.append(c)\n            if s[0] == a and s[n - 1] == a:\n                if len(ci) == 1:\n                    c = ci[0]\n                else:\n                    c = ci[0] + ci[-1]\n                (ci[0], ci[-1]) = (0, 0)\n            elif s[0] != a and s[n - 1] != a:\n                c = 0\n            elif s[0] == a:\n                c = ci[0]\n                ci[0] = 0\n            elif s[n - 1] == a:\n                c = ci[-1]\n                ci[-1] = 0\n            ai = [0, c]\n            ci.sort(reverse=True)\n            c = c + ci[0]\n            ai.append(c)\n            for i in range(1, len(ci)):\n                c = c + ci[i]\n                ai.append(c)\n            li.append(ai)\n        ans = 0\n        for i in range(26):\n            if len(li[i]) <= k:\n                ans = max(ans, li[i][-1])\n            else:\n                ans = max(ans, li[i][k])\n        if ans == 0:\n            print(-1)\n        else:\n            print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    if k == 0:\n        f = 0\n        for i in range(n - 1):\n            if s[i] != s[i + 1]:\n                f = 1\n                break\n        if f == 0:\n            print(n)\n        else:\n            print(-1)\n    else:\n        li = []\n        for i in range(26):\n            a = chr(i + 65)\n            ci = []\n            c = 0\n            f = 0\n            for i in range(n):\n                if s[i] == a:\n                    c = c + 1\n                else:\n                    if c != 0:\n                        ci.append(c)\n                    c = 0\n            ci.append(c)\n            if s[0] == a and s[n - 1] == a:\n                if len(ci) == 1:\n                    c = ci[0]\n                else:\n                    c = ci[0] + ci[-1]\n                (ci[0], ci[-1]) = (0, 0)\n            elif s[0] != a and s[n - 1] != a:\n                c = 0\n            elif s[0] == a:\n                c = ci[0]\n                ci[0] = 0\n            elif s[n - 1] == a:\n                c = ci[-1]\n                ci[-1] = 0\n            ai = [0, c]\n            ci.sort(reverse=True)\n            c = c + ci[0]\n            ai.append(c)\n            for i in range(1, len(ci)):\n                c = c + ci[i]\n                ai.append(c)\n            li.append(ai)\n        ans = 0\n        for i in range(26):\n            if len(li[i]) <= k:\n                ans = max(ans, li[i][-1])\n            else:\n                ans = max(ans, li[i][k])\n        if ans == 0:\n            print(-1)\n        else:\n            print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    if k == 0:\n        f = 0\n        for i in range(n - 1):\n            if s[i] != s[i + 1]:\n                f = 1\n                break\n        if f == 0:\n            print(n)\n        else:\n            print(-1)\n    else:\n        li = []\n        for i in range(26):\n            a = chr(i + 65)\n            ci = []\n            c = 0\n            f = 0\n            for i in range(n):\n                if s[i] == a:\n                    c = c + 1\n                else:\n                    if c != 0:\n                        ci.append(c)\n                    c = 0\n            ci.append(c)\n            if s[0] == a and s[n - 1] == a:\n                if len(ci) == 1:\n                    c = ci[0]\n                else:\n                    c = ci[0] + ci[-1]\n                (ci[0], ci[-1]) = (0, 0)\n            elif s[0] != a and s[n - 1] != a:\n                c = 0\n            elif s[0] == a:\n                c = ci[0]\n                ci[0] = 0\n            elif s[n - 1] == a:\n                c = ci[-1]\n                ci[-1] = 0\n            ai = [0, c]\n            ci.sort(reverse=True)\n            c = c + ci[0]\n            ai.append(c)\n            for i in range(1, len(ci)):\n                c = c + ci[i]\n                ai.append(c)\n            li.append(ai)\n        ans = 0\n        for i in range(26):\n            if len(li[i]) <= k:\n                ans = max(ans, li[i][-1])\n            else:\n                ans = max(ans, li[i][k])\n        if ans == 0:\n            print(-1)\n        else:\n            print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    if ' ' in s:\n        temp = s.index(' ')\n        s = s[:temp]\n    cnt = s.count(s[0])\n    if cnt == n:\n        print(n)\n        continue\n    if k == 0:\n        print(-1)\n        continue\n    a = []\n    for i in range(26):\n        a.append([])\n    for i in range(n):\n        pos = ord(s[i]) - 65\n        if len(a[pos]) == 0:\n            a[pos].append([1, i, i])\n        elif a[pos][-1][2] + 1 == i:\n            a[pos][-1][0] += 1\n            a[pos][-1][2] = i\n        else:\n            a[pos].append([1, i, i])\n    ans = 0\n    for i in range(26):\n        curr = 0\n        x = chr(i + 65)\n        if x != s[0] and x != s[-1]:\n            chance = k - 1\n            a[i].sort(reverse=True)\n            for j in range(min(len(a[i]), chance)):\n                curr += a[i][j][0]\n        elif x == s[0] and x != s[-1]:\n            curr = a[i][0][0]\n            a[i].sort(reverse=True)\n            chance = k - 1\n            j = 0\n            pos = 0\n            while pos < chance:\n                if j == len(a[i]):\n                    break\n                if a[i][j][1] == 0:\n                    j += 1\n                    continue\n                curr += a[i][j][0]\n                j += 1\n                pos += 1\n        elif x != s[0] and x == s[-1]:\n            curr = a[i][-1][0]\n            a[i].sort(reverse=True)\n            chance = k - 1\n            j = 0\n            pos = 0\n            while pos < chance:\n                if j == len(a[i]):\n                    break\n                if a[i][j][2] == n - 1:\n                    j += 1\n                    continue\n                curr += a[i][j][0]\n                j += 1\n                pos += 1\n        else:\n            curr = a[i][-1][0]\n            curr += a[i][0][0]\n            chance = k - 1\n            a[i].sort(reverse=True)\n            j = 0\n            pos = 0\n            while pos < chance:\n                if j == len(a[i]):\n                    break\n                if a[i][j][2] == n - 1 or a[i][j][1] == 0:\n                    j += 1\n                    continue\n                curr += a[i][j][0]\n                j += 1\n                pos += 1\n        if curr == -1:\n            continue\n        else:\n            ans = max(ans, curr)\n    print(ans)", "from string import ascii_uppercase\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s2 = input().strip()\n    if k == 0:\n        if len(set(s2)) == 1:\n            print(n)\n        else:\n            print(-1)\n        continue\n    maxi = 0\n    for ch in set(s2):\n        s = s2.strip(ch)\n        cur = len(s2) - len(s)\n        n = len(s)\n        l = []\n        d = 0\n        for i in range(n):\n            if s[i] == ch:\n                d += 1\n            elif d != 0:\n                l.append(d)\n                d = 0\n        if d != 0:\n            l.append(d)\n        l.sort()\n        i = len(l)\n        for _ in range(k - 1):\n            i -= 1\n            if i < 0:\n                break\n            cur += l[i]\n        if cur > maxi:\n            maxi = cur\n    print(maxi)"]