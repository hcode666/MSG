["T = int(input())\nfor _ in range(T):\n    (H, W) = [int(x) for x in input().split()]\n    A = [input().split() for row in range(H)]\n    exits = [(R, C, int(A[R][C])) for R in range(H) for C in range(W) if A[R][C] != '0' and A[R][C] != '-1']\n    B = [[False if A[R][C] != '-1' else True for C in range(W)] for R in range(H)]\n    if len(exits) == 0:\n        for row in F:\n            print(''.join(row))\n    exits.sort(key=lambda x: x[2], reverse=True)\n    tilesToCheck = set()\n    for timeLeft in range(0, exits[0][2] + 1)[::-1]:\n        while len(exits) > 0 and exits[0][2] == timeLeft:\n            newExit = exits.pop(0)\n            (R, C, Q) = newExit\n            tilesToCheck.add((R, C))\n            B[R][C] = True\n        tilesToCheckNextStep = set()\n        for tileToCheck in tilesToCheck:\n            (R, C) = tileToCheck\n            if R != 0 and (not B[R - 1][C]):\n                tilesToCheckNextStep.add((R - 1, C))\n            if C != W - 1 and (not B[R][C + 1]):\n                tilesToCheckNextStep.add((R, C + 1))\n            if R != H - 1 and (not B[R + 1][C]):\n                tilesToCheckNextStep.add((R + 1, C))\n            if C != 0 and (not B[R][C - 1]):\n                tilesToCheckNextStep.add((R, C - 1))\n            B[R][C] = True\n        tilesToCheck = tilesToCheckNextStep\n    for R in range(H):\n        for C in range(W):\n            if B[R][C] == True:\n                B[R][C] = 'Y'\n            elif B[R][C] == False:\n                B[R][C] = 'N'\n    for R in range(H):\n        for C in range(W):\n            if A[R][C] == '-1':\n                B[R][C] = 'B'\n    for row in B:\n        print(''.join(row))", "T = int(input())\nfor _ in range(T):\n    (H, W) = [int(x) for x in input().split()]\n    A = [input().split() for row in range(H)]\n    exits = [(R, C, int(A[R][C])) for R in range(H) for C in range(W) if A[R][C] != '0' and A[R][C] != '-1']\n    B = [[False if A[R][C] != '-1' else True for C in range(W)] for R in range(H)]\n    if len(exits) == 0:\n        for row in F:\n            print(''.join(row))\n    exits.sort(key=lambda x: x[2], reverse=True)\n    tilesToCheck = set()\n    for timeLeft in range(0, exits[0][2] + 1)[::-1]:\n        while len(exits) > 0 and exits[0][2] == timeLeft:\n            newExit = exits.pop(0)\n            (R, C, Q) = newExit\n            tilesToCheck.add((R, C))\n            B[R][C] = True\n        tilesToCheckNextStep = set()\n        for tileToCheck in tilesToCheck:\n            (R, C) = tileToCheck\n            if R != 0 and (not B[R - 1][C]):\n                tilesToCheckNextStep.add((R - 1, C))\n            if C != W - 1 and (not B[R][C + 1]):\n                tilesToCheckNextStep.add((R, C + 1))\n            if R != H - 1 and (not B[R + 1][C]):\n                tilesToCheckNextStep.add((R + 1, C))\n            if C != 0 and (not B[R][C - 1]):\n                tilesToCheckNextStep.add((R, C - 1))\n            B[R][C] = True\n        tilesToCheck = tilesToCheckNextStep\n    for R in range(H):\n        for C in range(W):\n            if B[R][C] == True:\n                B[R][C] = 'Y'\n            elif B[R][C] == False:\n                B[R][C] = 'N'\n    for R in range(H):\n        for C in range(W):\n            if A[R][C] == '-1':\n                B[R][C] = 'B'\n    for row in B:\n        print(''.join(row))"]