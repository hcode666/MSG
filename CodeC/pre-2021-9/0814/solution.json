["from operator import itemgetter\n\ndef solve(a, l, r):\n    ans = 0\n    interval = []\n    for i in range(n - 1, 0, -1):\n        (x, y) = (a[i] - a[i - 1] + 1, a[i] + a[i - 1] - 1)\n        interval.append([x, y])\n    interval.sort(key=itemgetter(0, 1))\n    for (x, y) in interval:\n        x = max(x, l)\n        y = min(y, r)\n        if y < x:\n            continue\n        ans += y - x + 1\n        l = y + 1\n        if l > r:\n            break\n    return ans\n(n, l, r) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nprint(solve(a, l, r))", "from operator import itemgetter\n\ndef solve(a, l, r):\n    ans = 0\n    interval = []\n    for i in range(n - 1, 0, -1):\n        (x, y) = (a[i] - a[i - 1] + 1, a[i] + a[i - 1] - 1)\n        interval.append([x, y])\n    interval.sort(key=itemgetter(0, 1))\n    for (x, y) in interval:\n        x = max(x, l)\n        y = min(y, r)\n        if y < x:\n            continue\n        ans += y - x + 1\n        l = y + 1\n        if l > r:\n            break\n    return ans\n(n, l, r) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nprint(solve(a, l, r))", "import sys\n(n, l, r) = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\narr.sort(reverse=True)\n(last, res) = (-1, 0)\nfor i in range(len(arr) - 1):\n    a = max(l, arr[i] - arr[i + 1] + 1)\n    b = min(r, arr[i] + arr[i + 1] - 1)\n    if a > b:\n        continue\n    if last == -1 or b < last:\n        res += b - a + 1\n        last = a\n    elif last > a:\n        res += last - a\n        last = a\nprint(res)", "import sys\n(n, l, r) = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\narr.sort(reverse=True)\n(last, res) = (-1, 0)\nfor i in range(len(arr) - 1):\n    a = max(l, arr[i] - arr[i + 1] + 1)\n    b = min(r, arr[i] + arr[i + 1] - 1)\n    if a > b:\n        continue\n    if last == -1 or b < last:\n        res += b - a + 1\n        last = a\n    elif last > a:\n        res += last - a\n        last = a\nprint(res)", "(a, n, m) = map(int, input().split())\nlist1 = [int(i) for i in input().split()]\nlist1.sort()\nans = 0\nfor i in range(a - 1, 0, -1):\n    (y, z) = (list1[i], list1[i - 1])\n    (lo, hi) = (y - z + 1, y + z - 1)\n    if m < lo or hi < n:\n        continue\n    if n >= lo and m <= hi:\n        ans += m - n + 1\n        break\n    ans += min(hi, m) - max(lo, n) + 1\n    m = max(lo, n) - 1\nprint(ans)", "(n, l, r) = map(int, input().split())\nlis = list(map(int, input().split()))\nlis.sort()\ns = []\ne = []\nfor i in range(n - 1):\n    s.append(1 + lis[i + 1] - lis[i])\n    e.append(lis[i + 1] + lis[i] - 1)\nlow = r + 1\nans = 0\ni = n - 2\nwhile i >= 0:\n    if s[i] > r or e[i] < l:\n        i -= 1\n        continue\n    s[i] = max(l, s[i])\n    e[i] = min(r, e[i])\n    if e[i] < low:\n        ans += 1 + e[i] - s[i]\n        low = s[i]\n    elif s[i] < low:\n        ans += low - s[i]\n        low = s[i]\n    i -= 1\nprint(ans)", "(x1, l, r) = map(int, input().split())\na = sorted(list(map(int, input().split())))\ne = len(a)\nfor i in range(e - 1, 0, -1):\n    if a[i] <= r:\n        w = min(a[i] + a[i - 1] - 1, r)\n        break\nt = l\nx = a[-1] + a[-2] - 1\nfor i in range(e - 1):\n    x = min(x, a[i + 1] - a[i] + 1)\n    x = max(l, x)\nprint(max(0, w - x + 1))", "a = input()\nb = input()\na = a.split()\na = [int(x) for x in a]\nb = b.split()\nb = [int(x) for x in b]\nb.sort()\nn = a[0]\nl = a[1]\nr = a[2]\nmini = b[-1] - b[-2] + 1\nfor i in range(0, n - 1):\n    if b[i + 1] - b[i] + 1 <= mini:\n        mini = b[i + 1] - b[i] + 1\ng = max(l, mini)\nj = n - 1\nwhile j > 0 and b[j] > r:\n    j -= 1\nmaxi = b[j] + b[j - 1] - 1\nc = min(r, maxi)\nprint(max(0, c - g + 1))", "def get(l, i):\n    c = 0\n    while i < len(l):\n        if l[i] % 10 == 1:\n            if c == 0:\n                return i\n            else:\n                c -= 1\n        else:\n            c += 1\n        i += 1\n    return i\n\ndef ans(p):\n    c = 0\n    i = 0\n    while i < len(p):\n        c1 = p[i]\n        i = get(p, i + 1)\n        c2 = p[i]\n        c += c2 // 10 - c1 // 10 + 1\n        i += 1\n    return c\n(n, l, r) = map(int, input().split())\np = list(map(int, input().split()))\np.sort()\np1 = []\ni = 0\nwhile i < n - 1:\n    c1 = max(l, p[i + 1] - p[i] + 1)\n    c2 = min(r, p[i + 1] + p[i] - 1)\n    if c2 >= c1:\n        p1 += [10 * c2 + 1, 10 * c1]\n    i += 1\np1.sort()\nprint(ans(p1))", "(num_strands, L, R) = [int(i) for i in input().strip().split()]\nstrands = [int(i) for i in input().strip().split()]\nstrands.sort()\nprev_shortest = 10 ** 18\ntotal = 0\nfor i in range(num_strands - 1, 0, -1):\n    longest = min(R + 1, strands[i] + strands[i - 1], prev_shortest)\n    shortest = max(L, strands[i] - strands[i - 1] + 1)\n    prev_shortest = min(prev_shortest, shortest)\n    if longest - shortest >= 0:\n        total += longest - shortest\nprint(total)", "import math\n(n, l, r) = map(int, input().split())\nar = list(map(int, input().split()))\nar1 = []\nar.sort()\nfor i in range(n - 1, 0, -1):\n    b = ar[i] + ar[i - 1]\n    a = abs(ar[i] - ar[i - 1])\n    ar1.append((a, b))\nar1.sort()\nar2 = []\nar2.append((ar1[0][0], ar1[0][1]))\nfor i in range(1, n - 1):\n    tmp1 = ar1[i][0]\n    tmp2 = ar1[i][1]\n    (m, n) = ar2.pop()\n    if n <= tmp1:\n        ar2.append((m, n))\n        ar2.append((tmp1, tmp2))\n        continue\n    elif n >= tmp2:\n        ar2.append((m, n))\n        continue\n    elif n < tmp2:\n        ar2.append((m, tmp2))\n        continue\ncnt = 0\nfor (a, b) in ar2:\n    if a <= l and b >= r:\n        if a == l:\n            l += 1\n        if b == r:\n            r -= 1\n        cnt += abs(l - r) + 1\n    elif a > l and b >= r and (a < r):\n        if b == r:\n            cnt += abs(b - a) - 1\n        else:\n            cnt += abs(r - a)\n    elif a <= l and b < r and (l < b):\n        if a == l:\n            cnt += abs(b - a) - 1\n        else:\n            cnt += abs(b - l)\n    elif l < a and r > b:\n        cnt += abs(abs(b - a)) - 1\nprint(cnt)", "def make_range(a):\n\n    def modify(gg, rr):\n        for x in range(len(rr)):\n            if rr[x][1] < gg[0]:\n                continue\n            elif rr[x][0] > gg[0]:\n                rr[x][0] = gg[0]\n            rr[x][1] = gg[1]\n            rr = rr[:x + 1]\n            break\n        return rr\n    rr = []\n    b = sorted(a)\n    for i in range(1, len(b)):\n        xx = [b[i] - b[i - 1] + 1, b[i] + b[i - 1] - 1]\n        rr.append(xx)\n        rr = modify(xx, rr)\n    return rr\n(n, l, r) = map(int, input().split())\na = map(int, input().split())\nran = make_range(a)\nans = 0\nfor x in ran:\n    if l > x[1] or r < x[0]:\n        continue\n    else:\n        ans += min(r, x[1]) - max(l, x[0]) + 1\nprint(ans)", "from itertools import chain\nflatten = chain.from_iterable\n(LEFT, RIGHT) = (1, -1)\n\ndef join_ranges(data, offset=0):\n    data = sorted(flatten((((start, LEFT), (stop + offset, RIGHT)) for (start, stop) in data)))\n    c = 0\n    for (value, label) in data:\n        if c == 0:\n            x = value\n        c += label\n        if c == 0:\n            yield (x, value - offset)\n(n, l, r) = map(int, input().split())\nlis = list(map(int, input().split()))\nlis.sort()\nd = []\nfor i in range(n - 1):\n    j = i + 1\n    mini = abs(lis[j] - lis[i]) + 1\n    maxi = lis[i] + lis[j] - 1\n    d.append([mini, maxi + 1])\nsol = list(join_ranges(d))\nans = 0\nfor i in sol:\n    mini = max(l, i[0])\n    maxi = min(r, i[1] - 1)\n    if mini <= maxi:\n        ans += maxi - mini + 1\nprint(ans)", "s = [int(i) for i in input().strip().split()]\n(n, l, r) = (s[0], s[1], s[2])\narr = [int(i) for i in input().strip().split()]\narr.sort(reverse=True)\nct = 0\nfor i in range(n - 1):\n    lo = arr[i] - arr[i + 1] + 1\n    hi = arr[i] + arr[i + 1] - 1\n    t1 = min(r, hi)\n    t2 = max(l, lo)\n    if t2 > t1:\n        continue\n    if t1 < l:\n        break\n    ct += t1 - t2 + 1\n    r = t2 - 1\n    if r < l:\n        break\nprint(ct)", "(n, l, r) = map(int, input().split())\na = []\na.extend(map(int, input().split()))\na.sort()\nb = []\nc = 0\nfor i in range(n - 1):\n    left = a[i + 1] - a[i] + 1\n    right = a[i] + a[i + 1] - 1\n    if left < l:\n        left = l\n    if right > r:\n        right = r\n    if right >= left:\n        b.append((left, right))\n        c += 1\nb.sort()\ns = b[0][1] - b[0][0] + 1\np = 0\nfor i in range(1, c):\n    if b[i][0] > b[p][1]:\n        s += b[i][1] - b[i][0] + 1\n        p = i\n    elif b[i][1] > b[p][1]:\n        s += b[i][1] - b[p][1]\n        p = i\nprint(s)", "(n, l, r) = input().split(' ')\n(n, l, r) = [int(n), int(l), int(r)]\narr = [int(temp) for temp in input().strip().split(' ')]\narr.sort()\nco = 0\nfor i in range(1, n):\n    j = n - i\n    ll = arr[j] - arr[j - 1] + 1\n    rr = arr[j] + arr[j - 1] - 1\n    if l <= ll <= r:\n        if l <= rr <= r:\n            co += rr - ll + 1\n        else:\n            co += r - ll + 1\n        r = ll - 1\n    elif l <= rr <= r:\n        co += rr - l + 1\n        break\nprint(co)", "def read(type=int):\n    return type(input())\n\ndef read_arr(type=int):\n    return [type(token) for token in input().split()]\n\ndef cmp_to_key(cmp):\n    from functools import total_ordering\n\n    @total_ordering\n    class K(object):\n\n        def __init__(self, obj, *args):\n            self.obj = obj\n\n        def __lt__(self, other):\n            return cmp(self.obj, other.obj) < 0\n\n        def __eq__(self, other):\n            return cmp(self.obj, other.obj) == 0\n    return K\n\ndef cmp(i, j):\n    if i[0] < j[0] or (i[0] == j[0] and i[1] < j[1]):\n        return -1\n    elif i[0] > j[0] or (i[0] == j[0] and i[1] > j[1]):\n        return 1\n    else:\n        return 0\n\ndef merge(I):\n    I.sort(key=cmp_to_key(cmp))\n    J = []\n    for i in I:\n        if len(J) == 0 or J[-1][1] < i[0]:\n            J.append(i)\n        else:\n            J[-1][1] = max(i[1], J[-1][1])\n    return J\n\ndef merged_len(i):\n    return max(0, min(i[1], R) - max(i[0], L) + 1)\n\ndef intersect(I):\n    s = 0\n    for i in I:\n        s += merged_len(i)\n    return s\n\ndef sol():\n    A.sort()\n    I = []\n    for i in range(1, n):\n        r = [A[i] - A[i - 1] + 1, A[i] + A[i - 1] - 1]\n        I.append(r)\n    I = merge(I)\n    s = intersect(I)\n    return s\n\ndef sol2():\n    I = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            I.append([abs(A[i] - A[j]) + 1, A[i] + A[j] - 1])\n    I = merge(I)\n    s = intersect(I)\n    return s\n(n, L, R) = read_arr()\nA = read_arr()\nprint(sol())", "(n, l, r) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nk = 0\nlower = [0] * (n - 1)\nupper = [0] * (n - 1)\nfor i in range(1, n):\n    lower[k] = a[i] - a[i - 1] + 1\n    upper[k] = a[i] + a[i - 1] - 1\n    k += 1\nsm = 0\ni = 0\nmn = float('inf')\nmx = -1\nlow = l\nwhile i < k:\n    upperVal = 0\n    lowerVal = 0\n    if lower[i] <= mn and upper[i] >= mx:\n        sm = 0\n        low = l\n    if lower[i] >= low and lower[i] <= r:\n        lowerVal = lower[i]\n    elif lower[i] < low and upper[i] >= low:\n        lowerVal = low\n    if upper[i] <= r and upper[i] >= low:\n        low = upper[i] + 1\n        upperVal = upper[i]\n    elif upper[i] > r and lower[i] <= r:\n        low = r + 1\n        upperVal = r\n    if lower[i] < mn:\n        mn = lower[i]\n    if upper[i] > mx:\n        mx = upper[i]\n    if upperVal != 0 and lowerVal != 0:\n        sm += upperVal - lowerVal + 1\n    i += 1\nprint(sm)", "import sys\n\ndef main():\n    (N, L, R) = map(int, sys.stdin.readline().split())\n    strands = list(map(int, sys.stdin.readline().split()))\n    strands.sort()\n    stack = []\n    for i in range(1, N):\n        lower = strands[i] - strands[i - 1] + 1\n        upper = strands[i] + strands[i - 1] - 1\n        while stack:\n            (s_lower, s_upper) = stack.pop()\n            if lower >= s_lower:\n                if lower <= s_upper + 1:\n                    lower = s_lower\n                else:\n                    stack.append((s_lower, s_upper))\n                break\n        stack.append((lower, upper))\n    ans = 0\n    for (l, u) in stack:\n        if l <= R:\n            if l >= L:\n                if u <= R:\n                    ans += u - l + 1\n                else:\n                    ans += R - l + 1\n            elif u <= R:\n                ans += u - L + 1\n            else:\n                ans += R - L + 1\n        else:\n            break\n    print(ans)\nmain()", "def lrval(l1, r1, l2, r2):\n    l3 = max(l1, l2)\n    r3 = min(r1, r2)\n    if r3 < l3:\n        return None\n    return (l3, r3)\n(n, l, r) = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\na.sort()\nb = []\nfor i in range(n - 1):\n    diff = a[i + 1] - a[i] + 1\n    sum1 = a[i + 1] + a[i] - 1\n    if lrval(l, r, diff, sum1) != None:\n        b.append(lrval(l, r, diff, sum1))\nb.sort()\nsum2 = b[0][1] - b[0][0] + 1\ne = b[0][1]\nfor i in range(1, len(b)):\n    if e >= b[i][1]:\n        continue\n    elif e < b[i][0]:\n        sum2 = sum2 + b[i][1] - b[i][0] + 1\n    elif e < b[i][1]:\n        sum2 = sum2 + b[i][1] - e\n    e = b[i][1]\nprint(sum2)", "def lrval(l1, r1, l2, r2):\n    l3 = max(l1, l2)\n    r3 = min(r1, r2)\n    if r3 < l3:\n        return None\n    return (l3, r3)\n(n, l, r) = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\na.sort()\nb = []\nfor i in range(n - 1):\n    diff = a[i + 1] - a[i] + 1\n    sum1 = a[i + 1] + a[i] - 1\n    if lrval(l, r, diff, sum1) != None:\n        b.append(lrval(l, r, diff, sum1))\nb.sort()\nsum2 = b[0][1] - b[0][0] + 1\ne = b[0][1]\nfor i in range(1, len(b)):\n    if e >= b[i][1]:\n        continue\n    elif e < b[i][0]:\n        sum2 = sum2 + b[i][1] - b[i][0]\n    elif e < b[i][1]:\n        sum2 = sum2 + b[i][1] - e\n    e = b[i][1]\nprint(sum2)", "(n, l, r) = map(int, input().split())\nz = list(map(int, input().split()))\nz.sort()\nans = 0\na = []\nfor i in range(1, n):\n    q = max(z[i] - z[i - 1] + 1, l)\n    m = min(z[i] + z[i - 1] - 1, r)\n    if q <= r and m >= l:\n        a.append([q, m])\nb = []\nfor (begin, end) in sorted(a):\n    if b and b[-1][1] >= begin - 1:\n        b[-1][1] = max(b[-1][1], end)\n    else:\n        b.append([begin, end])\nfor i in b:\n    ans = ans + (i[1] - i[0] + 1)\nprint(ans)", "(n, l, r) = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\na.sort()\nt = [[a[1] - a[0] + 1, a[1] + a[0] - 1]]\nfor i in range(2, n):\n    (x, y) = (a[i] - a[i - 1] + 1, a[i] + a[i - 1] - 1)\n    while t and x <= t[-1][1]:\n        (u, v) = t.pop()\n        if x > u:\n            x = u\n    t.append([x, y])\nc = 0\nfor i in t:\n    (x, y) = (max(l, i[0]), min(r, i[1]))\n    c += max(0, y - x + 1)\nprint(c)", "def compute(a, b, l, r):\n    if l > a:\n        a = l\n    if r < b:\n        b = r\n    if b >= a:\n        return b - a + 1\n    else:\n        return 0\n(n, l, r) = map(int, input().strip(' ').split(' '))\narray = list(map(int, input().strip(' ').split(' ')))\narray.sort()\ncomparelist = list()\nfor i in range(n - 1):\n    comparelist.append((array[i + 1] - array[i] + 1, array[i + 1] + array[i] - 1))\nimport operator\ncomparelist.sort(key=operator.itemgetter(0))\ncount = 0\nl1 = comparelist[0][0]\nr1 = comparelist[0][1]\nfor i in range(1, n - 1):\n    l2 = comparelist[i][0]\n    r2 = comparelist[i][1]\n    if r1 < l2:\n        count += compute(l1, r1, l, r)\n        l1 = l2\n        r1 = r2\n    elif r1 < r2:\n        r1 = r2\ncount += compute(l1, r1, l, r)\nprint(count)", "from random import randint\n(n, l, r) = map(int, input().split())\na = list(map(int, input().split()))\nb = []\na.sort()\nfor i in range(1, n):\n    x = a[i - 1]\n    y = a[i]\n    if min(y + x - 1, r) - max(y - x + 1, l) + 1 <= 0:\n        continue\n    b.append([max(y - x + 1, l), min(y + x - 1, r)])\nb.sort(key=lambda x: x[0])\nans = b[0][1] - b[0][0] + 1\nln = len(b)\nr1 = b[0][1]\nfor i in range(1, ln):\n    l2 = b[i][0]\n    r2 = b[i][1]\n    if r1 >= r2:\n        continue\n    ans += r2 - l2 + 1\n    if l2 <= r1:\n        ans -= r1 - l2 + 1\n    r1 = r2\nprint(ans)", "(N, L, R) = [int(x) for x in input().strip().split()]\nS = [int(x) for x in input().strip().split()]\nS = sorted(S)\nmini = 10 ** 20\nran = []\nfor i in range(1, N):\n    if S[i] - S[i - 1] < mini or (S[i] - S[i - 1] == mini and S[i] + S[i - 1] - 1 > ran[0][1]):\n        mini = S[i] - S[i - 1]\n        ran = [[S[i] - S[i - 1] + 1, S[i] + S[i - 1] - 1]]\nif ran[0][1] >= S[-1] - S[-2] + 1:\n    ran[0][1] = max(ran[0][1], S[-1] + S[-2] - 1)\nelse:\n    ran.append([S[-1] - S[-2] + 1, S[-1] + S[-2] - 1])\ncnt = 0\nfor interval in ran:\n    if L <= interval[0] <= interval[1] <= R:\n        cnt += interval[1] - interval[0] + 1\n    elif interval[0] < L and L <= interval[1] <= R:\n        cnt += interval[1] - L + 1\n    elif L <= interval[0] <= R and interval[1] > R:\n        cnt += R - interval[0] + 1\n    elif interval[0] <= L < R <= interval[1]:\n        cnt = R - L + 1\nprint(cnt)", "(N, L, R) = [int(n) for n in input().split()]\nnums = [int(n) for n in input().split()]\nnums.sort()\nnums = [[nums[i + 1] - nums[i] + 1, nums[i + 1] + nums[i] - 1] for i in range(len(nums) - 1)]\n\ndef getIntersection(lst):\n    (mn, mx) = lst\n    shouldBeZero = False\n    if mn > R:\n        return None\n    if mx < L:\n        return None\n    return (max(mn, L), min(mx, R))\n\ndef getNumsInRange(lst):\n    if lst is None:\n        return 0\n    (mn, mx) = lst\n    return mx - mn + 1\n\ndef getUnions(a):\n    a.sort()\n    b = [a[0]]\n    for (begin, end) in a[1:]:\n        if b and b[-1][1] >= begin - 1:\n            b[-1][1] = max(b[-1][1], end)\n        else:\n            b.append([begin, end])\n    return b\nunions = getUnions(nums)\ndiffs = [getNumsInRange(getIntersection(num)) for num in unions]\nprint(sum(diffs))", "class Node(object):\n    start = None\n    end = None\n\n    def __init__(self, s, e):\n        self.start = s\n        self.end = e\n\ndef compare(x, y):\n    a = x.end - x.start\n    b = y.end - x.start\n    if a < b:\n        return -1\n    elif a > b:\n        return 1\n    else:\n        return 0\nnodes = []\n(n, l, r) = map(int, input().split())\nlengths = list(map(int, input().split()))\nlengths.sort()\ni = 0\nwhile i < n - 1:\n    nodes.append(Node(lengths[i], lengths[i + 1]))\n    i += 1\nnodes = sorted(nodes, key=lambda k: k.end - k.start)\ncount = 0\nfor node in nodes:\n    sums = node.start + node.end - 1\n    if sums >= l:\n        end = min(r, sums)\n        start = max(node.end - node.start + 1, l)\n        if start <= end:\n            count += end - start + 1\n            l = end + 1\nprint(count)", "class Node(object):\n    start = None\n    end = None\n\n    def __init__(self, s, e):\n        self.start = s\n        self.end = e\nnodes = []\n\ndef do_append(p, q):\n    p_index = find_index(p)\n    q_index = find_index(q)\n    if p_index is None and q_index is None:\n        nodes.append(Node(p, q))\n        return\n    elif q_index is None:\n        if p_index < 0:\n            nodes[abs(p_index) - 1].start = p\n        nodes[abs(p_index) - 1].end = q\n        last_node = len(nodes)\n        while last_node > abs(p_index):\n            last_node -= 1\n            del nodes[last_node]\n        normalize(abs(p_index) - 1)\n        return\n    elif p_index == -1:\n        if q_index == -1:\n            nodes.insert(0, Node(p, q))\n            normalize(0)\n            return\n        else:\n            nodes[0].start = p\n            p_index = 1\n    if p_index < 0:\n        p_index += 1\n    else:\n        p_index -= 1\n    if q_index < 0:\n        q_index += 1\n    else:\n        q_index -= 1\n    if p_index == q_index:\n        if p_index <= 0 and nodes[abs(p_index)].start > p:\n            nodes.insert(-1 * p_index, Node(p, q))\n            normalize(abs(p_index))\n    else:\n        next_node = abs(p_index) + 1\n        while next_node < abs(q_index):\n            del nodes[abs(p_index) + 1]\n            next_node += 1\n        if p_index < 0:\n            nodes[abs(p_index)].start = p\n        if q_index < 0:\n            nodes[abs(p_index)].end = q\n        elif abs(q_index) != abs(p_index):\n            new_end = nodes[abs(p_index) + 1].end\n            del nodes[abs(p_index) + 1]\n            nodes[abs(p_index)].end = new_end\n        normalize(abs(p_index))\n\ndef normalize(index):\n    again = False\n    if index >= len(nodes) or index < 0:\n        return\n    if index > 0 and nodes[index - 1].end + 1 == nodes[index].start:\n        nodes[index - 1].end = nodes[index].end\n        del nodes[index]\n        again = True\n        if 1 < index < len(nodes) and nodes[index - 1].end + 1 == nodes[index].start:\n            nodes[index - 1].end = nodes[index].end\n            del nodes[index]\n            again = True\n    elif index + 1 < len(nodes) and nodes[index + 1].start - 1 == nodes[index].end:\n        nodes[index].end = nodes[index + 1].end\n        del nodes[index + 1]\n        again = True\n    if again:\n        normalize(index)\n\ndef find_index(p, start_index=0):\n    ind = start_index\n    while ind < len(nodes):\n        if nodes[ind].end >= p >= nodes[ind].start:\n            return ind + 1\n        elif nodes[ind].start > p:\n            return -1 * (ind + 1)\n        ind += 1\n    return None\n(n, l, r) = map(int, input().split())\nlengths = list(map(int, input().split()))\nlengths.sort()\ni = 0\nwhile i < n - 1:\n    j = i + 1\n    sums = lengths[i] + lengths[j]\n    diff = abs(lengths[i] - lengths[j])\n    if l > diff:\n        start = l\n    else:\n        start = diff + 1\n    if start < sums and start <= r:\n        if sums <= r:\n            end = sums - 1\n        else:\n            end = r\n        if start <= end:\n            do_append(start, end)\n    i += 1\ncount = 0\nfor node in nodes:\n    count = count + node.end - node.start + 1\nprint(count)", "import sys\n\ndef merge(arr, brr, p, q, r):\n    (a, b) = (q - p + 1, r - q)\n    ma1 = [arr[i + p] for i in range(0, a)]\n    ma2 = [arr[i + q + 1] for i in range(0, b)]\n    mb1 = [brr[i + p] for i in range(0, a)]\n    mb2 = [brr[i + q + 1] for i in range(0, b)]\n    (j, k, i) = (0, p, 0)\n    while True:\n        if ma1[i] <= ma2[j]:\n            arr[k] = ma1[i]\n            brr[k] = mb1[i]\n            k += 1\n            i += 1\n        else:\n            arr[k] = ma2[j]\n            brr[k] = mb2[j]\n            k += 1\n            j += 1\n        if i >= a or j >= b:\n            break\n    if i >= a:\n        while j < b:\n            arr[k] = ma2[j]\n            brr[k] = mb2[j]\n            k += 1\n            j += 1\n    elif j >= b:\n        while i < a:\n            arr[k] = ma1[i]\n            brr[k] = mb1[i]\n            k += 1\n            i += 1\n\ndef merge_sort(arr, brr, p, q):\n    if p < q:\n        r = p + int((q - p) // 2)\n        merge_sort(arr, brr, p, r)\n        merge_sort(arr, brr, r + 1, q)\n        merge(arr, brr, p, r, q)\n\ndef inter(arr, brr, i, l, r):\n    if brr[i] < l or arr[i] > r:\n        arr[i] = brr[i] = 0\n    elif arr[i] <= l and r <= brr[i]:\n        arr[i] = l\n        brr[i] = r\n    elif l <= arr[i] and brr[i] <= r:\n        return\n    elif arr[i] <= l and brr[i] <= r:\n        arr[i] = l\n    elif l <= arr[i] and r <= brr[i]:\n        brr[i] = r\n\ndef union(arr, brr):\n    mx = brr[0]\n    for i in range(0, len(arr) - 1):\n        if arr[i + 1] <= mx:\n            arr[i + 1] = mx + 1\n        mx = max(mx, brr[i + 1])\n    ans = 0\n    for i in range(0, len(arr)):\n        if arr[i] <= brr[i] and arr[i] != 0:\n            ans += brr[i] - arr[i] + 1\n    return ans\ninp = [int(i) for i in input().split()]\n(n, l, r) = (inp[0], inp[1], inp[2])\ninp = [int(i) for i in input().split()]\ninp.sort()\narr = [inp[i] - inp[i - 1] + 1 for i in range(1, n)]\nbrr = [inp[i] + inp[i - 1] - 1 for i in range(1, n)]\nfor i in range(0, n - 1):\n    inter(arr, brr, i, l, r)\nmerge_sort(arr, brr, 0, len(arr) - 1)\nprint(union(arr, brr))", "from operator import itemgetter\nnlr = [int(i) for i in input().split()]\nn = nlr[0]\nl = nlr[1]\nr = nlr[2]\ninp_arr = [int(i) for i in input().split()]\ninp_arr.sort()\ni = 1\nlo_up_arr = []\nlo_up_arr.append([inp_arr[i] - inp_arr[i - 1], inp_arr[i] + inp_arr[i - 1]])\nleng = 1\n\ndef fun(lo_up_arr, k, leng):\n    i = leng - 1\n    while i > k:\n        if lo_up_arr[i] == []:\n            i -= 1\n            continue\n        if lo_up_arr[i][0] >= lo_up_arr[k][0]:\n            if lo_up_arr[i][0] > lo_up_arr[k][1]:\n                f = 1\n            elif lo_up_arr[i][1] <= lo_up_arr[k][1]:\n                lo_up_arr[i] = []\n            else:\n                lo_up_arr[k][1] = lo_up_arr[i][1]\n                lo_up_arr[i] = []\n        elif lo_up_arr[i][1] < lo_up_arr[k][0]:\n            f = 1\n        elif lo_up_arr[i][1] > lo_up_arr[k][1]:\n            lo_up_arr[k][0] = lo_up_arr[i][0]\n            lo_up_arr[t][1] = lo_up_arr[i][1]\n        else:\n            lo_up_arr[k][0] = lo_up_arr[i][0]\n        i -= 1\nfor i in range(2, n):\n    flag = 0\n    f = 1\n    for t in range(0, leng):\n        if lo_up_arr[t] == []:\n            continue\n        if inp_arr[i] - inp_arr[i - 1] >= lo_up_arr[t][0]:\n            if inp_arr[i] - inp_arr[i - 1] > lo_up_arr[t][1]:\n                flag = 0\n                break\n            elif inp_arr[i] + inp_arr[i - 1] <= lo_up_arr[t][1]:\n                flag = 1\n                f = 0\n                break\n            else:\n                lo_up_arr[t][1] = inp_arr[i] + inp_arr[i - 1]\n                flag = 1\n                break\n        elif inp_arr[i] + inp_arr[i - 1] < lo_up_arr[t][0]:\n            flag = 0\n            break\n        elif inp_arr[i] + inp_arr[i - 1] > lo_up_arr[t][1]:\n            lo_up_arr[t][0] = inp_arr[i] - inp_arr[i - 1]\n            lo_up_arr[t][1] = inp_arr[i] + inp_arr[i - 1]\n            flag = 1\n            break\n        else:\n            lo_up_arr[t][0] = inp_arr[i] - inp_arr[i - 1]\n            flag = 1\n            break\n    if flag:\n        fun(lo_up_arr, t, leng)\n    else:\n        lo_up_arr.append([inp_arr[i] - inp_arr[i - 1], inp_arr[i] + inp_arr[i - 1]])\n        leng += 1\ni = 0\nwhile i < leng:\n    if lo_up_arr[i] == []:\n        i += 1\n        continue\n    if lo_up_arr[i][1] > r:\n        lo_up_arr[i][1] = r + 1\n        if lo_up_arr[i][0] >= r:\n            lo_up_arr[i][0] = r\n        if lo_up_arr[i][0] < l:\n            lo_up_arr[i][0] = l - 1\n    elif lo_up_arr[i][0] < l:\n        lo_up_arr[i][0] = l - 1\n    i += 1\ni = 0\nres = 0\nwhile i < leng:\n    if lo_up_arr[i] == []:\n        i += 1\n        continue\n    if not lo_up_arr[i][1] <= lo_up_arr[i][0]:\n        res += lo_up_arr[i][1] - lo_up_arr[i][0] - 1\n    i += 1\nprint(res)", "(a, b, c) = list(map(int, input().split()))\nd = list(map(int, input().split()))\nd.sort()\nmax = []\nmin = []\nd.reverse()\nfor i in range(a - 1):\n    max.append([d[i] + d[i + 1] - 1, d[i] - d[i + 1] + 1])\nuppr = c\nclwr = b\ntotal = 0\nfor i in range(len(max)):\n    if max[i][0] >= uppr:\n        if max[i][1] >= clwr and max[i][1] <= uppr:\n            total += uppr - max[i][1] + 1\n            uppr = max[i][1] - 1\n    if max[i][0] < uppr:\n        if max[i][1] >= clwr:\n            total += max[i][0] - max[i][1] + 1\n            uppr = max[i][1] - 1\n        if max[i][1] < clwr:\n            total += max[i][0] - clwr + 1\n            break\nprint(total)", "import time\n(a, b, c) = list(map(int, input().split()))\nd = list(map(int, input().split()))\nd.sort()\nmax = []\nmin = []\nd.reverse()\nfor i in range(a - 1):\n    max.append([d[i] + d[i + 1] - 1, d[i] - d[i + 1] + 1])\nuppr = c\nclwr = b\ntotal = 0\nfor i in range(len(max)):\n    if max[i][0] >= uppr:\n        if max[i][1] >= clwr and max[i][1] <= uppr:\n            total += uppr - max[i][1] + 1\n            uppr = max[i][1] - 1\n    if max[i][0] < uppr:\n        if max[i][1] >= clwr:\n            total += max[i][0] - max[i][1] + 1\n            uppr = max[i][1] - 1\n        if max[i][1] < clwr:\n            total += max[i][0] - clwr + 1\n            break\ntime.sleep(1)\nprint(total)", "(a, b, c) = list(map(int, input().split()))\nd = list(map(int, input().split()))\nd.sort()\nmax = []\nmin = []\nd.reverse()\nfor i in range(a - 1):\n    max.append([d[i] + d[i + 1] - 1, d[i] - d[i + 1] + 1])\nuppr = c\nclwr = b\ntotal = 0\nfor i in range(len(max)):\n    if max[i][0] >= uppr:\n        if max[i][1] >= clwr and max[i][1] <= uppr:\n            total += uppr - max[i][1] + 1\n            uppr = max[i][1] - 1\n    if max[i][0] < uppr:\n        if max[i][1] >= clwr:\n            total += max[i][0] - max[i][1] + 1\n            uppr = max[i][1] - 1\n        if max[i][1] < clwr:\n            total += max[i][0] - clwr + 1\n            break\nfor i in range(1000):\n    print('', end='')\nprint(total)", "(a, b, c) = list(map(int, input().split()))\nd = list(map(int, input().split()))\nd.sort()\nmax = []\nmin = []\nd.reverse()\nfor i in range(a - 1):\n    max.append([d[i] + d[i + 1] - 1, d[i] - d[i + 1] + 1])\nuppr = c\nclwr = b\ntotal = 0\nfor i in range(len(max)):\n    if max[i][0] >= uppr:\n        if max[i][1] >= clwr and max[i][1] <= uppr:\n            total += uppr - max[i][1] + 1\n            uppr = max[i][1] - 1\n    if max[i][0] < uppr:\n        if max[i][1] >= clwr:\n            total += max[i][0] - max[i][1] + 1\n            uppr = max[i][1] - 1\n        if max[i][1] < clwr:\n            total += max[i][0] - clwr + 1\n            break\nprint(total)", "(n, left, right) = map(int, input().split())\na = list(map(int, input().split()))\nif n <= 100:\n    s = set()\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            for k in range(abs(a[i] - a[j]) + 1, a[i] + a[j]):\n                if left <= k and k <= right:\n                    s.add(k)\n    print(len(s))\nelse:\n    a = sorted(a, reverse=True)\n    ranges = []\n    union = []\n    for i in range(0, n - 1):\n        j = i + 1\n        ranges.append([max(left, abs(a[i] - a[j]) + 1), min(right, a[i] + a[j] - 1)])\n    for (begin, end) in sorted(ranges):\n        if union and union[-1][1] >= begin - 1:\n            union[-1][1] = max(union[-1][1], end)\n        else:\n            union.append([begin, end])\n    print(union[0][1] - union[0][0] + 1)", "def mrg(arr, r, brr, r2, left, mid, right):\n    last = mid - 1\n    temp = left\n    ln = right - left + 1\n    while left <= last and mid <= right:\n        if arr[left] <= arr[mid]:\n            r[temp] = arr[left]\n            r2[temp] = brr[left]\n            temp = temp + 1\n            left = left + 1\n        else:\n            r[temp] = arr[mid]\n            r2[temp] = brr[mid]\n            temp = temp + 1\n            mid = mid + 1\n    while left <= last:\n        r[temp] = arr[left]\n        r2[temp] = brr[left]\n        temp = temp + 1\n        left = left + 1\n    while mid <= right:\n        r[temp] = arr[mid]\n        r2[temp] = brr[mid]\n        mid = mid + 1\n        temp = temp + 1\n    i = 0\n    while i < ln:\n        arr[right] = r[right]\n        brr[right] = r2[right]\n        right = right - 1\n        i += 1\n    return\n\ndef merge_srt(arr, r, brr, r2, left, right):\n    if right > left:\n        mid = int((right + left) // 2)\n        merge_srt(arr, r, brr, r2, left, mid)\n        merge_srt(arr, r, brr, r2, mid + 1, right)\n        mrg(arr, r, brr, r2, left, mid + 1, right)\n    return\narr = [int(i) for i in input().split()]\nn = arr[0]\nl = arr[1]\nr = arr[2]\narr = [int(i) for i in input().split()]\narr.sort()\narr1 = [0 for i in range(0, len(arr))]\narr2 = [0 for i in range(0, len(arr))]\nfor i in range(1, len(arr)):\n    arr1[i - 1] = arr[i] - arr[i - 1] + 1\n    arr2[i - 1] = arr[i] + arr[i - 1] - 1\nfor i in range(0, len(arr)):\n    if arr1[i] < l and arr2[i] < l:\n        arr1[i] = arr2[i] = 0\n    elif arr1[i] > r and arr2[i] > r:\n        arr1[i] = arr2[i] = 0\n    elif arr1[i] < l and arr2[i] > r:\n        arr1[i] = l\n        arr2[i] = r\n    elif arr1[i] < l and arr2[i] <= r:\n        arr1[i] = l\n    elif arr1[i] >= l and arr2[i] > r:\n        arr2[i] = r\nr1 = [0 for i in range(0, len(arr))]\nr2 = [0 for i in range(0, len(arr))]\nmerge_srt(arr1, r1, arr2, r2, 0, len(arr) - 1)\nmx = arr2[0]\nfor i in range(0, len(arr) - 1):\n    if arr1[i + 1] <= mx:\n        arr1[i + 1] = mx + 1\n    if mx < arr2[i + 1]:\n        mx = arr2[i + 1]\nans = 0\nfor i in range(0, len(arr)):\n    if arr2[i] >= arr1[i] and arr1[i] >= l and (arr2[i] <= r):\n        ans = ans + arr2[i] - arr1[i] + 1\nprint(ans)", "def intersection(L1, R1, L2, R2):\n    (L3, R3) = (max(L1, L2), min(R1, R2))\n    return (L3, R3) if L3 <= R3 else None\n(N, L, R) = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nL = [intersection(L, R, A[i] - A[i - 1] + 1, A[i] + A[i - 1] - 1) for i in range(1, N)]\nL = [x for x in L if x is not None]\nL.sort()\ntotal = 0\npe = -1\nfor (s, e) in L:\n    if s > pe:\n        total += e - s + 1\n        pe = e\n    elif e > pe:\n        total += e - pe\n        pe = e\nprint(total)", "(N, L, R) = map(int, input().strip().split())\nA = sorted(list(map(int, input().strip().split())))\nres = 0\nlef = 0\nrig = 0\nfor i in range(N - 1):\n    templ = A[N - 1 - i] - A[N - 2 - i] + 1\n    tempr = A[N - 1 - i] + A[N - 2 - i] - 1\n    if lef != 0 and tempr >= lef:\n        lef = min(lef, templ)\n    else:\n        lef = max(lef, L)\n        rig = min(rig, R)\n        res += max(0, rig - lef + 1)\n        lef = templ\n        rig = tempr\nlef = max(lef, L)\nrig = min(rig, R)\nres += max(0, rig - lef + 1)\nprint(res)", "def intersection(L1, R1, L2, R2):\n    return max(min(R1, R2) - max(L1, L2) + 1, 0)\n(N, L, R) = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\ns = 0\nmi = A[1] - A[0] + 1\n(pl, pr) = (0, 0)\nfor i in range(2, N):\n    d = A[i] - A[i - 1] + 1\n    t = A[i - 1] + A[i - 2] - 1\n    if d <= t:\n        mi = min(mi, d)\n    else:\n        if mi < pl:\n            s += intersection(L, R, mi, pl - 1)\n        s += intersection(L, R, max(mi, pr + 1), t)\n        (pl, pr) = (mi, t)\n        mi = d\nt = A[-1] + A[-2] - 1\nif mi < pl:\n    s += intersection(L, R, mi, pl - 1)\ns += intersection(L, R, max(mi, pr + 1), t)\nprint(s)", "import numpy\nimport math\n(n, l, r) = map(numpy.int64, input().split())\na = list(map(numpy.int64, input().split()))\nans = []\na.sort()\nfor i in range(1, n):\n    Range = [max(l, a[i] - a[i - 1] + 1), min(r, a[i] + a[i - 1] - 1)]\n    if Range[0] > Range[1]:\n        continue\n    ans.append([Range[0], Range[1]])\narr = []\nfor elem in ans:\n    if elem[0] > elem[1]:\n        continue\n    arr.append([elem[0], 0])\n    arr.append([elem[1], 1])\narr.sort()\ncnt = 0\nfinal_ans = 0\nfor elem in arr:\n    if cnt == 0:\n        start = elem[0]\n    if elem[1] == 0:\n        cnt += 1\n    else:\n        cnt -= 1\n    if cnt == 0:\n        final_ans = final_ans + (elem[0] - start + 1)\nprint(final_ans)", "(n, l, r) = map(int, input().strip().split())\nA = list(map(int, input().strip().split()))\nA.sort()\nans = 0\n(p, q) = (r + 1, r + 1)\nans = 0\nfor i in range(n - 1, 0, -1):\n    (a, b) = (A[i - 1], A[i])\n    (x, y) = (b - a + 1, a + b - 1)\n    if p == l:\n        break\n    if x < p:\n        y = min(y, p - 1)\n        x = max(x, l)\n        (p, q) = (x, y)\n        ans += q - p + 1\nprint(ans)", "(n, l, r) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nbrr = []\nfor i in range(n - 1):\n    brr.append((arr[i + 1] - arr[i], arr[i + 1] + arr[i]))\nbrr.sort(key=lambda x: x[1])\n(le, ri) = (brr[n - 2][0] + 1, brr[n - 2][1] - 1)\ncount = 0\nfor i in range(n - 3, -1, -1):\n    (a, b) = (brr[i][0] + 1, brr[i][1] - 1)\n    if a > b:\n        continue\n    if le <= b:\n        le = min(a, le)\n    elif le > r or ri < l:\n        (le, ri) = (a, b)\n    else:\n        (tl, tr) = (max(l, le), min(r, ri))\n        count += tr - tl + 1\n        (le, ri) = (a, b)\n(tl, tr) = (max(l, le), min(r, ri))\ncount += tr - tl + 1\nprint(count)", "(n, l, r) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nbrr = [0] * (n - 1)\nfor i in range(n - 1):\n    brr[i] = (arr[i + 1] - arr[i], arr[i + 1] + arr[i])\nbrr.sort(key=lambda x: x[1])\n(le, ri) = (brr[n - 2][0] + 1, brr[n - 2][1] - 1)\ncount = 0\nfor i in range(n - 3, -1, -1):\n    (a, b) = (brr[i][0] + 1, brr[i][1] - 1)\n    if a > b:\n        continue\n    if le <= b:\n        le = min(a, le)\n    elif le > r or ri < l:\n        (le, ri) = (a, b)\n    else:\n        (tl, tr) = (max(l, le), min(r, ri))\n        count += tr - tl + 1\n        (le, ri) = (a, b)\n(tl, tr) = (max(l, le), min(r, ri))\ncount += tr - tl + 1\nprint(count)", "(n, l, r) = map(int, input().strip().split())\narr = [int(i) for i in input().strip().split()]\narr.sort(reverse=True)\nans = 0\nfor y in range(n):\n    if y == n - 1:\n        break\n    x = arr[y + 1]\n    i = arr[y]\n    max = i + x - 1\n    min = i - x + 1\n    if max < r:\n        r = max\n    if min <= l:\n        ans += r - l + 1\n        break\n    if min > r:\n        continue\n    ans += r - min + 1\n    r = min - 1\n    if r < l:\n        break\nprint(ans)", "(n, l, r) = list(map(int, input().split()))\nstrands = list(map(int, input().split()))\nstrands.sort()\nrange_list = []\n\ndef insert_into_list(left, right):\n    range_list.append([left, right])\nfor i in range(n - 1, 0, -1):\n    a = strands[i - 1]\n    b = strands[i]\n    left_range = b - a + 1\n    right_range = a + b - 1\n    if left_range < l:\n        if right_range < l:\n            continue\n        left_range = l\n    if right_range > r:\n        if left_range > r:\n            continue\n        right_range = r\n    insert_into_list(left_range, right_range)\nrange_list.sort()\nsanitized_list = []\nfor i in range(len(range_list)):\n    curr = range_list[i]\n    curr_l = curr[0]\n    curr_r = curr[1]\n    if len(sanitized_list) == 0:\n        sanitized_list.append(curr)\n        continue\n    last = sanitized_list[-1]\n    last_l = last[0]\n    last_r = last[1]\n    if curr_l <= last_r:\n        if curr_r > last_r:\n            sanitized_list[-1][1] = curr_r\n    else:\n        sanitized_list.append(curr)\ncount = 0\nfor i in range(len(sanitized_list)):\n    san_curr = sanitized_list[i]\n    count += san_curr[1] - san_curr[0] + 1\nprint(count)", "c = 1\ncases = 1\nwhile c <= cases:\n    [n, l, r] = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    a.sort(reverse=True)\n    pos = []\n    for i in range(0, len(a) - 1):\n        new = False\n        if a[i] + a[i + 1] - 1 <= r and a[i] - a[i + 1] + 1 >= l:\n            l1 = a[i] - a[i + 1] + 1\n            r1 = a[i] + a[i + 1] - 1\n            new = True\n        elif a[i] + a[i + 1] - 1 >= r and a[i] - a[i + 1] + 1 >= l and (a[i] - a[i + 1] + 1 <= r):\n            l1 = a[i] - a[i + 1] + 1\n            r1 = r\n            new = True\n        elif a[i] - a[i + 1] + 1 <= l and a[i] + a[i + 1] - 1 <= r and (a[i] + a[i + 1] - 1 >= l):\n            l1 = l\n            r1 = a[i] + a[i + 1] - 1\n            new = True\n        elif a[i] - a[i + 1] + 1 < l and a[i] + a[i + 1] - 1 > r:\n            l1 = l\n            r1 = r\n            new = True\n        if len(pos) == 0 and new:\n            pos.append((l1, r1))\n        elif new and r1 >= pos[-1][0]:\n            temp = pos.pop()\n            pos.append((min(temp[0], l1), temp[1]))\n        elif new:\n            pos.append((l1, r1))\n    ans = 0\n    for i in pos:\n        ans += i[1] - i[0] + 1\n    print(ans)\n    c = c + 1", "c = 1\ncases = 1\nwhile c <= cases:\n    [n, l, r] = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    a.sort(reverse=True)\n    pos = []\n    for i in range(0, len(a) - 1):\n        new = False\n        if a[i] + a[i + 1] - 1 <= r and a[i] - a[i + 1] + 1 >= l:\n            l1 = a[i] - a[i + 1] + 1\n            r1 = a[i] + a[i + 1] - 1\n            new = True\n        elif a[i] + a[i + 1] - 1 > r and a[i] - a[i + 1] + 1 >= l and (a[i] - a[i + 1] + 1 < r):\n            l1 = a[i] - a[i + 1] + 1\n            r1 = r\n            new = True\n        elif a[i] - a[i + 1] + 1 < l and a[i] + a[i + 1] - 1 <= r and (a[i] + a[i + 1] - 1 > l):\n            l1 = l\n            r1 = a[i] + a[i + 1] - 1\n            new = True\n        elif a[i] - a[i + 1] + 1 < l and a[i] + a[i + 1] - 1 > r:\n            l1 = l\n            r1 = r\n            new = True\n        if len(pos) == 0 and new:\n            pos.append((l1, r1))\n        elif new and r1 >= pos[-1][0]:\n            temp = pos.pop()\n            pos.append((min(temp[0], l1), temp[1]))\n        elif new:\n            pos.append((l1, r1))\n    ans = 0\n    for i in pos:\n        ans += i[1] - i[0] + 1\n    print(ans)\n    c = c + 1", "import heapq as pq\n(n, L, R) = map(int, input().split())\nar = list(map(int, input().split()))\nar.sort()\nvec = []\nfor i in range(1, n):\n    vec.append((max(L - 1, ar[i] - ar[i - 1]), min(R + 1, ar[i] + ar[i - 1])))\npq.heapify(vec)\nvec = [pq.heappop(vec) for i in range(n - 1)]\nans = 0\ni = 0\nwhile i < n - 1:\n    st = vec[i][0]\n    en = vec[i][1]\n    i += 1\n    while i < n - 1 and vec[i][0] < en:\n        en = max(en, vec[i][1])\n        i += 1\n    if st < en:\n        ans += en - st - 1\nprint(ans)", "(n, L, R) = map(int, input().split())\nar = list(map(int, input().split()))\nar.sort()\nvec = []\nfor i in range(1, n):\n    vec.append((max(L - 1, ar[i] - ar[i - 1]), min(R + 1, ar[i] + ar[i - 1])))\nvec.sort()\nvec.append((1e+20, 1e+20))\nans = 0\ni = 0\nwhile i < n - 1:\n    st = vec[i][0]\n    en = vec[i][1]\n    i += 1\n    while i < n - 1 and vec[i][0] < en:\n        en = max(en, vec[i][1])\n        i += 1\n    if st < en:\n        ans += en - st - 1\nprint(ans)", "(n, L, R) = map(int, input().split())\nar = list(sorted(map(int, input().split())))\nvec = []\nfor i in range(1, n):\n    vec.append((max(L - 1, ar[i] - ar[i - 1]), min(R + 1, ar[i] + ar[i - 1])))\nvec.sort()\nvec.append((1e+20, 1e+20))\nans = 0\ni = 0\nwhile i < n - 1:\n    st = vec[i][0]\n    en = vec[i][1]\n    i += 1\n    while i < n - 1 and vec[i][0] < en:\n        en = max(en, vec[i][1])\n        i += 1\n    if st < en:\n        ans += en - st - 1\nprint(ans)", "(n, L, R) = map(int, input().split())\nar = list(sorted(map(int, input().split())))\nvec = []\nfor i in range(1, n):\n    vec.append((max(L - 1, ar[i] - ar[i - 1]), min(R + 1, ar[i] + ar[i - 1])))\nvec.sort()\nans = 0\ni = 0\nwhile i < n - 1:\n    st = vec[i][0]\n    en = vec[i][1]\n    i += 1\n    while i < n - 1 and vec[i][0] < en:\n        en = max(en, vec[i][1])\n        i += 1\n    if st < en:\n        ans += en - st - 1\nprint(ans)"]