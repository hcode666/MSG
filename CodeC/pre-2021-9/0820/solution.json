["p = 10 ** 9 + 7\nf = [0] * (10 ** 5 + 1)\nf[0] = f[1] = 1\nfor z in range(2, 10 ** 5 + 1):\n    f[z] = z * f[z - 1] % p\nt = int(input())\nfor i in range(t):\n    (n, x, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = [1] * x\n    ans = 0\n    j = 0\n    m %= p\n    for y in range(1, x):\n        c[y] = c[y - 1] * (m + (y - 1)) * f[y - 1] * pow(f[y], p - 2, p) % p\n    for u in range(x - 1, -1, -1):\n        ans = (ans + c[u] * a[j]) % p\n        j += 1\n    print(ans % p)", "p = 10 ** 9 + 7\nf = [0] * (10 ** 5 + 1)\nf[0] = f[1] = 1\nfor z in range(2, 10 ** 5 + 1):\n    f[z] = z * f[z - 1] % p\nt = int(input())\nfor i in range(t):\n    (n, x, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = [1] * x\n    ans = 0\n    j = 0\n    m %= p\n    for y in range(1, x):\n        c[y] = c[y - 1] * (m + (y - 1)) * f[y - 1] * pow(f[y], p - 2, p) % p\n    for u in range(x - 1, -1, -1):\n        ans = (ans + c[u] * a[j]) % p\n        j += 1\n    print(ans % p)", "p = 10 ** 9 + 7\nf = [0] * (10 ** 5 + 1)\nf[0] = f[1] = 1\nfor z in range(2, 10 ** 5 + 1):\n    f[z] = z * f[z - 1] % p\nt = int(input())\nfor i in range(t):\n    (n, x, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = [1] * x\n    ans = 0\n    j = 0\n    m %= p\n    for y in range(1, x):\n        c[y] = c[y - 1] * (m + (y - 1)) * f[y - 1] * pow(f[y], p - 2, p) % p\n    for u in range(x - 1, -1, -1):\n        ans = (ans + c[u] * a[j]) % p\n        j += 1\n    print(ans % p)", "p = 10 ** 9 + 7\nf = [0] * (10 ** 5 + 1)\nf[0] = f[1] = 1\nfor i in range(2, 10 ** 5 + 1):\n    f[i] = i * f[i - 1] % p\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    pre = [1] * x\n    ans = 0\n    j = 0\n    m = m % p\n    for i in range(1, x):\n        pre[i] = pre[i - 1] * (m + (i - 1)) * f[i - 1] * pow(f[i], p - 2, p) % p\n    for i in range(x - 1, -1, -1):\n        ans = (ans + pre[i] * a[j]) % p\n        j += 1\n    print(ans % p)", "p = 10 ** 9 + 7\nf = [0] * (10 ** 5 + 1)\nf[0] = f[1] = 1\nfor i in range(2, 10 ** 5 + 1):\n    f[i] = i * f[i - 1] % p\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    pre = [1] * x\n    ans = 0\n    j = 0\n    m = m % p\n    for i in range(1, x):\n        pre[i] = pre[i - 1] * (m + (i - 1)) * f[i - 1] * pow(f[i], p - 2, p) % p\n    for i in range(x - 1, -1, -1):\n        ans = (ans + pre[i] * a[j]) % p\n        j += 1\n    print(ans % p)", "p = 10 ** 9 + 7\nf = [0] * (10 ** 5 + 1)\nf[0] = f[1] = 1\nfor i in range(2, 10 ** 5 + 1):\n    f[i] = i * f[i - 1] % p\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    pre = [1] * x\n    ans = 0\n    j = 0\n    m = m % p\n    for i in range(1, x):\n        pre[i] = pre[i - 1] * (m + (i - 1)) * f[i - 1] * pow(f[i], p - 2, p) % p\n    for i in range(x - 1, -1, -1):\n        ans = (ans + pre[i] * a[j]) % p\n        j += 1\n    print(ans % p)", "def modInverse(a, m):\n    (m0, y, x) = (m, 0, 1)\n    if m == 1:\n        return 0\n    while a > 1:\n        (q, t) = (a // m, m)\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n(p, f) = (10 ** 9 + 7, [1] * (100000 + 1))\nfor i in range(1, 100000 + 1):\n    f[i] = i * f[i - 1] % p\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    (a, pre, ans, j, m) = (list(map(int, input().split())), [1] * x, 0, 0, m % p)\n    for i in range(1, x):\n        pre[i] = pre[i - 1] * (m + (i - 1)) * f[i - 1] * modInverse(f[i], p) % p\n    for i in range(x - 1, -1, -1):\n        ans = (ans + a[j] * pre[i]) % p\n        j += 1\n    print(ans % p)", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\np = 10 ** 9 + 7\nf = [1] * (100000 + 1)\nfor i in range(1, 100000 + 1):\n    f[i] = i * f[i - 1]\n    if f[i] > p:\n        f[i] = f[i] % p\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    m = m % p\n    a = list(map(int, input().split()))\n    pre = [1] * x\n    for i in range(1, x):\n        pre[i] = pre[i - 1] * (m + (i - 1)) * f[i - 1]\n        inv = modInverse(f[i], p)\n        pre[i] = pre[i] * inv % p\n    ans = 0\n    j = 0\n    for i in range(x - 1, -1, -1):\n        ans += a[j] * pre[i]\n        if ans > p:\n            ans = ans % p\n        j += 1\n    print(ans % p)", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\np = 10 ** 9 + 7\nf = [1] * (100000 + 1)\nfor i in range(1, 100000 + 1):\n    f[i] = i * f[i - 1]\n    if f[i] > p:\n        f[i] = f[i] % p\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    m = m % p\n    a = list(map(int, input().split()))\n    pre = [1] * x\n    for i in range(1, x):\n        pre[i] = pre[i - 1] * (m + (i - 1)) * f[i - 1]\n        inv = modInverse(f[i], p)\n        pre[i] = pre[i] * inv % p\n    ans = 0\n    j = 0\n    for i in range(x - 1, -1, -1):\n        ans += a[j] * pre[i]\n        if ans > p:\n            ans = ans % p\n        j += 1\n    print(ans % p)", "import math\nT = int(input())\nfor i in range(T):\n    (n, x, m) = map(int, input().split())\n    l1 = [int(i) for i in input().split()]\n    if x == 1:\n        l1[0] = l1[0] % 1000000007\n        print(l1[0])\n    elif x == 2:\n        m = m % 1000000007\n        l1[0] = l1[0] % 1000000007\n        l1[1] = (l1[1] % 1000000007 + l1[0] * m % 1000000007) % 1000000007\n        print(l1[1])\n    else:\n        m = m % 1000000007\n        c = -1\n        y = 0\n        q = 1\n        f = 1\n        y = l1[x - 1] % 1000000007\n        for j in range(x - 2, -1, -1):\n            c = c + 1\n            q = q * ((m + c) % 1000000007) % 1000000007\n            q = q * pow(c + 1, 1000000005, 1000000007) % 1000000007\n            y = (y + q * (l1[j] % 1000000007) % 1000000007) % 1000000007\n        print(y % 1000000007)", "f = []\nt = int(input())\nmod = 1000000007\nfor i in range(1, 100001):\n    f.append(pow(i, mod - 2, mod))\nfor i in range(t):\n    mul = 1\n    s = input().split(' ')\n    l = input().split(' ')\n    x = int(s[1])\n    mp = int(s[2])\n    q = int(l[x - 1]) % mod\n    for j in range(x - 1):\n        mul = mul * mp * f[j] % mod\n        mp += 1\n        q = q + mul * int(l[x - 2 - j]) % mod\n    print(q % mod)", "emod = 1000000007\nsave_list = []\ninverse = [1337]\n\ndef modpow(n, k):\n    if k == 0:\n        return 1\n    if k % 2 == 0:\n        return modpow(n * n % emod, k // 2)\n    else:\n        return modpow(n * n % emod, k // 2) * n % emod\n\ndef GenInvers():\n    i = 1\n    while i <= 100005:\n        inverse.append(modpow(i, emod - 2))\n        i += 1\n\ndef choose(n, k):\n    k = n - k\n    res = 1\n    i = 1\n    while i <= k:\n        res = res * (n - k + i) * inverse[i] % emod\n        save_list.append(res)\n        i += 1\nt = int(input())\nGenInvers()\nfor curent_test in range(t):\n    nxm = input().split()\n    n = int(nxm[0])\n    x = int(nxm[1])\n    m = int(nxm[2]) - 1\n    sum = 0\n    inp = input().split()\n    save_list = [1]\n    choose(m + (x - 1), m)\n    i = x - 1\n    j = 0\n    while i >= 0:\n        Ai = int(inp[i]) % emod\n        temp = Ai * save_list[j]\n        if temp >= emod:\n            temp %= emod\n        sum += temp\n        if sum >= emod:\n            sum %= emod\n        i -= 1\n        j += 1\n    print(sum)", "p = 10 ** 9 + 7\nN = [1, 1]\nfor i in range(2, 10 ** 5 + 1):\n    N.append(pow(i, p - 2, p) * N[-1] % p)\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    a = [0] + list(map(int, input().split()))\n    (val, total) = (m % p, a[x] % p)\n    for i in range(x - 1, 0, -1):\n        total = (a[i] * val * N[x - i] + total) % p\n        val = val * ((m + x - i) % p) % p\n    print(total)", "p = 10 ** 9 + 7\nN = [1, 1]\nfor i in range(2, 10 ** 5 + 1):\n    N.append(pow(i, p - 2, p) * N[-1] % p)\nfor _ in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    a = [0] + list(map(int, input().split()))\n    (val, total) = (m % p, a[x])\n    for i in range(x - 1, 0, -1):\n        total = (a[i] % p * val * N[x - i] + total) % p\n        val = val * ((m + x - i) % p) % p\n    print(total % p)", "f = []\nt = int(input())\nmod = 1000000007\nfor i in range(1, 100001):\n    f.append(pow(i, mod - 2, mod))\nfor i in range(t):\n    mul = 1\n    s = input().split(' ')\n    l = input().split(' ')\n    x = int(s[1])\n    mp = int(s[2])\n    q = int(l[x - 1]) % mod\n    for j in range(x - 1):\n        mul = mul * mp * f[j] % mod\n        mp += 1\n        q = q + mul * int(l[x - 2 - j]) % mod\n    print(q % mod)", "f = []\nt = int(input())\nmod = 1000000007\nfor i in range(1, 100001):\n    f.append(pow(i, mod - 2, mod))\nfor i in range(t):\n    mul = 1\n    s = input().split(' ')\n    l = input().split(' ')\n    x = int(s[1])\n    mp = int(s[2])\n    q = int(l[x - 1]) % mod\n    for j in range(x - 1):\n        mul = mul * mp * f[j] % mod\n        mp += 1\n        q = q + mul * int(l[x - 2 - j]) % mod\n    print(q % mod)", "modulo = 1000000007\nfood = []\nt = int(input())\nfor x in range(1, 100001):\n    food.append(pow(x, modulo - 2, modulo))\nfor i in range(t):\n    s = input()\n    s = s.split(' ')\n    n = int(s[0])\n    x = int(s[1])\n    m = int(s[2])\n    l = input().split(' ')\n    q = int(l[x - 1]) % modulo\n    multi = 1\n    for j in range(x - 1):\n        multi = multi * m * food[j] % modulo\n        m += 1\n        q = q + multi * int(l[x - 2 - j]) % modulo\n    print(q % modulo)", "MOD = 1000000007\narr = []\n\ndef calc(m, x):\n    num = (m - 1) % MOD\n    den = 0\n    i = 0\n    curEle = 1\n    ans = 0\n    ans += arr[x - i] * curEle\n    ans = ans % MOD\n    num += 1\n    den += 1\n    i += 1\n    while i < x:\n        curEle = curEle % MOD * (num % MOD) % MOD * pow(den, MOD - 2, MOD) % MOD\n        ans += arr[x - i] * curEle\n        ans = ans % MOD\n        num += 1\n        den += 1\n        i += 1\n    return ans\nt = int(input())\nfor i in range(t):\n    line = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    arr.insert(0, 0)\n    n = line[0]\n    x = line[1]\n    m = line[2]\n    ans = calc(m, x)\n    print(ans)", "t = int(input())\ns = ''\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nfor i in range(t):\n    (n, x, m) = map(int, input().split())\n    m %= 1000000007\n    A = list(map(int, input().split()))\n    ans = A[x - 1]\n    temp = 1\n    val = 0\n    for i in range(x - 2, -1, -1):\n        x = modinv(val + 1, 1000000007)\n        temp = temp * (m + val) * x % 1000000007\n        A[i] %= 1000000007\n        ans += A[i] * temp\n        ans %= 1000000007\n        val += 1\n    s += str(ans % 1000000007) + '\\n'\nprint(s, end='')", "def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nt = int(input())\nfor _ in range(t):\n    (n, select, m) = map(int, input().split())\n    m = m % 1000000007\n    arr = list(map(int, input().split()))\n    for i in range(select):\n        arr[i] = arr[i] % 1000000007\n    ans = arr[select - 1]\n    temp = 1\n    tp = 0\n    for i in range(select - 2, -1, -1):\n        temp = temp * (m + tp) % 1000000007\n        q = modinv(tp + 1, 1000000007)\n        temp = temp * q % 1000000007\n        ans += arr[i] * temp\n        ans = ans % 1000000007\n        tp += 1\n    print(ans % 1000000007)", "MOD = 10 ** 9 + 7\nfor t in range(int(input())):\n    (n, x, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    (v, c) = (a[x - 1] % MOD, 1)\n    for i in range(1, x):\n        c = c * (m + i - 1) * pow(i, MOD - 2, MOD) % MOD\n        v = (v + c * a[x - 1 - i]) % MOD\n    print(v)", "MOD = 1000000007\nMMI = lambda A, n, s=1, t=0, N=0: (n < 2 and t % N or MMI(n, A % n, t, s - A // n * t, N or n), -1)[n < 1]\nt = int(input())\nfor test in range(t):\n    (n, x, m) = map(int, input().split())\n    ls = list(map(int, input().split()))\n    for i in range(n):\n        ls[i] = ls[i] % MOD\n    (su, y, m) = (0, m, m - 1)\n    ml = [0 for i in range(x)]\n    (n, d, ml[0]) = (m % MOD, m % MOD, 1)\n    for i in range(1, x):\n        ml[i] = ml[i - 1] * (n + 1) % MOD\n        d = MMI(n + 1 - m, MOD)\n        ml[i] = ml[i] * d % MOD\n        n += 1\n    ml = ml[::-1]\n    for i in range(x):\n        su = (su + ml[i] * ls[i] % MOD) % MOD\n    print(su)", "MOD = 1000000007\nMMI = lambda A, n, s=1, t=0, N=0: (n < 2 and t % N or MMI(n, A % n, t, s - A // n * t, N or n), -1)[n < 1]\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a):\n    (g, x, y) = egcd(a, MOD)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % MOD\nt = int(input())\nfor test in range(t):\n    (n, x, m) = map(int, input().split())\n    ls = list(map(int, input().split()))\n    for i in range(n):\n        ls[i] = ls[i] % MOD\n    su = 0\n    y = m\n    m = m - 1\n    su = 0\n    ml = [0 for i in range(x)]\n    ml[0] = 1\n    (n, d) = (m % MOD, m % MOD)\n    for i in range(1, x):\n        ml[i] = ml[i - 1] * (n + 1)\n        ml[i] = ml[i] % MOD\n        d = MMI(n + 1 - m, MOD)\n        ml[i] = ml[i] * d\n        ml[i] = ml[i] % MOD\n        n += 1\n    ml = ml[::-1]\n    for i in range(x):\n        su = su + ml[i] * ls[i] % MOD\n        su = su % MOD\n    print(su)", "MOD = 1000000007\nMAXN = 100005\nINV_MOD = [0] * MAXN\n\ndef MOD_POW(a, b):\n    ret = int(1)\n    while b > 0:\n        if b & 1:\n            ret = ret * a\n            ret %= MOD\n        a = a * a\n        a %= MOD\n        b //= 2\n    return ret\n\ndef PREPROCESS():\n    for i in range(1, MAXN):\n        INV_MOD[i] = MOD_POW(int(i), MOD - 2)\n\ndef solve():\n    s = input()\n    (N, X, M) = s.strip().split(' ')\n    N = int(N)\n    X = int(X)\n    M = int(M)\n    s = input()\n    A = [int(x) for x in s.strip().split(' ')]\n    ans = int(0)\n    coeff = int(1)\n    j = int(1)\n    for i in range(X - 1, -1, -1):\n        ans = ans + A[i] * coeff\n        coeff = coeff * (M + j - 1)\n        coeff = coeff * INV_MOD[j]\n        ans %= MOD\n        coeff %= MOD\n        j += 1\n    print(ans)\n\ndef main():\n    PREPROCESS()\n    t = int(input())\n    while t > 0:\n        solve()\n        t -= 1\nmain()", "MOD = 10 ** 9 + 7\nd = dict()\n\ndef power(x, y):\n    if not y:\n        return 1\n    p = power(x, y // 2) % MOD\n    p = p * p % MOD\n    if y & 1:\n        return x * p % MOD\n    return p % MOD\n\ndef mod_inverse(x):\n    if x in d:\n        return d[x]\n    d[x] = power(x, MOD - 2)\n    return d[x]\nt = int(input())\nfor _ in range(t):\n    (n, x, m) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    ans = arr[x - 1] % MOD\n    p = 1\n    for i in range(x - 2, -1, -1):\n        p = p * (m + x - i - 2) * mod_inverse(x - i - 1) % MOD\n        ans = (ans + p * arr[i]) % MOD\n    print(ans)", "import sys\nMOD = 10 ** 9 + 7\nf = sys.stdin\nT = int(f.readlines(1)[0])\nfor t in range(T):\n    (N, X, M) = map(int, f.readlines(1)[0].split())\n    A = list(map(int, f.readlines(1)[0].split()))\n    X -= 1\n    sol = A[X] % MOD\n    i = X - 1\n    cnt = 0\n    nCr = 1\n    while i >= 0:\n        cnt += 1\n        nCr = nCr * (M + cnt - 1) % MOD\n        nCr = nCr * pow(cnt, MOD - 2, MOD) % MOD\n        sol = (sol + A[i] * nCr) % MOD\n        i -= 1\n    print(sol)"]