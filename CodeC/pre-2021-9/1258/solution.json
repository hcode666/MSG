["import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef calc_colors(nodes, x, colors, exp_color, parent):\n    total_value = 0\n    total_value1 = 0\n    if exp_color == '1':\n        val = 1\n        next_exp = '0'\n    else:\n        val = -1\n        next_exp = '1'\n    if colors[x] != exp_color:\n        total_value = val\n    else:\n        total_value1 = val\n    total_dist = 0\n    total_dist1 = 0\n    for i in nodes[x]:\n        if i == parent:\n            continue\n        (dist, val, dist1, val1) = calc_colors(nodes, i, colors, next_exp, x)\n        total_dist += dist\n        total_value += val\n        total_dist1 += dist1\n        total_value1 += val1\n    total_dist += abs(total_value)\n    total_dist1 += abs(total_value1)\n    return (total_dist, total_value, total_dist1, total_value1)\n\ndef solve() -> None:\n    n = int(input())\n    nodes = []\n    for i in range(n):\n        nodes.append([])\n    for i in range(n - 1):\n        (u, v) = tuple(map(int, input().split()))\n        nodes[u - 1].append(v - 1)\n        nodes[v - 1].append(u - 1)\n    colors = input()\n    (dist1, val1, dist2, val2) = calc_colors(nodes, 0, colors, '0', 0)\n    if val1 != 0 != val2:\n        print(-1)\n    elif val1 == 0 == val2:\n        if dist1 > dist2:\n            print(dist2)\n        else:\n            print(dist1)\n    elif val1 == 0:\n        print(dist1)\n    else:\n        print(dist2)\nt = int(input())\nfor i in range(t):\n    try:\n        solve()\n    except RecursionError:\n        print('recursionerror')", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef calc_colors(nodes, x, colors, exp_color, parent):\n    total_value = 0\n    total_value1 = 0\n    if exp_color == '1':\n        val = 1\n        next_exp = '0'\n    else:\n        val = -1\n        next_exp = '1'\n    if colors[x] != exp_color:\n        total_value = val\n    else:\n        total_value1 = val\n    total_dist = 0\n    total_dist1 = 0\n    for i in nodes[x]:\n        nodes[i].remove(x)\n        (dist, val, dist1, val1) = calc_colors(nodes, i, colors, next_exp, x)\n        total_dist += dist\n        total_value += val\n        total_dist1 += dist1\n        total_value1 += val1\n    total_dist += abs(total_value)\n    total_dist1 += abs(total_value1)\n    return (total_dist, total_value, total_dist1, total_value1)\n\ndef solve() -> None:\n    n = int(input())\n    nodes = []\n    for i in range(n):\n        nodes.append([])\n    for i in range(n - 1):\n        (u, v) = tuple(map(int, input().split()))\n        nodes[u - 1].append(v - 1)\n        nodes[v - 1].append(u - 1)\n    colors = input()\n    (dist1, val1, dist2, val2) = calc_colors(nodes, 0, colors, '0', 0)\n    if val1 != 0 != val2:\n        print(-1)\n    elif val1 == 0 == val2:\n        if dist1 > dist2:\n            print(dist2)\n        else:\n            print(dist1)\n    elif val1 == 0:\n        print(dist1)\n    else:\n        print(dist2)\nt = int(input())\nfor i in range(t):\n    try:\n        solve()\n    except RecursionError:\n        print('recursionerror')", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef calc_colors(nodes, x, colors, exp_color, parent):\n    total_value = 0\n    total_value1 = 0\n    if exp_color == '1':\n        val = 1\n        next_exp = '0'\n    else:\n        val = -1\n        next_exp = '1'\n    if colors[x] != exp_color:\n        total_value = val\n    else:\n        total_value1 = val\n    total_dist = 0\n    total_dist1 = 0\n    for i in nodes[x]:\n        if i == parent:\n            continue\n        (dist, val, dist1, val1) = calc_colors(nodes, i, colors, next_exp, x)\n        total_dist += dist\n        total_value += val\n        total_dist1 += dist1\n        total_value1 += val1\n    total_dist += abs(total_value)\n    total_dist1 += abs(total_value1)\n    return (total_dist, total_value, total_dist1, total_value1)\n\ndef solve() -> None:\n    n = int(input())\n    nodes = []\n    for i in range(n):\n        nodes.append([])\n    for i in range(n - 1):\n        (u, v) = tuple(map(int, input().split()))\n        nodes[u - 1].append(v - 1)\n        nodes[v - 1].append(u - 1)\n    colors = input()\n    (dist1, val1, dist2, val2) = calc_colors(nodes, 0, colors, '0', 0)\n    if val1 != 0 != val2:\n        print(-1)\n    elif val1 == 0 == val2:\n        if dist1 > dist2:\n            print(dist2)\n        else:\n            print(dist1)\n    elif val1 == 0:\n        print(dist1)\n    else:\n        print(dist2)\nt = int(input())\nfor i in range(t):\n    try:\n        solve()\n    except RecursionError:\n        print('recursionerror')", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef calc_colors(nodes, x, colors, exp_color, parent):\n    total_value = 0\n    total_value1 = 0\n    if colors[x] != exp_color:\n        total_value = 1 if exp_color == '1' else -1\n    else:\n        total_value1 = 1 if exp_color == '1' else -1\n    total_dist = 0\n    total_dist1 = 0\n    next_exp = '1' if exp_color == '0' else '0'\n    for i in nodes[x]:\n        if i == parent:\n            continue\n        (dist, val, dist1, val1) = calc_colors(nodes, i, colors, next_exp, x)\n        total_dist += dist\n        total_value += val\n        total_dist1 += dist1\n        total_value1 += val1\n    total_dist += abs(total_value)\n    total_dist1 += abs(total_value1)\n    return (total_dist, total_value, total_dist1, total_value1)\n\ndef solve() -> None:\n    n = int(input())\n    nodes = []\n    for i in range(n):\n        nodes.append([])\n    for i in range(n - 1):\n        (u, v) = tuple(map(int, input().split()))\n        nodes[u - 1].append(v - 1)\n        nodes[v - 1].append(u - 1)\n    colors = input()\n    (dist1, val1, dist2, val2) = calc_colors(nodes, 0, colors, '0', 0)\n    if val1 != 0 != val2:\n        print(-1)\n    elif val1 == 0 == val2:\n        if dist1 > dist2:\n            print(dist2)\n        else:\n            print(dist1)\n    elif val1 == 0:\n        print(dist1)\n    else:\n        print(dist2)\nt = int(input())\nfor i in range(t):\n    try:\n        solve()\n    except RecursionError:\n        print('recursionerror')", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef calc_colors(nodes, x, colors, exp_color, parent):\n    total_value = 0\n    if colors[x] != exp_color:\n        total_value = 1 if exp_color == '1' else -1\n    total_dist = 0\n    next_exp = '1' if exp_color == '0' else '0'\n    for i in nodes[x]:\n        if i == parent:\n            continue\n        (dist, val) = calc_colors(nodes, i, colors, next_exp, x)\n        total_dist += dist\n        total_value += val\n    total_dist += abs(total_value)\n    return (total_dist, total_value)\n\ndef solve() -> None:\n    n = int(input())\n    nodes = []\n    for i in range(n):\n        nodes.append([])\n    for i in range(n - 1):\n        (u, v) = tuple(map(int, input().split()))\n        nodes[u - 1].append(v - 1)\n        nodes[v - 1].append(u - 1)\n    colors = input()\n    (dist1, val1) = calc_colors(nodes, 0, colors, '0', 0)\n    (dist2, val2) = calc_colors(nodes, 0, colors, '1', 0)\n    if val1 != 0 != val2:\n        print(-1)\n    elif val1 == 0 == val2:\n        if dist1 > dist2:\n            print(dist2)\n        else:\n            print(dist1)\n    elif val1 == 0:\n        print(dist1)\n    else:\n        print(dist2)\nt = int(input())\nfor i in range(t):\n    try:\n        solve()\n    except RecursionError:\n        print('recursionerror')", "import sys, math\nimport io, os\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data():\n    return sys.stdin.readline().strip()\n\ndef mdata():\n    return list(map(int, data().split()))\n\ndef outl(var):\n    sys.stdout.write(' '.join(map(str, var)) + '\\n')\n\ndef out(var):\n    sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\nINF = float('inf')\nmod = int(1000000000.0) + 7\n\ndef dfs(graph, start, col_start):\n    n = len(graph)\n    dp = [0] * n\n    (visited, finished) = ([False] * n, [False] * n)\n    ans = 0\n    stack = [(start, col_start)]\n    while stack:\n        (start, c) = stack[-1]\n        if not visited[start]:\n            visited[start] = True\n            for child in graph[start]:\n                if not visited[child]:\n                    stack.append((child, 1 - c))\n        else:\n            stack.pop()\n            if S[start] != c:\n                dp[start] += S[start] - c\n            for child in graph[start]:\n                if finished[child]:\n                    dp[start] += dp[child]\n                    ans += abs(dp[child])\n            finished[start] = True\n    if dp[0] != 0:\n        ans = -1\n    return ans\nfor t in range(int(data())):\n    n = int(data())\n    graph = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = mdata()\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n    S = list(map(int, data()))\n    ans1 = dfs(graph, 0, 0)\n    ans2 = dfs(graph, 0, 1)\n    if ans1 == -1 or ans2 == -1:\n        out(max(ans1, ans2))\n    else:\n        out(min(ans1, ans2))", "import sys, math\nimport io, os\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data():\n    return sys.stdin.readline().strip()\n\ndef mdata():\n    return list(map(int, data().split()))\n\ndef outl(var):\n    sys.stdout.write(' '.join(map(str, var)) + '\\n')\n\ndef out(var):\n    sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\nINF = float('inf')\nmod = int(1000000000.0) + 7\n\ndef dfs(graph, start, col_start):\n    n = len(graph)\n    dp = [0] * n\n    (visited, finished) = ([False] * n, [False] * n)\n    ans = 0\n    stack = [(start, col_start)]\n    while stack:\n        (start, c) = stack[-1]\n        if not visited[start]:\n            visited[start] = True\n            for child in graph[start]:\n                if not visited[child]:\n                    stack.append((child, 1 - c))\n        else:\n            stack.pop()\n            if S[start] != c:\n                dp[start] += S[start] - c\n            for child in graph[start]:\n                if finished[child]:\n                    dp[start] += dp[child]\n                    ans += abs(dp[child])\n            finished[start] = True\n    if dp[0] != 0:\n        ans = -1\n    return ans\nfor t in range(int(data())):\n    n = int(data())\n    graph = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = mdata()\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n    S = list(map(int, data()))\n    ans1 = dfs(graph, 0, 0)\n    ans2 = dfs(graph, 0, 1)\n    if ans1 == -1 or ans2 == -1:\n        out(max(ans1, ans2))\n    else:\n        out(min(ans1, ans2))", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for i in range(n)]\n    visited = [False for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        g[a - 1].append(b - 1)\n        g[b - 1].append(a - 1)\n    col = [int(i) for i in str(input())]\n\n    def dfs(node, k):\n        cost = delta = 0\n        visited[node] = True\n        if col[node] != k:\n            if k == 1:\n                delta = 1\n            else:\n                delta = -1\n        for i in g[node]:\n            if visited[i] == False:\n                (c, d) = dfs(i, k ^ 1)\n                cost += c + abs(d)\n                delta += d\n        return (cost, delta)\n    (cost1, delta1) = dfs(0, k=1)\n    visited = [False for i in range(n)]\n    (cost2, delta2) = dfs(0, k=0)\n    if delta1 == 0:\n        if delta2 == 0:\n            print(min(cost1, cost2))\n        else:\n            print(cost1)\n    elif delta2 == 0:\n        print(cost2)\n    else:\n        print(-1)", "import sys\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    N = int(input())\n    G = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        G[u - 1] += [v - 1]\n        G[v - 1] += [u - 1]\n    C = [-1] * N\n    C[0] = 0\n    que = [0]\n    g = [[] for i in range(N)]\n    E = []\n    while que:\n        q = que.pop()\n        c = 1 - C[q]\n        for v in G[q]:\n            if C[v] == -1:\n                g[q] += [v]\n                C[v] = c\n        que += g[q]\n        E += g[q]\n    S = [int(i) for i in input()]\n    sc = sum(C)\n    ss = sum(S)\n    if sc != ss and sc + ss != N:\n        print(-1)\n        continue\n    if ss != sc:\n        C = [1 - i for i in C]\n    cs = [-1] * N\n    ss = [-1] * N\n\n    def countc(x, note, y):\n        if note[x] != -1:\n            return note[x]\n        note[x] = y[x]\n        for v in g[x]:\n            note[x] += countc(v, note, y)\n        return note[x]\n    countc(0, cs, C)\n    countc(0, ss, S)\n    ans = 0\n    for v in E:\n        ans += abs(cs[v] - ss[v])\n    if N % 2 == 0 and sc == N // 2:\n        C = [1 - i for i in C]\n        cs = [-1] * N\n        countc(0, cs, C)\n        ans = min(ans, sum([abs(cs[v] - ss[v]) for v in E]))\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for i in range(n)]\n    visited = [False for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        g[a - 1].append(b - 1)\n        g[b - 1].append(a - 1)\n    col = [int(i) for i in str(input())]\n    cost = [0 for i in range(n)]\n    delta = [0 for i in range(n)]\n\n    def dfs(node, k):\n        visited[node] = True\n        for i in g[node]:\n            if visited[i] == False:\n                dfs(i, k ^ 1)\n                cost[node] += cost[i] + abs(delta[i])\n                delta[node] += delta[i]\n        if col[node] != k:\n            if k == 1:\n                delta[node] += 1\n            else:\n                delta[node] -= 1\n        return (cost, delta)\n    dfs(0, k=1)\n    cost1 = cost[0]\n    delta1 = delta[0]\n    cost = [0 for i in range(n)]\n    delta = [0 for i in range(n)]\n    visited = [False for i in range(n)]\n    dfs(0, k=0)\n    cost2 = cost[0]\n    delta2 = delta[0]\n    if delta1 == 0:\n        if delta2 == 0:\n            print(min(cost1, cost2))\n        else:\n            print(cost1)\n    elif delta2 == 0:\n        print(cost2)\n    else:\n        print(-1)", "import sys, math\nimport io, os\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data():\n    return sys.stdin.readline().strip()\n\ndef mdata():\n    return list(map(int, data().split()))\n\ndef outl(var):\n    sys.stdout.write(' '.join(map(str, var)) + '\\n')\n\ndef out(var):\n    sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\nINF = float('inf')\nmod = int(1000000000.0) + 7\n\ndef dfs(graph, start, col_start):\n    n = len(graph)\n    dp = [0] * n\n    (visited, finished) = ([False] * n, [False] * n)\n    ans = 0\n    stack = [(start, col_start)]\n    while stack:\n        (start, c) = stack[-1]\n        if not visited[start]:\n            visited[start] = True\n            for child in graph[start]:\n                if not visited[child]:\n                    stack.append((child, 1 - c))\n        else:\n            stack.pop()\n            if S[start] != c:\n                dp[start] += S[start] - c\n            for child in graph[start]:\n                if finished[child]:\n                    dp[start] += dp[child]\n                    ans += abs(dp[child])\n            finished[start] = True\n    if dp[0] != 0:\n        ans = -1\n    return ans\nfor t in range(int(data())):\n    n = int(data())\n    graph = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = mdata()\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n    S = list(map(int, data()))\n    ans1 = dfs(graph, 0, 0)\n    ans2 = dfs(graph, 0, 1)\n    if ans1 == -1 or ans2 == -1:\n        out(max(ans1, ans2))\n    else:\n        out(min(ans1, ans2))", "import sys\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    N = int(input())\n    G = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        G[u - 1] += [v - 1]\n        G[v - 1] += [u - 1]\n    C = [-1] * N\n    C[0] = 0\n    que = [0]\n    g = [[] for i in range(N)]\n    E = []\n    while que:\n        q = que.pop()\n        c = 1 - C[q]\n        for v in G[q]:\n            if C[v] == -1:\n                g[q] += [v]\n                C[v] = c\n        que += g[q]\n        E += g[q]\n    S = [int(i) for i in input()]\n    sc = sum(C)\n    ss = sum(S)\n    if sc != ss and sc + ss != N:\n        print(-1)\n        continue\n    if ss != sc:\n        C = [1 - i for i in C]\n    cs = [-1] * N\n    ss = [-1] * N\n\n    def countc(x, note, y):\n        if note[x] != -1:\n            return note[x]\n        note[x] = y[x]\n        for v in g[x]:\n            note[x] += countc(v, note, y)\n        return note[x]\n    countc(0, cs, C)\n    countc(0, ss, S)\n    ans = 0\n    for v in E:\n        ans += abs(cs[v] - ss[v])\n    if N % 2 == 0 and sc == N // 2:\n        C = [1 - i for i in C]\n        cs = [-1] * N\n        countc(0, cs, C)\n        ans = min(ans, sum([abs(cs[v] - ss[v]) for v in E]))\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    N = int(input())\n    G = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        G[u - 1] += [v - 1]\n        G[v - 1] += [u - 1]\n    C = [-1] * N\n    C[0] = 0\n    que = [0]\n    g = [[] for i in range(N)]\n    E = []\n    while que:\n        q = que.pop()\n        c = 1 - C[q]\n        for v in G[q]:\n            if C[v] == -1:\n                g[q] += [v]\n                C[v] = c\n        que += g[q]\n        E += g[q]\n    S = [int(i) for i in input()]\n    sc = sum(C)\n    ss = sum(S)\n    if sc != ss and sc + ss != N:\n        print(-1)\n        continue\n    if ss != sc:\n        C = [1 - i for i in C]\n    cs = [-1] * N\n    ss = [-1] * N\n\n    def countc(x, note, y):\n        if note[x] != -1:\n            return note[x]\n        note[x] = y[x]\n        for v in g[x]:\n            note[x] += countc(v, note, y)\n        return note[x]\n    countc(0, cs, C)\n    countc(0, ss, S)\n    ans = 0\n    for v in E:\n        ans += abs(cs[v] - ss[v])\n    if N % 2 == 0 and sc == N // 2:\n        C = [1 - i for i in C]\n        cs = [-1] * N\n        countc(0, cs, C)\n        ans = min(ans, sum([abs(cs[v] - ss[v]) for v in E]))\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    N = int(input())\n    G = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        G[u - 1] += [v - 1]\n        G[v - 1] += [u - 1]\n    C = [-1] * N\n    C[0] = 0\n    que = [0]\n    g = [[] for i in range(N)]\n    E = []\n    while que:\n        q = que.pop()\n        c = 1 - C[q]\n        for v in G[q]:\n            if C[v] == -1:\n                g[q] += [v]\n                C[v] = c\n        que += g[q]\n        E += g[q]\n    S = [int(i) for i in input()]\n    sc = sum(C)\n    ss = sum(S)\n    if sc != ss and sc + ss != N:\n        print(-1)\n        continue\n    if ss != sc:\n        C = [1 - i for i in C]\n    cs = [-1] * N\n    ss = [-1] * N\n\n    def countc(x, note, y):\n        if note[x] != -1:\n            return note[x]\n        note[x] = y[x]\n        for v in g[x]:\n            note[x] += countc(v, note, y)\n        return note[x]\n    countc(0, cs, C)\n    countc(0, ss, S)\n    ans = 0\n    for v in E:\n        ans += abs(cs[v] - ss[v])\n    if N % 2 == 0 and sc == N // 2:\n        C = [1 - i for i in C]\n        cs = [-1] * N\n        countc(0, cs, C)\n        ans = min(ans, sum([abs(cs[v] - ss[v]) for v in E]))\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    N = int(input())\n    G = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        G[u - 1] += [v - 1]\n        G[v - 1] += [u - 1]\n    C = [-1] * N\n    C[0] = 0\n    que = [0]\n    g = [[] for i in range(N)]\n    E = []\n    while que:\n        q = que.pop()\n        c = 1 - C[q]\n        for v in G[q]:\n            if C[v] == -1:\n                g[q] += [v]\n                C[v] = c\n        que += g[q]\n        E += g[q]\n    S = [int(i) for i in input()]\n    sc = sum(C)\n    ss = sum(S)\n    if sc != ss and sc + ss != N:\n        print(-1)\n        continue\n    if ss != sc:\n        C = [1 - i for i in C]\n    cs = [-1] * N\n    ss = [-1] * N\n\n    def countc(x, note, y):\n        if note[x] != -1:\n            return note[x]\n        note[x] = y[x]\n        for v in g[x]:\n            note[x] += countc(v, note, y)\n        return note[x]\n    countc(0, cs, C)\n    countc(0, ss, S)\n    ans = 0\n    for v in E:\n        ans += abs(cs[v] - ss[v])\n    if N % 2 == 0 and sc == N // 2:\n        C = [1 - i for i in C]\n        cs = [-1] * N\n        countc(0, cs, C)\n        ans = min(ans, sum([abs(cs[v] - ss[v]) for v in E]))\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    N = int(input())\n    G = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        G[u - 1] += [v - 1]\n        G[v - 1] += [u - 1]\n    C = [-1] * N\n    C[0] = 0\n    que = [0]\n    g = [[] for i in range(N)]\n    E = []\n    while que:\n        q = que.pop()\n        c = 1 - C[q]\n        for v in G[q]:\n            if C[v] == -1:\n                g[q] += [v]\n                C[v] = c\n        que += g[q]\n        E += g[q]\n    S = [int(i) for i in input()]\n    sc = sum(C)\n    ss = sum(S)\n    if sc != ss and sc + ss != N:\n        print(-1)\n        continue\n    if ss != sc:\n        C = [1 - i for i in C]\n    cs = [-1] * N\n    ss = [-1] * N\n\n    def countc(x, note, y):\n        if note[x] != -1:\n            return note[x]\n        note[x] = y[x]\n        for v in g[x]:\n            note[x] += countc(v, note, y)\n        return note[x]\n    countc(0, cs, C)\n    countc(0, ss, S)\n    ans = 0\n    for v in E:\n        ans += abs(cs[v] - ss[v])\n    if N % 2 == 0 and sc == N // 2:\n        C = [1 - i for i in C]\n        cs = [-1] * N\n        countc(0, cs, C)\n        ans = min(ans, sum([abs(cs[v] - ss[v]) for v in E]))\n    print(ans)"]