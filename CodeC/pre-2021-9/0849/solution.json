["import queue\n\ndef BFS(start, end, dist, adj, s):\n    vis = queue.Queue()\n    vis.put(start)\n    dist[start] = 0\n    while vis.qsize() > 0:\n        ind = vis.get()\n        if ind > 0 and dist[ind - 1] == -1:\n            dist[ind - 1] = dist[ind] + 1\n            vis.put(ind - 1)\n        if ind < len(s) - 1 and dist[ind + 1] == -1:\n            dist[ind + 1] = dist[ind] + 1\n            vis.put(ind + 1)\n        for v in adj[s[ind]]:\n            if dist[v] == -1:\n                dist[v] = dist[ind] + 1\n                vis.put(v)\n        adj[s[ind]].clear()\n    return dist[end]\ns = [int(x) for x in input().strip()]\nN = len(s)\ndist = [-1 for _ in range(N)]\nadj = [[] for _ in range(10)]\nfor i in range(N):\n    adj[s[i]].append(i)\nprint(BFS(0, N - 1, dist, adj, s))", "from collections import deque\nseq = [int(x) for x in list(input()) if x.isdigit()]\npos = [[] for _ in range(10)]\nfor (i, e) in enumerate(seq):\n    pos[e].append(i)\ndist = [-1] * len(seq)\ndist[0] = 0\nQ = deque([0])\nwhile Q:\n    i = Q.popleft()\n    if i > 0 and dist[i - 1] == -1:\n        dist[i - 1] = dist[i] + 1\n        Q.append(i - 1)\n    if i + 1 < len(seq) and dist[i + 1] == -1:\n        dist[i + 1] = dist[i] + 1\n        Q.append(i + 1)\n    for j in pos[seq[i]]:\n        if dist[j] != -1:\n            continue\n        dist[j] = dist[i] + 1\n        Q.append(j)\n    pos[seq[i]].clear()\nprint(dist[-1])", "from collections import deque\nseq = [int(x) for x in input().strip()]\npos = [[] for _ in range(10)]\nfor (i, e) in enumerate(seq):\n    pos[e].append(i)\ndist = [-1] * len(seq)\ndist[0] = 0\nQ = deque([0])\nwhile Q:\n    i = Q.popleft()\n    if i > 0 and dist[i - 1] == -1:\n        dist[i - 1] = dist[i] + 1\n        Q.append(i - 1)\n    if i + 1 < len(seq) and dist[i + 1] == -1:\n        dist[i + 1] = dist[i] + 1\n        Q.append(i + 1)\n    for j in pos[seq[i]]:\n        if dist[j] != -1:\n            continue\n        dist[j] = dist[i] + 1\n        Q.append(j)\n    pos[seq[i]].clear()\nprint(dist[-1])", "from collections import deque\ns = [int(x) for x in input().strip()]\nN = len(s)\n(dist, a) = ([-1 for _ in range(N)], [[] for _ in range(10)])\nfor i in range(N):\n    a[s[i]].append(i)\nseen = deque([0])\ndist[0] = 0\nwhile seen:\n    idx = seen.popleft()\n    if idx > 0 and dist[idx - 1] == -1:\n        dist[idx - 1] = dist[idx] + 1\n        seen.append(idx - 1)\n    if idx < len(s) - 1 and dist[idx + 1] == -1:\n        dist[idx + 1] = dist[idx] + 1\n        seen.append(idx + 1)\n    for v in a[s[idx]]:\n        if dist[v] == -1:\n            dist[v] = dist[idx] + 1\n            seen.append(v)\n    a[s[idx]].clear()\nprint(dist[-1])", "import queue\ns = [int(x) for x in input().strip()]\nN = len(s)\n(dist, a) = ([-1 for _ in range(N)], [[] for _ in range(10)])\nfor i in range(N):\n    a[s[i]].append(i)\nseen = queue.Queue()\nseen.put(0)\ndist[0] = 0\nwhile seen.qsize() > 0:\n    idx = seen.get()\n    if idx > 0 and dist[idx - 1] == -1:\n        dist[idx - 1] = dist[idx] + 1\n        seen.put(idx - 1)\n    if idx < len(s) - 1 and dist[idx + 1] == -1:\n        dist[idx + 1] = dist[idx] + 1\n        seen.put(idx + 1)\n    for v in a[s[idx]]:\n        if dist[v] == -1:\n            dist[v] = dist[idx] + 1\n            seen.put(v)\n    a[s[idx]].clear()\nprint(dist[-1])", "import queue\n\ndef BFS(start, end, dist, adj, s):\n    vis = queue.Queue()\n    vis.put(start)\n    dist[start] = 0\n    while vis.qsize() > 0:\n        ind = vis.get()\n        if ind > 0 and dist[ind - 1] == -1:\n            dist[ind - 1] = dist[ind] + 1\n            vis.put(ind - 1)\n        if ind < len(s) - 1 and dist[ind + 1] == -1:\n            dist[ind + 1] = dist[ind] + 1\n            vis.put(ind + 1)\n        for v in adj[s[ind]]:\n            if dist[v] == -1:\n                dist[v] = dist[ind] + 1\n                vis.put(v)\n        adj[s[ind]].clear()\n    return dist[end]\ns = [int(x) for x in input().strip()]\nN = len(s)\ndist = [-1 for _ in range(N)]\nadj = [[] for _ in range(10)]\nfor i in range(N):\n    adj[s[i]].append(i)\nprint(BFS(0, N - 1, dist, adj, s))", "import heapq\nimport sys\n\ndef main(raw_sequence: str) -> int:\n    if len(raw_sequence) == 1:\n        return 0\n    elif raw_sequence[0] == raw_sequence[-1]:\n        return 1\n    sequence = [int(num) for num in raw_sequence]\n    same_digit_indexes = [[] for _ in range(10)]\n    digit_in_queue = [False] * len(sequence)\n    queue = [(0, 0)]\n    for (idx, digit) in enumerate(sequence):\n        same_digit_indexes[digit].append(idx)\n    while queue:\n        (distance, idx) = heapq.heappop(queue)\n        if idx == len(sequence) - 1:\n            return distance\n        digit = sequence[idx]\n        candidates = [idx - 1, idx + 1]\n        if same_digit_indexes[digit]:\n            candidates.extend(same_digit_indexes[digit])\n            same_digit_indexes[digit].clear()\n        for candidate_idx in candidates:\n            if candidate_idx <= 0 or candidate_idx >= len(sequence) or digit_in_queue[candidate_idx]:\n                continue\n            heapq.heappush(queue, (distance + 1, candidate_idx))\n            digit_in_queue[candidate_idx] = True\nfor case in sys.stdin:\n    print(main(case.strip()))", "import queue\n\ndef BFS(start, end, dist, adj, s):\n    vis = queue.Queue()\n    vis.put(start)\n    dist[start] = 0\n    while vis.qsize() > 0:\n        ind = vis.get()\n        if ind > 0 and dist[ind - 1] == -1:\n            dist[ind - 1] = dist[ind] + 1\n            vis.put(ind - 1)\n        if ind < len(s) - 1 and dist[ind + 1] == -1:\n            dist[ind + 1] = dist[ind] + 1\n            vis.put(ind + 1)\n        for v in adj[s[ind]]:\n            if dist[v] == -1:\n                dist[v] = dist[ind] + 1\n                vis.put(v)\n        adj[s[ind]].clear()\n    return dist[end]\ns = [int(x) for x in input().strip()]\nN = len(s)\ndist = [-1 for _ in range(N)]\nadj = [[] for _ in range(10)]\nfor i in range(N):\n    adj[s[i]].append(i)\nprint(BFS(0, N - 1, dist, adj, s))", "import queue\n\ndef BFS(start, end, dist, adj, s):\n    vis = queue.Queue()\n    vis.put(start)\n    dist[start] = 0\n    while vis.qsize() > 0:\n        ind = vis.get()\n        if ind > 0 and dist[ind - 1] == -1:\n            dist[ind - 1] = dist[ind] + 1\n            vis.put(ind - 1)\n        if ind < len(s) - 1 and dist[ind + 1] == -1:\n            dist[ind + 1] = dist[ind] + 1\n            vis.put(ind + 1)\n        for v in adj[s[ind]]:\n            if dist[v] == -1:\n                dist[v] = dist[ind] + 1\n                vis.put(v)\n        adj[s[ind]].clear()\n    return dist[end]\ns = [int(x) for x in input().strip()]\nN = len(s)\ndist = [-1 for _ in range(N)]\nadj = [[] for _ in range(10)]\nfor i in range(N):\n    adj[s[i]].append(i)\nprint(BFS(0, N - 1, dist, adj, s))", "import queue\n\ndef BFS(start, end, dist, adj, s):\n    vis = queue.Queue()\n    vis.put(start)\n    dist[start] = 0\n    while vis.qsize() > 0:\n        ind = vis.get()\n        if ind > 0 and dist[ind - 1] == -1:\n            dist[ind - 1] = dist[ind] + 1\n            vis.put(ind - 1)\n        if ind < len(s) - 1 and dist[ind + 1] == -1:\n            dist[ind + 1] = dist[ind] + 1\n            vis.put(ind + 1)\n        for v in adj[s[ind]]:\n            if dist[v] == -1:\n                dist[v] = dist[ind] + 1\n                vis.put(v)\n        adj[s[ind]].clear()\n    return dist[end]\ns = [int(x) for x in input().strip()]\nN = len(s)\ndist = [-1 for _ in range(N)]\nadj = [[] for _ in range(10)]\nfor i in range(N):\n    adj[s[i]].append(i)\nprint(BFS(0, N - 1, dist, adj, s))", "from queue import Queue\ns = input().strip()\nneighbours = [[] for i in range(10)]\nfor i in range(len(s)):\n    temp = int(s[i])\n    neighbours[temp].append(i)\ndigits = [-1] * len(s)\ndigits[0] = 0\nq = Queue()\nq.put(0)\nwhile not q.empty():\n    if digits[len(s) - 1] != -1:\n        break\n    currentNode = q.get(0)\n    value = int(s[currentNode])\n    for i in neighbours[value]:\n        if digits[i] == -1:\n            digits[i] = digits[currentNode] + 1\n            q.put(i)\n    neighbours[value] = []\n    if currentNode + 1 < len(s) and digits[currentNode + 1] == -1:\n        digits[currentNode + 1] = digits[currentNode] + 1\n        q.put(currentNode + 1)\n    if currentNode - 1 > 0 and digits[currentNode - 1] == -1:\n        digits[currentNode - 1] = digits[currentNode] + 1\n        q.put(currentNode - 1)\nprint(digits[len(s) - 1])", "import queue\nMAX_N = 100010\nMAX_DIGIT = 10\n\ndef BFS(start, end, dist, position, sequence):\n    visited = queue.Queue()\n    visited.put(start)\n    dist[start] = 0\n    while visited.qsize() > 0:\n        currentNode = visited.get()\n        if currentNode > 0 and dist[currentNode - 1] == -1:\n            dist[currentNode - 1] = dist[currentNode] + 1\n            visited.put(currentNode - 1)\n        if currentNode < len(sequence) - 1 and dist[currentNode + 1] == -1:\n            dist[currentNode + 1] = dist[currentNode] + 1\n            visited.put(currentNode + 1)\n        for v in position[sequence[currentNode]]:\n            if dist[v] == -1:\n                dist[v] = dist[currentNode] + 1\n                visited.put(v)\n        position[sequence[currentNode]].clear()\n    return dist[end]\nsequence = [int(x) for x in input().strip()]\nN = len(sequence)\ndist = [-1 for _ in range(N)]\nposition = [[] for _ in range(MAX_DIGIT)]\nfor i in range(N):\n    position[sequence[i]].append(i)\nprint(BFS(0, N - 1, dist, position, sequence))", "import queue\nMAX_N = 100010\nMAX_DIGIT = 10\n\ndef BFS(start, end, dist, position, sequence):\n    visited = queue.Queue()\n    visited.put(start)\n    dist[start] = 0\n    while visited.qsize() > 0:\n        currentNode = visited.get()\n        if currentNode > 0 and dist[currentNode - 1] == -1:\n            dist[currentNode - 1] = dist[currentNode] + 1\n            visited.put(currentNode - 1)\n        if currentNode < len(sequence) - 1 and dist[currentNode + 1] == -1:\n            dist[currentNode + 1] = dist[currentNode] + 1\n            visited.put(currentNode + 1)\n        for v in position[sequence[currentNode]]:\n            if dist[v] == -1:\n                dist[v] = dist[currentNode] + 1\n                visited.put(v)\n        position[sequence[currentNode]].clear()\n    return dist[end]\nsequence = [int(x) for x in input().strip()]\nN = len(sequence)\ndist = [-1 for _ in range(N)]\nposition = [[] for _ in range(MAX_DIGIT)]\nfor i in range(N):\n    position[sequence[i]].append(i)\nprint(BFS(0, N - 1, dist, position, sequence))", "import queue\nMAX_N = 100005\nMAX_DIGIT = 10\ndist = [-1 for _ in range(MAX_N)]\nposition = [[] for _ in range(MAX_DIGIT)]\ncommands = input().strip()\nn = len(commands)\n\ndef BFS(start, end, dist, position, n, commands):\n    myqueue = queue.Queue()\n    myqueue.put(start)\n    dist[start] = 0\n    while myqueue.qsize() > 0:\n        u = myqueue.get()\n        if u > 0 and dist[u - 1] == -1:\n            dist[u - 1] = dist[u] + 1\n            myqueue.put(u - 1)\n        if u < n - 1 and dist[u + 1] == -1:\n            dist[u + 1] = dist[u] + 1\n            myqueue.put(u + 1)\n        for v in position[ord(commands[u]) - 48]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                myqueue.put(v)\n        position[ord(commands[u]) - 48].clear()\n    print(dist[end])\nfor i in range(n):\n    position[ord(commands[i]) - 48].append(i)\nBFS(0, n - 1, dist, position, n, commands)", "from queue import Queue\ns = input().strip()\nt = [[] for i in range(10)]\nfor a in range(len(s)):\n    b = int(s[a])\n    t[b].append(a)\ndigits = [-1] * len(s)\ndigits[0] = 0\nq = Queue()\nq.put(0)\nwhile not q.empty():\n    if digits[len(s) - 1] != -1:\n        break\n    h = q.get(0)\n    value = int(s[h])\n    for c in t[value]:\n        if digits[c] == -1:\n            digits[c] = digits[h] + 1\n            q.put(c)\n    t[value] = []\n    if h + 1 < len(s) and digits[h + 1] == -1:\n        digits[h + 1] = digits[h] + 1\n        q.put(h + 1)\n    if h - 1 > 0 and digits[h - 1] == -1:\n        digits[h - 1] = digits[h] + 1\n        q.put(h - 1)\nprint(digits[len(s) - 1])", "n = input().strip()\nl = len(n)\np = [-1] * l\nu = [0] * 10\np[0] = 0\nid = 0\nc1 = [0]\nc2 = 0\nwhile c2 < l:\n    n2 = c1[c2]\n    if u[int(n[n2])] == 0:\n        for j in range(l):\n            if p[j] < 0 and n[j] == n[n2]:\n                p[j] = p[n2] + 1\n                c1.append(j)\n        u[int(n[n2])] = 1\n    if n2 > 0 and p[n2 - 1] < 0:\n        p[n2 - 1] = p[n2] + 1\n        c1.append(n2 - 1)\n    if n2 < l - 1 and p[n2 + 1] < 0:\n        p[n2 + 1] = p[n2] + 1\n        c1.append(n2 + 1)\n    c2 += 1\nprint(p[-1])", "N = input().strip()\nlength = len(N)\npi = [-1] * length\nni = [0] * 10\npi[0] = 0\nid = 0\ncurrent = [0]\ncounter = 0\nwhile counter < length:\n    np = current[counter]\n    if ni[int(N[np])] == 0:\n        for i in range(length):\n            if pi[i] < 0 and N[i] == N[np]:\n                pi[i] = pi[np] + 1\n                current.append(i)\n        ni[int(N[np])] = 1\n    if np > 0 and pi[np - 1] < 0:\n        pi[np - 1] = pi[np] + 1\n        current.append(np - 1)\n    if np < length - 1 and pi[np + 1] < 0:\n        pi[np + 1] = pi[np] + 1\n        current.append(np + 1)\n    counter = counter + 1\nprint(pi[-1])", "N = input().strip()\nlength = len(N)\npositioni = [-1] * length\nnumberi = [0] * 10\npositioni[0] = 0\nid = 0\ncr = [0]\ncount = 0\nwhile count < length:\n    ntmp = cr[count]\n    if numberi[int(N[ntmp])] == 0:\n        for i in range(length):\n            if positioni[i] < 0 and N[i] == N[ntmp]:\n                positioni[i] = positioni[ntmp] + 1\n                cr.append(i)\n        numberi[int(N[ntmp])] = 1\n    if ntmp > 0 and positioni[ntmp - 1] < 0:\n        positioni[ntmp - 1] = positioni[ntmp] + 1\n        cr.append(ntmp - 1)\n    if ntmp < length - 1 and positioni[ntmp + 1] < 0:\n        positioni[ntmp + 1] = positioni[ntmp] + 1\n        cr.append(ntmp + 1)\n    count = count + 1\nprint(positioni[-1])", "N = input().strip()\nlength = len(N)\npi = [-1] * length\nni = [0] * 10\npi[0] = 0\nid = 0\ncr = [0]\nc = 0\nwhile c < length:\n    numtmp = cr[c]\n    if ni[int(N[numtmp])] == 0:\n        for i in range(length):\n            if pi[i] < 0 and N[i] == N[numtmp]:\n                pi[i] = pi[numtmp] + 1\n                cr.append(i)\n        ni[int(N[numtmp])] = 1\n    if numtmp > 0 and pi[numtmp - 1] < 0:\n        pi[numtmp - 1] = pi[numtmp] + 1\n        cr.append(numtmp - 1)\n    if numtmp < length - 1 and pi[numtmp + 1] < 0:\n        pi[numtmp + 1] = pi[numtmp] + 1\n        cr.append(numtmp + 1)\n    c = c + 1\nprint(pi[-1])", "N = input().strip()\nij = [-1] * len(N)\nvj = [True] * 10\nij[0] = 0\ni = 0\nq = -1\npos = [0]\nwhile i < len(N):\n    if vj[int(N[pos[i]])]:\n        for j in range(len(N)):\n            if N[j] == N[pos[i]] and ij[j] == -1:\n                ij[j] = ij[pos[i]] + 1\n                pos.append(j)\n                if j == len(N) - 1:\n                    q = len(N)\n    vj[int(N[pos[i]])] = False\n    if pos[i] - 1 >= 0 and ij[pos[i] - 1] == -1:\n        ij[pos[i] - 1] = ij[pos[i]] + 1\n        pos.append(pos[i] - 1)\n    if pos[i] + 1 <= len(N) - 1 and ij[pos[i] + 1] == -1:\n        ij[pos[i] + 1] = ij[pos[i]] + 1\n        pos.append(pos[i] + 1)\n    i += 1\n    if q == len(N):\n        i = q\nprint(ij[-1])", "from collections import *\nmtrx = [int(x) for x in list(input().strip())]\nlength = len(mtrx)\nnumbros = [[] for i in range(10)]\nfor i in range(length):\n    numbros[mtrx[i]].append(i)\ndistance = [-1] * length\n\ndef bfs(x):\n    distance[x] = 0\n    q = deque()\n    q.append(x)\n    while len(q) > 0:\n        x = q.popleft()\n        if x == length - 1:\n            break\n        if x - 1 >= 0 and distance[x - 1] == -1:\n            q.append(x - 1)\n            distance[x - 1] = distance[x] + 1\n        if x + 1 <= length - 1 and distance[x + 1] == -1:\n            q.append(x + 1)\n            distance[x + 1] = distance[x] + 1\n        for bro in numbros[mtrx[x]]:\n            if distance[bro] == -1:\n                distance[bro] = distance[x] + 1\n                q.append(bro)\n        numbros[mtrx[x]] = []\n    return distance\nprint(bfs(0)[length - 1])", "s = input().strip()\nN = len(s)\nv = [-1] * N\ne = [0] * 10\nv[0] = 0\ns1 = [0]\nc = 0\nwhile c < N:\n    cur = s1[c]\n    if e[int(s[cur])] == 0:\n        for i in range(N):\n            if v[i] < 0 and s[i] == s[cur]:\n                v[i] = v[cur] + 1\n                s1.append(i)\n        e[int(s[cur])] = 1\n    if cur > 0 and v[cur - 1] < 0:\n        v[cur - 1] = v[cur] + 1\n        s1.append(cur - 1)\n    if cur < N - 1 and v[cur + 1] < 0:\n        v[cur + 1] = v[cur] + 1\n        s1.append(cur + 1)\n    c = c + 1\nprint(v[-1])", "from collections import deque, defaultdict\ns = input().strip()\nlength = len(s)\nadj = defaultdict(list)\ndistance = [0] * length\nvisited = [0] * length\nfor index in range(length):\n    char = s[index]\n    adj[char].append(index)\nqueue = [0]\nvisited[0] = 1\nwhile len(queue) != 0:\n    front = queue.pop(0)\n    if front == length - 1:\n        break\n    val = s[front]\n    for j in range(len(adj[val])):\n        next_index = adj[val][j]\n        if visited[next_index] == 0:\n            visited[next_index] = 1\n            queue.append(next_index)\n            distance[next_index] = distance[front] + 1\n    adj[val].clear()\n    if front - 1 >= 0 and front - 1 < length:\n        if visited[front - 1] == 0:\n            visited[front - 1] = 1\n            queue.append(front - 1)\n            distance[front - 1] = distance[front] + 1\n    if front + 1 >= 0 and front + 1 < length:\n        if visited[front + 1] == 0:\n            visited[front + 1] = 1\n            queue.append(front + 1)\n            distance[front + 1] = distance[front] + 1\nprint(distance[length - 1])", "from collections import deque, defaultdict\ns = input().strip()\nlength = len(s)\nadj = defaultdict(list)\ndistance = [0] * length\nvisited = [0] * length\nfor index in range(length):\n    char = s[index]\n    adj[char].append(index)\nqueue = [0]\nvisited[0] = 1\nwhile len(queue) != 0:\n    front = queue.pop(0)\n    if front == length - 1:\n        break\n    for j in range(len(adj[s[front]])):\n        next_index = adj[s[front]][j]\n        if visited[next_index] == 0:\n            visited[next_index] = 1\n            queue.append(next_index)\n            distance[next_index] = distance[front] + 1\n    adj[s[front]].clear()\n    if front - 1 >= 0 and front - 1 < length:\n        if visited[front - 1] == 0:\n            visited[front - 1] = 1\n            queue.append(front - 1)\n            distance[front - 1] = distance[front] + 1\n    if front + 1 >= 0 and front + 1 < length:\n        if visited[front + 1] == 0:\n            visited[front + 1] = 1\n            queue.append(front + 1)\n            distance[front + 1] = distance[front] + 1\nprint(distance[length - 1])", "from collections import deque, defaultdict\ns = input().strip()\nlength = len(s)\nadj = defaultdict(list)\ndistance = [0] * length\nvisited = [0] * length\nfor index in range(length):\n    char = s[index]\n    adj[char].append(index)\nqueue = [0]\nvisited[0] = 1\nwhile len(queue) != 0:\n    front = queue.pop(0)\n    if front == length - 1:\n        break\n    for j in range(len(adj[s[front]])):\n        next_index = adj[s[front]][j]\n        if visited[next_index] == 0:\n            visited[next_index] = 1\n            queue.append(next_index)\n            distance[next_index] = distance[front] + 1\n    adj[s[front]].clear()\n    if front - 1 >= 0 and front - 1 < length:\n        if visited[front - 1] == 0:\n            visited[front - 1] = 1\n            queue.append(front - 1)\n            distance[front - 1] = distance[front] + 1\n    if front + 1 >= 0 and front + 1 < length:\n        if visited[front + 1] == 0:\n            visited[front + 1] = 1\n            queue.append(front + 1)\n            distance[front + 1] = distance[front] + 1\nprint(distance[length - 1])", "from collections import *\nmtrx = [int(x) for x in list(input().strip())]\nlength = len(mtrx)\nnumbros = [[] for i in range(10)]\nfor i in range(length):\n    numbros[mtrx[i]].append(i)\ndistance = [-1] * length\n\ndef bfs(x):\n    distance[x] = 0\n    q = deque()\n    q.append(x)\n    while len(q) > 0:\n        x = q.popleft()\n        if x == length - 1:\n            break\n        if x - 1 >= 0 and distance[x - 1] == -1:\n            q.append(x - 1)\n            distance[x - 1] = distance[x] + 1\n        if x + 1 <= length - 1 and distance[x + 1] == -1:\n            q.append(x + 1)\n            distance[x + 1] = distance[x] + 1\n        for bro in numbros[mtrx[x]]:\n            if distance[bro] == -1:\n                distance[bro] = distance[x] + 1\n                q.append(bro)\n        numbros[mtrx[x]] = []\n    return distance\nprint(bfs(0)[length - 1])", "from collections import *\nmtrx = [int(x) for x in list(input().strip())]\nlength = len(mtrx)\nnumbros = [[] for i in range(10)]\nfor i in range(length):\n    numbros[mtrx[i]].append(i)\ndistance = [-1] * length\n\ndef bfs(x):\n    distance[x] = 0\n    q = deque()\n    q.append(x)\n    while len(q) > 0:\n        x = q.popleft()\n        if x == length - 1:\n            break\n        if x - 1 >= 0 and distance[x - 1] == -1:\n            q.append(x - 1)\n            distance[x - 1] = distance[x] + 1\n        if x + 1 <= length - 1 and distance[x + 1] == -1:\n            q.append(x + 1)\n            distance[x + 1] = distance[x] + 1\n        for bro in numbros[mtrx[x]]:\n            if distance[bro] == -1:\n                distance[bro] = distance[x] + 1\n                q.append(bro)\n        numbros[mtrx[x]] = []\n    return distance\nprint(bfs(0)[length - 1])", "from collections import *\nmtrx = [int(x) for x in list(input().strip())]\nlength = len(mtrx)\nnumbros = [[] for i in range(10)]\nfor i in range(length):\n    numbros[mtrx[i]].append(i)\ndistance = [-1] * length\n\ndef bfs(x):\n    distance[x] = 0\n    q = deque()\n    q.append(x)\n    while len(q) > 0:\n        x = q.popleft()\n        if x == length - 1:\n            break\n        if x - 1 >= 0 and distance[x - 1] == -1:\n            q.append(x - 1)\n            distance[x - 1] = distance[x] + 1\n        if x + 1 <= length - 1 and distance[x + 1] == -1:\n            q.append(x + 1)\n            distance[x + 1] = distance[x] + 1\n        for bro in numbros[mtrx[x]]:\n            if distance[bro] == -1:\n                distance[bro] = distance[x] + 1\n                q.append(bro)\n        numbros[mtrx[x]] = []\n    return distance\nprint(bfs(0)[length - 1])", "from collections import defaultdict\n\ndef main(string):\n    (graph, visited) = (defaultdict(list), [False] * len(string))\n    queue = [(string[0], 0, 0)]\n    visited[0] = True\n    for (index, character) in enumerate(string):\n        graph[character].append(index)\n    while queue:\n        (number, index, distance) = queue.pop(0)\n        if index == len(string) - 1:\n            return distance\n        if number in graph:\n            for otherIndex in graph[number]:\n                if not visited[otherIndex]:\n                    visited[otherIndex] = True\n                    queue.append((number, otherIndex, distance + 1))\n            del graph[number]\n        if index > 0 and (not visited[index - 1]):\n            visited[index - 1] = True\n            queue.append((string[index - 1], index - 1, distance + 1))\n        if index < len(string) - 1 and (not visited[index + 1]):\n            visited[index + 1] = True\n            queue.append((string[index + 1], index + 1, distance + 1))\nstring = input().strip()\nprint(main(string))", "import queue\n\ndef func(digits):\n    Q = queue.Queue()\n    Q.put(0)\n    dist = [-1 for i in range(len(digits))]\n    dist[0] = 0\n    position = [[] for i in range(10)]\n    n = len(digits)\n    for i in range(n):\n        position[ord(digits[i]) - 48].append(i)\n    while Q.qsize() > 0:\n        u = Q.get()\n        if u - 1 >= 0 and dist[u - 1] == -1:\n            dist[u - 1] = dist[u] + 1\n            Q.put(u - 1)\n        if u + 1 < n and dist[u + 1] == -1:\n            dist[u + 1] = dist[u] + 1\n            Q.put(u + 1)\n        for j in position[ord(digits[u]) - 48]:\n            if digits[u] == digits[j] and dist[j] == -1:\n                Q.put(j)\n                dist[j] = dist[u] + 1\n        position[ord(digits[u]) - 48].clear()\n    return dist[n - 1]\na = input().strip()\nprint(func(a))", "import queue\n\ndef func(digits):\n    Q = queue.Queue()\n    Q.put(0)\n    dist = [-1 for i in range(len(digits))]\n    dist[0] = 0\n    position = [[] for i in range(10)]\n    n = len(digits)\n    for i in range(n):\n        position[ord(digits[i]) - 48].append(i)\n    while Q.qsize() > 0:\n        u = Q.get()\n        if u - 1 >= 0 and dist[u - 1] == -1:\n            dist[u - 1] = dist[u] + 1\n            Q.put(u - 1)\n        if u + 1 < n and dist[u + 1] == -1:\n            dist[u + 1] = dist[u] + 1\n            Q.put(u + 1)\n        for j in position[ord(digits[u]) - 48]:\n            if digits[u] == digits[j] and dist[j] == -1:\n                Q.put(j)\n                dist[j] = dist[u] + 1\n        position[ord(digits[u]) - 48].clear()\n    return dist[n - 1]\na = input().strip()\nprint(func(a))", "from collections import defaultdict\ns = input().strip()\nn = len(s)\nindices = defaultdict(list)\nfor i in range(n):\n    indices[int(s[i])].append(i)\nq = []\ndist = [-1 for i in range(n)]\nq.append(0)\ndist[0] = 0\nwhile q:\n    u = q.pop(0)\n    if u - 1 >= 0 and dist[u - 1] == -1:\n        q.append(u - 1)\n        dist[u - 1] = 1 + dist[u]\n    if u + 1 < n and dist[u + 1] == -1:\n        q.append(u + 1)\n        dist[u + 1] = 1 + dist[u]\n    for v in indices[int(s[u])]:\n        if dist[v] == -1:\n            dist[v] = 1 + dist[u]\n            q.append(v)\n    indices[int(s[u])] = []\nprint(dist[n - 1])", "from collections import defaultdict\ns = input().strip()\nn = len(s)\nindices = defaultdict(list)\nfor i in range(n):\n    indices[int(s[i])].append(i)\nq = []\ndist = [-1 for i in range(n)]\nq.append(0)\ndist[0] = 0\nwhile q:\n    u = q.pop(0)\n    if u - 1 >= 0 and dist[u - 1] == -1:\n        q.append(u - 1)\n        dist[u - 1] = 1 + dist[u]\n    if u + 1 < n and dist[u + 1] == -1:\n        q.append(u + 1)\n        dist[u + 1] = 1 + dist[u]\n    for v in indices[int(s[u])]:\n        if dist[v] == -1:\n            dist[v] = 1 + dist[u]\n            q.append(v)\n    indices[int(s[u])] = []\nprint(dist[n - 1])", "import queue\n\ndef chef_digit_jump(digits):\n    Q = queue.Queue()\n    Q.put(0)\n    dist = [-1 for i in range(len(digits))]\n    dist[0] = 0\n    position = [[] for i in range(10)]\n    n = len(digits)\n    for i in range(n):\n        position[ord(digits[i]) - 48].append(i)\n    while Q.qsize() > 0:\n        u = Q.get()\n        if u - 1 >= 0 and dist[u - 1] == -1:\n            dist[u - 1] = dist[u] + 1\n            Q.put(u - 1)\n        if u + 1 < n and dist[u + 1] == -1:\n            dist[u + 1] = dist[u] + 1\n            Q.put(u + 1)\n        for j in position[ord(digits[u]) - 48]:\n            if digits[u] == digits[j] and dist[j] == -1:\n                Q.put(j)\n                dist[j] = dist[u] + 1\n        position[ord(digits[u]) - 48].clear()\n    return dist[n - 1]\na = input().strip()\nprint(chef_digit_jump(a))", "from collections import defaultdict\ns = input().strip()\nsize = len(s)\nans = defaultdict(list)\nfor i in range(size):\n    ans[s[i]].append(i)\nqueue = [0]\nvisited = {0: 0}\nwhile queue:\n    temp = queue.pop(0)\n    if temp == size - 1:\n        break\n    length = len(ans[s[temp]])\n    for i in range(length):\n        if ans[s[temp]][i] not in visited:\n            visited[ans[s[temp]][i]] = visited[temp] + 1\n            queue.append(ans[s[temp]][i])\n    ans[s[temp]] = []\n    if temp + 1 not in visited and temp + 1 < size:\n        queue.append(temp + 1)\n        visited[temp + 1] = visited[temp] + 1\n    if temp - 1 not in visited and temp - 1 >= 0:\n        queue.append(temp - 1)\n        visited[temp - 1] = visited[temp] + 1\nprint(visited[size - 1])", "from collections import defaultdict\ns = input().strip()\nsize = len(s)\nans = defaultdict(list)\nfor i in range(size):\n    ans[s[i]].append(i)\nqueue = [0]\nvisited = {0: 0}\nwhile queue:\n    temp = queue.pop(0)\n    if temp == size - 1:\n        break\n    length = len(ans[s[temp]])\n    for i in range(length):\n        if ans[s[temp]][i] not in visited:\n            visited[ans[s[temp]][i]] = visited[temp] + 1\n            queue.append(ans[s[temp]][i])\n    ans[s[temp]] = []\n    if temp + 1 not in visited and temp + 1 < size:\n        queue.append(temp + 1)\n        visited[temp + 1] = visited[temp] + 1\n    if temp - 1 not in visited and temp - 1 >= 0:\n        queue.append(temp - 1)\n        visited[temp - 1] = visited[temp] + 1\nprint(visited[size - 1])", "from collections import defaultdict\ns = input().strip()\nn = len(s)\nindices = defaultdict(list)\nfor i in range(n):\n    indices[int(s[i])].append(i)\nq = []\ndist = [-1 for i in range(n)]\nq.append(0)\ndist[0] = 0\nwhile q:\n    u = q.pop(0)\n    if u - 1 >= 0 and dist[u - 1] == -1:\n        q.append(u - 1)\n        dist[u - 1] = 1 + dist[u]\n    if u + 1 < n and dist[u + 1] == -1:\n        q.append(u + 1)\n        dist[u + 1] = 1 + dist[u]\n    for v in indices[int(s[u])]:\n        if dist[v] == -1:\n            dist[v] = 1 + dist[u]\n            q.append(v)\n    indices[int(s[u])] = []\nprint(dist[n - 1])", "from collections import defaultdict\na = input().strip()\nn = len(a)\ng = defaultdict(list)\nfor i in range(n):\n    g[a[i]].append(i)\nvis = {}\nvis[0] = 0\nq = [0]\nwhile len(q) != 0:\n    tmp = q.pop(0)\n    if tmp == n - 1:\n        break\n    val = a[tmp]\n    s = len(g[val])\n    for i in range(s):\n        if g[val][i] not in vis:\n            vis[g[val][i]] = vis[tmp] + 1\n            q.append(g[val][i])\n    g[val] = []\n    if tmp + 1 <= n - 1 and tmp + 1 not in vis:\n        q.append(tmp + 1)\n        vis[tmp + 1] = vis[tmp] + 1\n    if tmp - 1 >= 0 and tmp - 1 not in vis:\n        q.append(tmp - 1)\n        vis[tmp - 1] = vis[tmp] + 1\nprint(vis[n - 1])", "from collections import defaultdict\nfrom collections import deque\ng = defaultdict(lambda : [])\ns = input().strip()\nls = len(s)\nvis = [False for i in range(ls)]\ndis = [0 for i in range(ls)]\nfor i in range(1, ls):\n    g[s[i]].append(i)\nque = deque()\nque.append(0)\nvis[0] = True\nwhile que:\n    indx = que.popleft()\n    if indx == ls - 1:\n        break\n    temp = s[indx]\n    for i in g[temp]:\n        if not vis[i]:\n            vis[i] = True\n            que.append(i)\n            dis[i] = dis[indx] + 1\n    g[temp].clear()\n    if indx - 1 >= 0 and (not vis[indx - 1]):\n        vis[indx - 1] = True\n        que.append(indx - 1)\n        dis[indx - 1] = dis[indx] + 1\n    if indx + 1 < ls and (not vis[indx + 1]):\n        vis[indx + 1] = True\n        que.append(indx + 1)\n        dis[indx + 1] = dis[indx] + 1\nprint(dis[-1])", "from collections import defaultdict\na = input().strip()\nn = len(a)\ng = defaultdict(list)\nfor i in range(n):\n    g[a[i]].append(i)\nvis = {}\nvis[0] = 0\nq = [0]\nwhile len(q) != 0:\n    tmp = q.pop(0)\n    if tmp == n - 1:\n        break\n    val = a[tmp]\n    s = len(g[val])\n    for i in range(s):\n        if g[val][i] not in vis:\n            vis[g[val][i]] = vis[tmp] + 1\n            q.append(g[val][i])\n    g[val] = []\n    if tmp + 1 <= n - 1 and tmp + 1 not in vis:\n        q.append(tmp + 1)\n        vis[tmp + 1] = vis[tmp] + 1\n    if tmp - 1 >= 0 and tmp - 1 not in vis:\n        q.append(tmp - 1)\n        vis[tmp - 1] = vis[tmp] + 1\nprint(vis[n - 1])", "s = input().strip()\nn = len(s)\nindices = []\nfor i in range(10):\n    indices.append([])\nfor i in range(n):\n    indices[int(s[i])].append(i)\nq = []\ndist = [-1 for i in range(n)]\nq.append(0)\ndist[0] = 0\nwhile len(q) > 0:\n    u = q.pop(0)\n    if u - 1 >= 0 and dist[u - 1] == -1:\n        dist[u - 1] = 1 + dist[u]\n        q.append(u - 1)\n    if u + 1 < n and dist[u + 1] == -1:\n        dist[u + 1] = 1 + dist[u]\n        q.append(u + 1)\n    for v in indices[int(s[u])]:\n        if dist[v] == -1:\n            dist[v] = 1 + dist[u]\n            q.append(v)\n    indices[int(s[u])] = []\nprint(dist[n - 1])", "s = input().strip()\nn = len(s)\nindices = [[] for i in range(10)]\nfor i in range(n):\n    indices[int(s[i])].append(i)\nq = []\ndist = [-1 for i in range(n)]\nq.append(0)\ndist[0] = 0\nwhile len(q) > 0:\n    u = q.pop(0)\n    for v in indices[int(s[u])]:\n        if dist[v] == -1:\n            q.append(v)\n            dist[v] = 1 + dist[u]\n    indices[int(s[u])].clear()\n    if u - 1 >= 0 and dist[u - 1] == -1:\n        q.append(u - 1)\n        dist[u - 1] = 1 + dist[u]\n    if u + 1 < n and dist[u + 1] == -1:\n        q.append(u + 1)\n        dist[u + 1] = 1 + dist[u]\nprint(dist[n - 1])", "from sys import stdin, stdout\nimport math\nfrom collections import defaultdict, deque\n\ndef bfs(d, n, d1, s):\n    high = [-1 for x in range(n + 1)]\n    q = deque([0])\n    high[0] = 0\n    while q:\n        node = q.popleft()\n        for x in d1[int(s[node])]:\n            if high[x] == -1:\n                high[x] = high[node] + 1\n                q.append(x)\n        for x in d[node]:\n            if high[x] == -1:\n                high[x] = high[node] + 1\n                q.append(x)\n    print(high[n])\n\ndef main():\n    try:\n        s = stdin.readline().strip()\n        n = len(s)\n        d = defaultdict(list)\n        for i in range(1, len(s)):\n            d[int(s[i])].append(i)\n        high = [0] * (n + 1)\n        visit = [False] * (n + 1)\n        q = deque([0])\n        while q:\n            node = q.popleft()\n            if node == n - 1:\n                break\n            for x in d[int(s[node])]:\n                if visit[x] == False:\n                    visit[x] = True\n                    q.append(x)\n                    high[x] = high[node] + 1\n            d[int(s[node])].clear()\n            if node - 1 >= 0 and (not visit[node - 1]):\n                visit[node - 1] = True\n                q.append(node - 1)\n                high[node - 1] = high[node] + 1\n            if node + 1 < n and (not visit[node + 1]):\n                visit[node + 1] = True\n                q.append(node + 1)\n                high[node + 1] = high[node] + 1\n        print(high[n - 1])\n    except:\n        pass\n\ndef add(a, b, c):\n    res = a + b\n    if res >= c:\n        return res - c\n    else:\n        return res\n\ndef mod(a, b, c):\n    res = a * b\n    if res >= c:\n        return res % c\n    else:\n        return res\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    w = a // gcd(a, b)\n    return w * b\n\ndef expo(a, b):\n    (x, y) = (1, a)\n    while b > 0:\n        if b & 1:\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\n\ndef power(a, b, m):\n    (x, y) = (1,)\n    while b > 0:\n        if b & 1:\n            x = mod(x, y, m)\n        y = mod(y, y, m)\n        b >>= 1\n    return x\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\nmain()", "from collections import defaultdict\nfrom collections import deque\ng = defaultdict(lambda : [])\ns = input().strip()\nls = len(s)\nvis = [False for i in range(ls)]\ndis = [0 for i in range(ls)]\nfor i in range(1, ls):\n    g[s[i]].append(i)\nque = deque()\nque.append(0)\nvis[0] = True\nwhile que:\n    indx = que.popleft()\n    if indx == ls - 1:\n        break\n    temp = s[indx]\n    for i in g[temp]:\n        if not vis[i]:\n            vis[i] = True\n            que.append(i)\n            dis[i] = dis[indx] + 1\n    g[temp].clear()\n    if indx - 1 >= 0 and (not vis[indx - 1]):\n        vis[indx - 1] = True\n        que.append(indx - 1)\n        dis[indx - 1] = dis[indx] + 1\n    if indx + 1 < ls and (not vis[indx + 1]):\n        vis[indx + 1] = True\n        que.append(indx + 1)\n        dis[indx + 1] = dis[indx] + 1\nprint(dis[-1])", "from collections import defaultdict\na = input().strip()\nn = len(a)\ng = defaultdict(list)\nfor i in range(n):\n    g[a[i]].append(i)\nvis = {}\nvis[0] = 0\nq = [0]\nwhile len(q) != 0:\n    tmp = q.pop(0)\n    if tmp == n - 1:\n        break\n    val = a[tmp]\n    s = len(g[val])\n    for i in range(s):\n        if g[val][i] not in vis:\n            vis[g[val][i]] = vis[tmp] + 1\n            q.append(g[val][i])\n    g[val] = []\n    if tmp + 1 <= n - 1 and tmp + 1 not in vis:\n        q.append(tmp + 1)\n        vis[tmp + 1] = vis[tmp] + 1\n    if tmp - 1 >= 0 and tmp - 1 not in vis:\n        q.append(tmp - 1)\n        vis[tmp - 1] = vis[tmp] + 1\nprint(vis[n - 1])", "from collections import defaultdict, deque\ntext = input().strip()\nv = len(text)\ng = defaultdict(list)\nstore = defaultdict(list)\nfor i in range(1, v):\n    temp = ord(text[i])\n    store[temp].append(i)\nque = [0]\ndist = [0] * v\nvis = [False] * v\nvis[0] = True\nwhile len(que):\n    index = que.pop(0)\n    if index == v - 1:\n        break\n    temp = ord(text[index])\n    for i in store[temp]:\n        if not vis[i]:\n            vis[i] = True\n            que.append(i)\n            dist[i] = dist[index] + 1\n    del store[temp]\n    left = index - 1\n    right = index + 1\n    if left >= 0 and (not vis[left]):\n        vis[left] = True\n        que.append(left)\n        dist[left] = dist[index] + 1\n    if right < v and (not vis[right]):\n        vis[right] = True\n        que.append(right)\n        dist[right] = dist[index] + 1\nprint(dist[v - 1])", "from collections import defaultdict\nfrom collections import deque\ng = defaultdict(lambda : [])\ns = input().strip()\nls = len(s)\nvis = [False for i in range(ls)]\ndis = [0 for i in range(ls)]\nfor i in range(1, ls):\n    g[s[i]].append(i)\nque = deque()\nque.append(0)\nvis[0] = True\nwhile que:\n    indx = que.popleft()\n    if indx == ls - 1:\n        break\n    temp = s[indx]\n    for i in g[temp]:\n        if not vis[i]:\n            vis[i] = True\n            que.append(i)\n            dis[i] = dis[indx] + 1\n    g[temp].clear()\n    if indx - 1 >= 0 and (not vis[indx - 1]):\n        vis[indx - 1] = True\n        que.append(indx - 1)\n        dis[indx - 1] = dis[indx] + 1\n    if indx + 1 < ls and (not vis[indx + 1]):\n        vis[indx + 1] = True\n        que.append(indx + 1)\n        dis[indx + 1] = dis[indx] + 1\nprint(dis[-1])", "from collections import defaultdict\nfrom collections import deque\ns = input().strip()\nn = len(s)\ndist = [0] * n\nvisited = [False] * n\nd = defaultdict(list)\nfor i in range(n):\n    d[s[i]].append(i)\nvisited[0] = True\nstk = deque()\nstk.append(0)\nwhile stk:\n    node = stk.popleft()\n    if node == n - 1:\n        break\n    for i in d[s[node]]:\n        if not visited[i] and i != node:\n            dist[i] = dist[node] + 1\n            visited[i] = True\n            stk.append(i)\n    d[s[node]] = []\n    if node > 0 and (not visited[node - 1]):\n        stk.append(node - 1)\n        visited[node - 1] = True\n        dist[node - 1] = dist[node] + 1\n    if node < n - 1 and (not visited[node + 1]):\n        stk.append(node + 1)\n        visited[node + 1] = True\n        dist[node + 1] = dist[node] + 1\nprint(dist[-1])", "from collections import defaultdict\na = input().strip()\nn = len(a)\ng = defaultdict(list)\nfor i in range(n):\n    g[a[i]].append(i)\nvis = {}\nvis[0] = 0\nq = [0]\nwhile len(q) != 0:\n    tmp = q.pop(0)\n    if tmp == n - 1:\n        break\n    val = a[tmp]\n    s = len(g[val])\n    for i in range(s):\n        if g[val][i] not in vis:\n            vis[g[val][i]] = vis[tmp] + 1\n            q.append(g[val][i])\n    g[val] = []\n    if tmp + 1 <= n - 1 and tmp + 1 not in vis:\n        q.append(tmp + 1)\n        vis[tmp + 1] = vis[tmp] + 1\n    if tmp - 1 >= 0 and tmp - 1 not in vis:\n        q.append(tmp - 1)\n        vis[tmp - 1] = vis[tmp] + 1\nprint(vis[n - 1])", "from collections import defaultdict\n\ndef solve():\n    a = input().strip()\n    n = len(a)\n    g = defaultdict(list)\n    for i in range(n):\n        g[a[i]].append(i)\n    vis = {}\n    vis[0] = 0\n    q = [0]\n    while len(q) != 0:\n        tmp = q.pop(0)\n        if tmp == n - 1:\n            break\n        val = a[tmp]\n        x = len(g[val])\n        for i in range(x):\n            if g[val][i] not in vis:\n                q.append(g[val][i])\n                vis[g[val][i]] = vis[tmp] + 1\n        g[val] = []\n        if tmp + 1 <= n - 1 and tmp + 1 not in vis:\n            q.append(tmp + 1)\n            vis[tmp + 1] = vis[tmp] + 1\n        if tmp - 1 >= 0 and tmp - 1 not in vis:\n            q.append(tmp - 1)\n            vis[tmp - 1] = vis[tmp] + 1\n    print(vis[n - 1])\nsolve()", "from collections import defaultdict, deque\ntext = input().strip()\nv = len(text)\ng = defaultdict(list)\nstore = defaultdict(list)\nfor i in range(1, v):\n    temp = ord(text[i])\n    store[temp].append(i)\nque = deque([0])\ndist = [0] * v\nvis = [False] * v\nvis[0] = True\nwhile len(que):\n    index = que.popleft()\n    if index == v - 1:\n        break\n    temp = ord(text[index])\n    for i in store[temp]:\n        if not vis[i]:\n            vis[i] = True\n            que.append(i)\n            dist[i] = dist[index] + 1\n    del store[temp]\n    left = index - 1\n    right = index + 1\n    if left >= 0 and (not vis[left]):\n        vis[left] = True\n        que.append(left)\n        dist[left] = dist[index] + 1\n    if right < v and (not vis[right]):\n        vis[right] = True\n        que.append(right)\n        dist[right] = dist[index] + 1\nprint(dist[v - 1])", "from collections import defaultdict, deque\ntext = input().strip()\nv = len(text)\ng = defaultdict(list)\nstore = defaultdict(list)\nfor i in range(1, v):\n    temp = ord(text[i])\n    store[temp].append(i)\nque = [0]\ndist = [0] * v\nvis = [False] * v\nvis[0] = True\nwhile len(que):\n    index = que.pop(0)\n    if index == v - 1:\n        break\n    temp = ord(text[index])\n    for i in store[temp]:\n        if not vis[i]:\n            vis[i] = True\n            que.append(i)\n            dist[i] = dist[index] + 1\n    del store[temp]\n    left = index - 1\n    right = index + 1\n    if left >= 0 and (not vis[left]):\n        vis[left] = True\n        que.append(left)\n        dist[left] = dist[index] + 1\n    if right < v and (not vis[right]):\n        vis[right] = True\n        que.append(right)\n        dist[right] = dist[index] + 1\nprint(dist[v - 1])", "from collections import defaultdict, deque\ntext = input().strip()\nv = len(text)\ng = defaultdict(list)\nstore = defaultdict(list)\nfor i in range(1, v):\n    temp = ord(text[i]) - 48\n    store[temp].append(i)\nque = [0]\ndist = [0] * v\nvis = [False] * v\nvis[0] = True\nwhile len(que):\n    index = que.pop(0)\n    if index == v - 1:\n        break\n    temp = ord(text[index]) - 48\n    for i in store[temp]:\n        if not vis[i]:\n            vis[i] = True\n            que.append(i)\n            dist[i] = dist[index] + 1\n    del store[temp]\n    left = index - 1\n    right = index + 1\n    if left >= 0 and (not vis[left]):\n        vis[left] = True\n        que.append(left)\n        dist[left] = dist[index] + 1\n    if right < v and (not vis[right]):\n        vis[right] = True\n        que.append(right)\n        dist[right] = dist[index] + 1\nprint(dist[v - 1])", "from collections import defaultdict as dd\ns = input().strip()\nn = len(s)\nvis = [False for i in range(n)]\nd = [False for i in range(n)]\nV = dd(list)\nfor i in range(1, n):\n    val = ord(s[i]) - 48\n    V[val].append(i)\nd[0] = 0\nvis[0] = True\nQ = []\nQ.append(0)\nwhile len(Q):\n    idx = Q[0]\n    if idx == n - 1:\n        break\n    Q.pop(0)\n    val = ord(s[idx]) - 48\n    vsz = len(V[val])\n    for j in range(vsz):\n        nidx = V[val][j]\n        if not vis[nidx]:\n            vis[nidx] = True\n            Q.append(nidx)\n            d[nidx] = d[idx] + 1\n    V[val].clear()\n    if idx - 1 >= 0 and (not vis[idx - 1]):\n        vis[idx - 1] = True\n        Q.append(idx - 1)\n        d[idx - 1] = d[idx] + 1\n    if idx + 1 < n and (not vis[idx + 1]):\n        vis[idx + 1] = True\n        Q.append(idx + 1)\n        d[idx + 1] = d[idx] + 1\nprint(d[n - 1])", "digit = {'0': [], '1': [], '2': [], '3': [], '4': [], '5': [], '6': [], '7': [], '8': [], '9': []}\ns = input().strip()\nslen = len(s)\ndepth = []\nvisited = []\nqueuee = []\nfor i in range(slen):\n    digit[s[i]].append(i)\n    depth.append(0)\n    visited.append(False)\ndepth[0] = 0\nvisited[0] = True\nqueuee.append(0)\nwhile len(queuee):\n    index = queuee.pop(0)\n    if index == slen - 1:\n        break\n    for i in digit[s[index]]:\n        if not visited[i]:\n            visited[i] = True\n            queuee.append(i)\n            depth[i] = depth[index] + 1\n    digit[s[index]] = []\n    if index - 1 >= 0 and (not visited[index - 1]):\n        visited[index - 1] = True\n        queuee.append(index - 1)\n        depth[index - 1] = depth[index] + 1\n    if index + 1 < slen and (not visited[index + 1]):\n        visited[index + 1] = True\n        queuee.append(index + 1)\n        depth[index + 1] = depth[index] + 1\nprint(depth[slen - 1])", "from collections import defaultdict\n\nclass Graph:\n\n    def __init__(self, v):\n        self.adj = defaultdict(list)\n        self.V = v\n\n    def findstep(self, s):\n        visit = [0] * self.V\n        dist = [0] * self.V\n        q = []\n        q.append(0)\n        while q:\n            t = q.pop(0)\n            visit[t] = 1\n            for i in self.adj[s[t]]:\n                if visit[i] == 0 and i != t:\n                    q.append(i)\n                    visit[i] = 1\n                    dist[i] = dist[t] + 1\n            self.adj[s[t]] = []\n            if t > 0 and visit[t - 1] == 0:\n                q.append(t - 1)\n                visit[t - 1] = 1\n                dist[t - 1] = dist[t] + 1\n            if t < self.V - 1 and visit[t + 1] == 0:\n                q.append(t + 1)\n                visit[t + 1] = 1\n                dist[t + 1] = dist[t] + 1\n        return dist[-1]\ns = list(map(int, input().strip()))\nn = len(s)\ng = Graph(n)\nfor i in range(n):\n    g.adj[s[i]].append(i)\nprint(g.findstep(s))", "from queue import Queue\nS = list(map(int, input().strip()))\nN = len(S)\ngraph = {}\nfor i in range(N):\n    graph[S[i]] = []\nif N > 1:\n    for i in range(N):\n        graph[S[i]].append(i)\n    visited = [0] * N\n    distance = [0] * N\n    Q = Queue()\n    Q.put(0)\n    while not Q.empty():\n        t = Q.get()\n        for i in graph[S[t]]:\n            if visited[i] == 0 and i != t:\n                Q.put(i)\n                visited[i] = 1\n                distance[i] = distance[t] + 1\n        graph[S[t]] = []\n        if t > 0:\n            if visited[t - 1] == 0:\n                Q.put(t - 1)\n                visited[t - 1] = 1\n                distance[t - 1] = distance[t] + 1\n        if t < N - 1:\n            if visited[t + 1] == 0:\n                Q.put(t + 1)\n                visited[t + 1] = 1\n                distance[t + 1] = distance[t] + 1\n        visited[t] = 1\n    print(distance[-1])\nelse:\n    print(0)", "from queue import Queue\nS = list(map(int, input().strip()))\nN = len(S)\ngraph = {}\nfor i in range(N):\n    graph[S[i]] = []\nif N > 1:\n    for i in range(N):\n        graph[S[i]].append(i)\n    visited = [0] * N\n    distance = [0] * N\n    Q = Queue()\n    Q.put(0)\n    while not Q.empty():\n        t = Q.get()\n        for i in graph[S[t]]:\n            if visited[i] == 0 and i != t:\n                Q.put(i)\n                visited[i] = 1\n                distance[i] = distance[t] + 1\n        graph[S[t]] = []\n        if t > 0:\n            if visited[t - 1] == 0:\n                Q.put(t - 1)\n                visited[t - 1] = 1\n                distance[t - 1] = distance[t] + 1\n        if t < N - 1:\n            if visited[t + 1] == 0:\n                Q.put(t + 1)\n                visited[t + 1] = 1\n                distance[t + 1] = distance[t] + 1\n        visited[t] = 1\n    print(distance[-1])\nelse:\n    print(0)", "import heapq\n\ndef digitJump(text):\n    L = len(text)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for i in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(text[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(text[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(text[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(text[idx + 1]), idx + 1))\n    return minJump[0]\ntext = input().strip()\nprint(digitJump(text))", "import copy\nimport sys\nfrom collections import defaultdict, Counter\n\ndef input():\n    return sys.stdin.readline()\n\ndef mapi():\n    return map(int, input().split())\n\ndef maps():\n    return map(str, input().split())\n\ndef print(arg, *argv, end=None):\n    sys.stdout.write(str(arg))\n    for i in argv:\n        sys.stdout.write(' ' + str(i))\n    sys.stdout.write(end) if end else sys.stdout.write('\\n')\n\ndef solve():\n    t = 1\n    while t:\n        t -= 1\n        a = input().strip()\n        n = len(a)\n        g = defaultdict(list)\n        for i in range(n):\n            g[a[i]].append(i)\n        vis = {}\n        vis[0] = 0\n        q = [0]\n        while len(q) != 0:\n            tmp = q.pop(0)\n            if tmp == n - 1:\n                break\n            val = a[tmp]\n            x = len(g[val])\n            for i in range(x):\n                if g[val][i] not in vis:\n                    q.append(g[val][i])\n                    vis[g[val][i]] = vis[tmp] + 1\n            g[val] = []\n            if tmp + 1 <= n - 1 and tmp + 1 not in vis:\n                q.append(tmp + 1)\n                vis[tmp + 1] = vis[tmp] + 1\n            if tmp - 1 >= 0 and tmp - 1 not in vis:\n                q.append(tmp - 1)\n                vis[tmp - 1] = vis[tmp] + 1\n        print(vis[n - 1])\nsolve()", "from queue import Queue\ns = input().strip()\nt = [[] for i in range(10)]\nfor a in range(len(s)):\n    b = int(s[a])\n    t[b].append(a)\nd = [-1] * len(s)\nd[0] = 0\nq = Queue()\nq.put(0)\nwhile q.empty() == False:\n    if d[len(s) - 1] != -1:\n        break\n    h = q.get(0)\n    value = int(s[h])\n    for c in t[value]:\n        if d[c] == -1:\n            d[c] = d[h] + 1\n            q.put(c)\n    t[value] = []\n    if h + 1 < len(s) and d[h + 1] == -1:\n        d[h + 1] = d[h] + 1\n        q.put(h + 1)\n    if h - 1 > 0 and d[h - 1] == -1:\n        d[h - 1] = d[h] + 1\n        q.put(h - 1)\nprint(d[len(s) - 1])", "from queue import Queue\ns = input().strip()\nneighbours = [[] for _ in range(10)]\nfor index_node in range(len(s)):\n    value_node = int(s[index_node])\n    neighbours[value_node].append(index_node)\ndistances = [-1] * len(s)\ndistances[0] = 0\nq = Queue()\nq.put(0)\nwhile q.empty() == False:\n    if distances[len(s) - 1] != -1:\n        break\n    current_node_index = q.get(0)\n    value = int(s[current_node_index])\n    for neighbour_index in neighbours[value]:\n        if distances[neighbour_index] == -1:\n            distances[neighbour_index] = distances[current_node_index] + 1\n            q.put(neighbour_index)\n    neighbours[value] = []\n    if current_node_index + 1 < len(s) and distances[current_node_index + 1] == -1:\n        distances[current_node_index + 1] = distances[current_node_index] + 1\n        q.put(current_node_index + 1)\n    if current_node_index - 1 > 0 and distances[current_node_index - 1] == -1:\n        distances[current_node_index - 1] = distances[current_node_index] + 1\n        q.put(current_node_index - 1)\nprint(distances[len(s) - 1])", "from queue import Queue\ns = input().strip()\nedges = [[] for _ in range(10)]\nfor i in range(len(s)):\n    edges[int(s[i])].append(i)\ndist = [-1 for _ in range(len(s))]\nq = Queue()\nq.put(0)\ndist[0] = 0\nwhile not q.empty():\n    index = q.get()\n    if dist[len(s) - 1] != -1:\n        break\n    val = int(s[index])\n    for v in edges[val]:\n        if dist[v] == -1:\n            dist[v] = dist[index] + 1\n            q.put(v)\n    edges[val] = []\n    if index > 0 and dist[index - 1] == -1:\n        dist[index - 1] = dist[index] + 1\n        q.put(index - 1)\n    if index + 1 < len(s) and dist[index + 1] == -1:\n        dist[index + 1] = dist[index] + 1\n        q.put(index + 1)\nprint(dist[len(s) - 1])", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nS = list(map(int, input().strip()))\na = [[] for _ in range(10)]\n[a[v].append(i) for (i, v) in enumerate(S)]\nd = [False] * 10\nml = [(False, -1)] * len(S)\nml[0] = (True, 0)\nq = [0]\nwhile q:\n    cur = q.pop(0)\n    if cur == len(S) - 1:\n        print(ml[cur][1])\n        break\n    for adj in [cur - 1, cur + 1]:\n        if not 0 <= adj < len(S) or ml[adj][0]:\n            continue\n        ml[adj] = (True, ml[cur][1] + 1)\n        q.append(adj)\n    if d[S[cur]]:\n        continue\n    d[S[cur]] = True\n    for p in a[S[cur]]:\n        if ml[p][0]:\n            continue\n        ml[p] = (True, ml[cur][1] + 1)\n        q.append(p)", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom math import inf\nS = list(map(int, input().strip()))\na = [[] for _ in range(10)]\n[a[v].append(i) for (i, v) in enumerate(S)]\nd = [False] * 10\nml = [(False, inf)] * len(S)\nml[0] = (True, 0)\nq = [0]\nwhile q:\n    cur = q.pop(0)\n    if cur == len(S) - 1:\n        print(ml[cur][1])\n        break\n    for adj in [cur - 1, cur + 1]:\n        if not 0 <= adj < len(S) or ml[adj][0]:\n            continue\n        ml[adj] = (True, ml[cur][1] + 1)\n        q.append(adj)\n    if not d[S[cur]]:\n        d[S[cur]] = True\n        for p in a[S[cur]]:\n            if ml[p][0]:\n                continue\n            ml[p] = (True, ml[cur][1] + 1)\n            q.append(p)", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom math import inf\nS = list(map(int, input().strip()))\na = [[] for _ in range(10)]\n[a[v].append(i) for (i, v) in enumerate(S)]\nd = [False] * 10\nml = [(False, inf)] * len(S)\nml[0] = (True, 0)\nq = [0]\nwhile len(q):\n    cur = q.pop(0)\n    if cur == len(S) - 1:\n        print(ml[cur][1])\n        break\n    for adj in [cur - 1, cur + 1]:\n        if not 0 <= adj < len(S) or ml[adj][0]:\n            continue\n        ml[adj] = (True, ml[cur][1] + 1)\n        q.append(adj)\n    if d[S[cur]] == False:\n        d[S[cur]] = True\n        for p in a[S[cur]]:\n            if ml[p][0] == True:\n                continue\n            ml[p] = (True, ml[cur][1] + 1)\n            q.append(p)", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom math import inf\nS = list(map(int, input().strip()))\na = [[] for _ in range(10)]\n[a[v].append(i) for (i, v) in enumerate(S)]\nd = [False] * 10\nml = [(False, inf)] * len(S)\nml[0] = (True, 0)\nq = [0]\nwhile len(q):\n    cur = q.pop(0)\n    if cur == len(S) - 1:\n        print(ml[cur][1])\n        break\n    for adj in [cur - 1, cur + 1]:\n        if not 0 <= adj < len(S) or ml[adj][0]:\n            continue\n        ml[adj] = (True, ml[cur][1] + 1)\n        q.append(adj)\n    if d[S[cur]] == False:\n        d[S[cur]] = True\n        for p in a[S[cur]]:\n            if ml[p][0] == True:\n                continue\n            ml[p] = (True, ml[cur][1] + 1)\n            q.append(p)", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom math import inf\nS = list(map(int, input().strip()))\na = [[] for i in range(10)]\n[a[v].append(i) for (i, v) in enumerate(S)]\nd = [False] * 10\nml = [(False, inf)] * len(S)\nml[0] = (True, 0)\nq = [0]\nwhile len(q):\n    cur = q.pop(0)\n    if cur == len(S) - 1:\n        print(ml[cur][1])\n        break\n    for adj in [cur - 1, cur + 1]:\n        if not 0 <= adj < len(S) or ml[adj][0]:\n            continue\n        ml[adj] = (True, ml[cur][1] + 1)\n        q.append(adj)\n    if d[S[cur]] == False:\n        d[S[cur]] = True\n        for p in a[S[cur]]:\n            if ml[p][0] == True:\n                continue\n            ml[p] = (True, ml[cur][1] + 1)\n            q.append(p)", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom math import inf\nS = list(map(int, input().strip()))\na = [[] for i in range(10)]\n[a[v].append(i) for (i, v) in enumerate(S)]\nd = [False] * 10\nm_l = [(False, inf)] * len(S)\nm_l[0] = (True, 0)\nq = [0]\nwhile len(q):\n    current = q.pop(0)\n    if current == len(S) - 1:\n        print(m_l[current][1])\n        break\n    for adj in [current - 1, current + 1]:\n        if not 0 <= adj < len(S) or m_l[adj][0]:\n            continue\n        m_l[adj] = (True, m_l[current][1] + 1)\n        q.append(adj)\n    if d[S[current]] == False:\n        d[S[current]] = True\n        for p in a[S[current]]:\n            if m_l[p][0] == True:\n                continue\n            m_l[p] = (True, m_l[current][1] + 1)\n            q.append(p)", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom math import inf\nS = list(map(int, input().strip()))\na = [[] for i in range(10)]\n[a[v].append(i) for (i, v) in enumerate(S) if i != v]\nd = [False] * 10\nm = [False] * len(S)\nm[0] = 1\nl = [inf] * len(S)\nl[0] = 0\nq = [0]\nwhile len(q):\n    current = q.pop(0)\n    if current == len(S) - 1:\n        print(l[current])\n        break\n    adjs = list(filter(lambda x: 0 <= x < len(S) and (not m[x]), [current - 1, current + 1]))\n    for adj in adjs:\n        m[adj] = True\n        l[adj] = l[current] + 1\n    q.extend(adjs)\n    if d[S[current]] == False:\n        d[S[current]] = True\n        for p in a[S[current]]:\n            if m[p] == True:\n                continue\n            m[p] = True\n            l[p] = l[current] + 1\n            q.append(p)", "s = input().strip()\nans = -1\nL = []\nfor i in range(10):\n    h = []\n    L.append(h)\nfor i in range(0, len(s)):\n    L[int(s[i])].append(i)\npos = [0] * 10\nvisited = [False] * len(s)\nqueue = [(0, 0)]\nvisited[0] = True\nwhile queue:\n    k = queue.pop(0)\n    k1 = k[0]\n    k2 = k[1]\n    if k1 == len(s) - 1:\n        ans = k2\n        break\n    if k1 - 1 >= 0:\n        if visited[k1 - 1] == False:\n            queue.append((k1 - 1, k2 + 1))\n            visited[k1 - 1] = True\n    if k1 + 1 <= len(s) - 1:\n        if visited[k1 + 1] == False:\n            queue.append((k1 + 1, k2 + 1))\n            visited[k1 + 1] = True\n    if pos[int(s[k1])] == 0:\n        pos[int(s[k1])] = 1\n        for i in L[int(s[k1])]:\n            if visited[i] == False:\n                queue.append((i, k2 + 1))\n                visited[i] = True\nprint(ans)", "s = input().strip()\nans = -1\nL = []\nfor i in range(10):\n    h = []\n    L.append(h)\nfor i in range(0, len(s)):\n    L[int(s[i])].append(i)\npos = [0] * 10\nvisited = [False] * len(s)\nqueue = [(0, 0)]\nvisited[0] = True\nwhile queue:\n    k = queue.pop(0)\n    k1 = k[0]\n    k2 = k[1]\n    if k1 == len(s) - 1:\n        ans = k2\n        break\n    if k1 - 1 >= 0:\n        if visited[k1 - 1] == False:\n            queue.append((k1 - 1, k2 + 1))\n            visited[k1 - 1] = True\n    if k1 + 1 <= len(s) - 1:\n        if visited[k1 + 1] == False:\n            queue.append((k1 + 1, k2 + 1))\n            visited[k1 + 1] = True\n    if pos[int(s[k1])] == 0:\n        pos[int(s[k1])] = 1\n        for i in L[int(s[k1])]:\n            if visited[i] == False:\n                queue.append((i, k2 + 1))\n                visited[i] = True\nprint(ans)", "s = input().strip()\nans = -1\nL = []\nfor i in range(10):\n    h = []\n    L.append(h)\nfor i in range(0, len(s)):\n    L[int(s[i])].append(i)\npos = [0] * 10\nvisited = [False] * len(s)\nqueue = [(0, 0)]\nvisited[0] = True\nwhile queue:\n    k = queue.pop(0)\n    k1 = k[0]\n    k2 = k[1]\n    if k1 == len(s) - 1:\n        ans = k2\n        break\n    if k1 - 1 >= 0:\n        if visited[k1 - 1] == False:\n            queue.append((k1 - 1, k2 + 1))\n            visited[k1 - 1] = True\n    if k1 + 1 <= len(s) - 1:\n        if visited[k1 + 1] == False:\n            queue.append((k1 + 1, k2 + 1))\n            visited[k1 + 1] = True\n    if pos[int(s[k1])] == 0:\n        pos[int(s[k1])] = 1\n        for i in L[int(s[k1])]:\n            if visited[i] == False:\n                queue.append((i, k2 + 1))\n                visited[i] = True\nprint(ans)", "from collections import defaultdict\n\ndef main(string):\n    (graph, visited) = (defaultdict(list), [False] * len(string))\n    queue = [(string[0], 0, 0)]\n    visited[0] = True\n    for (index, character) in enumerate(string):\n        graph[character].append(index)\n    while queue:\n        (number, index, distance) = queue.pop(0)\n        if index == len(string) - 1:\n            return distance\n        if number in graph:\n            for otherIndex in graph[number]:\n                if not visited[otherIndex]:\n                    visited[otherIndex] = True\n                    queue.append((number, otherIndex, distance + 1))\n            del graph[number]\n        if index > 0 and (not visited[index - 1]):\n            visited[index - 1] = True\n            queue.append((string[index - 1], index - 1, distance + 1))\n        if index < len(string) - 1 and (not visited[index + 1]):\n            visited[index + 1] = True\n            queue.append((string[index + 1], index + 1, distance + 1))\nstring = input().strip()\nprint(main(string))", "from queue import Queue\ns = input().strip()\nneighbours = [[] for _ in range(10)]\nfor index_node in range(len(s)):\n    value_node = int(s[index_node])\n    neighbours[value_node].append(index_node)\ndistances = [-1] * len(s)\ndistances[0] = 0\nq = Queue()\nq.put(0)\nwhile q.empty() == False:\n    if distances[len(s) - 1] != -1:\n        break\n    current_node_index = q.get(0)\n    value = int(s[current_node_index])\n    for neighbour_index in neighbours[value]:\n        if distances[neighbour_index] == -1:\n            distances[neighbour_index] = distances[current_node_index] + 1\n            q.put(neighbour_index)\n    neighbours[value] = []\n    if current_node_index + 1 < len(s) and distances[current_node_index + 1] == -1:\n        distances[current_node_index + 1] = distances[current_node_index] + 1\n        q.put(current_node_index + 1)\n    if current_node_index - 1 > 0 and distances[current_node_index - 1] == -1:\n        distances[current_node_index - 1] = distances[current_node_index] + 1\n        q.put(current_node_index - 1)\nprint(distances[len(s) - 1])", "from queue import Queue\nimport sys\nsys.setrecursionlimit(100000)\nMAX = 100000\npath = [0 for i in range(MAX)]\nvisited = [False for i in range(MAX)]\ngraph = [[] for i in range(10)]\n\ndef BFS(start, end):\n    q = Queue()\n    q.put(start)\n    visited[start] = True\n    while not q.empty():\n        u = q.get()\n        if u == end:\n            break\n        tmp = ord(s[u]) - 48\n        for i in range(len(graph[tmp])):\n            v = graph[tmp][i]\n            if not visited[v]:\n                visited[v] = True\n                path[v] = path[u] + 1\n                q.put(v)\n        graph[tmp].clear()\n        if u - 1 >= 0 and (not visited[u - 1]):\n            visited[u - 1] = True\n            path[u - 1] = path[u] + 1\n            q.put(u - 1)\n        if u + 1 < n and (not visited[u + 1]):\n            visited[u + 1] = True\n            path[u + 1] = path[u] + 1\n            q.put(u + 1)\n    return path[end]\ns = input().strip()\nn = len(s)\nfor i in range(n):\n    tmp = ord(s[i]) - 48\n    graph[tmp].append(i)\nprint(BFS(0, n - 1))", "import sys\nimport queue\nsys.setrecursionlimit(100000)\nINF = int(10000000.0 + 1)\nMAX = 100005\n\nclass Pair:\n\n    def __init__(self, a, b):\n        self.first = a\n        self.second = b\n\ndef minJumps(s):\n    s = list(map(int, list(s)))\n    occ = [[] for i in range(10)]\n    for i in range(len(s)):\n        occ[s[i]].append(i)\n    vis = [False for i in range(len(s))]\n    Q = queue.Queue()\n    Q.put(Pair(0, 0))\n    vis[0] = True\n    ans = -1\n    while not Q.empty():\n        front = Q.get()\n        (u, w) = (front.first, front.second)\n        if u == len(s) - 1:\n            ans = w\n            break\n        if u < len(s) - 1 and (not vis[u + 1]):\n            Q.put(Pair(u + 1, w + 1))\n            vis[u + 1] = True\n        if u > 0 and (not vis[u - 1]):\n            Q.put(Pair(u - 1, w + 1))\n            vis[u - 1] = False\n        for idx in occ[s[u]]:\n            if not vis[idx]:\n                vis[idx] = True\n                Q.put(Pair(idx, w + 1))\n        occ[s[u]].clear()\n    print(ans)\n\ndef main():\n    minJumps(input().strip())\nmain()", "inn = input().strip()\nqueue = []\ncheck = 0\nn = len(inn)\nidex = [[] for _ in range(10)]\njump = [-1 for _ in range(n)]\njump[0] = 0\nqueue = [0]\nif len(inn) == 1:\n    print(0)\nelse:\n    for i in range(n):\n        nn = int(inn[i])\n        idex[nn].append(i)\n    while jump[-1] == -1:\n        idx = queue.pop(0)\n        v = int(inn[idx])\n        left = idx - 1\n        rigth = idx + 1\n        if left > 0:\n            if jump[left] == -1:\n                jump[left] = jump[idx] + 1\n                queue.append(left)\n        if rigth < n:\n            if jump[rigth] == -1:\n                jump[rigth] = jump[idx] + 1\n                queue.append(rigth)\n        if len(idex[v]) > 0:\n            idex[v].remove(idx)\n            for i in idex[v][::-1]:\n                if jump[-1] != -1:\n                    break\n                if jump[i] == -1:\n                    jump[i] = jump[idx] + 1\n                    queue.append(i)\n            idex[v] = []\n    print(jump[-1])", "s = input().strip()\nadj = [[] for _ in range(10)]\nfor i in range(len(s)):\n    adj[int(s[i])].append(i)\nd = [-1] * len(s)\nd[0] = 0\nqueue = []\nqueue.append(0)\nwhile queue:\n    u = queue.pop(0)\n    if d[len(s) - 1] != -1:\n        break\n    n = int(s[u])\n    for v in adj[n]:\n        if d[v] == -1:\n            d[v] = d[u] + 1\n            queue.append(v)\n    adj[n] = []\n    if u and d[u - 1] == -1:\n        d[u - 1] = d[u] + 1\n        queue.append(u - 1)\n    if u + 1 < len(s) and d[u + 1] == -1:\n        d[u + 1] = d[u] + 1\n        queue.append(u + 1)\nprint(d[len(s) - 1])", "from queue import Queue\ns = input().strip()\nedges = [[] for _ in range(10)]\nfor i in range(len(s)):\n    edges[int(s[i])].append(i)\ndist = [-1 for _ in range(len(s))]\nq = Queue()\nq.put(0)\ndist[0] = 0\nwhile not q.empty():\n    index = q.get()\n    if dist[len(s) - 1] != -1:\n        break\n    val = int(s[index])\n    for v in edges[val]:\n        if dist[v] == -1:\n            dist[v] = dist[index] + 1\n            q.put(v)\n    edges[val] = []\n    if index > 0 and dist[index - 1] == -1:\n        dist[index - 1] = dist[index] + 1\n        q.put(index - 1)\n    if index + 1 < len(s) and dist[index + 1] == -1:\n        dist[index + 1] = dist[index] + 1\n        q.put(index + 1)\nprint(dist[len(s) - 1])", "import queue\nn = input().strip()\na = []\nl = 0\nfor i in n:\n    a.append(int(i))\n    l += 1\ncheck = [[0] for x in range(10)]\nfor i in range(l):\n    check[a[i]].append(i)\nq = queue.Queue(l + 1)\nvisited = [-1 for x in range(l)]\nq.put(0)\nvisited[0] = 0\nwhile q.empty() == False:\n    cur = q.get()\n    if cur - 1 >= 0 and visited[cur - 1] == -1:\n        q.put(cur - 1)\n        visited[cur - 1] = visited[cur] + 1\n    if cur + 1 < l and visited[cur + 1] == -1:\n        q.put(cur + 1)\n        visited[cur + 1] = visited[cur] + 1\n    if check[a[cur]][0] == 0:\n        check[a[cur]][0] = 1\n        for i in range(1, len(check[a[cur]])):\n            if visited[check[a[cur]][i]] == -1:\n                q.put(check[a[cur]][i])\n                visited[check[a[cur]][i]] = visited[cur] + 1\n                if check[a[cur]][i] == l - 1:\n                    break\n    if visited[l - 1] != -1:\n        break\nprint(visited[l - 1])", "import sys\nfrom collections import deque\ns = list(map(int, list(input().strip())))\nn = len(s)\ndigits = [[] for i in range(10)]\ndist = [-1] * n\nused = [False] * 10\nfor i in range(n):\n    digits[s[i]].append(i)\ndist[0] = 0\nq = deque([0])\nans = 0\nwhile q:\n    v = q.popleft()\n    cur = dist[v]\n    if v == n - 1:\n        print(cur)\n        sys.exit()\n    if cur != 0 and dist[v - 1] == -1:\n        dist[v - 1] = cur + 1\n        q.append(v - 1)\n    if dist[v + 1] == -1:\n        dist[v + 1] = cur + 1\n        q.append(v + 1)\n    if not used[s[v]]:\n        used[s[v]] = True\n        for i in digits[s[v]]:\n            if dist[i] == -1:\n                dist[i] = cur + 1\n                q.append(i)", "s1 = input()\ns1 = s1.strip()\ns1 = list(s1)\ns = []\nhash1 = []\nfor i in range(10):\n    hash1.append([])\nl = len(s1)\nfor i in range(l):\n    s.append(int(s1[i]))\n    hash1[s[i]].append(i)\nsrc = 0\ndest = l - 1\nif l == 1:\n    print(0)\nelse:\n    dist = []\n    visited = []\n    times = []\n    for i in range(l):\n        dist.append(0)\n        visited.append(0)\n    dist[0] = 0\n    qu = []\n    le = 0\n    qu.append(0)\n    le += 1\n    visited[0] = 1\n    while le != 0:\n        x = qu[0]\n        del qu[0]\n        le -= 1\n        if x == l - 1:\n            break\n        if x - 1 >= 0 and visited[x - 1] == 0:\n            visited[x - 1] = 1\n            qu.append(x - 1)\n            le += 1\n            dist[x - 1] = dist[x] + 1\n        if x + 1 < l and visited[x + 1] == 0:\n            visited[x + 1] = 1\n            qu.append(x + 1)\n            le += 1\n            dist[x + 1] = dist[x] + 1\n        for i in range(len(hash1[s[x]])):\n            if visited[hash1[s[x]][i]] == 0:\n                visited[hash1[s[x]][i]] = 1\n                qu.append(hash1[s[x]][i])\n                dist[hash1[s[x]][i]] = dist[x] + 1\n                le += 1\n        hash1[s[x]] = []\n    print(dist[l - 1])", "s = input()\ns = s.strip()\ns = list(s)\nhash1 = []\nfor i in range(10):\n    hash1.append([])\nl = len(s)\nfor i in range(l):\n    hash1[ord(s[i]) - ord('0')].append(i)\nsrc = 0\ndest = l - 1\nif l == 1:\n    print(0)\nelse:\n    dist = []\n    visited = []\n    times = []\n    for i in range(l):\n        dist.append(0)\n        visited.append(0)\n    dist[0] = 0\n    qu = []\n    le = 0\n    qu.append(0)\n    le += 1\n    visited[0] = 1\n    while le != 0:\n        x = qu[0]\n        del qu[0]\n        le -= 1\n        if x == l - 1:\n            break\n        if x - 1 >= 0 and visited[x - 1] == 0:\n            visited[x - 1] = 1\n            qu.append(x - 1)\n            le += 1\n            dist[x - 1] = dist[x] + 1\n        if x + 1 < l and visited[x + 1] == 0:\n            visited[x + 1] = 1\n            qu.append(x + 1)\n            le += 1\n            dist[x + 1] = dist[x] + 1\n        val1 = hash1[ord(s[x]) - ord('0')]\n        for i in range(len(val1)):\n            val2 = val1[i]\n            if visited[val2] == 0:\n                visited[val2] = 1\n                qu.append(val2)\n                dist[val2] = dist[x] + 1\n                le += 1\n        hash1[ord(s[x]) - ord('0')] = []\n    print(dist[l - 1])", "s = input()\ns = s.strip()\ns = list(s)\nhash1 = []\nfor i in range(10):\n    hash1.append([])\nl = len(s)\nfor i in range(l):\n    hash1[ord(s[i]) - ord('0')].append(i)\nsrc = 0\ndest = l - 1\nif l == 1:\n    print(0)\nelse:\n    dist = []\n    visited = []\n    times = []\n    for i in range(l):\n        dist.append(0)\n        visited.append(0)\n    dist[0] = 0\n    qu = []\n    le = 0\n    qu.append(0)\n    le += 1\n    visited[0] = 1\n    while le != 0:\n        x = qu[0]\n        del qu[0]\n        le -= 1\n        if x == l - 1:\n            break\n        val = ord(s[x]) - ord('0')\n        for i in range(len(hash1[val])):\n            val2 = hash1[val][i]\n            if visited[val2] == 0:\n                visited[val2] = 1\n                qu.append(val2)\n                dist[val2] = dist[x] + 1\n                le += 1\n        hash1[val] = []\n        if x - 1 >= 0 and visited[x - 1] == 0:\n            visited[x - 1] = 1\n            qu.append(x - 1)\n            le += 1\n            dist[x - 1] = dist[x] + 1\n        if x + 1 < l and visited[x + 1] == 0:\n            visited[x + 1] = 1\n            qu.append(x + 1)\n            le += 1\n            dist[x + 1] = dist[x] + 1\n    print(dist[l - 1])", "from sys import stdin, stdout\n\ndef sin():\n    return stdin.readline().rstrip()\n\ndef listInput():\n    return list(map(int, sin().split()))\n\ndef printBS(li):\n    if not li:\n        return\n    for i in range(len(li) - 1):\n        stdout.write('%d ' % li[i])\n    stdout.write('%d\\n' % li[-1])\nli = [int(i) for i in sin()]\nMAX = 10 ** 6\nn = len(li)\nmc = [MAX] * 10\nans = [MAX] * n\nans[-1] = 0\nmc[li[-1]] = 0\nfor _ in range(19):\n    for i in range(n - 2, -1, -1):\n        ans[i] = min(ans[i + 1] + 1, 1 + mc[li[i]])\n        if ans[i] < mc[li[i]]:\n            mc[li[i]] = ans[i]\n    for i in range(1, n - 1):\n        ans[i] = min(ans[i - 1] + 1, 1 + mc[li[i]], ans[i])\n        mc[li[i]] = min(ans[i], mc[li[i]])\nprint(ans[0])", "from heapq import *\nS = input().strip()\nN = len(S)\ngraph = [[] for i in range(N + 10)]\nfor i in range(N):\n    if i == 0:\n        graph[i].append((1, i + 1))\n    elif i == N - 1:\n        graph[i].append((1, i - 1))\n    else:\n        graph[i].append((1, i + 1))\n        graph[i].append((1, i - 1))\n    dummy_node = N + int(S[i])\n    graph[i].append((0.5, dummy_node))\n    graph[dummy_node].append((0.5, i))\n\ndef dijkstra(s):\n    q = [(0, s)]\n    dist[s] = 0\n    while q:\n        (d, u) = heappop(q)\n        if d <= dist[u]:\n            for (w, v) in graph[u]:\n                if dist[v] > dist[u] + w:\n                    dist[v] = dist[u] + w\n                    heappush(q, (dist[v], v))\ninf = 1 << 64 - 1\ndist = [inf for _ in range(N + 10)]\ndijkstra(0)\nprint(int(dist[N - 1]))", "seq = [int(x) for x in input().strip()]\nn = len(seq)\nif n == 1:\n    print(0)\nelif n == 2:\n    print(1)\nelse:\n    same = [[] for _ in range(10)]\n    cost_arr = [0.5 for _ in range(n)]\n    bool_arr = [False for _ in range(10)]\n    for index in range(n):\n        same[seq[index]].append(index)\n    cost_arr[n - 1] = 0\n    mark_list = [n - 1]\n    k = 1\n    while cost_arr[0] == 0.5 and len(mark_list) != 0:\n        local_list = []\n        for index in mark_list:\n            num = seq[index]\n            if index + 1 < n and cost_arr[index + 1] == 0.5:\n                cost_arr[index + 1] = k\n                local_list.append(index + 1)\n            if index > 0 and cost_arr[index - 1] == 0.5:\n                cost_arr[index - 1] = k\n                local_list.append(index - 1)\n            if not bool_arr[num]:\n                for duplicate in same[num]:\n                    if cost_arr[duplicate] == 0.5:\n                        cost_arr[duplicate] = cost_arr[index] + 1\n                        local_list.append(duplicate)\n                bool_arr[num] = True\n        mark_list = local_list\n        k += 1\n    print(cost_arr[0])", "seq = [int(x) for x in input().strip()]\nn = len(seq)\nif n == 1:\n    print(0)\nelif n == 2:\n    print(1)\nelse:\n    same = [[] for _ in range(10)]\n    cost_arr = [0.5 for _ in range(n)]\n    bool_arr = [False for _ in range(10)]\n    for index in range(n):\n        same[seq[index]].append(index)\n    cost_arr[n - 1] = 0\n    mark_list = [n - 1]\n    while cost_arr[0] == 0.5 and len(mark_list) != 0:\n        index = mark_list.pop(0)\n        num = seq[index]\n        if index > 0 and cost_arr[index - 1] == 0.5:\n            cost_arr[index - 1] = cost_arr[index] + 1\n            mark_list.append(index - 1)\n        if index + 1 < n and cost_arr[index + 1] == 0.5:\n            cost_arr[index + 1] = cost_arr[index] + 1\n            mark_list.append(index + 1)\n        if not bool_arr[num]:\n            for duplicate in same[num]:\n                if cost_arr[duplicate] == 0.5:\n                    cost_arr[duplicate] = cost_arr[index] + 1\n                    mark_list.append(duplicate)\n            bool_arr[num] = True\n    print(cost_arr[0])", "seq = [int(x) for x in input().strip()]\nn = len(seq)\nif n == 1:\n    print(0)\nelif n == 2:\n    print(1)\nelse:\n    same = [[] for _ in range(10)]\n    cost_arr = [0.5 for _ in range(n)]\n    bool_arr = [False for _ in range(10)]\n    for index in range(n):\n        same[seq[index]].append(index)\n    cost_arr[n - 1] = 0\n    mark_list = [n - 1]\n    while cost_arr[0] == 0.5 and len(mark_list) != 0:\n        index = mark_list.pop(0)\n        num = seq[index]\n        if index > 0 and cost_arr[index - 1] == 0.5:\n            cost_arr[index - 1] = cost_arr[index] + 1\n            mark_list.append(index - 1)\n        if index + 1 < n and cost_arr[index + 1] == 0.5:\n            cost_arr[index + 1] = cost_arr[index] + 1\n            mark_list.append(index + 1)\n        if not bool_arr[num]:\n            for duplicate in same[num]:\n                if cost_arr[duplicate] == 0.5:\n                    cost_arr[duplicate] = cost_arr[index] + 1\n                    mark_list.append(duplicate)\n            bool_arr[num] = True\n    print(cost_arr[0])", "seq = [int(x) for x in input().strip()]\nn = len(seq)\nif n == 1:\n    print(0)\nelif n == 2:\n    print(1)\nelse:\n    arr = list()\n    same = [[] for _ in range(10)]\n    cost_arr = [0 for _ in range(n)]\n    bool_arr = [False for _ in range(10)]\n    for j in range(n):\n        same[seq[j]].append(j)\n    cost_arr[0] = 1\n    arr.append(0)\n    while cost_arr[n - 1] == 0 and len(arr) != 0:\n        index = arr.pop(0)\n        num = seq[index]\n        if not bool_arr[num]:\n            size = len(same[num])\n            for i in range(size):\n                if cost_arr[same[num][i]] == 0:\n                    cost_arr[same[num][i]] = cost_arr[index] + 1\n                    arr.append(same[num][i])\n            bool_arr[num] = True\n        if index > 0 and cost_arr[index - 1] == 0:\n            cost_arr[index - 1] = cost_arr[index] + 1\n            arr.append(index - 1)\n        if index + 1 < n and cost_arr[index + 1] == 0:\n            cost_arr[index + 1] = cost_arr[index] + 1\n            arr.append(index + 1)\n    print(cost_arr[n - 1] - 1)", "import re\nfrom collections import deque\nQUEUED = set()\nNEXT = deque([])\nUSED_DIGITS = set()\nJUMPS = {}\n\ndef get_steps():\n    steps = 0\n    index = 0\n    end = len(S) - 1\n    for i in range(0, 10):\n        JUMPS[str(i)] = []\n    for (i, digit) in enumerate(S):\n        JUMPS[digit].append(i)\n    while index != end:\n        if S[index] not in USED_DIGITS:\n            for i in reversed(JUMPS[S[index]]):\n                if i != index and i not in QUEUED:\n                    if i == end:\n                        NEXT.append((i, steps + 1))\n                        QUEUED.add(i)\n                    elif S[i + 1] not in USED_DIGITS or S[i - 1] not in USED_DIGITS:\n                        NEXT.append((i, steps + 1))\n                        QUEUED.add(i)\n            USED_DIGITS.add(S[index])\n        if index + 1 not in QUEUED and S[index + 1] not in USED_DIGITS:\n            NEXT.append((index + 1, steps + 1))\n            QUEUED.add(i)\n        if index - 1 not in QUEUED and S[index - 1] not in USED_DIGITS and index:\n            NEXT.append((index - 1, steps + 1))\n            QUEUED.add(i)\n        USED_DIGITS.add(S[index])\n        (index, steps) = NEXT.popleft()\n    return steps\nS = input()\nS = re.sub('\\\\D', '', S)\nS = re.sub('(\\\\d)\\\\1\\\\1+', '\\\\1\\\\1', S)\nprint(get_steps())"]