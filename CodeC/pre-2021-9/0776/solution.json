["t = int(input())\nfor _ in range(t):\n    n = int(input())\n    xs = []\n    ys = []\n    for _ in range(n):\n        (x, y) = map(int, input().split())\n        xs.append(x)\n        ys.append(y)\n    xs.sort()\n    ys.sort()\n    if n % 2 == 1:\n        print(1)\n    else:\n        mv = n // 2\n        xm = xs[mv] - xs[mv - 1] + 1\n        ym = ys[mv] - ys[mv - 1] + 1\n        print(xm * ym)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    xs = []\n    ys = []\n    for _ in range(n):\n        (x, y) = map(int, input().split())\n        xs.append(x)\n        ys.append(y)\n    xs.sort()\n    ys.sort()\n    if n % 2 == 1:\n        print(1)\n    else:\n        mv = n // 2\n        xm = xs[mv] - xs[mv - 1] + 1\n        ym = ys[mv] - ys[mv - 1] + 1\n        print(xm * ym)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    xs = []\n    ys = []\n    for _ in range(n):\n        (x, y) = map(int, input().split())\n        xs.append(x)\n        ys.append(y)\n    xs.sort()\n    ys.sort()\n    if n % 2 == 1:\n        print(1)\n    else:\n        mv = n // 2\n        xm = xs[mv] - xs[mv - 1] + 1\n        ym = ys[mv] - ys[mv - 1] + 1\n        print(xm * ym)", "for _ in range(int(input())):\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x += [a]\n        y += [b]\n    if n % 2:\n        print(1)\n    else:\n        x.sort()\n        y.sort()\n        print((x[n // 2] - x[(n - 1) // 2] + 1) * (y[n // 2] - y[(n - 1) // 2] + 1))", "for _ in range(int(input())):\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x += [a]\n        y += [b]\n    if n % 2:\n        print(1)\n    else:\n        x.sort()\n        y.sort()\n        print((x[n // 2] - x[(n - 1) // 2] + 1) * (y[n // 2] - y[(n - 1) // 2] + 1))", "def find(X, n):\n    X.sort()\n    if n % 2 == 1:\n        return 1\n    else:\n        return X[n // 2] - X[n // 2 - 1] + 1\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    X = []\n    Y = []\n    for _ in range(n):\n        (a, b) = map(int, input().split())\n        X.append(a)\n        Y.append(b)\n    print(find(X, n) * find(Y, n))", "t = int(input())\nfor i in range(t):\n    x = []\n    y = []\n    n = int(input())\n    for j in range(n):\n        (a, b) = map(int, input().split())\n        x.append(a)\n        y.append(b)\n    x.sort()\n    y.sort()\n    a = 1\n    b = 1\n    ans = 1\n    for k in (x, y):\n        if len(k) & 1 != 1:\n            (s, t) = (len(k) // 2, len(k) // 2 - 1)\n            ans *= k[s] - k[t] + 1\n    print(ans)", "t = int(input())\nfor i in range(t):\n    x = []\n    y = []\n    n = int(input())\n    for j in range(n):\n        (a, b) = map(int, input().split())\n        x.append(a)\n        y.append(b)\n    x.sort()\n    y.sort()\n    a = 1\n    b = 1\n    ans = 1\n    for k in (x, y):\n        if len(k) & 1 != 1:\n            (s, t) = (len(k) // 2, len(k) // 2 - 1)\n            ans *= k[s] - k[t] + 1\n    print(ans)", "from sys import stdin, stdout\ninp = lambda : map(int, stdin.readline().split())\nfrom bisect import bisect_right as br\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    x = []\n    y = []\n    for i in range(n):\n        (a, b) = inp()\n        x.append(a)\n        y.append(b)\n    x.sort()\n    y.sort()\n    a1 = x[n // 2] - x[(n - 1) // 2] + 1\n    a2 = y[n // 2] - y[(n - 1) // 2] + 1\n    print(a1 * a2)", "for _ in range(int(input())):\n    x = []\n    y = []\n    n = int(input())\n    for _ in range(n):\n        (a, b) = [int(c) for c in input().split()]\n        x.append(a)\n        y.append(b)\n    x.sort()\n    y.sort()\n    a = 1\n    b = 1\n    ans = 1\n    for u in (x, y):\n        if len(u) & 1 != 1:\n            (i, j) = (len(u) // 2, len(u) // 2 - 1)\n            ans *= u[i] - u[j] + 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    xi = []\n    yi = []\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        xi.append(x)\n        yi.append(y)\n    if n % 2 != 0:\n        print(1)\n    else:\n        xi.sort()\n        yi.sort()\n        l = xi[n // 2] - xi[(n - 1) // 2] + 1\n        r = yi[n // 2] - yi[(n - 1) // 2] + 1\n        print(l * r)", "for _ in range(int(input())):\n    n = int(input())\n    xi = []\n    yi = []\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        xi.append(x)\n        yi.append(y)\n    if n % 2 != 0:\n        print(1)\n    else:\n        xi.sort()\n        yi.sort()\n        l = xi[n // 2] - xi[(n - 1) // 2] + 1\n        r = yi[n // 2] - yi[(n - 1) // 2] + 1\n        print(l * r)", "for _ in range(int(input())):\n    n = int(input())\n    xi = []\n    yi = []\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        xi.append(x)\n        yi.append(y)\n    if n % 2 != 0:\n        print(1)\n    else:\n        xi.sort()\n        yi.sort()\n        l = xi[n // 2] - xi[(n - 1) // 2] + 1\n        r = yi[n // 2] - yi[(n - 1) // 2] + 1\n        print(l * r)", "def findHouseLocations():\n    t = int(input())\n    for j in range(t):\n        n = int(input())\n        x = []\n        y = []\n        for i in range(n):\n            m = list(map(int, input().split()))\n            x.append(m[0])\n            y.append(m[1])\n        x.sort()\n        y.sort()\n        x1 = x[n // 2] - x[(n - 1) // 2] + 1\n        y1 = y[n // 2] - y[(n - 1) // 2] + 1\n        print(x1 * y1)\nfindHouseLocations()", "from sys import stdin, stdout\ninp = lambda : map(int, stdin.readline().split())\nfrom bisect import bisect_right as br\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    x = []\n    y = []\n    for i in range(n):\n        (a, b) = inp()\n        x.append(a)\n        y.append(b)\n    x.sort()\n    y.sort()\n    a1 = x[n // 2] - x[(n - 1) // 2] + 1\n    a2 = y[n // 2] - y[(n - 1) // 2] + 1\n    print(a1 * a2)", "def io(func=str, n=1):\n\n    def nfp():\n        ff = str\n        try:\n            it = iter(func)\n\n            def nf(val):\n                nonlocal ff\n                ff = next(it, ff)\n                return ff(val)\n            return type(func)((nf(va) for va in input().split()))\n        except TypeError:\n            return func(input())\n    if type(n) is list:\n        return [_(func, x) for x in n]\n    else:\n        t = lambda : nfp()\n        if n == 1:\n            return t()\n        elif n == 0:\n            return [t() for i in range(int(input()))]\n        else:\n            return [t() for i in range(n)]\n\ndef median(seq):\n    seq = sorted(seq)\n    if len(seq) % 2 == 1:\n        return [seq[len(seq) // 2]]\n    else:\n        return list(range(seq[len(seq) // 2 - 1], seq[len(seq) // 2] + 1))\n\ndef median(seq):\n    if len(seq) % 2 == 1:\n        return 1\n    else:\n        seq = sorted(seq)\n        return seq[len(seq) // 2] - seq[len(seq) // 2 - 1] + 1\n\ndef main():\n    T = io(int)\n    for test in range(T):\n        R = io((int, int), 0)\n        [X, Y] = [median(l) for l in zip(*R)]\n        yield (X * Y)\nprint('\\n'.join([str(res) for res in main()]))"]