["l = [True] * 2000001\nfor i in range(2, 2000001):\n    if l[i]:\n        for j in range(2 * i, 2000000, i):\n            l[j] = False\n    if i * i > 2000000:\n        break\nmark = 0\nfor i in range(2, 2000001):\n    if l[i]:\n        mark += 1\n    l[i] = mark\n(n, m) = map(int, input().split())\nres = l[n + m]\nprint(res)", "l = [True] * 2000001\nfor i in range(2, 2000001):\n    if l[i]:\n        for j in range(2 * i, 2000000, i):\n            l[j] = False\n    if i * i > 2000000:\n        break\nmark = 0\nfor i in range(2, 2000001):\n    if l[i]:\n        mark += 1\n    l[i] = mark\n(n, m) = map(int, input().split())\nres = l[n + m]\nprint(res)", "l = [True] * 2000001\nfor i in range(2, 2000001):\n    if l[i]:\n        for j in range(2 * i, 2000000, i):\n            l[j] = False\n    if i * i > 2000000:\n        break\nmark = 0\nfor i in range(2, 2000001):\n    if l[i]:\n        mark += 1\n    l[i] = mark\n(n, m) = map(int, input().split())\nres = l[n + m]\nprint(res)", "l = [True] * 2000001\nfor i in range(2, 2000001):\n    if l[i]:\n        for j in range(2 * i, 2000000, i):\n            l[j] = False\n    if i * i > 2000000:\n        break\nmark = 0\nfor i in range(2, 2000001):\n    if l[i]:\n        mark += 1\n    l[i] = mark\n(n, m) = map(int, input().split())\nres = l[n + m]\nprint(res)", "l = [True] * 2000001\nfor i in range(2, 2000001):\n    if l[i]:\n        for j in range(2 * i, 2000000, i):\n            l[j] = False\n    if i * i > 2000000:\n        break\nmark = 0\nfor i in range(2, 2000001):\n    if l[i]:\n        mark += 1\n    l[i] = mark\n(n, m) = map(int, input().split())\nprint(l[n + m])", "l = [True] * 2000001\nfor i in range(2, 2000001):\n    if l[i]:\n        for j in range(2 * i, 2000000, i):\n            l[j] = False\n    if i * i > 2000000:\n        break\nmark = 0\nfor i in range(2, 2000001):\n    if l[i]:\n        mark += 1\n    l[i] = mark\n(n, m) = map(int, input().split())\nprint(l[n + m])", "l = [True] * 2000001\nfor i in range(2, 2000001):\n    if l[i]:\n        for j in range(2 * i, 2000000, i):\n            l[j] = False\n    if i * i > 2000000:\n        break\nmark = 0\nfor i in range(2, 2000001):\n    if l[i]:\n        mark += 1\n    l[i] = mark\n(n, m) = map(int, input().split())\nprint(l[n + m])", "l = [True] * 2000001\nfor i in range(2, 2000001):\n    if l[i]:\n        for j in range(2 * i, 2000000, i):\n            l[j] = False\n    if i * i > 2000000:\n        break\nmark = 0\nfor i in range(2, 2000001):\n    if l[i]:\n        mark += 1\n    l[i] = mark\n(n, m) = map(int, input().split())\nprint(l[n + m])", "l = [True] * 2000001\nfor i in range(2, 2000001):\n    if l[i]:\n        for j in range(2 * i, 2000000, i):\n            l[j] = False\n    if i * i > 2000000:\n        break\nmark = 0\nfor i in range(2, 2000001):\n    if l[i]:\n        mark += 1\n    l[i] = mark\n(n, m) = map(int, input().split())\nprint(l[n + m])", "l = [True] * 2000001\nfor i in range(2, 2000001):\n    if l[i]:\n        for j in range(2 * i, 2000000, i):\n            l[j] = False\n    if i * i > 2000000:\n        break\nmark = 0\nfor i in range(2, 2000001):\n    if l[i]:\n        mark += 1\n    l[i] = mark\n(n, m) = map(int, input().split())\nprint(l[n + m])", "MAXN = 2000003\nseive = [True] * MAXN\nseive[1] = False\ncount = [0] * MAXN\nfor i in range(2, MAXN):\n    if seive[i]:\n        for j in range(i * i, MAXN, i):\n            seive[j] = False\n    if i * i > MAXN:\n        break\ncurrent = 0\nfor i in range(2, MAXN):\n    if seive[i]:\n        current += 1\n    count[i] = current\n(n, m) = map(int, input().split())\nprint(count[n + m])", "prime_factors = [i for i in range(2 * 10 ** 6 + 1)]\nprime_arr = []\ncount = 0\nfor i in range(2, 2 * 10 ** 6 + 1):\n    if prime_factors[i] == i:\n        prime_arr.append(i)\n        num = i * i\n        count += 1\n        while num <= 2 * 10 ** 6:\n            if prime_factors[num] == num:\n                prime_factors[num] = i\n            num += i\nprime_arr_len = len(prime_arr)\n\ndef bin_search_primes(num):\n    start = 0\n    end = prime_arr_len - 1\n    while start <= end:\n        middle = (start + end) // 2\n        if prime_arr[middle] == num or (prime_arr[middle] < num and (middle + 1 == prime_arr_len or prime_arr[middle + 1] > num)):\n            return middle + 1\n        elif prime_arr[middle] > num:\n            end = middle - 1\n        else:\n            start = middle + 1\n(rows, columns) = map(int, input().split())\nprint(bin_search_primes(rows + columns))", "prime_factors = [i for i in range(2 * 10 ** 6 + 1)]\ncount = 0\nfor i in range(2, 2 * 10 ** 6 + 1):\n    if prime_factors[i] == i:\n        num = i * i\n        count += 1\n        while num <= 2 * 10 ** 6:\n            if prime_factors[num] == num:\n                prime_factors[num] = i\n            num += i\nprime_arr = []\nfor i in range(2, 2 * 10 ** 6 + 1):\n    if prime_factors[i] == i:\n        prime_arr.append(i)\nprime_arr_len = len(prime_arr)\n\ndef bin_search_primes(num):\n    start = 0\n    end = prime_arr_len - 1\n    while start <= end:\n        middle = (start + end) // 2\n        if prime_arr[middle] == num or (prime_arr[middle] < num and (middle + 1 == prime_arr_len or prime_arr[middle + 1] > num)):\n            return middle + 1\n        elif prime_arr[middle] > num:\n            end = middle - 1\n        else:\n            start = middle + 1\n(rows, columns) = map(int, input().split())\nprint(bin_search_primes(rows + columns))", "MAXN = 2000003\nseive = [True] * MAXN\nseive[1] = False\ncount = [0] * MAXN\nfor i in range(2, MAXN):\n    if seive[i]:\n        for j in range(i * i, MAXN, i):\n            seive[j] = False\n    if i * i > MAXN:\n        break\ncurrent = 0\nfor i in range(2, MAXN):\n    if seive[i]:\n        current += 1\n    count[i] = current\n(n, m) = map(int, input().split())\nprint(count[n + m])", "MAXN = 2000003\nseive = [True] * MAXN\nseive[1] = False\ncount = [0] * MAXN\nfor i in range(2, MAXN):\n    if seive[i]:\n        for j in range(i * i, MAXN, i):\n            seive[j] = False\n    if i * i > MAXN:\n        break\ncurrent = 0\nfor i in range(2, MAXN):\n    if seive[i]:\n        current += 1\n    count[i] = current\n(n, m) = map(int, input().split())\nprint(count[n + m])", "MAXN = 2000003\nseive = [True] * MAXN\nseive[1] = False\ncount = [0] * MAXN\nfor i in range(2, MAXN):\n    if seive[i]:\n        for j in range(i * i, MAXN, i):\n            seive[j] = False\n    if i * i > MAXN:\n        break\ncurrent = 0\nfor i in range(2, MAXN):\n    if seive[i]:\n        current += 1\n    count[i] = current\n(n, m) = map(int, input().split())\nprint(count[n + m])", "def sieve(n):\n    prime = [i for i in range(n + 1)]\n    prime[0] = True\n    prime[1] = True\n    p = 2\n    while p * p <= n:\n        if prime[p] != True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = True\n        p += 1\n    prime = list(set(prime))\n    del prime[0]\n    return prime\n(n, m) = map(int, input().split())\nprint(len(sieve(n + m)))", "def sieve(n):\n    prime = [i for i in range(n + 1)]\n    prime[0] = True\n    prime[1] = True\n    p = 2\n    while p * p <= n:\n        if prime[p] != True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = True\n        p += 1\n    prime = list(set(prime))\n    del prime[0]\n    return prime\n(n, m) = map(int, input().split())\nprint(len(sieve(n + m)))", "def sieve(n):\n    prime = [True for i in range(n + 1)]\n    prime[0] = True\n    prime[1] = True\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    num = 0\n    for i in range(2, n + 1):\n        if prime[i]:\n            num += 1\n    return num\n(n, m) = map(int, input().split())\nprint(sieve(n + m))", "def sieve(n):\n    prime = [True for i in range(n + 1)]\n    prime[0] = True\n    prime[1] = True\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    num = 0\n    for i in range(2, n + 1):\n        if prime[i]:\n            num += 1\n    return num\n(n, m) = map(int, input().split())\nprint(sieve(n + m))", "try:\n    ans = []\n\n    def SieveOfEratosthenes(n):\n        prime = [True for i in range(n + 1)]\n        p = 2\n        while p * p <= n:\n            if prime[p] == True:\n                for i in range(p * p, n + 1, p):\n                    prime[i] = False\n            p += 1\n        for p in range(2, n + 1):\n            if prime[p]:\n                ans.append(p)\n    (n, m) = map(int, input().split())\n    SieveOfEratosthenes(n + m)\n    print(len(ans))\nexcept Exception:\n    pass", "def sieve(n):\n    prime = [i for i in range(n + 1)]\n    prime[0] = True\n    prime[1] = True\n    p = 2\n    while p * p <= n:\n        if prime[p] != True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = True\n        p += 1\n    prime = list(set(prime))\n    del prime[0]\n    return prime\n(n, m) = map(int, input().split())\nprint(len(sieve(n + m)))", "def sieve(n):\n    prime = [i for i in range(n + 1)]\n    prime[0] = True\n    prime[1] = True\n    p = 2\n    while p * p <= n:\n        if prime[p] != True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = True\n        p += 1\n    prime = list(set(prime))\n    del prime[0]\n    return prime\n(n, m) = map(int, input().split())\nprint(len(sieve(n + m)))", "def sieve(n):\n    prime = [i for i in range(n + 1)]\n    prime[0] = True\n    prime[1] = True\n    p = 2\n    while p * p <= n:\n        if prime[p] != True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = True\n        p += 1\n    prime = list(set(prime))\n    del prime[0]\n    return prime\n(n, m) = map(int, input().split())\nprint(len(sieve(n + m)))", "def sieve(n):\n    prime = [i for i in range(n + 1)]\n    prime[0] = True\n    prime[1] = True\n    p = 2\n    while p * p <= n:\n        if prime[p] != True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = True\n        p += 1\n    prime = list(set(prime))\n    del prime[0]\n    return prime\n(n, m) = map(int, input().split())\nprint(len(sieve(n + m)))", "def sieve(n):\n    prime = [i for i in range(n + 1)]\n    prime[0] = True\n    prime[1] = True\n    p = 2\n    while p * p <= n:\n        if prime[p] != True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = True\n        p += 1\n    prime = list(set(prime))\n    del prime[0]\n    return prime\n(n, m) = map(int, input().split())\nprint(len(sieve(n + m)))", "(n, m) = map(int, input().split())\nmi = 2\nma = n + m\nans = [1 for i in range(ma + 1)]\nfor i in range(2, int(ma ** 0.5) + 1):\n    for j in range(i + i, ma + 1, i):\n        ans[j] = 0\nans[0] = 0\nans[1] = 0\nprint(ans.count(1))", "(n, m) = map(int, input().split())\nmi = 2\nma = n + m\nans = [1 for i in range(ma + 1)]\nfor i in range(2, int(ma ** 0.5) + 1):\n    for j in range(i + i, ma + 1, i):\n        ans[j] = 0\nans[0] = 0\nans[1] = 0\nprint(ans.count(1))", "(n, m) = map(int, input().split())\nk = 10000 * 1000 + 7\na = [1] * k\na[0] = a[1] = 0\ni = 2\nwhile i * i <= k:\n    x = i * i\n    if a[i] == 1:\n        for j in range(x, k, i):\n            a[j] = 0\n    i += 1\np = 0\nfor i in range(2, m + n + 1):\n    if a[i] == 1:\n        p += 1\nprint(p)", "(n, m) = map(int, input().split())\nk = 10000 * 1000 + 7\na = [1] * k\na[0] = a[1] = 0\ni = 2\nwhile i * i <= k:\n    x = i * i\n    if a[i] == 1:\n        for j in range(x, k, i):\n            a[j] = 0\n    i += 1\np = 0\nfor i in range(2, m + n + 1):\n    if a[i] == 1:\n        p += 1\nprint(p)", "(n, m) = map(int, input().split())\nk = 10000 * 1000 + 7\na = [1] * k\na[0] = a[1] = 0\ni = 2\nwhile i * i <= k:\n    x = i * i\n    if a[i] == 1:\n        for j in range(x, k, i):\n            a[j] = 0\n    i += 1\np = 0\nfor i in range(2, m + n + 1):\n    if a[i] == 1:\n        p += 1\nprint(p)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    c = 0\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n    print(c)\nfrom sys import stdin\n\ndef get_array():\n    return [int(x) for x in stdin.readline().rstrip().split()]\narr = get_array()\nSieveOfEratosthenes(arr[0] + arr[1] + 1)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    c = 0\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n    print(c)\n(r, c) = map(int, input().split())\nSieveOfEratosthenes(r + c + 1)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    c = 0\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n    print(c)\n(r, c) = map(int, input().split())\nSieveOfEratosthenes(r + c + 1)", "a = input().split(' ')\nn = int(a[0]) + int(a[1])\nl = [1 for i in range(n + 1)]\nl[0] = 0\nl[1] = 0\np = 2\nwhile p * p <= n:\n    if l[p]:\n        for i in range(p * p, n + 1, p):\n            l[i] = 0\n    p += 1\ncount = 0\nfor i in l:\n    if i:\n        count += 1\nprint(count)", "def S(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    c = 0\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n    print(c)\n(r, m) = map(int, input().split())\nn = m + r + 1\nS(n)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    c = 0\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n    print(c)\n(r, c) = map(int, input().split())\nSieveOfEratosthenes(r + c + 1)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    c = 0\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n    print(c)\n(r, c) = map(int, input().split())\nSieveOfEratosthenes(r + c + 1)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    c = 0\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n    print(c)\n(n, m) = [int(i) for i in input().split()]\nmax_n = n + m + 1\nSieveOfEratosthenes(max_n)", "from math import *\n(n, m) = map(int, input().split())\ns = 0\nl = [0] * (n + m + 1)\nfor i in range(2, n + m + 1):\n    if l[i] == 0:\n        for j in range(i ** 2, n + m + 1, i):\n            l[j] = 1\nfor i in range(2, n + m + 1):\n    if l[i] == 0:\n        s += 1\nprint(s)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    c = 0\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n    print(c)\n(r, m) = map(int, input().split())\nn = m + r + 1\nSieveOfEratosthenes(n)", "def isprime(n):\n    if n == 1:\n        return False\n    if n != 2 and n % 2 == 0:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n(n, m) = map(int, input().split())\nprimes = 0\nfor i in range(2, n + m + 1):\n    primes += int(isprime(i))\nprint(primes)", "def Sieve(n):\n    prime = []\n    c = 0\n    for i in range(0, n + 2):\n        prime.append(True)\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for i in range(2, n + 1):\n        if prime[i] == True:\n            c += 1\n    return c\n(n, m) = list(map(int, input().split()))\nprint(Sieve(n + m))", "(n, m) = map(int, input().split())\npi = []\n\ndef prime(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n):\n        if prime[p]:\n            pi.append(p)\n    print(len(pi))\nprime(n + m + 1)", "def Sieve(n):\n    prime = [1 for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = 0\n        p += 1\n    return prime\ntry:\n    (n, m) = list(map(int, input().split()))\n    x = Sieve(n + m)\n    print(sum(x) - 2)\nexcept:\n    pass", "import math\n\ndef sieve(n):\n    l = [True] * (n + 1)\n    prime = []\n    start = 2\n    end = int(math.sqrt(n))\n    while start <= end:\n        if l[start] == True:\n            prime.append(start)\n            for i in range(start * start, n + 1, start):\n                if l[i] == True:\n                    l[i] = False\n        start += 1\n    for j in range(end + 1, n + 1):\n        if l[j] == True:\n            prime.append(j)\n    return prime\n(n, m) = map(int, input().split())\nprint(len(sieve(n + m)))", "def prime(n):\n    if n <= 1:\n        return 0\n    if n <= 3:\n        return 1\n    if n % 2 == 0 or n % 3 == 0:\n        return 0\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return 0\n        i = i + 6\n    return 1\n(n, m) = map(int, input().split())\nans = []\nans.append(2)\nfor i in range(3, n + m + 1, 2):\n    if prime(i) == 1:\n        ans.append(i)\nprint(len(set(ans)))", "def prime(n):\n    if n <= 1:\n        return 0\n    if n <= 3:\n        return 1\n    if n % 2 == 0 or n % 3 == 0:\n        return 0\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return 0\n        i = i + 6\n    return 1\n(n, m) = map(int, input().split())\nans = []\nans.append(2)\nfor i in range(3, n + m + 1, 2):\n    if prime(i) == 1:\n        ans.append(i)\nprint(len(set(ans)))", "def isprime(x):\n    if x == 2 or x == 3:\n        return True\n    elif x % 2 == 0 or x % 3 == 0:\n        return False\n    else:\n        a = int(x ** (1 / 2))\n        for i in range(5, a + 1, 6):\n            if x % i == 0 or x % (i + 2) == 0:\n                return False\n        return True\n(n, m) = map(int, input().strip().split())\nlower = 2\nupper = n + m\ncu = 0\nfor i in range(lower, upper + 1):\n    if isprime(i) == True:\n        cu += 1\nprint(cu)", "def sieve(n):\n    prime = []\n    for i in range(0, n + 1):\n        prime.append(True)\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for j in range(p * p, n + 1, p):\n                prime[j] = False\n        p = p + 1\n    prime = prime[2:]\n    return prime.count(True)\n(n1, m1) = map(int, input().split())\na = n1 + m1\nprint(sieve(a))", "(m, n) = map(int, input().split())\nl = [1] * (m + n + 1)\nl[0] = 0\nl[1] = 0\nfor i in range(2, int((m + n) ** 0.5) + 1):\n    if l[i] == 1:\n        for j in range(2 * i, m + n + 1, i):\n            l[j] = 0\nprint(l.count(1))", "(m, n) = map(int, input().split())\nl = [1] * (m + n + 1)\nl[0] = 0\nl[1] = 0\nfor i in range(2, int((m + n) ** 0.5) + 1):\n    if l[i] == 1:\n        for j in range(2 * i, m + n + 1, i):\n            l[j] = 0\nprint(l.count(1))", "import math\n\ndef isprime(n):\n    F = math.floor(math.sqrt(n))\n    for i in range(2, F + 1):\n        if n % i == 0:\n            return False\n    return True\np = input().rstrip().split(' ')\na = int(p[0])\nb = int(p[1])\nA = 2\nG = 0\nB = 2 + (a - 1) + (b - 1)\nl = [1] * (B + 1)\nl[0] = 0\nl[1] = 0\nC = math.floor(math.sqrt(B))\nfor i in range(2, C + 1):\n    if l[i] == 1 and isprime(i):\n        l[i] = 1\n        A = 2\n        T = i * A\n        while T < len(l):\n            l[T] = 0\n            A += 1\n            T = i * A\nprint(l.count(1))", "def isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\n(x, y) = map(int, input().split())\nlist = []\ncount = 0\nfor i in range(x + y + 1):\n    if isPrime(i):\n        count += 1\nprint(count)", "def isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\n\ndef printPrime(n):\n    x = 0\n    for i in range(2, n + 1):\n        if isPrime(i):\n            x += 1\n    return x\n(n, m) = input().split()\nprint(printPrime(int(n) + int(m)))", "def get_the_number_of_primes_less_than_or_equal_to_n(n):\n    is_prime = [True for i in range(n + 1)]\n    is_prime[0] = False\n    is_prime[1] = False\n    num_of_primes = 0\n    p = 2\n    while p * p <= n:\n        if is_prime[p] == True:\n            for i in range(2 * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    for i in range(2, n + 1):\n        if is_prime[i] == True:\n            num_of_primes += 1\n    return num_of_primes\n(n, m) = list(map(int, input().split()))\nprint(get_the_number_of_primes_less_than_or_equal_to_n(n + m))", "(n, m) = list(map(int, input().split()))\nmaxa = n + m\nprime = [1 for i in range(maxa + 1)]\nprime[0] = 0\nprime[1] = 0\nfor i in range(2, maxa + 1):\n    if prime[i] == 1:\n        for j in range(i * i, maxa + 1, i):\n            prime[j] = 0\nans = 0\nfor i in range(2, maxa + 1):\n    if prime[i] == 1:\n        ans += 1\nif ans <= 1:\n    print(0)\nelse:\n    print(ans)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    count = 0\n    for p in range(2, n + 1):\n        if prime[p]:\n            count = count + 1\n    print(count)\n(n, m) = map(int, input().split())\nSieveOfEratosthenes(n + m)", "import sys\nfrom math import sqrt\nsys.setrecursionlimit(10 ** 5 + 1)\ninf = int(10 ** 20)\nmax_val = inf\nmin_val = -inf\nRW = lambda : sys.stdin.readline().strip()\nRI = lambda : int(RW())\nRMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRWI = lambda : [x for x in sys.stdin.readline().strip().split()]\n\ndef seive(limit):\n    status = [True for _ in range(limit + 1)]\n    primes = []\n    for i in range(2, limit + 1):\n        if status[i]:\n            primes.append(i)\n            for j in range(i * i, limit + 1, i):\n                status[j] = False\n    return primes\n(a, b) = RMI()\nprint(len(seive(a + b)))", "def prime(n):\n    p = [True for i in range(n + 1)]\n    d = int(n ** 0.5) + 1\n    for i in range(2, d + 1):\n        if p[i] == True:\n            for j in range(i * i, n + 1, i):\n                p[j] = False\n    prime = []\n    for i in range(2, len(p)):\n        if p[i] == True:\n            prime.append(i)\n    return len(prime)\ns = input('').split(' ')\nn = int(s[0])\nm = int(s[1])\nprint(prime(n + m))", "from math import sqrt\n\ndef prime(c):\n    p = [True for i in range(c + 1)]\n    d = int(sqrt(c))\n    for i in range(2, d + 1):\n        if p[i] == True:\n            for j in range(i * i, c + 1, i):\n                p[j] = False\n    yo = []\n    for k in range(2, c + 1):\n        if p[k]:\n            yo.append(k)\n    return yo\n(a, b) = map(int, input().split())\nc = a + b\nprint(len(prime(c)))", "def primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    prime[0] = False\n    prime[1] = False\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return sum(prime)\n(n, m) = [int(x) for x in input().split(' ')]\na = n + m\nprint(primes(a))", "def prime(n):\n    if n <= 1:\n        return 0\n    if n <= 3:\n        return 1\n    if n % 2 == 0 or n % 3 == 0:\n        return 0\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return 0\n        i = i + 6\n    return 1\n(n, m) = map(int, input().split())\nans = []\nans.append(2)\nfor i in range(3, n + m + 1, 2):\n    if prime(i) == 1:\n        ans.append(i)\nprint(len(set(ans)))", "def seive(n):\n    nonprimes = (n + 1) * [False]\n    count = 0\n    nonprimes[0] = nonprimes[1] = True\n    for i in range(2, n + 1):\n        if not nonprimes[i]:\n            count += 1\n            for j in range(2 * i, n + 1, i):\n                nonprimes[j] = True\n    print(count)\n(r, c) = map(int, input().split())\nk = r + c\nseive(k)", "prime = [True for x in range(2000001)]\nfor i in range(2, 2001):\n    if prime[i]:\n        for j in range(i * i, 2000001, i):\n            prime[j] = False\n(n, m) = map(int, input().split())\ncount = 0\nfor i in range(2, n + m + 1):\n    if prime[i]:\n        count += 1\nprint(count)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    c = 0\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n    print(c)\n(r, m) = map(int, input().split())\nn = m + r + 1\nSieveOfEratosthenes(n)", "def primes235(limit):\n    yield 2\n    yield 3\n    yield 5\n    if limit < 7:\n        return\n    modPrms = [7, 11, 13, 17, 19, 23, 29, 31]\n    gaps = [4, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 4, 6, 2, 6]\n    ndxs = [0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7]\n    lmtbf = (limit + 23) // 30 * 8 - 1\n    lmtsqrt = int(limit ** 0.5) - 7\n    lmtsqrt = lmtsqrt // 30 * 8 + ndxs[lmtsqrt % 30]\n    buf = [True] * (lmtbf + 1)\n    for i in range(lmtsqrt + 1):\n        if buf[i]:\n            ci = i & 7\n            p = 30 * (i >> 3) + modPrms[ci]\n            s = p * p - 7\n            p8 = p << 3\n            for j in range(8):\n                c = s // 30 * 8 + ndxs[s % 30]\n                buf[c::p8] = [False] * ((lmtbf - c) // p8 + 1)\n                s += p * gaps[ci]\n                ci += 1\n    for i in range(lmtbf - 6 + ndxs[(limit - 7) % 30]):\n        if buf[i]:\n            yield (30 * (i >> 3) + modPrms[i & 7])\nfrom itertools import takewhile\n(n, m) = map(int, input().split())\nprint(len(list(takewhile(lambda x: x <= m + n, primes235(m + n)))))", "(n, m) = map(int, input().split())\npi = []\n\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n):\n        if prime[p]:\n            pi.append(p)\n    print(len(pi))\nSieveOfEratosthenes(n + m + 1)", "def primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    c = 0\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n    print(c)\n(a, b) = map(int, input().split())\nprimes(a + b + 1)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    c = 0\n    for p in range(2, n):\n        if prime[p]:\n            c += 1\n    print(c)\n(n, m) = map(int, input().split())\nSieveOfEratosthenes(n + m + 1)", "(num, m) = map(int, input().split())\ncount = 0\nl = [True for i in range(num + m + 1)]\np = 2\nwhile p * p <= num + m:\n    if l[p]:\n        for i in range(p * p, num + m + 1, p):\n            l[i] = False\n    p += 1\nfor p in range(2, num + m + 1):\n    if l[p]:\n        count += 1\nprint(count)", "(a, b) = map(int, input().split())\nn = a + b + 1\nisprime = [True] * n\nprime = []\nSPF = [None] * n\n\ndef kk(N):\n    isprime[0] = isprime[1] = False\n    for i in range(2, N):\n        if isprime[i] == True:\n            prime.append(i)\n            SPF[i] = i\n        j = 0\n        while j < len(prime) and i * prime[j] < N and (prime[j] <= SPF[i]):\n            isprime[i * prime[j]] = False\n            SPF[i * prime[j]] = prime[j]\n            j += 1\nk = 0\nkk(n)\ni = 0\nwhile i < len(prime) and prime[i] <= n:\n    k += 1\n    i += 1\nprint(k)", "def isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\n(n, m) = map(int, input().split())\nans = 0\nfor i in range(2, n + m + 1):\n    if isPrime(i):\n        ans += 1\nprint(ans)", "(a, b) = map(int, input().split())\nn = a + b + 1\nisprime = [True] * n\nprime = []\nSPF = [None] * n\n\ndef manipulated_seive(N):\n    isprime[0] = isprime[1] = False\n    for i in range(2, N):\n        if isprime[i] == True:\n            prime.append(i)\n            SPF[i] = i\n        j = 0\n        while j < len(prime) and i * prime[j] < N and (prime[j] <= SPF[i]):\n            isprime[i * prime[j]] = False\n            SPF[i * prime[j]] = prime[j]\n            j += 1\nk = 0\nmanipulated_seive(n)\ni = 0\nwhile i < len(prime) and prime[i] <= n:\n    k += 1\n    i += 1\nprint(k)", "def sieveOfErathanos(n):\n    primes = [1 for i in range(n + 1)]\n    primes[0] = primes[1] = 0\n    i = 2\n    while i * i <= n:\n        if primes[i] == 1:\n            for j in range(i * i, n + 1, i):\n                primes[j] = 0\n        i += 1\n    return sum(primes)\n(n, m) = list(map(int, input().split()))\nprint(sieveOfErathanos(m + n))", "def prime(n):\n    if n == 2:\n        return 1\n    elif n % 2 == 0:\n        return int(0)\n    else:\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return int(0)\n                break\n        else:\n            return int(1)\n(n, m) = map(int, input().split())\nt = n + m\na = 0\nfor j in range(2, t + 1):\n    a += int(prime(j))\nprint(a)", "(n1, m) = map(int, input().split())\nn = n1 + m\nprime = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p * p, n + 1, p):\n            prime[i] = False\n    p += 1\nc = 0\nfor i in range(2, m + n1 + 1):\n    if prime[i]:\n        c += 1\nprint(c)", "def SieveOfEratosthenes(n, prime):\n    p = 2\n    while p * p <= n:\n        if prime[p] == 1:\n            for i in range(p * p, n + 1, p):\n                prime[i] = 0\n        p += 1\nn = 2 * 10 ** 6 + 2\nprime = [1 for i in range(n + 1)]\nSieveOfEratosthenes(n, prime)\nprime[0] = 0\nprime[1] = 0\nfor i in range(1, n + 1):\n    prime[i] += prime[i - 1]\n(num, m) = map(int, input().split())\nprint(prime[num + m])", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    c = 0\n    for p in range(2, n + 1):\n        if prime[p]:\n            c = c + 1\n    print(c)\n(N, M) = map(int, input().split())\nSieveOfEratosthenes(N + M)", "def sieve(n):\n    arr = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n):\n        if prime[p]:\n            arr.append(p)\n    return arr\nk = set(sieve(3 * 10 ** 6))\nc = 0\n(n, m) = [int(x) for x in input().split()]\nfor i in range(2, n + m + 1):\n    if i in k:\n        c += 1\nprint(c)", "n = 2000004\nprime = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p * p, n + 1, p):\n            prime[i] = False\n    p += 1\na = [0] * 2000005\ns = 0\nfor i in range(2, n + 1):\n    if prime[i] == True:\n        s += 1\n    a[i] = s\n(x, y) = map(int, input().split())\nprint(a[x + y])", "(n, m) = map(int, input().split())\nn = n + m\nprime = [True for _ in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p]:\n        for i in range(p * p, n + 1, p):\n            try:\n                prime[i] = False\n            except:\n                pass\n    p += 1\ns = 0\nfor p in range(2, n + 1):\n    if prime[p]:\n        s = s + 1\nprint(s)", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    total = 0\n    for p in range(2, n + 1):\n        if prime[p]:\n            total = total + 1\n    return total\n(x, y) = input().split(' ')\nx = int(x)\ny = int(y)\nprint(SieveOfEratosthenes(x + y))", "from bisect import *\nl = []\n\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for i in range(2, n):\n        if prime[i]:\n            l.append(i)\nSieveOfEratosthenes(3 * 10 ** 6 + 123)\n(n, m) = map(int, input().split())\nind = bisect_right(l, n + m)\nprint(ind)", "def SieveOfEratosthenes(n):\n    c = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n(n, m) = map(int, input().split())\nk = 0\nl = list(SieveOfEratosthenes(n + m))\nfor i in range(2, n + m + 1):\n    if l[i] == True:\n        k += 1\nprint(k)", "def S(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    g = 0\n    for p in range(2, n):\n        if prime[p]:\n            g = g + 1\n    return g\n(a, b) = list(map(int, input().split()))\nn = a + b\nl = S(n + 1)\nprint(l)", "def SieveOfEratosthenes(n):\n    c = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n(n, m) = map(int, input().split())\nk = 0\nl = list(SieveOfEratosthenes(n + m))\nfor i in range(2, n + m + 1):\n    if l[i] == True:\n        k += 1\nprint(k)", "MAX = 2000009\nprefix = [0] * (MAX + 1)\n\ndef buildPrefix():\n    prime = [1] * (MAX + 1)\n    p = 2\n    while p * p <= MAX:\n        if prime[p] == 1:\n            i = p * 2\n            while i <= MAX:\n                prime[i] = 0\n                i += p\n        p += 1\n    for p in range(2, MAX + 1):\n        prefix[p] = prefix[p - 1]\n        if prime[p] == 1:\n            prefix[p] += 1\n\ndef query(L, R):\n    return prefix[R] - prefix[L - 1]\nll = lambda : list(map(int, input().split()))\n[n, m] = ll()\nbuildPrefix()\nprint(query(2, n + m))", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime = prime[2:n]\n    print(prime.count(True))\n(n, m) = [int(i) for i in input().split()]\nk = n + m + 1\nSieveOfEratosthenes(k)", "(n, m) = map(int, input().split())\na = [i for i in range(2, n + m + 1)]\nind = 0\nwhile ind < len(a):\n    if a[ind] == 0:\n        ind += 1\n        continue\n    for i in range(ind + a[ind], len(a), a[ind]):\n        a[i] = 0\n    ind += 1\ncount = 0\nfor x in a:\n    if x != 0:\n        count += 1\nprint(count)", "(n, m) = map(int, input().split())\n\ndef sieve(n):\n    count = 0\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            count += 1\n    return count\nprint(sieve(n + m))", "def sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = 0\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes += 1\n    return primes\n(n, m) = (int(s) for s in input().split())\nprimes = sieve(n + m)\nprint(primes)", "def isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\n\ndef Prime(n):\n    N = 0\n    for i in range(2, n + 1):\n        N += isPrime(i)\n    return N\n(n, m) = map(int, input().split())\nprint(Prime(n + m))", "import sys\nmod = 1000000007\nget_arr = lambda : list(map(int, input().split()))\nget_int = lambda : int(input())\nget_ints = lambda : map(int, input().split())\nget_str = lambda : input()\nget_strs = lambda : input().split()\nfrom math import log\n\ndef sieve_of_eratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    ans = []\n    for i in range(2, n + 1):\n        if prime[i]:\n            ans.append(i)\n    return ans\n(n, m) = get_ints()\nans = sieve_of_eratosthenes(n + m)\nprint(len(ans))"]