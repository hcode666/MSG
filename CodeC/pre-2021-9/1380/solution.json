["import math\nfrom collections import Counter, defaultdict\nimport sys\nimport heapq\n\ndef overlap(res):\n    res.sort()\n    res2 = [res[0]]\n    for i in res:\n        if i[0] <= res2[-1][1] and i[1] <= res2[-1][1]:\n            continue\n        elif i[0] <= res2[-1][1] and i[1] >= res2[-1][1]:\n            res2[-1][1] = i[1]\n        else:\n            res2.append(i)\n    min_res = 0\n    for i in res2:\n        min_res += i[1] - i[0]\n    return min_res\n\ndef solve():\n    arr.sort()\n    max_res = arr[-1]\n    heap = []\n    for i in range(n - 2, -1, -1):\n        heapq.heappush(heap, -arr[i])\n    for i in range(n - 1):\n        val = -heapq.heappop(heap)\n        if val > u:\n            max_res += u\n            heapq.heappush(heap, -(val - u))\n        else:\n            max_res += val\n    arr.sort(reverse=True)\n    pos = 0\n    res = []\n    for i in arr:\n        pos += l\n        res.append([pos, pos + i])\n    min_res = overlap(res)\n    return (min_res, max_res)\nfor _ in range(int(input())):\n    (n, l, u) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    print(*solve())", "import math\nfrom collections import Counter, defaultdict\nimport sys\nimport heapq\n\ndef overlap(res):\n    res.sort()\n    res2 = [res[0]]\n    for i in res:\n        if i[0] <= res2[-1][1] and i[1] <= res2[-1][1]:\n            continue\n        elif i[0] <= res2[-1][1] and i[1] >= res2[-1][1]:\n            res2[-1][1] = i[1]\n        else:\n            res2.append(i)\n    min_res = 0\n    for i in res2:\n        min_res += i[1] - i[0]\n    return min_res\n\ndef solve():\n    arr.sort()\n    max_res = arr[-1]\n    heap = []\n    for i in range(n - 2, -1, -1):\n        heapq.heappush(heap, -arr[i])\n    for i in range(n - 1):\n        val = -heapq.heappop(heap)\n        if val > u:\n            max_res += u\n            heapq.heappush(heap, -(val - u))\n        else:\n            max_res += val\n    arr.sort(reverse=True)\n    pos = 0\n    res = []\n    for i in arr:\n        pos += l\n        res.append([pos, pos + i])\n    min_res = overlap(res)\n    return (min_res, max_res)\nfor _ in range(int(input())):\n    (n, l, u) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    print(*solve())", "T = int(input())\nfor t in range(T):\n    (N, L, U) = map(int, input().split())\n    arr = sorted(list(map(int, input().split())))\n    mini = maxi = arr[-1]\n    pref = min(L, arr[-1])\n    (cnt, mod) = (0, [])\n    for i in range(N - 2, -1, -1):\n        mini = max(mini, pref + arr[i])\n        pref = min(pref + L, mini)\n        if arr[i] >= U:\n            cnt += (arr[i] - U) // U\n            mod.append(arr[i] % U)\n            maxi += U\n    mod.sort(reverse=True)\n    ln = len(mod)\n    right = min(cnt + ln, N - 1 - ln)\n    maxi += min(cnt, N - 1 - ln) * U\n    for i in range(cnt, right):\n        maxi += max(mod[i - cnt], arr[i])\n    for i in range(right, N - 1 - ln):\n        maxi += arr[i]\n    print(mini, maxi)", "import heapq\n\ndef min_power(n, l, xs):\n    total = 0\n    y = 0\n    s = 0\n    for i in range(len(xs)):\n        x = xs[i]\n        total += min(x, max(0, y + x - s))\n        s = max(s, y + x)\n        y += l\n    return total\n\ndef max_power(n, u, xs):\n    xs = list(map(lambda x: -x, xs))\n    total = heapq.heappop(xs)\n    for _ in range(n - 1):\n        x = xs[0]\n        if x < -u:\n            total += -u\n            x += u\n            heapq.heapreplace(xs, x)\n        else:\n            total += heapq.heappop(xs)\n    return -total\nt = int(input())\nfor _ in range(t):\n    (n, l, u) = map(int, input().split())\n    xs = list(map(int, input().split()))\n    xs.sort(reverse=True)\n    print(min_power(n, l, xs), max_power(n, u, xs))", "import sys\nimport bisect\nfrom bisect import bisect_left as lb\nfrom bisect import bisect_right as rb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\nmod1 = 998244353\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs2(root, par):\n    if par != -1:\n        dp[root] = dp[par] + 1\n    for i in range(1, 20):\n        if kthpar[root][i - 1] != -1:\n            kthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n    for child in gp[root]:\n        if child == par:\n            continue\n        kthpar[child][0] = root\n        dfs(child, root)\nans = 0\nb = []\nvis = []\ntot = 0\ntime = []\ntime1 = []\nadj = []\nmx = -1\neps = 1e-07\n\ndef dfs(a, b, p, c):\n    if a == b:\n        return c\n    for (i, j) in adj[a]:\n        if i == p:\n            continue\n        temp = dfs(i, b, a, c + j)\n        if dfs(i, b, a):\n            mx = max(i, mx)\n            return 1\nadj = []\nans = []\n\ndef dfs(root, par, v):\n    global adj, ans, abe\n    tot = v\n    for (child, val) in adj[root]:\n        if par == child:\n            continue\n        tot |= dfs(child, root, val)\n    ans[root] = tot\n    return tot\nabe = 0\n\ndef traverse(root, par):\n    global adj, ans, abe\n    for (child, val) in adj[root]:\n        if par == child:\n            continue\n        if ans[child] == 0:\n            abe += 1\n        else:\n            traverse(child, root)\n\ndef hnbhai(tc):\n    (n, l, u) = sd()\n    x = sd()\n    x.sort(reverse=True)\n    tot = 0\n    bacha = 0\n    pos = 0\n    for i in x:\n        tmp = i + pos\n        if bacha < pos:\n            bacha = pos\n        if tmp > bacha:\n            tot += tmp - bacha\n            bacha = tmp\n        pos += l\n    abe = 0\n    tot1 = x[0]\n    temp = []\n    for i in range(1, n):\n        abe += x[i] // u\n        temp.append(x[i] % u)\n    temp.sort(reverse=True)\n    are = min(n - 1, abe)\n    tot1 += are * u + sum(temp[:min(n - 1 - are, len(temp))])\n    print(tot, tot1)\nfor _ in range(sb()):\n    hnbhai(_ + 1)"]