["from collections import defaultdict\nfrom heapq import *\nimport itertools, math\n\ndef parse_integer_list():\n    return [int(x) for x in input().split()]\n\ndef handle_input(N, M, A, B):\n    B = ['0' * (M - 1) + B[i] + '0' * (M - 1) for i in range(N)]\n    zeros = ['0' * (3 * M - 2)]\n    B = zeros * (N - 1) + B + zeros * (N - 1)\n    mincnt = N * M\n    for i in range(2 * N - 1):\n        for j in range(2 * M - 1):\n            cnt = 0\n            for k in range(N):\n                cnt += bin(int(A[k], 2) ^ int(B[i + k][j:j + M], 2))[2:].count('1')\n            mincnt = min(mincnt, cnt)\n    return mincnt\n    return A\nT = int(input())\nfor i in range(T):\n    (N, M) = parse_integer_list()\n    A = []\n    B = []\n    for i in range(N):\n        A.append(input())\n    for i in range(N):\n        B.append(input())\n    print(handle_input(N, M, A, B))", "for _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    mask = (1 << M) - 1\n    arrA = [None] * N\n    pixA = [None] * N\n    for i in range(N):\n        inp = input().strip()\n        pixA[i] = inp.count('1')\n        arrA[i] = int(inp, 2)\n    pixels = sum(pixA)\n    arrB = [None] * N\n    for i in range(N):\n        inp = input().strip()\n        arrB[i] = int(inp, 2)\n    bst = 2 * N * M\n    for i in range(-N, N + 1):\n        for j in range(-M, M + 1):\n            res = pixels\n            for k in range(N):\n                if 0 <= k + i < N:\n                    res -= pixA[k + i]\n                    brow = arrB[k]\n                    if j < 0:\n                        brow <<= -j\n                        brow &= mask\n                    else:\n                        brow >>= j\n                    res += bin(brow ^ arrA[k + i]).count('1')\n            bst = min(bst, res)\n    print(bst)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    o = [list(map(int, input())) for r in range(n)]\n    c = [list(map(int, input())) for r in range(n)]\n    oe = {(i, j) for i in range(n) for j in range(m) if o[i][j]}\n    (x, y) = (n + 1, m + 1)\n    d = [[0] * (m + 2 * y) for i in range(x)] + [[0] * y + c[i] + [0] * y for i in range(n)] + [[0] * (m + 2 * y) for i in range(x)]\n    mini = float('inf')\n    for i in range(x + n):\n        for j in range(y + m):\n            g = [d[k][j:j + m] for k in range(i, i + n)]\n            try:\n                e = {(r, s) for r in range(n) for s in range(m) if g[r][s]}\n            except:\n                pass\n            mini = min(mini, len(e.union(oe).difference(e.intersection(oe))))\n    print(mini)"]