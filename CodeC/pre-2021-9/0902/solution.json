["t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 1\n    s = []\n    p = []\n    for j in range(n):\n        p.append([j + 1, a[j]])\n    if n == 2:\n        print(1)\n    else:\n        s.append(p[0])\n        s.append(p[1])\n        x = len(s)\n        for z in range(2, n):\n            while x > 1:\n                s1 = (s[x - 1][1] - s[x - 2][1]) / (s[x - 1][0] - s[x - 2][0])\n                s2 = (p[z][1] - s[x - 1][1]) / (p[z][0] - s[x - 1][0])\n                if s1 <= s2:\n                    s.pop()\n                    x -= 1\n                else:\n                    break\n            s.append(p[z])\n            x += 1\n            ans = max(ans, s[x - 1][0] - s[x - 2][0])\n        print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 1\n    s = []\n    p = []\n    for j in range(n):\n        p.append([j + 1, a[j]])\n    if n == 2:\n        print(1)\n    else:\n        s.append(p[0])\n        s.append(p[1])\n        x = len(s)\n        for z in range(2, n):\n            while x > 1:\n                s1 = (s[x - 1][1] - s[x - 2][1]) / (s[x - 1][0] - s[x - 2][0])\n                s2 = (p[z][1] - s[x - 1][1]) / (p[z][0] - s[x - 1][0])\n                if s1 <= s2:\n                    s.pop()\n                    x -= 1\n                else:\n                    break\n            s.append(p[z])\n            x += 1\n            ans = max(ans, s[x - 1][0] - s[x - 2][0])\n        print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 1\n    s = []\n    p = []\n    for j in range(n):\n        p.append([j + 1, a[j]])\n    if n == 2:\n        print(1)\n    else:\n        s.append(p[0])\n        s.append(p[1])\n        x = len(s)\n        for z in range(2, n):\n            while x > 1:\n                s1 = (s[x - 1][1] - s[x - 2][1]) / (s[x - 1][0] - s[x - 2][0])\n                s2 = (p[z][1] - s[x - 1][1]) / (p[z][0] - s[x - 1][0])\n                if s1 <= s2:\n                    s.pop()\n                    x -= 1\n                else:\n                    break\n            s.append(p[z])\n            x += 1\n            ans = max(ans, s[x - 1][0] - s[x - 2][0])\n        print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 1\n    s = []\n    p = []\n    for j in range(n):\n        p.append([j + 1, a[j]])\n    if n == 2:\n        print(1)\n    else:\n        s.append(p[0])\n        s.append(p[1])\n        x = len(s)\n        for z in range(2, n):\n            while x > 1:\n                s1 = (s[x - 1][1] - s[x - 2][1]) / (s[x - 1][0] - s[x - 2][0])\n                s2 = (p[z][1] - s[x - 1][1]) / (p[z][0] - s[x - 1][0])\n                if s1 <= s2:\n                    s.pop()\n                    x -= 1\n                else:\n                    break\n            s.append(p[z])\n            x += 1\n            ans = max(ans, s[x - 1][0] - s[x - 2][0])\n        print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 1\n    s = []\n    p = []\n    for j in range(n):\n        p.append([j + 1, a[j]])\n    if n == 2:\n        print(1)\n    else:\n        s.append(p[0])\n        s.append(p[1])\n        x = len(s)\n        for z in range(2, n):\n            while x > 1:\n                s1 = (s[x - 1][1] - s[x - 2][1]) / (s[x - 1][0] - s[x - 2][0])\n                s2 = (p[z][1] - s[x - 1][1]) / (p[z][0] - s[x - 1][0])\n                if s1 <= s2:\n                    s.pop()\n                    x -= 1\n                else:\n                    break\n            s.append(p[z])\n            x += 1\n            ans = max(ans, s[x - 1][0] - s[x - 2][0])\n        print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 1\n    s = []\n    p = []\n    for j in range(n):\n        p.append([j + 1, a[j]])\n    if n == 2:\n        print(1)\n    else:\n        s.append(p[0])\n        s.append(p[1])\n        x = len(s)\n        for z in range(2, n):\n            while x > 1:\n                s1 = (s[x - 1][1] - s[x - 2][1]) / (s[x - 1][0] - s[x - 2][0])\n                s2 = (p[z][1] - s[x - 1][1]) / (p[z][0] - s[x - 1][0])\n                if s1 <= s2:\n                    s.pop()\n                    x -= 1\n                else:\n                    break\n            s.append(p[z])\n            x += 1\n            ans = max(ans, s[x - 1][0] - s[x - 2][0])\n        print(ans)", "for _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    ans = 1\n    s = []\n    p = []\n    for i in range(N):\n        p.append([i + 1, A[i]])\n    if N == 2:\n        print(1)\n    else:\n        s.append(p[0])\n        s.append(p[1])\n        size = len(s)\n        for i in range(2, N):\n            while size > 1:\n                s1 = (s[size - 1][1] - s[size - 2][1]) / (s[size - 1][0] - s[size - 2][0])\n                s2 = (p[i][1] - s[size - 1][1]) / (p[i][0] - s[size - 1][0])\n                if s1 <= s2:\n                    s.pop()\n                    size -= 1\n                else:\n                    break\n            s.append(p[i])\n            size += 1\n            ans = max(ans, s[size - 1][0] - s[size - 2][0])\n        print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    st = []\n    ar = list(map(int, input().split()))\n    for i in range(n):\n        p.append([i + 1, ar[i]])\n    if n == 2:\n        print(1)\n    else:\n        st.append(p[0])\n        st.append(p[1])\n        ans = 1\n        sz = len(st)\n        for i in range(2, n):\n            while len(st) >= 2:\n                s1 = (st[sz - 1][1] - st[sz - 2][1]) / (st[sz - 1][0] - st[sz - 2][0])\n                s2 = (p[i][1] - st[sz - 1][1]) / (p[i][0] - st[sz - 1][0])\n                if s1 <= s2:\n                    st.pop()\n                    sz -= 1\n                else:\n                    break\n            st.append(p[i])\n            sz += 1\n            ans = max(ans, st[sz - 1][0] - st[sz - 2][0])\n        print(ans)", "import math\n\ndef func(n, a):\n    store = []\n    s = 0\n    store.append((1, a[0]))\n    store.append((2, a[1]))\n    s = 2\n    ans = store[1][0] - store[0][0]\n    for i in range(2, n):\n        while s >= 2 and (a[i] - store[s - 1][1]) / (i + 1 - store[s - 1][0]) >= (store[s - 1][1] - store[s - 2][1]) / (store[s - 1][0] - store[s - 2][0]):\n            store.pop(s - 1)\n            s -= 1\n        ans = max(ans, i + 1 - store[s - 1][0])\n        store.append((i + 1, a[i]))\n        s += 1\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(func(n, a))", "def canSee(a, b, c, array):\n    return (array[c] - array[b]) * (b - a) >= (array[b] - array[a]) * (c - b)\nfor _ in range(int(input())):\n    n = int(input())\n    array = list(map(int, input().split()))\n    (stack, answer) = ([0, 1], 0)\n    for i in range(2, n):\n        while len(stack) > 1 and canSee(stack[-2], stack[-1], i, array):\n            stack.pop()\n        stack.append(i)\n    while len(stack) > 1:\n        top = stack.pop()\n        answer = max(answer, top - stack[-1])\n    print(answer)", "import math\n\ndef direction(a, b, c):\n    return (b.x - a.x) * (c.y - b.y) - (b.y - a.y) * (c.x - b.x)\n\ndef posDeg(x):\n    if x < 0:\n        return 180 - abs(x)\n    return x\n\ndef inDeg(pt1, pt2):\n    if pt1.x == pt2.x and pt1.y == pt2.y:\n        return 0\n    num = pt2.y - pt1.y\n    den = pt2.x - pt1.x\n    if den != 0:\n        return posDeg(math.degrees(math.atan(num / den)))\n    else:\n        return 90\n\nclass Point:\n\n    def __init__(self, x, y, deg=0):\n        self.x = x\n        self.y = y\n        self.deg = deg\n\ndef convex_hull(pts):\n    btm = 0\n    for i in range(1, n):\n        if pts[i].y < pts[btm].y:\n            btm = i\n    for i in range(n):\n        pts[i].deg = inDeg(pts[btm], pts[i])\n    pts.sort(key=lambda x: x.deg)\n    s = []\n    s.append(pts[0])\n    s.append(pts[1])\n    direc = 0\n    k = 2\n    while k < n:\n        direc = direction(s[-2], s[-1], pts[k])\n        if direc > 0:\n            s.append(pts[k])\n            k += 1\n        elif direc == 0:\n            s.pop()\n            s.append(pts[k])\n            k += 1\n        else:\n            s.pop()\n    return s\nfor _ in range(int(input())):\n    n = int(input())\n    y = list(map(int, input().split()))\n    x = range(1, n + 1)\n    pts = []\n    for i in range(n):\n        pts.append(Point(x[i], y[i]))\n    ans = convex_hull(pts)\n    ans.sort(key=lambda z: z.x)\n    upper = []\n    for p in reversed(ans):\n        while len(upper) >= 2 and direction(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    upper.sort(key=lambda z: z.x)\n    mxdist = 0\n    for i in range(len(upper) - 1):\n        mxdist = max(mxdist, abs(upper[i + 1].x - upper[i].x))\n    print(mxdist)", "def getMaxSlope(i, j, N, H):\n    s = -float('inf')\n    si = j\n    for x in range(j, N):\n        slope = (H[x] - H[i]) / (x - i)\n        if slope >= s:\n            s = slope\n            si = x\n    return si\nT = int(input())\nans = []\nfor _ in range(T):\n    N = int(input())\n    H = [int(i) for i in input().split()]\n    i = 0\n    j = 1\n    maxdist = 1\n    while i < N:\n        j = getMaxSlope(i, j, N, H)\n        if j - i > maxdist:\n            maxdist = j - i\n        i = j\n        j += 1\n    ans.append(maxdist)\nfor i in ans:\n    print(i)", "def canSee(a, b, c, array):\n    return (array[c] - array[b]) * (b - a) >= (array[b] - array[a]) * (c - b)\nfor _ in range(int(input())):\n    n = int(input())\n    array = list(map(int, input().split()))\n    stack = [0, 1]\n    for i in range(2, n):\n        while len(stack) > 1 and canSee(stack[-2], stack[-1], i, array):\n            stack.pop()\n        stack.append(i)\n    answer = 0\n    while len(stack) > 1:\n        top = stack.pop()\n        answer = max(answer, top - stack[-1])\n    print(answer)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    p = []\n    stk = []\n    for i in range(len(arr)):\n        p.append([i + 1, arr[i]])\n    if n <= 2:\n        print(1)\n    else:\n        stk.append(p[0])\n        stk.append(p[1])\n        length = len(stk)\n        ans = 1\n        for i in range(2, n):\n            while length >= 2:\n                slope1 = (stk[length - 1][1] - stk[length - 2][1]) / (stk[length - 1][0] - stk[length - 2][0])\n                slope2 = (p[i][1] - stk[length - 1][1]) / (p[i][0] - stk[length - 1][0])\n                if slope2 < slope1:\n                    break\n                else:\n                    stk.pop()\n                    length -= 1\n            stk.append(p[i])\n            length += 1\n            ans = max(ans, stk[length - 1][0] - stk[length - 2][0])\n        print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = []\n    for i in range(n):\n        t = [i, a[i]]\n        b.append(t)\n    c = []\n    c.append(b[0])\n    c.append(b[1])\n    l = 2\n    p = 1\n    for i in range(2, n):\n        while len(c) >= 2:\n            slope1 = (c[l - 1][1] - c[l - 2][1]) / (c[l - 1][0] - c[l - 2][0])\n            slope2 = (b[i][1] - c[l - 1][1]) / (b[i][0] - c[l - 1][0])\n            if slope1 <= slope2:\n                c.pop()\n                l = l - 1\n            else:\n                break\n        c.append(b[i])\n        l = l + 1\n        p = max(p, c[l - 1][0] - c[l - 2][0])\n    print(p)", "test = int(input())\nfor e in range(test):\n    n = int(input())\n    l = list(map(int, input().split()))\n    p = []\n    stk = []\n    for i in range(n):\n        p.append([i + 1, l[i]])\n    if n != 2:\n        stk.append(p[0])\n        stk.append(p[1])\n        ans = 1\n        ln = len(stk)\n        for i in range(2, n):\n            while len(stk) >= 2:\n                s1 = (stk[ln - 1][1] - stk[ln - 2][1]) / (stk[ln - 1][0] - stk[ln - 2][0])\n                s2 = (p[i][1] - stk[ln - 1][1]) / (p[i][0] - stk[ln - 1][0])\n                if s1 > s2:\n                    break\n                else:\n                    stk.pop()\n                    ln -= 1\n            stk.append(p[i])\n            ln += 1\n            ans = max(ans, stk[ln - 1][0] - stk[ln - 2][0])\n        print(ans)\n    else:\n        print(1)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = []\n    for i in range(n):\n        t = [i, a[i]]\n        b.append(t)\n    c = []\n    c.append(b[0])\n    c.append(b[1])\n    l = 2\n    p = 1\n    for i in range(2, n):\n        while len(c) >= 2:\n            slope1 = (c[l - 1][1] - c[l - 2][1]) / (c[l - 1][0] - c[l - 2][0])\n            slope2 = (b[i][1] - c[l - 1][1]) / (b[i][0] - c[l - 1][0])\n            if slope1 <= slope2:\n                c.pop()\n                l = l - 1\n            else:\n                break\n        c.append(b[i])\n        l = l + 1\n        p = max(p, c[l - 1][0] - c[l - 2][0])\n    print(p)", "for _ in range(int(input())):\n    n = int(input())\n    array = list(map(int, input().split()))\n    if n <= 2:\n        print(1)\n    else:\n        answere = 1\n        a = []\n        for i in range(n):\n            a.append([i + 1, array[i]])\n        b = []\n        b.append(a[0])\n        b.append(a[1])\n        l = len(b)\n        for i in range(2, n):\n            while l >= 2:\n                s1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                s2 = (b[l - 1][1] - a[i][1]) / (b[l - 1][0] - a[i][0])\n                if s2 >= s1:\n                    b.pop()\n                    l -= 1\n                else:\n                    break\n            b.append(a[i])\n            l += 1\n            answere = max(answere, b[l - 1][0] - b[l - 2][0])\n        print(answere)", "import math\n\ndef left_right(pa, pb, pc):\n    xa = pa[0]\n    ya = pa[1]\n    xb = pb[0]\n    yb = pb[1]\n    xc = pc[0]\n    yc = pc[1]\n    return (xb - xa) * (yc - ya) - (xc - xa) * (yb - ya)\n\ndef graham_hull(h_vec):\n    points = [[i, h_vec[i]] for i in range(len(h_vec))]\n    stack = [points[0], points[-1]]\n    for i in range(len(points) - 2, -1, -1):\n        while len(stack) > 2 and left_right(stack[-2], stack[-1], points[i]) <= 0:\n            stack.pop()\n        stack.append(points[i])\n    if stack[-1] == stack[0]:\n        stack = stack[0:-1]\n    stack.sort(key=lambda x: x[0])\n    stack = [s[0] for s in stack]\n    return stack\n\ndef jarvis_march(h_vec):\n    n = len(h_vec)\n    hull = [0]\n    index = 0\n    while index < n - 1:\n        x1 = index\n        y1 = h_vec[index]\n        max_alpha = -math.inf\n        max_index = None\n        for j in range(index + 1, n):\n            x2 = j\n            y2 = h_vec[j]\n            alpha = None\n            if y1 == y2:\n                alpha = 90\n            elif y1 > y2:\n                alpha = 90 - 180 * math.atan((y1 - y2) / (x2 - x1)) / math.pi\n            elif y1 < y2:\n                alpha = 90 + 180 * math.atan((y2 - y1) / (x2 - x1)) / math.pi\n            if max_alpha <= alpha:\n                max_alpha = alpha\n                max_index = j\n        index = max_index\n        hull.append(max_index)\n    return hull\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    h_vec = input().split(' ')\n    h_vec = [int(h) for h in h_vec]\n    hull = graham_hull(h_vec)\n    diff = 0\n    for i in range(1, len(hull)):\n        delta = hull[i] - hull[i - 1]\n        if diff < delta:\n            diff = delta\n    print(diff)", "import math\n\ndef left_right(pa, pb, pc):\n    xa = pa[0]\n    ya = pa[1]\n    xb = pb[0]\n    yb = pb[1]\n    xc = pc[0]\n    yc = pc[1]\n    return (xb - xa) * (yc - ya) - (xc - xa) * (yb - ya)\n\ndef graham_hull(h_vec):\n    points = [[i, h_vec[i]] for i in range(len(h_vec))]\n    stack = [points[0], points[-1]]\n    for i in range(len(points) - 2, -1, -1):\n        while len(stack) > 2 and left_right(stack[-2], stack[-1], points[i]) <= 0:\n            stack.pop()\n        stack.append(points[i])\n    if stack[-1] == stack[0]:\n        stack = stack[0:-1]\n    stack.sort(key=lambda x: x[0])\n    stack = [s[0] for s in stack]\n    return stack\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    h_vec = input().split(' ')\n    h_vec = [int(h) for h in h_vec]\n    hull = graham_hull(h_vec)\n    diff = 0\n    for i in range(1, len(hull)):\n        delta = hull[i] - hull[i - 1]\n        if diff < delta:\n            diff = delta\n    print(diff)", "def getOrientation(p0, p1, p2):\n    val = float((p1[0] - p0[0]) * (p2[1] - p0[1])) - float((p1[1] - p0[1]) * (p2[0] - p0[0]))\n    return val\nfor _ in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    points = []\n    for i in range(n):\n        points.append([i, h[i]])\n    ans = 1\n    stack = [points[0], points[1]]\n    stack_size = 2\n    for i in range(2, n):\n        while stack_size > 1:\n            d = getOrientation(stack[-2], stack[-1], points[i])\n            if d >= 0:\n                stack.pop()\n                stack_size -= 1\n            else:\n                break\n        stack_size += 1\n        ans = max(ans, points[i][0] - stack[-1][0])\n        stack.append(points[i])\n    print(ans)", "def slope(point1, point2):\n    return (point2[1] - point1[1]) / (point2[0] - point1[0])\n    pass\nfor _ in range(int(input())):\n    N = int(input())\n    p = list(map(int, input().split()))\n    points = [(i + 1, p[i]) for i in range(N)]\n    reach = [points[0], points[1]]\n    ans = 1\n    for i in range(2, N):\n        while len(reach) >= 2:\n            if slope(reach[-1], points[i]) >= slope(reach[len(reach) - 2], reach[-1]):\n                reach.pop()\n            else:\n                break\n        ans = max(ans, points[i][0] - reach[-1][0])\n        reach.append(points[i])\n    print(ans)", "from collections import deque\n\ndef orientation(p1, p2, p3):\n    v = (p2[1] - p1[1]) * (p3[0] - p2[0]) - (p3[1] - p2[1]) * (p2[0] - p1[0])\n    if v == 0:\n        return 0\n    if v > 0:\n        return 1\n    else:\n        return 2\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    h = [int(i) for i in input().split()]\n    s = deque()\n    s.append((1, h[0]))\n    s.append((2, h[1]))\n    for i in range(2, n):\n        while len(s) != 1:\n            p2 = s.pop()\n            p1 = s[-1]\n            if orientation(p1, p2, (i + 1, h[i])) == 1:\n                s.append(p2)\n                break\n        s.append((i + 1, h[i]))\n    ans = 0\n    i = 1\n    while i < len(s):\n        ans = max(ans, s[i][0] - s[i - 1][0])\n        i += 1\n    print(ans)", "from typing import List\n\ndef solve(N: int, sections: List[int]) -> int:\n    max_dist = 0\n    i = 0\n    while i < N:\n        slope = -float('inf')\n        k = i + 1\n        for j in range(k, N):\n            new_slope = (sections[j] - sections[i]) / (j - i)\n            if new_slope >= slope:\n                max_dist = max(max_dist, j - i)\n                k = j\n                slope = new_slope\n        i = k\n    return max_dist\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    sections = list(map(int, input().split()))\n    print(solve(n, sections))", "def crossproduct(l, c):\n    a = l[-2]\n    b = l[-1]\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\nt = int(input())\nfor case in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    l = [(i, a[i]) for i in range(n)]\n    p = [l[0], l[1]]\n    m = 1\n    for i in range(2, n):\n        while len(p) > 1 and crossproduct(p, l[i]) >= 0:\n            p = p[:-1]\n        m = max(m, l[i][0] - p[-1][0])\n        p.append(l[i])\n    print(m)", "import sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\ninp = lambda : list(map(int, sys.stdin.readline().rstrip('\\r\\n').split()))\nmod = 10 ** 9 + 7\nMod = 998244353\nINF = float('inf')\ntc = 1\ntc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    a = inp()\n\n    def solve(a, n):\n        stack = [[0, a[0]]]\n        ans = 0\n\n        def slope(b, c, d):\n            slope1 = (d[1] - c[1]) / (d[0] - c[0])\n            slope2 = (d[1] - b[1]) / (d[0] - b[0])\n            return slope2 >= slope1\n        for i in range(n):\n            while len(stack) > 1 and slope(stack[-1], stack[-2], [i, a[i]]):\n                stack.pop()\n            res = i - stack[-1][0]\n            ans = max(ans, res)\n            stack.append([i, a[i]])\n        return ans\n    ans1 = solve(a, n)\n    ans2 = solve(a[::-1], n)\n    print(max(ans1, -1))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ls = list(map(int, input().split()))\n    convex_hull = [0]\n    for i in range(1, len(ls)):\n        if convex_hull[-1] == 0:\n            convex_hull.append(i)\n        else:\n            m_prev = (ls[convex_hull[-2]] - ls[convex_hull[-1]]) / (convex_hull[-2] - convex_hull[-1])\n            m_new = (ls[convex_hull[-1]] - ls[i]) / (convex_hull[-1] - i)\n            while m_new >= m_prev:\n                convex_hull.pop()\n                if convex_hull[-1] == 0:\n                    break\n                m_prev = (ls[convex_hull[-2]] - ls[convex_hull[-1]]) / (convex_hull[-2] - convex_hull[-1])\n                m_new = (ls[convex_hull[-1]] - ls[i]) / (convex_hull[-1] - i)\n            convex_hull.append(i)\n    Max = 0\n    for i in range(1, len(convex_hull)):\n        Max = max(Max, convex_hull[i] - convex_hull[i - 1])\n    print(Max)", "def fun(arr, n):\n    s = []\n    s.append((0, arr[0]))\n    s.append((1, arr[1]))\n\n    def cross_product(i):\n        (x, y) = s[-2]\n        (x1, y1) = s[-1]\n        (x2, y2) = (i, arr[i])\n        return (x1 - x) * (y2 - y) - (x2 - x) * (y1 - y)\n    ans = 1\n    for i in range(2, n):\n        while len(s) > 1 and cross_product(i) >= 0:\n            s.pop()\n        ans = max(ans, i - s[-1][0])\n        s.append((i, arr[i]))\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    fun(arr, n)", "import sys\nimport math\nimport bisect\nimport collections\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inplist():\n    return list(map(int, input().split()))\n\ndef inpstrlist():\n    s = input()\n    return list(s[:len(s)])\n\ndef invr():\n    return map(int, input().split())\n\ndef printlist(var):\n    sys.stdout.write(' '.join(map(str, var)) + '\\n')\n\nclass Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef orientation(p, q, r):\n    val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\nfor _ in range(int(input())):\n    n = inp()\n    arr = inplist()\n    convexHull = [Point(0, arr[0]), Point(1, arr[1])]\n    ans = 1\n    for i in range(2, n):\n        temp = Point(i, arr[i])\n        while len(convexHull) > 1 and orientation(convexHull[-2], convexHull[-1], temp) != 1:\n            convexHull.pop()\n        ans = max(ans, i - convexHull[-1].x)\n        convexHull.append(temp)\n    print(ans)", "slope = lambda t1, t2: (t2[1] - t1[1]) / (t2[0] - t1[0])\ncheck = lambda t1, t2, t3: slope(t2, t3) < slope(t1, t2)\n\ndef grahamScan(arr, n):\n    tarr = list(zip(range(n), arr))\n    hull = tarr[:2]\n    l = 2\n    tarr = tarr[2:]\n    for i in tarr:\n        while not check(hull[-2], hull[-1], i):\n            hull.pop()\n            l -= 1\n            if l == 1:\n                break\n        hull.append(i)\n        l += 1\n    (hull, _) = zip(*hull)\n    dists = [hull[i] - hull[i - 1] for i in range(1, len(hull))]\n    return max(dists)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(grahamScan(arr, n))", "for _ in range(int(input())):\n    N = int(input())\n    arr = list(map(int, input().split()))\n    stack1 = []\n    stack2 = []\n    if N == 2:\n        print(1)\n        continue\n    for i in range(N):\n        stack1.append([i + 1, arr[i]])\n    stack2.extend([stack1[0], stack1[1]])\n    ans = 1\n    for i in range(2, N, 1):\n        while len(stack2) >= 2:\n            try:\n                m1 = (stack2[-1][1] - stack2[-2][1]) / (stack2[-1][0] - stack2[-2][0])\n            except ZeroDivisionError:\n                m1 = 0\n            try:\n                m2 = (stack1[i][1] - stack2[-1][1]) / (stack1[i][0] - stack2[-1][0])\n            except:\n                m2 = 0\n            if m1 <= m2:\n                stack2.pop()\n            else:\n                break\n        stack2.append(stack1[i])\n        ans = max(ans, stack2[-1][0] - stack2[-2][0])\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    n_s = list(map(int, input().split()[:n]))\n    n1 = []\n    if n <= 2:\n        print('1')\n    else:\n        for (i, c) in enumerate(n_s):\n            n1.append([i, c])\n        a = [n1[0], n1[1]]\n        ans = 1\n        for i in range(2, n, 1):\n            while len(a) >= 2:\n                slope1 = (a[-1][1] - a[-2][1]) / (a[-1][0] - a[-2][0])\n                slope2 = (n1[i][1] - a[-1][1]) / (n1[i][0] - a[-1][0])\n                if slope2 >= slope1:\n                    a = a[:-1]\n                else:\n                    break\n            a.append(n1[i])\n            ans = max(ans, a[-1][0] - a[-2][0])\n        print(ans)", "t = int(input())\nfor e in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    p = []\n    stk = []\n    for i in range(n):\n        p.append([i + 1, l[i]])\n    if n != 2:\n        stk.append(p[0])\n        stk.append(p[1])\n        ans = 1\n        ln = len(stk)\n        for i in range(2, n):\n            while len(stk) >= 2:\n                s1 = (stk[ln - 1][1] - stk[ln - 2][1]) / (stk[ln - 1][0] - stk[ln - 2][0])\n                s2 = (p[i][1] - stk[ln - 1][1]) / (p[i][0] - stk[ln - 1][0])\n                if s1 > s2:\n                    break\n                else:\n                    stk.pop()\n                    ln -= 1\n            stk.append(p[i])\n            ln += 1\n            ans = max(ans, stk[ln - 1][0] - stk[ln - 2][0])\n        print(ans)\n    else:\n        print(1)", "for t in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    if n <= 2:\n        print(1)\n    else:\n        ans = 1\n        a = []\n        for i in range(n):\n            k = [i, h[i]]\n            a.append(k)\n        b = []\n        b.append(a[0])\n        b.append(a[1])\n        l = len(b)\n        for i in range(2, n, 1):\n            while len(b) >= 2:\n                s1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                s2 = (a[i][1] - b[l - 1][1]) / (a[i][0] - b[l - 1][0])\n                if s1 <= s2:\n                    b.pop()\n                    l = l - 1\n                else:\n                    break\n            b.append(a[i])\n            l = l + 1\n            ans = max(ans, b[l - 1][0] - b[l - 2][0])\n        print(ans)", "t = int(input())\nfor e in range(t):\n    n = int(input())\n    l = input().split()\n    p = []\n    stk = []\n    for i in range(n):\n        l[i] = int(l[i])\n        p.append([i + 1, l[i]])\n    if n == 2:\n        print('1')\n        continue\n    stk.append(p[0])\n    stk.append(p[1])\n    res = 1\n    ln = len(stk)\n    for i in range(2, n):\n        while len(stk) >= 2:\n            s1 = (stk[ln - 1][1] - stk[ln - 2][1]) / (stk[ln - 1][0] - stk[ln - 2][0])\n            s2 = (p[i][1] - stk[ln - 1][1]) / (p[i][0] - stk[ln - 1][0])\n            if s1 <= s2:\n                stk.pop()\n                ln -= 1\n            else:\n                break\n        stk.append(p[i])\n        ln += 1\n        res = max(res, stk[ln - 1][0] - stk[ln - 2][0])\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ind = [i for i in range(n)]\n    if n >= 4:\n        (max1, max2) = (1, n - 2)\n        for i in range(1, n - 2):\n            if a[i] > a[max1]:\n                max1 = i\n        for i in range(n - 2, max1, -1):\n            if a[i] > a[max2]:\n                max2 = i\n        a = a[:max1 + 1] + a[max2:]\n        ind = ind[:max1 + 1] + ind[max2:]\n        n = len(a)\n    i = 1\n    (a_t, ind_t) = ([a[0]], [ind[0]])\n    while i < len(a) - 1:\n        (x, y, x1, y1, x2, y2) = (ind[i], a[i], ind_t[-1], a_t[-1], ind[i + 1], a[i + 1])\n        if not (y <= y1 and y <= y2 or y <= (y2 - y1) * (x - x1) / (x2 - x1) + y1):\n            if len(a_t) >= 2:\n                (x, y, x1, y1, x2, y2) = (ind_t[-1], a_t[-1], ind_t[-2], a_t[-2], ind[i], a[i])\n            if len(a_t) >= 2 and (y <= y1 and y <= y2 or y <= (y2 - y1) * (x - x1) / (x2 - x1) + y1):\n                a_t.pop()\n                ind_t.pop()\n            else:\n                a_t.append(a[i])\n                ind_t.append(ind[i])\n                i += 1\n        else:\n            i += 1\n    while True:\n        if len(a_t) >= 2:\n            (x, y, x1, y1, x2, y2) = (ind_t[-1], a_t[-1], ind_t[-2], a_t[-2], ind[-1], a[-1])\n            if y <= y1 and y <= y2 or y <= (y2 - y1) * (x - x1) / (x2 - x1) + y1:\n                a_t.pop()\n                ind_t.pop()\n            else:\n                break\n        else:\n            break\n    ind_t.append(ind[-1])\n    m = ind_t[1] - ind_t[0]\n    for i in range(1, len(ind_t)):\n        x = ind_t[i] - ind_t[i - 1]\n        if x > m:\n            m = x\n    print(m)", "for _ in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    hlists = []\n    slopelist = []\n    ans = 1\n    for i in range(n):\n        hi = [i + 1, h[i]]\n        hlists.append(hi)\n    if n == 2:\n        print('1')\n        continue\n    slopelist.append(hlists[0])\n    slopelist.append(hlists[1])\n    lens = len(slopelist)\n    for i in range(2, n):\n        while lens >= 2:\n            s1 = (slopelist[lens - 1][1] - slopelist[lens - 2][1]) / (slopelist[lens - 1][0] - slopelist[lens - 2][0])\n            s2 = (hlists[i][1] - slopelist[lens - 1][1]) / (hlists[i][0] - slopelist[lens - 1][0])\n            if s1 <= s2:\n                slopelist.pop()\n                lens = lens - 1\n            else:\n                break\n        slopelist.append(hlists[i])\n        lens = lens + 1\n        ans = max(ans, slopelist[lens - 1][0] - slopelist[lens - 2][0])\n    print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    p = []\n    ST = []\n    q = []\n    q = list(map(int, input().split()))\n    for j in range(n):\n        temp = (j + 1, q[j])\n        p.append(temp)\n    if n == 2:\n        print('1')\n        continue\n    ST.append(p[0])\n    ST.append(p[1])\n    ans = 1\n    sl = len(ST)\n    for j in range(2, n):\n        while len(ST) >= 2:\n            s1 = (ST[sl - 1][1] - ST[sl - 2][1]) / (ST[sl - 1][0] - ST[sl - 2][0])\n            s2 = (p[j][1] - ST[sl - 1][1]) / (p[j][0] - ST[sl - 1][0])\n            if s1 <= s2:\n                ST.pop()\n                sl -= 1\n            else:\n                break\n        ST.append(p[j])\n        sl += 1\n        ans = max(ans, ST[sl - 1][0] - ST[sl - 2][0])\n    print(ans)\n    q.clear()", "var1 = int(input())\nfor k in range(var1):\n    var2 = int(input())\n    l1 = list(map(int, input().split()))\n    if var2 <= 2:\n        print(1)\n        continue\n    out = 1\n    l2 = []\n    for j in range(var2):\n        l2.append([j, l1[j]])\n    l3 = [l2[0], l2[1]]\n    for j in range(2, var2):\n        while len(l3) >= 2:\n            u = l3[-1][1] - l3[-2][1]\n            d = l3[-1][0] - l3[-2][0]\n            s1 = u / d\n            u = l2[j][1] - l3[-1][1]\n            d = l2[j][0] - l3[-1][0]\n            s2 = u / d\n            if s2 >= s1:\n                l3 = l3[:-1]\n            else:\n                break\n        l3.append(l2[j])\n        out = max(out, l3[-1][0] - l3[-2][0])\n    print(out)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    h = list(map(int, input().split()))\n    if n <= 2:\n        print(1)\n    else:\n        ans = 1\n        a = []\n        for i in range(n):\n            a.append([i, h[i]])\n        b = [a[0], a[1]]\n        l = len(b)\n        for i in range(2, n):\n            while len(b) >= 2:\n                s1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                s2 = (a[i][1] - b[l - 1][1]) / (a[i][0] - b[l - 1][0])\n                if s2 >= s1:\n                    b.pop()\n                    l -= 1\n                else:\n                    break\n            b.append(a[i])\n            l += 1\n            ans = max(ans, b[l - 1][0] - b[l - 2][0])\n        print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    given = list(map(int, input().rstrip().split()))\n    if n <= 2:\n        print(1)\n    else:\n        A = []\n        answer = 1\n        for j in range(n):\n            D = [j, given[j]]\n            A.append(D)\n        B = []\n        B.append(A[0])\n        B.append(A[1])\n        lena = len(B)\n        for i in range(2, n):\n            while lena >= 2:\n                S1 = (B[lena - 1][1] - B[lena - 2][1]) / (B[lena - 1][0] - B[lena - 2][0])\n                S2 = (A[i][1] - B[lena - 1][1]) / (A[i][0] - B[lena - 1][0])\n                if S1 <= S2:\n                    B.pop()\n                    lena -= 1\n                else:\n                    break\n            B.append(A[i])\n            lena += 1\n            answer = max(answer, B[lena - 1][0] - B[lena - 2][0])\n        print(answer)", "try:\n    for i in range(int(input())):\n        n = int(input())\n        a = [int(i) for i in input().split()]\n        if n <= 2:\n            print(1)\n        else:\n            ans = -1\n            newa = []\n            for i in range(n):\n                newa.append([i, a[i]])\n            b = []\n            b.append(newa[0])\n            b.append(newa[1])\n            l = len(b)\n            for i in range(2, n):\n                while len(b) >= 2:\n                    slope1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                    slope2 = (newa[i][1] - b[l - 1][1]) / (newa[i][0] - b[l - 1][0])\n                    if slope2 >= slope1:\n                        b.pop()\n                        l -= 1\n                    else:\n                        break\n                b.append(newa[i])\n                l += 1\n                ans = max(ans, b[l - 1][0] - b[l - 2][0])\n            print(ans)\nexcept:\n    pass", "import sys\n\ndef mi(s):\n    return map(int, s.strip().split())\n\ndef lmi(s):\n    return list(mi(s))\n\ndef tmi(s):\n    return tuple(mi(s))\n\ndef mf(f, s):\n    return map(f, s)\n\ndef lmf(f, s):\n    return list(mf(f, s))\n\ndef js(lst):\n    return ' '.join((str(d) for d in lst))\n\ndef jsns(lst):\n    return ''.join((str(d) for d in lst))\n\ndef line():\n    return sys.stdin.readline().strip()\n\ndef linesp():\n    return line().split()\n\ndef iline():\n    return int(line())\n\ndef mat(n):\n    matr = []\n    for _ in range(n):\n        matr.append(linesp())\n    return matr\n\ndef matns(n):\n    mat = []\n    for _ in range(n):\n        mat.append([c for c in line()])\n    return mat\n\ndef mati(n):\n    mat = []\n    for _ in range(n):\n        mat.append(lmi(line()))\n    return mat\n\ndef pmat(mat):\n    for row in mat:\n        print(js(row))\nimport math\nimport sys\nimport collections\nimport bisect\nimport string\nimport time\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef convex_hull(points):\n    points = sorted(set(points))\n    if len(points) <= 1:\n        return points\n\n    def cross(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    return lower[:-1] + upper[:-1]\nfor t in range(int(input())):\n    n = int(input())\n    arr = get_list()\n    starting = [(1, 0)]\n    for j in range(0, n, 1):\n        starting.append((j + 1, arr[j]))\n    starting.append((n, 0))\n    solution = convex_hull(starting)\n    solution.sort()\n    ans = 0\n    for i in range(2, len(solution) - 1):\n        val = solution[i][0] - solution[i - 1][0]\n        ans = max(ans, val)\n    print(ans)", "from sys import stdin, stdout\nimport math\nimport math\n\ndef ii():\n    return int(stdin.readline())\n\ndef mi():\n    return map(int, stdin.readline().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return stdin.readline()\n\ndef slope(p1, p2):\n    return (p2[1] - p1[1]) / (p2[0] - p1[0])\nfor _ in range(ii()):\n    n = ii()\n    l1 = [(i + 1, v) for (i, v) in enumerate(li())]\n    ans = 1\n    stack = []\n    stack.append(l1[0])\n    stack.append(l1[1])\n    for i in range(2, n):\n        while len(stack) >= 2:\n            if slope(l1[i], stack[-1]) >= slope(stack[-2], l1[i]):\n                stack.pop()\n            else:\n                break\n        stack.append(l1[i])\n        ans = max(ans, abs(stack[-1][0] - stack[-2][0]))\n    print(ans)", "def s():\n    n = int(input())\n    array = list(map(int, input().split()))\n    if n <= 2:\n        print(1)\n    else:\n        answere = 1\n        a = []\n        for i in range(n):\n            a.append([i + 1, array[i]])\n        b = []\n        b.append(a[0])\n        b.append(a[1])\n        l = len(b)\n        for i in range(2, n):\n            while l >= 2:\n                s1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                s2 = (b[l - 1][1] - a[i][1]) / (b[l - 1][0] - a[i][0])\n                if s2 >= s1:\n                    b.pop()\n                    l -= 1\n                else:\n                    break\n            b.append(a[i])\n            l += 1\n            answere = max(answere, b[l - 1][0] - b[l - 2][0])\n        print(answere)\nfor _ in range(int(input())):\n    s()", "from bisect import bisect_left\nfrom bisect import bisect_right\n\ndef I():\n    return inp()\n\ndef II():\n    return int(inp())\n\ndef FI():\n    return float(inp())\n\ndef SI():\n    return list(str(inp()))\n\ndef MI():\n    return map(int, inp().split())\n\ndef LI():\n    return list(MI())\n\ndef SLI():\n    return sorted(LI())\n\ndef MF():\n    return map(float, inp().split())\n\ndef LF():\n    return list(MF())\n\ndef SLF():\n    return sorted(LF())\n\ndef prefixSum(arr):\n    for i in range(1, len(arr)):\n        arr[i] = arr[i] + arr[i - 1]\n    return arr\n\ndef isPowerOf2(x):\n    return x and (not x & x - 1)\n\ndef power2(n):\n    return len(str(bin(n & ~(n - 1))) - 1)\n\ndef sumn(n):\n    return n * (n + 1) // 2\n\ndef sqsum(n):\n    return n * (n + 1) * (2 * n + 1) // 6\n\ndef cusum(n):\n    return sumn(n) ** 2\n\ndef result(n, a):\n    list1 = []\n    res = 1\n    if n == 2:\n        return 1\n    else:\n        list1.append(tuple((0, a[0])))\n        list1.append(tuple((1, a[1])))\n        for i in range(2, n):\n            while len(list1) >= 2:\n                x = (list1[len(list1) - 1][1] - list1[len(list1) - 2][1]) / (list1[len(list1) - 1][0] - list1[len(list1) - 2][0])\n                y = (a[i] - list1[len(list1) - 1][1]) / (i - list1[len(list1) - 1][0])\n                if x <= y:\n                    list1.pop()\n                else:\n                    break\n            list1.append(tuple((i, a[i])))\n            if res < list1[len(list1) - 1][0] - list1[len(list1) - 2][0]:\n                res = list1[len(list1) - 1][0] - list1[len(list1) - 2][0]\n        return res\nt = int(input())\nfor i in range(0, t):\n    n = int(input())\n    a = list(map(int, input().split()))[:n]\n    print(result(n, a))", "t = input()\nfor _ in range(int(t)):\n    n = int(input())\n    h = list(map(int, input().split()))\n    for i in range(n):\n        h[i] = [i, h[i]]\n    if n <= 2:\n        print(1)\n    else:\n        cnt = 1\n        h2 = [h[0], h[1]]\n        l = len(h2)\n        for i in range(2, n):\n            while len(h2) >= 2:\n                s1 = (h2[l - 1][1] - h2[l - 2][1]) / (h2[l - 1][0] - h2[l - 2][0])\n                s2 = (h[i][1] - h2[l - 1][1]) / (h[i][0] - h2[l - 1][0])\n                if s2 >= s1:\n                    h2.pop()\n                    l -= 1\n                else:\n                    break\n            h2.append(h[i])\n            l += 1\n            cnt = max(cnt, h2[l - 1][0] - h2[l - 2][0])\n        print(cnt)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    st = []\n    array = list(map(int, input().split()))\n    for i in range(n):\n        p.append([i + 1, array[i]])\n    if n == 2:\n        print(1)\n    else:\n        st.append(p[0])\n        st.append(p[1])\n        maxDist = 1\n        sz = len(st)\n        for i in range(2, n):\n            while len(st) >= 2:\n                s1 = (st[sz - 1][1] - st[sz - 2][1]) / (st[sz - 1][0] - st[sz - 2][0])\n                s2 = (p[i][1] - st[sz - 1][1]) / (p[i][0] - st[sz - 1][0])\n                if s1 <= s2:\n                    st.pop()\n                    sz -= 1\n                else:\n                    break\n            st.append(p[i])\n            sz += 1\n            maxDist = max(maxDist, st[sz - 1][0] - st[sz - 2][0])\n        print(maxDist)", "def digbig(a, b):\n    if a >= b:\n        return a\n    else:\n        return b\nt = int(input())\nfor jj in range(t):\n    n = int(input())\n    h = list(map(int, input().split()))\n    if n <= 2:\n        print(1)\n    else:\n        ans = 1\n        a = []\n        for j in range(n):\n            a.append([j + 1, h[j]])\n        b = [a[0]]\n        b.append(a[1])\n        initial_len = len(b)\n        for i in range(2, n):\n            while initial_len >= 2:\n                y2 = b[initial_len - 1][1]\n                y1 = b[initial_len - 2][1]\n                diff_y = y2 - y1\n                x2 = b[initial_len - 1][0]\n                x1 = b[initial_len - 2][0]\n                diff_x = x2 - x1\n                slope1 = diff_y / diff_x\n                yc = a[i][1]\n                xc = a[i][0]\n                diff_y_sec = yc - y2\n                diff_x_sec = xc - x2\n                slope2 = diff_y_sec / diff_x_sec\n                if slope2 >= slope1:\n                    b.pop(-1)\n                    initial_len = initial_len - 1\n                else:\n                    break\n            b.append(a[i])\n            initial_len = initial_len + 1\n            ans = digbig(ans, b[initial_len - 1][0] - b[initial_len - 2][0])\n        print(ans)", "t = int(input())\nwhile t:\n    n = int(input())\n    h = list(map(int, input().split()))\n    ans = 1\n    if n == 2:\n        ans = 1\n    else:\n        dp = []\n        dp.append([1, h[0]])\n        dp.append([2, h[1]])\n        size = len(dp)\n        for i in range(2, n):\n            while len(dp) >= 2:\n                slope1 = (dp[size - 1][1] - dp[size - 2][1]) / (dp[size - 1][0] - dp[size - 2][0])\n                slope2 = (h[i] - dp[size - 1][1]) / (i + 1 - dp[size - 1][0])\n                if slope2 >= slope1:\n                    dp.pop()\n                    size -= 1\n                else:\n                    break\n            dp.append([i + 1, h[i]])\n            size += 1\n            ans = max(ans, dp[size - 1][0] - dp[size - 2][0])\n    print(ans)\n    t -= 1", "try:\n    for i in range(int(input())):\n        n = int(input())\n        a = [int(i) for i in input().split()]\n        if n <= 2:\n            print(1)\n        else:\n            ans = -1\n            newa = []\n            for i in range(n):\n                newa.append([i, a[i]])\n            b = []\n            b.append(newa[0])\n            b.append(newa[1])\n            l = len(b)\n            for i in range(2, n):\n                while len(b) >= 2:\n                    slope1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                    slope2 = (newa[i][1] - b[l - 1][1]) / (newa[i][0] - b[l - 1][0])\n                    if slope2 >= slope1:\n                        b.pop()\n                        l -= 1\n                    else:\n                        break\n                b.append(newa[i])\n                l += 1\n                ans = max(ans, b[l - 1][0] - b[l - 2][0])\n            print(ans)\nexcept:\n    pass", "def my_func():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    if n <= 2:\n        print(1)\n    else:\n        res = 1\n        a = []\n        for i in range(n):\n            a.append([i + 1, arr[i]])\n        b = []\n        b.append(a[0])\n        b.append(a[1])\n        l = len(b)\n        for i in range(2, n):\n            while l >= 2:\n                x = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                y = (b[l - 1][1] - a[i][1]) / (b[l - 1][0] - a[i][0])\n                if y >= x:\n                    b.pop()\n                    l -= 1\n                else:\n                    break\n            b.append(a[i])\n            l += 1\n            res = max(res, b[l - 1][0] - b[l - 2][0])\n        print(res)\nfor _ in range(int(input())):\n    my_func()", "for _ in range(int(input())):\n    n = int(input())\n    stack = []\n    arr = list(map(int, input().split()))\n    p = [[i + 1, arr[i]] for i in range(n)]\n    if n == 2:\n        print(1)\n        continue\n    stack.append(p[0])\n    stack.append(p[1])\n    (ans, l) = (1, len(stack))\n    for i in range(2, n):\n        while len(stack) >= 2:\n            s1 = (stack[-1][1] - stack[-2][1]) / (stack[-1][0] - stack[-2][0])\n            s2 = (p[i][1] - stack[-1][1]) / (p[i][0] - stack[-1][0])\n            if s1 <= s2:\n                stack.pop()\n            else:\n                break\n        stack.append(p[i])\n        ans = max(ans, stack[-1][0] - stack[-2][0])\n    print(ans)", "import math\n\ndef lengthSquare(X, Y):\n    xDiff = X[0] - Y[0]\n    yDiff = X[1] - Y[1]\n    return xDiff * xDiff + yDiff * yDiff\n\ndef findAngle(A, B, C):\n    a2 = lengthSquare(B, C)\n    b2 = lengthSquare(A, C)\n    c2 = lengthSquare(A, B)\n    a = math.sqrt(a2)\n    b = math.sqrt(b2)\n    c = math.sqrt(c2)\n    betta = math.acos((a2 + c2 - b2) / (2 * a * c))\n    betta = betta * 180 / math.pi\n    return betta\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 2:\n        print(1)\n    else:\n        tmp = [[1, a[0]], [2, a[1]]]\n        res = 1\n        s = len(tmp)\n        for i in range(2, n):\n            while len(tmp) >= 2:\n                s1 = (tmp[-1][1] - tmp[-2][1]) / (tmp[-1][0] - tmp[-2][0])\n                s2 = (a[i] - tmp[-1][1]) / (i + 1 - tmp[-1][0])\n                if s1 <= s2:\n                    tmp.pop()\n                    s -= 1\n                else:\n                    break\n            tmp.append([i + 1, a[i]])\n            s += 1\n            res = max(res, tmp[-1][0] - tmp[-2][0])\n        print(res)", "import math\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    h = list(map(int, input().split()))\n    d1 = []\n    cur = 0\n    for i in range(n):\n        if h[i] > cur:\n            cur = h[i]\n            d1.append((h[i], i))\n    d2 = []\n    cur = 0\n    for i in range(n - 1, -1, -1):\n        if h[i] > cur:\n            cur = h[i]\n            d2.append((h[i], i))\n    ans = 1\n    if len(d1) == len(d2) == 1 and n > 1:\n        ans = n - 1\n    else:\n        m = max(h)\n        ind1 = 0\n        ind2 = 0\n        for i in range(n):\n            if h[i] == m:\n                ind1 = i\n                break\n        for i in range(n - 1, -1, -1):\n            if h[i] == m:\n                ind2 = i\n                break\n        ans = max(ans, ind2 - ind1)\n        if len(d1) > 1:\n            stack = [d1[0], d1[1]]\n            ans = max(ans, abs(stack[-1][1] - stack[-2][1]))\n            for i in range(2, len(d1)):\n                while len(stack) >= 2:\n                    slope1 = (stack[-1][0] - stack[-2][0]) / (stack[-1][1] - stack[-2][1])\n                    slope2 = (d1[i][0] - stack[-1][0]) / (d1[i][1] - stack[-1][1])\n                    if abs(slope1) <= abs(slope2):\n                        stack.pop()\n                    else:\n                        break\n                stack.append(d1[i])\n                ans = max(ans, abs(stack[-1][1] - stack[-2][1]))\n        if len(d2) > 1:\n            stack = [d2[0], d2[1]]\n            ans = max(ans, abs(stack[-1][1] - stack[-2][1]))\n            for i in range(2, len(d2)):\n                while len(stack) >= 2:\n                    slope1 = (stack[-1][0] - stack[-2][0]) / (stack[-1][1] - stack[-2][1])\n                    slope2 = (d2[i][0] - stack[-1][0]) / (d2[i][1] - stack[-1][1])\n                    if abs(slope1) <= abs(slope2):\n                        stack.pop()\n                    else:\n                        break\n                stack.append(d2[i])\n                ans = max(ans, abs(stack[-1][1] - stack[-2][1]))\n        print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    if n <= 2:\n        print(1)\n    else:\n        max_diff = 1\n        tupleList = [tup for tup in enumerate(heights)]\n        stack = [tupleList[0], tupleList[1]]\n        l = 2\n        for j in range(2, n):\n            while l >= 2:\n                slope1 = (stack[l - 1][1] - stack[l - 2][1]) / (stack[l - 1][0] - stack[l - 2][0])\n                slope2 = (tupleList[j][1] - stack[l - 1][1]) / (tupleList[j][0] - stack[l - 1][0])\n                if slope2 >= slope1:\n                    stack.pop()\n                    l -= 1\n                else:\n                    break\n            stack.append(tupleList[j])\n            l += 1\n            max_diff = max(max_diff, stack[l - 1][0] - stack[l - 2][0])\n        print(max_diff)", "t = int(input())\nfor x in range(0, t):\n    N = int(input())\n    if N <= 2:\n        print(1)\n        temp = input()\n        continue\n    res = 1\n    string = input().split(' ')\n    li = []\n    for y in range(0, len(string)):\n        li.append([y, int(string[y])])\n    li2 = [li[0], li[1]]\n    length = len(li2)\n    for i in range(2, N):\n        while length >= 2:\n            slp1 = (li2[length - 1][1] - li2[length - 2][1]) / (li2[length - 1][0] - li2[length - 2][0])\n            slp2 = (li[i][1] - li2[length - 1][1]) / (li[i][0] - li2[length - 1][0])\n            if slp2 >= slp1:\n                li2.pop()\n                length = length - 1\n            else:\n                break\n        li2.append(li[i])\n        length = length + 1\n        res = max(res, li2[length - 1][0] - li2[length - 2][0])\n    print(res)", "for t in range(int(input())):\n    n = int(input())\n    sec = list(map(int, input().split()))\n    if n <= 2:\n        print(1)\n    else:\n        res = 1\n        a = []\n        for i in range(n):\n            a.append([i, sec[i]])\n        b = [a[0], a[1]]\n        l = len(b)\n        for i in range(2, n):\n            while l >= 2:\n                s1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                s2 = (a[i][1] - b[l - 1][1]) / (a[i][0] - b[l - 1][0])\n                if s2 >= s1:\n                    b.pop()\n                    l -= 1\n                else:\n                    break\n            b.append(a[i])\n            l += 1\n            res = max(res, b[l - 1][0] - b[l - 2][0])\n        print(res)", "for _ in range(int(input())):\n    n = int(input())\n    H = [int(x) for x in input().split()]\n    if n <= 2:\n        print(1)\n    else:\n        ans = 1\n        a = []\n        for i in range(n):\n            a.append([i, H[i]])\n        b = [[0, a[0][1]], [1, a[1][1]]]\n        l = 2\n        for i in range(2, n):\n            while l >= 2:\n                slope1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                slope2 = (a[i][1] - b[l - 1][1]) / (a[i][0] - b[l - 1][0])\n                if slope2 >= slope1:\n                    b.pop()\n                    l -= 1\n                else:\n                    break\n            b.append(a[i])\n            l += 1\n            ans = max(ans, b[l - 1][0] - b[l - 2][0])\n        print(ans)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    h = list(map(int, input().split()))\n    if n <= 2:\n        print(1)\n        continue\n    a = []\n    for i in range(n):\n        a.append([i, h[i]])\n    b = [a[0], a[1]]\n    l = len(b)\n    ans = 1\n    for i in range(2, n):\n        while l >= 2:\n            slope1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n            slope2 = (a[i][1] - b[l - 1][1]) / (a[i][0] - b[l - 1][0])\n            if slope2 >= slope1:\n                b.pop()\n                l -= 1\n            else:\n                break\n        b.append(a[i])\n        l += 1\n        ans = max(ans, b[l - 1][0] - b[l - 2][0])\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    if n <= 2:\n        print(1)\n    else:\n        ans = 1\n        a = []\n        for i in range(1, n + 1):\n            a.append([i, l[i - 1]])\n        b = [a[0], a[1]]\n        l = len(b)\n        for i in range(2, n):\n            while len(b) >= 2:\n                s1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                s2 = (a[i][1] - b[l - 1][1]) / (a[i][0] - b[l - 1][0])\n                if s2 >= s1:\n                    b.pop()\n                    l = l - 1\n                else:\n                    break\n            b.append(a[i])\n            l = l + 1\n            ans = max(ans, b[l - 1][0] - b[l - 2][0])\n        print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    indx = [(i, i + 1) for i in range(n - 1)]\n    done = False\n    if n == 2:\n        print(1)\n        continue\n    while not done:\n        done = True\n        new_indx = []\n        i = 0\n        while i < len(indx) - 1:\n            (p1, p2) = indx[i]\n            (_, p3) = indx[i + 1]\n            m1 = (h[p2] - h[p1]) / (p2 - p1)\n            m2 = (h[p3] - h[p2]) / (p3 - p2)\n            if m1 <= m2:\n                new_indx.append((p1, p3))\n                done = False\n                i += 1\n            else:\n                new_indx.append(indx[i])\n            if i + 2 == len(indx):\n                new_indx.append(indx[i + 1])\n            i += 1\n        indx = new_indx\n        if len(indx) == 1:\n            done = True\n    answer = [i[1] - i[0] for i in indx]\n    print(max(answer))", "for _ in range(int(input())):\n    n = int(input())\n    d = list(map(int, input().rstrip().split()))\n    if n <= 2:\n        print(1)\n    else:\n        ans = 1\n        a = []\n        for i in range(n):\n            c = [i, d[i]]\n            a.append(c)\n        b = []\n        b.append(a[0])\n        b.append(a[1])\n        len1 = len(b)\n        for i in range(2, n):\n            while len1 >= 2:\n                slope1 = (b[len1 - 1][1] - b[len1 - 2][1]) / (b[len1 - 1][0] - b[len1 - 2][0])\n                slope2 = (a[i][1] - b[len1 - 1][1]) / (a[i][0] - b[len1 - 1][0])\n                if slope2 >= slope1:\n                    b.pop()\n                    len1 = len1 - 1\n                else:\n                    break\n            b.append(a[i])\n            len1 = len1 + 1\n            ans = max(ans, b[len1 - 1][0] - b[len1 - 2][0])\n        print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    if n <= 2:\n        print(1)\n        continue\n    ans = 1\n    a = []\n    for j in range(n):\n        a.append([j, arr[j]])\n    b = [a[0], a[1]]\n    for j in range(2, n):\n        while len(b) >= 2:\n            nr = b[-1][1] - b[-2][1]\n            dr = b[-1][0] - b[-2][0]\n            slope1 = nr / dr\n            nr = a[j][1] - b[-1][1]\n            dr = a[j][0] - b[-1][0]\n            slope2 = nr / dr\n            if slope2 >= slope1:\n                b = b[:-1]\n            else:\n                break\n        b.append(a[j])\n        ans = max(ans, b[-1][0] - b[-2][0])\n    print(ans)", "def process(l):\n    if len(l) == 2:\n        return 1\n    n = len(l)\n    a = [0]\n    c = 0\n    for j in range(1, n):\n        if l[j] >= l[a[-1]]:\n            c = 10000000\n            p = len(a)\n            for i in range(p):\n                slope = (l[j] - l[a[p - i - 1]]) / (j - a[p - i - 1])\n                if slope <= c:\n                    a = a[:p - i] + [j]\n                    c = slope\n    ans = 1\n    for i in range(len(a) - 1):\n        if a[i + 1] - a[i] > ans:\n            ans = a[i + 1] - a[i]\n    return ans\nno = int(input())\nfor it in range(no):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n < 100000:\n        slope = -1000000000000000\n        dist = 1\n        next = 0\n        i = 0\n        while i < n - 1:\n            slope = -1000000000000000\n            for j in range(i + 1, n):\n                if (a[j] - a[i]) / (j - i) >= slope:\n                    next = j\n                    slope = (a[j] - a[i]) / (j - i)\n                    dist = max(dist, j - i)\n            i = next\n        print(dist)\n    else:\n        print(max(process(a), process(a[::-1])))", "for _ in range(int(input())):\n    n = int(input())\n    stack = []\n    arr = list(map(int, input().split()))\n    p = [[i + 1, arr[i]] for i in range(n)]\n    if n == 2:\n        print(1)\n        continue\n    stack.append(p[0])\n    stack.append(p[1])\n    (ans, l) = (1, len(stack))\n    for i in range(2, n):\n        while len(stack) >= 2:\n            s1 = (stack[-1][1] - stack[-2][1]) / (stack[-1][0] - stack[-2][0])\n            s2 = (p[i][1] - stack[-1][1]) / (p[i][0] - stack[-1][0])\n            if s1 <= s2:\n                stack.pop()\n            else:\n                break\n        stack.append(p[i])\n        ans = max(ans, stack[-1][0] - stack[-2][0])\n    print(ans)", "n = int(input())\nfor m in range(n):\n    l = int(input())\n    flag = False\n    li = [int(x) for x in input().split()]\n    if len(li) <= 2:\n        print(1)\n        flag = True\n    if flag == False:\n        d = []\n        for i in range(len(li)):\n            d.append([i + 1, li[i]])\n        b = d[:2]\n        q = 2\n        ans = 0\n        for i in range(2, len(li)):\n            while len(b) >= 2:\n                prevSlope = (b[q - 1][1] - b[q - 2][1]) / (b[q - 1][0] - b[q - 2][0])\n                newSlope = (d[i][1] - b[q - 1][1]) / (d[i][0] - b[q - 1][0])\n                if newSlope >= prevSlope:\n                    b.pop()\n                    q -= 1\n                else:\n                    break\n            b.append(d[i])\n            q += 1\n            ans = max(ans, b[q - 1][0] - b[q - 2][0])\n        print(ans)", "try:\n    for i in range(int(input())):\n        n = int(input())\n        a = [int(i) for i in input().split()]\n        if n <= 2:\n            print(1)\n        else:\n            ans = -1\n            newa = []\n            for i in range(n):\n                newa.append([i, a[i]])\n            b = []\n            b.append(newa[0])\n            b.append(newa[1])\n            l = len(b)\n            for i in range(2, n):\n                while len(b) >= 2:\n                    slope1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                    slope2 = (newa[i][1] - b[l - 1][1]) / (newa[i][0] - b[l - 1][0])\n                    if slope2 >= slope1:\n                        b.pop()\n                        l -= 1\n                    else:\n                        break\n                b.append(newa[i])\n                l += 1\n                ans = max(ans, b[l - 1][0] - b[l - 2][0])\n            print(ans)\nexcept:\n    pass", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    cord = [(1, l[0]), (2, l[1])]\n    ln_cord = 2\n    mx = 1\n    for i in range(2, n):\n        while ln_cord >= 2:\n            sl1 = (cord[ln_cord - 1][1] - cord[ln_cord - 2][1]) / (cord[ln_cord - 1][0] - cord[ln_cord - 2][0])\n            sl2 = (cord[ln_cord - 1][1] - l[i]) / (cord[ln_cord - 1][0] - (i + 1))\n            if sl1 <= sl2:\n                cord = cord[:ln_cord - 1]\n                ln_cord = ln_cord - 1\n            else:\n                break\n        cord.append((i + 1, l[i]))\n        ln_cord += 1\n        mx = max(mx, cord[ln_cord - 1][0] - cord[ln_cord - 2][0])\n    print(mx)", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ix = [i for i in range(1, n + 1)]\n    cord = [(1, l[0]), (2, l[1])]\n    ln_cord = 2\n    mx = 1\n    for i in range(2, n):\n        while ln_cord >= 2:\n            sl1 = (cord[ln_cord - 1][1] - cord[ln_cord - 2][1]) / (cord[ln_cord - 1][0] - cord[ln_cord - 2][0])\n            sl2 = (cord[ln_cord - 1][1] - l[i]) / (cord[ln_cord - 1][0] - (i + 1))\n            if sl1 <= sl2:\n                cord = cord[:ln_cord - 1]\n                ln_cord = ln_cord - 1\n            else:\n                break\n        cord.append((i + 1, l[i]))\n        ln_cord += 1\n        mx = max(mx, cord[ln_cord - 1][0] - cord[ln_cord - 2][0])\n    print(mx)", "try:\n    for i in range(int(input())):\n        n = int(input())\n        a = [int(i) for i in input().split()]\n        if n <= 2:\n            print(1)\n        else:\n            ans = -1\n            newa = []\n            for i in range(n):\n                newa.append([i, a[i]])\n            b = []\n            b.append(newa[0])\n            b.append(newa[1])\n            l = len(b)\n            for i in range(2, n):\n                while len(b) >= 2:\n                    slope1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                    slope2 = (newa[i][1] - b[l - 1][1]) / (newa[i][0] - b[l - 1][0])\n                    if slope2 >= slope1:\n                        b.pop()\n                        l -= 1\n                    else:\n                        break\n                b.append(newa[i])\n                l += 1\n                ans = max(ans, b[l - 1][0] - b[l - 2][0])\n            print(ans)\nexcept:\n    pass", "t = int(input())\nwhile t != 0:\n    t -= 1\n    n = int(input())\n    arr = list(map(int, input().split()))\n    st = []\n    st.append((0, arr[0]))\n    st.append((1, arr[1]))\n    ans = -1\n    if len(arr) == 2:\n        print('1')\n    else:\n        for i in range(2, n):\n            p = (i, arr[i])\n            while len(st) > 1:\n                s1 = (st[-1][1] - st[-2][1]) / (st[-1][0] - st[-2][0])\n                s2 = (p[1] - st[-1][1]) / (p[0] - st[-1][0])\n                if s2 >= s1:\n                    st.pop()\n                else:\n                    break\n            st.append(p)\n            ans = max(ans, st[-1][0] - st[-2][0])\n        print(ans)", "T = int(input())\nsol = []\n\ndef pivot(L, N, T, S):\n    if S == 2:\n        return ([0], T[1] - T[0])\n    x = 0\n    y = 1\n    t = []\n    s = 0\n    while y <= S - 2:\n        if (L[T[y]] - L[T[x]]) / (T[y] - T[x]) <= (L[T[y + 1]] - L[T[y]]) / (T[y + 1] - T[y]):\n            y += 1\n            continue\n        else:\n            t.append(T[y])\n            x = y\n            y += 1\n            s += 1\n    t = [0] + t + [N - 1]\n    s += 2\n    if t == T:\n        return (t, s)\n    else:\n        return pivot(L, N, t, s)\nfor i in range(T):\n    N = int(input())\n    L = list(map(int, input().split()))\n    if N == 2:\n        sol.append(1)\n        continue\n    else:\n        pass\n    dummy = [i for i in range(N)]\n    (T, S) = pivot(L, N, dummy, N)\n    if len(T) == 1:\n        sol.append(S)\n        continue\n    elif S == N:\n        sol.append(1)\n        continue\n    elif S == N - 1:\n        sol.append(2)\n        continue\n    elif S == 3:\n        sol.append(max(T[1] - T[0], T[2] - T[1]))\n        continue\n    else:\n        pass\n    ans = 0\n    for j in range(0, S - 1):\n        z = -float('inf')\n        for k in range(j + 1, S):\n            if (L[T[k]] - L[T[j]]) / (T[k] - T[j]) >= z:\n                z = (L[T[k]] - L[T[j]]) / (T[k] - T[j])\n                ans = max(ans, T[k] - T[j])\n                continue\n            else:\n                continue\n    sol.append(ans)\nfor i in sol:\n    print(i)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    if n == 2:\n        print('1')\n    else:\n        ans = 1\n        a = []\n        for i in range(n):\n            a.append([i, arr[i]])\n        b = [[0, arr[0]], [1, arr[1]]]\n        l = 2\n        for i in range(2, n):\n            while len(b) >= 2:\n                s1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n                s2 = (a[i][1] - b[l - 1][1]) / (a[i][0] - b[l - 1][0])\n                if s2 >= s1:\n                    b.pop()\n                    l -= 1\n                else:\n                    break\n            b.append([i, arr[i]])\n            l += 1\n            ans = max(ans, b[l - 1][0] - b[l - 2][0])\n        print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 2 or n == 1:\n        print(1)\n        continue\n    b = []\n    for i in range(n):\n        b.append([i, a[i]])\n    c = []\n    c.append(b[0])\n    c.append(b[1])\n    sol = 1\n    ind = len(c)\n    for i in range(2, n):\n        while len(c) >= 2:\n            s1 = (c[ind - 1][1] - c[ind - 2][1]) / (c[ind - 1][0] - c[ind - 2][0])\n            s2 = (b[i][1] - c[ind - 1][1]) / (b[i][0] - c[ind - 1][0])\n            if s1 <= s2:\n                c.pop()\n                ind = ind - 1\n            else:\n                break\n        c.append(b[i])\n        ind += 1\n        sol = max(sol, c[ind - 1][0] - c[ind - 2][0])\n    print(sol)", "for _ in range(int(input())):\n    n = int(input())\n    mp = list(map(int, input().split()))\n    step = [0, 1]\n    if n == 2:\n        print(mp[1] - mp[0])\n        continue\n    for i in range(2, n):\n        if (mp[step[-1]] - mp[step[-2]]) / (step[-1] - step[-2]) <= (mp[i] - mp[step[-2]]) / (i - step[-2]):\n            while len(step) > 1 and (mp[step[-1]] - mp[step[-2]]) / (step[-1] - step[-2]) <= (mp[i] - mp[step[-2]]) / (i - step[-2]):\n                step.pop()\n        step.append(i)\n    ans = 1\n    for i in range(len(step) - 1):\n        ans = max(ans, step[i + 1] - step[i])\n    print(ans)", "def maximum(num1, num2):\n    if num1 > num2:\n        return num1\n    else:\n        return num2\nt = int(input())\nfor _ in range(t):\n    comp_list = list()\n    sub_list = list()\n    n = input()\n    n = int(n)\n    list1 = [int(x) for x in input().split()]\n    if n == 2:\n        print('1')\n        continue\n    for l in range(n):\n        comp_list.append([l, list1[l]])\n    sub_list = comp_list[:2]\n    output = 1\n    length = 2\n    for l in range(2, n, 1):\n        while length >= 2:\n            slope2 = (comp_list[l][1] - sub_list[length - 1][1]) / (comp_list[l][0] - sub_list[length - 1][0])\n            slope1 = (sub_list[length - 1][1] - sub_list[length - 2][1]) / (sub_list[length - 1][0] - sub_list[length - 2][0])\n            if slope1 > slope2:\n                break\n            else:\n                sub_list.pop(-1)\n                length = len(sub_list)\n        sub_list.append(comp_list[l])\n        length = len(sub_list)\n        output = maximum(output, sub_list[length - 1][0] - sub_list[length - 2][0])\n    print(output)", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    if n == 2:\n        print('1')\n    else:\n        max1 = 1\n        a = []\n        for i in range(n):\n            a.append([i + 1, l[i]])\n        b = [a[0], a[1]]\n        ln = len(b)\n        for i in range(2, n):\n            while ln >= 2:\n                slp1 = (b[ln - 1][1] - b[ln - 2][1]) / (b[ln - 1][0] - b[ln - 2][0])\n                slp2 = (a[i][1] - b[ln - 1][1]) / (a[i][0] - b[ln - 1][0])\n                if slp2 >= slp1:\n                    b.pop()\n                    ln -= 1\n                else:\n                    break\n            b.append(a[i])\n            ln += 1\n            max1 = max(max1, b[ln - 1][0] - b[ln - 2][0])\n        print(max1)", "t = int(input())\nwhile t:\n    n = int(input())\n    height = list(map(int, input().split()))\n    section = [0] * n\n    for i in range(n):\n        section[i] = [i, height[i]]\n    if n == 2:\n        print(1)\n        t -= 1\n        continue\n    stack = [section[0], section[1]]\n    stack_size = len(stack)\n    res = 1\n    for i in range(2, n):\n        while stack_size >= 2:\n            current_slope = (section[i][1] - stack[stack_size - 1][1]) / (section[i][0] - stack[stack_size - 1][0])\n            prev_largest_slope = (stack[stack_size - 1][1] - stack[stack_size - 2][1]) / (stack[stack_size - 1][0] - stack[stack_size - 2][0])\n            if current_slope >= prev_largest_slope:\n                stack.pop()\n                stack_size -= 1\n            else:\n                break\n        stack.append(section[i])\n        stack_size += 1\n        current_max_dist = stack[stack_size - 1][0] - stack[stack_size - 2][0]\n        res = max(res, current_max_dist)\n    print(res)\n    t -= 1", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    li = [int(x) for x in input().split()]\n    list1 = list()\n    list2 = list()\n    if n <= 2:\n        print('1')\n        continue\n    answer = 1\n    for i in range(n):\n        list1.append([i, li[i]])\n    list2.append(list1[0])\n    list2.append(list1[1])\n    l = 2\n    for i in range(2, n, 1):\n        while l >= 2:\n            slope1 = (list2[l - 1][1] - list2[l - 2][1]) / (list2[l - 1][0] - list2[l - 2][0])\n            slope2 = (list1[i][1] - list2[l - 1][1]) / (list1[i][0] - list2[l - 1][0])\n            if slope2 >= slope1:\n                list2.pop()\n                l = l - 1\n            else:\n                break\n        list2.append(list1[i])\n        l = l + 1\n        answer = max(answer, list2[l - 1][0] - list2[l - 2][0])\n    print(answer)", "def fun(l, n):\n    if n == 2:\n        print(1)\n    else:\n        ans = 1\n        a = []\n        for i in range(len(l)):\n            a.append([i, l[i]])\n        a1 = []\n        a1.append(a[0])\n        a1.append(a[1])\n        l = len(a1)\n        for i in range(2, n):\n            while len(a1) >= 2:\n                slope1 = (a1[l - 1][1] - a1[l - 2][1]) / (a1[l - 1][0] - a1[l - 2][0])\n                slope2 = (a[i][1] - a1[l - 1][1]) / (a[i][0] - a1[l - 1][0])\n                if slope1 <= slope2:\n                    a1.pop()\n                    l -= 1\n                else:\n                    break\n            a1.append(a[i])\n            l += 1\n            ans = max(ans, a1[l - 1][0] - a1[l - 2][0])\n        print(ans)\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    fun(l, n)", "for _ in range(0, int(input())):\n    n = int(input())\n    h = [int(x) for x in input().split()]\n    if n <= 2:\n        print('1')\n    else:\n        ans = 1\n        a = []\n        for i in range(n):\n            a.append([i, h[i]])\n        b = [[0, a[0][1]], [1, a[1][1]]]\n        for i in range(2, n):\n            lenght = len(b)\n            while lenght >= 2:\n                slope1 = (b[lenght - 1][1] - b[lenght - 2][1]) / (b[lenght - 1][0] - b[lenght - 2][0])\n                slope2 = (a[i][1] - b[lenght - 1][1]) / (a[i][0] - b[lenght - 1][0])\n                if slope2 >= slope1:\n                    b.pop()\n                    lenght = lenght - 1\n                else:\n                    break\n            b.append(a[i])\n            lenght = lenght + 1\n            ans = max(ans, b[lenght - 1][0] - b[lenght - 2][0])\n        print(ans)", "def solve():\n    n = inp()\n    h = inl()\n    if n <= 2:\n        print(1)\n        return\n    a = []\n    for i in range(n):\n        a.append([i, h[i]])\n    b = [a[0], a[1]]\n    l = len(b)\n    ans = 1\n    for i in range(2, n):\n        while len(b) >= 2:\n            slp1 = (b[l - 1][1] - b[l - 2][1]) / (b[l - 1][0] - b[l - 2][0])\n            slp2 = (a[i][1] - b[l - 1][1]) / (a[i][0] - b[l - 1][0])\n            if slp2 >= slp1:\n                b.pop()\n                l -= 1\n            else:\n                break\n        b.append(a[i])\n        l += 1\n        ans = max(ans, b[l - 1][0] - b[l - 2][0])\n    print(ans)\n\ndef inp():\n    return int(input())\n\ndef inl():\n    return [int(i) for i in input().split()]\nt = 1\nt = inp()\nwhile t:\n    solve()\n    t -= 1", "for _ in range(int(input())):\n    n = int(input())\n    H = list(map(int, input().split()))\n    if n == 2:\n        print(1)\n        continue\n    if n <= 5 * 10 ** 5:\n        temp = []\n        temp.append((0, H[0]))\n        temp.append((1, H[1]))\n        ans = 1\n        for i in range(2, n):\n            tlen = len(temp)\n            while tlen >= 2:\n                A = (temp[tlen - 1][1] - temp[tlen - 2][1]) / (temp[tlen - 1][0] - temp[tlen - 2][0])\n                B = (H[i] - temp[tlen - 1][1]) / (i - temp[tlen - 1][0])\n                if A <= B:\n                    temp.pop()\n                    tlen -= 1\n                else:\n                    break\n            temp.append((i, H[i]))\n            tlen += 1\n            if ans < temp[tlen - 1][0] - temp[tlen - 2][0]:\n                ans = temp[tlen - 1][0] - temp[tlen - 2][0]\n        print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    h = [int(x) for x in input().split()]\n    p = []\n    for i in range(n):\n        p.append([i, h[i]])\n    if n == 2:\n        print(1)\n        continue\n    maxd = 1\n    t = []\n    t.append(p[0])\n    t.append(p[1])\n    m = len(t)\n    for i in range(2, n):\n        while len(t) >= 2:\n            m1 = (t[m - 1][1] - t[m - 2][1]) / (t[m - 1][0] - t[m - 2][0])\n            m2 = (p[i][1] - t[m - 1][1]) / (p[i][0] - t[m - 1][0])\n            if m1 <= m2:\n                t = t[:-1]\n                m -= 1\n            else:\n                break\n        t.append(p[i])\n        m += 1\n        maxd = max(maxd, t[m - 1][0] - t[m - 2][0])\n    print(maxd)", "for tests in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    vh = []\n    for i in range(n):\n        vh.append([i + 1, a[i]])\n    if n == 2:\n        print(1)\n    else:\n        angle = [vh[0], vh[1]]\n        (it, ans) = (2, 1)\n        for i in range(2, n):\n            while len(angle) > 1:\n                y1 = angle[it - 1][1] - angle[it - 2][1]\n                x1 = angle[it - 1][0] - angle[it - 2][0]\n                y2 = vh[i][1] - angle[it - 1][1]\n                x2 = vh[i][0] - angle[it - 1][0]\n                first = y1 / x1\n                second = y2 / x2\n                if first <= second:\n                    it -= 1\n                    angle.pop()\n                else:\n                    break\n            angle.append(vh[i])\n            it += 1\n            ans = max(ans, angle[it - 1][0] - angle[it - 2][0])\n        print(ans)", "from math import *\ntf = float('inf')\nfor y in range(int(input())):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    if n == 2:\n        print('1')\n        continue\n    for i in range(n):\n        lst[i] = [i + 1, lst[i]]\n    lst2 = [lst[0], lst[1]]\n    ans = 1\n    mn = 2\n    for i in range(2, n):\n        while mn >= 2:\n            ans1 = (lst2[-1][1] - lst2[-2][1]) / (lst2[-1][0] - lst2[-2][0])\n            ans2 = (lst[i][1] - lst2[-1][1]) / (lst[i][0] - lst2[-1][0])\n            if ans1 <= ans2:\n                lst2.pop()\n                mn -= 1\n            else:\n                break\n        lst2.append(lst[i])\n        mn += 1\n        ans = max(ans, lst2[mn - 1][0] - lst2[mn - 2][0])\n    print(ans)", "try:\n    t = int(input())\n    while t:\n        n = int(input())\n        arr = list(map(int, input().split()))\n        if len(arr) <= 2:\n            print(1)\n            continue\n        ans = 1\n        (p, st) = ([], [])\n        for i in range(len(arr)):\n            p.append([i + 1, arr[i]])\n        st.append(p[0])\n        st.append(p[1])\n        n = len(st)\n        for i in range(2, len(arr)):\n            while n >= 2:\n                s1 = (st[n - 1][1] - st[n - 2][1]) / (st[n - 1][0] - st[n - 2][0])\n                s2 = (p[i][1] - st[n - 1][1]) / (p[i][0] - st[n - 1][0])\n                if s1 <= s2:\n                    st.pop()\n                    n -= 1\n                else:\n                    break\n            st.append(p[i])\n            n += 1\n            ans = max(ans, st[n - 1][0] - st[n - 2][0])\n        print(ans)\n        t -= 1\nexcept:\n    pass", "try:\n    t = int(input())\n    while t:\n        n = int(input())\n        arr = list(map(int, input().split()))\n        if len(arr) <= 2:\n            print(1)\n            continue\n        ans = 1\n        (p, st) = ([], [])\n        for i in range(len(arr)):\n            p.append([i + 1, arr[i]])\n        st.append(p[0])\n        st.append(p[1])\n        n = len(st)\n        for i in range(2, len(arr)):\n            while n >= 2:\n                s1 = (st[n - 1][1] - st[n - 2][1]) / (st[n - 1][0] - st[n - 2][0])\n                s2 = (p[i][1] - st[n - 1][1]) / (p[i][0] - st[n - 1][0])\n                if s1 <= s2:\n                    st.pop()\n                    n -= 1\n                else:\n                    break\n            st.append(p[i])\n            n += 1\n            ans = max(ans, st[n - 1][0] - st[n - 2][0])\n        print(ans)\n        t -= 1\nexcept:\n    pass", "def hull(xs):\n    ret = []\n    for (i, x) in enumerate(xs):\n        while len(ret) >= 2:\n            (j, k) = (ret[-1], ret[-2])\n            (xj, xk) = (xs[j], xs[k])\n            if (xk - xj) * (i - j) < (k - j) * (x - xj):\n                break\n            ret.pop()\n        ret.append(i)\n    return ret\nimport sys\nff = sys.stdin\nt = int(ff.readline()[:-1])\nfor i in range(t):\n    n = int(ff.readline()[:-1])\n    x = list(map(int, ff.readline().split()))\n    h = hull(x)\n    print(max(map(lambda z: abs(z[1] - z[0]), zip(h, h[1:]))))", "for t in range(int(input())):\n    n = int(input())\n    h = [int(x) for x in input().split()]\n    p = [(i + 1, v) for (i, v) in enumerate(h)]\n    st = []\n    if n == 2:\n        print(1)\n        continue\n    st.extend([p[0], p[1]])\n    sol = 1\n    s = len(st)\n    for i in range(2, n):\n        while len(st) >= 2:\n            s1 = (st[s - 1][1] - st[s - 2][1]) / (st[s - 1][0] - st[s - 2][0])\n            s2 = (p[i][1] - st[s - 1][1]) / (p[i][0] - st[s - 1][0])\n            if s1 <= s2:\n                st.pop()\n                s -= 1\n            else:\n                break\n        st.append(p[i])\n        s += 1\n        sol = max(sol, st[s - 1][0] - st[s - 2][0])\n    print(sol)", "try:\n    for _ in range(int(input())):\n        n = int(input())\n        h = list(map(int, input().split()[:n]))\n        ans = 1\n        if n > 2:\n            slist = [(1, h[0]), (2, h[1])]\n            size = len(slist)\n            for i in range(2, n):\n                while len(slist) >= 2:\n                    pslope = (slist[-1][1] - slist[-2][1]) / (slist[-1][0] - slist[-2][0])\n                    nslope = (h[i] - slist[-1][1]) / (i + 1 - slist[-1][0])\n                    if pslope <= nslope:\n                        slist.pop(-1)\n                        size -= 1\n                    else:\n                        break\n                slist.append((i + 1, h[i]))\n                size += 1\n                ans = max(ans, slist[-1][0] - slist[-2][0])\n            print(ans)\n        else:\n            print(ans)\nexcept:\n    pass", "def get_slope(p1, p2):\n    if p1[0] == p2[0]:\n        return float('inf')\n    else:\n        return 1.0 * (p1[1] - p2[1]) / (p1[0] - p2[0])\n\ndef get_cross_product(p1, p2, p3):\n    return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\nt_n = int(input())\nfor i in range(t_n):\n    n_1 = int(input())\n    lis = list(map(int, input().split()))\n    points = []\n    for kk in range(1, len(lis) + 1):\n        kl = []\n        kl.append(kk)\n        kl.append(lis[kk - 1])\n        points.append(kl)\n    hull = []\n    start = points.pop(0)\n    hull = [start]\n    for po in points:\n        hull.append(po)\n        while len(hull) > 2 and get_cross_product(hull[-3], hull[-2], hull[-1]) >= 0:\n            hull.pop(-2)\n    lis_1 = []\n    for ind in range(len(hull) - 1):\n        lis_1.append(hull[ind + 1][0] - hull[ind][0])\n    print(max(lis_1))", "for _ in range(0, int(input())):\n    n = int(input())\n    h = [int(x) for x in input().split()]\n    if n <= 2:\n        print('1')\n    else:\n        ans = 1\n        a = []\n        for i in range(n):\n            a.append([i, h[i]])\n        b = [[0, a[0][1]], [1, a[1][1]]]\n        for i in range(2, n):\n            lenght = len(b)\n            while lenght >= 2:\n                slope1 = (b[lenght - 1][1] - b[lenght - 2][1]) / (b[lenght - 1][0] - b[lenght - 2][0])\n                slope2 = (a[i][1] - b[lenght - 1][1]) / (a[i][0] - b[lenght - 1][0])\n                if slope2 >= slope1:\n                    b.pop()\n                    lenght = lenght - 1\n                else:\n                    break\n            b.append(a[i])\n            lenght = lenght + 1\n            ans = max(ans, b[lenght - 1][0] - b[lenght - 2][0])\n        print(ans)"]