["from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef solve(s, K):\n    n = len(s)\n    cnt = Counter(s)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = [int(x) for x in input().split()]\n    s = [int(x) for x in input().split()]\n    print(solve(s, k))", "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef solve(s, K):\n    n = len(s)\n    cnt = Counter(s)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = [int(x) for x in input().split()]\n    s = [int(x) for x in input().split()]\n    print(solve(s, k))", "from collections import Counter\nmod = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 2001):\n    f += (f[-1] * i % mod,)\ninv = [pow(i, mod - 2, mod) for i in f]\nA = lambda k, n: f[n] * inv[n - k] % mod\n\ndef solve(s, K):\n    n = len(s)\n    cnt = Counter(s)\n    dp = [0] * (K + 1)\n    values = sorted(cnt, reverse=True)\n    dp[1] = f[cnt[values[0]]]\n    size = cnt[values[0]]\n    for i in range(1, len(values)):\n        size += cnt[values[i]]\n        new = [0] * (K + 1)\n        for k in range(1, K + 1):\n            new[k] += dp[k] * A(cnt[values[i]], size - 1)\n            new[k] %= mod\n            if k + 1 <= K:\n                new[k + 1] += cnt[values[i]] * A(cnt[values[i]] - 1, size - 1) * dp[k]\n                new[k + 1] %= mod\n        dp = new\n    return sum(dp[1:]) % mod\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = [int(x) for x in input().split()]\n    s = [int(x) for x in input().split()]\n    print(solve(s, k))"]