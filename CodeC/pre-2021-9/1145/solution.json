["__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom sys import stdin, stdout\nWHITE = 0\nGRAY = 1\nBLACK = 2\nread_numbers = lambda : list(map(int, stdin.readline().strip().split()))\noutput_line = lambda x: stdout.write(x)\n\ndef find_farthest_leaf(N, E, root=0):\n    color = [WHITE] * N\n    farthest_leaf = root\n    level = 0\n    max_level = 0\n    color[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if color[cur] == BLACK:\n            stack.pop()\n            level -= 1\n            continue\n        level += 1\n        if level >= max_level:\n            max_level = level\n            farthest_leaf = cur\n        for child in E[cur]:\n            if color[child] == BLACK:\n                continue\n            if color[child] == WHITE:\n                color[child] = GRAY\n                stack.append(child)\n        color[cur] = BLACK\n    return farthest_leaf\n\ndef search_strips(N, E, root):\n    color = [WHITE] * N\n    strips = [[] for _ in range(N)]\n    children = [[] for _ in range(N)]\n    leafs = [False] * N\n    color[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if color[cur] == BLACK:\n            stack.pop()\n            new_strips = []\n            for child in children[cur]:\n                if leafs[child]:\n                    new_strips += [1]\n                else:\n                    if len(strips[child]):\n                        strips[child][0] += 1\n                    new_strips += strips[child]\n            new_strips.sort(reverse=True)\n            strips[cur] = new_strips\n            continue\n        for child in E[cur]:\n            if color[child] == BLACK:\n                continue\n            if color[child] == WHITE:\n                color[child] = GRAY\n                stack.append(child)\n            children[cur].append(child)\n        leafs[cur] = False if children[cur] else True\n        color[cur] = BLACK\n    return strips[root]\n\ndef solve(N, E, k):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    farthest_leaf = find_farthest_leaf(N, E)\n    strips = search_strips(N, E, root=farthest_leaf)\n    max_k = 1\n    solution = 1\n    for strip in strips:\n        max_k += strip\n        solution += 1\n        if k <= max_k:\n            return solution\n\ndef main():\n    solutions = []\n    for _ in range(int(input())):\n        (n, k) = read_numbers()\n        E = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = read_numbers()\n            u -= 1\n            v -= 1\n            E[u].append(v)\n            E[v].append(u)\n        solution = solve(n, E, k)\n        solutions.append(str(solution))\n    solutions = '\\n'.join(solutions)\n    output_line(solutions)\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom sys import stdin, stdout\nWHITE = 0\nGRAY = 1\nBLACK = 2\nread_numbers = lambda : list(map(int, stdin.readline().strip().split()))\noutput_line = lambda x: stdout.write(x)\n\ndef find_farthest_leaf(N, E, root=0):\n    color = [WHITE] * N\n    farthest_leaf = root\n    level = 0\n    max_level = 0\n    color[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if color[cur] == BLACK:\n            stack.pop()\n            level -= 1\n            continue\n        level += 1\n        if level >= max_level:\n            max_level = level\n            farthest_leaf = cur\n        for child in E[cur]:\n            if color[child] == BLACK:\n                continue\n            if color[child] == WHITE:\n                color[child] = GRAY\n                stack.append(child)\n        color[cur] = BLACK\n    return farthest_leaf\n\ndef search_strips(N, E, root):\n    color = [WHITE] * N\n    strips = [[] for _ in range(N)]\n    children = [[] for _ in range(N)]\n    leafs = [False] * N\n    color[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if color[cur] == BLACK:\n            stack.pop()\n            new_strips = []\n            for child in children[cur]:\n                if leafs[child]:\n                    new_strips += [1]\n                else:\n                    if len(strips[child]):\n                        strips[child][0] += 1\n                    new_strips += strips[child]\n            new_strips.sort(reverse=True)\n            strips[cur] = new_strips\n            continue\n        for child in E[cur]:\n            if color[child] == BLACK:\n                continue\n            if color[child] == WHITE:\n                color[child] = GRAY\n                stack.append(child)\n            children[cur].append(child)\n        leafs[cur] = False if children[cur] else True\n        color[cur] = BLACK\n    return strips[root]\n\ndef solve(N, E, k):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    farthest_leaf = find_farthest_leaf(N, E)\n    strips = search_strips(N, E, root=farthest_leaf)\n    max_k = 1\n    solution = 1\n    for strip in strips:\n        max_k += strip\n        solution += 1\n        if k <= max_k:\n            return solution\n\ndef main():\n    solutions = []\n    for _ in range(int(input())):\n        (n, k) = read_numbers()\n        E = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = read_numbers()\n            u -= 1\n            v -= 1\n            E[u].append(v)\n            E[v].append(u)\n        solution = solve(n, E, k)\n        solutions.append(str(solution))\n    solutions = '\\n'.join(solutions)\n    output_line(solutions)\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom sys import stdin, stdout\nWHITE = 0\nGRAY = 1\nBLACK = 2\nread_numbers = lambda : list(map(int, stdin.readline().strip().split()))\noutput_line = lambda x: stdout.write(x)\n\ndef find_farthest_leaf(N, E, root=0):\n    color = [WHITE] * N\n    farthest_leaf = root\n    level = 0\n    max_level = 0\n    color[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if color[cur] == BLACK:\n            stack.pop()\n            level -= 1\n            continue\n        level += 1\n        if level >= max_level:\n            max_level = level\n            farthest_leaf = cur\n        for child in E[cur]:\n            if color[child] == BLACK:\n                continue\n            if color[child] == WHITE:\n                color[child] = GRAY\n                stack.append(child)\n        color[cur] = BLACK\n    return farthest_leaf\n\ndef search_strips(N, E, root):\n    color = [WHITE] * N\n    strips = [[] for _ in range(N)]\n    children = [[] for _ in range(N)]\n    leafs = [False] * N\n    color[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if color[cur] == BLACK:\n            stack.pop()\n            new_strips = []\n            for child in children[cur]:\n                if leafs[child]:\n                    new_strips.extend([1])\n                else:\n                    any_strip = len(strips[child])\n                    if any_strip:\n                        strips[child][0] += 1\n                    new_strips += strips[child]\n            new_strips.sort(reverse=True)\n            strips[cur] = new_strips\n            continue\n        for child in E[cur]:\n            if color[child] == BLACK:\n                continue\n            if color[child] == WHITE:\n                color[child] = GRAY\n                stack.append(child)\n            children[cur].append(child)\n        leafs[cur] = False if children[cur] else True\n        color[cur] = BLACK\n    return strips[root]\n\ndef solve(N, E, k):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    farthest_leaf = find_farthest_leaf(N, E)\n    strips = search_strips(N, E, root=farthest_leaf)\n    max_k = 1\n    solution = 1\n    for strip in strips:\n        max_k += strip\n        solution += 1\n        if k <= max_k:\n            return solution\n\ndef main():\n    solutions = []\n    for _ in range(int(input())):\n        (n, k) = read_numbers()\n        E = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = read_numbers()\n            u -= 1\n            v -= 1\n            E[u].append(v)\n            E[v].append(u)\n        solution = solve(n, E, k)\n        solutions.append(str(solution))\n    solutions = '\\n'.join(solutions)\n    output_line(solutions)\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom sys import stdin, stdout\nWHITE = 0\nGRAY = 1\nBLACK = 2\nread_numbers = lambda : list(map(int, stdin.readline().strip().split()))\noutput_line = lambda x: stdout.write(x)\n\ndef find_farthest_leaf(N, E, root=0):\n    color = [WHITE] * N\n    farthest_leaf = root\n    level = 0\n    max_level = 0\n    color[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if color[cur] == BLACK:\n            stack.pop()\n            level -= 1\n            continue\n        level += 1\n        if level >= max_level:\n            max_level = level\n            farthest_leaf = cur\n        for child in E[cur]:\n            if color[child] == BLACK:\n                continue\n            if color[child] == WHITE:\n                color[child] = GRAY\n                stack.append(child)\n        color[cur] = BLACK\n    return farthest_leaf\n\ndef search_strips(N, E, root):\n    color = [WHITE] * N\n    strips = [[] for _ in range(N)]\n    children = [[] for _ in range(N)]\n    leafs = [False] * N\n    color[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if color[cur] == BLACK:\n            stack.pop()\n            new_strips = []\n            for child in children[cur]:\n                if leafs[child]:\n                    new_strips.extend([1])\n                else:\n                    any_strip = len(strips[child])\n                    if any_strip:\n                        strips[child][0] += 1\n                    new_strips += strips[child]\n            new_strips.sort(reverse=True)\n            strips[cur] = new_strips\n            continue\n        any_children = False\n        for child in E[cur]:\n            if color[child] == BLACK:\n                continue\n            if color[child] == WHITE:\n                color[child] = GRAY\n                stack.append(child)\n                any_children = True\n            children[cur].append(child)\n        leafs[cur] = False if any_children else True\n        color[cur] = BLACK\n    return strips[root]\n\ndef solve(N, E, k):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    farthest_leaf = find_farthest_leaf(N, E)\n    strips = search_strips(N, E, root=farthest_leaf)\n    max_k = 1\n    solution = 1\n    for strip in strips:\n        max_k += strip\n        solution += 1\n        if k <= max_k:\n            return solution\n\ndef main():\n    solutions = []\n    for _ in range(int(input())):\n        (n, k) = read_numbers()\n        E = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = read_numbers()\n            u -= 1\n            v -= 1\n            E[u].append(v)\n            E[v].append(u)\n        solution = solve(n, E, k)\n        solutions.append(str(solution))\n    solutions = '\\n'.join(solutions)\n    output_line(solutions)\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom sys import stdin, stdout\nWHITE = 0\nGRAY = 1\nBLACK = 2\nread_numbers = lambda : list(map(int, stdin.readline().strip().split()))\noutput_line = lambda x: stdout.write(x)\n\ndef find_farthest_leaf(N, E, root=0):\n    color = [WHITE] * N\n    parent = [0] * N\n    dist = [0] * N\n    max_dist = 0\n    farthest_leaf = root\n    color[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if color[cur] == BLACK:\n            stack.pop()\n            continue\n        for child in E[cur]:\n            if color[child] == BLACK:\n                continue\n            if color[child] == WHITE:\n                color[child] = GRAY\n                stack.append(child)\n                parent[child] = cur\n            dist[child] = dist[parent[child]] + 1\n            if dist[child] > max_dist:\n                (max_dist, farthest_leaf) = (dist[child], child)\n        color[cur] = BLACK\n    return farthest_leaf\n\ndef search_strips(N, E, root):\n    color = [WHITE] * N\n    strips = [[] for _ in range(N)]\n    children = [[] for _ in range(N)]\n    leafs = [False] * N\n    color[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if color[cur] == BLACK:\n            stack.pop()\n            new_strips = []\n            for child in children[cur]:\n                if leafs[child]:\n                    new_strips.extend([1])\n                else:\n                    any_strip = len(strips[child])\n                    if any_strip:\n                        strips[child][0] += 1\n                    new_strips += strips[child]\n            new_strips.sort(reverse=True)\n            strips[cur] = new_strips\n            continue\n        any_children = False\n        for child in E[cur]:\n            if color[child] == BLACK:\n                continue\n            if color[child] == WHITE:\n                color[child] = GRAY\n                stack.append(child)\n                any_children = True\n            children[cur].append(child)\n        leafs[cur] = False if any_children else True\n        color[cur] = BLACK\n    return strips[root]\n\ndef solve(N, E, k):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    farthest_leaf = find_farthest_leaf(N, E)\n    strips = search_strips(N, E, root=farthest_leaf)\n    max_k = 1\n    solution = 1\n    for strip in strips:\n        max_k += strip\n        solution += 1\n        if k <= max_k:\n            return solution\n\ndef main():\n    solutions = []\n    for _ in range(int(input())):\n        (n, k) = read_numbers()\n        E = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = read_numbers()\n            u -= 1\n            v -= 1\n            E[u].append(v)\n            E[v].append(u)\n        solution = solve(n, E, k)\n        solutions.append(str(solution))\n    solutions = '\\n'.join(solutions)\n    output_line(solutions)\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom collections import defaultdict\nfrom sys import stdin, stdout\nWHITE = 0\nGRAY = 1\nBLACK = 2\nread_numbers = lambda : list(map(int, stdin.readline().strip().split()))\noutput_line = lambda x: stdout.write(x)\n\ndef find_farthest_leaf(N, E, root=0):\n    color = [WHITE] * N\n    parent = [0] * N\n    dist = [0] * N\n    max_dist = 0\n    farthest_leaf = root\n    color[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if color[cur] == BLACK:\n            stack.pop()\n            continue\n        for child in E[cur]:\n            if color[child] == BLACK:\n                continue\n            if color[child] == WHITE:\n                color[child] = GRAY\n                stack.append(child)\n            parent[child] = cur\n            dist[child] = dist[parent[child]] + 1\n            if dist[child] > max_dist:\n                (max_dist, farthest_leaf) = (dist[child], child)\n        color[cur] = BLACK\n    return farthest_leaf\n\ndef search_strips(N, E, root):\n    m = [WHITE] * N\n    strips = [[] for _ in range(N)]\n    c = [[] for _ in range(N)]\n    leafs = [False] * N\n    m[root] = GRAY\n    stack = [root]\n    while stack:\n        cur = stack[-1]\n        if m[cur] == BLACK:\n            stack.pop()\n            new_d = []\n            for children in c[cur]:\n                if leafs[children]:\n                    new_d += [1]\n                else:\n                    if len(strips[children]) > 0:\n                        strips[children][0] += 1\n                    new_d += strips[children]\n            strips[cur] = new_d\n            strips[cur].sort(reverse=True)\n            continue\n        added = 0\n        for i in E[cur]:\n            if m[i] == WHITE:\n                m[i] = GRAY\n                stack.append(i)\n                added += 1\n            if m[i] != BLACK:\n                c[cur].append(i)\n        leafs[cur] = True if added == 0 else False\n        m[cur] = BLACK\n    return strips[root]\n\ndef solve(N, E, k):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    leaf = find_farthest_leaf(N, E)\n    strips = search_strips(N, E, root=leaf)\n    max_k = 1 + strips[0]\n    if k <= max_k:\n        return 2\n    solution = 2\n    for i in range(1, len(strips)):\n        max_k += strips[i]\n        solution += 1\n        if k <= max_k:\n            return solution\n\ndef main():\n    solutions = []\n    for _ in range(int(input())):\n        (n, k) = read_numbers()\n        E = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = read_numbers()\n            u -= 1\n            v -= 1\n            E[u].append(v)\n            E[v].append(u)\n        solution = solve(n, E, k)\n        solutions.append(str(solution))\n    solutions = '\\n'.join(solutions)\n    output_line(solutions)\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom collections import defaultdict\nfrom sys import stdin, stdout\nWHITE = 0\nGRAY = 1\nBLACK = 2\nread_numbers = lambda : list(map(int, stdin.readline().strip().split()))\noutput_line = lambda x: stdout.write(x)\n\ndef find_leaf(N, E, root=0):\n    m = [WHITE] * N\n    m[root] = GRAY\n    s = [root]\n    p = [0] * N\n    d = [0] * N\n    max_dist = 0\n    max_index = 0\n    while len(s):\n        cur = s[-1]\n        if m[cur] == BLACK:\n            s.pop()\n            continue\n        for i in E[cur]:\n            if m[i] == WHITE:\n                m[i] = GRAY\n                s.append(i)\n                p[i] = cur\n            if m[i] != BLACK:\n                d[i] = d[p[i]] + 1\n                if d[i] > max_dist:\n                    max_dist = d[i]\n                    max_index = i\n        m[cur] = BLACK\n    return max_index\n\ndef search(N, E, root):\n    m = [WHITE] * N\n    m[root] = GRAY\n    s = [root]\n    p = [0] * N\n    d = [[] for _ in range(N)]\n    c = [[] for _ in range(N)]\n    leafs = [False] * N\n    while len(s):\n        cur = s[-1]\n        if m[cur] == BLACK:\n            s.pop()\n            new_d = []\n            for children in c[cur]:\n                if leafs[children]:\n                    new_d += [1]\n                else:\n                    if len(d[children]) > 0:\n                        d[children][0] += 1\n                    new_d += d[children]\n            d[cur] = new_d\n            d[cur].sort(reverse=True)\n            continue\n        added = 0\n        for i in E[cur]:\n            if m[i] == WHITE:\n                m[i] = GRAY\n                s.append(i)\n                added += 1\n                p[i] = cur\n            if m[i] != BLACK:\n                c[cur].append(i)\n        leafs[cur] = True if added == 0 else False\n        m[cur] = BLACK\n    return d[root]\n\ndef solve(N, E, k):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    root = find_leaf(N, E)\n    d = search(N, E, root)\n    max_k = 1 + d[0]\n    if k <= max_k:\n        return 2\n    s = 2\n    for i in range(1, len(d)):\n        max_k += d[i]\n        s += 1\n        if k <= max_k:\n            return s\n\ndef main():\n    solutions = []\n    for _ in range(int(input())):\n        (n, k) = read_numbers()\n        E = defaultdict(list)\n        for _ in range(n - 1):\n            (u, v) = read_numbers()\n            u -= 1\n            v -= 1\n            E[u].append(v)\n            E[v].append(u)\n        solutions.append(str(solve(n, E, k)))\n    solutions = '\\n'.join(solutions)\n    output_line(solutions)\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom sys import stdin, stdout\nWHITE = 0\nGRAY = 1\nBLACK = 2\nread_numbers = lambda : list(map(int, stdin.readline().strip().split()))\noutput_line = lambda x: stdout.write(x)\n\ndef find_leaf(N, E, root=0):\n    m = [WHITE] * N\n    m[root] = GRAY\n    s = [root]\n    p = [0] * N\n    d = [0] * N\n    max_dist = 0\n    max_index = 0\n    while len(s):\n        cur = s[-1]\n        if m[cur] == BLACK:\n            s.pop()\n            continue\n        for i in E[cur]:\n            if m[i] == WHITE:\n                m[i] = GRAY\n                s.append(i)\n                p[i] = cur\n            if m[i] != BLACK:\n                d[i] = d[p[i]] + 1\n                if d[i] > max_dist:\n                    max_dist = d[i]\n                    max_index = i\n        m[cur] = BLACK\n    return max_index\n\ndef search(N, E, root):\n    m = [WHITE] * N\n    m[root] = GRAY\n    s = [root]\n    p = [0] * N\n    d = [[] for _ in range(N)]\n    c = [[] for _ in range(N)]\n    leafs = [False] * N\n    while len(s):\n        cur = s[-1]\n        if m[cur] == BLACK:\n            s.pop()\n            new_d = []\n            for children in c[cur]:\n                if leafs[children]:\n                    new_d += [1]\n                else:\n                    if len(d[children]) > 0:\n                        d[children][0] += 1\n                    new_d += d[children]\n            d[cur] = new_d\n            d[cur].sort(reverse=True)\n            continue\n        added = 0\n        for i in E[cur]:\n            if m[i] == WHITE:\n                m[i] = GRAY\n                s.append(i)\n                added += 1\n                p[i] = cur\n            if m[i] != BLACK:\n                c[cur].append(i)\n        leafs[cur] = True if added == 0 else False\n        m[cur] = BLACK\n    return d[root]\n\ndef solve(N, E, k):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    root = find_leaf(N, E)\n    d = search(N, E, root)\n    max_k = 1 + d[0]\n    if k <= max_k:\n        return 2\n    s = 2\n    for i in range(1, len(d)):\n        max_k += d[i]\n        s += 1\n        if k <= max_k:\n            return s\n    return len(d)\n\ndef main():\n    solutions = []\n    for _ in range(int(input())):\n        (n, k) = read_numbers()\n        E = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = read_numbers()\n            u -= 1\n            v -= 1\n            E[u].append(v)\n            E[v].append(u)\n        solutions.append(str(solve(n, E, k)))\n    solutions = '\\n'.join(solutions)\n    output_line(solutions)\nmain()", "def ConstructTree(AdjList, vertex):\n    n = len(AdjList) - 1\n    Colour = [0] * (n + 1)\n    ToExplore = [0]\n    Colour[0] = 1\n    ToExplore.append(vertex)\n    Colour[vertex] = 1\n    pos = 1\n    while pos <= n:\n        node = ToExplore[pos]\n        Colour[node] = 1\n        pos += 1\n        for u in AdjList[node]:\n            if Colour[u] == 0:\n                ToExplore.append(u)\n    InfoList = [-1] * (n + 1)\n    for i in range(n, -1, -1):\n        node = ToExplore[i]\n        height_below = 0\n        child = 0\n        for u in AdjList[node]:\n            if InfoList[u] > height_below:\n                height_below = InfoList[u]\n                child = u\n        InfoList[node] = height_below + 1\n        InfoList[child] = -1\n    a = 0\n    b = n\n    while a < b:\n        if InfoList[a] == -1:\n            if InfoList[b] != -1:\n                InfoList[a] = InfoList[b]\n                InfoList[b] = -1\n                a += 1\n            b -= 1\n        else:\n            a += 1\n    if InfoList[a] == -1:\n        a -= 1\n    return InfoList[:a + 1]\n\ndef DiameterEnds(AdjList):\n    l = len(AdjList)\n    Colour = [0] * l\n    ToExplore = []\n    ToExplore.append(1)\n    index = 1\n    while len(ToExplore) != 0:\n        node = ToExplore.pop(0)\n        Colour[node] = 1\n        index = node\n        for u in AdjList[node]:\n            if Colour[u] == 0:\n                ToExplore.append(u)\n    return index\n\ndef MinimumSubSetCover():\n    (n, req) = list(map(int, input().split()))\n    TreeRepresentation = []\n    for _ in range(n + 1):\n        TreeRepresentation.append([])\n    for _ in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        TreeRepresentation[u].append(v)\n        TreeRepresentation[v].append(u)\n    if req == 1:\n        return 1\n    elif req == 2 or req == 3:\n        return 2\n    root = DiameterEnds(TreeRepresentation)\n    RootedTree = ConstructTree(TreeRepresentation, root)\n    RootedTree.sort(reverse=True)\n    count = 1\n    while req > 0:\n        req -= RootedTree.pop(0)\n        count += 1\n    return count\ntestCases = int(input())\nfor _ in range(testCases):\n    print(MinimumSubSetCover())", "def ConstructTree(AdjList, vertex):\n    n = len(AdjList) - 1\n    Colour = [0] * (n + 1)\n    ToExplore = [0]\n    Colour[0] = 1\n    ToExplore.append(vertex)\n    Colour[vertex] = 1\n    pos = 1\n    while pos <= n:\n        node = ToExplore[pos]\n        Colour[node] = 1\n        pos += 1\n        for u in AdjList[node]:\n            if Colour[u] == 0:\n                ToExplore.append(u)\n    InfoList = [-1] * (n + 1)\n    for i in range(n, -1, -1):\n        node = ToExplore[i]\n        height_below = 0\n        child = 0\n        for u in AdjList[node]:\n            if InfoList[u] > height_below:\n                height_below = InfoList[u]\n                child = u\n        InfoList[node] = height_below + 1\n        InfoList[child] = -1\n    newInfoList = []\n    for i in range(n + 1):\n        if InfoList[i] != -1:\n            newInfoList.append(InfoList[i])\n    return newInfoList\n\ndef DiameterEnds(AdjList):\n    l = len(AdjList)\n    Colour = [0] * l\n    ToExplore = []\n    ToExplore.append(1)\n    index = 1\n    while len(ToExplore) != 0:\n        node = ToExplore.pop(0)\n        Colour[node] = 1\n        index = node\n        for u in AdjList[node]:\n            if Colour[u] == 0:\n                ToExplore.append(u)\n    return index\n\ndef MinimumSubSetCover():\n    (n, req) = list(map(int, input().split()))\n    TreeRepresentation = []\n    for _ in range(n + 1):\n        TreeRepresentation.append([])\n    for _ in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        TreeRepresentation[u].append(v)\n        TreeRepresentation[v].append(u)\n    if req == 1:\n        return 1\n    elif req == 2 or req == 3:\n        return 2\n    root = DiameterEnds(TreeRepresentation)\n    RootedTree = ConstructTree(TreeRepresentation, root)\n    RootedTree.sort(reverse=True)\n    count = 1\n    while req > 0:\n        req -= RootedTree.pop(0)\n        count += 1\n    return count\ntestCases = int(input())\nfor _ in range(testCases):\n    print(MinimumSubSetCover())", "from collections import deque, Counter\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef helper(my_node):\n    visited = [False for i in range(n)]\n    depth = [0 for i in range(n)]\n    max_depth(my_node, visited, depth)\n    return depth\n\ndef max_depth(my_node, visited, depth):\n    curr_depth = 0\n    visited[my_node] = True\n    q = []\n    for i in G[my_node]:\n        if visited[i] == False:\n            visited[i] = True\n            q.append(i)\n    for i in q:\n        curr_depth = max(max_depth(i, visited, depth), curr_depth)\n    depth[my_node] = curr_depth + 1\n    return curr_depth + 1\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    G = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    if k == 1:\n        print(1)\n    else:\n        max_dist = -1\n        max_node = -1\n        visited = [False for i in range(n)]\n        visited[0] = True\n        q = deque()\n        q.append((0, 0))\n        while len(q) > 0:\n            curr = q.popleft()\n            curr_node = curr[0]\n            curr_dist = curr[1]\n            if curr_dist > max_dist:\n                max_node = curr_node\n                max_dist = curr_dist\n            for i in range(len(G[curr_node])):\n                if visited[G[curr_node][i]] == False:\n                    visited[G[curr_node][i]] = True\n                    q.append((G[curr_node][i], curr_dist + 1))\n        depth = helper(max_node)\n        cc = Counter(depth)\n        c = 0\n        ans = 1\n        for i in range(n, -1, -1):\n            br = False\n            temp = cc[i] - cc[i + 1]\n            for j in range(temp):\n                ans += 1\n                c += i\n                if c >= k:\n                    br = True\n                    break\n            if br:\n                break\n        print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFarthesting(node, gr, n1):\n    do = [False] * (n1 + 1)\n    fdrr = -1\n    dur = None\n    que = [(node, 0)]\n    do[node] = True\n    while que:\n        (nod, dis) = que.pop(0)\n        if fdrr < dis:\n            fdrr = dis\n            dur = nod\n        for cnod in gr[nod]:\n            if do[cnod]:\n                continue\n            do[cnod] = True\n            que.append((cnod, dis + 1))\n    return dur\n\ndef fixedHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixedHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n1, cur):\n    H = [0] * (n1 + 1)\n    fixedHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOLUTION(gr, n1, k):\n    if k == 1:\n        return 1\n    u = getFarthesting(1, gr, n1)\n    li = []\n    breakIntoLines(u, 0, gr, li, n1, 1)\n    li.sort(reverse=True)\n    size1 = 1\n    total1 = 0\n    i = 0\n    while total1 < k:\n        size1 += 1\n        total1 += li[i]\n        i += 1\n    return size1\nfor case in range(int(input())):\n    (n1, k) = map(int, input().split())\n    gr = [[] for i in range(n1 + 1)]\n    for i in range(n1 - 1):\n        (u1, v1) = map(int, input().split())\n        gr[u1].append(v1)\n        gr[v1].append(u1)\n    chap = GETSOLUTION(gr, n1, k)\n    print(chap)", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom collections import defaultdict\nfrom sys import stdin, stdout\nimport operator\nWHITE = 0\nGRAY = 1\nBLACK = 2\n\ndef find_leaf(N, E, root=0):\n    m = [WHITE] * N\n    m[root] = GRAY\n    s = [root]\n    p = [0] * N\n    d = [0] * N\n    max_dist = 0\n    max_index = 0\n    while len(s):\n        cur = s[-1]\n        if m[cur] == BLACK:\n            s.pop()\n            continue\n        for i in E[cur]:\n            if m[i] == WHITE:\n                m[i] = GRAY\n                s.append(i)\n                p[i] = cur\n            if m[i] != BLACK:\n                d[i] = d[p[i]] + 1\n                if d[i] > max_dist:\n                    max_dist = d[i]\n                    max_index = i\n        m[cur] = BLACK\n    return max_index\n\ndef search(N, E, root):\n    m = [WHITE] * N\n    m[root] = GRAY\n    s = [root]\n    p = [0] * N\n    d = [[] for _ in range(N)]\n    c = [[] for _ in range(N)]\n    leafs = [False] * N\n    while len(s):\n        cur = s[-1]\n        if m[cur] == BLACK:\n            s.pop()\n            new_d = []\n            for children in c[cur]:\n                if leafs[children]:\n                    new_d += [1]\n                else:\n                    if len(d[children]) > 0:\n                        d[children][-1] += 1\n                    new_d += d[children]\n            d[cur] = new_d\n            d[cur].sort()\n            continue\n        added = 0\n        for i in E[cur]:\n            if m[i] == WHITE:\n                m[i] = GRAY\n                s.append(i)\n                added += 1\n                p[i] = cur\n            if m[i] != BLACK:\n                c[cur].append(i)\n        leafs[cur] = True if added == 0 else False\n        m[cur] = BLACK\n    return d[root]\n\ndef solve(N, E, k):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    root = find_leaf(N, E)\n    d = search(N, E, root)\n    d.sort(reverse=True)\n    max_k = 1 + d[0]\n    if k <= max_k:\n        return 2\n    s = 2\n    for i in range(1, len(d)):\n        max_k += d[i]\n        s += 1\n        if k <= max_k:\n            return s\n    return len(d)\n\ndef main():\n    solutions = []\n    for _ in range(int(input())):\n        (n, k) = list(map(int, stdin.readline().strip().split()))\n        E = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = list(map(int, stdin.readline().strip().split()))\n            u -= 1\n            v -= 1\n            E[u].append(v)\n            E[v].append(u)\n        solutions.append(str(solve(n, E, k)))\n    stdout.write('\\n'.join(solutions))\nmain()", "import sys\ntry:\n    sys.stdin = open('inputf.in', 'r')\n    sys.stdout = open('outputf.in', 'w')\nexcept:\n    pass\nfrom itertools import permutations, combinations\nimport heapq\nfrom collections import OrderedDict\nimport bisect\nfrom functools import cmp_to_key\nfrom collections import deque\nimport string\nfrom collections import Counter\nfrom collections import defaultdict\nfrom math import sqrt\nfrom queue import PriorityQueue\nimport sys\nfrom bisect import bisect_left, bisect_right\nMOD = 1000000007\nsys.setrecursionlimit(100000)\n\ndef ii():\n    return int(sys.stdin.readline().strip())\n\ndef si():\n    return sys.stdin.readline().strip()\n\ndef li():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef mi():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef dparr(m, n):\n    return [[0] * n for i in range(m)]\n\ndef disdp(dp):\n    for i in dp:\n        print(*i)\n\ndef gai(i):\n    return ord(i) - ord('a')\n\ndef dij(graph, src):\n    dis = [float('inf')] * (len(graph) + 1)\n    dis[src] = 0\n    q = deque()\n    q.append(src)\n    while len(q) > 0:\n        x = q.popleft()\n        for i in graph[x]:\n            if dis[x] + 1 < dis[i]:\n                dis[i] = min(dis[x] + 1, dis[i])\n                q.append(i)\n    return dis\n\ndef nsel(arr):\n    pre = []\n    st = [-1]\n    for i in range(len(arr)):\n        while len(st) > 0 and arr[i] <= arr[st[-1]]:\n            st.pop()\n        if len(st) == 0:\n            pre.append(-1)\n        else:\n            pre.append(st[-1])\n        st.append(i)\n    return pre\n\ndef nser(arr):\n    pre = []\n    st = [-1]\n    for i in range(len(arr) - 1, -1, -1):\n        while len(st) > 0 and arr[i] <= arr[st[-1]]:\n            st.pop()\n        if len(st) == 0:\n            pre.append(-1)\n        else:\n            pre.append(st[-1])\n        st.append(i)\n    return pre[::-1]\n\ndef getarea(arr):\n    left = nsel(arr)\n    right = nser(arr)\n    n = len(arr)\n    mx = 0\n    print(left, right)\n    for i in range(len(arr)):\n        if left[i] == -1 and right[i] == -1:\n            mx = max(mx, arr[i] * n)\n        elif left[i] == -1 and right[i] != -1:\n            mx = max(mx, arr[i] * right[i])\n        elif left[i] != -1 and right[i] == -1:\n            mx = max(mx, arr[i] * (n - left[i] - 1))\n        else:\n            mx = max(mx, arr[i] * (right[i] - left[i] - 1))\n        print(mx)\n    return mx\n\ndef func(nums, k):\n    precnt = [1 if nums[0] % 2 != 0 else 0]\n    n = len(nums)\n    for i in range(1, n):\n        if nums[i] % 2 != 0:\n            precnt.append(1 + precnt[-1])\n        else:\n            precnt.append(precnt[-1])\n    dp = {}\n    dp[0] = 1\n    ans = 0\n    for i in range(n):\n        if precnt[i] >= k:\n            try:\n                ans += dp[precnt[i] - k]\n            except:\n                pass\n        try:\n            dp[precnt[i]] += 1\n        except:\n            dp[precnt[i]] = 1\n    print(ans)\n\ndef bfs(tree, n, node):\n    vis = [False] * (n + 1)\n    vis[node] = True\n    q = deque()\n    dist = [-1] * (n + 1)\n    dist[node] = 0\n    q.append(node)\n    while len(q) > 0:\n        x = q.popleft()\n        for i in tree[x]:\n            if vis[i] == False:\n                dist[i] = dist[x] + 1\n                vis[i] = True\n                q.append(i)\n    enddist = max(dist)\n    endnode = dist.index(enddist)\n    return (endnode, enddist)\ndep = []\nvis = []\n\ndef depth(tree, parent, start):\n    if vis[start]:\n        return 0\n    vis[start] = True\n    if tree[start] == []:\n        dep[start] = 0\n        return 0\n    elif len(tree[start]) == 1 and tree[start][0] == parent:\n        return 0\n    else:\n        md = 0\n        for i in tree[start]:\n            if i != start:\n                md = max(md, depth(tree, start, i))\n        dep[start] = md + 1\n        return md + 1\nfinal = {}\n\ndef get_path(tree, md, x, y, path):\n    if vis[x]:\n        return\n    vis[x] = True\n    if len(path) + 1 == md:\n        final['path'] = path + [x]\n        return\n    for i in tree[x]:\n        get_path(tree, md, i, y, path + [x])\nt = ii()\nfor _ in range(t):\n    (n, k) = mi()\n    tree = {}\n    for i in range(1, n + 1):\n        tree[i] = []\n    for i in range(n - 1):\n        (u, v) = mi()\n        tree[u].append(v)\n        tree[v].append(u)\n    if k == 1:\n        print(1)\n    else:\n        (start, startdist) = bfs(tree, n, 1)\n        (end, enddist) = bfs(tree, n, start)\n        dep = [0] * (n + 1)\n        vis = [False] * (n + 1)\n        depth(tree, -1, start)\n        vis = [False] * (n + 1)\n        final = {}\n        get_path(tree, max(dep) + 1, start, end, [])\n        path = final['path']\n        vispath = set(path)\n        if k <= len(path):\n            print(2)\n        else:\n            ans = 2\n            currnode = len(path)\n            dpdep = Counter()\n            x = 0\n            for i in range(n + 1):\n                dpdep[i] = 0\n            for i in range(1, len(dep)):\n                if i in vispath:\n                    continue\n                dpdep[dep[i]] += 1\n            for i in range(n + 1, -1, -1):\n                temp = dpdep[i] - x\n                b = False\n                for j in range(temp):\n                    ans += 1\n                    currnode += i + 1\n                    if currnode >= k:\n                        b = True\n                        break\n                if b:\n                    break\n                x += temp\n            print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef dfs(a, b, c, d, e, f):\n    temp1 = True\n    out = 0\n    for i in c[a]:\n        if i == b:\n            continue\n        temp1 = False\n        out = max(out, d[i])\n    if temp1:\n        e.append(f)\n        return\n    c1 = 0\n    for i in c[a]:\n        if i == b:\n            continue\n        if d[i] == out and c1 == 0:\n            dfs(i, a, c, d, e, f + 1)\n            c1 += 1\n        else:\n            dfs(i, a, c, d, e, 1)\n\ndef h(a, b, c, d):\n    temp1 = True\n    for i in c[a]:\n        if i == b:\n            continue\n        temp1 = False\n        h(i, a, c, d)\n        d[a] = max(d[a], 1 + d[i])\n    if temp1:\n        d[a] = 1\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    temp = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        temp[u].append(v)\n        temp[v].append(u)\n    if k == 1:\n        print(1)\n    else:\n        flag = [False] * (n + 1)\n        flag[1] = True\n        sub = [(1, 0)]\n        last = None\n        neg = -1\n        while sub:\n            (a, b) = sub.pop(0)\n            if neg < b:\n                neg = b\n                last = a\n            for k1 in temp[a]:\n                if flag[k1]:\n                    continue\n                flag[k1] = True\n                sub.append((k1, b + 1))\n        arr = []\n        H = [0] * (n + 1)\n        h(last, 0, temp, H)\n        dfs(last, 0, temp, H, arr, 1)\n        arr.sort(reverse=True)\n        ans = 1\n        (t1, t2) = (0, 0)\n        while t1 < k:\n            ans += 1\n            t1 += arr[t2]\n            t2 += 1\n        print(ans)", "import sys\nimport math\nfrom collections import *\nfrom queue import *\nfrom bisect import *\nsys.setrecursionlimit(10 ** 5)\nMOD = int(1000000000.0 + 7)\ninf = float('inf')\nninf = float('-inf')\ninput = sys.stdin.readline\n\ndef ii():\n    return list(map(int, input().strip().split()))\n(G, H, li) = ([], [], [])\n\ndef getFar(node, n):\n    vis = [False for k in range(n + 1)]\n    (vis[node], far) = (True, 1)\n    qu = Queue()\n    qu.put(far)\n    while not qu.empty():\n        parentIndex = qu.get()\n        for itrNode in G[parentIndex]:\n            if not vis[itrNode]:\n                vis[itrNode] = True\n                qu.put(itrNode)\n                far = itrNode\n    return far\n\ndef f(node, parent, current, maxm):\n    c = False\n    for itrNode in G[node]:\n        if itrNode != parent:\n            if H[itrNode] == maxm and c == False:\n                dfs(itrNode, node, current + 1)\n                c = True\n            else:\n                dfs(itrNode, node, 1)\n\ndef dfs(nod, parent, current):\n    (checkLeaf, maxm) = (True, 0)\n    for itrNode in G[nod]:\n        if itrNode != parent:\n            (checkLeaf, maxm) = (False, max(maxm, H[itrNode]))\n    if checkLeaf:\n        li.append(current)\n        return\n    else:\n        f(nod, parent, current, maxm)\n\ndef fixHeight(nod, parent):\n    checkLeaf = True\n    for itrNode in G[nod]:\n        if itrNode != parent:\n            checkLeaf = False\n            fixHeight(itrNode, nod)\n            H[nod] = max(H[nod], 1 + H[itrNode])\n    if checkLeaf:\n        H[nod] = 1\n\ndef breakIntoLines(nod, parent, n):\n    fixHeight(nod, parent)\n    dfs(nod, parent, 1)\n\ndef getSol(n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, n)\n    (size, total, i) = (1, 0, 0)\n    breakIntoLines(u, 0, n)\n    li.sort(reverse=True)\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor _ in range(int(input())):\n    (n, k) = ii()\n    G = [[] for j in range(n + 1)]\n    for j in range(n - 1):\n        (u, v) = ii()\n        G[u].append(v)\n        G[v].append(u)\n    H = [0] * (n + 1)\n    print(getSol(n, k))\n    G.clear()\n    H.clear()\n    li.clear()", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef breakIntoLines(nod, par, G, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, G, H)\n    dfs(nod, par, G, H, li, 1)\n\ndef getFar(node, G, n):\n    visited = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    visited[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in G[nod]:\n            if visited[cnod]:\n                continue\n            visited[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, G, H):\n    isleaf = True\n    for cnod in G[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, G, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, G, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in G[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in G[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, G, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, G, H, li, 1)\ntt = int(input())\nfor _ in range(tt):\n    (n, k) = map(int, input().split())\n    G = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        G[u].append(v)\n        G[v].append(u)\n    if k == 1:\n        print(1)\n        continue\n    u = getFar(1, G, n)\n    li = []\n    breakIntoLines(u, 0, G, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    print(size)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef atLast(vert, adj, n):\n    q = n\n    while q < n:\n        pass\n\ndef getLast(vert, adj, n):\n    ok = [False] * (n + 1)\n    ld = -1\n    dist = None\n    qu = [(vert, 0)]\n    ok[vert] = True\n    while qu:\n        (cod, dis) = qu.pop(0)\n        if ld < dis:\n            ld = dis\n            dist = cod\n        for ver in adj[cod]:\n            if ok[ver]:\n                continue\n            ok[ver] = True\n            qu.append((ver, dis + 1))\n    return dist\n\ndef atH(cod, par, adj, H):\n    leaf = True\n    for ver in adj[cod]:\n        if ver == par:\n            continue\n        leaf = False\n        atH(ver, cod, adj, H)\n        H[cod] = max(H[cod], 1 + H[ver])\n    if leaf:\n        H[cod] = 1\n\ndef atFirst(cod, par):\n    if cod > 10:\n        n = cod\n        while n < par:\n            n << 1\n\ndef dfs(cod, par, adj, H, li, cur):\n    leaf = True\n    mx = 0\n    for ver in adj[cod]:\n        if ver == par:\n            continue\n        leaf = False\n        mx = max(mx, H[ver])\n    if leaf:\n        li.append(cur)\n        return\n    c = 0\n    for ver in adj[cod]:\n        if ver == par:\n            continue\n        if H[ver] == mx and c == 0:\n            dfs(ver, cod, adj, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(ver, cod, adj, H, li, 1)\n\ndef getLine(cod, par, adj, li, n, cur):\n    H = [0] * (n + 1)\n    atH(cod, par, adj, H)\n    dfs(cod, par, adj, H, li, 1)\n\ndef solve(adj, n, k):\n    if k == 1:\n        atFirst(10, 5)\n        return 1\n    u = getLast(1, adj, n)\n    li = []\n    getLine(u, 0, adj, li, n, 1)\n    li.sort(reverse=True)\n    len = 1\n    sum = 0\n    i = 0\n    while sum < k:\n        len += 1\n        sum += li[i]\n        i += 1\n    return len\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    ans = solve(adj, n, k)\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFarthest(node, getright, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in getright[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef correctHeight(nod, par, getright, height):\n    isleaf = True\n    for cnod in getright[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        correctHeight(cnod, nod, getright, height)\n        height[nod] = max(height[nod], 1 + height[cnod])\n    if isleaf:\n        height[nod] = 1\n\ndef dfs(nod, par, getright, height, leaf, curentNode):\n    isleaf = True\n    mx = 0\n    for cnod in getright[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, height[cnod])\n    if isleaf:\n        leaf.append(curentNode)\n        return\n    c = 0\n    for cnod in getright[nod]:\n        if cnod == par:\n            continue\n        if height[cnod] == mx and c == 0:\n            dfs(cnod, nod, getright, height, leaf, curentNode + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, getright, height, leaf, 1)\n\ndef convertintolevels(nod, par, getright, leaf, n, curentNode):\n    height = [0] * (n + 1)\n    correctHeight(nod, par, getright, height)\n    dfs(nod, par, getright, height, leaf, 1)\n\ndef minimumsubtreecover(getright, n, k):\n    if k == 1:\n        return 1\n    u = getFarthest(1, getright, n)\n    leaf = []\n    convertintolevels(u, 0, getright, leaf, n, 1)\n    leaf.sort(reverse=True)\n    size = 1\n    totalsum = 0\n    i = 0\n    while totalsum < k:\n        size += 1\n        totalsum += leaf[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    getright = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        getright[u].append(v)\n        getright[v].append(u)\n    finalans = minimumsubtreecover(getright, n, k)\n    print(finalans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getData(node1, gr, n):\n    arr = [False] * (n + 1)\n    x = -1\n    far = None\n    q = [(node1, 0)]\n    arr[node1] = True\n    while q:\n        (node2, dis) = q.pop(0)\n        if x < dis:\n            x = dis\n            far = node2\n        for cnod in gr[node2]:\n            if arr[cnod]:\n                continue\n            arr[cnod] = True\n            q.append((cnod, dis + 1))\n    return far\n\ndef getData2(node, par, gr, H):\n    isleaf = True\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        getData2(cnod, node, gr, H)\n        H[node] = max(H[node], 1 + H[cnod])\n    if isleaf:\n        H[node] = 1\n\ndef dfs(node, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, node, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, node, gr, H, li, 1)\n\ndef getLines(node, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    getData2(node, par, gr, H)\n    dfs(node, par, gr, H, li, 1)\n\ndef getData3(gr, n, k):\n    if k == 1:\n        return 1\n    u = getData(1, gr, n)\n    li = []\n    getLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    min_subset = getData3(gr, n, k)\n    print(min_subset)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getData(node1, gr, n):\n    arr = [False] * (n + 1)\n    x = -1\n    far = None\n    q = [(node1, 0)]\n    arr[node1] = True\n    while q:\n        (node2, dis) = q.pop(0)\n        if x < dis:\n            x = dis\n            far = node2\n        for cnod in gr[node2]:\n            if arr[cnod]:\n                continue\n            arr[cnod] = True\n            q.append((cnod, dis + 1))\n    return far\n\ndef getData2(node, par, gr, H):\n    isleaf = True\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        getData2(cnod, node, gr, H)\n        H[node] = max(H[node], 1 + H[cnod])\n    if isleaf:\n        H[node] = 1\n\ndef dfs(node, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, node, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, node, gr, H, li, 1)\n\ndef getLines(node, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    getData2(node, par, gr, H)\n    dfs(node, par, gr, H, li, 1)\n\ndef getData3(gr, n, k):\n    if k == 1:\n        return 1\n    u = getData(1, gr, n)\n    li = []\n    getLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    min_subset = getData3(gr, n, k)\n    print(min_subset)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\nimport copy\n\ndef dfs(start, points, visited, subtree_nodes):\n    visited[start] = True\n    for i in points[start]:\n        if not visited[i]:\n            subtree_nodes[start] = max(subtree_nodes[start], dfs(i, points, visited, subtree_nodes))\n    subtree_nodes[start] += 1\n    return subtree_nodes[start]\n\ndef dfs2(start, top_node, points, visited, subtree_nodes, counter, ans_list):\n    visited[start] = True\n    if subtree_nodes[start] == 1 and start != top_node:\n        ans_list.append(counter)\n        return None\n    correct_neighbour = -1\n    correct_sum = -1\n    for i in points[start]:\n        if not visited[i]:\n            if subtree_nodes[i] > correct_sum:\n                correct_neighbour = i\n                correct_sum = subtree_nodes[i]\n    dfs2(correct_neighbour, top_node, points, visited, subtree_nodes, counter + 1, ans_list)\n    for i in points[start]:\n        if not visited[i] and i != correct_neighbour:\n            dfs2(i, top_node, points, visited, subtree_nodes, 1, ans_list)\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    points = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = [int(i) for i in input().split()]\n        points[u - 1].append(v - 1)\n        points[v - 1].append(u - 1)\n    if k == 1:\n        print(1)\n        continue\n    points2 = copy.deepcopy(points)\n    stack = []\n    visited = [False for i in range(n)]\n    stack.append(0)\n    visited[0] = True\n    top_node = 0\n    max_height = 1\n    while stack:\n        current = stack[-1]\n        if points[current]:\n            neighbour = points[current].pop()\n            if not visited[neighbour]:\n                stack.append(neighbour)\n                visited[neighbour] = True\n                if len(stack) > max_height:\n                    max_height = len(stack)\n                    top_node = stack[-1]\n        else:\n            stack.pop()\n    subtree_nodes = [0 for i in range(n)]\n    visited = [False for i in range(n)]\n    dfs(top_node, points2, visited, subtree_nodes)\n    if subtree_nodes[top_node] >= k:\n        print(2)\n        continue\n    ans_list = []\n    visited = [False for i in range(n)]\n    dfs2(top_node, top_node, points2, visited, subtree_nodes, 1, ans_list)\n    ans_list.sort(reverse=True)\n    sum_ = 0\n    for i in range(len(ans_list)):\n        sum_ += ans_list[i]\n        if sum_ >= k:\n            print(i + 2)\n            break", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef dfs(a, b, y, arr2, arr3, n1):\n    check = True\n    tmp_var = 0\n    for j in y[a]:\n        if j == b:\n            continue\n        check = False\n        tmp_var = max(tmp_var, arr2[j])\n    if check:\n        arr3.append(n1)\n        return\n    tmp = 0\n    for j in y[a]:\n        if j == b:\n            continue\n        if tmp == 0 and arr2[j] == tmp_var:\n            dfs(j, a, y, arr2, arr3, n1 + 1)\n            tmp = tmp + 1\n        else:\n            dfs(j, a, y, arr2, arr3, 1)\n\ndef ver_edg(a, b, arr2, y):\n    check = True\n    for j in y[a]:\n        if j == b:\n            continue\n        check = False\n        ver_edg(j, a, arr2, y)\n        arr2[a] = max(arr2[j] + 1, arr2[a])\n    if check:\n        arr2[a] = 1\n\ndef calculate(a, b, y, arr3, z, n1):\n    arr2 = [0] * (z + 1)\n    ver_edg(a, b, arr2, y)\n    dfs(a, b, y, arr2, arr3, 1)\n\ndef solve1(x, y, z):\n    arr1 = [False] * (z + 1)\n    x1 = -1\n    y1 = None\n    z1 = [(x, 0)]\n    arr1[x] = True\n    while z1:\n        (a, x2) = z1.pop(0)\n        if x1 < x2:\n            x1 = x2\n            y1 = a\n        for j in y[a]:\n            if arr1[j]:\n                continue\n            arr1[j] = True\n            z1.append((j, x2 + 1))\n    return y1\n\ndef solve(y, z, temp):\n    if temp == 1:\n        return 1\n    inp = solve1(1, y, z)\n    arr3 = []\n    calculate(inp, 0, y, arr3, z, 1)\n    arr3.sort(reverse=True)\n    t1 = 1\n    t2 = 0\n    i = 0\n    while t2 < temp:\n        t1 = t1 + 1\n        t2 = t2 + arr3[i]\n        i = i + 1\n    return t1\nfor ii in range(int(input())):\n    (z, temp) = map(int, input().split())\n    y = [[] for i in range(z + 1)]\n    for i in range(z - 1):\n        (inp, v) = map(int, input().split())\n        y[inp].append(v)\n        y[v].append(inp)\n    result = solve(y, z, temp)\n    print(result)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(100000000)\n\ndef minimum_subtree_cover():\n    (n, k) = map(int, input().split())\n    tree = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        addEdge(tree, u, v)\n    ans = calc_min_size_subset(tree, n, k)\n    print(ans)\n\ndef addEdge(tree, u, v):\n    tree[u].append(v)\n    tree[v].append(u)\n\ndef calc_min_size_subset(tree, n, k):\n    if k == 1:\n        return 1\n    u = get_cur(1, tree, n)\n    store = []\n    seperate_edges(u, 0, tree, store, n)\n    ans = 1\n    total = 0\n    i = 0\n    store.sort(reverse=True)\n    while total < k:\n        ans += 1\n        total += store[i]\n        i += 1\n    return ans\n\ndef get_cur(node, tree, n):\n    visited = [False] * (n + 1)\n    fd = -1\n    visited[node] = True\n    visited_list = [[node, 0]]\n    while len(visited_list) != 0:\n        item = visited_list[0]\n        visited_list.pop(0)\n        nod = item[0]\n        dis = item[1]\n        if fd < dis:\n            fd = dis\n            cur = nod\n        for element in tree[nod]:\n            if visited[element]:\n                continue\n            visited[element] = True\n            visited_list.append([element, dis + 1])\n    return cur\n\ndef seperate_edges(nod, parent_node, tree, store, n):\n    point = [0] * (n + 1)\n    find_height(nod, parent_node, tree, point)\n    depth_first_search(nod, parent_node, tree, point, store, 1)\n\ndef depth_first_search(nod, parent_node, tree, point, store, cur):\n    isLastNode = True\n    mx = 0\n    for element in tree[nod]:\n        if element != parent_node:\n            isLastNode = False\n            mx = max(mx, point[element])\n    if isLastNode:\n        store.append(cur)\n        return\n    c = 0\n    for element in tree[nod]:\n        if element == parent_node:\n            continue\n        if point[element] == mx and c == 0:\n            depth_first_search(element, nod, tree, point, store, cur + 1)\n            c += 1\n        else:\n            depth_first_search(element, nod, tree, point, store, 1)\n\ndef find_height(nod, parent_node, tree, point):\n    isLastNode = True\n    for element in tree[nod]:\n        if element == parent_node:\n            continue\n        isLastNode = False\n        find_height(element, nod, tree, point)\n        point[nod] = max(point[nod], 1 + point[element])\n    if isLastNode:\n        point[nod] = 1\nT = int(input())\nfor _ in range(T):\n    minimum_subtree_cover()", "import sys\nsys.setrecursionlimit(100000)\n\ndef calc_far(node, G, n):\n    done = [False] * (n + 1)\n    fd = -1\n    done[node] = True\n    queue = []\n    queue.append([node, 0])\n    while len(queue) != 0:\n        pi = queue[0]\n        queue.pop(0)\n        nod = pi[0]\n        dis = pi[1]\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in G[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            queue.append([cnod, dis + 1])\n    return far\n\ndef dfs(nod, par, G, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in G[nod]:\n        if cnod != par:\n            isleaf = False\n            mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in G[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, G, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, G, H, li, 1)\n\ndef fixheight(nod, par, G, H):\n    isleaf = True\n    for cnod in G[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixheight(cnod, nod, G, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef breakintolines(nod, par, G, li, n):\n    H = [0] * (n + 1)\n    fixheight(nod, par, G, H)\n    dfs(nod, par, G, H, li, 1)\n\ndef calc_ans(gr, n, k):\n    if k == 1:\n        return 1\n    u = calc_far(1, gr, n)\n    li = []\n    breakintolines(u, 0, gr, li, n)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    ans = calc_ans(gr, n, k)\n    print(ans)", "def farNode(root, tree):\n    d = [False] * (len(tree) + 1)\n    fNode = (root, -1)\n    q = [(root, 0)]\n    while q:\n        (node, dist) = q.pop(0)\n        d[node] = True\n        fNode = (node, dist) if dist > fNode[1] else fNode\n        for cNode in tree[node]:\n            if not d[cNode]:\n                q.append((cNode, dist + 1))\n    return fNode[0]\n\ndef leafNodes(root, tree, parentList, leafList):\n    d = [False] * (len(tree) + 1)\n    q = [(root, 0)]\n    while q:\n        isLeaf = True\n        (node, dist) = q.pop()\n        d[node] = True\n        for cNode in tree[node]:\n            if not d[cNode]:\n                q.append((cNode, dist + 1))\n                parentList[cNode] = node\n                isLeaf = False\n        if isLeaf:\n            leafList.append((node, dist))\n\ndef maxContributors(root, parentList, leafList):\n    optedOut = [False] * (len(parentList) + 1)\n    optedOut[root] = True\n    contributors = []\n    leafList.sort(key=lambda x: x[1], reverse=True)\n    for leaf in leafList:\n        parent = parentList[leaf[0]]\n        c = 1\n        while not optedOut[parent]:\n            optedOut[parent] = True\n            c += 1\n            parent = parentList[parent]\n        contributors.append(c)\n    contributors.sort(reverse=True)\n    return contributors\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    tree = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    if k == 1:\n        print(1)\n        continue\n    fNode = farNode(1, tree)\n    parentList = [None] * (n + 1)\n    leafList = []\n    leafNodes(fNode, tree, parentList, leafList)\n    cont = maxContributors(fNode, parentList, leafList)\n    s = 1\n    i = 0\n    while k > 1:\n        s += 1\n        k -= cont[i]\n        i += 1\n    print(s)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "from collections import defaultdict\nimport queue\nimport sys\nsys.setrecursionlimit(150000)\n\ndef getFar(node, n):\n    done = [False] * (n + 1)\n    fd = -1\n    done[node] = True\n    qu = queue.Queue()\n    qu.put((node, 0))\n    while not qu.empty():\n        pi = qu.get()\n        (nod, dis) = (pi[0], pi[1])\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in tree[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.put((cnod, dis + 1))\n    return far\n\ndef dfs(nod, par, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in tree[nod]:\n        if cnod != par:\n            isleaf = False\n            mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in tree[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, H, li, 1)\n\ndef fixheight(nod, par, H):\n    isleaf = True\n    for cnod in tree[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixheight(cnod, nod, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef breakIntolines(nod, par, li, n):\n    H = [0] * (n + 1)\n    try:\n        fixheight(nod, par, H)\n    except:\n        print(3)\n    dfs(nod, par, H, li, 1)\n\ndef solve(n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, n)\n    li = []\n    breakIntolines(u, 0, li, n)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().strip().split())\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        (a, b) = map(int, input().strip().split())\n        tree[a].append(b)\n        tree[b].append(a)\n    print(solve(n, k))", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef dfscall(ver, xx, edge, dis, lenn, cur):\n    leaf = True\n    maxx = 0\n    for nod in edge[ver]:\n        if nod == xx:\n            continue\n        (leaf, maxx) = (False, max(maxx, dis[nod]))\n    if leaf:\n        lenn.append(cur)\n        return\n    c = 0\n    for nod in edge[ver]:\n        if nod == xx:\n            continue\n        if dis[nod] == maxx and c == 0:\n            dfscall(nod, ver, edge, dis, lenn, cur + 1)\n            c += 1\n        else:\n            dfscall(nod, ver, edge, dis, lenn, 1)\n\ndef distance(ver, xx, edge, dis):\n    leaf = True\n    for nod in edge[ver]:\n        if nod == xx:\n            continue\n        leaf = False\n        distance(nod, ver, edge, dis)\n        dis[ver] = max(dis[ver], 1 + dis[nod])\n    if leaf:\n        dis[ver] = 1\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    edge = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        edge[u].append(v)\n        edge[v].append(u)\n    if k == 1:\n        print(1)\n    else:\n        arr = [False] * (n + 1)\n        (x, u, queue, arr[1]) = (-1, None, [(1, 0)], True)\n        while queue:\n            (node2, dis) = queue.pop(0)\n            if x < dis:\n                (x, u) = (dis, node2)\n            for nod in edge[node2]:\n                if arr[nod]:\n                    continue\n                arr[nod] = True\n                queue.append((nod, dis + 1))\n        (lenn, dis) = ([], [0] * (n + 1))\n        distance(u, 0, edge, dis)\n        dfscall(u, 0, edge, dis, lenn, 1)\n        lenn.sort(reverse=True)\n        (size, total, i) = (1, 0, 0)\n        while total < k:\n            size += 1\n            total += lenn[i]\n            i += 1\n        print(size)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef d1(node1, gr, n):\n    arr = [False] * (n + 1)\n    x = -1\n    far = None\n    q = [(node1, 0)]\n    arr[node1] = True\n    while q:\n        (node2, dis) = q.pop(0)\n        if x < dis:\n            x = dis\n            far = node2\n        for cnod in gr[node2]:\n            if arr[cnod]:\n                continue\n            arr[cnod] = True\n            q.append((cnod, dis + 1))\n    return far\n\ndef d2(node, par, gr, H):\n    isleaf = True\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        d2(cnod, node, gr, H)\n        H[node] = max(H[node], 1 + H[cnod])\n    if isleaf:\n        H[node] = 1\n\ndef dfs(node, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, node, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, node, gr, H, li, 1)\n\ndef getLines(node, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    d2(node, par, gr, H)\n    dfs(node, par, gr, H, li, 1)\n\ndef d3(gr, n, k):\n    if k == 1:\n        return 1\n    u = d1(1, gr, n)\n    li = []\n    getLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    g = d3(gr, n, k)\n    print(g)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getValue(node1, graph, n):\n    (myx, far) = (-1, None)\n    myarr = [0] * (n + 1)\n    qry = [(node1, 0)]\n    myarr[node1] = 1\n    while qry:\n        (node2, dist) = qry.pop(0)\n        if myx < dist:\n            (myx, far) = (dist, node2)\n        for cpt in graph[node2]:\n            if myarr[cpt]:\n                continue\n            myarr[cpt] = 1\n            qry.append((cpt, dist + 1))\n    return far\n\ndef getValue2(pt, mypar, graph, myH):\n    checkleaf = 1\n    for cpt in graph[pt]:\n        if cpt == mypar:\n            continue\n        checkleaf = 0\n        getValue2(cpt, pt, graph, myH)\n        myH[pt] = max(myH[pt], 1 + myH[cpt])\n    if checkleaf:\n        myH[pt] = 1\n\ndef mydfs(pt, mypar, graph, myH, li, current):\n    (checkleaf, mymx) = (1, 0)\n    for cpt in graph[pt]:\n        if cpt == mypar:\n            continue\n        checkleaf = 5 - 5\n        mymx = max(mymx, myH[cpt])\n    if checkleaf:\n        li.append(current)\n        return\n    c = 5 - 5\n    for cpt in graph[pt]:\n        if cpt == mypar:\n            continue\n        if myH[cpt] == mymx and c == 0:\n            mydfs(cpt, pt, graph, myH, li, current + 1)\n            c = c + 1\n        else:\n            mydfs(cpt, pt, graph, myH, li, 1)\n\ndef getPaths(pt, mypar, graph, li, n, current):\n    myH = [0] * (n + 1)\n    getValue2(pt, mypar, graph, myH)\n    mydfs(pt, mypar, graph, myH, li, 1)\n\ndef getValue3(graph, n, k):\n    if k == 1:\n        return 5 - 4\n    u = getValue(1, graph, n)\n    li = list()\n    getPaths(u, 0, graph, li, n, 1)\n    li = sorted(li, reverse=1)\n    (size, total, loop) = (1, 0, 0)\n    while total < k:\n        total = total + li[loop]\n        size = size + 1\n        loop = loop + 1\n    return size\n\ndef solve():\n    (n, k) = list(map(int, input().split()))\n    graph = [list() for loop in range(n + 1)]\n    for loop in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        graph[v].append(u)\n        graph[u].append(v)\n    temp = getValue3(graph, n, k)\n    sys.stdout.write(str(temp) + '\\n')\n\ndef main():\n    global t\n    tc = int(input())\n    for t in range(tc):\n        solve()\nmain()", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getData(node1, gr, n):\n    arr = [False] * (n + 1)\n    x = -1\n    far = None\n    q = [(node1, 0)]\n    arr[node1] = True\n    while q:\n        (node2, dis) = q.pop(0)\n        if x < dis:\n            x = dis\n            far = node2\n        for cnod in gr[node2]:\n            if arr[cnod]:\n                continue\n            arr[cnod] = True\n            q.append((cnod, dis + 1))\n    return far\n\ndef getData2(node, par, gr, H):\n    isleaf = True\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        getData2(cnod, node, gr, H)\n        H[node] = max(H[node], 1 + H[cnod])\n    if isleaf:\n        H[node] = 1\n\ndef dfs(node, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, node, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, node, gr, H, li, 1)\n\ndef getLines(node, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    getData2(node, par, gr, H)\n    dfs(node, par, gr, H, li, 1)\n\ndef getData3(gr, n, k):\n    if k == 1:\n        return 1\n    u = getData(1, gr, n)\n    li = []\n    getLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    min_subset = getData3(gr, n, k)\n    print(min_subset)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getValue(node1, graph, n):\n    (myx, far) = (-1, None)\n    myarr = [0] * (n + 1)\n    qry = [(node1, 0)]\n    myarr[node1] = 1\n    while qry:\n        (node2, dist) = qry.pop(0)\n        if myx < dist:\n            (myx, far) = (dist, node2)\n        for cpt in graph[node2]:\n            if myarr[cpt]:\n                continue\n            myarr[cpt] = 1\n            qry.append((cpt, dist + 1))\n    return far\n\ndef getValue2(pt, mypar, graph, myH):\n    checkleaf = 1\n    for cpt in graph[pt]:\n        if cpt == mypar:\n            continue\n        checkleaf = 0\n        getValue2(cpt, pt, graph, myH)\n        myH[pt] = max(myH[pt], 1 + myH[cpt])\n    if checkleaf:\n        myH[pt] = 1\n\ndef mydfs(pt, mypar, graph, myH, li, current):\n    (checkleaf, mymx) = (1, 0)\n    for cpt in graph[pt]:\n        if cpt == mypar:\n            continue\n        checkleaf = 0\n        mymx = max(mymx, myH[cpt])\n    if checkleaf:\n        li.append(current)\n        return\n    c = 0\n    for cpt in graph[pt]:\n        if cpt == mypar:\n            continue\n        if myH[cpt] == mymx and c == 0:\n            mydfs(cpt, pt, graph, myH, li, current + 1)\n            c = c + 1\n        else:\n            mydfs(cpt, pt, graph, myH, li, 1)\n\ndef getPaths(pt, mypar, graph, li, n, current):\n    myH = [0] * (n + 1)\n    getValue2(pt, mypar, graph, myH)\n    mydfs(pt, mypar, graph, myH, li, 1)\n\ndef getValue3(graph, n, k):\n    if k == 1:\n        return 1\n    u = getValue(1, graph, n)\n    li = list()\n    getPaths(u, 0, graph, li, n, 1)\n    li.sort(reverse=1)\n    (size, total, loop) = (1, 0, 0)\n    while total < k:\n        total = total + li[loop]\n        size = size + 1\n        loop = loop + 1\n    return size\n\ndef solve():\n    (n, k) = list(map(int, input().split()))\n    graph = [list() for loop in range(n + 1)]\n    for loop in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        graph[v].append(u)\n        graph[u].append(v)\n    temp = getValue3(graph, n, k)\n    sys.stdout.write(str(temp) + '\\n')\n\ndef main():\n    global t\n    tc = int(input())\n    for t in range(tc):\n        solve()\nmain()", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getData(node1, gr, n):\n    arr = [False] * (n + 1)\n    a = -1\n    far = None\n    p = [(node1, 0)]\n    arr[node1] = True\n    while p:\n        (node2, dis) = p.pop(0)\n        if a < dis:\n            a = dis\n            far = node2\n        for cnod in gr[node2]:\n            if arr[cnod]:\n                continue\n            arr[cnod] = True\n            p.append((cnod, dis + 1))\n    return far\n\ndef getData2(node, par, gr, H):\n    isleaf = True\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        getData2(cnod, node, gr, H)\n        H[node] = max(H[node], 1 + H[cnod])\n    if isleaf:\n        H[node] = 1\n\ndef dfs(node, par, gr, H, li, cur):\n    isleaf = True\n    mux = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mux = max(mux, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        if H[cnod] == mux and c == 0:\n            dfs(cnod, node, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, node, gr, H, li, 1)\n\ndef getLines(node, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    getData2(node, par, gr, H)\n    dfs(node, par, gr, H, li, 1)\n\ndef getData3(gr, n, kar):\n    if kar == 1:\n        return 1\n    u = getData(1, gr, n)\n    li = []\n    getLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < kar:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor i in range(int(input())):\n    (n, kar) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    min_subset = getData3(gr, n, kar)\n    print(min_subset)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef get_farest_node(node1, graph, n):\n    arr = [False] * (n + 1)\n    x = -1\n    far = None\n    q = [(node1, 0)]\n    arr[node1] = True\n    while q:\n        (node2, dis) = q.pop(0)\n        if x < dis:\n            x = dis\n            far = node2\n        for cnod in graph[node2]:\n            if arr[cnod]:\n                continue\n            arr[cnod] = True\n            q.append((cnod, dis + 1))\n    return far\n\ndef get_node1(node, par, graph, H):\n    check_leaf = True\n    for cnod in graph[node]:\n        if cnod == par:\n            continue\n        check_leaf = False\n        get_node1(cnod, node, graph, H)\n        H[node] = max(H[node], 1 + H[cnod])\n    if check_leaf:\n        H[node] = 1\n\ndef direct_search(node, par, graph, H, li, cur):\n    check_leaf = True\n    mx = 0\n    for cnod in graph[node]:\n        if cnod == par:\n            continue\n        check_leaf = False\n        mx = max(mx, H[cnod])\n    if check_leaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in graph[node]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            direct_search(cnod, node, graph, H, li, cur + 1)\n            c += 1\n        else:\n            direct_search(cnod, node, graph, H, li, 1)\n\ndef findLines_(node, par, graph, li, n, cur):\n    H = [0] * (n + 1)\n    get_node1(node, par, graph, H)\n    direct_search(node, par, graph, H, li, 1)\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        graph[x].append(y)\n        graph[y].append(x)\n    if k == 1:\n        size = 1\n    else:\n        x = get_farest_node(1, graph, n)\n        li = []\n        findLines_(x, 0, graph, li, n, 1)\n        li.sort(reverse=True)\n        size = 1\n        total = 0\n        i = 0\n        while total < k:\n            size += 1\n            total += li[i]\n            i += 1\n    min_subset = size\n    print(min_subset)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef e(a, b):\n    return [i for i in a if i not in b]\n\ndef dfs(r):\n    (v, s, c) = (set(), [r], 0)\n    while s:\n        u = s.pop()\n        c += 1\n        if u not in v:\n            v.add(u)\n            s.extend(e(d[u], v))\n            if not e(d[u], v):\n                f[u] = c\n                c = 0\n\ndef a(u=1, v=0):\n    if not e(d[u], {v}):\n        depth[u] = 0\n        return 0\n    else:\n        depth[u] = 1 + max([a(i, u) for i in e(d[u], {v})])\n        return depth[u]\nT = int(input())\nfor n1 in range(T):\n    (n, k) = [int(i) for i in input().split(' ')]\n    d = dict()\n    for i in range(1, n + 1):\n        d[i] = set()\n    for i in range(n - 1):\n        (u, v) = [int(i) for i in input().split(' ')]\n        d[u].add(v)\n        d[v].add(u)\n    if k == 1:\n        print(1)\n        continue\n    f = dict()\n    depth = dict()\n    a()\n    for i in d:\n        d[i] = sorted(d[i], key=lambda x: depth[x])\n    r = d[1][-1]\n    while depth[r] != 0:\n        r = d[r][-2]\n    a(r)\n    for i in d:\n        d[i] = sorted(d[i], key=lambda x: depth[x])\n    dfs(r)\n    l = sorted(list(f.values()))\n    i = 0\n    while n >= k:\n        n -= l[i]\n        i += 1\n    print(len(l) - i + 2)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getData(node1, gr, n):\n    arr = [False] * (n + 1)\n    x = -1\n    far = None\n    q = [(node1, 0)]\n    arr[node1] = True\n    while q:\n        (node2, dis) = q.pop(0)\n        if x < dis:\n            x = dis\n            far = node2\n        for cnod in gr[node2]:\n            if arr[cnod]:\n                continue\n            arr[cnod] = True\n            q.append((cnod, dis + 1))\n    return far\n\ndef getData2(node, par, gr, H):\n    isleaf = True\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        getData2(cnod, node, gr, H)\n        H[node] = max(H[node], 1 + H[cnod])\n    if isleaf:\n        H[node] = 1\n\ndef dfs(node, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, node, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, node, gr, H, li, 1)\n\ndef getLines(node, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    getData2(node, par, gr, H)\n    dfs(node, par, gr, H, li, 1)\n\ndef getData3(gr, n, k):\n    if k == 1:\n        return 1\n    u = getData(1, gr, n)\n    li = []\n    getLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    min_subset = getData3(gr, n, k)\n    print(min_subset)", "try:\n    import sys\n    sys.setrecursionlimit(10 ** 9)\n\n    def getFar(node, gr, n):\n        done = [False] * (n + 1)\n        fd = -1\n        far = None\n        qu = [(node, 0)]\n        done[node] = True\n        while qu:\n            (nod, dis) = qu.pop(0)\n            if fd < dis:\n                fd = dis\n                far = nod\n            for cnod in gr[nod]:\n                if done[cnod]:\n                    continue\n                done[cnod] = True\n                qu.append((cnod, dis + 1))\n        return far\n\n    def fixHeight(nod, par, gr, H):\n        isleaf = True\n        for cnod in gr[nod]:\n            if cnod == par:\n                continue\n            isleaf = False\n            fixHeight(cnod, nod, gr, H)\n            H[nod] = max(H[nod], 1 + H[cnod])\n        if isleaf:\n            H[nod] = 1\n\n    def dfs(nod, par, gr, H, li, cur):\n        isleaf = True\n        mx = 0\n        for cnod in gr[nod]:\n            if cnod == par:\n                continue\n            isleaf = False\n            mx = max(mx, H[cnod])\n        if isleaf:\n            li.append(cur)\n            return\n        c = 0\n        for cnod in gr[nod]:\n            if cnod == par:\n                continue\n            if H[cnod] == mx and c == 0:\n                dfs(cnod, nod, gr, H, li, cur + 1)\n                c += 1\n            else:\n                dfs(cnod, nod, gr, H, li, 1)\n\n    def breakIntoLines(nod, par, gr, li, n, cur):\n        H = [0] * (n + 1)\n        fixHeight(nod, par, gr, H)\n        dfs(nod, par, gr, H, li, 1)\n\n    def GETSOL(gr, n, k):\n        if k == 1:\n            return 1\n        u = getFar(1, gr, n)\n        li = []\n        breakIntoLines(u, 0, gr, li, n, 1)\n        li.sort(reverse=True)\n        size = 1\n        total = 0\n        i = 0\n        while total < k:\n            size += 1\n            total += li[i]\n            i += 1\n        return size\n    for case in range(int(input())):\n        (n, k) = map(int, input().split())\n        gr = [[] for i in range(n + 1)]\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            gr[u].append(v)\n            gr[v].append(u)\n        chad = GETSOL(gr, n, k)\n        print(chad)\nexcept:\n    pass", "from sys import stdin, stdout\nimport math\nfrom collections import defaultdict, deque\nimport resource, sys\nresource.setrlimit(resource.RLIMIT_STACK, (2 ** 29, -1))\nsys.setrecursionlimit(10 ** 7)\n\nclass Dfs:\n\n    def __init__(self, d, n):\n        self.d = d\n        self.n = n\n\n    def dfs(self, start=1):\n        (q, parent) = (deque([start]), [0] * (self.n + 1))\n        parent[start] = 1\n        while q:\n            node = q.popleft()\n            for x in self.d[node]:\n                if parent[x] == 0:\n                    parent[x] = node\n                    q.appendleft(x)\n        return parent\n\n    def dfs_further(self, start=1):\n        height = [-1] * (self.n + 1)\n        (ma, Node_last, height[start], q) = (0, -1, 0, deque([start]))\n        while q:\n            node = q.popleft()\n            for x in self.d[node]:\n                if height[x] == -1:\n                    height[x] = height[node] + 1\n                    if height[x] > ma:\n                        (ma, Node_last) = (height[x], x)\n                    q.appendleft(x)\n        return [Node_last, ma]\n\n    def tree_diameter(self):\n        z = self.dfs_further()\n        far_node = z[0]\n        z1 = self.dfs_further(start=far_node)\n        tree_length = z1[1]\n        return [tree_length + 1, z1[0], z[0]]\n\ndef DFS1(st, end):\n    q = deque([st])\n    parent = [-1] * (n + 1)\n    parent[st] = st\n    high[st] = 0\n    mx = 0\n    while q:\n        node = q.popleft()\n        cnt = 0\n        for x in d[node]:\n            if parent[x] == -1:\n                cnt += 1\n                high[x] = high[node] + 1\n                mx = max(high[x], mx)\n                parent[x] = node\n                q.append(x)\n        if cnt == 0:\n            leaf_node.add(node)\n    e = end\n    while e != st:\n        visit[e] = True\n        e = parent[e]\n    visit[e] = True\n\ndef main():\n    try:\n        global lo, n, ans, k, visit, d, dp, tin, tout, high, leaf_node\n        (n, k) = In()\n        leaf_node = set()\n        ans = [float('inf')]\n        d = defaultdict(list)\n        for i in range(n - 1):\n            (a, b) = In()\n            d[a].append(b)\n            d[b].append(a)\n        if k == 1:\n            print(1)\n            return\n        dfs1 = Dfs(d, n)\n        s = set()\n        an = dfs1.tree_diameter()\n        s.add(an[1])\n        s.add(an[2])\n        visit = [False] * (n + 1)\n        high = [-1] * (n + 1)\n        DFS1(an[1], an[2])\n        for x in s:\n            if x in leaf_node:\n                leaf_node.remove(x)\n        ans = 2\n        cnt = an[0]\n        if an[0] >= k:\n            print(2)\n            return\n        l = []\n        pants = [(high[x], x) for x in leaf_node]\n        pants.sort(key=lambda x: x[0], reverse=True)\n        for pant in pants:\n            x = pant[1]\n            cnt1 = 0\n            q = deque([x])\n            while q:\n                node = q.popleft()\n                if visit[node]:\n                    continue\n                visit[node] = True\n                cnt1 += 1\n                cur = high[node]\n                topush = -1\n                for v in d[node]:\n                    if not visit[v] and high[v] < cur:\n                        cur = high[v]\n                        topush = v\n                if topush != -1:\n                    q.append(topush)\n            if cnt1:\n                l.append((cnt1, x))\n        l.sort(key=lambda x: x[0], reverse=True)\n        for x in l:\n            cnt += x[0]\n            ans += 1\n            if cnt >= k:\n                break\n        print(ans)\n    except:\n        pass\n\ndef add(a, b, c):\n    res = a + b\n    if res >= c:\n        return res - c\n    else:\n        return res\n\ndef mod(a, b, c):\n    res = a * b\n    if res >= c:\n        return res % c\n    else:\n        return res\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    w = a // gcd(a, b)\n    return w * b\n\ndef expo(a, b):\n    (x, y) = (1, a)\n    while b > 0:\n        if b & 1:\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\n\ndef power(a, b, m):\n    (x, y) = (1,)\n    while b > 0:\n        if b & 1:\n            x = mod(x, y, m)\n        y = mod(y, y, m)\n        b >>= 1\n    return x\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\nfor _ in range(I()):\n    main()", "import heapq\n\nclass maxq:\n\n    def heappush(h, key, val):\n        heapq.heappush(h, (-key, val))\n\n    def heappop(h):\n        (key, val) = heapq.heappop(h)\n        return val\n\ndef get_subtrees_rooted_on_path(tree, path):\n    subtrees = []\n    for i in range(len(path)):\n        current = path[i]\n        prev = None if i == 0 else path[i - 1]\n        next = None if i + 1 == len(path) else path[i + 1]\n        for neighbor in tree[current]:\n            if neighbor != prev and neighbor != next:\n                subtrees += [(current, neighbor)]\n    return subtrees\n\ndef get_heaviest_leaves(tree, subtree_root):\n    (tree_source, root) = subtree_root\n    values = {root: 1}\n    path_from_root = {root: None}\n    next = [root]\n    heaviest_leaves = []\n    distance = 0\n    while len(next) > 0:\n        current = next\n        next = []\n        distance += 1\n        for node in current:\n            is_leaf = True\n            for next_node in tree[node]:\n                if next_node == tree_source:\n                    continue\n                if next_node in values:\n                    continue\n                next += [next_node]\n                values[next_node] = distance + 1\n                path_from_root[next_node] = node\n                is_leaf = False\n            if is_leaf:\n                maxq.heappush(heaviest_leaves, values[node], (values[node], node))\n    taken = set()\n    while len(heaviest_leaves) > 0:\n        (weight, heaviest_leaf) = maxq.heappop(heaviest_leaves)\n        valid = True\n        node = heaviest_leaf\n        while path_from_root[node] is not None:\n            prev = node\n            node = path_from_root[node]\n            if node in taken:\n                if weight == values[heaviest_leaf] - values[node]:\n                    break\n                valid = False\n                weight = values[heaviest_leaf] - values[node]\n                maxq.heappush(heaviest_leaves, weight, (weight, heaviest_leaf))\n                break\n        if valid:\n            yield (weight, heaviest_leaf)\n            node = heaviest_leaf\n            while node not in taken and node is not None:\n                taken.add(node)\n                node = path_from_root[node]\n\ndef get_next(tree, subtrees):\n    heaviest_leaf_generators = [get_heaviest_leaves(tree, subtree) for subtree in subtrees]\n    heaviest_leaves = []\n    for gen in heaviest_leaf_generators:\n        (weight, node) = next(gen)\n        maxq.heappush(heaviest_leaves, weight, (weight, node, gen))\n    while len(heaviest_leaves) > 0:\n        (weight, heaviest_leaf, gen) = maxq.heappop(heaviest_leaves)\n        yield weight\n        next_heaviest_from_tree = next(gen, None)\n        if next_heaviest_from_tree is not None:\n            (weight, node) = next_heaviest_from_tree\n            maxq.heappush(heaviest_leaves, weight, (weight, node, gen))\n\ndef get_diameter(tree):\n    next_nodes = [next(iter(tree))]\n    known = set(next_nodes)\n    while len(next_nodes) > 0:\n        current = next_nodes\n        next_nodes = []\n        for node in current:\n            for next_node in tree[node]:\n                if next_node not in known:\n                    known.add(next_node)\n                    next_nodes += [next_node]\n    root = node\n    known = set([root])\n    next_nodes = [root]\n    path_from_root = {root: root}\n    while len(next_nodes) > 0:\n        current = next_nodes\n        next_nodes = []\n        for node in current:\n            for next_node in tree[node]:\n                if next_node not in known:\n                    known.add(next_node)\n                    next_nodes += [next_node]\n                    path_from_root[next_node] = node\n    end_node = node\n    path = [end_node]\n    while path_from_root[path[-1]] != path[-1]:\n        path += [path_from_root[path[-1]]]\n    return path\n\ndef solve(edges, k):\n    if k == 1:\n        return 1\n    tree = {i: [] for edge in edges for i in edge}\n    for edge in edges:\n        tree[edge[0]] += [edge[1]]\n        tree[edge[1]] += [edge[0]]\n    diameter = get_diameter(tree)\n    k -= len(diameter)\n    subtrees_rooted_on_diameter = get_subtrees_rooted_on_path(tree, diameter)\n    s = 2\n    for weight in get_next(tree, subtrees_rooted_on_diameter):\n        if k <= 0:\n            break\n        k -= weight\n        s += 1\n    return s\nimport sys\nT = int(next(sys.stdin))\nfor _ in range(T):\n    (n, k) = map(int, next(sys.stdin).split())\n    edges = []\n    for _ in range(n - 1):\n        edge = tuple(map(int, next(sys.stdin).split()))\n        edges += [edge]\n    print(solve(edges, k))", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getData(node1, gr, n):\n    arr = [False] * (n + 1)\n    x = -1\n    far = None\n    q = [(node1, 0)]\n    arr[node1] = True\n    while q:\n        (node2, dis) = q.pop(0)\n        if x < dis:\n            x = dis\n            far = node2\n        for cnod in gr[node2]:\n            if arr[cnod]:\n                continue\n            arr[cnod] = True\n            q.append((cnod, dis + 1))\n    return far\n\ndef getData2(node, par, gr, H):\n    isleaf = True\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        getData2(cnod, node, gr, H)\n        H[node] = max(H[node], 1 + H[cnod])\n    if isleaf:\n        H[node] = 1\n\ndef dfs(node, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[node]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, node, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, node, gr, H, li, 1)\n\ndef getLines(node, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    getData2(node, par, gr, H)\n    dfs(node, par, gr, H, li, 1)\n\ndef getData3(gr, n, k):\n    if k == 1:\n        return 1\n    u = getData(1, gr, n)\n    li = []\n    getLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    min_subset = getData3(gr, n, k)\n    print(min_subset)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "from collections import deque\n\ndef bfs(tree, n):\n    q = deque()\n    visited = [0 for i in range(n + 1)]\n    d = dict()\n    for i in range(1, n + 1):\n        if len(tree[i]) == 1:\n            q.append(i)\n            d[i] = 0\n    res = []\n    lv = 0\n    while q:\n        u = q.popleft()\n        visited[u] += 1\n        d[u] += 1\n        lv = d[u]\n        for v in tree[u]:\n            if visited[v] == len(tree[v]):\n                continue\n            visited[v] += 1\n            if v not in d:\n                d[v] = d[u]\n            else:\n                l = min(d[v], d[u])\n                d[v] = d[v] + d[u] - l\n                res.append(l)\n            if visited[v] == len(tree[v]) - 1:\n                q.append(v)\n    res.append(lv)\n    res.sort(reverse=True)\n    return res\nfor t in range(int(input())):\n    (n, k) = tuple(map(int, input().strip().split()))\n    tree = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = tuple(map(int, input().strip().split()))\n        tree[u].append(v)\n        tree[v].append(u)\n    ans = k\n    if k > 2:\n        res = bfs(tree, n)\n        n_r = len(res)\n        ans = 2\n        cnt = res[0] + res[1]\n        i = 2\n        while cnt < k and i < n_r:\n            cnt += res[i]\n            ans += 1\n            i += 1\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "from heapq import heapify, heappush, heappop\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef mxbfs(u, g, n):\n    s = [-1] * (n + 1)\n    q = [u] * n\n    s[u] = 0\n    i = 0\n    j = 1\n    while i < n:\n        u = q[i]\n        i += 1\n        for v in g[u]:\n            if s[v] == -1:\n                s[v] = s[u] + 1\n                q[j] = v\n                j += 1\n    return s.index(max(s))\n\ndef maketree(u, g, r, d):\n    d[u] = True\n    m = 0\n    for v in g[u]:\n        if not d[v]:\n            node = maketree(v, g, r, d)\n            r[u].append(node)\n            m = min(m, node[0])\n    return [m - 1, u]\nt = int(input())\nz = [0] * t\nfor a in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    g = {}\n    vis = [False] * (n + 1)\n    for i in range(1, n + 1):\n        g[i] = []\n    for j in range(n - 1):\n        (u, v) = [int(i) for i in input().split()]\n        g[u].append(v)\n        g[v].append(u)\n    if k == 1:\n        z[a] = k\n        continue\n    ed = mxbfs(1, g, n)\n    r = {}\n    for i in range(1, n + 1):\n        r[i] = []\n    node = maketree(ed, g, r, vis)\n    try:\n        cover = 0\n        forest = [node]\n        ans = 1\n        while cover < k:\n            ans += 1\n            node = heappop(forest)\n            while node:\n                cover += 1\n                tree = r[node[1]]\n                m = [0, 0]\n                node = []\n                for i in tree:\n                    if i[0] < m[0]:\n                        m = i\n                for i in tree:\n                    if i[1] == m[1]:\n                        node = i\n                    else:\n                        heappush(forest, i)\n        z[a] = ans\n    except Exception:\n        break\nprint(*z, sep='\\n')", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef fix(nod, par, gr, H):\n    leafs = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        leafs = False\n        fix(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if leafs:\n        H[nod] = 1\n\ndef get(node, gr, n):\n    sol = [False] * (n + 1)\n    l = -1\n    dr = None\n    qu = [(node, 0)]\n    sol[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if l < dis:\n            l = dis\n            dr = nod\n        for cnod in gr[nod]:\n            if sol[cnod]:\n                continue\n            sol[cnod] = True\n            qu.append((cnod, dis + 1))\n    return dr\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef getinto(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fix(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef sol(li, n, k):\n    if k == 1:\n        return 1\n    u = get(1, li, n)\n    lis = []\n    siz = 1\n    value = 0\n    i = 0\n    getinto(u, 0, li, lis, n, 1)\n    lis.sort(reverse=True)\n    while value < k:\n        siz += 1\n        value += lis[i]\n        i += 1\n    return siz\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    lis = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        lis[u].append(v)\n        lis[v].append(u)\n    c = sol(lis, n, k)\n    print(c)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef avail_long(head, lists, n):\n    dis = -1\n    longs = None\n    que = [(head, 0)]\n    done = [False] * (n + 1)\n    done[head] = True\n    while que:\n        (node, dist) = que.pop(0)\n        if dis < dist:\n            dis = dist\n            longs = node\n        for i in lists[node]:\n            if done[i]:\n                continue\n            done[i] = True\n            que.append((i, dist + 1))\n    return longs\n\ndef avail(hd, val, lists, H):\n    leaf = True\n    for i in lists[hd]:\n        if i == val:\n            continue\n        leaf = False\n        avail(i, hd, lists, H)\n        H[hd] = max(H[hd], 1 + H[i])\n    if leaf:\n        H[hd] = 1\n\ndef depth(hd, val, lists, H, li, cur):\n    l = True\n    maxi = 0\n    for node in lists[hd]:\n        if node == val:\n            continue\n        l = False\n        maxi = max(maxi, H[node])\n    if l:\n        li.append(cur)\n        return\n    c = 0\n    for node in lists[hd]:\n        if node == val:\n            continue\n        if H[node] == maxi and c == 0:\n            depth(node, hd, lists, H, li, cur + 1)\n            c += 1\n        else:\n            depth(node, hd, lists, H, li, 1)\n\ndef divide(hd, val, lists, li, n, present):\n    al = [0] * (n + 1)\n    avail(hd, val, lists, al)\n    depth(hd, val, lists, al, li, 1)\n\ndef func(lists, n, k):\n    if k == 1:\n        return 1\n    u = avail_long(1, lists, n)\n    arr = []\n    var = 0\n    divide(u, 0, lists, arr, n, 1)\n    arr.sort(reverse=True)\n    length = 1\n    ans = 0\n    while ans < k:\n        ans += arr[var]\n        length += 1\n        var += 1\n    return length\nfor test in range(int(input())):\n    (n, k) = map(int, input().split())\n    lists = [[] for i in range(n + 1)]\n    for var in range(n - 1):\n        (ord1, ord2) = map(int, input().split())\n        lists[ord1].append(ord2)\n        lists[ord2].append(ord1)\n    sol = func(lists, n, k)\n    print(sol)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, kl, n):\n    done = [False] * (n + 1)\n    nc = -1\n    far = None\n    qd = [(node, 0)]\n    done[node] = True\n    while qd:\n        (nod, dis) = qd.pop(0)\n        if nc < dis:\n            nc = dis\n            far = nod\n        for cnod in kl[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qd.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, kl, H):\n    isLeaf = True\n    for cnod in kl[nod]:\n        if cnod == par:\n            continue\n        isLeaf = False\n        fixHeight(cnod, nod, kl, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isLeaf:\n        H[nod] = 1\n\ndef dfs(nod, par, kl, H, bi, cur):\n    isLeaf = True\n    ax = 0\n    for cnod in kl[nod]:\n        if cnod == par:\n            continue\n        isLeaf = False\n        ax = max(ax, H[cnod])\n    if isLeaf:\n        bi.append(cur)\n        return\n    c = 0\n    for cnod in kl[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == ax and c == 0:\n            dfs(cnod, nod, kl, H, bi, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, kl, H, bi, 1)\n\ndef breakIntoLines(nod, par, kl, bi, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, kl, H)\n    dfs(nod, par, kl, H, bi, 1)\n\ndef GETSOL(kl, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, kl, n)\n    bi = []\n    breakIntoLines(u, 0, kl, bi, n, 1)\n    bi.sort(reverse=True)\n    size = 1\n    tot = 0\n    i = 0\n    while tot < k:\n        size += 1\n        tot += bi[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    kl = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        kl[u].append(v)\n        kl[v].append(u)\n    ans = GETSOL(kl, n, k)\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, kl, n):\n    done = [False] * (n + 1)\n    nc = -1\n    far = None\n    qd = [(node, 0)]\n    done[node] = True\n    while qd:\n        (nod, dis) = qd.pop(0)\n        if nc < dis:\n            nc = dis\n            far = nod\n        for cnod in kl[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qd.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, kl, H):\n    isLeaf = True\n    for cnod in kl[nod]:\n        if cnod == par:\n            continue\n        isLeaf = False\n        fixHeight(cnod, nod, kl, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isLeaf:\n        H[nod] = 1\n\ndef dfs(nod, par, kl, H, bi, cur):\n    isLeaf = True\n    ax = 0\n    for cnod in kl[nod]:\n        if cnod == par:\n            continue\n        isLeaf = False\n        ax = max(ax, H[cnod])\n    if isLeaf:\n        bi.append(cur)\n        return\n    c = 0\n    for cnod in kl[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == ax and c == 0:\n            dfs(cnod, nod, kl, H, bi, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, kl, H, bi, 1)\n\ndef breakIntoLines(nod, par, kl, bi, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, kl, H)\n    dfs(nod, par, kl, H, bi, 1)\n\ndef GETSOL(kl, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, kl, n)\n    bi = []\n    breakIntoLines(u, 0, kl, bi, n, 1)\n    bi.sort(reverse=True)\n    size = 1\n    tot = 0\n    i = 0\n    while tot < k:\n        size += 1\n        tot += bi[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    kl = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        kl[u].append(v)\n        kl[v].append(u)\n    ans = GETSOL(kl, n, k)\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, kl, n):\n    done = [False] * (n + 1)\n    nc = -1\n    far = None\n    qd = [(node, 0)]\n    done[node] = True\n    while qd:\n        (nod, dis) = qd.pop(0)\n        if nc < dis:\n            nc = dis\n            far = nod\n        for cnod in kl[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qd.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, kl, H):\n    isLeaf = True\n    for cnod in kl[nod]:\n        if cnod == par:\n            continue\n        isLeaf = False\n        fixHeight(cnod, nod, kl, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isLeaf:\n        H[nod] = 1\n\ndef dfs(nod, par, kl, H, bi, cur):\n    isLeaf = True\n    ax = 0\n    for cnod in kl[nod]:\n        if cnod == par:\n            continue\n        isLeaf = False\n        ax = max(ax, H[cnod])\n    if isLeaf:\n        bi.append(cur)\n        return\n    c = 0\n    for cnod in kl[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == ax and c == 0:\n            dfs(cnod, nod, kl, H, bi, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, kl, H, bi, 1)\n\ndef breakIntoLines(nod, par, kl, bi, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, kl, H)\n    dfs(nod, par, kl, H, bi, 1)\n\ndef GETSOL(kl, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, kl, n)\n    bi = []\n    breakIntoLines(u, 0, kl, bi, n, 1)\n    bi.sort(reverse=True)\n    size = 1\n    tot = 0\n    i = 0\n    while tot < k:\n        size += 1\n        tot += bi[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    kl = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        kl[u].append(v)\n        kl[v].append(u)\n    ans = GETSOL(kl, n, k)\n    print(ans)", "def get_diameter_node(edges, n):\n    visited = [0] * n\n    stack = [1]\n    depth = {1: 1}\n    deapest = 1\n    while len(stack) > 0:\n        cur = stack.pop()\n        visited[cur - 1] = 1\n        for neighbour in edges[cur]:\n            if visited[neighbour - 1] == 0:\n                stack.append(neighbour)\n                depth[neighbour] = depth[cur] + 1\n                if depth[neighbour] > depth[deapest]:\n                    deapest = neighbour\n    return deapest\n\ndef get_contributions(edges, n, node):\n    visited = [0] * n\n    stack = [node]\n    depth = {node: 1}\n    contribution = {}\n    contribution_list = []\n    while len(stack) > 0:\n        cur = stack[-1]\n        if visited[cur - 1] == 0:\n            visited[cur - 1] = 1\n            for neighbour in edges[cur]:\n                if visited[neighbour - 1] == 0:\n                    flag = False\n                    stack.append(neighbour)\n                    depth[neighbour] = depth[cur] + 1\n        else:\n            m = 0\n            temp = []\n            for neighbour in edges[cur]:\n                if neighbour in contribution:\n                    m = max(m, contribution[neighbour])\n                    temp.append(contribution[neighbour])\n            if m == 0:\n                contribution[cur] = depth[cur]\n            else:\n                contribution[cur] = m\n            flag = True\n            for i in temp:\n                if flag and i == m:\n                    flag = False\n                else:\n                    contribution_list.append(i - depth[cur])\n            stack.pop()\n            if len(stack) == 0:\n                contribution_list.append(contribution[cur])\n    return sorted(contribution_list, reverse=True)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    edges = {}\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        if a not in edges:\n            edges[a] = []\n        if b not in edges:\n            edges[b] = []\n        edges[a].append(b)\n        edges[b].append(a)\n    if n == 1 or k == 1:\n        print(1)\n        continue\n    node = get_diameter_node(edges, n)\n    contri = get_contributions(edges, n, node)\n    total = 0\n    ans = 0\n    for i in range(len(contri)):\n        total += contri[i]\n        if total >= k:\n            ans = i + 2\n            break\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef Far(node, grp, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in grp[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeighT(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeighT(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfss(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfss(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfss(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeighT(nod, par, gr, H)\n    dfss(nod, par, gr, H, li, 1)\n\ndef GETSolution(grp, n, k):\n    if k == 1:\n        return 1\n    u = Far(1, grp, n)\n    li = []\n    breakIntoLines(u, 0, grp, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (nn, kk) = map(int, input().split())\n    grp = [[] for i in range(nn + 1)]\n    for i in range(nn - 1):\n        (u, v) = map(int, input().split())\n        grp[u].append(v)\n        grp[v].append(u)\n    chad = GETSolution(grp, nn, kk)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    done = [False] * (n + 1)\n    fd = -1\n    far = None\n    qu = [(node, 0)]\n    done[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            far = nod\n        for cnod in gr[nod]:\n            if done[cnod]:\n                continue\n            done[cnod] = True\n            qu.append((cnod, dis + 1))\n    return far\n\ndef fixHeight(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixHeight(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIntoLines(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixHeight(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef GETSOL(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIntoLines(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    chad = GETSOL(gr, n, k)\n    print(chad)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef getFar(node, gr, n):\n    do = [False] * (n + 1)\n    fd = -1\n    f = None\n    qu = [(node, 0)]\n    do[node] = True\n    while qu:\n        (nod, dis) = qu.pop(0)\n        if fd < dis:\n            fd = dis\n            f = nod\n        for cnod in gr[nod]:\n            if do[cnod]:\n                continue\n            do[cnod] = True\n            qu.append((cnod, dis + 1))\n    return f\n\ndef fixH(nod, par, gr, H):\n    isleaf = True\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        fixH(cnod, nod, gr, H)\n        H[nod] = max(H[nod], 1 + H[cnod])\n    if isleaf:\n        H[nod] = 1\n\ndef dfs(nod, par, gr, H, li, cur):\n    isleaf = True\n    mx = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        isleaf = False\n        mx = max(mx, H[cnod])\n    if isleaf:\n        li.append(cur)\n        return\n    c = 0\n    for cnod in gr[nod]:\n        if cnod == par:\n            continue\n        if H[cnod] == mx and c == 0:\n            dfs(cnod, nod, gr, H, li, cur + 1)\n            c += 1\n        else:\n            dfs(cnod, nod, gr, H, li, 1)\n\ndef breakIL(nod, par, gr, li, n, cur):\n    H = [0] * (n + 1)\n    fixH(nod, par, gr, H)\n    dfs(nod, par, gr, H, li, 1)\n\ndef solve(gr, n, k):\n    if k == 1:\n        return 1\n    u = getFar(1, gr, n)\n    li = []\n    breakIL(u, 0, gr, li, n, 1)\n    li.sort(reverse=True)\n    size = 1\n    total = 0\n    i = 0\n    while total < k:\n        size += 1\n        total += li[i]\n        i += 1\n    return size\nfor case in range(int(input())):\n    (n, k) = map(int, input().split())\n    gr = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        gr[u].append(v)\n        gr[v].append(u)\n    ch = solve(gr, n, k)\n    print(ch)"]