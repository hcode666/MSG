["from sys import setrecursionlimit\nsetrecursionlimit(int(1000000.0))\n\nclass DSU:\n\n    def __init__(self, s):\n        self.p = [-(i + 1) for i in s]\n\n    def find(self, n):\n        if self.p[n] < 0:\n            return n\n        self.p[n] = self.find(self.p[n])\n        return self.p[n]\n\n    def union(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            print('Invalid query!')\n        elif self.p[a] == self.p[b]:\n            return\n        elif self.p[a] < self.p[b]:\n            self.p[a] = min(self.p[a], self.p[b])\n            self.p[b] = a\n        else:\n            self.p[b] = min(self.p[a], self.p[b])\n            self.p[a] = b\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = list(map(int, input().split()))\n    d = DSU(s)\n    q = int(input())\n    for i in range(q):\n        a = list(map(int, input().split()))\n        if a[0] == 0:\n            d.union(a[1] - 1, a[2] - 1)\n        else:\n            print(d.find(a[1] - 1) + 1)", "from sys import setrecursionlimit\nsetrecursionlimit(int(1000000.0))\n\nclass DSU:\n\n    def __init__(self, s):\n        self.p = [-(i + 1) for i in s]\n\n    def find(self, n):\n        if self.p[n] < 0:\n            return n\n        self.p[n] = self.find(self.p[n])\n        return self.p[n]\n\n    def union(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            print('Invalid query!')\n        elif self.p[a] == self.p[b]:\n            return\n        elif self.p[a] < self.p[b]:\n            self.p[a] = min(self.p[a], self.p[b])\n            self.p[b] = a\n        else:\n            self.p[b] = min(self.p[a], self.p[b])\n            self.p[a] = b\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = list(map(int, input().split()))\n    d = DSU(s)\n    q = int(input())\n    for i in range(q):\n        a = list(map(int, input().split()))\n        if a[0] == 0:\n            d.union(a[1] - 1, a[2] - 1)\n        else:\n            print(d.find(a[1] - 1) + 1)", "def root(i):\n    while index[i] != i:\n        index[i] = index[index[i]]\n        i = index[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        index[b] = a\n    elif arr[b] > arr[a]:\n        index[a] = b\nfor _ in range(int(input())):\n    n1 = int(input())\n    ar = list(map(int, input().split()))\n    arr = [0] + ar\n    index = [i for i in range(n1 + 1)]\n    for t1 in range(int(input())):\n        compete = list(map(int, input().split()))\n        if compete[0] == 0:\n            (x1, y1) = (root(compete[1]), root(compete[2]))\n            if x1 == y1:\n                print('Invalid query!')\n            else:\n                union(x1, y1)\n        else:\n            print(root(compete[1]))", "def root(i):\n    while index[i] != i:\n        index[i] = index[index[i]]\n        i = index[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        index[b] = a\n    elif arr[b] > arr[a]:\n        index[a] = b\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    arr = [0] + ar\n    index = [i for i in range(n + 1)]\n    for t in range(int(input())):\n        compete = list(map(int, input().split()))\n        if compete[0] == 0:\n            (x, y) = (root(compete[1]), root(compete[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(root(compete[1]))", "def root(i):\n    while index[i] != i:\n        index[i] = index[index[i]]\n        i = index[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        index[b] = a\n    elif arr[b] > arr[a]:\n        index[a] = b\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    arr = [0] + ar\n    index = [i for i in range(n + 1)]\n    for t in range(int(input())):\n        compete = list(map(int, input().split()))\n        if compete[0] == 0:\n            (x, y) = (root(compete[1]), root(compete[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(root(compete[1]))", "def root(i):\n    while index[i] != i:\n        index[i] = index[index[i]]\n        i = index[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        index[b] = a\n    elif arr[b] > arr[a]:\n        index[a] = b\nfor _ in range(int(input())):\n    q = int(input())\n    ar = list(map(int, input().split()))\n    arr = [0] + ar\n    index = [i for i in range(q + 1)]\n    for t in range(int(input())):\n        compete = list(map(int, input().split()))\n        if compete[0] == 0:\n            (x, y) = (root(compete[1]), root(compete[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(root(compete[1]))", "def root(i):\n    while index[i] != i:\n        index[i] = index[index[i]]\n        i = index[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        index[b] = a\n    elif arr[b] > arr[a]:\n        index[a] = b\nfor _ in range(int(input())):\n    n1 = int(input())\n    ar = list(map(int, input().split()))\n    arr = [0] + ar\n    index = [i for i in range(n1 + 1)]\n    for t1 in range(int(input())):\n        compete = list(map(int, input().split()))\n        if compete[0] == 0:\n            (x1, y1) = (root(compete[1]), root(compete[2]))\n            if x1 == y1:\n                print('Invalid query!')\n            else:\n                union(x1, y1)\n        else:\n            print(root(compete[1]))", "def root(i):\n    while index[i] != i:\n        index[i] = index[index[i]]\n        i = index[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        index[b] = a\n    elif arr[b] > arr[a]:\n        index[a] = b\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    arr = [0] + ar\n    index = [i for i in range(n + 1)]\n    for t in range(int(input())):\n        compete = list(map(int, input().split()))\n        if compete[0] == 0:\n            (x, y) = (root(compete[1]), root(compete[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(root(compete[1]))", "def root(i):\n    while index[i] != i:\n        index[i] = index[index[i]]\n        i = index[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        index[b] = a\n    elif arr[b] > arr[a]:\n        index[a] = b\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    arr = [0] + ar\n    index = [i for i in range(n + 1)]\n    for t in range(int(input())):\n        compete = list(map(int, input().split()))\n        if compete[0] == 0:\n            (x, y) = (root(compete[1]), root(compete[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(root(compete[1]))", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    Z = list(map(int, input().split()))\n    S = [0] + Z\n    Q = int(input())\n    chef = [i for i in range(N + 1)]\n    for i in range(Q):\n        o = list(map(int, input().split()))\n        if o[0] == 0:\n            while chef[o[1]] != o[1]:\n                chef[o[1]] = chef[chef[o[1]]]\n                o[1] = chef[o[1]]\n            while chef[o[2]] != o[2]:\n                chef[o[2]] = chef[chef[o[2]]]\n                o[2] = chef[o[2]]\n            if o[1] == o[2]:\n                print('Invalid query!')\n            elif S[o[1]] > S[o[2]]:\n                chef[o[2]] = o[1]\n            elif S[o[1]] < S[o[2]]:\n                chef[o[1]] = o[2]\n        else:\n            while chef[o[1]] != o[1]:\n                chef[o[1]] = chef[chef[o[1]]]\n                o[1] = chef[o[1]]\n            print(o[1])", "T = int(input())\nfor tc in range(T):\n    N = int(input())\n    Z = list(map(int, input().split()))\n    S = [0] + Z\n    Q = int(input())\n    chef = [i for i in range(N + 1)]\n    for i in range(Q):\n        order = list(map(int, input().split()))\n        if order[0] == 0:\n            while chef[order[1]] != order[1]:\n                chef[order[1]] = chef[chef[order[1]]]\n                order[1] = chef[order[1]]\n            while chef[order[2]] != order[2]:\n                chef[order[2]] = chef[chef[order[2]]]\n                order[2] = chef[order[2]]\n            if order[1] == order[2]:\n                print('Invalid query!')\n            elif S[order[1]] > S[order[2]]:\n                chef[order[2]] = order[1]\n            elif S[order[1]] < S[order[2]]:\n                chef[order[1]] = order[2]\n        else:\n            while chef[order[1]] != order[1]:\n                chef[order[1]] = chef[chef[order[1]]]\n                order[1] = chef[order[1]]\n            print(order[1])", "T = int(input())\nfor tc in range(T):\n    N = int(input())\n    Z = list(map(int, input().split()))\n    S = [0] + Z\n    Q = int(input())\n    chef = [i for i in range(N + 1)]\n    for i in range(Q):\n        order = list(map(int, input().split()))\n        if order[0] == 0:\n            while chef[order[1]] != order[1]:\n                chef[order[1]] = chef[chef[order[1]]]\n                order[1] = chef[order[1]]\n            while chef[order[2]] != order[2]:\n                chef[order[2]] = chef[chef[order[2]]]\n                order[2] = chef[order[2]]\n            if order[1] == order[2]:\n                print('Invalid query!')\n            elif S[order[1]] > S[order[2]]:\n                chef[order[2]] = order[1]\n            elif S[order[1]] < S[order[2]]:\n                chef[order[1]] = order[2]\n        else:\n            while chef[order[1]] != order[1]:\n                chef[order[1]] = chef[chef[order[1]]]\n                order[1] = chef[order[1]]\n            print(order[1])", "def root(i):\n    while index[i] != i:\n        index[i] = index[index[i]]\n        i = index[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        index[b] = a\n    elif arr[b] > arr[a]:\n        index[a] = b\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    arr = [0] + ar\n    index = [i for i in range(n + 1)]\n    for t in range(int(input())):\n        compete = list(map(int, input().split()))\n        if compete[0] == 0:\n            (x, y) = (root(compete[1]), root(compete[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(root(compete[1]))", "lostTo = [-1] * 10000\n\ndef findOwner(i):\n    path = [i]\n    while lostTo[i] >= 0:\n        i = lostTo[i]\n        path.append(i)\n    for j in range(len(path) - 1):\n        lostTo[path[j]] = i\n    return i\nfor _ in range(int(input())):\n    N = int(input())\n    for i in range(N):\n        lostTo[i] = -1\n    S = list(map(int, input().split()))\n    bestDish = []\n    for i in range(N):\n        bestDish.append(S[i])\n    for _ in range(int(input())):\n        q = list(map(int, input().split()))\n        if q[0] == 1:\n            print(findOwner(q[1] - 1) + 1)\n        else:\n            o1 = findOwner(q[1] - 1)\n            o2 = findOwner(q[2] - 1)\n            if o1 == o2:\n                print('Invalid query!')\n            else:\n                if bestDish[o1] > bestDish[o2]:\n                    lostTo[o2] = o1\n                if bestDish[o1] < bestDish[o2]:\n                    lostTo[o1] = o2", "def root(i):\n    while index[i] != i:\n        index[i] = index[index[i]]\n        i = index[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        index[b] = a\n    elif arr[b] > arr[a]:\n        index[a] = b\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    arr = [0] + ar\n    index = [i for i in range(n + 1)]\n    for t in range(int(input())):\n        compete = list(map(int, input().split()))\n        if compete[0] == 0:\n            (x, y) = (root(compete[1]), root(compete[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(root(compete[1]))", "import sys\n\ndef find(i):\n    li = []\n    while i != dic[i]:\n        dic[i] = dic[dic[i]]\n        i = dic[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        dic[b] = a\n    elif arr[b] > arr[a]:\n        dic[a] = b\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    arr = [0] + ar\n    dic = {k: k for k in range(n + 1)}\n    q = int(input())\n    while q:\n        q -= 1\n        lis = list(map(int, input().split()))\n        if lis[0] == 0:\n            (x, y) = (find(lis[1]), find(lis[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(find(lis[1]))", "import sys\n\ndef find(i):\n    li = []\n    while i != dic[i]:\n        dic[i] = dic[dic[i]]\n        i = dic[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        dic[b] = a\n    elif arr[b] > arr[a]:\n        dic[a] = b\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, sys.stdin.readline().strip().split()))\n    arr = [0] + ar\n    dic = {k: k for k in range(n + 1)}\n    q = int(input())\n    while q:\n        q -= 1\n        lis = list(map(int, sys.stdin.readline().strip().split()))\n        if lis[0] == 0:\n            (x, y) = (find(lis[1]), find(lis[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(find(lis[1]))", "import sys\n\ndef find(i):\n    li = []\n    while i != dic[i]:\n        dic[i] = dic[dic[i]]\n        i = dic[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        dic[b] = a\n    elif arr[b] > arr[a]:\n        dic[a] = b\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, sys.stdin.readline().strip().split()))\n    arr = [0] + ar\n    dic = {k: k for k in range(n + 1)}\n    q = int(input())\n    while q:\n        q -= 1\n        lis = list(map(int, sys.stdin.readline().strip().split()))\n        if lis[0] == 0:\n            (x, y) = (find(lis[1]), find(lis[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(find(lis[1]))", "import sys\n\ndef find(i):\n    li = []\n    while i != dic[i]:\n        dic[i] = dic[dic[i]]\n        i = dic[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        dic[b] = a\n    elif arr[b] > arr[a]:\n        dic[a] = b\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    ar = list(map(int, sys.stdin.readline().strip().split()))\n    arr = [0] + ar\n    dic = {k: k for k in range(n + 1)}\n    q = int(input())\n    while q:\n        q -= 1\n        lis = list(map(int, sys.stdin.readline().strip().split()))\n        if lis[0] == 0:\n            (x, y) = (find(lis[1]), find(lis[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(find(lis[1]))", "import sys\n\ndef find(i):\n    li = []\n    while i != dic[i]:\n        dic[i] = dic[dic[i]]\n        i = dic[i]\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        dic[b] = a\n    elif arr[b] > arr[a]:\n        dic[a] = b\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    ar = list(map(int, sys.stdin.readline().strip().split()))\n    arr = [0] + ar\n    dic = {k: k for k in range(n + 1)}\n    q = int(input())\n    while q:\n        q -= 1\n        lis = list(map(int, sys.stdin.readline().strip().split()))\n        if lis[0] == 0:\n            (x, y) = (find(lis[1]), find(lis[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(find(lis[1]))", "import sys\n\ndef find(i):\n    li = []\n    while i != dic[i]:\n        li.append(i)\n        i = dic[i]\n    for j in li:\n        dic[j] = i\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        dic[b] = a\n    elif arr[b] > arr[a]:\n        dic[a] = b\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    ar = list(map(int, sys.stdin.readline().strip().split()))\n    arr = [0] + ar\n    dic = {k: k for k in range(n + 1)}\n    q = int(input())\n    while q:\n        q -= 1\n        lis = list(map(int, sys.stdin.readline().strip().split()))\n        if lis[0] == 0:\n            (x, y) = (find(lis[1]), find(lis[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(find(lis[1]))", "import sys\n\ndef find(i):\n    li = []\n    while i != dic[i]:\n        li.append(i)\n        i = dic[i]\n    for j in li:\n        dic[j] = i\n    return i\n\ndef union(a, b):\n    if arr[a] > arr[b]:\n        dic[b] = a\n    elif arr[b] > arr[a]:\n        dic[a] = b\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    ar = list(map(int, sys.stdin.readline().strip().split()))\n    arr = [0] + ar\n    dic = {k: k for k in range(n + 1)}\n    q = int(input())\n    while q:\n        q -= 1\n        lis = list(map(int, sys.stdin.readline().strip().split()))\n        if lis[0] == 0:\n            (x, y) = (find(lis[1]), find(lis[2]))\n            if x == y:\n                print('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            print(find(lis[1]))", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n\n    def find(a):\n        x = []\n        while par[a] != a:\n            x.append(a)\n            a = par[a]\n        for i in x:\n            par[i] = a\n        return a\n\n    def union(x, y):\n        if l[x] > l[y]:\n            par[y] = x\n        elif l[x] < l[y]:\n            par[x] = y\n    n = inp()\n    l = [0] + li()\n    par = {i: i for i in range(n + 1)}\n    q = inp()\n    for i in range(q):\n        p = li()\n        if len(p) == 3:\n            (a, b) = p[1:]\n            (x, y) = (find(a), find(b))\n            if x == y:\n                pr('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            pr(find(p[1]))\nfor _ in range(inp()):\n    solve()", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n\n    def find(a):\n        x = []\n        while par[a] != a:\n            x.append(a)\n            a = par[a]\n        for i in x:\n            par[i] = a\n        return a\n\n    def union(x, y):\n        x = find(x)\n        y = find(y)\n        if l[x] > l[y]:\n            par[y] = x\n        elif l[x] < l[y]:\n            par[x] = y\n    n = inp()\n    l = [0] + li()\n    par = {i: i for i in range(n + 1)}\n    q = inp()\n    for i in range(q):\n        p = li()\n        if len(p) == 3:\n            (a, b) = p[1:]\n            (x, y) = (find(a), find(b))\n            if x == y:\n                pr('Invalid query!')\n            else:\n                union(x, y)\n        else:\n            pr(find(p[1]))\nfor _ in range(inp()):\n    solve()", "import sys\nsys.setrecursionlimit(10 ** 4)\n\ndef union(parent, p, q, rank):\n    a = find(parent, p)\n    b = find(parent, q)\n    parent[b] = a\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    rank = [0] * (n + 1)\n    parent = [i for i in range(n + 1)]\n    s = [0] + [int(i) for i in input().split()]\n    q = int(input())\n    for i in range(q):\n        a = list(map(int, input().split()))\n        if a[0] == 0:\n            p = find(parent, a[1])\n            q = find(parent, a[2])\n            if p == q:\n                print('Invalid query!')\n            elif s[p] > s[q]:\n                union(parent, p, q, rank)\n            elif s[p] < s[q]:\n                union(parent, q, p, rank)\n        else:\n            print(find(parent, a[1]))", "from sys import stdin, stdout, setrecursionlimit\nimport math\nimport bisect\nimport resource\nresource.setrlimit(resource.RLIMIT_STACK, (2 ** 29, -1))\nsetrecursionlimit(10 ** 6)\n\nclass DSU:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n + 1)]\n        self.rank = [0 for i in range(n + 1)]\n\n    def find_set(self, v):\n        if v == self.parent[v]:\n            return v\n        self.parent[v] = self.find_set(self.parent[v])\n        return self.parent[v]\n\n    def union(self, a, b):\n        a = self.find_set(a)\n        b = self.find_set(b)\n        if a != b:\n            if cost[a] < cost[b]:\n                self.parent[a] = b\n            elif cost[a] > cost[b]:\n                self.parent[b] = a\n            return False\n        else:\n            return True\n\ndef main():\n    try:\n        for _ in range(I()):\n            n = I()\n            global cost\n            cost = [0] + list(In())\n            nq = I()\n            dsu = DSU(n)\n            for q in range(nq):\n                l = list(In())\n                if l[0] == 1:\n                    z = dsu.find_set(l[1])\n                    print(z)\n                else:\n                    ok = dsu.union(l[1], l[2])\n                    if ok:\n                        print('Invalid query!')\n    except:\n        pass\n\ndef add(a, b, c):\n    res = a + b\n    if res >= c:\n        return res - c\n    else:\n        return res\n\ndef mod(a, b, c):\n    res = a * b\n    if res >= c:\n        return res % c\n    else:\n        return res\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    w = a // gcd(a, b)\n    return w * b\n\ndef expo(a, b):\n    (x, y) = (1, a)\n    while b > 0:\n        if b & 1:\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\n\ndef power(a, b, m):\n    (x, y) = (1,)\n    while b > 0:\n        if b & 1:\n            x = mod(x, y, m)\n        y = mod(y, y, m)\n        b >>= 1\n    return x\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\nmain()", "def union(i, j):\n    fi = find(i)\n    fj = find(j)\n    if best[fi] > best[fj]:\n        dsu[fj] = fi\n    elif best[fj] > best[fi]:\n        dsu[fi] = fj\n\ndef find(x):\n    while dsu[x] != x:\n        dsu[x] = dsu[dsu[x]]\n        x = dsu[x]\n        best[x] = max(best[x], best[dsu[x]])\n        best[dsu[x]] = max(best[x], best[dsu[x]])\n    return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = int(input())\n    dsu = [i for i in range(n)]\n    best = [a[i] for i in range(n)]\n    for i in range(q):\n        quer = list(map(int, input().split()))\n        if quer[0] == 1:\n            print(find(quer[1] - 1) + 1)\n        else:\n            u1 = find(quer[1] - 1)\n            u2 = find(quer[2] - 1)\n            if u1 == u2:\n                print('Invalid query!')\n            else:\n                union(quer[2] - 1, quer[1] - 1)", "import sys\nfrom sys import stdin\nsys.setrecursionlimit(10 ** 6)\n\ndef find(n):\n    if grupy[n] == n:\n        return n\n    grupy[n] = find(grupy[n])\n    return grupy[n]\n\ndef union(l1, l2):\n    s1 = find(l1)\n    s2 = find(l2)\n    if s1 == s2:\n        print('Invalid query!')\n        return\n    if punkty[s1] > punkty[s2]:\n        wygrany = s1\n        przegrany = s2\n    elif punkty[s2] > punkty[s1]:\n        wygrany = s2\n        przegrany = s1\n    else:\n        return\n    grupy[przegrany] = wygrany\n    punkty[przegrany] = 0\nil_t = int(stdin.readline())\nfor i in range(il_t):\n    il_dan = int(stdin.readline())\n    grupy = list(range(0, il_dan + 1))\n    punkty = [0] + [int(x) for x in stdin.readline().split()]\n    il_pyt = int(stdin.readline())\n    for i in range(il_pyt):\n        pytanie = [int(x) for x in stdin.readline().split()]\n        if pytanie[0] == 0:\n            union(pytanie[1], pytanie[2])\n        else:\n            print(find(pytanie[1]))", "import sys\nfrom sys import stdin\nsys.setrecursionlimit(10 ** 6)\n\ndef find(n):\n    if grupy[n] == n:\n        return n\n    grupy[n] = find(grupy[n])\n    return grupy[n]\n\ndef union(l1, l2):\n    s1 = find(l1)\n    s2 = find(l2)\n    if punkty[s1] > punkty[s2]:\n        wygrany = s1\n        przegrany = s2\n    elif punkty[s2] > punkty[s1]:\n        wygrany = s2\n        przegrany = s1\n    elif punkty[s2] == punkty[s1] and s1 != s2:\n        return\n    if s1 != s2:\n        grupy[przegrany] = wygrany\n        punkty[przegrany] = 0\n    else:\n        print('Invalid query!')\nil_t = int(stdin.readline())\nfor i in range(il_t):\n    il_dan = int(stdin.readline())\n    grupy = list(range(0, il_dan + 1))\n    punkty = [0] + [int(x) for x in stdin.readline().split()]\n    il_pyt = int(stdin.readline())\n    for i in range(il_pyt):\n        pytanie = [int(x) for x in stdin.readline().split()]\n        if pytanie[0] == 0:\n            union(pytanie[1], pytanie[2])\n        else:\n            print(find(pytanie[1]))", "import sys\nfrom sys import stdin\nsys.setrecursionlimit(10 ** 6)\n\ndef find(n):\n    if grupy[n] == n:\n        return n\n    zmi = find(grupy[n])\n    grupy[n] = zmi\n    return zmi\n\ndef union(l1, l2):\n    s1 = find(l1)\n    s2 = find(l2)\n    if punkty[s1] > punkty[s2]:\n        wygrany = s1\n        przegrany = s2\n    elif punkty[s2] > punkty[s1]:\n        wygrany = s2\n        przegrany = s1\n    elif punkty[s2] == punkty[s1] and s1 != s2:\n        return\n    if s1 != s2:\n        grupy[przegrany] = wygrany\n        punkty[przegrany] = 0\n    else:\n        print('Invalid query!')\nil_t = int(stdin.readline())\nfor i in range(il_t):\n    il_dan = int(stdin.readline())\n    grupy = list(range(0, il_dan + 1))\n    punkty = [0] + [int(x) for x in stdin.readline().split()]\n    il_pyt = int(stdin.readline())\n    for i in range(il_pyt):\n        pytanie = [int(x) for x in stdin.readline().split()]\n        if pytanie[0] == 0:\n            union(int(pytanie[1]), int(pytanie[2]))\n        elif pytanie[0] == 1:\n            print(find(pytanie[1]))", "import sys\nfrom sys import stdin\nsys.setrecursionlimit(10 ** 6)\n\ndef find(n):\n    if grupy[n] == n:\n        return n\n    zmi = find(grupy[n])\n    grupy[n] = zmi\n    return zmi\n\ndef union(l1, l2):\n    s1 = find(l1)\n    s2 = find(l2)\n    if punkty[s1] > punkty[s2]:\n        wygrany = s1\n        przegrany = s2\n    elif punkty[s2] > punkty[s1]:\n        wygrany = s2\n        przegrany = s1\n    elif punkty[s2] == punkty[s1] and s1 != s2:\n        return\n    if s1 != s2:\n        grupy[przegrany] = wygrany\n        punkty[przegrany] = 0\n    else:\n        print('Invalid query!')\nil_t = int(input())\nfor i in range(il_t):\n    il_dan = int(input())\n    grupy = list(range(0, il_dan + 1))\n    punkty = [0] + [int(x) for x in input().split()]\n    il_pyt = int(input())\n    for i in range(il_pyt):\n        pytanie = [int(x) for x in input().split()]\n        if pytanie[0] == 0:\n            union(int(pytanie[1]), int(pytanie[2]))\n        elif pytanie[0] == 1:\n            print(find(pytanie[1]))", "def union(i, j):\n    fi = find(i)\n    fj = find(j)\n    if best[fi] > best[fj]:\n        dsu[fj] = fi\n    elif best[fj] > best[fi]:\n        dsu[fi] = fj\n\ndef find(x):\n    while dsu[x] != x:\n        dsu[x] = dsu[dsu[x]]\n        x = dsu[x]\n        best[x] = max(best[x], best[dsu[x]])\n        best[dsu[x]] = max(best[x], best[dsu[x]])\n    return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = int(input())\n    dsu = [i for i in range(n)]\n    best = [a[i] for i in range(n)]\n    for i in range(q):\n        quer = list(map(int, input().split()))\n        if quer[0] == 1:\n            print(find(quer[1] - 1) + 1)\n        else:\n            u1 = find(quer[1] - 1)\n            u2 = find(quer[2] - 1)\n            if u1 == u2:\n                print('Invalid query!')\n            else:\n                union(quer[2] - 1, quer[1] - 1)", "def findparent(x):\n    originalx = x\n    while x != -1:\n        oldx = x\n        x = parents[x]\n    if originalx != oldx:\n        parents[originalx] = oldx\n    return oldx\nfor _ in range(int(input())):\n    n = int(input())\n    parents = [-1 for i in range(n)]\n    s = list(map(int, input().split()))\n    q = int(input())\n    for i in range(q):\n        qr = list(map(int, input().split()))\n        if qr[0] == 1:\n            print(findparent(qr[1] - 1) + 1)\n        else:\n            p1 = findparent(qr[1] - 1)\n            p2 = findparent(qr[2] - 1)\n            if p1 == p2:\n                print('Invalid query!')\n            elif s[p1] < s[p2]:\n                parents[p1] = p2\n            elif s[p2] < s[p1]:\n                parents[p2] = p1", "def findparent(x):\n    originalx = x\n    while x != -1:\n        oldx = x\n        x = parents[x]\n    if originalx != oldx:\n        parents[originalx] = oldx\n    return oldx\nfor _ in range(int(input())):\n    n = int(input())\n    parents = [-1 for i in range(n)]\n    s = list(map(int, input().split()))\n    q = int(input())\n    for i in range(q):\n        qr = list(map(int, input().split()))\n        if qr[0] == 1:\n            print(findparent(qr[1] - 1) + 1)\n        else:\n            p1 = findparent(qr[1] - 1)\n            p2 = findparent(qr[2] - 1)\n            if p1 == p2:\n                print('Invalid query!')\n            elif s[p1] < s[p2]:\n                parents[p1] = p2\n            elif s[p2] < s[p1]:\n                parents[p2] = p1", "def union(i, j):\n    fi = find(i)\n    fj = find(j)\n    if best[fi] > best[fj]:\n        dsu[fj] = fi\n    elif best[fj] > best[fi]:\n        dsu[fi] = fj\n\ndef find(x):\n    while dsu[x] != x:\n        dsu[x] = dsu[dsu[x]]\n        x = dsu[x]\n        best[x] = max(best[x], best[dsu[x]])\n        best[dsu[x]] = max(best[x], best[dsu[x]])\n    return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = int(input())\n    dsu = [i for i in range(n)]\n    best = [a[i] for i in range(n)]\n    for i in range(q):\n        quer = list(map(int, input().split()))\n        if quer[0] == 1:\n            print(find(quer[1] - 1) + 1)\n        else:\n            u1 = find(quer[1] - 1)\n            u2 = find(quer[2] - 1)\n            if u1 == u2:\n                print('Invalid query!')\n            else:\n                union(quer[2] - 1, quer[1] - 1)", "def findparent(x):\n    originalx = x\n    while x != -1:\n        oldx = x\n        x = parents[x]\n    if originalx != oldx:\n        parents[originalx] = oldx\n    return oldx\nfor _ in range(int(input())):\n    n = int(input())\n    parents = [-1 for i in range(n)]\n    s = list(map(int, input().split()))\n    q = int(input())\n    for i in range(q):\n        qr = list(map(int, input().split()))\n        if qr[0] == 1:\n            print(findparent(qr[1] - 1) + 1)\n        else:\n            p1 = findparent(qr[1] - 1)\n            p2 = findparent(qr[2] - 1)\n            if p1 == p2:\n                print('Invalid query!')\n            elif s[p1] < s[p2]:\n                parents[p1] = p2\n            elif s[p2] < s[p1]:\n                parents[p2] = p1", "class DisjointSets:\n\n    def __init__(self, size):\n        self.scores = []\n        self.size = size\n        self.dish_chef = [i for i in range(size + 1)]\n\n    def find_chef(self, dish_num):\n        while self.dish_chef[dish_num] != dish_num:\n            self.dish_chef[dish_num] = self.dish_chef[self.dish_chef[dish_num]]\n            dish_num = self.dish_chef[dish_num]\n        return dish_num\n\n    def modify_chefs(self, dish1, dish2):\n        chef1 = self.find_chef(dish1)\n        chef2 = self.find_chef(dish2)\n        if chef1 == chef2:\n            print('Invalid query!')\n            return\n        if self.scores[chef1] > self.scores[chef2]:\n            self.dish_chef[chef2] = chef1\n        elif self.scores[chef1] < self.scores[chef2]:\n            self.dish_chef[chef1] = chef2\n\n    def input_scores(self):\n        self.scores = list(map(int, input().split()))\n        self.scores.insert(0, 0)\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    dis_set = DisjointSets(N)\n    dis_set.input_scores()\n    num_queries = int(input())\n    for j in range(num_queries):\n        list_ = input().split()\n        if list_[0] == '0':\n            dis_set.modify_chefs(int(list_[1]), int(list_[2]))\n        else:\n            print(dis_set.find_chef(int(list_[1])))", "def find(a):\n    parr = a\n    while par[parr] != parr:\n        parr = par[parr]\n    while par[a] != a:\n        temp = par[a]\n        par[a] = parr\n        a = temp\n    return parr\n\ndef union(a, b):\n    (a, b) = (find(a), find(b))\n    if a == b:\n        return\n    par[b] = a\nts = int(input())\nwhile ts > 0:\n    n = int(input())\n    cost = list(map(int, input().split()))\n    par = [i for i in range(n + 1)]\n    q = int(input())\n    for jj in range(q):\n        query = list(map(int, input().split()))\n        (a, b, x) = (0, 0, 0)\n        if query[0] == 0:\n            a = query[1]\n            b = query[2]\n            para = find(a)\n            parb = find(b)\n            if para == parb:\n                print('Invalid query!')\n            if cost[para - 1] > cost[parb - 1]:\n                union(para, parb)\n            elif cost[para - 1] < cost[parb - 1]:\n                union(parb, para)\n        else:\n            x = query[1]\n            print(find(x))\n    ts -= 1", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef findParent(dish, parent):\n    if parent[dish] == dish:\n        return dish\n    else:\n        parent[dish] = findParent(parent[dish], parent)\n        return parent[dish]\nfor t in range(int(input())):\n    n = int(input())\n    S = list(map(int, input().split()))\n    parent = [i for i in range(n)]\n    chef = [score for score in S]\n    for _ in range(int(input())):\n        query = list(map(int, input().strip().split()))\n        if query[0] == 0:\n            (x, y) = (query[1], query[2])\n            x -= 1\n            y -= 1\n            (dish1, dish2) = (x, y)\n            chef1 = findParent(dish1, parent)\n            chef2 = findParent(dish2, parent)\n            if chef1 == chef2:\n                print('Invalid query!')\n            elif chef[chef1] > chef[chef2]:\n                parent[chef2] = chef1\n            elif chef[chef1] < chef[chef2]:\n                parent[chef1] = chef2\n        else:\n            x = int(query[1])\n            print(findParent(x - 1, parent) + 1)", "import sys\nsys.setrecursionlimit(10000)\n\nclass DisjointSet:\n\n    def __init__(self, n):\n        p = [0] * (n + 1)\n        for i in range(1, n + 1):\n            p[i] = i\n        self.p = p\n        self.n = n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n            return self.p[x]\n        return self.p[x]\n\n    def union(self, dishscore, pa, pb):\n        if pa != pb:\n            if dishscore[pa - 1] > dishscore[pb - 1]:\n                self.p[pb] = pa\n            elif dishscore[pb - 1] > dishscore[pa - 1]:\n                self.p[pa] = pb\n        else:\n            sys.stdout.write('Invalid query!\\n')\n\ndef dishown():\n    t = int(sys.stdin.readline())\n    while t > 0:\n        n = int(sys.stdin.readline())\n        disset = DisjointSet(n)\n        dishscore = list(map(int, sys.stdin.readline().split()))\n        q = int(sys.stdin.readline())\n        for i in range(q):\n            query = list(map(int, sys.stdin.readline().split()))\n            if query[0] == 0:\n                a = query[1]\n                b = query[2]\n                pa = disset.find(a)\n                pb = disset.find(b)\n                disset.union(dishscore, pa, pb)\n            else:\n                sys.stdout.write(str(disset.find(query[1])) + '\\n')\n        t -= 1\ndishown()", "import sys\nsys.setrecursionlimit(10000)\n\nclass Node:\n\n    def __init__(self, data, score):\n        self.data = data\n        self.score = score\n        self.parent = self\n        self.rank = 1\n\ndef find_root(node):\n    if node != node.parent:\n        node.parent = find_root(node.parent)\n        return node.parent\n    return node.parent\n\ndef union_nodes(node_1, node_2):\n    (root_1, root_2) = (find_root(node_1), find_root(node_2))\n    if root_1 == root_2:\n        return '-1'\n    elif root_1.score > root_2.score:\n        root_2.parent = root_1\n    elif root_1.score < root_2.score:\n        root_1.parent = root_2\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    N = int(sys.stdin.readline())\n    Scores = list(map(int, sys.stdin.readline().strip().split(' ')))\n    vertex = [Node(i, s) for (i, s) in zip(range(1, N + 1), Scores)]\n    Q = int(sys.stdin.readline())\n    for i in range(Q):\n        query = list(map(int, sys.stdin.readline().strip().split(' ')))\n        if query[0] == 0:\n            (x, y) = (query[1], query[2])\n            result = union_nodes(vertex[x - 1], vertex[y - 1])\n            if result == '-1':\n                print('Invalid query!')\n        elif query[0] == 1:\n            x = query[1]\n            chef = find_root(vertex[x - 1])\n            print(chef.data)", "class Subset:\n\n    def __init__(self, parent, rank, score, owner):\n        self.parent = parent\n        self.rank = rank\n        self.score = score\n        self.owner = owner\n\ndef find(subsets, node):\n    if subsets[node].parent != node:\n        subsets[node].parent = find(subsets, subsets[node].parent)\n    return subsets[node].parent\n\ndef union(subsets, u, v):\n    if subsets[u].score == subsets[v].score:\n        return\n    if subsets[u].rank > subsets[v].rank:\n        subsets[v].parent = u\n        if subsets[u].score < subsets[v].score:\n            subsets[u].score = subsets[v].score\n            subsets[u].owner = subsets[v].owner\n    elif subsets[v].rank > subsets[u].rank:\n        subsets[u].parent = v\n        if subsets[v].score < subsets[u].score:\n            subsets[v].score = subsets[u].score\n            subsets[v].owner = subsets[u].owner\n    else:\n        subsets[v].parent = u\n        subsets[u].rank += 1\n        if subsets[u].score < subsets[v].score:\n            subsets[u].score = subsets[v].score\n            subsets[u].owner = subsets[v].owner\nt = int(input())\nwhile t != 0:\n    n = int(input())\n    s = list(map(int, input().split()))\n    subsets = []\n    subsets.append(Subset(0, 0, 0, 0))\n    for i in range(1, n + 1):\n        subsets.append(Subset(i, 0, s[i - 1], i))\n    q = int(input())\n    while q != 0:\n        x = list(map(int, input().split()))\n        if x[0] == 0:\n            u_id = find(subsets, x[1])\n            v_id = find(subsets, x[2])\n            if u_id == v_id:\n                print('Invalid query!')\n            else:\n                union(subsets, u_id, v_id)\n        else:\n            u_id = find(subsets, x[1])\n            print(subsets[u_id].owner)\n        q -= 1\n    t -= 1", "def union(i, j):\n    fi = find(i)\n    fj = find(j)\n    if best[fi] > best[fj]:\n        dsu[fj] = fi\n    elif best[fj] > best[fi]:\n        dsu[fi] = fj\n\ndef find(x):\n    while dsu[x] != x:\n        dsu[x] = dsu[dsu[x]]\n        x = dsu[x]\n        best[x] = max(best[x], best[dsu[x]])\n        best[dsu[x]] = max(best[x], best[dsu[x]])\n    return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = int(input())\n    dsu = [i for i in range(n)]\n    best = [a[i] for i in range(n)]\n    for i in range(q):\n        quer = list(map(int, input().split()))\n        if quer[0] == 1:\n            print(find(quer[1] - 1) + 1)\n        else:\n            u1 = find(quer[1] - 1)\n            u2 = find(quer[2] - 1)\n            if u1 == u2:\n                print('Invalid query!')\n            else:\n                union(quer[2] - 1, quer[1] - 1)", "def find1(owner, x):\n    z = x\n    while owner[x] != -1:\n        x = owner[x]\n    while owner[z] != -1:\n        temp = owner[z]\n        owner[z] = x\n        z = temp\n    return x\nt = int(input())\nfor ijk in range(0, t):\n    n = int(input())\n    s = list(map(int, input().strip().split()))\n    q = int(input())\n    owner = [-1] * n\n    for i in range(0, q):\n        query = list(map(int, input().strip().split()))\n        if query[0] == 0:\n            if find1(owner, query[1] - 1) == find1(owner, query[2] - 1):\n                print('Invalid query!')\n            else:\n                x1 = find1(owner, query[1] - 1)\n                x2 = find1(owner, query[2] - 1)\n                if s[x1] > s[x2]:\n                    owner[x2] = x1\n                elif s[x2] > s[x1]:\n                    owner[x1] = x2\n        else:\n            ans = find1(owner, query[1] - 1)\n            print(ans + 1)", "def find_parent(x):\n    y = x\n    while y != parent[y]:\n        y = parent[y]\n    while x != parent[x]:\n        z = parent[x]\n        parent[x] = y\n        x = z\n    return y\nfor _ in range(int(input())):\n    N = int(input())\n    S = [int(x) for x in input().split()]\n    parent = [i for i in range(N)]\n    chef = [i for i in range(N)]\n    for _ in range(int(input())):\n        query = [int(x) for x in input().split()]\n        if query[0] == 0:\n            x = find_parent(query[1] - 1)\n            y = find_parent(query[2] - 1)\n            if x == y:\n                print('Invalid query!')\n            elif S[chef[x]] > S[chef[y]]:\n                parent[y] = x\n                chef[y] = chef[x]\n            elif S[chef[x]] < S[chef[y]]:\n                parent[x] = y\n                chef[x] = chef[y]\n        else:\n            print(chef[find_parent(query[1] - 1)] + 1)", "def find(child):\n    new_parent = child\n    while new_parent != parents[new_parent]:\n        new_parent = parents[new_parent]\n    while child != parents[child]:\n        temp = parents[child]\n        parents[child] = new_parent\n        child = temp\n    return new_parent\n\ndef union(root1, root2):\n    (real_root1, real_root2) = (find(root1), find(root2))\n    if ratings[real_root1] > ratings[real_root2]:\n        parents[real_root2] = real_root1\n    elif ratings[real_root1] < ratings[real_root2]:\n        parents[real_root1] = real_root2\nfor _ in range(int(input().strip())):\n    n = int(input().strip())\n    parents = list(range(n))\n    ratings = list(map(int, input().strip().split()))\n    queries = int(input())\n    for query in range(queries):\n        inp = list(map(int, input().strip().split()))\n        if inp[0] == 0:\n            (root1, root2) = (inp[1] - 1, inp[2] - 1)\n            if find(root1) == find(root2):\n                print('Invalid query!')\n            else:\n                union(root1, root2)\n        else:\n            print(find(inp[1] - 1) + 1)", "def find(child):\n    new_parent = child\n    while new_parent != parents[new_parent]:\n        new_parent = parents[new_parent]\n    while child != parents[child]:\n        temp = parents[child]\n        parents[child] = new_parent\n        child = temp\n    return new_parent\n\ndef union(root1, root2):\n    (real_root1, real_root2) = (find(root1), find(root2))\n    if ratings[chef[real_root1]] > ratings[chef[real_root2]]:\n        parents[real_root2] = real_root1\n        chef[real_root2] = chef[real_root1]\n    elif ratings[chef[real_root1]] < ratings[chef[real_root2]]:\n        parents[real_root1] = real_root2\n        chef[real_root1] = chef[real_root2]\nfor _ in range(int(input().strip())):\n    n = int(input().strip())\n    parents = list(range(n))\n    chef = list(range(n))\n    ratings = list(map(int, input().strip().split()))\n    queries = int(input())\n    for query in range(queries):\n        inp = list(map(int, input().strip().split()))\n        if inp[0] == 0:\n            (root1, root2) = (inp[1] - 1, inp[2] - 1)\n            if find(root1) == find(root2):\n                print('Invalid query!')\n            else:\n                union(root1, root2)\n        else:\n            print(find(inp[1] - 1) + 1)", "def find(child):\n    new_parent = child\n    while new_parent != parents[new_parent]:\n        new_parent = parents[new_parent]\n    while child != parents[child]:\n        temp = parents[child]\n        parents[child] = new_parent\n        child = temp\n    return new_parent\n\ndef union(r1, r2):\n    (mr1, mr2) = (find(r1), find(r2))\n    if ratings[chef[mr1]] > ratings[chef[mr2]]:\n        parents[mr2] = mr1\n        chef[mr2] = chef[mr1]\n    elif ratings[chef[mr1]] < ratings[chef[mr2]]:\n        parents[mr1] = mr2\n        chef[mr1] = chef[mr2]\nfor _ in range(int(input())):\n    n = int(input())\n    parents = list(range(n))\n    chef = list(range(n))\n    ratings = list(map(int, input().strip().split()))\n    queries = int(input())\n    for query in range(queries):\n        inp = list(map(int, input().strip().split()))\n        if inp[0] == 0:\n            (r1, r2) = (inp[1] - 1, inp[2] - 1)\n            if find(r1) == find(r2):\n                print('Invalid query!')\n            else:\n                union(r1, r2)\n        else:\n            print(find(inp[1] - 1) + 1)", "x = int(input())\ndish = []\nowner = []\n\ndef calculate(a, b):\n    f1 = root(a)\n    f2 = root(b)\n    if f1 == f2:\n        print('Invalid query!')\n    elif dish[f1] > dish[f2]:\n        owner[f2] = owner[f1]\n    elif dish[f1] < dish[f2]:\n        owner[f1] = owner[f2]\n\ndef root(i):\n    while owner[i] != i:\n        owner[i] = owner[owner[i]]\n        i = owner[i]\n    return i\nwhile x > 0:\n    n = int(input())\n    dish = list(map(int, input().split()))\n    for i in range(n):\n        owner.append(i)\n    q = int(input())\n    query = []\n    for s in range(0, q):\n        query = list(map(int, input().split()))\n        if query[0] == 0:\n            calculate(query[1] - 1, query[2] - 1)\n        else:\n            ow = root(query[1] - 1)\n            print(ow + 1)\n        query.clear()\n    dish.clear()\n    owner.clear()\n    x -= 1", "def find(child):\n    new_parent = child\n    while new_parent != parents[new_parent]:\n        new_parent = parents[new_parent]\n    while child != parents[child]:\n        temp = parents[child]\n        parents[child] = new_parent\n        child = temp\n    return new_parent\n\ndef union(root1, root2):\n    (real_root1, real_root2) = (find(root1), find(root2))\n    if ratings[chef[real_root1]] > ratings[chef[real_root2]]:\n        parents[real_root2] = real_root1\n        chef[real_root2] = chef[real_root1]\n    elif ratings[chef[real_root1]] < ratings[chef[real_root2]]:\n        parents[real_root1] = real_root2\n        chef[real_root1] = chef[real_root2]\nfor _ in range(int(input().strip())):\n    n = int(input().strip())\n    parents = list(range(n))\n    chef = list(range(n))\n    ratings = list(map(int, input().strip().split()))\n    queries = int(input())\n    for query in range(queries):\n        inp = list(map(int, input().strip().split()))\n        if inp[0] == 0:\n            (root1, root2) = (inp[1] - 1, inp[2] - 1)\n            if find(root1) == find(root2):\n                print('Invalid query!')\n            else:\n                union(root1, root2)\n        else:\n            print(find(inp[1] - 1) + 1)", "def find_parent(x):\n    y = x\n    while y != parent[y]:\n        y = parent[y]\n    while x != parent[x]:\n        z = parent[x]\n        parent[x] = y\n        x = z\n    return y\nT = int(input())\nfor i in range(0, T):\n    N = int(input())\n    S = [*map(int, input().split())]\n    parent = [i for i in range(0, N)]\n    chef = [i for i in range(0, N)]\n    Q = int(input())\n    for j in range(0, Q):\n        query = [*map(int, input().split())]\n        if query[0] == 0:\n            x = find_parent(query[1] - 1)\n            y = find_parent(query[2] - 1)\n            if x == y:\n                print('Invalid query!')\n            elif S[chef[x]] > S[chef[y]]:\n                parent[y] = x\n                chef[y] = chef[x]\n            elif S[chef[x]] < S[chef[y]]:\n                parent[x] = y\n                chef[x] = chef[y]\n        else:\n            print(chef[find_parent(query[1] - 1)] + 1)", "class union:\n\n    def __init__(self, n):\n        self.n = n\n        self.array = [i for i in range(n)]\n        self.size = n * [1]\n        self.value = n * [0]\n\n    def root_of(self, pos):\n        if pos >= self.n or pos < 0:\n            return -1\n        link_to_root = []\n        p = pos\n        while self.array[p] != p:\n            link_to_root.append(p)\n            p = self.array[p]\n        root = p\n        for p in link_to_root:\n            self.array[p] = root\n        return root\n\n    def connect(self, x, y):\n        root_x = self.root_of(x)\n        root_y = self.root_of(y)\n        if root_x == root_y:\n            return False\n        if self.value[root_x] > self.value[root_y]:\n            self.array[root_y] = root_x\n        elif self.value[root_x] < self.value[root_y]:\n            self.array[root_x] = root_y\n        return True\n\n    def count_of_trees(self):\n        total = 0\n        for i in range(self.n):\n            if self.array[i] == i:\n                total += 1\n        return total\n\n    def trees_values(self):\n        values = []\n        for i in range(self.n):\n            if self.array[i] == i:\n                values.append(self.value[i])\n        return values\n\n    def __str__(self):\n        s = ''\n        for el in self.array:\n            s += str(el) + ' '\n        return s\nfor _ in range(int(input().strip())):\n    n = int(input().strip())\n    un = union(n)\n    v = list(map(int, input().strip().split()))\n    for i in range(n):\n        un.value[i] = v[i]\n    for _ in range(int(input().strip())):\n        ar = list(map(int, input().strip().split()))\n        if ar[0] == 0:\n            done = un.connect(ar[1] - 1, ar[2] - 1)\n            if not done:\n                print('Invalid query!')\n        else:\n            print(un.root_of(ar[1] - 1) + 1)", "import sys\nsys.setrecursionlimit(100000)\n\ndef find(x):\n    if x != l[x]:\n        l[x] = find(l[x])\n    return l[x]\n\ndef union(x, y):\n    x1 = find(x)\n    y1 = find(y)\n    if x1 == y1:\n        print('Invalid query!')\n    elif s[x1] > s[y1]:\n        l[y1] = x1\n    elif s[y1] > s[x1]:\n        l[x1] = y1\nfor t in range(int(input())):\n    n = int(input())\n    s = list(map(int, input().split()))\n    s = [0] + s\n    l = [i for i in range(n + 2)]\n    for _ in range(int(input())):\n        q = list(map(int, input().split()))\n        if len(q) == 3 and q[0] == 0:\n            (x, y) = (q[1], q[2])\n            union(x, y)\n        else:\n            x = q[1]\n            u = find(x)\n            print(u)"]