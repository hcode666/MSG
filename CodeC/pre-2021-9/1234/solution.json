["import sys\npekerja = []\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef faktor(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(factors, arr, pos):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(factors, arr, pos + 1))\n        arr[i] //= factors[pos]\n    return ans\nfor j in range(int(input())):\n    (k, x) = get_ints()\n    factors = faktor(x)\n    lenn = len(factors)\n    if lenn <= k:\n        ans = sum(factors) + k - lenn\n    else:\n        arr = [1] * k\n        ans = bruteForce(factors, arr, 0)\n    pekerja.append(ans)\nfor j in pekerja:\n    print(j)", "import sys\npekerja = []\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef faktor(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(factors, arr, pos):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(factors, arr, pos + 1))\n        arr[i] //= factors[pos]\n    return ans\nfor j in range(int(input())):\n    (k, x) = get_ints()\n    factors = faktor(x)\n    lenn = len(factors)\n    if lenn <= k:\n        ans = sum(factors) + k - lenn\n    else:\n        arr = [1] * k\n        ans = bruteForce(factors, arr, 0)\n    pekerja.append(ans)\nfor j in pekerja:\n    print(j)", "import sys, math, itertools, random, bisect\nfrom collections import defaultdict\nINF = 10 ** 18\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\n\ndef factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(factors, arr, pos):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(factors, arr, pos + 1))\n        arr[i] //= factors[pos]\n    return ans\nfor _ in range(int(input())):\n    (k, x) = get_ints()\n    factors = factorize(x)\n    lenn = len(factors)\n    if lenn <= k:\n        ans = sum(factors) + k - lenn\n    else:\n        arr = [1] * k\n        ans = bruteForce(factors, arr, 0)\n    print(ans)", "from math import log2\nimport bisect\nfrom bisect import bisect_left, bisect_right\nimport sys\nfrom math import gcd, sqrt\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\ninf = float('inf')\n\ndef get_factors(x):\n    if x == 1:\n        return []\n    sqrta = int(sqrt(x)) + 1\n    for i in range(2, sqrta):\n        if x % i == 0:\n            return [i] + get_factors(x // i)\n    return [x]\n\ndef min_generator(fac, k, index, new_list):\n    if index == len(fac):\n        return sum(new_list)\n    mina = inf\n    for i in range(0, min(index + 1, len(new_list))):\n        new_list[i] *= fac[index]\n        theta = min_generator(fac, k, index + 1, new_list)\n        if theta < mina:\n            mina = theta\n        new_list[i] //= fac[index]\n    return mina\n\ndef fun(k, x):\n    dict = defaultdict(lambda : 1)\n    factors = get_factors(x)\n    for i in factors:\n        dict[i] *= i\n    if len(dict) == k:\n        print(sum(dict.values()))\n        return\n    if len(dict) < k:\n        suma = sum(dict.values())\n        left = k - len(dict)\n        suma += left\n        print(suma)\n        return\n    if k == 1:\n        print(x)\n        return\n    fac = list(dict.values())\n    new_list = [1] * k\n    theta = min_generator(fac, k, 0, new_list)\n    print(theta)\nfor i in range(int(input())):\n    (k, x) = map(int, input().split())\n    fun(k, x)", "def factors(n):\n    factor = []\n    for i in range(2, int(n ** (1 / 2)) + 1):\n        cnt = 0\n        if n % i == 0:\n            while n % i == 0:\n                cnt += 1\n                n = n // i\n            factor.append(i ** cnt)\n    if n != 1:\n        factor.append(n)\n    return factor\n\ndef bruteforce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteforce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nfor _ in range(int(input())):\n    (k, n) = list(map(int, input().split()))\n    fac = factors(n)\n    if len(fac) == k:\n        print(sum(fac))\n    elif len(fac) < k:\n        print(sum(fac) + k - len(fac))\n    else:\n        arr = [1] * k\n        d = bruteforce(0, arr, fac)\n        print(d)", "def factorize(n):\n    fact = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            c = 0\n            while n % i == 0:\n                c += 1\n                n //= i\n            fact.append(i ** c)\n    if n != 1:\n        fact.append(n)\n    return fact\n\ndef brute(pos, ar, fact):\n    if pos == len(fact):\n        return sum(ar)\n    ans = float('inf')\n    for i in range(len(ar)):\n        ar[i] *= fact[pos]\n        ans = min(ans, brute(pos + 1, ar, fact))\n        ar[i] //= fact[pos]\n    return ans\nt = int(input())\nwhile t > 0:\n    (k, x) = map(int, input().split())\n    fact = factorize(x)\n    lenn = len(fact)\n    if lenn <= k:\n        ans = sum(fact) + k - lenn\n    else:\n        ar = [1] * k\n        ans = brute(0, ar, fact)\n    print(ans)\n    t -= 1", "def all_pcombo(arr, factors, pos):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, all_pcombo(arr, factors, pos + 1))\n        arr[i] //= factors[pos]\n    return ans\n\ndef factorization(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cnt = 0\n            while n % i == 0:\n                cnt += 1\n                n //= i\n            factors.append(i ** cnt)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve():\n    (k, x) = map(int, input().split())\n    factors = factorization(x)\n    len_ = len(factors)\n    ans = 0\n    if len_ <= k:\n        ans = sum(factors) + k - len_\n    else:\n        arr = [1] * k\n        ans = all_pcombo(arr, factors, 0)\n    print(ans)\nt = int(input())\nwhile t > 0:\n    solve()\n    t -= 1", "def all_pcombo(arr, factors, pos):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, all_pcombo(arr, factors, pos + 1))\n        arr[i] //= factors[pos]\n    return ans\n\ndef factorization(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cnt = 0\n            while n % i == 0:\n                cnt += 1\n                n //= i\n            factors.append(i ** cnt)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve():\n    (k, x) = map(int, input().split())\n    factors = factorization(x)\n    len_ = len(factors)\n    ans = 0\n    if len_ <= k:\n        ans = sum(factors) + k - len_\n    else:\n        arr = [1] * k\n        ans = all_pcombo(arr, factors, 0)\n    print(ans)\nt = int(input())\nwhile t > 0:\n    solve()\n    t -= 1", "import sys\nsys.setrecursionlimit(10000000)\n\ndef primes(x):\n    f = []\n    i = 2\n    while i * i <= x:\n        if x % i == 0:\n            t = 1\n            while x % i == 0:\n                x //= i\n                t *= i\n            f.append(t)\n        i += 1\n    if x > 1:\n        f.append(x)\n    return f\n\ndef recur(arr):\n    if len(arr) == k:\n        return sum(arr)\n    answer = float('inf')\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            temp = arr[:]\n            temp.remove(arr[i])\n            temp.remove(arr[j])\n            temp.append(arr[i] * arr[j])\n            answer = min(answer, recur(temp))\n    return answer\nfor _ in range(int(input())):\n    (k, X) = map(int, input().split())\n    p = primes(X)\n    if k >= len(p):\n        print(sum(p) + (k - len(p)))\n        continue\n    print(recur(p))", "import math\n\ndef factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef brtueforce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, brtueforce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\n\ndef solve():\n    (k, x) = map(int, input().split())\n    factors = factorize(x)\n    lenn = len(factors)\n    if lenn <= k:\n        ans = sum(factors) + k - lenn\n    else:\n        arr = [1] * k\n        ans = brtueforce(0, arr, factors)\n    print(ans)\nt = int(input())\nfor i in range(t):\n    solve()", "def factorizing(n):\n    factor = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count = 0\n            while n % i == 0:\n                count += 1\n                n //= i\n            factor.append(i ** count)\n    if n != 1:\n        factor.append(n)\n    return factor\n\ndef getans(a, f, p):\n    if p == len(f):\n        return sum(a)\n    ans = float('inf')\n    for i in range(len(a)):\n        a[i] *= f[p]\n        ans = min(ans, getans(a, f, p + 1))\n        a[i] //= f[p]\n    return ans\nT = int(input())\nwhile T:\n    T -= 1\n    (k, x) = map(int, input().split())\n    factors = factorizing(x)\n    if len(factors) <= k:\n        ans = sum(factors) + k - len(factors)\n    else:\n        a = [1] * k\n        ans = getans(a, factors, 0)\n    print(ans)", "def find_div(x):\n    b = []\n    e = int(x ** 0.5) + 1\n    for i in range(2, e):\n        if x % i == 0:\n            c = 0\n            while x % i == 0:\n                c += 1\n                x = x // i\n            b.append(i ** c)\n    if x != 1:\n        b.append(x)\n    return b\n\ndef solve(a, div, pos):\n    if pos == len(div):\n        return sum(a)\n    ans = 2 ** 30\n    for i in range(len(a)):\n        a[i] *= div[pos]\n        ans = min(ans, solve(a, div, pos + 1))\n        a[i] = a[i] // div[pos]\n    return ans\nt = int(input())\nfor _ in range(t):\n    (k, x) = map(int, input().split())\n    div = find_div(x)\n    if len(div) <= k:\n        ans = sum(div) + k - len(div)\n    else:\n        a = [1] * k\n        ans = solve(a, div, 0)\n    print(ans)", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cnt = 0\n            while n % i == 0:\n                cnt += 1\n                n //= i\n            factors.append(i ** cnt)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef brute(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, brute(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nt = int(input())\nwhile t:\n    (k, x) = map(int, input().split())\n    factors = factorize(x)\n    if len(factors) <= k:\n        ans = sum(factors) + k - len(factors)\n    else:\n        arr = [1] * k\n        ans = brute(0, arr, factors)\n    print(ans)\n    t -= 1", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cnt = 0\n            while n % i == 0:\n                cnt += 1\n                n //= i\n            factors.append(i ** cnt)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef brute(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, brute(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nt = int(input())\nwhile t:\n    (k, x) = map(int, input().split())\n    factors = factorize(x)\n    if len(factors) <= k:\n        ans = sum(factors) + k - len(factors)\n    else:\n        arr = [1] * k\n        ans = brute(0, arr, factors)\n    print(ans)\n    t -= 1", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nt = int(input())\nwhile t != 0:\n    (k, x) = map(int, input().split())\n    factors = factorize(x)\n    lenn = len(factors)\n    if lenn <= k:\n        ans = sum(factors) + k - lenn\n    else:\n        arr = [1] * k\n        ans = bruteForce(0, arr, factors)\n    print(ans)\n    t = t - 1", "MAX = 1000005\nprime = [True] * MAX\nfact = [list() for i in range(MAX)]\nfor i in range(2, MAX):\n    if prime[i]:\n        for j in range(i, MAX, i):\n            prime[j] = False\n            fact[j].append(i)\n\ndef solve(arr, i, k):\n    if i >= len(arr):\n        return sum(k)\n    z = float('inf')\n    for j in range(len(k)):\n        k[j] *= arr[i]\n        z = min(z, solve(arr, i + 1, k))\n        k[j] //= arr[i]\n    return z\nt = int(input())\nfor i in range(t):\n    (k, x) = map(int, input().split())\n    temp = []\n    for y in fact[x]:\n        p = x\n        z = 1\n        while p % y == 0:\n            p //= y\n            z *= y\n        temp.append(z)\n    if k >= len(fact[x]):\n        print(sum(temp) + k - len(temp))\n    else:\n        print(solve(temp, 0, [1] * k))", "def brute(ind, arr, factors):\n    if ind == len(factors):\n        return sum(arr)\n    ans = 10000000000000\n    for i in range(len(arr)):\n        arr[i] *= factors[ind]\n        ans = min(ans, brute(ind + 1, arr, factors))\n        arr[i] //= factors[ind]\n    return ans\n\ndef factorize(x):\n    factors = []\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            count = 0\n            while x % i == 0:\n                count += 1\n                x //= i\n            factors.append(i ** count)\n    if x != 1:\n        factors.append(x)\n    return factors\nt = int(input())\nfor _ in range(t):\n    (k, x) = map(int, input().split())\n    factors = factorize(x)\n    if len(factors) <= k:\n        print(sum(factors) + k - len(factors))\n    else:\n        arr = [1] * k\n        print(brute(0, arr, factors))", "try:\n    MAX = 1000005\n    prime = [True] * MAX\n    fact = [list() for i in range(MAX)]\n    for i in range(2, MAX):\n        if prime[i]:\n            for j in range(i, MAX, i):\n                prime[j] = False\n                fact[j].append(i)\n\n    def solve(arr, i, k):\n        if i >= len(arr):\n            return sum(k)\n        z = float('inf')\n        for j in range(len(k)):\n            k[j] *= arr[i]\n            z = min(z, solve(arr, i + 1, k))\n            k[j] //= arr[i]\n        return z\n    t = int(input())\n    for i in range(t):\n        (k, x) = map(int, input().split())\n        temp = []\n        for y in fact[x]:\n            p = x\n            z = 1\n            while p % y == 0:\n                p //= y\n                z *= y\n            temp.append(z)\n        if k >= len(fact[x]):\n            print(sum(temp) + k - len(temp))\n        else:\n            print(solve(temp, 0, [1] * k))\nexcept EOFError as e:\n    pass", "MAX = 1000005\nprime = [True] * MAX\nfact = [list() for i in range(MAX)]\nfor i in range(2, MAX):\n    if prime[i]:\n        for j in range(i, MAX, i):\n            prime[j] = False\n            fact[j].append(i)\n\ndef solve(arr, i, k):\n    if i >= len(arr):\n        return sum(k)\n    z = float('inf')\n    for j in range(len(k)):\n        k[j] *= arr[i]\n        z = min(z, solve(arr, i + 1, k))\n        k[j] //= arr[i]\n    return z\nt = int(input())\nfor i in range(t):\n    (k, x) = map(int, input().split())\n    temp = []\n    for y in fact[x]:\n        p = x\n        z = 1\n        while p % y == 0:\n            p //= y\n            z *= y\n        temp.append(z)\n    if k >= len(fact[x]):\n        print(sum(temp) + k - len(temp))\n    else:\n        print(solve(temp, 0, [1] * k))", "MAX = 1000005\nprime = [True] * MAX\nfact = [list() for i in range(MAX)]\nfor i in range(2, MAX):\n    if prime[i]:\n        for j in range(i, MAX, i):\n            prime[j] = False\n            fact[j].append(i)\n\ndef solve(arr, i, k):\n    if i >= len(arr):\n        return sum(k)\n    z = float('inf')\n    for j in range(len(k)):\n        k[j] *= arr[i]\n        z = min(z, solve(arr, i + 1, k))\n        k[j] //= arr[i]\n    return z\nt = int(input())\nfor i in range(t):\n    (k, x) = map(int, input().split())\n    temp = []\n    for y in fact[x]:\n        p = x\n        z = 1\n        while p % y == 0:\n            p //= y\n            z *= y\n        temp.append(z)\n    if k >= len(fact[x]):\n        print(sum(temp) + k - len(temp))\n    else:\n        print(solve(temp, 0, [1] * k))", "def primeFactors(n):\n    factors = []\n    cnt = 0\n    if n % 2 == 0:\n        while n % 2 == 0:\n            cnt += 1\n            n = n // 2\n        factors.append(2 ** cnt)\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        cnt = 0\n        if n % i == 0:\n            while n % i == 0:\n                cnt += 1\n                n = n // i\n            factors.append(i ** cnt)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef minSum(arr, k):\n    if len(arr) == k:\n        return sum(arr)\n    ans = 1e+18\n    for i in range(len(arr) - 1):\n        temp = []\n        for j in range(i + 1, len(arr)):\n            temp = [arr[i] * arr[j]] + arr[:i] + arr[i + 1:j] + arr[j + 1:]\n            ans = min(ans, minSum(temp, k))\n    return ans\nTC = int(input())\nfor tc in range(TC):\n    (k, x) = map(int, input().strip().split())\n    factors = primeFactors(x)\n    if len(factors) <= k:\n        print(sum(factors) + k - len(factors))\n    else:\n        print(minSum(factors, k))", "import sys\nsys.setrecursionlimit(10000000)\n\ndef primeFactors(n):\n    factors = []\n    cnt = 0\n    if n % 2 == 0:\n        while n % 2 == 0:\n            cnt += 1\n            n = n // 2\n        factors.append(2 ** cnt)\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        cnt = 0\n        if n % i == 0:\n            while n % i == 0:\n                cnt += 1\n                n = n // i\n            factors.append(i ** cnt)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef minSum(arr, k):\n    if len(arr) == k:\n        return sum(arr)\n    ans = 1e+18\n    for i in range(len(arr) - 1):\n        temp = []\n        for j in range(i + 1, len(arr)):\n            temp = [arr[i] * arr[j]] + arr[:i] + arr[i + 1:j] + arr[j + 1:]\n            ans = min(ans, minSum(temp, k))\n    return ans\nTC = int(input())\nfor tc in range(TC):\n    (k, x) = map(int, input().strip().split())\n    factors = primeFactors(x)\n    if len(factors) <= k:\n        print(sum(factors) + k - len(factors))\n    else:\n        print(minSum(factors, k))", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef recur(arr):\n    if len(arr) == k:\n        return sum(arr)\n    res = float('inf')\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            temp = arr[:]\n            temp.remove(arr[i])\n            temp.remove(arr[j])\n            temp.append(arr[i] * arr[j])\n            res = min(res, recur(temp))\n    return res\nfor i in range(int(input())):\n    (k, x) = map(int, input().split())\n    arr = factorize(x)\n    if len(arr) < k:\n        print(sum(arr) + k - len(arr))\n    else:\n        print(recur(arr))", "import sys\nsys.setrecursionlimit(10000000)\n\ndef primes(x):\n    f = []\n    i = 2\n    while i * i <= x:\n        if x % i == 0:\n            t = 1\n            while x % i == 0:\n                x //= i\n                t *= i\n            f.append(t)\n        i += 1\n    if x > 1:\n        f.append(x)\n    return f\n\ndef recur(arr):\n    if len(arr) == k:\n        return sum(arr)\n    answer = float('inf')\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            temp = arr[:]\n            temp.remove(arr[i])\n            temp.remove(arr[j])\n            temp.append(arr[i] * arr[j])\n            answer = min(answer, recur(temp))\n    return answer\nfor _ in range(int(input())):\n    (k, X) = map(int, input().split())\n    p = primes(X)\n    if k >= len(p):\n        print(sum(p) + (k - len(p)))\n        continue\n    print(recur(p))", "def prime(n):\n    ans = []\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            temp1 = 1\n            while n % i == 0:\n                n //= i\n                temp1 *= i\n            ans.append(temp1)\n        i += 1\n    if n > 1:\n        ans.append(n)\n    return ans\n\ndef recur(arr, k):\n    if len(arr) == k:\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            temp = arr[:]\n            temp.remove(arr[i])\n            temp.remove(arr[j])\n            temp.append(arr[i] * arr[j])\n            ans = min(ans, recur(temp, k))\n    return ans\ntc = int(input())\nfor i in range(tc):\n    (k, x) = map(int, input().split())\n    p = prime(x)\n    if len(p) <= k:\n        print(sum(p) + k - len(p))\n    else:\n        print(recur(p, k))", "import sys\nsys.setrecursionlimit(10000000)\n\ndef prime(n):\n    ans = []\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            temp1 = 1\n            while n % i == 0:\n                n //= i\n                temp1 *= i\n            ans.append(temp1)\n        i += 1\n    if n > 1:\n        ans.append(n)\n    return ans\n\ndef recur(arr, k):\n    if len(arr) == k:\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            temp = arr[:]\n            temp.remove(arr[i])\n            temp.remove(arr[j])\n            temp.append(arr[i] * arr[j])\n            ans = min(ans, recur(temp, k))\n    return ans\ntc = int(input())\nfor i in range(tc):\n    (k, x) = map(int, input().split())\n    p = prime(x)\n    if len(p) <= k:\n        print(sum(p) + k - len(p))\n    else:\n        print(recur(p, k))", "import math\n\ndef primeFactors(n):\n    d = {}\n    while n % 2 == 0:\n        n = n // 2\n        if 2 in d:\n            d[2] += 1\n        else:\n            d[2] = 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n            n = n // i\n    if n > 2:\n        if n in d:\n            d[n] += 1\n        else:\n            d[n] = 1\n    return d\n\ndef get_all_combs(arr, left):\n    global g\n    if not left:\n        g.append(sum(arr))\n    else:\n        new = left.pop()\n        for i in range(len(arr)):\n            newarr = arr.copy()\n            newarr[i] *= new\n            get_all_combs(newarr, left.copy())\nfor test in range(int(input())):\n    (k, x) = map(int, input().split())\n    d = primeFactors(x)\n    if k < len(d):\n        p = [item ** d[item] for item in d]\n        xo = [1] * k\n        g = []\n        get_all_combs(xo, p)\n        print(min(g))\n        continue\n    c2 = 0\n    for item in d:\n        c2 += item ** d[item]\n    diff = k - len(d)\n    c2 += diff\n    print(c2)", "from math import sqrt\nfrom collections import Counter\nfrom itertools import combinations as com\n\ndef get(l, k):\n    if len(l) == k:\n        return sum(l)\n    n = len(l)\n    m = 1000000000000\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            a = l.copy()\n            a.remove(l[i])\n            a.remove(l[j])\n            a.append(l[i] * l[j])\n            m = min(m, get(a, k))\n    return m\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    n = x\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n // 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n // i\n    if n > 2:\n        l.append(n)\n    cc = Counter(l)\n    l = [i ** cc[i] for i in cc]\n    if len(l) > k:\n        print(get(l, k))\n    else:\n        r = sum(l) + (k - len(l))\n        print(r)", "def solve(i=0):\n    if i == len(pfs):\n        return sum(a)\n    mini = float('inf')\n    for j in range(k):\n        a[j] *= pfs[i]\n        mini = min(mini, solve(i + 1))\n        a[j] //= pfs[i]\n    return mini\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    ox = x\n    pfs = []\n    for i in range(2, int(x ** 0.5) + 1):\n        c = 0\n        while x % i == 0:\n            x //= i\n            c += 1\n        if c > 0:\n            pfs.append(i ** c)\n    if x > 1:\n        pfs.append(x)\n    if len(pfs) <= k:\n        print(sum(pfs) + k - len(pfs))\n        continue\n    a = [1] * k\n    print(solve())", "def solve(i=0):\n    if i == len(pfs):\n        return sum(a)\n    mini = float('inf')\n    for j in range(k):\n        a[j] *= pfs[i]\n        mini = min(mini, solve(i + 1))\n        a[j] //= pfs[i]\n    return mini\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    ox = x\n    pfs = []\n    for i in range(2, int(x ** 0.5) + 1):\n        c = 0\n        while x % i == 0:\n            x //= i\n            c += 1\n        if c > 0:\n            pfs.append(i ** c)\n    if x > 1:\n        pfs.append(x)\n    if len(pfs) <= k:\n        print(sum(pfs) + k - len(pfs))\n        continue\n    a = [1] * k\n    print(solve())", "def solve(i, a, pfs):\n    if i == len(pfs):\n        return sum(a)\n    mini = float('inf')\n    for j in range(k):\n        a[j] *= pfs[i]\n        mini = min(mini, solve(i + 1, a, pfs))\n        a[j] //= pfs[i]\n    return mini\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    ox = x\n    pfs = []\n    for i in range(2, int(x ** 0.5) + 1):\n        c = 0\n        while x % i == 0:\n            x //= i\n            c += 1\n        if c > 0:\n            pfs.append(i ** c)\n    if x > 1:\n        pfs.append(x)\n    if len(pfs) <= k:\n        print(sum(pfs) + k - len(pfs))\n        continue\n    a = [1] * k\n    print(solve(0, a, pfs))", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr = cntr + 1\n                n = n // i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(pos + 1, arr, factors))\n        arr[i] = arr[i] // factors[pos]\n    return ans\nTC = int(input())\nfor tc in range(TC):\n    (K, X) = map(int, input().split())\n    factors = factorize(X)\n    lenn = len(factors)\n    if lenn <= K:\n        ans = sum(factors) + (K - lenn)\n    else:\n        arr = [1] * K\n        ans = bruteForce(0, arr, factors)\n    print(ans)", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr = cntr + 1\n                n = n // i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(pos + 1, arr, factors))\n        arr[i] = arr[i] // factors[pos]\n    return ans\nTC = int(input())\nfor tc in range(TC):\n    (K, X) = map(int, input().split())\n    factors = factorize(X)\n    lenn = len(factors)\n    if lenn <= K:\n        ans = sum(factors) + (K - lenn)\n    else:\n        arr = [1] * K\n        ans = bruteForce(0, arr, factors)\n    print(ans)", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr = cntr + 1\n                n = n // i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(pos + 1, arr, factors))\n        arr[i] = arr[i] // factors[pos]\n    return ans\nTC = int(input())\nfor tc in range(TC):\n    (K, X) = map(int, input().split())\n    factors = factorize(X)\n    lenn = len(factors)\n    if lenn <= K:\n        ans = sum(factors) + (K - lenn)\n    else:\n        arr = [1] * K\n        ans = bruteForce(0, arr, factors)\n    print(ans)", "import math\nimport sys\nfrom functools import partial, reduce\nfrom typing import Dict, List, Sequence, TypeVar\nSAMPLE_IN = 'sample.in'\nSAMPLE_ANS = 'sample.ans'\n\ndef read_ints(f) -> list:\n    return [int(x) for x in f.readline().split()]\n\ndef read_case(f=sys.stdin):\n    return read_ints(f)\n\ndef get_primes_until(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = False\n    is_prime[1] = False\n    lim = int(math.sqrt(n))\n    for i in range(2, lim):\n        if not is_prime[i]:\n            continue\n        for j in range(2 * i, n + 1, i):\n            is_prime[j] = False\n    primes = [2] + [i for i in range(3, n + 1, 2) if is_prime[i]]\n    return primes\nPRIMES = get_primes_until(1000000)\n\ndef factorize(n, primes=PRIMES):\n    powers = []\n    x = n\n    for p in primes:\n        c = 0\n        while x % p == 0:\n            x //= p\n            c += 1\n        if c > 0:\n            powers.append((p, c))\n        if x == 1:\n            return powers\n    raise ValueError('{} is too big, you need more primes'.format(n))\n\ndef solve(n, x) -> tuple:\n    if n == 1:\n        return x\n    powers = factorize(x)\n    if len(powers) <= n:\n        return n - len(powers) + sum((p ** exp for (p, exp) in powers))\n    else:\n        factors = [p ** exp for (p, exp) in powers]\n\n        def sum_of_products(groups):\n            return sum((reduce(lambda a, b: a * b, group) for group in groups))\n        return min((sum_of_products(partition) for partition in partitions_of_size(factors, n)))\nT = TypeVar('T')\n\ndef build_partition(items: Sequence[T], part_of: Dict[int, int]) -> List[List[T]]:\n    num_parts = 1 + max(part_of)\n    parts = [[] for _ in range(num_parts)]\n    for i in range(len(items)):\n        parts[part_of[i]].append(items[i])\n    return parts\n\ndef partitions_of_size(items, size):\n    n = len(items)\n    part_of = []\n\n    def f(current_num_parts, index_to_append):\n        part_of.append(index_to_append)\n        if index_to_append == current_num_parts < size:\n            current_num_parts += 1\n        max_num_parts = current_num_parts + n - len(part_of)\n        if max_num_parts >= size:\n            if len(part_of) == n:\n                yield build_partition(items, part_of)\n            else:\n                end = min(size, current_num_parts + 1)\n                for i in range(end):\n                    yield from f(current_num_parts, i)\n        part_of.pop()\n    return f(0, 0)\n\ndef make_submission(fin=sys.stdin, fout=sys.stdout):\n    output = partial(print, file=fout)\n    n_cases = int(fin.readline())\n    for t in range(n_cases):\n        case = read_case(fin)\n        answer = solve(*case)\n        output(answer, file=fout)\nimport os\nif os.getenv('GCJ_LOCAL'):\n    with open(SAMPLE_IN) as fin:\n        make_submission(fin)\nelse:\n    make_submission()", "import math\nimport sys\nfrom functools import partial, reduce\nfrom typing import Dict, List, Sequence, TypeVar\nSAMPLE_IN = 'sample.in'\nSAMPLE_ANS = 'sample.ans'\n\ndef read_ints(f) -> list:\n    return [int(x) for x in f.readline().split()]\n\ndef read_case(f=sys.stdin):\n    return read_ints(f)\n\ndef get_primes_until(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = False\n    is_prime[1] = False\n    lim = int(math.sqrt(n))\n    for i in range(2, lim):\n        if not is_prime[i]:\n            continue\n        for j in range(2 * i, n + 1, i):\n            is_prime[j] = False\n    primes = [2] + [i for i in range(3, n + 1, 2) if is_prime[i]]\n    return primes\nPRIMES = get_primes_until(1000000)\n\ndef factorize(n, primes=PRIMES):\n    powers = []\n    x = n\n    for p in primes:\n        c = 0\n        while x % p == 0:\n            x //= p\n            c += 1\n        if c > 0:\n            powers.append((p, c))\n        if x == 1:\n            return powers\n    raise ValueError('{} is too big, you need more primes'.format(n))\n\ndef solve(n, x) -> tuple:\n    if n == 1:\n        return x\n    powers = factorize(x)\n    if len(powers) <= n:\n        return n - len(powers) + sum((p ** exp for (p, exp) in powers))\n    else:\n        factors = [p ** exp for (p, exp) in powers]\n\n        def sum_of_products(groups):\n            return sum((reduce(lambda a, b: a * b, group) for group in groups))\n        return min((sum_of_products(partition) for partition in partitions_of_size(factors, n)))\nT = TypeVar('T')\n\ndef build_partition(items: Sequence[T], part_of: Dict[int, int]) -> List[List[T]]:\n    num_parts = 1 + max(part_of)\n    parts = [[] for _ in range(num_parts)]\n    for i in range(len(items)):\n        parts[part_of[i]].append(items[i])\n    return parts\n\ndef partitions(items):\n    n = len(items)\n    part_of = []\n\n    def f(max_index, index_to_append):\n        part_of.append(index_to_append)\n        if len(part_of) == n:\n            yield build_partition(items, part_of)\n        else:\n            if index_to_append == max_index:\n                max_index += 1\n            for i in range(max_index + 1):\n                yield from f(max_index, i)\n        part_of.pop()\n    return f(0, 0)\n\ndef partitions_of_size(items, size):\n    n = len(items)\n    part_of = []\n\n    def f(current_num_parts, index_to_append):\n        part_of.append(index_to_append)\n        if index_to_append == current_num_parts < size:\n            current_num_parts += 1\n        max_num_parts = current_num_parts + n - len(part_of)\n        if max_num_parts >= size:\n            if len(part_of) == n:\n                yield build_partition(items, part_of)\n            else:\n                end = min(size, current_num_parts + 1)\n                for i in range(end):\n                    yield from f(current_num_parts, i)\n        part_of.pop()\n    return f(0, 0)\n\ndef make_submission(fin=sys.stdin, fout=sys.stdout):\n    output = partial(print, file=fout)\n    n_cases = int(fin.readline())\n    for t in range(n_cases):\n        case = read_case(fin)\n        answer = solve(*case)\n        output(answer, file=fout)\nimport os\nif os.getenv('GCJ_LOCAL'):\n    with open(SAMPLE_IN) as fin:\n        make_submission(fin)\nelse:\n    make_submission()", "import math\n\ndef factorize(n):\n    factors = []\n    count = 0\n    while n % 2 == 0:\n        count += 1\n        n = n // 2\n    if count != 0:\n        factors.append(2 ** count)\n    count = 0\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            count += 1\n            n = n // i\n        if count != 0:\n            factors.append(i ** count)\n        count = 0\n    if n > 2:\n        factors.append(n)\n    return factors\n\ndef bruteForce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nTC = int(input())\nfor tc in range(TC):\n    (K, X) = map(int, input().split())\n    factors = factorize(X)\n    lenn = len(factors)\n    if lenn <= K:\n        ans = sum(factors) + K - lenn\n    else:\n        arr = [1] * K\n        ans = bruteForce(0, arr, factors)\n    print(ans)", "from fractions import Fraction\nimport bisect\nimport os\nimport io\nfrom collections import Counter\nimport bisect\nfrom collections import defaultdict\nimport math\nimport random\nimport heapq\nfrom math import sqrt\nimport sys\nfrom functools import reduce, cmp_to_key\nfrom collections import deque\nimport threading\nfrom itertools import combinations\nfrom io import BytesIO, IOBase\nfrom itertools import accumulate\nfrom queue import Queue\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef iinput():\n    return int(input())\n\ndef tinput():\n    return input().split()\n\ndef rinput():\n    return map(int, tinput())\n\ndef rlinput():\n    return list(rinput())\nmod = int(1000000000.0) + 7\n\ndef factors(n):\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\ndef swap(arr, a, b):\n    (arr[a], arr[b]) = (arr[b], arr[a])\n\ndef getPrimeFactors(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            value = i\n            count = 0\n            while n % value == 0:\n                count += 1\n                n //= value\n            factors.append(value ** count)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef partitions(pos, partition, factors):\n    if pos == len(factors):\n        return sum(partition)\n    ans = float('inf')\n    for i in range(len(partition)):\n        partition[i] *= factors[pos]\n        ans = min(ans, partitions(pos + 1, partition, factors))\n        partition[i] //= factors[pos]\n    return ans\n\ndef solve(K, X):\n    factors = getPrimeFactors(X)\n    lenn = len(factors)\n    if K >= lenn:\n        return sum(factors) + K - lenn\n    else:\n        partition = [1] * K\n        return partitions(0, partition, factors)\nfor _ in range(iinput()):\n    (K, X) = rinput()\n    print(solve(K, X))", "import sys\nfrom math import sqrt\nimport math\nfrom collections import defaultdict as df\n\ndef ini():\n    return int(sys.stdin.readline())\n\ndef inp():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef li():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef p(n):\n    d = df(lambda : 0)\n    while n % 2 == 0:\n        d[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            d[i] += 1\n            n = n / i\n    if n > 2:\n        d[int(n)] += 1\n    return d\n\ndef check(l, n):\n    if len(l) == n:\n        return sum(l)\n    maxi = float('inf')\n    for i in range(len(l) - 1):\n        for j in range(i + 1, len(l)):\n            t = l.copy()\n            t.remove(l[i])\n            t.remove(l[j])\n            t.append(l[i] * l[j])\n            maxi = min(maxi, check(t, n))\n    return maxi\nfor i in range(ini()):\n    (n, k) = inp()\n    d = p(k)\n    l = [value ** d[value] for value in d.keys()]\n    if n >= len(l):\n        print(sum(l) + (n - len(l)))\n    else:\n        print(check(l, n))", "def bruteforce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteforce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nfor _ in range(int(input())):\n    (n, x) = list(map(int, input().split()))\n    factors = []\n    k = n\n    h = x\n    for i in range(2, int(h ** 0.5) + 1):\n        if h % i == 0:\n            cnt = 0\n            while h % i == 0:\n                h //= i\n                cnt += 1\n            factors.append(i ** cnt)\n    if h != 1:\n        factors.append(h)\n    m = len(factors)\n    if m == k:\n        print(sum(factors))\n    elif m < k:\n        print(sum(factors) + k - m)\n    else:\n        arr = [1] * k\n        ans = bruteforce(0, arr, factors)\n        print(ans)", "import math\nfrom collections import defaultdict\n\ndef pp(n):\n    l = dict()\n    while n % 2 == 0:\n        if 2 in l.keys():\n            l[2] += 1\n        else:\n            l[2] = 1\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            if i in l.keys():\n                l[i] += 1\n            else:\n                l[i] = 1\n            n = n // i\n    if n > 2:\n        l[n] = 1\n    return l\n\ndef tp(s, k, a):\n    ans = float('inf')\n    tp = [0 for i in range(s)]\n    req = [k - 1 for i in range(s)]\n    while tp != req:\n        arr = [1 for i in range(k)]\n        for i in range(s):\n            arr[tp[i]] *= a[i]\n        if ans > sum(arr):\n            ans = sum(arr)\n        for i in range(s - 1, -1, -1):\n            if tp[i] < k - 1:\n                tp[i] += 1\n                break\n            else:\n                tp[i] = 0\n    return ans\nfor a0 in range(int(input())):\n    (k, x) = [int(x) for x in input().split()]\n    l = pp(x)\n    a = []\n    for i in l.keys():\n        a.append(i ** l[i])\n    if k >= len(a):\n        print(sum(a) + k - len(a))\n    else:\n        print(tp(len(a), k, a))", "def factorise(num):\n    factors = []\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            power = 0\n            while num % i == 0:\n                power += 1\n                num = num // i\n            factors.append(i ** power)\n    if num != 1:\n        factors.append(num)\n    return factors\n\ndef bruteforce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteforce(pos + 1, arr, factors))\n        arr[i] = arr[i] // factors[pos]\n    return ans\nt = int(input())\nfor _ in range(t):\n    (work, days) = map(int, input().split())\n    factors = factorise(days)\n    n = len(factors)\n    if n == work:\n        print(sum(factors))\n    elif n < work:\n        total = sum(factors) + work - n\n        print(total)\n    else:\n        arr = [1] * work\n        ans = bruteforce(0, arr, factors)\n        print(ans)", "from sys import stdin, stdout, stderr, maxsize\ntup = lambda : map(int, stdin.readline().split())\nI = lambda : int(stdin.readline())\nlint = lambda : [int(x) for x in stdin.readline().split()]\nS = lambda : stdin.readline().replace('\\n', '').strip()\nstpr = lambda x: stdout.write(f'{x}' + '\\n')\nstar = lambda x: print(' '.join(map(str, x)))\nfrom math import ceil, floor, gcd\nfrom _collections import defaultdict\nfrom bisect import bisect_left, bisect_right\nfrom itertools import combinations\n\ndef primes(x):\n    f = []\n    i = 2\n    while i * i <= x:\n        if x % i == 0:\n            t = 1\n            while x % i == 0:\n                x //= i\n                t *= i\n            f.append(t)\n        i += 1\n    if x > 1:\n        f.append(x)\n    return f\n\ndef recur(arr):\n    ans = maxsize\n    if len(arr) == k:\n        return sum(arr)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            t = arr[:]\n            t[i] = t[i] * t[j]\n            t.remove(t[j])\n            ans = min(ans, recur(t))\n    return ans\nfor _ in range(I()):\n    (k, x) = tup()\n    p = primes(x)\n    if len(p) <= k:\n        t = k - len(p)\n        print(sum(p) + t)\n        continue\n    print(recur(p))", "import math\n\ndef factors(x):\n    fac = []\n    for i in range(2, x // 2):\n        ctr = 0\n        if x % i == 0:\n            while x % i == 0:\n                ctr += 1\n                x /= i\n            fac.append(i ** ctr)\n    if x != 1:\n        fac.append(x)\n    return fac\n\ndef combo(pos, factors, lst):\n    if pos == len(factors):\n        return sum(lst)\n    ans = math.inf\n    for i in range(len(lst)):\n        lst[i] *= factors[pos]\n        ans = min(ans, combo(pos + 1, factors, lst))\n        lst[i] /= factors[pos]\n    return ans\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    lst = factors(x)\n    if len(lst) <= k:\n        print(int(sum(lst) + (k - len(lst))))\n    else:\n        lst = k * [1]\n        ans = combo(0, factors(x), lst)\n        print(int(ans))", "def bruteforce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteforce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nfor _ in range(int(input())):\n    (n, x) = list(map(int, input().split()))\n    factors = []\n    k = n\n    h = x\n    for i in range(2, int(h ** 0.5) + 1):\n        if h % i == 0:\n            cnt = 0\n            while h % i == 0:\n                h //= i\n                cnt += 1\n            factors.append(i ** cnt)\n    if h != 1:\n        factors.append(h)\n    m = len(factors)\n    if m == k:\n        print(sum(factors))\n    elif m < k:\n        print(sum(factors) + k - m)\n    else:\n        arr = [1] * k\n        ans = bruteforce(0, arr, factors)\n        print(ans)", "from math import gcd\n\ndef getFactors(x):\n    factors = []\n    temp = 1\n    while x % 2 == 0:\n        x = x // 2\n        temp *= 2\n    if temp > 1:\n        factors.append(temp)\n    for i in range(3, int(x ** 0.5) + 1, 2):\n        temp = 1\n        while x % i == 0:\n            x = x // i\n            temp *= i\n        if temp > 1:\n            factors.append(temp)\n    if x > 1:\n        factors.append(x)\n    return factors\n\ndef reduce(factors, k):\n\n    def func(cur):\n        if cur == len(factors):\n            ans[0] = min(ans[0], sum(partitions))\n            return\n        for i in range(k):\n            partitions[i] *= factors[cur]\n            func(cur + 1)\n            partitions[i] = partitions[i] // factors[cur]\n    partitions = [1 for i in range(k)]\n    ans = [float('inf')]\n    func(0)\n    return ans[0]\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    factors = getFactors(x)\n    if len(factors) <= k:\n        print(sum(factors) + k - len(factors))\n    else:\n        print(reduce(factors, k))", "from sys import setrecursionlimit\nsetrecursionlimit(1000000)\n\ndef primeFactors(n):\n    if n % 2 == 0:\n        num.append(1)\n        while n % 2 == 0:\n            num[-1] *= 2\n            n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            num.append(1)\n            while n % i == 0:\n                num[-1] *= i\n                n //= i\n    if n > 1:\n        num.append(n)\n\ndef final(l):\n    x = len(l)\n    if x == k:\n        return sum(l)\n    ans = float('inf')\n    for i in range(x - 1):\n        for j in range(i + 1, x):\n            num1 = l[:]\n            num1.remove(l[i])\n            num1.remove(l[j])\n            num1.append(l[i] * l[j])\n            ans = min(ans, final(num1))\n    return ans\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    num = []\n    primeFactors(x)\n    n = len(num)\n    if k >= n:\n        print(sum(num) + k - n)\n    else:\n        print(final(num))", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nT = int(input())\nfor tc in range(T):\n    (K, X) = map(int, input().split())\n    factors = factorize(X)\n    lenn = len(factors)\n    if lenn <= K:\n        ans = sum(factors) + K - lenn\n    else:\n        arr = [1] * K\n        ans = bruteForce(0, arr, factors)\n    print(ans)", "from sys import setrecursionlimit\nsetrecursionlimit(1000000)\n\ndef primeFactors(n):\n    if n % 2 == 0:\n        num.append(1)\n        while n % 2 == 0:\n            num[-1] *= 2\n            n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            num.append(1)\n            while n % i == 0:\n                num[-1] *= i\n                n //= i\n    if n > 2:\n        num.append(n)\n\ndef final(l):\n    if len(l) == k:\n        return sum(l)\n    ans = float('inf')\n    for i in range(len(l) - 1):\n        for j in range(i + 1, len(l)):\n            num1 = l[:]\n            num1.remove(l[i])\n            num1.remove(l[j])\n            num1.append(l[i] * l[j])\n            ans = min(ans, final(num1))\n    return ans\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    num = []\n    primeFactors(x)\n    n = len(num)\n    if k >= n:\n        print(sum(num) + k - n)\n    else:\n        print(final(num))", "from sys import setrecursionlimit\nsetrecursionlimit(1000000)\n\ndef prime(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return 0\n    return 1\n\ndef primeFactors(n):\n    if n % 2 == 0:\n        num.append(1)\n        while n % 2 == 0:\n            num[-1] *= 2\n            n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            num.append(1)\n            while n % i == 0:\n                num[-1] *= i\n                n //= i\n    if n > 2:\n        num.append(n)\n\ndef final(l):\n    if len(l) == k:\n        return sum(l)\n    ans = float('inf')\n    for i in range(len(l) - 1):\n        for j in range(i + 1, len(l)):\n            num1 = l[:]\n            num1.remove(l[i])\n            num1.remove(l[j])\n            num1.append(l[i] * l[j])\n            ans = min(ans, final(num1))\n    return ans\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    if prime(x):\n        print(x + k - 1)\n    else:\n        num = []\n        primeFactors(x)\n        n = len(num)\n        if k >= n:\n            print(sum(num) + k - n)\n        else:\n            print(final(num))", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nTC = int(input())\nfor tc in range(TC):\n    (K, X) = map(int, input().split())\n    factors = factorize(X)\n    lenn = len(factors)\n    if lenn <= K:\n        ans = sum(factors) + K - lenn\n    else:\n        arr = [1] * K\n        ans = bruteForce(0, arr, factors)\n    print(ans)", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nTC = int(input())\nfor tc in range(TC):\n    (K, X) = map(int, input().split())\n    factors = factorize(X)\n    lenn = len(factors)\n    if lenn <= K:\n        ans = sum(factors) + K - lenn\n    else:\n        arr = [1] * K\n        ans = bruteForce(0, arr, factors)\n    print(ans)", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nTC = int(input())\nfor tc in range(TC):\n    (K, X) = map(int, input().split())\n    factors = factorize(X)\n    lenn = len(factors)\n    if lenn <= K:\n        ans = sum(factors) + K - lenn\n    else:\n        arr = [1] * K\n        ans = bruteForce(0, arr, factors)\n    print(ans)", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteForce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteForce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nTC = int(input())\nfor tc in range(TC):\n    (K, X) = map(int, input().split())\n    factors = factorize(X)\n    lenn = len(factors)\n    if lenn <= K:\n        ans = sum(factors) + K - lenn\n    else:\n        arr = [1] * K\n        ans = bruteForce(0, arr, factors)\n    print(ans)", "import sys\nimport math\nfrom collections import defaultdict, Counter\ninput = sys.stdin.readline\n\ndef print(x):\n    sys.stdout.write(str(x) + '\\n')\n\ndef find(a, ind):\n    global ans\n    if ind == len(d1):\n        ans = min(ans, sum(a))\n        return\n    prev = a[:]\n    for j in range(k):\n        a[j] *= d1[ind]\n        find(a, ind + 1)\n        a = prev[:]\nt = int(input())\nfor i in range(t):\n    (k, x) = map(int, input().split())\n    d = defaultdict(int)\n    if x % 2 == 0:\n        while x % 2 == 0:\n            d[2] += 1\n            x //= 2\n        d[2] = pow(2, d[2])\n    for j in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % j == 0:\n            while x % j == 0:\n                d[j] += 1\n                x //= j\n            d[j] = pow(j, d[j])\n    if x > 2:\n        d[x] = x\n    d1 = list(d.values())\n    if len(d1) <= k:\n        ans = sum(d1)\n        ans += k - len(d1)\n    else:\n        ans = 10 ** 9\n        for j in range(k):\n            a = [1] * k\n            a[j] *= d1[0]\n            find(a, 1)\n    print(ans)", "primef = [[] for i in range(10 ** 6 + 1)]\nfor val in range(2, 10 ** 6):\n    if primef[val] != []:\n        continue\n    else:\n        for i in range(val, 10 ** 6 + 1, val):\n            primef[i].append(val)\n\ndef min_possible(a):\n    if len(a) == k:\n        return sum(a)\n    value = 10 ** 8\n    for i in range(len(a) - 1):\n        for j in range(i + 1, len(a)):\n            x = a[:]\n            temp = a[i] * a[j]\n            x.remove(a[i])\n            x.remove(a[j])\n            x.append(temp)\n            value = min(value, min_possible(x))\n    return value\n\ndef answer(x, k):\n    (s, val) = (0, x)\n    all_ = []\n    for i in primef[val]:\n        p = 0\n        while x % i == 0:\n            x //= i\n            p += 1\n        all_.append(i ** p)\n    if k - len(primef[val]) >= 0:\n        return min(sum(all_) + (k - len(primef[val])), val + (k - 1))\n    else:\n        return min_possible(all_)\nfor T in range(int(input())):\n    (k, x) = map(int, input().split())\n    print(answer(x, k))", "def factorize(n):\n    factor_list = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            counter = 0\n            while n % i == 0:\n                counter += 1\n                n //= i\n            factor_list.append(i ** counter)\n    if n != 1:\n        factor_list.append(n)\n    return factor_list\n\ndef brute_force(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, brute_force(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nfor tc in range(int(input())):\n    (K, X) = map(int, input().split())\n    factors = factorize(X)\n    lenn = len(factors)\n    if lenn <= K:\n        ans = sum(factors) + K - lenn\n    else:\n        arr = [1] * K\n        ans = brute_force(0, arr, factors)\n    print(ans)", "def multi(arr, fctrs, curr):\n    if curr == len(fctrs):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= fctrs[curr]\n        ans = min(ans, multi(arr, fctrs, curr + 1))\n        arr[i] //= fctrs[curr]\n    return ans\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    fctrs = []\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            fctrs.append(1)\n            while x % i == 0:\n                fctrs[-1] *= i\n                x //= i\n    if x > 1:\n        fctrs.append(x)\n    if k >= len(fctrs):\n        ans = sum(fctrs) + k - len(fctrs)\n    else:\n        arr = [1] * k\n        ans = multi(arr, fctrs, 0)\n    print(ans)", "def factorize(n):\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            cntr = 0\n            while n % i == 0:\n                cntr += 1\n                n //= i\n            factors.append(i ** cntr)\n    if n != 1:\n        factors.append(n)\n    return factors\n\ndef bruteforce(pos, arr, factors):\n    if pos == len(factors):\n        return sum(arr)\n    ans = float('inf')\n    for i in range(len(arr)):\n        arr[i] *= factors[pos]\n        ans = min(ans, bruteforce(pos + 1, arr, factors))\n        arr[i] //= factors[pos]\n    return ans\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    factors = factorize(x)\n    lenn = len(factors)\n    if lenn <= k:\n        print(sum(factors) + (k - lenn))\n    else:\n        arr = [1] * k\n        ans = bruteforce(0, arr, factors)\n        print(ans)", "import sys\nsys.setrecursionlimit(10000000)\n\ndef primes(x):\n    f = []\n    i = 2\n    while i * i <= x:\n        if x % i == 0:\n            t = 1\n            while x % i == 0:\n                x //= i\n                t *= i\n            f.append(t)\n        i += 1\n    if x > 1:\n        f.append(x)\n    return f\n\ndef recur(arr):\n    if len(arr) == k:\n        return sum(arr)\n    answer = float('inf')\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            temp = arr[:]\n            temp.remove(arr[i])\n            temp.remove(arr[j])\n            temp.append(arr[i] * arr[j])\n            answer = min(answer, recur(temp))\n    return answer\nfor _ in range(int(input())):\n    (k, X) = map(int, input().split())\n    p = primes(X)\n    if k >= len(p):\n        print(sum(p) + (k - len(p)))\n        continue\n    print(recur(p))", "import math as mt\nMAXN = 1000001\nspf = [0 for i in range(MAXN)]\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(2, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = list()\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\nsieve()\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    p = getFactorization(x)\n    s = list(set(p))\n    s.sort()\n    le = len(s)\n    ans = 0\n    ans1 = k - 1 + x\n    if le <= k:\n        for i in s:\n            ans += i ** p.count(i)\n        ans += k - le\n    else:\n        nl = [[1 for u in range(k)]]\n        for i in s:\n            v = i ** p.count(i)\n            newl = []\n            for y in nl:\n                for u in range(k):\n                    op = y.copy()\n                    op[u] *= v\n                    newl.append(op)\n            nl = newl.copy()\n        ans = sum(nl[0])\n        for i in nl:\n            ans = min(ans, sum(i))\n    print(min(ans, ans1))", "def solve(k, x):\n    fact = []\n    i = 2\n    while i * i <= x:\n        if x % i == 0:\n            fact.append(1)\n        while x % i == 0:\n            x //= i\n            fact[-1] *= i\n        i += 1\n    if x != 1:\n        fact.append(x)\n    if k >= len(fact):\n        return sum(fact) + k - len(fact)\n    arr = [1] * k\n    return partition(fact, 0, arr, k, float('inf'))\n\ndef partition(fact, i, arr, k, ans):\n    if i == len(fact):\n        return min(ans, sum(arr))\n    for j in range(len(arr)):\n        arr[j] *= fact[i]\n        ans = min(ans, partition(fact, i + 1, arr, k, ans))\n        arr[j] //= fact[i]\n    return ans\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    print(solve(k, x))", "import math as mt\nMAXN = 1000001\nspf = [0 for i in range(MAXN)]\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n        if spf[i] == i:\n            for j in range(i * i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = list()\n    while x != 1:\n        ret.append(spf[x])\n        x = x // spf[x]\n    return ret\nsieve()\nfor _ in range(int(input())):\n    (k, x) = map(int, input().split())\n    p = getFactorization(x)\n    s = list(set(p))\n    s.sort()\n    le = len(s)\n    ans = 0\n    ans1 = k - 1 + x\n    if le <= k:\n        for i in s:\n            ans += i ** p.count(i)\n        ans += k - le\n    else:\n        nl = [[1 for u in range(k)]]\n        for i in s:\n            v = i ** p.count(i)\n            newl = []\n            for y in nl:\n                for u in range(k):\n                    op = y.copy()\n                    op[u] *= v\n                    newl.append(op)\n            nl = newl.copy()\n        ans = sum(nl[0])\n        for i in nl:\n            ans = min(ans, sum(i))\n    print(min(ans, ans1))", "import math\n\ndef primeFactors(n):\n    d = {}\n    while n % 2 == 0:\n        n = n // 2\n        if 2 in d:\n            d[2] += 1\n        else:\n            d[2] = 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n            n = n // i\n    if n > 2:\n        if n in d:\n            d[n] += 1\n        else:\n            d[n] = 1\n    return d\n\ndef get_all_combs(arr, left):\n    global g\n    if not left:\n        g.append(sum(arr))\n    else:\n        new = left.pop()\n        for i in range(len(arr)):\n            newarr = arr.copy()\n            newarr[i] *= new\n            get_all_combs(newarr, left.copy())\nfor test in range(int(input())):\n    (k, x) = map(int, input().split())\n    d = primeFactors(x)\n    if k < len(d):\n        p = [item ** d[item] for item in d]\n        xo = [1] * k\n        g = []\n        get_all_combs(xo, p)\n        print(min(g))\n        continue\n    c2 = 0\n    for item in d:\n        c2 += item ** d[item]\n    diff = k - len(d)\n    c2 += diff\n    print(c2)", "import sys\nsys.setrecursionlimit(10000000)\n\ndef primes(x):\n    f = []\n    i = 2\n    while i * i <= x:\n        if x % i == 0:\n            t = 1\n            while x % i == 0:\n                x //= i\n                t *= i\n            f.append(t)\n        i += 1\n    if x > 1:\n        f.append(x)\n    return f\n\ndef recur(arr):\n    if len(arr) == k:\n        return sum(arr)\n    answer = float('inf')\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            temp = arr[:]\n            temp.remove(arr[i])\n            temp.remove(arr[j])\n            temp.append(arr[i] * arr[j])\n            answer = min(answer, recur(temp))\n    return answer\nfor _ in range(int(input())):\n    (k, X) = map(int, input().split())\n    p = primes(X)\n    if k >= len(p):\n        print(sum(p) + (k - len(p)))\n        continue\n    print(recur(p))", "from math import *\n\ndef algorithm_u(ns, m):\n\n    def visit(n, a):\n        ps = [[] for i in range(m)]\n        for j in range(n):\n            ps[a[j + 1]].append(ns[j])\n        return ps\n\n    def f(mu, nu, sigma, n, a):\n        if mu == 2:\n            yield visit(n, a)\n        else:\n            for v in f(mu - 1, nu - 1, (mu + sigma) % 2, n, a):\n                yield v\n        if nu == mu + 1:\n            a[mu] = mu - 1\n            yield visit(n, a)\n            while a[nu] > 0:\n                a[nu] = a[nu] - 1\n                yield visit(n, a)\n        elif nu > mu + 1:\n            if (mu + sigma) % 2 == 1:\n                a[nu - 1] = mu - 1\n            else:\n                a[mu] = mu - 1\n            if (a[nu] + sigma) % 2 == 1:\n                for v in b(mu, nu - 1, 0, n, a):\n                    yield v\n            else:\n                for v in f(mu, nu - 1, 0, n, a):\n                    yield v\n            while a[nu] > 0:\n                a[nu] = a[nu] - 1\n                if (a[nu] + sigma) % 2 == 1:\n                    for v in b(mu, nu - 1, 0, n, a):\n                        yield v\n                else:\n                    for v in f(mu, nu - 1, 0, n, a):\n                        yield v\n\n    def b(mu, nu, sigma, n, a):\n        if nu == mu + 1:\n            while a[nu] < mu - 1:\n                yield visit(n, a)\n                a[nu] = a[nu] + 1\n            yield visit(n, a)\n            a[mu] = 0\n        elif nu > mu + 1:\n            if (a[nu] + sigma) % 2 == 1:\n                for v in f(mu, nu - 1, 0, n, a):\n                    yield v\n            else:\n                for v in b(mu, nu - 1, 0, n, a):\n                    yield v\n            while a[nu] < mu - 1:\n                a[nu] = a[nu] + 1\n                if (a[nu] + sigma) % 2 == 1:\n                    for v in f(mu, nu - 1, 0, n, a):\n                        yield v\n                else:\n                    for v in b(mu, nu - 1, 0, n, a):\n                        yield v\n            if (mu + sigma) % 2 == 1:\n                a[nu - 1] = 0\n            else:\n                a[mu] = 0\n        if mu == 2:\n            yield visit(n, a)\n        else:\n            for v in b(mu - 1, nu - 1, (mu + sigma) % 2, n, a):\n                yield v\n    n = len(ns)\n    a = [0] * (n + 1)\n    for j in range(1, m + 1):\n        a[n - m + j] = j - 1\n    return f(m, n, 0, n, a)\nfor _ in range(int(input())):\n    (k, x) = [int(i) for i in input().split()]\n    facts = []\n    for i in range(2, int(sqrt(x)) + 1):\n        if x % i == 0:\n            y = 1\n            while x % i == 0:\n                y *= i\n                x /= i\n            facts.append(y)\n    if x > 1:\n        facts.append(x)\n    s = sum(facts)\n    m = len(facts)\n    rem_1 = max(0, k - m)\n    if rem_1:\n        s = int(sum(facts))\n        print(s + rem_1)\n        continue\n    ans_best = 10 ** 18\n    for s in algorithm_u(facts, k):\n        ans = 0\n        for subset in s:\n            y = 1\n            for elem in subset:\n                y *= elem\n            ans += y\n        ans_best = int(min(ans_best, ans))\n    print(ans_best)", "MAX = 1000005\nprime = [True] * MAX\nfact = [list() for i in range(MAX)]\nfor i in range(2, MAX):\n    if prime[i]:\n        for j in range(i, MAX, i):\n            prime[j] = False\n            fact[j].append(i)\n\ndef solve(arr, i, k):\n    if i >= len(arr):\n        return sum(k)\n    z = float('inf')\n    for j in range(len(k)):\n        k[j] *= arr[i]\n        z = min(z, solve(arr, i + 1, k))\n        k[j] //= arr[i]\n    return z\nt = int(input())\nfor i in range(t):\n    (k, x) = map(int, input().split())\n    temp = []\n    for y in fact[x]:\n        p = x\n        z = 1\n        while p % y == 0:\n            p //= y\n            z *= y\n        temp.append(z)\n    if k >= len(fact[x]):\n        print(sum(temp) + k - len(temp))\n    else:\n        print(solve(temp, 0, [1] * k))"]