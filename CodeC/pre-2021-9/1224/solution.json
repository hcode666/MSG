["import heapq\nimport math\nimport collections\n(n, k, s) = map(int, input().split())\na = list(map(int, input().split()))\nalliance = [list(map(int, input().split())) for _ in range(n)]\nplanet = collections.defaultdict(list)\nfor i in range(1, k + 1):\n    planet[i] = []\nfor (i, v) in enumerate(a):\n    planet[v].append(i)\nheap = [(0, a[s - 1])]\nheapq.heapify(heap)\nans = {}\nvisited = set()\nwhile heap:\n    (dist, node) = heapq.heappop(heap)\n    if node in visited:\n        continue\n    ans[node] = dist\n    visited.add(node)\n    for i in planet[node]:\n        for (j, k) in enumerate(alliance[i]):\n            if j + 1 not in visited and k != -1:\n                heapq.heappush(heap, (k + dist, j + 1))\nfor i in planet:\n    if i not in visited:\n        ans[i] = -1\nprint(*[ans[v] for v in a])", "import heapq\nimport math\nimport collections\n(n, k, s) = map(int, input().split())\na = list(map(int, input().split()))\nalliance = [list(map(int, input().split())) for _ in range(n)]\nplanet = collections.defaultdict(list)\nfor i in range(1, k + 1):\n    planet[i] = []\nfor (i, v) in enumerate(a):\n    planet[v].append(i)\nheap = [(0, a[s - 1])]\nheapq.heapify(heap)\nans = {}\nvisited = set()\nwhile heap:\n    (dist, node) = heapq.heappop(heap)\n    if node in visited:\n        continue\n    ans[node] = dist\n    visited.add(node)\n    for i in planet[node]:\n        for (j, k) in enumerate(alliance[i]):\n            if j + 1 not in visited and k != -1:\n                heapq.heappush(heap, (k + dist, j + 1))\nfor i in planet:\n    if i not in visited:\n        ans[i] = -1\nprint(*[ans[v] for v in a])", "import heapq\nimport math\nimport collections\n(n, k, s) = map(int, input().split())\na = list(map(int, input().split()))\nalliance = [list(map(int, input().split())) for _ in range(n)]\nplanet = collections.defaultdict(list)\nfor i in range(1, k + 1):\n    planet[i] = []\nfor (i, v) in enumerate(a):\n    planet[v].append(i)\nheap = [(0, a[s - 1])]\nheapq.heapify(heap)\nans = {}\nvisited = set()\nwhile heap:\n    (dist, node) = heapq.heappop(heap)\n    if node in visited:\n        continue\n    ans[node] = dist\n    visited.add(node)\n    for i in planet[node]:\n        for (j, k) in enumerate(alliance[i]):\n            if j + 1 not in visited and k != -1:\n                heapq.heappush(heap, (k + dist, j + 1))\nfor i in planet:\n    if i not in visited:\n        ans[i] = -1\nprint(*[ans[v] for v in a])", "import heapq\nimport math\nimport collections\n(n, k, s) = map(int, input().split())\na = list(map(int, input().split()))\nalliance = [list(map(int, input().split())) for _ in range(n)]\nplanet = collections.defaultdict(list)\nfor i in range(1, k + 1):\n    planet[i] = []\nfor (i, v) in enumerate(a):\n    planet[v].append(i)\nheap = [(0, a[s - 1])]\nheapq.heapify(heap)\nans = {}\nvisited = set()\nwhile heap:\n    (dist, node) = heapq.heappop(heap)\n    if node in visited:\n        continue\n    ans[node] = dist\n    visited.add(node)\n    for i in planet[node]:\n        for (j, k) in enumerate(alliance[i]):\n            if j + 1 not in visited and k != -1:\n                heapq.heappush(heap, (k + dist, j + 1))\nfor i in planet:\n    if i not in visited:\n        ans[i] = -1\nprint(*[ans[v] for v in a])", "import heapq\nimport math\nimport collections\n(n, k, s) = map(int, input().split())\na = list(map(int, input().split()))\nalliance = [list(map(int, input().split())) for _ in range(n)]\nplanet = collections.defaultdict(list)\nfor i in range(1, k + 1):\n    planet[i] = []\nfor (i, v) in enumerate(a):\n    planet[v].append(i)\nheap = [(0, a[s - 1])]\nheapq.heapify(heap)\nans = {}\nvisited = set()\nwhile heap:\n    (dist, node) = heapq.heappop(heap)\n    if node in visited:\n        continue\n    ans[node] = dist\n    visited.add(node)\n    for i in planet[node]:\n        for (j, k) in enumerate(alliance[i]):\n            if j + 1 not in visited and k != -1:\n                heapq.heappush(heap, (k + dist, j + 1))\nfor i in planet:\n    if i not in visited:\n        ans[i] = -1\nprint(*[ans[v] for v in a])", "import heapq\nimport math\nimport collections\n(n, k, s) = map(int, input().split())\na = list(map(int, input().split()))\nalliance = [list(map(int, input().split())) for _ in range(n)]\nplanet = collections.defaultdict(list)\nfor i in range(1, k + 1):\n    planet[i] = []\nfor (i, v) in enumerate(a):\n    planet[v].append(i)\nheap = [(0, a[s - 1])]\nheapq.heapify(heap)\nans = {}\nvisited = set()\nwhile heap:\n    (dist, node) = heapq.heappop(heap)\n    if node in visited:\n        continue\n    ans[node] = dist\n    visited.add(node)\n    for i in planet[node]:\n        for (j, k) in enumerate(alliance[i]):\n            if j + 1 not in visited and k != -1:\n                heapq.heappush(heap, (k + dist, j + 1))\nfor i in planet:\n    if i not in visited:\n        ans[i] = -1\nprint(*[ans[v] for v in a])", "from heapq import *\nfrom collections import defaultdict as dd\n\ndef dijsktra(src):\n    ans = dd(lambda : 10 ** 10)\n    ans[src] = 0\n    prcessed = set()\n    prcessed.add(src)\n    h = []\n    heappush(h, [0, src])\n    while h:\n        (d, node) = heappop(h)\n        for v in g[node]:\n            if v not in prcessed and d + g[node][v] < ans[v]:\n                ans[v] = d + g[node][v]\n                heappush(h, [ans[v], v])\n        prcessed.add(node)\n    return ans\n(n, k, s) = map(int, input().split())\na = list(map(int, input().split()))\ncost = []\ng = dd(dict)\nfor i in range(n):\n    a[i] -= 1\nfor i in range(n):\n    l = list(map(int, input().split()))\n    for i in range(k):\n        if l[i] == -1:\n            l[i] = 10 ** 10\n    cost.append(l)\nfor i in range(n):\n    for j in range(k):\n        g[a[i]][j] = min(g[a[i]][j], cost[i][j]) if j in g[a[i]] else cost[i][j]\nsrc = a[s - 1]\nans = dijsktra(src)\nres = []\nfor i in range(n):\n    res.append(-1 if ans[a[i]] >= 10 ** 10 else ans[a[i]])\nprint(*res)", "import heapq\nfrom collections import defaultdict as dd\n\ndef dijsktra(src):\n    ans = dd(lambda : 10 ** 10)\n    ans[src] = 0\n    prcessed = set()\n    prcessed.add(src)\n    h = []\n    heapq.heappush(h, [0, src])\n    while h:\n        (d, node) = heapq.heappop(h)\n        for v in g[node]:\n            if v not in prcessed and d + g[node][v] < ans[v]:\n                ans[v] = d + g[node][v]\n                heapq.heappush(h, [ans[v], v])\n        prcessed.add(node)\n    return ans\n(n, k, s) = map(int, input().split())\na = list(map(int, input().split()))\nfor i in range(n):\n    a[i] -= 1\ncost = []\nfor i in range(n):\n    l = list(map(int, input().split()))\n    for i in range(k):\n        if l[i] == -1:\n            l[i] = 10 ** 10\n    cost.append(l)\ng = dd(dict)\nfor i in range(n):\n    for j in range(k):\n        if j in g[a[i]]:\n            g[a[i]][j] = min(g[a[i]][j], cost[i][j])\n        else:\n            g[a[i]][j] = cost[i][j]\nsrc = a[s - 1]\nans = dijsktra(src)\nres = []\nfor i in range(n):\n    if ans[a[i]] >= 10 ** 10:\n        res.append(-1)\n    else:\n        res.append(ans[a[i]])\nprint(*res)", "import heapq\nfrom collections import defaultdict as dd\ng = dd(dict)\ninf = 10 ** 100\n\ndef dijsktra(src):\n    ans = dd(lambda : inf)\n    ans[src] = 0\n    prcessed = set()\n    prcessed.add(src)\n    h = []\n    heapq.heappush(h, [0, src])\n    while len(h):\n        (d, node) = heapq.heappop(h)\n        for v in g[node]:\n            te = d + g[node][v]\n            if v not in prcessed and te < ans[v]:\n                ans[v] = te\n                heapq.heappush(h, [ans[v], v])\n        prcessed.add(node)\n    return ans\n(n, k, s) = map(int, input().split())\na = list(map(int, input().split()))\nfor i in range(n):\n    a[i] -= 1\ncost = []\nfor i in range(n):\n    L = list(map(int, input().split()))\n    for i in range(k):\n        if L[i] == -1:\n            L[i] = inf\n    cost.append(L)\nfor i in range(n):\n    for j in range(k):\n        if j in g[a[i]]:\n            g[a[i]][j] = min(g[a[i]][j], cost[i][j])\n        else:\n            g[a[i]][j] = cost[i][j]\nsrc = a[s - 1]\nans = dijsktra(src)\npp = ''\nfor i in range(n):\n    if ans[a[i]] >= inf:\n        pp += '-1 '\n    else:\n        pp += str(ans[a[i]]) + ' '\nprint(pp)", "from sys import stdin\ninput = stdin.readline\nimport heapq\n\ndef answer():\n    q = []\n    heapq.heappush(q, [0, a[s - 1]])\n    allans = [float('inf')] * (k + 1)\n    allans[a[s - 1]] = 0\n    visited = [False] * (k + 1)\n    while len(q):\n        (cost, p) = heapq.heappop(q)\n        if visited[p]:\n            continue\n        visited[p] = True\n        for i in range(1, k + 1):\n            if edges[p][i] == -1 or visited[i]:\n                continue\n            if cost + edges[p][i] < allans[i]:\n                allans[i] = cost + edges[p][i]\n                heapq.heappush(q, [allans[i], i])\n    for i in range(k + 1):\n        if allans[i] == float('inf'):\n            allans[i] = -1\n    ans = [-1] * (n + 1)\n    for i in range(1, k + 1):\n        for j in alliance[i]:\n            ans[j] = allans[i]\n    return ans[1:]\nfor T in range(1):\n    (n, k, s) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = [list(map(int, input().split())) for i in range(n)]\n    alliance = [[] for i in range(k + 1)]\n    for i in range(n):\n        alliance[a[i]].append(i + 1)\n    edges = [[-1 for i in range(k + 1)] for j in range(k + 1)]\n    for x in range(1, k + 1):\n        for j in range(1, k + 1):\n            m = float('inf')\n            for i in alliance[x]:\n                if c[i - 1][j - 1] == -1:\n                    continue\n                m = min(m, c[i - 1][j - 1])\n            if m == float('inf'):\n                m = -1\n            edges[x][j] = m\n    print(*answer())", "from sys import stdin\ninput = stdin.readline\nimport heapq\n\ndef answer():\n    q = []\n    heapq.heappush(q, [0, a[s - 1]])\n    allans = [float('inf')] * (k + 1)\n    visited = [False] * (n + 1)\n    while len(q):\n        (cost, p) = heapq.heappop(q)\n        if visited[p]:\n            continue\n        visited[p] = True\n        for i in range(1, k + 1):\n            if edges[p][i] == -1:\n                continue\n            if cost + edges[p][i] < allans[i]:\n                allans[i] = cost + edges[p][i]\n                heapq.heappush(q, [allans[i], i])\n    for i in range(k + 1):\n        if allans[i] == float('inf'):\n            allans[i] = -1\n    ans = [-1] * (n + 1)\n    for i in range(1, k + 1):\n        for j in alliance[i]:\n            ans[j] = allans[i]\n    return ans[1:]\nfor T in range(1):\n    (n, k, s) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = [list(map(int, input().split())) for i in range(n)]\n    alliance = [[] for i in range(k + 1)]\n    for i in range(n):\n        alliance[a[i]].append(i + 1)\n    edges = [[float('inf') for i in range(k + 1)] for j in range(k + 1)]\n    for x in range(1, k + 1):\n        for j in range(1, k + 1):\n            m = float('inf')\n            for i in alliance[x]:\n                if c[i - 1][j - 1] == -1:\n                    continue\n                m = min(m, c[i - 1][j - 1])\n            edges[x][j] = min(edges[x][j], m)\n    for i in range(k + 1):\n        for j in range(k + 1):\n            if edges[x][j] == float('inf'):\n                edges[x][j] = -1\n    print(*answer())", "from sys import stdin\ninput = stdin.readline\nimport heapq\n\ndef answer():\n    q = []\n    heapq.heappush(q, [0, a[s - 1]])\n    allans = [float('inf')] * (k + 1)\n    visited = [False] * (n + 1)\n    while len(q):\n        (cost, p) = heapq.heappop(q)\n        if visited[p]:\n            continue\n        visited[p] = True\n        for i in range(1, k + 1):\n            if edges[p][i] == -1:\n                continue\n            if cost + edges[p][i] < allans[i]:\n                allans[i] = cost + edges[p][i]\n                heapq.heappush(q, [allans[i], i])\n    for i in range(k + 1):\n        if allans[i] == float('inf'):\n            allans[i] = -1\n    ans = [-1] * (n + 1)\n    for i in range(1, k + 1):\n        for j in alliance[i]:\n            ans[j] = allans[i]\n    return ans[1:]\nfor T in range(1):\n    (n, k, s) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = [list(map(int, input().split())) for i in range(n)]\n    alliance = [[] for i in range(k + 1)]\n    for i in range(n):\n        alliance[a[i]].append(i + 1)\n    edges = [[float('inf') for i in range(k + 1)] for j in range(k + 1)]\n    for x in range(1, k + 1):\n        for j in range(1, k + 1):\n            m = float('inf')\n            for i in alliance[x]:\n                if c[i - 1][j - 1] == -1:\n                    continue\n                m = min(m, c[i - 1][j - 1])\n            if m == float('inf'):\n                m = -1\n            edges[x][j] = min(edges[x][j], m)\n    for i in range(k + 1):\n        for j in range(k + 1):\n            if edges[x][j] == float('inf'):\n                edges[x][j] = -1\n    print(*answer())", "from sys import stdin\ninput = stdin.readline\nimport heapq\n\ndef answer():\n    q = []\n    heapq.heappush(q, [0, a[s - 1]])\n    allans = [float('inf')] * (k + 1)\n    visited = [False] * (n + 1)\n    while len(q):\n        (cost, p) = heapq.heappop(q)\n        if visited[p]:\n            continue\n        visited[p] = True\n        for i in range(1, k + 1):\n            if edges[p][i] == -1:\n                continue\n            if cost + edges[p][i] < allans[i]:\n                allans[i] = cost + edges[p][i]\n                heapq.heappush(q, [allans[i], i])\n    for i in range(k + 1):\n        if allans[i] == float('inf'):\n            allans[i] = -1\n    ans = [-1] * (n + 1)\n    for i in range(1, k + 1):\n        for j in alliance[i]:\n            ans[j] = allans[i]\n    return ans[1:]\nfor T in range(1):\n    (n, k, s) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = [list(map(int, input().split())) for i in range(n)]\n    alliance = [[] for i in range(k + 1)]\n    for i in range(n):\n        alliance[a[i]].append(i + 1)\n    edges = [[-1 for i in range(k + 1)] for j in range(k + 1)]\n    for x in range(1, k + 1):\n        for j in range(1, k + 1):\n            m = float('inf')\n            for i in alliance[x]:\n                if c[i - 1][j - 1] == -1:\n                    continue\n                m = min(m, c[i - 1][j - 1])\n            if m == float('inf'):\n                m = -1\n            edges[x][j] = m\n    print(*answer())", "(N, K, S) = map(int, input().split())\nS -= 1\nA = list(map(lambda x: int(x) - 1, input().split()))\nC = []\nfor i in range(N):\n    C.append(list(map(int, input().split())))\nC_BW_A = [{} for i in range(K)]\nfor i in range(N):\n    a = A[i]\n    for b in range(K):\n        if a != b:\n            cur_c = C_BW_A[a].get(b, float('inf'))\n            cost_f_p = C[i][b]\n            if 0 <= cost_f_p < cur_c:\n                C_BW_A[a][b] = cost_f_p\nC_F_BASE = [float('inf') for i in range(K)]\nC_F_BASE[A[S]] = 0\nunvisited = set(range(K))\nwhile unvisited:\n    (min_d, min_a) = (float('inf'), -1)\n    for a in unvisited:\n        if C_F_BASE[a] < min_d:\n            min_d = C_F_BASE[a]\n            min_a = a\n    if min_a == -1:\n        break\n    unvisited.remove(min_a)\n    for (n, l) in C_BW_A[min_a].items():\n        ndist = min_d + l\n        if ndist < C_F_BASE[n]:\n            C_F_BASE[n] = ndist\nfor i in range(K):\n    if C_F_BASE[i] == float('inf'):\n        C_F_BASE[i] = -1\nprint(' '.join((str(C_F_BASE[A[i]]) for i in range(N))))", "from sys import stdin\ninput = stdin.readline\nimport heapq\n\ndef answer():\n    q = []\n    heapq.heappush(q, [0, a[s - 1]])\n    allans = [10000000000.0] * (k + 1)\n    visited = [False] * (n + 1)\n    while len(q):\n        (cost, p) = heapq.heappop(q)\n        if visited[p]:\n            continue\n        visited[p] = True\n        for i in range(1, k + 1):\n            if edges[p][i] == -1:\n                continue\n            if cost + edges[p][i] < allans[i]:\n                allans[i] = cost + edges[p][i]\n                heapq.heappush(q, [allans[i], i])\n    for i in range(k + 1):\n        if allans[i] == 10000000000.0:\n            allans[i] = -1\n    ans = [-1] * (n + 1)\n    for i in range(1, k + 1):\n        for j in alliance[i]:\n            ans[j] = allans[i]\n    return ans[1:]\nfor T in range(1):\n    (n, k, s) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = [list(map(int, input().split())) for i in range(n)]\n    alliance = [[] for i in range(k + 1)]\n    for i in range(n):\n        alliance[a[i]].append(i + 1)\n    edges = [[-1 for i in range(k + 1)] for j in range(k + 1)]\n    for x in range(1, k + 1):\n        for j in range(1, k + 1):\n            m = 10000000000.0\n            for i in alliance[x]:\n                if c[i - 1][j - 1] == -1:\n                    continue\n                m = min(m, c[i - 1][j - 1])\n            if m == 10000000000.0:\n                m = -1\n            edges[x][j] = m\n    print(*answer())", "import heapq\nfrom collections import defaultdict as dd\n\ndef dijsktra(src):\n    ans = dd(lambda : 10 ** 10)\n    ans[src] = 0\n    prcessed = set()\n    prcessed.add(src)\n    h = []\n    heapq.heappush(h, [0, src])\n    while h:\n        (d, node) = heapq.heappop(h)\n        for v in g[node]:\n            if v not in prcessed and d + g[node][v] < ans[v]:\n                ans[v] = d + g[node][v]\n                heapq.heappush(h, [ans[v], v])\n        prcessed.add(node)\n    return ans\n(n, k, s) = map(int, input().split())\na = list(map(int, input().split()))\nfor i in range(n):\n    a[i] -= 1\ncost = []\nfor i in range(n):\n    l = list(map(int, input().split()))\n    for i in range(k):\n        if l[i] == -1:\n            l[i] = 10 ** 10\n    cost.append(l)\ng = dd(dict)\nfor i in range(n):\n    for j in range(k):\n        if j in g[a[i]]:\n            g[a[i]][j] = min(g[a[i]][j], cost[i][j])\n        else:\n            g[a[i]][j] = cost[i][j]\nsrc = a[s - 1]\nans = dijsktra(src)\nres = []\nfor i in range(n):\n    if ans[a[i]] >= 10 ** 10:\n        res.append(-1)\n    else:\n        res.append(ans[a[i]])\nprint(*res)", "from collections import defaultdict\nimport heapq\n(n, k, s) = map(int, input().split())\na = list(map(int, input().split()))\ncost = []\ndist = [[float('inf') for _ in range(k + 1)] for __ in range(k + 1)]\nfor j in range(n):\n    ca = list(map(int, input().split()))\n    for jj in range(1, k + 1):\n        if ca[jj - 1] != -1:\n            dist[a[j]][jj] = min(dist[a[j]][jj], ca[jj - 1])\nadj = defaultdict(list)\nfor i in range(1, k + 1):\n    for j in range(1, k + 1):\n        if i != j and dist[i][j] != float('inf'):\n            adj[i].append((j, dist[i][j]))\ninf = float('inf')\ndist = [inf for i in range(k + 1)]\ndist[a[s - 1]] = 0\npq = [(0, a[s - 1])]\nwhile pq:\n    (wei, node) = heapq.heappop(pq)\n    for (cnode, cw) in adj[node]:\n        cdis = wei + cw\n        if cdis < dist[cnode]:\n            dist[cnode] = cdis\n            heapq.heappush(pq, (cdis, cnode))\nfor i in range(n):\n    grp = a[i]\n    ans = dist[grp]\n    if ans == float('inf'):\n        ans = -1\n    print(ans, end=' ')\nprint()", "import heapq\nimport sys\ninput = sys.stdin.readline\n(n, k, s) = map(int, input().split())\n(a, pl_al) = (list(map(int, input().split())), {i: [] for i in range(1, k + 1)})\nfor (i, v) in enumerate(a):\n    pl_al[v].append(i)\nc = [list(map(int, input().split())) for _ in range(n)]\n(heap, costs) = ([(0, a[s - 1])], {})\nwhile heap:\n    (cost, al) = heapq.heappop(heap)\n    if al in costs:\n        continue\n    costs[al] = cost\n    for pl in pl_al[al]:\n        for (i, v) in enumerate(c[pl]):\n            if i + 1 not in costs and v != -1:\n                heapq.heappush(heap, (cost + v, i + 1))\nfor v in pl_al:\n    if v not in costs:\n        costs[v] = -1\nprint(' '.join((str(costs[v]) for v in a)))"]