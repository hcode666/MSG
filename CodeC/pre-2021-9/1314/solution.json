["from sys import stdin, stdout\ninput = stdin.readline\n\nclass SegmentTree:\n\n    def __init__(self, data, default=[-float('inf'), -1], func=max):\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        start += self._size\n        stop += self._size + 1\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return 'SegmentTree({0})'.format(self.data)\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    arr = [int(x) for x in input().split()]\n    ST = SegmentTree([[arr[i], i] for i in range(n)])\n    vals = [0 for i in range(n)]\n    st = []\n    for i in range(n - 1, -1, -1):\n        while st and arr[st[-1]] <= arr[i]:\n            st.pop()\n        if st:\n            vals[i] = 1 + vals[st[-1]]\n        st.append(i)\n    for i in range(q):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        (a, b) = (min(a, b), max(a, b))\n        print(vals[ST.query(a, b)[1]])", "from sys import stdin, stdout\ninput = stdin.readline\n\nclass SegmentTree:\n\n    def __init__(self, data, default=[-float('inf'), -1], func=max):\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        start += self._size\n        stop += self._size + 1\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return 'SegmentTree({0})'.format(self.data)\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    arr = [int(x) for x in input().split()]\n    ST = SegmentTree([[arr[i], i] for i in range(n)])\n    vals = [0 for i in range(n)]\n    st = []\n    for i in range(n - 1, -1, -1):\n        while st and arr[st[-1]] <= arr[i]:\n            st.pop()\n        if st:\n            vals[i] = 1 + vals[st[-1]]\n        st.append(i)\n    for i in range(q):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        (a, b) = (min(a, b), max(a, b))\n        print(vals[ST.query(a, b)[1]])", "from math import log2\n\ndef pre():\n    s = []\n    for i in range(n):\n        if len(s) == 0:\n            s.append(i)\n            continue\n        while len(s) and a[s[-1]] < a[i]:\n            nm[s[-1]] = i\n            s.pop()\n        s.append(i)\n    for i in range(n - 1, -1, -1):\n        if nm[i] != -1:\n            ans[i] = ans[nm[i]] + 1\n\ndef sparsetable():\n    for i in range(n):\n        s[i][0] = [a[i], i]\n    for i in range(1, len(s[0])):\n        for j in range(n - (1 << i) + 1):\n            s[j][i] = s[j][i - 1][:]\n            if s[j][i][0] < s[j + (1 << i - 1)][i - 1][0]:\n                s[j][i] = s[j + (1 << i - 1)][i - 1][:]\n\ndef query(x, y):\n    v = y - x + 1\n    (m, ind) = (0, -1)\n    for i in range(len(s[0]), -1, -1):\n        if v >> i & 1:\n            if m < s[x][i][0]:\n                m = s[x][i][0]\n                ind = s[x][i][1]\n            x += 1 << i\n    return ans[ind]\nfor T in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = [0] * (n + 1)\n    nm = [-1] * n\n    s = [[[0, 0] for i in range(int(log2(n)) + 1)] for j in range(n)]\n    pre()\n    sparsetable()\n    for i in range(q):\n        (x, y) = map(int, input().split())\n        print(query(min(x, y) - 1, max(x, y) - 1))", "segment_tree = []\nheight = []\n\ndef build(ind, start, end):\n    if start == end:\n        segment_tree[ind] = (height[start], start)\n        return segment_tree[ind]\n    mid = (start + end) // 2\n    left = build(2 * ind + 1, start, mid)\n    right = build(2 * ind + 2, mid + 1, end)\n    if left[0] > right[0]:\n        segment_tree[ind] = left\n    else:\n        segment_tree[ind] = right\n    return segment_tree[ind]\n\ndef query(ind, start, end, l, r):\n    if start > r or end < l:\n        return (-float('inf'), -1)\n    if l <= start and r >= end:\n        return segment_tree[ind]\n    mid = (start + end) // 2\n    left = query(2 * ind + 1, start, mid, l, r)\n    right = query(2 * ind + 2, mid + 1, end, l, r)\n    if left[0] > right[0]:\n        return left\n    else:\n        return right\nt = int(input())\nfor _ in range(t):\n    (n_stones, m_queries) = map(int, input().split())\n    segment_tree = [0] * (n_stones * 4)\n    height = list(map(int, input().split()))\n    build(0, 0, n_stones - 1)\n    stack = []\n    for i in range(n_stones - 1, -1, -1):\n        curr = height[i]\n        while stack and stack[-1] <= curr:\n            stack.pop(-1)\n        height[i] = len(stack)\n        stack.append(curr)\n    for _ in range(m_queries):\n        (l, r) = map(int, input().split())\n        if l > r:\n            (l, r) = (r, l)\n        l -= 1\n        r -= 1\n        (_, ind) = query(0, 0, n_stones - 1, l, r)\n        print(height[ind])", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 6)\nfrom queue import PriorityQueue\nfrom math import gcd\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\nlevel = 20\n\ndef edge(u, v):\n    tree[u].append(v)\n    tree[v].append(u)\n\ndef dfs(u, p):\n    depth[u] = depth[p] + 1\n    parent[u][0] = p\n    for i in tree[u]:\n        if i == p:\n            continue\n        dfs(i, u)\n\ndef pre(n):\n    for i in range(1, level):\n        for j in range(1, n + 1):\n            if parent[j][i - 1] != -1:\n                parent[j][i] = parent[parent[j][i - 1]][i - 1]\n\ndef lca(u, v):\n    if depth[v] < depth[u]:\n        (u, v) = (v, u)\n    diff = depth[v] - depth[u]\n    for i in range(level):\n        if diff >> i & 1:\n            v = parent[v][i]\n    if u == v:\n        return u\n    for i in range(level - 1, -1, -1):\n        if parent[u][i] != parent[v][i]:\n            u = parent[u][i]\n            v = parent[v][i]\n    return parent[u][0]\nfor _ in range(ii()):\n    (n, m) = il()\n    a = il() + [float('inf')]\n    nxt = [-1 for i in range(n + 1)]\n    dp = [0 for i in range(n + 1)]\n    depth = [0 for i in range(n + 2)]\n    tree = [[] for i in range(n + 2)]\n    parent = [[0 for i in range(level)] for i in range(n + 2)]\n    b = []\n    t = 0\n    for i in range(n + 1):\n        while t != 0 and a[b[-1]] < a[i]:\n            nxt[b[-1]] = i\n            b.pop()\n            t -= 1\n        b.append(i)\n        t += 1\n    for i in range(n - 1, -1, -1):\n        if nxt[i] == -1:\n            continue\n        edge(i + 1, nxt[i] + 1)\n        dp[i] = dp[nxt[i]] + 1\n    depth[n] = 0\n    dfs(n + 1, 0)\n    pre(n + 1)\n    for i in range(m):\n        (u, v) = il()\n        l = lca(u, v)\n        l -= 1\n        if l == u - 1 or l == v - 1:\n            print(max(0, dp[l] - 1))\n        else:\n            print(dp[l])", "import sys\nsys.setrecursionlimit(100000 + 10)\nfor _ in range(int(input())):\n\n    def build(a, ind, low, high):\n        if low == high:\n            st[ind] = [a[low], low]\n            return st[ind]\n        else:\n            mid = low + (high - low) // 2\n            left = build(a, 2 * ind + 1, low, mid)\n            right = build(a, 2 * ind + 2, mid + 1, high)\n            st[ind] = left[:] if left[0] > right[0] else right[:]\n            return st[ind]\n\n    def query(ind, low, high, l, r):\n        if low > r or high < l:\n            return [float('-inf'), -1]\n        if l <= low and r >= high:\n            return st[ind]\n        mid = low + (high - low) // 2\n        left = query(2 * ind + 1, low, mid, l, r)\n        right = query(2 * ind + 2, mid + 1, high, l, r)\n        return left if left[0] > right[0] else right\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    st = [0 for i in range(4 * n)]\n    build(a, 0, 0, n - 1)\n    (stack, ans) = ([], [-1] * n)\n    res = [0] * n\n    for i in range(n):\n        while stack and a[stack[-1]] < a[i]:\n            ans[stack.pop()] = i\n        stack.append(i)\n    for i in range(n - 1, -1, -1):\n        if ans[i] != -1:\n            res[i] = 1 + res[ans[i]]\n    for i in range(m):\n        (l, r) = map(int, input().split())\n        if l > r:\n            (l, r) = (r, l)\n        l -= 1\n        r -= 1\n        (ele, ind) = query(0, 0, n - 1, l, r)\n        print(res[ind])", "import sys\nsys.setrecursionlimit(100000 + 10)\nfor _ in range(int(input())):\n\n    def build(a, ind, low, high):\n        if low == high:\n            st[ind] = [a[low], low]\n            return st[ind]\n        else:\n            mid = low + (high - low) // 2\n            left = build(a, 2 * ind + 1, low, mid)\n            right = build(a, 2 * ind + 2, mid + 1, high)\n            if left[0] > right[0]:\n                st[ind] = left[:]\n            else:\n                st[ind] = right[:]\n            return st[ind]\n\n    def query(ind, low, high, l, r):\n        if low > r or high < l:\n            return [float('-inf'), -1]\n        if l <= low and r >= high:\n            return st[ind]\n        mid = low + (high - low) // 2\n        left = query(2 * ind + 1, low, mid, l, r)\n        right = query(2 * ind + 2, mid + 1, high, l, r)\n        if left[0] > right[0]:\n            return left\n        return right\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    st = [0 for i in range(4 * n)]\n    build(a, 0, 0, n - 1)\n    (stack, ans) = ([], [-1] * n)\n    for i in range(n):\n        while stack and a[stack[-1]] < a[i]:\n            ans[stack.pop()] = i\n        stack.append(i)\n    res = [0] * n\n    for i in range(n - 1, -1, -1):\n        if ans[i] != -1:\n            res[i] = 1 + res[ans[i]]\n    for i in range(m):\n        (l, r) = map(int, input().split())\n        if l > r:\n            (l, r) = (r, l)\n        l -= 1\n        r -= 1\n        (ele, ind) = query(0, 0, n - 1, l, r)\n        print(res[ind])", "import sys\nsys.setrecursionlimit(100000 + 10)\nfor _ in range(int(input())):\n\n    def build(a, ind, low, high):\n        if low == high:\n            st[ind] = [a[low], low]\n            return st[ind]\n        else:\n            mid = low + (high - low) // 2\n            left = build(a, 2 * ind + 1, low, mid)\n            right = build(a, 2 * ind + 2, mid + 1, high)\n            if left[0] > right[0]:\n                st[ind] = left[:]\n            else:\n                st[ind] = right[:]\n            return st[ind]\n\n    def query(ind, low, high, l, r):\n        if low > r or high < l:\n            return [float('-inf'), -1]\n        if l <= low and r >= high:\n            return st[ind]\n        mid = low + (high - low) // 2\n        left = query(2 * ind + 1, low, mid, l, r)\n        right = query(2 * ind + 2, mid + 1, high, l, r)\n        if left[0] > right[0]:\n            return left\n        return right\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    st = [float('inf') for i in range(4 * n)]\n    build(a, 0, 0, n - 1)\n    (stack, ans) = ([], [-1] * n)\n    for i in range(n):\n        while stack and a[stack[-1]] < a[i]:\n            ans[stack.pop()] = i\n        stack.append(i)\n    res = [0] * n\n    for i in range(n - 1, -1, -1):\n        if ans[i] != -1:\n            res[i] = 1 + res[ans[i]]\n    for i in range(m):\n        (l, r) = map(int, input().split())\n        if l > r:\n            (l, r) = (r, l)\n        l -= 1\n        r -= 1\n        (ele, ind) = query(0, 0, n - 1, l, r)\n        print(res[ind])", "import sys, os\nfrom io import BytesIO, IOBase\nmod = 10 ** 9 + 7\nMod = 998244353\nINF = float('inf')\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\ninp = lambda : list(map(int, sys.stdin.readline().rstrip('\\r\\n').split()))\nsys.setrecursionlimit(100000 + 10)\ntc = 1\ntc = int(input())\nfor test in range(1, tc + 1):\n    (n, m) = inp()\n    a = inp()\n    st = [float('inf') for i in range(4 * len(a))]\n\n    def build(a, ind, start, end):\n        if start == end:\n            st[ind] = [a[start], start]\n        else:\n            mid = (start + end) // 2\n            build(a, 2 * ind + 1, start, mid)\n            build(a, 2 * ind + 2, mid + 1, end)\n            A = st[2 * ind + 1]\n            B = st[2 * ind + 2]\n            if A[0] > B[0]:\n                st[ind] = A.copy()\n            else:\n                st[ind] = B.copy()\n            return st[ind]\n    build(a, 0, 0, n - 1)\n\n    def query(ind, l, r, start, end):\n        if start > r or end < l:\n            return [float('-inf'), -1]\n        if l <= start <= end <= r:\n            return st[ind]\n        mid = (start + end) // 2\n        A = query(2 * ind + 1, l, r, start, mid)\n        B = query(2 * ind + 2, l, r, mid + 1, end)\n        if A[0] > B[0]:\n            return A\n        return B\n    ans = [-1] * n\n    stack = []\n    for i in range(n):\n        while stack and a[stack[-1]] < a[i]:\n            ans[stack.pop()] = i\n        stack.append(i)\n    res = [0] * n\n    for i in range(n - 1, -1, -1):\n        if ans[i] != -1:\n            res[i] = 1 + res[ans[i]]\n    for i in range(m):\n        (l, r) = inp()\n        if l > r:\n            (l, r) = (r, l)\n        l -= 1\n        r -= 1\n        (lol, ind) = query(0, l, r, 0, n - 1)\n        print(res[ind])", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush, heappop\nimport math\nfrom collections import *\nfrom functools import reduce, cmp_to_key, lru_cache\nimport sys\ninput = sys.stdin.readline\nM = mod = 998244353\n\ndef factors(n):\n    return sorted(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0))))\n\ndef inv_mod(n):\n    return pow(n, mod - 2, mod)\n\ndef li():\n    return [int(i) for i in input().rstrip('\\n').split()]\n\ndef st():\n    return input().rstrip('\\n')\n\ndef val():\n    return int(input().rstrip('\\n'))\n\ndef li2():\n    return [i for i in input().rstrip('\\n')]\n\ndef li3():\n    return [int(i) for i in input().rstrip('\\n')]\n\ndef compress(l):\n    ind = 1\n    s = set(l)\n    index = defaultdict(list)\n    for i in range(n):\n        index[l[i]].append(i)\n    for i in sorted(s):\n        for j in index[i]:\n            l[j] = ind\n        ind += 1\n    return l[:]\n\nclass Node:\n\n    def __init__(self, s, e):\n        self.start = s\n        self.end = e\n        self.val = 0\n        self.left = None\n        self.right = None\n\ndef build(nums, l, r):\n    if l == r:\n        temp = Node(l, l)\n        temp.val = nums[l]\n    else:\n        mid = l + r >> 1\n        temp = Node(l, r)\n        temp.left = build(nums, l, mid)\n        temp.right = build(nums, mid + 1, r)\n        temp.val = max(temp.left.val, temp.right.val)\n    return temp\n\ndef update(root, start, value):\n    if root.start == start == root.end:\n        root.val = value\n    elif root.start <= start and root.end >= start:\n        update(root.left, start, value)\n        update(root.right, start, value)\n        root.val = max(root.left.val, root.right.val)\n\ndef query(root, start, end):\n    if root.start >= start and root.end <= end:\n        return root.val\n    elif root.start > end or root.end < start:\n        return -float('inf')\n    else:\n        temp1 = query(root.left, start, end)\n        temp2 = query(root.right, start, end)\n        return max(temp1, temp2)\n\nclass Bitree:\n\n    def __init__(self):\n        self.bitree = []\n\n    def getsum(self, i):\n        s = 0\n        i += 1\n        while i > 0:\n            s += self.bitree[i]\n            i -= i & -i\n        return s\n\n    def sum(self, a, b):\n        return self.getsum(b) - self.getsum(a - 1) if a else self.getsum(b)\n\n    def update(self, i, v):\n        i += 1\n        while i < len(self.bitree):\n            self.bitree[i] += v\n            i += i & -i\n\n    def build(self, arr):\n        n = len(arr)\n        self.bitree = [0] * (n + 1)\n        for i in range(n):\n            self.update(i, arr[i])\nfor _ in range(val()):\n    (n, m) = li()\n    l = compress(li())\n    root = build(l, 0, n - 1)\n    queries = defaultdict(list)\n    ans = [0] * m\n    for i in range(m):\n        (x, y) = sorted(li())\n        queries[y].append([x, i])\n    for i in queries:\n        queries[i] = sorted(queries[i])\n    fenwick = Bitree()\n    fenwick.build([0] * (n + 10))\n    stack = deque()\n    for i in range(n - 1, -1, -1):\n        while stack and stack[0] <= l[i]:\n            fenwick.update(stack[0], -1)\n            stack.popleft()\n        for (j, ind) in queries[i + 1]:\n            ma = query(root, j - 1, i)\n            ans[ind] = fenwick.sum(ma + 1, n + 3)\n        stack.appendleft(l[i])\n        fenwick.update(l[i], 1)\n    for i in ans:\n        print(i)"]