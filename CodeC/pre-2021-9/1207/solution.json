["import sys\nsys.setrecursionlimit(10 ** 6)\n(N, Q) = map(int, input().split())\ng = dict()\nkey = dict()\n(R, Rkey) = map(int, input().split())\nkey[R] = Rkey\nfor i in range(N - 1):\n    (u, v, k) = map(int, input().split())\n    key[u] = k\n    if u not in g:\n        g[u] = []\n    if v not in g:\n        g[v] = []\n    g[u].append(v)\n    g[v].append(u)\n\nclass Trie:\n\n    def __init__(self):\n        self.root = [None, None]\n\n    def insert(self, n):\n        t = Trie()\n        cur = t.root = self.root[:]\n        for i in range(30, -1, -1):\n            bit = n >> i & 1\n            cur[bit] = [None, None] if cur[bit] is None else cur[bit][:]\n            cur = cur[bit]\n        return t\n\n    def xor_max_min(self, k, minmode):\n        cur = self.root\n        res = 0\n        for i in range(30, -1, -1):\n            bit = k >> i & 1\n            pref = bit if minmode else not bit\n            res = res << 1 | (pref if cur[pref] is not None else not pref)\n            cur = cur[pref] if cur[pref] is not None else cur[not pref]\n        return res\ntrie = dict()\ntrie[R] = Trie().insert(key[R])\n\ndef dfs(u, p):\n    for v in g[u]:\n        if v == p:\n            continue\n        trie[v] = trie[u].insert(key[v])\n        dfs(v, u)\ndfs(R, None)\nanswers = []\nlast_answer = 0\nfor q in range(Q):\n    (t, *rest) = map(int, input().split())\n    t = t ^ last_answer\n    if t == 0:\n        (v, u, k) = rest\n        v ^= last_answer\n        u ^= last_answer\n        k ^= last_answer\n        trie[u] = trie[v].insert(k)\n    else:\n        (v, k) = rest\n        v ^= last_answer\n        k ^= last_answer\n        t = trie[v]\n        min_answer = k ^ t.xor_max_min(k, minmode=True)\n        max_answer = k ^ t.xor_max_min(k, minmode=False)\n        answers.append(str(min_answer) + ' ' + str(max_answer))\n        last_answer = min_answer ^ max_answer\nprint(*answers, sep='\\n')", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nclass Trie:\n\n    def __init__(self):\n        self.root = [None, None]\n\n    def xor_max_min(self, k, minmode):\n        cur = self.root\n        res = 0\n        for i in range(30, -1, -1):\n            bit = k >> i & 1\n            pref = bit if minmode else not bit\n            res = res << 1 | (pref if cur[pref] is not None else not pref)\n            cur = cur[pref] if cur[pref] is not None else cur[not pref]\n        return res\n\n    def insert(self, n):\n        t = Trie()\n        cur = t.root = self.root[:]\n        for i in range(30, -1, -1):\n            bit = n >> i & 1\n            cur[bit] = [None, None] if cur[bit] is None else cur[bit][:]\n            cur = cur[bit]\n        return t\n\n    @classmethod\n    def _print(cls, cur, num):\n        if len(num) == 31:\n            print(num)\n        if cur[0] is not None:\n            cls._print(cur[0], num + '0')\n        if cur[1] is not None:\n            cls._print(cur[1], num + '1')\n\n    def print(self):\n        self._print(self.root, '')\n(N, Q) = map(int, input().split())\ng = dict()\nkey = dict()\n(R, Rkey) = map(int, input().split())\nkey[R] = Rkey\nfor i in range(N - 1):\n    (u, v, k) = map(int, input().split())\n    key[u] = k\n    if u not in g:\n        g[u] = []\n    if v not in g:\n        g[v] = []\n    g[u].append(v)\n    g[v].append(u)\ntrie = dict()\ntrie[R] = Trie().insert(key[R])\n\ndef dfs(u, p):\n    for v in g[u]:\n        if v == p:\n            continue\n        trie[v] = trie[u].insert(key[v])\n        dfs(v, u)\ndfs(R, None)\nanswers = []\nlast_answer = 0\nfor q in range(Q):\n    (t, *rest) = map(int, input().split())\n    t = t ^ last_answer\n    if t == 0:\n        (v, u, k) = rest\n        v ^= last_answer\n        u ^= last_answer\n        k ^= last_answer\n        trie[u] = trie[v].insert(k)\n    else:\n        (v, k) = rest\n        v ^= last_answer\n        k ^= last_answer\n        t = trie[v]\n        min_answer = k ^ t.xor_max_min(k, minmode=True)\n        max_answer = k ^ t.xor_max_min(k, minmode=False)\n        answers.append(str(min_answer) + ' ' + str(max_answer))\n        last_answer = min_answer ^ max_answer\nprint(*answers, sep='\\n')"]