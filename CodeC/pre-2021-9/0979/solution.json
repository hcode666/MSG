["from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "def get_min_area_by_horizontal_split(points):\n    points.sort()\n    xs = [point[0] for point in points]\n    first_rectangle = [(points[0][1], points[0][1])]\n    for (x, y) in points[1:]:\n        bottom = min(first_rectangle[-1][0], y)\n        top = max(first_rectangle[-1][1], y)\n        first_rectangle.append((bottom, top))\n    first_heights = [top - bottom for (bottom, top) in first_rectangle]\n    second_rectangle = [(points[-1][1], points[-1][1])]\n    for (x, y) in points[-2::-1]:\n        bottom = min(second_rectangle[-1][0], y)\n        top = max(second_rectangle[-1][1], y)\n        second_rectangle.append((bottom, top))\n    second_rectangle = second_rectangle[::-1]\n    second_heights = [top - bottom for (bottom, top) in second_rectangle]\n    min_area = 10 ** 18\n    first_left = xs[0]\n    second_right = xs[-1]\n    iterator = zip(xs[:-1], first_heights[:-1], xs[1:], second_heights[1:])\n    for (first_right, first_height, second_left, second_height) in iterator:\n        first_width = first_right - first_left\n        first_area = first_width * first_height\n        second_width = second_right - second_left\n        second_area = second_width * second_height\n        min_area = min(min_area, first_area + second_area)\n    return min_area\nn_testcase = int(input())\nfor testcase in range(n_testcase):\n    n = int(input())\n    points = [tuple((int(x) for x in input().split())) for i in range(n)]\n    if n <= 2:\n        print(0)\n        continue\n    points_sorted_by_x = sorted(points)\n    points_sorted_by_y = sorted([(y, x) for (x, y) in points])\n    min_area = min(get_min_area_by_horizontal_split(points_sorted_by_x), get_min_area_by_horizontal_split(points_sorted_by_y))\n    print(min_area)", "for _ in range(int(input())):\n    n = int(input())\n    points = []\n    for i in range(n):\n        points.append(tuple(map(int, input().split())))\n    if n <= 2:\n        print(0)\n        continue\n    A = float('inf')\n    X = list(sorted(points))\n    (minpref, maxpref, minsuff, maxsuff) = ([X[0][1]], [X[0][1]], [X[-1][1]], [X[-1][1]])\n    for i in range(1, n):\n        minpref.append(min(minpref[i - 1], X[i][1]))\n        maxpref.append(max(maxpref[i - 1], X[i][1]))\n        minsuff.append(min(minsuff[i - 1], X[n - i - 1][1]))\n        maxsuff.append(max(maxsuff[i - 1], X[n - i - 1][1]))\n    for i in range(n - 1):\n        w0 = X[i][0] - X[0][0]\n        h0 = maxpref[i] - minpref[i]\n        w1 = X[n - 1][0] - X[i + 1][0]\n        h1 = maxsuff[n - i - 2] - minsuff[n - i - 2]\n        A = min(A, w0 * h0 + w1 * h1)\n    Y = list(sorted(points, key=lambda x: (x[1], x[0])))\n    (minpref, maxpref, minsuff, maxsuff) = ([Y[0][0]], [Y[0][0]], [Y[-1][0]], [Y[-1][0]])\n    for i in range(1, n):\n        minpref.append(min(minpref[i - 1], Y[i][0]))\n        maxpref.append(max(maxpref[i - 1], Y[i][0]))\n        minsuff.append(min(minsuff[i - 1], Y[n - i - 1][0]))\n        maxsuff.append(max(maxsuff[i - 1], Y[n - i - 1][0]))\n    for i in range(n - 1):\n        w0 = maxpref[i] - minpref[i]\n        h0 = Y[i][1] - Y[0][1]\n        w1 = maxsuff[n - i - 2] - minsuff[n - i - 2]\n        h1 = Y[n - 1][1] - Y[i + 1][1]\n        A = min(A, w0 * h0 + w1 * h1)\n    print(A)", "from operator import itemgetter\n\ndef AreaCalculation(sorted_list):\n    Area_1 = [0] * N\n    first = sorted_list[0][0]\n    index = 0\n    (mx_w, mn_w) = (sorted_list[0][1], sorted_list[0][1])\n    for (a, b) in sorted_list:\n        h = a - first\n        mx_w = max(mx_w, b)\n        mn_w = min(mn_w, b)\n        Area_1[index] = h * (mx_w - mn_w)\n        index += 1\n    Area_2 = [0] * N\n    last = sorted_list[-1][0]\n    index = N - 1\n    (mx_w, mn_w) = (sorted_list[-1][1], sorted_list[-1][1])\n    for (a, b) in sorted_list[::-1]:\n        h = last - a\n        mx_w = max(mx_w, b)\n        mn_w = min(mn_w, b)\n        Area_2[index] = h * (mx_w - mn_w)\n        index -= 1\n    area = float('inf')\n    for i in range(N - 1):\n        area = min(area, Area_1[i] + Area_2[i + 1])\n    return area\n\ndef MinimumDualArea(N, L1, L2):\n    if N <= 2:\n        return 0\n    L1.sort()\n    L2.sort()\n    return min(AreaCalculation(L1), AreaCalculation(L2))\nT = int(input())\nfor case in range(T):\n    N = int(input())\n    L1 = []\n    L2 = []\n    for i in range(N):\n        (x, y) = tuple(map(int, input().split()))\n        L1.append((x, y))\n        L2.append((y, x))\n    print(MinimumDualArea(N, L1, L2))", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    l.sort(key=lambda x: x[1])\n    l.sort(key=lambda x: x[0])\n    pref1 = [[l[0][1], l[0][1]]]\n    pref2 = [[l[-1][1], l[-1][1]]]\n    ma = l[0][1]\n    mi = l[0][1]\n    for i in range(1, n):\n        ma = max(ma, l[i][1])\n        mi = min(mi, l[i][1])\n        pref1.append([ma, mi])\n    ma = l[-1][1]\n    mi = l[-1][1]\n    for i in range(n - 2, -1, -1):\n        ma = max(ma, l[i][1])\n        mi = min(mi, l[i][1])\n        pref2.append([ma, mi])\n    pref2 = pref2[::-1]\n    a = l[0][0]\n    b = l[-1][0]\n    m = math.inf\n    ans = []\n    for i in range(n - 1):\n        x = abs(a - l[i][0]) * abs(pref1[i][0] - pref1[i][1])\n        y = abs(l[i + 1][0] - b) * abs(pref2[i + 1][0] - pref2[i + 1][1])\n        ans.append(x + y)\n        m = min(x + y, m)\n    a1 = m\n    l.sort(key=lambda x: x[1])\n    pref1 = [[l[0][0], l[0][0]]]\n    pref2 = [[l[-1][0], l[-1][0]]]\n    ma = l[0][0]\n    mi = l[0][0]\n    for i in range(1, n):\n        ma = max(ma, l[i][0])\n        mi = min(mi, l[i][0])\n        pref1.append([ma, mi])\n    ma = l[-1][0]\n    mi = l[-1][0]\n    for i in range(n - 2, -1, -1):\n        ma = max(ma, l[i][0])\n        mi = min(mi, l[i][0])\n        pref2.append([ma, mi])\n    pref2 = pref2[::-1]\n    a = l[0][1]\n    b = l[-1][1]\n    m = math.inf\n    ans = []\n    for i in range(n - 1):\n        x = abs(a - l[i][1]) * abs(pref1[i][0] - pref1[i][1])\n        y = abs(l[i + 1][1] - b) * abs(pref2[i + 1][0] - pref2[i + 1][1])\n        ans.append(x + y)\n        m = min(x + y, m)\n    x = min(m, a1)\n    if x == math.inf:\n        print(0)\n    else:\n        print(x)", "import math\n\ndef calc(L, n):\n    pre_min = [0] * n\n    suf_min = [0] * n\n    pre_max = [0] * n\n    suf_max = [0] * n\n    pre_max[0] = L[0][1]\n    pre_min[0] = L[0][1]\n    for i in range(1, n):\n        pre_max[i] = max(pre_max[i - 1], L[i][1])\n        pre_min[i] = min(pre_min[i - 1], L[i][1])\n    suf_max[n - 1] = L[n - 1][1]\n    suf_min[n - 1] = L[n - 1][1]\n    for i in range(n - 2, -1, -1):\n        suf_max[i] = max(suf_max[i + 1], L[i][1])\n        suf_min[i] = min(suf_min[i + 1], L[i][1])\n    ans = math.inf\n    for i in range(n - 1):\n        s1 = L[i][0] - L[0][0]\n        s2 = pre_max[i] - pre_min[i]\n        s3 = suf_max[i + 1] - suf_min[i + 1]\n        s4 = L[n - 1][0] - L[i + 1][0]\n        ans = min(ans, s1 * s2 + s3 * s4)\n    return ans\nt = int(input())\nfor z in range(t):\n    n = int(input())\n    points = []\n    points_y = []\n    for i in range(n):\n        p = list(map(int, input().split()))\n        points.append(p)\n        points_y.append(p[::-1])\n    if n <= 2:\n        print(0)\n    else:\n        points.sort()\n        points_y.sort()\n        print(min(calc(points, n), calc(points_y, n)))", "try:\n    import sys\n    from sys import stdin\n\n    def indx(li, val):\n        (f, l, ind) = (0, len(li), -1)\n        while f <= l and ind == -1:\n            mid = (f + l) // 2\n            if li[mid] == val:\n                ind = mid\n            elif val < li[mid]:\n                l = mid - 1\n            else:\n                f = mid + 1\n        return ind\n\n    def solveA(x, Y, ar, n):\n        (max_h, min_h) = (0, sys.maxsize)\n        for i in range(n - 1):\n            (max_h, min_h) = (max(x[i][1], max_h), min(x[i][1], min_h))\n            d1 = max_h - min_h\n            ind = indx(Y, x[i][1])\n            del Y[ind]\n            d2 = Y[-1] - Y[0]\n            new_ar = d1 * (x[i][0] - x[0][0]) + d2 * (x[n - 1][0] - x[i + 1][0])\n            ar = min(ar, new_ar)\n        return ar\n\n    def solveB(y, X, ar, n):\n        (max_wd, min_wd) = (0, sys.maxsize)\n        for i in range(n - 1):\n            (max_wd, min_wd) = (max(y[i][1], max_wd), min(y[i][1], min_wd))\n            d3 = max_wd - min_wd\n            ind = indx(X, y[i][1])\n            del X[ind]\n            d4 = X[-1] - X[0]\n            new_ar = d3 * (y[i][0] - y[0][0]) + d4 * (y[n - 1][0] - y[i + 1][0])\n            ar = min(ar, new_ar)\n        return ar\n\n    def solve(n):\n        (x, y, X, Y, ar) = ([], [], [], [], sys.maxsize)\n        for i in range(n):\n            (a, b) = map(int, sys.stdin.readline().split())\n            (x.append([a, b]), y.append([b, a]), X.append(a), Y.append(b))\n        x.sort()\n        y.sort()\n        X.sort()\n        Y.sort()\n        re = solveA(x, Y, ar, n)\n        result = solveB(y, X, re, n)\n        if n == 1:\n            print(0)\n        else:\n            print(result)\n\n    def main():\n        for _ in range(int(sys.stdin.readline())):\n            n = int(sys.stdin.readline())\n            solve(n)\n    main()\nexcept Exception:\n    pass", "def calc(a, n):\n    p1 = [0] * n\n    p2 = [0] * n\n    s1 = [0] * n\n    s2 = [0] * n\n    p1[0] = a[0][1]\n    p2[0] = a[0][1]\n    for i in range(1, n):\n        p1[i] = max(p1[i - 1], a[i][1])\n        p2[i] = min(p2[i - 1], a[i][1])\n    s1[n - 1] = a[n - 1][1]\n    s2[n - 1] = a[n - 1][1]\n    for i in range(n - 2, -1, -1):\n        s1[i] = max(s1[i + 1], a[i][1])\n        s2[i] = min(s2[i + 1], a[i][1])\n    ans = float('inf')\n    for i in range(0, n - 1):\n        r1l = p1[i] - p2[i]\n        r1b = a[i][0] - a[0][0]\n        r2l = s1[i + 1] - s2[i + 1]\n        r2b = a[n - 1][0] - a[i + 1][0]\n        ans = min(ans, r1l * r1b + r2l * r2b)\n    return ans\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    n = int(input())\n    a1 = []\n    a2 = []\n    for i in range(0, n):\n        b = [int(x) for x in input().split()]\n        a1.append(b)\n        a2.append(b[::-1])\n    if n <= 2:\n        print(0)\n        continue\n    a1.sort()\n    ans1 = calc(a1, n)\n    a2.sort()\n    ans2 = calc(a2, n)\n    print(min(ans1, ans2))", "import math\n\ndef dv(n, a):\n    a.sort()\n    bfl = [-1] * n\n    bfr = [-1] * n\n    bfl[0] = a[0][1]\n    for i in range(1, n):\n        bfl[i] = max(bfl[i - 1], a[i][1])\n    bfr[n - 1] = a[n - 1][1]\n    for i in range(n - 2, -1, -1):\n        bfr[i] = max(bfr[i + 1], a[i][1])\n    sfl = [math.inf] * n\n    sfr = [math.inf] * n\n    sfl[0] = a[0][1]\n    for i in range(1, n):\n        sfl[i] = min(sfl[i - 1], a[i][1])\n    sfr[n - 1] = a[n - 1][1]\n    for i in range(n - 2, -1, -1):\n        sfr[i] = min(sfr[i + 1], a[i][1])\n    res = math.inf\n    for i in range(n - 1):\n        al = (a[i][0] - a[0][0]) * (bfl[i] - sfl[i])\n        ar = (a[n - 1][0] - a[i + 1][0]) * (bfr[i + 1] - sfr[i + 1])\n        res = min(res, al + ar)\n    if res == math.inf:\n        return 0\n    return res\n\ndef dh(n, a):\n    a.sort(key=lambda x: x[1])\n    bfl = [-1] * n\n    bfr = [-1] * n\n    bfl[0] = a[0][0]\n    for i in range(1, n):\n        bfl[i] = max(bfl[i - 1], a[i][0])\n    bfr[n - 1] = a[n - 1][0]\n    for i in range(n - 2, -1, -1):\n        bfr[i] = max(bfr[i + 1], a[i][0])\n    sfl = [math.inf] * n\n    sfr = [math.inf] * n\n    sfl[0] = a[0][0]\n    for i in range(1, n):\n        sfl[i] = min(sfl[i - 1], a[i][0])\n    sfr[n - 1] = a[n - 1][0]\n    for i in range(n - 2, -1, -1):\n        sfr[i] = min(sfr[i + 1], a[i][0])\n    res = math.inf\n    for i in range(n - 1):\n        al = (a[i][1] - a[0][1]) * (bfl[i] - sfl[i])\n        ar = (a[n - 1][1] - a[i + 1][1]) * (bfr[i + 1] - sfr[i + 1])\n        res = min(res, al + ar)\n    if res == math.inf:\n        return 0\n    return res\n\ndef func(n, a):\n    dividevertically = dv(n, a)\n    dividehori = dh(n, a)\n    return min(dividehori, dividevertically)\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(tuple(map(int, input().split())))\n    print(func(n, a))", "test = int(input())\nfor i in range(0, test):\n    n = int(input())\n    finall = []\n    for i in range(0, n):\n        lis = list(map(int, input().split()))\n        finall.append(lis)\n    if n <= 2:\n        print(0)\n        continue\n    final = sorted(finall)\n    max_pref = [final[0][1]]\n    min_pref = [final[0][1]]\n    max_suf = []\n    min_suf = []\n    for i in range(1, len(final)):\n        if final[i][1] > max_pref[i - 1]:\n            max_pref.append(final[i][1])\n            max_suf.append(0)\n            min_suf.append(0)\n        else:\n            max_pref.append(max_pref[i - 1])\n            max_suf.append(0)\n            min_suf.append(0)\n        if final[i][1] < min_pref[i - 1]:\n            min_pref.append(final[i][1])\n            max_suf.append(0)\n            min_suf.append(0)\n        else:\n            min_pref.append(min_pref[i - 1])\n            max_suf.append(0)\n            min_suf.append(0)\n    max_suf[len(final) - 1] = final[len(final) - 1][1]\n    min_suf[len(final) - 1] = final[len(final) - 1][1]\n    for j in range(len(final) - 2, -1, -1):\n        if final[j][1] > max_suf[j + 1]:\n            max_suf[j] = final[j][1]\n        else:\n            max_suf[j] = max_suf[j + 1]\n        if final[j][1] < min_suf[j + 1]:\n            min_suf[j] = final[j][1]\n        else:\n            min_suf[j] = min_suf[j + 1]\n    mini = (final[len(final) - 1][0] - final[0][0]) * (max_pref[len(final) - 1] - min_pref[len(final) - 1])\n    for i in range(0, len(final) - 1):\n        width1 = final[i][0] - final[0][0]\n        height1 = max_pref[i] - min_pref[i]\n        width2 = final[len(final) - 1][0] - final[i + 1][0]\n        height2 = max_suf[i + 1] - min_suf[i + 1]\n        ans1 = width1 * height1 + width2 * height2\n        if ans1 < mini:\n            mini = ans1\n    final = sorted(finall, key=lambda x: x[1])\n    max_pref = [final[0][0]]\n    min_pref = [final[0][0]]\n    max_suf = []\n    min_suf = []\n    for i in range(1, len(final)):\n        if final[i][0] > max_pref[i - 1]:\n            max_pref.append(final[i][0])\n            max_suf.append(0)\n            min_suf.append(0)\n        else:\n            max_pref.append(max_pref[i - 1])\n            max_suf.append(0)\n            min_suf.append(0)\n        if final[i][0] < min_pref[i - 1]:\n            min_pref.append(final[i][0])\n            max_suf.append(0)\n            min_suf.append(0)\n        else:\n            min_pref.append(min_pref[i - 1])\n            max_suf.append(0)\n            min_suf.append(0)\n    max_suf[len(final) - 1] = final[len(final) - 1][0]\n    min_suf[len(final) - 1] = final[len(final) - 1][0]\n    for j in range(len(final) - 2, -1, -1):\n        if final[j][0] > max_suf[j + 1]:\n            max_suf[j] = final[j][0]\n        else:\n            max_suf[j] = max_suf[j + 1]\n        if final[j][0] < min_suf[j + 1]:\n            min_suf[j] = final[j][0]\n        else:\n            min_suf[j] = min_suf[j + 1]\n    mini2 = (final[len(final) - 1][1] - final[0][1]) * (max_pref[len(final) - 1] - min_pref[len(final) - 1])\n    for i in range(0, len(final) - 1):\n        width1 = max_pref[i] - min_pref[i]\n        height1 = final[i][1] - final[0][1]\n        width2 = max_suf[i + 1] - min_suf[i + 1]\n        height2 = final[len(final) - 1][1] - final[i + 1][1]\n        ans1 = width1 * height1 + width2 * height2\n        if ans1 < mini2:\n            mini2 = ans1\n    print(min(mini, mini2))", "import collections\nimport itertools\nimport sys\nimport numpy as np\n\ndef singleArea(n, points):\n    if n == 1:\n        return 0\n    points.sort(key=lambda x: x[1])\n    (pr, pst) = (collections.deque(), collections.deque())\n    (mnx, mny, mxx, mxy) = (points[0][0], points[0][1], points[0][0], points[0][1])\n    for i in range(n - 1):\n        (x, y) = points[i]\n        if x < mnx:\n            mnx = x\n        if y < mny:\n            mny = y\n        if x > mxx:\n            mxx = x\n        if y > mxy:\n            mxy = y\n        pr.append([abs(mxx - mnx), abs(mny - mxy)])\n    (mnx, mny, mxx, mxy) = (points[-1][0], points[-1][1], points[-1][0], points[-1][1])\n    points.reverse()\n    for i in range(n - 1):\n        (x, y) = points[i]\n        if x < mnx:\n            mnx = x\n        if y < mny:\n            mny = y\n        if x > mxx:\n            mxx = x\n        if y > mxy:\n            mxy = y\n        pst.appendleft([abs(mxx - mnx), abs(mny - mxy)])\n    ar = sys.maxsize\n    for (x, y) in itertools.zip_longest(pr, pst):\n        temp = x[0] * x[1] + y[0] * y[1]\n        if temp < ar:\n            ar = temp\n    return ar\n\ndef dualArea(n: int, points: list):\n    if n == 1:\n        return 0\n    points.sort()\n    (pr, pst) = (collections.deque(), collections.deque())\n    (mnx, mny, mxx, mxy) = (points[0][0], points[0][1], points[0][0], points[0][1])\n    for i in range(n - 1):\n        (x, y) = points[i]\n        if x < mnx:\n            mnx = x\n        if y < mny:\n            mny = y\n        if x > mxx:\n            mxx = x\n        if y > mxy:\n            mxy = y\n        pr.append([abs(mxx - mnx), abs(mny - mxy)])\n    (mnx, mny, mxx, mxy) = (points[-1][0], points[-1][1], points[-1][0], points[-1][1])\n    points.reverse()\n    for i in range(n - 1):\n        (x, y) = points[i]\n        if x < mnx:\n            mnx = x\n        if y < mny:\n            mny = y\n        if x > mxx:\n            mxx = x\n        if y > mxy:\n            mxy = y\n        pst.appendleft([abs(mxx - mnx), abs(mny - mxy)])\n    ar = sys.maxsize\n    for (x, y) in itertools.zip_longest(pr, pst):\n        temp = x[0] * x[1] + y[0] * y[1]\n        if temp < ar:\n            ar = temp\n    return ar\nfor _ in range(int(input())):\n    n = int(input())\n    arr = []\n    for i in range(n):\n        arr.append(list(map(int, input().split())))\n    print(min(singleArea(n, arr), dualArea(n, arr)))", "import sys\nfrom os import path\nif path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output1.txt', 'w')\nfrom heapq import heappop, heappush, heapify\nfrom math import ceil\nmini = -2 * pow(10, 9)\nmaxi = -1 * mini\nfrom collections import defaultdict\n\ndef smallareas(hash1, a):\n    l = []\n    m = []\n    for i in hash1:\n        temp = hash1[i]\n        l.append([i, temp[0]])\n        m.append([i, temp[-1]])\n    l.sort()\n    m.sort()\n    for i in range(1, a):\n        l[i][1] = min(l[i][1], l[i - 1][1])\n        m[i][1] = max(m[i][1], m[i - 1][1])\n    left = mini\n    right = maxi\n    top = mini\n    bottom = maxi\n    top = max(top, l[-1][0])\n    bottom = min(bottom, l[-1][0])\n    left = max(left, hash1[l[-1][0]][0])\n    right = min(right, hash1[l[-1][0]][-1])\n    breadth = right - left\n    length = top - bottom\n    lower = length * breadth\n    top1 = l[-2][0]\n    bottom1 = l[0][0]\n    left1 = l[-2][-1]\n    right1 = m[-2][-1]\n    breadth = right1 - left1\n    length = top1 - bottom1\n    upper = length * breadth\n    ans1 = lower + upper\n    top = l[-1][0]\n    for i in range(a - 3, -1, -1):\n        left = min(left, hash1[l[i + 1][0]][0])\n        right = max(right, hash1[l[i + 1][0]][-1])\n        bottom = l[i + 1][0]\n        breadth = right - left\n        length = top - bottom\n        lower = length * breadth\n        top1 = l[i][0]\n        bottom1 = l[0][0]\n        left1 = l[i][-1]\n        right1 = m[i][-1]\n        breadth = right1 - left1\n        length = top1 - bottom1\n        upper = length * breadth\n        ans1 = min(ans1, lower + upper)\n    return ans1\nfor _ in range(int(input())):\n    n = int(input())\n    (hash1, hash2) = (defaultdict(list), defaultdict(list))\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        hash1[a].append(b)\n        hash2[b].append(a)\n    (a, b) = (len(hash1), len(hash2))\n    if a > 2 and b > 2:\n        for i in hash1:\n            hash1[i].sort()\n        for i in hash2:\n            hash2[i].sort()\n        print(min(smallareas(hash1, a), smallareas(hash2, b)))\n    else:\n        print(0)", "try:\n    import sys\n    from sys import stdin\n\n    def indx(li, val):\n        (f, l, ind) = (0, len(li), -1)\n        while f <= l and ind == -1:\n            mid = (f + l) // 2\n            if li[mid] == val:\n                ind = mid\n            elif val < li[mid]:\n                l = mid - 1\n            else:\n                f = mid + 1\n        return ind\n\n    def solveA(x, Y, ar, n):\n        (max_h, min_h) = (0, sys.maxsize)\n        for i in range(n - 1):\n            (max_h, min_h) = (max(x[i][1], max_h), min(x[i][1], min_h))\n            d1 = max_h - min_h\n            ind = indx(Y, x[i][1])\n            del Y[ind]\n            d2 = Y[-1] - Y[0]\n            new_ar = d1 * (x[i][0] - x[0][0]) + d2 * (x[n - 1][0] - x[i + 1][0])\n            ar = min(ar, new_ar)\n        return ar\n\n    def solveB(y, X, ar, n):\n        (max_wd, min_wd) = (0, sys.maxsize)\n        for i in range(n - 1):\n            (max_wd, min_wd) = (max(y[i][1], max_wd), min(y[i][1], min_wd))\n            d3 = max_wd - min_wd\n            ind = indx(X, y[i][1])\n            del X[ind]\n            d4 = X[-1] - X[0]\n            new_ar = d3 * (y[i][0] - y[0][0]) + d4 * (y[n - 1][0] - y[i + 1][0])\n            ar = min(ar, new_ar)\n        return ar\n\n    def solve(n):\n        (x, y, X, Y, ar) = ([], [], [], [], sys.maxsize)\n        for i in range(n):\n            (a, b) = map(int, sys.stdin.readline().split())\n            (x.append([a, b]), y.append([b, a]), X.append(a), Y.append(b))\n        x.sort()\n        y.sort()\n        X.sort()\n        Y.sort()\n        re = solveA(x, Y, ar, n)\n        result = solveB(y, X, re, n)\n        if n == 1:\n            print(0)\n        else:\n            print(result)\n\n    def main():\n        for _ in range(int(sys.stdin.readline())):\n            n = int(sys.stdin.readline())\n            solve(n)\n    main()\nexcept Exception:\n    pass", "def maximum(arr1, index):\n    return max(arr1, key=lambda a: a[not index])[not index]\n\ndef minimum(arr1, index):\n    return min(arr1, key=lambda a: a[not index])[not index]\n\ndef prefix_suffix(arr):\n    prefix_min = [0] * (len(arr) + 2)\n    suffix_min = [0] * (len(arr) + 2)\n    prefix_max = [0] * (len(arr) + 2)\n    suffix_max = [0] * (len(arr) + 2)\n    prefix_min[0] = float('inf')\n    suffix_min[-1] = float('inf')\n    for i in range(1, len(arr) + 1):\n        prefix = arr[i - 1]\n        suffix = arr[-i]\n        prefix_min[i] = min(prefix_min[i - 1], prefix)\n        prefix_max[i] = max(prefix_max[i - 1], prefix)\n        suffix_min[-i - 1] = min(suffix_min[-i], suffix)\n        suffix_max[-i - 1] = max(suffix_max[-i], suffix)\n    return (prefix_min, prefix_max, suffix_min, suffix_max)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = []\n    for _ in range(n):\n        point = list(map(int, input().split()))\n        arr.append(point)\n    if n == 1:\n        print(0)\n    else:\n        x_sort = sorted(arr, key=lambda a: a[0])\n        y_sort = sorted(arr, key=lambda b: b[1])\n        area_x = float('inf')\n        x = prefix_suffix(list(map(lambda a: a[1], x_sort)))\n        prefix_min_x = x[0]\n        prefix_max_x = x[1]\n        suffix_min_x = x[2]\n        suffix_max_x = x[3]\n        for i in range(1, n):\n            x_1 = (prefix_max_x[i] - prefix_min_x[i]) * (x_sort[i - 1][0] - x_sort[0][0])\n            x_2 = (suffix_max_x[i + 1] - suffix_min_x[i + 1]) * (x_sort[-1][0] - x_sort[i][0])\n            area_x = min(area_x, x_1 + x_2)\n        area_y = float('inf')\n        y = prefix_suffix(list(map(lambda a: a[0], y_sort)))\n        prefix_min_y = y[0]\n        prefix_max_y = y[1]\n        suffix_min_y = y[2]\n        suffix_max_y = y[3]\n        for i in range(1, n):\n            y_1 = (prefix_max_y[i] - prefix_min_y[i]) * (y_sort[i - 1][1] - y_sort[0][1])\n            y_2 = (suffix_max_y[i + 1] - suffix_min_y[i + 1]) * (y_sort[-1][1] - y_sort[i][1])\n            area_y = min(area_y, y_1 + y_2)\n        print(int(min(area_x, area_y)))", "def height(A, n):\n    a = []\n    mn = 1000000000.0 + 1\n    mx = -1\n    for i in range(n - 1):\n        if A[i] < mn:\n            mn = A[i]\n        if A[i] > mx:\n            mx = A[i]\n        a.append(mx - mn)\n    return a\n\ndef sort(L):\n    return sorted(L, key=lambda x: x[0])\n\ndef fun(A, n):\n    l2 = []\n    for i in range(n):\n        l2.append(A[i][1])\n    h1 = height(l2, n)\n    h2 = height(l2[::-1], n)\n    h2 = h2[::-1]\n    area = 1e+19 + 1\n    for i in range(n - 1):\n        temp = h1[i] * (A[i][0] - A[0][0]) + h2[i] * (A[-1][0] - A[i + 1][0])\n        if temp < area:\n            area = temp\n    if area == 1e+19:\n        return 0\n    else:\n        return area\nfor i in range(int(input())):\n    n = int(input())\n    (Lx, Ly) = ([], [])\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        Lx.append([a, b])\n        Ly.append([b, a])\n    Lx = sort(Lx)\n    Ly = sort(Ly)\n    area1 = fun(Lx, n)\n    area2 = fun(Ly, n)\n    print(min(area1, area2))", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom math import inf\nfrom sys import stdin\nread_line = lambda : stdin.readline().strip()\nread_point = lambda : tuple(map(int, read_line().split()))\nbox_area = lambda left, right: (right[1] - left[1]) * (right[0] - left[0])\n\ndef solve(p):\n    sort_by_x = sorted(p, key=lambda x: (x[0], -x[1]))\n    box_left = []\n    (min_x, min_y) = sort_by_x[0]\n    (max_x, max_y) = sort_by_x[0]\n    for (x, y) in sort_by_x:\n        if x < min_x:\n            min_x = x\n        if x > max_x:\n            max_x = x\n        if y < min_y:\n            min_y = y\n        if y > max_y:\n            max_y = y\n        box_left.append([(min_x, min_y), (max_x, max_y)])\n    box_right = []\n    (min_x, min_y) = sort_by_x[-1]\n    (max_x, max_y) = sort_by_x[-1]\n    for (x, y) in sort_by_x[::-1]:\n        if x < min_x:\n            min_x = x\n        if x > max_x:\n            max_x = x\n        if y < min_y:\n            min_y = y\n        if y > max_y:\n            max_y = y\n        box_right.append([(min_x, min_y), (max_x, max_y)])\n    area = inf\n    for i in range(len(sort_by_x)):\n        area_left = box_area(*box_left[i])\n        area_right = box_area(*box_right[len(sort_by_x) - 2 - i])\n        new_area = area_left + area_right\n        if new_area < area:\n            area = new_area\n    return area\n\ndef main():\n    for _ in range(int(input())):\n        N = int(input())\n        p = [read_point() for _ in range(N)]\n        x = solve(p)\n        y = solve([(y, x) for (x, y) in p])\n        solution = min(x, y)\n        print(solution)\nmain()", "def height(A, n):\n    a = []\n    mn = 1000000000.0 + 1\n    mx = -1\n    for i in range(n - 1):\n        if A[i] < mn:\n            mn = A[i]\n        if A[i] > mx:\n            mx = A[i]\n        a.append(mx - mn)\n    return a\n\ndef sort(L):\n    return sorted(L, key=lambda x: x[0])\n\ndef fun(A, n):\n    l2 = []\n    for i in range(n):\n        l2.append(A[i][1])\n    h1 = height(l2, n)\n    h2 = height(l2[::-1], n)\n    h2 = h2[::-1]\n    area = 1e+19 + 1\n    for i in range(n - 1):\n        temp = h1[i] * (A[i][0] - A[0][0]) + h2[i] * (A[-1][0] - A[i + 1][0])\n        if temp < area:\n            area = temp\n    if area == 1e+19:\n        return 0\n    else:\n        return area\nfor i in range(int(input())):\n    n = int(input())\n    (Lx, Ly) = ([], [])\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        Lx.append([a, b])\n        Ly.append([b, a])\n    Lx = sort(Lx)\n    Ly = sort(Ly)\n    area1 = fun(Lx, n)\n    area2 = fun(Ly, n)\n    print(min(area1, area2))", "import math\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    (row, col) = ([], [])\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        col.append([a, b])\n        row.append([a, b])\n    if n <= 2:\n        print(0)\n        continue\n    row = sorted(row, key=lambda x: x[0])\n    col = sorted(col, key=lambda x: x[1])\n    (pre_min, pre_max, suff_min, suff_max) = ([math.inf] * n, [-1] * n, [math.inf] * n, [-1] * n)\n    (pre_min[0], pre_max[0]) = (row[0][1], row[0][1])\n    for i in range(1, n):\n        pre_min[i] = min(pre_min[i - 1], row[i][1])\n        pre_max[i] = max(pre_max[i - 1], row[i][1])\n    (suff_min[-1], suff_max[-1]) = (row[-1][1], row[-1][1])\n    for i in range(n - 2, -1, -1):\n        suff_min[i] = min(suff_min[i + 1], row[i][1])\n        suff_max[i] = max(suff_max[i + 1], row[i][1])\n    (ypre_min, ypre_max, ysuff_min, ysuff_max) = ([math.inf] * n, [-1] * n, [math.inf] * n, [-1] * n)\n    (ypre_min[0], ypre_max[0]) = (col[0][0], col[0][0])\n    (ysuff_min[-1], ysuff_max[-1]) = (col[-1][0], col[-1][0])\n    for i in range(1, n):\n        ypre_min[i] = min(ypre_min[i - 1], col[i][0])\n        ypre_max[i] = max(ypre_max[i - 1], col[i][0])\n    for i in range(n - 2, -1, -1):\n        ysuff_min[i] = min(ysuff_min[i + 1], col[i][0])\n        ysuff_max[i] = max(ysuff_max[i + 1], col[i][0])\n    area1 = math.inf\n    for i in range(n - 1):\n        x1_1 = pre_max[i] - pre_min[i]\n        x1_2 = row[i][0] - row[0][0]\n        x2_1 = suff_max[i + 1] - suff_min[i + 1]\n        x2_2 = row[-1][0] - row[i + 1][0]\n        area1 = min(area1, x1_1 * x1_2 + x2_1 * x2_2)\n    area2 = math.inf\n    for i in range(n - 1):\n        x1_1 = ypre_max[i] - ypre_min[i]\n        x1_2 = col[i][1] - col[0][1]\n        x2_1 = ysuff_max[i + 1] - ysuff_min[i + 1]\n        x2_2 = col[-1][1] - col[i + 1][1]\n        area2 = min(area2, x1_1 * x1_2 + x2_1 * x2_2)\n    print(min(area1, area2))", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    a = set()\n    for __ in range(n):\n        a.add(tuple(map(int, input().split())))\n    a = list(a)\n    a.sort()\n    n = len(a)\n    if n <= 2:\n        print(0)\n        continue\n    mp = defaultdict(list)\n    for x in a:\n        mp[x[0]].append(x[1])\n    keys = list(mp.keys())\n    keys_len = len(keys)\n    for key in keys:\n        if len(mp[key]) > 1:\n            mp[key] = [min(mp[key]), max(mp[key])]\n    pre = []\n    maxy = -1\n    miny = 10 ** 9 + 1\n    for i in range(keys_len):\n        if i == 0:\n            if len(mp[keys[i]]) == 1:\n                maxy = mp[keys[i]][0]\n                miny = mp[keys[i]][0]\n            else:\n                maxy = max(mp[keys[i]][0], mp[keys[i]][1])\n                miny = min(mp[keys[i]][0], mp[keys[i]][1])\n        elif len(mp[keys[i]]) == 1:\n            aa = maxy\n            ba = miny\n            ca = mp[keys[i]][0]\n            maxy = max(aa, ba, ca)\n            miny = min(aa, ba, ca)\n        else:\n            aa = maxy\n            ba = miny\n            ca = mp[keys[i]][0]\n            da = mp[keys[i]][1]\n            maxy = max(aa, ba, ca, da)\n            miny = min(aa, ba, ca, da)\n        pre.append((miny, maxy))\n    post = []\n    maxy = -1\n    miny = 10 ** 9 + 1\n    for i in range(keys_len - 1, -1, -1):\n        if i == keys_len - 1:\n            if len(mp[keys[i]]) == 1:\n                maxy = mp[keys[i]][0]\n                miny = mp[keys[i]][0]\n            else:\n                maxy = max(mp[keys[i]][0], mp[keys[i]][1])\n                miny = min(mp[keys[i]][0], mp[keys[i]][1])\n        elif len(mp[keys[i]]) == 1:\n            aa = maxy\n            ba = miny\n            ca = mp[keys[i]][0]\n            maxy = max(aa, ba, ca)\n            miny = min(aa, ba, ca)\n        else:\n            aa = maxy\n            ba = miny\n            ca = mp[keys[i]][0]\n            da = mp[keys[i]][1]\n            maxy = max(aa, ba, ca, da)\n            miny = min(aa, ba, ca, da)\n        post.append((miny, maxy))\n    post = post[::-1]\n    area = 10 ** 20\n    for i in range(keys_len - 1):\n        area = min(area, (pre[i][1] - pre[i][0]) * (keys[i] - keys[0]) + (post[i + 1][1] - post[i + 1][0]) * (keys[-1] - keys[i + 1]))\n    b = []\n    for x in a:\n        b.append((x[1], x[0]))\n    b.sort()\n    n = len(b)\n    mp = defaultdict(list)\n    for x in b:\n        mp[x[0]].append(x[1])\n    keys = list(mp.keys())\n    keys_len = len(keys)\n    for key in keys:\n        if len(mp[key]) > 1:\n            mp[key] = [min(mp[key]), max(mp[key])]\n    pre = []\n    maxy = -1\n    miny = 10 ** 9 + 1\n    for i in range(keys_len):\n        if i == 0:\n            if len(mp[keys[i]]) == 1:\n                maxy = mp[keys[i]][0]\n                miny = mp[keys[i]][0]\n            else:\n                maxy = max(mp[keys[i]][0], mp[keys[i]][1])\n                miny = min(mp[keys[i]][0], mp[keys[i]][1])\n        elif len(mp[keys[i]]) == 1:\n            aa = maxy\n            ba = miny\n            ca = mp[keys[i]][0]\n            maxy = max(aa, ba, ca)\n            miny = min(aa, ba, ca)\n        else:\n            aa = maxy\n            ba = miny\n            ca = mp[keys[i]][0]\n            da = mp[keys[i]][1]\n            maxy = max(aa, ba, ca, da)\n            miny = min(aa, ba, ca, da)\n        pre.append((miny, maxy))\n    post = []\n    maxy = -1\n    miny = 10 ** 9 + 1\n    for i in range(keys_len - 1, -1, -1):\n        if i == keys_len - 1:\n            if len(mp[keys[i]]) == 1:\n                maxy = mp[keys[i]][0]\n                miny = mp[keys[i]][0]\n            else:\n                maxy = max(mp[keys[i]][0], mp[keys[i]][1])\n                miny = min(mp[keys[i]][0], mp[keys[i]][1])\n        elif len(mp[keys[i]]) == 1:\n            aa = maxy\n            ba = miny\n            ca = mp[keys[i]][0]\n            maxy = max(aa, ba, ca)\n            miny = min(aa, ba, ca)\n        else:\n            aa = maxy\n            ba = miny\n            ca = mp[keys[i]][0]\n            da = mp[keys[i]][1]\n            maxy = max(aa, ba, ca, da)\n            miny = min(aa, ba, ca, da)\n        post.append((miny, maxy))\n    post = post[::-1]\n    for i in range(keys_len - 1):\n        area = min(area, (pre[i][1] - pre[i][0]) * (keys[i] - keys[0]) + (post[i + 1][1] - post[i + 1][0]) * (keys[-1] - keys[i + 1]))\n    print(area)", "def area(rectangle):\n    [A, B] = rectangle\n    return abs(B[0] - A[0]) * abs(B[1] - A[1])\n\ndef solve(points):\n    if len(points) <= 2:\n        return 0\n    points_x = sorted(points, key=lambda x: x[0])\n    ymx = {}\n    for p in points_x:\n        if p[0] not in ymx:\n            ymx[p[0]] = [p[1], p[1]]\n            continue\n        if p[1] < ymx[p[0]][0]:\n            ymx[p[0]][0] = p[1]\n        elif p[1] > ymx[p[0]][1]:\n            ymx[p[0]][1] = p[1]\n    y_right = {points_x[-1][0]: ymx[points_x[-1][0]]}\n    for i in range(N - 2, -1, -1):\n        y_right[points_x[i][0]] = [min(y_right[points_x[i + 1][0]][0], ymx[points_x[i][0]][0]), max(y_right[points_x[i + 1][0]][1], ymx[points_x[i][0]][1])]\n    r1_x = [points_x[0][0], points_x[0][0]]\n    r2_x = [points_x[-1][0], points_x[-1][0]]\n    r1_y = [ymx[points_x[0][0]][0], ymx[points_x[0][0]][1]]\n    r2_y = [y_right[points_x[-1][0]][0], y_right[points_x[-1][0]][1]]\n    area_max = float('inf')\n    for i in range(N - 1):\n        r1_x[1] = points_x[i][0]\n        r2_x[0] = points_x[i + 1][0]\n        if r1_y[0] > ymx[points_x[i][0]][0]:\n            r1_y[0] = ymx[points_x[i][0]][0]\n        if r1_y[1] < ymx[points_x[i][0]][1]:\n            r1_y[1] = ymx[points_x[i][0]][1]\n        r2_y = y_right[points_x[i + 1][0]]\n        new_area = area([[r1_x[0], r1_y[0]], [r1_x[1], r1_y[1]]]) + area([[r2_x[0], r2_y[0]], [r2_x[1], r2_y[1]]])\n        if new_area < area_max:\n            area_max = new_area\n    points = [[y, x] for [x, y] in points]\n    points_x = sorted(points, key=lambda x: x[0])\n    ymx = {}\n    for p in points_x:\n        if p[0] not in ymx:\n            ymx[p[0]] = [p[1], p[1]]\n            continue\n        if p[1] < ymx[p[0]][0]:\n            ymx[p[0]][0] = p[1]\n        elif p[1] > ymx[p[0]][1]:\n            ymx[p[0]][1] = p[1]\n    y_right = {points_x[-1][0]: ymx[points_x[-1][0]]}\n    for i in range(N - 2, -1, -1):\n        y_right[points_x[i][0]] = [min(y_right[points_x[i + 1][0]][0], ymx[points_x[i][0]][0]), max(y_right[points_x[i + 1][0]][1], ymx[points_x[i][0]][1])]\n    r1_x = [points_x[0][0], points_x[0][0]]\n    r2_x = [points_x[-1][0], points_x[-1][0]]\n    r1_y = [ymx[points_x[0][0]][0], ymx[points_x[0][0]][1]]\n    r2_y = [y_right[points_x[-1][0]][0], y_right[points_x[-1][0]][1]]\n    full_rect = [[points_x[0][0], y_right[points[0][0]][0]], [points_x[-1][0], y_right[points[0][0]][1]]]\n    for i in range(N - 1):\n        r1_x[1] = points_x[i][0]\n        r2_x[0] = points_x[i + 1][0]\n        if r1_y[0] > ymx[points_x[i][0]][0]:\n            r1_y[0] = ymx[points_x[i][0]][0]\n        if r1_y[1] < ymx[points_x[i][0]][1]:\n            r1_y[1] = ymx[points_x[i][0]][1]\n        r2_y = y_right[points_x[i + 1][0]]\n        new_area = area([[r1_x[0], r1_y[0]], [r1_x[1], r1_y[1]]]) + area([[r2_x[0], r2_y[0]], [r2_x[1], r2_y[1]]])\n        if new_area < area_max:\n            area_max = new_area\n    return area_max\nfor _ in range(int(input())):\n    N = int(input())\n    points = [[int(x) for x in input().split()] for i in range(N)]\n    print(solve(points))", "from collections import defaultdict\n\ndef neginf():\n    return float('-inf')\n\ndef inf():\n    return float('inf')\n\ndef solve(p):\n    (minX, maxX) = (defaultdict(inf), defaultdict(neginf))\n    (minY, maxY) = (defaultdict(inf), defaultdict(neginf))\n    for (x, y) in p:\n        minX[y] = min(minX[y], x)\n        maxX[y] = max(maxX[y], x)\n        minY[x] = min(minY[x], y)\n        maxY[x] = max(maxY[x], y)\n    X = list(minY.keys())\n    Y = list(minX.keys())\n    X.sort()\n    Y.sort()\n    area = inf()\n    (pref, suff) = ([], [])\n    (mn, mx) = (inf(), neginf())\n    for x in X:\n        (mn, mx) = (min(mn, minY[x]), max(mx, maxY[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (inf(), neginf())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minY[x]), max(mx, maxY[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (inf(), neginf())\n    for y in Y:\n        (mn, mx) = (min(mn, minX[y]), max(mx, maxX[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (inf(), neginf())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minX[y]), max(mx, maxX[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    arr = []\n    for i in range(N):\n        List = list(map(int, input().split()))\n        arr.append(List)\n    val = solve(arr)\n    print(val)", "import math\nMAX = 0\nMIN = 1\n\ndef task():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        (a, b) = map(int, input().split())\n        points.append([a, b])\n    if n <= 2:\n        return 0\n    points.sort(key=lambda x: x[0])\n    mx = -1\n    mn = math.inf\n    leftRect = list()\n    for p in points:\n        mx = max(mx, p[1])\n        mn = min(mn, p[1])\n        leftRect.append((mx, mn))\n    mx = -1\n    mn = math.inf\n    minArea = math.inf\n    for i in range(n - 1, 0, -1):\n        p = points[i]\n        mx = max(mx, p[1])\n        mn = min(mn, p[1])\n        areaRight = (points[-1][0] - p[0]) * (mx - mn)\n        areaLeft = (points[i - 1][0] - points[0][0]) * (leftRect[i - 1][MAX] - leftRect[i - 1][MIN])\n        minArea = min(minArea, areaLeft + areaRight)\n    points.sort(key=lambda x: x[1])\n    mx = -1\n    mn = math.inf\n    bottomRect = list()\n    for p in points:\n        mx = max(mx, p[0])\n        mn = min(mn, p[0])\n        bottomRect.append((mx, mn))\n    mx = -1\n    mn = math.inf\n    for i in range(n - 1, 0, -1):\n        p = points[i]\n        mx = max(mx, p[0])\n        mn = min(mn, p[0])\n        areaTop = (points[-1][1] - p[1]) * (mx - mn)\n        areaBottom = (points[i - 1][1] - points[0][1]) * (bottomRect[i - 1][MAX] - bottomRect[i - 1][MIN])\n        minArea = min(minArea, areaBottom + areaTop)\n    return minArea\nfor _ in range(int(input())):\n    print(task())", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[-1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (minn, maxx) = (INF(), NINF())\n    for x in X:\n        (minn, maxx) = (min(minn, min_Y[x]), max(maxx, max_Y[x]))\n        pref.append((x - X[0]) * (maxx - minn))\n    (minn, maxx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (minn, maxx) = (min(minn, min_Y[x]), max(maxx, max_Y[x]))\n        suff.append((X[-1] - x) * (maxx - minn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (minn, maxx) = (INF(), NINF())\n    for y in Y:\n        (minn, maxx) = (min(minn, min_X[y]), max(maxx, max_X[y]))\n        pref.append((y - Y[0]) * (maxx - minn))\n    (minn, maxx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (minn, maxx) = (min(minn, min_X[y]), max(maxx, max_X[y]))\n        suff.append((Y[-1] - y) * (maxx - minn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    print(area)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (minn, maxx) = (INF(), NINF())\n    for x in X:\n        (minn, maxx) = (min(minn, min_Y[x]), max(maxx, max_Y[x]))\n        pref.append((x - X[0]) * (maxx - minn))\n    (minn, maxx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (minn, maxx) = (min(minn, min_Y[x]), max(maxx, max_Y[x]))\n        suff.append((X[-1] - x) * (maxx - minn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (minn, maxx) = (INF(), NINF())\n    for y in Y:\n        (minn, maxx) = (min(minn, min_X[y]), max(maxx, max_X[y]))\n        pref.append((y - Y[0]) * (maxx - minn))\n    (minn, maxx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (minn, maxx) = (min(minn, min_X[y]), max(maxx, max_X[y]))\n        suff.append((Y[-1] - y) * (maxx - minn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    print(area)", "def func(arr):\n    n = len(arr)\n    if n == 1:\n        return 0\n    (L1, R1, L2, R2) = ([2000000000] * (n + 1), [2000000000] * (n + 1), [-2000000000] * (n + 1), [-2000000000] * (n + 1))\n    res = 2000000000000000000\n    arr.sort()\n    for i in range(0, n):\n        L1[i] = arr[i][1]\n        L2[i] = arr[i][1]\n        if i:\n            L1[i] = min(L1[i - 1], L1[i])\n            L2[i] = max(L2[i - 1], L2[i])\n    for i in range(n - 1, -1, -1):\n        R1[i] = arr[i][1]\n        R2[i] = arr[i][1]\n        R1[i] = min(R1[i + 1], R1[i])\n        R2[i] = max(R2[i + 1], R2[i])\n    for i in range(0, n - 1):\n        res = min(res, (L2[i] - L1[i]) * (arr[i][0] - arr[0][0]) + (R2[i + 1] - R1[i + 1]) * (arr[n - 1][0] - arr[i + 1][0]))\n    return res\ntc = int(input())\nfor i in range(tc):\n    n = int(input())\n    arr1 = [[0 for i in range(2)] for j in range(n)]\n    arr2 = [[0 for i in range(2)] for j in range(n)]\n    for i in range(0, n):\n        (arr1[i][0], arr1[i][1]) = list(map(int, input().split()))\n        arr2[i][0] = arr1[i][1]\n        arr2[i][1] = arr1[i][0]\n    res1 = func(arr1)\n    res2 = func(arr2)\n    print(min(res1, res2))", "def getmm(points, c):\n    ans = [(points[0][c], points[0][c])]\n    ansr = [(points[-1][c], points[-1][c])]\n    for p in points[1:]:\n        ans.append((min(p[c], ans[-1][0]), max(p[c], ans[-1][1])))\n    for p in points[-2::-1]:\n        ansr.append((min(p[c], ansr[-1][0]), max(p[c], ansr[-1][1])))\n    return (ans, ansr[::-1])\nte = int(input())\nwhile te != 0:\n    te -= 1\n    points = []\n    n = int(input())\n    for i in range(n):\n        points.append(list(map(int, input().split())))\n    p_x = sorted(points, key=lambda x: x[0])\n    p_y = sorted(points, key=lambda x: x[1])\n    (mmx, mmx_r) = getmm(p_y, 0)\n    (mmy, mmy_r) = getmm(p_x, 1)\n    ans = float('inf')\n    (l, r) = (p_x[0][0], p_x[-1][0])\n    for i in range(1, n):\n        r1 = (p_x[i - 1][0] - l) * (mmy[i - 1][1] - mmy[i - 1][0])\n        r2 = (r - p_x[i][0]) * (mmy_r[i][1] - mmy_r[i][0])\n        ans = min(r1 + r2, ans)\n    (b, t) = (p_y[0][1], p_y[-1][1])\n    for i in range(1, n):\n        r1 = (p_y[i - 1][1] - b) * (mmx[i - 1][1] - mmx[i - 1][0])\n        r2 = (t - p_y[i][1]) * (mmx_r[i][1] - mmx_r[i][0])\n        ans = min(r1 + r2, ans)\n    print(0 if ans == float('inf') else ans)", "import sys\nimport math\nfrom collections import *\nfrom queue import *\nfrom bisect import *\nMOD = int(1000000000.0 + 7)\ninf = float('inf')\nninf = float('-inf')\ninput = sys.stdin.readline\n\ndef ii():\n    return list(map(int, input().strip().split()))\n\ndef infInitialise():\n    return defaultdict(lambda : inf)\n\ndef negInitialise():\n    return defaultdict(lambda : ninf)\n\ndef helper(res):\n    (minm_X, maxm_X, minm_Y, maxm_Y) = (infInitialise(), negInitialise(), infInitialise(), negInitialise())\n    for (x, y) in res:\n        minm_X[y] = min(minm_X[y], x)\n        maxm_X[y] = max(maxm_X[y], x)\n        ml = min(minm_X[y], maxm_X[y])\n        minm_Y[x] = min(minm_Y[x], y)\n        maxm_Y[x] = max(maxm_Y[x], y)\n    (X, Y, combinedArea) = ([], [], inf)\n    for k in minm_Y.keys():\n        X.append(k)\n    for k in minm_X.keys():\n        Y.append(k)\n    (mn, mx, preArr, sufArr, fl) = (inf, ninf, [], [], 0)\n    X.sort()\n    Y.sort()\n    for x in X:\n        if minm_Y[x] <= mn:\n            mn = minm_Y[x]\n        if mx < maxm_Y[x]:\n            mx = max(mx, maxm_Y[x])\n        preArr.append((x - X[0]) * (mx - mn))\n    (mn, mx, fl, X_axis) = (inf, -inf, 0, X[-1::-1])\n    for x in X_axis:\n        if minm_Y[x] <= mn:\n            mn = minm_Y[x]\n        if mx < maxm_Y[x]:\n            mx = max(mx, maxm_Y[x])\n        sufArr.append((X[0 - 1] - x) * (mx - mn))\n    temp = []\n    for k in range(len(sufArr) - 1, -1, -1):\n        temp.append(sufArr[k])\n    temp.append(0)\n    (sufArr, mn, mx, fl) = (temp, inf, ninf, 0)\n    for i in range(len(X)):\n        suk = preArr[i - 1 + 1] + sufArr[i + 1]\n        combinedArea = min(combinedArea, suk)\n    (prefArr, sufArr, fl) = ([], [], 0)\n    for y in Y:\n        cal1 = y - Y[0]\n        (mn, mx) = (min(mn, minm_X[y]), max(mx, maxm_X[y]))\n        cal2 = mx - mn\n        prefArr.append(cal1 * cal2)\n    (mn, mx, fl, Y_axis) = (inf, ninf, 0, Y[-1::-1])\n    for y in Y_axis:\n        cal1 = Y[-1] - y\n        (mn, mx) = (min(mn, minm_X[y]), max(mx, maxm_X[y]))\n        cal2 = mx - mn\n        sufArr.append(cal1 * cal2)\n    temp = []\n    for k in range(len(sufArr) - 1, -1, -1):\n        temp.append(sufArr[k])\n    temp.append(0)\n    sufArr = temp\n    nY = len(Y)\n    for i in range(nY):\n        suk = prefArr[i] + sufArr[i + 1]\n        combinedArea = min(combinedArea, suk)\n    return combinedArea\nfor _ in range(int(input())):\n    res = []\n    (n,) = ii()\n    for i in range(n):\n        arr = ii()\n        res.append(arr)\n    ans = helper(res)\n    print(ans)", "import sys\nimport time\n\ndef timebata():\n    return time.perf_counter()\n\ndef mini(x, y):\n    if x < y:\n        return x\n    else:\n        return y\n\ndef maxa(x, y):\n    if x > y:\n        return x\n    else:\n        return y\n\ndef miaaaji(arr, n):\n    arr = [-1 for i in range(n)]\n    return arr\nfor _ in range(int(input())):\n    points = []\n    xmin = sys.maxsize - 2\n    xmax = 0\n    ymin = sys.maxsize - 2\n    ymax = 0\n    n = int(input())\n    for ii in range(n):\n        (x, y) = map(int, input().split())\n        points.append((x, y))\n        if x > xmax:\n            xmax = x\n        xmin = mini(x, xmin)\n        ymax = maxa(y, ymax)\n        if y > ymin:\n            a11 = timebata()\n            ymin = y\n    if n == 1:\n        t11 = timebata()\n        print(0)\n    else:\n        t22 = timebata()\n        points = sorted(points, key=lambda x: (x[0], x[1]))\n        t33 = timebata()\n        lydpmin = []\n        for i in range(n):\n            lydpmin.append(-1)\n        lydpmax = []\n        for i in range(n):\n            lydpmax.append(-1)\n        lulu8 = points[0][1]\n        lydpmin[0] = lulu8\n        lydpmax[0] = lulu8\n        for i in range(1, n):\n            at1 = max(points[i][1], lydpmax[i - 1])\n            lydpmax[i] = at1\n            at2 = min(points[i][1], lydpmin[i - 1])\n            lydpmin[i] = at2\n        rampam = -1\n        e1 = timebata()\n        rydpmin = []\n        for i in range(n):\n            rydpmin.append(-1)\n        e2 = timebata()\n        rydpmax = []\n        for i in range(n):\n            rydpmax.append(-1)\n        lulu1 = points[-1][1]\n        rydpmin[-1] = lulu1\n        rydpmax[-1] = lulu1\n        for i in range(n - 2, -1, -1):\n            ar5 = max(points[i][1], rydpmax[i + 1])\n            rydpmax[i] = ar5\n            ar6 = min(points[i][1], rydpmin[i + 1])\n            rydpmin[i] = ar6\n        lxdpmin = []\n        for i in range(n):\n            lxdpmin.append(-1)\n        lxdpmax = []\n        for i in range(n):\n            lxdpmax.append(-1)\n        lulu = points[0][0]\n        lxdpmin[0] = lulu\n        lxdpmax[0] = lulu\n        for i in range(1, n):\n            bb = max(points[i][0], lxdpmax[i - 1])\n            lxdpmax[i] = bb\n            bb1 = min(points[i][0], lxdpmin[i - 1])\n            lxdpmin[i] = bb1\n        rxdpmin = []\n        for i in range(n):\n            rxdpmin.append(-1)\n        rxdpmax = []\n        for i in range(n):\n            rxdpmax.append(-1)\n        lulu2 = points[-1][0]\n        rxdpmin[-1] = lulu2\n        rxdpmax[-1] = lulu2\n        for i in range(n - 2, -1, -1):\n            e3 = timebata()\n            rxdpmax[i] = max(points[i][0], rxdpmax[i + 1])\n            e4 = timebata()\n            ll1 = points[i][0]\n            rxdpmin[i] = min(ll1, rxdpmin[i + 1])\n        f1 = lxdpmax[0] - lxdpmin[0]\n        f2 = lydpmax[0] - lydpmin[0]\n        ar1 = f1 * f2\n        f3 = rxdpmax[1] - rxdpmin[1]\n        f4 = rydpmax[1] - rydpmin[1]\n        ar2 = f3 * f4\n        fuddu = timebata()\n        arsum = ar1 + ar2\n        for i in range(1, n):\n            tic = timebata()\n            f11 = lxdpmax[i - 1] - lxdpmin[i - 1]\n            f22 = lydpmax[i - 1] - lydpmin[i - 1]\n            ar1 = f11 * f22\n            f33 = rxdpmax[i] - rxdpmin[i]\n            f44 = rydpmax[i] - rydpmin[i]\n            ar2 = f33 * f44\n            temparsum = ar1 + ar2\n            if temparsum < arsum:\n                arsum = temparsum\n        chch = 0\n        if arsum == chch:\n            print(0)\n        else:\n            points = sorted(points, key=lambda x: (x[1], x[0]))\n            z1 = timebata()\n            lydpmin = []\n            for i in range(n):\n                lydpmin.append(-1)\n            lydpmax = []\n            for i in range(n):\n                lydpmax.append(-1)\n            lulu3 = points[0][1]\n            lydpmin[0] = lulu3\n            lydpmax[0] = lulu3\n            for i in range(1, n):\n                tac1 = timebata()\n                lydpmax[i] = max(points[i][1], lydpmax[i - 1])\n                tac2 = timebata()\n                lydpmin[i] = min(points[i][1], lydpmin[i - 1])\n            rydpmin = []\n            for i in range(n):\n                rydpmin.append(-1)\n            rydpmax = []\n            for i in range(n):\n                rydpmax.append(-1)\n            lulu5 = points[-1][1]\n            rydpmin[-1] = lulu5\n            rydpmax[-1] = lulu5\n            for i in range(n - 2, -1, -1):\n                an3 = max(points[i][1], rydpmax[i + 1])\n                rydpmax[i] = an3\n                an4 = min(points[i][1], rydpmin[i + 1])\n                rydpmin[i] = an4\n            lxdpmin = [-1]\n            for i in range(n):\n                lxdpmin.append(-1)\n            lxdpmax = []\n            for i in range(n):\n                lxdpmax.append(-1)\n            lulu6 = points[0][0]\n            lxdpmin[0] = lulu6\n            lxdpmax[0] = lulu6\n            for i in range(1, n):\n                an1 = max(points[i][0], lxdpmax[i - 1])\n                lxdpmax[i] = an1\n                an2 = min(points[i][0], lxdpmin[i - 1])\n                lxdpmin[i] = an2\n            rxdpmin = []\n            for i in range(n):\n                rxdpmin.append(-1)\n            rxdpmax = []\n            for i in range(n):\n                rxdpmax.append(-1)\n            lulu4 = points[-1][0]\n            rxdpmin[-1] = lulu4\n            rxdpmax[-1] = lulu4\n            ppp = n - 2\n            ccc = -1\n            for i in range(ppp, -1, ccc):\n                toc = timebata()\n                pd1 = points[i][0]\n                rxdpmax[i] = max(pd1, rxdpmax[i + 1])\n                pd2 = min(points[i][0], rxdpmin[i + 1])\n                rxdpmin[i] = pd2\n            tic1 = timebata()\n            nx1 = lxdpmax[0] - lxdpmin[0]\n            toc2 = timebata()\n            nx2 = lydpmax[0] - lydpmin[0]\n            ar1 = nx1 * nx2\n            nx3 = rxdpmax[1] - rxdpmin[1]\n            nx4 = rydpmax[1] - rydpmin[1]\n            ar2 = nx3 * nx4\n            temparsum = ar1 + ar2\n            if temparsum < arsum:\n                pcr = timebata()\n                arsum = temparsum\n            for i in range(1, n):\n                pcr1 = timebata()\n                mkc1 = lxdpmax[i - 1] - lxdpmin[i - 1]\n                mkc2 = lydpmax[i - 1] - lydpmin[i - 1]\n                ar1 = mkc1 * mkc2\n                mkc3 = rxdpmax[i] - rxdpmin[i]\n                mkc4 = rydpmax[i] - rydpmin[i]\n                ar2 = mkc3 * mkc4\n                temparsum = ar1 + ar2\n                if temparsum < arsum:\n                    arsum = temparsum\n            print(arsum)", "import sys\nimport math\nfrom collections import *\nfrom queue import *\nfrom bisect import *\nMOD = int(1000000000.0 + 7)\ninf = float('inf')\nninf = float('-inf')\ninput = sys.stdin.readline\n\ndef ii():\n    return list(map(int, input().strip().split()))\n\ndef infInitialise():\n    return defaultdict(lambda : inf)\n\ndef negInitialise():\n    return defaultdict(lambda : -inf)\n\ndef solve(p):\n    (minm_X, maxm_X, minm_Y, maxm_Y) = (infInitialise(), negInitialise(), infInitialise(), negInitialise())\n    for (x, y) in p:\n        minm_X[y] = min(minm_X[y], x)\n        maxm_X[y] = max(maxm_X[y], x)\n        ml = min(minm_X[y], maxm_X[y])\n        minm_Y[x] = min(minm_Y[x], y)\n        maxm_Y[x] = max(maxm_Y[x], y)\n    (X, Y, combinedArea) = ([], [], inf)\n    for k in minm_Y.keys():\n        X.append(k)\n    for k in minm_X.keys():\n        Y.append(k)\n    X.sort()\n    Y.sort()\n    (mn, mx, preArr, sufArr, fl) = (inf, -inf, [], [], 0)\n    for x in X:\n        if minm_Y[x] <= mn:\n            mn = minm_Y[x]\n        if mx < maxm_Y[x]:\n            mx = max(mx, maxm_Y[x])\n        preArr.append((x - X[0]) * (mx - mn))\n    (mn, mx, fl, X_axis) = (inf, -inf, 0, X[-1::-1])\n    for x in X_axis:\n        if minm_Y[x] <= mn:\n            mn = minm_Y[x]\n        if mx < maxm_Y[x]:\n            mx = max(mx, maxm_Y[x])\n        sufArr.append((X[0 - 1] - x) * (mx - mn))\n    temp = []\n    for k in range(len(sufArr) - 1, -1, -1):\n        temp.append(sufArr[k])\n    temp.append(0)\n    (sufArr, mn, mx, fl) = (temp, inf, -inf, 0)\n    for i in range(len(X)):\n        suk = preArr[i - 1 + 1] + sufArr[i + 1]\n        combinedArea = min(combinedArea, suk)\n    (prefArr, sufArr, fl) = ([], [], 0)\n    for y in Y:\n        cal1 = y - Y[0]\n        (mn, mx) = (min(mn, minm_X[y]), max(mx, maxm_X[y]))\n        cal2 = mx - mn\n        prefArr.append(cal1 * cal2)\n    (mn, mx, fl, Y_axis) = (inf, -inf, 0, Y[-1::-1])\n    for y in Y_axis:\n        cal1 = Y[-1] - y\n        (mn, mx) = (min(mn, minm_X[y]), max(mx, maxm_X[y]))\n        cal2 = mx - mn\n        sufArr.append(cal1 * cal2)\n    temp = []\n    for k in range(len(sufArr) - 1, -1, -1):\n        temp.append(sufArr[k])\n    temp.append(0)\n    sufArr = temp\n    nY = len(Y)\n    for i in range(nY):\n        suk = prefArr[i] + sufArr[i + 1]\n        combinedArea = min(combinedArea, suk)\n    return combinedArea\nfor _ in range(int(input())):\n    res = []\n    (n,) = ii()\n    for i in range(n):\n        arr = ii()\n        res.append(arr)\n    ans = solve(res)\n    print(ans)", "import collections\nfrom collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    min_X = defaultdict(lambda : float('inf'))\n    max_X = defaultdict(lambda : float('-inf'))\n    min_Y = defaultdict(lambda : float('inf'))\n    max_Y = defaultdict(lambda : float('-inf'))\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    areax = float('inf')\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    local_y_max = float('-inf')\n    local_y_min = float('inf')\n    left_areas = []\n    for i in X:\n        local_y_max = max(max_Y[i], local_y_max)\n        local_y_min = min(min_Y[i], local_y_min)\n        area_left = (i - X[0]) * (local_y_max - local_y_min)\n        left_areas.append(area_left)\n    rev_X = X[-1::-1]\n    local_y_max = float('-inf')\n    local_y_min = float('inf')\n    right_areas = []\n    for i in rev_X:\n        local_y_max = max(max_Y[i], local_y_max)\n        local_y_min = min(min_Y[i], local_y_min)\n        area_right = (X[-1] - i) * (local_y_max - local_y_min)\n        right_areas.append(area_right)\n    right_areas = right_areas[-1::-1]\n    right_areas.append(0)\n    for i in range(len(X)):\n        areax = min(areax, left_areas[i] + right_areas[i + 1])\n    local_x_max = float('-inf')\n    local_x_min = float('inf')\n    bottom_areas = []\n    for i in Y:\n        local_x_max = max(max_X[i], local_x_max)\n        local_x_min = min(min_X[i], local_x_min)\n        area_bottom = (i - Y[0]) * (local_x_max - local_x_min)\n        bottom_areas.append(area_bottom)\n    rev_Y = Y[-1::-1]\n    local_x_max = float('-inf')\n    local_x_min = float('inf')\n    areay = float('inf')\n    up_areas = []\n    for i in rev_Y:\n        local_x_max = max(max_X[i], local_x_max)\n        local_x_min = min(min_X[i], local_x_min)\n        area_up = (Y[-1] - i) * (local_x_max - local_x_min)\n        up_areas.append(area_up)\n    up_areas = up_areas[-1::-1]\n    up_areas.append(0)\n    for i in range(len(Y)):\n        areay = min(areay, bottom_areas[i] + up_areas[i + 1])\n    if areax <= areay:\n        print(areax)\n    else:\n        print(areay)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (minn, maxx) = (INF(), NINF())\n    for x in X:\n        (minn, maxx) = (min(minn, min_Y[x]), max(maxx, max_Y[x]))\n        pref.append((x - X[0]) * (maxx - minn))\n    (minn, maxx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (minn, maxx) = (min(minn, min_Y[x]), max(maxx, max_Y[x]))\n        suff.append((X[-1] - x) * (maxx - minn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (minn, maxx) = (INF(), NINF())\n    for y in Y:\n        (minn, maxx) = (min(minn, min_X[y]), max(maxx, max_X[y]))\n        pref.append((y - Y[0]) * (maxx - minn))\n    (minn, maxx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (minn, maxx) = (min(minn, min_X[y]), max(maxx, max_X[y]))\n        suff.append((Y[-1] - y) * (maxx - minn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    print(area)", "from collections import defaultdict as dd\n\ndef horizontal(x_pair, N):\n    area = 10 ** 18\n    max_h = 0\n    min_h = 10 ** 18\n    h1 = [0] * N\n    for val in range(N):\n        max_h = max(max_h, x_pair[val][1])\n        min_h = min(min_h, x_pair[val][1])\n        h1[val] = max_h - min_h\n    max_h = 0\n    min_h = 10 ** 18\n    h2 = [0] * N\n    for val in range(N - 1, -1, -1):\n        max_h = max(max_h, x_pair[val][1])\n        min_h = min(min_h, x_pair[val][1])\n        h2[val] = max_h - min_h\n    for a in range(N - 1):\n        area = min(area, (x_pair[a][0] - x_pair[0][0]) * h1[a] + (x_pair[N - 1][0] - x_pair[a + 1][0]) * h2[a + 1])\n    return area\n\ndef vertical(y_pair, N, area):\n    max_w = 0\n    min_w = 10 ** 18\n    w1 = [0] * N\n    for val in range(N):\n        max_w = max(max_w, y_pair[val][1])\n        min_w = min(min_w, y_pair[val][1])\n        w1[val] = max_w - min_w\n    max_w = 0\n    min_w = 10 ** 18\n    w2 = [0] * N\n    for val in range(N - 1, -1, -1):\n        max_w = max(max_w, y_pair[val][1])\n        min_w = min(min_w, y_pair[val][1])\n        w2[val] = max_w - min_w\n    for a in range(N - 1):\n        area = min(area, (y_pair[a][0] - y_pair[0][0]) * w1[a] + (y_pair[N - 1][0] - y_pair[a + 1][0]) * w2[a + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    x_pair = []\n    y_pair = []\n    for _ in range(N):\n        (x, y) = map(int, input().split())\n        x_pair.append((x, y))\n        y_pair.append((y, x))\n    if N == 1:\n        print(0)\n        continue\n    x_pair = sorted(x_pair)\n    y_pair = sorted(y_pair)\n    area = horizontal(x_pair, N)\n    area = vertical(y_pair, N, area)\n    print(area)", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "def helper2(sorted_points):\n    consolidated_points = []\n    curr_x = sorted_points[0][0]\n    min_y = sorted_points[0][1]\n    max_y = min_y\n    for (x, y) in sorted_points:\n        if curr_x == x:\n            min_y = min(min_y, y)\n            max_y = max(max_y, y)\n        else:\n            consolidated_points.append((curr_x, min_y, max_y))\n            curr_x = x\n            min_y = y\n            max_y = y\n    consolidated_points.append((curr_x, min_y, max_y))\n    return consolidated_points\n\ndef get_rectangle_areas(consolidated_points, x_inc=False):\n    min_x = consolidated_points[0][0]\n    max_x = min_x\n    min_y = consolidated_points[0][1]\n    max_y = consolidated_points[0][2]\n    areas = [0]\n    for (x, y_lower, y_upper) in consolidated_points:\n        if x_inc:\n            max_x = x\n        else:\n            min_x = x\n        min_y = min(min_y, y_lower)\n        max_y = max(max_y, y_upper)\n        areas.append((max_x - min_x) * (max_y - min_y))\n    return areas\n\ndef helper(points):\n    points.sort()\n    consolidated_points = helper2(points)\n    min_area = None\n    areas_left_to_right = get_rectangle_areas(consolidated_points, x_inc=True)\n    areas_right_to_left = get_rectangle_areas(consolidated_points[::-1], x_inc=False)[::-1]\n    for (a1, a2) in zip(areas_left_to_right, areas_right_to_left):\n        area = a1 + a2\n        min_area = min(area, min_area) if min_area != None else area\n    return min_area\n\ndef solve(N):\n    x_points = []\n    y_points = []\n    for i in range(N):\n        (x, y) = map(int, input().split())\n        x_points.append((x, y))\n        y_points.append((y, x))\n    return min(helper(x_points), helper(y_points))\nT = int(input())\nfor i in range(T):\n    print(solve(int(input())))", "from collections import defaultdict\n\ndef infi():\n    return float('inf')\n\ndef ninfi():\n    return float('-inf')\n\ndef calc(p):\n    (minx, maxx) = (defaultdict(infi), defaultdict(ninfi))\n    (miny, maxy) = (defaultdict(infi), defaultdict(ninfi))\n    for (x, y) in p:\n        minx[y] = min(minx[y], x)\n        maxx[y] = max(maxx[y], x)\n        miny[x] = min(miny[x], y)\n        maxy[x] = max(maxy[x], y)\n    x = list(miny.keys())\n    y = list(minx.keys())\n    x.sort()\n    y.sort()\n    area = infi()\n    (pref, suff) = ([], [])\n    (mn, mx) = (infi(), ninfi())\n    for i in x:\n        (mn, mx) = (min(mn, miny[i]), max(mx, maxy[i]))\n        pref.append((i - x[0]) * (mx - mn))\n    (mn, mx) = (infi(), ninfi())\n    for i in x[-1::-1]:\n        (mn, mx) = (min(mn, miny[i]), max(mx, maxy[i]))\n        suff.append((x[-1] - i) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(x)):\n        area = min(area, pref[i] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (infi(), ninfi())\n    for j in y:\n        (mn, mx) = (min(mn, minx[j]), max(mx, maxx[j]))\n        pref.append((j - y[0]) * (mx - mn))\n    (mn, mx) = (infi(), ninfi())\n    for j in y[-1::-1]:\n        (mn, mx) = (min(mn, minx[j]), max(mx, maxx[j]))\n        suff.append((y[-1] - j) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    p = []\n    for j in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = calc(p)\n    print(ans)", "t = int(input())\nfrom collections import defaultdict\n\ndef ninf():\n    return float('-inf')\n\ndef inf():\n    return float('inf')\n\ndef answerfinder(coordinates):\n    (maxX, minX, maxY, minY) = (defaultdict(ninf), defaultdict(inf), defaultdict(ninf), defaultdict(inf))\n    for (x, y) in coordinates:\n        (minX[y], maxX[y], minY[x], maxY[x]) = (min(minX[y], x), max(maxX[y], x), min(minY[x], y), max(maxY[x], y))\n    X = list(minY.keys())\n    Y = list(minX.keys())\n    X.sort()\n    Y.sort()\n    prevarea = []\n    nextarea = []\n    area = inf()\n    (mnx, mxx) = (inf(), ninf())\n    for x in X:\n        (mnx, mxx) = (min(minY[x], mnx), max(maxY[x], mxx))\n        prevarea.append((x - X[0]) * (mxx - mnx))\n    (mnx, mxx) = (inf(), ninf())\n    for x in X[-1::-1]:\n        (mnx, mxx) = (min(minY[x], mnx), max(maxY[x], mxx))\n        nextarea.append((X[-1] - x) * (mxx - mnx))\n    nextarea = nextarea[-1::-1]\n    nextarea.append(0)\n    for i in range(len(X)):\n        area = min(area, prevarea[i] + nextarea[i + 1])\n    prevarea = []\n    nextarea = []\n    (mnx, mxx) = (inf(), ninf())\n    for y in Y:\n        (mnx, mxx) = (min(minX[y], mnx), max(maxX[y], mxx))\n        prevarea.append((y - Y[0]) * (mxx - mnx))\n    (mnx, mxx) = (inf(), ninf())\n    for y in Y[-1::-1]:\n        (mnx, mxx) = (min(minX[y], mnx), max(maxX[y], mxx))\n        nextarea.append((Y[-1] - y) * (mxx - mnx))\n    nextarea = nextarea[-1::-1]\n    nextarea.append(0)\n    for i in range(len(Y)):\n        area = min(area, prevarea[i] + nextarea[i + 1])\n    return area\nfor _ in range(t):\n    n = int(input())\n    coordinates = []\n    for _ in range(n):\n        (x, y) = map(int, input().split())\n        coordinates.append([x, y])\n    ans = answerfinder(coordinates)\n    print(ans)", "for i in range(int(input())):\n    n = int(input())\n    coordinates = []\n    for j in range(n):\n        temp = list(map(int, input().split()))\n        coordinates.append(temp)\n    coordinates.sort()\n    y = []\n    for j in range(n):\n        y.append(coordinates[j][1])\n    length = [[0, 0] for j in range(n)]\n    miny = 1000000000.0 + 1\n    maxy = -1\n    for j in range(n):\n        miny = min(miny, y[j])\n        maxy = max(maxy, y[j])\n        length[j][0] = maxy - miny\n    miny = 1000000000.0 + 1\n    maxy = -1\n    for j in range(n - 1, 0, -1):\n        miny = min(miny, y[j])\n        maxy = max(maxy, y[j])\n        length[j - 1][1] = maxy - miny\n    areamin = 1e+18 + 1\n    for j in range(1, n):\n        area = (coordinates[-1][0] - coordinates[j][0]) * length[j - 1][1] + (coordinates[j - 1][0] - coordinates[0][0]) * length[j - 1][0]\n        areamin = min(area, areamin)\n    for x in coordinates:\n        (x[0], x[1]) = (x[1], x[0])\n    coordinates.sort()\n    x = []\n    for j in range(n):\n        x.append(coordinates[j][1])\n    breadth = [[0, 0] for j in range(n)]\n    minx = 1000000000.0 + 1\n    maxx = -1\n    for j in range(n):\n        minx = min(minx, x[j])\n        maxx = max(maxx, x[j])\n        breadth[j][0] = maxx - minx\n    minx = 1000000000.0 + 1\n    maxx = -1\n    for j in range(n - 1, 0, -1):\n        minx = min(minx, x[j])\n        maxx = max(maxx, x[j])\n        breadth[j - 1][1] = maxx - minx\n    for j in range(1, n):\n        area = (coordinates[-1][0] - coordinates[j][0]) * breadth[j - 1][1] + (coordinates[j - 1][0] - coordinates[0][0]) * breadth[j - 1][0]\n        areamin = min(area, areamin)\n    if areamin >= 1e+18 + 1:\n        print(0)\n    else:\n        print(areamin)", "from collections import defaultdict\nimport math\n\ndef minimumDualArea(listOfList):\n    minx = defaultdict(infinity)\n    maxx = defaultdict(negativeinfinity)\n    maxy = defaultdict(negativeinfinity)\n    miny = defaultdict(infinity)\n    for (y, x) in listOfList:\n        minx[x] = min(minx[x], y)\n        maxx[x] = max(maxx[x], y)\n        miny[y] = min(miny[y], x)\n        maxy[y] = max(maxy[y], x)\n    xcordi = list(miny.keys())\n    ycordi = list(minx.keys())\n    ycordi.sort()\n    xcordi.sort()\n    initialArea = infinity()\n    preffix = []\n    suffix = []\n    minc = infinity()\n    maxc = negativeinfinity()\n    for y in ycordi:\n        minc = min(minc, minx[y])\n        maxc = max(maxc, maxx[y])\n        preffix.append((y - ycordi[0]) * (maxc - minc))\n    minc = infinity()\n    maxc = negativeinfinity()\n    for y in ycordi[len(ycordi)::-1]:\n        minc = min(minc, minx[y])\n        maxc = max(maxc, maxx[y])\n        suffix.append((ycordi[-1] - y) * (maxc - minc))\n    suffix = suffix[len(suffix)::-1]\n    suffix.append(0)\n    i = 0\n    while i < len(ycordi):\n        initialArea = min(initialArea, preffix[i] + suffix[i + 1])\n        i += 1\n    suffix = []\n    preffix = []\n    maxc = negativeinfinity()\n    minc = infinity()\n    for x in xcordi:\n        minc = min(minc, miny[x])\n        maxc = max(maxc, maxy[x])\n        preffix.append((x - xcordi[0]) * (maxc - minc))\n    minc = infinity()\n    maxc = negativeinfinity()\n    for x in xcordi[len(xcordi)::-1]:\n        minc = min(minc, miny[x])\n        maxc = max(maxc, maxy[x])\n        suffix.append((xcordi[0 - 1] - x) * (maxc - minc))\n    suffix = suffix[len(suffix)::-1]\n    suffix.append(0)\n    i = 0\n    while i < len(xcordi):\n        initialArea = min(initialArea, preffix[i - 1 + 1] + suffix[i + 1])\n        i += 1\n    return initialArea\n\ndef infinity():\n    return float('inf')\n\ndef negativeinfinity():\n    return float('-inf')\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    coordinates = []\n    for j in range(N):\n        xy = list(map(int, input().split()))\n        coordinates.append(xy)\n    result = minimumDualArea(coordinates)\n    print(result)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor c in range(t):\n    n = int(input())\n    r = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        r.append(li)\n    ans = solve(r)\n    print(ans)", "from bisect import bisect_left\n\ndef find_min_area(points):\n    points.sort(key=lambda k: k[0])\n    curr = 0\n    min_area = 99999999999999999999\n    y_min = 999999999999999999999\n    y_max = 0\n    all_y = [point[1] for point in points]\n    all_y.sort()\n    end = len(points) - 1\n    if len(points) == 1:\n        return 0\n    while curr < len(points) - 1:\n        y_max = max(y_max, points[curr][1])\n        y_min = min(y_min, points[curr][1])\n        idx = bisect_left(all_y, points[curr][1])\n        del all_y[idx]\n        curr_area = (points[curr][0] - points[0][0]) * (y_max - y_min) + (points[end][0] - points[curr + 1][0]) * (all_y[-1] - all_y[0])\n        min_area = min(min_area, curr_area)\n        curr += 1\n    return min_area\ntt = int(input())\nfor jj in range(tt):\n    n = int(input())\n    points = [0] * n\n    for i in range(n):\n        points[i] = list(map(int, input().split()))\n    area_by_x = find_min_area(points)\n    y_points = [[point[1], point[0]] for point in points]\n    area_by_y = find_min_area(y_points)\n    print(min(area_by_x, area_by_y))", "from collections import defaultdict\n\ndef solve(arr):\n    (min_X, max_X) = (defaultdict(a), defaultdict(b))\n    (min_Y, max_Y) = (defaultdict(a), defaultdict(b))\n    for (x, y) in arr:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    for i in range(5):\n        sar = 'varu'\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = float('inf')\n    (pref, suff) = ([], [])\n    (x1, x2) = (float('inf'), float('-inf'))\n    for x in X:\n        (x1, x2) = (min(x1, min_Y[x]), max(x2, max_Y[x]))\n        pref.append((x - X[0]) * (x2 - x1))\n    (x1, x2) = (float('inf'), float('-inf'))\n    for x in X[-1::-1]:\n        (x1, x2) = (min(x1, min_Y[x]), max(x2, max_Y[x]))\n        suff.append((X[-1] - x) * (x2 - x1))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (x1, x2) = (float('inf'), float('-inf'))\n    for y in Y:\n        (x1, x2) = (min(x1, min_X[y]), max(x2, max_X[y]))\n        pref.append((y - Y[0]) * (x2 - x1))\n    (x1, x2) = (float('inf'), float('-inf'))\n    for y in Y[-1::-1]:\n        (x1, x2) = (min(x1, min_X[y]), max(x2, max_X[y]))\n        suff.append((Y[-1] - y) * (x2 - x1))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\n\ndef a():\n    return float('inf')\n\ndef b():\n    return float('-inf')\ntt = int(input())\nfor _ in range(tt):\n    N = int(input())\n    arr = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        arr.append(li)\n    ans = solve(arr)\n    print(ans)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (min__x, max__x) = (defaultdict(INF), defaultdict(NINF))\n    (min__y, max__y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        min__x[y] = min(min__x[y], x)\n        max__x[y] = max(max__x[y], x)\n        min__y[x] = min(min__y[x], y)\n        max__y[x] = max(max__y[x], y)\n    X = list(min__y.keys())\n    Y = list(min__x.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min__y[x]), max(mx, max__y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min__y[x]), max(mx, max__y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min__x[y]), max(mx, max__x[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min__x[y]), max(mx, max__x[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nzz = int(input())\nfor _ in range(zz):\n    N = int(input())\n    p = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        p.append(li)\n    answer = solve(p)\n    print(answer)", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef sum(p):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nfor _ in range(int(input())):\n    n = int(input())\n    b = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        b.append(l)\n    a = sum(b)\n    print(a)", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "for i in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(n):\n        p = list(map(int, input().split()))\n        l.append(p)\n    l.sort()\n    y = []\n    for i in range(n):\n        y.append(l[i][1])\n    mx = -1\n    mn = 1000000000.0 + 1\n    ht = [[0, 0] for i in range(n)]\n    for i in range(n):\n        mx = max(mx, y[i])\n        mn = min(mn, y[i])\n        ht[i][0] = mx - mn\n    mx = -1\n    mn = 1000000000.0 + 1\n    for i in range(n - 1, 0, -1):\n        mx = max(mx, y[i])\n        mn = min(mn, y[i])\n        ht[i - 1][1] = mx - mn\n    a1 = 1e+19\n    a2 = 1e+19\n    for i in range(1, n):\n        a = (l[i - 1][0] - l[0][0]) * ht[i - 1][0] + (l[-1][0] - l[i][0]) * ht[i - 1][1]\n        a1 = min(a1, a)\n    for x in l:\n        (x[0], x[1]) = (x[1], x[0])\n    l.sort()\n    x = []\n    for i in range(n):\n        x.append(l[i][1])\n    w = [[0, 0] for i in range(n)]\n    mx = -1\n    mn = 1000000000.0 + 1\n    for i in range(n):\n        mx = max(mx, x[i])\n        mn = min(mn, x[i])\n        w[i][0] = mx - mn\n    mx = -1\n    mn = 1000000000.0 + 1\n    for i in range(n - 1, 0, -1):\n        mx = max(mx, x[i])\n        mn = min(mn, x[i])\n        w[i - 1][1] = mx - mn\n    for i in range(1, n):\n        a = (l[i - 1][0] - l[0][0]) * w[i - 1][0] + (l[-1][0] - l[i][0]) * w[i - 1][1]\n        a2 = min(a2, a)\n    ans = min(a1, a2)\n    if ans >= 1e+18 + 1:\n        print(0)\n    else:\n        print(ans)", "try:\n    import sys\n    from sys import stdin\n\n    def indx(li, val):\n        (f, l, ind) = (0, len(li), -1)\n        while f <= l and ind == -1:\n            mid = (f + l) // 2\n            if li[mid] == val:\n                ind = mid\n            elif val < li[mid]:\n                l = mid - 1\n            else:\n                f = mid + 1\n        return ind\n\n    def solveA(x, Y, ar, n):\n        (max_h, min_h) = (0, sys.maxsize)\n        for i in range(n - 1):\n            (max_h, min_h) = (max(x[i][1], max_h), min(x[i][1], min_h))\n            d1 = max_h - min_h\n            ind = indx(Y, x[i][1])\n            del Y[ind]\n            d2 = Y[-1] - Y[0]\n            new_ar = d1 * (x[i][0] - x[0][0]) + d2 * (x[n - 1][0] - x[i + 1][0])\n            ar = min(ar, new_ar)\n        return ar\n\n    def solveB(y, X, ar, n):\n        (max_wd, min_wd) = (0, sys.maxsize)\n        for i in range(n - 1):\n            (max_wd, min_wd) = (max(y[i][1], max_wd), min(y[i][1], min_wd))\n            d3 = max_wd - min_wd\n            ind = indx(X, y[i][1])\n            del X[ind]\n            d4 = X[-1] - X[0]\n            new_ar = d3 * (y[i][0] - y[0][0]) + d4 * (y[n - 1][0] - y[i + 1][0])\n            ar = min(ar, new_ar)\n        return ar\n\n    def solve(n):\n        (x, y, X, Y, ar) = ([], [], [], [], sys.maxsize)\n        for i in range(n):\n            (a, b) = map(int, sys.stdin.readline().split())\n            (x.append([a, b]), y.append([b, a]), X.append(a), Y.append(b))\n        x.sort()\n        y.sort()\n        X.sort()\n        Y.sort()\n        re = solveA(x, Y, ar, n)\n        result = solveB(y, X, re, n)\n        if n == 1:\n            print(0)\n        else:\n            print(result)\n\n    def main():\n        for _ in range(int(sys.stdin.readline())):\n            n = int(sys.stdin.readline())\n            solve(n)\n    main()\nexcept Exception:\n    pass", "try:\n    import sys\n    from sys import stdin\n\n    def indx(li, val):\n        (f, l, ind) = (0, len(li), -1)\n        while f <= l and ind == -1:\n            mid = (f + l) // 2\n            if li[mid] == val:\n                ind = mid\n            elif val < li[mid]:\n                l = mid - 1\n            else:\n                f = mid + 1\n        return ind\n\n    def solveA(x, Y, ar, n):\n        (max_h, min_h) = (0, sys.maxsize)\n        for i in range(n - 1):\n            (max_h, min_h) = (max(x[i][1], max_h), min(x[i][1], min_h))\n            d1 = max_h - min_h\n            ind = indx(Y, x[i][1])\n            del Y[ind]\n            d2 = Y[-1] - Y[0]\n            new_ar = d1 * (x[i][0] - x[0][0]) + d2 * (x[n - 1][0] - x[i + 1][0])\n            ar = min(ar, new_ar)\n        return ar\n\n    def solveB(y, X, ar, n):\n        (max_wd, min_wd) = (0, sys.maxsize)\n        for i in range(n - 1):\n            (max_wd, min_wd) = (max(y[i][1], max_wd), min(y[i][1], min_wd))\n            d3 = max_wd - min_wd\n            ind = indx(X, y[i][1])\n            del X[ind]\n            d4 = X[-1] - X[0]\n            new_ar = d3 * (y[i][0] - y[0][0]) + d4 * (y[n - 1][0] - y[i + 1][0])\n            ar = min(ar, new_ar)\n        return ar\n\n    def solve(n):\n        (x, y, X, Y, ar) = ([], [], [], [], sys.maxsize)\n        for i in range(n):\n            (a, b) = map(int, sys.stdin.readline().split())\n            (x.append([a, b]), y.append([b, a]), X.append(a), Y.append(b))\n        x.sort()\n        y.sort()\n        X.sort()\n        Y.sort()\n        re = solveA(x, Y, ar, n)\n        result = solveB(y, X, re, n)\n        if n == 1:\n            print(0)\n        else:\n            print(result)\n\n    def main():\n        for _ in range(int(sys.stdin.readline())):\n            n = int(sys.stdin.readline())\n            solve(n)\n    main()\nexcept Exception:\n    pass", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[-1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef minimumDualarea(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pefix, suffix) = ([], [])\n    (minimum, maximum) = (INF(), NINF())\n    for x in X:\n        (minimum, maximum) = (min(minimum, min_Y[x]), max(maximum, max_Y[x]))\n        pefix.append((x - X[0]) * (maximum - minimum))\n    (minimum, maximum) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (minimum, maximum) = (min(minimum, min_Y[x]), max(maximum, max_Y[x]))\n        suffix.append((X[-1] - x) * (maximum - minimum))\n    suffix = suffix[-1::-1]\n    suffix.append(0)\n    for i in range(len(X)):\n        area = min(area, pefix[i] + suffix[i + 1])\n    (pefix, suffix) = ([], [])\n    (minimum, maximum) = (INF(), NINF())\n    for y in Y:\n        (minimum, maximum) = (min(minimum, min_X[y]), max(maximum, max_X[y]))\n        pefix.append((y - Y[0]) * (maximum - minimum))\n    (minimum, maximum) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (minimum, maximum) = (min(minimum, min_X[y]), max(maximum, max_X[y]))\n        suffix.append((Y[-1] - y) * (maximum - minimum))\n    suffix = suffix[-1::-1]\n    suffix.append(0)\n    for i in range(len(Y)):\n        area = min(area, pefix[i] + suffix[i + 1])\n    return area\ntestcases = int(input())\nfor iter in range(testcases):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = minimumDualarea(P)\n    print(ans)", "INF = int(1e+20)\n\ndef sweep_area(indices, X, Y):\n    minX = [INF] * N\n    maxX = [-1] * N\n    height = [0] * N\n    last_minX = INF\n    last_maxX = -1\n    y = Y[indices[0]]\n    for i in indices:\n        last_minX = min(last_minX, X[i])\n        last_maxX = max(last_maxX, X[i])\n        minX[i] = last_minX\n        maxX[i] = last_maxX\n        height[i] = abs(Y[i] - y)\n    return (minX, maxX, height)\n\ndef merge(curX, maxXtop, minXtop, maxXbot, minXbot, wBot, wTop, prevWbot):\n    maxX = max(curX)\n    minX = min(curX)\n    curMaxXtop = max(maxX, maxXtop)\n    curMinXtop = min(minX, minXtop)\n    curMinXbot = min(minX, minXbot)\n    area = (curMaxXtop - curMinXtop) * wTop + (maxXbot - minXbot) * prevWbot\n    last_x = curX[0]\n    for x in curX:\n        if minXtop < x:\n            continue\n        xBot = max(x, maxXbot)\n        xTop = min(last_x, minXtop)\n        area1 = (curMaxXtop - xTop) * wTop\n        area2 = (xBot - curMinXbot) * wBot\n        area = min(area, area1 + area2)\n        last_x = x\n    return area\n\ndef minimum_area(X, Y):\n    indices = list(range(N))\n    indices.sort(key=lambda i: (-Y[i], X[i]))\n    (minXtop, maxXtop, heightTop) = sweep_area(indices, X, Y)\n    indices.reverse()\n    (minXbot, maxXbot, heightBot) = sweep_area(indices, X, Y)\n    i_1 = indices[0]\n    x_indices = []\n    double_area = INF\n    j = -1\n    for i in indices + [INF]:\n        if i == INF or Y[i_1] != Y[i]:\n            if i == INF:\n                area = (maxXbot[j] - minXbot[j]) * heightBot[j]\n            elif j == -1:\n                area = (maxXtop[i] - minXtop[i]) * heightTop[i]\n            else:\n                curX = [X[k] for k in x_indices]\n                area1 = merge(curX, maxXtop[i], minXtop[i], maxXbot[j], minXbot[j], heightBot[i_1], heightTop[i_1], heightBot[j])\n                area2 = merge(curX, maxXbot[j], minXbot[j], maxXtop[i], minXtop[i], heightTop[i_1], heightBot[i_1], heightTop[i])\n                area = min(area1, area2)\n            double_area = min(double_area, area)\n            j = i_1\n            x_indices = []\n        x_indices.append(i)\n        i_1 = i\n    return double_area\n\ndef solve():\n    return min(minimum_area(X, Y), minimum_area(Y, X))\ntest_cases = int(input())\nfor test_case in range(test_cases):\n    N = int(input())\n    X = [0] * N\n    Y = [0] * N\n    for i in range(N):\n        (X[i], Y[i]) = map(int, input().split())\n    print(solve())", "def VerticalLevels(array):\n    l = len(array)\n    array.append([0, array[-1][1] + 1])\n    ans = []\n    (start, end) = (0, 0)\n    while end < l:\n        if array[end][1] == array[end + 1][1]:\n            end += 1\n        else:\n            ans.append(array[start:end + 1])\n            end += 1\n            start = end\n    return ans\n\ndef MinArea(Point, TopExtremes, BotExtremes):\n    levels = len(Point)\n    if levels == 1:\n        return 0\n    area1 = (TopExtremes[1][1] - TopExtremes[1][0]) * (Point[levels - 1][0][1] - Point[1][0][1])\n    area2 = (BotExtremes[levels - 2][1] - BotExtremes[levels - 2][0]) * (Point[levels - 2][0][1] - Point[0][0][1])\n    area = min(area1, area2)\n    for i in range(1, levels - 1):\n        level_i = Point[i]\n        l = len(level_i)\n        a1 = (TopExtremes[i][1] - TopExtremes[i][0]) * (Point[-1][0][1] - Point[i][0][1])\n        a2 = (BotExtremes[i - 1][1] - BotExtremes[i - 1][0]) * (Point[i - 1][0][1] - Point[0][0][1])\n        area = min(area, a1 + a2)\n        a1 = (TopExtremes[i + 1][1] - TopExtremes[i + 1][0]) * (Point[-1][0][1] - Point[i + 1][0][1])\n        a2 = (BotExtremes[i][1] - BotExtremes[i][0]) * (Point[i][0][1] - Point[0][0][1])\n        area = min(area, a1 + a2)\n        for j in range(l - 1):\n            top_left = min(TopExtremes[i + 1][0], level_i[0][0])\n            top_right = max(TopExtremes[i + 1][1], level_i[j][0])\n            a1 = (top_right - top_left) * (Point[levels - 1][0][1] - Point[i][0][1])\n            bot_left = min(BotExtremes[i - 1][0], Point[i][j + 1][0])\n            bot_right = max(BotExtremes[i - 1][1], Point[i][-1][0])\n            a2 = (bot_right - bot_left) * (Point[i][0][1] - Point[0][0][1])\n            area = min(area, a1 + a2)\n            bot_left = min(BotExtremes[i - 1][0], Point[i][0][0])\n            bot_right = max(BotExtremes[i - 1][1], Point[i][j][0])\n            a1 = (bot_right - bot_left) * (Point[i][0][1] - Point[0][0][1])\n            top_left = min(TopExtremes[i + 1][0], Point[i][j + 1][0])\n            top_right = max(TopExtremes[i + 1][1], Point[i][-1][0])\n            a2 = (top_right - top_left) * (Point[-1][0][1] - Point[i][0][1])\n            area = min(area, a2 + a1)\n    return area\n\ndef EachCase():\n    n = int(input())\n    Point = [0] * n\n    for i in range(n):\n        Point[i] = list(map(int, input().split()))\n    Swapped = [0] * n\n    for i in range(n):\n        Swapped[i] = Point[i][::-1]\n    a = HorizontalCase(Point)\n    b = HorizontalCase(Swapped)\n    print(min(a, b))\n\ndef HorizontalCase(Point):\n    Point.sort(key=lambda x: [x[1], x[0]])\n    Point = VerticalLevels(Point)\n    levels = len(Point)\n    BotExtremes = [-1] * levels\n    BotExtremes[0] = [Point[0][0][0], Point[0][-1][0]]\n    for i in range(1, levels):\n        (left, right) = BotExtremes[i - 1]\n        BotExtremes[i] = [min(left, Point[i][0][0]), max(right, Point[i][-1][0])]\n    TopExtremes = [-1] * levels\n    TopExtremes[-1] = [Point[-1][0][0], Point[-1][-1][0]]\n    for i in range(levels - 2, -1, -1):\n        (left, right) = TopExtremes[i + 1]\n        TopExtremes[i] = [min(left, Point[i][0][0]), max(right, Point[i][-1][0])]\n    area = MinArea(Point, TopExtremes, BotExtremes)\n    return area\ntestCases = int(input())\nfor _ in range(testCases):\n    EachCase()", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[-1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "from collections import defaultdict\n\ndef Inf():\n    return float('inf')\n\ndef NInf():\n    return float('-inf')\n\ndef solve(array):\n    (min_X, max_X) = (defaultdict(Inf), defaultdict(NInf))\n    (min_Y, max_Y) = (defaultdict(Inf), defaultdict(NInf))\n    for (x, y) in array:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = Inf()\n    (pre, last) = ([], [])\n    (mn, mx) = (Inf(), NInf())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pre.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (Inf(), NInf())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        last.append((X[0 - 1] - x) * (mx - mn))\n    last = last[-1::-1]\n    last.append(0)\n    for i in range(len(X)):\n        area = min(area, pre[i - 1 + 1] + last[i + 1])\n    (pre, last) = ([], [])\n    (mn, mx) = (Inf(), NInf())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pre.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (Inf(), NInf())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        last.append((Y[-1] - y) * (mx - mn))\n    last = last[-1::-1]\n    last.append(0)\n    for i in range(len(Y)):\n        area = min(area, pre[i] + last[i + 1])\n    return area\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        a.append(l)\n    ans = solve(a)\n    print(ans)", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef calculate(vec):\n    (m1, m2) = (defaultdict(INF), defaultdict(NINF))\n    (m3, m4) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in vec:\n        m1[y] = min(m1[y], x)\n        m2[y] = max(m2[y], x)\n        m3[x] = min(m3[x], y)\n        m4[x] = max(m4[x], y)\n    res1 = list(m3.keys())\n    res2 = list(m1.keys())\n    res1.sort()\n    res2.sort()\n    res3 = INF()\n    (p, s) = ([], [])\n    (a, b) = (INF(), NINF())\n    for x in res1:\n        (a, b) = (min(a, m3[x]), max(b, m4[x]))\n        p.append((x - res1[0]) * (b - a))\n    (a, b) = (INF(), NINF())\n    for x in res1[-1::-1]:\n        (a, b) = (min(a, m3[x]), max(b, m4[x]))\n        s.append((res1[-1] - x) * (b - a))\n    s = s[-1::-1]\n    s.append(0)\n    for i in range(len(res1)):\n        res3 = min(res3, p[i] + s[i + 1])\n    (p, s) = ([], [])\n    (a, b) = (INF(), NINF())\n    for y in res2:\n        (a, b) = (min(a, m1[y]), max(b, m2[y]))\n        p.append((y - res2[0]) * (b - a))\n    (a, b) = (INF(), NINF())\n    for y in res2[-1::-1]:\n        (a, b) = (min(a, m1[y]), max(b, m2[y]))\n        s.append((res2[-1] - y) * (b - a))\n    s = s[-1::-1]\n    s.append(0)\n    for i in range(len(res2)):\n        res3 = min(res3, p[i] + s[i + 1])\n    return res3\ntest = int(input())\nfor _ in range(test):\n    n = int(input())\n    vec = []\n    for i in range(n):\n        arr = list(map(int, input().split()))\n        vec.append(arr)\n    res = calculate(vec)\n    print(res)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solution(p):\n    (min_x, max_x) = (defaultdict(INF), defaultdict(NINF))\n    (min_y, max_y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        min_x[y] = min(min_x[y], x)\n        max_x[y] = max(max_x[y], x)\n        min_y[x] = min(min_y[x], y)\n        max_y[x] = max(max_y[x], y)\n    X = list(min_y.keys())\n    Y = list(min_x.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_y[x]), max(mx, max_y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_y[x]), max(mx, max_y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_x[y]), max(mx, max_x[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_x[y]), max(mx, max_x[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\ntc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    m = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        m.append(li)\n    result = solution(m)\n    print(result)", "import sys\n\ndef compute_dp(points):\n    dp = []\n    (ax, min_y) = points[0]\n    max_y = min_y\n    for p in points:\n        (bx, by) = p\n        min_y = min(by, min_y)\n        max_y = max(by, max_y)\n        area = abs(bx - ax) * abs(max_y - min_y)\n        dp.append(area)\n    return dp\n\ndef compute_min_area(N, points):\n    sorted_x = sorted(points, key=lambda p: p[0])\n    dp = compute_dp(sorted_x)\n    sorted_x.reverse()\n    dp_r = compute_dp(sorted_x)\n    dp_r.reverse()\n    min_area = dp[N - 1]\n    for i in range(N - 1):\n        min_area = min(min_area, dp[i] + dp_r[i + 1])\n    return min_area\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    N = int(sys.stdin.readline())\n    points = []\n    for _ in range(N):\n        p = tuple(map(int, sys.stdin.readline().split()))\n        points.append(p)\n    if N <= 2:\n        print(0)\n        continue\n    min_area_x = compute_min_area(N, points)\n    points_transposed = map(lambda p: (p[1], p[0]), points)\n    min_area_y = compute_min_area(N, points_transposed)\n    print(min(min_area_x, min_area_y))", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom math import inf\n\ndef box_area(left, right):\n    return (right[1] - left[1]) * (right[0] - left[0])\n\ndef solve(p):\n    sort_by_x = sorted(p, key=lambda x: (x[0], -x[1]))\n    box_left = []\n    (min_x, min_y) = sort_by_x[0]\n    (max_x, max_y) = sort_by_x[0]\n    for (x, y) in sort_by_x:\n        if x < min_x:\n            min_x = x\n        if x > max_x:\n            max_x = x\n        if y < min_y:\n            min_y = y\n        if y > max_y:\n            max_y = y\n        box_left.append([(min_x, min_y), (max_x, max_y)])\n    box_right = []\n    (min_x, min_y) = sort_by_x[-1]\n    (max_x, max_y) = sort_by_x[-1]\n    for (x, y) in sort_by_x[::-1]:\n        if x < min_x:\n            min_x = x\n        if x > max_x:\n            max_x = x\n        if y < min_y:\n            min_y = y\n        if y > max_y:\n            max_y = y\n        box_right.append([(min_x, min_y), (max_x, max_y)])\n    area = inf\n    for i in range(len(sort_by_x)):\n        area_left = box_area(*box_left[i])\n        area_right = box_area(*box_right[len(sort_by_x) - 2 - i])\n        new_area = area_left + area_right\n        if new_area < area:\n            area = new_area\n    return area\n\ndef main():\n    for _ in range(int(input())):\n        N = int(input())\n        p = [tuple(map(int, input().split())) for _ in range(N)]\n        x = solve(p)\n        y = solve([(y, x) for (x, y) in p])\n        solution = min(x, y)\n        print(solution)\nmain()", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom collections import defaultdict\n\ndef box_area(left, right):\n    return (right[1] - left[1]) * (right[0] - left[0])\n\ndef find_box(p):\n    x = [x for (x, y) in p]\n    y = [y for (x, y) in p]\n    return ((min(x), min(y)), (max(x), max(y)))\n\ndef solve_scan(p):\n    sort_by_x = sorted(p, key=lambda x: (x[0], -x[1]))\n    min_max_table_left = []\n    (min_x, min_y) = sort_by_x[0]\n    (max_x, max_y) = sort_by_x[0]\n    for (x, y) in sort_by_x:\n        if x < min_x:\n            min_x = x\n        if x > max_x:\n            max_x = x\n        if y < min_y:\n            min_y = y\n        if y > max_y:\n            max_y = y\n        min_max_table_left.append([(min_x, min_y), (max_x, max_y)])\n    min_max_table_right = []\n    (min_x, min_y) = sort_by_x[-1]\n    (max_x, max_y) = sort_by_x[-1]\n    for (x, y) in sort_by_x[::-1]:\n        if x < min_x:\n            min_x = x\n        if x > max_x:\n            max_x = x\n        if y < min_y:\n            min_y = y\n        if y > max_y:\n            max_y = y\n        min_max_table_right.append([(min_x, min_y), (max_x, max_y)])\n    area = box_area(*find_box(sort_by_x))\n    for i in range(len(sort_by_x)):\n        area_left = box_area(*min_max_table_left[i])\n        area_right = box_area(*min_max_table_right[len(sort_by_x) - 2 - i])\n        new_area = area_left + area_right\n        if new_area < area:\n            area = new_area\n    return area\n\ndef main():\n    for _ in range(int(input())):\n        N = int(input())\n        p = [tuple(map(int, input().split())) for _ in range(N)]\n        x = solve_scan(p)\n        y = solve_scan([(y, x) for (x, y) in p])\n        print(f'{min(x, y)}')\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom collections import defaultdict\n\ndef find_middle(P):\n    prev_x = P[0][0]\n    better = (prev_x, prev_x)\n    best_size = 0\n    for (x, y) in P[1:]:\n        size = x - prev_x\n        if size > best_size:\n            best_size = size\n            better = (prev_x, x)\n        prev_x = x\n    return better\n\ndef box_area(left, right):\n    return (right[1] - left[1]) * (right[0] - left[0])\n\ndef find_box(p):\n    x = [x for (x, y) in p]\n    y = [y for (x, y) in p]\n    return ((min(x), min(y)), (max(x), max(y)))\n\ndef solve_middle(p):\n    sort_by_x = sorted(p)\n    middle = find_middle(sort_by_x)\n    left_middle_points = [i for i in sort_by_x if i[0] <= middle[0]]\n    right_middle_points = [i for i in sort_by_x if i[0] >= middle[1]]\n    area_left = area_right = 0\n    if left_middle_points:\n        area_left = box_area(*find_box(left_middle_points))\n    if right_middle_points:\n        area_right = box_area(*find_box(right_middle_points))\n    return area_left + area_right\n\ndef solve_scan(p):\n    sort_by_x = sorted(p, key=lambda x: (x[0], -x[1]))\n    min_max_table_left = []\n    (min_x, min_y) = sort_by_x[0]\n    (max_x, max_y) = sort_by_x[0]\n    for (x, y) in sort_by_x:\n        if x < min_x:\n            min_x = x\n        if x > max_x:\n            max_x = x\n        if y < min_y:\n            min_y = y\n        if y > max_y:\n            max_y = y\n        min_max_table_left.append([(min_x, min_y), (max_x, max_y)])\n    min_max_table_right = []\n    (min_x, min_y) = sort_by_x[-1]\n    (max_x, max_y) = sort_by_x[-1]\n    for (x, y) in sort_by_x[::-1]:\n        if x < min_x:\n            min_x = x\n        if x > max_x:\n            max_x = x\n        if y < min_y:\n            min_y = y\n        if y > max_y:\n            max_y = y\n        min_max_table_right.append([(min_x, min_y), (max_x, max_y)])\n    area = box_area(*find_box(sort_by_x))\n    for i in range(len(sort_by_x)):\n        area_left = box_area(*min_max_table_left[i])\n        area_right = box_area(*min_max_table_right[len(sort_by_x) - 2 - i])\n        new_area = area_left + area_right\n        if new_area < area:\n            area = new_area\n    return area\n\ndef main():\n    for _ in range(int(input())):\n        N = int(input())\n        p = [tuple(map(int, input().split())) for _ in range(N)]\n        x = solve_middle(p)\n        y = solve_middle([(y, x) for (x, y) in p])\n        z = solve_scan(p)\n        w = solve_scan([(y, x) for (x, y) in p])\n        print(f'{min(x, y, z, w)}')\nmain()", "import collections\nfrom collections import defaultdict\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    xmin = defaultdict(lambda : float('inf'))\n    xmax = defaultdict(lambda : float('-inf'))\n    ymin = defaultdict(lambda : float('inf'))\n    ymax = defaultdict(lambda : float('-inf'))\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        xmin[y] = min(xmin[y], x)\n        xmax[y] = max(xmax[y], x)\n        ymin[x] = min(ymin[x], y)\n        ymax[x] = max(ymax[x], y)\n    areax = float('inf')\n    X = list(ymin.keys())\n    Y = list(xmin.keys())\n    X.sort()\n    Y.sort()\n    lymax = float('-inf')\n    lymin = float('inf')\n    left_areas = []\n    for i in X:\n        lymax = max(ymax[i], lymax)\n        lymin = min(ymin[i], lymin)\n        area_left = (i - X[0]) * (lymax - lymin)\n        left_areas.append(area_left)\n    rev_X = X[-1::-1]\n    lymax = float('-inf')\n    lymin = float('inf')\n    right_areas = []\n    for i in rev_X:\n        lymax = max(ymax[i], lymax)\n        lymin = min(ymin[i], lymin)\n        area_right = (X[-1] - i) * (lymax - lymin)\n        right_areas.append(area_right)\n    right_areas = right_areas[-1::-1]\n    right_areas.append(0)\n    for i in range(len(X)):\n        areax = min(areax, left_areas[i] + right_areas[i + 1])\n    lxmax = float('-inf')\n    lxmin = float('inf')\n    bottom_areas = []\n    for i in Y:\n        lxmax = max(xmax[i], lxmax)\n        lxmin = min(xmin[i], lxmin)\n        area_bottom = (i - Y[0]) * (lxmax - lxmin)\n        bottom_areas.append(area_bottom)\n    rev_Y = Y[-1::-1]\n    lxmax = float('-inf')\n    lxmin = float('inf')\n    areay = float('inf')\n    up_areas = []\n    for i in rev_Y:\n        lxmax = max(xmax[i], lxmax)\n        lxmin = min(xmin[i], lxmin)\n        area_up = (Y[-1] - i) * (lxmax - lxmin)\n        up_areas.append(area_up)\n    up_areas = up_areas[-1::-1]\n    up_areas.append(0)\n    for i in range(len(Y)):\n        areay = min(areay, bottom_areas[i] + up_areas[i + 1])\n    print(min(areax, areay))", "from collections import defaultdict\ntest = int(input())\nfor j in range(test):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    (min_X, max_X) = (defaultdict(lambda : float('inf')), defaultdict(lambda : float('-inf')))\n    (min_Y, max_Y) = (defaultdict(lambda : float('inf')), defaultdict(lambda : float('-inf')))\n    for (a, b) in p:\n        min_Y[a] = min(min_Y[a], b)\n        max_Y[a] = max(max_Y[a], b)\n        min_X[b] = min(min_X[b], a)\n        max_X[b] = max(max_X[b], a)\n    X = sorted(list(min_Y.keys()))\n    Y = sorted(list(min_X.keys()))\n    area = float('inf')\n    prefix = []\n    suffix = []\n    mn = float('inf')\n    mx = float('-inf')\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        prefix.append((y - Y[0]) * (mx - mn))\n    mn = float('inf')\n    mx = float('-inf')\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suffix.append((Y[-1] - y) * (mx - mn))\n    suffix = suffix[-1::-1]\n    suffix.append(0)\n    for i in range(len(Y)):\n        area = min(area, prefix[i] + suffix[i + 1])\n    prefix = []\n    suffix = []\n    mn = float('inf')\n    mx = float('-inf')\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        prefix.append((x - X[0]) * (mx - mn))\n    mn = float('inf')\n    mx = float('-inf')\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suffix.append((X[-1] - x) * (mx - mn))\n    suffix = suffix[-1::-1]\n    suffix.append(0)\n    for i in range(len(X)):\n        area = min(area, prefix[i - 1 + 1] + suffix[i + 1])\n    print(area)", "import copy\nt = int(input())\nfor i in range(0, t):\n    n = int(input())\n    lst_x = []\n    lst_y = []\n    for j in range(0, n):\n        (x, y) = map(int, input().split())\n        tup = (x, y)\n        lst_x.append(copy.deepcopy(tup))\n        tup = (y, x)\n        lst_y.append(copy.deepcopy(tup))\n    if n > 2:\n        lst_x.sort()\n        lst_y.sort()\n        min_y = [lst_x[0][1]]\n        max_y = [lst_x[0][1]]\n        min_x = [lst_y[0][1]]\n        max_x = [lst_y[0][1]]\n        min_y_rev = [lst_x[-1][1]]\n        max_y_rev = [lst_x[-1][1]]\n        min_x_rev = [lst_y[-1][1]]\n        max_x_rev = [lst_y[-1][1]]\n        for j in range(1, n):\n            min_y.append(min(min_y[-1], lst_x[j][1]))\n            max_y.append(max(max_y[-1], lst_x[j][1]))\n            min_x.append(min(min_x[-1], lst_y[j][1]))\n            max_x.append(max(max_x[-1], lst_y[j][1]))\n            min_y_rev.append(min(min_y_rev[-1], lst_x[n - j - 1][1]))\n            max_y_rev.append(max(max_y_rev[-1], lst_x[n - j - 1][1]))\n            min_x_rev.append(min(min_x_rev[-1], lst_y[n - j - 1][1]))\n            max_x_rev.append(max(max_x_rev[-1], lst_y[n - j - 1][1]))\n        min_x_rev.reverse()\n        min_y_rev.reverse()\n        max_x_rev.reverse()\n        max_y_rev.reverse()\n        m1 = (lst_x[n - 1][0] - lst_x[0][0]) * (max_y[n - 1] - min_y[n - 1])\n        for j in range(0, n - 1):\n            t = (lst_x[j][0] - lst_x[0][0]) * (max_y[j] - min_y[j]) + (lst_x[n - 1][0] - lst_x[j + 1][0]) * (max_y_rev[j + 1] - min_y_rev[j + 1])\n            if t < m1:\n                m1 = t\n        for j in range(0, n - 1):\n            t = (lst_y[j][0] - lst_y[0][0]) * (max_x[j] - min_x[j]) + (lst_y[n - 1][0] - lst_y[j + 1][0]) * (max_x_rev[j + 1] - min_x_rev[j + 1])\n            if t < m1:\n                m1 = t\n        print(m1)\n    else:\n        print(0)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef something(p):\n    (rko_x, rko_X) = (defaultdict(INF), defaultdict(NINF))\n    (rko_y, rko_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        rko_x[y] = min(rko_x[y], x)\n        rko_X[y] = max(rko_X[y], x)\n        rko_y[x] = min(rko_y[x], y)\n        rko_Y[x] = max(rko_Y[x], y)\n    X = list(rko_y.keys())\n    Y = list(rko_x.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, rko_y[x]), max(mx, rko_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, rko_y[x]), max(mx, rko_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, rko_x[y]), max(mx, rko_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, rko_x[y]), max(mx, rko_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = something(p)\n    print(ans)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef something(p):\n    (rko_x, rko_X) = (defaultdict(INF), defaultdict(NINF))\n    (rko_y, rko_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        rko_x[y] = min(rko_x[y], x)\n        rko_X[y] = max(rko_X[y], x)\n        rko_y[x] = min(rko_y[x], y)\n        rko_Y[x] = max(rko_Y[x], y)\n    X = list(rko_y.keys())\n    Y = list(rko_x.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, rko_y[x]), max(mx, rko_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, rko_y[x]), max(mx, rko_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, rko_x[y]), max(mx, rko_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, rko_x[y]), max(mx, rko_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = something(p)\n    print(ans)", "import math\nfor _ in range(int(input())):\n    N = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(N)]\n    min_area = math.inf\n    transpose = True\n    for _ in range(2):\n        points.sort()\n        start_x = points[0][0]\n        end_x = points[-1][0]\n        if start_x == end_x:\n            min_area = 0\n            continue\n        min_y = 10 ** 9 + 1\n        max_y = -min_y\n        max_y_left = [0] * N\n        min_y_left = [0] * N\n        for (i, (_, y)) in enumerate(points):\n            max_y = max(max_y, y)\n            min_y = min(min_y, y)\n            max_y_left[i] = max_y\n            min_y_left[i] = min_y\n        min_y = 10 ** 9 + 1\n        max_y = -min_y\n        max_y_right = [0] * N\n        min_y_right = [0] * N\n        for (i, (_, y)) in enumerate(reversed(points), 1):\n            max_y = max(max_y, y)\n            min_y = min(min_y, y)\n            max_y_right[N - i] = max_y\n            min_y_right[N - i] = min_y\n        prev_x = start_x\n        for (i, (x, _)) in enumerate(points):\n            if prev_x == x:\n                continue\n            left = (prev_x - start_x) * (max_y_left[i - 1] - min_y_left[i - 1])\n            right = (end_x - x) * (max_y_right[i] - min_y_right[i])\n            min_area = min(min_area, left + right)\n            prev_x = x\n        if transpose:\n            points = [(y, x) for (x, y) in points]\n            transpose = False\n    print(min_area)", "import collections\nfrom collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    min_X = defaultdict(lambda : float('inf'))\n    max_X = defaultdict(lambda : float('-inf'))\n    min_Y = defaultdict(lambda : float('inf'))\n    max_Y = defaultdict(lambda : float('-inf'))\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    areax = float('inf')\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    local_y_max = float('-inf')\n    local_y_min = float('inf')\n    left_areas = []\n    for i in X:\n        local_y_max = max(max_Y[i], local_y_max)\n        local_y_min = min(min_Y[i], local_y_min)\n        area_left = (i - X[0]) * (local_y_max - local_y_min)\n        left_areas.append(area_left)\n    rev_X = X[-1::-1]\n    local_y_max = float('-inf')\n    local_y_min = float('inf')\n    right_areas = []\n    for i in rev_X:\n        local_y_max = max(max_Y[i], local_y_max)\n        local_y_min = min(min_Y[i], local_y_min)\n        area_right = (X[-1] - i) * (local_y_max - local_y_min)\n        right_areas.append(area_right)\n    right_areas = right_areas[-1::-1]\n    right_areas.append(0)\n    for i in range(len(X)):\n        areax = min(areax, left_areas[i] + right_areas[i + 1])\n    local_x_max = float('-inf')\n    local_x_min = float('inf')\n    bottom_areas = []\n    for i in Y:\n        local_x_max = max(max_X[i], local_x_max)\n        local_x_min = min(min_X[i], local_x_min)\n        area_bottom = (i - Y[0]) * (local_x_max - local_x_min)\n        bottom_areas.append(area_bottom)\n    rev_Y = Y[-1::-1]\n    local_x_max = float('-inf')\n    local_x_min = float('inf')\n    areay = float('inf')\n    up_areas = []\n    for i in rev_Y:\n        local_x_max = max(max_X[i], local_x_max)\n        local_x_min = min(min_X[i], local_x_min)\n        area_up = (Y[-1] - i) * (local_x_max - local_x_min)\n        up_areas.append(area_up)\n    up_areas = up_areas[-1::-1]\n    up_areas.append(0)\n    for i in range(len(Y)):\n        areay = min(areay, bottom_areas[i] + up_areas[i + 1])\n    if areax <= areay:\n        print(areax)\n    else:\n        print(areay)", "import collections\nfrom collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    min_X = defaultdict(lambda : float('inf'))\n    max_X = defaultdict(lambda : float('-inf'))\n    min_Y = defaultdict(lambda : float('inf'))\n    max_Y = defaultdict(lambda : float('-inf'))\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    areax = float('inf')\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    local_y_max = float('-inf')\n    local_y_min = float('inf')\n    left_areas = []\n    for i in X:\n        local_y_max = max(max_Y[i], local_y_max)\n        local_y_min = min(min_Y[i], local_y_min)\n        area_left = (i - X[0]) * (local_y_max - local_y_min)\n        left_areas.append(area_left)\n    rev_X = X[-1::-1]\n    local_y_max = float('-inf')\n    local_y_min = float('inf')\n    right_areas = []\n    for i in rev_X:\n        local_y_max = max(max_Y[i], local_y_max)\n        local_y_min = min(min_Y[i], local_y_min)\n        area_right = (X[-1] - i) * (local_y_max - local_y_min)\n        right_areas.append(area_right)\n    right_areas = right_areas[-1::-1]\n    right_areas.append(0)\n    for i in range(len(X)):\n        areax = min(areax, left_areas[i] + right_areas[i + 1])\n    local_x_max = float('-inf')\n    local_x_min = float('inf')\n    bottom_areas = []\n    for i in Y:\n        local_x_max = max(max_X[i], local_x_max)\n        local_x_min = min(min_X[i], local_x_min)\n        area_bottom = (i - Y[0]) * (local_x_max - local_x_min)\n        bottom_areas.append(area_bottom)\n    rev_Y = Y[-1::-1]\n    local_x_max = float('-inf')\n    local_x_min = float('inf')\n    areay = float('inf')\n    up_areas = []\n    for i in rev_Y:\n        local_x_max = max(max_X[i], local_x_max)\n        local_x_min = min(min_X[i], local_x_min)\n        area_up = (Y[-1] - i) * (local_x_max - local_x_min)\n        up_areas.append(area_up)\n    up_areas = up_areas[-1::-1]\n    up_areas.append(0)\n    for i in range(len(Y)):\n        areay = min(areay, bottom_areas[i] + up_areas[i + 1])\n    areax = int(areax)\n    areay = int(areay)\n    print(min(areax, areay))", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "from collections import deque\n\ndef read_int_array():\n    return [int(token) for token in input().split(' ')]\n\ndef solve_sort_first_dimension(points):\n    points.sort(key=lambda p: p[0])\n    prefixes = []\n    minx = points[0][0]\n    miny = points[0][1]\n    maxy = points[0][1]\n    for (x, y) in points:\n        dx = x - minx\n        miny = min(miny, y)\n        maxy = max(maxy, y)\n        dy = maxy - miny\n        prefixes.append(dx * dy)\n    suffixes = deque()\n    maxx = points[-1][0]\n    miny = points[-1][1]\n    maxy = points[-1][1]\n    for (x, y) in reversed(points):\n        dx = maxx - x\n        miny = min(miny, y)\n        maxy = max(maxy, y)\n        dy = maxy - miny\n        suffixes.appendleft(dx * dy)\n    suffixes.popleft()\n    return min(map(lambda x: x[0] + x[1], zip(prefixes, suffixes)))\n\ndef solve(points):\n    if len(points) < 2:\n        return 0\n    return min([solve_sort_first_dimension(points), solve_sort_first_dimension([(y, x) for (x, y) in points])])\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        points = []\n        for i in range(n):\n            points.append(read_int_array())\n        print(solve(points))\nmain()", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "def solve2(coordinates):\n    coordinates.sort()\n    minX = coordinates[0][0]\n    maxX = coordinates[-1][0]\n    minY = coordinates[0][1]\n    maxY = coordinates[0][1]\n    size_left = [0 for i in range(len(coordinates) + 1)]\n    for (idx, (x, y)) in enumerate(coordinates):\n        minY = min(minY, y)\n        maxY = max(maxY, y)\n        size_left[idx + 1] = maxY - minY\n    minY = coordinates[-1][1]\n    maxY = coordinates[-1][1]\n    size_right = [0 for i in range(len(coordinates) + 1)]\n    for (idx, (x, y)) in reversed(list(enumerate(coordinates))):\n        minY = min(minY, y)\n        maxY = max(maxY, y)\n        size_right[idx] = maxY - minY\n    answer = (maxX - coordinates[0][0]) * size_right[0]\n    for idx in range(1, len(coordinates)):\n        left_rectangle = (coordinates[idx - 1][0] - minX) * size_left[idx]\n        right_rectangle = (maxX - coordinates[idx][0]) * size_right[idx]\n        answer = min(answer, left_rectangle + right_rectangle)\n    return answer\n\ndef solve(t):\n    N = int(input())\n    coordinates = []\n    for i in range(N):\n        (x, y) = map(int, input().split())\n        coordinates.append((x, y))\n    answer = solve2(coordinates)\n    coordinates = [(y, x) for (x, y) in coordinates]\n    answer = min(answer, solve2(coordinates))\n    print(answer)\nT = int(input())\nfor t in range(T):\n    solve(t + 1)", "from collections import defaultdict\nimport sys\n\ndef Negative():\n    return -1 * sys.maxsize\n\ndef positive():\n    return sys.maxsize\n\ndef solution(p):\n    (a, b) = (defaultdict(positive), defaultdict(Negative))\n    (c, d) = (defaultdict(positive), defaultdict(Negative))\n    for (x, y) in p:\n        a[y] = min(a[y], x)\n        b[y] = max(b[y], x)\n        c[x] = min(c[x], y)\n        d[x] = max(d[x], y)\n    X = list(c.keys())\n    Y = list(a.keys())\n    X.sort()\n    Y.sort()\n    areasum = positive()\n    (pre, suf) = ([], [])\n    (mn, mx) = (positive(), Negative())\n    for x in X:\n        (mn, mx) = (min(mn, c[x]), max(mx, d[x]))\n        pre.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (positive(), Negative())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, c[x]), max(mx, d[x]))\n        suf.append((X[0 - 1] - x) * (mx - mn))\n    suf = suf[-1::-1]\n    suf.append(0)\n    for i in range(len(X)):\n        areasum = min(areasum, pre[i - 1 + 1] + suf[i + 1])\n    (pre, suf) = ([], [])\n    (mn, mx) = (positive(), Negative())\n    for y in Y:\n        (mn, mx) = (min(mn, a[y]), max(mx, b[y]))\n        pre.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (positive(), Negative())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, a[y]), max(mx, b[y]))\n        suf.append((Y[-1] - y) * (mx - mn))\n    suf = suf[-1::-1]\n    suf.append(0)\n    for i in range(len(Y)):\n        areasum = min(areasum, pre[i] + suf[i + 1])\n    return areasum\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solution(p)\n    print(ans)", "from collections import defaultdict\nimport math\n\nclass my_methods:\n\n    def isprime(self, n):\n        i = 0\n        for _ in range(2, n + 1):\n            if n % _ == 0:\n                i += 1\n        a = True if i == 1 else False\n        return a\n\n    def iseven(self, n):\n        a = True if n % 2 == 0 else False\n        return a\n\n    def isodd(self, n):\n        a = True if n % 2 != 0 else False\n        return a\n\n    def get_odd(self, srt, n):\n        if self.isodd(srt) == True:\n            a = [x for x in range(srt, n + 1, 2)]\n        else:\n            a = [x for x in range(srt + 1, n + 1, 2)]\n        return a\n\n    def get_even(self, srt, n):\n        if self.iseven(srt) == True:\n            a = [x for x in range(srt, n + 1, 2)]\n        else:\n            a = [x for x in range(srt + 1, n + 1, 2)]\n        return a\n\n    def get_factors(self, n):\n        i = 1\n        d = []\n        while n >= i ** 2:\n            if n % i == 0:\n                d.append(i)\n                if n != i ** 2:\n                    d.append(n // i)\n            i += 1\n        return sorted(d)\n\n    def isremain(self, n):\n        a = True if n % i == 0 else False\n        return a\n\n    def get_fact(self, n):\n        i = 1\n        a = 1 if n <= 1 else n * self.get_fact(n - 1)\n        return a\n\n    def sq_roots(self, a, b, c):\n        d = []\n        (x, y) = (-b + math.sqrt(b * 2 - 4 * a * c), -b - math.sqrt(b * 2 - 4 * a * c))\n        (z1, z2) = (x // 2 * a, y // 2 * a)\n        d.append(int(z1))\n        d.append(int(z2))\n        return d\n\n    def merge_sort(self, a):\n        if len(a) > 1:\n            mid = len(a) // 2\n            (l, r) = (a[:mid], a[mid:])\n            self.merge_Sort(l)\n            self.merge_Sort(r)\n            (i, j, k) = (0, 0, 0)\n            while i < len(l) and j < len(r):\n                if l[i] < r[j]:\n                    a[k] = l[i]\n                    i += 1\n                    k += 1\n                else:\n                    a[k] = r[j]\n                    j += 1\n                    k += 1\n            while i < len(l):\n                a[k] = l[i]\n                i += 1\n                k += 1\n            while j < len(r):\n                a[k] = r[j]\n                j += 1\n                k += 1\n        return a\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "inf = float('inf')\nfor _ in range(int(input())):\n    minX = {}\n    maxX = {}\n    minY = {}\n    maxY = {}\n    n = int(input())\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        minY[x] = min(minY.get(x, inf), y)\n        maxY[x] = max(maxY.get(x, -inf), y)\n        minX[y] = min(minX.get(y, inf), x)\n        maxX[y] = max(maxX.get(y, -inf), x)\n    X = sorted(list(minY.keys()))\n    Y = sorted(list(minX.keys()))\n    area = inf\n    (rect_from_start, rect_from_end) = ([], [])\n    (top, bottom) = (-inf, inf)\n    for x in X:\n        top = max(top, maxY[x])\n        bottom = min(bottom, minY[x])\n        rect_from_start.append((x - X[0]) * (top - bottom))\n    (top, bottom) = (-inf, inf)\n    for x in X[::-1]:\n        top = max(top, maxY[x])\n        bottom = min(bottom, minY[x])\n        rect_from_end.append((X[-1] - x) * (top - bottom))\n    rect_from_end.reverse()\n    rect_from_end.append(0)\n    for i in range(len(X)):\n        area = min(area, rect_from_end[i + 1] + rect_from_start[i])\n    (rect_from_start, rect_from_end) = ([], [])\n    (top, bottom) = (-inf, inf)\n    for y in Y:\n        top = max(top, maxX[y])\n        bottom = min(bottom, minX[y])\n        rect_from_start.append((y - Y[0]) * (top - bottom))\n    (top, bottom) = (-inf, inf)\n    for y in Y[::-1]:\n        top = max(top, maxX[y])\n        bottom = min(bottom, minX[y])\n        rect_from_end.append((Y[-1] - y) * (top - bottom))\n    rect_from_end.reverse()\n    rect_from_end.append(0)\n    for i in range(len(Y)):\n        area = min(area, rect_from_end[i + 1] + rect_from_start[i])\n    print(area)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (minn, maxx) = (INF(), NINF())\n    for x in X:\n        (minn, maxx) = (min(minn, min_Y[x]), max(maxx, max_Y[x]))\n        pref.append((x - X[0]) * (maxx - minn))\n    (minn, maxx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (minn, maxx) = (min(minn, min_Y[x]), max(maxx, max_Y[x]))\n        suff.append((X[-1] - x) * (maxx - minn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (minn, maxx) = (INF(), NINF())\n    for y in Y:\n        (minn, maxx) = (min(minn, min_X[y]), max(maxx, max_X[y]))\n        pref.append((y - Y[0]) * (maxx - minn))\n    (minn, maxx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (minn, maxx) = (min(minn, min_X[y]), max(maxx, max_X[y]))\n        suff.append((Y[-1] - y) * (maxx - minn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    print(area)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "from collections import defaultdict\n\ndef N_INF():\n    return float('-inf')\n\ndef I_N_F():\n    return float('inf')\n\ndef result(point):\n    (min_A, maxi_A) = (defaultdict(I_N_F), defaultdict(N_INF))\n    (min_B, maxi_B) = (defaultdict(I_N_F), defaultdict(N_INF))\n    for (x, y) in point:\n        min_A[y] = min(min_A[y], x)\n        maxi_A[y] = max(maxi_A[y], x)\n        min_B[x] = min(min_B[x], y)\n        maxi_B[x] = max(maxi_B[x], y)\n    A = list(min_B.keys())\n    B = list(min_A.keys())\n    A.sort()\n    B.sort()\n    AR = I_N_F()\n    (PRF, SFF) = ([], [])\n    (mn, mx) = (I_N_F(), N_INF())\n    for x in A:\n        (mn, mx) = (min(mn, min_B[x]), max(mx, maxi_B[x]))\n        PRF.append((x - A[0]) * (mx - mn))\n    (mn, mx) = (I_N_F(), N_INF())\n    for x in A[-1::-1]:\n        (mn, mx) = (min(mn, min_B[x]), max(mx, maxi_B[x]))\n        SFF.append((A[0 - 1] - x) * (mx - mn))\n    SFF = SFF[-1::-1]\n    SFF.append(0)\n    for i in range(len(A)):\n        AR = min(AR, PRF[i - 1 + 1] + SFF[i + 1])\n    (PRF, SFF) = ([], [])\n    (mn, mx) = (I_N_F(), N_INF())\n    for y in B:\n        (mn, mx) = (min(mn, min_A[y]), max(mx, maxi_A[y]))\n        PRF.append((y - B[0]) * (mx - mn))\n    (mn, mx) = (I_N_F(), N_INF())\n    for y in B[-1::-1]:\n        (mn, mx) = (min(mn, min_A[y]), max(mx, maxi_A[y]))\n        SFF.append((B[-1] - y) * (mx - mn))\n    SFF = SFF[-1::-1]\n    SFF.append(0)\n    for i in range(len(B)):\n        AR = min(AR, PRF[i] + SFF[i + 1])\n    return AR\ntest_case = int(input())\nfor _ in range(test_case):\n    num = int(input())\n    point = []\n    for i in range(num):\n        li = list(map(int, input().split()))\n        point.append(li)\n    z = result(point)\n    print(z)", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[-1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "from collections import defaultdict\n\ndef NINF():\n    return float('-inf')\n\ndef INF():\n    return float('inf')\n\ndef solve(p):\n    (minium_X, maximum_X) = (defaultdict(INF), defaultdict(NINF))\n    (minium_Y, maximum_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in p:\n        minium_X[y] = min(minium_X[y], x)\n        maximum_X[y] = max(maximum_X[y], x)\n        minium_Y[x] = min(minium_Y[x], y)\n        maximum_Y[x] = max(maximum_Y[x], y)\n    X = list(minium_Y.keys())\n    Y = list(minium_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minium_Y[x]), max(mx, maximum_Y[x]))\n        suff.append((X[0 - 1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i - 1 + 1] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minium_X[y]), max(mx, maximum_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        p.append(li)\n    ans = solve(p)\n    print(ans)", "from collections import defaultdict\n\ndef neginf():\n    return float('-inf')\n\ndef inf():\n    return float('inf')\n\ndef getArea(p):\n    (minmX, maxmX) = (defaultdict(inf), defaultdict(neginf))\n    (minmY, maxmY) = (defaultdict(inf), defaultdict(neginf))\n    for (x, y) in p:\n        minmX[y] = min(minmX[y], x)\n        maxmX[y] = max(maxmX[y], x)\n        minmY[x] = min(minmY[x], y)\n        maxmY[x] = max(maxmY[x], y)\n    X = list(minmY.keys())\n    Y = list(minmX.keys())\n    X.sort()\n    Y.sort()\n    area = inf()\n    (p, s) = ([], [])\n    (mn, mx) = (inf(), neginf())\n    for x in X:\n        (mn, mx) = (min(mn, minmY[x]), max(mx, maxmY[x]))\n        p.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (inf(), neginf())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, minmY[x]), max(mx, maxmY[x]))\n        s.append((X[-1] - x) * (mx - mn))\n    s = s[-1::-1]\n    s.append(0)\n    for i in range(len(X)):\n        area = min(area, p[i - 1 + 1] + s[i + 1])\n    (p, s) = ([], [])\n    (mn, mx) = (inf(), neginf())\n    for y in Y:\n        (mn, mx) = (min(mn, minmX[y]), max(mx, maxmX[y]))\n        p.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (inf(), neginf())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, minmX[y]), max(mx, maxmX[y]))\n        s.append((Y[-1] - y) * (mx - mn))\n    s = s[-1::-1]\n    s.append(0)\n    for i in range(len(Y)):\n        area = min(area, p[i] + s[i + 1])\n    return area\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        p.append(l)\n    ans = getArea(p)\n    print(ans)", "from collections import defaultdict\n\ndef INF():\n    return float('inf')\n\ndef NINF():\n    return float('-inf')\n\ndef solve(P):\n    (min_X, max_X) = (defaultdict(INF), defaultdict(NINF))\n    (min_Y, max_Y) = (defaultdict(INF), defaultdict(NINF))\n    for (x, y) in P:\n        min_X[y] = min(min_X[y], x)\n        max_X[y] = max(max_X[y], x)\n        min_Y[x] = min(min_Y[x], y)\n        max_Y[x] = max(max_Y[x], y)\n    X = list(min_Y.keys())\n    Y = list(min_X.keys())\n    X.sort()\n    Y.sort()\n    area = INF()\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for x in X:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        pref.append((x - X[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for x in X[-1::-1]:\n        (mn, mx) = (min(mn, min_Y[x]), max(mx, max_Y[x]))\n        suff.append((X[-1] - x) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(X)):\n        area = min(area, pref[i] + suff[i + 1])\n    (pref, suff) = ([], [])\n    (mn, mx) = (INF(), NINF())\n    for y in Y:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        pref.append((y - Y[0]) * (mx - mn))\n    (mn, mx) = (INF(), NINF())\n    for y in Y[-1::-1]:\n        (mn, mx) = (min(mn, min_X[y]), max(mx, max_X[y]))\n        suff.append((Y[-1] - y) * (mx - mn))\n    suff = suff[-1::-1]\n    suff.append(0)\n    for i in range(len(Y)):\n        area = min(area, pref[i] + suff[i + 1])\n    return area\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    P = []\n    for i in range(N):\n        li = list(map(int, input().split()))\n        P.append(li)\n    ans = solve(P)\n    print(ans)", "import sys\ninput = sys.stdin.readline\nT = int(input())\n\ndef solve(point):\n    point = sorted(point, key=lambda x: (-x[1], x[0]))\n    n = len(point)\n    if n == 1:\n        return 0\n    Lx = [[0, 0] for _ in range(n)]\n    Ly = [[0, 0] for _ in range(n)]\n    Rx = [[0, 0] for _ in range(n)]\n    Ry = [[0, 0] for _ in range(n)]\n    Lx[0][0] = Rx[0][0] = point[0][0]\n    Ly[0][0] = Ry[0][0] = point[0][1]\n    for i in range(1, n):\n        Lx[i][0] = min(Lx[i - 1][0], point[i][0])\n        Rx[i][0] = max(Rx[i - 1][0], point[i][0])\n        Ly[i][0] = min(Ly[i - 1][0], point[i][1])\n        Ry[i][0] = max(Ry[i - 1][0], point[i][1])\n    Lx[n - 1][1] = Rx[n - 1][1] = point[n - 1][0]\n    Ly[n - 1][1] = Ry[n - 1][1] = point[n - 1][1]\n    for i in range(n - 2, -1, -1):\n        Lx[i][1] = min(Lx[i + 1][1], point[i][0])\n        Rx[i][1] = max(Rx[i + 1][1], point[i][0])\n        Ly[i][1] = min(Ly[i + 1][1], point[i][1])\n        Ry[i][1] = max(Ry[i + 1][1], point[i][1])\n    ans = 10 ** 18\n    s = [[0, 0] for _ in range(n)]\n    for i in range(n):\n        s[i][0] = (Rx[i][0] - Lx[i][0]) * (Ry[i][0] - Ly[i][0])\n        s[i][1] = (Rx[i][1] - Lx[i][1]) * (Ry[i][1] - Ly[i][1])\n        if i:\n            ans = min(ans, s[i][1] + s[i - 1][0])\n    return ans\nfor tt in range(T):\n    n = int(input())\n    point = [[0, 0] for _ in range(n)]\n    for i in range(n):\n        (point[i][0], point[i][1]) = map(int, input().split())\n    ans = solve(point)\n    for i in range(n):\n        point[i] = [point[i][1], point[i][0]]\n    ans = min(ans, solve(point))\n    print(ans)"]