["from random import randrange\nprime = []\n\ndef sieve():\n    N = 1000010\n    pr = [True] * N\n    pr[0] = pr[1] = False\n    for i in range(int(N ** 0.5)):\n        if pr[i]:\n            for j in range(2 * i, N, i):\n                pr[j] = False\n    for i in range(N):\n        if pr[i]:\n            prime.append(i)\n\ndef miller_rabin(p):\n    if p == 2 or p == 3:\n        return True\n    if p < 3 or p % 2 == 0:\n        return False\n    for i in range(1):\n        rand = randrange(2, p - 2)\n        n = p - 1\n        while n % 2 == 0:\n            n //= 2\n        mod = pow(rand, n, p)\n        if mod == 1 or mod == p - 1:\n            continue\n        flag = 0\n        while n != p - 1:\n            mod = pow(rand, n, p)\n            if mod == p - 1:\n                flag = 1\n                break\n            n *= 2\n        if flag == 0:\n            return 0\n    return True\n\ndef fac(n):\n    ans = 1\n    for p in prime:\n        if p * p * p > n:\n            break\n        count = 1\n        while n % p == 0:\n            n //= p\n            count += 1\n        ans = ans * count\n    if miller_rabin(n):\n        ans *= 2\n    elif n ** 0.5 * n ** 0.5 == n and miller_rabin(int(n ** 0.5)):\n        ans *= 3\n    elif n != 1:\n        ans *= 4\n    return ans\na = int(input())\nif abs(a) <= 1:\n    print(-1)\nelse:\n    sieve()\n    print(2 * fac(abs(a)) * fac(abs(a - 1)))", "from random import randrange\nprime = []\n\ndef sieve():\n    N = 1000010\n    pr = [True] * N\n    pr[0] = pr[1] = False\n    for i in range(int(N ** 0.5)):\n        if pr[i]:\n            for j in range(2 * i, N, i):\n                pr[j] = False\n    for i in range(N):\n        if pr[i]:\n            prime.append(i)\n\ndef miller_rabin(p):\n    if p == 2 or p == 3:\n        return True\n    if p < 3 or p % 2 == 0:\n        return False\n    for i in range(1):\n        rand = randrange(2, p - 2)\n        n = p - 1\n        while n % 2 == 0:\n            n //= 2\n        mod = pow(rand, n, p)\n        if mod == 1 or mod == p - 1:\n            continue\n        flag = 0\n        while n != p - 1:\n            mod = pow(rand, n, p)\n            if mod == p - 1:\n                flag = 1\n                break\n            n *= 2\n        if flag == 0:\n            return 0\n    return True\n\ndef fac(n):\n    ans = 1\n    for p in prime:\n        if p * p * p > n:\n            break\n        count = 1\n        while n % p == 0:\n            n //= p\n            count += 1\n        ans = ans * count\n    if miller_rabin(n):\n        ans *= 2\n    elif n ** 0.5 * n ** 0.5 == n and miller_rabin(int(n ** 0.5)):\n        ans *= 3\n    elif n != 1:\n        ans *= 4\n    return ans\na = int(input())\nif abs(a) <= 1:\n    print(-1)\nelse:\n    sieve()\n    print(2 * fac(abs(a)) * fac(abs(a - 1)))", "from random import randrange\nprime = []\n\ndef sieve():\n    N = 1000010\n    pr = [True] * N\n    pr[0] = pr[1] = False\n    for i in range(int(N ** 0.5)):\n        if pr[i]:\n            for j in range(2 * i, N, i):\n                pr[j] = False\n    for i in range(N):\n        if pr[i]:\n            prime.append(i)\n\ndef miller_rabin(p):\n    if p == 2 or p == 3:\n        return True\n    if p < 3 or p % 2 == 0:\n        return False\n    for i in range(1):\n        rand = randrange(2, p - 2)\n        n = p - 1\n        while n % 2 == 0:\n            n //= 2\n        mod = pow(rand, n, p)\n        if mod == 1 or mod == p - 1:\n            continue\n        flag = 0\n        while n != p - 1:\n            mod = pow(rand, n, p)\n            if mod == p - 1:\n                flag = 1\n                break\n            n *= 2\n        if flag == 0:\n            return 0\n    return True\n\ndef fac(n):\n    ans = 1\n    for p in prime:\n        if p * p * p > n:\n            break\n        count = 1\n        while n % p == 0:\n            n //= p\n            count += 1\n        ans = ans * count\n    if miller_rabin(n):\n        ans *= 2\n    elif n ** 0.5 * n ** 0.5 == n and miller_rabin(int(n ** 0.5)):\n        ans *= 3\n    elif n != 1:\n        ans *= 4\n    return ans\na = int(input())\nif abs(a) <= 1:\n    print(-1)\nelse:\n    sieve()\n    print(2 * fac(abs(a)) * fac(abs(a - 1)))", "from random import randrange\nprime = []\n\ndef sieve():\n    N = 1000010\n    pr = [True] * N\n    pr[0] = pr[1] = False\n    for i in range(int(N ** 0.5)):\n        if pr[i]:\n            for j in range(2 * i, N, i):\n                pr[j] = False\n    for i in range(N):\n        if pr[i]:\n            prime.append(i)\n\ndef miller_rabin(p):\n    if p == 2 or p == 3:\n        return True\n    if p < 3 or p % 2 == 0:\n        return False\n    for i in range(2):\n        rand = randrange(2, p - 2)\n        n = p - 1\n        while n % 2 == 0:\n            n //= 2\n        mod = pow(rand, n, p)\n        if mod == 1 or mod == p - 1:\n            continue\n        flag = 0\n        while n != p - 1:\n            mod = pow(rand, n, p)\n            if mod == p - 1:\n                flag = 1\n                break\n            n *= 2\n        if flag == 0:\n            return 0\n    return True\n\ndef fac(n):\n    ans = 1\n    for p in prime:\n        if p * p * p > n:\n            break\n        count = 1\n        while n % p == 0:\n            n //= p\n            count += 1\n        ans = ans * count\n    if miller_rabin(n):\n        ans *= 2\n    elif n ** 0.5 * n ** 0.5 == n and miller_rabin(int(n ** 0.5)):\n        ans *= 3\n    elif n != 1:\n        ans *= 4\n    return ans\na = int(input())\nif abs(a) <= 1:\n    print(-1)\nelse:\n    sieve()\n    print(2 * fac(abs(a)) * fac(abs(a - 1)))", "from random import randrange\nprime = []\n\ndef sieve():\n    N = 1000010\n    pr = [True] * N\n    pr[0] = pr[1] = False\n    for i in range(int(N ** 0.5)):\n        if pr[i]:\n            for j in range(2 * i, N, i):\n                pr[j] = False\n    for i in range(N):\n        if pr[i]:\n            prime.append(i)\n\ndef miller_rabin(p):\n    if p == 2 or p == 3:\n        return True\n    if p < 3 or p % 2 == 0:\n        return False\n    for i in range(5):\n        rand = randrange(2, p - 2)\n        n = p - 1\n        while n % 2 == 0:\n            n //= 2\n        mod = pow(rand, n, p)\n        if mod == 1 or mod == p - 1:\n            continue\n        flag = 0\n        while n != p - 1:\n            mod = pow(rand, n, p)\n            if mod == p - 1:\n                flag = 1\n                break\n            n *= 2\n        if flag == 0:\n            return 0\n    return True\n\ndef fac(n):\n    ans = 1\n    for p in prime:\n        if p * p * p > n:\n            break\n        count = 1\n        while n % p == 0:\n            n //= p\n            count += 1\n        ans = ans * count\n    if miller_rabin(n):\n        ans *= 2\n    elif n ** 0.5 * n ** 0.5 == n and miller_rabin(int(n ** 0.5)):\n        ans *= 3\n    elif n != 1:\n        ans *= 4\n    return ans\na = int(input())\nif abs(a) <= 1:\n    print(-1)\nelse:\n    sieve()\n    print(2 * fac(abs(a)) * fac(abs(a - 1)))", "from random import randrange\nprime = []\n\ndef sieve():\n    N = 1000010\n    pr = [True] * N\n    pr[0] = pr[1] = False\n    for i in range(int(N ** 0.5)):\n        if pr[i]:\n            for j in range(2 * i, N, i):\n                pr[j] = False\n    for i in range(N):\n        if pr[i]:\n            prime.append(i)\n\ndef miller_rabin(p):\n    if p == 2 or p == 3:\n        return True\n    if p < 3 or p % 2 == 0:\n        return False\n    for i in range(10):\n        rand = randrange(2, p - 2)\n        n = p - 1\n        while n % 2 == 0:\n            n //= 2\n        mod = pow(rand, n, p)\n        if mod == 1 or mod == p - 1:\n            continue\n        flag = 0\n        while n != p - 1:\n            mod = pow(rand, n, p)\n            if mod == p - 1:\n                flag = 1\n                break\n            n *= 2\n        if flag == 0:\n            return 0\n    return True\n\ndef fac(n):\n    ans = 1\n    for p in prime:\n        if p * p * p > n:\n            break\n        count = 1\n        while n % p == 0:\n            n //= p\n            count += 1\n        ans = ans * count\n    if miller_rabin(n):\n        ans *= 2\n    elif n ** 0.5 * n ** 0.5 == n and miller_rabin(int(n ** 0.5)):\n        ans *= 3\n    elif n != 1:\n        ans *= 4\n    return ans\na = int(input())\nif abs(a) <= 1:\n    print(-1)\nelse:\n    sieve()\n    print(2 * fac(abs(a)) * fac(abs(a - 1)))", "from random import randrange\nprime = []\n\ndef sieve():\n    N = 1000010\n    pr = [True] * N\n    pr[0] = pr[1] = False\n    for i in range(int(N ** 0.5)):\n        if pr[i]:\n            for j in range(2 * i, N, i):\n                pr[j] = False\n    for i in range(N):\n        if pr[i]:\n            prime.append(i)\n\ndef miller_rabin(p):\n    if p == 2 or p == 3:\n        return True\n    if p < 3 or p % 2 == 0:\n        return False\n    for i in range(10):\n        rand = randrange(2, p - 2)\n        n = p - 1\n        while n % 2 == 0:\n            n //= 2\n        mod = pow(rand, n, p)\n        if mod == 1 or mod == p - 1:\n            continue\n        flag = 0\n        while n != p - 1:\n            mod = pow(rand, n, p)\n            if mod == p - 1:\n                flag = 1\n                break\n            n *= 2\n        if flag == 0:\n            return 0\n    return True\nsieve()\n\ndef fac(n):\n    ans = 1\n    for p in prime:\n        if p * p * p > n:\n            break\n        count = 1\n        while n % p == 0:\n            n //= p\n            count += 1\n        ans = ans * count\n    if miller_rabin(n):\n        ans *= 2\n    elif n ** 0.5 * n ** 0.5 == n and miller_rabin(int(n ** 0.5)):\n        ans *= 3\n    elif n != 1:\n        ans *= 4\n    return ans\na = int(input())\nif abs(a) <= 1:\n    print(-1)\nelse:\n    print(2 * fac(abs(a)) * fac(abs(a - 1)))"]