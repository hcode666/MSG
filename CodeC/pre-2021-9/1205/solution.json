["(limit, MOD) = (int(2 * 10 ** 6 + 10), int(10 ** 9) + 7)\n(factorial, invFactorial) = ([0] * limit, [0] * limit)\n\ndef calFactorial():\n    limit = int(2 * 10 ** 6 + 10)\n    (factorial[0], factorial[1], invFactorial[0], invFactorial[1]) = (1, 1, 1, 1)\n    for i in range(2, limit):\n        factorial[i] = factorial[i - 1] * i % MOD\n    for i in range(2, limit):\n        invFactorial[i] = (MOD - MOD // i * invFactorial[MOD % i]) % MOD\n    for i in range(1, limit):\n        invFactorial[i] = invFactorial[i - 1] * invFactorial[i] % MOD\n\ndef nCr(N, R):\n    if R > N:\n        return 0\n    ans = factorial[N] * invFactorial[R] % MOD * invFactorial[N - R]\n    ans %= MOD\n    return ans\n\ndef solve(N, K):\n    ans = 2 * nCr(N + K + 1, K + 2) - N\n    ans = (ans % MOD + MOD) % MOD\n    print(ans)\ncalFactorial()\nT = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    solve(N, K)", "(limit, MOD) = (int(2 * 10 ** 6 + 10), int(10 ** 9) + 7)\n(factorial, invFactorial) = ([0] * limit, [0] * limit)\n\ndef calFactorial():\n    limit = int(2 * 10 ** 6 + 10)\n    (factorial[0], factorial[1], invFactorial[0], invFactorial[1]) = (1, 1, 1, 1)\n    for i in range(2, limit):\n        factorial[i] = factorial[i - 1] * i % MOD\n    for i in range(2, limit):\n        invFactorial[i] = (MOD - MOD // i * invFactorial[MOD % i]) % MOD\n    for i in range(1, limit):\n        invFactorial[i] = invFactorial[i - 1] * invFactorial[i] % MOD\n\ndef nCr(N, R):\n    if R > N:\n        return 0\n    ans = factorial[N] * invFactorial[R] % MOD * invFactorial[N - R]\n    ans %= MOD\n    return ans\n\ndef solve(N, K):\n    ans = 2 * nCr(N + K + 1, K + 2) - N\n    ans = (ans % MOD + MOD) % MOD\n    print(ans)\ncalFactorial()\nT = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    solve(N, K)", "t = int(input())\nq = [1]\nfor i in range(1, 2000002):\n    q.append(q[-1] * i % (10 ** 9 + 7))\ninv = lambda x: pow(q[x], 10 ** 9 + 5, 10 ** 9 + 7)\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    print((2 * q[k + n + 1] * inv(k + 2) * inv(n - 1) - n) % (10 ** 9 + 7))", "(limit, MOD) = (int(2 * 10 ** 6 + 10), int(10 ** 9) + 7)\n(factorial, invFactorial) = ([0] * limit, [0] * limit)\n\ndef calFactorial():\n    limit = int(2 * 10 ** 6 + 10)\n    (factorial[0], factorial[1], invFactorial[0], invFactorial[1]) = (1, 1, 1, 1)\n    for i in range(2, limit):\n        factorial[i] = factorial[i - 1] * i % MOD\n    for i in range(2, limit):\n        invFactorial[i] = (MOD - MOD // i * invFactorial[MOD % i]) % MOD\n    for i in range(1, limit):\n        invFactorial[i] = invFactorial[i - 1] * invFactorial[i] % MOD\n\ndef nCr(N, R):\n    if R > N:\n        return 0\n    ans = factorial[N] * invFactorial[R] % MOD * invFactorial[N - R]\n    ans %= MOD\n    return ans\n\ndef solve(N, K):\n    ans = 2 * nCr(N + K + 1, K + 2) - N\n    ans = (ans % MOD + MOD) % MOD\n    print(ans)\ncalFactorial()\nT = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    solve(N, K)", "(limit, MOD) = (int(2 * 10 ** 6 + 10), int(10 ** 9) + 7)\n(factorial, invFactorial) = ([0] * limit, [0] * limit)\n\ndef calFactorial():\n    limit = int(2 * 10 ** 6 + 10)\n    (factorial[0], factorial[1], invFactorial[0], invFactorial[1]) = (1, 1, 1, 1)\n    for i in range(2, limit):\n        factorial[i] = factorial[i - 1] * i % MOD\n    for i in range(2, limit):\n        invFactorial[i] = (MOD - MOD // i * invFactorial[MOD % i]) % MOD\n    for i in range(1, limit):\n        invFactorial[i] = invFactorial[i - 1] * invFactorial[i] % MOD\n\ndef nCr(N, R):\n    if R > N:\n        return 0\n    ans = factorial[N] * invFactorial[R] % MOD * invFactorial[N - R]\n    ans %= MOD\n    return ans\n\ndef solve(N, K):\n    ans = 2 * nCr(N + K + 1, K + 2) - N\n    ans = (ans % MOD + MOD) % MOD\n    print(ans)\ncalFactorial()\nT = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    solve(N, K)", "def power(a, n):\n    res = 1\n    while n:\n        if n % 2 == 1:\n            res = res * a % p\n            n -= 1\n        else:\n            a = a * a % p\n            n = n // 2\n    return res\n\ndef c(n, k):\n    if k > n:\n        return 0\n    res = f[n]\n    res = res * power(f[k], p - 2) % p\n    res = res * power(f[n - k], p - 2) % p\n    return res % p\np = 10 ** 9 + 7\nf = [0] * (2100000 + 2)\nf[0] = f[1] = 1\nfor i in range(2, 2100000 + 2):\n    f[i] = i * f[i - 1] % p\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    m = c(n + k + 1, k + 2)\n    print((2 * int(m) - n + p) % p)", "q = [1]\nfor i in range(1, 2000002):\n    q.append(q[-1] * i % (10 ** 9 + 7))\ninv = lambda x: pow(q[x], 10 ** 9 + 5, 10 ** 9 + 7)\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    print((2 * q[k + n + 1] * inv(k + 2) * inv(n - 1) - n) % (10 ** 9 + 7))", "factorial = [1]\nmod = 10 ** 9 + 7\nfor i in range(1, 3000000):\n    a = factorial[-1] * i % mod\n    factorial.append(a)\n\ndef C(a, b):\n    if b > a:\n        return 0\n    num = factorial[a]\n    den = factorial[b] * factorial[a - b] % mod\n    inverse = pow(den, mod - 2, mod)\n    answer = num * inverse % mod\n    return answer\n\ndef solve2(N, K):\n    num = ((N + 1) * C(K + N + 1, K) - (K ** 2 + 3 * K + 2)) % mod\n    num *= 2\n    num = num * N % mod\n    den = (K + 1) * (K + 2) % mod\n    inverse = pow(den, mod - 2, mod)\n    answer = num * inverse % mod\n    return (answer + N) % mod\nfor i in range(int(input())):\n    (N, K) = map(int, input().split())\n    print(solve2(N, K))", "fac = []\nm = int(1000000000.0 + 7)\nfac.append(1)\nfor i in range(1, 2 * 10 ** 6 + 2):\n    temp = fac[i - 1] % m * i % m % m\n    fac.append(temp)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    res = (2 * (fac[n + k + 1] * pow(fac[n - 1], m - 2, m) * pow(fac[k + 2], m - 2, m)) - n) % m\n    print(res)", "t = int(input())\nq = [1]\nfor i in range(1, 2000002):\n    q.append(q[-1] * i % (10 ** 9 + 7))\ninv = lambda x: pow(q[x], 10 ** 9 + 5, 10 ** 9 + 7)\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    print((2 * q[k + n + 1] * inv(k + 2) * inv(n - 1) - n) % (10 ** 9 + 7))", "t = int(input())\nq = [1]\nfor i in range(1, 2000002):\n    q.append(q[-1] * i % (10 ** 9 + 7))\ninv = lambda x: pow(q[x], 10 ** 9 + 5, 10 ** 9 + 7)\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    print((2 * q[k + n + 1] * inv(k + 2) * inv(n - 1) - n) % (10 ** 9 + 7))", "t = int(input())\nq = [1]\nfor i in range(1, 2000002):\n    q.append(q[-1] * i % (10 ** 9 + 7))\ninv = lambda x: pow(q[x], 10 ** 9 + 5, 10 ** 9 + 7)\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    print((2 * q[k + n + 1] * inv(k + 2) * inv(n - 1) - n) % (10 ** 9 + 7))", "q = [1]\nfor i in range(1, 2000002):\n    q.append(q[-1] * i % (10 ** 9 + 7))\ninv = lambda x: pow(q[x], 10 ** 9 + 5, 10 ** 9 + 7)\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    print((2 * q[k + n + 1] * inv(k + 2) * inv(n - 1) - n) % (10 ** 9 + 7))", "t = int(input())\nq = [1]\nfor i in range(1, 2000002):\n    q.append(q[-1] * i % (10 ** 9 + 7))\ninv = lambda x: pow(q[x], 10 ** 9 + 5, 10 ** 9 + 7)\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    print((2 * q[k + n + 1] * inv(k + 2) * inv(n - 1) - n) % (10 ** 9 + 7))", "t = int(input())\nq = [1]\nfor i in range(1, 2000002):\n    q.append(q[-1] * i % (10 ** 9 + 7))\ninv = lambda x: pow(q[x], 10 ** 9 + 5, 10 ** 9 + 7)\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    print((2 * q[k + n + 1] * inv(k + 2) * inv(n - 1) - n) % (10 ** 9 + 7))", "mod = 10 ** 9 + 7\nt = int(input())\nfact = [1]\nfor i in range(1, 2000002):\n    fact.append(fact[-1] * i % mod)\ninv = lambda x: pow(fact[x], mod - 2, mod)\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    print((2 * fact[k + n + 1] * inv(k + 2) * inv(n - 1) - n) % mod)", "T = int(input())\nfact = [1 for x in range(2000005)]\nmod = 1000000007\nfor x in range(1, 2000005):\n    fact[x] = x * fact[x - 1] % mod\nfor y in range(T):\n    (n, k) = map(int, input().split())\n    ans = fact[n + k + 1] * pow(fact[k + 2] * fact[n - 1], mod - 2, mod) % mod\n    ans = (2 * ans + mod - n) % mod\n    print(ans)", "mod = 1000000007\narr = [1]\nfor i in range(1, 2000006):\n    arr.append(arr[i - 1] * i % mod)\nx = int(input())\nfor i in range(x, 0, -1):\n    (n, k) = map(int, input().split())\n    num = 2 * n * (n + k + 1) * arr[n + k] % mod\n    den1 = pow((k + 1) * (k + 2) * arr[k], mod - 2, mod)\n    den2 = pow(arr[n], mod - 2, mod)\n    res = (num * den1 * den2 - n) % mod\n    print(int(res))", "M = 1000000007\nN = 2000005\nF = [0] * N\nF[0] = 1\nfor i in range(1, N):\n    F[i] = F[i - 1] * i % M\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    ans = F[n + k + 1] * pow(F[k + 2], M - 2, M) * pow(F[n - 1], M - 2, M) % M * 2 - n + M\n    print(ans % M)"]