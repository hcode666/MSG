["import random\ndy = [-2, -1, 1, 2, -2, -1, 1, 2]\ndx = [-1, -2, -2, -1, 1, 2, 2, 1]\n\nclass Ponies:\n    mat = []\n    G = []\n    match = []\n    used = []\n\n    def dfs(self, v):\n        global used\n        used.add(v)\n        for i in range(len(G[v])):\n            u = G[v][i]\n            w = match[u]\n            if w < 0 or (w not in used and self.dfs(w)):\n                match[v] = u\n                match[u] = v\n                return 1\n        return 0\n\n    def bipartiteMatching(self, V):\n        global used\n        global match\n        res = 0\n        match = [-1] * 1500\n        for v in range(V):\n            if match[v] < 0:\n                used = set([])\n                if self.dfs(v):\n                    res += 1\n        return res\n\n    def maxIndependentSet(self, h, w, V):\n        global G\n        G = [[] for _ in range(1500)]\n        for i in range(h):\n            for j in range(w):\n                if mat[i][j] == -1:\n                    continue\n                curr = mat[i][j]\n                for k in range(8):\n                    y = i + dy[k]\n                    x = j + dx[k]\n                    if y < 0 or y >= h or x < 0 or (x >= w) or (mat[y][x] == -1):\n                        continue\n                    G[curr] += [mat[y][x]]\n        maximalIndependentSet = V - self.bipartiteMatching(V)\n        return maximalIndependentSet\n\n    def solve(self, chessboard):\n        global mat\n        V = 0\n        mat = [[0 for _ in range(50)] for _ in range(50)]\n        h = len(chessboard)\n        w = len(chessboard[0])\n        for i in range(h):\n            for j in range(w):\n                if chessboard[i][j] == '.':\n                    V += 1\n                    mat[i][j] = V\n                else:\n                    mat[i][j] = -1\n        return self.maxIndependentSet(h, w, V)\nsolver = Ponies()\nT = int(input())\nwhile T:\n    T -= 1\n    (h, w) = [int(entry) for entry in input().split(' ')]\n    input_mat = []\n    for _ in range(h):\n        row = input()\n        input_mat += [row]\n    print(solver.solve(input_mat))", "import random\ndy = [-2, -1, 1, 2, -2, -1, 1, 2]\ndx = [-1, -2, -2, -1, 1, 2, 2, 1]\n\nclass Ponies:\n    mat = []\n    G = []\n    match = []\n    used = []\n\n    def dfs(self, v):\n        global used\n        used.add(v)\n        for i in range(len(G[v])):\n            u = G[v][i]\n            w = match[u]\n            if w < 0 or (w not in used and self.dfs(w)):\n                match[v] = u\n                match[u] = v\n                return 1\n        return 0\n\n    def bipartiteMatching(self, V):\n        global used\n        global match\n        res = 0\n        match = [-1] * 1500\n        for v in range(V):\n            if match[v] < 0:\n                used = set([])\n                if self.dfs(v):\n                    res += 1\n        return res\n\n    def maxIndependentSet(self, h, w, V):\n        global G\n        G = [[] for _ in range(1500)]\n        for i in range(h):\n            for j in range(w):\n                if mat[i][j] == -1:\n                    continue\n                curr = mat[i][j]\n                for k in range(8):\n                    y = i + dy[k]\n                    x = j + dx[k]\n                    if y < 0 or y >= h or x < 0 or (x >= w) or (mat[y][x] == -1):\n                        continue\n                    G[curr] += [mat[y][x]]\n        maximalIndependentSet = V - self.bipartiteMatching(V)\n        return maximalIndependentSet\n\n    def solve(self, chessboard):\n        global mat\n        V = 0\n        mat = [[0 for _ in range(50)] for _ in range(50)]\n        h = len(chessboard)\n        w = len(chessboard[0])\n        for i in range(h):\n            for j in range(w):\n                if chessboard[i][j] == '.':\n                    V += 1\n                    mat[i][j] = V\n                else:\n                    mat[i][j] = -1\n        return self.maxIndependentSet(h, w, V)\nsolver = Ponies()\nT = int(input())\nwhile T:\n    T -= 1\n    (h, w) = [int(entry) for entry in input().split(' ')]\n    input_mat = []\n    for _ in range(h):\n        row = input()\n        input_mat += [row]\n    print(solver.solve(input_mat))", "import random\ndy = [-2, -1, 1, 2, -2, -1, 1, 2]\ndx = [-1, -2, -2, -1, 1, 2, 2, 1]\n\nclass Ponies:\n    mat = []\n    G = []\n    match = []\n    used = []\n\n    def dfs(self, v):\n        global used\n        used.add(v)\n        for i in range(len(G[v])):\n            u = G[v][i]\n            w = match[u]\n            if w < 0 or (w not in used and self.dfs(w)):\n                match[v] = u\n                match[u] = v\n                return 1\n        return 0\n\n    def bipartiteMatching(self, V):\n        global used\n        global match\n        res = 0\n        match = [-1] * 1500\n        for v in range(V):\n            if match[v] < 0:\n                used = set([])\n                if self.dfs(v):\n                    res += 1\n        return res\n\n    def maxIndependentSet(self, h, w, V):\n        global G\n        G = [[] for _ in range(1500)]\n        for i in range(h):\n            for j in range(w):\n                if mat[i][j] == -1:\n                    continue\n                curr = mat[i][j]\n                for k in range(8):\n                    y = i + dy[k]\n                    x = j + dx[k]\n                    if y < 0 or y >= h or x < 0 or (x >= w) or (mat[y][x] == -1):\n                        continue\n                    G[curr] += [mat[y][x]]\n        maximalIndependentSet = V - self.bipartiteMatching(V)\n        return maximalIndependentSet\n\n    def solve(self, chessboard):\n        global mat\n        V = 0\n        mat = [[0 for _ in range(50)] for _ in range(50)]\n        h = len(chessboard)\n        w = len(chessboard[0])\n        for i in range(h):\n            for j in range(w):\n                if chessboard[i][j] == '.':\n                    V += 1\n                    mat[i][j] = V\n                else:\n                    mat[i][j] = -1\n        return self.maxIndependentSet(h, w, V)\nsolver = Ponies()\nT = int(input())\nwhile T:\n    T -= 1\n    (h, w) = [int(entry) for entry in input().split(' ')]\n    input_mat = []\n    for _ in range(h):\n        row = input()\n        input_mat += [row]\n    print(solver.solve(input_mat))", "import random\ndy = [-2, -1, 1, 2, -2, -1, 1, 2]\ndx = [-1, -2, -2, -1, 1, 2, 2, 1]\n\nclass Ponies:\n    mat = []\n    G = []\n    match = []\n    used = []\n\n    def dfs(self, v):\n        global used\n        used.add(v)\n        for i in range(len(G[v])):\n            u = G[v][i]\n            w = match[u]\n            if w < 0 or (w not in used and self.dfs(w)):\n                match[v] = u\n                match[u] = v\n                return 1\n        return 0\n\n    def bipartiteMatching(self, V):\n        global used\n        global match\n        res = 0\n        match = [-1] * 1500\n        for v in range(V):\n            if match[v] < 0:\n                used = set([])\n                if self.dfs(v):\n                    res += 1\n        return res\n\n    def maxIndependentSet(self, h, w, V):\n        global G\n        G = [[] for _ in range(1500)]\n        for i in range(h):\n            for j in range(w):\n                if mat[i][j] == -1:\n                    continue\n                curr = mat[i][j]\n                for k in range(8):\n                    y = i + dy[k]\n                    x = j + dx[k]\n                    if y < 0 or y >= h or x < 0 or (x >= w) or (mat[y][x] == -1):\n                        continue\n                    G[curr] += [mat[y][x]]\n        maximalIndependentSet = V - self.bipartiteMatching(V)\n        return maximalIndependentSet\n\n    def solve(self, chessboard):\n        global mat\n        V = 0\n        mat = [[0 for _ in range(50)] for _ in range(50)]\n        h = len(chessboard)\n        w = len(chessboard[0])\n        for i in range(h):\n            for j in range(w):\n                if chessboard[i][j] == '.':\n                    V += 1\n                    mat[i][j] = V\n                else:\n                    mat[i][j] = -1\n        return self.maxIndependentSet(h, w, V)\nsolver = Ponies()\nT = int(input())\nwhile T:\n    T -= 1\n    (h, w) = [int(entry) for entry in input().split(' ')]\n    input_mat = []\n    for _ in range(h):\n        row = input()\n        input_mat += [row]\n    print(solver.solve(input_mat))", "dy = [-2, -1, 1, 2, -2, -1, 1, 2]\ndx = [-1, -2, -2, -1, 1, 2, 2, 1]\n\nclass Ponies:\n    mat = []\n    G = []\n    match = []\n    used = []\n\n    def dfs(self, v):\n        global used\n        used[v] = 1\n        for i in range(len(G[v])):\n            u = G[v][i]\n            w = match[u]\n            if w < 0 or (not used[w] and self.dfs(w)):\n                match[v] = u\n                match[u] = v\n                return 1\n        return 0\n\n    def bipartiteMatching(self, V):\n        global used\n        global match\n        res = 0\n        match = [-1] * 1500\n        for v in range(V):\n            if match[v] < 0:\n                used = [0] * 1500\n                if self.dfs(v):\n                    res += 1\n        return res\n\n    def maxIndependentSet(self, h, w, V):\n        global G\n        G = [[] for _ in range(1500)]\n        for i in range(h):\n            for j in range(w):\n                if mat[i][j] == -1:\n                    continue\n                curr = mat[i][j]\n                for k in range(8):\n                    y = i + dy[k]\n                    x = j + dx[k]\n                    if y < 0 or y >= h or x < 0 or (x >= w) or (mat[y][x] == -1):\n                        continue\n                    G[curr] += [mat[y][x]]\n        maximalIndependentSet = V - self.bipartiteMatching(V)\n        return maximalIndependentSet\n\n    def solve(self, chessboard):\n        global mat\n        V = 0\n        mat = [[0 for _ in range(50)] for _ in range(50)]\n        h = len(chessboard)\n        w = len(chessboard[0])\n        for i in range(h):\n            for j in range(w):\n                if chessboard[i][j] == '.':\n                    V += 1\n                    mat[i][j] = V\n                else:\n                    mat[i][j] = -1\n        return self.maxIndependentSet(h, w, V)\nsolver = Ponies()\nT = int(input())\nwhile T:\n    T -= 1\n    (h, w) = [int(entry) for entry in input().split(' ')]\n    input_mat = []\n    for _ in range(h):\n        row = input()\n        input_mat += [row]\n    print(solver.solve(input_mat))", "dy = [-2, -1, 1, 2, -2, -1, 1, 2]\ndx = [-1, -2, -2, -1, 1, 2, 2, 1]\n\nclass Ponies:\n    mat = []\n    G = []\n    match = []\n    used = []\n\n    def dfs(self, v):\n        global used\n        used[v] = 1\n        for i in range(len(G[v])):\n            u = G[v][i]\n            w = match[u]\n            if w < 0 or (not used[w] and self.dfs(w)):\n                match[v] = u\n                match[u] = v\n                return 1\n        return 0\n\n    def bipartiteMatching(self, V):\n        global used\n        global match\n        res = 0\n        match = [-1] * 1500\n        for v in range(V):\n            if match[v] < 0:\n                used = [0] * 1500\n                if self.dfs(v):\n                    res += 1\n        return res\n\n    def maxIndependentSet(self, h, w, V):\n        global G\n        G = [[] for _ in range(1500)]\n        for i in range(h):\n            for j in range(w):\n                if mat[i][j] == -1:\n                    continue\n                curr = mat[i][j]\n                for k in range(8):\n                    y = i + dy[k]\n                    x = j + dx[k]\n                    if y < 0 or y >= h or x < 0 or (x >= w) or (mat[y][x] == -1):\n                        continue\n                    G[curr] += [mat[y][x]]\n        maximalIndependentSet = V - self.bipartiteMatching(V)\n        return maximalIndependentSet\n\n    def solve(self, h, w):\n        global mat\n        V = 0\n        mat = [[0 for _ in range(50)] for _ in range(50)]\n        for i in range(h):\n            row = input()\n            for j in range(w):\n                if row[j] == '.':\n                    V += 1\n                    mat[i][j] = V\n                else:\n                    mat[i][j] = -1\n        return self.maxIndependentSet(h, w, V)\nsolver = Ponies()\nT = int(input())\nwhile T:\n    T -= 1\n    (h, w) = [int(entry) for entry in input().split(' ')]\n    print(solver.solve(h, w))"]