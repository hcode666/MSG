["for _ in range(int(input())):\n    s = list(input())\n    s.sort()\n    n = len(s)\n    s.append('0')\n    l = []\n    (a, c) = (s[0], 1)\n    for i in range(1, n + 1):\n        if s[i] != s[i - 1]:\n            l.append([a, c])\n            (a, c) = (s[i], 1)\n        else:\n            c += 1\n    s1 = ''\n    a = max(l, key=lambda x: x[1])\n    a1 = l.index(a)\n    while len(l) > 1:\n        p = a[:]\n        s1 += p[0]\n        p[1] -= 1\n        del l[a1]\n        a = max(l, key=lambda x: x[1])\n        a1 = l.index(a)\n        if p[1] > 0:\n            l.append(p)\n    if l[0][1] == 1:\n        s1 += l[0][0]\n        print(s1)\n    else:\n        print(-1)", "for _ in range(int(input())):\n    s = list(input())\n    s.sort()\n    n = len(s)\n    s.append('0')\n    l = []\n    (a, c) = (s[0], 1)\n    for i in range(1, n + 1):\n        if s[i] != s[i - 1]:\n            l.append([a, c])\n            (a, c) = (s[i], 1)\n        else:\n            c += 1\n    s1 = ''\n    a = max(l, key=lambda x: x[1])\n    a1 = l.index(a)\n    while len(l) > 1:\n        p = a[:]\n        s1 += p[0]\n        p[1] -= 1\n        del l[a1]\n        a = max(l, key=lambda x: x[1])\n        a1 = l.index(a)\n        if p[1] > 0:\n            l.append(p)\n    if l[0][1] == 1:\n        s1 += l[0][0]\n        print(s1)\n    else:\n        print(-1)", "for _ in range(int(input())):\n    s = list(input())\n    s.sort()\n    n = len(s)\n    s.append('0')\n    l = []\n    (a, c) = (s[0], 1)\n    for i in range(1, n + 1):\n        if s[i] != s[i - 1]:\n            l.append([a, c])\n            (a, c) = (s[i], 1)\n        else:\n            c += 1\n    s1 = ''\n    a = max(l, key=lambda x: x[1])\n    a1 = l.index(a)\n    while len(l) > 1:\n        p = a[:]\n        s1 += p[0]\n        p[1] -= 1\n        del l[a1]\n        a = max(l, key=lambda x: x[1])\n        a1 = l.index(a)\n        if p[1] > 0:\n            l.append(p)\n    if l[0][1] == 1:\n        s1 += l[0][0]\n        print(s1)\n    else:\n        print(-1)", "import heapq\nfor _ in range(int(input())):\n    dic = {}\n    temp = []\n    ans = ''\n    s = input()\n    for i in s:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    heapq.heapify(temp)\n    for i in dic:\n        heapq.heappush(temp, [-dic[i], i])\n    condition = True\n    ny = True\n    useless = ''\n    while condition:\n        if not temp:\n            condition = False\n            continue\n        if temp[0][1] != useless:\n            ans += temp[0][1]\n            useless = temp[0][1]\n            mx = heapq.heappop(temp)\n            if mx[0] != -1:\n                heapq.heappush(temp, [mx[0] + 1, mx[1]])\n            else:\n                heapq.heapify(temp)\n        elif len(temp) > 1:\n            ans += temp[1][1]\n            useless = temp[1][1]\n            mx = temp.pop(1)\n            if mx[0] != -1:\n                heapq.heappush(temp, [mx[0] + 1, mx[1]])\n            else:\n                heapq.heapify(temp)\n        else:\n            ny = False\n            condition = False\n    if ny == True:\n        print(ans)\n    else:\n        print(-1)", "for _ in range(int(input())):\n    s = list(input())\n    s.sort()\n    n = len(s)\n    s.append('0')\n    l = []\n    (a, c) = (s[0], 1)\n    for i in range(1, n + 1):\n        if s[i] != s[i - 1]:\n            l.append([a, c])\n            (a, c) = (s[i], 1)\n        else:\n            c += 1\n    s1 = ''\n    a = max(l, key=lambda x: x[1])\n    a1 = l.index(a)\n    while len(l) > 1:\n        p = a[:]\n        s1 += p[0]\n        p[1] -= 1\n        del l[a1]\n        a = max(l, key=lambda x: x[1])\n        a1 = l.index(a)\n        if p[1] > 0:\n            l.append(p)\n    if l[0][1] == 1:\n        s1 += l[0][0]\n        print(s1)\n    else:\n        print(-1)", "for _ in range(int(input())):\n    s = list(input())\n    s.sort()\n    n = len(s)\n    s.append('0')\n    l = []\n    (a, c) = (s[0], 1)\n    for i in range(1, n + 1):\n        if s[i] != s[i - 1]:\n            l.append([a, c])\n            (a, c) = (s[i], 1)\n        else:\n            c += 1\n    s1 = ''\n    a = max(l, key=lambda x: x[1])\n    a1 = l.index(a)\n    while len(l) > 1:\n        p = a[:]\n        s1 += p[0]\n        p[1] -= 1\n        del l[a1]\n        a = max(l, key=lambda x: x[1])\n        a1 = l.index(a)\n        if p[1] > 0:\n            l.append(p)\n    if l[0][1] == 1:\n        s1 += l[0][0]\n        print(s1)\n    else:\n        print(-1)", "t = int(input())\nfor _ in range(t):\n    s = input()\n    hash = {}\n    yo = ''\n    maxi = -10\n    for i in s:\n        try:\n            hash[i]\n        except:\n            hash[i] = 1\n        else:\n            hash[i] += 1\n    ans = []\n    j = 0\n    for i in hash.keys():\n        ans.append(list(i * hash[i]))\n        j += 1\n    k = []\n    i = 0\n    j = 0\n    count = 0\n    while True:\n        if i < len(ans[j]):\n            k.append(ans[j][i])\n            count += 1\n        if count == len(s):\n            break\n        if j + 1 >= len(ans):\n            j = 0\n            i += 1\n        else:\n            j += 1\n    bo = []\n    ha = 0\n    ka = ''\n    for i in range(len(k) - 1):\n        if k[i] == k[i + 1]:\n            ha = i\n            ka = k[i]\n            break\n    count = len(k[i:])\n    bo = k[:i]\n    yo = []\n    la = 0\n    for i in range(len(bo) - 1):\n        if bo[i] != ka and bo[i + 1] != ka and (la < count):\n            yo.append(bo[i])\n            yo.append(ka)\n            la += 1\n        else:\n            yo.append(bo[i])\n    if bo != []:\n        yo.append(bo[-1])\n        if len(yo) < len(k):\n            if ka != yo[0]:\n                yo.insert(0, ka)\n        if len(yo) < len(k):\n            if ka != yo[-1]:\n                yo.insert(len(yo), ka)\n    flag = 0\n    flag1 = 0\n    for i in range(len(k) - 1):\n        if k[i] != k[i + 1]:\n            continue\n        else:\n            flag = 1\n            break\n    if flag == 1:\n        for i in range(len(yo) - 1):\n            if yo[i] != yo[i + 1]:\n                continue\n            else:\n                flag1 = 1\n                break\n        if flag1 == 1 or len(yo) != len(k):\n            print(-1)\n        else:\n            print(''.join(yo))\n    else:\n        print(''.join(k))", "from heapq import *\nfor _ in range(int(input())):\n    s = input()\n    freq = {}\n    for i in s:\n        freq[i] = freq.get(i, 0) + 1\n    h = []\n    for i in freq:\n        heappush(h, (-freq[i], i))\n    ans = '#'\n    while h:\n        (f, ch) = heappop(h)\n        f = -f\n        if not h:\n            if f > 1 or ans[-1] == ch:\n                ans = -1\n            else:\n                ans += ch\n            break\n        (f2, ch2) = heappop(h)\n        f2 = -f2\n        if ans[-1] == ch:\n            ans += ch2 + ch\n        else:\n            ans += ch + ch2\n        f -= 1\n        f2 -= 1\n        if f > 0:\n            heappush(h, (-f, ch))\n        if f2 > 0:\n            heappush(h, (-f2, ch2))\n    if ans == -1:\n        print(-1)\n    else:\n        print(ans[1:])", "from collections import Counter\nfor _ in range(int(input())):\n    s = input()\n    n = len(s)\n    ct = Counter(s)\n    a = []\n    for (k, v) in ct.most_common():\n        a.extend(k * v)\n    h = (n - 1) // 2 + 1\n    buf = [0] * n\n    p = 0\n    for i in range(0, n, 2):\n        buf[i] = a[p]\n        p += 1\n    for i in range(1, n, 2):\n        buf[i] = a[p]\n        p += 1\n    ok = True\n    for i in range(n - 1):\n        if buf[i] == buf[i + 1]:\n            ok = False\n    print(''.join(buf) if ok else '-1')"]