["def setbit(n):\n    cnt = 0\n    for i in range(32):\n        if n & 1 << i:\n            cnt += 1\n    return cnt\n\ndef power(n):\n    res = 1\n    a = 2\n    while n > 0:\n        if n & 1:\n            res = res * a % 1000000007\n        a = a * a % 1000000007\n        n >>= 1\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    (flag, bit) = (1, 0)\n    for i in range(1, n):\n        if arr[i - 1] & arr[i] == arr[i - 1]:\n            bit += setbit(arr[i - 1])\n        else:\n            flag = 0\n            print(0)\n            break\n    if flag:\n        print(power(bit))", "def setbit(n):\n    cnt = 0\n    for i in range(32):\n        if n & 1 << i:\n            cnt += 1\n    return cnt\n\ndef power(n):\n    res = 1\n    a = 2\n    while n > 0:\n        if n & 1:\n            res = res * a % 1000000007\n        a = a * a % 1000000007\n        n >>= 1\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    (flag, bit) = (1, 0)\n    for i in range(1, n):\n        if arr[i - 1] & arr[i] == arr[i - 1]:\n            bit += setbit(arr[i - 1])\n        else:\n            flag = 0\n            print(0)\n            break\n    if flag:\n        print(power(bit))", "def setbit(n):\n    cnt = 0\n    for i in range(32):\n        if n & 1 << i:\n            cnt += 1\n    return cnt\n\ndef power(n):\n    res = 1\n    a = 2\n    while n > 0:\n        if n & 1:\n            res = res * a % 1000000007\n        a = a * a % 1000000007\n        n >>= 1\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    (flag, bit) = (1, 0)\n    for i in range(1, n):\n        if arr[i - 1] & arr[i] == arr[i - 1]:\n            bit += setbit(arr[i - 1])\n        else:\n            flag = 0\n            print(0)\n            break\n    if flag:\n        print(power(bit))", "def setbit(n):\n    cnt = 0\n    for i in range(32):\n        if n & 1 << i:\n            cnt += 1\n    return cnt\n\ndef power(n):\n    res = 1\n    a = 2\n    while n > 0:\n        if n & 1:\n            res = res * a % 1000000007\n        a = a * a % 1000000007\n        n >>= 1\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    (flag, bit) = (1, 0)\n    for i in range(1, n):\n        if arr[i - 1] & arr[i] == arr[i - 1]:\n            bit += setbit(arr[i - 1])\n        else:\n            flag = 0\n            print(0)\n            break\n    if flag:\n        print(power(bit))", "import math\nfor t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = 10 ** 9 + 7\n    f = 1\n    p = 0\n    for i in range(1, n):\n        x = a[i - 1] & a[i]\n        if x == a[i - 1]:\n            p += bin(a[i - 1]).count('1')\n        else:\n            f = 0\n            break\n    if f == 0:\n        print(f % m)\n    else:\n        print(2 ** p % m)", "import math\nfor t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = 10 ** 9 + 7\n    f = 1\n    p = 0\n    for i in range(1, n):\n        x = a[i - 1] & a[i]\n        if x == a[i - 1]:\n            p += bin(a[i - 1]).count('1')\n        else:\n            f = 0\n            break\n    if f == 0:\n        print(f % m)\n    else:\n        print(2 ** p % m)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    mod = 10 ** 9 + 7\n    ans = 1\n    c = 0\n    for i in range(1, n):\n        x = ar[i] & ar[i - 1]\n        if x == ar[i - 1]:\n            c += bin(ar[i - 1]).count('1')\n        else:\n            ans = 0\n            break\n    if ans == 0:\n        print(ans % mod)\n    else:\n        print(2 ** c % mod)", "import math\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    ar = [int(x) for x in input().split()]\n    mod = 10 ** 9 + 7\n    ans = 1\n    c = 0\n    for i in range(1, n):\n        x = ar[i] & ar[i - 1]\n        if x == ar[i - 1]:\n            c += bin(ar[i - 1]).count('1')\n        else:\n            ans = 0\n            break\n    if ans == 0:\n        print(ans % mod)\n    else:\n        print(2 ** c % mod)", "try:\n    import math\n    for _ in range(int(input())):\n        n = int(input())\n        ar = [int(x) for x in input().split()]\n        mod = 10 ** 9 + 7\n        ans = 1\n        c = 0\n        for i in range(1, n):\n            x = ar[i] & ar[i - 1]\n            if x == ar[i - 1]:\n                c += bin(ar[i - 1]).count('1')\n            else:\n                ans = 0\n                break\n        if ans == 0:\n            print(ans % mod)\n        else:\n            print(2 ** c % mod)\nexcept:\n    pass", "try:\n    import math\n    for _ in range(int(input())):\n        n = int(input())\n        ar = [int(x) for x in input().split()]\n        mod = 10 ** 9 + 7\n        ans = 1\n        c = 0\n        for i in range(1, n):\n            x = ar[i] & ar[i - 1]\n            if x == ar[i - 1]:\n                c += bin(ar[i - 1]).count('1')\n            else:\n                ans = 0\n                break\n        if ans == 0:\n            print(ans % mod)\n        else:\n            print(2 ** c % mod)\nexcept:\n    pass", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    ar = [int(x) for x in input().split()]\n    mod = 10 ** 9 + 7\n    ans = 1\n    c = 0\n    for i in range(1, n):\n        x = ar[i] & ar[i - 1]\n        if x == ar[i - 1]:\n            c += bin(ar[i - 1]).count('1')\n        else:\n            ans = 0\n            break\n    if ans == 0:\n        print(ans % mod)\n    else:\n        print(2 ** c % mod)", "mod = 10 ** 9 + 7\n\ndef pow2(x):\n    (p, n) = (1, 2)\n    while x:\n        if x & 1:\n            p = p % mod * (n % mod) % mod\n        n = n % mod * (n % mod) % mod\n        x //= 2\n    return p\n\ndef count_bit(val):\n    bit = 0\n    while val:\n        bit += 1\n        val &= val - 1\n    return bit\n\ndef answer():\n    val = b[0]\n    po2 = 0\n    for i in range(1, len(b)):\n        if val > b[i]:\n            return 0\n        po2 += count_bit(val & b[i])\n        val = b[i]\n    return pow2(po2) % mod\nfor T in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    print(answer())", "mod = 10 ** 9 + 7\n\ndef pow2(x):\n    (p, n) = (1, 2)\n    while x:\n        if x & 1:\n            p = p % mod * (n % mod) % mod\n        n = n % mod * (n % mod) % mod\n        x //= 2\n    return p\n\ndef count_bit(val):\n    bit = 0\n    for i in range(30):\n        if val >> i & 1:\n            bit += 1\n    return bit\n\ndef answer():\n    val = b[0]\n    po2 = 0\n    for i in range(1, len(b)):\n        if val > b[i]:\n            return 0\n        po2 += count_bit(val & b[i])\n        val = b[i]\n    return pow2(po2) % mod\nfor T in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    print(answer())", "def solve(lis, n):\n    cnt = 0\n    for i in range(1, n):\n        val = lis[i] & lis[i - 1]\n        if val != lis[i - 1]:\n            return -1\n        for i in range(32):\n            if 1 << i & val > 0:\n                cnt += 1\n    return 2 ** cnt % mod\nfor t in range(int(input())):\n    n = int(input())\n    lis = list(map(int, input().split()))\n    mod = int(1000000000.0) + 7\n    ans = solve(lis, n)\n    print(0 if ans == -1 else ans)", "def solve(lis, n):\n    cnt = 0\n    for i in range(1, n):\n        val = lis[i] & lis[i - 1]\n        if val != lis[i - 1]:\n            return -1\n        cnt += bin(val).count('1')\n    return 2 ** cnt % mod\nfor t in range(int(input())):\n    n = int(input())\n    lis = list(map(int, input().split()))\n    mod = int(1000000000.0) + 7\n    ans = solve(lis, n)\n    print(0 if ans == -1 else ans)", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    c = 0\n    a = 1\n    for i in range(1, n):\n        p = l[i - 1] & l[i]\n        if p != l[i - 1]:\n            a = 0\n            break\n        else:\n            c += bin(p).count('1')\n    if a == 0:\n        print(0)\n    else:\n        print(2 ** c % (10 ** 9 + 7))", "t = int(input())\nmod = pow(10, 9) + 7\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    b = [int(x) for x in input().split()]\n    bprev = b[0]\n    ans = 1\n    for i in range(1, n):\n        if bin(~b[i] & b[i - 1]).count('1'):\n            ans = 0\n            break\n        ans += bin(b[i] & b[i - 1]).count('1')\n    if ans == 0:\n        print(ans)\n    else:\n        ans -= 1\n        print(2 ** ans % 1000000007)", "def bi(n):\n    count = 0\n    while n:\n        count += 1\n        n = n & n - 1\n    return count\nt = int(input())\nfor q in range(t):\n    n = int(input())\n    b = list(map(int, input().split()))\n    ans = 1\n    mod = 10 ** 9 + 7\n    end = 0\n    for i in range(1, n):\n        if b[i] | b[i - 1] != b[i]:\n            end = 1\n            print(0)\n            break\n        else:\n            k = bi(b[i] & b[i - 1])\n            ans = ans * 2 ** k % mod\n    if end == 0:\n        print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    c = 0\n    for i in range(1, n):\n        p = a[i - 1] & a[i]\n        if p != a[i - 1]:\n            c = 0\n            break\n        else:\n            c += bin(p).count('1')\n    if c == 0:\n        print(c)\n    else:\n        print(2 ** c % (10 ** 9 + 7))", "import sys\nsys.setrecursionlimit(10 ** 3)\nimport math\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    p = 0\n    c = 0\n    flag = 0\n    mod = 10 ** 9 + 7\n    for i in range(1, len(l)):\n        if l[i - 1] > l[i]:\n            flag = 1\n            break\n        p += list(bin(l[i] & l[i - 1])[2:]).count('1')\n    if flag == 1:\n        print(0)\n        continue\n    t_2 = pow(2, p, mod)\n    print(t_2)", "import sys\nsys.setrecursionlimit(10 ** 3)\nimport math\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    p = 0\n    c = 0\n    flag = 0\n    mod = 10 ** 9 + 7\n    for i in range(len(l) - 1):\n        t_1 = list(bin(l[i])[2:]).count('1')\n        if c <= t_1:\n            c = t_1\n        else:\n            flag = 1\n        p += t_1\n    if flag == 1:\n        print(0)\n        continue\n    t_2 = pow(2, p, mod)\n    print(t_2)", "import sys\nsys.setrecursionlimit(10 ** 3)\n\ndef fast_expo(n):\n    mod = 10 ** 9 + 7\n    if n == 1:\n        return 2\n    x = fast_expo(n // 2) % mod\n    if n % 2 == 0:\n        return x * x % (10 ** 9 + 7)\n    else:\n        return x * x * 2 % (10 ** 9 + 7)\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    p = 0\n    c = 0\n    flag = 0\n    mod = 10 ** 9 + 7\n    for i in range(len(l) - 1):\n        t_1 = list(bin(l[i])[2:]).count('1')\n        if c <= t_1:\n            c = t_1\n        else:\n            flag = 1\n        p += t_1\n    if flag == 1:\n        print(0)\n        continue\n    t_2 = fast_expo(p) % mod\n    print(t_2)", "m = pow(10, 9) + 7\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = 1\n    f = a[0]\n    for i in range(1, n):\n        p = f\n        q = a[i]\n        g = p & q\n        if g != p:\n            c = 0\n            break\n        f = a[i]\n        c = c * pow(2, bin(g)[2:].count('1')) % m\n    print(c)\n    t = t - 1", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    str1 = input().split(' ')\n    a = [int(num) for num in str1]\n    sum1 = 1\n    M = 1000000007\n    count = 0\n    for i in range(0, len(a) - 1, 1):\n        if bin(a[i] & ~a[i + 1]).count('1') > 0:\n            count = -1\n            break\n        count += bin(a[i] & a[i + 1]).count('1')\n    if count == -1:\n        sum1 = 0\n    else:\n        sum1 = 2 ** count % M\n    print(sum1)", "test = int(input())\nfor _ in range(test):\n    n = int(input())\n    a = list([int(j) for j in input().split()])\n    count = 1\n    res = 1\n    if n > 1:\n        for j in range(n - 1):\n            if a[j + 1] | a[j] > a[j + 1]:\n                res = 0\n                break\n            x = str(bin(a[j + 1])[2:]).count('1')\n            y = str(bin(a[j + 1] - a[j])[2:]).count('1')\n            count *= pow(2, x - y, 1000000007)\n            count %= 1000000007\n    if res == 0:\n        print(0 % 1000000007)\n    else:\n        print(count % 1000000007)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list([int(j) for j in input().split()])\n    count = 1\n    res = 1\n    if n > 1:\n        for j in range(n - 1):\n            if a[j + 1] | a[j] > a[j + 1]:\n                res = 0\n                break\n            x = str(bin(a[j + 1])[2:]).count('1')\n            y = str(bin(a[j + 1] - a[j])[2:]).count('1')\n            count *= pow(2, x - y, 1000000007)\n            count %= 1000000007\n    if res == 0:\n        print(0 % 1000000007)\n    else:\n        print(count % 1000000007)", "for afskafshjd in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    count = 0\n    flag = 0\n    for i in range(1, n):\n        if b[i] < b[i - 1]:\n            flag = 1\n            break\n        x = bin(b[i] & b[i - 1])\n        count = count + x.count('1')\n    if flag == 1:\n        print('0')\n        continue\n    print(pow(2, count, 10 ** 9 + 7))", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list([int(j) for j in input().split()])\n    count = 1\n    res = 1\n    if n > 1:\n        for j in range(n - 1):\n            if a[j + 1] | a[j] > a[j + 1]:\n                res = 0\n                break\n            x = str(bin(a[j + 1])[2:]).count('1')\n            y = str(bin(a[j + 1] - a[j])[2:]).count('1')\n            count *= pow(2, x - y, 1000000007)\n            count %= 1000000007\n    if res == 0:\n        print(0 % 1000000007)\n    else:\n        print(count % 1000000007)", "M = 1000000007\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    l = [int(i) for i in input().split()]\n    count1 = 0\n    for i in range(1, n):\n        if l[i - 1] & l[i] != l[i - 1]:\n            count1 = 0\n            break\n        else:\n            count1 += bin(l[i - 1] & l[i]).count('1')\n    if count1 == 0:\n        print(count1)\n    else:\n        print(2 ** count1 % M)", "m = pow(10, 9) + 7\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    t = 1\n    y = 0\n    for i in range(n - 1):\n        if l[i] <= l[i + 1] and l[i] & l[i + 1] == l[i]:\n            y = y + bin(l[i]).count('1')\n        else:\n            t = 0\n            break\n    t = t * pow(2, y, m) % m\n    print(t % m)", "m = pow(10, 9) + 7\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    t = 1\n    for i in range(n - 1):\n        if l[i] <= l[i + 1] and l[i] & l[i + 1] == l[i]:\n            y = bin(l[i]).count('1')\n            t = t * pow(2, y, m) % m\n        else:\n            t = 0\n            break\n    print(t % m)", "def solve(n, b):\n    for i in range(n - 1):\n        if b[i] & b[i + 1] != b[i]:\n            print(0)\n            return\n    x = 0\n    for i in range(n - 1):\n        x += bin(b[i]).count('1')\n    ans = 1\n    while x:\n        if x > 30:\n            ans *= twopow[30]\n            ans %= mod\n            x -= 30\n        else:\n            ans *= twopow[x]\n            ans %= mod\n            x = 0\n    print(ans % mod)\nmod = 10 ** 9 + 7\ntwopow = {x: (1 << x) % mod for x in range(35)}\nfor _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    solve(n, b)", "def solve(n, b):\n    for i in range(n - 1):\n        if b[i] & b[i + 1] != b[i]:\n            print(0)\n            return\n    x = 0\n    for i in range(n - 1):\n        x += bin(b[i]).count('1')\n    print(pow(2, x, mod))\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    solve(n, b)", "def solve(n, b):\n    for i in range(n - 1):\n        if b[i] & b[i + 1] != b[i]:\n            print(0)\n            return\n    x = 0\n    for i in range(n - 1):\n        x += bin(b[i]).count('1')\n    print(str((1 << x) % mod))\nmod = 10 ** 9 + 7\ntwopow = {x: pow(2, x) % mod for x in range(35)}\nfor _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    solve(n, b)", "def get_num_of_ones(x):\n    c = 0\n    while x:\n        x &= x - 1\n        c += 1\n    return c\nmod = 10 ** 9 + 7\ntwopow = {x: pow(2, x) % mod for x in range(35)}\nfor _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    ones_in_prev = 0\n    ones_in_current = 0\n    ans = 1\n    flag = True\n    ones_in_current = get_num_of_ones(b[0])\n    ones_in_prev = ones_in_current\n    for i in range(1, n):\n        ans *= twopow[ones_in_prev]\n        ans %= mod\n        ones_in_current = get_num_of_ones(b[i])\n        ones_in_prev = ones_in_current\n        if b[i] < b[i - 1]:\n            flag = False\n            break\n    if flag:\n        print(ans % mod)\n    else:\n        print(0)", "def get_num_of_ones(x):\n    c = 0\n    while x:\n        if x & 1:\n            c += 1\n        x >>= 1\n    return c\nmod = 10 ** 9 + 7\ntwopow = {x: pow(2, x) % mod for x in range(35)}\nfor _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    ones_in_prev = 0\n    ones_in_current = 0\n    ans = 1\n    flag = True\n    ones_in_current = get_num_of_ones(b[0])\n    ones_in_prev = ones_in_current\n    for i in range(1, n):\n        ans *= twopow[ones_in_prev]\n        ans %= mod\n        ones_in_current = get_num_of_ones(b[i])\n        ones_in_prev = ones_in_current\n        if b[i] < b[i - 1]:\n            flag = False\n            break\n    if flag:\n        print(ans % mod)\n    else:\n        print(0)", "def get_num_of_ones(x):\n    c = 0\n    while x:\n        if x & 1:\n            c += 1\n        x >>= 1\n    return c\nmod = 10 ** 9 + 7\ntwopow = {x: pow(2, x) % mod for x in range(35)}\nfor _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    ones_in_prev = 0\n    ones_in_current = 0\n    ans = 1\n    flag = True\n    for i in range(n):\n        if i == 0:\n            ones_in_current = get_num_of_ones(b[0])\n            ones_in_prev = ones_in_current\n        else:\n            ans *= twopow[ones_in_prev]\n            ans %= mod\n            ones_in_current = get_num_of_ones(b[i])\n            ones_in_prev = ones_in_current\n            if b[i] < b[i - 1]:\n                flag = False\n                break\n    if flag:\n        print(ans % mod)\n    else:\n        print(0)", "def get_num_of_ones(x):\n    c = 0\n    while x:\n        if x & 1:\n            c += 1\n        x >>= 1\n    return c\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    ones_in_prev = 0\n    ones_in_current = 0\n    ans = 1\n    flag = True\n    for i in range(n):\n        if i == 0:\n            ones_in_current = get_num_of_ones(b[0])\n            ones_in_prev = ones_in_current\n        else:\n            ans *= pow(2, ones_in_prev) % mod\n            ans %= mod\n            ones_in_current = get_num_of_ones(b[i])\n            ones_in_prev = ones_in_current\n            if b[i] < b[i - 1]:\n                flag = False\n                break\n    if flag:\n        print(ans % mod)\n    else:\n        print(0)", "mod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    N = int(input())\n    arr = list(map(int, input().split()))\n    setb = lambda x: bin(x).count('1')\n    ans = 1\n    mult = []\n    for i in range(1, N):\n        if arr[i] & arr[i - 1] != arr[i - 1]:\n            mult.clear()\n            break\n        mult.append(setb(arr[i] & arr[i - 1]))\n    ans = pow(2, sum(mult), mod)\n    if not mult:\n        print(0)\n    else:\n        print(ans)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    d = [int(i) for i in input().split()]\n    a = [bin(i) for i in d]\n    count = 1\n    mod = 10 ** 9 + 7\n    for i in range(1, n):\n        c = a[i - 1].count('1')\n        count *= pow(2, c, mod)\n        count = count % mod\n    flag = 0\n    for i in range(1, n):\n        if d[i - 1] | d[i] != d[i]:\n            flag = 1\n            print(0)\n            break\n    if flag == 0:\n        print(count)", "m = 10 ** 9 + 7\n\ndef cs(n, count):\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\nfor _ in range(int(input())):\n    (n, b, a) = (int(input()), list(map(int, input().split())), 1)\n    for i in range(1, n):\n        if b[i] & b[i - 1] == b[i - 1]:\n            a = a * int(pow(2, cs(b[i - 1], 0))) % m\n        else:\n            a = 0\n            break\n    print(a)", "t = int(input())\nwhile t > 0:\n    N = int(input())\n    B = list(map(int, input().split()))\n    k = 0\n    for i in range(len(B) - 1):\n        if bin(B[i] & ~B[i + 1]).count('1') > 0:\n            k = -1\n            break\n        k += bin(B[i] & B[i + 1]).count('1')\n    if k == -1:\n        print(0)\n    else:\n        k = 2 ** k % 1000000007\n        print(k)\n    t -= 1", "from sys import stdin\n\ndef power(b, p, m):\n    if p == 0:\n        return 1\n    else:\n        x = power(b, p // 2, m) % m\n        x = x * x % m\n        if p % 2 == 0:\n            return x % m\n        else:\n            return x * b % m\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    s = 0\n    flag = False\n    for i in range(1, n):\n        if bin(arr[i - 1]).count('1') > bin(arr[i]).count('1'):\n            print('0')\n            flag = True\n            break\n        s += bin(arr[i - 1]).count('1')\n    if not flag:\n        print(power(2, s, 1000000007))", "import sys\nt = int(sys.stdin.readline())\nwhile t:\n    t -= 1\n    count = 0\n    n = int(input())\n    arr = list(map(int, sys.stdin.readline().split()))\n    for i in range(len(arr) - 1):\n        if bin(arr[i] & arr[i + 1]) != bin(arr[i]):\n            count = -1\n            break\n        count += bin(arr[i] & arr[i + 1]).count('1')\n    if count == -1:\n        print(0)\n    else:\n        print(2 ** count % 1000000007)", "import sys\nt = int(sys.stdin.readline())\nwhile t:\n    t -= 1\n    count = 0\n    n = int(input())\n    arr = list(map(int, sys.stdin.readline().split()))\n    for i in range(len(arr) - 1):\n        if bin(arr[i] & ~arr[i + 1]).count('1') > 0:\n            count = -1\n            break\n        count += bin(arr[i] & arr[i + 1]).count('1')\n    if count == -1:\n        print(0)\n    else:\n        print(2 ** count % 1000000007)", "const = 10 ** 9 + 7\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    ans = 1\n    Bi = list(map(int, input().split()))\n    for i in range(N - 1):\n        if str(bin(Bi[i])).count('1') - str(bin(Bi[i + 1])).count('1') > 0:\n            ans = 0\n            break\n        ans += str(bin(Bi[i])).count('1')\n    if ans != 0:\n        ans = 2 ** (ans - 1) % const\n    print(ans)", "const = 10 ** 9 + 7\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    ans = 1\n    Bi = list(map(int, input().split()))\n    for i in range(N - 1):\n        if str(bin(Bi[i])).count('1') - str(bin(Bi[i + 1])).count('1') > 0:\n            ans = 0\n            break\n        ans = ans % const * pow(2, str(bin(Bi[i])).count('1')) % const % const\n    print(ans)", "import math\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    b = list(map(int, input().split()))\n    m = 1000000007\n    p = 1\n    flag = 0\n    for j in range(n - 1):\n        if b[j + 1] | b[j] > max(b[j], b[j + 1]):\n            p = 0\n            break\n        s = bin(b[j]).count('1')\n        p = p * pow(2, s, m) % m\n    print(p)", "m = 1000000007\nfor t in range(int(input())):\n    n = int(input())\n    B = list(map(int, input().split()))\n    if B != sorted(B):\n        print(0)\n    else:\n        freq = [B[i] & B[i + 1] for i in range(n - 1)]\n        p = 0\n        for b in freq:\n            b = bin(b)\n            p += b.count('1')\n        print(pow(2, p, m))", "import sys\nm = 1000000000.0 + 7\n\ndef countSetBits(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    ans = 1\n    flag = 0\n    for i in range(n - 1):\n        if nums[i] > nums[i + 1]:\n            flag = 1\n            break\n        ans = ans % m * pow(2, countSetBits(nums[i])) % m % m\n    if flag:\n        print(0)\n    else:\n        print(int(ans))", "t = int(input())\n\ndef bitcount(n):\n    count = 0\n    while n > 0:\n        count = count + 1\n        n = n & n - 1\n    return count\n\ndef exponent(a, b, modi):\n    if b == 0:\n        return 1\n    elif b == 1:\n        return a % modi\n    else:\n        r = exponent(a, b // 2, modi)\n        if b % 2 == 0:\n            return r * r % modi\n        else:\n            return r * r % modi * a % modi\nwhile t > 0:\n    n = int(input())\n    x = input().split()\n    count = 0\n    r = -1\n    old = 0\n    flag = 0\n    for i in range(len(x) - 1):\n        old = r\n        r = bitcount(int(x[i]))\n        if old > r:\n            flag = -1\n            break\n        count += r\n    if flag == 0:\n        modi = 1000000007\n        ans = exponent(2, count, modi)\n        print(ans)\n    else:\n        print('0')\n    t -= 1", "import sys\nm = 1000000000.0 + 7\n\ndef countSetBits(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    ans = 1\n    flag = 0\n    for i in range(n - 1):\n        if nums[i] > nums[i + 1]:\n            flag = 1\n            break\n        ans = ans % m * pow(2, countSetBits(nums[i])) % m % m\n    if flag:\n        print(0)\n    else:\n        print(int(ans))", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = 1\n    d = 0\n    for i in range(n - 1):\n        if l[i] & l[i + 1] != l[i]:\n            print(0)\n            d = 1\n            break\n    if d == 1:\n        continue\n    c = 0\n    for i in l:\n        c += bin(i)[2:].count('1')\n    c -= bin(i)[2:].count('1')\n    print(2 ** c % 1000000007)", "def cb(n):\n    c = 0\n    while n:\n        if n & 1:\n            c += 1\n        n >>= 1\n    return c\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = 1\n    d = 0\n    for i in range(n - 1):\n        if l[i] & l[i + 1] != l[i]:\n            print(0)\n            d = 1\n            break\n    if d == 1:\n        continue\n    c = 0\n    for i in l:\n        c += cb(i)\n    c -= cb(l[n - 1])\n    print(2 ** c % 1000000007)", "import sys\nT = int(sys.stdin.readline())\nfor _ in range(T):\n    N = int(sys.stdin.readline())\n    B = list(map(int, sys.stdin.readline().split()))\n    k = 0\n    for i in range(len(B) - 1):\n        if bin(B[i] & ~B[i + 1]).count('1') > 0:\n            k = -1\n            break\n        k += bin(B[i] & B[i + 1]).count('1')\n    if k == -1:\n        print(0)\n    else:\n        print(2 ** k % 1000000007)", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    b = list(map(int, input().split()))\n    ans = 1\n    for i in range(n - 1):\n        if b[i] > b[i + 1]:\n            ans = 0\n            break\n        ans = ans * (1 << bin(b[i]).count('1')) % (10 ** 9 + 7)\n    print(ans % (10 ** 9 + 7))\n    t = t - 1", "M = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    count = 0\n    f = 0\n    for i in range(1, n):\n        if l[i] < l[i - 1]:\n            f = 1\n            break\n        x = bin(l[i] & l[i - 1])\n        count = count + x.count('1')\n    if f:\n        print('0')\n        continue\n    print(2 ** count % M)", "M = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    count = 0\n    f = 0\n    for i in range(1, n):\n        if l[i] < l[i - 1]:\n            f = 1\n            break\n        x = bin(l[i] & l[i - 1])\n        count = count + x.count('1')\n    if f:\n        print('0')\n        continue\n    print(2 ** count % M)", "def c(s):\n    r = 0\n    while s > 0:\n        if s & 1 == 1:\n            r += 1\n        s >>= 1\n    return r\nb = [1] * 40\nfor i in range(1, 40):\n    b[i] = b[i - 1] * 2 % 1000000007\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = a[0]\n    p = 1\n    for i in range(1, n):\n        if ~a[i] & s > 0:\n            p = 0\n            break\n        m = c(s)\n        p *= b[m]\n        p %= 1000000007\n        s = s | a[i]\n    print(p)", "for _ in range(int(input())):\n    N = int(input())\n    array = list(map(int, input().split()))\n    ans = 1\n    Binary = [bin(array[0]).count('1')]\n    for i in range(1, N):\n        T = array[i]\n        a = array[i - 1]\n        Binary.append(bin(array[i]).count('1'))\n        test = bin(T & a).count('1')\n        if Binary[i - 1] > test:\n            ans = 0\n            break\n        ans = ans * (2 ** test % (10 ** 9 + 7)) % (10 ** 9 + 7)\n    print(ans)", "for afskafshjd in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    count = 0\n    flag = 0\n    for i in range(1, n):\n        if b[i] < b[i - 1]:\n            flag = 1\n            break\n        x = bin(b[i] & b[i - 1])\n        count = count + x.count('1')\n    if flag == 1:\n        print('0')\n        continue\n    print(pow(2, count, 10 ** 9 + 7))", "def countSetBits(N):\n    count = 0\n    while N:\n        N &= N - 1\n        count += 1\n    return count\n\ndef main():\n    T = int(input())\n    mod = int(1000000000.0 + 7)\n    for _ in range(T):\n        N = int(input())\n        B = list(map(int, input().split()))\n        ans = 1\n        for i in range(N):\n            if i > 0 and B[i] & B[i - 1] != B[i - 1]:\n                ans = 0\n                break\n            if i <= N - 2:\n                ans = ans % mod * (pow(2, countSetBits(B[i]), mod) % mod) % mod\n        print(ans)\nmain()", "import sys\nreadline = lambda : map(int, sys.stdin.readline().split(' '))\n(T,) = readline()\nfor _ in range(T):\n    (N,) = readline()\n    B = list(readline())\n    A0 = B[0]\n    B1 = None\n    setbits = 0\n    no = False\n    for j in range(1, N):\n        B1 = B[j]\n        if A0 & ~B1 > 0:\n            print(0)\n            no = True\n            break\n        else:\n            setbits += bin(A0 & B1).count('1')\n        A0 = B[j]\n    if no:\n        pass\n    else:\n        print((1 << setbits) % 1000000007)", "from sys import stdin\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    flag = 0\n    c = 0\n    arr = list(map(int, stdin.readline().split()))\n    for i in range(n - 1):\n        if bin(arr[i] & ~arr[i + 1]).count('1') > 0:\n            flag = 1\n            break\n        c += bin(arr[i] & arr[i + 1]).count('1')\n    if flag == 1:\n        print('0')\n    else:\n        print(2 ** c % 1000000007)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    bl = list(map(int, input().split()))\n    agg = 0\n    flag = True\n    for i in range(n - 1):\n        if bl[i] ^ bl[i + 1] > bl[i + 1]:\n            flag = False\n            break\n        temp = '{0:b}'.format(bl[i])\n        agg += temp.count('1')\n    if flag:\n        agg = 2 ** agg\n        print(agg % 1000000007)\n    else:\n        print(0)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    bl = list(map(int, input().split()))\n    agg = 0\n    flag = True\n    for i in range(n - 1):\n        if bl[i] ^ bl[i + 1] > bl[i + 1]:\n            flag = False\n            break\n        temp = '{0:b}'.format(bl[i])\n        agg += temp.count('1')\n    if flag:\n        agg = 2 ** agg\n        print(agg % 1000000007)\n    else:\n        print(0)", "def power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef countSetBits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    po = 0\n    a = list(map(int, input().split()))\n    valid = True\n    for i in range(n - 1):\n        if a[i] & a[i + 1] != a[i]:\n            print(0)\n            valid = False\n            break\n    if not valid:\n        continue\n    for i in range(n - 1):\n        po += countSetBits(a[i] & a[i + 1])\n    print(power(2, po, 1000000007))", "t = int(input())\nwhile t:\n    n = int(input())\n    bArr = [int(x) for x in input().split()]\n    valid = True\n    for i in range(1, len(bArr)):\n        if bArr[i] & bArr[i - 1] != bArr[i - 1]:\n            valid = False\n    if not valid:\n        print(0)\n        t -= 1\n        continue\n    mod = 10 ** 9 + 7\n    total_ways = 1\n    for i in range(1, len(bArr)):\n        setbitsCount = bin(bArr[i - 1]).count('1')\n        total_ways = total_ways * pow(2, setbitsCount, mod) % mod\n    print(total_ways % mod)\n    t -= 1", "t = int(input())\nwhile t:\n    n = int(input())\n    bArr = [int(x) for x in input().split()]\n    mod = 10 ** 9 + 7\n    total_ways = 1\n    validation = True\n    for i in range(1, len(bArr)):\n        if bArr[i] & bArr[i - 1] == bArr[i - 1]:\n            setbitsCount = bin(bArr[i - 1]).count('1')\n            total_ways = total_ways * pow(2, setbitsCount, mod) % mod\n        else:\n            validation = False\n            break\n    if not validation:\n        print(0)\n        t -= 1\n        continue\n    else:\n        print(total_ways % mod)\n        t -= 1", "def countSetBits(n):\n    total = 0\n    while n:\n        total += n & 1\n        n = n >> 1\n    return total\n\ndef totalWays(bArr, n):\n    valid = True\n    for i in range(1, len(bArr)):\n        if bArr[i] & bArr[i - 1] != bArr[i - 1]:\n            valid = False\n    if not valid:\n        return 0\n    mod = int(1000000000.0 + 7)\n    total_ways = 1\n    for i in range(1, len(bArr)):\n        setbits = countSetBits(bArr[i - 1])\n        total_ways *= pow(2, setbits, mod)\n        total_ways %= mod\n    return total_ways % mod\n\ndef main():\n    t = int(input())\n    while t:\n        n = int(input())\n        bArr = [int(x) for x in input().split()]\n        print(totalWays(bArr, n))\n        t -= 1\nmain()", "t = int(input())\nwhile t:\n    n = int(input())\n    bArr = [int(x) for x in input().split()]\n    valid = True\n    for i in range(1, len(bArr)):\n        if bArr[i] & bArr[i - 1] != bArr[i - 1]:\n            valid = False\n    if not valid:\n        print(0)\n        t -= 1\n        continue\n    mod = 10 ** 9 + 7\n    total_ways = 1\n    for i in range(1, len(bArr)):\n        setbitsCount = bin(bArr[i - 1]).count('1')\n        total_ways = total_ways * pow(2, setbitsCount, mod) % mod\n    print(total_ways % mod)\n    t -= 1", "m = 10 ** 9\nm += 7\n\ndef calc(i):\n    a = 0\n    while i > 0:\n        q = i % 2\n        a += q\n        i = i // 2\n    return a\nfor tst in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    ans = 1\n    for k in range(n - 1):\n        if a[k] & a[k + 1] == a[k]:\n            kk = calc(a[k])\n            ans = ans * 2 ** kk % m\n        else:\n            ans = 0\n            break\n    print(ans)", "for i in range(int(input())):\n    n = int(input())\n    sum1 = 1\n    l = list(map(int, input().split()))\n    for i in range(1, n):\n        z = l[i] & l[i - 1]\n        str1 = bin(z).replace('0b', '')\n        cnt1 = str1.count('1')\n        if l[i] | l[i - 1] > l[i]:\n            sum1 = 0\n            break\n        cnt1 = 1 << cnt1\n        cnt1 = cnt1 % 1000000007\n        sum1 = sum1 * cnt1\n        sum1 = sum1 % 1000000007\n    print(sum1)", "for i in range(int(input())):\n    n = int(input())\n    sum1 = 1\n    l = list(map(int, input().split()))\n    for i in range(1, n):\n        z = l[i] & l[i - 1]\n        str1 = bin(z).replace('0b', '')\n        cnt1 = str1.count('1')\n        if l[i] | l[i - 1] > l[i]:\n            sum1 = 0\n            break\n        sum1 = sum1 * 2 ** cnt1\n        sum1 = sum1 % 1000000007\n    print(sum1)", "T = int(input())\nmod = 10 ** 9 + 7\nfor z in range(T):\n    N = int(input())\n    arr = [int(x) for x in input().split()]\n    count = 1\n    flag = False\n    for i in range(1, N):\n        if arr[i] | arr[i - 1] > arr[i]:\n            flag = True\n            break\n        count_1 = bin(arr[i - 1]).count('1')\n        count = count * 2 ** count_1 % mod\n    if flag == True:\n        print(0)\n    else:\n        print(count)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    falg = 1\n    s = [int(x) for x in input().split()]\n    sum = 0\n    for i in range(1, len(s)):\n        if s[i - 1] & s[i] != s[i - 1]:\n            falg = 0\n            break\n        else:\n            sum += bin(s[i - 1] & s[i]).count('1')\n    if falg != 0:\n        print(pow(2, sum, 1000000007))\n    else:\n        print(0)", "def check(n):\n    c = 0\n    while n != 0:\n        c += 1\n        n = n & n - 1\n    return pow(2, c)\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    m = 1\n    mod = 1000000007\n    f = 0\n    f1 = 0\n    for i in range(n - 1):\n        if l[i] & l[i + 1] != l[i]:\n            f1 = 1\n            break\n        c1 = check(l[i])\n        m = m % mod * (c1 % mod) % mod\n    if f1 == 1:\n        print(0)\n    else:\n        print(m)", "mod = 1000000007\ntc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    b = list(map(int, input().split()))\n    count = 0\n    for i in range(1, n):\n        if b[i - 1] & b[i] == b[i - 1]:\n            count += bin(b[i - 1]).count('1')\n        else:\n            print(0)\n            break\n    else:\n        ans = 2 ** count % mod\n        print(ans)", "mod = 10 ** 9 + 7\n\ndef check_0(a, b):\n    if a > b:\n        return False\n    else:\n        a = bin(a)[2:]\n        b = bin(b)[2:]\n        a = '0' * (len(b) - len(a)) + a\n        b1 = True\n        for x in range(len(b)):\n            if b[x] == '0':\n                if a[x] == '1':\n                    b1 = False\n                    break\n        return b1\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = 1\n    b = True\n    for i in range(1, n):\n        if not check_0(arr[i - 1], arr[i]):\n            b = False\n            print(0)\n            break\n        else:\n            ones = bin(arr[i] & arr[i - 1]).count('1')\n            prod = 2 ** ones % mod\n            ans = ans % mod * prod % mod\n    if b:\n        print(ans)", "import sys\nreadline = lambda : map(int, sys.stdin.readline().split(' '))\n(T,) = readline()\nfor _ in range(T):\n    (N,) = readline()\n    B = list(readline())\n    A0 = B[0]\n    B1 = None\n    setbits = 0\n    no = False\n    for j in range(1, N):\n        B1 = B[j]\n        if A0 & ~B1 > 0:\n            print(0)\n            no = True\n            break\n        else:\n            setbits += bin(A0 & B1).count('1')\n        A0 = B[j]\n    if no:\n        pass\n    else:\n        print(2 ** setbits % 1000000007)", "import sys\nreadline = lambda : map(int, sys.stdin.readline().split(' '))\n(T,) = readline()\nfor _ in range(T):\n    (N,) = readline()\n    B = list(readline())\n    A0 = B[0]\n    B1 = None\n    setbits = 0\n    no = False\n    for j in range(1, N):\n        B1 = B[j]\n        if A0 & ~B1 > 0:\n            print(0)\n            no = True\n            break\n        else:\n            setbits += bin(A0 & B1).count('1')\n        A0 = B[j]\n    if no:\n        pass\n    else:\n        print(2 ** setbits % 1000000007)", "import sys\nf = sys.stdin\nreadline = lambda : map(int, f.readline().rstrip().split(' '))\n(T,) = readline()\nfor i in range(T):\n    (N,) = readline()\n    B = list(readline())\n    ans = 0\n    impossible = False\n    for i in range(len(B) - 1):\n        ans += bin(B[i] & B[i + 1]).count('1')\n        if bin(B[i] & ~B[i + 1]).count('1') > 0:\n            impossible = True\n    ans = 2 ** ans % 1000000007\n    print(0 if impossible else ans)", "def no_of_ones(x):\n    exp = 0\n    for ele in bin(x)[2:]:\n        if ele == '1':\n            exp += 1\n    return exp\nfor i in range(int(input())):\n    size = int(input())\n    arr = [int(i) for i in input().split()]\n    result = 0\n    ans = 1\n    for i in range(size - 1):\n        result += no_of_ones(arr[i])\n    poss = True\n    for i in range(size - 1):\n        if arr[i] & arr[i + 1] != arr[i]:\n            poss = False\n            break\n    print(pow(2, result, 1000000007) if poss else 0)", "import sys\n\ndef finp():\n    return sys.stdin.readline()\n\ndef fop(s):\n    return sys.stdout.write(str(s) + '\\n')\n\ndef fintinp():\n    return int(sys.stdin.readline())\n\ndef flistintinp():\n    return list(map(int, finp().split()))\n\ndef op(s):\n    return s\n\ndef inp():\n    return input()\n\ndef intop(s):\n    return int(s)\n\ndef intinp():\n    return int(input())\n\ndef listintinp():\n    return list(map(int, inp().split()))\n\ndef listinp():\n    return list(map(str, inp().split()))\nimport math\nprimelists = []\nmaxprecomprimeval = 100001\nfrom math import ceil, sqrt\nmysievelists = [i for i in range(maxprecomprimeval)]\n\ndef primeprecomputer():\n    for i in range(2, math.ceil(math.sqrt(maxprecomprimeval))):\n        if mysievelists[i] == i:\n            for j in range(i * i, maxprecomprimeval, i):\n                if mysievelists[j] == j:\n                    mysievelists[j] = i\n    for i in range(2, maxprecomprimeval):\n        if mysievelists[i] == i:\n            primelists.append(mysievelists[i])\n    return primelists\nfrom bisect import bisect_right, bisect_left\n\ndef bisectright(lists, nbr):\n    return bisect_right(lists, nbr)\n\ndef bisectleft(lists, nbr):\n    return bisect_left(lists, nbr)\nMOD = 1000000007\nmpflists = []\n\ndef mpf(n):\n    k = 0\n    primeprecomputer()\n    while n != 1:\n        print(mysievelists[n])\n        mpflists.append(mysievelists[n])\n        n //= mysievelists[n]\n        k += 1\n    return mpflists\nfor __ in range(intinp()):\n    n = intinp()\n    lists = flistintinp()\n    v = 0\n    set = 0\n    for i in range(1, n):\n        if lists[i] < lists[i - 1]:\n            set = 1\n            break\n        val = bin(lists[i] & lists[i - 1])\n        v = v + val.count('1')\n    if set == 1:\n        print('0')\n    else:\n        print(pow(2, v, MOD))", "import sys\n\ndef finp():\n    return sys.stdin.readline()\n\ndef fop(s):\n    return sys.stdout.write(str(s) + '\\n')\n\ndef fintinp():\n    return int(sys.stdin.readline())\n\ndef flistintinp():\n    return list(map(int, finp().split()))\n\ndef op(s):\n    return s\n\ndef inp():\n    return input()\n\ndef intop(s):\n    return int(s)\n\ndef intinp():\n    return int(input())\n\ndef listintinp():\n    return list(map(int, inp().split()))\n\ndef listinp():\n    return list(map(str, inp().split()))\nimport math\nprimelists = []\nmaxprecomprimeval = 100001\nfrom math import ceil, sqrt\nmysievelists = [i for i in range(maxprecomprimeval)]\n\ndef primeprecomputer():\n    for i in range(2, math.ceil(math.sqrt(maxprecomprimeval))):\n        if mysievelists[i] == i:\n            for j in range(i * i, maxprecomprimeval, i):\n                if mysievelists[j] == j:\n                    mysievelists[j] = i\n    for i in range(2, maxprecomprimeval):\n        if mysievelists[i] == i:\n            primelists.append(mysievelists[i])\n    return primelists\nfrom bisect import bisect_right, bisect_left\n\ndef bisectright(lists, nbr):\n    return bisect_right(lists, nbr)\n\ndef bisectleft(lists, nbr):\n    return bisect_left(lists, nbr)\nMOD = 100000007\nmpflists = []\n\ndef mpf(n):\n    k = 0\n    primeprecomputer()\n    while n != 1:\n        print(mysievelists[n])\n        mpflists.append(mysievelists[n])\n        n //= mysievelists[n]\n        k += 1\n    return mpflists\nfor __ in range(intinp()):\n    n = intinp()\n    lists = flistintinp()\n    v = 0\n    set = 0\n    for i in range(1, n):\n        if lists[i] < lists[i - 1]:\n            set = 1\n            break\n        val = bin(lists[i] & lists[i - 1])\n        v = v + val.count('1')\n    if set == 1:\n        print('0')\n    else:\n        print(pow(2, v, 10 ** 9 + 7))", "for _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    count = 0\n    flag = 0\n    for i in range(1, n):\n        if b[i] < b[i - 1]:\n            flag = 1\n            break\n        x = bin(b[i] & b[i - 1])\n        count = count + x.count('1')\n    if flag == 1:\n        print('0')\n    else:\n        print(pow(2, count, 10 ** 9 + 7))", "from sys import stdin, stdout\n\ndef result(arr):\n    M = 10 ** 9 + 7\n    for i in range(n - 1):\n        if arr[i] & arr[i + 1] != arr[i]:\n            return 0\n    c = 0\n    for i in range(n):\n        c += bin(arr[i]).count('1')\n    c -= bin(arr[-1]).count('1')\n    ans = 2 ** (c % M) % M\n    return ans\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    print(result(arr))", "for _ in range(int(input())):\n    n = int(input())\n    x = list(map(int, input().split()))\n    k = 0\n    p = int(1000000000.0 + 7)\n    for i in range(n - 1):\n        if bin(x[i] & ~x[i + 1]).count('1') > 0:\n            k = -1\n            break\n        else:\n            k += bin(x[i]).count('1')\n    if k == -1:\n        print(0)\n    else:\n        print(pow(2, k, p))"]