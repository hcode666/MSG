["from sys import stdin, stdout\nimport math\nimport resource, sys\nresource.setrlimit(resource.RLIMIT_STACK, (2 ** 29, -1))\nsys.setrecursionlimit(10 ** 6)\nfrom collections import defaultdict, deque\nimport bisect\n\ndef devgraph(l, n, ok):\n    l = [0] + l\n    d = defaultdict(list)\n    if ok:\n        (a, b, q, c) = (2, n + 1, deque([1]), 1)\n    else:\n        (a, b, q, c) = (n, 0, deque([n]), -1)\n    for i in range(a, b, c):\n        while len(q) and l[q[-1]] <= l[i]:\n            q.pop()\n        if len(q) and l[q[-1]] > l[i]:\n            d[q[-1]].append(i)\n        q.append(i)\n    return d\n\ndef dfs1(node, d, end):\n    if node == end:\n        return cost[node]\n    elif node < end:\n        return -1\n    ans = -1\n    for x in d[node]:\n        if x != node and x >= end:\n            z = dfs1(x, d, end)\n            if z != -1:\n                ans = z + cost[node]\n    return ans\n\ndef dfs2(node, d, end):\n    if node == end:\n        return cost[node]\n    elif node > end:\n        return -1\n    ans = -1\n    for x in d[node]:\n        if x != node and x <= end:\n            z = dfs2(x, d, end)\n            if z != -1:\n                ans = z + cost[node]\n    return ans\n\nclass Segmenttree:\n    (st, n) = ([], 0)\n\n    def __init__(self, n, l):\n        self.st = [0] * (2 * n)\n        self.n = n\n        for i in range(n):\n            self.st[i + n] = l[i]\n        for i in range(n - 1, 0, -1):\n            self.st[i] = self.st[i << 1] + self.st[i << 1 | 1]\n\n    def update(self, p, val):\n        self.st[p + self.n] = val\n        p += self.n\n        while p > 1:\n            self.st[p >> 1] = self.st[p] + self.st[p ^ 1]\n            p >>= 1\n\n    def query(self, l, r):\n        (l, r) = (l + self.n, r + self.n)\n        res = 0\n        while l < r:\n            if l & 1:\n                res += self.st[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                res += self.st[r]\n            l >>= 1\n            r >>= 1\n        return res\n\ndef dfs(node, d, seg, cnt, visit):\n    cnt[-1] += 1\n    visit[node] = True\n    seg[node][0] = cnt[-1]\n    for x in d[node]:\n        if visit[x] == False:\n            dfs(x, d, seg, cnt, visit)\n    cnt[-1] += 1\n    seg[node][1] = cnt[-1]\n\ndef main():\n    try:\n        (n, nQ) = In()\n        l = list(In())\n        global cost\n        cost = [0] + list(In())\n        right = devgraph(l, n, 1)\n        left = devgraph(l, n, 0)\n        right[0] = list(right.keys())\n        left[0] = list(left.keys())\n        upd1 = [[0, 0] for x in range(n + 1)]\n        visit = [False for x in range(n + 1)]\n        dfs(0, right, upd1, [-1], visit)\n        seg1 = [0] * (2 * (n + 1) + 1)\n        for x in range(1, n + 1):\n            co = cost[x]\n            seg1[upd1[x][0]] += co\n            seg1[upd1[x][1]] -= co\n        upd2 = [[0, 0] for x in range(n + 1)]\n        visit = [False for x in range(n + 1)]\n        dfs(0, left, upd2, [-1], visit)\n        seg2 = [0] * (2 * (n + 1) + 1)\n        for x in range(1, n + 1):\n            co = cost[x]\n            seg2[upd2[x][0]] += co\n            seg2[upd2[x][1]] -= co\n        Sg1 = Segmenttree(len(seg1), seg1)\n        Sg2 = Segmenttree(len(seg2), seg2)\n        for i in range(nQ):\n            (a, b, c) = In()\n            if a == 2:\n                if c < b and upd2[b][0] < upd2[c][0] and (upd2[b][1] > upd2[c][1]):\n                    (st, end) = (upd2[b][0], upd2[c][0])\n                    su = 0\n                    print(Sg2.query(st, end + 1))\n                elif b < c and upd1[b][0] < upd1[c][0] and (upd1[b][1] > upd1[c][1]):\n                    (st, end) = (upd1[b][0], upd1[c][0])\n                    su = 0\n                    print(Sg1.query(st, end + 1))\n                elif b == c:\n                    print(cost[b])\n                else:\n                    print(-1)\n            else:\n                co = cost[b]\n                Sg1.update(upd1[b][0], -co)\n                Sg2.update(upd2[b][0], -co)\n                Sg1.update(upd1[b][1], +co)\n                Sg2.update(upd2[b][1], +co)\n                cost[b] = c\n                co = cost[b]\n                Sg1.update(upd1[b][0], +co)\n                Sg2.update(upd2[b][0], +co)\n                Sg1.update(upd1[b][1], -co)\n                Sg2.update(upd2[b][1], -co)\n    except:\n        pass\n\ndef add(a, b, c):\n    res = a + b\n    if res >= c:\n        return res - c\n    else:\n        return res\n\ndef mod(a, b, c):\n    res = a * b\n    if res >= c:\n        return res % c\n    else:\n        return res\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    w = a // gcd(a, b)\n    return w * b\n\ndef expo(a, b):\n    (x, y) = (1, a)\n    while b > 0:\n        if b & 1:\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\n\ndef power(a, b, m):\n    (x, y) = (1,)\n    while b > 0:\n        if b & 1:\n            x = mod(x, y, m)\n        y = mod(y, y, m)\n        b >>= 1\n    return x\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\nmain()", "from sys import stdin, stdout\nimport math\nimport resource, sys\nresource.setrlimit(resource.RLIMIT_STACK, (2 ** 29, -1))\nsys.setrecursionlimit(10 ** 6)\nfrom collections import defaultdict, deque\nimport bisect\n\ndef devgraph(l, n, ok):\n    l = [0] + l\n    d = defaultdict(list)\n    if ok:\n        (a, b, q, c) = (2, n + 1, deque([1]), 1)\n    else:\n        (a, b, q, c) = (n, 0, deque([n]), -1)\n    for i in range(a, b, c):\n        while len(q) and l[q[-1]] <= l[i]:\n            q.pop()\n        if len(q) and l[q[-1]] > l[i]:\n            d[q[-1]].append(i)\n        q.append(i)\n    return d\n\ndef dfs1(node, d, end):\n    if node == end:\n        return cost[node]\n    elif node < end:\n        return -1\n    ans = -1\n    for x in d[node]:\n        if x != node and x >= end:\n            z = dfs1(x, d, end)\n            if z != -1:\n                ans = z + cost[node]\n    return ans\n\ndef dfs2(node, d, end):\n    if node == end:\n        return cost[node]\n    elif node > end:\n        return -1\n    ans = -1\n    for x in d[node]:\n        if x != node and x <= end:\n            z = dfs2(x, d, end)\n            if z != -1:\n                ans = z + cost[node]\n    return ans\n\nclass Segmenttree:\n    (st, n) = ([], 0)\n\n    def __init__(self, n, l):\n        self.st = [0] * (2 * n)\n        self.n = n\n        for i in range(n):\n            self.st[i + n] = l[i]\n        for i in range(n - 1, 0, -1):\n            self.st[i] = self.st[i << 1] + self.st[i << 1 | 1]\n\n    def update(self, p, val):\n        self.st[p + self.n] = val\n        p += self.n\n        while p > 1:\n            self.st[p >> 1] = self.st[p] + self.st[p ^ 1]\n            p >>= 1\n\n    def query(self, l, r):\n        (l, r) = (l + self.n, r + self.n)\n        res = 0\n        while l < r:\n            if l & 1:\n                res += self.st[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                res += self.st[r]\n            l >>= 1\n            r >>= 1\n        return res\n\ndef dfs(node, d, seg, cnt, visit):\n    cnt[-1] += 1\n    visit[node] = True\n    seg[node][0] = cnt[-1]\n    for x in d[node]:\n        if visit[x] == False:\n            dfs(x, d, seg, cnt, visit)\n    cnt[-1] += 1\n    seg[node][1] = cnt[-1]\n\ndef main():\n    try:\n        (n, nQ) = In()\n        l = list(In())\n        global cost\n        cost = [0] + list(In())\n        right = devgraph(l, n, 1)\n        left = devgraph(l, n, 0)\n        right[0] = list(right.keys())\n        left[0] = list(left.keys())\n        upd1 = [[0, 0] for x in range(n + 1)]\n        visit = [False for x in range(n + 1)]\n        dfs(0, right, upd1, [-1], visit)\n        seg1 = [0] * (2 * (n + 1) + 1)\n        for x in range(1, n + 1):\n            co = cost[x]\n            seg1[upd1[x][0]] += co\n            seg1[upd1[x][1]] -= co\n        upd2 = [[0, 0] for x in range(n + 1)]\n        visit = [False for x in range(n + 1)]\n        dfs(0, left, upd2, [-1], visit)\n        seg2 = [0] * (2 * (n + 1) + 1)\n        for x in range(1, n + 1):\n            co = cost[x]\n            seg2[upd2[x][0]] += co\n            seg2[upd2[x][1]] -= co\n        Sg1 = Segmenttree(len(seg1), seg1)\n        Sg2 = Segmenttree(len(seg2), seg2)\n        for i in range(nQ):\n            (a, b, c) = In()\n            if a == 2:\n                if c < b and upd2[b][0] < upd2[c][0] and (upd2[b][1] > upd2[c][1]):\n                    (st, end) = (upd2[b][0], upd2[c][0])\n                    su = 0\n                    print(Sg2.query(st, end + 1))\n                elif b < c and upd1[b][0] < upd1[c][0] and (upd1[b][1] > upd1[c][1]):\n                    (st, end) = (upd1[b][0], upd1[c][0])\n                    su = 0\n                    print(Sg1.query(st, end + 1))\n                elif b == c:\n                    print(cost[b])\n                else:\n                    print(-1)\n            else:\n                co = cost[b]\n                Sg1.update(upd1[b][0], -co)\n                Sg2.update(upd2[b][0], -co)\n                Sg1.update(upd1[b][1], +co)\n                Sg2.update(upd2[b][1], +co)\n                cost[b] = c\n                co = cost[b]\n                Sg1.update(upd1[b][0], +co)\n                Sg2.update(upd2[b][0], +co)\n                Sg1.update(upd1[b][1], -co)\n                Sg2.update(upd2[b][1], -co)\n    except:\n        pass\n\ndef add(a, b, c):\n    res = a + b\n    if res >= c:\n        return res - c\n    else:\n        return res\n\ndef mod(a, b, c):\n    res = a * b\n    if res >= c:\n        return res % c\n    else:\n        return res\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    w = a // gcd(a, b)\n    return w * b\n\ndef expo(a, b):\n    (x, y) = (1, a)\n    while b > 0:\n        if b & 1:\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\n\ndef power(a, b, m):\n    (x, y) = (1,)\n    while b > 0:\n        if b & 1:\n            x = mod(x, y, m)\n        y = mod(y, y, m)\n        b >>= 1\n    return x\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\nmain()", "N = 2 * 10 ** 5 + 10\nMAX = 10 ** 18\nheight = [MAX] * N\nvalue = [0] * N\nlft_high = [0] * N\nrgt_high = [0] * N\naux_lft = [0] * N\naux_rgt = [0] * N\n(n, q) = (0, 0)\n\nclass FenwickTree:\n\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def update(self, x, d):\n        while x <= self.n:\n            self.bit[x] += d\n            x += x & -x\n\n    def query(self, x):\n        res = 0\n        while x > 0:\n            res += self.bit[x]\n            x -= x & -x\n        return res\n\n    def range_query(self, l, r):\n        return self.query(r) - self.query(l - 1)\nt1 = FenwickTree(N)\nt2 = FenwickTree(N)\nt3 = FenwickTree(N)\n\ndef precompute_left():\n    stack = [0]\n    for i in range(1, n + 1):\n        while height[stack[-1]] < height[i]:\n            stack.pop()\n        lft_high[i] = stack[-1]\n        aux_lft[stack[-1]] -= value[i]\n        stack.append(i)\n\ndef precompute_right():\n    stack = [n + 1]\n    for i in range(n, 0, -1):\n        while height[stack[-1]] < height[i]:\n            stack.pop()\n        rgt_high[i] = stack[-1]\n        aux_rgt[stack[-1]] -= value[i]\n        stack.append(i)\n\ndef update(b, k):\n    diff = k - value[b]\n    t1.update(b, diff)\n    if lft_high[b] > 0:\n        t2.update(lft_high[b], -diff)\n    if rgt_high[b] > 0:\n        t3.update(rgt_high[b], -diff)\n    value[b] = k\n    aux_lft[lft_high[b]] -= diff\n    aux_rgt[rgt_high[b]] -= diff\n\ndef query_left(x, y):\n    if lft_high[x] >= y:\n        return -1\n    ans = t1.range_query(y, x) + t2.range_query(y, x)\n    return ans - aux_lft[x]\n\ndef query_right(x, y):\n    if rgt_high[x] <= y:\n        return -1\n    ans = t1.range_query(x, y) + t3.range_query(x, y)\n    return ans - aux_rgt[x]\n\ndef query(x, y):\n    if x == y:\n        return value[x]\n    elif x > y:\n        return query_left(x, y)\n    else:\n        return query_right(x, y)\n(n, q) = map(int, input().split())\nh = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nfor i in range(n):\n    height[i + 1] = h[i]\n    value[i + 1] = a[i]\nprecompute_left()\nprecompute_right()\nfor i in range(1, N):\n    t1.update(i, value[i])\n    t2.update(i, aux_lft[i])\n    t3.update(i, aux_rgt[i])\nfor i in range(q):\n    (t, x, y) = map(int, input().split())\n    if t == 1:\n        update(x, y)\n    else:\n        print(query(x, y))", "N = 2 * 10 ** 5 + 10\nMAX = 10 ** 18\nheight = [MAX] * N\nvalue = [0] * N\nlft_high = [0] * N\nrgt_high = [0] * N\naux_lft = [0] * N\naux_rgt = [0] * N\n(n, q) = (0, 0)\n\nclass FenwickTree:\n\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def update(self, x, d):\n        while x <= self.n:\n            self.bit[x] += d\n            x += x & -x\n\n    def query(self, x):\n        res = 0\n        while x > 0:\n            res += self.bit[x]\n            x -= x & -x\n        return res\n\n    def range_query(self, l, r):\n        return self.query(r) - self.query(l - 1)\nt1 = FenwickTree(N)\nt2 = FenwickTree(N)\nt3 = FenwickTree(N)\n\ndef precompute_left():\n    stack = [0]\n    for i in range(1, n + 1):\n        while height[stack[-1]] < height[i]:\n            stack.pop()\n        lft_high[i] = stack[-1]\n        aux_lft[stack[-1]] -= value[i]\n        stack.append(i)\n\ndef precompute_right():\n    stack = [n + 1]\n    for i in range(n, 0, -1):\n        while height[stack[-1]] < height[i]:\n            stack.pop()\n        rgt_high[i] = stack[-1]\n        aux_rgt[stack[-1]] -= value[i]\n        stack.append(i)\n\ndef update(b, k):\n    diff = k - value[b]\n    t1.update(b, diff)\n    if lft_high[b] > 0:\n        t2.update(lft_high[b], -diff)\n    if rgt_high[b] > 0:\n        t3.update(rgt_high[b], -diff)\n    value[b] = k\n    aux_lft[lft_high[b]] -= diff\n    aux_rgt[rgt_high[b]] -= diff\n\ndef query_left(x, y):\n    if lft_high[x] >= y:\n        return -1\n    ans = t1.range_query(y, x) + t2.range_query(y, x)\n    return ans - aux_lft[x]\n\ndef query_right(x, y):\n    if rgt_high[x] <= y:\n        return -1\n    ans = t1.range_query(x, y) + t3.range_query(x, y)\n    return ans - aux_rgt[x]\n\ndef query(x, y):\n    if x == y:\n        return value[x]\n    elif x > y:\n        return query_left(x, y)\n    else:\n        return query_right(x, y)\n(n, q) = map(int, input().split())\nh = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nfor i in range(n):\n    height[i + 1] = h[i]\n    value[i + 1] = a[i]\nprecompute_left()\nprecompute_right()\nfor i in range(1, N):\n    t1.update(i, value[i])\n    t2.update(i, aux_lft[i])\n    t3.update(i, aux_rgt[i])\nfor i in range(q):\n    (t, x, y) = map(int, input().split())\n    if t == 1:\n        update(x, y)\n    else:\n        print(query(x, y))", "(n, q) = map(int, input('').split())\nh = list(map(int, input('').split()))\na = list(map(int, input('').split()))\n\ndef solve1():\n    (right_sum, left_sum) = ([0] * n, [0] * n)\n    (right, left) = ([n] * n, [-1] * n)\n    tree1 = [0] * (2 * n)\n    tree2 = [0] * (2 * n)\n    B1 = [0] * n\n    B2 = [0] * n\n    taste = a[:]\n\n    def update1(p, value):\n        tree1[p + n] = value\n        p = p + n\n        i = p\n        while i > 1:\n            tree1[i >> 1] = tree1[i] + tree1[i ^ 1]\n            i >>= 1\n\n    def query1(l, r):\n        res = 0\n        l += n\n        r += n\n        while l < r:\n            if l & 1:\n                res += tree1[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                res += tree1[r]\n            l >>= 1\n            r >>= 1\n        return res\n\n    def update2(p, value):\n        tree2[p + n] = value\n        p = p + n\n        i = p\n        while i > 1:\n            tree2[i >> 1] = tree2[i] + tree2[i ^ 1]\n            i >>= 1\n\n    def query2(l, r):\n        res = 0\n        l += n\n        r += n\n        while l < r:\n            if l & 1:\n                res += tree2[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                res += tree2[r]\n            l >>= 1\n            r >>= 1\n        return res\n    great = dict()\n    stack1 = []\n    for i in range(0, n):\n        great[i] = [-1, n]\n        left_sum[i] = a[i]\n        while stack1 and h[stack1[-1]] <= h[i]:\n            great[stack1[-1]] = [-1, i]\n            stack1.pop()\n        if stack1:\n            left_sum[i] += left_sum[stack1[-1]]\n        stack1.append(i)\n    stack1 = []\n    for i in range(n - 1, -1, -1):\n        right_sum[i] = a[i]\n        while stack1 and h[stack1[-1]] <= h[i]:\n            great[stack1[-1]][0] = i\n            stack1.pop()\n        if stack1:\n            right_sum[i] += right_sum[stack1[-1]]\n        stack1.append(i)\n    stack1 = []\n    for i in range(n - 1, -1, -1):\n        while stack1 and h[stack1[-1]] < h[i]:\n            stack1.pop()\n        if stack1:\n            right[i] = stack1[-1]\n        stack1.append(i)\n    stack1 = []\n    for i in range(0, n):\n        while stack1 and h[stack1[-1]] < h[i]:\n            stack1.pop()\n        if stack1:\n            left[i] = stack1[-1]\n        stack1.append(i)\n    for i in range(q):\n        (x, y, z) = map(int, input('').split())\n        if x == 1:\n            diff = z - a[y - 1]\n            a[y - 1] = z\n            y -= 1\n            prev = great[y]\n            B1[y] += diff\n            B2[y] += diff\n            if prev[1] != n:\n                B1[prev[1]] -= diff\n                update1(prev[1], B1[prev[1]])\n            if prev[0] != -1:\n                B2[prev[0]] -= diff\n                update2(prev[0], B2[prev[0]])\n            update1(y, B1[y])\n            update2(y, B2[y])\n        else:\n            y -= 1\n            z -= 1\n            if y == z:\n                print(a[y])\n            elif h[z] >= h[y]:\n                print(-1)\n            elif abs(y - z) == 1:\n                print(a[y] + a[z])\n            elif z < y:\n                diff1 = query2(y, n)\n                diff2 = query2(z, n)\n                if z <= left[y]:\n                    print(-1)\n                else:\n                    print(right_sum[z] + diff2 - diff1 - right_sum[y] + a[y])\n            else:\n                diff1 = query1(0, y + 1)\n                diff2 = query1(0, z + 1)\n                if z >= right[y]:\n                    print(-1)\n                else:\n                    print(left_sum[z] + diff2 - diff1 - left_sum[y] + a[y])\nsolve1()", "from sys import stdin, stdout\nfrom math import gcd, ceil, sqrt\nfrom collections import Counter\nfrom bisect import bisect_left, bisect_right\nii1 = lambda : int(stdin.readline().strip())\nis1 = lambda : stdin.readline().strip()\niia = lambda : list(map(int, stdin.readline().strip().split()))\nisa = lambda : stdin.readline().strip().split()\nmod = 1000000007\n\ndef getsum(tree, index):\n    res = 0\n    index = index + 1\n    while index > 0:\n        res += tree[index]\n        index -= index & -index\n    return res\n\ndef update(tree, ind, n, val):\n    ind += 1\n    while ind <= n:\n        tree[ind] += val\n        ind += ind & -ind\n\ndef makeFenwickTree(arr):\n    tree = [0] * (len(arr) + 1)\n    for i in range(len(arr)):\n        update(tree, i, len(arr), arr[i])\n    return tree\n\ndef getArrays(h, p, first=False):\n    (prefix, postfix) = ([0] * n, [0] * n)\n    stack = []\n    (left, right) = ({}, {})\n    for i in range(n):\n        prefix[i] = p[i]\n        while len(stack) and h[stack[-1]] <= h[i]:\n            left[stack[-1]] = i\n            prefix[i] -= p[stack[-1]]\n            stack.pop()\n        stack.append(i)\n    stack = []\n    for i in range(n)[::-1]:\n        postfix[i] = p[i]\n        while len(stack) and h[stack[-1]] <= h[i]:\n            right[stack[-1]] = i\n            postfix[i] -= p[stack[-1]]\n            stack.pop()\n        stack.append(i)\n    if first:\n        return [prefix, postfix, left, right]\n    else:\n        return [prefix, postfix]\n(n, q) = iia()\nh = iia()\np = iia()\n(prefix, postfix, left, right) = getArrays(h, p, True)\npreTree = makeFenwickTree(prefix)\npostTree = makeFenwickTree(postfix[::-1])\nfor i in range(q):\n    t = iia()\n    if t[0] == 1:\n        chg = t[2] - p[t[1] - 1]\n        p[t[1] - 1] = t[2]\n        update(preTree, t[1] - 1, len(prefix), chg)\n        update(postTree, n - t[1], len(postfix), chg)\n        if t[1] - 1 in right:\n            update(postTree, n - right[t[1] - 1] - 1, len(postfix), -chg)\n        if t[1] - 1 in left:\n            update(preTree, left[t[1] - 1], len(prefix), -chg)\n    else:\n        (a, b) = (t[1] - 1, t[2] - 1)\n        if a == b:\n            print(p[a])\n        elif a > b and right.get(a, float('-inf')) < b:\n            asum = getsum(postTree, n - a - 1)\n            bsum = getsum(postTree, n - b - 1)\n            print(bsum - asum + p[a])\n        elif b > a and left.get(a, float('inf')) > b:\n            asum = getsum(preTree, a)\n            bsum = getsum(preTree, b)\n            print(bsum - asum + p[a])\n        else:\n            print(-1)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\ndef inp_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef inp_int():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef dfsl(tree_left, root, epl, visl):\n    for i in range(len(tree_left[root])):\n        if visl[tree_left[root][i]] == False:\n            visl[tree_left[root][i]] = True\n            epl.append(tree_left[root][i])\n            dfsl(tree_left, tree_left[root][i], epl, visl)\n            epl.append(-tree_left[root][i])\n\ndef euler_left(h, n):\n    stack_left = []\n    for i in range(1, n + 1):\n        if len(stack_left) == 0:\n            stack_left.append((h[i], i))\n        else:\n            while len(stack_left) != 0 and stack_left[-1][0] <= h[i]:\n                stack_left.pop()\n            if len(stack_left) != 0:\n                tree_left[i].append(stack_left[-1][1])\n                tree_left[stack_left[-1][1]].append(i)\n            stack_left.append((h[i], i))\n    visl = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if visl[i] == False:\n            epl.append(i)\n            visl[i] = True\n            dfsl(tree_left, i, epl, visl)\n            epl.append(-i)\n    epl.insert(0, -1)\n    for i in range(1, len(epl)):\n        if epl[i] > 0:\n            entry_left[epl[i]] = i\n            update_left(i, tasty[epl[i]])\n        else:\n            exit_left[-epl[i]] = i\n            update_left(i, -tasty[-epl[i]])\n\ndef euler_right(h, n):\n    tree_right = defaultdict(list)\n    stack_right = []\n    for i in range(n, 0, -1):\n        if len(stack_right) == 0:\n            stack_right.append((h[i], i))\n        else:\n            while len(stack_right) != 0 and stack_right[-1][0] <= h[i]:\n                stack_right.pop()\n            if len(stack_right) != 0:\n                tree_right[i].append(stack_right[-1][1])\n                tree_right[stack_right[-1][1]].append(i)\n            stack_right.append((h[i], i))\n    visr = [False] * (n + 1)\n    for i in range(n, 0, -1):\n        if visr[i] == False:\n            epr.append(i)\n            visr[i] = True\n            dfsl(tree_right, i, epr, visr)\n            epr.append(-i)\n    epr.insert(0, -1)\n    for i in range(1, len(epr)):\n        if epr[i] > 0:\n            entry_right[epr[i]] = i\n            update_right(i, tasty[epr[i]])\n        else:\n            exit_right[-epr[i]] = i\n            update_right(i, -tasty[-epr[i]])\n\ndef update_left(pos, val):\n    while pos <= 2 * n:\n        fenwick_left[pos] = fenwick_left[pos] + val\n        pos = pos + (pos & -pos)\n\ndef sum_left(pos):\n    ans = 0\n    while pos > 0:\n        ans = ans + fenwick_left[pos]\n        pos = pos - (pos & -pos)\n    return ans\n\ndef update_right(pos, val):\n    while pos <= 2 * n:\n        fenwick_right[pos] = fenwick_right[pos] + val\n        pos = pos + (pos & -pos)\n\ndef sum_right(pos):\n    ans = 0\n    while pos > 0:\n        ans = ans + fenwick_right[pos]\n        pos = pos - (pos & -pos)\n    return ans\nepl = []\nepr = []\ntree_left = defaultdict(list)\ntree_right = defaultdict(list)\n(n, q) = inp_int()\nh = inp_list()\ntasty = inp_list()\nentry_left = [0] * (n + 1)\nexit_left = [0] * (n + 1)\nentry_right = [0] * (n + 1)\nexit_right = [0] * (n + 1)\nfenwick_left = [0] * (2 * n + 5)\nfenwick_right = [0] * (2 * n + 5)\nh.insert(0, 0)\ntasty.insert(0, 0)\neuler_left(h, n)\neuler_right(h, n)\nfor _ in range(q):\n    inp = inp_list()\n    op = inp[0]\n    so = inp[1]\n    des = inp[2]\n    if op == 1:\n        update_left(entry_left[so], des - tasty[so])\n        update_left(exit_left[so], -(des - tasty[so]))\n        update_right(entry_right[so], des - tasty[so])\n        update_right(exit_right[so], -(des - tasty[so]))\n        tasty[so] = des\n    if op == 2:\n        res = -1\n        if so == des:\n            sys.stdout.write(str(tasty[so]))\n            print()\n        else:\n            if so < des and entry_left[so] < entry_left[des] and (exit_left[so] > exit_left[des]):\n                res = sum_left(entry_left[des]) - sum_left(entry_left[so] - 1)\n            elif so > des and entry_right[so] < entry_right[des] and (exit_right[so] > exit_right[des]):\n                res = sum_right(entry_right[des]) - sum_right(entry_right[so] - 1)\n            sys.stdout.write(str(res))\n            print()", "def update_tree(i, n, a, Tree):\n    while i < n:\n        Tree[i] += a\n        i |= i + 1\n\ndef get_sum_tree(i, Tree):\n    sum1 = 0\n    while i >= 0:\n        sum1 += Tree[i]\n        i &= i + 1\n        i -= 1\n    return sum1\n\ndef get_cost(l, r):\n    if h[l] <= h[r]:\n        return -1\n    elif right_arr[l] <= r:\n        return -1\n    else:\n        if flag:\n            y = cost[l]\n            total = get_sum_tree(r, left_tree) - get_sum_tree(l, left_tree) + y\n        else:\n            total = sum_left_arr[r] - sum_left_arr[l] + cost[l]\n        return total\n\ndef rev_get_cost(l, r):\n    if h[l] <= h[r]:\n        return -1\n    elif left_arr[l] >= r:\n        return -1\n    else:\n        if flag:\n            y = cost[l]\n            total = get_sum_tree(r, right_tree) - get_sum_tree(l, right_tree) + y\n        else:\n            total = sum_right_arr[l] - sum_right_arr[r] + cost[r]\n        return total\n(n, q) = map(int, input().split())\nh = list(map(int, input().split()))\ncost = list(map(int, input().split()))\nstack = []\nleft_arr = [-1] * n\nsum_left_arr = [0] * n\ns_len = 0\nfor i in range(n):\n    while s_len > 0:\n        if h[i] >= h[stack[-1]]:\n            if left_arr[i] == -1 and h[i] == h[stack[-1]]:\n                left_arr[i] = stack[-1]\n            stack.pop(-1)\n            s_len -= 1\n        else:\n            if left_arr[i] == -1:\n                left_arr[i] = stack[-1]\n            sum_left_arr[i] = sum_left_arr[stack[-1]] + cost[i]\n            stack.append(i)\n            s_len += 1\n            break\n    if s_len == 0:\n        sum_left_arr[i] = cost[i]\n        stack.append(i)\n        s_len += 1\nleft_tree = [0] * 1000000\nupdate_tree(0, n, sum_left_arr[0], left_tree)\nfor i in range(1, n):\n    update_tree(i, n, sum_left_arr[i] - sum_left_arr[i - 1], left_tree)\nstack = []\nright_arr = [n] * n\nsum_right_arr = [0] * n\ns_len = 0\nfor i in range(n - 1, -1, -1):\n    while s_len > 0:\n        if h[stack[-1]] <= h[i]:\n            if right_arr[i] == n and h[i] == h[stack[-1]]:\n                right_arr[i] = stack[-1]\n            stack.pop(-1)\n            s_len -= 1\n        else:\n            if right_arr[i] == n:\n                right_arr[i] = stack[-1]\n            sum_right_arr[i] = sum_right_arr[stack[-1]] + cost[i]\n            stack.append(i)\n            s_len += 1\n            break\n    if s_len == 0:\n        sum_right_arr[i] = cost[i]\n        stack.append(i)\n        s_len += 1\nright_tree = [0] * 1000000\nupdate_tree(0, n, sum_right_arr[0], right_tree)\nfor i in range(1, n):\n    update_tree(i, n, sum_right_arr[i] - sum_right_arr[i - 1], right_tree)\nflag = 1\nfor q1 in range(q):\n    (type, l, r) = map(int, input().split())\n    if type == 2:\n        if r == l:\n            print(cost[l - 1])\n        elif r > l:\n            print(get_cost(l - 1, r - 1))\n        else:\n            print(rev_get_cost(l - 1, r - 1))\n    else:\n        flag = 1\n        l = l - 1\n        RNeighbour = right_arr[l]\n        update_tree(l, n, r - cost[l], left_tree)\n        if RNeighbour != n:\n            update_tree(RNeighbour, n, cost[l] - r, left_tree)\n        LNeighbour = left_arr[l]\n        if LNeighbour == -1:\n            update_tree(0, n, -cost[l] + r, right_tree)\n            update_tree(l + 1, n, -r + cost[l], right_tree)\n        else:\n            update_tree(LNeighbour + 1, n, -cost[l] + r, right_tree)\n            update_tree(l + 1, n, -r + cost[l], right_tree)\n        cost[l] = r", "import sys\nimport math\nfrom collections import defaultdict, Counter\ninput = sys.stdin.readline\n\ndef print(x):\n    sys.stdout.write(str(x) + '\\n')\n\ndef getsum(BIT, i):\n    s = 0\n    i += 1\n    while i > 0:\n        s += BIT[i]\n        i -= i & -i\n    return s\n\ndef updateBit(BIT, n, i, v):\n    i += 1\n    while i <= n:\n        BIT[i] += v\n        i += i & -i\n\ndef update(BIT, l, r, n, val):\n    updateBit(BIT, n, l, val)\n    updateBit(BIT, n, r + 1, -val)\n(n, q) = map(int, input().split())\nh = list(map(int, input().split()))\na = list(map(int, input().split()))\nl1 = [0] * n\nl2 = [0] * n\nl2[0] = a[0]\nl1[n - 1] = a[n - 1]\nstk = [0] * n\nstk[0] = [h[n - 1], n - 1]\ntop = 0\nfor i in range(n - 2, -1, -1):\n    if h[i] >= h[i + 1]:\n        while top >= 0 and h[i] >= stk[top][0]:\n            top -= 1\n    if top == -1:\n        l1[i] = a[i]\n    else:\n        l1[i] = a[i] + l1[stk[top][1]]\n    top += 1\n    stk[top] = [h[i], i]\nstk[0] = [h[0], 0]\ntop = 0\nfor i in range(1, n):\n    if h[i] >= h[i - 1]:\n        while top >= 0 and h[i] >= stk[top][0]:\n            top -= 1\n    if top == -1:\n        l2[i] = a[i]\n    else:\n        l2[i] = a[i] + l2[stk[top][1]]\n    top += 1\n    stk[top] = [h[i], i]\nBIT1 = [0] * (n + 1)\nBIT2 = [0] * (n + 1)\nh1 = [0] * n\nh2 = [0] * n\nh1[0] = 0\nh2[n - 1] = n - 1\nstk[0] = [h[n - 1], n - 1]\ntop = 0\nfor i in range(n - 2, -1, -1):\n    if h[i] > h[i + 1]:\n        while top >= 0 and h[i] > stk[top][0]:\n            top -= 1\n    if top == -1:\n        h2[i] = n - 1\n    else:\n        h2[i] = stk[top][1] - 1\n    top += 1\n    stk[top] = [h[i], i]\nstk[0] = [h[0], 0]\ntop = 0\nfor i in range(1, n):\n    if h[i] > h[i - 1]:\n        while top >= 0 and h[i] > stk[top][0]:\n            top -= 1\n    if top == -1:\n        h1[i] = 0\n    else:\n        h1[i] = stk[top][1] + 1\n    top += 1\n    stk[top] = [h[i], i]\nfor i in range(q):\n    (a1, b1, c1) = map(int, input().split())\n    if a1 == 2:\n        if h[b1 - 1] <= h[c1 - 1] and b1 != c1:\n            print(-1)\n        else:\n            if b1 < c1:\n                if h2[b1 - 1] < c1 - 1:\n                    ans = -1\n                else:\n                    ans = getsum(BIT2, c1 - 1) - getsum(BIT2, b1 - 1) + l2[c1 - 1] - l2[b1 - 1] + a[b1 - 1]\n            elif h1[b1 - 1] > c1 - 1:\n                ans = -1\n            else:\n                ans = getsum(BIT1, c1 - 1) - getsum(BIT1, b1 - 1) + l1[c1 - 1] - l1[b1 - 1] + a[b1 - 1]\n            print(ans)\n    else:\n        val = c1 - a[b1 - 1]\n        update(BIT1, h1[b1 - 1], b1 - 1, n, val)\n        update(BIT2, b1 - 1, h2[b1 - 1], n, val)\n        a[b1 - 1] = c1", "from collections import defaultdict, deque\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef addedge(u, v, d):\n    d[u].append(v)\n\ndef dfs(neigh, visited, s, euler, a, entry, exit):\n    visited[s] = True\n    euler.append(a[s])\n    entry[s] = len(euler) - 1\n    for j in neigh[s]:\n        if visited[j] == False:\n            dfs(neigh, visited, j, euler, a, entry, exit)\n    euler.append(-1 * a[s])\n    exit[s] = len(euler) - 1\n(n, q) = map(int, input().split())\nh = list(map(int, input().split()))\na = list(map(int, input().split()))\nleft = []\nright = []\nfor i in range(n):\n    left.append(-1)\n    right.append(-1)\nd = deque()\nneigh1 = defaultdict(list)\nneigh2 = defaultdict(list)\nd.append((h[0], 0))\nfor i in range(1, n):\n    next = (h[i], i)\n    if len(d) != 0:\n        if next[0] <= d[-1][0]:\n            d.append(next)\n        else:\n            while len(d) != 0 and next[0] > d[-1][0]:\n                temp = d.pop()\n                right[temp[1]] = next[1]\n                addedge(right[temp[1]], temp[1], neigh2)\n    d.append(next)\nd.clear()\nd.append((h[-1], n - 1))\nfor i in range(n - 2, -1, -1):\n    next = (h[i], i)\n    if len(d) != 0:\n        if next[0] <= d[-1][0]:\n            d.append(next)\n        else:\n            while len(d) != 0 and next[0] > d[-1][0]:\n                temp = d.pop()\n                left[temp[1]] = next[1]\n                addedge(left[temp[1]], temp[1], neigh1)\n    d.append(next)\netour_left = []\nentry_left = []\nexit_left = []\netour_right = []\nentry_right = []\nexit_right = []\nvisited1 = []\nvisited2 = []\nfor i in range(n):\n    visited1.append(False)\n    visited2.append(False)\n    entry_left.append(-1)\n    exit_left.append(-1)\n    entry_right.append(-1)\n    exit_right.append(-1)\nfor i in range(n):\n    if visited1[i] == False and left[i] == -1:\n        dfs(neigh1, visited1, i, etour_left, a, entry_left, exit_left)\n    if visited2[i] == False and right[i] == -1:\n        dfs(neigh2, visited2, i, etour_right, a, entry_right, exit_right)\ntree1 = construct(etour_left, len(etour_left))\ntree2 = construct(etour_right, len(etour_right))\nfor i in range(q):\n    (temp, l, r) = map(int, input().split())\n    if temp == 1:\n        l = l - 1\n        temp = a[l]\n        a[l] = r\n        r = r - temp\n        updatebit(tree1, len(etour_left), entry_left[l], r)\n        updatebit(tree1, len(etour_left), exit_left[l], -1 * r)\n        updatebit(tree2, len(etour_right), entry_right[l], r)\n        updatebit(tree2, len(etour_right), exit_right[l], -1 * r)\n    else:\n        l = l - 1\n        r = r - 1\n        if l == r:\n            print(a[l])\n        elif l < r:\n            if exit_left[r] > exit_left[l] or entry_left[r] < entry_left[l]:\n                print(-1)\n            else:\n                p = entry_left[l]\n                q = entry_left[r]\n                print(getsum(tree1, q) - getsum(tree1, p - 1))\n        elif exit_right[r] > exit_right[l] or entry_right[r] < entry_right[l]:\n            print(-1)\n        else:\n            p = entry_right[l]\n            q = entry_right[r]\n            print(getsum(tree2, q) - getsum(tree2, p - 1))", "from collections import deque, defaultdict\n\ndef getSum(l, r, segTree):\n    ans = 0\n    n = len(segTree) // 2\n    l += n\n    r += n\n    while l < r:\n        if l & 1:\n            ans += segTree[l]\n            l += 1\n        if r & 1:\n            r -= 1\n            ans += segTree[r]\n        l >>= 1\n        r >>= 1\n    return ans\n\ndef main():\n    (N, Q) = map(int, input().split())\n    h = list(map(int, input().split()))\n    h.append(float('inf'))\n    a = list(map(int, input().split()))\n    a.append(0)\n    prevL = [N] * N\n    stack = deque([(float('inf'), N)])\n    mastOrdL = [(N, 0)] * (N + 1)\n    for i in range(N):\n        isPopped = False\n        while stack[-1][0] <= h[i]:\n            stack.pop()\n            isPopped = True\n        prevL[i] = stack[-1][1]\n        if isPopped:\n            mastOrdL[i] = (i, 0)\n        else:\n            mastOrdL[i] = (mastOrdL[prevL[i]][0], mastOrdL[prevL[i]][1] + 1)\n        stack.append((h[i], i))\n    prevR = [N] * N\n    stack.clear()\n    stack.append((float('inf'), N))\n    mastOrdR = [(N, 0)] * (N + 1)\n    for i in range(N - 1, -1, -1):\n        isPopped = False\n        while stack[-1][0] <= h[i]:\n            stack.pop()\n            isPopped = True\n        prevR[i] = stack[-1][1]\n        if isPopped:\n            mastOrdR[i] = (i, 0)\n        else:\n            mastOrdR[i] = (mastOrdR[prevR[i]][0], mastOrdR[prevR[i]][1] + 1)\n        stack.append((h[i], i))\n    Lval = defaultdict(lambda : [])\n    Lval[mastOrdL[N][0]] = [0]\n    for i in range(0, N):\n        Lval[mastOrdL[i][0]].append(a[i])\n    Rval = defaultdict(lambda : [])\n    for i in range(N, -1, -1):\n        Rval[mastOrdR[i][0]].append(a[i])\n    for master in Lval:\n        arr = Lval[master]\n        n = len(arr)\n        segTree = [0] * (2 * n)\n        for i in range(n):\n            segTree[n + i] = arr[i]\n        for i in range(n - 1, 0, -1):\n            segTree[i] = segTree[i << 1] + segTree[i << 1 | 1]\n        Lval[master] = segTree\n    for master in Rval:\n        arr = Rval[master]\n        n = len(arr)\n        segTree = [0] * (2 * n)\n        for i in range(n):\n            segTree[n + i] = arr[i]\n        for i in range(n - 1, 0, -1):\n            segTree[i] = segTree[i << 1] + segTree[i << 1 | 1]\n        Rval[master] = segTree\n    for _ in range(Q):\n        (qtype, x, y) = map(int, input().split())\n        if qtype == 1:\n            segTree = Lval[mastOrdL[x - 1][0]]\n            n = len(segTree) // 2\n            p = mastOrdL[x - 1][1]\n            segTree[p + n] = y\n            p += n\n            i = p\n            while i > 1:\n                segTree[i >> 1] = segTree[i] + segTree[i ^ 1]\n                i >>= 1\n            segTree = Rval[mastOrdR[x - 1][0]]\n            n = len(segTree) // 2\n            p = mastOrdR[x - 1][1]\n            segTree[p + n] = y\n            p += n\n            i = p\n            while i > 1:\n                segTree[i >> 1] = segTree[i] + segTree[i ^ 1]\n                i >>= 1\n        else:\n            a_den = x - 1\n            b_den = y - 1\n            flag = False\n            if a_den < b_den:\n                total = 0\n                while mastOrdL[b_den][0] != mastOrdL[a_den][0]:\n                    if h[a_den] <= h[b_den] or a_den > b_den:\n                        print(-1)\n                        flag = True\n                        break\n                    total += getSum(0, mastOrdL[b_den][1] + 1, Lval[mastOrdL[b_den][0]])\n                    b_den = prevL[mastOrdL[b_den][0]]\n                if flag:\n                    continue\n                if mastOrdL[b_den][1] >= mastOrdL[a_den][1]:\n                    total += getSum(mastOrdL[a_den][1], mastOrdL[b_den][1] + 1, Lval[mastOrdL[b_den][0]])\n                    print(total)\n                else:\n                    print(-1)\n            else:\n                total = 0\n                while mastOrdR[b_den][0] != mastOrdR[a_den][0]:\n                    if h[a_den] <= h[b_den] or a_den < b_den:\n                        print(-1)\n                        flag = True\n                        break\n                    total += getSum(0, mastOrdR[b_den][1] + 1, Rval[mastOrdR[b_den][0]])\n                    b_den = prevR[mastOrdR[b_den][0]]\n                if flag:\n                    continue\n                if mastOrdR[b_den][1] >= mastOrdR[a_den][1]:\n                    total += getSum(mastOrdR[a_den][1], mastOrdR[b_den][1] + 1, Rval[mastOrdR[b_den][0]])\n                    print(total)\n                else:\n                    print(-1)\nmain()", "import math\n\nclass Forward2:\n\n    def __init__(self, a_l, h_l):\n        self.a_l = a_l\n        self.h_l = h_l\n        self.compute()\n\n    def range_query(self, left, right):\n        segtree = self.segtree\n        n = len(self.a_l)\n        left += n\n        right += n\n        ma = -1\n        while left < right:\n            if left & 1:\n                ma = max(ma, segtree[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                ma = max(ma, segtree[right])\n            left //= 2\n            right //= 2\n        return ma\n\n    def compute(self):\n        a_l = self.a_l\n        h_l = self.h_l\n        cur_sum = a_l[0]\n        stack = [0]\n        dp = [a_l[0] for _ in range(n)]\n        segtree = [-1 for _ in range(2 * n + 1)]\n        for i in range(n):\n            segtree[n + i] = h_l[i]\n        for i in range(n - 1, 0, -1):\n            segtree[i] = max(segtree[2 * i], segtree[2 * i + 1])\n        for i in range(1, n):\n            while len(stack) > 0 and h_l[i] >= h_l[stack[-1]]:\n                cur_sum -= a_l[stack[-1]]\n                del stack[-1]\n            cur_sum += a_l[i]\n            dp[i] = cur_sum\n            stack.append(i)\n        self.dp = dp\n        self.segtree = segtree\n\n    def cal(self, a, b):\n        a -= 1\n        b -= 1\n        dp = self.dp\n        a_l = self.a_l\n        h_l = self.h_l\n        if h_l[a] > self.range_query(a + 1, b):\n            return dp[b] - dp[a] + a_l[a]\n        return -1\n\nclass Forward:\n\n    def __init__(self, a_l, h_l):\n        self.a_l = a_l\n        self.h_l = h_l\n        self.compute()\n\n    def range_query(self, left, right):\n        segtree = self.segtree\n        n = len(self.a_l)\n        left += n\n        right += n\n        ma = -1\n        while left < right:\n            if left & 1:\n                ma = max(ma, segtree[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                ma = max(ma, segtree[right])\n            left //= 2\n            right //= 2\n        return ma\n\n    def compute(self):\n        a_l = self.a_l\n        h_l = self.h_l\n        stack = [0]\n        jump_cld = {}\n        jump_par = {}\n        par_map = {1 + (1 & -1): [1]}\n        dp = [0 for _ in range(n)]\n        segtree = [-1 for _ in range(2 * n + 1)]\n        for i in range(n):\n            segtree[n + i] = h_l[i]\n        for i in range(n - 1, 0, -1):\n            segtree[i] = max(segtree[2 * i], segtree[2 * i + 1])\n        for i in range(1, n):\n            while len(stack) > 0 and h_l[i] >= h_l[stack[-1]]:\n                del stack[-1]\n            stack.append(i)\n            ti = len(stack)\n            par_i = ti - (ti & -ti) - 1\n            if stack[par_i] != i:\n                jump_par[i] = stack[par_i]\n            cld_i = ti + (ti & -ti)\n            if cld_i in par_map:\n                if ti > par_map[cld_i][-1]:\n                    par_map[cld_i].append(ti)\n            else:\n                par_map[cld_i] = [ti]\n            if ti in par_map:\n                for v in par_map[ti]:\n                    v -= 1\n                    v = stack[v]\n                    if v in jump_cld:\n                        jump_cld[v].append(i)\n                    else:\n                        jump_cld[v] = [i]\n        self.dp = dp\n        self.jump_cld = jump_cld\n        self.jump_par = jump_par\n        self.segtree = segtree\n        for i in range(n):\n            self.recur(i, a_l[i])\n\n    def recur(self, i, v):\n        jump_cld = self.jump_cld\n        dp = self.dp\n        dp[i] += v\n        if i in jump_cld:\n            for cld_i in jump_cld[i]:\n                self.recur(cld_i, v)\n\n    def update(self, i, v):\n        a_l = self.a_l\n        i -= 1\n        diff = v - a_l[i]\n        self.recur(i, diff)\n        a_l[i] = v\n\n    def cal(self, a, b):\n        h_l = self.h_l\n        a_l = self.a_l\n        jump_par = self.jump_par\n        dp = self.dp\n        a -= 1\n        b -= 1\n        h_l = self.h_l\n        if h_l[a] <= self.range_query(a + 1, b):\n            return -1\n        total_b = 0\n        par_i = b\n        while True:\n            total_b += dp[par_i]\n            if par_i in jump_par:\n                par_i = jump_par[par_i]\n            else:\n                break\n        total_a = 0\n        par_i = a\n        while True:\n            total_a += dp[par_i]\n            if par_i in jump_par:\n                par_i = jump_par[par_i]\n            else:\n                break\n        return total_b - total_a + a_l[a]\n(n, q) = map(int, input().split())\nh_l = list(map(int, input().split()))\na_l = list(map(int, input().split()))\nqs = []\nnoUpdate = True\nfor _ in range(q):\n    (typ, a, b) = map(int, input().split())\n    qs.append([typ, a, b])\n    if typ == 1:\n        noUpdate = False\nif noUpdate:\n    forward = Forward2(a_l, h_l)\n    backward = Forward2(a_l[::-1], h_l[::-1])\nelse:\n    forward = Forward(a_l, h_l)\n    backward = Forward(a_l[::-1], h_l[::-1])\nfor (typ, a, b) in qs:\n    if typ == 1:\n        forward.update(a, b)\n        backward.update(n + 1 - a, b)\n    else:\n        if a < b:\n            ans = forward.cal(a, b)\n        else:\n            ans = backward.cal(n + 1 - a, n + 1 - b)\n        print(ans)", "N = 2 * 10 ** 5 + 10\nMAX = 10 ** 18\nheight = [MAX] * N\nvalue = [0] * N\nlft_high = [0] * N\nrgt_high = [0] * N\naux_lft = [0] * N\naux_rgt = [0] * N\n(n, q) = (0, 0)\n\nclass FenwickTree:\n\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def update(self, x, d):\n        while x <= self.n:\n            self.bit[x] += d\n            x += x & -x\n\n    def query(self, x):\n        res = 0\n        while x > 0:\n            res += self.bit[x]\n            x -= x & -x\n        return res\n\n    def range_query(self, l, r):\n        return self.query(r) - self.query(l - 1)\nt1 = FenwickTree(N)\nt2 = FenwickTree(N)\nt3 = FenwickTree(N)\n\ndef precompute_left():\n    stack = [0]\n    for i in range(1, n + 1):\n        while height[stack[-1]] < height[i]:\n            stack.pop()\n        lft_high[i] = stack[-1]\n        aux_lft[stack[-1]] -= value[i]\n        stack.append(i)\n\ndef precompute_right():\n    stack = [n + 1]\n    for i in range(n, 0, -1):\n        while height[stack[-1]] < height[i]:\n            stack.pop()\n        rgt_high[i] = stack[-1]\n        aux_rgt[stack[-1]] -= value[i]\n        stack.append(i)\n\ndef update(b, k):\n    diff = k - value[b]\n    t1.update(b, diff)\n    if lft_high[b] > 0:\n        t2.update(lft_high[b], -diff)\n    if rgt_high[b] > 0:\n        t3.update(rgt_high[b], -diff)\n    value[b] = k\n    aux_lft[lft_high[b]] -= diff\n    aux_rgt[rgt_high[b]] -= diff\n\ndef query_left(x, y):\n    if lft_high[x] >= y:\n        return -1\n    ans = t1.range_query(y, x) + t2.range_query(y, x)\n    return ans - aux_lft[x]\n\ndef query_right(x, y):\n    if rgt_high[x] <= y:\n        return -1\n    ans = t1.range_query(x, y) + t3.range_query(x, y)\n    return ans - aux_rgt[x]\n\ndef query(x, y):\n    if x == y:\n        return value[x]\n    elif x > y:\n        return query_left(x, y)\n    else:\n        return query_right(x, y)\n(n, q) = map(int, input().split())\nh = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nfor i in range(n):\n    height[i + 1] = h[i]\n    value[i + 1] = a[i]\nprecompute_left()\nprecompute_right()\nfor i in range(1, N):\n    t1.update(i, value[i])\n    t2.update(i, aux_lft[i])\n    t3.update(i, aux_rgt[i])\nfor i in range(q):\n    (t, x, y) = map(int, input().split())\n    if t == 1:\n        update(x, y)\n    else:\n        print(query(x, y))"]