["import math\n\ndef minfun(array, minsegtree, l, r, p):\n    if l == r:\n        minsegtree[p] = array[l]\n        return\n    mid = (l + r) // 2\n    minfun(array, minsegtree, l, mid, 2 * p + 1)\n    minfun(array, minsegtree, mid + 1, r, 2 * p + 2)\n    minsegtree[p] = min(minsegtree[2 * p + 1], minsegtree[2 * p + 2])\n\ndef maxfun(array, maxsegtree, l, r, p):\n    if l == r:\n        maxsegtree[p] = array[l]\n        return\n    mid = (l + r) // 2\n    maxfun(array, maxsegtree, l, mid, 2 * p + 1)\n    maxfun(array, maxsegtree, mid + 1, r, 2 * p + 2)\n    maxsegtree[p] = max(maxsegtree[2 * p + 1], maxsegtree[2 * p + 2])\n\ndef rangeminquery(minsegtree, ql, qr, l, r, p):\n    if ql <= l and qr >= r:\n        return minsegtree[p]\n    if ql > r or qr < l:\n        return 100000001\n    mid = (l + r) // 2\n    return min(rangeminquery(minsegtree, ql, qr, l, mid, 2 * p + 1), rangeminquery(minsegtree, ql, qr, mid + 1, r, 2 * p + 2))\n\ndef rangemaxquery(maxsegtree, ql, qr, l, r, p):\n    if ql <= l and qr >= r:\n        return maxsegtree[p]\n    if ql > r or qr < l:\n        return 0\n    mid = (l + r) // 2\n    return max(rangemaxquery(maxsegtree, ql, qr, l, mid, 2 * p + 1), rangemaxquery(maxsegtree, ql, qr, mid + 1, r, 2 * p + 2))\nn = int(input())\narray = list(map(int, input().split()))\nlength = 2 * n - 1\nlg = math.log2(n)\nif lg % 1 != 0:\n    length = 2 * pow(2, int(lg) + 1) - 1\nminsegtree = [100000001] * length\nmaxsegtree = [0] * length\nminfun(array, minsegtree, 0, n - 1, 0)\nmaxfun(array, maxsegtree, 0, n - 1, 0)\nq = int(input())\nfor i in range(q):\n    (l, r) = map(int, input().split())\n    s = rangeminquery(minsegtree, l, r, 0, n - 1, 0)\n    m1 = (rangemaxquery(maxsegtree, l, r, 0, n - 1, 0) - s) / 2\n    m2 = 0\n    if l != 0:\n        m2 = max(m2, rangemaxquery(maxsegtree, 0, l - 1, 0, n - 1, 0))\n    if r != n - 1:\n        m2 = max(m2, rangemaxquery(maxsegtree, r + 1, n - 1, 0, n - 1, 0))\n    print(float(s + max(m1, m2)))", "import math\n\ndef minfun(array, minsegtree, l, r, p):\n    if l == r:\n        minsegtree[p] = array[l]\n        return\n    mid = (l + r) // 2\n    minfun(array, minsegtree, l, mid, 2 * p + 1)\n    minfun(array, minsegtree, mid + 1, r, 2 * p + 2)\n    minsegtree[p] = min(minsegtree[2 * p + 1], minsegtree[2 * p + 2])\n\ndef maxfun(array, maxsegtree, l, r, p):\n    if l == r:\n        maxsegtree[p] = array[l]\n        return\n    mid = (l + r) // 2\n    maxfun(array, maxsegtree, l, mid, 2 * p + 1)\n    maxfun(array, maxsegtree, mid + 1, r, 2 * p + 2)\n    maxsegtree[p] = max(maxsegtree[2 * p + 1], maxsegtree[2 * p + 2])\n\ndef rangeminquery(minsegtree, ql, qr, l, r, p):\n    if ql <= l and qr >= r:\n        return minsegtree[p]\n    if ql > r or qr < l:\n        return 100000001\n    mid = (l + r) // 2\n    return min(rangeminquery(minsegtree, ql, qr, l, mid, 2 * p + 1), rangeminquery(minsegtree, ql, qr, mid + 1, r, 2 * p + 2))\n\ndef rangemaxquery(maxsegtree, ql, qr, l, r, p):\n    if ql <= l and qr >= r:\n        return maxsegtree[p]\n    if ql > r or qr < l:\n        return 0\n    mid = (l + r) // 2\n    return max(rangemaxquery(maxsegtree, ql, qr, l, mid, 2 * p + 1), rangemaxquery(maxsegtree, ql, qr, mid + 1, r, 2 * p + 2))\nn = int(input())\narray = list(map(int, input().split()))\nlength = 2 * n - 1\nlg = math.log2(n)\nif lg % 1 != 0:\n    length = 2 * pow(2, int(lg) + 1) - 1\nminsegtree = [100000001] * length\nmaxsegtree = [0] * length\nminfun(array, minsegtree, 0, n - 1, 0)\nmaxfun(array, maxsegtree, 0, n - 1, 0)\nq = int(input())\nfor i in range(q):\n    (l, r) = map(int, input().split())\n    s = rangeminquery(minsegtree, l, r, 0, n - 1, 0)\n    m1 = (rangemaxquery(maxsegtree, l, r, 0, n - 1, 0) - s) / 2\n    m2 = 0\n    if l != 0:\n        m2 = max(m2, rangemaxquery(maxsegtree, 0, l - 1, 0, n - 1, 0))\n    if r != n - 1:\n        m2 = max(m2, rangemaxquery(maxsegtree, r + 1, n - 1, 0, n - 1, 0))\n    print(float(s + max(m1, m2)))", "import math\nn = int(input())\narr = [int(x) for x in input().split()]\nk = int(math.log2(n))\nsp = [[0 for i in range(k + 1)] for j in range(n)]\nfor j in range(k + 1):\n    i = 0\n    while i + (1 << j) - 1 < n:\n        if j == 0:\n            sp[i][j] = arr[i]\n        else:\n            sp[i][j] = max(sp[i][j - 1], sp[i + (1 << j - 1)][j - 1])\n        i += 1\nsp1 = [[0 for i in range(k + 1)] for j in range(n)]\nfor j in range(k + 1):\n    i = 0\n    while i + (1 << j) - 1 < n:\n        if j == 0:\n            sp1[i][j] = arr[i]\n        else:\n            sp1[i][j] = min(sp1[i][j - 1], sp1[i + (1 << j - 1)][j - 1])\n        i += 1\n\ndef query1(l, r):\n    k = r - l + 1\n    msb = int(math.log2(k))\n    return max(sp[l][msb], sp[r - (1 << msb) + 1][msb])\n\ndef query(l, r):\n    k = r - l + 1\n    msb = int(math.log2(k))\n    ans = min(sp1[l][msb], sp1[r - (1 << msb) + 1][msb])\n    m = ans + (query1(l, r) - ans) / 2\n    if l - 1 >= 0:\n        m = max(m, ans + query1(0, l - 1))\n    if r + 1 <= n - 1:\n        m = max(m, ans + query1(r + 1, n - 1))\n    return float(m)\nq = int(input())\nfor i in range(q):\n    (l, r) = map(int, input().split())\n    print(query(l, r))", "import math\nn = int(input())\narr = [int(x) for x in input().split()]\nk = int(math.log2(n))\nsp = [[0 for i in range(k + 1)] for j in range(n)]\nfor j in range(k + 1):\n    i = 0\n    while i + (1 << j) - 1 < n:\n        if j == 0:\n            sp[i][j] = arr[i]\n        else:\n            sp[i][j] = max(sp[i][j - 1], sp[i + (1 << j - 1)][j - 1])\n        i += 1\nsp1 = [[0 for i in range(k + 1)] for j in range(n)]\nfor j in range(k + 1):\n    i = 0\n    while i + (1 << j) - 1 < n:\n        if j == 0:\n            sp1[i][j] = arr[i]\n        else:\n            sp1[i][j] = min(sp1[i][j - 1], sp1[i + (1 << j - 1)][j - 1])\n        i += 1\n\ndef query1(l, r):\n    k = r - l + 1\n    msb = int(math.log2(k))\n    return max(sp[l][msb], sp[r - (1 << msb) + 1][msb])\n\ndef query(l, r):\n    k = r - l + 1\n    msb = int(math.log2(k))\n    ans = min(sp1[l][msb], sp1[r - (1 << msb) + 1][msb])\n    m = ans + (query1(l, r) - ans) / 2\n    if l - 1 >= 0:\n        m = max(m, ans + query1(0, l - 1))\n    if r + 1 <= n - 1:\n        m = max(m, ans + query1(r + 1, n - 1))\n    return float(m)\nq = int(input())\nfor i in range(q):\n    (l, r) = map(int, input().split())\n    print(query(l, r))", "import math\nn = int(input())\narr = [int(x) for x in input().split()]\nk = int(math.log2(n))\nsp = [[0 for i in range(k + 1)] for j in range(n)]\nfor j in range(k + 1):\n    i = 0\n    while i + (1 << j) - 1 < n:\n        if j == 0:\n            sp[i][j] = arr[i]\n        else:\n            sp[i][j] = max(sp[i][j - 1], sp[i + (1 << j - 1)][j - 1])\n        i += 1\nsp1 = [[0 for i in range(k + 1)] for j in range(n)]\nfor j in range(k + 1):\n    i = 0\n    while i + (1 << j) - 1 < n:\n        if j == 0:\n            sp1[i][j] = arr[i]\n        else:\n            sp1[i][j] = min(sp1[i][j - 1], sp1[i + (1 << j - 1)][j - 1])\n        i += 1\n\ndef query1(l, r):\n    k = r - l + 1\n    msb = int(math.log2(k))\n    return max(sp[l][msb], sp[r - (1 << msb) + 1][msb])\n\ndef query(l, r):\n    k = r - l + 1\n    msb = int(math.log2(k))\n    ans = min(sp1[l][msb], sp1[r - (1 << msb) + 1][msb])\n    m = ans + (query1(l, r) - ans) / 2\n    if l - 1 >= 0:\n        m = max(m, ans + query1(0, l - 1))\n    if r + 1 <= n - 1:\n        m = max(m, ans + query1(r + 1, n - 1))\n    return float(m)\nq = int(input())\nfor i in range(q):\n    (l, r) = map(int, input().split())\n    print(query(l, r))", "from sys import stdin, stdout\nimport math\nfrom collections import Counter\nimport functools\nimport time\nimport bisect\n\ndef tr():\n    return range(int(line()))\n\ndef sm():\n    return map(int, line().split())\n\ndef ln():\n    return list(sm())\n\ndef nl():\n    return int(line())\n\ndef ssm():\n    return map(str, line().split())\n\ndef line():\n    return stdin.readline().rstrip()\n\ndef b(x):\n    return bin(x).replace('0b', '')\n\ndef o(x):\n    if type(x) != type(''):\n        x = str(x)\n    stdout.write(x + '\\n')\n\ndef osp(x):\n    if type(x) != type(''):\n        x = str(x)\n    stdout.write(x + ' ')\n\ndef ol(x):\n    stdout.write(' '.join(map(str, x)))\n\ndef wline():\n    return stdin.read().split()\n\ndef build_st(matrix, n, func):\n    i = 1\n    while i <= math.floor(math.log2(n)):\n        j = 0\n        while j + (1 << i) <= n:\n            matrix[i][j] = func(matrix[i - 1][j], matrix[i - 1][j + (1 << i - 1)])\n            j += 1\n        i += 1\n\ndef query(matrix, func, l, r, overlap=1):\n    s = r - l + 1\n    p = math.floor(math.log2(s))\n    k = 1 << p\n    return func(matrix[p][l], matrix[p][1 + r - k])\n\ndef main():\n    n = nl()\n    l = ln()\n    st_min = [[0] * n for _ in range(math.floor(math.log2(n)) + 1)]\n    st_max = [[0] * n for _ in range(math.floor(math.log2(n)) + 1)]\n    for i in range(n):\n        st_min[0][i] = l[i]\n        st_max[0][i] = l[i]\n    build_st(st_min, n, min)\n    build_st(st_max, n, max)\n    q = nl()\n    for i in range(q):\n        (l, r) = sm()\n        fastest_in_range = query(st_min, min, l, r)\n        slowest_in_range = query(st_max, max, l, r)\n        (slowest_left, slowest_right) = (0, 0)\n        if l - 1 >= 0:\n            slowest_left = query(st_max, max, 0, l - 1)\n        if r + 1 < n:\n            slowest_right = query(st_max, max, r + 1, n - 1)\n        slowest_outside = max(slowest_left, slowest_right)\n        print(float(fastest_in_range + max((slowest_in_range - fastest_in_range) / 2, slowest_outside)))\nmain()", "from sys import stdin, stdout\nimport math\nfrom collections import Counter\nimport functools\nimport time\nimport bisect\n\ndef tr():\n    return range(int(line()))\n\ndef sm():\n    return map(int, line().split())\n\ndef ln():\n    return list(sm())\n\ndef nl():\n    return int(line())\n\ndef ssm():\n    return map(str, line().split())\n\ndef line():\n    return stdin.readline().rstrip()\n\ndef b(x):\n    return bin(x).replace('0b', '')\n\ndef o(x):\n    if type(x) != type(''):\n        x = str(x)\n    stdout.write(x + '\\n')\n\ndef osp(x):\n    if type(x) != type(''):\n        x = str(x)\n    stdout.write(x + ' ')\n\ndef ol(x):\n    stdout.write(' '.join(map(str, x)))\n\ndef wline():\n    return stdin.read().split()\n\ndef build_st(matrix, n, func):\n    i = 1\n    while i <= math.floor(math.log2(n)):\n        j = 0\n        while j + (1 << i) <= n:\n            matrix[i][j] = func(matrix[i - 1][j], matrix[i - 1][j + (1 << i - 1)])\n            j += 1\n        i += 1\n\ndef query(matrix, func, l, r, overlap=1):\n    s = r - l + 1\n    p = math.floor(math.log2(s))\n    k = 1 << p\n    return func(matrix[p][l], matrix[p][1 + r - k])\n\ndef main():\n    n = nl()\n    l = ln()\n    st_min = [[0] * n for _ in range(math.floor(math.log2(n)) + 1)]\n    st_max = [[0] * n for _ in range(math.floor(math.log2(n)) + 1)]\n    for i in range(n):\n        st_min[0][i] = l[i]\n        st_max[0][i] = l[i]\n    build_st(st_min, n, min)\n    build_st(st_max, n, max)\n    q = nl()\n    for i in range(q):\n        (l, r) = sm()\n        fastest_in_range = query(st_min, min, l, r)\n        slowest_in_range = query(st_max, max, l, r)\n        (slowest_left, slowest_right) = (0, 0)\n        if l - 1 >= 0:\n            slowest_left = query(st_max, max, 0, l - 1)\n        if r + 1 < n:\n            slowest_right = query(st_max, max, r + 1, n - 1)\n        slowest_outside = max(slowest_left, slowest_right)\n        print(float(fastest_in_range + max((slowest_in_range - fastest_in_range) / 2, slowest_outside)))\nmain()", "from sys import stdin, stdout\nimport math\nfrom collections import Counter\nimport functools\nimport time\nimport bisect\n\ndef tr():\n    return range(int(line()))\n\ndef sm():\n    return map(int, line().split())\n\ndef ln():\n    return list(sm())\n\ndef nl():\n    return int(line())\n\ndef ssm():\n    return map(str, line().split())\n\ndef line():\n    return stdin.readline().rstrip()\n\ndef b(x):\n    return bin(x).replace('0b', '')\n\ndef o(x):\n    if type(x) != type(''):\n        x = str(x)\n    stdout.write(x + '\\n')\n\ndef osp(x):\n    if type(x) != type(''):\n        x = str(x)\n    stdout.write(x + ' ')\n\ndef ol(x):\n    stdout.write(' '.join(map(str, x)))\n\ndef wline():\n    return stdin.read().split()\n\ndef build_st(values, n, func):\n    matrix = {}\n    matrix[1] = values\n    l = 2\n    while l <= n:\n        prev_row = matrix[l // 2]\n        row_size = n - l + 1\n        row = [0] * row_size\n        for i in range(row_size):\n            row[i] = func(prev_row[i + l // 2], prev_row[i])\n        matrix[l] = row\n        l *= 2\n    return matrix\n\ndef query(matrix, func, l, r, overlap=1):\n    s = r - l + 1\n    p = math.floor(math.log2(s))\n    k = 1 << p\n    return func(matrix[k][l], matrix[k][1 + r - k])\n\ndef main():\n    n = nl()\n    l = ln()\n    st_min = build_st(l, n, min)\n    st_max = build_st(l, n, max)\n    q = nl()\n    for i in range(q):\n        (l, r) = sm()\n        fastest_in_range = query(st_min, min, l, r)\n        slowest_in_range = query(st_max, max, l, r)\n        (slowest_left, slowest_right) = (0, 0)\n        if l - 1 >= 0:\n            slowest_left = query(st_max, max, 0, l - 1)\n        if r + 1 < n:\n            slowest_right = query(st_max, max, r + 1, n - 1)\n        slowest_outside = max(slowest_left, slowest_right)\n        print(float(fastest_in_range + max((slowest_in_range - fastest_in_range) / 2, slowest_outside)))\nmain()", "from sys import stdin, stdout\nimport math\nfrom collections import Counter\nimport functools\nimport time\nimport bisect\n\ndef tr():\n    return range(int(line()))\n\ndef sm():\n    return map(int, line().split())\n\ndef ln():\n    return list(sm())\n\ndef nl():\n    return int(line())\n\ndef ssm():\n    return map(str, line().split())\n\ndef line():\n    return stdin.readline().rstrip()\n\ndef b(x):\n    return bin(x).replace('0b', '')\n\ndef o(x):\n    if type(x) != type(''):\n        x = str(x)\n    stdout.write(x + '\\n')\n\ndef osp(x):\n    if type(x) != type(''):\n        x = str(x)\n    stdout.write(x + ' ')\n\ndef ol(x):\n    stdout.write(' '.join(map(str, x)))\n\ndef wline():\n    return stdin.read().split()\nfrom math import inf\n\ndef build_tree(tree, n, func):\n    i = n - 1\n    while i > 0:\n        tree[i] = func(tree[2 * i], tree[2 * i + 1])\n        i -= 1\n\ndef query(tree, n, l, r, func, default_value):\n    l += n\n    r += n\n    result = default_value\n    while l < r:\n        if l & 1:\n            result = func(result, tree[l])\n            l += 1\n        if r & 1:\n            r -= 1\n            result = func(result, tree[r])\n        l >>= 1\n        r >>= 1\n    return result\n\ndef main():\n    n = nl()\n    l = ln()\n    min_tree = [0] * (2 * n)\n    max_tree = [inf] * (2 * n)\n    for i in range(n):\n        min_tree[n + i] = l[i]\n        max_tree[n + i] = l[i]\n    build_tree(min_tree, n, min)\n    build_tree(max_tree, n, max)\n    q = nl()\n    for _ in range(q):\n        (l, r) = sm()\n        fastest_candle = query(min_tree, n, l, r + 1, min, inf)\n        slowest_in_range = query(max_tree, n, l, r + 1, max, 0)\n        (slowest_left, slowest_right) = (0, 0)\n        if l - 1 >= 0:\n            slowest_left = query(max_tree, n, 0, l, max, 0)\n        if r + 1 < n:\n            slowest_right = query(max_tree, n, r + 1, n, max, 0)\n        slowest_outside_range = max(slowest_right, slowest_left)\n        print(float(fastest_candle + max((slowest_in_range - fastest_candle) / 2, slowest_outside_range)))\nmain()", "from math import *\n\ndef make_sparse_table_max(arr, n):\n    row = n\n    col = floor(log2(n)) + 1\n    st = [[-1 for x in range(col)] for x in range(row)]\n    for i in range(row):\n        st[i][0] = arr[i]\n    for j in range(1, col):\n        i = 0\n        while i + (1 << j) <= n:\n            st[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1])\n            i += 1\n    return st\n\ndef make_sparse_table_min(arr, n):\n    row = n\n    col = floor(log2(n)) + 1\n    st = [[-1 for x in range(col)] for x in range(row)]\n    for i in range(row):\n        st[i][0] = arr[i]\n    for j in range(1, col):\n        i = 0\n        while i + (1 << j) <= n:\n            st[i][j] = min(st[i][j - 1], st[i + (1 << j - 1)][j - 1])\n            i += 1\n    return st\n\ndef find_max(st1, l, r):\n    j = floor(log2(r - l + 1))\n    ans = max(st1[l][j], st1[r - (1 << j) + 1][j])\n    return ans\n\ndef find_min(st2, l, r):\n    j = floor(log2(r - l + 1))\n    ans = min(st2[l][j], st2[r - (1 << j) + 1][j])\n    return ans\nn = int(input())\narr = [int(x) for x in input().split()]\nst1 = make_sparse_table_max(arr, n)\nst2 = make_sparse_table_min(arr, n)\nq = int(input())\nwhile q:\n    (l, r) = input().split()\n    l = int(l)\n    r = int(r)\n    ans1 = 0\n    ans2 = 0\n    ans3 = find_min(st2, l, r)\n    if l != 0:\n        ans1 = find_max(st1, 0, l - 1)\n    if r != n - 1:\n        ans2 = find_max(st1, r + 1, n - 1)\n    ans4 = max(ans2, ans1) + ans3\n    ans5 = ans3 + (find_max(st1, l, r) - ans3) / 2\n    ans = max(ans4, ans5)\n    print(float(ans))\n    q -= 1", "import math\nimport sys\n\nclass SegmentTree:\n\n    def __init__(self, a, m, d=None):\n        self._size = len(a)\n        self._m = m\n        nearest = 1 << (self._size - 1).bit_length()\n        if nearest == self._size:\n            nearest *= 2\n        self._nearest = nearest\n        self._a = [d] * self._size + [m([x]) for x in a]\n        for i in range(self._size - 1, 0, -1):\n            self._a[i] = self._m(self._a[2 * i], self._a[2 * i + 1])\n\n    def update(self, v, s, e=None):\n        i = len(self._a) // 2 + s\n        self._a[i] = v\n        while i != 1:\n            i //= 2\n            self._a[i] = self._m(self._a[2 * i], self._a[2 * i + 1])\n\n    def query(self, s, e):\n        curr = self._a[0]\n        s += self._size\n        e += self._size\n        while s < e:\n            if s & 1 > 0:\n                curr = self._m(curr, self._a[s])\n                s += 1\n            if e & 1 > 0:\n                e -= 1\n                curr = self._m(curr, self._a[e])\n            s = s // 2\n            e = e // 2\n        return curr\n\ndef rl():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n = int(rl())\n    nums = list(map(int, rl().split()))\n    min_tree = SegmentTree(nums, min, float('inf'))\n    max_tree = SegmentTree(nums, max, -1)\n    for _ in range(int(rl())):\n        (left, right) = map(int, rl().split())\n        b = min_tree.query(left, right + 1)\n        options = [(max_tree.query(left, right + 1) - b) / 2 + b]\n        if left:\n            options.append(max_tree.query(0, left) + b)\n        if right < n - 1:\n            options.append(max_tree.query(right + 1, len(nums)) + b)\n        print(f'{max(options):.1f}')\nmain()", "from typing import Callable, List\nimport math\nimport operator as op\n\nclass SparseTable:\n\n    def __init__(self, operation: Callable, canoverlap: bool, vs: List[int]) -> None:\n        self.canoverlap = canoverlap\n        self.operation = operation\n        self.table = [vs.copy()]\n        exp = 0\n        for exp in range(math.floor(math.log2(len(vs)))):\n            newrow = []\n            d = 2 ** exp\n            for i in range(len(self.table[-1]) - d):\n                newrow.append(operation(self.table[-1][i], self.table[-1][i + d]))\n            self.table.append(newrow)\n\n    def query(self, l, r):\n        if self.canoverlap:\n            return self.__lap_query(l, r)\n        else:\n            raise NotImplementedError()\n\n    def __lap_query(self, l, r):\n        rowidx = math.floor(math.log2(r - l + 1))\n        row = self.table[rowidx]\n        rquery = r - 2 ** rowidx + 1\n        try:\n            res = self.operation(row[l], row[rquery])\n        except IndexError as e:\n            print(f'failed on {l}-{r}: query {rowidx} at {l},{rquery}')\n            raise e\n        return res\nN = int(input())\nvs = list(map(int, input().split()))\nmaxtab = SparseTable(max, True, vs)\nmintab = SparseTable(min, True, vs)\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    inshort = mintab.query(l, r)\n    inlong = maxtab.query(l, r)\n    outlong = 0\n    if l > 0:\n        outlong = max(outlong, maxtab.query(0, l - 1))\n    if r < N - 1:\n        outlong = max(outlong, maxtab.query(r + 1, N - 1))\n    print(f'{max(outlong, (inlong - inshort) / 2) + inshort:.1f}')", "import sys\n\ndef rall():\n    return sys.stdin.readlines()\n\ndef rl():\n    return sys.stdin.readline().strip()\n\ndef rl_types(types):\n    str_list = [x for x in sys.stdin.readline().strip().split(' ')]\n    return [types[i](str_list[i]) for i in range(len(str_list))]\n\ndef pr(something=''):\n    sys.stdout.write(str(something) + '\\n')\n\ndef pra(array):\n    sys.stdout.write(' '.join([str(x) for x in array]) + '\\n')\n\ndef solve(array):\n    return array\n\ndef st_build(vals, func):\n    nv = len(vals)\n    tbl = {}\n    tbl[1] = list(vals)\n    l = 2\n    while l <= nv:\n        prv = tbl[l // 2]\n        row = [0] * (nv - l + 1)\n        for i in range(len(row)):\n            row[i] = func(prv[i], prv[i + l // 2])\n        tbl[l] = row\n        l *= 2\n    return (tbl, func)\n\ndef lgpw2(n):\n    p = 1\n    while 2 * p <= n:\n        p *= 2\n    return p\n\ndef st_query(st, l, r):\n    (tbl, func) = st\n    w = r - l + 1\n    w2 = lgpw2(w)\n    st_row = tbl[w2]\n    return func(st_row[l], st_row[r - w2 + 1])\n_ = int(rl())\nmatches = list(map(int, rl().split(' ')))\nnq = int(rl())\nst_min = st_build(matches, min)\nst_max = st_build(matches, max)\nfor _ in range(nq):\n    (l, r) = map(int, rl().split(' '))\n    time_all_light = st_query(st_min, l, r)\n    longest_inside = st_query(st_max, l, r)\n    longest_outside = 0.0\n    if l > 0:\n        longest_left = st_query(st_max, 0, l - 1)\n        longest_outside = max(longest_left, longest_outside)\n    if r < len(matches) - 1:\n        longest_right = st_query(st_max, r + 1, len(matches) - 1)\n        longest_outside = max(longest_right, longest_outside)\n    max_inside = (longest_inside - time_all_light) / 2.0 + time_all_light\n    max_outside = float(time_all_light + longest_outside)\n    pr(max(max_inside, max_outside))", "class Node:\n\n    def __init__(self, val=0, left=None, right=None):\n        self.left = left\n        self.right = right\n        if left == None:\n            self.minE = self.maxE = val\n        else:\n            self.minE = 10 ** 9\n            self.maxE = 0\n            if left:\n                self.minE = min(left.minE, self.minE)\n                self.maxE = max(left.maxE, self.maxE)\n            if right:\n                self.minE = min(right.minE, self.minE)\n                self.maxE = max(right.maxE, self.maxE)\n\ndef build(i, j):\n    if i == j:\n        return Node(val=arr[i])\n    else:\n        m = (i + j) // 2\n        return Node(left=build(i, m), right=build(m + 1, j))\n\ndef query(node, i, j, ql, qr):\n    if i == ql and j == qr:\n        return (node.minE, node.maxE)\n    else:\n        m = (i + j) // 2\n        m1 = m3 = 10 ** 9\n        m2 = m4 = 0\n        if ql <= m:\n            (m1, m2) = query(node.left, i, m, ql, min(qr, m))\n        if qr >= m + 1:\n            (m3, m4) = query(node.right, m + 1, j, max(ql, m + 1), qr)\n        return (min(m1, m3), max(m2, m4))\nN = int(input())\narr = list(map(int, input().split()))\nroot = build(0, N - 1)\nQ = int(input())\nfor _ in range(Q):\n    (x, y) = map(int, input().split())\n    ans = 0\n    (mi, ma) = query(root, 0, N - 1, x, y)\n    maxO = 0\n    if x > 0:\n        (_, maxO) = query(root, 0, N - 1, 0, x - 1)\n    if y < N - 1:\n        (_, t) = query(root, 0, N - 1, y + 1, N - 1)\n        maxO = max(maxO, t)\n    print(float(max(maxO + mi, (mi + ma) / 2)))", "import sys\nfrom math import floor, log2\n\nclass IO:\n\n    def read(self):\n        return sys.stdin.readline().strip()\n\n    def Int(self):\n        return int(self.read())\n\n    def Tuple(self, dtype=int):\n        return map(dtype, self.read().split())\n\n    def List(self, dtype=int):\n        return list(map(dtype, self.read().split()))\n\n    def Print(self, *txt, sep=' ', end='\\n'):\n        sys.stdout.write(sep.join([str(ele) for ele in txt]) + end)\nK = 25\n\ndef build1(arr, n):\n    st = [[0] * K for i in range(n)]\n    for i in range(n):\n        st[i][0] = arr[i]\n    for j in range(1, K):\n        i = 0\n        while i + (1 << j) <= n:\n            st[i][j] = min(st[i][j - 1], st[i + (1 << j - 1)][j - 1])\n            i += 1\n    return st\n\ndef build2(arr, n):\n    st = [[0] * K for i in range(n)]\n    for i in range(n):\n        st[i][0] = arr[i]\n    for j in range(1, K):\n        i = 0\n        while i + (1 << j) <= n:\n            st[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1])\n            i += 1\n    return st\n\ndef query(arr, st, func, l, r, n):\n    if l < 0 or r < 0 or l > n - 1 or (r > n - 1) or (r < l):\n        return 0\n    j = floor(log2(r - l + 1))\n    return func(st[l][j], st[r - (1 << j) + 1][j])\nio = IO()\nn = io.Int()\narr = io.List()\nst1 = build1(arr, n)\nst2 = build2(arr, n)\nq = io.Int()\nfor i in range(q):\n    (l, r) = io.Tuple()\n    x1 = query(arr, st1, min, l, r, n)\n    x2 = query(arr, st2, max, l, r, n)\n    x3 = query(arr, st2, max, 0, l - 1, n)\n    x4 = query(arr, st2, max, r + 1, n - 1, n)\n    x = max((x2 - x1) / 2, x3, x4)\n    io.Print(float(x + x1))", "def minVal(x, y):\n    if x > y:\n        return y\n    else:\n        return x\n\ndef build_min(arr, st_min, ss, se, si):\n    if ss == se:\n        st_min[si] = arr[ss]\n        return\n    mid = ss + (se - ss) // 2\n    build_min(arr, st_min, ss, mid, 2 * si + 1)\n    build_min(arr, st_min, mid + 1, se, 2 * si + 2)\n    st_min[si] = minVal(st_min[si * 2 + 1], st_min[si * 2 + 2])\n    return\n\ndef build_max(arr, st_max, ss, se, si):\n    if ss == se:\n        st_max[si] = arr[ss]\n        return\n    mid = ss + (se - ss) // 2\n    build_max(arr, st_max, ss, mid, 2 * si + 1)\n    build_max(arr, st_max, mid + 1, se, 2 * si + 2)\n    st_max[si] = max(st_max[si * 2 + 1], st_max[si * 2 + 2])\n    return\n\ndef getMin(arr, st_min, ss, se, qs, qe, si):\n    if qs <= ss and qe >= se:\n        return st_min[si]\n    if qs > se or qe < ss:\n        return 10000000000000000000000000\n    mid = ss + (se - ss) // 2\n    return minVal(getMin(arr, st_min, ss, mid, qs, qe, 2 * si + 1), getMin(arr, st_min, mid + 1, se, qs, qe, 2 * si + 2))\n\ndef getMax(arr, st_max, ss, se, qs, qe, si):\n    if qs <= ss and qe >= se:\n        return st_max[si]\n    if qs > se or qe < ss:\n        return 0\n    mid = ss + (se - ss) // 2\n    return max(getMax(arr, st_max, ss, mid, qs, qe, 2 * si + 1), getMax(arr, st_max, mid + 1, se, qs, qe, 2 * si + 2))\nn = int(input())\narr = list(map(int, input().split()))\nst_min = [0] * (4 * n)\nst_max = [0] * (4 * n)\nbuild_min(arr, st_min, 0, n - 1, 0)\nbuild_max(arr, st_max, 0, n - 1, 0)\nq = int(input())\nwhile q:\n    (L, R) = map(int, input().split())\n    maxx = getMax(arr, st_max, 0, n - 1, L, R, 0)\n    minn = getMin(arr, st_min, 0, n - 1, L, R, 0)\n    total = 0\n    if maxx == st_max[0]:\n        val1 = maxx - minn\n        val1 = val1 / 2\n        total = minn + val1\n        new_max = max(getMax(arr, st_max, 0, n - 1, 0, L - 1, 0), getMax(arr, st_max, 0, n - 1, R + 1, n - 1, 0))\n        new_max = new_max + minn\n        if new_max >= total:\n            print(float(new_max))\n        else:\n            print(float(total))\n    else:\n        num = st_max[0] + minn\n        print(float(num))\n    q = q - 1", "N = int(input())\narr = [int(x) for x in input().split()]\nMAXN = 100005\nseg = [0] * (4 * MAXN)\nseg1 = [0] * (4 * MAXN)\n\ndef build(node, ss, se):\n    if ss == se:\n        seg[node] = arr[ss]\n        return arr[ss]\n    mid = ss + se >> 1\n    build(2 * node + 1, ss, mid)\n    build(2 * node + 2, mid + 1, se)\n    seg[node] = min(seg[2 * node + 1], seg[2 * node + 2])\n\ndef build1(node, ss, se):\n    if ss == se:\n        seg1[node] = arr[ss]\n        return arr[ss]\n    mid = ss + se >> 1\n    build1(2 * node + 1, ss, mid)\n    build1(2 * node + 2, mid + 1, se)\n    seg1[node] = max(seg1[2 * node + 1], seg1[2 * node + 2])\n\ndef getmin(node, ss, se, qs, qe):\n    if qs > se or qe < ss or qs > qe:\n        return 1000000000000000000000000000\n    if qs <= ss and qe >= se:\n        return seg[node]\n    mid = ss + se >> 1\n    return min(getmin(2 * node + 1, ss, mid, qs, qe), getmin(2 * node + 2, mid + 1, se, qs, qe))\n\ndef getmax(node, ss, se, qs, qe):\n    if qs > se or qe < ss or qs > qe:\n        return 0\n    if qs <= ss and qe >= se:\n        return seg1[node]\n    mid = ss + se >> 1\n    return max(getmax(2 * node + 1, ss, mid, qs, qe), getmax(2 * node + 2, mid + 1, se, qs, qe))\nbuild1(0, 0, N - 1)\nbuild(0, 0, N - 1)\nQ = int(input())\nfor i in range(0, Q):\n    (L, R) = map(int, input().split())\n    t1 = getmax(0, 0, N - 1, 0, L - 1)\n    t2 = getmax(0, 0, N - 1, R + 1, N - 1)\n    t3 = getmin(0, 0, N - 1, L, R)\n    t4 = getmax(0, 0, N - 1, L, R)\n    ans = t3 + max(t1 / 1, t2 / 1, (t4 - t3) / 2)\n    print(ans)", "def min_stree(i, l, h):\n    if l == h:\n        minsegmenttree[i] = b[l]\n        return b[l]\n    m = (l + h) // 2\n    left = min_stree(i * 2 + 1, l, m)\n    right = min_stree(i * 2 + 2, m + 1, h)\n    minsegmenttree[i] = min(left, right)\n    return minsegmenttree[i]\n\ndef max_stree(i, l, h):\n    if l == h:\n        maxsegmenttree[i] = b[l]\n        return b[l]\n    m = (l + h) // 2\n    left = max_stree(i * 2 + 1, l, m)\n    right = max_stree(i * 2 + 2, m + 1, h)\n    maxsegmenttree[i] = max(left, right)\n    return maxsegmenttree[i]\n\ndef getmin(i, low, high, l, r):\n    if r < low or l > high:\n        return 10 ** 8\n    if l <= low and high <= r:\n        return minsegmenttree[i]\n    m = (low + high) // 2\n    left = getmin(i * 2 + 1, low, m, l, r)\n    right = getmin(i * 2 + 2, m + 1, high, l, r)\n    return min(left, right)\n\ndef getmax(i, low, high, l, r):\n    if r < low or l > high:\n        return 0\n    if l <= low and high <= r:\n        return maxsegmenttree[i]\n    m = (low + high) // 2\n    left = getmax(i * 2 + 1, low, m, l, r)\n    right = getmax(i * 2 + 2, m + 1, high, l, r)\n    return max(left, right)\nn = int(input())\nb = list(map(int, input().split()))\nminsegmenttree = [0] * (4 * n)\nmaxsegmenttree = [0] * (4 * n)\nmin_stree(0, 0, n - 1)\nmax_stree(0, 0, n - 1)\nq = int(input())\nfor _ in range(q):\n    (l, r) = map(int, input().split())\n    fastburn = getmin(0, 0, n - 1, l, r)\n    slowburn = getmax(0, 0, n - 1, l, r)\n    lside_slowburn = 0\n    if l > 0:\n        lside_slowburn = getmax(0, 0, n - 1, 0, l - 1)\n    rside_slowburn = 0\n    if r < n - 1:\n        rside_slowburn = getmax(0, 0, n - 1, r + 1, n - 1)\n    inrange_slowburn = (slowburn - fastburn) / 2\n    tot_time = fastburn + max(lside_slowburn, rside_slowburn, inrange_slowburn)\n    print(float(tot_time))", "def buildSparseTable(n, st, kt, a):\n    j = 1\n    while 1 << j <= n:\n        i = 0\n        while i + (1 << j) - 1 < n:\n            if st[i][j - 1] < st[i + (1 << j - 1)][j - 1]:\n                st[i][j] = st[i][j - 1]\n            else:\n                st[i][j] = st[i + (1 << j - 1)][j - 1]\n            if kt[i][j - 1] > kt[i + (1 << j - 1)][j - 1]:\n                kt[i][j] = kt[i][j - 1]\n            else:\n                kt[i][j] = kt[i + (1 << j - 1)][j - 1]\n            i += 1\n        j += 1\n\ndef st(L, R, log2):\n    j = int(log2[R - L + 1])\n    if mina[L][j] <= mina[R - (1 << j) + 1][j]:\n        return mina[L][j]\n    else:\n        return mina[R - (1 << j) + 1][j]\n\ndef kt(L, R, log2):\n    j = int(log2[R - L + 1])\n    if maxa[L][j] >= maxa[R - (1 << j) + 1][j]:\n        return maxa[L][j]\n    else:\n        return maxa[R - (1 << j) + 1][j]\nn = int(input().strip())\nlog2 = [0, 0]\nfor i in range(2, n + 1):\n    log2.append(log2[i // 2] + 1)\narr = list(map(int, input().split()))\nk = log2[n]\n(mina, maxa) = [[[arr[j] for i in range(k + 1)] for j in range(n)] for x in range(2)]\nbuildSparseTable(n, mina, maxa, arr)\nq = int(input().strip())\nfor __ in range(q):\n    (a, b) = map(int, input().split())\n    m2 = st(a, b, log2)\n    m3 = kt(a, b, log2)\n    if a == 0:\n        m1 = 0\n    else:\n        m1 = kt(0, max(a - 1, 0), log2)\n    if b == n - 1:\n        m4 = 0\n    else:\n        m4 = kt(min(n - 1, b + 1), n - 1, log2)\n    m3 -= m2\n    m3 /= 2\n    print(max(m1 / 1, m3 / 1, m4 / 1) + m2)", "def precompute(arr, k, t):\n    stl = [[arr[i] for _ in range(k)] for i in range(len(arr))]\n    if t > 1:\n        for j in range(1, k):\n            i = 0\n            while i + (1 << j) <= len(arr):\n                stl[i][j] = max(stl[i][j - 1], stl[i + (1 << j - 1)][j - 1])\n                i += 1\n    else:\n        for j in range(1, k):\n            i = 0\n            while i + (1 << j) <= len(arr):\n                stl[i][j] = min(stl[i][j - 1], stl[i + (1 << j - 1)][j - 1])\n                i += 1\n    return stl\n\ndef main_method():\n    n = int(input())\n    log = [0 for _ in range(pow(10, 5) + 1)]\n    for i in range(2, pow(10, 5) + 1):\n        log[i] = log[i // 2] + 1\n    arr = list(map(int, input().strip().split()))\n    k = 0\n    while 1 << k <= len(arr):\n        k += 1\n    stl_min = precompute(arr, k, 1)\n    stl_max = precompute(arr, k, 2)\n    t = int(input())\n    while t > 0:\n        t -= 1\n        (p, q) = list(map(int, input().strip().split()))\n        temp_max = 0\n        min_range = min(stl_min[p][log[q - p + 1]], stl_min[q - (1 << log[q - p + 1]) + 1][log[q - p + 1]])\n        max_range = max(stl_max[p][log[q - p + 1]], stl_max[q - (1 << log[q - p + 1]) + 1][log[q - p + 1]])\n        if p > 0:\n            temp_max = max(temp_max, max(stl_max[0][log[p]], stl_max[p - (1 << log[p])][log[p]]))\n        if q < len(arr) - 1:\n            temp_max = max(temp_max, max(stl_max[q + 1][log[len(arr) - q - 1]], stl_max[len(arr) - (1 << log[len(arr) - q - 1])][log[len(arr) - q - 1]]))\n        max_range += min_range\n        max_range /= 2\n        print('{}'.format(float(max(temp_max + min_range, max_range))))\nmain_method()", "from math import log2\nN = int(input())\na = list(map(int, input().split()))\nQ = int(input())\nK = int(log2(N))\nmaxTable = [[0 for j in range(K + 1)] for i in range(N)]\nminTable = [[0 for j in range(K + 1)] for i in range(N)]\nfor i in range(N):\n    maxTable[i][0] = a[i]\n    minTable[i][0] = a[i]\nfor j in range(1, K + 1):\n    for i in range(N - (1 << j) + 1):\n        maxTable[i][j] = max(maxTable[i][j - 1], maxTable[i + (1 << j - 1)][j - 1])\n        minTable[i][j] = min(minTable[i][j - 1], minTable[i + (1 << j - 1)][j - 1])\nlogs = [0] * (N + 1)\nlogs[1] = 0\nfor i in range(2, N + 1):\n    logs[i] = 1 + logs[i // 2]\n\ndef findMax(l, r):\n    interval = logs[r - l + 1]\n    maxVal = max(maxTable[l][interval], maxTable[r - (1 << interval) + 1][interval])\n    return maxVal\n\ndef findMin(l, r):\n    interval = logs[r - l + 1]\n    minVal = min(minTable[l][interval], minTable[r - (1 << interval) + 1][interval])\n    return minVal\nfor q in range(Q):\n    (l, r) = list(map(int, input().split()))\n    interval = logs[r - l + 1]\n    maxVal = max(maxTable[l][interval], maxTable[r - (1 << interval) + 1][interval])\n    minVal = min(minTable[l][interval], minTable[r - (1 << interval) + 1][interval])\n    (leftMax, rightMax) = (0, 0)\n    if l > 0:\n        leftMax = findMax(0, l - 1)\n    if r < N - 1:\n        rightMax = findMax(r + 1, N - 1)\n    print('{:.1f}'.format(minVal + max(leftMax, rightMax, (maxVal - minVal) / 2)))", "from math import log2, floor\nn = int(input())\nb = list(map(int, input().split()))\nk = floor(log2(n))\ntb1 = [[0] * (k + 1) for _ in range(n)]\ntb2 = [[0] * (k + 1) for _ in range(n)]\nfor i in range(n):\n    tb1[i][0] = b[i]\n    tb2[i][0] = b[i]\nfor j in range(1, k + 1):\n    for i in range(n - (1 << j) + 1):\n        tb1[i][j] = max(tb1[i][j - 1], tb1[i + (1 << j - 1)][j - 1])\n        tb2[i][j] = min(tb2[i][j - 1], tb2[i + (1 << j - 1)][j - 1])\n\ndef maxquery(l, r):\n    k = floor(log2(r - l + 1))\n    return max(tb1[l][k], tb1[r - (1 << k) + 1][k])\n\ndef minquery(l, r):\n    k = floor(log2(r - l + 1))\n    return min(tb2[l][k], tb2[r - (1 << k) + 1][k])\n\ndef query(l, r):\n    m = minquery(l, r)\n    M = maxquery(l, r)\n    y = max(maxquery(0, l - 1) if l > 0 else 0, maxquery(r + 1, n - 1) if r < n - 1 else 0)\n    return m + max((M - m) / 2, y)\nq = int(input())\nfor _ in range(q):\n    (l, r) = map(int, input().split())\n    print('{:.1f}'.format(query(l, r)))", "maxN = 100000\nlog = [0 for i in range(maxN + 1)]\nfor i in range(2, maxN + 1):\n    log[i] = log[i // 2] + 1\n\ndef log2(n):\n    return log[n]\n\ndef preComputeMax(a):\n    n = len(a)\n    k = log2(maxN)\n    sp = [[0 for i in range(k + 1)] for j in range(n)]\n    for i in range(n):\n        sp[i][0] = a[i]\n    for j in range(1, k + 1):\n        for i in range(n + 1 - (1 << j)):\n            sp[i][j] = max(sp[i][j - 1], sp[i + (1 << j - 1)][j - 1])\n    return sp\n\ndef preComputeMin(a):\n    n = len(a)\n    k = log2(maxN)\n    sp = [[0 for i in range(k + 1)] for j in range(n)]\n    for i in range(n):\n        sp[i][0] = a[i]\n    for j in range(1, k + 1):\n        for i in range(n + 1 - (1 << j)):\n            sp[i][j] = min(sp[i][j - 1], sp[i + (1 << j - 1)][j - 1])\n    return sp\n\ndef maxRangeQueries(l, r):\n    length = r - l + 1\n    k = log2(length)\n    return max(spmax[l][k], spmax[r - (1 << k) + 1][k])\n\ndef minRangeQueries(l, r):\n    length = r - l + 1\n    k = log2(length)\n    return min(spmin[l][k], spmin[r - (1 << k) + 1][k])\nn = int(input())\na = list(map(int, input().split()))\nspmin = preComputeMin(a)\nspmax = preComputeMax(a)\nq = int(input())\nfor _ in range(q):\n    (l, r) = map(int, input().split())\n    m = float(minRangeQueries(l, r))\n    M = float(maxRangeQueries(l, r))\n    left = 0\n    right = 0\n    if l > 0:\n        left = maxRangeQueries(0, l - 1)\n    if r < n - 1:\n        right = maxRangeQueries(r + 1, n - 1)\n    md = float(max(left, right))\n    print(m + max((M - m) / 2, md))", "from math import gcd\nlogs = [0] * (10 ** 5 + 10)\nlogs[0] = 11\nn = int(input())\narr = list(map(int, input().split()))\nfor i in range(2, n + 1):\n    logs[i] = logs[i // 2] + 1\ntable = [[0 for i in range(n)] for j in range(logs[n] + 1)]\nfor i in range(logs[n] + 1):\n    curr_len = 2 ** i\n    j = 0\n    while j + curr_len <= n:\n        if curr_len == 1:\n            table[i][j] = arr[j]\n        else:\n            table[i][j] = max(table[i - 1][j], table[i - 1][j + curr_len // 2])\n        j += 1\ntable2 = [[0 for i in range(n)] for j in range(logs[n] + 1)]\nfor i in range(logs[n] + 1):\n    curr_len = 2 ** i\n    j = 0\n    while j + curr_len <= n:\n        if curr_len == 1:\n            table2[i][j] = arr[j]\n        else:\n            table2[i][j] = min(table2[i - 1][j], table2[i - 1][j + curr_len // 2])\n        j += 1\n\ndef query(l, r, choice):\n    p = logs[r - l + 1]\n    p_len = 1 << p\n    if choice == 1:\n        return max(table[p][l], table[p][r - p_len + 1])\n    else:\n        return min(table2[p][l], table2[p][r - p_len + 1])\nfor i in range(int(input())):\n    (l, r) = map(int, input().split())\n    out_max1 = -9 * 10 ** 9\n    if l != 0:\n        out_max1 = query(0, l - 1, 1)\n    if r != n - 1:\n        out_max1 = max(out_max1, query(r + 1, n - 1, 1))\n    mini = query(l, r, 0)\n    in_max = query(l, r, 1)\n    print('{:.1f}'.format(mini + max((in_max - mini) / 2, out_max1)))", "import math\n\ndef query_mi(l, r):\n    j = int(math.log(r - l + 1, 2))\n    minimum = min(dp_m[l][j], dp_m[r - (1 << j) + 1][j])\n    return minimum\n\ndef query_ma(l, r):\n    j = int(math.log(r - l + 1, 2))\n    maximum = max(dp_ma[l][j], dp_ma[r - (1 << j) + 1][j])\n    return maximum\nn = int(input())\narr = [int(i) for i in input().split()]\nk = int(math.floor(math.log(n, 2))) + 1\ndp_m = [[0 for j in range(k)] for i in range(n)]\nfor i in range(n):\n    dp_m[i][0] = arr[i]\nfor j in range(1, k + 1):\n    i = 0\n    while i + (1 << j) <= n:\n        dp_m[i][j] = min(dp_m[i][j - 1], dp_m[i + (1 << j - 1)][j - 1])\n        i += 1\ndp_ma = [[0 for j in range(k)] for i in range(n)]\nfor i in range(n):\n    dp_ma[i][0] = arr[i]\nfor j in range(1, k + 1):\n    i = 0\n    while i + (1 << j) <= n:\n        dp_ma[i][j] = max(dp_ma[i][j - 1], dp_ma[i + (1 << j - 1)][j - 1])\n        i += 1\nq = int(input())\nfor _ in range(q):\n    (l, r) = [int(i) for i in input().split()]\n    mi_ins = query_mi(l, r)\n    ma_ins = query_ma(l, r)\n    t1 = 0\n    t2 = 0\n    if l - 1 >= 0:\n        t1 = query_ma(0, l - 1)\n    if r + 1 <= n - 1:\n        t2 = query_ma(r + 1, n - 1)\n    ma_out = max(t1, t2)\n    ma_out = float(ma_out)\n    ans = mi_ins + max(ma_out, (ma_ins - mi_ins) / 2)\n    print(ans)", "from math import inf\n\ndef build_max():\n    i = n - 1\n    while i > 0:\n        t_max[i] = max(t_max[i << 1], t_max[i << 1 | 1])\n        i -= 1\n\ndef build_min():\n    i = n - 1\n    while i > 0:\n        t_min[i] = min(t_min[i << 1], t_min[i << 1 | 1])\n        i -= 1\n\ndef max_query(l, r):\n    ans = 0\n    l += n\n    r += n\n    while l < r:\n        if l & 1:\n            ans = max(ans, t_max[l])\n            l += 1\n        if r & 1:\n            r -= 1\n            ans = max(ans, t_max[r])\n        l >>= 1\n        r >>= 1\n    return ans\n\ndef min_query(l, r):\n    ans = inf\n    l += n\n    r += n\n    while l < r:\n        if l & 1:\n            ans = min(ans, t_min[l])\n            l += 1\n        if r & 1:\n            r -= 1\n            ans = min(ans, t_min[r])\n        l >>= 1\n        r >>= 1\n    return ans\nn = int(input())\nt_max = [0] * (2 * n)\nt_min = [inf] * (2 * n)\narray = list(map(int, input().split()))\nfor i in range(n):\n    t_max[i + n] = array[i]\n    t_min[i + n] = array[i]\nbuild_min()\nbuild_max()\nq = int(input())\nfor _ in range(q):\n    (l, r) = map(int, input().split())\n    max1 = max_query(0, l)\n    max2 = max_query(r + 1, n)\n    max3 = max_query(l, r + 1)\n    min4 = min_query(l, r + 1)\n    temp = (max3 - min4) / 2\n    ans = max(max1 + min4, max2 + min4, min4 + temp)\n    if type(ans) == int:\n        print(str(ans) + '.0')\n    else:\n        ans = str(ans)\n        c = ans.index('.')\n        print(ans[:c + 2])", "import math\nn = int(input())\nbi = list(map(int, input().strip().split(' ')))\nk = int(math.log2(n))\nk += 1\nlog = [0] * (n + 1)\nlog[1] = 0\nfor i in range(2, n + 1):\n    log[i] = log[i // 2] + 1\nsmax = [[0] * (k + 1) for _ in range(n)]\nsmin = [[0] * (k + 1) for _ in range(n)]\nfor i in range(n):\n    smax[i][0] = bi[i]\n    smin[i][0] = bi[i]\nfor j in range(1, k + 2):\n    i = 0\n    while i + (1 << j) <= n:\n        smin[i][j] = min(smin[i][j - 1], smin[i + (1 << j - 1)][j - 1])\n        smax[i][j] = max(smax[i][j - 1], smax[i + (1 << j - 1)][j - 1])\n        i += 1\n\ndef val(l, u):\n    if u >= n or u < 0 or l > u or (l > n - 1):\n        return (0, 0)\n    else:\n        x = log[u - l + 1]\n        return (max(smax[l][x], smax[u - (1 << x) + 1][x]), min(smin[l][x], smin[u - (1 << x) + 1][x]))\nq = int(input())\nwhile q:\n    q -= 1\n    (x, y) = map(int, input().strip().split(' '))\n    (mx, mn) = val(x, y)\n    (mx1, mn1) = val(y + 1, n - 1)\n    (mx2, mn2) = val(0, x - 1)\n    result = max(mx2 + mn, mx1 + mn, mn + (mx - mn) / 2)\n    print('%.1f' % result)", "from math import *\n\ndef make_sparse_table_max(arr, n):\n    row = n\n    col = floor(log2(n)) + 1\n    st = [[-1 for x in range(col)] for x in range(row)]\n    for i in range(row):\n        st[i][0] = arr[i]\n    for j in range(1, col):\n        i = 0\n        while i + (1 << j) <= n:\n            st[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1])\n            i += 1\n    return st\n\ndef make_sparse_table_min(arr, n):\n    row = n\n    col = floor(log2(n)) + 1\n    st = [[-1 for x in range(col)] for x in range(row)]\n    for i in range(row):\n        st[i][0] = arr[i]\n    for j in range(1, col):\n        i = 0\n        while i + (1 << j) <= n:\n            st[i][j] = min(st[i][j - 1], st[i + (1 << j - 1)][j - 1])\n            i += 1\n    return st\n\ndef find_max(st1, l, r):\n    j = floor(log2(r - l + 1))\n    ans = max(st1[l][j], st1[r - (1 << j) + 1][j])\n    return ans\n\ndef find_min(st2, l, r):\n    j = floor(log2(r - l + 1))\n    ans = min(st2[l][j], st2[r - (1 << j) + 1][j])\n    return ans\nn = int(input())\narr = [int(x) for x in input().split()]\nst1 = make_sparse_table_max(arr, n)\nst2 = make_sparse_table_min(arr, n)\nq = int(input())\nwhile q:\n    (l, r) = input().split()\n    l = int(l)\n    r = int(r)\n    ans1 = 0\n    ans2 = 0\n    ans3 = find_min(st2, l, r)\n    if l != 0:\n        ans1 = find_max(st1, 0, l - 1)\n    if r != n - 1:\n        ans2 = find_max(st1, r + 1, n - 1)\n    ans4 = max(ans2, ans1) + ans3\n    ans5 = ans3 + (find_max(st1, l, r) - ans3) / 2\n    ans = max(ans4, ans5)\n    print(float(ans))\n    q -= 1", "import numpy as np\nn = int(input())\nk = int(np.log2(n)) + 2\nst_min = np.zeros((n, k), dtype=np.uint32)\nst_max = np.zeros((n, k), dtype=np.uint32)\narr = tuple(map(int, input().split()))\n\ndef log(x):\n    j = 20\n    mask = 1 << j\n    while j:\n        if mask & x:\n            return j\n        j -= 1\n        mask >>= 1\n    return 0\nst_min[:, 0] = arr\nst_max[:, 0] = arr\nfor j in range(1, k):\n    i = 0\n    while i + (1 << j) <= n:\n        st_min[i][j] = min(st_min[i][j - 1], st_min[i + (1 << j - 1)][j - 1])\n        st_max[i][j] = max(st_max[i][j - 1], st_max[i + (1 << j - 1)][j - 1])\n        i += 1\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    j = log(r - l + 1)\n    ans1 = min(st_min[l][j], st_min[r - (1 << j) + 1][j])\n    ans2 = (max(st_max[l][j], st_max[r - (1 << j) + 1][j]) - ans1) / 2\n    if l > 0:\n        j1 = log(l)\n        ans2 = max(ans2, st_max[0][j1], st_max[l - (1 << j1)][j1])\n    if r < n - 1:\n        j2 = log(n - 1 - r)\n        ans2 = max(ans2, st_max[r + 1][j2], st_max[n - (1 << j2)][j2])\n    print('{:0.1f}'.format(ans1 + ans2))", "import math\n\ndef get(l, r, a):\n    x = len(a) // 2\n    y = l\n    n = r\n    m = len(a)\n    o = 0\n    p = 0\n    q = 1000000001\n    while l < r:\n        if l % 2 == 1:\n            p = max(p, a[l][1])\n            q = min(q, a[l][0])\n            l += 1\n        if r % 2 == 1:\n            p = max(p, a[r - 1][1])\n            q = min(q, a[r - 1][0])\n            r -= 1\n        l //= 2\n        r //= 2\n    z = 0\n    while x < y:\n        if x % 2 == 1:\n            z = max(z, a[x][1])\n            x += 1\n        if y % 2 == 1:\n            z = max(z, a[y - 1][1])\n            y -= 1\n        x //= 2\n        y //= 2\n    while n < m:\n        if n % 2 == 1:\n            o = max(o, a[n][1])\n            n += 1\n        if m % 2 == 1:\n            o = max(o, a[m - 1][1])\n            m -= 1\n        n //= 2\n        m //= 2\n    o = max(o, z)\n    s = q + max((p - q) / 2, o)\n    return s\nx = int(input())\na = list(map(int, input().split()))\nlol = [[0] * 2] * x * 2\ni = 2 * x - 1\nwhile i > 0:\n    if i >= x:\n        lol[i] = [a[i - x], a[i - x]]\n    else:\n        p = min(lol[2 * i][0], lol[2 * i + 1][0])\n        q = max(lol[2 * i][1], lol[2 * i + 1][1])\n        lol[i] = [p, q]\n    i -= 1\nn = int(input())\nfor __ in range(n):\n    (l, r) = map(int, input().split())\n    r += 1 + x\n    l += x\n    print('%.1f' % get(l, r, lol))", "from math import *\n\ndef make_sparse_table_max(arr, n):\n    row = n\n    col = floor(log2(n)) + 1\n    st = [[-1 for x in range(col)] for x in range(row)]\n    for i in range(row):\n        st[i][0] = arr[i]\n    for j in range(1, col):\n        i = 0\n        while i + (1 << j) <= n:\n            st[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1])\n            i += 1\n    return st\n\ndef make_sparse_table_min(arr, n):\n    row = n\n    col = floor(log2(n)) + 1\n    st = [[-1 for x in range(col)] for x in range(row)]\n    for i in range(row):\n        st[i][0] = arr[i]\n    for j in range(1, col):\n        i = 0\n        while i + (1 << j) <= n:\n            st[i][j] = min(st[i][j - 1], st[i + (1 << j - 1)][j - 1])\n            i += 1\n    return st\n\ndef find_max(st1, l, r):\n    j = floor(log2(r - l + 1))\n    ans = max(st1[l][j], st1[r - (1 << j) + 1][j])\n    return ans\n\ndef find_min(st2, l, r):\n    j = floor(log2(r - l + 1))\n    ans = min(st2[l][j], st2[r - (1 << j) + 1][j])\n    return ans\nn = int(input())\narr = [int(x) for x in input().split()]\nst1 = make_sparse_table_max(arr, n)\nst2 = make_sparse_table_min(arr, n)\nq = int(input())\nwhile q:\n    (l, r) = input().split()\n    l = int(l)\n    r = int(r)\n    ans1 = 0\n    ans2 = 0\n    ans3 = find_min(st2, l, r)\n    if l != 0:\n        ans1 = find_max(st1, 0, l - 1)\n    if r != n - 1:\n        ans2 = find_max(st1, r + 1, n - 1)\n    ans4 = max(ans2, ans1) + ans3\n    ans5 = ans3 + (find_max(st1, l, r) - ans3) / 2\n    ans = max(ans4, ans5)\n    print(float(ans))\n    q -= 1", "from sys import stdin\ninput = stdin.readline\n\ndef getmin(l, r):\n    x = log[r - l + 1]\n    return min(dpmin[x][l], dpmin[x][r - (1 << x) + 1])\n\ndef getmax(l, r):\n    if l > r:\n        return 0\n    x = log[r - l + 1]\n    return max(dpmax[x][l], dpmax[x][r - (1 << x) + 1])\nn = int(input())\ndpmin = list(map(int, input().split()))\nlog = [0, 0]\nfor i in range(2, n + 1):\n    log += [log[i // 2] + 1]\nx = log[n]\ndpmax = dpmin.copy()\ndpmin = [dpmin] + [[0] * n for i in range(x)]\ndpmax = [dpmax] + [[0] * n for i in range(x)]\nfor i in range(1, x + 1):\n    for j in range(n):\n        dpmax[i][j] = max(dpmax[i - 1][j], dpmax[i - 1][min(j + (1 << i - 1), n - 1)])\n        dpmin[i][j] = min(dpmin[i - 1][j], dpmin[i - 1][min(j + (1 << i - 1), n - 1)])\nfor i in range(int(input())):\n    (l, r) = map(int, input().split())\n    burnmin = getmin(l, r)\n    burnmax = getmax(l, r)\n    out = burnmin + max(getmax(0, l - 1), getmax(r + 1, n - 1), (burnmax - burnmin) / 2)\n    print(format(out, '.1f'))", "from sys import stdin\ninput = stdin.readline\n\ndef getmin(l, r):\n    x = log[r - l + 1]\n    return min(dpmin[x][l], dpmin[x][r - (1 << x) + 1])\n\ndef getmax(l, r):\n    if l > r:\n        return 0\n    x = log[r - l + 1]\n    return max(dpmax[x][l], dpmax[x][r - (1 << x) + 1])\nn = int(input())\ndpmin = list(map(int, input().split()))\nlog = [-1]\nfor i in range(1, n + 1):\n    log.append(log[i // 2] + 1)\nx = log[n]\ndpmin = [dpmin] + [[0] * n for i in range(x)]\ndpmax = [dpmin[0].copy()] + [[0] * n for i in range(x)]\nfor i in range(1, x + 1):\n    for j in range(n):\n        dpmax[i][j] = max(dpmax[i - 1][j], dpmax[i - 1][min(j + (1 << i - 1), n - 1)])\n        dpmin[i][j] = min(dpmin[i - 1][j], dpmin[i - 1][min(j + (1 << i - 1), n - 1)])\nfor i in range(int(input())):\n    (l, r) = map(int, input().split())\n    burnmin = getmin(l, r)\n    burnmax = getmax(l, r)\n    out = burnmin + max(getmax(0, l - 1), getmax(r + 1, n - 1), (burnmax - burnmin) / 2)\n    print(format(out, '.1f'))", "import sys\nMAX = sys.maxsize\nMAXN = 10 ** 5 + 10\nlogT = [0] * MAXN\nfor i in range(2, MAXN):\n    logT[i] = logT[i // 2] + 1\n\ndef buildSparse(a):\n    n = len(a)\n    k = logT[n] + 1\n    st1 = [[MAX for j in range(k)] for i in range(n)]\n    st2 = [[-MAX for j in range(k)] for i in range(n)]\n    for i in range(n):\n        st1[i][0] = a[i]\n        st2[i][0] = a[i]\n    j = 1\n    while 1 << j <= n:\n        i = 0\n        while i + (1 << j) - 1 < n:\n            st1[i][j] = min(st1[i][j - 1], st1[i + (1 << j - 1)][j - 1])\n            st2[i][j] = max(st2[i][j - 1], st2[i + (1 << j - 1)][j - 1])\n            i += 1\n        j += 1\n    return (st1, st2)\n\ndef query(l, r, x, st1, st2):\n    if l > r:\n        if x:\n            return -MAX\n        else:\n            return MAX\n    tot = r - l + 1\n    k = logT[tot]\n    if x:\n        return max(st2[l][k], st2[l + tot - (1 << k)][k])\n    else:\n        return min(st1[l][k], st1[l + tot - (1 << k)][k])\nn = int(input())\na = list(map(int, sys.stdin.readline().strip().split()))\n(st1, st2) = buildSparse(a)\nq = int(input())\nfor _ in range(q):\n    (l, r) = map(int, sys.stdin.readline().strip().split())\n    mnlr = query(l, r, 0, st1, st2)\n    mxlr = query(l, r, 1, st1, st2)\n    mx0l = query(0, l - 1, 1, st1, st2)\n    mxrn = query(r + 1, n - 1, 1, st1, st2)\n    res = mnlr + max(mx0l, mxrn, (mxlr - mnlr) / 2)\n    print(format(res, '.1f'))", "from math import *\nimport sys\nMAX = sys.maxsize\n\ndef buildSparse(a):\n    n = len(a)\n    k = floor(log(n, 2)) + 1\n    st1 = [[MAX for j in range(k)] for i in range(n)]\n    st2 = [[-MAX for j in range(k)] for i in range(n)]\n    for i in range(n):\n        st1[i][0] = a[i]\n        st2[i][0] = a[i]\n    j = 1\n    while 1 << j <= n:\n        i = 0\n        while i + (1 << j) - 1 < n:\n            st1[i][j] = min(st1[i][j - 1], st1[i + (1 << j - 1)][j - 1])\n            st2[i][j] = max(st2[i][j - 1], st2[i + (1 << j - 1)][j - 1])\n            i += 1\n        j += 1\n    return (st1, st2)\n\ndef query(l, r, x, st1, st2):\n    if l > r:\n        if x:\n            return -MAX\n        else:\n            return MAX\n    tot = r - l + 1\n    k = floor(log(tot, 2))\n    if x:\n        return max(st2[l][k], st2[l + tot - (1 << k)][k])\n    else:\n        return min(st1[l][k], st1[l + tot - (1 << k)][k])\nn = int(input())\na = list(map(int, sys.stdin.readline().strip().split()))\n(st1, st2) = buildSparse(a)\nq = int(input())\nfor _ in range(q):\n    (l, r) = map(int, sys.stdin.readline().strip().split())\n    mnlr = query(l, r, 0, st1, st2)\n    mxlr = query(l, r, 1, st1, st2)\n    mx0l = query(0, l - 1, 1, st1, st2)\n    mxrn = query(r + 1, n - 1, 1, st1, st2)\n    res = mnlr + max(mx0l, mxrn, (mxlr - mnlr) / 2)\n    print(format(res, '.1f'))", "from math import *\nimport sys\nMAX = sys.maxsize\n\ndef buildSparse(a):\n    n = len(a)\n    k = floor(log(n, 2)) + 1\n    st1 = [[MAX for j in range(k)] for i in range(n)]\n    st2 = [[-MAX for j in range(k)] for i in range(n)]\n    for i in range(n):\n        st1[i][0] = a[i]\n        st2[i][0] = a[i]\n    j = 1\n    while 2 ** j <= n:\n        i = 0\n        while i + 2 ** j - 1 < n:\n            st1[i][j] = min(st1[i][j - 1], st1[i + 2 ** (j - 1)][j - 1])\n            st2[i][j] = max(st2[i][j - 1], st2[i + 2 ** (j - 1)][j - 1])\n            i += 1\n        j += 1\n    return (st1, st2)\n\ndef query(l, r, x, st1, st2):\n    if l > r:\n        if x:\n            return -MAX\n        else:\n            return MAX\n    tot = r - l + 1\n    k = floor(log(tot, 2))\n    if x:\n        return max(st2[l][k], st2[l + tot - 2 ** k][k])\n    else:\n        return min(st1[l][k], st1[l + tot - 2 ** k][k])\nn = int(input())\na = list(map(int, sys.stdin.readline().strip().split()))\n(st1, st2) = buildSparse(a)\nq = int(input())\nfor _ in range(q):\n    (l, r) = map(int, sys.stdin.readline().strip().split())\n    mnlr = query(l, r, 0, st1, st2)\n    mxlr = query(l, r, 1, st1, st2)\n    mx0l = query(0, l - 1, 1, st1, st2)\n    mxrn = query(r + 1, n - 1, 1, st1, st2)\n    res = mnlr + max(mx0l, mxrn, (mxlr - mnlr) / 2)\n    print(format(res, '.1f'))", "N = int(input())\narr = [int(x) for x in input().split()]\nMAXN = 100005\nseg = [0] * (4 * MAXN)\nseg1 = [0] * (4 * MAXN)\n\ndef build(node, ss, se):\n    if ss == se:\n        seg[node] = arr[ss]\n        return arr[ss]\n    mid = ss + se >> 1\n    build(2 * node + 1, ss, mid)\n    build(2 * node + 2, mid + 1, se)\n    seg[node] = min(seg[2 * node + 1], seg[2 * node + 2])\n\ndef build1(node, ss, se):\n    if ss == se:\n        seg1[node] = arr[ss]\n        return arr[ss]\n    mid = ss + se >> 1\n    build1(2 * node + 1, ss, mid)\n    build1(2 * node + 2, mid + 1, se)\n    seg1[node] = max(seg1[2 * node + 1], seg1[2 * node + 2])\n\ndef getmin(node, ss, se, qs, qe):\n    if qs > se or qe < ss or qs > qe:\n        return 1000000000000000000000000000\n    if qs <= ss and qe >= se:\n        return seg[node]\n    mid = ss + se >> 1\n    return min(getmin(2 * node + 1, ss, mid, qs, qe), getmin(2 * node + 2, mid + 1, se, qs, qe))\n\ndef getmax(node, ss, se, qs, qe):\n    if qs > se or qe < ss or qs > qe:\n        return 0\n    if qs <= ss and qe >= se:\n        return seg1[node]\n    mid = ss + se >> 1\n    return max(getmax(2 * node + 1, ss, mid, qs, qe), getmax(2 * node + 2, mid + 1, se, qs, qe))\nbuild1(0, 0, N - 1)\nbuild(0, 0, N - 1)\nQ = int(input())\nfor i in range(0, Q):\n    (L, R) = map(int, input().split())\n    t1 = getmax(0, 0, N - 1, 0, L - 1)\n    t2 = getmax(0, 0, N - 1, R + 1, N - 1)\n    t3 = getmin(0, 0, N - 1, L, R)\n    t4 = getmax(0, 0, N - 1, L, R)\n    ans = t3 + max(t1 / 1, t2 / 1, (t4 - t3) / 2)\n    print(ans)", "N = int(input())\narr = [int(x) for x in input().split()]\nMAXN = 100005\nseg = [0] * (4 * MAXN + 1)\nseg1 = [0] * (4 * MAXN + 1)\n\ndef build(node, ss, se):\n    if ss == se:\n        seg[node] = arr[ss]\n        return arr[ss]\n    mid = ss + se >> 1\n    build(2 * node + 1, ss, mid)\n    build(2 * node + 2, mid + 1, se)\n    seg[node] = min(seg[2 * node + 1], seg[2 * node + 2])\n\ndef build1(node, ss, se):\n    if ss == se:\n        seg1[node] = arr[ss]\n        return arr[ss]\n    mid = ss + se >> 1\n    build1(2 * node + 1, ss, mid)\n    build1(2 * node + 2, mid + 1, se)\n    seg1[node] = max(seg1[2 * node + 1], seg1[2 * node + 2])\n\ndef getmin(node, ss, se, qs, qe):\n    if qs > se or qe < ss or qs > qe:\n        return 1000000000000000000000000000\n    if qs <= ss and qe >= se:\n        return seg[node]\n    mid = ss + se >> 1\n    return min(getmin(2 * node + 1, ss, mid, qs, qe), getmin(2 * node + 2, mid + 1, se, qs, qe))\n\ndef getmax(node, ss, se, qs, qe):\n    if qs > se or qe < ss or qs > qe:\n        return 0\n    if qs <= ss and qe >= se:\n        return seg1[node]\n    mid = ss + se >> 1\n    return max(getmax(2 * node + 1, ss, mid, qs, qe), getmax(2 * node + 2, mid + 1, se, qs, qe))\nbuild1(0, 0, N - 1)\nbuild(0, 0, N - 1)\nQ = int(input())\nfor i in range(0, Q):\n    (L, R) = map(int, input().split())\n    t1 = getmax(0, 0, N - 1, 0, L - 1)\n    t2 = getmax(0, 0, N - 1, R + 1, N - 1)\n    t3 = getmin(0, 0, N - 1, L, R)\n    t4 = getmax(0, 0, N - 1, L, R)\n    ans = t3 + max(t1 / 1, t2 / 1, (t4 - t3) / 2)\n    print(ans)", "inf = 10 ** 20\n\ndef buildmax(v, start, end):\n    if start == end:\n        t2[v] = a[start]\n        return None\n    mid = (start + end) // 2\n    buildmax(v * 2, start, mid)\n    buildmax(v * 2 + 1, mid + 1, end)\n    t2[v] = max(t2[2 * v], t2[2 * v + 1])\n\ndef range_maximum_query(node, segx, segy, qx, qy):\n    if qx > segy or qy < segx or qx > qy:\n        return 0\n    elif segx >= qx and segy <= qy:\n        return t2[node]\n    else:\n        return max(range_maximum_query(node * 2, segx, (segx + segy) // 2, qx, qy), range_maximum_query(node * 2 + 1, (segx + segy) // 2 + 1, segy, qx, qy))\n\ndef build(v, start, end):\n    if start == end:\n        t1[v] = a[start]\n        return None\n    mid = (start + end) // 2\n    build(v * 2, start, mid)\n    build(v * 2 + 1, mid + 1, end)\n    t1[v] = min(t1[2 * v], t1[2 * v + 1])\n\ndef range_minimum_query(node, segx, segy, qx, qy):\n    if qx > segy or qy < segx or qx > qy:\n        return inf\n    elif segx >= qx and segy <= qy:\n        return t1[node]\n    else:\n        return min(range_minimum_query(node * 2, segx, (segx + segy) // 2, qx, qy), range_minimum_query(node * 2 + 1, (segx + segy) // 2 + 1, segy, qx, qy))\na = [0]\nno_of_msticks = int(input())\ng = [int(g) for g in input().split()]\na.extend(g)\nt1 = [0] * (4 * no_of_msticks + 1)\nbuild(1, 1, no_of_msticks)\nt2 = [0] * (4 * no_of_msticks + 1)\nbuildmax(1, 1, no_of_msticks)\nq = int(input())\nfor j in range(q):\n    (l, r) = input().split()\n    (l, r) = [int(l), int(r)]\n    l += 1\n    r += 1\n    max1 = range_maximum_query(1, 1, len(g), 1, l - 1)\n    max2 = range_maximum_query(1, 1, len(g), l, r)\n    min2 = range_minimum_query(1, 1, len(g), l, r)\n    max3 = range_maximum_query(1, 1, len(g), r + 1, len(g))\n    prob1 = max(max1, max3) + min2\n    prob2 = min2 + (max2 - min2) / 2\n    if prob2 > prob1:\n        print(prob2 / 1)\n    else:\n        print(prob1 / 1)"]