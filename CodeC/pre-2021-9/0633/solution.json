["def func(a, n, m, final):\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            k = 1\n            while i - k >= 0 and i + k < n and (j - k >= 0) and (j + k < m):\n                if a[i - k][j] == a[i + k][j] and a[i][j - k] == a[i][j + k]:\n                    final += 1\n                else:\n                    break\n                k += 1\n    return final\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        arr.append(l)\n    print(func(arr, n, m, n * m))", "def func(a, n, m, final):\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            k = 1\n            while i - k >= 0 and i + k < n and (j - k >= 0) and (j + k < m):\n                if a[i - k][j] == a[i + k][j] and a[i][j - k] == a[i][j + k]:\n                    final += 1\n                else:\n                    break\n                k += 1\n    return final\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        arr.append(l)\n    print(func(arr, n, m, n * m))", "def solve(mat, row, col, count):\n    for i in range(row):\n        for j in range(col):\n            maxRange = min(i, row - i - 1, j, col - j - 1)\n            for k in range(1, maxRange + 1):\n                if mat[i][j - k] == mat[i][j + k] and mat[i - k][j] == mat[i + k][j]:\n                    count += 1\n                else:\n                    break\n    return count\nfor _ in range(int(input())):\n    (r, c) = map(int, input().split())\n    arr = []\n    for i in range(r):\n        a = list(map(str, input().split()))\n        arr.append(a)\n    print(solve(arr, r, c, r * c))", "def solve(mat, row, col, count):\n    for i in range(row):\n        for j in range(col):\n            maxRange = min(i, row - i - 1, j, col - j - 1)\n            for k in range(1, maxRange + 1):\n                if mat[i][j - k] == mat[i][j + k] and mat[i - k][j] == mat[i + k][j]:\n                    count += 1\n                else:\n                    break\n    return count\nfor _ in range(int(input())):\n    (r, c) = map(int, input().split())\n    arr = []\n    for i in range(r):\n        a = list(map(str, input().split()))\n        arr.append(a)\n    print(solve(arr, r, c, r * c))", "def snek(s, j, k):\n    x = 1\n    c = 0\n    while j - x >= 0 and j + x < n and (k - x >= 0) and (k + x < m):\n        if s[j - x][k] == s[j + x][k] and s[j][k - x] == s[j][k + x]:\n            c += 1\n            x += 1\n        else:\n            break\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    s = []\n    ans = 0\n    for i in range(n):\n        s.append(list(map(int, input().split())))\n    for j in range(1, n):\n        for k in range(1, m):\n            ans += snek(s, j, k)\n    print(n * m + ans)", "def snek(s, j, k):\n    x = 1\n    c = 0\n    while j - x >= 0 and j + x < n and (k - x >= 0) and (k + x < m):\n        if s[j - x][k] == s[j + x][k] and s[j][k - x] == s[j][k + x]:\n            c += 1\n            x += 1\n        else:\n            break\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    s = []\n    ans = 0\n    for i in range(n):\n        s.append(list(map(int, input().split())))\n    for j in range(1, n):\n        for k in range(1, m):\n            ans += snek(s, j, k)\n    print(n * m + ans)", "def snek(s, j, k):\n    x = 1\n    c = 0\n    while j - x >= 0 and j + x < n and (k - x >= 0) and (k + x < m):\n        if s[j - x][k] == s[j + x][k] and s[j][k - x] == s[j][k + x]:\n            c += 1\n            x += 1\n        else:\n            break\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    s = []\n    ans = 0\n    for i in range(n):\n        s.append(list(map(int, input().split())))\n    for j in range(1, n):\n        for k in range(1, m):\n            ans += snek(s, j, k)\n    print(n * m + ans)", "def snek(s, j, k):\n    x = 1\n    c = 0\n    while j - x >= 0 and j + x < n and (k - x >= 0) and (k + x < m):\n        if s[j - x][k] == s[j + x][k] and s[j][k - x] == s[j][k + x]:\n            c += 1\n            x += 1\n        else:\n            break\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    s = []\n    ans = 0\n    for i in range(n):\n        s.append(list(map(int, input().split())))\n    for j in range(1, n):\n        for k in range(1, m):\n            ans += snek(s, j, k)\n    print(n * m + ans)", "def countt(mat, i, j):\n    x = 1\n    count = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if mat[i - x][j] == mat[i + x][j] and mat[i][j - x] == mat[i][j + x]:\n            count += 1\n            x += 1\n        else:\n            break\n    return count\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    mat = []\n    sum = 0\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(1, n):\n        for j in range(1, m):\n            sum += countt(mat, i, j)\n    print(n * m + sum)", "def countt(mat, i, j):\n    x = 1\n    count = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if mat[i - x][j] == mat[i + x][j] and mat[i][j - x] == mat[i][j + x]:\n            count += 1\n            x += 1\n        else:\n            break\n    return count\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    mat = []\n    sum = 0\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(1, n):\n        for j in range(1, m):\n            sum += countt(mat, i, j)\n    print(n * m + sum)", "def countt(mat, i, j):\n    x = 1\n    count = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if mat[i - x][j] == mat[i + x][j] and mat[i][j - x] == mat[i][j + x]:\n            count += 1\n            x += 1\n        else:\n            break\n    return count\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    mat = []\n    sum = 0\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(1, n):\n        for j in range(1, m):\n            sum += countt(mat, i, j)\n    print(n * m + sum)", "def countt(mat, i, j):\n    x = 1\n    count = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if mat[i - x][j] == mat[i + x][j] and mat[i][j - x] == mat[i][j + x]:\n            count += 1\n            x += 1\n        else:\n            break\n    return count\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    mat = []\n    sum = 0\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(1, n):\n        for j in range(1, m):\n            sum += countt(mat, i, j)\n    print(n * m + sum)", "def countt(mat, i, j):\n    x = 1\n    count = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if mat[i - x][j] == mat[i + x][j] and mat[i][j - x] == mat[i][j + x]:\n            count += 1\n            x += 1\n        else:\n            break\n    return count\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    mat = []\n    sum = 0\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(1, n):\n        for j in range(1, m):\n            sum += countt(mat, i, j)\n    print(n * m + sum)", "def func(a, n, m, final):\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            k = 1\n            while i - k >= 0 and i + k < n and (j - k >= 0) and (j + k < m):\n                if a[i - k][j] == a[i + k][j] and a[i][j - k] == a[i][j + k]:\n                    final += 1\n                else:\n                    break\n                k += 1\n    return final\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        a.append(l)\n    print(func(a, n, m, n * m))", "def func(a, n, m, final):\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            k = 1\n            while i - k >= 0 and i + k < n and (j - k >= 0) and (j + k < m):\n                if a[i - k][j] == a[i + k][j] and a[i][j - k] == a[i][j + k]:\n                    final += 1\n                else:\n                    break\n                k += 1\n    return final\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        a.append(l)\n    print(func(a, n, m, n * m))", "def func(a, n, m, final):\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            k = 1\n            while i - k >= 0 and i + k < n and (j - k >= 0) and (j + k < m):\n                if a[i - k][j] == a[i + k][j] and a[i][j - k] == a[i][j + k]:\n                    final += 1\n                else:\n                    break\n                k += 1\n    return final\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        a.append(l)\n    print(func(a, n, m, n * m))", "def matrix(a, i, j):\n    x = 1\n    ans = 0\n    while j - x >= 0 and i - x >= 0 and (j + x < m) and (i + x < n):\n        if a[i][j - x] == a[i][j + x] and a[i - x][j] == a[i + x][j]:\n            x += 1\n            ans += 1\n        else:\n            break\n    return ans\nfor _ in range(0, int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    sum = 0\n    for i in range(1, n):\n        for j in range(1, m):\n            sum += matrix(a, i, j)\n    print(sum + n * m)", "def solve(matrix, n, m):\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            maxLength = min(i, n - i - 1, j, m - j - 1)\n            for k in range(1, maxLength + 1):\n                if matrix[i][j - k] == matrix[i][j + k] and matrix[i - k][j] == matrix[i + k][j]:\n                    count += 1\n                else:\n                    break\n    return count + n * m\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    matrix = []\n    for i in range(n):\n        entries = list(map(int, input().split()))\n        matrix.append(entries[:])\n    print(solve(matrix, n, m))", "def countfun(mat, i, j):\n    x = 1\n    count = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if mat[i - x][j] == mat[i + x][j] and mat[i][j - x] == mat[i][j + x]:\n            count += 1\n            x += 1\n        else:\n            break\n    return count\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    mat = []\n    sum = 0\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(1, n):\n        for j in range(1, m):\n            sum += countfun(mat, i, j)\n    print(n * m + sum)", "def check(mat, i, j, count):\n    k = 1\n    while i - k >= 0 and i + k < r and (j - k >= 0) and (j + k < c):\n        if mat[i - k][j] == mat[i + k][j] and mat[i][j - k] == mat[i][j + k]:\n            count += 1\n            k += 1\n        else:\n            break\n    return count\nt = int(input())\nfor z in range(t):\n    (r, c) = map(int, input().split())\n    mat = []\n    count = 0\n    for i in range(r):\n        row = list(map(int, input().split()))\n        mat += [row]\n    for i in range(1, r):\n        for j in range(1, c):\n            count = check(mat, i, j, count)\n    print(r * c + count)", "def Shwetank(l, t):\n    count = 0\n    for i in range(1, n - 1):\n        a = l[i]\n        for j in range(1, m - 1):\n            b = t[j]\n            r1 = j - 1\n            r2 = j + 1\n            c1 = i - 1\n            c2 = i + 1\n            while r1 >= 0 and r2 <= m - 1 and (c1 >= 0) and (c2 <= n - 1):\n                if a[r1] == a[r2] and b[c1] == b[c2]:\n                    count += 1\n                    r1 -= 1\n                    r2 += 1\n                    c1 -= 1\n                    c2 += 1\n                else:\n                    break\n    return count\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    count = 0\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    t = [[l[j][i] for j in range(len(l))] for i in range(len(l[0]))]\n    count += Shwetank(l, t)\n    count += n * m\n    print(count)", "def doremon(grid):\n    n = len(grid)\n    m = len(grid[0])\n    summ = 0\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            for k in range(1, min(i, j, m - j - 1, n - i - 1) + 1):\n                if grid[i + k][j] == grid[i - k][j] and grid[i][j + k] == grid[i][j - k]:\n                    summ = summ + 1\n                else:\n                    break\n    result = summ + n * m\n    return result\nt = int(input())\nfor i in range(0, t):\n    nm = list(map(int, input().strip().split()))\n    n = nm[0]\n    m = nm[1]\n    arr = []\n    for j in range(0, n):\n        scratch = list(map(int, input().strip().split()))\n        arr.append(scratch)\n    print(doremon(arr))", "test = False\n\ndef calc(grid, r, c):\n    maxRange = min(r + 1, c + 1, M - c, N - r)\n    k = 1\n    temp = 0\n    while k < maxRange:\n        if grid[r - k][c] == grid[r + k][c] and grid[r][c - k] == grid[r][c + k]:\n            temp += 1\n        else:\n            return temp\n        k += 1\n    return temp\nT = int(input().strip())\nfor i in range(T):\n    (N, M) = map(int, input().strip().split(' '))\n    grid = []\n    for j in range(N):\n        grid.append([int(x) for x in input().strip().split(' ')])\n    if test:\n        print(N, M, grid)\n    answer = 0\n    for r in range(1, N - 1):\n        for c in range(1, M - 1):\n            answer += calc(grid, r, c)\n    answer += M * N\n    print(answer)", "def solve(t, i, j):\n    count = 0\n    mini1 = min(i, n - 1 - i)\n    mini2 = min(j, m - 1 - j)\n    z = min(mini1, mini2) + 1\n    q = 1\n    while q < z:\n        if t[i][j - q] == t[i][j + q] and t[i - q][j] == t[i + q][j]:\n            count += 1\n            q += 1\n        else:\n            break\n    return count\nfor i in range(int(input())):\n    z = list(map(int, input().split()))\n    n = z[0]\n    m = z[-1]\n    t = []\n    for i in range(n):\n        t.append([int(i) for i in input().split()])\n    count = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            o = solve(t, i, j)\n            count += o\n    print(count)", "t = int(input())\nfor test in range(t):\n    matrix = []\n    (n, m) = map(int, input().split())\n    trans_matrix = [[0 for x in range(n)] for y in range(m)]\n    for k in range(n):\n        rows = list(map(int, input().split()))\n        matrix.append(rows)\n    for i in range(m):\n        for j in range(n):\n            trans_matrix[i][j] = matrix[j][i]\n    if m >= 3 and n >= 3:\n        count = 0\n        for i in range(1, n - 1):\n            j = 1\n            while j < int(m // 2):\n                c = 1\n                cnt = 0\n                if i > int(n // 2):\n                    min_val = min(2 * (j + 1) - 1, 2 * (n - i) - 1)\n                else:\n                    i = i\n                    min_val = min(2 * (j + 1) - 1, 2 * (i + 1) - 1)\n                itr = (min_val - 1) // 2\n                e = matrix[i][j - itr:j + itr + 1]\n                e.reverse()\n                e_rev = e\n                d = trans_matrix[j][i - itr:i + itr + 1]\n                d.reverse()\n                d_rev = d\n                if j - itr >= 0 and j + itr < m and (i - itr >= 0) and (i + itr < n) and (e_rev == matrix[i][j - itr:j + itr + 1]) and (d_rev == trans_matrix[j][i - itr:i + itr + 1]):\n                    count += itr\n                else:\n                    while c <= itr:\n                        if j - c >= 0 and j + c < m and (i - c >= 0) and (i + c < n) and (matrix[i][j - c] == matrix[i][j + c]) and (matrix[i - c][j] == matrix[i + c][j]):\n                            c += 1\n                            cnt += 1\n                        else:\n                            break\n                    count += cnt\n                j += 1\n            j = int(m // 2)\n            while j < m - 1:\n                cnt = 0\n                c = 1\n                less = m - j\n                if i > int(n // 2):\n                    min_val = min(2 * less - 1, 2 * (n - i) - 1)\n                else:\n                    i = i\n                    min_val = min(2 * less - 1, 2 * (i + 1) - 1)\n                itr = (min_val - 1) // 2\n                e = matrix[i][j - itr:j + itr + 1]\n                e.reverse()\n                e_rev = e\n                d = trans_matrix[j][i - itr:i + itr + 1]\n                d.reverse()\n                d_rev = d\n                if j - itr >= 0 and j + itr < m and (i - itr >= 0) and (i + itr < n) and (e_rev == matrix[i][j - itr:j + itr + 1]) and (d_rev == trans_matrix[j][i - itr:i + itr + 1]):\n                    count += itr\n                else:\n                    while c <= itr:\n                        if j - c >= 0 and j + c < m and (i - c >= 0) and (i + c < n) and (matrix[i][j - c] == matrix[i][j + c]) and (matrix[i - c][j] == matrix[i + c][j]):\n                            c += 1\n                            cnt += 1\n                        else:\n                            break\n                    count += cnt\n                j += 1\n        ans = count + m * n\n    else:\n        ans = m * n\n    print(ans)", "def solve(t, i, j):\n    count = 0\n    mini1 = min(i, n - 1 - i)\n    mini2 = min(j, m - 1 - j)\n    z = min(mini1, mini2) + 1\n    q = 1\n    while q < z:\n        if t[i][j - q] == t[i][j + q] and t[i - q][j] == t[i + q][j]:\n            count += 1\n            q += 1\n        else:\n            break\n    return count\nfor i in range(int(input())):\n    z = list(map(int, input().split()))\n    n = z[0]\n    m = z[-1]\n    t = []\n    for i in range(n):\n        t.append([int(i) for i in input().split()])\n    count = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            o = solve(t, i, j)\n            count += o\n    print(count)", "def solve(t, i, j):\n    count = 0\n    mini1 = min(i, n - 1 - i)\n    mini2 = min(j, m - 1 - j)\n    z = min(mini1, mini2) + 1\n    q = 1\n    while q < z:\n        if t[i][j - q] == t[i][j + q] and t[i - q][j] == t[i + q][j]:\n            count += 1\n            q += 1\n        else:\n            break\n    return count\nfor i in range(int(input())):\n    z = list(map(int, input().split()))\n    n = z[0]\n    m = z[-1]\n    t = []\n    for i in range(n):\n        t.append([int(i) for i in input().split()])\n    count = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            o = solve(t, i, j)\n            count += o\n    print(count)", "def func(arr, n, m, ans):\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            k = 1\n            while i - k >= 0 and i + k < n and (j - k >= 0) and (j + k < m):\n                if arr[i - k][j] == arr[i + k][j] and arr[i][j - k] == arr[i][j + k]:\n                    ans += 1\n                else:\n                    break\n                k += 1\n    return ans\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(list(map(int, input().split())))\n    print(func(arr, n, m, n * m))", "def palindrome(mat, i, j, c):\n    h = 0\n    for k in range(1, c + 1):\n        if mat[i][j - k] == mat[i][j + k]:\n            if mat[i - k][j] == mat[i + k][j]:\n                h = h + 1\n            else:\n                break\n        else:\n            break\n    return h\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    mat = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        mat.append(a)\n    k = 0\n    for i in range(n):\n        for j in range(m):\n            if i > 0 and j > 0:\n                if n - 1 - i > 0 and m - 1 - j > 0:\n                    a = min(i, n - 1 - i)\n                    b = min(j, m - 1 - j)\n                    c = min(a, b)\n                    k = k + palindrome(mat, i, j, c)\n    print(k + n * m)", "def largest_palind(matrix, i, j, n, m):\n    limit = min(min(i, abs(n - 1 - i)), min(j, abs(m - 1 - j)))\n    max_i = 0\n    max_j = 0\n    for k in range(1, limit + 1):\n        if matrix[i + k][j] == matrix[i - k][j]:\n            max_i = k\n        else:\n            break\n        if matrix[i][j + k] == matrix[i][j - k]:\n            max_j = k\n        else:\n            break\n    return min(max_i, max_j)\nfor _ in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    matrix = []\n    sum = n * m\n    for i in range(n):\n        row = [int(x) for x in input().split()]\n        matrix.append(row)\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            val = largest_palind(matrix, i, j, n, m)\n            sum += val\n    print(sum)", "def func(arr, n, m):\n    ans = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            k = 1\n            while i - k >= 0 and i + k < n and (j - k >= 0) and (j + k < m):\n                if arr[i - k][j] == arr[i + k][j] and arr[i][j - k] == arr[i][j + k]:\n                    ans += 1\n                else:\n                    break\n                k += 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(list(map(int, input().split())))\n    result = func(arr, n, m)\n    print(result)", "def func(arr, n, m):\n    ans = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            k = 1\n            while i + k < n and i - k >= 0 and (j + k < m) and (j - k >= 0):\n                if arr[i - k][j] == arr[i + k][j] and arr[i][j - k] == arr[i][j + k]:\n                    ans += 1\n                else:\n                    break\n                k += 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        arr.append(list(map(int, input().split())))\n    print(func(arr, n, m))", "def countfun(mat, i, j):\n    x = 1\n    count = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if mat[i - x][j] == mat[i + x][j] and mat[i][j - x] == mat[i][j + x]:\n            count += 1\n            x += 1\n        else:\n            break\n    return count\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    mat = []\n    sum = 0\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(1, n):\n        for j in range(1, m):\n            sum += countfun(mat, i, j)\n    print(n * m + sum)", "def func(n, m, matrix):\n    s = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            if matrix[i][j - 1] == matrix[i][j + 1] and matrix[i - 1][j] == matrix[i + 1][j]:\n                s += 1\n                k = 2\n                while j + k < m and i + k < n and (i - k >= 0) and (j - k >= 0) and (matrix[i][j - k] == matrix[i][j + k]) and (matrix[i - k][j] == matrix[i + k][j]):\n                    s += 1\n                    k += 1\n    print(s)\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    matrix = []\n    for i in range(n):\n        a = input().split()\n        matrix.append(a)\n    func(n, m, matrix)", "def func(n, m, matrix):\n    s = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            if matrix[i][j - 1] == matrix[i][j + 1] and matrix[i - 1][j] == matrix[i + 1][j]:\n                s += 1\n                k = 2\n                while j + k < m and i + k < n and (i - k >= 0) and (j - k >= 0) and (matrix[i][j - k] == matrix[i][j + k]) and (matrix[i - k][j] == matrix[i + k][j]):\n                    s += 1\n                    k += 1\n    print(s)\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    matrix = []\n    for i in range(n):\n        a = input().split()\n        matrix.append(a)\n    func(n, m, matrix)", "def func(n, m, matrix):\n    s = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            if matrix[i][j - 1] == matrix[i][j + 1] and matrix[i - 1][j] == matrix[i + 1][j]:\n                s += 1\n                for k in range(2, min(n, m) // 2 + min(n, m) % 2):\n                    if j + k < m and i + k < n and (i - k >= 0) and (j - k >= 0) and (matrix[i][j - k] == matrix[i][j + k]) and (matrix[i - k][j] == matrix[i + k][j]):\n                        s += 1\n                    else:\n                        break\n    print(s)\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    matrix = []\n    for i in range(n):\n        a = input().split()\n        matrix.append(a)\n    func(n, m, matrix)", "import sys\n\ndef func(a, i, j):\n    d = 1\n    z = a[i]\n    temp = 0\n    while True:\n        if i - d >= 0 and i + d < n and (j - d >= 0) and (j + d < m):\n            if z[j - d] != z[j + d] or a[i - d][j] != a[i + d][j]:\n                return temp\n            else:\n                temp += 1\n                d += 1\n        else:\n            return temp\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list()\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    ans = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            o = func(a, i, j)\n            ans += o\n    print(ans)", "import sys\n\ndef func(a, i, j):\n    d = 1\n    z = a[i]\n    temp = 0\n    while True:\n        if i - d >= 0 and i + d < n and (j - d >= 0) and (j + d < m):\n            if z[j - d] != z[j + d] or a[i - d][j] != a[i + d][j]:\n                return temp\n            else:\n                temp += 1\n                d += 1\n        else:\n            return temp\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list()\n    for i in range(n):\n        a.append(list(map(int, sys.stdin.readline().split())))\n    ans = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            o = func(a, i, j)\n            ans += o\n    print(ans)", "def fun(a, i, j):\n    x = 1\n    c = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if a[i - x][j] == a[i + x][j] and a[i][j - x] == a[i][j + x]:\n            x += 1\n            c += 1\n        else:\n            break\n    return c\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    a = []\n    ans = 0\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    for i in range(1, n):\n        for j in range(1, m):\n            ans += fun(a, i, j)\n    print(n * m + ans)", "def func(li, i, j, n, m):\n    a = 1\n    count = 0\n    while (i - a >= 0 and i + a < n) and (j - a >= 0 and j + a < m):\n        if li[i][j - a] == li[i][j + a] and li[i - a][j] == li[i + a][j]:\n            count += 1\n            a += 1\n        else:\n            break\n    return count\nfor k in range(int(input(''))):\n    li = []\n    count = 0\n    (n, m) = map(int, input('').split(' '))\n    for j in range(n):\n        li.append(list(map(int, input('').split(' '))))\n    for i in range(1, n):\n        for j in range(1, m):\n            count += func(li, i, j, n, m)\n    ans = n * m + count\n    print(ans)", "def func(li, i, j, n, m):\n    a = 1\n    count = 0\n    while (i - a >= 0 and i + a < n) and (j - a >= 0 and j + a < m):\n        if li[i][j - a] == li[i][j + a] and li[i - a][j] == li[i + a][j]:\n            count += 1\n            a += 1\n        else:\n            break\n    return count\nfor k in range(int(input(''))):\n    li = []\n    count = 0\n    (n, m) = map(int, input('').split(' '))\n    for j in range(n):\n        li.append(list(map(int, input('').split(' '))))\n    for i in range(1, n):\n        for j in range(1, m):\n            count += func(li, i, j, n, m)\n    ans = n * m + count\n    print(ans)", "def is_palindrome(i, j, mat, m, n):\n    count = 0\n    t = 0\n    while True:\n        try:\n            if (i - t < 0 or j - t < 0) or i + t > m or j + t > n:\n                return count\n            if mat[i - t][j] == mat[i + t][j] and mat[i][j - t] == mat[i][j + t]:\n                count += 1\n                t += 1\n            else:\n                return count\n        except:\n            return count\nt = int(input())\nfor _ in range(t):\n    (M, N) = map(int, input().split())\n    mat = []\n    for i in range(M):\n        mat.append(input().split())\n    count = 0\n    i = 0\n    while i < M:\n        j = 0\n        while j < N:\n            count += is_palindrome(i, j, mat, M - 1, N - 1)\n            j += 1\n        i += 1\n    print(count)", "def fun(arr, i, j, n, m):\n    lans = 0\n    l = 1\n    while i - l >= 0 and i + l < n and (j - l >= 0) and (j + l < m):\n        if arr[i + l][j] == arr[i - l][j] and arr[i][j - l] == arr[i][j + l]:\n            lans += 1\n            l += 1\n        else:\n            break\n    return lans\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append([int(x) for x in input().split()])\n    ans = n * m\n    for i in range(n):\n        for j in range(m):\n            ans += fun(arr, i, j, n, m)\n    print(ans)", "def fun(i, j):\n    x = 1\n    ans = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if matrix[i - x][j] == matrix[i + x][j] and matrix[i][j - x] == matrix[i][j + x]:\n            ans += 1\n            x += 1\n        else:\n            break\n    return ans\ntry:\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        matrix = []\n        total = n * m\n        for i in range(n):\n            temp = [int(x) for x in input().split()][:m]\n            matrix.append(temp)\n        for i in range(1, n):\n            for j in range(1, m):\n                total += fun(i, j)\n        print(total)\nexcept Exception as e:\n    print(e)", "def doremon(c, i, j):\n    u = v = i\n    z = c[i]\n    w = x = j\n    crt = 0\n    while u >= 0 and v < a and (w >= 0) and (x < b) and (c[u][j] == c[v][j]) and (c[i][w] == c[i][x]):\n        u = u - 1\n        v = v + 1\n        w = w - 1\n        x = x + 1\n        crt += 1\n    return crt\nimport sys\nn = int(input())\nwhile n != 0:\n    (a, b) = map(int, input().split())\n    c = list()\n    crt = 0\n    for i in range(a):\n        c.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(a):\n        for j in range(b):\n            t = doremon(c, i, j)\n            crt = crt + t\n    print(crt)\n    n = n - 1", "def fen(l1, k, l):\n    z = l1[k]\n    e = 1\n    ce = 0\n    while 1:\n        if l - e >= 0 and l + e < q and (k - e >= 0) and (k + e < p):\n            if l1[k - e][l] != l1[k + e][l] or z[l - e] != z[l + e]:\n                return ce\n            ce = ce + 1\n            e = e + 1\n        else:\n            break\n    return ce\nimport sys\nT = int(input())\nfor i in range(T):\n    l1 = list()\n    ce = 0\n    (p, q) = list(map(int, input().split()))\n    ce = p * q\n    for j in range(p):\n        l1.append(list(map(int, sys.stdin.readline().split())))\n    for k in range(1, p - 1):\n        for l in range(1, q - 1):\n            o = fen(l1, k, l)\n            ce = ce + o\n    print(ce)", "def calcPairs(A, i, j, xR, M, N):\n    p = 0\n    for x in range(1, xR):\n        if j + x < M and j - x >= 0 and (i + x < N) and (i - x >= 0):\n            if A[i][j - x] == A[i][j + x] and A[i + x][j] == A[i - x][j]:\n                p += 1\n                continue\n            break\n        break\n    return p\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    A = []\n    for i in range(N):\n        A.append(list(map(int, input().split())))\n    pairs = N * M\n    if N < 3 or M < 3:\n        print(pairs)\n    else:\n        xR = min(N - 1, M - 1)\n        for i in range(1, N - 1):\n            for j in range(1, M - 1):\n                pairs += calcPairs(A, i, j, xR, M, N)\n        print(pairs)", "def fun(mat, i, j, n, m):\n    x = 1\n    c = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if mat[i - x][j] == mat[i + x][j] and mat[i][j - x] == mat[i][j + x]:\n            c += 1\n            x += 1\n        else:\n            break\n    return c\nimport sys\nfor _ in range(int(input())):\n    l = list(map(int, input().split()))\n    (n, m) = (l[0], l[1])\n    mat = []\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    total = 0\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            total += fun(mat, i, j, n, m)\n    print(total + n * m)", "def fun(a, i, j):\n    p = 1\n    asi = 0\n    while 1:\n        if i - p >= 0 and i + p < n and (j - p >= 0) and (j + p < m):\n            if a[i - p][j] == a[i + p][j] and a[i][j - p] == a[i][j + p]:\n                asi = asi + 1\n                p = p + 1\n            else:\n                break\n        else:\n            break\n    return asi\nfrom sys import stdin\nt = int(input())\nfor k in range(t):\n    (n, m) = map(int, input().strip().split())\n    a = []\n    for j in range(n):\n        a.append(list(map(int, stdin.readline().strip().split())))\n    ansi = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            asi = fun(a, i, j)\n            ansi = ansi + asi\n    print(ansi)", "def check(i, j, n, m, each):\n    while i - each >= 0 and j - each >= 0 and (i + each < n) and (j + each < m):\n        if matrix[i - each][j] == matrix[i + each][j] and matrix[i][j - each] == matrix[i][j + each]:\n            each += 1\n        else:\n            break\n    return each\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    matrix = []\n    ans = 0\n    for _ in range(n):\n        a = list(map(int, input().split()))\n        matrix.append(a)\n    for i in range(n):\n        for j in range(m):\n            each = 1\n            ans += check(i, j, n, m, each)\n    print(ans)", "from collections import Counter\nfrom collections import defaultdict\nimport math\nimport random\nimport heapq as hq\nfrom math import sqrt\nimport sys\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef iinput():\n    return int(input())\n\ndef tinput():\n    return input().split()\n\ndef rinput():\n    return map(int, tinput())\n\ndef rlinput():\n    return list(rinput())\nmod = int(1000000000.0) + 7\n\ndef solve(mat, n, m):\n    ans = m * n\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            temp = 1\n            while i + temp < n and j + temp < m and (j - temp >= 0) and (i - temp >= 0):\n                if mat[i][j + temp] == mat[i][j - temp] and mat[i + temp][j] == mat[i - temp][j]:\n                    temp += 1\n                    ans += 1\n                else:\n                    break\n    return ans\nfor _ in range(iinput()):\n    (n, m) = rinput()\n    mat = [[0 for j in range(m)] for i in range(n)]\n    for i in range(n):\n        temp = rlinput()\n        for j in range(m):\n            mat[i][j] = temp[j]\n    print(solve(mat, n, m))", "def func(arr, n, m):\n    ans = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            k = 1\n            while i + k < n and i - k >= 0 and (j + k < m) and (j - k >= 0):\n                if arr[i - k][j] == arr[i + k][j] and arr[i][j - k] == arr[i][j + k]:\n                    ans += 1\n                else:\n                    break\n                k += 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        arr.append(list(map(int, input().split())))\n    print(func(arr, n, m))", "def countfun(mat, i, j):\n    x = 1\n    count = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if mat[i - x][j] == mat[i + x][j] and mat[i][j - x] == mat[i][j + x]:\n            count += 1\n            x += 1\n        else:\n            break\n    return count\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    mat = []\n    sum = 0\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(1, n):\n        for j in range(1, m):\n            sum += countfun(mat, i, j)\n    print(n * m + sum)", "def f(n, m, i, j, l):\n    k = min(i, n - i - 1, j, m - j - 1)\n    v = 1\n    ans = 0\n    while v != k + 1:\n        if l[i - v][j] == l[i + v][j] and l[i][j - v] == l[i][j + v]:\n            ans = ans + 1\n        else:\n            break\n        v = v + 1\n    return ans\nt = int(input())\nfor x in range(t):\n    (n, m) = map(int, input().split())\n    l = [[]] * n\n    fans = m * n\n    for y in range(n):\n        l[y] = list(map(int, input().split()))\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            fans = fans + f(n, m, i, j, l)\n    print(fans)", "def getPairs(i, j, M, N, mat):\n    minSteps = min(i - 0, M - i - 1, j - 0, N - j - 1)\n    count = 0\n    for x in range(1, minSteps + 1):\n        if mat[i - x][j] == mat[i + x][j] and mat[i][j - x] == mat[i][j + x]:\n            count += 1\n        else:\n            break\n    return count\nT = int(input())\nfor t in range(T):\n    (M, N) = map(int, list(input().strip().split()))\n    matrix = list()\n    for mat in range(M):\n        matrix.append(list(map(int, input().strip().split())))\n    count = M * N\n    for i in range(1, M - 1):\n        for j in range(1, N - 1):\n            count = count + getPairs(i, j, M, N, matrix)\n    print(count)", "def main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        ctr = 0\n        l2 = []\n        for i in range(n):\n            a = list(map(int, input().split()))\n            l2.append(a)\n        for i in range(n):\n            for j in range(m):\n                l3 = 1\n                while l3 <= i and l3 <= j and (l3 + i < n) and (l3 + j < m) and (l2[i - l3][j] == l2[i + l3][j]) and (l2[i][j - l3] == l2[i][j + l3]):\n                    l3 += 1\n                ctr += l3\n        print(ctr)\nmain()", "def main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        ctr = 0\n        l2 = []\n        for i in range(n):\n            a = list(map(int, input().split()))\n            l2.append(a)\n        for i in range(0, n):\n            for j in range(0, m):\n                l3 = 1\n                while l3 <= i and l3 <= j and (l3 + i < n) and (l3 + j < m) and (l2[i - l3][j] == l2[i + l3][j]) and (l2[i][j - l3] == l2[i][j + l3]):\n                    l3 += 1\n                ctr += l3\n        print(ctr)\nmain()", "def main():\n    from sys import stdin, stdout\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        ctr = 0\n        l2 = []\n        for i in range(n):\n            a = list(map(int, input().split()))\n            l2.append(a)\n        for i in range(0, n):\n            for j in range(0, m):\n                l3 = 1\n                while l3 <= i and l3 <= j and (l3 + i < n) and (l3 + j < m) and (l2[i - l3][j] == l2[i + l3][j]) and (l2[i][j - l3] == l2[i][j + l3]):\n                    l3 += 1\n                ctr += l3\n        print(ctr)\nmain()", "def main():\n    from sys import stdin, stdout\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        ctr = 0\n        l2 = []\n        for i in range(n):\n            a = list(map(int, input().split()))\n            l2.append(a)\n        for i in range(n):\n            for j in range(m):\n                l3 = 1\n                while l3 <= i and l3 <= j and (l3 + i < n) and (l3 + j < m) and (l2[i - l3][j] == l2[i + l3][j]) and (l2[i][j - l3] == l2[i][j + l3]):\n                    l3 += 1\n                ctr += l3\n        print(ctr)\nmain()", "def main():\n    from sys import stdin, stdout\n    t = int(input())\n    for i in range(0, t):\n        (n, m) = map(int, input().split())\n        a = []\n        for i in range(n):\n            b = list(map(int, input().split()))\n            a.append(b)\n            c = 0\n        for i in range(0, n):\n            for j in range(0, m):\n                k = 1\n                while i - k >= 0 and j - k >= 0 and (i + k < n) and (j + k < m) and (a[i - k][j] == a[i + k][j]) and (a[i][j - k] == a[i][j + k]):\n                    k = k + 1\n                c = c + k\n        print(c)\nmain()", "def f(n, m, i, j, l):\n    ans = 0\n    k = min(i, n - i - 1, j, m - j - 1)\n    for v in range(1, k + 1):\n        if l[i - v][j] == l[i + v][j] and l[i][j - v] == l[i][j + v]:\n            ans = ans + 1\n        else:\n            break\n    return ans\nt = int(input())\nfor x in range(t):\n    (n, m) = map(int, input().split())\n    l = [[]] * n\n    fans = m * n\n    for y in range(n):\n        l[y] = list(map(int, input().split()))\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            fans = fans + f(n, m, i, j, l)\n    print(fans)", "def fen(l1, k, l):\n    z = l1[k]\n    e = 1\n    ce = 0\n    while 1:\n        if l - e >= 0 and l + e < q and (k - e >= 0) and (k + e < p):\n            if l1[k - e][l] != l1[k + e][l] or z[l - e] != z[l + e]:\n                return ce\n            ce = ce + 1\n            e = e + 1\n        else:\n            break\n    return ce\nimport sys\nT = int(input())\nfor i in range(T):\n    l1 = list()\n    ce = 0\n    (p, q) = list(map(int, input().split()))\n    ce = p * q\n    for j in range(p):\n        l1.append(list(map(int, sys.stdin.readline().split())))\n    for k in range(1, p - 1):\n        for l in range(1, q - 1):\n            o = fen(l1, k, l)\n            ce = ce + o\n    print(ce)", "def main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        a = [0] * n\n        for i in range(n):\n            a[i] = list(map(int, input().split()))\n        ans = 0\n        for i in range(n):\n            if i == 0 or i == n - 1:\n                ans += m\n            else:\n                for j in range(m):\n                    if j == 0 or j == m - 1:\n                        ans += 1\n                    else:\n                        (l, r, u, d) = (j, j, i, i)\n                        ans += 1\n                        l -= 1\n                        r += 1\n                        u -= 1\n                        d += 1\n                        while l >= 0 and r < m and (u >= 0) and (d < n):\n                            if a[i][l] == a[i][r] and a[u][j] == a[d][j]:\n                                ans += 1\n                                l -= 1\n                                r += 1\n                                u -= 1\n                                d += 1\n                            else:\n                                break\n        print(ans)\nmain()", "def main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        a = []\n        for x in range(n):\n            a.append(list(map(int, input().split())))\n        c = 0\n        for i in range(0, n):\n            for j in range(0, m):\n                k = 1\n                while i - k >= 0 and j - k >= 0 and (i + k < n) and (j + k < m) and (a[i - k][j] == a[i + k][j]) and (a[i][j - k] == a[i][j + k]):\n                    k += 1\n                c += k\n        print(c)\nmain()", "def main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        a = []\n        for x in range(n):\n            a.append(list(map(int, input().split())))\n        c = 0\n        for i in range(0, n):\n            for j in range(0, m):\n                k = 1\n                while i - k >= 0 and j - k >= 0 and (i + k < n) and (j + k < m) and (a[i - k][j] == a[i + k][j]) and (a[i][j - k] == a[i][j + k]):\n                    k += 1\n                c += k\n        print(c)\nmain()", "def main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        a = []\n        for x in range(n):\n            b = list(map(int, input().split()))\n            a.append(b)\n        c = 0\n        for i in range(0, n):\n            for j in range(0, m):\n                k = 1\n                while i - k >= 0 and j - k >= 0 and (i + k < n) and (j + k < m) and (a[i - k][j] == a[i + k][j]) and (a[i][j - k] == a[i][j + k]):\n                    k += 1\n                c += k\n        print(c)\nmain()", "def check(i, j, l1, n, m):\n    l = min(i, j, m - j, n - i)\n    s = 0\n    for k in range(1, l + 1):\n        if l1[i + k][j] == l1[i - k][j] and l1[i][j + k] == l1[i][j - k]:\n            s = s + 1\n        else:\n            break\n    return s\nfor a in range(int(input())):\n    (n, m) = map(int, input().split())\n    l1 = []\n    sum1 = m * n\n    for i in range(n):\n        l1.append(list(map(int, input().split())))\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            sum1 = sum1 + check(i, j, l1, n - 1, m - 1)\n    print(sum1)", "def fen(l1, k, l):\n    z = l1[k]\n    e = 1\n    ce = 0\n    while 1:\n        if l - e >= 0 and l + e < q and (k - e >= 0) and (k + e < p):\n            if l1[k - e][l] != l1[k + e][l] or z[l - e] != z[l + e]:\n                return ce\n            ce = ce + 1\n            e = e + 1\n        else:\n            break\n    return ce\nimport sys\nT = int(input())\nfor i in range(T):\n    l1 = list()\n    ce = 0\n    (p, q) = list(map(int, input().split()))\n    ce = p * q\n    for j in range(p):\n        l1.append(list(map(int, sys.stdin.readline().split())))\n    for k in range(1, p - 1):\n        for l in range(1, q - 1):\n            o = fen(l1, k, l)\n            ce = ce + o\n    print(ce)", "def countfun(mat, i, j):\n    x = 1\n    count = 0\n    while i - x >= 0 and i + x < n and (j - x >= 0) and (j + x < m):\n        if mat[i - x][j] == mat[i + x][j] and mat[i][j - x] == mat[i][j + x]:\n            count += 1\n            x += 1\n        else:\n            break\n    return count\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    mat = []\n    sum = 0\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(1, n):\n        for j in range(1, m):\n            sum += countfun(mat, i, j)\n    print(n * m + sum)", "II = lambda : [int(x) for x in input().split()]\nI2 = lambda : int(input())\nT = int(input())\nfor _ in range(T):\n    a = II()\n    (N, M) = a\n    A = [II() for _ in range(N)]\n    H = [[1] * M for _ in range(N)]\n    for i in range(N):\n        (c, r) = (0, 0)\n        for j in range(1, M - 1):\n            m_pos = c - (j - c)\n            m_val = H[i][m_pos] if m_pos >= 0 else 1\n            if j + m_val - 1 < r:\n                H[i][j] = m_val\n                continue\n            m_val = max(min(r - j + 1, m_val), 1)\n            H[i][j] = m_val\n            for d in range(m_val, M):\n                if 0 <= j - d <= j + d < M and A[i][j - d] == A[i][j + d]:\n                    H[i][j] += 1\n                else:\n                    (c, r) = (j, j + d - 1)\n                    break\n    V = [[1] * M for _ in range(N)]\n    for j in range(M):\n        (c, r) = (0, 0)\n        for i in range(1, N - 1):\n            m_pos = c - (i - c)\n            m_val = V[m_pos][j] if m_pos >= 0 else 1\n            if i + m_val - 1 < r:\n                V[i][j] = m_val\n                continue\n            m_val = max(min(r - i + 1, m_val), 1)\n            V[i][j] = m_val\n            for d in range(m_val, M):\n                if 0 <= i - d <= i + d < N and A[i - d][j] == A[i + d][j]:\n                    V[i][j] += 1\n                else:\n                    (c, r) = (i, i + d - 1)\n                    break\n    count = 0\n    for i in range(N):\n        for j in range(M):\n            count += min(H[i][j], V[i][j])\n    print(count)", "test = int(input())\nfor t in range(test):\n    matrix = []\n    (n, m) = map(int, input().split())\n    transpose_matrix = [[0 for x in range(n)] for y in range(m)]\n    for a in range(n):\n        rows = list(map(int, input().split()))\n        matrix.append(rows)\n    for i in range(m):\n        for j in range(n):\n            transpose_matrix[i][j] = matrix[j][i]\n    if m >= 3 and n >= 3:\n        count1 = 0\n        for i in range(1, n - 1):\n            j = 1\n            while j < int(m // 2):\n                count = 0\n                if i > int(n // 2):\n                    max_val = min(2 * (j + 1) - 1, 2 * (n - i) - 1)\n                else:\n                    i = i\n                    max_val = min(2 * (j + 1) - 1, 2 * (i + 1) - 1)\n                itr = (max_val - 1) // 2\n                sub_row = matrix[i][j - itr:j + itr + 1]\n                sub_row.reverse()\n                sub_row_rev = sub_row\n                sub_col = transpose_matrix[j][i - itr:i + itr + 1]\n                sub_col.reverse()\n                sub_col_rev = sub_col\n                k = 1\n                if j - itr >= 0 and j + itr < m and (i - itr >= 0) and (i + itr < n) and (sub_row_rev == matrix[i][j - itr:j + itr + 1] and sub_col_rev == transpose_matrix[j][i - itr:i + itr + 1]):\n                    count1 += itr\n                else:\n                    while k <= itr:\n                        if j - k >= 0 and j + k < m and (i - k >= 0) and (i + k < n) and (matrix[i][j - k] == matrix[i][j + k] and matrix[i - k][j] == matrix[i + k][j]):\n                            k += 1\n                            count += 1\n                        else:\n                            break\n                    count1 += count\n                j += 1\n            j = int(m // 2)\n            while j < m - 1:\n                count = 0\n                rev = m - j\n                if i > int(n // 2):\n                    max_val = min(2 * rev - 1, 2 * (n - i) - 1)\n                else:\n                    i = i\n                    max_val = min(2 * rev - 1, 2 * (i + 1) - 1)\n                itr = (max_val - 1) // 2\n                sub_row = matrix[i][j - itr:j + itr + 1]\n                sub_row.reverse()\n                sub_row_rev = sub_row\n                sub_col = transpose_matrix[j][i - itr:i + itr + 1]\n                sub_col.reverse()\n                sub_col_rev = sub_col\n                k = 1\n                if j - itr >= 0 and j + itr < m and (i - itr >= 0) and (i + itr < n) and (sub_row_rev == matrix[i][j - itr:j + itr + 1] and sub_col_rev == transpose_matrix[j][i - itr:i + itr + 1]):\n                    count1 += itr\n                else:\n                    while k <= itr:\n                        if j - k >= 0 and j + k < m and (i - k >= 0) and (i + k < n) and (matrix[i][j - k] == matrix[i][j + k] and matrix[i - k][j] == matrix[i + k][j]):\n                            k += 1\n                            count += 1\n                        else:\n                            break\n                    count1 += count\n                j += 1\n        answer = count1 + m * n\n    else:\n        answer = m * n\n    print(answer)", "t = int(input())\nfor test in range(t):\n    matrix = []\n    (n, m) = map(int, input().split())\n    trans_matrix = [[0 for x in range(n)] for y in range(m)]\n    for k in range(n):\n        rows = list(map(int, input().split()))\n        matrix.append(rows)\n    for i in range(m):\n        for j in range(n):\n            trans_matrix[i][j] = matrix[j][i]\n    if m >= 3 and n >= 3:\n        count = 0\n        for i in range(1, n - 1):\n            j = 1\n            while j < int(m // 2):\n                c = 1\n                cnt = 0\n                if i > int(n // 2):\n                    min_val = min(2 * (j + 1) - 1, 2 * (n - i) - 1)\n                else:\n                    i = i\n                    min_val = min(2 * (j + 1) - 1, 2 * (i + 1) - 1)\n                itr = (min_val - 1) // 2\n                e = matrix[i][j - itr:j + itr + 1]\n                e.reverse()\n                e_rev = e\n                d = trans_matrix[j][i - itr:i + itr + 1]\n                d.reverse()\n                d_rev = d\n                if j - itr >= 0 and j + itr < m and (i - itr >= 0) and (i + itr < n) and (e_rev == matrix[i][j - itr:j + itr + 1]) and (d_rev == trans_matrix[j][i - itr:i + itr + 1]):\n                    count += itr\n                else:\n                    while c <= itr:\n                        if j - c >= 0 and j + c < m and (i - c >= 0) and (i + c < n) and (matrix[i][j - c] == matrix[i][j + c]) and (matrix[i - c][j] == matrix[i + c][j]):\n                            c += 1\n                            cnt += 1\n                        else:\n                            break\n                    count += cnt\n                j += 1\n            j = int(m // 2)\n            while j < m - 1:\n                cnt = 0\n                c = 1\n                less = m - j\n                if i > int(n // 2):\n                    min_val = min(2 * less - 1, 2 * (n - i) - 1)\n                else:\n                    i = i\n                    min_val = min(2 * less - 1, 2 * (i + 1) - 1)\n                itr = (min_val - 1) // 2\n                e = matrix[i][j - itr:j + itr + 1]\n                e.reverse()\n                e_rev = e\n                d = trans_matrix[j][i - itr:i + itr + 1]\n                d.reverse()\n                d_rev = d\n                if j - itr >= 0 and j + itr < m and (i - itr >= 0) and (i + itr < n) and (e_rev == matrix[i][j - itr:j + itr + 1]) and (d_rev == trans_matrix[j][i - itr:i + itr + 1]):\n                    count += itr\n                else:\n                    while c <= itr:\n                        if j - c >= 0 and j + c < m and (i - c >= 0) and (i + c < n) and (matrix[i][j - c] == matrix[i][j + c]) and (matrix[i - c][j] == matrix[i + c][j]):\n                            c += 1\n                            cnt += 1\n                        else:\n                            break\n                    count += cnt\n                j += 1\n        ans = count + m * n\n    else:\n        ans = m * n\n    print(ans)", "def main():\n    from sys import stdin, stdout\n    t = int(input())\n    for i in range(0, t):\n        (n, m) = map(int, input().split())\n        a = []\n        for i in range(n):\n            b = list(map(int, input().split()))\n            a.append(b)\n            c = 0\n        for i in range(0, n):\n            for j in range(0, m):\n                k = 1\n                while i - k >= 0 and j - k >= 0 and (i + k < n) and (j + k < m) and (a[i - k][j] == a[i + k][j]) and (a[i][j - k] == a[i][j + k]):\n                    k = k + 1\n                c = c + k\n        print(c)\nmain()", "def check(a, b, m, A, B):\n    x = min(a, b, A - a, B - b)\n    s = 0\n    f1 = 0\n    for j in range(1, x + 1):\n        if m[a - j][b] == m[a + j][b] and m[a][b - j] == m[a][b + j]:\n            s = s + 1\n        else:\n            f1 = 1\n            break\n    return s\nt = int(input())\nfor i in range(0, t):\n    (N, M) = map(int, input().split())\n    arr = []\n    for j in range(0, N):\n        m = list(map(int, input().split()))\n        arr.append(m)\n    ans = N * M\n    for p in range(1, N - 1):\n        for q in range(1, M - 1):\n            ans = ans + check(p, q, arr, N - 1, M - 1)\n    print(ans)", "from collections import Counter\nfrom collections import defaultdict\nimport math\nimport random\nimport heapq as hq\nfrom math import sqrt\nimport sys\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef iinput():\n    return int(input())\n\ndef tinput():\n    return input().split()\n\ndef rinput():\n    return map(int, tinput())\n\ndef rlinput():\n    return list(rinput())\nmod = int(1000000000.0) + 7\n\ndef solve(mat, n, m):\n    ans = m * n\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            temp = 1\n            while i + temp < n and j + temp < m and (j - temp >= 0) and (i - temp >= 0):\n                if mat[i][j + temp] == mat[i][j - temp] and mat[i + temp][j] == mat[i - temp][j]:\n                    temp += 1\n                    ans += 1\n                else:\n                    break\n    return ans\nfor _ in range(iinput()):\n    (n, m) = rinput()\n    mat = [[0 for j in range(m)] for i in range(n)]\n    for i in range(n):\n        temp = rlinput()\n        for j in range(m):\n            mat[i][j] = temp[j]\n    print(solve(mat, n, m))", "def chfdora(A, n, m):\n    c = 0\n    for i in range(0, n):\n        for j in range(0, m):\n            d = min(i, n - 1 - i, j, m - j - 1)\n            pnt = 0\n            for k in range(0, d + 1):\n                if A[i - k][j] != A[i + k][j]:\n                    break\n                else:\n                    pnt += 1\n            gnt = 0\n            for k in range(0, d + 1):\n                if A[i][j - k] != A[i][j + k]:\n                    break\n                else:\n                    gnt += 1\n            c += min(pnt, gnt)\n    print(c)\nT = int(input())\nfor i in range(0, T):\n    (N, M) = map(int, input().split())\n    A = []\n    for i in range(N):\n        B = list(map(int, input().split()))\n        A.append(B)\n    chfdora(A, N, M)", "def dora(a, n, m):\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            d = min(i, n - 1 - i, j, m - 1 - j)\n            p = 0\n            for k in range(d + 1):\n                if a[i - k][j] != a[i + k][j]:\n                    break\n                else:\n                    p = p + 1\n            g = 0\n            for k in range(d + 1):\n                if a[i][j - k] != a[i][j + k]:\n                    break\n                else:\n                    g = g + 1\n            ans = ans + min(p, g)\n    print(ans)\nfor _ in range(int(input())):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = []\n    for i in range(n):\n        b = list(map(int, input().split()))\n        a.append(b)\n    dora(a, n, m)", "def solve(l, n, m):\n    cnt = n * m\n    for r in range(1, n - 1):\n        for c in range(1, m - 1):\n            _min = min(min(c, m - c - 1), min(r, n - r - 1))\n            for k in range(1, _min + 1):\n                if l[r][c + k] == l[r][c - k] and l[r - k][c] == l[r + k][c]:\n                    cnt += 1\n                else:\n                    break\n    return cnt\nt = int(input())\nfor _ in range(t):\n    ans = 0\n    (n, m) = map(int, input().split())\n    l = []\n    for rows in range(n):\n        x = list(map(int, input().split()))\n        l.append(x)\n    ans += solve(l, n, m)\n    print(ans)", "def chfdora(A, n, m):\n    c = 0\n    for i in range(0, n):\n        for j in range(0, m):\n            d = min(i, n - 1 - i, j, m - j - 1)\n            pnt = 0\n            for k in range(0, d + 1):\n                if A[i - k][j] != A[i + k][j]:\n                    break\n                else:\n                    pnt += 1\n            gnt = 0\n            for k in range(0, d + 1):\n                if A[i][j - k] != A[i][j + k]:\n                    break\n                else:\n                    gnt += 1\n            c += min(pnt, gnt)\n    print(c)\nT = int(input())\nfor i in range(0, T):\n    (N, M) = map(int, input().split())\n    A = []\n    for i in range(N):\n        B = list(map(int, input().split()))\n        A.append(B)\n    chfdora(A, N, M)", "def chfdora(A, n, m):\n    c = 0\n    for i in range(0, n):\n        for j in range(0, m):\n            d = min(i, n - 1 - i, j, m - j - 1)\n            pnt = 0\n            for k in range(0, d + 1):\n                if A[i - k][j] != A[i + k][j]:\n                    break\n                else:\n                    pnt += 1\n            gnt = 0\n            for k in range(0, d + 1):\n                if A[i][j - k] != A[i][j + k]:\n                    break\n                else:\n                    gnt += 1\n            c += min(pnt, gnt)\n    print(c)\nT = int(input())\nfor i in range(0, T):\n    (N, M) = map(int, input().split())\n    A = []\n    for i in range(N):\n        B = list(map(int, input().split()))\n        A.append(B)\n    chfdora(A, N, M)", "def accumulator(A, ci, cj, limit):\n    count = 0\n    for k in range(1, limit + 1):\n        if A[ci + k][cj] == A[ci - k][cj] and A[ci][cj + k] == A[ci][cj - k]:\n            count += 1\n        else:\n            return count\n    return count\ntests = int(input())\nfor l in range(tests):\n    (N, M) = input().split(' ')\n    (N, M) = (int(N), int(M))\n    A = []\n    for ll in range(N):\n        A.append([int(i) for i in input().split(' ')])\n    count = N * M\n    for i in range(1, N - 1):\n        for j in range(1, M - 1):\n            count += accumulator(A, i, j, min(i, j, N - i - 1, M - j - 1))\n    print(count)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    dic = {}\n    i = 0\n    while i < n:\n        j = 0\n        o = []\n        o = list(map(int, input().split()))\n        while j < len(o):\n            x = o[j]\n            dic[i, j] = x\n            j = j + 1\n        i = i + 1\n    som = 0\n    k = 0\n    d = {}\n    while k < n:\n        i = 0\n        l = 0\n        r = -1\n        while i < m:\n            if i > r:\n                ld = i\n                rd = i\n                cnt = 0\n                f = 0\n                while f == 0:\n                    if dic[k, ld] == dic[k, rd]:\n                        ldd = ld - 1\n                        rdd = rd + 1\n                        cnt = cnt + 1\n                        if ldd >= 0 and rdd <= m - 1:\n                            ld = ldd\n                            rd = rdd\n                        else:\n                            f = 1\n                    else:\n                        ld = ld + 1\n                        rd = rd - 1\n                        f = 1\n                d[k, i] = cnt\n                if rd >= r:\n                    l = ld\n                    r = rd\n            else:\n                j = l + (r - i)\n                if j - d[k, j] + 1 <= l:\n                    cnt = r - i + 1\n                    f = 0\n                    ld = i - cnt + 1\n                    rd = i + cnt - 1\n                    cnt = cnt - 1\n                    while f == 0:\n                        if dic[k, ld] == dic[k, rd]:\n                            ldd = ld - 1\n                            rdd = rd + 1\n                            cnt = cnt + 1\n                            if ldd >= 0 and rdd <= m - 1:\n                                ld = ldd\n                                rd = rdd\n                            else:\n                                f = 1\n                        else:\n                            ld = ld + 1\n                            rd = rd - 1\n                            f = 1\n                    d[k, i] = cnt\n                    if rd >= r:\n                        l = ld\n                        r = rd\n                else:\n                    cnt = d[k, j]\n                    d[k, i] = cnt\n                    ld = i - cnt + 1\n                    rd = i + cnt - 1\n                    if rd >= r:\n                        l = ld\n                        r = rd\n            i = i + 1\n        k = k + 1\n    k = 0\n    do = {}\n    while k < m:\n        i = 0\n        l = 0\n        r = -1\n        while i < n:\n            if i > r:\n                ld = i\n                rd = i\n                cnt = 0\n                f = 0\n                while f == 0:\n                    if dic[ld, k] == dic[rd, k]:\n                        ldd = ld - 1\n                        rdd = rd + 1\n                        cnt = cnt + 1\n                        if ldd >= 0 and rdd <= n - 1:\n                            ld = ldd\n                            rd = rdd\n                        else:\n                            f = 1\n                    else:\n                        ld = ld + 1\n                        rd = rd - 1\n                        f = 1\n                do[i, k] = cnt\n                q = d[i, k]\n                mi = min(q, cnt)\n                som = som + mi\n                if rd >= r:\n                    l = ld\n                    r = rd\n            else:\n                j = l + (r - i)\n                if j - do[j, k] + 1 <= l:\n                    cnt = r - i + 1\n                    f = 0\n                    ld = i - cnt + 1\n                    rd = i + cnt - 1\n                    cnt = cnt - 1\n                    while f == 0:\n                        if dic[ld, k] == dic[rd, k]:\n                            ldd = ld - 1\n                            rdd = rd + 1\n                            cnt = cnt + 1\n                            if ldd >= 0 and rdd <= n - 1:\n                                ld = ldd\n                                rd = rdd\n                            else:\n                                f = 1\n                        else:\n                            ld = ld + 1\n                            rd = rd - 1\n                            f = 1\n                    do[i, k] = cnt\n                    q = d[i, k]\n                    mi = min(q, cnt)\n                    som = som + mi\n                    if rd >= r:\n                        l = ld\n                        r = rd\n                else:\n                    cnt = do[j, k]\n                    do[i, k] = cnt\n                    q = d[i, k]\n                    mi = min(q, cnt)\n                    som = som + mi\n                    ld = i - cnt + 1\n                    rd = i + cnt - 1\n                    if rd >= r:\n                        l = ld\n                        r = rd\n            i = i + 1\n        k = k + 1\n    print(som)", "def chfdora(A, n, m):\n    c = 0\n    for i in range(0, n):\n        for j in range(0, m):\n            d = min(i, n - 1 - i, j, m - j - 1)\n            pnt = 0\n            for k in range(0, d + 1):\n                if A[i - k][j] != A[i + k][j]:\n                    break\n                else:\n                    pnt += 1\n            gnt = 0\n            for k in range(0, d + 1):\n                if A[i][j - k] != A[i][j + k]:\n                    break\n                else:\n                    gnt += 1\n            c += min(pnt, gnt)\n    print(c)\nT = int(input())\nfor i in range(0, T):\n    (N, M) = map(int, input().split())\n    A = []\n    for i in range(N):\n        B = list(map(int, input().split()))\n        A.append(B)\n    chfdora(A, N, M)", "T = int(input())\nfor t in range(T):\n    (N, M) = [int(x) for x in input().split()]\n    inp = []\n    for i in range(N):\n        inp.append([int(x) for x in input().split()])\n    phor = [[0] * M for i in range(N)]\n    pvert = [[0] * M for i in range(N)]\n    for i in range(N):\n        l = 0\n        r = -1\n        for j in range(M):\n            if j > r:\n                k = 1\n            else:\n                k = min(phor[i][l + r - j], r - j + 1)\n            while 0 <= j - k and j + k < M and (inp[i][j - k] == inp[i][j + k]):\n                k += 1\n            phor[i][j] = k\n            k -= 1\n            if j + k > r:\n                l = j - k\n                r = j + k\n    for j in range(M):\n        l = 0\n        r = -1\n        for i in range(N):\n            if i > r:\n                k = 1\n            else:\n                k = min(pvert[l + r - i][j], r - i + 1)\n            while 0 <= i - k and i + k < N and (inp[i - k][j] == inp[i + k][j]):\n                k += 1\n            pvert[i][j] = k\n            k -= 1\n            if i + k > r:\n                l = i - k\n                r = i + k\n    summ = 0\n    for i in range(N):\n        for j in range(M):\n            summ += min(phor[i][j], pvert[i][j])\n    print(summ)", "def longestPalindrome(s):\n    l = len(s)\n    res = [0] * l\n    (c, r) = (0, 0)\n    for i in range(l):\n        m = 2 * c - i\n        if i < r and m >= 0:\n            res[i] = min(r - i, res[m])\n        try:\n            while i + res[i] < l and i - res[i] >= 0 and (s[i + res[i]] == s[i - res[i]]):\n                res[i] += 1\n        except IndexError as e:\n            pass\n        if i + res[i] > r:\n            c = i\n            r = i + res[i]\n    return res\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    ldash = []\n    ldash = list(map(list, zip(*l)))\n    lh = [[0] * m] * n\n    ldashh = [[0] * n] * m\n    for i in range(n):\n        lh[i] = longestPalindrome(l[i])\n    for i in range(m):\n        ldashh[i] = longestPalindrome(ldash[i])\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            ans += min(lh[i][j], ldashh[j][i])\n    print(ans)", "def longestPalindrome(s):\n    l = len(s)\n    res = [0] * l\n    (c, r) = (0, 0)\n    for i in range(l):\n        m = 2 * c - i\n        if i < r and m >= 0:\n            res[i] = min(r - i, res[m])\n        try:\n            while i + res[i] < l and i - res[i] >= 0 and (s[i + res[i]] == s[i - res[i]]):\n                res[i] += 1\n        except IndexError as e:\n            pass\n        if i + res[i] > r:\n            c = i\n            r = i + res[i]\n    return res\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    ldash = []\n    ldash = list(map(list, zip(*l)))\n    lh = []\n    ldashh = []\n    for i in range(n):\n        lh.append(longestPalindrome(l[i]))\n    for i in range(m):\n        ldashh.append(longestPalindrome(ldash[i]))\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            ans += min(lh[i][j], ldashh[j][i])\n    print(ans)", "def count_matrix(matrix, i, j, n, m):\n    l = min(i - 0, n - 1 - i, j - 0, m - 1 - j)\n    count = 0\n    for k in range(l):\n        if matrix[i - k - 1][j] == matrix[i + k + 1][j] and matrix[i][j - k - 1] == matrix[i][j + k + 1]:\n            count += 1\n        else:\n            break\n    return count\n\ndef find_pairs(matrix, n, m):\n    pairs = n * m\n    mn = min(n, m)\n    l = mn if mn % 2 != 0 else mn - 1\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            pairs += count_matrix(matrix, i, j, n, m)\n    return pairs\npairs = []\ntest_cases = int(input())\nfor test_case in range(test_cases):\n    size = list(map(int, input().strip().split()))\n    (n, m) = (size[0], size[1])\n    matrix = []\n    for i in range(n):\n        rows = list(map(int, input().strip().split()))\n        matrix.append(rows)\n    pairs.append(find_pairs(matrix, n, m))\nfor pair in pairs:\n    print(pair)", "from abc import ABC, abstractmethod\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef get_int(source):\n    return int(source())\n\ndef get_ints(source):\n    return [int(x) for x in source().split(' ')]\n\ndef getline_from_std():\n    return input()\n\nclass IOProcessing(ABC):\n\n    @abstractmethod\n    def read_test_case(self, source):\n        pass\n\n    @abstractmethod\n    def process_test_case(self, tcase):\n        pass\n\n    def solve(self, input_type='from_std', output_type='to_std', input_path='', output_path='output.txt', tcase_handling='all'):\n        ans = []\n        if input_type == 'from_file':\n            with open(input_path, 'r') as in_file:\n                t = int(in_file.readline())\n                for _ in range(t):\n                    tcase = self.read_test_case(in_file.readline)\n                    ans.append(self.process_test_case(tcase))\n                    if tcase_handling == 'single' and output_type == 'to_std':\n                        print(ans[-1])\n        elif input_type == 'from_std':\n            t = int(getline_from_std())\n            for _ in range(t):\n                tcase = self.read_test_case(getline_from_std)\n                ans.append(self.process_test_case(tcase))\n                if tcase_handling == 'single' and output_type == 'to_std':\n                    print(ans[-1])\n        if output_type == 'to_file':\n            with open(output_path, 'w') as output:\n                for a in ans:\n                    output.write(str(a) + '\\n')\n        elif output_type == 'to_std' and tcase_handling == 'all':\n            for a in ans:\n                print(a)\n\nclass Ex_1_io(IOProcessing):\n\n    def read_test_case(self, source):\n        (n, m) = get_ints(source)\n        a = []\n        for _ in range(n):\n            a.append(get_ints(source))\n        return {'n': n, 'm': m, 'a': a}\n\n    def process_test_case(self, tcase):\n        n = tcase['n']\n        m = tcase['m']\n        a = tcase['a']\n        ans = 0\n        for i in range(n):\n            for j in range(m):\n                maxd = min(i, j, n - i, m - j)\n                l = 0\n                while l <= maxd and i - l >= 0 and (i + l < n) and (j - l >= 0) and (j + l < m) and (a[i - l][j] == a[i + l][j]) and (a[i][j - l] == a[i][j + l]):\n                    l += 1\n                ans += l\n        return ans\nsolution = Ex_1_io()\nsolution.solve(input_type='from_std', output_type='to_std', input_path='input.txt', output_path='output.txt', tcase_handling='all')", "from itertools import count\n\ndef read_mat(rows, cols):\n    mat = [input().split() for _ in range(rows)]\n    return mat\n\ndef noof_pairs(mat, rows, cols):\n    noof_elems = rows * cols\n    cnt = 0\n    for i in range(1, rows - 1):\n        for j in range(1, cols - 1):\n            for k in count(1):\n                if i - k >= 0 and j - k >= 0 and (i + k < rows) and (j + k < cols):\n                    pass\n                else:\n                    break\n                if mat[i][j - k] == mat[i][j + k] and mat[i - k][j] == mat[i + k][j]:\n                    cnt += 1\n                else:\n                    break\n    return cnt + noof_elems\n\ndef main():\n    for i in range(int(input())):\n        (rows, cols) = map(int, input().split())\n        mat = read_mat(rows, cols)\n        cnt = noof_pairs(mat, rows, cols)\n        print(cnt)\nmain()", "pali = lambda x: x == x[::-1]\n\ndef traverse(arr, n, m):\n    cnt = m * n\n    for i in range(n):\n        for j in range(m):\n            length = 2 * min(i, j, n - i - 1, m - j - 1) + 1\n            if length == 1:\n                continue\n            if i < length // 2 or i >= n - length // 2 or j < length // 2 or (j >= m - length // 2):\n                continue\n            for x in range(1, length // 2 + 1):\n                if arr[i - x][j] == arr[i + x][j] and arr[i][j - x] == arr[i][j + x]:\n                    cnt += 1\n                else:\n                    break\n    return cnt\n\ndef brute(arr, m, n):\n    res = 0\n    res += traverse(arr, n, m)\n    return res\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(list(map(int, input().split())))\n    print(brute(arr, m, n))", "def maxPall(text):\n    g = [0] * len(text)\n    (c, r) = (0, 0)\n    l = len(text)\n    for i in range(0, len(text)):\n        mirror = 2 * c - i\n        if mirror >= 0 and i < r:\n            g[i] = min(r - i, g[mirror])\n        try:\n            while i + g[i] < l and i - g[i] >= 0 and (text[i + g[i]] == text[i - g[i]]):\n                g[i] += 1\n        except IndexError as e:\n            pass\n        if i + g[i] > r:\n            c = i\n            r = i + g[i]\n    return g\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ar = []\n    for i in range(n):\n        ar.append(list(map(int, input().split())))\n    rowPal = []\n    colPal = []\n    for i in range(n):\n        rowPal.append(maxPall(ar[i]))\n    arr = list(map(list, zip(*ar)))\n    for i in range(m):\n        colPal.append(maxPall(arr[i]))\n    colPal = list(map(list, zip(*colPal)))\n    g = 0\n    for i in range(n):\n        for j in range(m):\n            g += min(rowPal[i][j], colPal[i][j])\n    print(g)", "import numpy as np\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    matrix = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        matrix.append(temp)\n    ans = 0\n    rows = np.zeros((n, m))\n    for row in range(n):\n        l = 0\n        r = -1\n        for i in range(m):\n            if i > r:\n                k = 1\n            else:\n                k = min(rows[row][l + r - i], 1 + r - i)\n                k = int(k)\n            while 0 <= i - k and i + k < m and (matrix[row][i - k] == matrix[row][i + k]):\n                k += 1\n            rows[row][i] = k\n            k -= 1\n            if i + k > r:\n                l = i - k\n                r = i + k\n    cols = np.zeros((n, m))\n    for col in range(m):\n        l = 0\n        r = -1\n        for i in range(n):\n            if i > r:\n                k = 1\n            else:\n                k = min(cols[l + r - i][col], 1 + r - i)\n                k = int(k)\n            while 0 <= i - k and i + k < n and (matrix[i - k][col] == matrix[i + k][col]):\n                k += 1\n            cols[i][col] = k\n            ans += min(rows[i][col], k)\n            kk = k - 1\n            if i + kk > r:\n                l = i - kk\n                r = i + kk\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            ans += min(rows[i][j], cols[i][j])\n    print(int(ans))", "def pairs(matrix, n, m):\n    pairs = n * m\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            for k in range(min(min(n - i - 1, i), min(m - j - 1, j))):\n                k += 1\n                if matrix[i - k][j] == matrix[i + k][j] and matrix[i][j + k] == matrix[i][j - k]:\n                    pairs += 1\n                else:\n                    break\n    return pairs\nfor test in range(int(input())):\n    (N, M) = [int(x) for x in input().split()]\n    MATRIX = [[int(x) for x in input().split()] for x in range(N)]\n    print(pairs(MATRIX, N, M))", "def check(x, i, j, y):\n    r = 0\n    count = 0\n    while r <= y:\n        if x[i][j - r] == x[i][j + r] and x[i - r][j] == x[i + r][j]:\n            count += 1\n        else:\n            return count\n        r += 1\n    return count\nt = int(input())\nwhile t > 0:\n    (n, m) = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        a = [int(y) for y in input().split()]\n        matrix.append(a)\n        m = len(a)\n    final = 0\n    for i in range(n):\n        for j in range(m):\n            temp1 = 1000000\n            temp2 = 1000000\n            if i >= n / 2:\n                temp1 = n - 1 - i\n            if j >= m / 2:\n                temp2 = m - j - 1\n            temp = min(i, j, temp1, temp2)\n            final = final + check(matrix, i, j, temp)\n    print(final)\n    t -= 1", "def manachars(arr, n, l):\n    n = 2 * n + 1\n    c = 1\n    r = 2\n    diff = -1\n    imirror = -1\n    l[1] = 1\n    for i in range(2, n):\n        imirror = 2 * c - i\n        diff = r - i\n        if diff > 0:\n            l[i] = min(diff, l[imirror])\n        try:\n            while i + l[i] < n and i - l[i] > 0 and ((i + l[i] + 1) % 2 == 0 or arr[(i - l[i] - 1) // 2] == arr[(i + l[i] + 1) // 2]):\n                l[i] += 1\n        except:\n            pass\n        if i + l[i] > r:\n            c = i\n            r = i + l[i]\ntry:\n    t = int(input())\n    for _ in range(t):\n        (n, m) = list(map(int, input().split()))\n        arr = []\n        arrtrans = [[0 for i in range(n)] for j in range(m)]\n        for i in range(n):\n            x = list(map(int, input().split()))\n            arr.append(x)\n            for j in range(m):\n                arrtrans[j][i] = arr[i][j]\n        ans = 0\n        l = [[0 for i in range(2 * m + 1)] for j in range(n)]\n        for i in range(n):\n            manachars(arr[i], m, l[i])\n        l1 = [[0 for i in range(2 * n + 1)] for j in range(m)]\n        for j in range(m):\n            manachars(arrtrans[j], n, l1[j])\n        ans = 0\n        for i in range(n):\n            for j in range(m):\n                a = 2 * i + 1\n                b = 2 * j + 1\n                ans += (min(l[i][b], l1[j][a]) - 1) // 2\n        print(m * n + ans)\nexcept:\n    pass", "import math\n\ndef LPS(A):\n    T = ['$', '#']\n    for a in A:\n        T.append(a)\n        T.append('#')\n    T.append('@')\n    P = [0] * len(T)\n    (C, R) = (0, 0)\n    for i in range(1, len(T)):\n        mirr = 2 * C - i\n        if i < R:\n            P[i] = min(R - i, P[mirr])\n        try:\n            if i - (1 + P[i]) < 0:\n                raise IndexError\n            while T[i + (1 + P[i])] == T[i - (1 + P[i])]:\n                P[i] += 1\n        except IndexError:\n            pass\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n    X = []\n    for i in range(len(T)):\n        if T[i] != '$' and T[i] != '@' and (T[i] != '#'):\n            X.append(P[i])\n    return X\ntest = int(input())\nfor t in range(test):\n    arr = list()\n    (n, m) = map(int, input().split())\n    for i in range(n):\n        arr.append(list(map(int, input().split())))\n    rowCount = [[0] * m for i in range(n)]\n    for i in range(n):\n        sol = LPS(arr[i])\n        for j in range(m):\n            rowCount[i][j] = sol[j]\n    colCount = [[0] * m for i in range(n)]\n    for j in range(m):\n        A = []\n        for i in range(n):\n            A.append(arr[i][j])\n        sol = LPS(A)\n        for i in range(n):\n            colCount[i][j] = sol[i]\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            count += math.ceil(min(rowCount[i][j], colCount[i][j]) / 2)\n    print(count)"]