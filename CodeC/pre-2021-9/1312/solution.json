["import bisect\nimport math\n\ndef find_possible(vec, t):\n    if len(vec) == 1:\n        return [(vec[0], 0)]\n    p1 = find_possible(vec[:len(vec) // 2], t)\n    p2 = find_possible(vec[len(vec) // 2:], t)\n    i1 = 0\n    i1t = 0\n    i2 = 0\n    i2t = 0\n    min_bribe_1 = math.inf\n    min_bribe_2 = math.inf\n    rv = []\n    while i1 < len(p1) and i2 < len(p2):\n        if p1[i1][0] < p2[i2][0]:\n            while i2t < len(p2) and p2[i2t][0] <= p1[i1][0] + t:\n                min_bribe_2 = min(min_bribe_2, p2[i2t][1] + 1)\n                i2t += 1\n            min_bribe_1 = min(min_bribe_1, p1[i1][1])\n            if min_bribe_2 < math.inf:\n                rv.append((p1[i1][0], p1[i1][1] + min_bribe_2))\n            i1 += 1\n        else:\n            assert p1[i1][0] > p2[i2][0]\n            while i1t < len(p1) and p1[i1t][0] <= p2[i2][0] + t:\n                min_bribe_1 = min(min_bribe_1, p1[i1t][1] + 1)\n                i1t += 1\n            min_bribe_2 = min(min_bribe_2, p2[i2][1])\n            if min_bribe_1 < math.inf:\n                rv.append((p2[i2][0], p2[i2][1] + min_bribe_1))\n            i2 += 1\n    if i1 < len(p1):\n        assert min_bribe_2 == 0\n        rv.extend(p1[i1:])\n    if i2 < len(p2):\n        assert min_bribe_1 == 0\n        rv.extend(p2[i2:])\n    return rv\nfor _ in range(int(input())):\n    (__, t) = [int(x) for x in input().split()]\n    x = [int(x) for x in input().split()]\n    ans = find_possible(x, t)\n    i = bisect.bisect_left(ans, (x[0] + 1, 0))\n    if i == 0 or ans[i - 1][0] != x[0]:\n        print(-1)\n    else:\n        print(ans[i - 1][1])", "import bisect\nimport math\n\ndef find_possible(vec, t):\n    if len(vec) == 1:\n        return [(vec[0], 0)]\n    p1 = find_possible(vec[:len(vec) // 2], t)\n    p2 = find_possible(vec[len(vec) // 2:], t)\n    i1 = 0\n    i1t = 0\n    i2 = 0\n    i2t = 0\n    min_bribe_1 = math.inf\n    min_bribe_2 = math.inf\n    rv = []\n    while i1 < len(p1) and i2 < len(p2):\n        if p1[i1][0] < p2[i2][0]:\n            while i2t < len(p2) and p2[i2t][0] <= p1[i1][0] + t:\n                min_bribe_2 = min(min_bribe_2, p2[i2t][1] + 1)\n                i2t += 1\n            min_bribe_1 = min(min_bribe_1, p1[i1][1])\n            if min_bribe_2 < math.inf:\n                rv.append((p1[i1][0], p1[i1][1] + min_bribe_2))\n            i1 += 1\n        else:\n            assert p1[i1][0] > p2[i2][0]\n            while i1t < len(p1) and p1[i1t][0] <= p2[i2][0] + t:\n                min_bribe_1 = min(min_bribe_1, p1[i1t][1] + 1)\n                i1t += 1\n            min_bribe_2 = min(min_bribe_2, p2[i2][1])\n            if min_bribe_1 < math.inf:\n                rv.append((p2[i2][0], p2[i2][1] + min_bribe_1))\n            i2 += 1\n    if i1 < len(p1):\n        assert min_bribe_2 == 0\n        rv.extend(p1[i1:])\n    if i2 < len(p2):\n        assert min_bribe_1 == 0\n        rv.extend(p2[i2:])\n    return rv\nfor _ in range(int(input())):\n    (__, t) = [int(x) for x in input().split()]\n    x = [int(x) for x in input().split()]\n    ans = find_possible(x, t)\n    i = bisect.bisect_left(ans, (x[0] + 1, 0))\n    if i == 0 or ans[i - 1][0] != x[0]:\n        print(-1)\n    else:\n        print(ans[i - 1][1])", "import bisect\nimport math\n\ndef find_possible(vec, t):\n    if len(vec) == 1:\n        return [(vec[0], 0)]\n    assert len(vec) % 2 == 0\n    p1 = find_possible(vec[:len(vec) // 2], t)\n    p2 = find_possible(vec[len(vec) // 2:], t)\n    i1 = 0\n    i1t = 0\n    i2 = 0\n    i2t = 0\n    min_bribe_1 = math.inf\n    min_bribe_2 = math.inf\n    rv = []\n    while i1 < len(p1) and i2 < len(p2):\n        if p1[i1][0] <= p2[i2][0]:\n            while i2t < len(p2) and p2[i2t][0] <= p1[i1][0] + t:\n                min_bribe_2 = min(min_bribe_2, p2[i2t][1] + 1)\n                i2t += 1\n            min_bribe_1 = min(min_bribe_1, p1[i1][1])\n        if p1[i1][0] >= p2[i2][0]:\n            while i1t < len(p1) and p1[i1t][0] <= p2[i2][0] + t:\n                min_bribe_1 = min(min_bribe_1, p1[i1t][1] + 1)\n                i1t += 1\n            min_bribe_2 = min(min_bribe_2, p2[i2][1])\n        if p1[i1][0] < p2[i2][0]:\n            if min_bribe_2 < math.inf:\n                rv.append((p1[i1][0], p1[i1][1] + min_bribe_2))\n            i1 += 1\n        else:\n            assert p1[i1][0] > p2[i2][0]\n            if min_bribe_1 < math.inf:\n                rv.append((p2[i2][0], p2[i2][1] + min_bribe_1))\n            i2 += 1\n    if i1 < len(p1):\n        assert min_bribe_2 == 0\n        rv.extend(p1[i1:])\n    if i2 < len(p2):\n        assert min_bribe_1 == 0\n        rv.extend(p2[i2:])\n    return rv\nfor _ in range(int(input())):\n    (h, t) = [int(x) for x in input().split()]\n    x = [int(x) for x in input().split()]\n    assert len(x) == 2 ** h\n    ans = find_possible(x, t)\n    i = bisect.bisect_left(ans, (x[0] + 1, 0))\n    if i == 0 or ans[i - 1][0] != x[0]:\n        print(-1)\n    else:\n        print(ans[i - 1][1])", "import bisect\nimport math\n\ndef find_possible(vec, t):\n    if len(vec) == 1:\n        return [(vec[0], 0)]\n    assert len(vec) % 2 == 0\n    p1 = find_possible(vec[:len(vec) // 2], t)\n    p2 = find_possible(vec[len(vec) // 2:], t)\n    i1 = 0\n    i1t = 0\n    i2 = 0\n    i2t = 0\n    min_bribe_1 = math.inf\n    min_bribe_2 = math.inf\n    rv = []\n    while i1 < len(p1) and i2 < len(p2):\n        if p1[i1][0] <= p2[i2][0]:\n            while i2t < len(p2) and p2[i2t][0] <= p1[i1][0] + t:\n                min_bribe_2 = min(min_bribe_2, p2[i2t][1] + 1)\n                i2t += 1\n            min_bribe_1 = min(min_bribe_1, p1[i1][1])\n        if p1[i1][0] >= p2[i2][0]:\n            while i1t < len(p1) and p1[i1t][0] <= p2[i2][0] + t:\n                min_bribe_1 = min(min_bribe_1, p1[i1t][1] + 1)\n                i1t += 1\n            min_bribe_2 = min(min_bribe_2, p2[i2][1])\n        if p1[i1][0] < p2[i2][0]:\n            if min_bribe_2 < math.inf:\n                rv.append((p1[i1][0], p1[i1][1] + min_bribe_2))\n            i1 += 1\n        elif p1[i1][0] > p2[i2][0]:\n            if min_bribe_1 < math.inf:\n                rv.append((p2[i2][0], p2[i2][1] + min_bribe_1))\n            i2 += 1\n        else:\n            min_val = min(p1[i1][1] + min_bribe_2, p2[i2][1] + min_bribe_1)\n            if min_val < math.inf:\n                rv.append((p1[i1][0], min_val))\n            i1 += 1\n            i2 += 1\n    if i1 < len(p1):\n        assert min_bribe_2 == 0\n        rv.extend(p1[i1:])\n    if i2 < len(p2):\n        assert min_bribe_1 == 0\n        rv.extend(p2[i2:])\n    return rv\nfor _ in range(int(input())):\n    (h, t) = [int(x) for x in input().split()]\n    x = [int(x) for x in input().split()]\n    assert len(x) == 2 ** h\n    us = x[0]\n    bribe = 0\n    for i in range(h):\n        others = x[2 ** i:2 ** (i + 1)]\n        mx = max(others)\n        if mx < us:\n            continue\n        if mx <= us + t:\n            bribe += 1\n            continue\n        if mx > us + t * (i + 1):\n            bribe = -1\n            break\n        possibles = find_possible(others, t)\n        p1 = bisect.bisect_left(possibles, (us, 0))\n        p2 = bisect.bisect_right(possibles, (us + t, math.inf))\n        if p1 > 0:\n            ans1 = min((b for (__, b) in possibles[:p1]))\n        else:\n            ans1 = math.inf\n        if p2 > p1:\n            ans2 = min((b + 1 for (__, b) in possibles[p1:p2]))\n        else:\n            ans2 = math.inf\n        ans = min(ans1, ans2)\n        if ans == math.inf:\n            bribe = -1\n            break\n        bribe += ans\n    print(bribe)"]