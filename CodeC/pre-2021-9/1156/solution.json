["inf = 10000000\nt = int(input())\nfor _ in range(t):\n    dp = []\n    a = []\n    m = []\n    n = int(input())\n    for _ in range(n):\n        inp = list(map(int, input().split()))\n        a.append(inp[1:])\n        m.append(inp[0])\n        dp.append([0] * inp[0])\n    for i in range(1, n):\n        (m1, m2) = (-inf, -inf)\n        for j in range(m[i - 1]):\n            m1 = max(m1, dp[i - 1][(j + 1) % m[i - 1]] - i * a[i - 1][j])\n            m2 = max(m2, dp[i - 1][(j + 1) % m[i - 1]] + i * a[i - 1][j])\n        for j in range(m[i]):\n            dp[i][j] = max(dp[i][j], m1 + i * a[i][j], m2 - i * a[i][j])\n    ans = max(dp[n - 1])\n    print(ans)", "inf = 10000000\nt = int(input())\nfor _ in range(t):\n    dp = []\n    a = []\n    m = []\n    n = int(input())\n    for _ in range(n):\n        inp = list(map(int, input().split()))\n        a.append(inp[1:])\n        m.append(inp[0])\n        dp.append([0] * inp[0])\n    for i in range(1, n):\n        (m1, m2) = (-inf, -inf)\n        for j in range(m[i - 1]):\n            m1 = max(m1, dp[i - 1][(j + 1) % m[i - 1]] - i * a[i - 1][j])\n            m2 = max(m2, dp[i - 1][(j + 1) % m[i - 1]] + i * a[i - 1][j])\n        for j in range(m[i]):\n            dp[i][j] = max(dp[i][j], m1 + i * a[i][j], m2 - i * a[i][j])\n    ans = max(dp[n - 1])\n    print(ans)", "def shift_array_by_one(a):\n    return [a.pop(-1)] + a\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    for i in range(n):\n        inp = list(map(int, input().strip().split()))\n        cnt = inp.pop(0)\n        if i == 0:\n            new_cost = [0] * cnt\n        else:\n            new_cost = []\n            for j in range(cnt):\n                elem = i * inp[j]\n                val = max(m1 + elem, m2 - elem)\n                new_cost.append(val)\n        last_dishes = shift_array_by_one(inp)\n        m1 = new_cost[0] - (i + 1) * last_dishes[0]\n        m2 = new_cost[0] + (i + 1) * last_dishes[0]\n        for k in range(1, cnt):\n            valp = new_cost[k] - (i + 1) * last_dishes[k]\n            valn = new_cost[k] + (i + 1) * last_dishes[k]\n            if valp > m1:\n                m1 = valp\n            if valn > m2:\n                m2 = valn\n    print(max(new_cost))", "INF = 10 ** 15\nfor t in range(int(input())):\n    N = int(input())\n    A = [list(map(int, input().split()))[1:] for i in range(N)]\n    M = [len(Ai) for Ai in A]\n    dp_firstpos = [-INF] * N\n    dp_firstneg = [-INF] * N\n    dp_firstpos[N - 1] = max(A[N - 1]) * (N - 1)\n    dp_firstneg[N - 1] = -min(A[N - 1]) * (N - 1)\n    for i in range(N - 2, -1, -1):\n        for j in range(M[i]):\n            lastpos = A[i][j - 1] * (i + 1) + dp_firstneg[i + 1]\n            lastneg = -A[i][j - 1] * (i + 1) + dp_firstpos[i + 1]\n            firstpos = A[i][j] * i\n            firstneg = -A[i][j] * i\n            dp_firstpos[i] = max(dp_firstpos[i], firstpos + lastpos, firstpos + lastneg)\n            dp_firstneg[i] = max(dp_firstneg[i], firstneg + lastpos, firstneg + lastneg)\n    ans = max(dp_firstpos[0], dp_firstneg[0])\n    print(ans)", "INF = 10 ** 15\nfor t in range(int(input())):\n    N = int(input())\n    A = [list(map(int, input().split()))[1:] for i in range(N)]\n    M = [len(Ai) for Ai in A]\n    dp = [[-INF] * 4 for i in range(N)]\n    dp[N - 1][0] = max(A[N - 1]) * (N - 1)\n    dp[N - 1][1] = -min(A[N - 1]) * (N - 1)\n    for i in range(N - 2, -1, -1):\n        for j in range(M[i]):\n            lastpos = A[i][j - 1] * (i + 1) + dp[i + 1][1]\n            lastneg = -A[i][j - 1] * (i + 1) + dp[i + 1][0]\n            firstpos = A[i][j] * i\n            firstneg = -A[i][j] * i\n            dp[i][0] = max(dp[i][0], firstpos + lastpos, firstpos + lastneg)\n            dp[i][1] = max(dp[i][1], firstneg + lastpos, firstneg + lastneg)\n    ans = max(dp[0])\n    print(ans)", "def main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        A = []\n        for _ in range(N):\n            A.append(list(map(int, input().split()[1:])))\n        P = M = 0\n        for i in range(N):\n            li = len(A[i])\n            P0 = max((max(P - i * A[i][j] + (i + 1) % N * A[i][(j - 1) % li], M + i * A[i][j] + (i + 1) % N * A[i][(j - 1) % li]) for j in range(li)))\n            M0 = max((max(P - i * A[i][j] - (i + 1) % N * A[i][(j - 1) % li], M + i * A[i][j] - (i + 1) % N * A[i][(j - 1) % li]) for j in range(li)))\n            (P, M) = (P0, M0)\n        print(P)\nmain()", "INF = 10 ** 15\nfor t in range(int(input())):\n    N = int(input())\n    A = [list(map(int, input().split()))[1:] for i in range(N)]\n    M = [len(Ai) for Ai in A]\n    dp = [[-INF] * 4 for i in range(N)]\n    dp[N - 1][0] = max(A[N - 1]) * (N - 1)\n    dp[N - 1][1] = -min(A[N - 1]) * (N - 1)\n    for i in range(N - 2, -1, -1):\n        for j in range(M[i]):\n            pos = A[i][j - 1] * (i + 1) + dp[i + 1][1]\n            neg = -A[i][j - 1] * (i + 1) + dp[i + 1][0]\n            dp[i][0] = max(dp[i][0], pos + A[i][j] * i, neg + A[i][j] * i)\n            dp[i][1] = max(dp[i][1], pos - A[i][j] * i, neg - A[i][j] * i)\n    ans = max(dp[0])\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for i in range(n):\n        b = list(map(int, input().strip().split()))\n        a.append(b)\n    m = []\n    ans = []\n    for i in range(n):\n        min = 1\n        max = 1\n        for j in range(1, a[i][0] + 1):\n            if a[i][j] < a[i][min]:\n                min = j\n            if a[i][j] > a[i][max]:\n                max = j\n        m.append((min, max))\n    if n == 1:\n        print(0)\n        continue\n    ans1 = []\n    ans2 = []\n    for i in range(1, a[1][0] + 1):\n        ans1.append(abs(a[0][m[0][0]] - a[1][i]))\n        ans2.append(abs(a[0][m[0][1]] - a[1][i]))\n    for i in range(n - 2):\n        maxp1 = 0\n        maxp2 = 0\n        max1 = ans1[0] + abs(a[i + 1][a[i + 1][0]] - a[i + 2][m[i + 2][0]]) * (i + 2)\n        max2 = ans1[0] + abs(a[i + 1][a[i + 1][0]] - a[i + 2][m[i + 2][1]]) * (i + 2)\n        for j in range(a[i + 1][0]):\n            if max1 < ans1[j] + abs(a[i + 1][(j - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][0]]) * (i + 2):\n                maxp1 = j\n                max1 = ans1[maxp1] + abs(a[i + 1][(maxp1 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][0]]) * (i + 2)\n            if max2 < ans1[j] + abs(a[i + 1][(j - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][1]]) * (i + 2):\n                maxp2 = j\n                max2 = ans1[maxp2] + abs(a[i + 1][(maxp2 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][1]]) * (i + 2)\n        ans = []\n        for j in range(1, a[i + 2][0] + 1):\n            k1 = ans1[maxp1] + abs(a[i + 1][(maxp1 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][j]) * (i + 2)\n            k2 = ans1[maxp2] + abs(a[i + 1][(maxp2 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][j]) * (i + 2)\n            if k2 > k1:\n                ans.append(k2)\n            else:\n                ans.append(k1)\n        ans1 = ans\n        maxp1 = 0\n        maxp2 = 0\n        max1 = ans2[0] + abs(a[i + 1][a[i + 1][0]] - a[i + 2][m[i + 2][0]]) * (i + 2)\n        max2 = ans2[0] + abs(a[i + 1][a[i + 1][0]] - a[i + 2][m[i + 2][1]]) * (i + 2)\n        for j in range(a[i + 1][0]):\n            if max1 < ans2[j] + abs(a[i + 1][(j - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][0]]) * (i + 2):\n                maxp1 = j\n                max1 = ans2[maxp1] + abs(a[i + 1][(maxp1 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][0]]) * (i + 2)\n            if max2 < ans2[j] + abs(a[i + 1][(j - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][1]]) * (i + 2):\n                maxp2 = j\n                max2 = ans2[maxp2] + abs(a[i + 1][(maxp2 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][1]]) * (i + 2)\n        ans = []\n        for j in range(1, a[i + 2][0] + 1):\n            k1 = ans2[maxp1] + abs(a[i + 1][(maxp1 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][j]) * (i + 2)\n            k2 = ans2[maxp2] + abs(a[i + 1][(maxp2 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][j]) * (i + 2)\n            if k2 > k1:\n                k1 = k2\n            ans.append(k1)\n        ans2 = ans\n    ansx = -1\n    for i in ans1:\n        if i > ansx:\n            ansx = i\n    for i in ans2:\n        if i > ansx:\n            ansx = i\n    print(ansx)", "import sys\n\nclass Dish:\n\n    def __init__(self, arr, ind):\n        self.arr = arr\n        if ind == 1 or ind == n:\n            min1 = min(arr)\n            max1 = max(arr)\n            self.arr = [min1, max1]\n        self.len = len(self.arr)\n        self.arrVal = [0] * self.len\n        self.ind = ind\n        self.prods1 = []\n        self.prods2 = []\n        self.valInd = 0\n\n    def rebuildArr(self):\n        arr = self.arr\n        arrVal = self.arrVal\n        ar1 = []\n        ar2 = []\n        for ind in range(self.len):\n            next1 = arrVal[ind] + self.ind * arr[ind]\n            next2 = arrVal[ind] - self.ind * arr[ind]\n            ar1.append((next1, ind))\n            ar2.append((next2, ind))\n        ar1.sort()\n        ar2.sort()\n        ind1 = ar1[-1][1]\n        ind2 = ar2[-1][1]\n        self.arr = [self.arr[ind1], self.arr[ind2]]\n        self.arrVal = [self.arrVal[ind1], self.arrVal[ind2]]\n        self.len = 2\n\n    def __str__(self):\n        return str((self.ind, len(self.arr), self.vals))\n\n    def getCur(self):\n        (first, last) = self.vals[self.valInd]\n        return first\n\n    def getLast(self):\n        (first, last) = self.vals[self.valInd]\n        return last\n\n    def initProds(self):\n        if self.ind == 1 or self.ind == n:\n            minVal = min(self.arr)\n            maxVal = max(self.arr)\n            self.prods1.append((minVal, minVal, minVal))\n            self.prods2.append((maxVal, maxVal, maxVal))\n            self.prods1.sort()\n            self.prods2.sort()\n            return\n        for i in range(self.len):\n            j = (i - 1 + self.len) % self.len\n            I = self.arr[i]\n            J = self.arr[j]\n            next1 = self.ind * I * (self.ind + 1) * J\n            next2 = self.ind * I / ((self.ind + 1) * J)\n            self.prods1.append((next1, I, J))\n            self.prods2.append((next2, I, J))\n        self.prods1.sort()\n        self.prods2.sort()\n\n    def getVals(self):\n        res = set([])\n        res.add(self.prods1[0][1:])\n        res.add(self.prods2[0][1:])\n        res.add(self.prods1[-1][1:])\n        res.add(self.prods2[-1][1:])\n        return list(res)\n\ndef doMaxOne(ind):\n    global dishes, n\n    dish = dishes[ind]\n    curPower = getPower(ind)\n    curValInd = dish.valInd\n    for rec in range(len(dish.vals)):\n        dish.valInd = rec\n        power1 = getPower(ind)\n        power2 = 0\n        if rec > 0:\n            power2 = getPower(ind - 1)\n        power = power1 + power2\n        if power > curPower:\n            curValInd = rec\n            curPower = power\n    dish.valInd = curValInd\n\ndef doMaxTwo():\n    for rec in range(len(dishes) - 1):\n        dish1 = dishes[rec]\n        dish2 = dishes[rec + 1]\n        curRec1 = 0\n        curRec2 = 0\n        curProd = 0\n        for val1Ind in range(len(dish1.vals)):\n            val1 = dish1.vals[val1Ind]\n            dish1.valInd = val1Ind\n            for val2Ind in range(len(dish2.vals)):\n                val2 = dish2.vals[val2Ind]\n                dish2.valInd = val2Ind\n                nextProd = getPower(rec) + getPower(rec + 1)\n                if nextProd > curProd:\n                    curRec1 = val1Ind\n                    curRec2 = val2Ind\n                    curProd = nextProd\n        dish1.valInd = curRec1\n        dish2.valInd = curRec2\n\ndef doMaxThree():\n    if n < 3:\n        doMaxTwo()\n        return\n    for rec in range(len(dishes) - 2):\n        dish1 = dishes[rec]\n        dish2 = dishes[rec + 1]\n        dish3 = dishes[rec + 2]\n        curRec1 = 0\n        curRec2 = 0\n        curRec3 = 0\n        curProd = 0\n        for val1Ind in range(len(dish1.vals)):\n            val1 = dish1.vals[val1Ind]\n            dish1.valInd = val1Ind\n            for val2Ind in range(len(dish2.vals)):\n                val2 = dish2.vals[val2Ind]\n                dish2.valInd = val2Ind\n                for val3Ind in range(len(dish3.vals)):\n                    val3 = dish3.vals[val3Ind]\n                    dish3.valInd = val3Ind\n                    nextProd = getPower(rec) + getPower(rec + 1) + getPower(rec + 2)\n                    if nextProd > curProd:\n                        curRec1 = val1Ind\n                        curRec2 = val2Ind\n                        curRec3 = val3Ind\n                        curProd = nextProd\n        dish1.valInd = curRec1\n        dish2.valInd = curRec2\n        dish3.valInd = curRec3\n\ndef calcPower():\n    res = 0\n    for ind in range(len(dishes)):\n        res += getPower(ind)\n    return res\n\ndef doit():\n    for ind in range(len(dishes)):\n        doMaxOne(ind)\n\ndef printDishes():\n    for dish in dishes:\n        print(dish.vals[dish.valInd])\n        print(dish.vals)\n\ndef getPower(ind):\n    if ind == n - 1:\n        return 0\n    last = dishes[ind].getLast()\n    first = dishes[ind + 1].getCur()\n    return abs(last - first) * dishes[ind].ind\n\ndef bruteForce():\n    for dishInd in range(1, n):\n        dish = dishes[dishInd]\n        prevDish = dishes[dishInd - 1]\n        ln = dish.len\n        for arrInd in range(dish.len):\n            ingr = dish.arr[arrInd]\n            curInd = -1\n            curVal = 0\n            for prevInd in range(prevDish.len):\n                nextVal = prevDish.arrVal[prevInd] + abs(prevDish.arr[prevInd] - ingr) * dishInd\n                if nextVal > curVal:\n                    curVal = nextVal\n            dish.arrVal[(arrInd - 1 + ln) % ln] = curVal\n        dish.rebuildArr()\n    return max(dishes[n - 1].arrVal)\nq = int(input().strip())\nfor _ in range(q):\n    dishes = []\n    n = int(input().strip())\n    for ind in range(n):\n        dishes.append(Dish(list(map(int, input().strip().split(' ')))[1:], ind + 1))\n    print(bruteForce())", "import bisect\nMIN = -10 ** 20\n\ndef read_test():\n    N = int(input())\n    A = []\n    for _ in range(N):\n        A.append(list(map(int, input().strip().split()))[1:])\n    return (N, A)\n\ndef solve_test(N, A):\n    sol = 0\n    (P, Q) = ([], [])\n    (mx_pre, mx_suf) = ([], [])\n\n    def process_min_max():\n        nonlocal P, mx_pre, mx_suf\n        lP = len(P)\n        mx_pre = [MIN] * lP\n        mx_suf = [MIN] * lP\n        for i in range(lP):\n            mx_pre[i] = max(P[i][2], mx_pre[i - 1] if i > 0 else MIN)\n            mx_suf[lP - 1 - i] = max(P[lP - 1 - i][3], mx_suf[lP - i] if i > 0 else MIN)\n    (m, M) = (min(A[0]), max(A[0]))\n    Q.append((m, 0, -m, m))\n    if len(A[0]) > 0:\n        Q.append((M, 0, -M, M))\n    for n in range(1, N):\n        a = A[n]\n        Q.sort()\n        (P, Q) = (Q, [])\n        process_min_max()\n        for i in range(len(a)):\n            (first, last) = (a[i], a[i - 1])\n            ins_pos = bisect.bisect_left(P, (first, 0, 0, 0))\n            pos_pre = ins_pos - 1\n            pos_suf = ins_pos\n            if pos_pre < 0:\n                cost1 = MIN\n            else:\n                cost1 = mx_pre[pos_pre] + first * n\n            if pos_suf > len(P) - 1:\n                cost2 = MIN\n            else:\n                cost2 = mx_suf[pos_suf] - first * n\n            cost = max(cost1, cost2)\n            Q.append((last, cost, -last * (n + 1) + cost, last * (n + 1) + cost))\n    return max(map(lambda x: x[1], Q))\nT = int(input())\nfor _ in range(T):\n    (N, A) = read_test()\n    sol = solve_test(N, A)\n    print(sol)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    lengths = []\n    arr = []\n    final_arr = []\n    for k in range(n):\n        temp_array = [int(j) for j in input().split()]\n        arr.append(temp_array[1:])\n        lengths.append(temp_array[0])\n        final_arr.append([0] * lengths[k])\n    if n == 1:\n        print(0)\n    else:\n        final_arr[0] = arr[0]\n        (m1, m2) = (max(arr[0]), min(arr[0]))\n        for j in range(lengths[1]):\n            final_arr[1][j] = max(abs(arr[1][j] - m1), abs(arr[1][j] - m2))\n        for s in range(2, n):\n            max1 = -100000000000.0\n            max2 = -100000000000.0\n            for f in range(lengths[s - 1]):\n                foo = final_arr[s - 1][(f + 1) % lengths[s - 1]] + s * arr[s - 1][f]\n                bar = final_arr[s - 1][(f + 1) % lengths[s - 1]] - s * arr[s - 1][f]\n                if foo > max1:\n                    max1 = foo\n                if bar > max2:\n                    max2 = bar\n            for g in range(lengths[s]):\n                final_arr[s][g] = max(max1 - s * arr[s][g], max2 + s * arr[s][g])\n        print(max(final_arr[-1]))", "for _ in range(int(input())):\n    N = int(input())\n    Ingr = []\n    IngrSize = []\n    Total = 0\n    maxLen = 0\n    for i in range(N):\n        Ingr.append(list(map(int, input().split())))\n        IngrSize.append(Ingr[-1][0])\n        if maxLen < Ingr[-1][0]:\n            maxLen = Ingr[-1][0]\n        Ingr[-1].pop(0)\n    if N <= 1:\n        print(0)\n        continue\n    DPArr = []\n    for i in range(IngrSize[0]):\n        DPArr.append(tuple([Ingr[0][i], 0]))\n    for i in range(1, N):\n        newDPArr = [[0, 0] for a in range(IngrSize[i])]\n        DPArr.sort()\n        LeftMax = []\n        RightMax = []\n        LM = DPArr[0][1] - DPArr[0][0]\n        RM = DPArr[-1][1] + DPArr[-1][0]\n        LeftMax.append(LM)\n        RightMax.append(RM)\n        for j in range(1, IngrSize[i - 1]):\n            if LM < DPArr[j][1] - DPArr[j][0]:\n                LM = DPArr[j][1] - DPArr[j][0]\n            if RM < DPArr[IngrSize[i - 1] - 1 - j][1] + DPArr[IngrSize[i - 1] - 1 - j][0]:\n                RM = DPArr[IngrSize[i - 1] - 1 - j][1] + DPArr[IngrSize[i - 1] - 1 - j][0]\n            LeftMax.append(LM)\n            RightMax.append(RM)\n        RightMax.reverse()\n        for j in range(IngrSize[i]):\n            Max = 0\n            VALUE = Ingr[i][j] * i\n            if VALUE <= DPArr[0][0]:\n                Max = RightMax[0] - VALUE\n            elif VALUE >= DPArr[-1][0]:\n                Max = LeftMax[-1] + VALUE\n            else:\n                M1 = 0\n                M2 = 0\n                Beg = 0\n                End = IngrSize[i - 1] - 1\n                while Beg <= End:\n                    Mid = (Beg + End) // 2\n                    if VALUE >= DPArr[Mid][0] and DPArr[Mid + 1][0] >= VALUE:\n                        M1 = LeftMax[Mid] + VALUE\n                        M2 = RightMax[Mid + 1] - VALUE\n                        Max = max(M1, M2)\n                        break\n                    elif VALUE >= DPArr[Mid][0] and VALUE >= DPArr[Mid + 1][0]:\n                        Beg = Mid + 1\n                    else:\n                        End = Mid - 1\n            newDPArr[(j - 1 + IngrSize[i]) % IngrSize[i]][0] = Ingr[i][(j - 1 + IngrSize[i]) % IngrSize[i]] * (i + 1)\n            newDPArr[(j - 1 + IngrSize[i]) % IngrSize[i]][1] = Max\n        DPArr = newDPArr[:]\n    ANS = 0\n    for (i, w) in DPArr:\n        if w > ANS:\n            ANS = w\n    print(ANS)", "def main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        A = []\n        for _ in range(N):\n            A.append(list(map(int, input().split()[1:])))\n        P = M = 0\n        for i in range(N):\n            li = len(A[i])\n            P0 = max((max(P - i * A[i][j] + (i + 1) % N * A[i][(j - 1) % li], M + i * A[i][j] + (i + 1) % N * A[i][(j - 1) % li]) for j in range(li)))\n            M0 = max((max(P - i * A[i][j] - (i + 1) % N * A[i][(j - 1) % li], M + i * A[i][j] - (i + 1) % N * A[i][(j - 1) % li]) for j in range(li)))\n            (P, M) = (P0, M0)\n        print(max(P, M))\nmain()", "def getPairs(x, k, k1):\n    n = len(x)\n    y = [(x[i], x[(i + 1) % n]) for i in range(n)]\n    ret = []\n    for a in [-1, 1]:\n        yy = [(z[0] * k1 + z[1] * k * a, z) for z in y]\n        yy = sorted(yy)\n        mn = yy[0][0]\n        mx = yy[-1][0]\n        ret += [yy[0][1], yy[-1][1]]\n    return ret\n\ndef solve(z):\n    prev = [0]\n    y = []\n    n = len(z)\n    for (i, x) in enumerate(z):\n        if i == 0:\n            y = getPairs(x, 0, 1)\n            prev = [0] * len(y)\n            continue\n        n = len(y)\n        x = getPairs(x, i, (i + 1) % len(z))\n        ret = [0] * len(x)\n        for (a, aa) in enumerate(x):\n            mx = 0\n            for (b, bb) in enumerate(y):\n                val = prev[b % n] + i * abs(aa[1] - bb[0])\n                if val > mx:\n                    mx = val\n            ret[a] = mx\n        prev = ret\n        y = x\n    return max(prev)\nimport sys\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    x = int(f.readline())\n    y = []\n    for i in range(x):\n        y += [list(map(int, f.readline().split()))[1:]]\n    sol = solve(y)\n    print(sol)"]