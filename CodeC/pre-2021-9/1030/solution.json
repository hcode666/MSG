["from math import gcd\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    g = [set() for _ in range(n)]\n    for j in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].add(v)\n        g[v].add(u)\n    weight = list(map(int, input().split()))\n    mod = list(map(int, input().split()))\n    ans = [None] * n\n\n    def dfs(node, v, p=None):\n        f = 0\n        for i in g[node]:\n            if i != p:\n                dfs(i, gcd(v, weight[i]), node)\n                f = 1\n        if f == 0:\n            ans[node] = mod[node] - gcd(v, mod[node])\n    dfs(0, weight[0])\n    print(' '.join(map(str, [i for i in ans if i != None])))", "from math import gcd\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    g = [set() for _ in range(n)]\n    for j in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].add(v)\n        g[v].add(u)\n    weight = list(map(int, input().split()))\n    mod = list(map(int, input().split()))\n    ans = [None] * n\n\n    def dfs(node, v, p=None):\n        f = 0\n        for i in g[node]:\n            if i != p:\n                dfs(i, gcd(v, weight[i]), node)\n                f = 1\n        if f == 0:\n            ans[node] = mod[node] - gcd(v, mod[node])\n    dfs(0, weight[0])\n    print(' '.join(map(str, [i for i in ans if i != None])))", "from math import gcd\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    g = [set() for _ in range(n)]\n    for j in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].add(v)\n        g[v].add(u)\n    weight = list(map(int, input().split()))\n    mod = list(map(int, input().split()))\n    ans = [None] * n\n\n    def dfs(node, v, p=None):\n        f = 0\n        for i in g[node]:\n            if i != p:\n                dfs(i, gcd(v, weight[i]), node)\n                f = 1\n        if f == 0:\n            ans[node] = mod[node] - gcd(v, mod[node])\n    dfs(0, weight[0])\n    print(' '.join(map(str, [i for i in ans if i != None])))", "from math import gcd\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    g = [set() for _ in range(n)]\n    for j in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].add(v)\n        g[v].add(u)\n    weight = list(map(int, input().split()))\n    mod = list(map(int, input().split()))\n    ans = [None] * n\n\n    def dfs(node, v, p=None):\n        f = 0\n        for i in g[node]:\n            if i != p:\n                dfs(i, gcd(v, weight[i]), node)\n                f = 1\n        if f == 0:\n            ans[node] = mod[node] - gcd(v, mod[node])\n    dfs(0, weight[0])\n    print(' '.join(map(str, [i for i in ans if i != None])))", "from math import gcd\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    g = [set() for _ in range(n)]\n    for j in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].add(v)\n        g[v].add(u)\n    weight = list(map(int, input().split()))\n    mod = list(map(int, input().split()))\n    ans = [None] * n\n\n    def dfs(node, v, p=None):\n        f = 0\n        for i in g[node]:\n            if i != p:\n                dfs(i, gcd(v, weight[i]), node)\n                f = 1\n        if f == 0:\n            ans[node] = mod[node] - gcd(v, mod[node])\n    dfs(0, weight[0])\n    print(' '.join(map(str, [i for i in ans if i != None])))", "def gcd(a, b):\n    while b > 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef dfs(g, k, m, s, p, l, x, x1):\n    for i in g[s]:\n        if i != p:\n            dfs(g, gcd(k, l[i]), m, i, s, l, x, x1)\n    if len(g[s]) == 1 and s != 0:\n        x1[s] = m[s] - gcd(k, m[s])\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    g = {k: [] for k in range(n)}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    c = 0\n    li = []\n    for i in g:\n        if len(g[i]) == 1:\n            li.append(i)\n    l = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    x = [0 for i in range(n)]\n    x1 = [-1 for i in range(n)]\n    dfs(g, l[0], m, 0, -1, l, x, x1)\n    for i in x1:\n        if i != -1:\n            print(i, end=' ')\n    t = t - 1", "def gcd(a, b):\n    while b > 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef dfs(g, k, m, s, p, l, x, x1):\n    for i in g[s]:\n        if i != p:\n            dfs(g, gcd(k, l[i]), m, i, s, l, x, x1)\n    if len(g[s]) == 1 and s != 0:\n        x1[s] = m[s] - gcd(k, m[s])\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    g = {k: [] for k in range(n)}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    c = 0\n    li = []\n    for i in g:\n        if len(g[i]) == 1:\n            li.append(i)\n    l = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    x = [0 for i in range(n)]\n    x1 = [-1 for i in range(n)]\n    dfs(g, l[0], m, 0, -1, l, x, x1)\n    for i in x1:\n        if i != -1:\n            print(i, end=' ')\n    t = t - 1", "from math import gcd\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    g = [set() for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].add(v)\n        g[v].add(u)\n    weight = list(map(int, input().split()))\n    mod = list(map(int, input().split()))\n    ans = [None] * n\n\n    def dfs(node, v, p=None):\n        f = 0\n        for i in g[node]:\n            if i != p:\n                dfs(i, gcd(v, weight[i]), node)\n                f = 1\n        if f == 0:\n            ans[node] = mod[node] - gcd(v, mod[node])\n    dfs(0, weight[0])\n    print(' '.join(map(str, [i for i in ans if i != None])))", "def gcd(a, b):\n    while b > 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef dfs(g, k, m, s, p, l, x, x1):\n    for i in g[s]:\n        if i != p:\n            dfs(g, gcd(k, l[i]), m, i, s, l, x, x1)\n    if len(g[s]) == 1 and s != 0:\n        x1[s] = m[s] - gcd(k, m[s])\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    g = {k: [] for k in range(n)}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    c = 0\n    li = []\n    for i in g:\n        if len(g[i]) == 1:\n            li.append(i)\n    l = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    x = [0 for i in range(n)]\n    x1 = [-1 for i in range(n)]\n    dfs(g, l[0], m, 0, -1, l, x, x1)\n    for i in x1:\n        if i != -1:\n            print(i, end=' ')\n    t = t - 1", "def gcd(a, b):\n    while b > 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef dfs(g, k, m, s, p, l, x, x1):\n    for i in g[s]:\n        if i != p:\n            dfs(g, gcd(k, l[i]), m, i, s, l, x, x1)\n    if len(g[s]) == 1 and s != 0:\n        x1[s] = m[s] - gcd(k, m[s])\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    g = {k: [] for k in range(n)}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    c = 0\n    li = []\n    for i in g:\n        if len(g[i]) == 1:\n            li.append(i)\n    l = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    x = [0 for i in range(n)]\n    x1 = [-1 for i in range(n)]\n    dfs(g, l[0], m, 0, -1, l, x, x1)\n    for i in x1:\n        if i != -1:\n            print(i, end=' ')\n    print()\n    t = t - 1", "t = int(input())\nfrom collections import defaultdict\nimport queue\nimport sys\nsys.setrecursionlimit(10 ** 5)\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef dfs(i, graph, visited, g, v, leaves):\n    if visited[i] == False:\n        visited[i] = True\n        isleaf = True\n        for j in graph[i]:\n            if visited[j] == False:\n                g[j] = gcd(g[i], v[j])\n                isleaf = False\n                dfs(j, graph, visited, g, v, leaves)\n        if isleaf:\n            leaves.append(i)\nfor _ in range(t):\n    n = int(input())\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (u, v1) = list(map(int, input().split()))\n        graph[u].append(v1)\n        graph[v1].append(u)\n    v = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    v = [0] + v\n    m = [0] + m\n    g = {}\n    g[1] = v[1]\n    leaves = []\n    visited = {i: False for i in range(1, n + 1)}\n    dfs(1, graph, visited, g, v, leaves)\n    leaves.sort()\n    for i in range(len(leaves)):\n        l = leaves[i]\n        print(m[l] - gcd(g[l], m[l]), end=' ')\n    print()", "import functools\nfrom math import gcd\nimport sys\nsys.setrecursionlimit(10 ** 5)\n\ndef fun():\n    n = int(input())\n    g = {x: [] for x in range(1, n + 1)}\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    a = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    ls = []\n\n    def dfs(u, p, path=[]):\n        path.append(a[u - 1])\n        if len(g[u]) == 1 and p in g[u]:\n            d = functools.reduce(gcd, path)\n            ls.append([u, m[u - 1] - gcd(m[u - 1], d)])\n        for v in g[u]:\n            if v != p:\n                dfs(v, u)\n        path.pop()\n    dfs(1, 0)\n    for l in sorted(ls, key=lambda l: l[0]):\n        print(l[1], end=' ')\nfor _ in range(int(input())):\n    fun()", "from math import gcd\n\ndef find_sum(v=1, p=1, g=0):\n    for ee in graph[v]:\n        if ee != p:\n            find_sum(ee, v, gcd(g, arr_val[ee - 1]))\n    if len(graph[v]) == 1 and v != 1:\n        ans[v] = arr_rem[v - 1] - gcd(arr_rem[v - 1], g)\nt = int(input().strip())\nfor i in range(t):\n    n = int(input())\n    graph = {}\n    for e in range(1, n + 1):\n        graph[e] = list()\n    for e in range(n - 1):\n        (a, b) = map(int, input().strip().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    arr_val = list(map(int, input().strip().split()))\n    arr_rem = list(map(int, input().strip().split()))\n    Visited = [False] * (n + 1)\n    ans = [-1] * (n + 1)\n    find_sum(1, 1, g=arr_val[0])\n    for e in ans:\n        if e != -1:\n            print(e, end=' ')\n    print()", "from math import gcd\nt = int(input())\nfor it in range(t):\n    edge = {}\n    f = []\n    rev = {}\n    n = int(input())\n    val = []\n    m = []\n    for i in range(n - 1):\n        (x, y) = map(int, input().split(' '))\n        edge[x] = y\n        rev[y] = x\n    val = list(map(int, input().split(' ')))\n    m = list(map(int, input().split(' ')))\n    for i in range(2, n + 1):\n        k = i\n        res = 0\n        if k not in edge.keys():\n            res = val[k - 1]\n            while k != 1:\n                res = gcd(res, val[rev[k] - 1])\n                k = rev[k]\n            res = gcd(res, val[0])\n            res = gcd(res, m[i - 1])\n            res = m[i - 1] - res\n            f.append(res % m[i - 1])\n        elif k not in rev.keys():\n            res = val[k - 1]\n            while k != 1:\n                res = gcd(res, val[edge[k] - 1])\n                k = edge[k]\n            res = gcd(res, val[0])\n            res = gcd(res, m[i - 1])\n            res = m[i - 1] - res\n            f.append(res % m[i - 1])\n    for i in f:\n        print(i, end=' ')\n    print('')", "import sys\nsys.setrecursionlimit(10 ** 8)\nmod = 1000000007\nget_arr = lambda : list(map(int, input().split()))\nget_int = lambda : int(input())\nget_ints = lambda : map(int, input().split())\nget_str = lambda : input()\nget_strs = lambda : input().split()\nfrom math import gcd\n\ndef fn(root, leafs, d, vis, g):\n    vis[root] = True\n    isLeaf = True\n    for i in d[root]:\n        if vis[i] == False:\n            isLeaf = False\n            if g == None:\n                fn(i, leafs, d, vis, A[root])\n            else:\n                fn(i, leafs, d, vis, gcd(g, A[root]))\n    if isLeaf:\n        leafs.append([root, gcd(g, A[root])])\nfor _ in range(get_int()):\n    n = get_int()\n    d = {}\n    for i in range(1, n + 1):\n        d[i] = []\n    for i in range(n - 1):\n        (u, v) = get_ints()\n        d[u] += [v]\n        d[v] += [u]\n    A = [None] + get_arr()\n    mods = [None] + get_arr()\n    vis = [False] * (n + 1)\n    leafs = []\n    fn(1, leafs, d, vis, None)\n    leafs = sorted(leafs)\n    for i in leafs:\n        (a, b) = (i[1], mods[i[0]])\n        x = gcd(a, b)\n        print((b // x - 1) * x, end=' ')\n    print()", "import sys\nsys.setrecursionlimit(10 ** 8)\nmod = 1000000007\nget_arr = lambda : list(map(int, input().split()))\nget_int = lambda : int(input())\nget_ints = lambda : map(int, input().split())\nget_str = lambda : input()\nget_strs = lambda : input().split()\nfrom math import gcd\n\ndef fn(root, leafs, d, vis, g):\n    vis[root] = True\n    isLeaf = True\n    for i in d[root]:\n        if vis[i] == False:\n            isLeaf = False\n            if g == None:\n                fn(i, leafs, d, vis, A[root])\n            else:\n                fn(i, leafs, d, vis, gcd(g, A[root]))\n    if isLeaf:\n        leafs.append([root, gcd(g, A[root])])\nfor _ in range(get_int()):\n    n = get_int()\n    d = {}\n    for i in range(1, n + 1):\n        d[i] = []\n    for i in range(n - 1):\n        (u, v) = get_ints()\n        d[u] += [v]\n        d[v] += [u]\n    A = [None] + get_arr()\n    mods = [None] + get_arr()\n    vis = [False] * (n + 1)\n    leafs = []\n    fn(1, leafs, d, vis, None)\n    leafs = sorted(leafs)\n    for i in leafs:\n        (a, b) = (i[1], mods[i[0]])\n        x = gcd(a, b)\n        print((b // x - 1) * x, end=' ')\n    print()", "from math import gcd\nt = int(input())\nfor it in range(t):\n    edge = {}\n    f = []\n    rev = {}\n    n = int(input())\n    val = []\n    m = []\n    for i in range(n - 1):\n        (x, y) = map(int, input().split(' '))\n        edge[x] = y\n        rev[y] = x\n    val = list(map(int, input().split(' ')))\n    m = list(map(int, input().split(' ')))\n    for i in range(2, n + 1):\n        k = i\n        res = 0\n        if k not in edge.keys():\n            res = val[k - 1]\n            while k != 1:\n                res = gcd(res, val[rev[k] - 1])\n                k = rev[k]\n            res = gcd(res, val[0])\n            res = gcd(res, m[i - 1])\n            res = m[i - 1] - res\n            f.append(res % m[i - 1])\n        elif k not in rev.keys():\n            res = val[k - 1]\n            while k != 1:\n                res = gcd(res, val[edge[k] - 1])\n                k = edge[k]\n            res = gcd(res, val[0])\n            res = gcd(res, m[i - 1])\n            res = m[i - 1] - res\n            f.append(res % m[i - 1])\n    for i in f:\n        print(i, end=' ')\n    print('')", "import sys\n\ndef gcd(a1, b1):\n    if b1 == 0:\n        return a1\n    else:\n        return gcd(b1, a1 % b1)\n\ndef dfs(b, c, a, m, s, p, x):\n    x = gcd(x, a[s])\n    if len(b[s]) == 1 and s != 0:\n        c[s] = gcd(x, m[s])\n    for i in b[s]:\n        if i != p:\n            dfs(b, c, a, m, i, s, x)\nsys.setrecursionlimit(3000000)\nt = int(input())\nfor t1 in range(t):\n    n = int(input())\n    b = {i: [] for i in range(0, n)}\n    for i in range(n - 1):\n        (u, v) = [int(j) for j in input().split()]\n        b[u - 1].append(v - 1)\n        b[v - 1].append(u - 1)\n    a = [int(j) for j in input().split()]\n    m = [int(j) for j in input().split()]\n    c = [0 for j in range(n)]\n    dfs(b, c, a, m, 0, -1, a[0])\n    for i in range(1, n):\n        if len(b[i]) == 1:\n            print(m[i] - c[i], end=' ')\n    print()", "import sys\nfrom math import gcd\nsys.setrecursionlimit(100010)\n\ndef eval_gcd(L, mod):\n    tem1 = L[0]\n    for i in L:\n        tem1 = gcd(tem1, i)\n    return mod - gcd(tem1, mod)\nfor _ in range(int(input().strip(' '))):\n    non = int(input())\n    nary = [set() for _ in range(non + 1)]\n    for _ in range(non - 1):\n        (x, y) = map(int, input().strip(' ').split(' '))\n        nary[x].add(y)\n        nary[y].add(x)\n    valit = list(map(int, input().strip(' ').split(' ')))\n    paramit = list(map(int, input().strip(' ').split(' ')))\n    leaf = []\n\n    def dfs(node, par, path=[]):\n        path.append(valit[node - 1])\n        if len(nary[node]) == 1 and par in nary[node]:\n            temp = path.copy()\n            ans = eval_gcd(temp, paramit[node - 1])\n            leaf.append([node, ans])\n        for item in nary[node]:\n            if item != par:\n                dfs(item, node)\n        path.pop()\n    dfs(1, 0)\n    leaf.sort(key=lambda w: w[0])\n    for i in leaf:\n        print(i[1], end=' ')", "import sys\nfrom math import gcd\nsys.setrecursionlimit(100010)\n\ndef find_gcd(L, mod):\n    tem = L[0]\n    for k in L:\n        tem = gcd(tem, k)\n    return mod - gcd(tem, mod)\nfor _ in range(int(input().strip(' '))):\n    n = int(input())\n    graph = [set() for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (x, y) = map(int, input().strip(' ').split(' '))\n        graph[x].add(y)\n        graph[y].add(x)\n    val = list(map(int, input().strip(' ').split(' ')))\n    param = list(map(int, input().strip(' ').split(' ')))\n    leaf = []\n\n    def getit(node, par, path=[]):\n        path.append(val[node - 1])\n        if len(graph[node]) == 1 and par in graph[node]:\n            temp = path.copy()\n            ans = find_gcd(temp, param[node - 1])\n            leaf.append([node, ans])\n        for ijk in graph[node]:\n            if ijk != par:\n                getit(ijk, node)\n        path.pop()\n    getit(1, 0)\n    leaf.sort(key=lambda w: w[0])\n    for i in leaf:\n        print(i[1], end=' ')", "class Node:\n\n    def __init__(self, idx):\n        self.idx = idx\n        self.parent = None\n        self.children = []\n        self.v = None\n        self.m = None\n        self.gcd = 0\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef get_input_line():\n    return input()\n\ndef solve2(node, value):\n    if not node:\n        return value\n    value = gcd(node.v, value)\n    if value == 1:\n        return value\n    node = node.parent\n    return solve2(node, value)\n\ndef solve3(node, value):\n    if not node:\n        return value\n    value = gcd(node.v, value)\n    if value == 1:\n        return value\n    node = node.parent\n    return solve3(node, value)\n\ndef solve(nodes):\n    values = []\n    for node in nodes:\n        if not node.children:\n            node.cd = solve2(node, node.m)\n            values.append(str(node.m - node.cd))\n    return ' '.join(values)\n\ndef dfs(edges, vs, ms, cd, values, current_index):\n    cd = gcd(vs[current_index - 1], cd)\n    cd2 = gcd(ms[current_index - 1], cd)\n    values[current_index - 1] = ms[current_index - 1] - cd2\n    for other_index in sorted(list(edges[current_index])):\n        edges[other_index].remove(current_index)\n        dfs(edges, vs, ms, cd, values, other_index)\n\ndef solve4(edges, vs, ms):\n    current_index = 1\n    values = [0] * len(vs)\n    cd = vs[0]\n    dfs(edges, vs, ms, cd, values, current_index)\n    leaves = [i + 1 for i in range(len(vs)) if len(edges[i + 1]) == 0]\n    return ' '.join([str(values[i - 1]) for i in leaves])\n\ndef main():\n    test_count = int(get_input_line())\n    for i in range(test_count):\n        nodes_count = int(get_input_line())\n        edges = {}\n        for j in range(nodes_count - 1):\n            (x, y) = list(map(int, get_input_line().split()))\n            if x not in edges:\n                edges[x] = set()\n            edges[x].add(y)\n            if y not in edges:\n                edges[y] = set()\n            edges[y].add(x)\n        vs = list(map(int, get_input_line().split()))\n        ms = list(map(int, get_input_line().split()))\n        print(solve4(edges, vs, ms))\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom math import gcd\n\ndef solve(e, v, m, k):\n    s = []\n    stack = [0]\n    while stack:\n        cur = stack[-1]\n        k[cur] = True\n        if e[cur]:\n            child = e[cur].pop()\n            if k[child]:\n                continue\n            is_leaf[cur] = False\n            v[child] = gcd(v[cur], v[child])\n            stack.append(child)\n        else:\n            cur = stack.pop()\n            if is_leaf[cur]:\n                v[cur] = gcd(v[cur], m[cur])\n                s.append((cur, m[cur] - v[cur]))\n    print(' '.join(map(lambda x: str(x[1]), sorted(s, key=lambda x: x[0]))))\nfor _ in range(int(input())):\n    N = int(input())\n    e = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (x, y) = list(map(int, input().split()))\n        e[x - 1].append(y - 1)\n        e[y - 1].append(x - 1)\n    v = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    k = [False for _ in range(N)]\n    is_leaf = [True for _ in range(N)]\n    solve(e, v, m, k)", "from math import gcd\nfor i in range(int(input())):\n    no_nodes = int(input())\n    dic = dict()\n    seta = set()\n    setb = set()\n    for i in range(no_nodes - 1):\n        (a, b) = map(int, input().split())\n        seta.add(a)\n        setb.add(b)\n        if a not in dic.keys():\n            dic[a] = [b]\n        else:\n            dic[a].append(b)\n        if b not in dic.keys():\n            dic[b] = [a]\n        else:\n            dic[b].append(a)\n    values = list(map(int, input().split()))\n    modulo = list(map(int, input().split()))\n    arr = []\n    answer = dict()\n    arr.append(1)\n    temp = values[0]\n    nodesvisited = set()\n    l1 = []\n    while arr:\n        currentnode = arr.pop()\n        if currentnode not in nodesvisited:\n            nodesvisited.add(currentnode)\n            for item in dic[currentnode]:\n                if item not in nodesvisited:\n                    values[item - 1] = gcd(values[item - 1], values[currentnode - 1])\n                    if len(dic[item]) == 1 and item != 1:\n                        l1.append((item, modulo[item - 1] - gcd(modulo[item - 1], values[item - 1])))\n                    else:\n                        arr.append(item)\n    l1.sort()\n    for item in l1:\n        print(item[1], end=' ')\n    print('')", "def traverse(i):\n    visited.add(i)\n    if len(tree[i]) == 1 and i != 0:\n        leaf[i] = m[i] - gcd(gcdstore[i], m[i])\n        return\n    for j in range(len(tree[i])):\n        if tree[i][j] not in visited:\n            gcdstore[tree[i][j]] = gcd(gcdstore[i], v[tree[i][j]])\n            traverse(tree[i][j])\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    (tree, gcdstore) = (dict(), dict())\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        (x, y) = (x - 1, y - 1)\n        if x in tree:\n            tree[x].append(y)\n        else:\n            tree[x] = [y]\n        if y in tree:\n            tree[y].append(x)\n        else:\n            tree[y] = [x]\n    (v, m) = ([int(x) for x in input().split()], [int(x) for x in input().split()])\n    leaf = [-1] * n\n    visited = set()\n    gcdstore[0] = v[0]\n    traverse(0)\n    for i in range(n):\n        if leaf[i] != -1:\n            print(leaf[i], end=' ')\n    print()", "from math import gcd\nT = int(input())\nfor i in range(T):\n    graph = {}\n    children = {}\n    N = int(input())\n    for i in range(1, N + 1):\n        graph[i] = []\n        children[i] = []\n    for i in range(N - 1):\n        (x, y) = map(int, input().split())\n        graph[x].append(y)\n        graph[y].append(x)\n    parent = {}\n\n    def findParent(node):\n        for i in graph[node]:\n            try:\n                temp = parent[i]\n            except:\n                if i != 1:\n                    parent[i] = node\n                    findParent(i)\n    findParent(1)\n    for i in range(1, N + 1):\n        for j in graph[i]:\n            if i == 1 or j != parent[i]:\n                children[i].append(j)\n    leaf = []\n    for i in range(1, N + 1):\n        if children[i] == []:\n            leaf.append(i)\n    value = {}\n    ls = list(map(int, input().split()))\n    for i in range(1, N + 1):\n        value[i] = ls[i - 1]\n    parameter = {}\n    ls = list(map(int, input().split()))\n    for i in range(1, N + 1):\n        parameter[i] = ls[i - 1]\n\n    def dfs(curnode):\n        if curnode != 1:\n            value[curnode] = gcd(value[curnode], value[parent[curnode]])\n        for node in children[curnode]:\n            dfs(node)\n    dfs(1)\n    for leafnode in leaf:\n        print((parameter[leafnode] - gcd(value[leafnode], parameter[leafnode])) % parameter[leafnode], end=' ')\n    print()", "import math\n\ndef dfs(a, b, arr1, v, vector):\n    arr1[a] = math.gcd(arr1[b], v[a])\n    for i in range(len(vector[a])):\n        if vector[a][i] == b:\n            continue\n        dfs(vector[a][i], a, arr1, v, vector)\nt = int(input())\nMAX = 100005\nfor _ in range(t):\n    n = int(input())\n    arr1 = [0] * MAX\n    vector = []\n    for i in range(MAX):\n        vector.append([])\n    for i in range(n - 1):\n        (x, y) = list(map(int, input().split()))\n        vector[x].append(y)\n        vector[y].append(x)\n    v = [0] + list(map(int, input().split()))\n    m = [0] + list(map(int, input().split()))\n    endnodes = []\n    for i in range(2, n + 1):\n        if len(vector[i]) == 1:\n            endnodes.append(i)\n    dfs(1, 0, arr1, v, vector)\n    for i in range(len(endnodes)):\n        ll = endnodes[i]\n        ans = m[ll] - math.gcd(arr1[ll], m[ll])\n        print(ans, end=' ')\n    print", "import sys\nfrom math import gcd\nsys.setrecursionlimit(100010)\n\ndef get_gcd(L, mod):\n    temp = L[0]\n    for i in L:\n        temp = gcd(temp, i)\n    return mod - gcd(temp, mod)\nfor _ in range(int(input().strip(' '))):\n    number_of_nodes = int(input())\n    tree = [set() for _ in range(number_of_nodes + 1)]\n    for _ in range(number_of_nodes - 1):\n        (x, y) = map(int, input().strip(' ').split(' '))\n        tree[x].add(y)\n        tree[y].add(x)\n    value = list(map(int, input().strip(' ').split(' ')))\n    parameter = list(map(int, input().strip(' ').split(' ')))\n    leaves = []\n\n    def dfs(node, par, path=[]):\n        path.append(value[node - 1])\n        if len(tree[node]) == 1 and par in tree[node]:\n            temp = path.copy()\n            ans = get_gcd(temp, parameter[node - 1])\n            leaves.append([node, ans])\n        for item in tree[node]:\n            if item != par:\n                dfs(item, node)\n        path.pop()\n    dfs(1, 0)\n    leaves.sort(key=lambda w: w[0])\n    for i in leaves:\n        print(i[1], end=' ')", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef dfs(node, v, val, m, visited, res, l):\n    visited[node] = True\n    flag = False\n    for i in l.graph[node]:\n        if not visited[i]:\n            flag = True\n            dfs(i, v, gcd(val, v[i]), m, visited, res, l)\n    if not flag:\n        res[node] = m[node] - gcd(val, m[node])\nfrom collections import defaultdict\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict()\n\n    def addEdge(self, u, v):\n        if u not in self.graph:\n            self.graph[u] = [v]\n        else:\n            self.graph[u].append(v)\n        if v not in self.graph:\n            self.graph[v] = [u]\n        else:\n            self.graph[v].append(u)\nt = int(input())\nfor z in range(t):\n    n = int(input())\n    res = [-1] * (n + 1)\n    l = Graph()\n    for k in range(n - 1):\n        (u, v) = map(int, input().split())\n        l.addEdge(u, v)\n    v = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    visited = [False] * (n + 1)\n    v.insert(0, 0)\n    m.insert(0, 0)\n    dfs(1, v, v[1], m, visited, res, l)\n    for i in range(1, len(res)):\n        if res[i] != -1:\n            print(res[i], end=' ')", "check = []\nfrom math import gcd\n\ndef bfs(root):\n    visit = [False for i in range(n + 1)]\n    queue = []\n    leaf = []\n    queue.append(root)\n    gcdvalue = [0 for i in range(n + 1)]\n    gcdvalue[root] = l[root - 1]\n    visit[root] = True\n    while queue:\n        x = queue.pop(0)\n        if len(g[x]) == 1 and x != 1:\n            leaf.append(x)\n        for i in g[x]:\n            if visit[i] == False:\n                queue.append(i)\n                gcdvalue[i] = gcd(gcdvalue[x], l[i - 1])\n                visit[i] = True\n    leaf.sort()\n    for i in leaf:\n        print(m[i - 1] - gcd(m[i - 1], gcdvalue[i]), end=' ')\nfor _ in range(int(input())):\n    n = int(input())\n    global g\n    g = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        g[u].append(v)\n        g[v].append(u)\n    l = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    bfs(1)", "visit = [0] * 100000\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef dfs(s, edges, gcd_val, d, m, v):\n    visit[s] = 1\n    gcd_val = gcd(gcd_val, v[s])\n    if len(edges[s]) == 1:\n        d[s] = m[s] - gcd(gcd_val, m[s])\n    for x in edges[s]:\n        if visit[x] == 0:\n            dfs(x, edges, gcd_val, d, m, v)\nT = int(input())\nfor t in range(T):\n    visit = [0] * 100000\n    n = int(input())\n    edges = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        edges[u].append(v)\n        edges[v].append(u)\n    v = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    d = {}\n    dfs(0, edges, v[0], d, m, v)\n    try:\n        del d[0]\n    except:\n        pass\n    for x in sorted(d):\n        print(d[x], end=' ')\n    print()", "import math\nimport operator\nimport sys\nsys.setrecursionlimit(200000)\n\ndef list_answer(x, a1, a2, b, c, s, m):\n    list_x = b[x]\n    c[x] = 1\n    count = 0\n    s = math.gcd(s, a1[x])\n    l = []\n    for i in range(len(list_x)):\n        if c[list_x[i]] == 1:\n            continue\n        count = 1\n        m = list_answer(list_x[i], a1, a2, b, c, s, m)\n    if count == 1:\n        return m\n    else:\n        m.append([x, s % a2[x]])\n        return m\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    b = [[] for x in range(n)]\n    c = [0] * 100000\n    for i in range(n - 1):\n        (x, y) = [int(k) for k in input().split()]\n        b[x - 1].append(y - 1)\n        b[y - 1].append(x - 1)\n    a1 = [int(x) for x in input().split()]\n    a2 = [int(x) for x in input().split()]\n    answer = list_answer(0, a1, a2, b, c, a1[0], [])\n    answer = sorted(answer, key=operator.itemgetter(0))\n    for i in range(len(answer)):\n        k = answer[i][1] % a2[answer[i][0]]\n        print(a2[answer[i][0]] - math.gcd(a2[answer[i][0]], k), end=' ')\n    print('')", "import math\nimport operator\nimport sys\nsys.setrecursionlimit(200000)\n\ndef list_answer(x, a1, a2, b, c, s, m):\n    list_x = b[x]\n    c[x] = 1\n    count = 0\n    s = math.gcd(s, a1[x])\n    l = []\n    for i in range(len(list_x)):\n        if c[list_x[i]] == 1:\n            continue\n        count = 1\n        m = list_answer(list_x[i], a1, a2, b, c, s, m)\n    if count == 1:\n        return m\n    else:\n        m.append([x, s % a2[x]])\n        return m\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    b = [[] for x in range(n)]\n    c = [0] * 100000\n    for i in range(n - 1):\n        (x, y) = [int(k) for k in input().split()]\n        b[x - 1].append(y - 1)\n        b[y - 1].append(x - 1)\n    a1 = [int(x) for x in input().split()]\n    a2 = [int(x) for x in input().split()]\n    answer = list_answer(0, a1, a2, b, c, a1[0], [])\n    answer = sorted(answer, key=operator.itemgetter(0))\n    for i in range(len(answer)):\n        k = answer[i][1] % a2[answer[i][0]]\n        if k == 0:\n            print('0', end=' ')\n        else:\n            print(a2[answer[i][0]] - math.gcd(a2[answer[i][0]], k), end=' ')\n    print('')", "t = int(input().strip())\n\ndef calcGcd(a, b):\n    return a if b == 0 else calcGcd(b, a % b)\n\ndef make_link(G, node1, node2):\n    if node1 not in childCount:\n        childCount[node1] = 0\n    childCount[node1] += 1\n    gcds[node1] = -1\n    gcds[node2] = -1\n    if node2 not in childCount:\n        childCount[node2] = 0\n    childCount[node2] += 1\n    if node1 not in G:\n        G[node1] = {}\n    G[node1][node2] = 1\n    if node2 not in G:\n        G[node2] = {}\n    G[node2][node1] = 1\n    return G\n\ndef dfs(G, node, gcdOfParent):\n    for c in G[node]:\n        if gcds[c] == -1:\n            gcds[c] = calcGcd(gcdOfParent, vs[c])\n            dfs(G, c, gcds[c])\nfor _ in range(t):\n    global childCount\n    global gcds\n    global G\n    childCount = {}\n    gcds = []\n    G = {}\n    n = int(input().strip())\n    gcds = [-1] * (n + 2)\n    for _ in range(n - 1):\n        inp = list(map(int, input().strip().split()))\n        make_link(G, inp[0] - 1, inp[1] - 1)\n    vs = list(map(int, input().strip().split()))\n    ms = list(map(int, input().strip().split()))\n    gcds[0] = vs[0]\n    dfs(G, 0, gcds[0])\n    nodes = [i for i in range(1, n) if childCount[i] == 1]\n    nodes.sort()\n    for n in nodes:\n        print(ms[n] - calcGcd(ms[n], gcds[n]), end=' ')\n    print()", "def find_hcf(a, o):\n    while o:\n        (a, o) = (o, a % o)\n    return a\nt = int(input())\nwhile t > 0:\n    ans = []\n    n = int(input())\n    child = []\n    parent = []\n    for i in range(n + 1):\n        child.append(0)\n        parent.append(0)\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        if x < y:\n            child[x] = y\n            parent[y] = x\n        else:\n            child[y] = x\n            parent[x] = y\n    v = tuple(map(int, input().split()))\n    m = tuple(map(int, input().split()))\n    leaf = 0\n    leaf_nodes = []\n    for i in range(n, 0, -1):\n        if child[i] == 0:\n            leaf += 1\n            leaf_nodes.append(i)\n    for index in leaf_nodes:\n        j = index\n        p = 0\n        hcf = find_hcf(v[0], m[index - 1])\n        while parent[j] != 0:\n            hcf = find_hcf(hcf, v[j - 1])\n            p += 1\n            j = parent[j]\n        ans.append(m[index - 1] - hcf)\n    for q in range(leaf - 1, -1, -1):\n        print(ans[q], end=' ')\n    t -= 1", "from collections import defaultdict\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\nclass tree:\n\n    def __init__(self, nodes):\n        self.nodes = nodes\n        self.graph = defaultdict(list)\n        self.value = list()\n        self.mod = list()\n\n    def add(self, a, b):\n        self.graph[a].append(b)\n        self.graph[b].append(a)\n\n    def value(self, n):\n        return self.value[n - 1]\n\n    def mvalue(self, n):\n        return self.mod[n - 1]\n\n    def start(self):\n        answer = defaultdict()\n        root = 1\n        visited = [False for i in range(self.nodes)]\n        val = self.value[0]\n        visited[0] = True\n        for keys in self.graph[1]:\n            if visited[keys - 1] == False:\n                self.dfs(keys, answer, val, visited)\n        return answer\n\n    def dfs(self, root, answer, val, visited):\n        visited[root - 1] = True\n        if len(self.graph[root]) == 1:\n            m = self.mod[root - 1]\n            v = self.value[root - 1]\n            g = gcd(val, v)\n            g1 = gcd(g, m)\n            answer[root] = m - g1\n        else:\n            xx = gcd(val, self.value[root - 1])\n            for i in self.graph[root]:\n                if visited[i - 1] == False:\n                    self.dfs(i, answer, xx, visited)\nfor _ in range(int(input())):\n    n = int(input())\n    g = tree(n)\n    for kk in range(n - 1):\n        (a, b) = map(int, input().split())\n        g.add(a, b)\n    g.value = [int(i) for i in input().split()]\n    g.mod = [int(i) for i in input().split()]\n    ans = g.start()\n    for i in range(1, n + 1):\n        if i in ans:\n            print(ans[i], end=' ')\n    print()", "from collections import defaultdict\nfrom math import gcd\nT = int(input())\nfor t in range(T):\n    N = int(input().strip())\n    tree = [[] for i in range(N)]\n    for i in range(N - 1):\n        (x, y) = [int(k) - 1 for k in input().strip().split()]\n        tree[x].append(y)\n        tree[y].append(x)\n    v = [int(k) for k in input().strip().split()]\n    m = [int(k) for k in input().strip().split()]\n    queue = [(0, None, v[0])]\n    answ = []\n    while len(queue) > 0:\n        (node, parent, curr_gcd) = queue.pop()\n        if len(tree[node]) == 1 and node != 0:\n            answ.append((node, gcd(curr_gcd, m[node])))\n        else:\n            for child in tree[node]:\n                if child != parent:\n                    queue.append((child, node, gcd(curr_gcd, v[child])))\n    answ.sort()\n    print(' '.join((str(m[a[0]] - a[1]) for a in answ)))", "from collections import defaultdict, deque\nfrom math import gcd\nfor t in range(int(input())):\n    (n, edges) = (int(input()), defaultdict(list))\n    for _ in range(1, n):\n        (x, y) = (int(i) - 1 for i in input().split())\n        edges[x].append(y)\n        edges[y].append(x)\n    v = [int(i) for i in input().split()]\n    m = [int(i) for i in input().split()]\n    (queue, count) = (deque([0]), defaultdict(int, {0: 1}))\n    while queue:\n        i = queue.popleft()\n        for j in edges[i]:\n            count[j] += 1\n            if count[j] > 1:\n                continue\n            v[j] = gcd(v[i], v[j])\n            queue.append(j)\n    print(*(m[i] - gcd(v[i], m[i]) for i in range(n) if count[i] == 1))", "from collections import defaultdict\nfrom sys import stdin, stdout\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\ndef iterate(g, node, hcf=0, parent=-1):\n    hcf = gcd(hcf, va[node])\n    if len(g.graph[node]) != 1 or node == 0:\n        res[node] = -1\n    else:\n        res[node] = m[node] - gcd(hcf, m[node])\n    for i in g.graph[node]:\n        if i != parent:\n            iterate(g, i, hcf, node)\nt = int(stdin.readline())\nwhile t:\n    n = int(stdin.readline())\n    g = Graph()\n    for _ in range(n - 1):\n        (u, v) = map(int, stdin.readline().split())\n        u = u - 1\n        v = v - 1\n        g.addEdge(u, v)\n    res = [-1 for _ in range(n)]\n    va = list(map(int, stdin.readline().split()))\n    m = list(map(int, stdin.readline().split()))\n    iterate(g, 0)\n    ans = ''\n    for i in res:\n        if i != -1:\n            ans += str(i) + ' '\n    print(ans)\n    t = t - 1", "from math import gcd\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    adj = [[] for x in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().strip().split())\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    v = list(map(int, input().strip().split()))\n    m = list(map(int, input().strip().split()))\n    factors = [0] * n\n    leaves = []\n    parent = [-1] * n\n    queue = [0]\n    for i in queue:\n        children = set(adj[i]) - set([parent[i]])\n        if parent[i] == -1:\n            factors[i] = v[i]\n        else:\n            factors[i] = gcd(factors[parent[i]], v[i])\n        if len(children) <= 0:\n            leaves.append(i)\n        for q in children:\n            parent[q] = i\n            queue.append(q)\n    leaves.sort()\n    re = [m[i] - gcd(m[i], factors[i]) for i in leaves]\n    print(*re)", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef solve(l, ms, vs, leafs, u, ant, gcdAcum):\n    if len(l[u]) == 1 and l[u][0] == ant:\n        leafs[u] = ms[u] - gcd(gcdAcum, ms[u])\n        return\n    for e in l[u]:\n        if e != ant:\n            solve(l, ms, vs, leafs, e, u, gcd(gcdAcum, vs[e]))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = [[] for i in range(n)]\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        x -= 1\n        y -= 1\n        l[x].append(y)\n        l[y].append(x)\n    vs = [int(e) for e in input().split()]\n    ms = [int(e) for e in input().split()]\n    leafs = dict()\n    solve(l, ms, vs, leafs, 0, -1, vs[0])\n    for i in sorted(leafs):\n        print(leafs[i], end=' ')", "GI = lambda : int(input())\nGIS = lambda : map(int, input().split())\nLGIS = lambda : list(GIS())\nfrom fractions import gcd\nimport sys\nsys.setrecursionlimit(10 ** 5)\n\ndef main():\n    for t in range(GI()):\n        N = GI()\n        edges = {}\n        for _ in range(N - 1):\n            (x, y) = GIS()\n            for (a, b) in ((x, y), (y, x)):\n                edges.setdefault(a, []).append(b)\n        vs = LGIS()\n        ms = LGIS()\n        print(' '.join(map(str, solve(N, edges, vs, ms))))\n\ndef solve(N, edges, vs, ms):\n    ret = []\n    visited = [0] * N\n\n    def recurse(i, rgcd):\n        visited[i] = 1\n        rgcd = gcd(rgcd, vs[i])\n        gone_visiting = False\n        for ii in edges[i + 1]:\n            if not visited[ii - 1]:\n                gone_visiting = True\n                recurse(ii - 1, rgcd)\n        if not gone_visiting:\n            ret.append((i, ms[i] - gcd(ms[i], rgcd)))\n    recurse(0, vs[0])\n    return [mm for (_, mm) in sorted(ret)]\nmain()", "from collections import defaultdict\nimport math\ngcd_map = dict()\n\ndef get_gcd(a, b):\n    if a in gcd_map:\n        if b in gcd_map[a]:\n            return gcd_map[a][b]\n    curr_gcd = int(math.gcd(a, b))\n    if a in gcd_map:\n        gcd_map[a][b] = curr_gcd\n    else:\n        gcd_map[a] = dict()\n        gcd_map[a][b] = curr_gcd\n    if b in gcd_map:\n        gcd_map[b][a] = curr_gcd\n    else:\n        gcd_map[b] = dict()\n        gcd_map[b][a] = curr_gcd\n    return curr_gcd\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(lambda : list())\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def DFS(self, vs):\n        m = len(self.graph)\n        leaves = dict()\n        root_to_node_path_gcd = [0 for _ in range(m)]\n        root_to_node_path_gcd[0] = vs[0]\n        stack = list()\n        visited = [False for _ in range(m)]\n        visited[0] = True\n        stack.append(0)\n        while len(stack):\n            top_vertex = stack[-1]\n            neighbor = None\n            for i in self.graph[top_vertex]:\n                if not visited[i]:\n                    neighbor = i\n                    break\n            if neighbor is not None:\n                visited[neighbor] = True\n                stack.append(neighbor)\n                root_to_node_path_gcd[neighbor] = math.gcd(root_to_node_path_gcd[top_vertex], vs[neighbor])\n            else:\n                if len(self.graph[top_vertex]) == 1 and top_vertex != 0:\n                    leaves[top_vertex] = True\n                stack.pop()\n        return (leaves, root_to_node_path_gcd)\nfor _ in range(int(input())):\n    n = int(input())\n    g = Graph()\n    for _ in range(n - 1):\n        (ui, vi) = list(map(int, input().split()))\n        g.add_edge(ui - 1, vi - 1)\n    vs = list(map(int, input().split()))\n    ms = list(map(int, input().split()))\n    (leaves, root_to_node_path_gcd) = g.DFS(vs)\n    for (idx, curr_gcd) in enumerate(root_to_node_path_gcd):\n        if idx in leaves:\n            print(ms[idx] - math.gcd(ms[idx], curr_gcd), end=' ')", "import sys\nsys.setrecursionlimit(100001)\nglobal val, mi, res\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef dfs(n, p, x):\n    s = gcd(val[n], x)\n    leaf = True\n    for i in adj[n]:\n        if i != p:\n            leaf = False\n            dfs(i, n, s)\n    if leaf:\n        s = gcd(s, mi[n])\n        if s == 1:\n            res.add((n, mi[n] - 1))\n        else:\n            s = (mi[n] - 1) // s * s\n            res.add((n, s))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (a, b) = [int(x) for x in input().split()]\n        (a, b) = (a - 1, b - 1)\n        adj[a].append(b)\n        adj[b].append(a)\n    val = [int(x) for x in input().split()]\n    mi = [int(x) for x in input().split()]\n    res = set()\n    dfs(0, 0, val[0])\n    for i in sorted(res):\n        print(i[1], end=' ')\n    print('')", "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef solve(u):\n    if visited[u] == 1:\n        return\n    visited[u] = 1\n    if len(V[u]) == 1:\n        if u != 1:\n            l2.append(u)\n    values2[u] = gcd(values2[u], values2[pa[u]])\n    for i in range(len(V[u])):\n        if visited[V[u][i]] != 1:\n            pa[V[u][i]] = u\n            solve(V[u][i])\nfor _ in range(int(input())):\n    n = int(input())\n    V = []\n    for p in range(n + 1):\n        V.append([])\n    for _ in range(n - 1):\n        (a, b) = list(map(int, input().split()))\n        V[a].append(b)\n        V[b].append(a)\n    values = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    values = [0] + values\n    m = [0] + m\n    visited = [0] * (n + 1)\n    pa = [0] * (n + 1)\n    l2 = []\n    pa[1] = 1\n    values2 = values[:]\n    solve(1)\n    l2.sort()\n    for j in l2:\n        mo = m[j]\n        z = gcd(mo, values2[j])\n        print(mo - z, end=' ')\n    print()", "def dfs(u):\n    if visited[u] == 1:\n        return\n    visited[u] = 1\n    if len(V[u]) == 1 and u != 1:\n        leaf.append(u)\n    for i in range(len(V[u])):\n        if visited[V[u][i]] != 1:\n            parent[V[u][i]] = u\n            dfs(V[u][i])\n\ndef dfs2(u):\n    if visited[u] == 1:\n        return\n    visited[u] = 1\n    v2[u] = gcd(v2[u], v2[parent[u]])\n    if len(V[u]) == 1 and u != 1:\n        leaf.append(u)\n    for i in range(len(V[u])):\n        if visited[V[u][i]] != 1:\n            parent[V[u][i]] = u\n            dfs2(V[u][i])\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\nfor _ in range(int(input())):\n    n = int(input())\n    V = [[] for j in range(n + 1)]\n    for _ in range(n - 1):\n        (x, y) = list(map(int, input().split()))\n        V[x].append(y)\n        V[y].append(x)\n    v = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    v = [0] + v\n    v2 = v[:]\n    m = [0] + m\n    visited = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    leaf = []\n    parent[1] = 1\n    dfs2(1)\n    leaf.sort()\n    for j in leaf:\n        mo = m[j]\n        print(mo - gcd(mo, v2[j]), end=' ')\n    print()", "import sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(100000)\n\ndef doIt(node, g, ans, p=-1):\n    if node != 0 and len(adj[node]) == 1:\n        ans[node] = m[node] - math.gcd(g, m[node])\n        return ans\n    for neigh in adj[node]:\n        if neigh != p:\n            ans = doIt(neigh, math.gcd(g, v[neigh]), ans, node)\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    v = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    ans = defaultdict(lambda : -1)\n    ans = doIt(0, v[0], ans)\n    for i in range(n):\n        if ans[i] != -1:\n            print(ans[i], end=' ')", "import collections\nfrom collections import defaultdict\nimport math\n\nclass Graph:\n\n    def __init__(self, n):\n        self.graph = defaultdict(list)\n        self.n = n\n\n    def addEdge(self, a, b):\n        self.graph[a].append(b)\n        self.graph[b].append(a)\n\n    def calculate(self, v, val, m):\n        Stack = collections.deque([])\n        Stack.append(v)\n        visited = [False] * n\n        visited[v] = True\n        score = [-1] * n\n        score[v] = val[v]\n        ls = []\n        gs = []\n        temp = -1\n        while len(Stack) > 0:\n            flag = 0\n            if len(self.graph[Stack[-1]]) == 1 and Stack[-1] != 0:\n                X = Stack.pop()\n                temp = math.gcd(score[X], m[X])\n                ls.append(X)\n                gs.append(m[X] - temp)\n            else:\n                Par = Stack[-1]\n            for i in self.graph[Par]:\n                if visited[i] == False:\n                    flag = 1\n                    last = Stack[-1]\n                    Stack.append(i)\n                    visited[i] = True\n                    score[i] = math.gcd(score[last], val[i])\n                    break\n            if flag == 0:\n                X = Stack.pop()\n        return (ls, gs)\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    g = Graph(n)\n    for i in range(1, n):\n        (u, v) = [int(x) for x in input().split()]\n        g.addEdge(u - 1, v - 1)\n    val = [int(x) for x in input().split()]\n    m = [int(x) for x in input().split()]\n    (a, b) = g.calculate(0, val, m)\n    (list1, list2) = zip(*sorted(zip(a, b)))\n    for i in list2:\n        print(i, end=' ')\n    print()", "from math import gcd\nfor _ in range(int(input())):\n    n = int(input())\n    b = [[] for i in range(n)]\n    vis = [0] * n\n    for i in range(n - 1):\n        (c, d) = map(int, input().split())\n        b[c - 1].append(d - 1)\n        b[d - 1].append(c - 1)\n    st = [0]\n    v = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    while st:\n        x = st.pop()\n        vis[x] = 1\n        for i in b[x]:\n            if vis[i] == 0:\n                st.append(i)\n                v[i] = gcd(v[i], v[x])\n    le = []\n    for i in range(1, n):\n        if len(b[i]) == 1:\n            le.append(i)\n    a = []\n    for i in le:\n        a.append(m[i] - gcd(m[i], v[i]))\n    print(*a)", "from math import gcd\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        x -= 1\n        y -= 1\n        g[x].append(y)\n        g[y].append(x)\n    a = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    ans = [a[i] for i in range(n)]\n    vis = [0] * n\n    vis[0] = 1\n    st = []\n    st.append(0)\n    tmp = []\n    while len(st):\n        x = st[-1]\n        st.pop()\n        for i in g[x]:\n            if not vis[i]:\n                if len(g[i]) == 1:\n                    tmp.append(i)\n                vis[i] = 1\n                ans[i] = gcd(ans[x], a[i])\n                st.append(i)\n    tmp.sort()\n    for i in tmp:\n        print(m[i] - gcd(m[i], ans[i]), end=' ')\n    print()", "import math\ncases = int(input())\nwhile cases > 0:\n    n = int(input())\n    visited = [False] * n\n    graph = [[] for x in range(n)]\n    for i in range(n - 1):\n        (x, y) = input().split()\n        x = int(x) - 1\n        y = int(y) - 1\n        graph[x].append(y)\n        graph[y].append(x)\n    v = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    gcds = [0] * n\n    gcds[0] = v[0]\n    visited[0] = True\n    queue = [0]\n    leaves = []\n    while len(queue) != 0:\n        x = queue.pop()\n        for y in graph[x]:\n            if not visited[y]:\n                visited[y] = True\n                gcds[y] = math.gcd(gcds[x], v[y])\n                queue.append(y)\n        if x != 0 and len(graph[x]) == 1:\n            leaves.append(x)\n    leaves.sort()\n    for i in leaves:\n        p = gcds[i]\n        q = m[i]\n        print(str(q - math.gcd(p, q)), end=' ')\n    print('', end='\\n')\n    cases -= 1", "import sys\nsys.setrecursionlimit(100010)\nT = int(input())\n\ndef compute_gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return compute_gcd(b, a % b)\n\ndef compute_the_max_remainders_for_all_the_leaves_of_the_tree(tree, V, M, is_node_visited, max_remainders_list, curr_node, curr_gcd):\n    is_node_visited[curr_node] = True\n    curr_gcd = compute_gcd(curr_gcd, V[curr_node])\n    if curr_node != 0 and len(tree[curr_node]) == 1:\n        curr_gcd = compute_gcd(curr_gcd, M[curr_node])\n        max_remainder = M[curr_node] - curr_gcd\n        max_remainders_list.append((curr_node, max_remainder))\n    else:\n        for child in tree[curr_node]:\n            if is_node_visited[child] == False:\n                compute_the_max_remainders_for_all_the_leaves_of_the_tree(tree, V, M, is_node_visited, max_remainders_list, child, curr_gcd)\nwhile T:\n    N = int(input())\n    tree = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (u, v) = list(map(int, input().split()))\n        tree[u - 1].append(v - 1)\n        tree[v - 1].append(u - 1)\n    V = list(map(int, input().split()))\n    M = list(map(int, input().split()))\n    is_node_visited = [False for _ in range(N)]\n    max_remainders_list = []\n    compute_the_max_remainders_for_all_the_leaves_of_the_tree(tree, V, M, is_node_visited, max_remainders_list, 0, V[0])\n    max_remainders_list.sort()\n    for i in range(len(max_remainders_list)):\n        print(max_remainders_list[i][1], end=' ')\n    print()\n    T -= 1", "import math\nfor i in range(int(input())):\n    n = int(input())\n    d1 = {}\n    d2 = {}\n    for i in range(0, n - 1):\n        (x, y) = map(int, input().split())\n        if x not in d1:\n            d1[x] = [y]\n        else:\n            d1[x].append(y)\n        if y not in d1:\n            d1[y] = [x]\n        else:\n            d1[y].append(x)\n    l1 = list(map(int, input().split()))\n    l2 = list(map(int, input().split()))\n    ans = []\n    l3 = [0] * n\n    visited = {}\n    queue = [1]\n    while len(visited) != n:\n        s = queue.pop()\n        if s not in visited:\n            visited[s] = 1\n            for item in d1[s]:\n                if item not in visited:\n                    l1[item - 1] = math.gcd(l1[item - 1], l1[s - 1])\n                    queue.append(item)\n    for i in range(2, n + 1):\n        if len(d1[i]) == 1:\n            f = l2[i - 1] - math.gcd(l1[i - 1], l2[i - 1])\n            print(f, end=' ')\n    print('')", "def gcdf(a, b):\n    if b == 0:\n        return a\n    return gcdf(b, a % b)\n\ndef dfs(node, par, curgcd):\n    if len(g[node]) == 1 and g[node][0] == par:\n        gcd = gcdf(A[node], curgcd)\n        ans[node] = m[node] - gcdf(gcd, m[node])\n    else:\n        gcd = gcdf(curgcd, A[node])\n        for i in g[node]:\n            if i == par:\n                continue\n            dfs(i, node, gcdf(gcd, A[i]))\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = [int(i) for i in input().split()]\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    A = [int(i) for i in input().split()]\n    m = [int(i) for i in input().split()]\n    gcd = A[0]\n    ans = [-1 for i in range(n)]\n    dfs(0, -1, A[0])\n    fin = []\n    for i in ans:\n        if i != -1:\n            fin.append(i)\n    print(*fin)", "from collections import deque\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\nfor _ in range(int(input())):\n    n = int(input())\n    a = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        a[x].append(y)\n        a[y].append(x)\n    v = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    vis = [0] * (n + 1)\n    q = deque([1])\n    val = [v[0]] * (n + 1)\n    e = [[] for _ in range(n + 1)]\n    vis[1] = 1\n    while q:\n        p = q.popleft()\n        for i in a[p]:\n            if vis[i] == 0:\n                e[p].append(i)\n                vis[i] = 1\n                q.append(i)\n                val[i - 1] = gcd(v[i - 1], val[p - 1])\n    for i in range(1, n + 1):\n        if len(e[i]) == 0:\n            print(m[i - 1] - gcd(val[i - 1], m[i - 1]), end=' ')", "import sys\nsys.setrecursionlimit(100000)\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef dfs(no, visit, d, values, module, ans, an):\n    visit[no] = 1\n    f = 0\n    for i in d[no]:\n        if visit[i] == 0:\n            f = 1\n            dfs(i, visit, d, values, module, ans, gcd(an, values[i - 1]))\n    if f == 0:\n        ans.append([no, module[no - 1] - gcd(an, module[no - 1])])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = dict()\n    ans = []\n    visit = [0] * (n + 1)\n    for i in range(1, n + 1):\n        d[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    values = list(map(int, input().split()))\n    module = list(map(int, input().split()))\n    dfs(1, visit, d, values, module, ans, values[0])\n    ans.sort()\n    for i in range(len(ans)):\n        print(ans[i][1], end=' ')\n    print()", "import math\ncases = int(input())\nwhile cases > 0:\n    n = int(input())\n    visited = [False] * n\n    graph = [[] for x in range(n)]\n    for i in range(n - 1):\n        (x, y) = input().split()\n        x = int(x) - 1\n        y = int(y) - 1\n        graph[x].append(y)\n        graph[y].append(x)\n    v = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    gcds = [0] * n\n    gcds[0] = v[0]\n    visited[0] = True\n    queue = [0]\n    leaves = []\n    while len(queue) != 0:\n        x = queue.pop()\n        for y in graph[x]:\n            if not visited[y]:\n                visited[y] = True\n                gcds[y] = math.gcd(gcds[x], v[y])\n                queue.append(y)\n        if x != 0 and len(graph[x]) == 1:\n            leaves.append(x)\n    leaves.sort()\n    for i in leaves:\n        p = gcds[i]\n        q = m[i]\n        print(str(q - math.gcd(p, q)), end=' ')\n    print('', end='\\n')\n    cases -= 1", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    dic = {'1': 1}\n    graph = [[] for i in range(n + 1)]\n    myMom = [0 for x in range(n + 1)]\n    score = []\n    mykey = 0\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    value = list(map(int, input().split()))\n    value.insert(0, 0)\n    mod = list(map(int, input().split()))\n    mod.insert(0, 0)\n\n    def run(nodeNum):\n        c = 0\n        for v in graph[nodeNum]:\n            if str(v) not in dic.keys():\n                c += 1\n                myMom[v] = nodeNum\n                dic[str(v)] = 1\n                run(v)\n        if c == 0:\n            gcd = math.gcd(mod[nodeNum], value[nodeNum])\n            backward = myMom[nodeNum]\n            while backward != 0 and gcd != 1:\n                gcd = math.gcd(value[backward], gcd)\n                backward = myMom[backward]\n            score.append([nodeNum, mod[nodeNum] - gcd])\n    run(1)\n    score.sort()\n    for (_, l_ans) in score:\n        print(l_ans, end=' ')\n    print()", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    dic = {'1': 1}\n    graph = [[] for i in range(n + 1)]\n    myMom = [0 for x in range(n + 1)]\n    score = []\n    mykey = 0\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    value = list(map(int, input().split()))\n    value.insert(0, 0)\n    mod = list(map(int, input().split()))\n    mod.insert(0, 0)\n\n    def run(nodeNum):\n        c = 0\n        for v in graph[nodeNum]:\n            if str(v) not in dic.keys():\n                c += 1\n                myMom[v] = nodeNum\n                dic[str(v)] = 1\n                run(v)\n        if c == 0:\n            gcd = math.gcd(mod[nodeNum], value[nodeNum])\n            backward = myMom[nodeNum]\n            while backward != 0 and gcd != 1:\n                gcd = math.gcd(value[backward], gcd)\n                backward = myMom[backward]\n            score.append([nodeNum, mod[nodeNum] - gcd])\n    run(1)\n    score.sort()\n    for (_, l_ans) in score:\n        print(l_ans, end=' ')\n    print()", "from math import gcd\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    tree = {}\n    for i in range(1, n):\n        (x, y) = list(map(int, input().strip().split()))\n        x -= 1\n        y -= 1\n        tree[x] = tree.get(x, []) + [y]\n        tree[y] = tree.get(y, []) + [x]\n    v = list(map(int, input().strip().split()))\n    m = list(map(int, input().strip().split()))\n    visited = {}\n    ans = []\n\n    def solve(curr, g):\n        visited[curr] = True\n        if len(tree[curr]) == 1 and curr != 0:\n            ans.append((curr, m[curr] - gcd(g, m[curr])))\n            return\n        for node in tree[curr]:\n            if node not in visited:\n                solve(node, gcd(v[node], g))\n    solve(0, v[0])\n    for x in sorted(ans):\n        print(x[1], end=' ')", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    return gcd(b, a % b)\n\ndef read_line(mentioned_type=int):\n    return tuple(map(mentioned_type, input().split()))\n\ndef dfs(node, values, m, graph, visited, ans, val=None):\n    visited.add(node)\n    if val:\n        val = gcd(val, values[node - 1])\n    else:\n        val = values[node - 1]\n    is_leaf = True\n    for each in graph[node]:\n        if each not in visited:\n            is_leaf = False\n            dfs(each, values, m, graph, visited, ans, val)\n    if is_leaf:\n        ans[node] = m[node - 1] - gcd(val, m[node - 1])\nt = int(input())\nwhile t:\n    n = int(input())\n    graph = defaultdict(set)\n    for i in range(n - 1):\n        (u, v) = read_line()\n        graph[u].add(v)\n        graph[v].add(u)\n    values = read_line()\n    m = read_line()\n    ans = {}\n    dfs(1, values, m, graph, set(), ans)\n    print(' '.join(map(lambda x: str(x[1]), sorted(ans.items()))))\n    t -= 1", "from math import gcd\n\ndef listgcd(List):\n    min(List)\nfor _ in range(int(input())):\n    N = int(input())\n    ans = []\n    Tree = {}\n    Tree[1] = None\n    Tree_path = {1: [1]}\n    for _ in range(N - 1):\n        (x, y) = map(int, input().split())\n        if x in Tree:\n            Tree[y] = x\n            Tree_path[y] = Tree_path[x] + [y]\n        else:\n            Tree[x] = y\n            Tree_path[x] = Tree_path[y] + [x]\n    Leaf = sorted(set(Tree.keys()) - set(Tree.values()))\n    values = dict(((i + 1, j) for (i, j) in enumerate(map(int, input().split()))))\n    module = dict(((i + 1, j) for (i, j) in enumerate(map(int, input().split()))))\n    for i in Leaf:\n        mod = module[i]\n        t = mod\n        for j in Tree_path[i]:\n            t = gcd(t, values[j])\n            if t == 1:\n                ans.append(mod - 1)\n                break\n        else:\n            ans.append(mod - t)\n    print(*ans, sep=' ')", "from collections import defaultdict\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n        self.parents = None\n        self.leafs = None\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def bfs(self, s, vals, gcds):\n        visited = [False] * len(self.graph)\n        self.leafs = []\n        self.parents = [None] * len(self.graph)\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        gcds[0] = vals[0]\n        while queue:\n            s = queue.pop(0)\n            leaf = True\n            for i in self.graph[s]:\n                if visited[i] == False:\n                    gcds[i] = gcd(gcds[s], vals[i])\n                    self.parents[i] = s\n                    leaf = False\n                    queue.append(i)\n                    visited[i] = True\n            if leaf:\n                self.leafs.append(s)\nt = int(input())\nfor _t in range(t):\n    n = int(input())\n    g = Graph()\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g.add_edge(u - 1, v - 1)\n    values = list(map(int, input().split()))\n    param = list(map(int, input().split()))\n    gcds = [None] * n\n    g.bfs(0, values, gcds)\n    g.leafs.sort()\n    for l in g.leafs:\n        print(param[l] - gcd(gcds[l], param[l]), end=' ')", "from math import gcd\nimport bisect\nimport itertools\nimport sys\nfrom collections import deque\nI = lambda : sys.stdin.readline()\nmod = 10 ** 9 + 7\n\ndef modu(a, m):\n    if a % m:\n        return a % m\n    return m\n\ndef mindiff(a):\n    b = a[:]\n    b.sort()\n    m = 10000000000\n    for i in range(len(b) - 1):\n        if b[i + 1] - b[i] < m:\n            m = b[i + 1] - b[i]\n    return m\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef merge(a, b):\n    i = 0\n    j = 0\n    c = 0\n    ans = []\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            ans.append(a[i])\n            i += 1\n        else:\n            ans.append(b[j])\n            c += len(a) - i\n            j += 1\n    ans += a[i:]\n    ans += b[j:]\n    return (ans, c)\n\ndef mergesort(a):\n    if len(a) == 1:\n        return (a, 0)\n    mid = len(a) // 2\n    (left, left_inversion) = mergesort(a[:mid])\n    (right, right_inversion) = mergesort(a[mid:])\n    (m, c) = merge(left, right)\n    c += left_inversion + right_inversion\n    return (m, c)\n\ndef is_prime(num):\n    if num == 1:\n        return False\n    if num == 2:\n        return True\n    if num == 3:\n        return True\n    if num % 2 == 0:\n        return False\n    if num % 3 == 0:\n        return False\n    t = 5\n    a = 2\n    while t <= int(math.sqrt(num)):\n        if num % t == 0:\n            return False\n        t += a\n        a = 6 - a\n    return True\n\ndef ceil(a, b):\n    if a % b == 0:\n        return a // b\n    else:\n        return a // b + 1\n\ndef ncr1(n, r):\n    s = 1\n    for i in range(min(n - r, r)):\n        s *= n - i\n        s %= mod\n        s *= pow(i + 1, mod - 2, mod)\n        s %= mod\n    return s\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef check(a, b, c):\n    for i in range(0, c - 1):\n        if a * i % b == c:\n            return i\n    return 0\nfor _ in range(int(input())):\n    n = int(input())\n    a = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        a[x].append(y)\n        a[y].append(x)\n    q = deque([1])\n    v = [0] + list(map(int, input().split()))\n    m = [0] + list(map(int, input().split()))\n    e = [[] for i in range(n + 1)]\n    p = [1] * (n + 1)\n    val = v[:]\n    vis = [0] * (n + 1)\n    vis[1] = 1\n    while q:\n        k = q.popleft()\n        for i in a[k]:\n            if vis[i] == 0:\n                e[k].append(i)\n                vis[i] = 1\n                val[i] = gcd(val[k], v[i])\n                q.append(i)\n                p[i] = k\n    for i in range(1, n + 1):\n        if len(e[i]) == 0:\n            print(m[i] - gcd(m[i], val[i]), end=' ')\n    print()", "def gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef maketree(graph, root, V):\n    (leaves, gcdnode) = ([], {})\n    visited = set([])\n    heap = [(root, V[root])]\n    while heap:\n        (u, value) = heap.pop(0)\n        visited.add(u)\n        gcdnode[u] = gcd(V[u], value)\n        leave = True\n        for v in graph[u]:\n            if v not in visited:\n                leave = False\n                heap.append((v, gcdnode[u]))\n        if leave:\n            leaves.append(u)\n    return (sorted(leaves), gcdnode)\n\ndef solve(N, V, M, graph):\n    (leaves, gcdnode) = maketree(graph, 1, V)\n    solution = [M[leave] - gcd(gcdnode[leave], M[leave]) for leave in leaves]\n    return solution\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    N = int(input().strip())\n    graph = {}\n    for u in range(1, N + 1):\n        graph[u] = []\n    for i in range(N - 1):\n        (u, v) = list(map(int, input().strip().split()))\n        graph[u].append(v)\n        graph[v].append(u)\n    V = [0] + list(map(int, input().strip().split()))\n    M = [0] + list(map(int, input().strip().split()))\n    print(' '.join(map(str, solve(N, V, M, graph))))", "t = int(input())\nimport math\n\ndef dfs(i, tree, p, gout, arr):\n    gins = math.gcd(gout, v[i - 1])\n    if len(tree[i]) == 1 and tree[i][0] == p:\n        arr.append([i, m[i - 1] - math.gcd(gins, m[i - 1])])\n    else:\n        for k in tree[i]:\n            if k != p:\n                dfs(k, tree, i, gins, arr)\nfor _ in range(t):\n    n = int(input())\n    tree = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    v = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    arr = []\n    dfs(1, tree, -1, v[0], arr)\n    a = ''\n    arr.sort()\n    for i in arr:\n        a += str(i[1]) + ' '\n    print(a[:-1])", "from collections import defaultdict\nfrom math import gcd\nfrom sys import stdin, setrecursionlimit\nsetrecursionlimit = 10 ** 6\n\ndef calc(p, x, m):\n    Sum = sum(p)\n    d = gcd(x, m)\n    if Sum == 0 or m == 0:\n        return 0\n    r = Sum % d\n    for y in p:\n        if not y % d:\n            continue\n        r = max(r, y % d)\n        r = max(r, (Sum - y) % d)\n        r = max(r, calc(p - {y}, y, d) % d)\n    return r\n\ndef dfs(tree, parent, node, par):\n    stack = []\n    visited = [0] * (len(tree) + 1)\n    stack.append((node, par))\n    while stack:\n        (node, par) = stack.pop()\n        if visited[node]:\n            continue\n        visited[node] = 1\n        parent[node] = par\n        for v in tree[node]:\n            if v != par:\n                stack.append((v, node))\n\ndef dfs_recc(tree, parent, node, par):\n    parent[node] = par\n    for v in tree[node]:\n        if v != par:\n            dfs_recc(tree, parent, v, node)\n\ndef get_path(parent, V, node, mod):\n    path = set()\n    for x in (0, node):\n        if V[x] % mod:\n            path.add(V[x] % mod)\n    while node != 0:\n        if V[node] % mod:\n            path.add(V[node] % mod)\n        node = parent[node]\n    return path\n\ndef solve():\n    for _ in range(int(stdin.readline())):\n        N = int(stdin.readline())\n        tree = defaultdict(list)\n        parent = [-1] * N\n        for _ in range(N - 1):\n            (u, v) = map(int, stdin.readline().split())\n            tree[u - 1].append(v - 1)\n            tree[v - 1].append(u - 1)\n        dfs_recc(tree, parent, 0, -1)\n        V = [int(k) for k in stdin.readline().split()]\n        M = [int(k) for k in stdin.readline().split()]\n        result = []\n        for node in range(1, N):\n            if len(tree[node]) < 2:\n                mod = M[node]\n                path = get_path(parent, V, node, mod)\n                ans = 0\n                d = mod\n                for x in path:\n                    d = gcd(d, x)\n                ans = max(ans, mod - d)\n                result.append(ans)\n        print(' '.join((str(k) for k in result)))\nsolve()", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef simplify(G, i):\n    q = []\n    leaves = []\n    par = {1: 0}\n    q.append(i)\n    while len(q) > 0:\n        c = q[0]\n        for x in G[c]:\n            del G[x][G[x].index(c)]\n            par[x] = c\n            if len(G[x]) > 0:\n                q.append(x)\n            else:\n                leaves.append(x)\n        del q[0]\n    return [leaves, par]\n\ndef solve(leaf, par, V, m):\n    c = leaf\n    f = m\n    x = f\n    while c > 0:\n        x = gcd(V[c], x)\n        if x < f:\n            f = x\n        if f == 1:\n            break\n        c = par[c]\n    return m - f\nfor tc in range(int(input())):\n    N = int(input())\n    G = {i: [] for i in range(1, N + 1)}\n    for i in range(N - 1):\n        [u, v] = [int(x) for x in input().split()]\n        G[u].append(v)\n        G[v].append(u)\n    V = [0] + [int(x) for x in input().split()]\n    M = [0] + [int(x) for x in input().split()]\n    [leaves, par] = simplify(G, 1)\n    leaves.sort()\n    ans = []\n    for leaf in leaves:\n        ans.append(solve(leaf, par, V, M[leaf]))\n    print(' '.join([str(x) for x in ans]))", "from math import gcd\nT = int(input())\nfor i in range(T):\n    graph = {}\n    children = {}\n    N = int(input())\n    for i in range(1, N + 1):\n        graph[i] = []\n        children[i] = []\n    for i in range(N - 1):\n        (x, y) = map(int, input().split())\n        graph[x].append(y)\n        graph[y].append(x)\n    parent = {}\n    for i in range(1, N + 1):\n        for j in graph[i]:\n            try:\n                temp = parent[j]\n            except:\n                if j != 1:\n                    parent[j] = i\n    for i in range(1, N + 1):\n        for j in graph[i]:\n            if i == 1 or j != parent[i]:\n                children[i].append(j)\n    leaf = []\n    for i in range(1, N + 1):\n        if children[i] == []:\n            leaf.append(i)\n    value = {}\n    ls = list(map(int, input().split()))\n    for i in range(1, N + 1):\n        value[i] = ls[i - 1]\n    parameter = {}\n    ls = list(map(int, input().split()))\n    for i in range(1, N + 1):\n        parameter[i] = ls[i - 1]\n\n    def dfs(curnode):\n        if curnode != 1:\n            value[curnode] = gcd(value[curnode], value[parent[curnode]])\n        for node in children[curnode]:\n            dfs(node)\n    dfs(1)\n    for leafnode in leaf:\n        print((parameter[leafnode] - gcd(value[leafnode], parameter[leafnode])) % parameter[leafnode], end=' ')\n    print()", "from collections import deque\n\ndef hcf(a, b):\n    if b == 0:\n        return a\n    else:\n        return hcf(b, a % b)\n\ndef gcd(l):\n    res = l[0]\n    for c in l[1:]:\n        res = hcf(res, c)\n    return res\nt = int(input())\nfor tc in range(t):\n    res = []\n    n = int(input())\n    tree = []\n    for i in range(n):\n        tree.append([])\n    for nn in range(n - 1):\n        xy = input().split()\n        x = int(xy[0])\n        y = int(xy[1])\n        tree[x - 1].append(y - 1)\n        tree[y - 1].append(x - 1)\n    v = [int(i) for i in input().split()]\n    m = [int(i) for i in input().split()]\n    q = deque()\n    q.append(0)\n    h = [0] * n\n    h[0] = v[0]\n    visited = [0] * n\n    visited[0] = 1\n    while len(q) > 0:\n        ver = q.popleft()\n        for i in tree[ver]:\n            if visited[i] == 0:\n                q.append(i)\n                visited[i] = 1\n                h[i] = hcf(h[ver], v[i])\n    for i in range(1, n):\n        x = tree[i]\n        if len(x) == 1:\n            ans = m[i] - hcf(h[i], m[i])\n            res.append(ans)\n    print(*res)", "import math\n\ndef Solve(graph, values, mods):\n    n = len(values)\n    gcds = [0] * n\n    visited = [False] * n\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        if not visited[node - 1]:\n            visited[node - 1] = True\n            gcds[node - 1] = math.gcd(gcds[node - 1], values[node - 1])\n            for kid in graph[node]:\n                if not visited[kid - 1]:\n                    gcds[kid - 1] = math.gcd(gcds[node - 1], gcds[kid - 1])\n                    stack.append(kid)\n    leaves = []\n    for i in graph.keys():\n        if len(graph[i]) == 1 and i != 1:\n            leaves.append(i)\n    leaves.sort()\n    ans = ''\n    for leaf in leaves:\n        g = math.gcd(gcds[leaf - 1], mods[leaf - 1])\n        gcds[leaf - 1] = g\n        if g > 1:\n            ans += str(mods[leaf - 1] - g) + ' '\n        else:\n            ans += str(mods[leaf - 1] // g - 1) + ' '\n    print(ans)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        graph = {}\n        for j in range(1, n + 1):\n            graph[j] = []\n        for j in range(n - 1):\n            (x, y) = map(int, input().split())\n            graph[x].append(y)\n            graph[y].append(x)\n        values = list(map(int, input().split()))\n        mods = list(map(int, input().split()))\n        Solve(graph, values, mods)\nmain()", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfrom collections import defaultdict\nfrom collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    d = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    v = [0] + list(map(int, input().split()))\n    m = [0] + list(map(int, input().split()))\n    b = deque()\n    b.append(1)\n    parent = [0] * (n + 1)\n    while len(b) != 0:\n        t = b.popleft()\n        for i in d[t]:\n            if parent[t] != i:\n                v[i] = gcd(v[i], v[t])\n                parent[i] = t\n                b.append(i)\n    for i in range(2, n + 1):\n        if len(d[i]) == 1:\n            mod = m[i]\n            t = v[i]\n            print(mod - gcd(t, mod), end=' ')", "import resource, sys\nresource.setrlimit(resource.RLIMIT_STACK, (2 ** 29, -1))\nsys.setrecursionlimit(10 ** 6)\nfrom math import gcd\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef dfs(node, p):\n    leaf = True\n    for to in graph[node]:\n        if to == p:\n            continue\n        leaf = False\n        v[to] = gcd(v[to], v[node])\n        dfs(to, node)\n    if leaf == True:\n        leaves.append(node)\n\ndef main():\n    for _ in range(int(input())):\n        global n, graph, v, m, leaves\n        n = int(input())\n        graph = [[] for i in range(n + 1)]\n        for i in range(n - 1):\n            (x, y) = map(int, input().split())\n            graph[x].append(y)\n            graph[y].append(x)\n        v = list(map(int, input().split()))\n        v.insert(0, 0)\n        m = list(map(int, input().split()))\n        m.insert(0, 0)\n        leaves = []\n        dfs(1, 1)\n        leaves.sort()\n        ans = []\n        for i in leaves:\n            x = gcd(v[i], m[i])\n            ans.append(m[i] - x)\n        print(*ans)\nmain()", "def directify(graph, root=0):\n    front = [root]\n    while len(front) > 0:\n        parent = front.pop()\n        kids = graph[parent]\n        front.extend(kids)\n        for kid in kids:\n            g_kids = graph[kid]\n            found = False\n            for (index, g_kid) in enumerate(g_kids):\n                if g_kid == parent:\n                    found = True\n                    break\n            if found:\n                (g_kids[index], g_kids[-1]) = (g_kids[-1], g_kids[index])\n                g_kids.pop()\n\ndef gcd(a, b):\n    while b > 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef scores(graph, values, mods, root=0):\n    to_visit = [(root, values[root])]\n    leaves = []\n    while len(to_visit) > 0:\n        (cur, parent_gcd) = to_visit.pop()\n        kids = graph[cur]\n        cur_gcd = gcd(parent_gcd, values[cur])\n        to_visit.extend([(kid, cur_gcd) for kid in kids])\n        if len(kids) == 0:\n            cur_mod = mods[cur]\n            leaf_gcd = gcd(cur_gcd, cur_mod)\n            score = cur_mod - leaf_gcd\n            leaves.append((cur, score))\n    leaves.sort()\n    ret = [val for (_, val) in leaves]\n    return ret\nfor _ in range(int(input())):\n    N = int(input())\n    graph = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (a, b) = map(lambda x: int(x) - 1, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    graph_vals = list(map(int, input().split()))\n    graph_mods = list(map(int, input().split()))\n    directify(graph)\n    ret = scores(graph, graph_vals, graph_mods)\n    print(' '.join(map(str, ret)))", "from sys import *\nimport os\nimport re\nfrom math import *\n\ndef nextline():\n    return list(map(lambda x: int(x.strip()), input().strip().split()))\nT = int(input())\nsetrecursionlimit(200000)\nans = []\ng = []\n\ndef solve(u, p, m):\n    isleaf = True\n    m = gcd(m, V[u])\n    for v in g[u]:\n        if v == p:\n            continue\n        isleaf = False\n        solve(v, u, m)\n    if isleaf:\n        mod = M[u]\n        m = gcd(m, mod)\n        ans[u] = mod - m\nfor t in range(T):\n    N = int(input())\n    ans = [-1] * N\n    g = [[] for x in range(N)]\n    for i in range(N - 1):\n        (u, v) = nextline()\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    V = nextline()\n    M = nextline()\n    solve(0, -1, 0)\n    print(*[x for x in ans if x != -1])", "import math\n\ndef getAnswers(adj, value, modulus, node, parent, answer):\n    if parent != -1:\n        value[node] = math.gcd(value[node], value[parent])\n    for v in adj[node]:\n        if v != parent:\n            getAnswers(adj, value, modulus, v, node, answer)\n    if len(adj[node]) == 1 and parent != -1:\n        answer[node] = modulus[node] - math.gcd(modulus[node], value[node])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    answer = [-1] * n\n    for _ in range(n - 1):\n        (a, b) = [int(x) for x in input().split()]\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    value = [int(x) for x in input().split()]\n    modulus = [int(x) for x in input().split()]\n    getAnswers(adj, value, modulus, 0, -1, answer)\n    print(' '.join([str(x) for x in answer if x != -1]))"]