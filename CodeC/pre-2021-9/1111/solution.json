["md = 10 ** 9 + 7\n\ndef mmul(a, b, adj):\n    c0 = (a[0] * b[0] + a[1] * b[1] * adj) % md\n    c1 = (a[0] * b[1] + a[1] * b[0]) % md\n    return (c0, c1)\n\ndef mpow(b, adj, t):\n    rv = (1, 0)\n    while True:\n        if t % 2 != 0:\n            rv = mmul(rv, b, adj)\n        t //= 2\n        if t == 0:\n            return rv\n        b = mmul(b, b, adj)\nfor _ in range(int(input())):\n    (l, d, t) = (int(x) for x in input().split())\n    (y, __) = mpow((d, 1), d ** 2 - l ** 2, t)\n    print(y * pow(l, 1 - t, md) % md)", "md = 10 ** 9 + 7\n\ndef mmul(a, b, adj):\n    c0 = (a[0] * b[0] + a[1] * b[1] * adj) % md\n    c1 = (a[0] * b[1] + a[1] * b[0]) % md\n    return (c0, c1)\n\ndef mpow(b, adj, t):\n    rv = (1, 0)\n    while True:\n        if t % 2 != 0:\n            rv = mmul(rv, b, adj)\n        t //= 2\n        if t == 0:\n            return rv\n        b = mmul(b, b, adj)\nfor _ in range(int(input())):\n    (l, d, t) = (int(x) for x in input().split())\n    (y, __) = mpow((d, 1), d ** 2 - l ** 2, t)\n    print(y * pow(l, 1 - t, md) % md)", "def prod(a, b):\n    ans00 = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % m\n    ans01 = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % m\n    ans10 = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % m\n    ans11 = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % m\n    return ([ans00, ans01], [ans10, ans11])\n\ndef matexpo(a, b):\n    c = [[1, 0], [0, 1]]\n    while b > 0:\n        if b % 2 == 1:\n            c = prod(c, a)\n        (b, a) = (b // 2, prod(a, a))\n    return c\nm = 1000000007\nfor T in range(int(input())):\n    (l, d, t) = [int(x) for x in input().split()]\n    mt = matexpo([[2 * (d * pow(l, m - 2, m)), -1], [1, 0]], t - 1)\n    print(l * ((mt[0][0] * (d * pow(l, m - 2, m)) + mt[0][1]) % m) % m)", "def prod(a, b):\n    ans00 = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % m\n    ans01 = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % m\n    ans10 = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % m\n    ans11 = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % m\n    return ([ans00, ans01], [ans10, ans11])\n\ndef matexpo(a, b):\n    c = [[1, 0], [0, 1]]\n    while b > 0:\n        if b % 2 == 1:\n            c = prod(c, a)\n        (b, a) = (b // 2, prod(a, a))\n    return c\nm = 1000000007\nfor T in range(int(input())):\n    (l, d, t) = [int(x) for x in input().split()]\n    mt = matexpo([[2 * (d * pow(l, m - 2, m)), -1], [1, 0]], t - 1)\n    print(l * ((mt[0][0] * (d * pow(l, m - 2, m)) + mt[0][1]) % m) % m)", "def prod(a, b):\n    ans00 = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % m\n    ans01 = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % m\n    ans10 = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % m\n    ans11 = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % m\n    return ([ans00, ans01], [ans10, ans11])\n\ndef matexpo(a, b):\n    n = len(a)\n    c = [[1, 0], [0, 1]]\n    while b > 0:\n        if b % 2 == 1:\n            c = prod(c, a)\n        b //= 2\n        a = prod(a, a)\n    return c\nimport math\nm = 1000000007\nfor T in range(int(input())):\n    (l, d, t) = [int(x) for x in input().split()]\n    cosx = d * pow(l, m - 2, m)\n    mt = [[2 * cosx, -1], [1, 0]]\n    mt = matexpo(mt, t - 1)\n    costx = (mt[0][0] * cosx + mt[0][1]) % m\n    print(l * costx % m)", "mod = 1000000007\n\ndef matmult(a, b):\n    c00 = a[0][0] * b[0][0] + a[0][1] * b[1][0]\n    c01 = a[0][0] * b[0][1] + a[0][1] * b[1][1]\n    c10 = a[1][0] * b[0][0] + a[1][1] * b[1][0]\n    c11 = a[1][0] * b[0][1] + a[1][1] * b[1][1]\n    c00 %= mod\n    c01 %= mod\n    c10 %= mod\n    c11 %= mod\n    return [[c00, c01], [c10, c11]]\n\ndef matpow(a, b):\n    n = len(a)\n    c = [[1, 0], [0, 1]]\n    while b > 0:\n        if b % 2:\n            c = matmult(c, a)\n        b = b // 2\n        a = matmult(a, a)\n    return c\nfor _ in range(int(input())):\n    (l, d, t) = map(int, input().split())\n    cosx = d * pow(l, mod - 2, mod) % mod\n    mat = [[2 * cosx, -1], [1, 0]]\n    mat = matpow(mat, t - 1)\n    costx = (mat[0][0] * cosx + mat[0][1]) % mod\n    print(l * costx % mod)", "def pow(a, b, c):\n    n = 1\n    m = a\n    v = b\n    if a == 1:\n        return 1\n    while v > 0:\n        if v % 2 == 1:\n            n *= m % c\n            n %= c\n        m *= m\n        m %= c\n        v //= 2\n    return n % c\n\ndef mul(a, b, c, mod):\n    return [(a[0] * b[0] % mod + a[1] * b[1] % mod * c % mod % mod) % mod, (a[0] * b[1] + a[1] * b[0]) % mod]\n\ndef pow_cos(a, b, cos2, mod):\n    n = [1, 0]\n    m = a\n    v = b\n    if a == [1, 0]:\n        return [1, 0]\n    while v > 0:\n        if v % 2 == 1:\n            n = mul(n, m, cos2, mod)\n        m = mul(m, m, cos2, mod)\n        m[0] %= mod\n        m[1] %= mod\n        v //= 2\n    return n\nmod = 1000000007\nT = int(input())\nfor _ in range(T):\n    (l, d, t) = map(int, input().split())\n    cos = d * pow(l, mod - 2, mod) % mod\n    cos2 = (cos ** 2 - 1) % mod\n    ans = pow_cos([cos, 1], t, cos2, mod)[0]\n    ans *= l\n    ans %= mod\n    print(ans)", "def pow(a, b, c):\n    n = 1\n    m = a\n    v = b\n    if a == 1:\n        return 1\n    while v > 0:\n        if v % 2 == 1:\n            n *= m % c\n            n %= c\n        m *= m\n        m %= c\n        v //= 2\n    return n % c\n\ndef mul(a, b, c, mod):\n    return [(a[0] * b[0] % mod + a[1] * b[1] % mod * c % mod % mod) % mod, (a[0] * b[1] + a[1] * b[0]) % mod]\n\ndef pow_cos(a, b, cos2, mod):\n    n = [1, 0]\n    m = a\n    v = b\n    if a == [1, 0]:\n        return [1, 0]\n    while v > 0:\n        if v % 2 == 1:\n            n = mul(n, m, cos2, mod)\n        m = mul(m, m, cos2, mod)\n        m[0] %= mod\n        m[1] %= mod\n        v //= 2\n    return n\nmod = 1000000007\nT = int(input())\nfor _ in range(T):\n    (l, d, t) = map(int, input().split())\n    cos = d * pow(l, mod - 2, mod) % mod\n    cos2 = (cos ** 2 - 1) % mod\n    ans = pow_cos([cos, 1], t, cos2, mod)[0]\n    ans *= l\n    ans %= mod\n    print(ans)", "mod = 10 ** 9 + 7\n\ndef multiplymod(P, Q):\n    R = [[0, 0], [0, 0]]\n    R[0][0] = (P[0][0] * Q[0][0] + P[0][1] * Q[1][0]) % mod\n    R[0][1] = (P[0][0] * Q[0][1] + P[0][1] * Q[1][1]) % mod\n    R[1][0] = (P[1][0] * Q[0][0] + P[1][1] * Q[1][0]) % mod\n    R[1][1] = (P[1][0] * Q[0][1] + P[1][1] * Q[1][1]) % mod\n    return R\n\ndef power(A, n, base):\n    res = [[1, 0], [0, 1]]\n    while n > 0:\n        if n % 2 == 1:\n            res = multiplymod(res, A)\n        n = n // 2\n        A = multiplymod(A, A)\n    return res\n\ndef cosnx(a, n):\n    M = [[2 * a, mod - 1], [1, 0]]\n    M = power(M, n - 1, a)\n    return (M[0][0] * a + M[0][1]) % mod\nfor _ in range(int(input())):\n    (l, d, t) = map(int, input().split())\n    if t == 1:\n        print(d)\n    else:\n        cosx = d * pow(l, mod - 2, mod) % mod\n        ans = cosnx(cosx, t) * l % mod\n        print(ans)", "mod = 10 ** 9 + 7\n\ndef fastpow(a, n):\n    res = 1\n    a %= mod\n    while n > 0:\n        if n % 2 == 1:\n            res = res * a % mod\n        n = n // 2\n        a = a * a % mod\n    return res\n\ndef multiplymod(P, Q):\n    R = [[0, 0], [0, 0]]\n    R[0][0] = (P[0][0] * Q[0][0] + P[0][1] * Q[1][0]) % mod\n    R[0][1] = (P[0][0] * Q[0][1] + P[0][1] * Q[1][1]) % mod\n    R[1][0] = (P[1][0] * Q[0][0] + P[1][1] * Q[1][0]) % mod\n    R[1][1] = (P[1][0] * Q[0][1] + P[1][1] * Q[1][1]) % mod\n    return R\n\ndef power(A, n, base):\n    res = [[1, 0], [0, 1]]\n    while n > 0:\n        if n % 2 == 1:\n            res = multiplymod(res, A)\n        n = n // 2\n        A = multiplymod(A, A)\n    return res\n\ndef getcosnx(a, n):\n    M = [[2 * a, mod - 1], [1, 0]]\n    M = power(M, n - 1, a)\n    return (M[0][0] * a + M[0][1]) % mod\nT = int(input())\nfor tc in range(T):\n    (l, d, t) = map(int, input().split())\n    if t == 1:\n        print(d)\n        continue\n    cosx = d * fastpow(l, mod - 2) % mod\n    ans = getcosnx(cosx, t) * l % mod\n    print(ans)", "mod = 10 ** 9 + 7\n\ndef fastpow(a, n):\n    res = 1\n    a %= mod\n    while n > 0:\n        if n % 2 == 1:\n            res = res * a % mod\n        n = n // 2\n        a = a * a % mod\n    return res\n\ndef multiplymod(P, Q):\n    R = [[0, 0], [0, 0]]\n    R[0][0] = (P[0][0] * Q[0][0] + P[0][1] * Q[1][0]) % mod\n    R[0][1] = (P[0][0] * Q[0][1] + P[0][1] * Q[1][1]) % mod\n    R[1][0] = (P[1][0] * Q[0][0] + P[1][1] * Q[1][0]) % mod\n    R[1][1] = (P[1][0] * Q[0][1] + P[1][1] * Q[1][1]) % mod\n    return R\n\ndef power(A, n, base):\n    res = [[1, 0], [0, 1]]\n    while n > 0:\n        if n % 2 == 1:\n            res = multiplymod(res, A)\n        n = n // 2\n        A = multiplymod(A, A)\n    return res\n\ndef getcosnx(a, n):\n    M = [[2 * a, mod - 1], [1, 0]]\n    M = power(M, n - 1, a)\n    return (M[0][0] * a + M[0][1]) % mod\nT = int(input())\nfor tc in range(T):\n    (l, d, t) = map(int, input().split())\n    if t == 1:\n        print(d)\n        continue\n    cosx = d * fastpow(l, mod - 2) % mod\n    ans = getcosnx(cosx, t) * l % mod\n    print(ans)", "mod = 1000000007\n\ndef fast_exp(x, e):\n    ret = 1\n    while e:\n        if e & 1:\n            ret = ret * x % mod\n        x = x * x % mod\n        e >>= 1\n    return ret\n\ndef inv(x):\n    return fast_exp(x, mod - 2)\n\nclass matrix:\n\n    def __init__(self):\n        self.a = 1\n        self.b = 0\n        self.c = 0\n        self.d = 1\n\n    def multiply(self, p, q, r, s):\n        e = (self.a * p + self.b * r) % mod\n        f = (self.a * q + self.b * s) % mod\n        g = (self.c * p + self.d * r) % mod\n        h = (self.c * q + self.d * s) % mod\n        (self.a, self.b, self.c, self.d) = (e, f, g, h)\n\ndef fast_matrix_exp(m, x):\n    ret = matrix()\n    while x:\n        if x & 1:\n            ret.multiply(m.a, m.b, m.c, m.d)\n        m.multiply(m.a, m.b, m.c, m.d)\n        x >>= 1\n    return ret\nT = int(input())\nwhile T != 0:\n    (l, d, t) = input().split()\n    l = int(l)\n    d = int(d)\n    t = int(t)\n    mt = matrix()\n    mt.a = 2 * d * inv(l) % mod\n    mt.b = mod - 1\n    mt.c = 1\n    mt.d = 0\n    mt = fast_matrix_exp(mt, t - 1)\n    print((mt.a * d + mt.b * l + mod) % mod)\n    T = T - 1", "import sys\nbase = 10 ** 9 + 7\nfrom math import gcd\nsys.setrecursionlimit(3000)\n\ndef cos(l, d, t, space):\n    if t == 0:\n        space[t] = 1\n        return 1\n    elif t == 1:\n        space[t] = d * modinv(l)\n        return d * modinv(l)\n    elif t in space:\n        return space[t]\n    elif t % 2 == 0:\n        if t // 2 in space:\n            space[t] = (2 * pow(space[t // 2], 2, base) - 1) % base\n            return space[t]\n        else:\n            space[t] = (2 * pow(cos(l, d, t // 2, space), 2, base) - 1) % base\n            return space[t]\n    else:\n        if t // 2 in space:\n            v1 = space[t // 2]\n        else:\n            v1 = cos(l, d, t // 2, space)\n            space[t // 2] = v1\n        if t // 2 + 1 in space:\n            v2 = space[t // 2 + 1]\n        else:\n            v2 = cos(l, d, t // 2 + 1, space)\n            space[t // 2 + 1] = v2\n        space[t] = (2 * v1 * v2 - space[1]) % base\n        return space[t]\n\ndef modinv(a):\n    return pow(a, base - 2, base)\nfor i in range(int(input())):\n    (l, d, t) = map(int, input().split())\n    space = {}\n    comm = gcd(l, d)\n    l1 = l // comm\n    d1 = d // comm\n    print(l * cos(l1, d1, t, space) % base)", "MOD = 1000000007\n\ndef poww(x, y, mod=MOD):\n    if y <= 0:\n        return 1\n    if y == 1:\n        return x % MOD\n    if y % 2 == 0:\n        pp = poww(x, y // 2) % mod\n        return pp * pp % mod\n    else:\n        pp = poww(x, y // 2) % mod\n        return pp * pp % mod * x % mod\n\ndef inv_mod(x, mod):\n    return poww(x, mod - 2, mod)\n\ndef isPowerTwo(num):\n    return num != 0 and num & num - 1 == 0\n\ndef matmull(a, b):\n    xx = [[0, 0], [0, 0]]\n    xx[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n    xx[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n    xx[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n    xx[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n    return xx\n\ndef matpow(mm, n):\n    if n == 1:\n        return mm\n    if n % 2 == 0:\n        pp = matpow(mm, n // 2)\n        return matmull(pp, pp)\n    else:\n        pp = matpow(mm, n // 2)\n        return matmull(matmull(pp, pp), mm)\n\ndef mulll(a, b):\n    xx = [0, 0]\n    xx[0] = (a[0][0] * b[0] + a[0][1] * b[1]) % MOD\n    xx[1] = (a[1][0] * b[0] + a[1][1] * b[1]) % MOD\n    return xx\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (l, d, n) = map(int, input().split())\n    x = d * inv_mod(l, MOD) % MOD\n    first = x\n    second = ((2 * x % MOD * x % MOD - 1) % MOD + MOD) % MOD\n    if n == 1:\n        print(d)\n        continue\n    if n == 2:\n        ans = (second * l % MOD + MOD) % MOD\n        print(ans)\n        continue\n    mm = [[2 * x, -1], [1, 0]]\n    bb = [x, 1]\n    n -= 1\n    xx = [[0, 0], [0, 0]]\n    xx = matpow(mm, n)\n    xx = mulll(xx, bb)\n    print(xx[0] * l % MOD)", "import random\nimport math\nTEST = False\nif not TEST:\n    T = int(input())\nelse:\n    T = 100000\nM = 10 ** 9 + 7\n\ndef simplify(p, q):\n    r = math.gcd(p, q)\n    p = p // r\n    q = q // r\n    return (p, q)\n\ndef chebyshev(n, a):\n    if n == 0:\n        return 1\n    if n == 1:\n        return a\n    if n in mem:\n        return mem[n]\n    if n & 1 == 0:\n        b = chebyshev(n // 2, a)\n        c = 2 * b * b - 1\n        c %= M\n        mem[n] = c\n        return c\n    else:\n        b2 = chebyshev(n // 2, a)\n        b1 = chebyshev(n // 2 + 1, a)\n        c = 2 * b1 * b2 - a\n        c %= M\n        mem[n] = c\n        return c\nfor _ in range(T):\n    if not TEST:\n        (l, d, t) = [int(c) for c in input().strip().split()]\n    else:\n        l = random.randrange(10 ** 9) + 1\n        d = random.randrange(l) + 1\n        t = 1 + random.randrange(10 ** 18)\n    mem = dict()\n    r = pow(l, M - 2, M)\n    a = d * r\n    a %= M\n    b = chebyshev(t, a)\n    rep = b * l\n    rep = rep % M\n    print(rep)", "def f(t, R, Y, C):\n    if t == 1:\n        return Y\n    (f0, f1, i) = (R, Y, 2)\n    mat = modpow([[0, 1], [-1, 2 * C]], t - 1)\n    return mat[1][0] * R + mat[1][1] * Y\n\ndef egcd(a, b):\n    (prevx, x) = (1, 0)\n    (prevy, y) = (0, 1)\n    while b:\n        q = a // b\n        (x, prevx) = (prevx - q * x, x)\n        (y, prevy) = (prevy - q * y, y)\n        (a, b) = (b, a % b)\n    return (a, prevx, prevy)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef mul(m1, m2):\n    return [[(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % MOD, (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % MOD], [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % MOD, (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % MOD]]\n\ndef modpow(mat, p):\n    if p == 1:\n        return mat\n    elif p % 2 == 0:\n        ans = modpow(mat, p // 2)\n        return mul(ans, ans)\n    else:\n        ans = modpow(mat, p - 1)\n        return mul(mat, ans)\nMOD = 10 ** 9 + 7\nT = int(input())\nfor _ in range(T):\n    (l, d, t) = map(int, input().split())\n    c = d * modinv(l, MOD) % MOD\n    ans = f(t, l, d, c)\n    print(ans % MOD)", "import sys\nbase = 10 ** 9 + 7\nfrom math import gcd\nsys.setrecursionlimit(3000)\n\ndef cos(l, d, t, space):\n    if t == 0:\n        space[t] = 1\n        return 1\n    elif t == 1:\n        space[t] = d * modinv(l)\n        return d * modinv(l)\n    elif t in space:\n        return space[t]\n    elif t % 2 == 0:\n        if t // 2 in space:\n            space[t] = (2 * pow(space[t // 2], 2, base) - 1) % base\n            return space[t]\n        else:\n            space[t] = (2 * pow(cos(l, d, t // 2, space), 2, base) - 1) % base\n            return space[t]\n    else:\n        if t // 2 in space:\n            v1 = space[t // 2]\n        else:\n            v1 = cos(l, d, t // 2, space)\n            space[t // 2] = v1\n        if t // 2 + 1 in space:\n            v2 = space[t // 2 + 1]\n        else:\n            v2 = cos(l, d, t // 2 + 1, space)\n            space[t // 2 + 1] = v2\n        space[t] = (2 * v1 * v2 - space[1]) % base\n        return space[t]\n\ndef modinv(a):\n    return pow(a, base - 2, base)\nfor i in range(int(input())):\n    (l, d, t) = map(int, input().split())\n    space = {}\n    comm = gcd(l, d)\n    l1 = l // comm\n    d1 = d // comm\n    print(l * cos(l1, d1, t, space) % base)", "mod = 10 ** 9 + 7\n\ndef fastpow(a, n):\n    res = 1\n    a %= mod\n    while n > 0:\n        if n % 2 == 1:\n            res = res * a % mod\n        n = n // 2\n        a = a * a % mod\n    return res\n\ndef multiplymod(P, Q):\n    R = [[0, 0], [0, 0]]\n    R[0][0] = (P[0][0] * Q[0][0] + P[0][1] * Q[1][0]) % mod\n    R[0][1] = (P[0][0] * Q[0][1] + P[0][1] * Q[1][1]) % mod\n    R[1][0] = (P[1][0] * Q[0][0] + P[1][1] * Q[1][0]) % mod\n    R[1][1] = (P[1][0] * Q[0][1] + P[1][1] * Q[1][1]) % mod\n    return R\n\ndef power(A, n, base):\n    res = [[1, 0], [0, 1]]\n    while n > 0:\n        if n % 2 == 1:\n            res = multiplymod(res, A)\n        n = n // 2\n        A = multiplymod(A, A)\n    return res\n\ndef getcosnx(a, n):\n    M = [[2 * a, mod - 1], [1, 0]]\n    M = power(M, n - 1, a)\n    return (M[0][0] * a + M[0][1]) % mod\nT = int(input())\nfor tc in range(T):\n    (l, d, t) = map(int, input().split())\n    if t == 1:\n        print(d)\n        continue\n    cosx = d * fastpow(l, mod - 2) % mod\n    ans = getcosnx(cosx, t) * l % mod\n    print(ans)", "(d, u, m) = (0, 0, 10 ** 9 + 7)\n\ndef solve(l, r):\n    if r == 0:\n        return (1, 0, 0, 1)\n    if r & 1:\n        (x, y, z, w) = solve(l, r - 1)\n        return ((2 * u * x + d * y) % m, -d * x % m, (2 * u * z + d * w) % m, -d * z % m)\n    (x, y, z, w) = solve(l, r // 2)\n    return ((x * x + y * z) % m, (x * y + y * w) % m, (x * z + w * z) % m, (y * z + w * w) % m)\nfor _ in range(int(input())):\n    (d, u, t) = list(map(int, input().split()))\n    l = solve((2 * u, -d, d, 0), t - 1)\n    ans = (l[0] * u + l[1] * d) * pow(pow(d, t - 1, m), m - 2, m) % m\n    print(ans)", "import math\nfrom fractions import gcd\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, mod) % mod\n    p = p * p % mod\n    if y % 2 == 0:\n        return p\n    return x * p % mod\nval = [0] * 64\nval[0] = 1\nmod = 1000000007\nfor i in range(1, 63):\n    val[i] = val[i - 1] * 2\nfor _ in range(eval(input())):\n    l = 0\n    y = 0\n    y1 = 0\n    v0 = 0\n    arr = [0] * 64\n    ps = [0] * 64\n    si = [0] * 64\n    co = [0] * 64\n    ro = 0\n    t1 = 0\n    i = 0\n    v = 1\n    fl = 0\n    pr = 0\n    f = 0\n    (l, y, t1) = map(int, input().split())\n    f = gcd(y, l)\n    p = power(l // f, mod - 2, mod) % mod\n    v0 = (p * (y // f) % mod + mod) % mod\n    arr[0] = v0\n    ps[0] = 1\n    for i in range(1, 64):\n        arr[i] = ((2 * arr[i - 1] * arr[i - 1] % mod - 1) % mod + mod) % mod\n        ps[i] = ps[i - 1] * (2 * arr[i - 1] % mod) % mod\n    v = 1\n    for i in range(0, 64):\n        if val[i] > t1:\n            break\n        elif val[i] & t1:\n            if fl != 0:\n                si[i] = co[pr] * ps[i] % mod + arr[i] * si[pr] % mod % mod\n                co[i] = ((co[pr] * arr[i] % mod - si[pr] * ps[i] % mod * (1 - v0 * v0 % mod) % mod % mod) % mod + mod) % mod\n                v = co[i]\n                pr = i\n            else:\n                v = arr[i]\n                si[i] = ps[i]\n                co[i] = v\n                fl = 1\n                pr = i\n    print(v * l % mod)", "import math\nimport copy\nimport sys\n\ndef modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef fcos2px(cosx, t):\n    m = 10 ** 9 + 7\n    (n, d) = cosx\n    p = 1\n    while p < t:\n        n = (2 * power(n, 2, m) % m - power(d, 2, m) % m) % m\n        d = power(d, 2, m)\n        p = p * 2\n    return n\n\ndef isPowerOfTwo(n):\n    if n == 0:\n        return False\n    while n != 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n\ndef multiply(A, B):\n    m = 10 ** 9 + 7\n    x00 = (A[0][0] * B[0][0] + A[0][1] * B[1][0]) % m\n    x01 = (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % m\n    x10 = (A[1][0] * B[0][0] + A[1][1] * B[1][0]) % m\n    x11 = (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % m\n    return [[x00, x01], [x10, x11]]\n\ndef matrix_power(A, x):\n    result = [[1, 0], [0, 1]]\n    while x > 0:\n        if x & 1 != 0:\n            result = multiply(result, A)\n        A = multiply(A, A)\n        x = x >> 1\n    return result\nr = int(input())\nfor _ in range(r):\n    (l, d, t) = map(int, sys.stdin.readline().split(' '))\n    m = 10 ** 9 + 7\n    c = [d, l]\n    log = math.log\n    num = 0\n    if t == 1:\n        num = d\n    elif isPowerOfTwo(t):\n        num = fcos2px(c, t)\n    else:\n        A = [[2 * d % m, -1 * power(l, 2, m)], [1, 0]]\n        A = matrix_power(A, t - 1)\n        num = (d * A[0][0] % m % m + A[0][1]) % m\n    ans = l % m * (num % m) % m * power(l, t * (m - 2), m) % m\n    print(ans)", "def modInverse(a, m):\n    (g, x, y) = gcdExtended(a, m)\n    if g != 1:\n        return -1\n    res = (x % m + m) % m\n    return res\n\ndef gcdExtended(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    (gcd, x1, y1) = gcdExtended(b % a, a)\n    x = y1 - b // a * x1\n    y = x1\n    return (gcd, x, y)\n\ndef exponential_modulo(n, k, m):\n    if n == 0:\n        return 0\n    elif k == 0:\n        return 1\n    (t, k1) = (k % 2, k // 2)\n    n1 = n * n % m\n    if t == 1:\n        return exponential_modulo(n1, k1, m) * (n % m) % m\n    else:\n        return exponential_modulo(n1, k1, m) % m\n\ndef prerequisites(l, d, t, m):\n    cosine = [d]\n    sine = [1]\n    powerl = [l]\n    pow2 = 2\n    while pow2 <= t:\n        powerl.append(powerl[-1] * powerl[-1] % m)\n        c = (2 * cosine[-1] * cosine[-1] % m - powerl[-1] + m) % m\n        s = (2 * sine[-1] * cosine[-1] + m * m) % m\n        cosine.append(c)\n        sine.append(s)\n        pow2 *= 2\n    return (sine, cosine, powerl)\nm = 1000000007\nfor test in range(int(input().strip())):\n    (l, d, t) = map(int, input().strip().split())\n    origl = l\n    (gcd, x, y) = gcdExtended(d, l)\n    (l, d) = (l // gcd, d // gcd)\n    perpend = l * l - d * d\n    (sine, cosine, powerl) = prerequisites(l, d, t, m)\n    binaryt = bin(t)[::-1]\n    cs = None\n    si = None\n    for i in range(0, len(binaryt) - 2):\n        if binaryt[i] == '1':\n            if cs == None:\n                cs = cosine[i]\n                si = sine[i]\n            else:\n                cs1 = cs\n                cs = (cosine[i] * cs % m - sine[i] * si % m * perpend % m + m * m) % m\n                si = (sine[i] * cs1 % m + cosine[i] * si % m + m) % m\n    inver = modInverse(l, m)\n    inver = exponential_modulo(inver, t - 1, m)\n    ans = cs * inver * gcd % m\n    print(ans)", "from collections import Counter\nfrom itertools import groupby\nmod = 10 ** 9 + 7\n\nclass Root:\n\n    def __init__(self, a, b, c):\n        self.real = a\n        self.imag = b\n        self.imag_mod = c\n\n    def __mul__(self, c2):\n        real = (self.real * c2.real + self.imag * c2.imag * self.imag_mod) % mod\n        imag = (self.real * c2.imag + self.imag * c2.real) % mod\n        return Root(real, imag, self.imag_mod)\n\n    def __pow__(self, n):\n        res = Root(1, 0, self.imag_mod)\n        val = self\n        while n:\n            if n % 2:\n                res *= val\n            val *= val\n            n //= 2\n        return res\nfor _ in range(int(input())):\n    (I, d, t) = [int(x) for x in input().split()]\n    i = pow(I, mod - 2, mod)\n    z = Root(d * i % mod, 1, (d ** 2 - I ** 2) * i ** 2 % mod)\n    z = z.__pow__(t)\n    f = z.real * I % mod\n    print(f)", "import math\nfrom fractions import Fraction\n\ndef modInverse(a, tmp, m):\n    return pow(a, tmp, m)\n\ndef matrixPower(M, n):\n    if n == 1:\n        return M\n    else:\n        P = matrixPower(M, n // 2)\n        a11 = (P[0][0] ** 2 + P[0][1] * P[1][0]) % 1000000007\n        a12 = (P[0][0] + P[1][1]) * P[0][1] % 1000000007\n        a21 = (P[0][0] + P[1][1]) * P[1][0] % 1000000007\n        a22 = (P[1][1] ** 2 + P[0][1] * P[1][0]) % 1000000007\n        P = [[a11, a12], [a21, a22]]\n        if n % 2 == 0:\n            return P\n        else:\n            a11 = (P[0][0] * M[0][0] + P[0][1] * M[1][0]) % 1000000007\n            a12 = (P[0][0] * M[0][1] + P[0][1] * M[1][1]) % 1000000007\n            a21 = (P[1][0] * M[0][0] + P[1][1] * M[1][0]) % 1000000007\n            a22 = (P[1][0] * M[0][1] + P[1][1] * M[1][1]) % 1000000007\n            return [[a11, a12], [a21, a22]]\nt = int(input())\nfor _ in range(t):\n    (l, d, t) = [int(i) for i in input().split(' ')]\n    r = modInverse(l, 1000000005, 1000000007)\n    cosine = d * r % 1000000007\n    matrix = [[2 * cosine, -1], [1, 0]]\n    if t > 1:\n        preMat = matrixPower(matrix, t - 1)\n        ans = l * ((preMat[0][0] * cosine + preMat[0][1]) % 1000000007) % 1000000007\n        print(ans)\n    else:\n        print(l * cosine % 1000000007)", "MOD = 10 ** 9 + 7\n\ndef inverse(a):\n    m = MOD\n    (x, y) = (1, 0)\n    while m > 1:\n        (x, y) = (y, x - a // m * y)\n        (a, m) = (m, a % m)\n    if y < 0:\n        y += MOD\n    return y\nmul = lambda a, b, x: ((a[0] * b[1] + a[1] * b[0] + 2 * x * a[0] * b[0]) % MOD, (a[1] * b[1] - a[0] * b[0]) % MOD)\n\ndef exp(a, k, x):\n    ans = (0, 1)\n    while k:\n        if k & 1:\n            ans = mul(ans, a, x)\n        a = mul(a, a, x)\n        k >>= 1\n    return ans\nT = int(input())\nfor _ in range(T):\n    (l, d, t) = map(int, input().split())\n    x = d * inverse(l) % MOD\n    print(mul((x, -1), exp((1, 0), t - 1, x), x)[0] * l % MOD)", "MOD = 10 ** 9 + 7\n\ndef inverse(a):\n    m = MOD\n    (x, y) = (1, 0)\n    while m > 1:\n        (x, y) = (y, x - a // m * y)\n        (a, m) = (m, a % m)\n    if y < 0:\n        y += MOD\n    return y\nmul = lambda a, b, x: ((a[0] * b[1] + a[1] * b[0] + 2 * x * a[0] * b[0]) % MOD, (a[1] * b[1] - a[0] * b[0]) % MOD)\n\ndef exp(a, k, x):\n    ans = (0, 1)\n    while k:\n        if k & 1:\n            ans = mul(ans, a, x)\n        a = mul(a, a, x)\n        k >>= 1\n    return ans\nT = int(input())\nfor _ in range(T):\n    (l, d, t) = map(int, input().split())\n    x = d * inverse(l) % MOD\n    print(mul((x, -1), exp((1, 0), t - 1, x), x)[0] * l % MOD)", "MOD = 10 ** 9 + 7\n\ndef inverse(a):\n    m = MOD\n    (x, y) = (1, 0)\n    while m > 1:\n        (x, y) = (y, x - a // m * y)\n        (a, m) = (m, a % m)\n    if y < 0:\n        y += MOD\n    return y\nmul = lambda a, b, x: ((a[0] * b[1] + a[1] * b[0] + 2 * x * a[0] % MOD * b[0]) % MOD, (a[1] * b[1] - a[0] * b[0]) % MOD)\n\ndef exp(a, k, x):\n    ans = (0, 1)\n    while k:\n        if k & 1:\n            ans = mul(ans, a, x)\n        a = mul(a, a, x)\n        k >>= 1\n    return ans\nT = int(input())\nfor _ in range(T):\n    (l, d, t) = map(int, input().split())\n    x = d * inverse(l) % MOD\n    print(mul((x, MOD - 1), exp((1, 0), t - 1, x), x)[0] * l % MOD)", "MOD = 10 ** 9 + 7\n\ndef inverse(a):\n    m = MOD\n    (x, y) = (1, 0)\n    while m > 1:\n        (x, y) = (y, x - a // m * y)\n        (a, m) = (m, a % m)\n    if y < 0:\n        y += MOD\n    return y\nmul = lambda a, b, x: ((a[0] * b[1] + a[1] * b[0] + 2 * x * a[0] * b[0]) % MOD, (a[1] * b[1] - a[0] * b[0]) % MOD)\n\ndef exp(a, k, x):\n    ans = (0, 1)\n    while k:\n        if k & 1:\n            ans = mul(ans, a, x)\n        a = mul(a, a, x)\n        k >>= 1\n    return ans\nT = int(input())\nfor _ in range(T):\n    (l, d, t) = map(int, input().split())\n    x = d * inverse(l) % MOD\n    print(mul((x, -1), exp((1, 0), t - 1, x), x)[0] * l % MOD)", "MOD = 10 ** 9 + 7\n\ndef inverse(a):\n    m = MOD\n    (x, y) = (1, 0)\n    while m > 1:\n        (x, y) = (y, x - a // m * y)\n        (a, m) = (m, a % m)\n    if y < 0:\n        y += MOD\n    return y\nmul = lambda a, b, x: ((a[0] * b[1] + a[1] * b[0] + 2 * x * a[0] * b[0]) % MOD, (a[1] * b[1] - a[0] * b[0]) % MOD)\n\ndef exp(a, k, x):\n    ans = (0, 1)\n    while k:\n        if k & 1:\n            ans = mul(ans, a, x)\n        a = mul(a, a, x)\n        k >>= 1\n    return ans\nT = int(input())\nfor _ in range(T):\n    (l, d, t) = map(int, input().split())\n    x = d * inverse(l) % MOD\n    print(mul((x, -1), exp((1, 0), t - 1, x), x)[0] * l % MOD)"]