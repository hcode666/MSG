["import sys\nfrom math import atan2, pi, hypot, tan\ninput = sys.stdin.readline\n\ndef polygon_area(x, y, n):\n    area = 0\n    j = n - 1\n    for i in range(n):\n        area += (x[j] + x[i]) * (y[j] - y[i])\n        j = i\n    return abs(area / 2)\n\ndef get_angle(i, x, y, n):\n    p1 = i\n    p2 = (i + 1) % n\n    p3 = (i - 1) % n\n    angle = atan2(y[p3] - y[p1], x[p3] - x[p1]) - atan2(y[p2] - y[p1], x[p2] - x[p1])\n    if angle < 0:\n        angle += 2 * pi\n    return angle\n\ndef solve():\n    (n, q) = map(int, input().split())\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x[i] = a\n        y[i] = b\n    original_area = polygon_area(x, y, n)\n    sum_of_sides = 0\n    for i in range(n):\n        a = i\n        b = (i + 1) % n\n        sum_of_sides += hypot(x[a] - x[b], y[a] - y[b])\n    tans = [tan(get_angle(i, x, y, n) / 2) for i in range(n)]\n    inverses = sum((1 / x for x in tans))\n    for _ in range(q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        new_area = original_area + d * sum_of_sides + d * d * inverses\n        print(f'{new_area:.08f}')\n\ndef main():\n    for t in range(int(input())):\n        solve()\nmain()", "import sys\nfrom math import atan2, pi, hypot, tan\ninput = sys.stdin.readline\n\ndef polygon_area(x, y, n):\n    area = 0\n    j = n - 1\n    for i in range(n):\n        area += (x[j] + x[i]) * (y[j] - y[i])\n        j = i\n    return abs(area / 2)\n\ndef get_angle(i, x, y, n):\n    p1 = i\n    p2 = (i + 1) % n\n    p3 = (i - 1) % n\n    angle = atan2(y[p3] - y[p1], x[p3] - x[p1]) - atan2(y[p2] - y[p1], x[p2] - x[p1])\n    if angle < 0:\n        angle += 2 * pi\n    return angle\n\ndef solve():\n    (n, q) = map(int, input().split())\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x[i] = a\n        y[i] = b\n    original_area = polygon_area(x, y, n)\n    sum_of_sides = 0\n    for i in range(n):\n        a = i\n        b = (i + 1) % n\n        sum_of_sides += hypot(x[a] - x[b], y[a] - y[b])\n    tans = [tan(get_angle(i, x, y, n) / 2) for i in range(n)]\n    inverses = sum((1 / x for x in tans))\n    for _ in range(q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        new_area = original_area + d * sum_of_sides + d * d * inverses\n        print(f'{new_area:.08f}')\n\ndef main():\n    for t in range(int(input())):\n        solve()\nmain()", "import sys\nfrom math import atan2, pi, hypot, tan\ninput = sys.stdin.readline\n\ndef polygon_area(x, y, n):\n    area = 0\n    j = n - 1\n    for i in range(n):\n        area += (x[j] + x[i]) * (y[j] - y[i])\n        j = i\n    return abs(area / 2)\n\ndef get_angle(i, x, y, n):\n    p1 = i\n    p2 = (i + 1) % n\n    p3 = (i - 1) % n\n    angle = atan2(y[p3] - y[p1], x[p3] - x[p1]) - atan2(y[p2] - y[p1], x[p2] - x[p1])\n    if angle < 0:\n        angle += 2 * pi\n    return angle\n\ndef solve():\n    (n, q) = map(int, input().split())\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x[i] = a\n        y[i] = b\n    original_area = polygon_area(x, y, n)\n    sum_of_sides = 0\n    for i in range(n):\n        a = i\n        b = (i + 1) % n\n        sum_of_sides += hypot(x[a] - x[b], y[a] - y[b])\n    tans = [tan(get_angle(i, x, y, n) / 2) for i in range(n)]\n    inverses = sum((1 / x for x in tans))\n    for _ in range(q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        new_area = original_area + d * sum_of_sides + d * d * inverses\n        print(f'{new_area:.08f}')\n\ndef main():\n    for t in range(int(input())):\n        solve()\nmain()", "from math import sqrt\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    coordinates = []\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        coordinates.append([x, y])\n    original_area = 0.0\n    area_corner_trianges = 0.0\n    perimeter = 0.0\n    for i in range(n):\n        (x0, y0) = (coordinates[i - 1][0], coordinates[i - 1][1])\n        (x1, y1) = (coordinates[i][0], coordinates[i][1])\n        (x2, y2) = (coordinates[(i + 1) % n][0], coordinates[(i + 1) % n][1])\n        perimeter += sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n        original_area += x1 * y2 - y1 * x2\n        i1 = x0 - x1\n        j1 = y0 - y1\n        i2 = x2 - x1\n        j2 = y2 - y1\n        cosVal = (i1 * i2 + j1 * j2) / (sqrt(i1 ** 2 + j1 ** 2) * sqrt(i2 ** 2 + j2 ** 2))\n        area_corner_trianges += sqrt((1 + cosVal) / (1 - cosVal))\n    original_area = 0.5 * abs(original_area)\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        ans = original_area + d * perimeter + d ** 2 * area_corner_trianges\n        print('{0:.7f}'.format(ans))", "from math import sqrt, acos, pi, tan\n\ndef distance(p1, p2):\n    return sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\ndef angleWithPoints(p0, p1, p2):\n    vec1 = [p0[0] - p1[0], p0[1] - p1[1]]\n    vec2 = [p0[0] - p2[0], p0[1] - p2[1]]\n    return acos((vec1[0] * vec2[0] + vec1[1] * vec2[1]) / (distance(p0, p1) * distance(p0, p2)))\nfor _ in range(int(input())):\n    (size, q) = map(int, input().split())\n    points = []\n    totalArea = 0.0\n    totalPerimeter = 0.0\n    delta = 0.0\n    for i in range(size):\n        (x, y) = map(float, input().split())\n        points.append([x * 1.0, y * 1.0])\n    for i in range(size):\n        prevP = points[(i - 1 + size) % size]\n        currP = points[i]\n        nextP = points[(i + 1) % size]\n        totalArea += currP[0] * nextP[1] - nextP[0] * currP[1]\n        totalPerimeter += distance(currP, nextP)\n        theta = pi - angleWithPoints(currP, prevP, nextP)\n        delta += tan(theta / 2.0)\n    totalArea *= 0.5\n    for i in range(q):\n        (v, ti) = map(float, input().split())\n        d = v * 1.0 * (ti * 1.0)\n        ans = totalArea + totalPerimeter * d + delta * d * d\n        print('%.10f' % ans)", "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\ndef angleWithPoints(p0, p1, p2):\n    vec1 = [p0[0] - p1[0], p0[1] - p1[1]]\n    vec2 = [p0[0] - p2[0], p0[1] - p2[1]]\n    return math.acos((vec1[0] * vec2[0] + vec1[1] * vec2[1]) / (distance(p0, p1) * distance(p0, p2)))\nfor _ in range(int(input())):\n    (size, q) = map(int, input().split())\n    points = []\n    for i in range(size):\n        (x, y) = map(float, input().split())\n        points.append([x * 1.0, y * 1.0])\n    totalArea = 0.0\n    totalPerimeter = 0.0\n    delta = 0.0\n    for i in range(size):\n        prevP = points[(i - 1 + size) % size]\n        currP = points[i]\n        nextP = points[(i + 1) % size]\n        totalArea += currP[0] * nextP[1] - nextP[0] * currP[1]\n        totalPerimeter = totalPerimeter + distance(currP, nextP)\n        theta = math.pi - angleWithPoints(currP, prevP, nextP)\n        delta = delta + math.tan(theta / 2.0)\n    totalArea = totalArea * 0.5\n    for i in range(q):\n        (v, ti) = map(float, input().split())\n        d = v * 1.0 * (ti * 1.0)\n        ans = totalArea + totalPerimeter * d + delta * d * d\n        print('%.10f' % ans)", "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\ndef angleWithPoints(p0, p1, p2):\n    vec1 = [p0[0] - p1[0], p0[1] - p1[1]]\n    vec2 = [p0[0] - p2[0], p0[1] - p2[1]]\n    return math.acos((vec1[0] * vec2[0] + vec1[1] * vec2[1]) / (distance(p0, p1) * distance(p0, p2)))\nfor _ in range(int(input())):\n    (size, q) = map(int, input().split())\n    points = []\n    for i in range(size):\n        (x, y) = map(float, input().split())\n        points.append([x * 1.0, y * 1.0])\n    totalArea = 0.0\n    totalPerimeter = 0.0\n    delta = 0.0\n    for i in range(size):\n        prevP = points[(i - 1 + size) % size]\n        currP = points[i]\n        nextP = points[(i + 1) % size]\n        totalArea += currP[0] * nextP[1] - nextP[0] * currP[1]\n        totalPerimeter = totalPerimeter + distance(currP, nextP)\n        theta = math.pi - angleWithPoints(currP, prevP, nextP)\n        delta = delta + math.tan(theta / 2.0)\n    totalArea = totalArea * 0.5\n    for i in range(q):\n        (v, ti) = map(float, input().split())\n        d = v * 1.0 * (ti * 1.0)\n        ans = totalArea + totalPerimeter * d + delta * d * d\n        print('%.10f' % ans)", "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\ndef angleWithPoints(p0, p1, p2):\n    vec1 = [p0[0] - p1[0], p0[1] - p1[1]]\n    vec2 = [p0[0] - p2[0], p0[1] - p2[1]]\n    return math.acos((vec1[0] * vec2[0] + vec1[1] * vec2[1]) / (distance(p0, p1) * distance(p0, p2)))\nfor _ in range(int(input())):\n    (size, q) = map(int, input().split())\n    points = []\n    for i in range(size):\n        (x, y) = map(float, input().split())\n        points.append([x * 1.0, y * 1.0])\n    totalArea = 0.0\n    totalPerimeter = 0.0\n    delta = 0.0\n    for i in range(size):\n        prevP = points[(i - 1 + size) % size]\n        currP = points[i]\n        nextP = points[(i + 1) % size]\n        totalArea += currP[0] * nextP[1] - nextP[0] * currP[1]\n        totalPerimeter = totalPerimeter + distance(currP, nextP)\n        theta = math.pi - angleWithPoints(currP, prevP, nextP)\n        delta = delta + math.tan(theta / 2.0)\n    totalArea = totalArea * 0.5\n    for i in range(q):\n        (v, ti) = map(float, input().split())\n        d = v * 1.0 * (ti * 1.0)\n        ans = totalArea + totalPerimeter * d + delta * d * d\n        print('%.10f' % ans)", "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\ndef angleWithPoints(p0, p1, p2):\n    vec1 = [p0[0] - p1[0], p0[1] - p1[1]]\n    vec2 = [p0[0] - p2[0], p0[1] - p2[1]]\n    return math.acos((vec1[0] * vec2[0] + vec1[1] * vec2[1]) / (distance(p0, p1) * distance(p0, p2)))\nfor _ in range(int(input())):\n    (size, q) = map(int, input().split())\n    points = []\n    for i in range(size):\n        (x, y) = map(float, input().split())\n        points.append([x * 1.0, y * 1.0])\n    totalArea = 0.0\n    totalPerimeter = 0.0\n    delta = 0.0\n    for i in range(size):\n        prevP = points[(i - 1 + size) % size]\n        currP = points[i]\n        nextP = points[(i + 1) % size]\n        totalArea += currP[0] * nextP[1] - nextP[0] * currP[1]\n        totalPerimeter = totalPerimeter + distance(currP, nextP)\n        theta = math.pi - angleWithPoints(currP, prevP, nextP)\n        delta = delta + math.tan(theta / 2.0)\n    totalArea = totalArea * 0.5\n    for i in range(q):\n        (v, ti) = map(float, input().split())\n        d = v * 1.0 * (ti * 1.0)\n        ans = totalArea + totalPerimeter * d + delta * d * d\n        print('%.10f' % ans)", "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\ndef angleWithPoints(p0, p1, p2):\n    vec1 = [p0[0] - p1[0], p0[1] - p1[1]]\n    vec2 = [p0[0] - p2[0], p0[1] - p2[1]]\n    return math.acos((vec1[0] * vec2[0] + vec1[1] * vec2[1]) / (distance(p0, p1) * distance(p0, p2)))\nfor _ in range(int(input())):\n    (size, q) = map(int, input().split())\n    points = []\n    for i in range(size):\n        (x, y) = map(float, input().split())\n        points.append([x * 1.0, y * 1.0])\n    totalArea = 0.0\n    totalPerimeter = 0.0\n    delta = 0.0\n    for i in range(size):\n        prevP = points[(i - 1 + size) % size]\n        currP = points[i]\n        nextP = points[(i + 1) % size]\n        totalArea += currP[0] * nextP[1] - nextP[0] * currP[1]\n        totalPerimeter = totalPerimeter + distance(currP, nextP)\n        theta = math.pi - angleWithPoints(currP, prevP, nextP)\n        delta = delta + math.tan(theta / 2.0)\n    totalArea = totalArea * 0.5\n    for i in range(q):\n        (v, ti) = map(float, input().split())\n        d = v * 1.0 * (ti * 1.0)\n        ans = totalArea + totalPerimeter * d + delta * d * d\n        print('%.10f' % ans)", "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\ndef angleWithPoints(p0, p1, p2):\n    vec1 = [p0[0] - p1[0], p0[1] - p1[1]]\n    vec2 = [p0[0] - p2[0], p0[1] - p2[1]]\n    return math.acos((vec1[0] * vec2[0] + vec1[1] * vec2[1]) / (distance(p0, p1) * distance(p0, p2)))\nfor _ in range(int(input())):\n    (size, q) = map(int, input().split())\n    points = []\n    for i in range(size):\n        (x, y) = map(float, input().split())\n        points.append([x * 1.0, y * 1.0])\n    totalArea = 0.0\n    totalPerimeter = 0.0\n    delta = 0.0\n    for i in range(size):\n        prevP = points[(i - 1 + size) % size]\n        currP = points[i]\n        nextP = points[(i + 1) % size]\n        totalArea += currP[0] * nextP[1] - nextP[0] * currP[1]\n        totalPerimeter = totalPerimeter + distance(currP, nextP)\n        theta = math.pi - angleWithPoints(currP, prevP, nextP)\n        delta = delta + math.tan(theta / 2.0)\n    totalArea = totalArea * 0.5\n    for i in range(q):\n        (v, ti) = map(float, input().split())\n        d = v * 1.0 * (ti * 1.0)\n        ans = totalArea + totalPerimeter * d + delta * d * d\n        print('%.10f' % ans)", "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\ndef angleWithPoints(p0, p1, p2):\n    vec1 = [p0[0] - p1[0], p0[1] - p1[1]]\n    vec2 = [p0[0] - p2[0], p0[1] - p2[1]]\n    return math.acos((vec1[0] * vec2[0] + vec1[1] * vec2[1]) / (distance(p0, p1) * distance(p0, p2)))\nfor _ in range(int(input())):\n    (size, q) = map(int, input().split())\n    points = []\n    for i in range(size):\n        (x, y) = map(float, input().split())\n        points.append([x * 1.0, y * 1.0])\n    totalArea = 0.0\n    totalPerimeter = 0.0\n    delta = 0.0\n    for i in range(size):\n        prevP = points[(i - 1 + size) % size]\n        currP = points[i]\n        nextP = points[(i + 1) % size]\n        totalArea += currP[0] * nextP[1] - nextP[0] * currP[1]\n        totalPerimeter = totalPerimeter + distance(currP, nextP)\n        theta = math.pi - angleWithPoints(currP, prevP, nextP)\n        delta = delta + math.tan(theta / 2.0)\n    totalArea = totalArea * 0.5\n    for i in range(q):\n        (v, ti) = map(float, input().split())\n        d = v * 1.0 * (ti * 1.0)\n        ans = totalArea + totalPerimeter * d + delta * d * d\n        print('%.10f' % ans)", "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\ndef angleWithPoints(p0, p1, p2):\n    vec1 = [p0[0] - p1[0], p0[1] - p1[1]]\n    vec2 = [p0[0] - p2[0], p0[1] - p2[1]]\n    return math.acos((vec1[0] * vec2[0] + vec1[1] * vec2[1]) / (distance(p0, p1) * distance(p0, p2)))\nfor _ in range(int(input())):\n    (size, q) = map(int, input().split())\n    points = []\n    for i in range(size):\n        (x, y) = map(float, input().split())\n        points.append([x * 1.0, y * 1.0])\n    totalArea = 0.0\n    totalPerimeter = 0.0\n    delta = 0.0\n    for i in range(size):\n        prevP = points[(i - 1 + size) % size]\n        currP = points[i]\n        nextP = points[(i + 1) % size]\n        totalArea += currP[0] * nextP[1] - nextP[0] * currP[1]\n        totalPerimeter = totalPerimeter + distance(currP, nextP)\n        theta = math.pi - angleWithPoints(currP, prevP, nextP)\n        delta = delta + math.tan(theta / 2.0)\n    totalArea = totalArea * 0.5\n    for i in range(q):\n        (v, ti) = map(float, input().split())\n        d = v * 1.0 * (ti * 1.0)\n        ans = totalArea + totalPerimeter * d + delta * d * d\n        print('%.10f' % ans)", "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\ndef angleWithPoints(p0, p1, p2):\n    vec1 = [p0[0] - p1[0], p0[1] - p1[1]]\n    vec2 = [p0[0] - p2[0], p0[1] - p2[1]]\n    return math.acos((vec1[0] * vec2[0] + vec1[1] * vec2[1]) / (distance(p0, p1) * distance(p0, p2)))\nfor _ in range(int(input())):\n    (size, q) = map(int, input().split())\n    points = []\n    for i in range(size):\n        (x, y) = map(float, input().split())\n        points.append([x * 1.0, y * 1.0])\n    totalArea = 0.0\n    totalPerimeter = 0.0\n    delta = 0.0\n    for i in range(size):\n        prevP = points[(i - 1 + size) % size]\n        currP = points[i]\n        nextP = points[(i + 1) % size]\n        totalArea += currP[0] * nextP[1] - nextP[0] * currP[1]\n        totalPerimeter = totalPerimeter + distance(currP, nextP)\n        theta = math.pi - angleWithPoints(currP, prevP, nextP)\n        delta = delta + math.tan(theta / 2.0)\n    totalArea = totalArea * 0.5\n    for i in range(q):\n        (v, ti) = map(float, input().split())\n        d = v * 1.0 * (ti * 1.0)\n        ans = totalArea + totalPerimeter * d + delta * d * d\n        print('%.10f' % ans)", "import sys\nfrom math import atan2, pi, hypot, tan\ninput = sys.stdin.readline\n\ndef polygon_area(x, y, n):\n    area = 0\n    j = n - 1\n    for i in range(n):\n        area += (x[j] + x[i]) * (y[j] - y[i])\n        j = i\n    return abs(area / 2)\n\ndef get_angle(i, x, y, n):\n    p1 = i\n    p2 = (i + 1) % n\n    p3 = (i - 1) % n\n    angle = atan2(y[p3] - y[p1], x[p3] - x[p1]) - atan2(y[p2] - y[p1], x[p2] - x[p1])\n    if angle < 0:\n        angle += 2 * pi\n    return angle\n\ndef solve():\n    (n, q) = map(int, input().split())\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x[i] = a\n        y[i] = b\n    original_area = polygon_area(x, y, n)\n    sum_of_sides = 0\n    for i in range(n):\n        a = i\n        b = (i + 1) % n\n        sum_of_sides += hypot(x[a] - x[b], y[a] - y[b])\n    tans = [tan(get_angle(i, x, y, n) / 2) for i in range(n)]\n    inverses = sum((1 / x for x in tans))\n    for _ in range(q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        new_area = original_area + d * sum_of_sides + d * d * inverses\n        print(f'{new_area:.08f}')\n\ndef main():\n    for t in range(int(input())):\n        solve()\nmain()", "def distance(x1, y1, x2, y2):\n    ans = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    ans = ans ** 0.5\n    return ans\n\ndef cosine(x1, y1, x2, y2, x3, y3):\n    a = distance(x1, y1, x2, y2)\n    b = distance(x3, y3, x2, y2)\n    c = distance(x1, y1, x3, y3)\n    ans = a * a + b * b - c * c\n    ans /= 2 * a * b\n    return ans\n\ndef cothalf(x1, y1, x2, y2, x3, y3):\n    cos = (cosine(x1, y1, x2, y2, x3, y3) + 1) / 2\n    sin = 1 - cos\n    ans = cos / sin\n    ans = ans ** 0.5\n    return ans\n\ndef cotsum(x, y, n):\n    ans = 0\n    for i in range(n - 2):\n        ans += cothalf(x[i], y[i], x[i + 1], y[i + 1], x[i + 2], y[i + 2])\n    ans += cothalf(x[n - 2], y[n - 2], x[n - 1], y[n - 1], x[0], y[0])\n    ans += cothalf(x[n - 1], y[n - 1], x[0], y[0], x[1], y[1])\n    return ans\n\ndef perimeter(x, y, n):\n    ans = 0\n    for i in range(n - 1):\n        ans += distance(x[i], y[i], x[i + 1], y[i + 1])\n    ans += distance(x[0], y[0], x[n - 1], y[n - 1])\n    return ans\n\ndef area(x, y, n):\n    ans = 0\n    for i in range(n - 1):\n        ans += x[i] * y[i + 1] - y[i] * x[i + 1]\n    ans += x[n - 1] * y[0] - y[n - 1] * x[0]\n    ans /= 2\n    if ans < 0:\n        ans = -ans\n    return ans\nt = int(input())\nfor zz in range(t):\n    nq = list(map(int, input().split()))\n    n = nq[0]\n    q = nq[1]\n    x = []\n    y = []\n    for i in range(n):\n        ttt = list(map(int, input().split()))\n        x.append(ttt[0])\n        y.append(ttt[1])\n    ar = area(x, y, n)\n    p = perimeter(x, y, n)\n    cs = cotsum(x, y, n)\n    for i in range(q):\n        vt = list(map(int, input().split()))\n        s = vt[0] * vt[1]\n        ar += s * p + s * s * cs\n        print(ar)\n        ar -= s * p + s * s * cs", "import sys\nfrom math import atan2, pi, hypot, tan\ninput = sys.stdin.readline\n\ndef polygon_area(x, y, n):\n    area = 0\n    j = n - 1\n    for i in range(n):\n        area += (x[j] + x[i]) * (y[j] - y[i])\n        j = i\n    return abs(area / 2)\n\ndef get_angle(i, x, y, n):\n    p1 = i\n    p2 = (i + 1) % n\n    p3 = (i - 1) % n\n    angle = atan2(y[p3] - y[p1], x[p3] - x[p1]) - atan2(y[p2] - y[p1], x[p2] - x[p1])\n    if angle < 0:\n        angle += 2 * pi\n    return angle\n\ndef solve():\n    (n, q) = map(int, input().split())\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x[i] = a\n        y[i] = b\n    original_area = polygon_area(x, y, n)\n    sum_of_sides = 0\n    for i in range(n):\n        a = i\n        b = (i + 1) % n\n        sum_of_sides += hypot(x[a] - x[b], y[a] - y[b])\n    tans = [tan(get_angle(i, x, y, n) / 2) for i in range(n)]\n    inverses = sum((1 / x for x in tans))\n    for _ in range(q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        new_area = original_area + d * sum_of_sides + d * d * inverses\n        print(f'{new_area:.08f}')\n\ndef main():\n    for t in range(int(input())):\n        solve()\nmain()", "import sys\nfrom math import atan2, pi, hypot, tan\ninput = sys.stdin.readline\n\ndef polygon(x, y, n):\n    area = 0\n    j = n - 1\n    for i in range(n):\n        area += (x[i] + x[j]) * (y[j] - y[i])\n        j = i\n    return abs(area / 2)\n\ndef get_angle(i, x, y, n):\n    p1 = i\n    p2 = (i + 1) % n\n    p3 = (i - 1) % n\n    angle = atan2(y[p3] - y[p1], x[p3] - x[p1]) - atan2(y[p2] - y[p1], x[p2] - x[p1])\n    if angle < 0:\n        angle += 2 * pi\n    return angle\n\ndef solve():\n    (n, q) = map(int, input().split())\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x[i] = a\n        y[i] = b\n    o = polygon(x, y, n)\n    ss = 0\n    for i in range(n):\n        a = i\n        b = (i + 1) % n\n        ss += hypot(x[a] - x[b], y[a] - y[b])\n    tans = [tan(get_angle(i, x, y, n) / 2) for i in range(n)]\n    inver = sum((1 / x for x in tans))\n    for _ in range(q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        new_area = o + d * ss + d * d * inver\n        print(f'{new_area:.08f}')\n\ndef main():\n    for t in range(int(input())):\n        solve()\nmain()", "import math\n\ndef lengthBetweenPoints(p0, p1):\n    return math.sqrt(pow(p0[0] - p1[0], 2) + pow(p0[1] - p1[1], 2))\n\ndef angleBetweenPoints(a, b, c):\n    l0 = lengthBetweenPoints(a, b)\n    l1 = lengthBetweenPoints(b, c)\n    l2 = lengthBetweenPoints(a, c)\n    return math.acos((l0 * l0 + l1 * l1 - l2 * l2) / (2 * l0 * l1))\n\ndef polygonArea(poly, n):\n    area = 0.0\n    j = n - 1\n    for i in range(0, n):\n        area += (poly[j][0] + poly[i][0]) * (poly[j][1] - poly[i][1])\n        j = i\n    return abs(area / 2.0)\n\ndef polygonPerimeter(poly, n):\n    peri = 0\n    for i in range(n):\n        p0 = poly[i]\n        p1 = poly[i + 1 if i != n - 1 else 0]\n        length = lengthBetweenPoints(p0, p1)\n        peri += length\n    return peri\n\ndef polygonTriCot(poly, n):\n    tricot = 0\n    for i in range(n):\n        a = poly[i - 1]\n        b = poly[i]\n        c = poly[i + 1 if i != n - 1 else 0]\n        angle = angleBetweenPoints(a, b, c)\n        tricot += 1 / math.tan(angle / 2)\n    return tricot\nfor _ in range(int(input())):\n    (N, Q) = map(int, input().split())\n    poly = []\n    for i in range(N):\n        (x, y) = map(int, input().split())\n        poly.append((x, y))\n    poly_area = polygonArea(poly, N)\n    poly_peri = polygonPerimeter(poly, N)\n    poly_tric = polygonTriCot(poly, N)\n    for i in range(Q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        print(poly_area + d * poly_peri + d * d * poly_tric)", "import math\nt = int(input().strip())\n\ndef cot(x):\n    if x == 0:\n        return 0\n    t = math.tan(x)\n    if t == 0:\n        return 0\n    else:\n        return 1 / t\nfor _ in range(0, t):\n    (N, Q) = map(int, input().strip().split())\n    coords = []\n    for _ in range(0, N):\n        (x, y) = map(float, input().strip().split())\n        coords.append((x, y))\n    area = abs(sum([coords[i][0] * (coords[i + 1][1] - coords[i - 1][1]) for i in range(-1, N - 1)])) / 2.0\n    perimeter = 0\n    anglesT = 0\n    for i in range(0, N):\n        pi = i - 1\n        ni = (i + 1) % N\n        x0 = coords[pi][0]\n        y0 = coords[pi][1]\n        x1 = coords[i][0]\n        y1 = coords[i][1]\n        x2 = coords[ni][0]\n        y2 = coords[ni][1]\n        d1 = (x1 - x0) ** 2 + (y1 - y0) ** 2\n        d2 = (x1 - x2) ** 2 + (y1 - y2) ** 2\n        d3 = (x2 - x0) ** 2 + (y2 - y0) ** 2\n        perimeter += math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n        angle = math.acos((d1 + d2 - d3) / (2 * math.sqrt(d1) * math.sqrt(d2)))\n        anglesT += cot(angle / 2)\n    for _ in range(0, Q):\n        (v, t) = map(float, input().strip().split())\n        dist = v * t\n        a = perimeter * dist + dist ** 2 * anglesT\n        print(area + a)", "from math import sin, cos, acos\n\ndef polyArea(x, y):\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))\n\ndef euclideanDistance(A, B):\n    return ((A[0] - B[0]) ** 2 + (A[1] - B[1]) ** 2) ** (1 / 2)\n\ndef angleVertix(O, A, B):\n    module = euclideanDistance(A, O) * euclideanDistance(O, B)\n    scalar = (O[0] - A[0]) * (O[0] - B[0]) + (O[1] - A[1]) * (O[1] - B[1])\n    return acos(scalar / module)\nT = int(input())\nfor _ in range(T):\n    (N, Q) = map(int, input().split())\n    anglesCoeffSum = 0\n    perimeter = 0\n    manualArea = 0\n    vertices = []\n    firstVertix = 0\n    for n in range(N):\n        (x, y) = map(int, input().split())\n        vertices.append([x, y])\n    for i in range(len(vertices)):\n        v = vertices[i]\n        prev = vertices[len(vertices) - 1]\n        adj = vertices[0]\n        if i != len(vertices) - 1:\n            adj = vertices[i + 1]\n        if i != 0:\n            prev = vertices[i - 1]\n        side = euclideanDistance(adj, v)\n        perimeter += side\n        a = angleVertix(v, prev, adj)\n        anglesCoeffSum += 1 / sin(a) * (1 + cos(a))\n        manualArea += v[0] * adj[1] - v[1] * adj[0]\n    for q in range(Q):\n        (t, v) = map(int, input().split())\n        s = t * v\n        print(abs(manualArea) / 2 + perimeter * s + anglesCoeffSum * s ** 2)", "import sys\nfrom math import atan2, pi, hypot, tan\ninput = sys.stdin.readline\n\ndef polygon_area(x, y, n):\n    area = 0\n    j = n - 1\n    for i in range(n):\n        area += (x[j] + x[i]) * (y[j] - y[i])\n        j = i\n    return abs(area / 2)\n\ndef get_angle(i, x, y, n):\n    p1 = i\n    p2 = (i + 1) % n\n    p3 = (i - 1) % n\n    angle = atan2(y[p3] - y[p1], x[p3] - x[p1]) - atan2(y[p2] - y[p1], x[p2] - x[p1])\n    if angle < 0:\n        angle += 2 * pi\n    return angle\n\ndef solve():\n    (n, q) = map(int, input().split())\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x[i] = a\n        y[i] = b\n    original_area = polygon_area(x, y, n)\n    sum_of_sides = 0\n    for i in range(n):\n        a = i\n        b = (i + 1) % n\n        sum_of_sides += hypot(x[a] - x[b], y[a] - y[b])\n    tans = [tan(get_angle(i, x, y, n) / 2) for i in range(n)]\n    inverses = sum((1 / x for x in tans))\n    for _ in range(q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        new_area = original_area + d * sum_of_sides + d * d * inverses\n        print(f'{new_area:.08f}')\n\ndef main():\n    for t in range(int(input())):\n        solve()\nmain()", "import sys\nfrom math import atan2, pi, hypot, tan\ninput = sys.stdin.readline\n\ndef polygon_area(x, y, n):\n    area = 0\n    j = n - 1\n    for i in range(n):\n        area += (x[j] + x[i]) * (y[j] - y[i])\n        j = i\n    return abs(area / 2)\n\ndef get_angle(i, x, y, n):\n    p1 = i\n    p2 = (i + 1) % n\n    p3 = (i - 1) % n\n    angle = atan2(y[p3] - y[p1], x[p3] - x[p1]) - atan2(y[p2] - y[p1], x[p2] - x[p1])\n    angle = abs(angle)\n    if angle > pi:\n        angle = 2 * pi - angle\n    return angle\n\ndef solve():\n    (n, q) = map(int, input().split())\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x[i] = a\n        y[i] = b\n    original_area = polygon_area(x, y, n)\n    sum_of_sides = 0\n    for i in range(n):\n        a = i\n        b = (i + 1) % n\n        sum_of_sides += hypot(x[a] - x[b], y[a] - y[b])\n    tans = [tan(get_angle(i, x, y, n) / 2) for i in range(n)]\n    inverses = sum((1 / x for x in tans))\n    for _ in range(q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        new_area = original_area + d * sum_of_sides + d * d * inverses\n        print(f'{new_area:.08f}')\n\ndef main():\n    for t in range(int(input())):\n        solve()\nmain()", "import sys\nimport math\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef tr(a, n):\n    return math.floor(a * 10 ** n) / 10 ** n\nt = int(input())\nfor j in range(t):\n    a = get_ints()\n    x = []\n    y = []\n    for l in range(a[0]):\n        r = get_ints()\n        x.append(r[0])\n        y.append(r[1])\n    A = 0.0\n    j = a[0] - 1\n    for rr in range(a[0]):\n        A += (x[j] + x[rr]) * (y[j] - y[rr])\n        j = rr\n    A = abs(A / 2.0)\n    sum2 = 0.0\n    for k in range(a[0] - 2):\n        gy = (x[k] - x[k + 1]) * (-x[k + 1] + x[k + 2]) + (y[k] - y[k + 1]) * (-y[k + 1] + y[k + 2])\n        n12 = (x[k] - x[k + 1]) ** 2 + (y[k] - y[k + 1]) ** 2\n        n23 = (x[k + 2] - x[k + 1]) ** 2 + (y[k + 2] - y[k + 1]) ** 2\n        angle = gy / (n12 * n23) ** 0.5\n        act = math.acos(angle) / 2\n        length1 = 1 / math.tan(act)\n        sum2 = sum2 + length1\n    gy = (x[a[0] - 2] - x[a[0] - 1]) * (-x[a[0] - 1] + x[0]) + (y[a[0] - 2] - y[a[0] - 1]) * (-y[a[0] - 1] + y[0])\n    n12 = (x[a[0] - 2] - x[a[0] - 1]) ** 2 + (y[a[0] - 2] - y[a[0] - 1]) ** 2\n    n23 = (-x[a[0] - 1] + x[0]) ** 2 + (-y[a[0] - 1] + y[0]) ** 2\n    angle = gy / (n12 * n23) ** 0.5\n    act = math.acos(angle) / 2\n    length1 = 1 / math.tan(act)\n    sum2 = sum2 + length1\n    gy = (x[a[0] - 1] - x[0]) * (-x[0] + x[1]) + (y[a[0] - 1] - y[0]) * (-y[0] + y[1])\n    n12 = (x[a[0] - 1] - x[0]) ** 2 + (y[a[0] - 1] - y[0]) ** 2\n    n23 = (-x[0] + x[1]) ** 2 + (-y[0] + y[1]) ** 2\n    angle = gy / (n12 * n23) ** 0.5\n    act = math.acos(angle) / 2\n    length1 = 1 / math.tan(act)\n    sum2 = sum2 + length1\n    psum = 0.0\n    for ii in range(a[0] - 1):\n        psum += ((x[ii] - x[ii + 1]) ** 2 + (y[ii] - y[ii + 1]) ** 2) ** 0.5\n    psum += ((x[a[0] - 1] - x[0]) ** 2 + (y[a[0] - 1] - y[0]) ** 2) ** 0.5\n    for k in range(a[1]):\n        gg = get_ints()\n        d = A + psum * gg[0] * gg[1] + sum2 * gg[0] * gg[0] * gg[1] * gg[1]\n        print(d)", "def distance(x1, y1, x2, y2):\n    ans = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    ans = ans ** 0.5\n    return ans\n\ndef cosine(x1, y1, x2, y2, x3, y3):\n    a = distance(x1, y1, x2, y2)\n    b = distance(x3, y3, x2, y2)\n    c = distance(x1, y1, x3, y3)\n    ans = a * a + b * b - c * c\n    ans /= 2 * a * b\n    return ans\n\ndef cothalf(x1, y1, x2, y2, x3, y3):\n    cos = (cosine(x1, y1, x2, y2, x3, y3) + 1) / 2\n    sin = 1 - cos\n    ans = cos / sin\n    ans = ans ** 0.5\n    return ans\n\ndef cotsum(x, y, n):\n    ans = 0\n    for i in range(n - 2):\n        ans += cothalf(x[i], y[i], x[i + 1], y[i + 1], x[i + 2], y[i + 2])\n    ans += cothalf(x[n - 2], y[n - 2], x[n - 1], y[n - 1], x[0], y[0])\n    ans += cothalf(x[n - 1], y[n - 1], x[0], y[0], x[1], y[1])\n    return ans\n\ndef perimeter(x, y, n):\n    ans = 0\n    for i in range(n - 1):\n        ans += distance(x[i], y[i], x[i + 1], y[i + 1])\n    ans += distance(x[0], y[0], x[n - 1], y[n - 1])\n    return ans\n\ndef area(x, y, n):\n    ans = 0\n    for i in range(n - 1):\n        ans += x[i] * y[i + 1] - y[i] * x[i + 1]\n    ans += x[n - 1] * y[0] - y[n - 1] * x[0]\n    ans /= 2\n    if ans < 0:\n        ans = -ans\n    return ans\nt = int(input())\nfor zz in range(t):\n    nq = list(map(int, input().split()))\n    n = nq[0]\n    q = nq[1]\n    x = []\n    y = []\n    for i in range(n):\n        ttt = list(map(int, input().split()))\n        x.append(ttt[0])\n        y.append(ttt[1])\n    ar = area(x, y, n)\n    p = perimeter(x, y, n)\n    cs = cotsum(x, y, n)\n    for i in range(q):\n        vt = list(map(int, input().split()))\n        s = vt[0] * vt[1]\n        ar += s * p + s * s * cs\n        print(ar)\n        ar -= s * p + s * s * cs", "import math\nT = int(input())\nfor a in range(T):\n    (N, Q) = [int(x) for x in input().split()]\n    (Ar, Das) = (list(), list())\n    (a1, a2) = (0, 0)\n    for i in range(N):\n        I = [float(x) for x in input().split()]\n        a1 += I[0]\n        a2 += I[1]\n        Ar.append(I)\n    for i in range(Q):\n        I = [float(x) for x in input().split()]\n        Das.append(I[0] * I[1])\n    c = [a1 / N, a2 / N]\n    for i in range(N):\n        Ar[i] = [Ar[i][0] - c[0], Ar[i][1] - c[1]]\n\n    def P(x1, y1, x2, y2):\n        if x1 - x2 == 0:\n            return [x2, 0]\n        else:\n            m = (y2 - y1) / (x2 - x1)\n            p = (m * x2 - y2) / (m * m + 1)\n            return [m * p, -p]\n\n    def mod(P):\n        return math.sqrt(P[0] * P[0] + P[1] * P[1])\n\n    def holla(x1, y1, x2, y2, x3, y3, P1, P2):\n        mP1 = mod(P1)\n        mP2 = mod(P2)\n        if x2 - x1 == 0:\n            (A, B) = (P1[0], P1[0] / mP1)\n            m2 = (y3 - y2) / (x3 - x2)\n            return [A, B, m2 * (A - P2[0]) + P2[1], m2 * B + (P2[1] - m2 * P2[0]) / mP2]\n        elif x3 - x2 == 0:\n            (A, B) = (P2[0], P2[0] / mP2)\n            m1 = (y2 - y1) / (x2 - x1)\n            return [A, B, m1 * (A - P1[0]) + P1[1], m1 * B + (P1[1] - m1 * P1[0]) / mP1]\n        else:\n            (m1, m2) = ((y2 - y1) / (x2 - x1), (y3 - y2) / (x3 - x2))\n            A = (P2[1] - P1[1] - (m2 * P2[0] - m1 * P1[0])) / (m1 - m2)\n            B = (P2[1] / mP2 - P1[1] / mP1 - (m2 * P2[0] / mP2 - m1 * P1[0] / mP1)) / (m1 - m2)\n            C = m2 * (A - P2[0]) + P2[1]\n            D = m2 * B + (P2[1] - m2 * P2[0]) / mP2\n            return [A, B, C, D]\n    Ar.append(Ar[0])\n    Ar.append(Ar[1])\n    Box = list()\n    for k in range(N):\n        P1 = P(Ar[k][0], Ar[k][1], Ar[k + 1][0], Ar[k + 1][1])\n        P2 = P(Ar[k + 1][0], Ar[k + 1][1], Ar[k + 2][0], Ar[k + 2][1])\n        Box.append(holla(Ar[k][0], Ar[k][1], Ar[k + 1][0], Ar[k + 1][1], Ar[k + 2][0], Ar[k + 2][1], P1, P2))\n    Box.append(Box[0])\n    (L1, L2, L3) = (0, 0, 0)\n    for k in range(N):\n        (A1, B1, C1, D1) = Box[k]\n        (A2, B2, C2, D2) = Box[k + 1]\n        L1 += A1 * C2 - C1 * A2\n        L2 += A1 * D2 + B1 * C2 - (C1 * B2 + D1 * A2)\n        L3 += B1 * D2 - D1 * B2\n    for d in Das:\n        print(0.5 * (L1 + L2 * d + L3 * d * d))", "import math\n\ndef dist(x1, y1, x2, y2):\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** (1 / 2)\n\ndef cos_theta(a, b, c):\n    return (b ** 2 + c ** 2 - a ** 2) / (2 * b * c)\n\ndef sin_theta(ct):\n    return (1 - ct ** 2) ** (1 / 2)\n\ndef angle_area_factor(a, b, c):\n    c = cos_theta(a, b, c)\n    s = sin_theta(c)\n    if round(s, 3) == 0:\n        return 0\n    else:\n        return c / s + 1 / s\nT = int(input())\nfor i in range(T):\n    (N, Q) = [int(j) for j in input().split()]\n    c_x = 0\n    c_y = 0\n    X = []\n    Y = []\n    for k in range(N):\n        (x, y) = [int(l) for l in input().split()]\n        X.append(x)\n        Y.append(y)\n        c_x += x\n        c_y += y\n    c_x /= N\n    c_y /= N\n    Tan_Inv = []\n    flag = 0\n    for m in range(N):\n        Tan_Inv.append(math.atan2(Y[m] - c_y, X[m] - c_x))\n    z = zip(Tan_Inv, X, Y)\n    s = sorted(z)\n    s.append(s[0])\n    D = []\n    Alt_D = []\n    Area = 0\n    for n in range(N):\n        if n == 0:\n            w0 = s[N - 1]\n        else:\n            w0 = s[n - 1]\n        w1 = s[n]\n        w2 = s[n + 1]\n        D.append(dist(w1[1], w1[2], w2[1], w2[2]))\n        Area += w1[1] * w2[2] - w2[1] * w1[2]\n        Alt_D.append(dist(w0[1], w0[2], w2[1], w2[2]))\n    Area /= 2\n    perimeter = 0\n    total_angle_area_factor = 0\n    for o in range(N):\n        a = Alt_D[o]\n        b = D[o]\n        if o == 0:\n            c = D[N - 1]\n        else:\n            c = D[o - 1]\n        total_angle_area_factor += angle_area_factor(a, b, c)\n        perimeter += b\n    for p in range(Q):\n        (v, t) = [int(q) for q in input().split()]\n        factor = v * t\n        print(Area + perimeter * factor + total_angle_area_factor * factor ** 2)", "import math\nPI = 3.14159265\n\ndef tan_inv(y, x):\n    if x == 0:\n        if y > 0:\n            return PI / 2\n        if y < 0:\n            return 3 * PI / 2\n        else:\n            return 10\n    a = y / x\n    z = a - a ** 3 / 3 + a ** 5 / 5 - a ** 7 / 7 + a ** 9 / 9\n    if x < 0:\n        if a <= 0:\n            return z + PI\n        elif a > 0:\n            return z - PI\n    else:\n        return z\n\ndef dist(x1, y1, x2, y2):\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** (1 / 2)\n\ndef cos_theta(a, b, c):\n    return (b ** 2 + c ** 2 - a ** 2) / (2 * b * c)\n\ndef sin_theta(ct):\n    return (1 - ct ** 2) ** (1 / 2)\n\ndef angle_area_factor(a, b, c):\n    c = cos_theta(a, b, c)\n    s = sin_theta(c)\n    if round(s, 3) == 0:\n        return 0\n    else:\n        return c / s + 1 / s\nT = int(input())\nfor i in range(T):\n    (N, Q) = [int(j) for j in input().split()]\n    c_x = 0\n    c_y = 0\n    X = []\n    Y = []\n    for k in range(N):\n        (x, y) = [int(l) for l in input().split()]\n        X.append(x)\n        Y.append(y)\n        c_x += x\n        c_y += y\n    c_x /= N\n    c_y /= N\n    Tan_Inv = []\n    flag = 0\n    for m in range(N):\n        Tan_Inv.append(math.atan2(Y[m] - c_y, X[m] - c_x))\n    z = zip(Tan_Inv, X, Y)\n    s = sorted(z)\n    s.append(s[0])\n    D = []\n    Alt_D = []\n    Area = 0\n    for n in range(N):\n        if n == 0:\n            w0 = s[N - 1]\n        else:\n            w0 = s[n - 1]\n        w1 = s[n]\n        w2 = s[n + 1]\n        D.append(dist(w1[1], w1[2], w2[1], w2[2]))\n        Area += w1[1] * w2[2] - w2[1] * w1[2]\n        Alt_D.append(dist(w0[1], w0[2], w2[1], w2[2]))\n    Area /= 2\n    perimeter = 0\n    total_angle_area_factor = 0\n    for o in range(N):\n        a = Alt_D[o]\n        b = D[o]\n        if o == 0:\n            c = D[N - 1]\n        else:\n            c = D[o - 1]\n        total_angle_area_factor += angle_area_factor(a, b, c)\n        perimeter += b\n    for p in range(Q):\n        (v, t) = [int(q) for q in input().split()]\n        factor = v * t\n        print(Area + perimeter * factor + total_angle_area_factor * factor ** 2)", "import math\nPI = 3.14159265\n\ndef tan_inv(y, x):\n    if x == 0:\n        if y > 0:\n            return PI / 2\n        if y < 0:\n            return 3 * PI / 2\n        else:\n            return 10\n    a = y / x\n    z = a - a ** 3 / 3 + a ** 5 / 5 - a ** 7 / 7 + a ** 9 / 9\n    if x < 0:\n        if a <= 0:\n            return z + PI\n        elif a > 0:\n            return z - PI\n    else:\n        return z\n\ndef dist(x1, y1, x2, y2):\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** (1 / 2)\n\ndef cos_theta(a, b, c):\n    return (b ** 2 + c ** 2 - a ** 2) / (2 * b * c)\n\ndef sin_theta(ct):\n    return (1 - ct ** 2) ** (1 / 2)\n\ndef angle_area_factor(a, b, c):\n    c = cos_theta(a, b, c)\n    s = sin_theta(c)\n    if round(s, 3) == 0:\n        return 0\n    else:\n        return c / s + 1 / s\nT = int(input())\nfor i in range(T):\n    (N, Q) = [int(j) for j in input().split()]\n    c_x = 0\n    c_y = 0\n    X = []\n    Y = []\n    for k in range(N):\n        (x, y) = [int(l) for l in input().split()]\n        X.append(x)\n        Y.append(y)\n        c_x += x\n        c_y += y\n    c_x /= N\n    c_y /= N\n    Tan_Inv = []\n    flag = 0\n    for m in range(N):\n        Tan_Inv.append(math.atan2(Y[m] - c_y, X[m] - c_x))\n    z = zip(Tan_Inv, X, Y)\n    s = sorted(z)\n    s.append(s[0])\n    D = []\n    Alt_D = []\n    Area = 0\n    for n in range(N):\n        if n == 0:\n            w0 = s[N - 1]\n        else:\n            w0 = s[n - 1]\n        w1 = s[n]\n        w2 = s[n + 1]\n        D.append(dist(w1[1], w1[2], w2[1], w2[2]))\n        Area += w1[1] * w2[2] - w2[1] * w1[2]\n        Alt_D.append(dist(w0[1], w0[2], w2[1], w2[2]))\n    Area /= 2\n    perimeter = 0\n    total_angle_area_factor = 0\n    for o in range(N):\n        a = Alt_D[o]\n        b = D[o]\n        if o == 0:\n            c = D[N - 1]\n        else:\n            c = D[o - 1]\n        total_angle_area_factor += angle_area_factor(a, b, c)\n        perimeter += b\n    for p in range(Q):\n        (v, t) = [int(q) for q in input().split()]\n        factor = v * t\n        print(Area + perimeter * factor + total_angle_area_factor * factor ** 2)", "import math\nPI = 3.14159265\n\ndef tan_inv(y, x):\n    if x == 0:\n        if y > 0:\n            return PI / 2\n        if y < 0:\n            return 3 * PI / 2\n        else:\n            return 10\n    a = y / x\n    z = a - a ** 3 / 3 + a ** 5 / 5 - a ** 7 / 7 + a ** 9 / 9\n    if x < 0:\n        if a <= 0:\n            return z + PI\n        elif a > 0:\n            return z - PI\n    else:\n        return z\n\ndef dist(x1, y1, x2, y2):\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** (1 / 2)\n\ndef cos_theta(a, b, c):\n    return (b ** 2 + c ** 2 - a ** 2) / (2 * b * c)\n\ndef sin_theta(ct):\n    return (1 - ct ** 2) ** (1 / 2)\n\ndef angle_area_factor(a, b, c):\n    c = cos_theta(a, b, c)\n    s = sin_theta(c)\n    if round(s, 3) == 0:\n        return 0\n    else:\n        return c / s + 1 / s\nT = int(input())\nfor i in range(T):\n    (N, Q) = [int(j) for j in input().split()]\n    c_x = 0\n    c_y = 0\n    X = []\n    Y = []\n    I = []\n    for k in range(N):\n        (x, y) = [int(l) for l in input().split()]\n        X.append(x)\n        Y.append(y)\n        I.append(k + 1)\n        c_x += x\n        c_y += y\n    c_x /= N\n    c_y /= N\n    Tan_Inv = []\n    flag = 0\n    for m in range(N):\n        u = tan_inv(Y[m] - c_y, X[m] - c_x)\n        if u == 10:\n            flag = 1\n        Tan_Inv.append(math.atan2(Y[m] - c_y, X[m] - c_x))\n    z = zip(Tan_Inv, X, Y, I)\n    s = sorted(z)\n    s.append(s[0])\n    D = []\n    Alt_D = []\n    Area = 0\n    for n in range(N):\n        if n == 0:\n            w0 = s[N - 1]\n        else:\n            w0 = s[n - 1]\n        w1 = s[n]\n        w2 = s[n + 1]\n        D.append(dist(w1[1], w1[2], w2[1], w2[2]))\n        Area += w1[1] * w2[2] - w2[1] * w1[2]\n        Alt_D.append(dist(w0[1], w0[2], w2[1], w2[2]))\n    Area /= 2\n    perimeter = 0\n    total_angle_area_factor = 0\n    for o in range(N):\n        a = Alt_D[o]\n        b = D[o]\n        if o == 0:\n            c = D[N - 1]\n        else:\n            c = D[o - 1]\n        total_angle_area_factor += angle_area_factor(a, b, c)\n        perimeter += b\n    for p in range(Q):\n        if flag:\n            print(Area)\n            continue\n        (v, t) = [int(q) for q in input().split()]\n        factor = v * t\n        print(Area + perimeter * factor + total_angle_area_factor * factor ** 2)", "from math import sin, cos, acos\n\ndef polyArea(x, y):\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))\n\ndef euclideanDistance(A, B):\n    return ((A[0] - B[0]) ** 2 + (A[1] - B[1]) ** 2) ** (1 / 2)\n\ndef angleVertix(O, A, B):\n    module = euclideanDistance(A, O) * euclideanDistance(O, B)\n    scalar = (O[0] - A[0]) * (O[0] - B[0]) + (O[1] - A[1]) * (O[1] - B[1])\n    return acos(scalar / module)\nT = int(input())\nfor _ in range(T):\n    (N, Q) = map(int, input().split())\n    anglesCoeffSum = 0\n    perimeter = 0\n    manualArea = 0\n    vertices = []\n    firstVertix = 0\n    for n in range(N):\n        (x, y) = map(int, input().split())\n        vertices.append([x, y])\n    for i in range(len(vertices)):\n        v = vertices[i]\n        prev = vertices[len(vertices) - 1]\n        adj = vertices[0]\n        if i != len(vertices) - 1:\n            adj = vertices[i + 1]\n        if i != 0:\n            prev = vertices[i - 1]\n        side = euclideanDistance(adj, v)\n        perimeter += side\n        a = angleVertix(v, prev, adj)\n        anglesCoeffSum += 1 / sin(a) * (1 + cos(a))\n        manualArea += v[0] * adj[1] - v[1] * adj[0]\n    for q in range(Q):\n        (t, v) = map(int, input().split())\n        s = t * v\n        print(abs(manualArea) / 2 + perimeter * s + anglesCoeffSum * s ** 2)", "from math import acos, sqrt, tan\nT = int(input())\nr = []\nfor j in range(T):\n    [N, Q] = [int(k) for k in input().split()]\n    x = []\n    y = []\n    for i1 in range(N):\n        x1 = input().split()\n        x.append(int(x1[0]))\n        y.append(int(x1[1]))\n    x = x + [x[0], x[1]]\n    y = y + [y[0], y[1]]\n    a1 = 0\n    ts = 0\n    ta = 0\n    for i in range(N):\n        a1 = a1 + (x[i] * y[i + 1] - x[i + 1] * y[i]) / 2\n        a = sqrt((x[i] - x[i + 1]) ** 2 + (y[i] - y[i + 1]) ** 2)\n        b = sqrt((x[i + 2] - x[i + 1]) ** 2 + (y[i + 2] - y[i + 1]) ** 2)\n        dp = (x[i] - x[i + 1]) * (x[i + 2] - x[i + 1]) + (y[i] - y[i + 1]) * (y[i + 2] - y[i + 1])\n        th = acos(dp / (a * b))\n        ts = ts + a\n        ta = ta + 1 / tan(th / 2)\n    for i1 in range(Q):\n        x1 = input().split()\n        vt = int(x1[0]) * int(x1[1])\n        r.append(vt * vt * ta + vt * ts + a1)\nfor res in r:\n    print(res)", "from math import tan, acos, sqrt\n\ndef dist(p, q):\n    return sqrt(sum(((px - qx) ** 2.0 for (px, qx) in zip(p, q))))\n\ndef func(points):\n    (x1, y1) = points[0]\n    (x2, y2) = points[1]\n    (x3, y3) = points[2]\n    return 1 / tan(acos(((x3 - x2) * (x1 - x2) + (y3 - y2) * (y1 - y2)) / dist((x1, y1), (x2, y2)) / dist((x3, y3), (x2, y2))) / 2)\nt = int(input())\nfor _ in range(t):\n    (n, q) = (int(x) for x in input().split())\n    points = [tuple((int(x) for x in input().split())) for _ in range(n)]\n    cross = lambda a, b: a[0] * b[1] - b[0] * a[1]\n    (lensum, area) = (dist(points[0], points[-1]), cross(points[-1], points[0]))\n    for i in range(n - 1):\n        lensum += dist(points[i + 1], points[i])\n        area += cross(points[i], points[i + 1])\n    cotanglesum = func((points[0], points[-1], points[-2])) + func((points[-1], points[0], points[1]))\n    area = abs(area) / 2\n    for i in range(n - 2):\n        cotanglesum += func((points[i], points[i + 1], points[i + 2]))\n    for _ in range(q):\n        (v, t) = (int(x) for x in input().split())\n        k = v * t\n        print(area + k * lensum + k * k * cotanglesum)", "import math\n\ndef getTangentOfExternalAngle(x1, y1, x0, y0, x2, y2):\n    cosTheta = ((x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)) / math.sqrt(((x1 - x0) ** 2 + (y1 - y0) ** 2) * ((x2 - x0) ** 2 + (y2 - y0) ** 2))\n    tanTheta = math.sqrt((cosTheta + 1) / (1 - cosTheta))\n    return tanTheta\n\ndef getAreaByCoordinates(x, y, n):\n    area = 0\n    for i in range(0, n - 1):\n        area += x[i] * y[i + 1] - x[i + 1] * y[i]\n    area += x[n - 1] * y[0] - x[0] * y[n - 1]\n    area *= 0.5\n    return area\n\ndef getTraversedArea(x, y, q, n, n_q, debug=False):\n    sides = []\n    sumOfSides = 0\n    for i in range(0, n):\n        side = math.sqrt((x[(i + 1) % n] - x[i]) ** 2 + (y[(i + 1) % n] - y[i]) ** 2)\n        sides.append(side)\n        sumOfSides += side\n    tangets = []\n    sumOfTangents = 0\n    for i in range(0, n):\n        tani = getTangentOfExternalAngle(x[(i - 1) % n], y[(i - 1) % n], x[i], y[i], x[(i + 1) % n], y[(i + 1) % n])\n        tangets.append(tani)\n        sumOfTangents += tani\n    firstArea = getAreaByCoordinates(x, y, n)\n    if debug:\n        print('Sides: ', sides)\n        print('Tangents: ', tangets)\n    for i in range(n_q):\n        (v, t) = q[i]\n        d = v * t\n        area = firstArea + d ** 2 * sumOfTangents + d * sumOfSides\n        print('%.7f' % area)\n\ndef main():\n    for _ in range(int(input())):\n        (n, n_q) = map(int, input().split())\n        x = [0] * n\n        y = [0] * n\n        q = [0] * n_q\n        for i in range(n):\n            (xi, yi) = map(int, input().split())\n            x[i] = xi\n            y[i] = yi\n        for i in range(n_q):\n            (v, t) = map(int, input().split())\n            q[i] = (v, t)\n        getTraversedArea(x, y, q, n, n_q)\nmain()", "def area(vertices, n):\n    area = 0.0\n    j = n - 1\n    for i in range(0, n):\n        area += (vertices[j][0] + vertices[i][0]) * (vertices[j][1] - vertices[i][1])\n        j = i\n    return abs(area / 2.0)\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    vertices = []\n    for i in range(n):\n        vertices.append(list(map(int, input().split())))\n    original_area = area(vertices, n)\n    cot_sum = 0\n    perimeter = 0\n    for i in range(n):\n        x1 = vertices[i][0]\n        y1 = vertices[i][1]\n        x2 = vertices[(i + 1) % n][0]\n        y2 = vertices[(i + 1) % n][1]\n        x3 = vertices[(i + 2) % n][0]\n        y3 = vertices[(i + 2) % n][1]\n        a = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n        perimeter += a\n        b = ((x3 - x2) ** 2 + (y3 - y2) ** 2) ** 0.5\n        c = ((x3 - x1) ** 2 + (y3 - y1) ** 2) ** 0.5\n        cosine = (a ** 2 + b ** 2 - c ** 2) / (2 * a * b)\n        cot_sum += ((1 + cosine) / (1 - cosine)) ** 0.5\n    for i in range(q):\n        ans = original_area\n        (v, t) = map(int, input().split())\n        d = v * t\n        ans += cot_sum * d ** 2 + perimeter * d\n        print(ans)", "from math import pi, sqrt, acos, sin, tan\n\ndef angle(v1, v2):\n    a = acos((v1[0] * v2[0] + v1[1] * v2[1]) / (sqrt(v1[0] ** 2 + v1[1] ** 2) * sqrt(v2[0] ** 2 + v2[1] ** 2)))\n    return a\n\ndef distance(x1, y1, x2, y2):\n    return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    (X, Y) = ([], [])\n    for _ in range(n):\n        (xi, yi) = map(int, input().split())\n        X.append(xi)\n        Y.append(yi)\n    (area, perimeter, inc_factor) = (0, 0, 0)\n    j = n - 1\n    for i in range(n):\n        (vi, vj) = ([X[i] - X[i - 1], Y[i] - Y[i - 1]], [X[i] - X[(i + 1) % n], Y[i] - Y[(i + 1) % n]])\n        theta = angle(vi, vj)\n        inc_factor += 1 / sin(theta) + 1 * tan(pi / 2 - theta)\n        perimeter += distance(X[i], Y[i], X[(i + 1) % n], Y[(i + 1) % n])\n        area += (X[j] + X[i]) * (Y[j] - Y[i])\n        j = i\n    area = abs(area / 2)\n    for _ in range(q):\n        (vi, ti) = map(int, input().split())\n        dis = vi * ti\n        res = area + perimeter * dis + dis * dis * inc_factor\n        print(res)", "from math import pi, sqrt, acos, sin, cos, tan\n\ndef angle(v1, v2):\n    a = acos((v1[0] * v2[0] + v1[1] * v2[1]) / (sqrt(v1[0] ** 2 + v1[1] ** 2) * sqrt(v2[0] ** 2 + v2[1] ** 2)))\n    return a\n\ndef increase(theta):\n    return 1 / sin(theta) + 1 * tan(pi / 2 - theta)\n\ndef distance(x1, y1, x2, y2):\n    return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    (X, Y) = ([], [])\n    for _ in range(n):\n        (xi, yi) = map(int, input().split())\n        X.append(xi)\n        Y.append(yi)\n    area = 0\n    j = n - 1\n    for i in range(0, n):\n        area += (X[j] + X[i]) * (Y[j] - Y[i])\n        j = i\n    area = abs(area / 2)\n    perimeter = 0\n    for i in range(n):\n        perimeter += distance(X[i], Y[i], X[(i + 1) % n], Y[(i + 1) % n])\n    angles = []\n    for i in range(n):\n        vector1 = [X[i] - X[i - 1], Y[i] - Y[i - 1]]\n        vector2 = [X[i] - X[(i + 1) % n], Y[i] - Y[(i + 1) % n]]\n        angles.append(angle(vector1, vector2))\n    inc_factor = 0\n    for i in range(n):\n        inc_factor += increase(angles[i]) + increase(angles[(i + 1) % n])\n    for _ in range(q):\n        (vi, ti) = map(int, input().split())\n        dis = vi * ti\n        res = area + perimeter * dis + 0.5 * dis * dis * inc_factor\n        print(res)", "from sys import stdin, stdout\n\ndef findDistance(x, y):\n    return math.sqrt(sum([(a - b) ** 2 for (a, b) in zip(x, y)]))\n\ndef areaOfTrapezoid(h, sum1, sum2):\n    return 1 * sum1 * h + h * h * sum2\n\ndef polygonArea(X, Y, n):\n    area = 0.0\n    j = n - 1\n    for i in range(0, n):\n        area += (X[j] + X[i]) * (Y[j] - Y[i])\n        j = i\n    return abs(area / 2.0)\nimport math\n\ndef lengthSquare(X, Y):\n    xDiff = X[0] - Y[0]\n    yDiff = X[1] - Y[1]\n    return xDiff * xDiff + yDiff * yDiff\n\ndef returnAngles(A, B, C):\n    a2 = lengthSquare(B, C)\n    b2 = lengthSquare(A, C)\n    c2 = lengthSquare(A, B)\n    a = math.sqrt(a2)\n    b = math.sqrt(b2)\n    c = math.sqrt(c2)\n    alpha = math.acos((b2 + c2 - a2) / (2 * b * c))\n    betta = math.acos((a2 + c2 - b2) / (2 * a * c))\n    gamma = math.acos((a2 + b2 - c2) / (2 * a * b))\n    return [alpha, betta, gamma]\n\ndef find_Centroid(v):\n    ans = [0, 0]\n    n = len(v)\n    signedArea = 0\n    for i in range(len(v)):\n        x0 = v[i][0]\n        y0 = v[i][1]\n        x1 = v[(i + 1) % n][0]\n        y1 = v[(i + 1) % n][1]\n        A = x0 * y1 - x1 * y0\n        signedArea += A\n        ans[0] += (x0 + x1) * A\n        ans[1] += (y0 + y1) * A\n    signedArea *= 0.5\n    ans[0] = ans[0] / (6 * signedArea)\n    ans[1] = ans[1] / (6 * signedArea)\n    return ans\nt = int(stdin.readline().strip())\nfor _ in range(t):\n    (n, q) = list(map(int, stdin.readline().strip().split()))\n    vertices = list()\n    vertexX = list()\n    vertexY = list()\n    for _ in range(n):\n        vertex = list(map(int, stdin.readline().strip().split()))\n        vertexX.append(vertex[0])\n        vertexY.append(vertex[1])\n        vertices.append(vertex)\n    centroid = find_Centroid(vertices)\n    angles = list()\n    angles1 = list()\n    distances = list()\n    sum1 = 0\n    sum2 = 0\n    area = polygonArea(vertexX, vertexY, n)\n    for i in range(n):\n        (a, b, c) = (i - 1, i, i + 1)\n        if i == 0:\n            a = n - 1\n        elif i == n - 1:\n            c = 0\n        temp11 = returnAngles(vertices[a], vertices[b], vertices[c])\n        angles1.append(temp11[1])\n    for i in range(n):\n        if i == n - 1:\n            y = 0\n        else:\n            y = i + 1\n        temp1 = returnAngles(vertices[i], vertices[y], centroid)\n        temp2 = findDistance(vertices[i], vertices[y])\n        angles.append(temp1)\n        distances.append(temp2)\n    for i in range(n):\n        sum1 = sum1 + distances[i]\n        sum2 = sum2 + 1 / math.tan(angles1[i] / 2)\n    for _ in range(q):\n        (v, t) = list(map(int, stdin.readline().strip().split()))\n        area1 = area + areaOfTrapezoid(v * t, sum1, sum2)\n        print(area1)", "def distance(x1, y1, x2, y2):\n    ans = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    ans = ans ** 0.5\n    return ans\n\ndef cosine(x1, y1, x2, y2, x3, y3):\n    a = distance(x1, y1, x2, y2)\n    b = distance(x3, y3, x2, y2)\n    c = distance(x1, y1, x3, y3)\n    ans = a * a + b * b - c * c\n    ans /= 2 * a * b\n    return ans\n\ndef cothalf(x1, y1, x2, y2, x3, y3):\n    cos = (cosine(x1, y1, x2, y2, x3, y3) + 1) / 2\n    sin = 1 - cos\n    ans = cos / sin\n    ans = ans ** 0.5\n    return ans\n\ndef cotsum(x, y, n):\n    ans = 0\n    for i in range(n - 2):\n        ans += cothalf(x[i], y[i], x[i + 1], y[i + 1], x[i + 2], y[i + 2])\n    ans += cothalf(x[n - 2], y[n - 2], x[n - 1], y[n - 1], x[0], y[0])\n    ans += cothalf(x[n - 1], y[n - 1], x[0], y[0], x[1], y[1])\n    return ans\n\ndef perimeter(x, y, n):\n    ans = 0\n    for i in range(n - 1):\n        ans += distance(x[i], y[i], x[i + 1], y[i + 1])\n    ans += distance(x[0], y[0], x[n - 1], y[n - 1])\n    return ans\n\ndef area(x, y, n):\n    ans = 0\n    for i in range(n - 1):\n        ans += x[i] * y[i + 1] - y[i] * x[i + 1]\n    ans += x[n - 1] * y[0] - y[n - 1] * x[0]\n    ans /= 2\n    if ans < 0:\n        ans = -ans\n    return ans\nt = int(input())\nfor zz in range(t):\n    nq = list(map(int, input().split()))\n    n = nq[0]\n    q = nq[1]\n    x = []\n    y = []\n    for i in range(n):\n        ttt = list(map(int, input().split()))\n        x.append(ttt[0])\n        y.append(ttt[1])\n    ar = area(x, y, n)\n    p = perimeter(x, y, n)\n    cs = cotsum(x, y, n)\n    for i in range(q):\n        vt = list(map(int, input().split()))\n        s = vt[0] * vt[1]\n        ar += s * p + s * s * cs\n        print(ar)\n        ar -= s * p + s * s * cs", "import math\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    xy = []\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        xy.append((x, y))\n    p = 0\n    cot = 0\n    for i in range(n):\n        (x1, y1) = xy[i]\n        (x2, y2) = xy[(i + 1) % n]\n        (x3, y3) = xy[(i + 2) % n]\n        a = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n        b = ((x3 - x2) ** 2 + (y3 - y2) ** 2) ** 0.5\n        c = ((x1 - x3) ** 2 + (y1 - y3) ** 2) ** 0.5\n        p += a\n        p = p\n        cos = (a ** 2 + b ** 2 - c ** 2) / (2 * a * b)\n        cot += ((1 + cos) / (1 - cos)) ** 0.5\n        cot = cot\n    ians = 0.0\n    j = n - 1\n    for i in range(0, n):\n        ians += (xy[j][0] + xy[i][0]) * (xy[j][1] - xy[i][1])\n        j = i\n    ians = abs(ians / 2.0)\n    for i in range(q):\n        ans = ians\n        (v, t) = map(int, input().split())\n        z = v * t\n        ans += z * p\n        ans = ans + z * z * cot\n        print(ans)", "import numpy as np\nimport sys\nimport time\nstart_time = time.time()\ntry:\n    sys.stdin = open('input.txt', 'r')\nexcept:\n    pass\ninput = sys.stdin.readline\n\ndef area(x, y):\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))\n\ndef angle(b):\n    a = np.roll(b, -1, axis=0)\n    c = np.roll(b, 1, axis=0)\n    return np.arctan2(c[:, 1] - b[:, 1], c[:, 0] - b[:, 0]) - np.arctan2(a[:, 1] - b[:, 1], a[:, 0] - b[:, 0])\n\ndef dist(p):\n    return np.sqrt(((p - np.roll(p, 1, axis=0)) ** 2).sum(axis=1))\nT = int(input())\nfor _ in range(T):\n    (n, q) = map(int, input().split())\n    p = np.ndarray((n, 2), dtype=np.float64)\n    for i in range(n):\n        p[i] = tuple(map(int, input().split()))\n    a = area(*zip(*p))\n    l = np.abs(1 / np.tan(angle(p) / 2)).sum()\n    d = np.abs(dist(p)).sum()\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        print((v * t) ** 2 * l + v * t * d + a)", "import math\n\ndef get_init_area(vertices):\n    (res, length) = (0, len(vertices))\n    for i in range(0, length):\n        res += (vertices[i][0] + vertices[(i + 1) % length][0]) * (vertices[(i + 1) % length][1] - vertices[i][1])\n    return abs(res) / 2\n\ndef get_sides(vertices):\n    (sides, length) = ([], len(vertices))\n    for i in range(0, length):\n        y = vertices[(i + 1) % length][1] - vertices[i][1]\n        x = vertices[(i + 1) % length][0] - vertices[i][0]\n        sides.append(math.sqrt(y ** 2 + x ** 2))\n    return sides\n\ndef get_slopes(vertices):\n    (slopes, length) = ([], len(vertices))\n    for i in range(0, length):\n        y = vertices[(i + 1) % length][1] - vertices[i][1]\n        x = vertices[(i + 1) % length][0] - vertices[i][0]\n        slopes.append([x, y])\n    return slopes\n\ndef get_angles(slopes):\n    (angles, length) = ([], len(slopes))\n    for i in range(0, length):\n        num = slopes[i][1] * slopes[(i + 1) % length][0] - slopes[(i + 1) % length][1] * slopes[i][0]\n        den = slopes[i][0] * slopes[(i + 1) % length][0] + slopes[i][1] * slopes[(i + 1) % length][1]\n        if den == 0:\n            angles.append(math.pi / 2)\n        else:\n            angle = math.atan(num / den)\n            if angle < 0:\n                angle += math.pi\n            angles.append(angle)\n    return angles\n\ndef get_tan_sum(angles):\n    res = 0\n    for angle in angles:\n        res += math.cos(angle / 2) / math.sin(angle / 2)\n    return res\n\ndef print_angles(angles):\n    new_angles = []\n    for angle in angles:\n        new_angles.append(math.degrees(angle))\n    print(new_angles)\n    print('angle sum: ', sum(new_angles))\nT = int(input())\nfor i in range(0, T):\n    inp = list(map(int, input().split()))\n    (N, Q) = (inp[0], inp[1])\n    vertices = []\n    for j in range(0, N):\n        vertices.append(list(map(int, input().split())))\n    area = get_init_area(vertices)\n    sides = get_sides(vertices)\n    slopes = get_slopes(vertices)\n    angles = get_angles(slopes)\n    perimeter = sum(sides)\n    tan_sum = get_tan_sum(angles)\n    for j in range(0, Q):\n        inp = list(map(int, input().split()))\n        d = inp[0] * inp[1]\n        res_area = area\n        res_area += perimeter * d\n        res_area += d ** 2 * tan_sum\n        print('{0:.7f}'.format(res_area))", "import math\n\ndef get_init_area(vertices):\n    (res, length) = (0, len(vertices))\n    for i in range(0, length):\n        res += (vertices[i][0] + vertices[(i + 1) % length][0]) * (vertices[(i + 1) % length][1] - vertices[i][1])\n    return abs(res) / 2\n\ndef get_sides(vertices):\n    (sides, length) = ([], len(vertices))\n    for i in range(0, length):\n        y = vertices[(i + 1) % length][1] - vertices[i][1]\n        x = vertices[(i + 1) % length][0] - vertices[i][0]\n        sides.append(math.sqrt(y ** 2 + x ** 2))\n    return sides\n\ndef get_slopes(vertices):\n    (slopes, length) = ([], len(vertices))\n    for i in range(0, length):\n        y = vertices[(i + 1) % length][1] - vertices[i][1]\n        x = vertices[(i + 1) % length][0] - vertices[i][0]\n        slopes.append([x, y])\n    return slopes\n\ndef get_angles(slopes):\n    (angles, length) = ([], len(slopes))\n    for i in range(0, length):\n        num = slopes[i][1] * slopes[(i + 1) % length][0] - slopes[(i + 1) % length][1] * slopes[i][0]\n        den = slopes[i][0] * slopes[(i + 1) % length][0] + slopes[i][1] * slopes[(i + 1) % length][1]\n        if den == 0:\n            angles.append(math.pi / 2)\n        else:\n            angle = math.atan(num / den)\n            if angle < 0:\n                angle += math.pi\n            angles.append(angle)\n    return angles\n\ndef get_tan_sum(angles):\n    res = 0\n    for angle in angles:\n        res += math.cos(angle / 2) / math.sin(angle / 2)\n    return res\n\ndef print_angles(angles):\n    new_angles = []\n    for angle in angles:\n        new_angles.append(math.degrees(angle))\n    print(new_angles)\n    print('angle sum: ', sum(new_angles))\nT = int(input())\nfor i in range(0, T):\n    inp = list(map(int, input().split()))\n    (N, Q) = (inp[0], inp[1])\n    vertices = []\n    for j in range(0, N):\n        vertices.append(list(map(int, input().split())))\n    area = get_init_area(vertices)\n    sides = get_sides(vertices)\n    slopes = get_slopes(vertices)\n    angles = get_angles(slopes)\n    perimeter = sum(sides)\n    tan_sum = get_tan_sum(angles)\n    for j in range(0, Q):\n        inp = list(map(int, input().split()))\n        d = inp[0] * inp[1]\n        res_area = area\n        res_area += perimeter * d\n        res_area += d ** 2 * tan_sum\n        print('{0:.7f}'.format(res_area))", "from decimal import *\nfrom math import *\nimport sys\ngetcontext().prec = 16\nMAXN = 10005\ncoordX = [Decimal(0)] * MAXN\ncoordY = [Decimal(0)] * MAXN\nvectrX = [Decimal(0)] * MAXN\nvectrY = [Decimal(0)] * MAXN\nlenSides = [Decimal(0)] * MAXN\nTestcases = int(input())\nfor i in range(Testcases):\n    (N, Q) = map(int, input().split())\n    sumSides = Decimal(0)\n    sumCot = Decimal(0)\n    for i in range(N):\n        (coordX[i], coordY[i]) = map(Decimal, input().split())\n    area = Decimal(0)\n    for i in range(N):\n        h = coordX[(i + 1) % N] - coordX[i]\n        b = coordY[(i + 1) % N] + coordY[i]\n        area = area + h * b\n        dx = coordX[(i + 1) % N] - coordX[i]\n        dy = coordY[(i + 1) % N] - coordY[i]\n        lenSides[i] = (dx * dx + dy * dy).sqrt()\n        sumSides = sumSides + lenSides[i]\n        vectrX[i] = dx\n        vectrY[i] = dy\n    for i in range(N):\n        prod = vectrX[i] * vectrX[(i + 1) % N] + vectrY[i] * vectrY[(i + 1) % N]\n        prodEsc = Decimal(prod) / Decimal(lenSides[i])\n        cosAng = Decimal(prodEsc) / Decimal(lenSides[(i + 1) % N])\n        cotMid = Decimal(Decimal(1) - cosAng) / Decimal(Decimal(1) + cosAng)\n        cotMid = Decimal(cotMid).sqrt()\n        sumCot = sumCot + cotMid\n    if area < 0:\n        area = -area\n    area = area / 2\n    for q in range(Q):\n        (v, t) = map(Decimal, input().split())\n        ans = area + v * t * sumSides + v * v * t * t * sumCot\n        print(ans)", "from heapq import heapify, heappush, heappop\nfrom decimal import *\ngetcontext().prec = 19\n\ndef dif(b, a):\n    return (b[0] - a[0], b[1] - a[1])\n\ndef cosprod(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef sinprod(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef norm(a):\n    return Decimal.sqrt(a[0] * a[0] + a[1] * a[1])\n\ndef get_sum(pq):\n    heapify(pq)\n    while len(pq) > 1:\n        heappush(pq, heappop(pq) + heappop(pq))\n    return heappop(pq)\nfor tcase in range(int(input())):\n    (n, q) = map(int, input().split())\n    vertex = [tuple(map(Decimal, input().split()))]\n    side = []\n    sidelen = []\n    for i in range(1, n):\n        vertex.append(tuple(map(Decimal, input().split())))\n        s = dif(vertex[i], vertex[i - 1])\n        side.append(s)\n        sidelen.append(norm(s))\n    vertex.append(vertex[0])\n    side.append(dif(vertex[n], vertex[n - 1]))\n    sidelen.append(norm(side[n - 1]))\n    side.append(side[0])\n    sidelen.append(sidelen[0])\n    perimeter = 0\n    sum_tan_half_ext_ang = 0\n    for i in range(1, n + 1):\n        cop = cosprod(side[i - 1], side[i])\n        sip = sinprod(side[i - 1], side[i])\n        rec = sidelen[i - 1] * sidelen[i]\n        perimeter += sidelen[i]\n        if cop > 0:\n            sum_tan_half_ext_ang += sip / (rec + cop)\n        else:\n            sum_tan_half_ext_ang += (rec - cop) / sip\n    area = 0\n    for i in range(1, n - 1):\n        area += sinprod(side[i], dif(vertex[n], vertex[i]))\n    area /= 2\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        height = v * t\n        sum_medians = perimeter + sum_tan_half_ext_ang * height\n        result = area + sum_medians * height\n        print('{:.3f}'.format(result))", "from heapq import heapify, heappush, heappop\nfrom decimal import *\ngetcontext().prec = 19\n\ndef dif(b, a):\n    return (b[0] - a[0], b[1] - a[1])\n\ndef cosprod(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef sinprod(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef norm(a):\n    return Decimal.sqrt(a[0] * a[0] + a[1] * a[1])\n\ndef get_sum(pq):\n    heapify(pq)\n    while len(pq) > 1:\n        heappush(pq, heappop(pq) + heappop(pq))\n    return heappop(pq)\nfor tcase in range(int(input())):\n    (n, q) = map(int, input().split())\n    vertex = [tuple(map(Decimal, input().split())) for i in range(n)]\n    vertex.append(vertex[0])\n    side = [dif(vertex[i + 1], vertex[i]) for i in range(n)]\n    side.append(side[0])\n    sidelen = [norm(side[i]) for i in range(n + 1)]\n    perimeter = 0\n    sum_tan_half_ext_ang = 0\n    for i in range(1, n + 1):\n        cop = cosprod(side[i - 1], side[i])\n        sip = sinprod(side[i - 1], side[i])\n        rec = sidelen[i - 1] * sidelen[i]\n        perimeter += sidelen[i]\n        sum_tan_half_ext_ang += sip / (rec + cop)\n    area = 0\n    for i in range(1, n - 1):\n        area += sinprod(side[i], dif(vertex[n], vertex[i]))\n    area /= 2\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        height = v * t\n        sum_medians = perimeter + sum_tan_half_ext_ang * height\n        result = area + sum_medians * height\n        print('{:.3f}'.format(result))", "from heapq import heapify, heappush, heappop\nfrom decimal import *\ngetcontext().prec = 18\n\ndef dif(b, a):\n    return (b[0] - a[0], b[1] - a[1])\n\ndef cosprod(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef sinprod(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef norm(a):\n    return Decimal.sqrt(a[0] * a[0] + a[1] * a[1])\n\ndef get_sum(pq):\n    heapify(pq)\n    while len(pq) > 1:\n        heappush(pq, heappop(pq) + heappop(pq))\n    return heappop(pq)\nfor tcase in range(int(input())):\n    (n, q) = map(int, input().split())\n    vertex = [tuple(map(Decimal, input().split())) for i in range(n)]\n    vertex.append(vertex[0])\n    side = [dif(vertex[i + 1], vertex[i]) for i in range(n)]\n    side.append(side[0])\n    sidelen = [norm(side[i]) for i in range(n + 1)]\n    perimeter = 0\n    sum_tan_half_ext_ang = 0\n    for i in range(1, n + 1):\n        cop = cosprod(side[i - 1], side[i])\n        sip = sinprod(side[i - 1], side[i])\n        rec = sidelen[i - 1] * sidelen[i]\n        perimeter += sidelen[i]\n        sum_tan_half_ext_ang += sip / (rec + cop)\n    area = 0\n    for i in range(1, n - 1):\n        area += sinprod(side[i], dif(vertex[n], vertex[i]))\n    area /= 2\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        height = v * t\n        sum_medians = perimeter + sum_tan_half_ext_ang * height\n        result = area + sum_medians * height\n        print('{:.3f}'.format(result))", "from heapq import heapify, heappush, heappop\nfrom math import sqrt\nfrom decimal import *\n\ndef dif(b, a):\n    return (b[0] - a[0], b[1] - a[1])\n\ndef cosprod(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef sinprod(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef normsqr(a):\n    return cosprod(a, a)\n\ndef get_sum(pq):\n    heapify(pq)\n    while len(pq) > 1:\n        heappush(pq, heappop(pq) + heappop(pq))\n    return heappop(pq)\nfor tcase in range(int(input())):\n    (n, q) = map(int, input().split())\n    vertex = [None] + [tuple(map(int, input().split())) for i in range(n)]\n    vertex[0] = vertex[n]\n    side = [dif(vertex[i + 1], vertex[i]) for i in range(n)]\n    side.append(side[0])\n    sidelensqr = [normsqr(side[i]) for i in range(n + 1)]\n    perimeter = get_sum([sqrt(sidelensqr[i]) for i in range(1, n + 1)])\n    pq = []\n    for i in range(1, n + 1):\n        cop = cosprod(side[i - 1], side[i])\n        sip = sinprod(side[i - 1], side[i])\n        rec = sqrt(Decimal(normsqr(side[i - 1]) * normsqr(side[i])))\n        co = cop / rec\n        si = sip / rec\n        if co > 0.0:\n            pq.append(si / (1.0 + co))\n        else:\n            pq.append((1.0 - co) / si)\n    sum_tan_half_ext_ang = get_sum(pq)\n    area = sum((sinprod(side[i], dif(vertex[n], vertex[i])) for i in range(1, n - 1))) / 2.0\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        height = v * t\n        result = get_sum([area, perimeter * height, sum_tan_half_ext_ang * height * height])\n        print('{:.3f}'.format(result))", "from heapq import heapify, heappush, heappop\nfrom math import sqrt\n\ndef dif(b, a):\n    return (b[0] - a[0], b[1] - a[1])\n\ndef cosprod(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef sinprod(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef normsqr(a):\n    return cosprod(a, a)\n\ndef get_sum(pq):\n    heapify(pq)\n    while len(pq) > 1:\n        heappush(pq, heappop(pq) + heappop(pq))\n    return heappop(pq)\nfor tcase in range(int(input())):\n    (n, q) = map(int, input().split())\n    vertex = [None] + [tuple(map(int, input().split())) for i in range(n)]\n    vertex[0] = vertex[n]\n    side = [dif(vertex[i + 1], vertex[i]) for i in range(n)]\n    side.append(side[0])\n    sidelensqr = [normsqr(side[i]) for i in range(n + 1)]\n    perimeter = get_sum([sqrt(sidelensqr[i]) for i in range(1, n + 1)])\n    pq = []\n    for i in range(1, n + 1):\n        cop = cosprod(side[i - 1], side[i])\n        sip = sinprod(side[i - 1], side[i])\n        rec = sqrt(normsqr(side[i - 1]) * normsqr(side[i]))\n        if cop > 0.0:\n            pq.append(sip / (rec + cop))\n        else:\n            pq.append((rec - cop) / sip)\n    sum_tan_half_ext_ang = get_sum(pq)\n    area = sum((sinprod(side[i], dif(vertex[n], vertex[i])) for i in range(1, n - 1))) / 2.0\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        height = v * t\n        result = get_sum([area, perimeter * height, sum_tan_half_ext_ang * height * height])\n        print('{:.3f}'.format(result))", "from heapq import heapify, heappush, heappop\nfrom math import sqrt\n\ndef dif(b, a):\n    return (b[0] - a[0], b[1] - a[1])\n\ndef cosprod(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef sinprod(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef normsqr(a):\n    return cosprod(a, a)\n\ndef get_sum(pq):\n    heapify(pq)\n    while len(pq) > 1:\n        heappush(pq, heappop(pq) + heappop(pq))\n    return heappop(pq)\nfor tcase in range(int(input())):\n    (n, q) = map(int, input().split())\n    vertex = [None] + [tuple(map(int, input().split())) for i in range(n)]\n    vertex[0] = vertex[n]\n    side = [dif(vertex[i + 1], vertex[i]) for i in range(n)]\n    side.append(side[0])\n    sidelensqr = [normsqr(side[i]) for i in range(n + 1)]\n    perimeter = get_sum([sqrt(sidelensqr[i]) for i in range(1, n + 1)])\n    pq = []\n    for i in range(1, n + 1):\n        cop = cosprod(side[i - 1], side[i])\n        sip = sinprod(side[i - 1], side[i])\n        rec = sqrt(normsqr(side[i - 1]) * normsqr(side[i]))\n        if cop > 0.0:\n            pq.append(sip / (rec + cop))\n        else:\n            pq.append((rec - cop) / sip)\n    sum_tan_half_ext_ang = get_sum(pq)\n    area = sum((sinprod(side[i], dif(vertex[n], vertex[i])) for i in range(1, n - 1))) / 2.0\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        height = v * t\n        sum_medians = perimeter + sum_tan_half_ext_ang * height\n        result = area + sum_medians * height\n        print('{:.3f}'.format(result))", "from heapq import heapify, heappush, heappop\nfrom math import sqrt\n\ndef dif(b, a):\n    return (b[0] - a[0], b[1] - a[1])\n\ndef cosprod(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef sinprod(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef normsqr(a):\n    return cosprod(a, a)\n\ndef get_sum(pq):\n    heapify(pq)\n    while len(pq) > 1:\n        heappush(pq, heappop(pq) + heappop(pq))\n    return heappop(pq)\nfor tcase in range(int(input())):\n    (n, q) = map(int, input().split())\n    vertex = [None] + [tuple(map(int, input().split())) for i in range(n)]\n    vertex[0] = vertex[n]\n    side = [dif(vertex[i + 1], vertex[i]) for i in range(n)]\n    side.append(side[0])\n    sidelensqr = [normsqr(side[i]) for i in range(n + 1)]\n    perimeter = get_sum([sqrt(sidelensqr[i]) for i in range(1, n + 1)])\n    pq = []\n    for i in range(1, n + 1):\n        cop = cosprod(side[i - 1], side[i])\n        sip = sinprod(side[i - 1], side[i])\n        rec = sqrt(normsqr(side[i - 1]) * normsqr(side[i]))\n        co = cop / rec\n        si = sip / rec\n        if co < 0.0:\n            pq.append(si / (1.0 + co))\n        else:\n            pq.append((1.0 - co) / si)\n    sum_tan_half_ext_ang = get_sum(pq)\n    area = sum((sinprod(side[i], dif(vertex[n], vertex[i])) for i in range(1, n - 1))) / 2.0\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        height = v * t\n        sum_medians = perimeter + sum_tan_half_ext_ang * height\n        result = area + sum_medians * height\n        print('{:.3f}'.format(result))", "from heapq import heapify, heappush, heappop\nfrom math import sqrt\n\ndef dif(b, a):\n    return (b[0] - a[0], b[1] - a[1])\n\ndef cosprod(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef sinprod(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef normsqr(a):\n    return cosprod(a, a)\n\ndef get_sum(pq):\n    heapify(pq)\n    while len(pq) > 1:\n        heappush(pq, heappop(pq) + heappop(pq))\n    return heappop(pq)\nfor tcase in range(int(input())):\n    (n, q) = map(int, input().split())\n    vertex = [None] + [tuple(map(int, input().split())) for i in range(n)]\n    vertex[0] = vertex[n]\n    side = [dif(vertex[i + 1], vertex[i]) for i in range(n)]\n    side.append(side[0])\n    sidelensqr = [normsqr(side[i]) for i in range(n + 1)]\n    perimeter = get_sum([sqrt(sidelensqr[i]) for i in range(1, n + 1)])\n    pq = []\n    for i in range(1, n + 1):\n        cop = cosprod(side[i - 1], side[i])\n        sip = sinprod(side[i - 1], side[i])\n        rec = sqrt(normsqr(side[i - 1]) * normsqr(side[i]))\n        co = cop / rec\n        si = sip / rec\n        if co > 0.0:\n            pq.append(si / (1.0 + co))\n        else:\n            pq.append((1.0 - co) / si)\n    sum_tan_half_ext_ang = get_sum(pq)\n    area = sum((sinprod(side[i], dif(vertex[n], vertex[i])) for i in range(1, n - 1))) / 2.0\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        height = v * t\n        sum_medians = perimeter + sum_tan_half_ext_ang * height\n        result = area + sum_medians * height\n        print('{:.3f}'.format(result))", "from math import sqrt, acos, tan\n\ndef sidelen(A, B):\n    return sqrt((A[0] - B[0]) ** 2 + (A[1] - B[1]) ** 2)\nT = int(input())\nfor _ in range(T):\n    (N, Q) = map(int, input().split())\n    v = []\n    for _ in range(N):\n        (x, y) = map(int, input().split())\n        v.append((x, y))\n    v.append(v[0])\n    v.append(v[1])\n    base_area = 0\n    perimeter = 0\n    for i in range(N):\n        base_area += v[i][0] * v[i + 1][1] - v[i][1] * v[i + 1][0]\n        perimeter += sidelen(v[i], v[i + 1])\n    base_area = abs(base_area)\n    base_area = base_area / 2\n    anglesum = 0\n    for i in range(N):\n        a = sidelen(v[i], v[i + 1])\n        b = sidelen(v[i + 1], v[i + 2])\n        c = sidelen(v[i + 2], v[i])\n        beta = acos((a ** 2 + b ** 2 - c ** 2) / (2 * a * b))\n        anglesum += 1 / tan(beta / 2)\n    for j in range(Q):\n        (v, t) = map(int, input().split())\n        print(base_area + v * t * perimeter + (v * t) ** 2 * anglesum)", "from heapq import heapify, heappush, heappop\nfrom math import sqrt\n\ndef dif(b, a):\n    return (b[0] - a[0], b[1] - a[1])\n\ndef cosprod(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef sinprod(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef normsqr(a):\n    return cosprod(a, a)\n\ndef get_sum(pq):\n    heapify(pq)\n    while len(pq) > 1:\n        heappush(pq, heappop(pq) + heappop(pq))\n    return heappop(pq)\nfor tcase in range(int(input())):\n    (n, q) = map(int, input().split())\n    vertex = [None] + [tuple(map(int, input().split())) for i in range(n)]\n    vertex[0] = vertex[n]\n    side = [dif(vertex[i + 1], vertex[i]) for i in range(n)]\n    side.append(side[0])\n    sidelensqr = [normsqr(side[i]) for i in range(n + 1)]\n    perimeter = get_sum([sqrt(sidelensqr[i]) for i in range(1, n + 1)])\n    sum_tan_half_ext_ang = get_sum([sinprod(side[i - 1], side[i]) / (sqrt(normsqr(side[i - 1]) * normsqr(side[i])) + cosprod(side[i - 1], side[i])) for i in range(1, n + 1)])\n    area = sum((sinprod(side[i], dif(vertex[n], vertex[i])) for i in range(1, n - 1))) / 2.0\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        height = v * t\n        sum_medians = perimeter + sum_tan_half_ext_ang * height\n        result = area + sum_medians * height\n        print('{:.3f}'.format(result))", "from math import sqrt\n\ndef dif(b, a):\n    return (b[0] - a[0], b[1] - a[1])\n\ndef cosprod(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef sinprod(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef normsqr(a):\n    return cosprod(a, a)\nfor tcase in range(int(input())):\n    (n, q) = map(int, input().split())\n    vertex = [None] + [tuple(map(int, input().split())) for i in range(n)]\n    vertex[0] = vertex[n]\n    side = [dif(vertex[i + 1], vertex[i]) for i in range(n)]\n    side.append(side[0])\n    sidelensqr = [normsqr(side[i]) for i in range(n + 1)]\n    perimeter = sum((sqrt(sidelensqr[i]) for i in range(1, n + 1)))\n    sum_tan_half_ext_ang = sum((sinprod(side[i - 1], side[i]) / (sqrt(normsqr(side[i - 1]) * normsqr(side[i])) + cosprod(side[i - 1], side[i])) for i in range(1, n + 1)))\n    area = sum((sinprod(side[i], dif(vertex[n], vertex[i])) for i in range(1, n - 1))) / 2.0\n    for i in range(q):\n        (v, t) = map(int, input().split())\n        height = v * t\n        sum_medians = perimeter + sum_tan_half_ext_ang * height\n        result = area + sum_medians * height\n        print('{:.3f}'.format(result))", "import sys\nimport math\nfrom decimal import *\n\ndef pyt(x, y):\n    return x * x + y * y\n\ndef cross(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef dot(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef norm(a):\n    return dot(a, a)\ngetcontext().prec = 40\ninp = [a.strip() for a in sys.stdin.readlines()]\nT = int(inp[0])\nline = 1\nfor _ in range(T):\n    (n, Q) = [int(x) for x in inp[line].split()]\n    line += 1\n    (xs, ys) = (list(), list())\n    for i in range(n):\n        (x, y) = [int(x) for x in inp[line].split()]\n        xs.append(x)\n        ys.append(y)\n        line += 1\n    area = 0\n    peri = Decimal(0)\n    corners = Decimal(0)\n    for i in range(n):\n        j = (i + 1) % n\n        area += (xs[i] - xs[j]) * (ys[i] + ys[j])\n        peri += Decimal(pyt(xs[i] - xs[j], ys[i] - ys[j])).sqrt()\n        k = (i + 2) % n\n        a = (xs[i] - xs[j], ys[i] - ys[j])\n        b = (xs[k] - xs[j], ys[k] - ys[j])\n        sin = cross(b, a)\n        if sin > 0:\n            cos = dot(b, a)\n            na = norm(a)\n            nb = norm(b)\n            corners += ((Decimal(na) * Decimal(nb)).sqrt() + Decimal(cos)) / Decimal(sin)\n    A = Decimal(abs(area) / 2)\n    P = peri\n    C = corners\n    for i in range(Q):\n        (v, t) = [int(x) for x in inp[line].split()]\n        D = Decimal(v * t)\n        print(A + (P + C * D) * D)\n        line += 1", "import sys\nimport math\nfrom decimal import *\n\ndef pyt(x: Decimal, y: Decimal) -> Decimal:\n    return x * x + y * y\n\ndef cross(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef dot(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef norm(a):\n    return dot(a, a)\n\ndef abs1(a):\n    return norm(a).sqrt()\ngetcontext().prec = 20\ninp = [a.strip() for a in sys.stdin.readlines()]\nT = int(inp[0])\nline = 1\nfor _ in range(T):\n    (n, Q) = [int(x) for x in inp[line].split()]\n    line += 1\n    (xs, ys) = (list(), list())\n    for i in range(n):\n        (x, y) = [Decimal(x) for x in inp[line].split()]\n        xs.append(x)\n        ys.append(y)\n        line += 1\n    area = Decimal(0)\n    peri = Decimal(0)\n    corners = Decimal(0)\n    for i in range(n):\n        j = (i + 1) % n\n        area = area + (xs[i] - xs[j]) * (ys[i] + ys[j])\n        peri = peri + pyt(xs[i] - xs[j], ys[i] - ys[j]).sqrt()\n        k = (i + 2) % n\n        a = (xs[i] - xs[j], ys[i] - ys[j])\n        b = (xs[k] - xs[j], ys[k] - ys[j])\n        sin = cross(b, a)\n        if sin > 0:\n            cos = dot(b, a)\n            ab = abs1(a) * abs1(b)\n            corners = corners + (ab + cos) / sin\n    area = abs(area) / 2\n    for i in range(Q):\n        (v, t) = [Decimal(x) for x in inp[line].split()]\n        v *= t\n        print(area + peri * v + corners * v * v)\n        line += 1", "import sys\nimport math\n\ndef pyt(x, y):\n    return x * x + y * y\n\ndef cross(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef dot(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef norm(a):\n    return dot(a, a)\n\ndef abs1(a):\n    return math.sqrt(norm(a))\ninp = [a.strip() for a in sys.stdin.readlines()]\nT = int(inp[0])\nline = 1\nfor _ in range(T):\n    (n, Q) = [int(x) for x in inp[line].split()]\n    line += 1\n    (xs, ys) = (list(), list())\n    for i in range(n):\n        (x, y) = [int(x) for x in inp[line].split()]\n        xs.append(x)\n        ys.append(y)\n        line += 1\n    area = 0\n    peri = 0\n    corners = 0\n    for i in range(n):\n        j = (i + 1) % n\n        area += (xs[i] - xs[j]) * (ys[i] + ys[j])\n        peri += math.sqrt(pyt(xs[i] - xs[j], ys[i] - ys[j]))\n        k = (i + 2) % n\n        a = (xs[i] - xs[j], ys[i] - ys[j])\n        b = (xs[k] - xs[j], ys[k] - ys[j])\n        sin = cross(b, a)\n        if sin > 0:\n            cos = dot(b, a)\n            ab = abs1(a) * abs1(b)\n            corners += (ab + cos) / sin\n    area = abs(area) / 2\n    for i in range(Q):\n        (v, t) = [int(x) for x in inp[line].split()]\n        v *= t\n        print(area + (peri + corners * v) * v)\n        line += 1", "import sys\nimport math\n\ndef pyt(x, y):\n    return x * x + y * y\n\ndef cross(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef dot(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef norm(a):\n    return dot(a, a)\n\ndef abs1(a):\n    return math.sqrt(norm(a))\ninp = [a.strip() for a in sys.stdin.readlines()]\nT = int(inp[0])\nline = 1\nfor _ in range(T):\n    (n, Q) = [int(x) for x in inp[line].split()]\n    line += 1\n    (xs, ys) = (list(), list())\n    for i in range(n):\n        (x, y) = [int(x) for x in inp[line].split()]\n        xs.append(x)\n        ys.append(y)\n        line += 1\n    area = 0\n    peri = 0\n    corners = 0\n    for i in range(n):\n        j = (i + 1) % n\n        area += (xs[i] - xs[j]) * (ys[i] + ys[j])\n        peri += math.sqrt(pyt(xs[i] - xs[j], ys[i] - ys[j]))\n        k = (i + 2) % n\n        a = (xs[i] - xs[j], ys[i] - ys[j])\n        b = (xs[k] - xs[j], ys[k] - ys[j])\n        ab = abs1(a) * abs1(b)\n        cos = dot(b, a)\n        sin = cross(b, a)\n        corners += sin * ((cos + ab) / (ab - cos) + 1) / ab\n    area = abs(area) / 2\n    corners /= 2\n    for i in range(Q):\n        (v, t) = [int(x) for x in inp[line].split()]\n        v *= t\n        print(area + peri * v + corners * v * v)\n        line += 1", "from math import atan2, tan, hypot, pi\n\nclass Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef solve():\n    (n, q) = map(int, input().split())\n    pt = []\n    for _ in range(n):\n        (x, y) = map(float, input().split())\n        pt.append(Point(x, y))\n    (psum, nsum) = (0, 0)\n    total_len = 0\n    tan_sum = 0\n    for i in range(n):\n        a = pt[i]\n        b = pt[(i + 1) % n]\n        c = pt[(i + 2) % n]\n        psum += a.x * b.y\n        nsum += a.y * b.x\n        total_len += hypot(a.x - b.x, a.y - b.y)\n        (ax, ay) = (b.x - a.x, b.y - a.y)\n        (bx, by) = (c.x - b.x, c.y - b.y)\n        la = hypot(ax, ay)\n        lb = hypot(bx, by)\n        ax /= la\n        ay /= la\n        bx /= lb\n        by /= lb\n        dot = ax * bx + ay * by\n        det = ax * by - ay * bx\n        angle = atan2(det, dot)\n        tan_sum += tan(angle / 2)\n    area = abs(psum - nsum) / 2\n    for _ in range(q):\n        (v, t) = map(int, input().split())\n        dx = v * t\n        print(area + total_len * dx + dx * dx * tan_sum)\nfor _ in range(int(input())):\n    solve()", "import math\nt = int(input())\nfor i in range(0, t):\n    (n, q) = map(int, input().split())\n    V = []\n    Q = []\n    for j in range(0, n):\n        (x, y) = map(int, input().split())\n        V.append((x, y))\n    base_area = 0\n    peri = 0\n    U = []\n    E = []\n    for j in range(0, n):\n        e = (V[(j + 1) % n][0] - V[j][0], V[(j + 1) % n][1] - V[j][1])\n        U.append(e)\n        d1 = (e[0] ** 2 + e[1] ** 2) ** 0.5\n        E.append(d1)\n        base_area += (V[(j + 1) % n][0] - V[j][0]) * (V[(j + 1) % n][1] + V[j][1])\n        peri += d1\n    base_area = abs(base_area / 2)\n    cosine = [0] * n\n    for j in range(0, n):\n        cosine[j] = (U[j][0] * U[(j + 1) % n][0] + U[j][1] * U[(j + 1) % n][1]) / (E[j] * E[(j + 1) % n])\n    st = 0\n    for j in range(0, n):\n        temp = cosine[j]\n        temp1 = ((1 - temp) / (temp + 1)) ** 0.5\n        st += temp1\n    for v in range(0, q):\n        (v, t0) = map(int, input().split())\n        d = v * t0\n        area = base_area\n        area += peri * d\n        area += d * d * st\n        print(area)", "import sys\nimport math\n\ndef pyt(x, y):\n    return x * x + y * y\n\ndef angle(a, b, c):\n    return math.atan2(a[1] - b[1], a[0] - b[0]) - math.atan2(c[1] - b[1], c[0] - b[0])\ninp = [a.strip() for a in sys.stdin.readlines()]\nT = int(inp[0])\nline = 1\nfor _ in range(T):\n    (n, Q) = [int(x) for x in inp[line].split()]\n    line += 1\n    (xs, ys) = (list(), list())\n    for i in range(n):\n        (x, y) = [int(x) for x in inp[line].split()]\n        xs.append(x)\n        ys.append(y)\n        line += 1\n    area = 0\n    peri = 0\n    corners = 0\n    for i in range(n):\n        j = (i + 1) % n\n        area += (xs[i] - xs[j]) * (ys[i] + ys[j])\n        peri += math.sqrt(pyt(xs[i] - xs[j], ys[i] - ys[j]))\n        k = (i + 2) % n\n        ang = angle((xs[i], ys[i]), (xs[j], ys[j]), (xs[k], ys[k])) / 2\n        opp = math.sin(ang)\n        adj = math.cos(ang)\n        corners += opp * adj\n        corners += adj * adj * adj / opp\n    area = abs(area) / 2\n    for i in range(Q):\n        (v, t) = [int(x) for x in inp[line].split()]\n        v *= t\n        print(area + peri * v + corners * v * v)\n        line += 1", "import sys\nimport math\n\ndef pyt(x, y):\n    return x * x + y * y\n\ndef dot(a, b):\n    return a[0] * b[0] + a[1] * b[1]\n\ndef norm(a):\n    return dot(a, a)\n\ndef abs1(a):\n    return math.sqrt(norm(a))\n\ndef angle2(a, b):\n    return math.acos(dot(a, b) / abs1(a) / abs1(b))\n\ndef angle(a, b, c):\n    return angle2((a[0] - b[0], a[1] - b[1]), (c[0] - b[0], c[1] - b[1]))\ninp = [a.strip() for a in sys.stdin.readlines()]\nT = int(inp[0])\nline = 1\nfor _ in range(T):\n    (n, Q) = [int(x) for x in inp[line].split()]\n    line += 1\n    (xs, ys) = (list(), list())\n    for i in range(n):\n        (x, y) = [int(x) for x in inp[line].split()]\n        xs.append(x)\n        ys.append(y)\n        line += 1\n    area = 0\n    peri = 0\n    corners = 0\n    for i in range(n):\n        j = (i + 1) % n\n        area += (xs[i] - xs[j]) * (ys[i] + ys[j])\n        peri += math.sqrt(pyt(xs[i] - xs[j], ys[i] - ys[j]))\n        k = (i + 2) % n\n        ang = angle((xs[i], ys[i]), (xs[j], ys[j]), (xs[k], ys[k])) / 2\n        opp = math.sin(ang)\n        adj = math.cos(ang)\n        corners += opp * adj\n        corners += adj * adj * adj / opp\n    area = abs(area) / 2\n    for i in range(Q):\n        (v, t) = [int(x) for x in inp[line].split()]\n        v *= t\n        print(area + peri * v + corners * v * v)\n        line += 1", "import math\nt = int(input())\nfor i in range(0, t):\n    (n, q) = map(int, input().split())\n    V = []\n    Q = []\n    for j in range(0, n):\n        (x, y) = map(int, input().split())\n        V.append((x, y))\n    base_area = 0\n    peri = 0\n    U = []\n    E = []\n    for j in range(0, n):\n        e = (V[(j + 1) % n][0] - V[j][0], V[(j + 1) % n][1] - V[j][1])\n        U.append(e)\n        d1 = (e[0] ** 2 + e[1] ** 2) ** 0.5\n        E.append(d1)\n        base_area += (V[(j + 1) % n][0] - V[j][0]) * (V[(j + 1) % n][1] + V[j][1])\n        peri += d1\n    base_area = abs(base_area / 2)\n    cosine = [0] * n\n    for j in range(0, n):\n        cosine[j] = (U[j][0] * U[(j + 1) % n][0] + U[j][1] * U[(j + 1) % n][1]) / (E[j] * E[(j + 1) % n])\n    st = 0\n    for j in range(0, n):\n        temp = cosine[j]\n        temp1 = ((1 - temp) / (temp + 1)) ** 0.5\n        st += temp1\n    for v in range(0, q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        area = base_area\n        area += peri * d\n        area += d * d * st\n        print(area)", "import math\nt = int(input())\nfor i in range(0, t):\n    (n, q) = map(int, input().split())\n    V = []\n    Q = []\n    for j in range(0, n):\n        (x, y) = map(int, input().split())\n        V.append((x, y))\n    base_area = 0\n    peri = 0\n    U = []\n    for j in range(0, n):\n        e = (V[(j + 1) % n][0] - V[j][0], V[(j + 1) % n][1] - V[j][1])\n        U.append(e)\n    for j in range(0, n):\n        base_area += (V[j - 1][0] - V[j][0]) * (V[j - 1][1] + V[j][1])\n        peri += (U[j][0] ** 2 + U[j][1] ** 2) ** 0.5\n    base_area = abs(base_area / 2)\n    cotangents = [0] * n\n    for j in range(0, n):\n        cotangents[j] = -1 * (U[j][0] * U[(j + 1) % n][0] + U[j][1] * U[(j + 1) % n][1]) / abs(U[j][0] * U[(j + 1) % n][1] - U[j][1] * U[(j + 1) % n][0])\n    st = 0\n    for j in range(0, n):\n        temp = cotangents[j]\n        temp1 = temp + (temp * temp + 1) ** 0.5\n        st += temp1\n    for v in range(0, q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        area = base_area\n        area += peri * d\n        area += d * d * st\n        print(area)", "import math\nt = int(input())\nfor i in range(0, t):\n    (n, q) = map(int, input().split())\n    V = []\n    Q = []\n    for j in range(0, n):\n        (x, y) = map(int, input().split())\n        V.append((x, y))\n    base_area = 0\n    peri = 0\n    U = []\n    for j in range(-1, n - 1):\n        U.append((V[j + 1][0] - V[j][0], V[j + 1][1] - V[j][1]))\n    for j in range(0, n):\n        base_area += (V[j - 1][0] - V[j][0]) * (V[j - 1][1] + V[j][1])\n        peri += (U[j][0] ** 2 + U[j][1] ** 2) ** 0.5\n    base_area = abs(base_area / 2)\n    cotangents = [0] * n\n    for j in range(0, n - 1):\n        cotangents[j] = -1 * (U[j][0] * U[j + 1][0] + U[j][1] * U[j + 1][1]) / abs(U[j][0] * U[j + 1][1] - U[j][1] * U[j + 1][0])\n    cotangents[n - 1] = -1 * (U[n - 1][0] * U[0][0] + U[n - 1][1] * U[0][1]) / abs(U[n - 1][0] * U[0][1] - U[n - 1][1] * U[0][0])\n    st = 0\n    for j in range(0, n):\n        temp = cotangents[j]\n        temp1 = temp + (temp * temp + 1) ** 0.5\n        st += temp1\n    for v in range(0, q):\n        (v, t) = map(int, input().split())\n        d = v * t\n        area = base_area\n        area += peri * d\n        area += d * d * st\n        print(area)", "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\ndef angleWithPoints(p0, p1, p2):\n    vec1 = [p0[0] - p1[0], p0[1] - p1[1]]\n    vec2 = [p0[0] - p2[0], p0[1] - p2[1]]\n    return math.acos((vec1[0] * vec2[0] + vec1[1] * vec2[1]) / (distance(p0, p1) * distance(p0, p2)))\nfor _ in range(int(input())):\n    (size, q) = map(int, input().split())\n    points = []\n    for i in range(size):\n        (x, y) = map(float, input().split())\n        points.append([x * 1.0, y * 1.0])\n    totalArea = 0.0\n    totalPerimeter = 0.0\n    delta = 0.0\n    for i in range(size):\n        prevP = points[(i - 1 + size) % size]\n        currP = points[i]\n        nextP = points[(i + 1) % size]\n        totalArea += currP[0] * nextP[1] - nextP[0] * currP[1]\n        totalPerimeter = totalPerimeter + distance(currP, nextP)\n        theta = math.pi - angleWithPoints(currP, prevP, nextP)\n        delta = delta + math.tan(theta / 2.0)\n    totalArea = totalArea * 0.5\n    for i in range(q):\n        (v, ti) = map(float, input().split())\n        d = v * 1.0 * (ti * 1.0)\n        ans = totalArea + totalPerimeter * d + delta * d * d\n        print('%.10f' % ans)"]