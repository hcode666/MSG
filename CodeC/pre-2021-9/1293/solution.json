["import sys\ntry:\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def calculate(target_sum, rang_index):\n        populate(target_sum, rang_index)\n        return cal_recurse(0, target_sum)\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    _test_cases = int(input())\n    precalculate()\n    for _a_case in range(_test_cases):\n        rang = [0] * 101\n        multisets = {}\n        _rang_index = [int(i) for i in input().split(' ')]\n        _target_sum = int(input())\n        print(calculate(_target_sum, _rang_index))\nexcept:\n    pass", "import sys\ntry:\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def calculate(target_sum, rang_index):\n        populate(target_sum, rang_index)\n        return cal_recurse(0, target_sum)\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    _test_cases = int(input())\n    precalculate()\n    for _a_case in range(_test_cases):\n        rang = [0] * 101\n        multisets = {}\n        _rang_index = [int(i) for i in input().split(' ')]\n        _target_sum = int(input())\n        print(calculate(_target_sum, _rang_index))\nexcept:\n    pass", "import sys\ntry:\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def calculate(target_sum, rang_index):\n        populate(target_sum, rang_index)\n        return cal_recurse(0, target_sum)\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    _test_cases = int(input())\n    precalculate()\n    for _a_case in range(_test_cases):\n        rang = [0] * 101\n        multisets = {}\n        _rang_index = [int(i) for i in input().split(' ')]\n        _target_sum = int(input())\n        print(calculate(_target_sum, _rang_index))\nexcept:\n    pass", "import sys\ntry:\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def calculate(target_sum, rang_index):\n        populate(target_sum, rang_index)\n        return cal_recurse(0, target_sum)\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    _test_cases = int(input())\n    precalculate()\n    for _a_case in range(_test_cases):\n        rang = [0] * 101\n        multisets = {}\n        _rang_index = [int(i) for i in input().split(' ')]\n        _target_sum = int(input())\n        print(calculate(_target_sum, _rang_index))\nexcept:\n    pass", "import sys\ntry:\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def calculate(target_sum, rang_index):\n        populate(target_sum, rang_index)\n        return cal_recurse(0, target_sum)\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    _test_cases = int(input())\n    precalculate()\n    for _a_case in range(_test_cases):\n        rang = [0] * 101\n        multisets = {}\n        _rang_index = [int(i) for i in input().split(' ')]\n        _target_sum = int(input())\n        print(calculate(_target_sum, _rang_index))\nexcept:\n    pass", "import sys\ntry:\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def calculate(target_sum, rang_index):\n        populate(target_sum, rang_index)\n        return cal_recurse(0, target_sum)\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    _test_cases = int(input())\n    precalculate()\n    for _a_case in range(_test_cases):\n        rang = [0] * 101\n        multisets = {}\n        _rang_index = [int(i) for i in input().split(' ')]\n        _target_sum = int(input())\n        print(calculate(_target_sum, _rang_index))\nexcept:\n    pass", "import sys\nmod_val = 1000000007\nrang = [0] * 101\npow_cache = [0] * 102\nmultisets = {}\n\ndef mod_pow(base, pow):\n    result = 1\n    while pow:\n        if pow & 1:\n            result = result * base % mod_val\n        base = base * base % mod_val\n        pow = pow >> 1\n    return result\n\ndef precalculate():\n    for i in range(1, 102):\n        pow_cache[i] = mod_pow(i, mod_val - 2)\n\ndef cal_recurse(i, target_sum):\n    if target_sum == 0:\n        return 1\n    if i >= target_sum:\n        return 0\n    if (i, target_sum) in multisets:\n        return multisets[i, target_sum]\n    ans = cal_recurse(i + 1, target_sum)\n    max_pos = target_sum // (i + 1)\n    choose = rang[i + 1] % mod_val\n    for j in range(1, max_pos + 1):\n        temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n        ans += temp\n        ans %= mod_val\n        choose *= rang[i + 1] + j\n        choose *= pow_cache[j + 1]\n        choose %= mod_val\n    multisets[i, target_sum] = ans\n    return ans\n\ndef calculate(target_sum, rang_index):\n    populate(target_sum, rang_index)\n    return cal_recurse(0, target_sum)\n\ndef populate(target_sum, rang_i):\n    for i in range(1, target_sum + 1):\n        rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n_test_cases = int(input())\nprecalculate()\nfor _a_case in range(_test_cases):\n    rang = [0] * 101\n    multisets = {}\n    _rang_index = [int(i) for i in input().split(' ')]\n    _target_sum = int(input())\n    print(calculate(_target_sum, _rang_index))", "import sys\nmod_val = 1000000007\nrang = [0] * 101\npow_cache = [0] * 102\nmultisets = {}\n\ndef mod_pow(base, pow):\n    result = 1\n    while pow:\n        if pow & 1:\n            result = result * base % mod_val\n        base = base * base % mod_val\n        pow = pow >> 1\n    return result\n\ndef precalculate():\n    for i in range(1, 102):\n        pow_cache[i] = mod_pow(i, mod_val - 2)\n\ndef cal_recurse(i, target_sum):\n    if target_sum == 0:\n        return 1\n    if i >= target_sum:\n        return 0\n    if (i, target_sum) in multisets:\n        return multisets[i, target_sum]\n    ans = cal_recurse(i + 1, target_sum)\n    max_pos = target_sum // (i + 1)\n    choose = rang[i + 1] % mod_val\n    for j in range(1, max_pos + 1):\n        temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n        ans += temp\n        ans %= mod_val\n        choose *= rang[i + 1] + j\n        choose *= pow_cache[j + 1]\n        choose %= mod_val\n    multisets[i, target_sum] = ans\n    return ans\n\ndef calculate(target_sum, rang_index):\n    populate(target_sum, rang_index)\n    return cal_recurse(0, target_sum)\n\ndef populate(target_sum, rang_i):\n    for i in range(1, target_sum + 1):\n        rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n_test_cases = int(input())\nprecalculate()\nfor _a_case in range(_test_cases):\n    rang = [0] * 101\n    multisets = {}\n    _rang_index = [int(i) for i in input().split(' ')]\n    _target_sum = int(input())\n    print(calculate(_target_sum, _rang_index))", "def c(x, y):\n    ans = 1\n    for i in range(x, x + y):\n        ans *= i\n    for i in range(1, y + 1):\n        ans //= i\n    return ans\nt = int(input())\nmod = 10 ** 9 + 7\nfor q in range(t):\n    a = list(map(int, input().split()))\n    s = int(input())\n    d = [0 for i in range(s + 1)]\n    d[0] = 1\n    for i in range(1, s + 1):\n        for j in range(s, -1, -1):\n            k = 1\n            while k * i + j <= s:\n                d[k * i + j] = (d[k * i + j] + d[j] * c(a[0] + i * a[1] + i ** 2 * a[2] + i ** 3 * a[3], k)) % mod\n                k += 1\n    print(d[s])"]