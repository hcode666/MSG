["import sys\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\n\ndef dfs1(u):\n    visited[u] = True\n    v = (u + e[u] + 1) % n\n    if visited[v] is False:\n        dfs1(v)\n    order.append(u)\n\ndef dfs2(u):\n    visited[u] = True\n    for adjacent in transpose[u]:\n        if visited[adjacent] is False:\n            dfs2(adjacent)\n    scc.append(u)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    e = [int(x) for x in input().split()]\n    transpose = defaultdict(list)\n    for (index, value) in enumerate(e):\n        transpose[(index + value + 1) % n].append(index)\n    ans = 0\n    visited = [False] * n\n    order = []\n    for i in range(n):\n        if visited[i] is False:\n            dfs1(i)\n    visited = [False] * n\n    for i in range(n):\n        node = order[n - 1 - i]\n        scc = []\n        if visited[node] is False:\n            dfs2(node)\n            if len(scc) == 1 and scc[0] != (scc[0] + e[scc[0]] + 1) % n:\n                continue\n            ans += len(scc)\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\n\ndef dfs1(u):\n    visited[u] = True\n    v = (u + e[u] + 1) % n\n    if visited[v] is False:\n        dfs1(v)\n    order.append(u)\n\ndef dfs2(u):\n    visited[u] = True\n    for adjacent in transpose[u]:\n        if visited[adjacent] is False:\n            dfs2(adjacent)\n    scc.append(u)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    e = [int(x) for x in input().split()]\n    transpose = defaultdict(list)\n    for (index, value) in enumerate(e):\n        transpose[(index + value + 1) % n].append(index)\n    ans = 0\n    visited = [False] * n\n    order = []\n    for i in range(n):\n        if visited[i] is False:\n            dfs1(i)\n    visited = [False] * n\n    for i in range(n):\n        node = order[n - 1 - i]\n        scc = []\n        if visited[node] is False:\n            dfs2(node)\n            if len(scc) == 1 and scc[0] != (scc[0] + e[scc[0]] + 1) % n:\n                continue\n            ans += len(scc)\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\n\ndef dfs1(u):\n    visited[u] = True\n    v = (u + e[u] + 1) % n\n    if visited[v] is False:\n        dfs1(v)\n    order.append(u)\n\ndef dfs2(u):\n    visited[u] = True\n    for adjacent in transpose[u]:\n        if visited[adjacent] is False:\n            dfs2(adjacent)\n    scc.append(u)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    e = [int(x) for x in input().split()]\n    transpose = defaultdict(list)\n    for (index, value) in enumerate(e):\n        transpose[(index + value + 1) % n].append(index)\n    ans = 0\n    visited = [False] * n\n    order = []\n    for i in range(n):\n        if visited[i] is False:\n            dfs1(i)\n    visited = [False] * n\n    for i in range(n):\n        node = order[n - 1 - i]\n        scc = []\n        if visited[node] is False:\n            dfs2(node)\n            if len(scc) == 1 and scc[0] != (scc[0] + e[scc[0]] + 1) % n:\n                continue\n            ans += len(scc)\n    print(ans)", "import sys\nsys.setrecursionlimit(1000000)\nt = int(input())\n\ndef dfs1(node, adj, vis, out):\n    for child in adj[node]:\n        if not vis[child]:\n            vis[child] = True\n            dfs1(child, adj, vis, out)\n    out.append(node)\n\ndef dfs2(node, adj, vis, con):\n    for child in adj[node]:\n        if not vis[child]:\n            vis[child] = True\n            dfs2(child, adj, vis, con)\n    con.append(node)\nfor tt in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    adjlist = [[] for i in range(n)]\n    tadjlist = [[] for i in range(n)]\n    counter2 = 0\n    for (num, i) in enumerate(a):\n        if num == (num + i + 1) % n:\n            counter2 += 1\n        adjlist[num].append((num + i + 1) % n)\n        tadjlist[(num + i + 1) % n].append(num)\n    vis = [False for i in range(n)]\n    out = []\n    for i in range(n):\n        if not vis[i]:\n            vis[i] = True\n            dfs1(i, adjlist, vis, out)\n    vis = [False for i in range(n)]\n    counter = 0\n    for i in out[::-1]:\n        if not vis[i]:\n            con = []\n            vis[i] = True\n            dfs2(i, tadjlist, vis, con)\n            if len(con) == 1:\n                counter += 1\n    print(n - counter + counter2)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    g = defaultdict(int)\n    for i in range(n):\n        g[i] = (i + b[i] + 1) % n\n    magic = 0\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            to = i\n            while not visited[to]:\n                cycle.append(to)\n                visited[to] = True\n                to = g[to]\n            if to in cycle:\n                magic += len(cycle[cycle.index(to):])\n    print(magic)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    b = [int(i) for i in input().split()]\n    g = defaultdict(int)\n    for i in range(n):\n        g[i] = (i + b[i] + 1) % n\n    magic = 0\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            to = i\n            while not visited[to]:\n                cycle.append(to)\n                visited[to] = True\n                to = g[to]\n            if to in cycle:\n                magic += len(cycle[cycle.index(to):])\n    print(magic)", "for _ in range(int(input())):\n    n = int(input())\n    z = input().split()\n    a = list(map(int, z[:n]))\n    mag = []\n    unused = [True] * n\n    for ix in range(n):\n        if unused[ix]:\n            cyc = []\n            c = ix\n            while unused[c]:\n                cyc.append(c)\n                unused[c] = False\n                c = (c + a[c] + 1) % n\n            if c in cyc:\n                mx = cyc.index(c)\n                mag.extend(cyc[mx:])\n    print(len(mag))", "T = int(input())\nfor i in range(T):\n    n = int(input())\n    z = input().split()\n    a = list(map(int, z[:n]))\n    mag = []\n    unused = [True] * n\n    for ix in range(n):\n        if unused[ix]:\n            cyc = []\n            c = ix\n            while unused[c]:\n                cyc.append(c)\n                unused[c] = False\n                c = (c + a[c] + 1) % n\n            if c in cyc:\n                mx = cyc.index(c)\n                mag.extend(cyc[mx:])\n    print(len(mag))", "for _ in range(int(input())):\n    n = int(input())\n    z = input().split()\n    a = list(map(int, z[:n]))\n    mag = []\n    unused = [True] * n\n    for ix in range(n):\n        if unused[ix]:\n            cyc = []\n            c = ix\n            while unused[c]:\n                cyc.append(c)\n                unused[c] = False\n                c = (c + a[c] + 1) % n\n            if c in cyc:\n                mx = cyc.index(c)\n                mag.extend(cyc[mx:])\n    print(len(mag))", "import sys\nsys.setrecursionlimit(int(1000000.0))\nt = int(input())\nfrom collections import defaultdict\nglobal vis, d, tp, ol, scc\n\ndef v():\n    return set()\n\ndef dfs(i):\n    vis.add(i)\n    for k in d[i]:\n        if k not in vis:\n            dfs(k)\n    ol.append(i)\n\ndef dfs1(i):\n    global scc\n    vis.add(i)\n    for k in tp[i]:\n        if k not in vis:\n            dfs1(k)\n    scc.append(i)\nfor _ in range(t):\n    d = defaultdict(v)\n    tp = defaultdict(v)\n    vis = set()\n    n = int(input())\n    arr = list(map(int, input().split()))\n    for i in range(n):\n        p = i\n        q = (i + arr[i] + 1) % n\n        d[p].add(q)\n        tp[q].add(p)\n    ol = []\n    for i in range(n):\n        if i not in vis:\n            dfs(i)\n    ol.reverse()\n    vis = set()\n    ans = 0\n    for i in ol:\n        if i not in vis:\n            scc = []\n            dfs1(i)\n            if len(scc) == 1 and i not in d[i]:\n                continue\n            ans += len(scc)\n    print(ans)", "import sys\nsys.setrecursionlimit(int(1000000.0))\nt = int(input())\nfrom collections import defaultdict\nglobal vis, d, tp, ol, scc\n\ndef v():\n    return set()\n\ndef dfs(i):\n    vis.add(i)\n    for k in d[i]:\n        if k not in vis:\n            dfs(k)\n    ol.append(i)\n\ndef dfs1(i):\n    global scc\n    vis.add(i)\n    for k in tp[i]:\n        if k not in vis:\n            dfs1(k)\n    scc.append(i)\nfor _ in range(t):\n    d = defaultdict(v)\n    tp = defaultdict(v)\n    vis = set()\n    n = int(input())\n    arr = list(map(int, input().split()))\n    for i in range(n):\n        p = i\n        q = (i + arr[i] + 1) % n\n        d[p].add(q)\n        tp[q].add(p)\n    ol = []\n    for i in range(n):\n        if i not in vis:\n            dfs(i)\n    ol.reverse()\n    vis = set()\n    ans = 0\n    for i in ol:\n        if i not in vis:\n            scc = []\n            dfs1(i)\n            if len(scc) == 1 and i not in d[i]:\n                continue\n            ans += len(scc)\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    z = input().split()\n    a = list(map(int, z[:n]))\n    mag = []\n    unused = [True] * n\n    for ix in range(n):\n        if unused[ix]:\n            cyc = []\n            c = ix\n            while unused[c]:\n                cyc.append(c)\n                unused[c] = False\n                c = (c + a[c] + 1) % n\n            if c in cyc:\n                mx = cyc.index(c)\n                mag.extend(cyc[mx:])\n    print(len(mag))", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs1(node):\n    vis[node] = 1\n    for kid in range(1, len(gp[node])):\n        vl = gp[node][kid]\n        if vis[vl] == 0:\n            dfs1(vl)\n    save1.append(node)\n\ndef dfs2(node):\n    vis[node] = 1\n    ar.append(node)\n    for i in range(1, len(tgp[node])):\n        vl = tgp[node][i]\n        if vis[vl] == 0:\n            dfs2(vl)\nfor _ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split(' ')))\n    gp = [[-1] for i in range(n)]\n    tgp = [[-1] for i in range(n)]\n    vis = [0 for i in range(n)]\n    for i in range(n):\n        val = (i + li[i] + 1) % n\n        gp[i].append(val)\n        tgp[val].append(i)\n    save1 = []\n    for i in range(n):\n        if vis[i] == 0:\n            dfs1(i)\n    vis = [0 for i in range(n)]\n    save1.reverse()\n    c = 0\n    for i in range(len(save1)):\n        ar = []\n        if vis[save1[i]] == 0:\n            dfs2(save1[i])\n            if len(ar) > 1:\n                c = c + len(ar)\n            if len(ar) == 1:\n                if ar[0] in gp[save1[i]]:\n                    c = c + 1\n    print(c)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs1(node):\n    vis[node] = 1\n    for kid in range(1, len(gp[node])):\n        vl = gp[node][kid]\n        if vis[vl] == 0:\n            dfs1(vl)\n    save1.append(node)\n\ndef dfs2(node):\n    vis[node] = 1\n    ar.append(node)\n    for i in range(1, len(tgp[node])):\n        vl = tgp[node][i]\n        if vis[vl] == 0:\n            dfs2(vl)\nfor _ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split(' ')))\n    gp = [[-1] for i in range(n)]\n    tgp = [[-1] for i in range(n)]\n    vis = [0 for i in range(n)]\n    for i in range(n):\n        val = (i + li[i] + 1) % n\n        gp[i].append(val)\n        tgp[val].append(i)\n    save1 = []\n    for i in range(n):\n        if vis[i] == 0:\n            dfs1(i)\n    vis = [0 for i in range(n)]\n    save1.reverse()\n    c = 0\n    for i in range(len(save1)):\n        ar = []\n        if vis[save1[i]] == 0:\n            dfs2(save1[i])\n            if len(ar) > 1:\n                c = c + len(ar)\n            if len(ar) == 1:\n                if ar[0] in gp[save1[i]]:\n                    c = c + 1\n    print(c)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(root):\n    visited[root] = True\n    for x in d[root]:\n        if visited[x] == False:\n            dfs(x)\n    way.append(root)\n\ndef dfs1(root):\n    visited[root] = True\n    arr.append(root)\n    for x in d_inv[root]:\n        if visited[x] == False:\n            dfs1(x)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    d_inv = defaultdict(list)\n    cou = 0\n    for i in range(len(a)):\n        (x, y) = (i, (i + a[i] + 1) % n)\n        d[x].append(y)\n        d_inv[y].append(x)\n    visited = [False] * n\n    way = []\n    for i in range(n):\n        if visited[i] == False:\n            dfs(i)\n    visited = [False] * n\n    way.reverse()\n    for j in range(len(way)):\n        arr = []\n        if visited[way[j]] == False:\n            dfs1(way[j])\n            if len(arr) > 1:\n                cou += len(arr)\n            if len(arr) == 1:\n                if way[j] in d[way[j]]:\n                    cou += 1\n    print(cou)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    b = [int(i) for i in input().split()]\n    g = defaultdict(int)\n    for i in range(n):\n        g[i] = (i + b[i] + 1) % n\n    magic = 0\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            to = i\n            while not visited[to]:\n                cycle.append(to)\n                visited[to] = True\n                to = g[to]\n            if to in cycle:\n                magic += len(cycle[cycle.index(to):])\n    print(magic)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split(' ')))\n    visited = [False] * n\n    path = []\n    count = 0\n    for i in range(n):\n        if not visited[i]:\n            node = i\n            path = []\n            while not visited[node]:\n                path.append(node)\n                visited[node] = True\n                node = (node + 1 + arr[node]) % n\n            if node in path:\n                cycle_node = path.index(node)\n                count += len(path[cycle_node:])\n    print(count)", "from collections import deque\nfrom sys import setrecursionlimit\nsetrecursionlimit(1000100)\n\nclass Solution(object):\n\n    def __init__(self):\n        super().__init__()\n\n    def find_scc(self, adj, n):\n        mark = [False] * n\n        id = [0] * (n + 1)\n        low_link = [0] * n\n        in_stack = [False] * n\n        mp = {}\n        st = deque()\n        for v in range(n):\n            if mark[v]:\n                continue\n            self.scc(v, mark, id, low_link, adj, in_stack, st, mp)\n        s = 0\n        for v in range(n):\n            cc = mp[low_link[v]]\n            if cc == 1 and v in adj[v]:\n                s += 1\n            elif cc > 1:\n                s += 1\n        return s\n\n    def scc(self, v, mark, id, low_link, adj, in_stack, st, mp):\n        in_stack[v] = mark[v] = True\n        low_link[v] = id[v] = id[-1]\n        id[-1] += 1\n        st.append(v)\n        for n_v in adj[v]:\n            if not mark[n_v]:\n                self.scc(n_v, mark, id, low_link, adj, in_stack, st, mp)\n            if in_stack[n_v]:\n                low_link[v] = min(low_link[v], low_link[n_v])\n        if id[v] == low_link[v]:\n            mp[id[v]] = 0\n            while st:\n                mp[id[v]] += 1\n                top_v = st.pop()\n                in_stack[top_v] = False\n                low_link[top_v] = id[v]\n                if top_v == v:\n                    break\n\ndef main():\n    sol = Solution()\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        adj = [[] for _ in range(n)]\n        sp = [int(e) for e in input().split()]\n        for i in range(n):\n            adj[i].append((i + sp[i] + 1) % n)\n        print(sol.find_scc(adj, n))\nmain()", "for _ in range(int(input())):\n    n = int(input())\n    z = input().split()\n    a = list(map(int, z[:n]))\n    mag = []\n    unused = [True] * n\n    for ix in range(n):\n        if unused[ix]:\n            cyc = []\n            c = ix\n            while unused[c]:\n                cyc.append(c)\n                unused[c] = False\n                c = (c + a[c] + 1) % n\n            if c in cyc:\n                mx = cyc.index(c)\n                mag.extend(cyc[mx:])\n    print(len(mag))", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    b = [int(i) for i in input().split()]\n    g = defaultdict(int)\n    vis = [0] * n\n    ans = 0\n    for i in range(n):\n        g[i] = (i + b[i] + 1) % n\n    for i in range(n):\n        if not vis[i]:\n            cycle = []\n            to = i\n            while not vis[to]:\n                vis[to] = 1\n                cycle.append(to)\n                to = g[to]\n            if to in cycle:\n                ans += len(cycle[cycle.index(to):])\n    print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    b = [int(i) for i in input().split()]\n    g = defaultdict(int)\n    for i in range(n):\n        g[i] = (i + b[i] + 1) % n\n    magic = 0\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            to = i\n            while not visited[to]:\n                cycle.append(to)\n                visited[to] = True\n                to = g[to]\n            if to in cycle:\n                magic += len(cycle[cycle.index(to):])\n    print(magic)", "T = int(input())\nfor _ in range(T):\n    n = int(input())\n    a = list(map(int, input().split()))\n    magicBoxIndices = []\n    isUnvisited = [True] * n\n    for vertexIndex in range(n):\n        if isUnvisited[vertexIndex]:\n            curCycle = []\n            curVertexIndex = vertexIndex\n            while isUnvisited[curVertexIndex]:\n                curCycle.append(curVertexIndex)\n                isUnvisited[curVertexIndex] = False\n                nextVertexIndex = (curVertexIndex + a[curVertexIndex] + 1) % n\n                curVertexIndex = nextVertexIndex\n            if curVertexIndex in curCycle:\n                magicBoxIndicesInCurCycle = curCycle.index(curVertexIndex)\n                magicBoxIndices.extend(curCycle[magicBoxIndicesInCurCycle:])\n    print(len(magicBoxIndices))", "for _ in range(int(input())):\n    n = int(input())\n    z = input().split()\n    a = list(map(int, z[:n]))\n    mag = 0\n    vis = [0] * n\n    seq = 1\n    for ix in range(n):\n        if vis[ix] == 0:\n            thread = seq\n            c = ix\n            while vis[c] == 0:\n                vis[c] = seq\n                seq += 1\n                c = (c + a[c] + 1) % n\n            if vis[c] >= thread:\n                mag += seq - vis[c]\n    print(mag)", "for _ in range(int(input())):\n    n = int(input())\n    z = input().split()\n    a = list(map(int, z[:n]))\n    mag = []\n    unused = [True] * n\n    for ix in range(n):\n        if unused[ix]:\n            cyc = []\n            c = ix\n            while unused[c]:\n                cyc.append(c)\n                unused[c] = False\n                c = (c + a[c] + 1) % n\n            if c in cyc:\n                mx = cyc.index(c)\n                mag.extend(cyc[mx:])\n    print(len(mag))", "for i in range(int(input())):\n    n = int(input())\n    skip = [int(x) for x in input().split()]\n    visited = [0 for i in range(n)]\n    ans = 0\n    for i in range(n):\n        if visited[i] == 0:\n            curr = i\n            cycle = [curr]\n            while visited[curr] == 0 or (curr in cycle and visited[curr] < 3):\n                visited[curr] += 1\n                cycle.append(curr)\n                curr = (curr + skip[curr] + 1) % n\n    for i in visited:\n        if i >= 2:\n            ans += 1\n    print(ans)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    visited_boxes = set()\n    cyclic_count = 0\n    for i in range(n):\n        path = []\n        if i in visited_boxes:\n            continue\n        current_box = i\n        while True:\n            visited_boxes.add(current_box)\n            path.append(current_box)\n            next_box = current_box + a[current_box] + 1\n            next_box = next_box % n\n            if next_box > i and next_box not in visited_boxes:\n                current_box = next_box\n                continue\n            break\n        if next_box in path:\n            cyclic_count += len(path[path.index(next_box):])\n    print(cyclic_count)", "t = int(input())\nwhile t > 0:\n    count = 0\n    n = int(input())\n    visited = []\n    recursion = []\n    parent = []\n    arr = list(map(int, input().split()))\n    for i in range(n):\n        visited.append(0)\n        parent.append(-1)\n    for i in range(n):\n        recursion = []\n        source = i\n        if visited[i] == 1:\n            continue\n        else:\n            while visited[source] != 1:\n                prev = source\n                recursion.append(source)\n                visited[source] = 1\n                source = (source + arr[source] + 1) % n\n                parent[source] = prev\n            if source in recursion:\n                while parent[prev] != source:\n                    count += 1\n                    prev = parent[prev]\n                if source == prev:\n                    count += 1\n                else:\n                    count += 2\n    print(count)\n    t -= 1", "T = int(input())\nwhile T > 0:\n    T -= 1\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    next = [(i + A[i] + 1) % n for i in range(n)]\n    visited = set()\n    accepted = set()\n    for i in range(n):\n        if i not in visited:\n            tmp = set()\n            Flag = False\n            h = t = i\n            while True:\n                h = next[h]\n                t = next[next[t]]\n                tmp |= set([i, h, t])\n                if h in accepted or t in accepted or h in visited or (t in visited):\n                    break\n                if h == t:\n                    Flag = True\n                    break\n            if Flag:\n                accepted.add(h)\n                h = next[h]\n                while True:\n                    if h == t:\n                        break\n                    accepted.add(h)\n                    h = next[h]\n            visited |= tmp\n    print(len(accepted))", "T = int(input())\nwhile T > 0:\n    T -= 1\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    next = [(i + A[i] + 1) % n for i in range(n)]\n    visited = set()\n    magicnum = set()\n    count = 0\n    for i in range(n):\n        if i not in visited:\n            tmp = set()\n            Flag = False\n            h = t = i\n            while True:\n                h = next[h]\n                t = next[next[t]]\n                tmp |= set([i, h, t])\n                if h in magicnum or t in magicnum or h in visited or (t in visited):\n                    break\n                if h == t:\n                    Flag = True\n                    break\n            if Flag:\n                magicnum.add(h)\n                h = next[h]\n                count += 1\n                while True:\n                    if h == t:\n                        break\n                    magicnum.add(h)\n                    h = next[h]\n                    count += 1\n            visited |= tmp\n    print(count)", "for _ in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    ans = 0\n    i = 0\n    checked = {}\n    path = {}\n    while i < n:\n        if checked.get(i, -1) != -1:\n            i += 1\n            continue\n        curr = i\n        dist = {}\n        distance = 0\n        while checked.get(curr, -1) == -1:\n            if curr == i:\n                path[i] = []\n            else:\n                distance += 1\n                dist[curr] = distance\n                path[i].append(curr)\n            checked[curr] = 1\n            curr = (curr + arr[curr] + 1) % n\n        if dist.get(curr, -1) != -1:\n            chk = 1\n        else:\n            chk = 0\n        if curr != i and chk == 1:\n            ans += distance - dist[curr] + 1\n        elif curr == i:\n            ans += len(path[i]) + 1\n        i += 1\n    print(ans)", "t = int(input())\nans = []\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    mapping = []\n    for j in range(n):\n        a[j] = a[j] % n\n        if n - j - 1 > a[j]:\n            mapping.append(j + a[j] + 1)\n        else:\n            mapping.append(a[j] - (n - j - 1))\n    loops = [0 for j in range(n)]\n    for j in range(n):\n        indices = []\n        curr_index = j\n        while True:\n            if indices.__contains__(curr_index):\n                lb = indices.index(curr_index)\n                for x in indices[lb:]:\n                    loops[x] = 1\n                break\n            elif loops[curr_index] == 1:\n                break\n            elif loops[curr_index] == -1:\n                break\n            else:\n                indices.append(curr_index)\n                loops[curr_index] = -1\n                curr_index = mapping[curr_index]\n    ans.append(loops.count(1))\nfor i in ans:\n    print(i)", "def main():\n    testCases = int(input())\n    while testCases != 0:\n        testCases -= 1\n        solve()\n\ndef solve():\n    N = int(input())\n    taste = [int(i) for i in input().strip().split(' ')]\n    visited = [False] * N\n    arr = [0] * N\n    indexSet = set()\n    for i in range(N):\n        indexSet.add(i)\n    while len(indexSet) != 0:\n        index = indexSet.pop()\n        thisVisit = set()\n        while arr[index] != 2:\n            if visited[index]:\n                break\n            arr[index] += 1\n            thisVisit.add(index)\n            index = (index + taste[index] + 1) % N\n        for i in thisVisit:\n            visited[i] = True\n    count = 0\n    for i in arr:\n        if i == 2:\n            count += 1\n    print(count)\nmain()", "cas = int(input())\nfor t in range(cas):\n    n = int(input())\n    boxes = list(map(int, input().split()))\n    circle = [0 for i in range(n)]\n    for i in range(n):\n        if circle[i] == 0:\n            visited = []\n            curr = i\n            while True:\n                visited.append(curr)\n                curr = curr + (boxes[curr] + 1)\n                curr = curr % n\n                if circle[curr] == 1 or circle[curr] == -1:\n                    circle[i] = -1\n                    break\n                elif curr in visited:\n                    idx = visited.index(curr)\n                    for j in visited[idx:]:\n                        circle[j] = 1\n                    for k in visited[:idx]:\n                        circle[k] = -1\n                    break\n    magk = circle.count(1)\n    print(magk)", "nn = int(input())\n\ndef func1():\n    n = int(input())\n    ll = list(map(int, input().split()))\n    prev = [[] for _ in range(n)]\n    for i in range(n):\n        nxt = (i + ll[i] + 1) % n\n        prev[nxt].append(i)\n    for i in range(n):\n        if not prev[i]:\n            j = i\n            while True:\n                nxt = (j + ll[j] + 1) % n\n                if j in prev[nxt]:\n                    prev[nxt].remove(j)\n                if prev[nxt]:\n                    break\n                j = nxt\n    magic = 0\n    for i in range(n):\n        if prev[i]:\n            magic += 1\n    return magic\nans = []\nfor _ in range(nn):\n    ans.append(func1())\nfor a in ans:\n    print(a)", "import sys\nF = sys.stdin\n\ndef f(a, n):\n    for i in range(n):\n        a[i] = (a[i] + i + 1) % n\n    ret = [0] * n\n    for i in range(n):\n        if ret[i] > 0:\n            continue\n        j = i + 2\n        while ret[i] == 0:\n            ret[i] = j\n            i = a[i]\n        while ret[i] == j:\n            ret[i] = 1\n            i = a[i]\n    return sum((1 for x in ret if x == 1))\n\ndef get_ints():\n    return list(map(int, F.readline().split()))\nt = int(F.readline())\nfor i in range(t):\n    n = int(F.readline())\n    print(f(get_ints(), n))", "import sys\ncases = int(input())\nwhile cases > 0:\n    cases -= 1\n    lsize = int(input())\n    data = input()\n    data = list(map(int, data.split()))\n    count = 0\n    for x in data:\n        data[count] = (x + 1 + count) % lsize\n        count += 1\n    count = 0\n    result = 0\n    visited = [False] * lsize\n    inLoop = [0] * lsize\n    for i in range(0, lsize):\n        if not visited[i]:\n            visited[i] = True\n            k = data[i]\n            count += 1\n            tmp = False\n            while count <= lsize and (not tmp):\n                if not visited[k]:\n                    count += 1\n                    visited[k] = True\n                    k = data[k]\n                elif inLoop[k] == 0:\n                    inLoop[i] = -1\n                    j = data[i]\n                    while j != k:\n                        inLoop[j] = -1\n                        j = data[j]\n                    inLoop[k] = 1\n                    j = data[k]\n                    while j != k:\n                        inLoop[j] = 1\n                        j = data[j]\n                    tmp = True\n                elif inLoop[k] != 0:\n                    inLoop[i] = -1\n                    j = data[i]\n                    while j != k:\n                        inLoop[j] = -1\n                        j = data[j]\n                    tmp = True\n    print(inLoop.count(1))", "def nextver(l1, x):\n    while l1[x] == 0:\n        x += 1\n    return x\n\ndef ans(l, l1, n, t, s):\n    if t > 0:\n        i = nextver(l1, s)\n        s = i\n        tt = []\n        while l1[i] != 0:\n            tt += [i]\n            l1[i] = 0\n            t -= 1\n            i = (i + 1 + l[i]) % n\n            if s - i == 1:\n                s = i + 1\n        if i in tt:\n            return (l, l1, len(tt) - tt.index(i), t, s)\n        else:\n            return (l, l1, 0, t, s)\n    else:\n        return (l, l1, -1, t, s)\ntest = int(input())\nwhile test != 0:\n    test -= 1\n    n = int(input())\n    l = list(map(int, input().split()))\n    l1 = [1] * n\n    t = n\n    s = 0\n    (l, l1, k, t, s) = ans(l, l1, n, t, s)\n    a = 0\n    while k != -1:\n        a += k\n        (l, l1, k, t, s) = ans(l, l1, n, t, s)\n    print(a)", "t = int(input())\nans = []\nfor i in range(t):\n    n = int(input())\n    a = []\n    an = 0\n    ta = [0] * n\n    a.extend(map(int, input().split()))\n    for j in range(n):\n        if ta[j] == 1:\n            continue\n        l = j\n        k = 0\n        v = []\n        while ta[l] == 0:\n            ta[l] = 1\n            v.append(l)\n            k = k + a[l] + 1\n            l = (l + a[l] + 1) % n\n        if k >= n:\n            try:\n                an = an + len(v) - v.index(l)\n            except:\n                an = an\n    ans.append(an)\nfor i in range(t):\n    print(ans[i])", "a = int(input())\nwhile a > 0:\n    n = int(input())\n    move = list()\n    visited = [0] * n\n    arr = list(map(int, input().split(' ')))\n    for i in range(0, n):\n        move.insert(i, (i + arr[i] + 1) % n)\n    count = 0\n    for i in range(0, n):\n        j = i\n        se = set()\n        se.clear()\n        if j not in se:\n            while visited[j] < 3:\n                if j not in se:\n                    se.add(j)\n                    visited[j] += 1\n                    j = move[j]\n                elif j in se:\n                    if visited[j] == 1:\n                        visited[j] += 1\n                        j = move[j]\n                    elif visited[j] == 2:\n                        count += 1\n                        visited[j] += 1\n                        j = move[j]\n                    else:\n                        break\n    print(count)\n    a = a - 1", "t = int(input())\nfor test in range(t):\n    N = int(input())\n    A = list(map(int, input().split()))\n    vis = [0] * N\n    what = [0] * N\n    counter = 1\n    ans = 0\n    for i in range(N):\n        if vis[i]:\n            continue\n        j = i\n        cnt = 0\n        while not vis[j]:\n            what[j] = cnt\n            vis[j] = counter\n            cnt += 1\n            j = (j + A[j] + 1) % N\n        if vis[j] == counter:\n            ans += cnt - what[j]\n        counter += 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [0] * len(a)\n    cl = 0\n    ans = 0\n    for i in range(n):\n        if b[i] == 0:\n            cl += 1\n            j = i\n            idx = []\n            while b[j] == 0:\n                b[j] = cl\n                idx.append(j)\n                j += a[j] + 1\n                j %= n\n            if b[j] == cl:\n                ans += 1\n                while idx != [] and idx.pop() != j:\n                    ans += 1\n    print(ans)", "import sys\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    a = []\n    a = map(int, sys.stdin.readline().split())\n    a = list(a)\n    b = [-1] * n\n    vis = []\n    vis = [0] * n\n    se = set()\n    c = [0] * n\n    for i in range(n):\n        x = a[i]\n        if x > n - 1:\n            x = x % n\n        b[i] = (x + i + 1) % n\n    t = 0\n    su = 0\n    for i in range(n):\n        s = []\n        z = i\n        while vis[z] != 1:\n            vis[z] = 1\n            s.append(z)\n            z = b[z]\n        if len(s) > 0 and z in s:\n            y = s.index(z)\n            t = len(s[y:])\n            su = su + t\n    print(su)", "for t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = [-1] * n\n    repeat = [0] * n\n    for i in range(n):\n        j = i\n        pair = []\n        again = False\n        if repeat[j] == 2 or repeat[j] == 1:\n            continue\n        while True:\n            pair.append(j)\n            repeat[j] = 1\n            if b[j] == -1:\n                b[j] = (a[j] + j + 1) % n\n            j = b[j]\n            if repeat[j] == 2:\n                again = True\n                break\n            if j in pair:\n                again = False\n                break\n            if repeat[j] == 1:\n                again = True\n                break\n        if again:\n            continue\n        index = pair.index(j)\n        for x in range(index, len(pair)):\n            repeat[pair[x]] = 2\n    count = 0\n    for i in range(n):\n        if repeat[i] == 2:\n            count += 1\n    print(count)", "for t in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    l = list()\n    for i in range(n):\n        l.append(0)\n    for i in range(n):\n        l[(i + a[i] + 1) % n] += 1\n    l1 = []\n    for i in range(n):\n        if l[i] == 0:\n            l1.append(i)\n    for i in l1:\n        j = i\n        while True:\n            j = (j + a[j] + 1) % n\n            l[j] -= 1\n            if l[j] > 0:\n                break\n    count = 0\n    for i in l:\n        if i > 0:\n            count += 1\n    print(count)", "def ismagic(A, N, Tested):\n    ret = 0\n    for i in range(N):\n        if Tested[i] == 0:\n            nextbox = i\n            loop = []\n            while Tested[nextbox] == 0:\n                Tested[nextbox] = 1\n                loop += [nextbox]\n                nextbox = A[nextbox]\n            if nextbox in loop:\n                ret += len(loop) - loop.index(nextbox)\n    return ret\nT = int(input().strip())\nfor i in range(T):\n    N = int(input().strip())\n    A0 = list(map(int, input().strip().split(' ')))\n    A = {}\n    Tested = {}\n    for i in range(N):\n        A[i] = (i + A0[i] + 1) % N\n        Tested[i] = 0\n    print(ismagic(A, N, Tested))", "import sys\nsys.setrecursionlimit(100010)\n\ndef dfs(g, s, visited, st, depth):\n    st[s] = depth[0]\n    visited[s] = True\n    for v in g[s]:\n        if v in st:\n            return depth[0] - st[v] + 1\n        elif not visited[v]:\n            depth[0] += 1\n            return dfs(g, v, visited, st, depth)\n    return 0\nfor t in range(int(input())):\n    N = int(input())\n    arr = list(map(int, input().split()))\n    g = [[] for i in range(N)]\n    for (i, x) in enumerate(arr):\n        to = (i + x + 1) % N\n        g[i].append(to)\n    visited = [False for i in range(N)]\n    ans = 0\n    for i in range(N):\n        if not visited[i]:\n            st = {}\n            depth = [1]\n            ans += dfs(g, i, visited, st, depth)\n    print(ans)", "t = int(input())\nfor t0 in range(t):\n    n = int(input())\n    li = [int(i) for i in input().strip().split()]\n    gr = dict()\n    for i in range(n):\n        b = (i + li[i] + 1) % n\n        gr[i] = b\n    st = set([i for i in range(n)])\n    ct = 0\n    fc = [False for i in range(n)]\n    while st:\n        ele = st.pop()\n        st.add(ele)\n        a = ele\n        cts = 0\n        while not fc[ele]:\n            cts += 1\n            fc[ele] = True\n            st.remove(ele)\n            ele = gr[ele]\n        if a != ele:\n            tp = a\n            ctt = 0\n            while tp != ele:\n                tp = gr[tp]\n                ctt += 1\n            cts -= ctt\n            ct += cts\n        elif a == ele:\n            ct += cts\n    print(ct)", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    nxt = [0] * n\n    for (i, j) in enumerate(arr):\n        nxt[i] = (i + j + 1) % n\n    rst = 0\n    grp = [None] * n\n    for i in range(n):\n        if grp[i] is not None:\n            continue\n        stack = deque()\n        j = i\n        while grp[j] is None:\n            stack.append(j)\n            grp[j] = i\n            j = nxt[j]\n        if grp[j] != i:\n            continue\n        k = None\n        while stack and k != j:\n            k = stack.pop()\n            rst += 1\n    print(rst)", "for _ in range(int(input())):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    nxt = [0] * n\n    for (i, j) in enumerate(arr):\n        nxt[i] = (i + j + 1) % n\n    rst = 0\n    grp = [None] * n\n    for i in range(n):\n        if grp[i] is not None:\n            continue\n        stack = []\n        j = i\n        while grp[j] is None:\n            stack.append(j)\n            grp[j] = i\n            j = nxt[j]\n        if grp[j] != i:\n            continue\n        k = None\n        while stack and k != j:\n            k = stack.pop()\n            rst += 1\n    print(rst)", "for _ in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    ans = 0\n    i = 0\n    checked = {}\n    path = {}\n    while i < n:\n        if checked.get(i, -1) != -1:\n            i += 1\n            continue\n        curr = i\n        dist = {}\n        distance = 0\n        while checked.get(curr, -1) == -1:\n            if curr == i:\n                path[i] = []\n            else:\n                distance += 1\n                dist[curr] = distance\n                path[i].append(curr)\n            checked[curr] = 1\n            curr = (curr + arr[curr] + 1) % n\n        if dist.get(curr, -1) != -1:\n            chk = 1\n        else:\n            chk = 0\n        if curr != i and chk == 1:\n            ans += distance - dist[curr] + 1\n        elif curr == i:\n            ans += len(path[i]) + 1\n        i += 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    B = [False for _ in range(n)]\n    A = [int(i) for i in input().split()]\n    special = [0 for _ in range(n)]\n    for i in range(n):\n        j = i\n        if B[i]:\n            continue\n        V = {}\n        while not B[j] and (not V.get(j, False)):\n            V[j] = True\n            j = (j + 1 + A[j]) % n\n        store = B[j]\n        ls = j\n        j = i\n        while not B[j]:\n            B[j] = True\n            j = (j + 1 + A[j]) % n\n        if special[j] or store:\n            continue\n        j = ls\n        special[j] = 1\n        j = (j + 1 + A[j]) % n\n        while j != ls:\n            special[j] = 1\n            j = (j + 1 + A[j]) % n\n    print(sum(special))", "t = int(input())\nfor t0 in range(t):\n    n = int(input())\n    li = [int(i) for i in input().strip().split()]\n    gr = dict()\n    for i in range(n):\n        b = (i + li[i] + 1) % n\n        gr[i] = b\n    st = set([i for i in range(n)])\n    ct = 0\n    fc = [False for i in range(n)]\n    while st:\n        ele = st.pop()\n        st.add(ele)\n        a = ele\n        cts = 0\n        while not fc[ele]:\n            cts += 1\n            fc[ele] = True\n            st.remove(ele)\n            ele = gr[ele]\n        if a != ele:\n            tp = a\n            ctt = 0\n            while tp != ele:\n                tp = gr[tp]\n                ctt += 1\n            cts -= ctt\n            ct += cts\n        elif a == ele:\n            ct += cts\n    print(ct)", "for t in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    special = set()\n    notsospecial = set()\n    i = 0\n    while len(special) + len(notsospecial) < n:\n        if i in special or i in notsospecial:\n            i += 1\n            continue\n        path = [i]\n        j = (i + a[i] + 1) % n\n        while True:\n            if j in special or j in notsospecial:\n                notsospecial.update(set(path))\n                break\n            if j in path:\n                istar = path.index(j)\n                special.update(set(path[istar:]))\n                notsospecial.update(set(path[:istar]))\n                break\n            path.append(j)\n            j = (j + a[j] + 1) % n\n        i += 1\n    print(len(special))", "for _ in range(int(input())):\n    n = int(input())\n    graph = [0] * n\n    vis = [False] * n\n    inloop = [0] * n\n    arr = list(map(int, input().split()))\n    for i in range(n):\n        graph[i] = (i + 1 + arr[i]) % n\n    for i in range(n):\n        if not vis[i]:\n            stk = [i]\n            vis[i] = True\n            while stk:\n                j = graph[i]\n                if vis[j]:\n                    if inloop[j] == 0:\n                        inloop[j] = 1\n                        x = stk.pop()\n                        inloop[x] = 1\n                        while x != j:\n                            inloop[x] = 1\n                            x = stk.pop()\n                        while stk:\n                            x = stk.pop()\n                            inloop[x] = -1\n                    elif inloop[j] == 1 or inloop[j] == -1:\n                        while stk:\n                            x = stk.pop()\n                            inloop[x] = -1\n                else:\n                    vis[j] = True\n                    stk.append(j)\n                    i = j\n    print(inloop.count(1))", "T = int(input())\nfor t in range(T):\n    N = int(input())\n    A = list(map(int, input().split()))\n    M = [-1] * N\n    for i in range(N):\n        if M[i] < 0:\n            k = i\n            while M[k] < 0:\n                M[k] = i + 1\n                k += A[k] + 1\n                k %= N\n            while M[k] == i + 1:\n                M[k] = 0\n                k += A[k] + 1\n                k %= N\n    print(len(list(filter(lambda x: x == 0, M))))"]