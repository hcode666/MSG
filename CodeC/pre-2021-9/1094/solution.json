["import sys\nsys.setrecursionlimit(10000000)\n\ndef dfs(x):\n    if x in b:\n        l = b[x][0]\n        r = b[x][1]\n        dfs(l)\n        if mn[x - 1] > mn[l - 1]:\n            mn[x - 1] = mn[l - 1]\n        if mx[x - 1] < mx[l - 1]:\n            mx[x - 1] = mx[l - 1]\n        dfs(r)\n        if mn[x - 1] > mn[r - 1]:\n            mn[x - 1] = mn[r - 1]\n        if mx[x - 1] < mx[r - 1]:\n            mx[x - 1] = mx[r - 1]\n    else:\n        return\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    b = {}\n    mn = [10000000] * n\n    mx = [0] * n\n    ans = 0\n    for j in range(n):\n        (y, z) = map(int, input().split())\n        if y == -1:\n            mn[j] = z\n            mx[j] = z\n        else:\n            b[j + 1] = [y, z]\n    dfs(1)\n    for j in range(1, n + 1):\n        if j in b:\n            l = b[j][0]\n            r = b[j][1]\n            if mx[l - 1] < mn[r - 1]:\n                continue\n            elif mx[r - 1] < mn[l - 1]:\n                ans += 1\n            else:\n                ans = -1\n                break\n    print(ans)", "import sys\nsys.setrecursionlimit(10000000)\n\ndef dfs(x):\n    if x in b:\n        l = b[x][0]\n        r = b[x][1]\n        dfs(l)\n        if mn[x - 1] > mn[l - 1]:\n            mn[x - 1] = mn[l - 1]\n        if mx[x - 1] < mx[l - 1]:\n            mx[x - 1] = mx[l - 1]\n        dfs(r)\n        if mn[x - 1] > mn[r - 1]:\n            mn[x - 1] = mn[r - 1]\n        if mx[x - 1] < mx[r - 1]:\n            mx[x - 1] = mx[r - 1]\n    else:\n        return\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    b = {}\n    mn = [10000000] * n\n    mx = [0] * n\n    ans = 0\n    for j in range(n):\n        (y, z) = map(int, input().split())\n        if y == -1:\n            mn[j] = z\n            mx[j] = z\n        else:\n            b[j + 1] = [y, z]\n    dfs(1)\n    for j in range(1, n + 1):\n        if j in b:\n            l = b[j][0]\n            r = b[j][1]\n            if mx[l - 1] < mn[r - 1]:\n                continue\n            elif mx[r - 1] < mn[l - 1]:\n                ans += 1\n            else:\n                ans = -1\n                break\n    print(ans)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    D = {}\n    for i in range(n):\n        D[i + 1] = list(map(int, input().split()))\n    queue = []\n    tup = [0]\n    queue.append(D[1])\n    while len(queue) > 0:\n        ele = queue.pop(0)\n        tup.append(ele)\n        if ele[0] == -1:\n            continue\n        else:\n            queue.append(D[ele[0]])\n            queue.append(D[ele[1]])\n    count_swap = 0\n    parent = n\n    flag = 1\n    while parent != 0:\n        if tup[parent][0] == -1:\n            tup[parent].append(tup[parent][1])\n            tup[parent].append(tup[parent][1])\n        else:\n            left_min = D[tup[parent][0]][2]\n            left_max = D[tup[parent][0]][3]\n            right_min = D[tup[parent][1]][2]\n            right_max = D[tup[parent][1]][3]\n            if left_max < right_min:\n                tup[parent].append(left_min)\n                tup[parent].append(right_max)\n            elif left_min > right_max:\n                count_swap += 1\n                tup[parent].append(right_min)\n                tup[parent].append(left_max)\n            else:\n                flag = 0\n                break\n        parent -= 1\n    if not flag:\n        print(-1)\n    else:\n        print(count_swap)"]