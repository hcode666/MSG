["from fractions import Fraction\n\ndef determinant(mat):\n    res = Fraction(1, 1)\n    n = len(mat)\n    for i in range(n):\n        if mat[i][i] == Fraction(0):\n            for j in range(i + 1, n):\n                if mat[j][i] != Fraction(0):\n                    swap(mat[i][j])\n                    res *= -1.0\n                    break\n        if mat[i][i] == 0:\n            return Fraction(0)\n        res *= mat[i][i]\n        for j in range(i + 1, n):\n            f = Fraction(1) * mat[j][i] / mat[i][i]\n            for k in range(i, n):\n                mat[j][k] -= f * mat[i][k]\n    return res\n\nclass UnionFind:\n\n    def __init__(self, maxSize):\n        self.parent = [i for i in range(maxSize)]\n        self.treeHeight = [1 for i in range(maxSize)]\n        self.treeSize = [1 for i in range(maxSize)]\n\n    def find(self, x):\n        root = x\n        while self.parent[root] != root:\n            root = self.parent[root]\n        climbingNode = x\n        while climbingNode != root:\n            temp = self.parent[climbingNode]\n            self.parent[climbingNode] = root\n            climbingNode = temp\n        return root\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if self.treeHeight[rootX] < self.treeHeight[rootY]:\n            (rootX, rootY) = (rootY, rootX)\n        if self.treeHeight[rootX] == self.treeHeight[rootY]:\n            self.treeHeight[rootX] += 1\n        self.parent[rootY] = rootX\n        self.treeSize[rootX] += self.treeHeight[rootY]\nt = int(input())\nfor tests in range(t):\n    n = int(input())\n    graph = []\n    for i in range(n):\n        graph.append(list(map(int, list(input().strip()))))\n    unf = UnionFind(n)\n    m = int(input())\n    notPossible = False\n    favs = []\n    for i in range(m):\n        favs.append(list(map(int, list(input().strip().split()))))\n    for i in range(m):\n        (a, b) = favs[i]\n        if unf.find(a - 1) == unf.find(b - 1):\n            notPossible = True\n            break\n        unf.union(a - 1, b - 1)\n    if notPossible:\n        print(0)\n        continue\n    parent = [unf.find(i) for i in range(n)]\n    parent.sort()\n    indices = [parent[0]]\n    for i in parent[1:]:\n        if i != indices[-1]:\n            indices.append(i)\n    newSize = len(indices)\n    newGraph = [[0 for i in range(newSize)] for j in range(newSize)]\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] == 1 and unf.find(i) != unf.find(j):\n                newGraph[indices.index(unf.find(i))][indices.index(unf.find(j))] -= 1\n    if newSize == 1:\n        print(1)\n        continue\n    for i in range(newSize):\n        newGraph[i][i] = -1 * sum(newGraph[i])\n    newGraph.pop()\n    for i in range(len(newGraph)):\n        newGraph[i].pop()\n    for i in range(len(newGraph)):\n        for j in range(len(newGraph)):\n            newGraph[i][j] = Fraction(newGraph[i][j], 1)\n    ans = int(determinant(newGraph))\n    print(ans)", "from fractions import Fraction\n\ndef determinant(mat):\n    res = Fraction(1, 1)\n    n = len(mat)\n    for i in range(n):\n        if mat[i][i] == Fraction(0):\n            for j in range(i + 1, n):\n                if mat[j][i] != Fraction(0):\n                    swap(mat[i][j])\n                    res *= -1.0\n                    break\n        if mat[i][i] == 0:\n            return Fraction(0)\n        res *= mat[i][i]\n        for j in range(i + 1, n):\n            f = Fraction(1) * mat[j][i] / mat[i][i]\n            for k in range(i, n):\n                mat[j][k] -= f * mat[i][k]\n    return res\n\nclass UnionFind:\n\n    def __init__(self, maxSize):\n        self.parent = [i for i in range(maxSize)]\n        self.treeHeight = [1 for i in range(maxSize)]\n        self.treeSize = [1 for i in range(maxSize)]\n\n    def find(self, x):\n        root = x\n        while self.parent[root] != root:\n            root = self.parent[root]\n        climbingNode = x\n        while climbingNode != root:\n            temp = self.parent[climbingNode]\n            self.parent[climbingNode] = root\n            climbingNode = temp\n        return root\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if self.treeHeight[rootX] < self.treeHeight[rootY]:\n            (rootX, rootY) = (rootY, rootX)\n        if self.treeHeight[rootX] == self.treeHeight[rootY]:\n            self.treeHeight[rootX] += 1\n        self.parent[rootY] = rootX\n        self.treeSize[rootX] += self.treeHeight[rootY]\nt = int(input())\nfor tests in range(t):\n    n = int(input())\n    graph = []\n    for i in range(n):\n        graph.append(list(map(int, list(input().strip()))))\n    unf = UnionFind(n)\n    m = int(input())\n    notPossible = False\n    favs = []\n    for i in range(m):\n        favs.append(list(map(int, list(input().strip().split()))))\n    for i in range(m):\n        (a, b) = favs[i]\n        if unf.find(a - 1) == unf.find(b - 1):\n            notPossible = True\n            break\n        unf.union(a - 1, b - 1)\n    if notPossible:\n        print(0)\n        continue\n    parent = [unf.find(i) for i in range(n)]\n    parent.sort()\n    indices = [parent[0]]\n    for i in parent[1:]:\n        if i != indices[-1]:\n            indices.append(i)\n    newSize = len(indices)\n    newGraph = [[0 for i in range(newSize)] for j in range(newSize)]\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] == 1 and unf.find(i) != unf.find(j):\n                newGraph[indices.index(unf.find(i))][indices.index(unf.find(j))] -= 1\n    if newSize == 1:\n        print(1)\n        continue\n    for i in range(newSize):\n        newGraph[i][i] = -1 * sum(newGraph[i])\n    newGraph.pop()\n    for i in range(len(newGraph)):\n        newGraph[i].pop()\n    for i in range(len(newGraph)):\n        for j in range(len(newGraph)):\n            newGraph[i][j] = Fraction(newGraph[i][j], 1)\n    ans = int(determinant(newGraph))\n    print(ans)", "from fractions import Fraction\n\ndef determinant(mat):\n    res = Fraction(1, 1)\n    n = len(mat)\n    for i in range(n):\n        if mat[i][i] == Fraction(0):\n            for j in range(i + 1, n):\n                if mat[j][i] != Fraction(0):\n                    swap(mat[i][j])\n                    res *= -1.0\n                    break\n        if mat[i][i] == 0:\n            return Fraction(0)\n        res *= mat[i][i]\n        for j in range(i + 1, n):\n            f = Fraction(1) * mat[j][i] / mat[i][i]\n            for k in range(i, n):\n                mat[j][k] -= f * mat[i][k]\n    return res\n\nclass UnionFind:\n\n    def __init__(self, maxSize):\n        self.parent = [i for i in range(maxSize)]\n        self.treeHeight = [1 for i in range(maxSize)]\n        self.treeSize = [1 for i in range(maxSize)]\n\n    def find(self, x):\n        root = x\n        while self.parent[root] != root:\n            root = self.parent[root]\n        climbingNode = x\n        while climbingNode != root:\n            temp = self.parent[climbingNode]\n            self.parent[climbingNode] = root\n            climbingNode = temp\n        return root\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if self.treeHeight[rootX] < self.treeHeight[rootY]:\n            (rootX, rootY) = (rootY, rootX)\n        if self.treeHeight[rootX] == self.treeHeight[rootY]:\n            self.treeHeight[rootX] += 1\n        self.parent[rootY] = rootX\n        self.treeSize[rootX] += self.treeHeight[rootY]\nt = int(input())\nfor tests in range(t):\n    n = int(input())\n    graph = []\n    for i in range(n):\n        graph.append(list(map(int, list(input().strip()))))\n    unf = UnionFind(n)\n    m = int(input())\n    notPossible = False\n    favs = []\n    for i in range(m):\n        favs.append(list(map(int, list(input().strip().split()))))\n    for i in range(m):\n        (a, b) = favs[i]\n        if unf.find(a - 1) == unf.find(b - 1):\n            notPossible = True\n            break\n        unf.union(a - 1, b - 1)\n    if notPossible:\n        print(0)\n        continue\n    parent = [unf.find(i) for i in range(n)]\n    parent.sort()\n    indices = [parent[0]]\n    for i in parent[1:]:\n        if i != indices[-1]:\n            indices.append(i)\n    newSize = len(indices)\n    newGraph = [[0 for i in range(newSize)] for j in range(newSize)]\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] == 1 and unf.find(i) != unf.find(j):\n                newGraph[indices.index(unf.find(i))][indices.index(unf.find(j))] -= 1\n    if newSize == 1:\n        print(1)\n        continue\n    for i in range(newSize):\n        newGraph[i][i] = -1 * sum(newGraph[i])\n    newGraph.pop()\n    for i in range(len(newGraph)):\n        newGraph[i].pop()\n    for i in range(len(newGraph)):\n        for j in range(len(newGraph)):\n            newGraph[i][j] = Fraction(newGraph[i][j], 1)\n    ans = int(determinant(newGraph))\n    print(ans)"]