["from itertools import combinations\nimport random\n\ndef dc(a, b):\n    c = a ^ b\n    c = int(2 ** (c.bit_length() - 1))\n    return c\n\ndef cal2(a):\n    a.sort()\n    mp = int(2 ** (a[-1].bit_length() - 1))\n    while len(a) > 1:\n        p = 0\n        if a[0] == mp and len(a) > 2:\n            p = 1\n        c = a[p] ^ a[-1]\n        c = int(2 ** (c.bit_length() - 1))\n        del a[-1]\n        a[p] = c\n        a.sort()\n    return a[0]\n\ndef cal(a):\n    la = len(a)\n    a.sort()\n    mp = int(2 ** (a[-1].bit_length() - 1))\n    mc = 0\n    for x in a:\n        if x >= mp:\n            mc += 1\n    if la == 2:\n        return dc(a[0], a[1])\n    if la == 3:\n        if mc == 1:\n            return mp\n        return min(dc(dc(a[0], a[1]), a[2]), dc(dc(a[2], a[1]), a[0]), dc(dc(a[0], a[2]), a[1]))\n    if la == 4:\n        if mc == 1:\n            return mp\n        if mc == 2:\n            return 0\n        if mc == 3:\n            return mp\n        if mc == 4:\n            return min(dc(dc(dc(a[0], a[1]), a[2]), a[3]), dc(dc(dc(a[2], a[1]), a[0]), a[3]), dc(dc(dc(a[0], a[2]), a[1]), a[3]), dc(dc(a[0], a[1]), dc(a[2], a[3])), dc(dc(a[0], a[2]), dc(a[1], a[3])), dc(dc(a[0], a[3]), dc(a[2], a[1])), dc(dc(dc(a[3], a[1]), a[2]), a[0]), dc(dc(dc(a[3], a[1]), a[0]), a[2]), dc(dc(dc(a[3], a[2]), a[0]), a[1]))\n    if la == 5:\n        if mc == 1:\n            return mp\n        if mc == 2:\n            return 0\n        if mc == 3:\n            return mp\n        if mc == 4:\n            return 0\n        if mc == 5:\n            return mp\nn = int(input())\na = list(map(int, input().split()))\nif True:\n    result = 0\n    res1 = result\n    result = 0\n    ph = {}\n    ap = [0 for _ in range(n)]\n    for i in range(n):\n        ap[i] = int(2 ** (a[i].bit_length() - 1))\n    for i in range(n):\n        result += a[i]\n    for i in range(n):\n        for j in range(max(i - 4, 0), i):\n            v1 = cal(ap[j:i + 1])\n            v2 = cal(a[j:i + 1])\n            if v1 != v2:\n                result += abs(v1 - v2)\n    for i in range(n):\n        p = ap[i]\n        phn = {}\n        s = 0\n        for (k, v) in ph.items():\n            (lp, le) = k\n            if p < lp:\n                phn[k] = v\n            if p > lp:\n                s += v\n        if (p, 0) in ph:\n            phn[p, 1] = ph[p, 0] + 1 + s\n        else:\n            phn[p, 1] = 1 + s\n        if (p, 1) in ph:\n            phn[p, 0] = ph[p, 1]\n        ph = phn\n        tr = 0\n        for (k, v) in ph.items():\n            (lp, le) = k\n            if le == 1:\n                if lp == p:\n                    tr += lp * (v - 1)\n                else:\n                    tr += lp * v\n        result += tr\n        result = result % 998244353\n    print(result)", "import sys\nimport math\nfrom collections import defaultdict, Counter\ninput = sys.stdin.readline\n\ndef print(x):\n    sys.stdout.write(str(x) + '\\n')\n\ndef find(a, b, c):\n    cur = a ^ b\n    if cur == 0:\n        now = 0\n    else:\n        now = pow(2, int(math.log2(cur)))\n    if now == c:\n        return -1\n    cur = now ^ c\n    mi = int(math.log2(cur))\n    cur = a ^ c\n    if cur == 0:\n        now = 0\n    else:\n        now = pow(2, int(math.log2(cur)))\n    if now == b:\n        return -1\n    cur = now ^ b\n    mi = min(mi, int(math.log2(cur)))\n    cur = c ^ b\n    if cur == 0:\n        now = 0\n    else:\n        now = pow(2, int(math.log2(cur)))\n    if now == a:\n        return -1\n    cur = now ^ a\n    mi = min(mi, int(math.log2(cur)))\n    return mi\nmod = 998244353\nn = int(input())\na = list(map(int, input().split()))\nl = [0] * n\nf = [0] * 32\nfor i in range(31):\n    f[i] = 1 << i\npre = [0] * n\nind = [[0, 0]] * n\nans = a[0] % mod\nif a[0] == 0:\n    l[0] = -1\n    pre[0] = 0\nelse:\n    b = math.log2(a[0])\n    l[0] = int(b)\n    pre[0] = f[l[0]]\nind[0] = [l[0], 0]\ntop = 0\nfor i in range(1, n):\n    ans = (ans + a[i]) % mod\n    if a[i] == 0:\n        l[i] = -1\n    else:\n        b = math.log2(a[i])\n        l[i] = int(b)\n    while l[i] > ind[top][0]:\n        top -= 1\n        if top == -1:\n            break\n    if top == -1:\n        pre[i] = f[l[i]] * i\n        ans = (ans + pre[i]) % mod\n        pre[i] = (pre[i] + f[l[i]]) % mod\n    else:\n        pre[i] = f[l[i]] * (i - ind[top][1] - 1)\n        ans = (ans + pre[i]) % mod\n        pre[i] = (pre[i] + f[l[i]]) % mod\n        if l[i] == ind[top][0]:\n            top1 = top - 1\n            if top1 != -1:\n                pre[i] = (pre[i] + pre[ind[top1][1]]) % mod\n                ans = (ans + pre[ind[top1][1]]) % mod\n        else:\n            ans = (ans + pre[ind[top][1]]) % mod\n            pre[i] = (pre[i] + pre[ind[top][1]]) % mod\n    top += 1\n    ind[top] = [l[i], i]\nfor i in range(n - 1):\n    d = defaultdict(int)\n    ma = max(l[i], l[i + 1])\n    d[l[i]] = 1\n    d[l[i + 1]] += 1\n    if l[i] == l[i + 1]:\n        cur = a[i] ^ a[i + 1]\n        if cur != 0:\n            b = int(math.log2(cur))\n            ans = (ans + f[b]) % mod\n    for j in range(i + 2, min(n, i + 4)):\n        d[l[j]] += 1\n        ma = max(ma, l[j])\n        if d[ma] & 1:\n            pass\n        elif d[ma] == 2 and j == i + 2:\n            cur = find(a[i], a[i + 1], a[i + 2])\n            ans = (ans + f[cur]) % mod\n        elif d[ma] == 4:\n            p = a[i] ^ a[i + 1]\n            if p == 0:\n                now = 0\n            else:\n                now = f[int(math.log2(p))]\n            cur = find(now, a[i + 2], a[i + 3])\n            p = a[i] ^ a[i + 2]\n            if p == 0:\n                now = 0\n            else:\n                now = f[int(math.log2(p))]\n            cur = min(cur, find(now, a[i + 1], a[i + 3]))\n            p = a[i] ^ a[i + 3]\n            if p == 0:\n                now = 0\n            else:\n                now = f[int(math.log2(p))]\n            cur = min(cur, find(now, a[i + 1], a[i + 2]))\n            p = a[i + 1] ^ a[i + 2]\n            if p == 0:\n                now = 0\n            else:\n                now = f[int(math.log2(p))]\n            cur = min(cur, find(now, a[i], a[i + 3]))\n            p = a[i + 1] ^ a[i + 3]\n            if p == 0:\n                now = 0\n            else:\n                now = f[int(math.log2(p))]\n            cur = min(cur, find(now, a[i], a[i + 2]))\n            p = a[i + 3] ^ a[i + 2]\n            if p == 0:\n                now = 0\n            else:\n                now = f[int(math.log2(p))]\n            cur = min(cur, find(now, a[i + 1], a[i]))\n            ans = (ans + f[cur]) % mod\nprint(ans)"]