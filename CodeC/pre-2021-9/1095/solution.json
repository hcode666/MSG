["import math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom functools import reduce\nimport operator as op\nMOD = 10 ** 9 + 7\n\ndef ncr(n, m):\n    if m > n:\n        return 0\n    numer = reduce(op.mul, range(n, n - m, -1), 1)\n    denom = reduce(op.mul, range(1, m + 1), 1)\n    return numer // denom\n\ndef solve(N, K):\n    if N < K:\n        return 0\n    ans = 0\n    for x in range(K):\n        t = ncr(K - 1, x)\n        t *= 2 ** (x + 1)\n        t %= MOD\n        t *= ncr(N - K + 1, x + 1)\n        t %= MOD\n        ans += t\n        ans %= MOD\n    return ans\nT = int(input())\nfor ti in range(T):\n    (N, K) = map(int, input().split())\n    print(solve(N, K))", "import math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom functools import reduce\nimport operator as op\nMOD = 10 ** 9 + 7\n\ndef ncr(n, m):\n    if m > n:\n        return 0\n    numer = reduce(op.mul, range(n, n - m, -1), 1)\n    denom = reduce(op.mul, range(1, m + 1), 1)\n    return numer // denom\n\ndef solve(N, K):\n    if N < K:\n        return 0\n    ans = 0\n    for x in range(K):\n        t = ncr(K - 1, x)\n        t *= 2 ** (x + 1)\n        t %= MOD\n        t *= ncr(N - K + 1, x + 1)\n        t %= MOD\n        ans += t\n        ans %= MOD\n    return ans\nT = int(input())\nfor ti in range(T):\n    (N, K) = map(int, input().split())\n    print(solve(N, K))", "def modinv(a, m):\n    ap = m\n    (tp, t) = (0, 1)\n    while a > 1:\n        (q, b) = divmod(ap, a)\n        (tp, t) = (t, tp - q * t)\n        (ap, a) = (a, b)\n    return t % m\nmdl = 1000000007\ninv = [modinv(a, mdl) for a in range(1002)]\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if k == 0:\n        print(1)\n        continue\n    p = n - k\n    if p < 0:\n        print(0)\n        continue\n    p2 = 2\n    spl = 0\n    sop = 1\n    ins = p + 1\n    tot = p2 * sop * ins % mdl\n    while spl < k - 1 and spl < p:\n        spl += 1\n        p2 = p2 * 2 % mdl\n        sop = sop * (k - spl) * inv[spl] % mdl\n        ins = ins * (p + 1 - spl) * inv[spl + 1] % mdl\n        tot = (tot + sop * ins * p2) % mdl\n    print(tot)", "def euclidean_alg(a, b):\n    rm1 = a\n    sm1 = 1\n    tm1 = 0\n    r = b\n    s = 0\n    t = 1\n    while r != 0:\n        q = rm1 // r\n        temp_r = rm1\n        temp_s = sm1\n        temp_t = tm1\n        rm1 = r\n        sm1 = s\n        tm1 = t\n        r = temp_r - q * rm1\n        s = temp_s - q * sm1\n        t = temp_t - q * tm1\n    return (rm1, sm1, tm1)\n\ndef modular_inverse(n, p):\n    (r, s, t) = euclidean_alg(n, p)\n    return s\n\ndef solve(N, k, p=10 ** 9 + 7):\n    res = 0\n    for i in range(1, min(k + 1, N - k + 2)):\n        res = (res + pow(2, i, p) * choose(k - 1, i - 1, p) * choose(N - k + 1, i, p)) % p\n    return res\n\ndef choose(a, b, p):\n    assert a >= b\n    num = 1\n    for i in range(a - b + 1, a + 1):\n        num = num * i % p\n    den = 1\n    for i in range(1, b + 1):\n        den = den * i % p\n    return num * modular_inverse(den, p) % p\nT = int(input())\nfor test in range(T):\n    (N, k) = [int(v) for v in input().split()]\n    print(solve(N, k))", "c1 = []\nc2 = []\nmodu = 1000000007\n\ndef nc(k, r):\n    for i in range(1, k):\n        c1.append(c1[i - 1] * r // i)\n        r -= 1\n\ndef dim(k, r):\n    for i in range(1, k + 1):\n        c2.append(c2[i - 1] * r // i)\n        r -= 1\n\ndef fans(k):\n    suma = 0\n    for i in range(1, k + 1):\n        suma += c1[i - 1] * c2[i] * pow(2, i, modu)\n    return suma % modu\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    if k > n:\n        print(0)\n    elif k == n:\n        print(2)\n    else:\n        c1 = [1]\n        c2 = [1]\n        nc(k, k - 1)\n        dim(k, n - k + 1)\n        print(fans(k))", "import sys\nsys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nmodinv_mem = {}\n\ndef modinv(n):\n    if n not in modinv_mem:\n        modinv_mem[n] = pow(n, MOD - 2, MOD)\n    return modinv_mem[n]\nC_mem = {}\n\ndef C(n, k):\n    if k == 0:\n        return 1\n    if (n, k) not in C_mem:\n        C_mem[n, k] = n * modinv(k) * C(n - 1, k - 1) % MOD\n    return C_mem[n, k]\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 0\n    if k > n:\n        print(0)\n    else:\n        for i in range(k):\n            ans += C(n - k + 1, i + 1) * C(k - 1, i) * pow(2, i + 1, MOD) % MOD\n        print(int(ans % MOD))", "import math\nglobal pri\npri = 1000000007\n\ndef gcd(n, m):\n    if n == 0:\n        return m\n    else:\n        return gcd(m % n, n)\n\ndef modinv(n):\n    tmp = gcd(n, pri)\n    return pow(n, pri - 2, pri)\npri = 1000000007\n\ndef cho(n, r):\n    if r > n:\n        return 0\n    elif r == n or r == 0:\n        return 1\n    else:\n        k = n - r\n        tmp = 1\n        tmp1 = 1\n        for i in range(1, r + 1):\n            tmp = tmp * (k + i) % pri\n            tmp1 = tmp1 * i % pri\n        tmp1 = modinv(tmp1)\n        tmp = tmp % pri * (tmp1 % pri) % pri\n        return tmp % pri\nt = input()\nt = int(t)\nwhile t:\n    (n, k) = input().split(' ')\n    n = int(n)\n    k = int(k)\n    s = 0\n    x = n - k + 1\n    for i in range(0, k):\n        s = s + cho(k - 1, i) % pri * (cho(x + i, k) % pri) % pri\n    y = 2 * s % pri\n    print(y)\n    t = t - 1", "import functools\nmod = 1000000007\n\ndef ncr(n, r):\n    if r > n:\n        return 0\n    else:\n        r = min(r, n - r)\n        a = functools.reduce(lambda x, y: x * y, range(n, n - r, -1), 1)\n        b = functools.reduce(lambda x, y: x * y, range(1, r + 1), 1)\n        return a // b\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    m = 0\n    for i in range(k):\n        m += 2 * ncr(k - 1, i) * ncr(n + 1 + i - k, k) % mod\n    print(m % mod)", "c1 = []\nc2 = []\nmodu = 1000000007\n\ndef nc(k, r):\n    for i in range(1, k):\n        c1.append(c1[i - 1] * r // i)\n        r -= 1\n\ndef dim(k, r):\n    for i in range(1, k + 1):\n        c2.append(c2[i - 1] * r // i)\n        r -= 1\n\ndef fans(k):\n    suma = 0\n    for i in range(1, k + 1):\n        suma += c1[i - 1] * c2[i] * pow(2, i, modu)\n    return suma % modu\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    if k > n:\n        print(0)\n    elif k == n:\n        print(2)\n    else:\n        c1 = [1]\n        c2 = [1]\n        nc(k, k - 1)\n        dim(k, n - k + 1)\n        print(fans(k))", "mod = 10 ** 9 + 7\nfor i in range(int(input())):\n    (a, b) = map(int, input().split())\n    if b > a:\n        print(0)\n    elif b == a:\n        print(2)\n    else:\n        ans = 2 * (a - b + 1)\n        comb1 = (a - b + 1) * (a - b) // 2\n        comb2 = b - 1\n        for j in range(1, min(a - b + 1, b)):\n            ans = ans + pow(2, j + 1, mod) * comb1 * comb2\n            comb1 = (a - b - j) * comb1 // (j + 2)\n            comb2 = (b - j - 1) * comb2 // (j + 1)\n        print(ans % mod)", "t = int(input())\nwhile t:\n    (n, k) = map(int, input().split(' '))\n    mod = 10 ** 9 + 7\n\n    def egcd(a, b):\n        if a == 0:\n            return (b, 0, 1)\n        else:\n            (g, y, x) = egcd(b % a, a)\n            return (g, x - b // a * y, y)\n\n    def modinv(a, m):\n        (g, x, y) = egcd(a, m)\n        return x % m\n\n    def getpascal(n):\n        coff = []\n        coff.append(1)\n        for i in range(1, n + 1):\n            den = modinv(i, mod)\n            num = (n - i + 1) % mod\n            coff.append(coff[i - 1] * num % mod * den % mod)\n            if len(coff) > k:\n                break\n        return coff\n    coef1 = getpascal(k - 1)\n    coef2 = getpascal(n - k + 1)\n    pow2 = 2\n    sum = 0\n    for i in range(1, k + 1):\n        try:\n            sum += pow2 * coef1[i - 1] % mod * coef2[i] % mod\n            sum %= mod\n            pow2 = pow2 * 2 % mod\n        except:\n            break\n    print(sum)\n    t = t - 1", "mod = 1000000007\n\ndef modular_inverse(value):\n    return fast_mod_pow(value, mod - 2)\n\ndef fast_mod_pow(a, x):\n    value = 1\n    while x > 0:\n        if x % 2 != 0:\n            value = value * a % mod\n        a = a * a % mod\n        x //= 2\n    return value\n\ndef modular_biomial_coffiecient(n, r):\n    deno = 1\n    for i in range(1, r + 1):\n        deno = deno * i % mod\n    nume = 1\n    for i in range(r):\n        nume = nume * (n - i) % mod\n    return nume * modular_inverse(deno) % mod\nfor _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    ans = 0\n    if k > n:\n        print(0)\n    else:\n        for i in range(k):\n            ans = (ans + 2 * modular_biomial_coffiecient(k - 1, i) * modular_biomial_coffiecient(n + 1 + i - k, k)) % mod\n        print(ans)", "from functools import reduce as rd\nimport operator as optr\ninp = lambda : map(int, input().split())\n\ndef Combination(n, r):\n    r = min(r, n - r)\n    numerator = rd(optr.mul, range(n, n - r, -1), 1)\n    denominator = rd(optr.mul, range(1, r + 1), 1)\n    return numerator // denominator\nmod = 10 ** 9 + 7\ntest = int(input())\nfor __ in range(test):\n    (n, k) = inp()\n    result = 0\n    if n >= k:\n        if n % 2 == 0 and k <= n // 2 or (n % 2 != 0 and k <= n // 2 + 1):\n            for i in range(1, k + 1):\n                result += 2 ** i % mod * Combination(k - 1, i - 1) % mod * Combination(n - k + 1, i) % (10 ** 9 + 7) % mod\n        else:\n            cnt = 0\n            for i in range(1, k + 1):\n                result += 2 ** i % mod * Combination(k - 1, i - 1) % mod * Combination(n - k + 1, i) % (10 ** 9 + 7) % mod\n                cnt += 1\n                if cnt == n - k + 1:\n                    break\n        print(result % mod)\n    else:\n        print(0)", "import functools\nimport operator as op\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = functools.reduce(op.mul, range(n, n - r, -1), 1)\n    deno = functools.reduce(op.mul, range(1, r + 1), 1)\n    return numer // deno\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 0\n    mod = 10 ** 9 + 7\n    if n < k:\n        ans = 0\n    elif n % 2 == 0:\n        if k <= n // 2:\n            for i in range(1, k + 1):\n                ans += 2 ** i % mod * ncr(k - 1, i - 1) % mod * ncr(n - k + 1, i) % (10 ** 9 + 7) % mod\n        else:\n            cnt = 0\n            for i in range(1, k + 1):\n                ans += 2 ** i % mod * ncr(k - 1, i - 1) % mod * ncr(n - k + 1, i) % (10 ** 9 + 7) % mod\n                cnt += 1\n                if cnt == n - k + 1:\n                    break\n    elif k <= n // 2 + 1:\n        for i in range(1, k + 1):\n            ans += 2 ** i % mod * ncr(k - 1, i - 1) % mod * ncr(n - k + 1, i) % (10 ** 9 + 7) % mod\n    else:\n        cnt = 0\n        for i in range(1, k + 1):\n            ans += 2 ** i % mod * ncr(k - 1, i - 1) % mod * ncr(n - k + 1, i) % (10 ** 9 + 7) % mod\n            cnt += 1\n            if cnt == n - k + 1:\n                break\n    print(ans % mod)", "from operator import mul\nfrom itertools import *\nfrom functools import *\nm = 10 ** 9 + 7\n\ndef nCr(n, r):\n    if r > n - r:\n        r = n - r\n    return reduce(mul, range(n - r + 1, n + 1), 1) // reduce(mul, range(1, r + 1), 1) % m\n\ndef find(n, k):\n    if k == 0:\n        return 1\n    elif k > n:\n        return 0\n    elif k == n:\n        return 2\n    else:\n        n += 1\n        ans = 0\n        for i in range(1, min(n - k, k) + 1):\n            ans = (ans + pow(2, i, m) * nCr(k - 1, i - 1) * nCr(n - k, i) % m) % m\n        return ans\nT = int(input())\nfor testCase in range(T):\n    (N, K) = list(map(int, input().split()))\n    print(find(N, K))", "def replace(n, k):\n    d = [0 for _ in range(k + 1)]\n    d[0] = 1\n    d[1] = 2 * (n - k + 1)\n    for i in range(2, k + 1):\n        d[i] = (2 * (n - k + 1) * d[i - 1] + (i - 2) * d[i - 2]) // i\n    return d[k]\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    ways = 0\n    if k > n:\n        print(0)\n        continue\n    print(replace(n, k) % 1000000007)", "mod = 1000000007\n\ndef modinv(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef checkbin(n, k):\n    if k > n:\n        return 0\n    elif k == n:\n        return 1\n    else:\n        num = 1\n        for i in range(k):\n            num = num % mod * ((n - i) % mod) % mod\n        denom = 1\n        for i in range(1, k + 1):\n            denom = denom % mod * (i % mod) % mod\n        return num % mod * (modinv(denom, mod) % mod) % mod\n\ndef solve(n, k):\n    answer = 0\n    for i in range(n + 1):\n        answer = (answer % mod + checkbin(n, i) % mod * (checkbin(k, i) % mod) % mod * (pow(2, i, mod) % mod) % mod) % mod\n    return answer\nt = int(input())\nwhile t > 0:\n    (n, k) = map(int, input().split())\n    answer = 0\n    if k == 1:\n        answer = 2 % mod * (n % mod) % mod\n    elif n == k:\n        answer = 2\n    elif n > k:\n        answer = (solve(k, n - k) % mod + solve(k - 1, n - k) % mod) % mod\n    print(answer)\n    t = t - 1", "import sys\nsys.setrecursionlimit(10 ** 9)\nmod = 10 ** 9 + 7\n\ndef nCr(n, r):\n    if r == 0:\n        return 1\n    return nCr(n, r - 1) * (n - r + 1) // r\na = int(input())\nfor i in range(a):\n    b = [int(i) for i in input().split()]\n    n = b[0]\n    k = b[1]\n    s = 0\n    if k <= n:\n        for r in range(1, k + 1):\n            s = s + int(2 ** r * nCr(k - 1, r - 1) * nCr(n - k + 1, r))\n            s = s % mod\n        s = s % mod\n    print(s)", "(a, b, mod) = ([], [], pow(10, 9) + 7)\n\ndef funca(k, w):\n    for i in range(1, k):\n        a.append(a[i - 1] * w // i)\n        w -= 1\n\ndef funcb(k, w):\n    for i in range(1, k + 1):\n        b.append(b[i - 1] * w // i)\n        w -= 1\n\ndef answer(k):\n    ans = 0\n    for i in range(1, k + 1):\n        ans += a[i - 1] * b[i] * pow(2, i, mod)\n    return ans % mod\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if k > n:\n        print(0)\n    elif k == n:\n        print(2)\n    else:\n        (a, b) = ([1], [1])\n        funca(k, k - 1)\n        funcb(k, n - k + 1)\n        print(answer(k))", "t = int(input())\nM = 10 ** 9 + 7\n\ndef powerMod(n, k, m):\n    if k == 0:\n        return 1\n    if k == 1:\n        return n % m\n    pw = powerMod(n, k // 2, m)\n    if k % 2 == 0:\n        return pw * pw % m\n    else:\n        return pw * pw * n % m\n\ndef inverseMod(n, m):\n    return powerMod(n, m - 2, m)\n\ndef choiceMod(n, k, m):\n    nprod = 1\n    kprod = 1\n    invrm1f = 1\n    invrf = 1\n    rf = 1\n    power2 = 1\n    result = 0\n    for r in range(1, k + 1):\n        rf = rf * r % m\n        invrm1f = invrf\n        invrf = inverseMod(rf, m)\n        nprod = nprod * (n - r + 2) % m\n        power2 = power2 * 2 % m\n        result = (result + nprod * invrf * power2 * kprod * invrm1f) % m\n        kprod = kprod * (k - r) % m\n    return result\nfor _ in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    if k == 0:\n        print(1)\n    elif k > n:\n        print(0)\n    elif k == n:\n        print(2)\n    else:\n        print(choiceMod(n - k, k, M))", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor it in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    ans = 0\n    MOD = 1000000007\n    n += 1\n    if n >= k:\n        for i in range(k):\n            mul = ncr(n - k, i + 1, MOD) * 1 % MOD\n            mul = mul * ncr(k - 1, i, MOD) % MOD\n            mul = mul * pow(2, i + 1, MOD) % MOD\n            ans = (ans + mul) % MOD\n    print(ans)", "from sys import stdin, stdout\nfor _ in range(int(stdin.readline())):\n    (n, k) = [int(x) for x in stdin.readline().split()]\n    if k > n:\n        print(0)\n    elif n == k:\n        print(2)\n    elif k == 1:\n        print(2 * n % (10 ** 9 + 7))\n    else:\n        x = 1\n        c1 = 2 * (n - k + 1)\n        f = min(k - 1, n - k)\n        c = 4\n        n1 = (n - k + 1) * (n - k) // 2\n        n2 = k - 1\n        flag = 1\n        while flag:\n            a = c * n1 * n2\n            c1 += a\n            n1 = (n - k - x) * n1 // (x + 2)\n            n2 = n2 * (k - x - 1) // (x + 1)\n            c *= 2\n            x += 1\n            f -= 1\n            if f > 0:\n                continue\n            else:\n                flag = 0\n        print(c1 % (10 ** 9 + 7))", "from sys import stdin, stdout\nfor _ in range(int(stdin.readline())):\n    (n, k) = [int(x) for x in stdin.readline().split()]\n    if k > n:\n        print(0)\n    else:\n        x = 1\n        c1 = 2 * (n - k + 1)\n        f = min(k - 1, n - k)\n        c = 4\n        n1 = (n - k + 1) * (n - k) // 2\n        n2 = k - 1\n        flag = 1\n        while flag:\n            a = c * n1 * n2\n            c1 += a\n            n1 = (n - k - x) * n1 // (x + 2)\n            n2 = n2 * (k - x - 1) // (x + 1)\n            c *= 2\n            x += 1\n            f -= 1\n            if f > 0:\n                continue\n            else:\n                flag = 0\n        print(c1 % (10 ** 9 + 7))", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split(' '))\n    ans = 0\n    if k > n:\n        print(0)\n    else:\n        term = (n - k + 1) * 2\n        for r in range(1, k + 1):\n            ans += term\n            term = term * 2 * (k - r) * (n - k + 1 - r) // (r * (r + 1))\n        print(int(ans) % (10 ** 9 + 7))", "mod = int(1000000000.0) + 7\n\ndef inv(n):\n    return pow(n, mod - 2, mod)\n\ndef solve(n, k):\n    ans = 0\n    ra = min(k, n - k + 1)\n    aux1 = genAux1(k - 1, ra - 1)\n    aux2 = genAux1(n - k + 1, ra)\n    prev = 1\n    for r in range(1, ra + 1):\n        prev = prev * 2\n        ans += prev % mod * aux1[r - 1] * aux2[r]\n    print(ans % mod)\n\ndef genAux1(n, k):\n    result = [1] * (k + 1)\n    for r in range(1, k + 1):\n        result[r] = result[r - 1] * (n - r + 1) * inv(r) % mod\n    return result\nfor _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    if k > n:\n        print(0)\n    else:\n        solve(n, k)", "import sys\nsys.setrecursionlimit(10 ** 9)\nM = 10 ** 9 + 7\nd = {}\n\ndef ncr(n, r):\n    if r == 0:\n        return 1\n    elif n < r:\n        return 0\n    elif (n, r) in d:\n        return d[n, r]\n    else:\n        d[n, r] = (n - r + 1) * ncr(n, r - 1) // r\n        return d[n, r]\n\ndef solve(n, k):\n    if k == 0:\n        return 1\n    ans = 0\n    for r in range(1, k + 1):\n        ans = (ans % M + 2 ** r % M * (ncr(k - 1, r - 1) % M) % M * (ncr(n - k + 1, r) % M) % M) % M\n    return ans\nfor _ in range(int(input())):\n    (n, k) = (int(s) for s in input().split())\n    if k > n:\n        print(0)\n    else:\n        print(solve(n, k))", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 9)\nQ = 10 ** 9 + 7\nncr = defaultdict(int)\n\ndef choose(n, k):\n    if k == 0 or k == n:\n        return 1\n    elif k == 1 or k == n - 1:\n        return n\n    elif (n, k) in ncr:\n        return ncr[n, k]\n    else:\n        a = choose(n, k - 1) * (n - k + 1) // k\n        ncr[n, k] = a\n        return a\n\ndef solve(n, r):\n    sm = 0\n    if r > n:\n        return 0\n    for i in range(1, r + 1):\n        sm = (sm % Q + 2 ** i % Q * (choose(r - 1, i - 1) % Q) % Q * (choose(n - r + 1, i) % Q) % Q) % Q\n    if r == 0:\n        return 1\n    return sm\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    print(solve(n, k))", "inf = 1000000007\npow2 = list()\npow2.append(1)\nfor i in range(1, 1100):\n    pow2.append(pow2[i - 1] * 2 % inf)\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor x in range(t):\n    (n, k) = [int(i) for i in input().strip().split(' ')]\n    ans = 0\n    val = 0\n    for j in range(1, k + 1):\n        val = ncr(n - k + 1, j, inf) * ncr(k - 1, j - 1, inf) % inf\n        val = val * pow2[j] % inf\n        ans = (ans + val) % inf\n    ans = ans % inf\n    if n < k:\n        ans = 0\n    print(int(ans))", "modulo = 1000000007\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    if k > n:\n        print('0')\n        continue\n    iterations = min(k - 1, n - k)\n    answer = n - k + 1 << 1\n    c = 4\n    temp2 = (n - k + 1) * (n - k) // 2\n    temp1 = k - 1\n    r = 1\n    for i in range(iterations):\n        prod = c * temp1 * temp2\n        answer += prod\n        c = c << 1\n        temp1 = (k - r - 1) * temp1 // (r + 1)\n        temp2 = (n - k - r) * temp2 // (r + 2)\n        r += 1\n        iterations -= 1\n    print(answer % modulo)", "import sys\nfrom collections import defaultdict\ndp1 = defaultdict(int)\ndp2 = defaultdict(int)\nsys.setrecursionlimit(10 ** 9)\nm = 10 ** 9 + 7\n\ndef ncr(n, r):\n    if r == 0:\n        return 1\n    elif r == 1:\n        return n\n    elif (n, r) in dp1:\n        return dp1[n, r]\n    else:\n        p = ncr(n, r - 1) * (n - r + 1) // r\n        dp1[n, r] = p\n        return p\n\ndef fun(n, k):\n    if k > n:\n        return 0\n    elif k == 0:\n        return 1\n    elif k == n:\n        return 2\n    else:\n        r1 = 0\n        for i in range(1, k + 1):\n            r1 += 2 ** i % m * (ncr(k - 1, i - 1) % m) % m * (ncr(n - k + 1, i) % m) % m\n        return r1 % m\nfor i in range(int(input())):\n    (n, k) = [int(j) for j in input().split()]\n    print(fun(n, k))", "def ncr(n, r):\n    if n < r:\n        return 0\n    num = den = 1\n    for i in range(1, r + 1):\n        num = num * (n - i + 1) % mod\n        den = den * i % mod\n    return num * pow(den, mod - 2, mod) % mod\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans = 0\n    for ki in range(k + 1, 1, -1):\n        ans = (ans + ncr(n - k + 1, ki - 1) * pow(2, ki - 1, mod) % mod * ncr(k - 1, ki - 2)) % mod\n    print(ans)", "mod = int(1000000000.0) + 7\n\ndef solve(n, k):\n    ans = 0\n    ra = min(k, n - k + 1)\n    aux1 = genAux1(k - 1, ra - 1)\n    aux2 = genAux1(n - k + 1, ra)\n    for r in range(1, ra + 1):\n        ans += 2 ** r * aux1[r - 1] * aux2[r]\n    print(ans % mod)\n\ndef genAux1(n, k):\n    result = [1] * (k + 1)\n    for r in range(1, k + 1):\n        result[r] = result[r - 1] * (n - r + 1) // r\n    return result\nfor _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    if k > n:\n        print(0)\n    else:\n        solve(n, k)", "def ncr(n, r):\n    if r > n:\n        return 0\n    if r > n - r:\n        r = n - r\n    ans = 1\n    for i in range(1, r + 1):\n        ans *= n - r + i\n        ans //= i\n    return ans\n\ndef solve(n, k):\n    n += 1\n    res = 0\n    for i in range(k + 1):\n        res += ncr(k - 1, i) * ncr(n - k, i + 1) * 2 ** (i + 1)\n    return res % 1000000007\nt = int(input())\nfor i in range(t):\n    (n, r) = input().split()\n    n = int(n)\n    r = int(r)\n    print(int(solve(n, r)))", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    if k > n:\n        print('0')\n        continue\n    x = 1\n    count = 2 * (n - k + 1)\n    f = min(k - 1, n - k)\n    c = 4\n    n1 = (n - k + 1) * (n - k) // 2\n    n2 = k - 1\n    d2 = 1\n    while f > 0:\n        a = c * n1 * n2\n        count += a\n        n1 = (n - k - x) * n1 // (x + 2)\n        n2 = n2 * (k - x - 1) // (x + 1)\n        c = c * 2\n        x += 1\n        f -= 1\n    print(count % 1000000007)", "m = int(1000000000.0 + 7)\nfor _ in range(int(input())):\n    (n, k) = [int(n) for n in input().split()]\n    if n == k:\n        print(2)\n        continue\n    if k > n:\n        print(0)\n        continue\n    ans = 0\n    k1 = k - 1\n    n1 = n - k + 1\n    a = [1]\n    for i in range(1, k):\n        p = a[i - 1] * k1 // i\n        a.append(p)\n        k1 = k1 - 1\n    b = [1]\n    for i in range(1, k + 1):\n        p = b[i - 1] * n1 // i\n        b.append(p)\n        n1 = n1 - 1\n    for i in range(1, k + 1):\n        ans = ans + a[i - 1] * b[i] * pow(2, i, m)\n        ans = ans % m\n    print(ans)", "import math\nfrom sys import stdin, stdout\nm = int(1000000000.0 + 7)\n\ndef ncr_fun_mod_m(n, r):\n    c = [0 for i in range(r + 1)]\n    c[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, r), 0, -1):\n            c[j] = (c[j] + c[j - 1]) % m\n    return c[r]\nfor _ in range(int(input())):\n    (n, k) = [int(n) for n in input().split()]\n    if n == k:\n        print(2)\n        continue\n    if k > n:\n        print(0)\n        continue\n    ans = 0\n    k1 = k - 1\n    n1 = n - k + 1\n    a = [1]\n    for i in range(1, k):\n        p = a[i - 1] * k1 // i\n        a.append(p)\n        k1 = k1 - 1\n    b = [1]\n    for i in range(1, k + 1):\n        p = b[i - 1] * n1 // i\n        b.append(p)\n        n1 = n1 - 1\n    for i in range(1, k + 1):\n        ans = ans + a[i - 1] * b[i] * pow(2, i, m)\n        ans = ans % m\n    print(ans)", "mod = 1000000007\n\ndef powermod(base, exp, mod):\n    base %= mod\n    result = 1\n    while exp > 0:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef inversemod(a, mod):\n    return powermod(a, mod - 2, mod)\n\ndef binomial_nCr(n, k, mod):\n    if k > n or n < 0 or k < 0:\n        return 0\n    else:\n        num = 1\n        for i in range(k):\n            num = num * (n - i) % mod\n        den = 1\n        for i in range(1, k + 1):\n            den = den * i % mod\n        return num * inversemod(den, mod) % mod\n\ndef comb_fn(N, k):\n    if k > N or N < 0 or k < 0:\n        return 0\n    else:\n        top = N\n        comb_val = 1\n        while top > N - k:\n            comb_val *= top % mod\n            top -= 1\n        n = 1\n        while n < k + 1:\n            comb_val //= n % mod\n            n += 1\n        return comb_val\n\ndef comb_fn1(n, k):\n    if k > n - k:\n        k = n - k\n    res = 1\n    for i in range(k):\n        res = res * (n - i) / (i + 1) % mod\n    return int(res)\ntc = int(input())\nfor i in range(tc):\n    (n, k) = [int(x) for x in input().split()]\n    opmodbn = 0\n    for i in range(0, k + 1):\n        opmodbn = (opmodbn + pow(2, i) % mod * binomial_nCr(n - k + 1, i, mod) * binomial_nCr(k - 1, i - 1, mod)) % mod\n    print(opmodbn)", "mod = 1000000007\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    if k > n:\n        print(0)\n        continue\n    s = 0\n    for x in range(1, min(n - k + 1, k) + 1):\n        p = 1\n        for i in range(x):\n            p = p * 2 % mod\n        for i in range(1, x + 1):\n            p = p * (n - k - x + 1 + i) // i\n        p %= mod\n        q = 1\n        for i in range(1, x):\n            q = q * (k - x + i) // i\n        q %= mod\n        s += p * q % mod\n        s %= mod\n    print(s)", "import math\nmod = 1000000007\nt = int(input())\npowers = []\ni = 1\nwhile i <= mod - 2:\n    if i & mod - 2:\n        powers.append(i)\n    i <<= 1\n\ndef inv(num):\n    tmp = num\n    key = 1\n    ans = 1\n    while key < mod - 2:\n        if key in powers:\n            ans = ans * tmp % mod\n        key *= 2\n        tmp = tmp * tmp % mod\n    return ans\n\ndef comb(a, b):\n    if a < 0 or b < 0 or a < b:\n        return 0\n    ans = 1\n    for i in range(max(a - b + 1, b + 1), a + 1):\n        ans *= i % mod\n    b = math.factorial(min(b, a - b)) % mod\n    return ans * inv(b)\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    ans = 0\n    for j in range(1, k + 1):\n        ans += pow(2, j) * comb(k - 1, j - 1) * (comb(n - k - 1, j - 2) + 2 * comb(n - k - 1, j - 1) + comb(n - k - 1, j))\n        ans %= mod\n    if n == k:\n        ans = 2\n    print(ans)", "from sys import stdin, stdout\ncin = stdin.readline\ncout = stdout.write\n\ndef Soeras(n):\n    emirp = [True for i in range(n + 1)]\n    j = 2\n    while j * j <= n:\n        if emirp[p] == True:\n            for i in range(j * 2, n + 1, j):\n                emirp[i] = False\n        j += 1\nmod = int(1000000000.0 + 7)\n\ndef retmod(num):\n    return num % mod\n\ndef spi():\n    return cin().split()\n\ndef ncrmetferm(n, r, p):\n    upr = 1\n    low = 1\n    for i in range(r):\n        upr = upr * (n - i)\n        upr = upr % p\n        low = low * (i + 1)\n        low = low % p\n    pwval = pow(low, p - 2, p)\n    retval = upr * pwval % p\n    return retval\n\ndef compt(minima, n, k):\n    calc = 0\n    for i in range(1, mini):\n        ncrval1 = ncrmetferm(k - 1, i - 1, mod) % mod\n        ncrval2 = ncrmetferm(n + 1 - k, i, mod)\n        calc = (calc % mod + ncrval1 * ncrval2 % mod % mod * pow(2, i, mod) % mod) % mod\n    return calc\nt = int(cin())\nfor cases in range(t):\n    (n, k) = list(map(int, spi()))\n    mini = min(n + 1 - k, k) + 1\n    res = compt(mini, n, k)\n    retmod(res)\n    print(res)", "from sys import stdin, stdout\ncin = stdin.readline\ncout = stdout.write\n\ndef ii():\n    return int(cin())\n\ndef li():\n    return list(map(int, cin().split()))\nmod = int(1000000000.0 + 7)\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nfor _ in range(ii()):\n    (n, k) = li()\n    s = 0\n    for i in range(1, min(n + 1 - k, k) + 1):\n        s = (s % mod + ncr(k - 1, i - 1, mod) % mod * ncr(n + 1 - k, i, mod) % mod % mod * pow(2, i, mod) % mod) % mod\n    s %= mod\n    print(s)", "p = 1000000007\n\ndef binomial(n, r):\n    numerator = denominator = 1\n    for i in range(r):\n        numerator = numerator * (n - i) % p\n        denominator = denominator * (i + 1) % p\n    return numerator * pow(denominator, p - 2, p) % p\nt = int(input())\nwhile t:\n    answer = 0\n    inp = list(map(int, input().split()))\n    n = inp[0]\n    r = inp[1]\n    if r <= n / 2:\n        end = r\n    else:\n        end = n - r + 1\n    for i in range(0, end):\n        answer += binomial(n - r + 1, i + 1) * binomial(r - 1, i) * ((1 << i + 1) % p) % p\n    print(answer % p)\n    t -= 1", "import math\nT = int(input())\n\ndef ncr(n, k):\n    num = 1\n    denom = 1\n    for i in range(1, k + 1):\n        num = num * (n - (k - i))\n        denom = denom * i\n    return num // denom\n\ndef bricks(N, K):\n    s = 0\n    for p in range(1, min(K, N - K + 1) + 1):\n        s += 2 ** p * ncr(N - K + 1, p) * ncr(K - 1, p - 1) % (10 ** 9 + 7)\n    return s % (10 ** 9 + 7)\nfor i in range(T):\n    (n, k) = map(int, input().split())\n    print(bricks(n, k))", "import math\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nwhile t > 0:\n    (n, r) = map(int, input().split())\n    n = n + 1\n    if n - r > r:\n        k = r\n    else:\n        k = n - r\n    sum = 0\n    for i in range(1, k + 1):\n        a = ncr(r - 1, i - 1, 1000000007)\n        b = ncr(n - r, i, 1000000007)\n        c = 2 ** i % 1000000007\n        s = a * b * c % 1000000007\n        sum = sum % 1000000007 + s\n    print(sum % 1000000007)\n    t = t - 1", "mod = 7 + 10 ** 9\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split(' ')]\n    (a, b) = ([1], [1])\n    if k > n:\n        print(0)\n        continue\n    for i in range(1, k + 1):\n        x = a[-1] * (n - k + 1 - (i - 1))\n        bb = i\n        x = x * pow(bb, mod - 2, mod) % mod\n        a.append(x)\n    for i in range(1, k + 1):\n        x = b[-1] * (k - i)\n        bb = i\n        x = x * pow(bb, mod - 2, mod) % mod\n        b.append(x)\n    ans = 0\n    for i in range(k):\n        ans = (ans + a[i + 1] * b[i] * (1 << i + 1)) % mod\n    print(ans)", "T = int(input())\nmod = 1000000007\nfor t in range(T):\n    (N, R) = map(int, input().split())\n    if R > N:\n        print(0)\n        continue\n    if R == 1:\n        print(2 * N % mod)\n        continue\n    N += 1\n    ans = num = (N - R) * 2\n    den = 1\n    for i in range(2, min(N - R, R) + 1):\n        num *= (R + 1 - i) * (N - R + 1 - i) * 2\n        den *= (i - 1) * i\n        ans += num // den\n    print(ans % mod)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor i in range(1, t + 1):\n    (n, r) = map(int, input().split())\n    beauty = 0\n    n = n + 1\n    if n - r > r:\n        k = r\n    else:\n        k = n - r\n    for j in range(1, k + 1):\n        pehela = ncr(r - 1, j - 1, 1000000007)\n        dusra = ncr(n - r, j, 1000000007)\n        teesra = 2 ** j % 1000000007\n        chautha = pehela * dusra * teesra % 1000000007\n        beauty = beauty % 1000000007 + chautha\n    print(beauty % 1000000007)", "mod = pow(10, 9) + 7\ntc = int(input())\nfor _ in range(tc):\n    p1 = [1]\n    (n, k) = [int(i) for i in input().split(' ')]\n    if k > n:\n        print(0)\n    elif k == n:\n        print(2)\n    else:\n        n += 1\n        r1 = 1\n        for i in range(1, k + 1):\n            r1 = r1 * (n - k - i + 1) * pow(i, mod - 2, mod) % mod\n            p1.append(r1)\n        r2 = 1\n        p2 = [1]\n        for i in range(1, k):\n            r2 = r2 * (k - 1 - i + 1) * pow(i, mod - 2, mod) % mod\n            p2.append(r2)\n        s = 0\n        for i in range(k):\n            s += p1[i + 1] * p2[i] % mod * pow(2, i + 1, mod) % mod\n        print(s % mod)", "import math\nfor _ in range(int(input())):\n    mod = 1000000007\n    (n, k) = map(int, input().split())\n    if k > n:\n        print(0)\n    else:\n        x = n - k\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        dp[1] = 2 * x + 2\n        for i in range(2, k + 1):\n            dp[i] = (dp[1] * dp[i - 1] + (i - 2) * dp[i - 2]) * pow(i, mod - 2, mod)\n        print(dp[k] % mod)", "from sys import stdin\nxrange = range\nMOD = 10 ** 9 + 7\n\ndef kfact(k):\n    kf = [1] * (k + 1)\n    f = 1\n    for i in xrange(2, k + 1):\n        f = f * i % MOD\n        kf[i] = f\n    return kf\n\ndef rkfact(n, k):\n    k = min(n, k)\n    rkf = [1] * (k + 1)\n    f = 1\n    for i in xrange(1, k + 1):\n        f = f * (n - i + 1) % MOD\n        rkf[i] = f\n    return rkf\n\ndef bricks(n, k):\n    kf = kfact(k)\n    s = min(k, n - k + 1)\n    rkf = rkfact(n - k + 1, s)\n    r = 0\n    for i in xrange(1, s + 1):\n        nom = kf[k - 1]\n        den = kf[i - 1] * kf[k - i] % MOD\n        nom = nom * pow(den, MOD - 2, MOD) % MOD\n        nom = nom * pow(2, i, MOD) % MOD\n        nom = nom * rkf[i] * pow(kf[i], MOD - 2, MOD) % MOD\n        r = (r + nom) % MOD\n    return r\n\ndef main():\n    readl = stdin.readline\n    for __ in xrange(int(readl())):\n        (n, k) = map(int, readl().split())\n        if k > n:\n            print(0)\n        else:\n            print(bricks(n, k))\nmain()", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nmod = 1000000007\nfor j in range(t):\n    (n, k) = map(int, input().split())\n    ans = 0\n    for i in range(1, min(n - k + 2, k + 1)):\n        ans += pow(2, i, mod) * ncr(k - 1, i - 1, mod) * ncr(n - k + 1, i, mod)\n        ans %= mod\n    print(int((ans + mod) % mod))", "mod = 1000000007\n\ndef MODPow(base, exp, mod):\n    base %= mod\n    result = 1\n    while exp > 0:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef MODInverse(a, p):\n    return MODPow(a, p - 2, p)\n\ndef MODBinomial(n, k, p):\n    if k > n or n < 0 or k < 0:\n        return 0\n    else:\n        numerator = 1\n        for i in range(k):\n            numerator = numerator * (n - i) % p\n        denominator = 1\n        for i in range(1, k + 1):\n            denominator = denominator * i % p\n        return numerator * MODInverse(denominator, p) % p\n\ndef comb_fn(N, k):\n    if k > N or N < 0 or k < 0:\n        return 0\n    else:\n        top = N\n        comb_val = 1\n        while top > N - k:\n            comb_val *= top % mod\n            top -= 1\n        n = 1\n        while n < k + 1:\n            comb_val //= n % mod\n            n += 1\n        return comb_val\n\ndef comb_fn1(n, k):\n    if k > n - k:\n        k = n - k\n    res = 1\n    for i in range(k):\n        res = res * (n - i) / (i + 1) % mod\n    return int(res)\ntc = int(input())\nfor i in range(tc):\n    (n, k) = [int(x) for x in input().split()]\n    opmodbn = 0\n    for i in range(0, k + 1):\n        opmodbn = (opmodbn + pow(2, i) % mod * MODBinomial(n - k + 1, i, mod) * MODBinomial(k - 1, i - 1, mod)) % mod\n    print(opmodbn)", "import math\n\ndef ncr(n, r):\n    pro1 = 1\n    pro2 = 1\n    for i in range(r):\n        pro1 *= n - i\n        pro2 *= i + 1\n    return pro1 // pro2\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    s = 0\n    for p in range(1, min(n - k + 1, k) + 1):\n        s += 2 ** p * ncr(n - k + 1, p) * ncr(k - 1, p - 1) % (10 ** 9 + 7)\n    print(s % (10 ** 9 + 7))", "def power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef MODInverse(a, p):\n    return pow(a, p - 2, p)\n\ndef nCr(n, k, p):\n    if k < 0:\n        return 0\n    elif k > n:\n        return 0\n    else:\n        numerator = 1\n        for i in range(0, k):\n            numerator = numerator * (n - i) % p\n        denominator = 1\n        for i in range(1, k + 1):\n            denominator = denominator * i % p\n        return numerator * MODInverse(denominator, p) % p\nx = int(input())\nmod = 10 ** 9 + 7\nfor j in range(x):\n    a = [int(x) for x in input().split()]\n    ans = 0\n    for i in range(0, a[1] + 1):\n        ans = (ans + power(2, i, mod) * nCr(a[0] - a[1] + 1, i, mod) * nCr(a[1] - 1, i - 1, mod)) % mod\n    print(int(ans))", "def MODInverse(a, p):\n    return pow(a, p - 2, p)\n\ndef nCr(n, k, p):\n    if k > n or n < 0 or k < 0:\n        return 0\n    else:\n        numerator = 1\n        for i in range(0, k):\n            numerator = numerator * (n - i) % p\n        denominator = 1\n        for i in range(1, k + 1):\n            denominator = denominator * i % p\n        return numerator * MODInverse(denominator, p) % p\ntc = int(input())\nfor i in range(tc):\n    (n, k) = [int(x) for x in input().split()]\n    ans = 0\n    mod = 1000000007\n    for i in range(1, k + 1):\n        ans = (ans + pow(2, i) * nCr(n - k + 1, i, mod) % mod * nCr(k - 1, i - 1, mod) % mod) % mod\n    print(int(ans))", "def C(n, r, p):\n    if r < 0 or r > n:\n        return 0\n    if r > n - r:\n        r = n - r\n    (ans, dans) = (1, 1)\n    for i in range(1, r + 1):\n        ans = ans * ((n - r + i) % p) % p\n        dans = dans * i % p\n    ret = ans * pow(dans, p - 2, p) % p\n    return ret % p\nts = input()\nt = int(ts)\nwhile t:\n    (n, k) = map(int, input().split(' '))\n    (ans, p) = (0, int(1000000000.0 + 7))\n    for i in range(1, k + 1):\n        ans = (ans + C(k - 1, i - 1, p) * C(n - k + 1, i, p) % p * pow(2, i, p) % p) % p\n    print(ans % p)\n    t -= 1", "def nCr(n, k):\n    if k > n:\n        return 0\n    mod = 10 ** 9 + 7\n    res = 1\n    for i in range(k):\n        res = res * (n - i)\n        res = res // (i + 1)\n    return res % mod\n\ndef ans(n, k):\n    ans = 0\n    mod = 10 ** 9 + 7\n    for i in range(0, k):\n        ans += nCr(n - k, i + 1) * nCr(k - 1, i) * 2 ** (i + 1)\n    return ans % mod\nfrom sys import stdin, stdout\n\ndef main():\n    t = int(input())\n    mod = 10 ** 9 + 7\n    for i in range(0, t):\n        z = input()\n        z = z.split(' ')\n        n = int(z[0])\n        k = int(z[1])\n        k = ans(n + 1, k)\n        stdout.write(str(k % mod))\n        stdout.write(str('\\n'))\nmain()", "def com(n, k):\n    if k > n:\n        return 0\n    res = 1\n    for i in range(k):\n        res = res * (n - i)\n        res = res // (i + 1)\n    return res\n\ndef func(n, r):\n    sum = 0\n    for i in range(0, r):\n        sum = (sum + com(n - r, i + 1) * com(r - 1, i) * pow(2, i + 1, 1000000007)) % 1000000007\n    return sum\nt = int(input())\nfor i in range(0, t):\n    x = input().split(' ')\n    n = int(x[0])\n    k = int(x[1])\n    print(func(n + 1, k))", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num % p * ((n - i) % p) % p\n        den = den % p * ((i + 1) % p) % p\n    return num % p * pow(den, p - 2, p) % p\nt = int(input())\nfor i in range(0, t):\n    (n, k) = map(int, input().split())\n    x = 0\n    if k > n:\n        print(0)\n    else:\n        m = 1000000007\n        for i in range(1, k + 1):\n            y = pow(2, i, m) * ncr(k - 1, i - 1, m) % m * ncr(n - k + 1, i, m) % m\n            x = (x % m + y % m) % m\n        print(x)", "def binomial(n, k):\n    if 0 <= k <= n:\n        ntok = 1\n        ktok = 1\n        for t in range(1, min(k, n - k) + 1):\n            ntok *= n\n            ktok *= t\n            n -= 1\n        return ntok // ktok\n    else:\n        return 0\nm = 10 ** 9 + 7\n\ndef T(n, r):\n    return int(sum([binomial(r - 1, k - 1) * binomial(n - r, k) * 2 ** k for k in range(min(n - r, r) + 1)]))\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().strip().split())\n    ans = T(n + 1, k)\n    print(ans % m)", "def ncr(n, k):\n    if n < k:\n        return 0\n    num = 1\n    den = 1\n    if k > n - k:\n        k = n - k\n    for i in range(1, k + 1):\n        num = num * (n - k + i)\n        den = den * i\n    ans = num // den\n    return ans % 1000000007\nt = int(input())\nfor _ in range(t):\n    (n, k) = input().split()\n    n = int(n)\n    k = int(k)\n    if k > n:\n        print('0')\n        continue\n    ans = 0\n    for i in range(k):\n        ans = (ans + ncr(n + 1 - k, i + 1) * ncr(k - 1, i) % 1000000007 * 2 ** (i + 1) % 1000000007) % 1000000007\n    print(int(ans))", "def _C(n, r):\n    global f\n    if n < 0 or r < 0:\n        return 1\n    if n < r:\n        return 1\n    return f[n] // (f[n - r] * f[r])\nt = int(input())\nglobal f\nf = [1, 1]\nfor i in range(2, 1001):\n    f.append(f[i - 1] * i)\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    times = min(k, (n + 1) // 2)\n    s = 0\n    two = 2\n    upp = n - k + 1\n    down = 1\n    if n < k:\n        print('0')\n        continue\n    for i in range(1, times + 1):\n        s = s + two * _C(k - 1, i - 1) * upp // down\n        s = s % 1000000007\n        two = two * 2\n        upp = upp * (n - k + 1 - i)\n        down = down * (i + 1)\n    print(s)", "p = int(pow(10, 9) + 7)\n\ndef modBin(n, k, p):\n    nu = 1\n    for i in range(0, k):\n        nu = nu * (n - i) % p\n    de = 1\n    for i in range(1, k + 1):\n        de = de * i % p\n    return nu * pow(de, p - 2, p) % p\nfor t in range(0, int(input())):\n    (n, k) = map(int, input().split(' '))\n    n = n + 1\n    if k > n:\n        print(0)\n    else:\n        answer = 0\n        n = n - k\n        y = min(n, k)\n        for i in range(0, y + 1):\n            f = modBin(k - 1, i - 1, p)\n            g = modBin(n, i, p)\n            h = int(pow(2, i, p))\n            answer = (f % p * g % p * h % p % p + answer % p) % p\n        print(answer - 1)", "P = int(1000000000.0) + 7\n\ndef modpow(a, b):\n    ans = 1\n    while b:\n        if b & 1:\n            ans *= a % P\n        b >>= 1\n        a = a * a % P\n    return ans\n\ndef modinv(a):\n    return modpow(a, P - 2)\n\ndef nCr(n, r):\n    if r > n - r:\n        r = n - r\n    ans = 1\n    for i in range(1, r + 1):\n        ans = ans * (n - r + i) % P\n        ans = ans * modinv(i) % P\n    return ans % P\n\ndef A(n, r):\n    ans = 0\n    sec = nCr(n, 0)\n    fst = 0\n    for k in range(min(n, r) + 1):\n        (x, y) = (r - 1, k - 1)\n        if y < 2:\n            fst = nCr(x, y)\n        ans = (ans + fst * sec * modpow(2, k)) % P\n        fst = fst * (x - y) * modinv(y + 1) % P\n        sec = sec * (n - k) * modinv(k + 1) % P\n        ans %= P\n    return ans % P\n\ndef T(m, r):\n    ans = A(m - r + 1, r) - 1\n    return ans\ntc = int(input())\nfor i in range(tc):\n    (n, k) = map(int, input().split())\n    if n < k:\n        print(0)\n    else:\n        print(T(n, k))", "p = 10 ** 9 + 7\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    ans = 1\n    inv = 1\n    for i in range(n - r + 1, n + 1):\n        ans = ans * i % p\n    for i in range(1, r + 1):\n        inv = inv * i % p\n    inv = pow(inv, p - 2, p)\n    return ans * inv % p\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    an = 0\n    for j in range(1, k + 1):\n        an = (an + pow(2, j, p) * ncr(n - k + 1, j) * ncr(k - 1, j - 1)) % p\n    print(an)", "import math\n\ndef comb(n, r):\n    if r > n:\n        return 0\n    if r == n:\n        return 1\n    nr = 1\n    dr = 1\n    if r > n - r:\n        r = n - r\n    for x in range(n - r + 1, n + 1):\n        nr = nr * x\n    for x in range(1, r + 1):\n        dr = dr * x\n    return nr // dr % 1000000007\nt = int(input())\nfor x in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    if k < 0:\n        print('0')\n    elif k == 1:\n        print(n * 2 % 1000000007)\n    else:\n        ans = 0\n        for i in range(1, k + 1):\n            ans = (ans + 2 ** i % 1000000007 * (comb(k - 1, i - 1) % 1000000007) % 1000000007 * (comb(n - k + 1, i) % 1000000007) % 1000000007 % 1000000007) % 1000000007\n        print(ans)", "mod = int(1000000000.0 + 7)\n\ndef find(n, k, mod):\n    nu = 1\n    de = 1\n    for i in range(k):\n        nu = nu * (n - i) % mod\n        de = de * (i + 1) % mod\n    return nu * pow(de, mod - 2, mod) % mod\n\ndef pow(q, z, mod):\n    res = 1\n    q = q % mod\n    while z > 0:\n        if z & 1 == 1:\n            res = res * q % mod\n        z = z >> 1\n        q = q * q % mod\n    return res\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    res = 0\n    for l in range(1, min(n + 1 - k, k) + 1):\n        res = (res % mod + find(k - 1, l - 1, mod) % mod * find(n + 1 - k, l, mod) % mod % mod * pow(2, l, mod) % mod) % mod\n    print(res)", "p = int(1000000000.0 + 7)\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef calculate(n, r, p):\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = numerator * (n - i) % p\n        denominator = denominator * (i + 1) % p\n    return numerator * power(denominator, p - 2, p) % p\nfor t in range(int(input())):\n    (n, r) = map(int, input().split())\n    answer = 0\n    for k in range(1, min(n + 1 - r, r) + 1):\n        answer = (answer % p + calculate(r - 1, k - 1, p) % p * calculate(n + 1 - r, k, p) % p % p * power(2, k, p) % p) % p\n    print(answer)", "p = int(1000000000.0 + 7)\n\ndef calculate(n, r, p):\n    numerator = denominator = 1\n    for i in range(r):\n        numerator = numerator * (n - i) % p\n        denominator = denominator * (i + 1) % p\n    return numerator * pow(denominator, p - 2, p) % p\nfor t in range(int(input())):\n    (n, r) = map(int, input().split())\n    n = n + 1\n    answer = 0\n    for k in range(1, min(n - r, r) + 1):\n        answer = (answer % p + calculate(r - 1, k - 1, p) % p * calculate(n - r, k, p) % p % p * pow(2, k, p) % p) % p\n    print(answer)", "MOD = int(10 ** 9 + 7)\n\ndef power(n, p):\n    ans = 1 % MOD\n    while p > 0:\n        if p % 2 == 1:\n            ans = ans * n % MOD\n        n = n * n % MOD\n        p >>= 1\n    return ans\n\ndef inver(x):\n    return power(x, MOD - 2)\ninv = [0] * 1002\nfor i in range(1, 1002):\n    inv[i] = inver(i)\n\ndef C(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k > n - k:\n        k = n - k\n    res = 1\n    for i in range(k):\n        res = res * (n - i) % MOD\n        res = res * inv[i + 1] % MOD\n    return res\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    if N == K:\n        print(2)\n        continue\n    if K > N:\n        print(0)\n        continue\n    res = 0\n    for i in range(1, K + 1):\n        res = (res + C(N - K + 1, i) * (power(2, i) * C(K - 1, i - 1)) % MOD % MOD) % MOD\n    print(res)", "def binomial(n, k):\n    if 0 <= k <= n:\n        (num, den) = (1, 1)\n        for t in range(1, min(k, n - k) + 1):\n            num *= n\n            den *= t\n            n -= 1\n        return num // den\n    else:\n        return 0\n\ndef T(n, k):\n    res = 0\n    for i in range(1, k + 1):\n        res += 2 ** i * binomial(k - 1, i - 1) * binomial(n - k + 1, i)\n    return res % mod\n\ndef pascal_style(n, k):\n    return (T(n - 2, k - 1) + T(n - 1, k - 1) + T(n - 1, k)) % mod\n\ndef hockeystick_style(n, k):\n    res = T(n - 1, k)\n    for i in range(1, k + 1):\n        res += 2 * T(n - i - 1, k - i)\n    return res % mod\n\ndef solve():\n    for _ in range(int(input())):\n        (N, K) = map(int, input().split())\n        if K == 1:\n            print(2 * N % mod)\n            continue\n        if K > N:\n            print(0)\n            continue\n        print(T(N, K))\nmod = 10 ** 9 + 7\nsolve()", "import operator as op\nimport functools\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = functools.reduce(op.mul, range(n, n - r, -1), 1)\n    denom = functools.reduce(op.mul, range(1, r + 1), 1)\n    return numer // denom\nnum = 1000000007\nvar4 = 0\ntest = input()\ntest = int(test)\nwhile test > 0:\n    ruko1 = 0\n    ruko = 0\n    test -= 1\n    (var1, var2) = [int(x) for x in input().split()]\n    var1 += 1\n    if var4 == 1:\n        var4 = var4 % 2\n        var4 = var4 + 3\n        var4 = var4 * 2 / 3\n    var3 = min(var2, var1 - var2)\n    for i in range(1, var3 + 1):\n        ruko = ncr(var2 - 1, i - 1) % num * ncr(var1 - var2, i) % num * pow(2, i) % num % num\n        ruko1 = (ruko1 % num + ruko % num) % num\n    print(ruko1)\n    ruko1 = 0", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\ntt = int(input())\nm = 1000000007\nwhile tt > 0:\n    tt = tt - 1\n    (nn, k) = input().split()\n    nn = int(nn)\n    k = int(k)\n    nn = nn + 1\n    if nn - k <= k:\n        na = nn - k\n    else:\n        na = k\n    s = 0\n    for x in range(1, na + 1):\n        s = (s % m + ncr(k - 1, x - 1, m) % m * ncr(nn - k, x, m) % m * 2 ** x % m % m) % m\n    s = s % m\n    print(int(s))", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\ntt = int(input())\nm = 1000000007\nwhile tt > 0:\n    tt = tt - 1\n    (nn, k) = input().split()\n    nn = int(nn)\n    k = int(k)\n    nn = nn + 1\n    if nn - k <= k:\n        na = nn - k\n    else:\n        na = k\n    s = 0\n    for x in range(1, na + 1):\n        s = (s % m + ncr(k - 1, x - 1, m) % m * ncr(nn - k, x, m) % m * pow(2, x) % m % m) % m\n    s = s % m\n    print(int(s))", "MOD = 10 ** 9 + 7\nz = []\nfor i in range(1100):\n    z.append(pow(i, MOD - 2, MOD))\n\ndef binomial(n, k):\n    if k > n:\n        return 0\n    if k > n - k:\n        k = n - k\n    res = 1\n    for i in range(k):\n        res = res * (n - i) % MOD\n        res = res * z[i + 1] % MOD\n    return res\n\ndef game(n, k):\n    sum = 0\n    for i in range(k):\n        temp = binomial(n - k, i + 1) * binomial(k - 1, i) % MOD * pow(2, i + 1, MOD) % MOD\n        sum = (sum + temp) % MOD\n    return sum\nfor tc in range(int(input())):\n    (n, k) = map(int, input().split())\n    n = n + 1\n    t = game(n, k)\n    print(t)", "import operator as op\nimport functools\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = functools.reduce(op.mul, range(n, n - r, -1), 1)\n    denom = functools.reduce(op.mul, range(1, r + 1), 1)\n    return numer // denom\nnum = 1000000007\ntest = input()\ntest = int(test)\nwhile test > 0:\n    ruko1 = 0\n    ruko = 0\n    test -= 1\n    (var1, var2) = [int(x) for x in input().split()]\n    var1 += 1\n    var3 = min(var2, var1 - var2)\n    for i in range(1, var3 + 1):\n        ruko = ncr(var2 - 1, i - 1) % num * ncr(var1 - var2, i) % num * pow(2, i) % num % num\n        ruko1 = (ruko1 % num + ruko % num) % num\n    print(ruko1)\n    ruko1 = 0", "hell = 1000000007\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef C(n, r):\n    num = 1\n    den = 1\n    p = 1\n    m = min(n - r, r)\n    for i in range(1, m + 1):\n        num = (n - i + 1) % hell\n        p *= num\n        p %= hell\n        den = modInverse(i, hell) % hell\n        p *= den\n        p %= hell\n    return p\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = 0\n    for i in range(1, min(n - k + 1, k) + 1):\n        a = C(n - k + 1, i)\n        b = C(k - 1, i - 1)\n        c = power(2, i, hell)\n        p = a * b % hell\n        p *= c\n        p %= hell\n        s += p\n        s %= hell\n    print(s)", "M = 10 ** 9 + 7\n\ndef ip():\n    return int(input())\n\ndef ipp():\n    return map(int, input().split())\ndp = []\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef solve2(n, k):\n    dp[1] = 2 * (n - k + 1) % M\n    dp[2] = 2 * (n - k + 1) * (n - k + 1) % M\n    for j in range(3, k + 1):\n        p = dp[j - 1]\n        q = dp[j - 2]\n        r = p * (n - k + 1) * 2 + q * (j - 2)\n        r %= M\n        r *= modInverse(j, M)\n        r %= M\n        dp[j] = r\n    return dp[k]\nfor i in range(1023):\n    dp.append(-1)\nT = ip()\nwhile T != 0:\n    (n, k) = ipp()\n    if n >= k:\n        ans = solve2(n, k)\n        ans %= M\n        print(ans)\n    else:\n        print(0)\n    T -= 1", "MOD = int(1000000000.0 + 7)\n\ndef binomial(n, k):\n    if 0 <= k <= n:\n        ntok = 1\n        ktok = 1\n        for t in range(1, min(k, n - k) + 1):\n            ntok *= n\n            ktok *= t\n            n -= 1\n        return ntok // ktok % MOD\n    else:\n        return 0\nT = int(input())\nfor _ in range(T):\n    (n, k) = [int(x) for x in input().split()]\n    s = 0\n    for r in range(1, k + 1):\n        t = pow(2, r, MOD) * binomial(k - 1, r - 1) * binomial(n - k + 1, r)\n        t %= MOD\n        s += t\n        s %= MOD\n    print(s)", "def calc_ways():\n    n = N - (K - 1)\n    A = 1\n    B = n\n    C = 2\n    ctr = A * B * C\n    for i in range(2, min(n, K) + 1):\n        A = A * (K - (i - 1)) // (i - 1)\n        B = B * (n - (i - 1)) // i\n        C = C * 2 % 1000000007\n        ctr = (ctr + A * B * C) % 1000000007\n    return str(ctr % 1000000007)\nT = int(input())\nopList = []\nfor x in range(T):\n    (N, K) = map(int, input().split())\n    if 0 in [N, K] or N < K:\n        opList.append('0')\n    else:\n        opList.append(calc_ways())\nprint('\\n'.join(opList))", "M = 10 ** 9 + 7\n\ndef ip():\n    return int(input())\n\ndef ipp():\n    return map(int, input().split())\ndp = []\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef solve(n, k):\n    if k == 1:\n        dp[1] = 2 * n % M\n        return 2 * n % M\n    if k == 2:\n        x = n - 1\n        x = x * x * 2 % M\n        dp[2] = x\n        return x\n    if n == k:\n        dp[k] = 2\n        return 2\n    if dp[k - 1] == -1:\n        p = solve(n - 1, k - 1)\n    else:\n        p = dp[k - 1]\n    if dp[k - 2] == -1:\n        q = solve(n - 2, k - 2)\n    else:\n        q = dp[k - 2]\n    r = p * (n - k + 1) * 2 + q * (k - 2)\n    r %= M\n    r *= modInverse(k, M)\n    r %= M\n    dp[k] = r\n    return r\nfor i in range(1023):\n    dp.append(-1)\n_ = ip()\nwhile _ != 0:\n    i = 0\n    for i in range(1008):\n        dp[i] = -1\n    (n, k) = ipp()\n    if k == 1000:\n        ans1 = solve(n - 1, k - 1)\n        ans2 = solve(n - 2, k - 2)\n        ans3 = (n - k + 1) * ans1 * 2 + (k - 2) * ans2\n        ans3 *= modInverse(k, M)\n        ans3 %= M\n        print(ans3)\n    elif n > k:\n        ans = solve(n, k)\n        ans %= M\n        print(ans)\n    elif n == k:\n        print(2)\n    else:\n        print(0)\n    _ -= 1", "MOD = 1000000007\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef ncr(n, r):\n    if r > n:\n        return 0\n    if r == n or n == 0:\n        return 1\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % MOD\n        den = den * (i + 1) % MOD\n    return num * power(den, MOD - 2, MOD) % MOD\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if k > n or k == 0:\n        print(0)\n    elif k == n:\n        print(2)\n    else:\n        ans = 0\n        for i in range(1, k + 1):\n            ans = (ans + power(2, i, MOD) % MOD * (ncr(n - k + 1, i) % MOD * ncr(k - 1, i - 1) % MOD) % MOD) % MOD\n        print(ans)", "M = 10 ** 9 + 7\n\ndef ip():\n    return int(input())\n\ndef ipp():\n    return map(int, input().split())\ndp = []\n\ndef solve(n, k):\n    if k == 1:\n        dp[1] = 2 * n\n        return 2 * n\n    if k == 2:\n        x = n - 1\n        x = x * x * 2\n        dp[2] = x\n        return x\n    if n == k:\n        dp[k] = 2\n        return 2\n    if dp[k - 1] == -1:\n        p = solve(n - 1, k - 1)\n    else:\n        p = dp[k - 1]\n    if dp[k - 2] == -1:\n        q = solve(n - 2, k - 2)\n    else:\n        q = dp[k - 2]\n    r = p * (n - k + 1) * 2 + q * (k - 2)\n    r //= k\n    dp[k] = r\n    return r\nfor i in range(1023):\n    dp.append(-1)\nt = ip()\nwhile t != 0:\n    i = 0\n    for i in range(1008):\n        dp[i] = -1\n    (n, k) = ipp()\n    if k == 1000:\n        ans1 = solve(n - 1, k - 1)\n        ans2 = solve(n - 2, k - 2)\n        ans3 = (n - k + 1) * ans1 * 2 + (k - 2) * ans2\n        ans3 //= k\n        ans3 %= M\n        print(ans3)\n    elif n > k:\n        ans = solve(n, k)\n        ans %= M\n        print(ans)\n    elif n == k:\n        print(2)\n    else:\n        print(0)\n    t -= 1", "M = 10 ** 9 + 7\n\ndef ip():\n    return int(input())\n\ndef ipp():\n    return map(int, input().split())\n\ndef sar():\n    return list(ipp())\ndp = []\n\ndef solve(n, k):\n    if k == 1:\n        return 2 * n\n    if k == 2:\n        x = n - 1\n        x = x * x * 2\n        return x\n    if n == k:\n        return 2\n    if dp[k] != -1:\n        return dp[k]\n    p = solve(n - 1, k - 1)\n    q = solve(n - 2, k - 2)\n    r = p * (n - k + 1) * 2\n    r += q * (k - 2)\n    r //= k\n    dp[k] = r\n    return r\nfor i in range(100023):\n    dp.append(-1)\nt = ip()\nwhile t != 0:\n    i = 0\n    for i in range(100008):\n        dp[i] = -1\n    (n, k) = ipp()\n    if k == 1000:\n        ans1 = solve(n - 1, k - 1)\n        ans2 = solve(n - 2, k - 2)\n        ans3 = (n - k + 1) * ans1 * 2\n        ans3 += (k - 2) * ans2\n        ans3 //= k\n        ans3 %= M\n        print(ans3)\n    elif n > k:\n        ans = solve(n, k)\n        ans %= M\n        print(ans)\n    elif n == k:\n        print(2)\n    else:\n        print(0)\n    t -= 1", "import math as ma\nimport sys\nfrom sys import exit\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\ndef li():\n    return list(map(int, input().split()))\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef num():\n    return map(int, input().split())\n\ndef nu():\n    return int(input())\n\ndef find_gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\nmd = [0] * 1100\nfor i in range(1100):\n    md[i] = pow(i, 1000000005, 1000000007)\n\ndef binomial(n, k):\n    if n < k:\n        return 0\n    if k > n - k:\n        k = n - k\n    res = 1\n    for i in range(k):\n        res = res * (n - i) % 1000000007\n        res = res * md[i + 1] % 1000000007\n    return res\nmm = 1000000007\nt = nu()\nfor it in range(t):\n    (n, k) = num()\n    z = n + 1\n    ss = 0\n    if k > n:\n        print(0)\n        continue\n    pp = [1] * (k + 1)\n    for i in range(1, k + 1):\n        pp[i] = pp[i - 1] * 2 % mm\n    for i in range(0, k):\n        ss = (ss + binomial(z - k, i + 1) * binomial(k - 1, i) % mm * pp[i + 1] % mm) % mm\n    print(ss % mm)", "from sys import stdin\n\ndef xgcd(a, b):\n    (x0, x1, y0, y1) = (1, 0, 0, 1)\n    while a != 0:\n        (q, b, a) = (b // a, a, b % a)\n        (x0, x1) = (x1, x0 - q * x1)\n        (y0, y1) = (y1, y0 - q * y1)\n    return (b, y0, x0)\n\ndef modinv(a, m):\n    (g, x, y) = xgcd(a, m)\n    if g != 1:\n        raise Exception('No modular inverse')\n    return x % m\np = 10 ** 9 + 7\n\ndef read():\n    t = int(stdin.readline().strip())\n    cases = []\n    for _ in range(t):\n        cases.append(list(map(int, stdin.readline().strip().split())))\n    return (t, cases)\n\ndef solve(n, k):\n    if k > n:\n        return 0\n    m = n - k + 1\n    r = 0\n    t = 1\n    for l in range(min(k, m)):\n        t = t * 2 * (m - l) * modinv(l + 1, p) % p\n        if l > 0:\n            t = t * (k - l) * modinv(l, p) % p\n        r = (r + t) % p\n    return r\n(t, cases) = read()\nfor (n, k) in cases:\n    print(solve(n, k))", "mod = 10 ** 9 + 7\n\ndef C(n, k):\n    if k > n:\n        return 0\n    elif k == n or k == 0:\n        return 1\n    if k > n - k:\n        k = n - k\n    res = 1\n    for i in range(k):\n        res *= n - i\n        res //= i + 1\n    return res\nfor t in range(int(input())):\n    (N, K) = map(int, input().split())\n    ans = 0\n    for r in range(1, K + 1):\n        ans += pow(2, r) * C(K - 1, r - 1) * C(N - K + 1, r)\n    print(ans % mod)", "import math\np = 1000000007\n\ndef calcnCrMODp(n, r):\n    if r < 0:\n        return 0\n    if n < r:\n        return 0\n    if r > int(n / 2):\n        r = n - r\n    val1 = 1\n    val2 = 1\n    for i in range(r):\n        val1 = val1 % p * (n - i) % p % p\n        val2 = val2 % p * (i + 1) % p % p\n    val2 = val2 % p\n    mod_list = [val2]\n    b_pow = 2\n    log2_b_pow = 1\n    while b_pow <= p - 2:\n        val2 = val2 % p * (val2 % p) % p\n        mod_list.append(val2)\n        b_pow = b_pow * 2\n        log2_b_pow += 1\n    b_pow = int(b_pow / 2)\n    log2_b_pow = log2_b_pow - 1\n    ans = mod_list[-1]\n    rem_pow = p - 2 - b_pow\n    while rem_pow > 0:\n        b_pow = int(b_pow / 2)\n        log2_b_pow -= 1\n        if b_pow <= rem_pow:\n            rem_pow -= b_pow\n            ans = ans % p * mod_list[log2_b_pow] % p % p\n    return ans % p * (val1 % p) % p\n\ndef mod_pow(a, n):\n    val2 = a % p\n    mod_list = [val2]\n    b_pow = 2\n    log2_b_pow = 1\n    while b_pow <= n:\n        val2 = val2 % p * (val2 % p) % p\n        mod_list.append(val2)\n        b_pow = b_pow * 2\n        log2_b_pow += 1\n    b_pow = int(b_pow / 2)\n    log2_b_pow = log2_b_pow - 1\n    ans = mod_list[-1]\n    rem_pow = n - b_pow\n    while rem_pow > 0:\n        b_pow = int(b_pow / 2)\n        log2_b_pow -= 1\n        if b_pow <= rem_pow:\n            rem_pow -= b_pow\n            ans = ans % p * (mod_list[log2_b_pow] % p) % p\n    return ans\nT = int(input())\nfor i in range(T):\n    _input = input().split()\n    N = int(_input[0])\n    K = int(_input[1])\n    sum_ = 0\n    for r in range(K + 1):\n        sum_ = (sum_ % p + mod_pow(2, r) * calcnCrMODp(K - 1, r - 1) * calcnCrMODp(N - K + 1, r) % p) % p\n    print(sum_)", "m = 1000000007\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    return p if y % 2 == 0 else x * p % m\n\ndef power2(l):\n    ret = 1\n    for i in range(l):\n        ret = ret % m * 2 % m\n    return ret\nt = input()\nt = int(t)\nwhile t > 0:\n    (a, b) = input().split()\n    a = int(a)\n    b = int(b)\n\n    def T(n, r):\n        xx = min(n - r, r) + 1\n        fact1 = []\n        fact2 = []\n        fact1.append(1)\n        fact1.append((r - 1) % m)\n        fact2.append(1)\n        fact2.append((n - r) % m)\n        upper1 = r - 1\n        upper2 = n - r\n        lower = 1\n        i1 = r - 2\n        i2 = n - r - 1\n        j = 2\n        x = 0\n        for x in range(2, xx + 1):\n            upper1 = upper1 % m * (i1 % m) % m\n            upper2 = upper2 % m * (i2 % m) % m\n            lower = lower % m * (j % m) % m\n            fact1.append(upper1 % m * (power(lower, m - 2, m) % m) % m)\n            fact2.append(upper2 % m * (power(lower, m - 2, m) % m) % m)\n            i1 -= 1\n            i2 -= 1\n            j += 1\n        fact1.append(0)\n        fact2.append(0)\n        sum = 0\n        for k in range(xx):\n            sum = (sum % m + fact1[k - 1] * fact2[k] * power2(k) % m) % m\n        return sum\n    print(T(a + 1, b) % m)\n    t -= 1", "MOD = 10 ** 9 + 7\n\ndef inverse(n):\n    (a, b, c, d) = (1, 0, 0, 1)\n    (l, r) = (MOD, n)\n    while r != 0:\n        (a, b, c, d) = (c, d, a - l // r * c, b - l // r * d)\n        (l, r) = (r, l % r)\n    return b % MOD\nT = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    answer = 0\n    binom1 = 1\n    binom2 = N - K + 1\n    for m in range(1, min(K, N - K + 1) + 1):\n        answer = (answer + pow(2, m, MOD) * binom1 * binom2) % MOD\n        binom1 = binom1 * (K - m) * inverse(m) % MOD\n        binom2 = binom2 * inverse(m + 1) * (N - m - K + 1) % MOD\n    print(answer)", "def ip():\n    return int(input())\n\ndef ipp():\n    return map(int, input().split())\n\ndef sar():\n    return list(ipp())\n\ndef pars(a):\n    print(' '.join(list(map(str, a))))\n    print('\\r')\n\ndef parl(a):\n    print('\\r'.join(list(map(str, a))))\n    print('\\r')\nm = 1000000007\n\ndef ncr(n, r):\n    nr = 1\n    dr = 1\n    for i in range(r):\n        nr = nr * (n - i) % m\n        dr = dr * (i + 1) % m\n    return nr * pow(dr, m - 2, m) % m\nT = 1\nT = int(input().strip())\nfor _ in range(T):\n    (n, k) = ipp()\n    ans = 0\n    if k == n:\n        print(2)\n    elif k > n:\n        print(0)\n    else:\n        for i in range(1, k + 1):\n            ans = (ans % m + pow(2, i, m) * (ncr(k - 1, i - 1) * ncr(n - k + 1, i) % m) % m) % m\n        print(ans % m)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nwhile t != 0:\n    (N, K) = map(int, input().split())\n    if K > N:\n        print(0)\n    else:\n        ans = 0\n        m = 10 ** 9 + 7\n        for r in range(1, K + 1):\n            ans = (ans + pow(2, r, m) * ncr(K - 1, r - 1, m) % m * ncr(N - K + 1, r, m) % m) % m\n        print(ans)\n    t = t - 1", "from functools import lru_cache\nfrom sys import setrecursionlimit\nsetrecursionlimit(1000000)\nmod = 1000000007\n\ndef addR(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mulR(a, b):\n    return a % mod * (b % mod) % mod\n\n@lru_cache(maxsize=None)\ndef combi(n, r):\n    if n < 0 or r < 0:\n        return 0\n    if r == 0:\n        return 1\n    if n == 0:\n        return 0\n    ans = 1\n    r = max(r, n - r)\n    m = n\n    while m >= r + 1:\n        ans = mulR(ans, m)\n        m -= 1\n    d = n - r\n    while d > 0:\n        ans = mulR(ans, poww(d, mod - 2))\n        d -= 1\n    return ans\n\n@lru_cache(maxsize=None)\ndef poww(z, l):\n    if l == 1:\n        return z\n    if l == 0:\n        return 1\n    x = poww(z, int(l / 2))\n    y = poww(z, l % 2)\n    return mulR(mulR(x, x), y)\n\ndef fff(n, k):\n    a = n - k + 1\n    b = k\n    i = 1\n    ans = 0\n    while i <= min(a, b):\n        compo1 = poww(2, i)\n        compo2 = combi(a, i)\n        compo3 = combi(b - 1, i - 1)\n        ans = addR(ans, mulR(mulR(compo1, compo2), compo3))\n        i += 1\n    return ans\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    print(fff(n, k))"]