["n = int(input())\na = list(map(int, input().split()))\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(a, map(int, input().split())))))\n    nn = len(slices)\n    if k > nn:\n        print(0)\n        continue\n    b = 64\n    bm = 0\n    p_sum = [slices[0]]\n    for i in range(1, nn):\n        p_sum.append(slices[i] + p_sum[-1])\n    dp = [[False] * k for __ in range(nn)]\n    while b > -1:\n        bm = bm | 1 << b\n        for cn in range(nn):\n            dp[cn][0] = p_sum[cn] & bm == bm\n            for ck in range(1, k):\n                dp[cn][ck] = False\n        for cn in range(nn):\n            for ck in range(1, k):\n                for pn in range(cn):\n                    dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n        if not dp[-1][-1]:\n            bm -= 1 << b\n        b -= 1\n    print(bm)", "n = int(input())\na = list(map(int, input().split()))\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(a, map(int, input().split())))))\n    nn = len(slices)\n    if k > nn:\n        print(0)\n        continue\n    b = 64\n    bm = 0\n    p_sum = [slices[0]]\n    for i in range(1, nn):\n        p_sum.append(slices[i] + p_sum[-1])\n    dp = [[False] * k for __ in range(nn)]\n    while b > -1:\n        bm = bm | 1 << b\n        for cn in range(nn):\n            dp[cn][0] = p_sum[cn] & bm == bm\n            for ck in range(1, k):\n                dp[cn][ck] = False\n        for cn in range(nn):\n            for ck in range(1, k):\n                for pn in range(cn):\n                    dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n        if not dp[-1][-1]:\n            bm -= 1 << b\n        b -= 1\n    print(bm)", "n = int(input())\ntaste = list(map(int, input().split()))\nq = int(input())\nfrom functools import lru_cache\n\ndef solve(taste, sweet):\n    g = [i * j for (i, j) in zip(taste, sweet) if i * j]\n    size = len(g)\n    ans = 0\n\n    @lru_cache(None)\n    def dp(i, k, bit):\n        if i == size:\n            return k == 0\n        s = r = 0\n        for j in range(i, size):\n            s += g[j]\n            if s & 1 << bit and s & ans >= ans:\n                r |= dp(j + 1, k - 1, bit)\n        return r\n    for bit in range(64, -1, -1):\n        ans |= dp(0, k, bit) << bit\n    return ans\nfor _ in range(q):\n    k = int(input())\n    sweet = list(map(int, input().split()))\n    print(solve(taste, sweet))", "n = int(input())\ntaste = list(map(int, input().split()))\nq = int(input())\nfrom functools import lru_cache\n\ndef solve(taste, sweet):\n    g = [i * j for (i, j) in zip(taste, sweet) if i * j]\n    size = len(g)\n    ans = 0\n\n    @lru_cache(None)\n    def dp(i, k, bit):\n        if i == size:\n            return k == 0\n        s = r = 0\n        for j in range(i, size):\n            s += g[j]\n            if s & 1 << bit and s & ans >= ans:\n                r |= dp(j + 1, k - 1, bit)\n        return r\n    for bit in range(64, -1, -1):\n        ans |= dp(0, k, bit) << bit\n    return ans\nfor _ in range(q):\n    k = int(input())\n    sweet = list(map(int, input().split()))\n    print(solve(taste, sweet))", "n = int(input())\ntaste = list(map(int, input().split()))\nq = int(input())\nfrom functools import lru_cache\n\ndef solve(taste, sweet):\n    g = [i * j for (i, j) in zip(taste, sweet) if i * j]\n    size = len(g)\n    ans = 0\n\n    @lru_cache(None)\n    def dp(i, k, bit):\n        if i == size:\n            return k == 0\n        s = r = 0\n        for j in range(i, size):\n            s += g[j]\n            if s & 1 << bit and s & ans >= ans:\n                r |= dp(j + 1, k - 1, bit)\n        return r\n    for bit in range(64, -1, -1):\n        ans |= dp(0, k, bit) << bit\n    return ans\nfor _ in range(q):\n    k = int(input())\n    sweet = list(map(int, input().split()))\n    print(solve(taste, sweet))", "n = int(input())\ntaste = list(map(int, input().split()))\nq = int(input())\nfrom functools import lru_cache\n\ndef solve(taste, sweet):\n    g = [i * j for (i, j) in zip(taste, sweet) if i * j]\n    size = len(g)\n    ans = 0\n\n    @lru_cache(None)\n    def dp(i, k, bit):\n        if i == size:\n            return k == 0\n        s = r = 0\n        for j in range(i, size):\n            s += g[j]\n            if s & 1 << bit and s & ans >= ans:\n                r |= dp(j + 1, k - 1, bit)\n        return r\n    for bit in range(64, -1, -1):\n        if dp(0, k, bit):\n            ans |= 1 << bit\n    return ans\nfor _ in range(q):\n    k = int(input())\n    sweet = list(map(int, input().split()))\n    print(solve(taste, sweet))", "n = int(input())\na = list(map(int, input().split()))\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(a, map(int, input().split())))))\n    nn = len(slices)\n    if k > nn:\n        print(0)\n        continue\n    b = 64\n    bm = 0\n    p_sum = [slices[0]]\n    for i in range(1, nn):\n        p_sum.append(slices[i] + p_sum[-1])\n    dp = [[False] * k for __ in range(nn)]\n    while b > -1:\n        bm = bm | 1 << b\n        for cn in range(nn):\n            dp[cn][0] = p_sum[cn] & bm == bm\n            for ck in range(1, k):\n                dp[cn][ck] = False\n        for cn in range(nn):\n            for ck in range(1, k):\n                for pn in range(cn):\n                    dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n        if not dp[-1][-1]:\n            bm -= 1 << b\n        b -= 1\n    print(bm)", "def group(S, k):\n    if k == 1:\n        return sum(S)\n    firstPiece = 0\n    answer = 0\n    dynamic = {}\n    for i in range(len(S) - k + 1):\n        firstPiece += S[i]\n        answer = max(groupWithPattern(S[i + 1:], k - 1, firstPiece, dynamic), answer)\n    return answer\n\ndef groupWithPattern(S, k, p, dynamic):\n    if k == 1:\n        return sum(S) & p\n    try:\n        return dynamic[len(S), k, p]\n    except KeyError:\n        pass\n    firstPiece = 0\n    answer = 0\n    for i in range(len(S) - k + 1):\n        firstPiece += S[i]\n        answer = max(groupWithPattern(S[i + 1:], k - 1, p & firstPiece, dynamic), answer)\n    dynamic[len(S), k, p] = answer\n    return answer\nn = int(input())\nA = [int(a) for a in input().split()]\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    T = [int(t) for t in input().split()]\n    S = [a * t for (a, t) in zip(A, T) if a * t > 0]\n    print(group(S, k) if k <= len(S) else 0)", "from sys import *\nimport os\nimport re\nfrom math import *\nfrom bisect import *\nfrom collections import defaultdict\nimport functools\n\ndef nextline():\n    return list(map(int, input().strip().split()))\nN = int(input())\nA = nextline()\nQ = int(input())\nfor q in range(Q):\n    (K,) = nextline()\n    t = nextline()\n    values = []\n    for i in range(N):\n        v = t[i] * A[i]\n        if v == 0:\n            continue\n        values.append(v)\n    M = len(values)\n    if K > M:\n        print(0)\n        continue\n    if K == M:\n        print(functools.reduce(lambda a, b: a & b, values))\n        continue\n    DP = [None] * (M + 1)\n    DP[0] = set()\n    presum = [0] * (M + 1)\n    for i in range(M):\n        presum[i + 1] = presum[i] + values[i]\n        DP[i + 1] = {presum[i + 1]}\n    for p in range(2, K + 1):\n        DPM1 = DP\n        DP = [set() for x in range(M + 1)]\n        for i in range(p, M + 1):\n            for j in range(p - 1, i):\n                partsum = presum[i] - presum[j]\n                for v in DPM1[j]:\n                    DP[i].add(partsum & v)\n    print(max(DP[M]))", "from sys import *\nimport os\nimport re\nfrom math import *\nfrom bisect import *\nfrom collections import defaultdict\nimport functools\n\ndef nextline():\n    return list(map(int, input().strip().split()))\nN = int(input())\nA = nextline()\nQ = int(input())\nfor q in range(Q):\n    (K,) = nextline()\n    t = nextline()\n    values = []\n    for i in range(N):\n        v = t[i] * A[i]\n        if v == 0:\n            continue\n        values.append(v)\n    M = len(values)\n    if K > M:\n        print(0)\n        continue\n    DP = [None] * (M + 1)\n    DP[0] = set()\n    presum = [0] * (M + 1)\n    for i in range(M):\n        presum[i + 1] = presum[i] + values[i]\n        DP[i + 1] = {presum[i + 1]}\n    for p in range(2, K + 1):\n        DPM1 = DP\n        DP = [set() for x in range(M + 1)]\n        for i in range(p, M + 1):\n            for j in range(p - 1, i):\n                partsum = presum[i] - presum[j]\n                for v in DPM1[j]:\n                    DP[i].add(partsum & v)\n    print(max(DP[M]))"]