["import numpy as np\nimport math\nt_cases = int(input())\nMOD = 1000000000 + 7\nbmax = 5000\nsq_integers = []\nsum_sq_integers = []\nfor i in range(1, bmax + 1):\n    sq_integers.append(i * i)\n    sum_sq_integers.append(0)\nfor i in range(0, bmax):\n    if i == 0:\n        sum_sq_integers[i] = sq_integers[i]\n    else:\n        sum_sq_integers[i] = sq_integers[i] + sum_sq_integers[i - 1]\n\ndef get_sum_sq(a, b):\n    if a > b:\n        return 0\n    if a == 1:\n        return sum_sq_integers[b - 1]\n    return sum_sq_integers[b - 1] - sum_sq_integers[a - 2]\ndp_rem_sq = []\nfor i in range(1, bmax + 1):\n    tmp_lst = []\n    sm = 0\n    for j in range(0, bmax // 50):\n        for k in range(j * 50 + 1, j * 50 + 51):\n            if k > i:\n                sm += k * k % i\n        tmp_lst.append(sm)\n    dp_rem_sq.append(tmp_lst)\n\ndef f4(a, b, bm, c):\n    if a < b or c < b:\n        return 0\n    return (bm - b + 1 + MOD) % MOD\n\ndef f3(a, b, bm):\n    if a <= b or b >= bm:\n        return 0\n    if a < bm * bm // b:\n        sqrt_ab = int(math.sqrt(a * b))\n        ans = f3(a, b, sqrt_ab) + max(0, bm - max(b, sqrt_ab)) * max(0, a - b)\n        return ans % MOD\n    ind = bm // 50 - 1\n    ans = 0\n    if ind >= 0:\n        ans = get_sum_sq(b, ind * 50 + 50) - dp_rem_sq[b - 1][ind]\n    ans = ans // b % MOD\n    for i in range(bm // 50 * 50 + 1, bm + 1):\n        if i >= b:\n            ans += i * i // b % MOD\n            ans = ans % MOD\n    ans = (ans - b * max(bm - b + 1, 0) % MOD + MOD) % MOD\n    return ans\n\ndef f2(a, b, bm, c):\n    if a < b or c < b:\n        return 0\n    tmp = (f3(a, b, bm) + f3(c, b, bm) + f4(a, b, bm, c)) % MOD\n    return tmp\n\ndef f_501(a, b, c):\n    ans = 0\n    for i in range(1, b + 1):\n        ans += f2(a, i, b, c) % MOD\n    ans = (a * b * c % MOD + MOD - ans % MOD) % MOD\n    return ans % MOD\n\ndef exc(a, x, b, c):\n    if 1 <= x and x <= a and (x <= c):\n        return max(min(b * b // x, a) - x, 0) + max(min(b * b // x, c) - x, 0) + 1\n    return 0\n\ndef triple_b(a, b, c):\n    if a * c == 0 or b * b - a * c >= 0:\n        return 0\n    sm = 0\n    for i in range(1, b + 1):\n        sm = (sm + exc(a, i, b, c)) % MOD\n    sm = (a * c - sm + MOD) % MOD\n    return sm % MOD\nans = ''\nfor i in range(0, t_cases):\n    (a, b, c) = list(map(int, input().split()))\n    sm = 0\n    if b <= 100:\n        for i in range(1, b + 1):\n            sm = (sm + triple_b(a - 1, i, c - 1)) % MOD\n    else:\n        sm = f_501(a - 1, b, c - 1) % MOD\n    ans = ans + str(sm) + '\\n'\nprint(ans, end='')", "import numpy as np\nimport math\nt_cases = int(input())\nMOD = 1000000000 + 7\nbmax = 5000\nsq_integers = []\nsum_sq_integers = []\nfor i in range(1, bmax + 1):\n    sq_integers.append(i * i)\n    sum_sq_integers.append(0)\nfor i in range(0, bmax):\n    if i == 0:\n        sum_sq_integers[i] = sq_integers[i]\n    else:\n        sum_sq_integers[i] = sq_integers[i] + sum_sq_integers[i - 1]\n\ndef get_sum_sq(a, b):\n    if a > b:\n        return 0\n    if a == 1:\n        return sum_sq_integers[b - 1]\n    return sum_sq_integers[b - 1] - sum_sq_integers[a - 2]\ndp_rem_sq = []\nfor i in range(1, bmax + 1):\n    tmp_lst = []\n    sm = 0\n    for j in range(0, bmax // 50):\n        for k in range(j * 50 + 1, j * 50 + 51):\n            if k > i:\n                sm += k * k % i\n        tmp_lst.append(sm)\n    dp_rem_sq.append(tmp_lst)\n\ndef f4(a, b, bm, c):\n    if a < b or c < b:\n        return 0\n    return (bm - b + 1 + MOD) % MOD\n\ndef f3(a, b, bm):\n    if a <= b or b >= bm:\n        return 0\n    if a < bm * bm // b:\n        sqrt_ab = int(math.sqrt(a * b))\n        ans = f3(a, b, sqrt_ab) + max(0, bm - max(b, sqrt_ab)) * max(0, a - b)\n        return ans % MOD\n    ind = bm // 50 - 1\n    ans = 0\n    if ind >= 0:\n        ans = get_sum_sq(b, ind * 50 + 50) - dp_rem_sq[b - 1][ind]\n    ans = ans // b % MOD\n    for i in range(bm // 50 * 50 + 1, bm + 1):\n        if i >= b:\n            ans += i * i // b % MOD\n            ans = ans % MOD\n    ans = (ans - b * max(bm - b + 1, 0) % MOD + MOD) % MOD\n    return ans\n\ndef f2(a, b, bm, c):\n    if a < b or c < b:\n        return 0\n    tmp = (f3(a, b, bm) + f3(c, b, bm) + f4(a, b, bm, c)) % MOD\n    return tmp\n\ndef f_501(a, b, c):\n    ans = 0\n    for i in range(1, b + 1):\n        ans += f2(a, i, b, c) % MOD\n    ans = (a * b * c % MOD + MOD - ans % MOD) % MOD\n    return ans % MOD\n\ndef exc(a, x, b, c):\n    if 1 <= x and x <= a and (x <= c):\n        return max(min(b * b // x, a) - x, 0) + max(min(b * b // x, c) - x, 0) + 1\n    return 0\n\ndef triple_b(a, b, c):\n    if a * c == 0 or b * b - a * c >= 0:\n        return 0\n    sm = 0\n    for i in range(1, b + 1):\n        sm = (sm + exc(a, i, b, c)) % MOD\n    sm = (a * c - sm + MOD) % MOD\n    return sm % MOD\nans = ''\nfor i in range(0, t_cases):\n    (a, b, c) = list(map(int, input().split()))\n    sm = 0\n    if b <= 100:\n        for i in range(1, b + 1):\n            sm = (sm + triple_b(a - 1, i, c - 1)) % MOD\n    else:\n        sm = f_501(a - 1, b, c - 1) % MOD\n    ans = ans + str(sm) + '\\n'\nprint(ans, end='')", "import math\nMOD = 10 ** 9 + 7\nB_MAX = 5000\nD = [[0] * (B_MAX + 1) for _ in range(B_MAX + 1)]\nfor b in range(1, B_MAX + 1):\n    b_sq = b ** 2\n    for i in range(1, b + 1):\n        D[b][i] = (b_sq // i + D[b][i - 1]) % MOD\n\ndef greater_product(A, C, b):\n    b_sq = b ** 2\n    ans = 0\n    if A <= b and C <= b:\n        ans = 0\n    elif A > b and C > b:\n        s = math.ceil(b_sq / A)\n        less_than = (s - 1) * A % MOD\n        less_than = (less_than + D[b][b] - D[b][s - 1]) % MOD\n        s = math.ceil(b_sq / C)\n        less_than = (less_than + (s - 1) * (C - b)) % MOD\n        less_than = (less_than + D[b][b - 1] - D[b][s - 1]) % MOD\n        less_than = (less_than - b * (b - s)) % MOD\n        ans = (A * C - less_than) % MOD\n    else:\n        if A <= b:\n            (A, C) = (C, A)\n        s = math.ceil(b_sq / A)\n        if s > C:\n            ans = 0\n        else:\n            less_than = (s - 1) * A % MOD\n            less_than = (less_than + D[b][C] - D[b][s - 1]) % MOD\n            ans = (A * C - less_than) % MOD\n    if ans < 0:\n        ans += MOD\n    return ans\nt = int(input())\nfor _ in range(t):\n    (A, B, C) = map(int, input().split())\n    A -= 1\n    C -= 1\n    ret = 0\n    for b in range(1, B + 1):\n        ret = (ret + greater_product(A, C, b)) % MOD\n    print(ret)"]