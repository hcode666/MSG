["import sys\nimport copy\nimport math\nisIo = False\nsys.setrecursionlimit(10 ** 6)\nif isIo:\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nisTakeTestCase = True\n\ndef scanIntList():\n    return map(int, input().split())\n\ndef printList(lst):\n    for elem in lst:\n        print(elem, end=' ')\n    print()\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)\n\ndef solve():\n    (n, k, a) = scanIntList()\n    special = list(scanIntList())\n    isSpecial = {}\n    for node in special:\n        isSpecial[node] = True\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (x, y) = scanIntList()\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    for i in range(1, n + 1):\n        print(objective[i], end=' ')\n    print()\n    for i in range(1, n + 1):\n        print(myspec[i], end=' ')\n    print()\n\ndef driver():\n    testCases = 1\n    if isTakeTestCase:\n        testCases = int(input())\n    for i in range(testCases):\n        solve()\ndriver()", "import sys\nimport copy\nimport math\nisIo = False\nsys.setrecursionlimit(10 ** 6)\nif isIo:\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nisTakeTestCase = True\n\ndef scanIntList():\n    return map(int, input().split())\n\ndef printList(lst):\n    for elem in lst:\n        print(elem, end=' ')\n    print()\n\ndef markDistance(tree, isSpecial, dist, parentOfSpec, root, par, distanceFromRoot):\n    dist[root] = distanceFromRoot + 1\n    dep = int(10000000000.0)\n    depSpec = -1\n    if root in isSpecial:\n        parentOfSpec[root] = root\n        dep = 0\n        depSpec = root\n    for node in tree[root]:\n        if par != node:\n            (specNode, tempDep) = markDistance(tree, isSpecial, dist, parentOfSpec, node, root, distanceFromRoot + 1)\n            if dep > tempDep:\n                dep = tempDep\n                depSpec = specNode\n    parentOfSpec[root] = depSpec\n    return (parentOfSpec[root], dep + 1)\n\ndef dfs(tree, dist, parentOfSpec, objective, myspec, root, par, specAnc):\n    if parentOfSpec[root] != -1:\n        objective[root] = dist[root]\n        specAnc = root\n        myspec[root] = parentOfSpec[root]\n    else:\n        objective[root] = 2 * dist[specAnc] - dist[root]\n        myspec[root] = parentOfSpec[specAnc]\n    for node in tree[root]:\n        if par != node:\n            dfs(tree, dist, parentOfSpec, objective, myspec, node, root, specAnc)\n\ndef solve():\n    (n, k, a) = scanIntList()\n    special = list(scanIntList())\n    isSpecial = {}\n    for node in special:\n        isSpecial[node] = True\n    tree = [[] for _ in range(n + 1)]\n    dist = [-1 for _ in range(n + 1)]\n    objective = [-1 for _ in range(n + 1)]\n    parentOfSpec = [0 for _ in range(n + 1)]\n    myspec = [-1 for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (x, y) = scanIntList()\n        tree[x].append(y)\n        tree[y].append(x)\n    markDistance(tree, isSpecial, dist, parentOfSpec, a, -1, -1)\n    dfs(tree, dist, parentOfSpec, objective, myspec, a, -1, -1)\n    for i in range(1, n + 1):\n        print(objective[i], end=' ')\n    print()\n    for i in range(1, n + 1):\n        print(myspec[i], end=' ')\n    print()\n\ndef driver():\n    testCases = 1\n    if isTakeTestCase:\n        testCases = int(input())\n    for i in range(testCases):\n        solve()\ndriver()", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef dfs(root, depth, parent=-1):\n    sp = -1\n    parent_list[root] = parent\n    for e in adj_list[root]:\n        if e != parent_list[root]:\n            temp = dfs(e, depth + 1, root)\n            if temp != -1 and sp == -1:\n                sp = temp\n    if sp_nodes[root]:\n        sp = root\n    if sp != -1:\n        ans_list[root] = depth\n        ans_node_list[root] = sp\n    return sp\n\ndef dfs2(root, depth, L, parent):\n    ans_list[root] = ans_list[L] - depth\n    ans_node_list[root] = ans_node_list[L]\n    for e in adj_list[root]:\n        if e != parent:\n            dfs2(e, depth + 1, L, root)\nt = int(input())\nfor _ in range(t):\n    (n, k, a) = map(int, input().split())\n    a -= 1\n    f = map(int, input().split())\n    sp_nodes = [False] * n\n    for i in f:\n        sp_nodes[i - 1] = True\n    adj_list = [[] for i in range(n)]\n    parent_list = [-1] * n\n    ans_list = [-1] * n\n    ans_node_list = [-1] * n\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    dfs(a, 0)\n    for i in range(n):\n        if ans_list[i] == -1 and parent_list[i] != -1 and (ans_node_list[parent_list[i]] != -1):\n            dfs2(i, 1, parent_list[i], parent_list[i])\n    print(*ans_list)\n    print(' '.join(map(str, [x + 1 for x in ans_node_list])))\n    print()", "import sys\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\nip = sys.stdin.read().split('\\n')\nit = 0\n\ndef dfs(root, depth, parent=-1):\n    sp = -1\n    parent_list[root] = parent\n    for e in adj_list[root]:\n        if e != parent_list[root]:\n            temp = dfs(e, depth + 1, root)\n            if temp != -1 and sp == -1:\n                sp = temp\n    if sp_nodes[root]:\n        sp = root\n    if sp != -1:\n        ans_list[root] = depth\n        ans_node_list[root] = sp\n    return sp\n\ndef dfs2(root, depth, L, parent):\n    ans_list[root] = ans_list[L] - depth\n    ans_node_list[root] = ans_node_list[L]\n    for e in adj_list[root]:\n        if e != parent:\n            dfs2(e, depth + 1, L, root)\nt = int(ip[it])\nit += 1\noutput = []\nfor _ in range(t):\n    (n, k, a) = map(int, ip[it].split())\n    it += 1\n    a -= 1\n    f = map(int, ip[it].split())\n    it += 1\n    sp_nodes = [False] * n\n    for i in f:\n        sp_nodes[i - 1] = True\n    adj_list = [[] for i in range(n)]\n    parent_list = [-1] * n\n    ans_list = [-1] * n\n    ans_node_list = [-1] * n\n    for _ in range(n - 1):\n        (u, v) = map(int, ip[it].split())\n        it += 1\n        u -= 1\n        v -= 1\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    dfs(a, 0)\n    for i in range(n):\n        if ans_list[i] == -1 and parent_list[i] != -1 and (ans_node_list[parent_list[i]] != -1):\n            dfs2(i, 1, parent_list[i], parent_list[i])\n    output.append(' '.join(map(str, ans_list)))\n    output.append(' '.join(map(str, [x + 1 for x in ans_node_list])))\nprint('\\n'.join(output))", "import sys\nsys.setrecursionlimit(10 ** 7)\n\nclass Graph:\n\n    def __init__(self, N):\n        self.N = N\n        self.adj = [[] for i in range(N + 1)]\n        self.hasSpInSub = [False] * (N + 1)\n        self.nearestAncestor = [0] * (N + 1)\n        self.level = [0] * (N + 1)\n        self.anySpNode = [0] * (N + 1)\n\n    def addEdge(self, a, b):\n        self.adj[a].append(b)\n        self.adj[b].append(a)\n\n    def prep(self, a, dic):\n\n        def dfs(node, par, depth):\n            self.level[node] = depth\n            for cnode in self.adj[node]:\n                if cnode == par:\n                    continue\n                v = dfs(cnode, node, depth + 1)\n                if v:\n                    self.anySpNode[node] = v\n                self.hasSpInSub[node] = v or self.hasSpInSub[node]\n            if node in dic:\n                self.hasSpInSub[node] = True\n                self.anySpNode[node] = node\n            return self.anySpNode[node]\n        dfs(a, 0, 0)\n\n        def dfs1(node, par, latestSpecialAncestor):\n            if self.hasSpInSub[node]:\n                latestSpecialAncestor = node\n            self.nearestAncestor[node] = latestSpecialAncestor\n            for cnode in self.adj[node]:\n                if cnode == par:\n                    continue\n                dfs1(cnode, node, latestSpecialAncestor)\n        dfs1(a, 0, a)\n\n    def show(self):\n        for node in range(1, self.N + 1):\n            print('node', node, 'Has Special Node', self.hasSpInSub[node])\n        print()\n        for node in range(1, self.N + 1):\n            print('Node', node, 'Nearest Special Ancestor', self.nearestAncestor[node])\n        print('-' * 40)\n\n    def dist(self, u, v):\n        return self.level[v] - self.level[u]\n\ndef solve(N, f, a):\n    spNodes = {}\n    for node in f:\n        spNodes[node] = 1\n    gr = Graph(N)\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        gr.addEdge(u, v)\n    gr.prep(a, spNodes)\n    Distances = []\n    SpecialNode = []\n    for b in range(1, N + 1):\n        nearestAncestor = gr.nearestAncestor[b]\n        v = gr.dist(a, nearestAncestor) - gr.dist(nearestAncestor, b)\n        Distances.append(v)\n        SpecialNode.append(gr.anySpNode[nearestAncestor])\n    print(*Distances)\n    print(*SpecialNode)\nfor case in range(int(input())):\n    (N, K, a) = map(int, input().split())\n    f = list(map(int, input().split()))\n    solve(N, f, a)", "import math\nimport sys\n\ndef solve():\n    (n, k, a) = map(int, input().split())\n    a -= 1\n    temp = list(map(int, input().split()))\n    spc = [False] * n\n    for i in temp:\n        spc[i - 1] = True\n    edges = []\n    for i in range(n):\n        edges.append([])\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        edges[u - 1].append(v - 1)\n        edges[v - 1].append(u - 1)\n    vis = [False] * n\n    parent = [None] * n\n    depth = [0] * n\n    dist = [None] * n\n    a_to_spc = [None] * n\n    nodes = [a]\n    max_depth = 0\n    levels = []\n    for i in range(n):\n        levels.append([])\n    while nodes:\n        node = nodes.pop()\n        levels[depth[node]].append(node)\n        vis[node] = True\n        for child in edges[node]:\n            if not vis[child]:\n                nodes.append(child)\n                depth[child] = depth[node] + 1\n                parent[child] = node\n        if depth[node] > max_depth:\n            max_depth = depth[node]\n    vis = [False] * n\n    for i in range(max_depth, -1, -1):\n        while levels[i]:\n            node = levels[i].pop()\n            if spc[node]:\n                dist[node] = depth[node]\n                a_to_spc[node] = node\n            parent_node = parent[node]\n            if dist[node] is not None:\n                u = a_to_spc[node]\n                children = [x for x in edges[node] if dist[x] is None and x != parent_node]\n                while children:\n                    child = children.pop()\n                    dist[child] = 2 * depth[node] - depth[child]\n                    a_to_spc[child] = u\n                    children.extend([x for x in edges[child] if dist[x] is None])\n            if parent_node != None and dist[node] != None:\n                a_to_spc[parent_node] = a_to_spc[node]\n                dist[parent_node] = depth[parent_node]\n    for i in range(n):\n        print(dist[i], end=' ')\n    print('')\n    for i in range(n):\n        print(a_to_spc[i] + 1, end=' ')\n    print('')\nt = int(input())\nfor i in range(t):\n    solve()", "T = int(input())\nfor _ in range(T):\n    (n, k, a) = [int(x) for x in input().split()]\n    special = [int(x) for x in input().split()]\n    graph = {i + 1: [] for i in range(n)}\n    for i in range(n - 1):\n        (u, v) = [int(x) for x in input().split()]\n        graph[u].append(v)\n        graph[v].append(u)\n    adist = {i + 1: 10 ** 6 for i in range(n)}\n    parent = {i + 1: 0 for i in range(n)}\n    queue = [a]\n    visited = {a}\n    adist[a] = 0\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if v not in visited:\n                queue.append(v)\n                visited.add(v)\n                adist[v] = min(adist[v], adist[u] + 1)\n                parent[v] = u\n    good = {a: special[0]}\n    for u in special:\n        v = u\n        while v not in good:\n            good[v] = u\n            v = parent[v]\n    gdist = {i + 1: 10 ** 6 for i in range(n)}\n    snode = {i + 1: special[0] for i in range(n)}\n    queue = [a]\n    visited = {a}\n    gdist[a] = 0\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if v not in visited:\n                queue.append(v)\n                visited.add(v)\n                if v in good:\n                    gdist[v] = 0\n                    snode[v] = good[v]\n                else:\n                    gdist[v] = min(gdist[v], gdist[u] + 1)\n                    snode[v] = snode[parent[v]]\n    fdist = [adist[i + 1] - 2 * gdist[i + 1] for i in range(n)]\n    fnode = [snode[i + 1] for i in range(n)]\n    print(*fdist)\n    print(*fnode)", "for _ in range(int(input())):\n    (n, k, a) = [int(x) for x in input().split()]\n    special = [int(x) for x in input().split()]\n    graph = {i + 1: [] for i in range(n)}\n    for i in range(n - 1):\n        (u, v) = [int(x) for x in input().split()]\n        graph[u].append(v)\n        graph[v].append(u)\n    adist = {i + 1: 10 ** 6 for i in range(n)}\n    parent = {i + 1: 0 for i in range(n)}\n    queue = [a]\n    visited = {a}\n    adist[a] = 0\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if v not in visited:\n                queue.append(v)\n                visited.add(v)\n                adist[v] = min(adist[v], adist[u] + 1)\n                parent[v] = u\n    good = {a: special[0]}\n    for u in special:\n        v = u\n        while v not in good:\n            good[v] = u\n            v = parent[v]\n    gdist = {i + 1: 10 ** 6 for i in range(n)}\n    snode = {i + 1: special[0] for i in range(n)}\n    queue = [a]\n    visited = {a}\n    gdist[a] = 0\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if v not in visited:\n                queue.append(v)\n                visited.add(v)\n                if v in good:\n                    gdist[v] = 0\n                    snode[v] = good[v]\n                else:\n                    gdist[v] = min(gdist[v], gdist[u] + 1)\n                    snode[v] = snode[parent[v]]\n    fdist = [adist[i + 1] - 2 * gdist[i + 1] for i in range(n)]\n    fnode = [snode[i + 1] for i in range(n)]\n    print(*fdist)\n    print(*fnode)", "for _ in range(int(input())):\n    (n, k, a) = [int(x) for x in input().split()]\n    special = [int(x) for x in input().split()]\n    graph = {i + 1: [] for i in range(n)}\n    for i in range(n - 1):\n        (u, v) = [int(x) for x in input().split()]\n        graph[u].append(v)\n        graph[v].append(u)\n    adist = {i + 1: 10 ** 6 for i in range(n)}\n    parent = {i + 1: 0 for i in range(n)}\n    queue = [a]\n    visited = {a}\n    adist[a] = 0\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if v not in visited:\n                queue.append(v)\n                visited.add(v)\n                adist[v] = min(adist[v], adist[u] + 1)\n                parent[v] = u\n    good = {a: special[0]}\n    for u in special:\n        v = u\n        while v not in good:\n            good[v] = u\n            v = parent[v]\n    gdist = {i + 1: 10 ** 6 for i in range(n)}\n    snode = {i + 1: special[0] for i in range(n)}\n    queue = [a]\n    visited = {a}\n    gdist[a] = 0\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if v not in visited:\n                queue.append(v)\n                visited.add(v)\n                if v in good:\n                    gdist[v] = 0\n                    snode[v] = good[v]\n                else:\n                    gdist[v] = min(gdist[v], gdist[u] + 1)\n                    snode[v] = snode[parent[v]]\n    fdist = [adist[i + 1] - 2 * gdist[i + 1] for i in range(n)]\n    fnode = [snode[i + 1] for i in range(n)]\n    print(*fdist)\n    print(*fnode)", "from collections import defaultdict, deque\n\ndef bfs(start, version):\n    seen = set()\n    q = deque()\n    q.append(start)\n    adist[start] = 0\n    while q:\n        v = q.popleft()\n        if v not in seen:\n            seen.add(v)\n            for neighbor in d[v]:\n                if neighbor not in seen:\n                    q.append(neighbor)\n                    if version == 1:\n                        adist[neighbor] = min(adist[neighbor], adist[v] + 1)\n                        parent[neighbor] = v\n                    elif neighbor in good:\n                        gdist[neighbor] = 0\n                        snode[neighbor] = good[neighbor]\n                    else:\n                        gdist[neighbor] = min(gdist[neighbor], gdist[v] + 1)\n                        snode[neighbor] = snode[parent[neighbor]]\nt = int(input())\nfor _ in range(t):\n    (n, k, a) = map(int, input().split())\n    f = [int(i) for i in input().split()]\n    d = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    adist = {i + 1: 10 ** 6 for i in range(n)}\n    parent = {i + 1: -1 for i in range(n)}\n    bfs(a, 1)\n    good = {a: f[0]}\n    for u in f:\n        v = u\n        while v not in good:\n            good[v] = u\n            v = parent[v]\n    gdist = {i + 1: 10 ** 6 for i in range(n)}\n    snode = {i + 1: f[0] for i in range(n)}\n    gdist[a] = 0\n    bfs(a, 2)\n    fdist = [adist[i + 1] - 2 * gdist[i + 1] for i in range(n)]\n    fnode = [snode[i + 1] for i in range(n)]\n    print(*fdist)\n    print(*fnode)", "from sys import stdin, stdout\nfrom collections import defaultdict as dd\nfrom collections import deque\nimport math\nimport sys\nimport random\nsys.setrecursionlimit(int(10000000.0))\ninput = stdin.readline\nflush = stdout.flush\np = int(1000000000.0) + 7\n\ndef dfs(root, x):\n    vis[root] = True\n    dis[root] = x\n    for i in d[root]:\n        if vis[i] == False:\n            dfs(i, x + 1)\n\ndef dfs2(root):\n    has_after = -1\n    vis[root] = True\n    for i in d[root]:\n        if vis[i] == False:\n            has_after = max(dfs2(i), has_after)\n            if i in f:\n                has_after = i\n    if root in f:\n        has_after = root\n    if has_after != -1:\n        pos[root] = has_after\n    return has_after\n\ndef dfs3(root, b, repp):\n    has_above = b\n    has_rep = repp\n    if pos[root] != -1:\n        has_above = root\n        has_rep = pos[root]\n    abv[root] = has_above\n    rep[root] = has_rep\n    vis[root] = True\n    for i in d[root]:\n        if vis[i] == False:\n            dfs3(i, has_above, has_rep)\ntc = 1\ntc = int(input())\nfor _ in range(tc):\n    (n, k, a) = map(int, input().split())\n    a -= 1\n    f = list(map(int, input().split()))\n    for i in range(k):\n        f[i] -= 1\n    f = set(f)\n    d = dd(lambda : [])\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        d[u].append(v)\n        d[v].append(u)\n    vis = [False for i in range(n)]\n    dis = [-1 for i in range(n)]\n    dfs(a, 0)\n    vis = [False for i in range(n)]\n    pos = [-1 for i in range(n)]\n    pos[a] = dfs2(a)\n    vis = [False for i in range(n)]\n    abv = [-1 for i in range(n)]\n    rep = [-1 for i in range(n)]\n    dfs3(a, -1, -1)\n    a1 = []\n    a2 = []\n    for i in range(n):\n        if pos[i] != -1:\n            a1.append(dis[i])\n            a2.append(pos[i] + 1)\n        elif abv[i] != -1:\n            ds1 = dis[abv[i]]\n            ds2 = dis[i] - dis[abv[i]]\n            a1.append(ds1 - ds2)\n            a2.append(rep[i] + 1)\n    print(*a1)\n    print(*a2)", "import collections\nimport math\nt = int(input())\nfor i in range(t):\n    (n, k, a) = [int(x) for x in input().split()]\n    lis_k = set([int(x) for x in input().split()])\n    graph = collections.defaultdict(list)\n    graph_2 = collections.defaultdict(list)\n    for i1 in range(n - 1):\n        (node1, node2) = [int(x) for x in input().split()]\n        graph[node1].append(node2)\n        graph[node2].append(node1)\n        graph_2[node1].append(node2)\n        graph_2[node2].append(node1)\n    if n == 1:\n        print(0)\n        print(1)\n        continue\n    lis_temp = [[a, -1, False, -1]]\n    lis_k_new = dict()\n    while lis_temp:\n        (node, parent, below, special) = lis_temp[-1]\n        if node not in graph_2 or not graph_2[node]:\n            lis_temp.pop()\n            if node == a:\n                if below:\n                    lis_k_new[a] = special\n                continue\n            if below:\n                lis_k_new[node] = special\n                lis_temp[-1][2] = True\n                lis_temp[-1][3] = special\n            if node in lis_k:\n                lis_temp[-1][2] = True\n                lis_temp[-1][3] = node\n            continue\n        node_child = graph_2[node].pop()\n        if node_child == parent:\n            if not graph_2[node]:\n                lis_temp.pop()\n                if node == a:\n                    if below:\n                        lis_k_new[a] = special\n                    continue\n                if below:\n                    lis_k_new[node] = special\n                    lis_temp[-1][2] = True\n                    lis_temp[-1][3] = special\n                if node in lis_k:\n                    lis_temp[-1][2] = True\n                    lis_temp[-1][3] = node\n                continue\n            node_child = graph_2[node].pop()\n        lis_temp.append([node_child, node, False, -1])\n    parent_dict = dict()\n    avail_dict = dict()\n    special_node_dict = dict()\n    special_node_prev = dict()\n    last_k_prev = dict()\n    min_value = [math.inf for x in range(n)]\n    lis = [[a, -1, 0, 0, -1]]\n    while lis:\n        (node, parent, depth, last_k, special_node) = lis.pop()\n        if node not in parent_dict:\n            parent_dict[node] = parent\n            avail_dict[node] = False\n            if node in lis_k_new:\n                last_k = depth\n                avail_dict[node] = True\n                special_node = lis_k_new[node]\n            if node in lis_k:\n                last_k = depth\n                avail_dict[node] = True\n                special_node = node\n            min_value[node - 1] = last_k - (depth - last_k)\n            special_node_dict[node] = special_node\n            special_node_prev[node] = special_node\n            last_k_prev[node] = last_k\n        if not graph[node]:\n            if avail_dict[node]:\n                min_value[node - 1] = depth\n            if node != a:\n                parent_node = parent_dict[node]\n                lis.append([parent_node, parent_dict[parent_node], depth - 1, last_k_prev[parent_node], special_node_prev[parent_node]])\n                if avail_dict[node]:\n                    avail_dict[parent_node] = True\n                    special_node_dict[parent_node] = special_node_dict[node]\n            continue\n        node_child = graph[node].pop()\n        if node_child != parent:\n            lis.append([node_child, node, depth + 1, last_k, special_node])\n        else:\n            if not graph[node]:\n                if avail_dict[node]:\n                    min_value[node - 1] = depth\n                if node != a:\n                    parent_node = parent_dict[node]\n                    lis.append([parent_node, parent_dict[parent_node], depth - 1, last_k_prev[parent_node], special_node_prev[parent_node]])\n                    if avail_dict[node]:\n                        avail_dict[parent_node] = True\n                        special_node_dict[parent_node] = special_node_dict[node]\n                continue\n            node_child = graph[node].pop()\n            lis.append([node_child, node, depth + 1, last_k, special_node])\n    print(*min_value)\n    list_k = list(lis_k)\n    for i1 in special_node_dict:\n        if special_node_dict[i1] == -1:\n            special_node_dict[i1] = list_k[0]\n    print(*[special_node_dict[x] for x in range(1, n + 1)])", "T = int(input())\nfor _ in range(T):\n    (n, k, a) = [int(x) for x in input().split()]\n    special = [int(x) for x in input().split()]\n    graph = {i + 1: [] for i in range(n)}\n    for i in range(n - 1):\n        (u, v) = [int(x) for x in input().split()]\n        graph[u].append(v)\n        graph[v].append(u)\n    adist = {i + 1: 10 ** 6 for i in range(n)}\n    parent = {i + 1: 0 for i in range(n)}\n    queue = [a]\n    visited = {a}\n    adist[a] = 0\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if v not in visited:\n                queue.append(v)\n                visited.add(v)\n                adist[v] = min(adist[v], adist[u] + 1)\n                parent[v] = u\n    good = {a: special[0]}\n    for u in special:\n        v = u\n        while v not in good:\n            good[v] = u\n            v = parent[v]\n    gdist = {i + 1: 10 ** 6 for i in range(n)}\n    snode = {i + 1: special[0] for i in range(n)}\n    queue = [a]\n    visited = {a}\n    gdist[a] = 0\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if v not in visited:\n                queue.append(v)\n                visited.add(v)\n                if v in good:\n                    gdist[v] = 0\n                    snode[v] = good[v]\n                else:\n                    gdist[v] = min(gdist[v], gdist[u] + 1)\n                    snode[v] = snode[parent[v]]\n    fdist = [adist[i + 1] - 2 * gdist[i + 1] for i in range(n)]\n    fnode = [snode[i + 1] for i in range(n)]\n    print(*fdist)\n    print(*fnode)"]