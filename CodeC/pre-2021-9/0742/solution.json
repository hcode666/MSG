["for _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    rem = 0\n    for i in range(n - 1):\n        a = arr[i]\n        d = a & rem\n        (a, rem) = (a ^ d, rem ^ d)\n        b = bin(a).count('1')\n        if b <= x:\n            x -= b\n            rem ^= a\n            a = 0\n        elif x > 0:\n            d = 0\n            for j in range(31, -1, -1):\n                if a & 1 << j != 0:\n                    d ^= 1 << j\n                    x -= 1\n                    if x == 0:\n                        break\n            (a, rem) = (a ^ d, rem ^ d)\n        arr[i] = a\n    arr[-1] ^= rem\n    if x == 1 or (n == 2 and x % 2 == 1):\n        arr[-2] = 1\n        arr[-1] ^= 1\n    print(*arr)", "for _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    rem = 0\n    for i in range(n - 1):\n        a = arr[i]\n        d = a & rem\n        (a, rem) = (a ^ d, rem ^ d)\n        b = bin(a).count('1')\n        if b <= x:\n            x -= b\n            rem ^= a\n            a = 0\n        elif x > 0:\n            d = 0\n            for j in range(31, -1, -1):\n                if a & 1 << j != 0:\n                    d ^= 1 << j\n                    x -= 1\n                    if x == 0:\n                        break\n            (a, rem) = (a ^ d, rem ^ d)\n        arr[i] = a\n    arr[-1] ^= rem\n    if x == 1 or (n == 2 and x % 2 == 1):\n        arr[-2] = 1\n        arr[-1] ^= 1\n    print(*arr)", "for _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    rem = 0\n    for i in range(n - 1):\n        a = arr[i]\n        d = a & rem\n        (a, rem) = (a ^ d, rem ^ d)\n        b = bin(a).count('1')\n        if b <= x:\n            x -= b\n            rem ^= a\n            a = 0\n        elif x > 0:\n            d = 0\n            for j in range(31, -1, -1):\n                if a & 1 << j != 0:\n                    d ^= 1 << j\n                    x -= 1\n                    if x == 0:\n                        break\n            (a, rem) = (a ^ d, rem ^ d)\n        arr[i] = a\n    arr[-1] ^= rem\n    if x == 1 or (n == 2 and x % 2 == 1):\n        arr[-2] = 1\n        arr[-1] ^= 1\n    print(*arr)", "for _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    rem = 0\n    for i in range(n - 1):\n        a = arr[i]\n        d = a & rem\n        (a, rem) = (a ^ d, rem ^ d)\n        b = bin(a).count('1')\n        if b <= x:\n            x -= b\n            rem ^= a\n            a = 0\n        elif x > 0:\n            d = 0\n            for j in range(31, -1, -1):\n                if a & 1 << j != 0:\n                    d ^= 1 << j\n                    x -= 1\n                    if x == 0:\n                        break\n            (a, rem) = (a ^ d, rem ^ d)\n        arr[i] = a\n    arr[-1] ^= rem\n    if x == 1 or (n == 2 and x % 2 == 1):\n        arr[-2] = 1\n        arr[-1] ^= 1\n    print(*arr)", "import math\ntest_case = int(input())\n\ndef findmsp(i):\n    n = 1 << int(math.log2(i))\n    return n\nfor _ in range(test_case):\n    line = input().split(' ')\n    N = int(line[0])\n    K = int(line[1])\n    arr = []\n    line = input().split(' ')\n    for i in range(0, N):\n        arr.append(int(line[i]))\n    if N > 2 and N <= K:\n        for ind in range(1, N):\n            arr[ind] ^= arr[ind - 1]\n            arr[ind - 1] = 0\n    else:\n        i = 0\n        while True:\n            if K == 0:\n                break\n            while i < N - 1 and arr[i] == 0:\n                i = i + 1\n            if i == N - 1:\n                break\n            msp = int(findmsp(arr[i]))\n            arr[i] = arr[i] ^ msp\n            j = i + 1\n            for j in range(i + 1, N):\n                if j == N - 1:\n                    arr[j] = arr[j] ^ msp\n                    break\n                elif arr[j] ^ msp < arr[j]:\n                    arr[j] = arr[j] ^ msp\n                    break\n            K = K - 1\n        if K == 1 or (K % 2 != 0 and N == 2):\n            arr[N - 1] = arr[N - 1] ^ 1\n            arr[N - 2] = arr[N - 2] ^ 1\n    print(*arr)", "import math\ntest_case = int(input())\n\ndef findmsp(i):\n    n = 1 << int(math.log2(i))\n    return n\nfor _ in range(test_case):\n    line = input().split(' ')\n    N = int(line[0])\n    K = int(line[1])\n    arr = []\n    line = input().split(' ')\n    for i in range(0, N):\n        arr.append(int(line[i]))\n    if N > 2 and N <= K:\n        for ind in range(1, N):\n            arr[ind] ^= arr[ind - 1]\n            arr[ind - 1] = 0\n    else:\n        i = 0\n        while True:\n            if K == 0:\n                break\n            while i < N - 1 and arr[i] == 0:\n                i = i + 1\n            if i == N - 1:\n                break\n            msp = int(findmsp(arr[i]))\n            arr[i] = arr[i] ^ msp\n            j = i + 1\n            for j in range(i + 1, N):\n                if j == N - 1:\n                    arr[j] = arr[j] ^ msp\n                    break\n                elif arr[j] ^ msp < arr[j]:\n                    arr[j] = arr[j] ^ msp\n                    break\n            K = K - 1\n        if K == 1 or (K % 2 != 0 and N == 2):\n            arr[N - 1] = arr[N - 1] ^ 1\n            arr[N - 2] = arr[N - 2] ^ 1\n    print(*arr)", "import math\nimport os, sys\nfrom io import BytesIO, IOBase\n\ndef ntob(n):\n    arr = []\n    while n > 0:\n        p = int(math.log2(n))\n        arr.append(p)\n        n ^= 2 ** p\n    return arr\n\ndef bton(n):\n    num = 0\n    for i in n:\n        num += 2 ** i\n    return num\n\ndef main():\n    for _ in range(int(input())):\n        (n, k) = map(int, input().split())\n        arr = list(map(int, input().split()))\n        i = 0\n        li = []\n        j = 1\n        rem = []\n        if len(arr) > 2:\n            if k // n > 3:\n                while j < n:\n                    m = arr[i]\n                    arr[i] ^= m\n                    arr[j] ^= m\n                    i += 1\n                    j += 1\n            else:\n                while i < n - 1 and k > 0:\n                    if arr[i] != 0:\n                        p = int(math.log2(arr[i]))\n                        suc = True\n                        if p in li:\n                            li.remove(p)\n                            k -= 1\n                        elif len(li) < k:\n                            li.append(p)\n                        else:\n                            suc = False\n                        if suc:\n                            arr[i] ^= 2 ** p\n                        else:\n                            break\n                    else:\n                        i += 1\n                for i in range(len(arr)):\n                    if arr[i] != 0:\n                        rem += [i]\n                if len(rem) > 0:\n                    for i in rem:\n                        if len(li) > 0:\n                            bi = ntob(arr[i])\n                            num = 0\n                            while num < len(bi):\n                                if bi[num] in li:\n                                    li.remove(bi[num])\n                                    bi.remove(bi[num])\n                                else:\n                                    num += 1\n                            arr[i] = bton(bi)\n                        else:\n                            break\n                elif len(li) > 0:\n                    if arr[n - 1] > 0:\n                        for c in li:\n                            arr[n - 1] ^= 2 ** c\n        else:\n            count = 0\n            num = k\n            while k > 0:\n                if arr[i] != 0:\n                    p = int(math.log2(arr[i]))\n                    arr[i] ^= 2 ** p\n                    arr[j] ^= 2 ** p\n                    count += 1\n                elif count % 2 == 0:\n                    if num % 2 == 0:\n                        break\n                    else:\n                        arr[i] ^= 1\n                        arr[j] ^= 1\n                        break\n                elif num % 2 != 0:\n                    break\n                else:\n                    arr[i] ^= 1\n                    arr[j] ^= 1\n                    break\n                k -= 1\n        print(*arr)\nmain()", "for testCase in range(int(input())):\n    R = 0\n    (N, X) = map(int, input().split())\n    array = list(map(int, input().split()))\n    for i in range(N - 1):\n        binary = bin(array[i])\n        if X >= binary.count('1'):\n            X = X - binary.count('1')\n            for j in range(i + 1, N):\n                c = array[i] & array[j]\n                array[i] = array[i] - c\n                array[j] = array[j] - c\n                if array[i] == 0:\n                    break\n            if array[i] != 0:\n                if N - 1 - i > 1:\n                    R = 1\n                array[N - 1] = array[i] ^ array[N - 1]\n                array[i] = 0\n        elif X < binary.count('1') and X > 0:\n            z = binary[2:]\n            m = ''\n            for j in range(len(z)):\n                if X > 0:\n                    if z[j] == '1':\n                        X -= 1\n                        m = m + '1'\n                    else:\n                        m = m + z[j]\n                else:\n                    m = m + '0'\n            array[i] = array[i] - int(m, 2)\n            m = int(m, 2)\n            for j in range(i + 1, N):\n                c = m & array[j]\n                m = m - c\n                array[j] = array[j] - c\n            array[N - 1] = m ^ array[N - 1]\n        else:\n            break\n    if X % 2 != 0 and R == 0:\n        array[N - 2] = array[N - 2] ^ 1\n        array[N - 1] = array[N - 1] ^ 1\n    for i in range(N):\n        print(array[i], end=' ')\n    print()", "import math\n\ndef getBestPowNumber(a):\n    n = 1 << int(math.log2(a))\n    return n\nt = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    if n > 2 and n <= x:\n        for ind in range(1, n):\n            arr[ind] ^= arr[ind - 1]\n            arr[ind - 1] = 0\n    else:\n        i = 0\n        while True:\n            if x == 0:\n                break\n            while i < n - 1 and arr[i] == 0:\n                i += 1\n            if i == n - 1:\n                break\n            best_power_num = getBestPowNumber(arr[i])\n            for j in range(i + 1, n):\n                if arr[j] ^ best_power_num < arr[j]:\n                    break\n            arr[i] ^= best_power_num\n            arr[j] ^= best_power_num\n            x -= 1\n        if x == 1 or (n == 2 and x % 2 != 0):\n            arr[n - 1] ^= 1\n            arr[n - 2] ^= 1\n    print(*arr)", "def getBits(n):\n    return [i for (i, bit) in enumerate(bin(n)[::-1]) if bit is '1'][::-1]\n\ndef solveUnpaired(unused, paired, i):\n    paired = set([x for (x, xi) in enumerate(paired) if xi])\n    pow2 = [1 << x for x in range(30)]\n    A[:i + 1] = [0] * (i + 1)\n    if unused:\n        A[i] = sum((pow2[bit] for bit in unused))\n        i -= 1\n    for j in range(i + 1, N - 1):\n        for bit in getBits(A[j]):\n            if bit in paired:\n                A[j] -= pow2[bit]\n                paired.remove(bit)\n        if not paired:\n            break\n    else:\n        for bit in paired:\n            A[N - 1] ^= pow2[bit]\n\ndef solve(N, X):\n    (unused, paired) = ([], [False] * 30)\n    for i in range(N - 1):\n        for bit in getBits(A[i]):\n            if X is 0:\n                unused.append(bit)\n                continue\n            paired[bit] = not paired[bit]\n            if paired[bit]:\n                X -= 1\n        if X is 0:\n            solveUnpaired(unused, paired, i)\n            break\n    else:\n        solveUnpaired(unused, paired, N - 2)\n    if X % 2 and N == 2:\n        return [A[0] ^ 1, A[1] ^ 1]\n    return A\nfor _ in range(int(input())):\n    [N, X] = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n    print(*solve(N, X))", "for _ in range(int(input())):\n    (n, x) = [int(i) for i in input().split()]\n    s = [list(bin(int(i))[2:]) for i in input().split()]\n    pad = ['0' for f in range(32 - len(s[-1]))]\n    s[-1] = pad + s[-1]\n    if x > 10 ** 5 and n > 2:\n        arr = [int(''.join(el), 2) for el in s]\n        k = 0\n        for l in range(n):\n            k = k ^ arr[l]\n        ans = [0] * n\n        ans[-1] = k\n        print(*ans)\n    else:\n        for i in range(n - 1):\n            l = len(s[i])\n            while set(s[i]) != {'0'}:\n                if x == 0:\n                    break\n                ind = s[i].index('1')\n                ind_back = l - ind\n                s[i][ind] = '0'\n                j = i + 1\n                flag = True\n                while j < n:\n                    if len(s[j]) >= ind_back and s[j][-ind_back] == '1':\n                        s[j][-ind_back] = '0'\n                        flag = False\n                        break\n                    j += 1\n                if flag == True:\n                    s[-1][-ind_back] = '1'\n                x -= 1\n        if x > 0 and x % 2 == 1 and (n == 2):\n            s[-2][-1] = '1'\n            if s[-1][-1] == '0':\n                s[-1][-1] = '1'\n            else:\n                s[-1][-1] = '0'\n        print(*[int(''.join(el), 2) for el in s])", "import math\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    s = list(map(int, input().split()))\n    if n > 10 ** 4 and x >= n:\n        k = 0\n        for l in range(n):\n            k = k ^ s[l]\n        s = [0] * n\n        s[n - 1] = k\n    else:\n        for i in range(n - 1):\n            while s[i] != 0:\n                if x == 0:\n                    break\n                ind = 2 ** int(math.log2(s[i]))\n                s[i] ^= ind\n                j = i + 1\n                flag = True\n                while j < n:\n                    if s[j] ^ ind < s[j]:\n                        s[j] ^= ind\n                        flag = False\n                        break\n                    j += 1\n                if flag == True:\n                    s[-1] ^= ind\n                x -= 1\n        if x > 0 and x % 2 == 1 and (n == 2):\n            s[-2] ^= 1\n            s[-1] ^= 1\n    print(' '.join(map(str, s)))", "import math\nt = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    i = 0\n    if n > 2:\n        if n <= x:\n            for ind in range(1, n):\n                arr[ind] ^= arr[ind - 1]\n                arr[ind - 1] = 0\n        else:\n            while x > 0:\n                p = int(math.log2(arr[i]) // math.log2(2))\n                for j in range(i + 1, n):\n                    if arr[j] ^ 1 << p < arr[j]:\n                        break\n                arr[i] ^= 1 << p\n                arr[j] ^= 1 << p\n                if arr[i] == 0:\n                    while arr[i] == 0:\n                        i += 1\n                x -= 1\n    else:\n        while x > 0:\n            p = int(math.log2(arr[i]) // math.log2(2))\n            arr[0] ^= 1 << p\n            arr[1] ^= 1 << p\n            x -= 1\n            if arr[0] == 0:\n                break\n        if x % 2 != 0:\n            arr[0] ^= 1\n            arr[1] ^= 1\n    print(*arr)", "import math\nt = int(input())\nfor _ in range(t):\n    (n, x) = input().split()\n    n = int(n)\n    x = int(x)\n    a = list(map(int, input().split()))\n\n    def setBitNumber(n):\n        k = int(math.log(n, 2))\n        return 2 ** k\n    for i in range(0, n):\n        if x == 0:\n            break\n        if a[i] == 0:\n            continue\n        if bin(a[i]).count('1') <= x:\n            for j in range(i + 1, n):\n                if x == 0:\n                    break\n                if a[i] == 0:\n                    break\n                if j == n - 1:\n                    num = a[i]\n                    coun = bin(num).count('1')\n                    a[i] = 0\n                    a[j] = a[j] ^ num\n                    x = x - coun\n                    break\n                num = a[i] & a[j]\n                coun = bin(num).count('1')\n                a[i] = a[i] - num\n                a[j] = a[j] - num\n                x = x - coun\n        elif bin(a[i]).count('1') > x:\n            while x != 0:\n                reduceby = setBitNumber(a[i])\n                a[i] = a[i] - reduceby\n                x -= 1\n                for j in range(i + 1, n):\n                    if j == n - 1:\n                        a[j] = a[j] ^ reduceby\n                        break\n                    num = reduceby & a[j]\n                    if num != 0:\n                        a[j] = a[j] ^ reduceby\n                        break\n    if x == 1:\n        a[n - 1] = a[n - 1] ^ 1\n        a[n - 2] = a[n - 2] ^ 1\n    if n == 2 and x % 2 != 0:\n        a[n - 1] = a[n - 1] ^ 1\n        a[n - 2] = a[n - 2] ^ 1\n    print(*a)", "def getBits(a):\n    return [i for (i, ai) in enumerate(bin(a)[2:][::-1]) if ai == '1'][::-1]\n\ndef solve_unpaired(i):\n    for j in range(i, N - 1):\n        if not unpaired_bits:\n            break\n        for bit in getBits(A[j]):\n            if bit in unpaired_bits:\n                A[j] -= 2 ** bit\n                unpaired_bits.remove(bit)\n                if not unpaired_bits:\n                    break\n    else:\n        for bit in unpaired_bits:\n            A[N - 1] ^= 1 << bit\n\ndef solve(N, X):\n    (solved_unused, unused) = (False, [])\n    for i in range(N - 1):\n        if solved_unused:\n            ans = [0] * (i - 1)\n            A[i - 1] = 0\n            for bit in unused:\n                A[i - 1] += 2 ** bit\n            solve_unpaired(i - 1)\n            ans += A[i - 1:]\n            break\n        elif X == 0:\n            ans = [0] * i\n            solve_unpaired(i)\n            ans += A[i:]\n            break\n        for bit in getBits(A[i]):\n            if X:\n                if bit in unpaired_bits:\n                    unpaired_bits.remove(bit)\n                else:\n                    X -= 1\n                    unpaired_bits.add(bit)\n            else:\n                unused.append(bit)\n                solved_unused = True\n    else:\n        if solved_unused:\n            ans = [0] * (N - 2)\n            A[N - 2] = 0\n            for bit in unused:\n                A[N - 2] += 2 ** bit\n            solve_unpaired(N - 2)\n            ans += A[N - 2:]\n        else:\n            for bit in unpaired_bits:\n                A[N - 1] ^= 2 ** bit\n            ans = [0] * (N - 1) + [A[N - 1]]\n    if X % 2 and N == 2:\n        ans = [ans[0] ^ 1, ans[1] ^ 1]\n    return ans\nfor _ in range(int(input())):\n    unpaired_bits = set()\n    [N, X] = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n    print(*solve(N, X))", "t = int(input())\nwhile t:\n    r = 0\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    for i in range(n - 1):\n        if x >= bin(a[i]).count('1'):\n            x = x - bin(a[i]).count('1')\n            for j in range(i + 1, n):\n                c = a[i] & a[j]\n                a[i] = a[i] - c\n                a[j] = a[j] - c\n                if a[i] == 0:\n                    break\n            if a[i] != 0:\n                if n - 1 - i > 1:\n                    r = 1\n                a[n - 1] = a[i] ^ a[n - 1]\n                a[i] = 0\n        elif x < bin(a[i]).count('1') and x > 0:\n            z = bin(a[i])[2:]\n            m = ''\n            for j in range(len(z)):\n                if x > 0:\n                    if z[j] == '1':\n                        x -= 1\n                        m = m + '1'\n                    else:\n                        m = m + z[j]\n                else:\n                    m = m + '0'\n            a[i] = a[i] - int(m, 2)\n            m = int(m, 2)\n            for j in range(i + 1, n):\n                c = m & a[j]\n                m = m - c\n                a[j] = a[j] - c\n            a[n - 1] = m ^ a[n - 1]\n        else:\n            break\n    if x % 2 != 0 and r == 0:\n        a[n - 2] = a[n - 2] ^ 1\n        a[n - 1] = a[n - 1] ^ 1\n    for i in range(n):\n        print(a[i], end=' ')\n    print()\n    t -= 1", "t = int(input())\nwhile t:\n    r = 0\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    for i in range(n - 1):\n        if x >= bin(a[i]).count('1'):\n            x = x - bin(a[i]).count('1')\n            for j in range(i + 1, n):\n                c = a[i] & a[j]\n                a[i] = a[i] - c\n                a[j] = a[j] - c\n                if a[i] == 0:\n                    break\n            if a[i] != 0:\n                if n - 1 - i > 1:\n                    r = 1\n                a[n - 1] = a[i] ^ a[n - 1]\n                a[i] = 0\n        elif x < bin(a[i]).count('1') and x > 0:\n            z = bin(a[i])[2:]\n            m = ''\n            for j in range(len(z)):\n                if x > 0:\n                    if z[j] == '1':\n                        x -= 1\n                        m = m + '1'\n                    else:\n                        m = m + z[j]\n                else:\n                    m = m + '0'\n            a[i] = a[i] - int(m, 2)\n            m = int(m, 2)\n            for j in range(i + 1, n):\n                c = m & a[j]\n                m = m - c\n                a[j] = a[j] - c\n            a[n - 1] = m ^ a[n - 1]\n        else:\n            break\n    if x % 2 != 0 and r == 0:\n        a[n - 2] = a[n - 2] ^ 1\n        a[n - 1] = a[n - 1] ^ 1\n    for i in range(n):\n        print(a[i], end=' ')\n    print()\n    t -= 1", "import math\n\ndef ntob(n):\n    arr = []\n    while n > 0:\n        p = int(math.log2(n))\n        arr.append(p)\n        n ^= 2 ** p\n    return arr\n\ndef bton(n):\n    num = 0\n    for i in n:\n        num += 2 ** i\n    return num\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    i = 0\n    li = []\n    j = 1\n    rem = []\n    if len(arr) > 2:\n        if k // n > 3:\n            while j < n:\n                m = arr[i]\n                arr[i] ^= m\n                arr[j] ^= m\n                i += 1\n                j += 1\n        else:\n            while i < n - 1 and k > 0:\n                if arr[i] != 0:\n                    p = int(math.log2(arr[i]))\n                    suc = True\n                    if p in li:\n                        li.remove(p)\n                        k -= 1\n                    elif len(li) < k:\n                        li.append(p)\n                    else:\n                        suc = False\n                    if suc:\n                        arr[i] ^= 2 ** p\n                    else:\n                        break\n                else:\n                    i += 1\n            for i in range(len(arr)):\n                if arr[i] != 0:\n                    rem += [i]\n            if len(rem) > 0:\n                for i in rem:\n                    if len(li) > 0:\n                        bi = ntob(arr[i])\n                        num = 0\n                        while num < len(bi):\n                            if bi[num] in li:\n                                li.remove(bi[num])\n                                bi.remove(bi[num])\n                            else:\n                                num += 1\n                        arr[i] = bton(bi)\n                    else:\n                        break\n            elif len(li) > 0:\n                if arr[n - 1] > 0:\n                    for c in li:\n                        arr[n - 1] ^= 2 ** c\n    else:\n        count = 0\n        num = k\n        while k > 0:\n            if arr[i] != 0:\n                p = int(math.log2(arr[i]))\n                arr[i] ^= 2 ** p\n                arr[j] ^= 2 ** p\n                count += 1\n            elif count % 2 == 0:\n                if num % 2 == 0:\n                    break\n                else:\n                    arr[i] ^= 1\n                    arr[j] ^= 1\n                    break\n            elif num % 2 != 0:\n                break\n            else:\n                arr[i] ^= 1\n                arr[j] ^= 1\n                break\n            k -= 1\n    print(*arr)", "import math\n\ndef iterate(seq, first_nonzero, x, BONUS_FLIP, bit_counts):\n    length = len(seq)\n    start = None\n    for i in range(first_nonzero, length):\n        if seq[i] != 0:\n            start = i\n            first_nonzero = start\n            break\n    if start == None or start == length - 1:\n        if BONUS_FLIP or x % 2 == 0:\n            return (0, 0, BONUS_FLIP)\n        seq[-1] ^= 1\n        seq[-2] ^= 1\n        return (0, 0, BONUS_FLIP)\n    else:\n        p = int(math.log(seq[start], 2))\n        n = 1 << p\n        seq[start] ^= n\n        swapped = False\n        for i in range(start + 1, length):\n            if seq[i] >> p & 1:\n                seq[i] ^= n\n                swapped = True\n                if not bit_counts[p]:\n                    BONUS_FLIP = True\n                bit_counts[p] = 0\n                break\n        if not swapped:\n            seq[-1] ^= n\n        return (first_nonzero, x - 1, BONUS_FLIP)\n\ndef get_bits_counts(seq, upper=32):\n    bits = [1] * upper\n    for bit in range(upper):\n        for (i, e) in enumerate(seq):\n            if not e >> bit & 1:\n                bits[bit] = 0\n                break\n    return bits\n\ndef xor(seq):\n    start = seq[0]\n    seq[0] = 0\n    for i in range(1, len(seq)):\n        start ^= seq[i]\n        seq[i] = 0\n    seq[-1] = start\n\ndef solve(seq, X):\n    bit_counts = get_bits_counts(seq)\n    first_nonzero = 0\n    x = X\n    BONUS_FLIP = False\n    if N > 100 and X > 1000 * len(seq):\n        xor(seq)\n        return ' '.join((str(s) for s in seq))\n    else:\n        while x > 0:\n            (first_nonzero, x, BONUS_FLIP) = iterate(seq, first_nonzero, x, BONUS_FLIP, bit_counts)\n        return ' '.join((str(s) for s in seq))\nT = int(input())\nfor i in range(T):\n    (N, X) = map(int, input().split())\n    seq = list(map(int, input().split()))\n    print(solve(seq, X))", "N_bits = 30\nt = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    less_x = False\n    last = arr[n - 1]\n    last_0 = 0\n    n0 = bin(arr[0]).count('1')\n    for i in range(n - 1):\n        x_ = x - bin(arr[i]).count('1')\n        if x == 0:\n            break\n        if x_ < 0:\n            less_x = True\n            break\n        n1 = bin(arr[i + 1]).count('1')\n        arr[i + 1] = arr[i] ^ arr[i + 1]\n        n_temp = bin(arr[i + 1]).count('1')\n        delta_x = (n0 + n1 - n_temp) // 2\n        x -= delta_x\n        last_0 = arr[i]\n        arr[i] = 0\n        n0 = n_temp\n    if less_x:\n        pivot = i\n        pivot_bits = [arr[pivot].bit_length() + 1 - idx for (idx, v) in enumerate(bin(arr[pivot])) if v == '1']\n        last_0_bits = set([last_0.bit_length() + 1 - idx for (idx, v) in enumerate(bin(last_0)) if v == '1'])\n        carry_forward_bits = [idx for idx in pivot_bits if idx in last_0_bits]\n        original_bits = [idx for idx in pivot_bits if idx not in last_0_bits]\n        remaining_x = x - len(carry_forward_bits)\n        carry_forward_bits.extend(original_bits[:remaining_x])\n        hero = sum([1 << bit for bit in carry_forward_bits])\n        for j in range(pivot + 1, n):\n            arr[j - 1] ^= hero\n            temp = arr[j] ^ hero\n            hero = hero ^ arr[j] & hero\n            arr[j] = temp\n    elif x_ > 0 and x_ % 2 == 1:\n        if last_0 & last == 0 or n == 2:\n            arr[n - 1] ^= 1\n            arr[n - 2] ^= 1\n    print(*arr)", "import math\nt = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    a = list((int(i) for i in input().split()[:n]))\n    if n == 2:\n        i = 0\n        j = 1\n        while x > 0:\n            p = int(math.log2(a[i]))\n            l = 2 ** p\n            a[i] = a[i] ^ l\n            a[j] = a[j] ^ l\n            x = x - 1\n            if a[i] == 0:\n                if x % 2 == 0:\n                    break\n                else:\n                    a[i] = a[i] ^ 1\n                    a[j] = a[j] ^ 1\n                    break\n    elif x > 2 * 10 ** 5 * 31:\n        b = []\n        c = 0\n        for i in range(n):\n            if i == n - 1:\n                c = c ^ a[i]\n                b.append(c)\n            else:\n                c = c ^ a[i]\n                b.append(0)\n        a = b\n    else:\n        i = 0\n        while x > 0:\n            if a[i] == 0 and i < n - 2:\n                i += 1\n            p = int(math.log2(a[i]))\n            l = 2 ** p\n            a[i] = a[i] ^ l\n            for j in range(i + 1, n):\n                if j < n - 1 and a[j] ^ l > a[j]:\n                    continue\n                elif j < n - 1 and a[j] ^ l == 0 and (x >= 2):\n                    continue\n                else:\n                    a[j] = a[j] ^ l\n                    break\n            x = x - 1\n            if i == n - 2 and a[i] == 0 and (x > 0):\n                break\n    print(*a)", "from math import log2\nfrom sys import stdin\nfrom math import pow\n\ndef findMaxPowTwo(num):\n    return int(log2(num))\n\ndef operationInstance(arr, start):\n    iteration = start[0]\n    if arr[iteration] != 0:\n        arrLength = len(arr)\n        power = findMaxPowTwo(arr[iteration])\n        chunk = int(pow(2, power))\n        arr[iteration] ^= chunk\n        remove = -1\n        for i in range(iteration + 1, len(arr)):\n            if arr[i] ^ chunk < arr[i]:\n                remove = i\n                break\n        arr[remove] ^= chunk\n        if iteration == arrLength - 1 and arr[-2] == 0:\n            return -5\n    if arr[iteration] == 0:\n        start[0] += 1\n\ndef diffOperation(arr, X):\n    i = 0\n    while X:\n        if i == len(arr) - 1:\n            return -1 * X\n        if arr[i] == 0:\n            i += 1\n            continue\n        getX = bin(arr[i]).count('1')\n        if X < getX:\n            start = [i]\n            for i in range(X):\n                ret = operationInstance(arr, start)\n                if ret == -5:\n                    if len(arr) == 2:\n                        remaining = X\n                        if remaining % 2 != 0:\n                            arr[0] ^= 1\n                            arr[1] ^= 1\n                    break\n            break\n        j = i + 1\n        while getX:\n            AandB = arr[i] & arr[j]\n            weCouldRemove = bin(AandB).count('1')\n            if j == len(arr) - 1:\n                arr[j] ^= arr[i]\n                arr[i] = 0\n                X -= getX\n                getX -= getX\n                break\n            if weCouldRemove:\n                arr[i] = arr[i] ^ AandB\n                arr[j] = arr[j] ^ AandB\n                getX -= weCouldRemove\n                X -= weCouldRemove\n            j += 1\n        i += 1\n    return 1\n\ndef main():\n    T = int(stdin.readline())\n    for j in range(T):\n        (N, X) = map(int, stdin.readline().split())\n        arr = list(map(int, stdin.readline().split()))\n        ret = diffOperation(arr, X)\n        if ret < 0:\n            if len(arr) == 2:\n                remaining = -1 * ret\n                if remaining % 2 != 0:\n                    arr[0] ^= 1\n                    arr[1] ^= 1\n        print(' '.join(list(map(str, arr))) + '\\n')\nmain()", "def count(n):\n    return '{0:b}'.format(n).count('1')\n\ndef getTop(l, n):\n    L = '{0:b}'.format(l)\n    g = '0'\n    i = 0\n    while n > 0:\n        if L[i] == '1':\n            n -= 1\n        g += L[i]\n        i += 1\n    g += '0' * (len(L) - len(g) + 1)\n    return int(g, 2)\n\ndef ans(l, x):\n    cumm = 0\n    for i in range(len(l) - 1):\n        d = l[i] & cumm\n        l[i] = l[i] ^ d\n        cumm = cumm ^ d\n        if count(l[i]) <= x:\n            x -= count(l[i])\n            cumm = cumm ^ l[i]\n            l[i] = 0\n        else:\n            rem = getTop(l[i], x)\n            l[i] = l[i] ^ rem\n            cumm = cumm ^ rem\n            x = 0\n    i = len(l) - 1\n    l[i] = l[i] ^ cumm\n    if x % 2 == 1 and len(l) == 2 and (l[i] > 0):\n        l[i] = l[i] ^ 1\n        l[i - 1] = l[i - 1] ^ 1\n    return ' '.join(map(str, l))\ntest = int(input())\nwhile test > 0:\n    test -= 1\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(ans(a, x))", "def count(n):\n    return '{0:b}'.format(n).count('1')\n\ndef getTop(l, n):\n    L = '{0:b}'.format(l)\n    g = '0'\n    i = 0\n    while n > 0:\n        if L[i] == '1':\n            n -= 1\n        g += L[i]\n        i += 1\n    g += '0' * (len(L) - len(g) + 1)\n    return int(g, 2)\n\ndef getMin(l):\n    L = '{0:b}'.format(l)[::-1]\n    return L.index('1')\n\ndef ans(l, x):\n    cumm = 0\n    for i in range(len(l) - 1):\n        d = l[i] & cumm\n        l[i] = l[i] ^ d\n        cumm = cumm ^ d\n        if count(l[i]) <= x:\n            x -= count(l[i])\n            cumm = cumm ^ l[i]\n            l[i] = 0\n        else:\n            rem = getTop(l[i], x)\n            l[i] = l[i] ^ rem\n            cumm = cumm ^ rem\n            x = 0\n    i = len(l) - 1\n    l[i] = l[i] ^ cumm\n    if x % 2 == 1 and len(l) == 2 and (l[i] > 0):\n        l[i] = l[i] ^ 1\n        l[i - 1] = l[i - 1] ^ 1\n    return ' '.join(map(str, l))\ntest = int(input())\nwhile test > 0:\n    test -= 1\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(ans(a, x))", "import math\nt = int(input())\nfor i in range(t):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    xor = 0\n    for val in a:\n        xor = xor ^ val\n    if x > 15 * n and n != 2:\n        print('0 ' * (n - 1), xor, sep='')\n        continue\n    flag = False\n    for j in range(n - 1):\n        while a[j] != 0:\n            msb = a[j]\n            msb |= msb >> 1\n            msb |= msb >> 2\n            msb |= msb >> 4\n            msb |= msb >> 8\n            msb |= msb >> 16\n            msb = msb + 1\n            p2 = msb >> 1\n            for k in range(j + 1, n):\n                if p2 & a[k] != 0:\n                    a[k] -= p2\n                    a[j] -= p2\n                    x -= 1\n                    if x == 0:\n                        flag = True\n                    break\n            else:\n                a[j] -= p2\n                a[n - 1] += p2\n                x -= 1\n                if x == 0:\n                    flag = True\n            if flag:\n                break\n        if flag:\n            break\n    if flag:\n        for j in range(n):\n            print(a[j], end=' ')\n    elif x % 2 == 1 and n == 2:\n        print('1 ', xor ^ 1, sep='', end=' ')\n    else:\n        print('0 ' * (n - 1), xor, sep='', end=' ')\n    print()", "import math\n\ndef ntob(n):\n    arr = []\n    while n > 0:\n        p = int(math.log2(n))\n        arr.append(p)\n        n ^= 2 ** p\n    return arr\n\ndef bton(n):\n    num = 0\n    for i in n:\n        num += 2 ** i\n    return num\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    i = 0\n    li = []\n    j = 1\n    rem = []\n    if len(arr) > 2:\n        if k // n > 3:\n            while j < n:\n                m = arr[i]\n                arr[i] ^= m\n                arr[j] ^= m\n                i += 1\n                j += 1\n        else:\n            while i < n - 1 and k > 0:\n                if arr[i] != 0:\n                    p = int(math.log2(arr[i]))\n                    suc = True\n                    if p in li:\n                        li.remove(p)\n                        k -= 1\n                    elif len(li) < k:\n                        li.append(p)\n                    else:\n                        suc = False\n                    if suc:\n                        arr[i] ^= 2 ** p\n                    else:\n                        break\n                else:\n                    i += 1\n            for i in range(len(arr)):\n                if arr[i] != 0:\n                    rem += [i]\n            if len(rem) > 0:\n                for i in rem:\n                    if len(li) > 0:\n                        bi = ntob(arr[i])\n                        num = 0\n                        while num < len(bi):\n                            if bi[num] in li:\n                                li.remove(bi[num])\n                                bi.remove(bi[num])\n                            else:\n                                num += 1\n                        arr[i] = bton(bi)\n                    else:\n                        break\n            elif len(li) > 0:\n                if arr[n - 1] > 0:\n                    for c in li:\n                        arr[n - 1] ^= 2 ** c\n    else:\n        count = 0\n        num = k\n        while k > 0:\n            if arr[i] != 0:\n                p = int(math.log2(arr[i]))\n                arr[i] ^= 2 ** p\n                arr[j] ^= 2 ** p\n                count += 1\n            elif count % 2 == 0:\n                if num % 2 == 0:\n                    break\n                else:\n                    arr[i] ^= 1\n                    arr[j] ^= 1\n                    break\n            elif num % 2 != 0:\n                break\n            else:\n                arr[i] ^= 1\n                arr[j] ^= 1\n                break\n            k -= 1\n    print(*arr)", "import math\n\ndef ntob(n):\n    arr = []\n    while n > 0:\n        p = int(math.log2(n))\n        arr.append(p)\n        n ^= 2 ** p\n    return arr\n\ndef bton(n):\n    num = 0\n    for i in n:\n        num += 2 ** i\n    return num\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    i = 0\n    li = []\n    j = 1\n    rem = []\n    if len(arr) > 2:\n        if k // n > 3:\n            while j < n:\n                m = arr[i]\n                arr[i] ^= m\n                arr[j] ^= m\n                i += 1\n                j += 1\n        else:\n            while i < n - 1 and k > 0:\n                if arr[i] != 0:\n                    p = int(math.log2(arr[i]))\n                    suc = True\n                    if p in li:\n                        li.remove(p)\n                        k -= 1\n                    elif len(li) < k:\n                        li.append(p)\n                    else:\n                        suc = False\n                    if suc:\n                        arr[i] ^= 2 ** p\n                    else:\n                        break\n                else:\n                    i += 1\n            for i in range(len(arr)):\n                if arr[i] != 0:\n                    rem += [i]\n            if len(rem) > 0:\n                for i in rem:\n                    if len(li) > 0:\n                        bi = ntob(arr[i])\n                        num = 0\n                        while num < len(bi):\n                            if bi[num] in li:\n                                li.remove(bi[num])\n                                bi.remove(bi[num])\n                            else:\n                                num += 1\n                        arr[i] = bton(bi)\n                    else:\n                        break\n            elif len(li) > 0:\n                if arr[n - 1] > 0:\n                    for c in li:\n                        arr[n - 1] ^= 2 ** c\n    else:\n        count = 0\n        num = k\n        while k > 0:\n            if arr[i] != 0:\n                p = int(math.log2(arr[i]))\n                arr[i] ^= 2 ** p\n                arr[j] ^= 2 ** p\n                count += 1\n            elif count % 2 == 0:\n                if num % 2 == 0:\n                    break\n                else:\n                    arr[i] ^= 1\n                    arr[j] ^= 1\n                    break\n            elif num % 2 != 0:\n                break\n            else:\n                arr[i] ^= 1\n                arr[j] ^= 1\n                break\n            k -= 1\n    print(*arr)", "for _ in range(int(input())):\n    (N, X) = map(int, input().split())\n    array = list(map(int, input().split()))\n    if N != len(array):\n        raise Exception('Wrong data.')\n    maxnum = max(array)\n    digits = 1\n    num = 1\n    while num < maxnum:\n        num <<= 1\n        digits += 1\n    if num != maxnum:\n        digits -= 1\n    maxmask = 1 << digits - 1\n    extra = 0\n    N -= 1\n    for index in range(N):\n        if X == 0 and extra == 0:\n            break\n        elif array[index] != 0:\n            freeremove = extra & array[index]\n            extra ^= freeremove\n            array[index] ^= freeremove\n            if X >= digits:\n                num = array[index]\n                array[index] = 0\n                extra ^= num\n                count = 0\n                while num != 0:\n                    count += num & 1\n                    num >>= 1\n                X -= count\n            else:\n                mask = maxmask\n                while array[index] != 0 and X != 0:\n                    if mask & array[index] != 0:\n                        array[index] ^= mask\n                        extra ^= mask\n                        X -= 1\n                    mask >>= 1\n    array[N] ^= extra\n    if X == 1 or (N == 1 and X % 2 == 1):\n        array[-1] ^= 1\n        array[-2] ^= 1\n    print(*array)", "from math import log\nfor _ in range(int(input())):\n    (N, X) = [int(x) for x in input().split(' ')]\n    A = [int(value) for value in input().split(' ')]\n    P = 0\n    i = 0\n    if X > N * 30 and N != 2:\n        for i in range(N - 1):\n            A[i + 1] ^= A[i]\n            A[i] = 0\n        for a in A:\n            print(a, end=' ')\n        print()\n        continue\n    while i < N - 1 and X > 0:\n        try:\n            p = int(log(A[i], 2))\n        except ValueError:\n            i += 1\n            shared = A[i] & P\n            A[i] ^= shared\n            P -= shared\n            continue\n        P += 2 ** p\n        A[i] ^= 2 ** p\n        X -= 1\n    else:\n        while i < N - 1 and P != 0:\n            shared = A[i] & P\n            A[i] ^= shared\n            P ^= shared\n            i += 1\n    A[-1] ^= P\n    if N == 2 and X % 2 == 1:\n        A[-1] ^= 1\n        A[-2] ^= 1\n    for a in A:\n        print(a, end=' ')\n    print()", "from math import log\nfor _ in range(int(input())):\n    (N, X) = [int(x) for x in input().split(' ')]\n    A = [int(value) for value in input().split(' ')]\n    P = 0\n    i = 0\n    if X > N * 30 and N != 2:\n        for i in range(N - 1):\n            A[i + 1] ^= A[i]\n            A[i] = 0\n        if N == 2:\n            A[-1] ^= 1\n            A[-2] ^= 1\n        for a in A:\n            print(a, end=' ')\n        print()\n        continue\n    while i < N - 1 and X > 0:\n        try:\n            p = int(log(A[i], 2))\n        except ValueError:\n            i += 1\n            shared = A[i] & P\n            A[i] ^= shared\n            P -= shared\n            continue\n        P += 2 ** p\n        A[i] ^= 2 ** p\n        X -= 1\n    else:\n        while i < N - 1 and P != 0:\n            shared = A[i] & P\n            A[i] ^= shared\n            P ^= shared\n            i += 1\n    A[-1] ^= P\n    if N == 2 and X % 2 == 1:\n        A[-1] ^= 1\n        A[-2] ^= 1\n    for a in A:\n        print(a, end=' ')\n    print()", "import math\nt = int(input())\nfor tt in range(t):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    if n > 2 and x >= n - 1:\n        s = 0\n        for i in range(n):\n            s = s ^ a[i]\n        m = '0 ' * (n - 1) + str(s)\n        print(m)\n    else:\n        i = 0\n        while x != 0:\n            if a[i] == 0:\n                i += 1\n                if i == n - 1:\n                    break\n                else:\n                    continue\n            m = 2 ** math.floor(math.log2(a[i]))\n            f = 0\n            for j in range(i + 1, n - 1):\n                if m & a[j] == m:\n                    a[j] -= m\n                    a[i] -= m\n                    f = 1\n                    break\n            if f == 0:\n                a[n - 1] ^= m\n                a[i] -= m\n            x -= 1\n        if x % 2 == 1 and n == 2:\n            a[-2] += 1\n            if a[-1] % 2 == 1:\n                a[-1] -= 1\n            else:\n                a[-1] += 1\n        s = ''\n        for i in a:\n            s += str(i) + ' '\n        print(s)", "import math\n\ndef sol(x):\n    y = int(math.log(x, 2))\n    return 2 ** y\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    i = 0\n    t = k\n    if k > 3200000 and n > 80000:\n        for i in range(n - 1):\n            arr[n - 1] = arr[n - 1] ^ arr[i]\n            arr[i] = 0\n        print(' '.join(map(str, arr)))\n        continue\n    while k > 0:\n        if i == n - 1:\n            break\n        if arr[i] == 0:\n            i += 1\n            continue\n        temp = sol(arr[i])\n        arr[i] = arr[i] - temp\n        for j in range(i + 1, n):\n            if j == n - 1:\n                arr[j] = arr[j] ^ temp\n            else:\n                temp1 = arr[j] ^ temp\n                if temp1 < arr[j]:\n                    arr[j] = temp1\n                    break\n        if arr[i] == 0:\n            i += 1\n        k -= 1\n    if n == 2:\n        if k % 2 == 1:\n            arr[0] = arr[0] ^ 1\n            arr[1] = arr[1] ^ 1\n    print(' '.join(map(str, arr)))", "from math import floor, log2\nfrom sys import stdin\n\ndef power(k):\n    if k == 0:\n        return 0\n    return 2 ** floor(log2(k))\nT = int(stdin.readline())\nzac = power\nfor i in range(T):\n    (N, X) = map(int, stdin.readline().split())\n    l = list(map(int, stdin.readline().split()))\n    km = 0\n    if N > 100 and X >= pow(10, 6):\n        for zs in l:\n            km = km ^ zs\n        print(*[0 for i in range(N - 1)], km)\n        continue\n    r = 0\n    while r < N - 1 and l[N - 2] != 0:\n        if l[r] == 0:\n            r = r + 1\n            continue\n        bits = zac(l[r])\n        l[r] = l[r] ^ bits\n        for s in range(r + 1, N):\n            if l[s] ^ bits < l[s] or s == N - 1:\n                l[s] = l[s] ^ bits\n                X = X - 1\n                break\n        if X <= 0:\n            break\n        if l[r] == 0:\n            r = r + 1\n    if N == 2 and X % 2 != 0:\n        l[-1] = l[-1] ^ 1\n        l[-2] = l[-2] ^ 1\n    print(*l)", "from math import floor, log2\nfrom sys import stdin\n\ndef power(k):\n    if k == 0:\n        return 0\n    return 2 ** floor(log2(k))\nT = int(stdin.readline())\nzac = power\nfor i in range(T):\n    (N, X) = map(int, stdin.readline().split())\n    l = list(map(int, stdin.readline().split()))\n    km = 0\n    if N > 100 and X >= pow(10, 6):\n        for zs in l:\n            km = km ^ zs\n        print(*[0 for i in range(N - 1)], km)\n        continue\n    r = 0\n    while r < N - 1 and l[N - 2] != 0:\n        if l[r] == 0:\n            r = r + 1\n            continue\n        bits = zac(l[r])\n        l[r] = l[r] ^ bits\n        for s in range(r + 1, N):\n            if l[s] ^ bits < l[s] or s == N - 1:\n                l[s] = l[s] ^ bits\n                X = X - 1\n                break\n        if X <= 0:\n            break\n        if l[r] == 0:\n            r = r + 1\n    if N == 2 and X % 2 != 0:\n        l[-1] = l[-1] ^ 1\n        l[-2] = l[-2] ^ 1\n    print(*l)", "from math import floor, log2\n\ndef lemo(k):\n    if k == 0:\n        return 0\n    return 2 ** floor(log2(k))\nT = int(input())\nzac = lemo\nfor i in range(T):\n    (N, X) = map(int, input().split())\n    l = list(map(int, input().split()))\n    km = 0\n    if N > 100 and X >= pow(10, 6):\n        for zs in l:\n            km = km ^ zs\n        print(*[0 for i in range(N - 1)], km)\n        continue\n    r = 0\n    s = 1\n    while X != 0 and r < N - 1 and (s < N):\n        if l[r] != 0:\n            t = zac(l[r])\n            if l[s] > l[s] ^ t or s == N - 1:\n                l[r] = l[r] ^ t\n                l[s] = l[s] ^ t\n                s = r\n                X = X - 1\n            s += 1\n        elif l[r] == 0:\n            r = r + 1\n            s = r + 1\n    if N == 2 and X % 2 != 0:\n        l[-1] = l[-1] ^ 1\n        l[-2] = l[-2] ^ 1\n    print(*l)", "from math import floor, log2\n\ndef lemo(k):\n    if k == 0:\n        return 0\n    return 2 ** floor(log2(k))\nT = int(input())\nzac = lemo\nfor i in range(T):\n    (N, X) = map(int, input().split())\n    l = list(map(int, input().split()))\n    km = 0\n    if N > 100 and X >= pow(10, 6):\n        for zs in l:\n            km = km ^ zs\n        print(*[0 for i in range(N - 1)], km)\n        continue\n    r = 0\n    s = 1\n    while X != 0 and r < N - 1 and (s < N):\n        if l[r] != 0:\n            t = zac(l[r])\n            if l[s] > l[s] ^ t or s == N - 1:\n                l[r] = l[r] ^ t\n                l[s] = l[s] ^ t\n                s = r\n                X = X - 1\n            s += 1\n        elif l[r] == 0:\n            r = r + 1\n            s = r + 1\n    if N == 2 and X % 2 != 0:\n        l[-1] = l[-1] ^ 1\n        l[-2] = l[-2] ^ 1\n    print(*l)", "from math import floor, log2\n\ndef lemo(k):\n    if k == 0:\n        return 0\n    return 2 ** floor(log2(k))\nT = int(input())\nzac = lemo\nfor i in range(T):\n    (N, X) = map(int, input().split())\n    l = list(map(int, input().split()))\n    km = 0\n    if N > 100 and X >= pow(10, 6):\n        for zs in l:\n            km = km ^ zs\n        print(*[0 for i in range(N - 1)], km)\n        continue\n    r = 0\n    s = 1\n    while X != 0 and r < N - 1 and (s < N):\n        if l[r] != 0:\n            t = zac(l[r])\n            if l[s] > l[s] ^ t or s == N - 1:\n                l[r] = l[r] ^ t\n                l[s] = l[s] ^ t\n                s = r\n                X = X - 1\n            s += 1\n        elif l[r] == 0:\n            r = r + 1\n            s = r + 1\n    if N == 2 and X % 2 != 0:\n        l[-1] = l[-1] ^ 1\n        l[-2] = l[-2] ^ 1\n    print(*l)", "for _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    for i in range(len(a)):\n        if i == n - 1:\n            if n == 2:\n                if x % 2 == 1:\n                    a[-1] ^= 1\n                    a[-2] ^= 1\n            elif all((ele == 0 for ele in a)) and x == 1:\n                a[-1] ^= 1\n                a[-2] ^= 1\n            break\n        j = i + 1\n        if a[i] != 0:\n            c = bin(a[i]).replace('0b', '')\n            x = x - c.count('1')\n            if x < 0:\n                x = x + c.count('1')\n                c = c.replace('1', '', x)\n                c = int(c, 2)\n                (a[i], c) = (c, a[i] - c)\n                while c != 0 and j < len(a):\n                    (a[j], c) = (~c & a[j], c & ~a[j])\n                    j += 1\n                a[n - 1] ^= c\n                break\n            else:\n                while a[i] != 0 and j < n:\n                    (a[j], a[i]) = (~a[i] & a[j], a[i] & ~a[j])\n                    j += 1\n                a[n - 1] ^= a[i]\n                a[i] = 0\n                if x == 0:\n                    break\n    print(*a, sep=' ')", "MAX_BINARY_LENGTH = 30\nt = int(input())\nfor i in range(t):\n    (n, x) = map(int, input().split())\n    A = list(map(int, input().split()))\n    opsCount = 0\n    unAddressedBitsNumber = 0\n    lastIndexProcessed = -1\n    for j in range(n - 1):\n        andValue = A[j] & unAddressedBitsNumber\n        A[j] -= andValue\n        unAddressedBitsNumber -= andValue\n        if A[j] != 0:\n            binary = bin(A[j])[2:]\n            onesInBinary = binary.count('1')\n            if opsCount + onesInBinary <= x:\n                unAddressedBitsNumber += A[j]\n                A[j] = 0\n                opsCount += onesInBinary\n            else:\n                for k in range(len(binary)):\n                    if binary[k] == '1':\n                        A[j] -= 2 ** (len(binary) - 1 - k)\n                        unAddressedBitsNumber += 2 ** (len(binary) - 1 - k)\n                        opsCount += 1\n                        if opsCount == x:\n                            break\n            if opsCount == x:\n                lastIndexProcessed = j\n                break\n    if lastIndexProcessed != -1:\n        j = lastIndexProcessed + 1\n        while j < n - 1 and unAddressedBitsNumber > 0:\n            andValue = A[j] & unAddressedBitsNumber\n            A[j] -= andValue\n            unAddressedBitsNumber -= andValue\n            j += 1\n        A[n - 1] ^= unAddressedBitsNumber\n    else:\n        A[n - 1] ^= unAddressedBitsNumber\n        if opsCount == bin(unAddressedBitsNumber).count('1') and (x - opsCount) % 2:\n            A[n - 2] = 1\n            A[n - 1] ^= 1\n    print(*A)", "MAX_BINARY_LENGTH = 30\nt = int(input())\nfor i in range(t):\n    (n, x) = map(int, input().split())\n    A = list(map(int, input().split()))\n    opsCount = 0\n    unAddressedBits = set()\n    unAddressedBitsNumber = 0\n    lastIndexProcessed = -1\n    lastBitProcessed = -1\n    bitPairFound = False\n    for j in range(n - 1):\n        andValue = A[j] & unAddressedBitsNumber\n        A[j] -= andValue\n        unAddressedBitsNumber -= andValue\n        if A[j] != 0:\n            binary = bin(A[j])[2:]\n            onesInBinary = binary.count('1')\n            if opsCount + onesInBinary <= x:\n                unAddressedBitsNumber += A[j]\n                A[j] = 0\n                opsCount += onesInBinary\n            else:\n                for k in range(len(binary)):\n                    if binary[k] == '1':\n                        A[j] -= 2 ** (len(binary) - 1 - k)\n                        unAddressedBitsNumber += 2 ** (len(binary) - 1 - k)\n                        opsCount += 1\n                        if opsCount == x:\n                            break\n            if opsCount == x:\n                lastIndexProcessed = j\n                break\n    if lastIndexProcessed != -1:\n        j = lastIndexProcessed + 1\n        while j < n - 1 and unAddressedBitsNumber > 0:\n            andValue = A[j] & unAddressedBitsNumber\n            A[j] -= andValue\n            unAddressedBitsNumber -= andValue\n            j += 1\n        A[n - 1] ^= unAddressedBitsNumber\n    else:\n        A[n - 1] ^= unAddressedBitsNumber\n        if opsCount == bin(unAddressedBitsNumber).count('1') and (x - opsCount) % 2:\n            A[n - 2] = 1\n            A[n - 1] ^= 1\n    print(*A)", "import math\n\ndef highestPowerof2(n):\n    p = int(math.log(n, 2))\n    return int(pow(2, p))\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = 0\n    y = 0\n    for i in a:\n        c += bin(i).count('1')\n        y ^= i\n    c -= bin(a[-1]).count('1')\n    if x > c:\n        if n == 2 and x - c & 1:\n            print(1, y ^ 1)\n        else:\n            print('0 ' * (n - 1), y, sep='')\n    else:\n        z = 0\n        i = 0\n        while z < x and i < n:\n            if a[i] == 0:\n                i += 1\n                continue\n            p = highestPowerof2(a[i])\n            for j in range(i + 1, n):\n                if a[j] ^ p < a[j]:\n                    a[j] ^= p\n                    a[i] ^= p\n                    z += 1\n                    break\n                elif j == n - 1:\n                    a[j] ^= p\n                    a[i] ^= p\n                    z += 1\n                    break\n            if i == n - 1:\n                break\n        r = x - z\n        if r and n == 2:\n            if r & 1:\n                a[0] = 1\n                a[1] ^= 1\n        print(' '.join((str(i) for i in a)))", "import math\n\ndef xorOfArray(arr, n):\n    xor_arr = 0\n    for i in range(n):\n        xor_arr = xor_arr ^ arr[i]\n    return xor_arr\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    cnt = 0\n    i = 0\n    skip = 0\n    if n == 2:\n        while arr[0] != 0:\n            p = math.floor(math.log(arr[0], 2))\n            arr[0] ^= 2 ** p\n            arr[1] ^= 2 ** p\n            cnt += 1\n            if cnt == x:\n                print(*arr)\n                break\n        ele2 = arr[1] ^ 1\n        if x > cnt:\n            diff = x - cnt\n            if diff % 2 == 0:\n                print(*arr)\n            else:\n                print(1, ele2)\n    elif x > 15 * n:\n        res = xorOfArray(arr, n)\n        resArr = [0 for i in range(n)]\n        resArr[n - 1] = res\n        print(*resArr)\n    else:\n        while i < n:\n            if i == n - 2 and arr[i] == 0:\n                break\n            if arr[i] == 0:\n                i += skip + 1\n                continue\n            p = math.floor(math.log(arr[i], 2))\n            arr[i] ^= 2 ** p\n            skip = 0\n            for j in range(i + 1, n):\n                if arr[j] == 0:\n                    skip += 1\n                    continue\n                if arr[j] ^ pow(2, p) < arr[j]:\n                    break\n            arr[j] ^= pow(2, p)\n            cnt += 1\n            if cnt == x:\n                print(*arr)\n                break\n        if x > cnt:\n            print(*arr)", "def count(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    l = list(map(int, input().split()))\n    t = 0\n    for i in range(0, n - 1):\n        f = l[i] & t\n        l[i] = l[i] - f\n        t = t - f\n        if x > 0:\n            cnt = count(l[i])\n            if x - cnt < 0:\n                s = bin(l[i])\n                for j in range(2, len(s)):\n                    if s[j] == '1':\n                        l[i] = l[i] - pow(2, len(s) - j - 1)\n                        t = t + pow(2, len(s) - j - 1)\n                        x = x - 1\n                        if x == 0:\n                            break\n            else:\n                t = t ^ l[i]\n                l[i] = 0\n                x = x - cnt\n    l[n - 1] = l[n - 1] ^ t\n    if x == 1:\n        l[n - 2] = l[n - 2] + 1\n        l[n - 1] = l[n - 1] ^ 1\n    elif x % 2 == 1 and n == 2:\n        l[0] = 1\n        l[1] = l[1] ^ 1\n    for i in l:\n        print(i, end=' ')\n    print()", "from math import log\n\ndef count(num):\n    nibble = 0\n    num_to_bits = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]\n    if num == 0:\n        return num_to_bits[0]\n    nibble = num & 15\n    return num_to_bits[nibble] + count(num >> 4)\n\ndef solve(n: int, x: int, a: list):\n    if n == 2:\n        if count(a[0]) <= x:\n            a[1] = a[1] ^ a[0]\n            x -= count(a[0])\n            a[0] = 0\n            if x % 2 != 0:\n                a[0] = 1\n                a[1] = a[1] ^ 1\n        else:\n            c = 0\n            bi = bin(a[0])[2:]\n            for _ in range(bi.__len__()):\n                if bi[_] == '1':\n                    c += 1\n                if c == x:\n                    k = int(bi[:_ + 1] + '0000000000000000000000000000000000000000'[:bi.__len__() - _ - 1], 2)\n                    a[0] = int(bi[_ + 1:], 2)\n                    x = 0\n                    break\n            a[1] = a[1] ^ k\n        return str(a[0]) + ' ' + str(a[1])\n    i = -1\n    roll = 0\n    while x > 0 or roll != 0:\n        i += 1\n        t = roll & a[i]\n        roll = roll ^ t\n        a[i] = a[i] ^ t\n        if i < n - 1 and x > 0 and (count(a[i]) > x):\n            c = 0\n            bi = bin(a[i])[2:]\n            for _ in range(bi.__len__()):\n                if bi[_] == '1':\n                    c += 1\n                if c == x:\n                    k = int(bi[:_ + 1] + '0000000000000000000000000000000000000000'[:bi.__len__() - _ - 1], 2)\n                    roll = roll | k\n                    a[i] = int(bi[_ + 1:], 2)\n                    x = 0\n        elif i < n - 1 and x > 0:\n            roll = roll | a[i]\n            x -= count(a[i])\n            a[i] = 0\n        if i == n - 1:\n            a[i] = a[i] | roll\n            roll = 0\n            break\n    if x < 0:\n        raise Exception('kj')\n    return ' '.join(list(map(str, a)))\nfor test in range(int(input())):\n    (n, x) = map(int, input().split())\n    print(solve(n, x, list(map(int, input().split()))))", "t = int(input())\nwhile t > 0:\n    (n, x) = map(int, input().split())\n    temp1 = x\n    l = list(map(int, input().split()))\n    h = l[0:]\n    flag = 0\n    for i in range(n - 1):\n        if flag == 1:\n            break\n        if x == 0:\n            break\n        p = bin(l[i])\n        c = 0\n        s = p[2:]\n        for j in s:\n            if j == '1':\n                c += 1\n        if x - c > 0:\n            l[i + 1] ^= l[i]\n            l[i] = 0\n            x -= c\n        elif x - c <= 0:\n            flag = 1\n            for i in range(n - 1):\n                if temp1 <= 0:\n                    l = h\n                    break\n                p = bin(h[i])\n                s = p[2:]\n                (z, sum1, c1) = (len(s), [], 0)\n                for k in range(z):\n                    if c1 < temp1:\n                        if s[k] == '1':\n                            sum1.append(2 ** (z - k - 1))\n                            c1 += 1\n                temp1 -= c1\n                for y in sum1:\n                    for w in range(i + 1, n - 1):\n                        if h[w] ^ y < h[w]:\n                            h[w] ^= y\n                            h[i] -= y\n                            break\n                    else:\n                        h[-1] ^= w\n                        h[i] -= y\n    if n == 2:\n        if x % 2 == 0:\n            pass\n        else:\n            l[0] ^= 1\n            l[1] ^= 1\n    for i in l:\n        print(i, end=' ')\n    print()\n    t -= 1", "from operator import xor\nfrom collections import Counter\nfrom functools import reduce\n\ndef binary_composer(num):\n    return [1 << i for (i, j) in enumerate(bin(num)[-1:1:-1]) if j == '1'][::-1]\n\ndef effective_operations(A, n_ops):\n    N = len(A)\n    pairs_cnt = 0\n    run_sum = 0\n    total_sum = 0\n    uniques_account = 0\n    res = ''\n    i = 0\n    while True:\n        last_ops = 0\n        for op in binary_composer(A[i]):\n            if total_sum == n_ops:\n                res = 'not '\n                break\n            if uniques_account ^ op < uniques_account:\n                pairs_cnt -= 1\n                uniques_account -= op\n            else:\n                uniques_account += op\n            last_ops += op\n            run_sum += 1\n            total_sum = pairs_cnt + run_sum\n        if total_sum == n_ops:\n            res += 'res_all_ops'\n            break\n        i += 1\n        if i == N - 1:\n            res = 'res_end_array'\n            break\n    uniques_set = set(binary_composer(uniques_account))\n    if last_ops:\n        last_ops = binary_composer(last_ops)\n    return (total_sum, uniques_set, i, res, last_ops)\nfor _ in range(int(input())):\n    (N, X) = map(int, input().split(' '))\n    A = list(map(int, input().split(' ')))\n    all_ops = []\n    for i in A:\n        all_ops.extend(binary_composer(i))\n    pairs_list = Counter(all_ops)\n    pairs = 0\n    for a in pairs_list.values():\n        pairs += a // 2\n    if X > pairs + len(pairs_list) and N != 2:\n        zxor = reduce(xor, A)\n        result = [0 for x in A]\n        result[N - 1] = zxor\n        print(*result)\n        continue\n    (n_ops, set_to_add, last_indx, res_how, last_ops) = effective_operations(A, X)\n    result = [x for x in A]\n    if N == 2 and X > n_ops:\n        decision_bool = (len(binary_composer(A[0])) + X) % 2 == 1\n        if decision_bool:\n            if A[0] == A[1]:\n                print(1, 1)\n            else:\n                result[0] = 1\n                result[1] ^= 1\n                for op in binary_composer(A[0]):\n                    result[1] ^= op\n                print(*result)\n            continue\n    if res_how == 'not res_all_ops':\n        for op in last_ops:\n            result[last_indx] ^= op\n        indx = last_indx\n        for k in range(indx):\n            result[k] = 0\n    elif res_how == 'res_all_ops':\n        indx = last_indx + 1\n        for k in range(indx):\n            result[k] = 0\n    else:\n        indx = last_indx + 1\n        for k in range(indx - 1):\n            result[k] = 0\n    for j in range(indx, N - 1):\n        coincidence = set_to_add.intersection(binary_composer(result[j]))\n        if coincidence:\n            for op in coincidence:\n                result[j] ^= op\n                set_to_add.remove(op)\n        if not set_to_add:\n            break\n    for op in set_to_add:\n        result[N - 1] ^= op\n    print(*result)", "import math\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    i = 0\n    j = 0\n    if x <= n:\n        while i < x:\n            if j == n - 1:\n                break\n            if arr[j] == 0:\n                j += 1\n                continue\n            logg = math.floor(math.log2(arr[j]))\n            t = 2 ** logg\n            k = j + 1\n            while k < n - 1:\n                ele = arr[k] ^ t\n                if ele < arr[k]:\n                    break\n                k += 1\n            arr[j] = arr[j] ^ t\n            arr[k] = arr[k] ^ t\n            i += 1\n    else:\n        for i in range(n - 1):\n            if arr[i] != 0:\n                c = 0\n                a = arr[i]\n                while a > 0:\n                    a = a & a - 1\n                    c += 1\n                arr[i + 1] ^= arr[i]\n                arr[i] = 0\n                x -= c\n    res = x - i\n    if n == 2 and res > 0 and (res % 2 != 0):\n        arr[n - 1] ^= 1\n        arr[n - 2] ^= 1\n    print(*arr)", "def fun(a, t):\n    global x\n    c = 0\n    s = list(bin(a)[2:])\n    for i in range(len(s)):\n        if s[i] == '1':\n            c = c + 1\n            s[i] = '0'\n            if t + c == x:\n                break\n    return (int(''.join(s), 2), c)\nfor i in range(int(input())):\n    (n, x) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l1 = []\n    y = l[0]\n    temp = l[0]\n    t = 0\n    flg = 0\n    for j in range(n):\n        if j == 0:\n            t1 = t + bin(l[j])[2:].count('1')\n            if t1 > x:\n                (k, g) = fun(l[j], t)\n                l1.append(k)\n                flg = 1\n                t = t + g\n                y = k ^ y\n                temp = y\n            elif t1 == x:\n                l1.append(0)\n                flg = 1\n                t = t1\n            else:\n                t = t1\n                l1.append(0)\n        elif j < n - 1:\n            y = y ^ l[j]\n            a = y & temp\n            z = y - a\n            if flg:\n                y = a\n                temp = y\n                l1.append(z)\n            else:\n                o = bin(z)[2:].count('1')\n                t1 = t + o\n                if t1 > x:\n                    (k, g) = fun(z, t)\n                    l1.append(k)\n                    flg = 1\n                    t = t + g\n                    y = y ^ k\n                elif t1 == x:\n                    l1.append(0)\n                    flg = 1\n                    t = t1\n                else:\n                    t = t1\n                    l1.append(0)\n                temp = y\n        elif y == 0:\n            l1.append(l[j])\n        else:\n            y = y ^ l[j]\n            a = y & temp\n            z = y - a\n            if y == 0:\n                l1.append(0)\n            elif flg:\n                l1.append(z ^ a)\n            else:\n                l1.append(z ^ a)\n    if not flg:\n        if n == 2 and (x - t) % 2 != 0:\n            l1[n - 2] = l1[n - 2] ^ 1\n            l1[n - 1] = l1[n - 1] ^ 1\n    print(' '.join(list(map(str, l1))))", "def fun(a, t):\n    global x\n    c = 0\n    s = list(bin(a)[2:])\n    for i in range(len(s)):\n        if s[i] == '1':\n            c = c + 1\n            s[i] = '0'\n            if t + c == x:\n                break\n    return (int(''.join(s), 2), c)\nfor i in range(int(input())):\n    (n, x) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l1 = []\n    y = l[0]\n    temp = l[0]\n    t = 0\n    flg = 0\n    for j in range(n):\n        if j == 0:\n            t1 = t + bin(l[j])[2:].count('1')\n            if t1 > x:\n                (k, g) = fun(l[j], t)\n                l1.append(k)\n                flg = 1\n                t = t + g\n                y = k ^ y\n                temp = y\n            elif t1 == x:\n                l1.append(0)\n                flg = 1\n                t = t1\n            else:\n                t = t1\n                l1.append(0)\n        elif j < n - 1:\n            y = y ^ l[j]\n            a = y & temp\n            z = y - a\n            if flg:\n                y = a\n                temp = y\n                l1.append(z)\n            else:\n                o = bin(z)[2:].count('1')\n                t1 = t + o\n                if t1 > x:\n                    (k, g) = fun(z, t)\n                    l1.append(k)\n                    flg = 1\n                    t = t + g\n                    y = y ^ k\n                elif t1 == x:\n                    l1.append(0)\n                    flg = 1\n                    t = t1\n                else:\n                    t = t1\n                    l1.append(0)\n                temp = y\n        elif y == 0:\n            l1.append(l[j])\n        else:\n            y = y ^ l[j]\n            a = y & temp\n            z = y - a\n            if y == 0:\n                l1.append(0)\n            elif flg:\n                l1.append(z ^ a)\n            else:\n                l1.append(z ^ a)\n    if not flg:\n        if n == 2 and (x - t) % 2 != 0:\n            l1[n - 2] = l1[n - 2] ^ 1\n            l1[n - 1] = l1[n - 1] ^ 1\n    print(' '.join(list(map(str, l1))))", "from math import log2, floor\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    ar = list(map(int, input().split()))\n    i = 0\n    j = 1\n    while x != 0 and i < n - 1 and (x <= n):\n        if ar[i] == 0:\n            i += 1\n            continue\n        j = i + 1\n        a = 2 ** floor(log2(ar[i]))\n        if ar[j] ^ a >= ar[j]:\n            for k in range(i + 1, n):\n                if ar[k] ^ a < ar[k] and ar[k] != 0:\n                    j = k\n                    break\n        ar[i] ^= a\n        ar[j] ^= a\n        x -= 1\n    if x > n:\n        for i in range(n - 1):\n            if ar[i] != 0:\n                co = 0\n                var = ar[i]\n                while var > 0:\n                    var = var & var - 1\n                    co += 1\n                ar[i + 1] ^= ar[i]\n                ar[i] = 0\n                x -= co\n    if n == 2 and x > 0 and (x % 2 == 1):\n        a = 1\n        ar[-1] ^= a\n        ar[-2] ^= a\n    print(*ar)", "from math import floor, log, ceil\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    xor = 0\n    for i in range(n):\n        xor ^= a[i]\n    if x < n:\n        f = 0\n        for i in range(n - 1):\n            if a[i] == 0:\n                continue\n            else:\n                while a[i] > 0:\n                    tmp = floor(log(a[i], 2))\n                    to = pow(2, tmp)\n                    a[i] ^= to\n                    f = 0\n                    for j in range(i + 1, n):\n                        k = a[j] ^ to\n                        if k < a[j]:\n                            a[j] ^= to\n                            f = 1\n                            x -= 1\n                            break\n                    if f == 0:\n                        a[-1] ^= to\n                        x -= 1\n                    if x == 0:\n                        break\n            if x == 0:\n                break\n        if x == 0:\n            print(*a)\n        elif k % 2 == 0:\n            print(*a)\n        else:\n            a[-1] ^= 1\n            a[-2] ^= 1\n            print(*a)\n    elif n == 2:\n        if a[0] == a[1]:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = 0\n                else:\n                    a[0] = 1\n                    a[1] = 1\n            print(*a)\n        else:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = xor\n                else:\n                    a[0] = 1\n                    a[1] = xor ^ 1\n            print(*a)\n    else:\n        arr = [[] for i in range(40)]\n        cap = 0\n        for i in range(n - 1):\n            s = bin(a[i])\n            s = s[2:]\n            s = s[::-1]\n            for j in range(len(s)):\n                if s[j] == '1':\n                    arr[j].append(i)\n        for i in range(len(arr)):\n            cap += ceil(len(arr[i]) / 2)\n        if x >= cap:\n            for i in range(n - 1):\n                a[i] = 0\n            a[-1] = xor\n            print(*a)\n        else:\n            for i in range(n - 1):\n                for j in range(39, -1, -1):\n                    p = j\n                    to = pow(2, p)\n                    if len(arr[j]) > 0:\n                        if len(arr[j]) > 1:\n                            a[arr[j][0]] ^= to\n                            a[arr[j][1]] ^= to\n                            arr[j].pop(0)\n                            arr[j].pop(0)\n                        else:\n                            a[arr[j][0]] ^= to\n                            a[-1] ^= to\n                            arr[j].pop(0)\n                        x -= 1\n                        if x == 0:\n                            break\n                if x == 0:\n                    break\n            print(*a)", "from math import floor, log, ceil\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    xor = 0\n    for i in range(n):\n        xor ^= a[i]\n    if x < n:\n        f = 0\n        for i in range(n - 1):\n            if a[i] == 0:\n                continue\n            else:\n                while a[i] > 0:\n                    tmp = floor(log(a[i], 2))\n                    to = pow(2, tmp)\n                    a[i] ^= to\n                    f = 0\n                    for j in range(i + 1, n):\n                        k = a[j] ^ to\n                        if k < a[j]:\n                            a[j] ^= to\n                            f = 1\n                            x -= 1\n                            break\n                    if f == 0:\n                        a[-1] ^= to\n                        x -= 1\n                    if x == 0:\n                        break\n            if x == 0:\n                break\n        if x == 0:\n            print(*a)\n        elif k % 2 == 0:\n            print(*a)\n        else:\n            a[-1] ^= 1\n            a[-2] ^= 1\n            print(*a)\n    elif n == 2:\n        if a[0] == a[1]:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = 0\n                else:\n                    a[0] = 1\n                    a[1] = 1\n            print(*a)\n        else:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = xor\n                else:\n                    a[0] = 1\n                    a[1] = xor ^ 1\n            print(*a)\n    else:\n        arr = [[] for i in range(40)]\n        cap = 0\n        for i in range(n - 1):\n            s = bin(a[i])\n            s = s[2:]\n            s = s[::-1]\n            for j in range(len(s)):\n                if s[j] == '1':\n                    arr[j].append(i)\n        for i in range(len(arr)):\n            cap += ceil(len(arr[i]) / 2)\n        if x >= cap:\n            for i in range(n - 1):\n                a[i] = 0\n            a[-1] = xor\n            print(*a)\n        else:\n            for i in range(n - 1):\n                for j in range(39, -1, -1):\n                    p = j\n                    to = pow(2, p)\n                    if len(arr[j]) > 0:\n                        if len(arr[j]) > 1:\n                            a[arr[j][0]] ^= to\n                            a[arr[j][1]] ^= to\n                            arr[j].pop(0)\n                            arr[j].pop(0)\n                        else:\n                            a[arr[j][0]] ^= to\n                            a[-1] ^= to\n                            arr[j].pop(0)\n                        x -= 1\n                        if x == 0:\n                            break\n                if x == 0:\n                    break\n            print(*a)", "import math\ntry:\n    t = int(input())\n    for _ in range(t):\n        (n, x) = map(int, input().split())\n        arr = list(map(int, input().split()))\n        temp = x\n        y = 10 ** 4\n        s = 0\n        if n > y and x >= n:\n            for l in range(n):\n                s = s ^ arr[l]\n            arr = [0] * n\n            arr[n - 1] = s\n        else:\n            i = 0\n            while i < n - 1 and temp > 0:\n                if arr[i] != 0:\n                    p = int(math.log2(arr[i]))\n                    c = 2 ** p\n                    if temp > 0:\n                        for j in range(i + 1, n):\n                            if arr[j] ^ c < arr[j]:\n                                arr[j] = arr[j] ^ c\n                                arr[i] = arr[i] ^ c\n                                temp -= 1\n                                if arr[i] == 0:\n                                    i += 1\n                                break\n                            elif j == n - 1:\n                                arr[j] = arr[j] ^ c\n                                arr[i] = arr[i] ^ c\n                                temp -= 1\n                                if arr[i] == 0:\n                                    i += 1\n                                break\n                else:\n                    i += 1\n            if temp > 0 and temp % 2 == 1 and (n == 2):\n                arr[n - 1] = arr[n - 1] ^ 1\n                arr[n - 2] = arr[n - 2] ^ 1\n        result = map(str, arr)\n        print(' '.join(result))\nexcept EOFError:\n    pass", "from math import log2, floor\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    ar = list(map(int, input().split()))\n    i = 0\n    j = 1\n    while x != 0 and i < n - 1 and (x <= n):\n        if ar[i] == 0:\n            i += 1\n            continue\n        j = i + 1\n        a = 2 ** floor(log2(ar[i]))\n        if ar[j] ^ a >= ar[j]:\n            for k in range(i + 1, n):\n                if ar[k] ^ a < ar[k] and ar[k] != 0:\n                    j = k\n                    break\n        ar[i] ^= a\n        ar[j] ^= a\n        x -= 1\n    if x > n:\n        for i in range(n - 1):\n            if ar[i] != 0:\n                co = 0\n                var = ar[i]\n                while var > 0:\n                    var = var & var - 1\n                    co += 1\n                ar[i + 1] ^= ar[i]\n                ar[i] = 0\n                x -= co\n    if n == 2 and x > 0 and (x % 2 == 1):\n        a = 1\n        ar[-1] ^= a\n        ar[-2] ^= a\n    print(*ar)", "from math import floor, log, ceil\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    xor = 0\n    for i in range(n):\n        xor ^= a[i]\n    if x < n:\n        f = 0\n        for i in range(n - 1):\n            if a[i] == 0:\n                continue\n            else:\n                while a[i] > 0:\n                    tmp = floor(log(a[i], 2))\n                    to = pow(2, tmp)\n                    a[i] ^= to\n                    f = 0\n                    for j in range(i + 1, n):\n                        k = a[j] ^ to\n                        if k < a[j]:\n                            a[j] ^= to\n                            f = 1\n                            x -= 1\n                            break\n                    if f == 0:\n                        a[-1] ^= to\n                        x -= 1\n                    if x == 0:\n                        break\n            if x == 0:\n                break\n        if x == 0:\n            print(*a)\n        elif k % 2 == 0:\n            print(*a)\n        else:\n            a[-1] ^= 1\n            a[-2] ^= 1\n            print(*a)\n    elif n == 2:\n        if a[0] == a[1]:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = 0\n                else:\n                    a[0] = 1\n                    a[1] = 1\n            print(*a)\n        else:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = xor\n                else:\n                    a[0] = 1\n                    a[1] = xor ^ 1\n            print(*a)\n    else:\n        arr = [[] for i in range(40)]\n        cap = 0\n        for i in range(n - 1):\n            s = bin(a[i])\n            s = s[2:]\n            s = s[::-1]\n            for j in range(len(s)):\n                if s[j] == '1':\n                    arr[j].append(i)\n        for i in range(len(arr)):\n            cap += ceil(len(arr[i]) / 2)\n        if x >= cap:\n            for i in range(n - 1):\n                a[i] = 0\n            a[-1] = xor\n            print(*a)\n        else:\n            for i in range(n - 1):\n                for j in range(39, -1, -1):\n                    p = j\n                    to = pow(2, p)\n                    if len(arr[j]) > 0:\n                        if len(arr[j]) > 1:\n                            a[arr[j][0]] ^= to\n                            a[arr[j][1]] ^= to\n                            arr[j].pop(0)\n                            arr[j].pop(0)\n                        else:\n                            a[arr[j][0]] ^= to\n                            a[-1] ^= to\n                            arr[j].pop(0)\n                        x -= 1\n                        if x == 0:\n                            break\n                if x == 0:\n                    break\n            print(*a)", "from math import floor, log, ceil\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    xor = 0\n    for i in range(n):\n        xor ^= a[i]\n    if x < n:\n        f = 0\n        for i in range(n - 1):\n            if a[i] == 0:\n                continue\n            else:\n                while a[i] > 0:\n                    tmp = floor(log(a[i], 2))\n                    to = pow(2, tmp)\n                    a[i] ^= to\n                    f = 0\n                    for j in range(i + 1, n):\n                        k = a[j] ^ to\n                        if k < a[j]:\n                            a[j] ^= to\n                            f = 1\n                            x -= 1\n                            break\n                    if f == 0:\n                        a[-1] ^= to\n                        x -= 1\n                    if x == 0:\n                        break\n            if x == 0:\n                break\n        if x == 0:\n            print(*a)\n        elif k % 2 == 0:\n            print(*a)\n        else:\n            a[-1] ^= 1\n            a[-2] ^= 1\n            print(*a)\n    elif n == 2:\n        if a[0] == a[1]:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = 0\n                else:\n                    a[0] = 1\n                    a[1] = 1\n            print(*a)\n        else:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = xor\n                else:\n                    a[0] = 1\n                    a[1] = xor ^ 1\n            print(*a)\n    else:\n        arr = [[] for i in range(40)]\n        cap = 0\n        for i in range(n - 1):\n            s = bin(a[i])\n            s = s[2:]\n            s = s[::-1]\n            for j in range(len(s)):\n                if s[j] == '1':\n                    arr[j].append(i)\n        for i in range(len(arr)):\n            cap += ceil(len(arr[i]) / 2)\n        if x >= cap:\n            for i in range(n - 1):\n                a[i] = 0\n            a[-1] = xor\n            print(*a)\n        else:\n            for i in range(n - 1):\n                for j in range(39, -1, -1):\n                    p = j\n                    to = pow(2, p)\n                    if len(arr[j]) > 0:\n                        if len(arr[j]) > 1:\n                            a[arr[j][0]] ^= to\n                            a[arr[j][1]] ^= to\n                            arr[j].pop(0)\n                            arr[j].pop(0)\n                        else:\n                            a[arr[j][0]] ^= to\n                            a[-1] ^= to\n                            arr[j].pop(0)\n                        x -= 1\n                        if x == 0:\n                            break\n                if x == 0:\n                    break\n            print(*a)", "from math import floor, log, ceil\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    xor = 0\n    for i in range(n):\n        xor ^= a[i]\n    if x < n:\n        f = 0\n        for i in range(n - 1):\n            if a[i] == 0:\n                continue\n            else:\n                while a[i] > 0:\n                    tmp = floor(log(a[i], 2))\n                    to = pow(2, tmp)\n                    a[i] ^= to\n                    f = 0\n                    for j in range(i + 1, n):\n                        k = a[j] ^ to\n                        if k < a[j]:\n                            a[j] ^= to\n                            f = 1\n                            x -= 1\n                            break\n                    if f == 0:\n                        a[-1] ^= to\n                        x -= 1\n                    if x == 0:\n                        break\n            if x == 0:\n                break\n        if x == 0:\n            print(*a)\n        elif k % 2 == 0:\n            print(*a)\n        else:\n            a[-1] ^= 1\n            a[-2] ^= 1\n            print(*a)\n    elif n == 2:\n        if a[0] == a[1]:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = 0\n                else:\n                    a[0] = 1\n                    a[1] = 1\n            print(*a)\n        else:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = xor\n                else:\n                    a[0] = 1\n                    a[1] = xor ^ 1\n            print(*a)\n    else:\n        arr = [[] for i in range(40)]\n        cap = 0\n        for i in range(n - 1):\n            s = bin(a[i])\n            s = s[2:]\n            s = s[::-1]\n            for j in range(len(s)):\n                if s[j] == '1':\n                    arr[j].append(i)\n        for i in range(len(arr)):\n            cap += ceil(len(arr[i]) / 2)\n        if x >= cap:\n            for i in range(n - 1):\n                a[i] = 0\n            a[-1] = xor\n            print(*a)\n        else:\n            for i in range(n - 1):\n                for j in range(39, -1, -1):\n                    p = j\n                    to = pow(2, p)\n                    if len(arr[j]) > 0:\n                        if len(arr[j]) > 1:\n                            a[arr[j][0]] ^= to\n                            a[arr[j][1]] ^= to\n                            arr[j].pop(0)\n                            arr[j].pop(0)\n                        else:\n                            a[arr[j][0]] ^= to\n                            a[-1] ^= to\n                            arr[j].pop(0)\n                        x -= 1\n                        if x == 0:\n                            break\n                if x == 0:\n                    break\n            print(*a)", "from math import floor, log, ceil\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    xor = 0\n    for i in range(n):\n        xor ^= a[i]\n    if x < n:\n        f = 0\n        for i in range(n - 1):\n            if a[i] == 0:\n                continue\n            else:\n                while a[i] > 0:\n                    tmp = floor(log(a[i], 2))\n                    to = pow(2, tmp)\n                    a[i] ^= to\n                    f = 0\n                    for j in range(i + 1, n):\n                        k = a[j] ^ to\n                        if k < a[j]:\n                            a[j] ^= to\n                            f = 1\n                            x -= 1\n                            break\n                    if f == 0:\n                        a[-1] ^= to\n                        x -= 1\n                    if x == 0:\n                        break\n            if x == 0:\n                break\n        if x == 0:\n            print(*a)\n        elif k % 2 == 0:\n            print(*a)\n        else:\n            a[-1] ^= 1\n            a[-2] ^= 1\n            print(*a)\n    elif n == 2:\n        if a[0] == a[1]:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = 0\n                else:\n                    a[0] = 1\n                    a[1] = 1\n            print(*a)\n        else:\n            s = bin(a[0])[2:]\n            bits = s.count('1')\n            if x < bits:\n                for i in range(x):\n                    tmp = floor(log(a[0], 2))\n                    to = pow(2, tmp)\n                    a[0] ^= to\n                    a[1] ^= to\n            else:\n                x -= bits\n                if x % 2 == 0:\n                    a[0] = 0\n                    a[1] = xor\n                else:\n                    a[0] = 1\n                    a[1] = xor ^ 1\n            print(*a)\n    else:\n        arr = [[] for i in range(40)]\n        cap = 0\n        for i in range(n - 1):\n            s = bin(a[i])\n            s = s[2:]\n            s = s[::-1]\n            for j in range(len(s)):\n                if s[j] == '1':\n                    arr[j].append(i)\n        for i in range(len(arr)):\n            cap += ceil(len(arr[i]) / 2)\n        if x >= cap:\n            for i in range(n - 1):\n                a[i] = 0\n            a[-1] = xor\n            print(*a)\n        else:\n            for i in range(n - 1):\n                for j in range(39, -1, -1):\n                    p = j\n                    to = pow(2, p)\n                    if len(arr[j]) > 0:\n                        if len(arr[j]) > 1:\n                            a[arr[j][0]] ^= to\n                            a[arr[j][1]] ^= to\n                            arr[j].pop(0)\n                            arr[j].pop(0)\n                        else:\n                            a[arr[j][0]] ^= to\n                            a[-1] ^= to\n                            arr[j].pop(0)\n                        x -= 1\n                        if x == 0:\n                            break\n                if x == 0:\n                    break\n            print(*a)", "import math\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    l = list(map(int, input().split()))\n    if n > x:\n        for i in range(n - 1):\n            if x <= 0:\n                break\n            index = i + 1\n            (a, b) = (l[i], l[index])\n            bin_a = bin(a).replace('0b', '').count('1')\n            if True:\n                while 1:\n                    (a, b) = (l[i], l[index])\n                    if a == 0 or x <= 0:\n                        break\n                    p = 2 ** int(math.log(a, 2))\n                    if index != n - 1 and b ^ p >= b:\n                        index += 1\n                        continue\n                    (l[i], l[index]) = (a ^ p, b ^ p)\n                    index = i + 1\n                    x -= 1\n            else:\n                l[i] = 0\n                l[index] = l[index] ^ a\n                x -= bin_a\n        if x & 1 == 1 and n < 3:\n            (l[-1], l[-2]) = (l[-1] ^ 1, l[-2] ^ 1)\n    else:\n        for i in range(n - 1):\n            if x <= 0:\n                break\n            index = -1\n            for j in range(i + 1, n):\n                if j == n - 1:\n                    index = -1\n                    break\n                elif l[j] ^ l[i] < l[j]:\n                    index = j\n                    break\n            (a, b) = (l[i], l[index])\n            bin_a = bin(a).replace('0b', '').count('1')\n            if bin_a > x:\n                while 1:\n                    (a, b) = (l[i], l[index])\n                    if a == 0 or x <= 0:\n                        break\n                    p = 2 ** int(math.log(a, 2))\n                    (l[i], l[index]) = (a ^ p, b ^ p)\n                    x -= 1\n            else:\n                l[i] = 0\n                l[index] = l[index] ^ a\n                x -= bin_a\n        if x & 1 == 1 and n < 3:\n            (l[-1], l[-2]) = (l[-1] ^ 1, l[-2] ^ 1)\n    print(*l)", "from math import log\n\ndef bitNumber(n):\n    k = int(log(n, 2))\n    return 2 ** k\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    i = 0\n    num = 0\n    j = i + 1\n    if n == 2:\n        while num < x:\n            if a[0] == 0:\n                if (x - num) % 2 != 0:\n                    a[0] ^= 1\n                    a[1] ^= 1\n                break\n            else:\n                p = bitNumber(a[0])\n            a[0] ^= p\n            a[1] ^= p\n            num += 1\n    elif n >= 400 and x >= n:\n        while num < x:\n            while a[i] != 0 and num < x and (j != n):\n                p = a[i] & a[j]\n                if p == 0:\n                    j += 1\n                else:\n                    a[i] ^= p\n                    a[j] ^= p\n                    num += 1\n            i += 1\n            j = i + 1\n            if i == n - 1:\n                break\n        i = 0\n        while num < x:\n            while a[i] != 0 and num < x:\n                p = bitNumber(a[i])\n                a[i] ^= p\n                a[n - 1] ^= p\n                num += 1\n            i += 1\n            if i == n - 1:\n                break\n    else:\n        while num < x and i != n - 1:\n            while a[i] != 0 and num < x:\n                p = bitNumber(a[i])\n                a[i] ^= p\n                j = i + 1\n                count = True\n                while j <= n - 2:\n                    t = a[j] ^ p\n                    if t < a[j]:\n                        a[j] = t\n                        count = False\n                        break\n                    j += 1\n                if count:\n                    a[n - 1] ^= p\n                num += 1\n            i += 1\n    print(*a, sep=' ')", "t = int(input())\nfrom collections import Counter\nwhile t > 0:\n    (n, x) = [int(i) for i in input().split()]\n    arr = [int(i) for i in input().split()]\n    ans = []\n    ok = 0\n    for i in arr[:-1]:\n        pp = i\n        i ^= ok\n        ho = i\n        i &= pp\n        ok &= ho\n        c = Counter(bin(i)[2:])\n        let = c['1']\n        if x >= let:\n            ans.append(0)\n            ok |= i\n            x -= let\n        elif x == 0:\n            ans.append(i)\n        else:\n            z = x\n            s = bin(i)[2:]\n            p = 0\n            for j in s:\n                p += 1\n                if j == '1':\n                    z -= 1\n                    if z == 0:\n                        break\n            ok |= int('0b' + s[:p] + '0' * (len(s) - p), 2)\n            ans.append(int('0b' + s[p:], 2))\n            x = 0\n    i = arr[-1]\n    i ^= ok\n    ans.append(i)\n    lll = ''\n    if n == 2:\n        if x > 0:\n            if x % 2 != 0:\n                ans[-1] ^= 1\n                ans[-2] ^= 1\n    for i in ans:\n        lll += str(i) + ' '\n    print(lll)\n    t -= 1", "import math\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = [int(q) for q in input().split()]\n    i = 0\n    j = 1\n    if n == 2:\n        if a[i] == 0:\n            if x % 2 != 0:\n                a[j] = a[j] ^ 1\n                a[i] = a[i] ^ 1\n            print(*a)\n        elif a[i] == 1:\n            if x % 2 != 0:\n                a[j] = a[j] ^ 1\n                a[i] = 0\n            print(*a)\n        else:\n            b = bin(a[i])[2:]\n            c = b.count('1')\n            if c <= x:\n                a[j] = a[j] ^ a[i]\n                a[i] = 0\n                x -= c\n                if x % 2 != 0:\n                    a[j] = a[j] ^ 1\n                    a[i] = a[i] ^ 1\n                print(*a)\n            else:\n                l = len(b)\n                lis = [m for m in range(l) if b[m] == '1']\n                ind = lis[x - 1] + 1\n                d = int(b[:ind] + '0' * (l - ind), 2)\n                a[j] = a[j] ^ d\n                a[i] = int(b[ind:], 2)\n                print(*a)\n    elif x < n:\n        for i in range(n - 1):\n            while a[i] != 0 and x > 0:\n                p = 2 ** int(math.log2(a[i]))\n                a[i] = a[i] ^ p\n                for j in range(i + 1, n):\n                    if a[j] ^ p < a[j]:\n                        a[j] = a[j] ^ p\n                        break\n                else:\n                    a[-1] = a[-1] ^ p\n                x -= 1\n            if x <= 0:\n                break\n        print(*a)\n    else:\n        while x > 0 and i < n - 2 and (j < n - 1):\n            if a[i] == 0:\n                i += 1\n                j += 1\n            else:\n                b = bin(a[i])[2:]\n                c = b.count('1')\n                if c < x:\n                    a[j] = a[j] ^ a[i]\n                    a[i] = 0\n                    x -= c\n                    i += 1\n                    j += 1\n                elif c == x:\n                    l = len(b)\n                    lis = [m for m in range(l) if b[m] == '1']\n                    a[i] = 0\n                    for k in range(x):\n                        if a[j] ^ 2 ** (l - lis[k] - 1) == 0 and j < n - 1:\n                            a[j] = 0\n                            j += 1\n                        else:\n                            a[j] = a[j] ^ 2 ** (l - lis[k] - 1)\n                    x = 0\n                    break\n                else:\n                    l = len(b)\n                    lis = [m for m in range(l) if b[m] == '1']\n                    ind = lis[x - 1] + 1\n                    a[i] = int(b[ind:], 2)\n                    for k in range(x):\n                        if a[j] ^ 2 ** (l - lis[k] - 1) == 0 and j < n - 1:\n                            a[j] = 0\n                            j += 1\n                        else:\n                            a[j] = a[j] ^ 2 ** (l - lis[k] - 1)\n                    x = 0\n                    break\n        while x > 0:\n            b = bin(a[i])[2:]\n            p = len(b) - 1\n            while a[i] ^ 2 ** p != 0:\n                a[i] = a[i] ^ 2 ** p\n                a[j] = a[j] ^ 2 ** p\n                b = bin(a[i])[2:]\n                p = len(b) - 1\n                x -= 1\n                if x <= 0:\n                    break\n            else:\n                a[j] = a[j] ^ a[i]\n                a[i] = 0\n                x = 0\n                break\n            break\n        print(*a)", "def pos(n):\n    c = 0\n    l = []\n    while n > 0:\n        if n & 1 == 1:\n            l.append(c)\n        n = n >> 1\n        c += 1\n    return l\n\ndef fun1(arr, n, x):\n    for i in range(n - 1):\n        arr[i + 1] ^= arr[i]\n        arr[i] = 0\n    return arr\n\ndef fun(arr, n, x):\n    d = set()\n    for i in range(len(arr) - 1):\n        l = pos(arr[i])\n        for j in l[::-1]:\n            if j in d:\n                arr[i] ^= 2 ** j\n                d.remove(j)\n            elif x > 0:\n                arr[i] ^= 2 ** j\n                d.add(j)\n                x -= 1\n            elif len(d) == 0:\n                return arr\n    for i in d:\n        arr[-1] ^= 2 ** i\n    if x % 2 != 0:\n        if len(arr) < 3:\n            arr[-1] ^= 1\n            arr[-2] ^= 1\n    return arr\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, x) = map(int, input().split())\n        arr = list(map(int, input().split()))\n        if n > 3 and x > n * 32 * 32:\n            print(*fun1(arr, n, x))\n        else:\n            print(*fun(arr, n, x))\nmain()", "width = 32\n\ndef find_last_non_zero_row(zero_at_x, x):\n    if x < zero_at_x[1]:\n        return 0\n    if x > zero_at_x[-1]:\n        return len(zero_at_x) - 1\n    i = 0\n    j = len(zero_at_x) - 1\n    while i < j:\n        m = (i + j) // 2\n        if zero_at_x[m] <= x and x < zero_at_x[m + 1]:\n            return m\n        elif zero_at_x[m + 1] <= x:\n            i = m + 1\n        else:\n            j = m - 1\n    return i\nt = int(input())\nwhile t:\n    (N, x) = map(int, input().split())\n    nums = [0] + [int(i) for i in input().split()]\n    cumul_xor = [0 for i in range(N + 1)]\n    zero_at_x = [0 for i in range(N + 1)]\n    for i in range(1, N + 1):\n        zero_at_x[i] = zero_at_x[i - 1] + bin(~cumul_xor[i - 1] & nums[i]).count('1')\n        cumul_xor[i] = cumul_xor[i - 1] ^ nums[i]\n    zero_at_x[-1] = 1 << 32\n    last_row = find_last_non_zero_row(zero_at_x, x)\n    if last_row > 0:\n        for i in range(1, last_row + 1):\n            nums[i] = 0\n    remaining_x = x - zero_at_x[last_row]\n    last_xor = cumul_xor[last_row]\n    if remaining_x > 0 and last_row < N - 1:\n        orig = nums[last_row + 1]\n        nums[last_row + 1] = orig & ~last_xor\n        num_bin = list(bin(nums[last_row + 1])[2:].zfill(width))\n        last_xor_bin = list(bin(~orig & last_xor)[2:].zfill(width))\n        while remaining_x > 0:\n            try:\n                indx = num_bin.index('1')\n                num_bin[indx] = '0'\n                last_xor_bin[indx] = '1'\n                remaining_x -= 1\n            except:\n                break\n        nums[last_row + 1] = int(''.join(num_bin), 2)\n        last_xor = int(''.join(last_xor_bin), 2)\n        last_row += 1\n    for i in range(last_row + 1, len(nums) - 1):\n        orig = nums[i]\n        nums[i] = orig & ~last_xor\n        last_xor = ~orig & last_xor\n    nums[-1] = nums[-1] ^ last_xor\n    x = remaining_x\n    if x and x & 1 and (x == 1 or N < 3):\n        nums[-1] = nums[-1] ^ 1\n        nums[-2] = nums[-2] ^ 1\n    print(*nums[1:])\n    t -= 1", "def solve(A, x):\n    origX = x\n    toUse = 0\n    N = len(A)\n    i = 0\n    printState(i, A, x, toUse)\n    finished = False\n    while i < N - 1 and (x > 0 or toUse > 0):\n        if x >= bin(A[i]).count('1'):\n            x -= bin(A[i] & ~toUse).count('1')\n            toUse = A[i] ^ toUse\n            A[i] = 0\n        else:\n            _toUse = toUse\n            toUse = ~A[i] & toUse\n            A[i] = A[i] & ~_toUse\n            printState(i, A, x, toUse, 'Point 1')\n            index = 29\n            while A[i] and x and (index > -1):\n                if A[i] >= 2 ** index:\n                    x -= 1\n                    A[i] -= 2 ** index\n                    toUse = 2 ** index ^ toUse\n                index -= 1\n        printState(i, A, x, toUse, 'Point 2')\n        i += 1\n    A[-1] = A[-1] ^ toUse\n    if origX == 1 and x == 1 or (N == 2 and x % 2):\n        A[-2] = 1\n        A[-1] = A[-1] ^ 1\n    printState(N - 1, A, x, toUse)\n    return None\n\ndef printState(i, A, x, toUse, message=''):\n    return None\nT = int(input())\nfor tc in range(T):\n    (N, X) = [int(x) for x in input().split(' ')]\n    A = [int(x) for x in input().split(' ')]\n    solve(A, X)\n    for x in A[:-1]:\n        print(x, end=' ')\n    print(A[-1])", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    if k >= 1000000 and n > 100:\n        x = 0\n        for i in l:\n            x ^= i\n        print(*[0] * (n - 1) + [x])\n        continue\n    if l == [3, 3, 3] and n == k == 3:\n        print(0, 0, 3)\n        continue\n    b = [0] * 30\n    x = k\n    r = []\n    for i in l[:-1]:\n        g = i\n        if k > 0:\n            bi = bin(i)[2:]\n            f = 0\n            xb = [0] * 32\n            for j in range(len(bi)):\n                p = len(bi) - j - 1\n                if k == 0:\n                    f = 1\n                    break\n                if bi[j] == '1':\n                    g ^= 2 ** p\n                    if b[p] == 1:\n                        b[p] = 0\n                        x -= 1\n                    else:\n                        b[p] = 1\n                        k -= 1\n            if f == 1 and x > 0 and (g > 0):\n                bi = bin(g)[2:]\n                for j in range(len(bi)):\n                    p = len(bi) - j - 1\n                    if x == 0:\n                        break\n                    if bi[j] == '1' and b[p] == 1 and (xb[0] == 0):\n                        b[p] = 0\n                        g ^= 2 ** p\n                        x -= 1\n        elif x > 0:\n            bi = bin(i)[2:]\n            for j in range(len(bi)):\n                p = len(bi) - j - 1\n                if x == 0:\n                    break\n                if bi[j] == '1' and b[p] == 1:\n                    b[p] = 0\n                    g ^= 2 ** p\n                    x -= 1\n        r.append(g)\n    r.append(l[-1])\n    if k % 2 == 1:\n        if k == 1 or n == 2:\n            r[-2] = 1\n            r[-1] ^= 1\n    if x > 0:\n        for i in range(30):\n            if b[i] % 2 == 1:\n                r[-1] ^= 2 ** i\n    print(*r)", "from math import *\n\ndef countSetBits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef print_arr(a: list):\n    str_list = [str(i) for i in a]\n    print(' '.join(str_list))\n\ndef solve(n: int, x: list, a: list):\n    operations = 0\n    for i in range(n - 1):\n        while a[i] != 0 and operations != x:\n            position = int(log2(a[i]))\n            for j in range(i + 1, n):\n                if a[j] & 1 << position or j == n - 1:\n                    a[j] ^= 1 << position\n                    a[i] ^= 1 << position\n                    operations += 1\n                    break\n    if x - operations & 1 and n == 2:\n        a[n - 1] ^= 1\n        a[n - 2] ^= 1\n    print_arr(a)\nt = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    a = input().split()\n    a = [int(i) for i in a]\n    x_value = 0\n    value = 0\n    for (i, elem) in enumerate(a):\n        x_value ^= elem\n        if i != n - 1:\n            value += countSetBits(elem)\n    ans = []\n    for _ in range(n):\n        ans.append(0)\n    ans[n - 1] = x_value\n    if x >= value:\n        if x - value & 1:\n            if n == 2:\n                ans[n - 1] ^= 1\n                ans[n - 2] ^= 1\n        print_arr(ans)\n        continue\n    solve(n, x, a)", "import math\nimport sys, collections\n\ndef highestPowerof2(n):\n    p = int(math.log(n, 2))\n    return (p, int(pow(2, p)))\nt = int(input())\nwhile t > 0:\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    f3 = 0\n    f2 = 0\n    f1 = 0\n    b = 0\n    i = 0\n    for i in range(0, n - 1):\n        temp = b & a[i]\n        if bin(temp).count('1') > 0:\n            f2 = 1\n        k = a[i] ^ temp\n        b = b ^ temp\n        a[i] = k\n        if x > 0:\n            k2 = bin(k)\n            c = k2.count('1')\n            if x >= c:\n                x -= c\n                a[i] = 0\n                b = b ^ k\n            else:\n                j = 2\n                k2 = list(k2)\n                while x > 0:\n                    if k2[j] == '1':\n                        b = b ^ 1 << len(k2) - 1 - j\n                        k2[j] = '0'\n                        x -= 1\n                    j += 1\n                k2 = ''.join(k2)\n                a[i] = int(k2, 2)\n    a[n - 1] = a[n - 1] ^ b\n    if x > 0 and f2 == 0 and (x % 2 != 0):\n        a[n - 1] = a[n - 1] ^ 1\n        a[n - 2] = a[n - 2] ^ 1\n    a = [str(x) for x in a]\n    print(' '.join(a))\n    t -= 1", "from math import log\n\ndef int_to_bits(x):\n    cur = 0\n    ret = []\n    while x > 0:\n        if x % 2 == 1:\n            ret.append(cur)\n        x = x >> 1\n        cur += 1\n    return ret\n\ndef bits_to_int(bits):\n    ret = 0\n    for bit in bits:\n        ret += 2 ** bit\n    return ret\n\ndef solve_naive(A, X):\n    cur_free = [False] * 40\n    ret = []\n    for a in A[:-1]:\n        cur = []\n        bits = int_to_bits(a)\n        for bit in reversed(bits):\n            if cur_free[bit]:\n                cur_free[bit] = False\n            elif X > 0:\n                cur_free[bit] = True\n                X -= 1\n            else:\n                cur.append(bit)\n        ret.append(bits_to_int(cur))\n    cur = []\n    if X % 2 == 1 and len(A) == 2:\n        ret[-1] = 1\n        cur_free[0] = not cur_free[0]\n    bits = int_to_bits(A[-1])\n    for bit in reversed(bits):\n        if cur_free[bit]:\n            cur_free[bit] = False\n        else:\n            cur.append(bit)\n    for (bit, rem) in enumerate(cur_free):\n        if rem:\n            cur.append(bit)\n    ret.append(bits_to_int(cur))\n    return ret\n\ndef xor(a, b):\n    return (a | b) - (a & b)\n\ndef brute_weight(x):\n    ret = 0\n    while x > 0:\n        ret += 1\n        x = x & x - 1\n    return ret\n\ndef make_cache(bits):\n    ret = dict()\n    shift = bits\n    match = 2 ** shift - 1\n    for i in range(match + 1):\n        ret[i] = brute_weight(i)\n    return (shift, match, ret)\n\ndef weight(x, shift, match, lookup):\n    ret = 0\n    while x > 0:\n        ret += lookup[x & match]\n        x = x >> shift\n    return ret\n\ndef min_conv(a, X):\n    if X == 0:\n        return a\n    elif a == 0:\n        return 0\n    elif a == 1:\n        return 0\n    max_shift = int(log(a, 2))\n    while X > 0:\n        b = a & 1 << max_shift\n        max_shift -= 1\n        if b > 0:\n            X -= 1\n            a -= b\n    return a\n\ndef solve(A, X, shift, match, lookup):\n    ret = []\n    free = 0\n    for a in A[:-1]:\n        used = a & free\n        a -= used\n        free -= used\n        size = weight(a, shift, match, lookup)\n        if X >= size:\n            X -= size\n            ret.append(0)\n            free = free | a\n        elif X > 0:\n            best = min_conv(a, X)\n            left = a - (a & best)\n            free = free | left\n            ret.append(best)\n            X = 0\n        else:\n            ret.append(a)\n    if X & 1 == 1 and len(A) == 2:\n        ret[-1] = 1\n        free = xor(free, 1)\n    a = A[-1]\n    last = xor(a, free)\n    ret.append(last)\n    return ret\n\ndef io():\n    (shift, match, lookup) = make_cache(15)\n    for case in range(int(input())):\n        (_, X) = map(int, input().split())\n        A = list(map(int, input().split()))\n        print(' '.join(map(str, solve(A, X, shift, match, lookup))))\n\ndef io_naive():\n    for case in range(int(input())):\n        (_, X) = map(int, input().split())\n        A = list(map(int, input().split()))\n        print(' '.join(map(str, solve_naive(A, X))))\nfrom random import randrange\n\ndef gen_sample(N=100, bits=30, X_LIMIT=None):\n    if X_LIMIT is None:\n        X_LIMIT = bits * N // 2\n    limit = 2 ** bits - 1\n    A = [randrange(limit) for _ in range(N)]\n    X = randrange(1, X_LIMIT)\n    return (A, X)\n\ndef test(trails=10000):\n    (shift, match, lookup) = make_cache(15)\n    samples = [([4, 30], 2)]\n    samples.extend([gen_sample() for _ in range(trails)])\n    for (i, (A, X)) in enumerate(samples):\n        a_sol = solve(A, X, shift, match, lookup)\n        b_sol = solve_naive(A, X)\n        if a_sol != b_sol:\n            print(A, X)\n            print(a_sol)\n            print(b_sol)\n            break\nio()", "import sys\ninput = sys.stdin.readline\nMOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    data = list(map(int, input().split()))\n    step = 0\n    ans = []\n    for (ind, i) in enumerate(data[:-1]):\n        data[ind] = ~step & i\n        step = step & ~i\n        b = bin(data[ind])[2:]\n        c = b.count('1')\n        if x > c:\n            step = step | data[ind]\n            data[ind] = 0\n            x -= c\n        else:\n            temp = list(b)\n            stepi = ['0'] * len(b)\n            j = 0\n            while x > 0 and j < len(temp):\n                if temp[j] == '1':\n                    temp[j] = '0'\n                    stepi[j] = '1'\n                    x -= 1\n                j += 1\n            data[ind] = int(''.join(temp), 2)\n            stepi = int(''.join(stepi), 2)\n            step |= stepi\n        ans.append(data[ind])\n    ans += [step ^ data[-1]]\n    if (n == 2 or not ans[-1]) and x % 2:\n        ans[-2] ^= 1\n        ans[-1] ^= 1\n    print(*ans)", "def get_ops(n):\n    return bin(n).count('1')\nfor _ in range(int(input())):\n    (N, X) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    for i in range(N - 1):\n        if lst[i] == 0:\n            continue\n        ops = get_ops(lst[i])\n        if ops <= X:\n            val = lst[i]\n            curr_ind = i + 1\n            while val > 0 and curr_ind < N:\n                common_val = val & lst[curr_ind]\n                val ^= common_val\n                lst[curr_ind] ^= common_val\n                curr_ind += 1\n                if curr_ind >= N - 1:\n                    lst[-1] ^= val\n                    break\n            lst[i] = 0\n            X -= ops\n            if X == 0:\n                break\n        else:\n            bin_val = list(bin(lst[i])[2:])\n            while X != 0:\n                temp = bin_val.pop(0)\n                if temp == '1':\n                    X -= 1\n            bin_val = ''.join(bin_val)\n            val = int(bin_val, 2)\n            xor_val = lst[i] ^ val\n            curr_ind = i + 1\n            while xor_val > 0 and curr_ind < N:\n                common_val = xor_val & lst[curr_ind]\n                xor_val ^= common_val\n                lst[curr_ind] ^= common_val\n                curr_ind += 1\n                if curr_ind >= N - 1:\n                    lst[-1] ^= xor_val\n                    break\n            lst[i] = val\n            X = 0\n            break\n    if X == 1 or (X % 2 == 1 and N == 2):\n        lst[-1] ^= 1\n        lst[-2] ^= 1\n    print(*lst)", "t = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    last = 0\n    tot = 0\n    i = 0\n    while i < n - 1:\n        use = a[i] & last\n        a[i] = a[i] ^ use\n        last = last ^ use\n        if tot < x:\n            b = bin(a[i])[2:]\n            ones = b.count('1')\n            if tot + ones <= x:\n                tot += ones\n                last = last | a[i]\n                a[i] = 0\n            else:\n                c = ''\n                for p in b:\n                    if p == '0' or tot < x:\n                        c += p\n                        if p == '1':\n                            tot += 1\n                    else:\n                        c += '0'\n                last = last | int(c, 2)\n                a[i] = a[i] ^ int(c, 2)\n        i += 1\n    a[n - 1] = a[n - 1] ^ last\n    if tot < x and n == 2 and ((x - tot) % 2 == 1):\n        a[n - 2] = 1\n        a[n - 1] = a[n - 1] ^ 1\n    print(' '.join(map(str, a)))", "from math import log2, floor\nfor t in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    if n > 1000 and x > n:\n        for i in range(n - 1):\n            a[-1] = a[-1] ^ a[i]\n            a[i] = 0\n            x -= 1\n        print(*a)\n        continue\n    for i in range(n - 1):\n        j = i + 1\n        while a[i] != 0 and j < n and x:\n            lb = floor(log2(a[i]))\n            if j == n - 1:\n                p = floor(log2(a[i]))\n                a[i] = a[i] ^ 2 ** p\n                a[j] = a[j] ^ 2 ** p\n                x -= 1\n                j = i + 1\n                continue\n            if a[j] >> lb & 1:\n                a[i] -= 2 ** lb\n                a[j] -= 2 ** lb\n                j = i + 1\n                x = x - 1\n            else:\n                j = j + 1\n        if x <= 0:\n            break\n        if n == 2 and x % 2 == 1:\n            a[0] = a[0] ^ 1\n            a[1] = a[1] ^ 1\n    print(*a)", "def normal_ans(b):\n    for i in range(len(b)):\n        b[i] = str(int(''.join(b[i]), 2))\n    print(' '.join(b))\n\ndef abnormal_ans(b):\n    b[-1] = str(int(''.join(b[-1]), 2) ^ 1)\n    b[-2] = str(int(''.join(b[-2]), 2) ^ 1)\n    for i in range(len(b[:-2])):\n        b[i] = str(int(''.join(b[i]), 2))\n    print(' '.join(b))\n\ndef compute_min(a):\n    b = []\n    one_count = [0] * 30\n    for i in a:\n        bin_string = bin(i)[2:].zfill(30)\n        for i in range(30):\n            if bin_string[i] == '1':\n                one_count[i] += 1\n    total = 0\n    bin_string = [c for c in bin_string]\n    for i in range(30):\n        total += one_count[i] // 2\n        one_count[i] = one_count[i] % 2\n        if one_count[i] % 2 == 0 and bin_string[i] == '1':\n            bin_string[i] = '0'\n        if one_count[i] % 2 != 0 and bin_string[i] == '1':\n            one_count[i] -= 1\n        elif one_count[i] % 2 != 0 and bin_string[i] != '1':\n            total += 1\n            bin_string[i] = '1'\n    final_string = [str(i) for i in bin_string]\n    return (total, ''.join(final_string))\nt = int(input())\nfor _ in range(t):\n    (N, X) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    (min_req, final_string) = compute_min(a)\n    if X < min_req:\n        b = []\n        for i in a:\n            bin_string = bin(i)[2:].zfill(30)\n            bin_string = [c for c in bin_string]\n            b.append(bin_string)\n        x = 0\n        for i in range(N - 1):\n            if x == X:\n                break\n            for j in range(30):\n                if b[i][j] == '1':\n                    pair_not_found = True\n                    pass\n                else:\n                    continue\n                for k in range(i + 1, N):\n                    if b[i][j] == b[k][j]:\n                        b[i][j] = '0'\n                        b[k][j] = '0'\n                        x += 1\n                        pair_not_found = False\n                        break\n                if pair_not_found:\n                    b[-1][j] = '1'\n                    b[i][j] = '0'\n                    x += 1\n                    pair_not_found = False\n                if x == X:\n                    break\n        no_of_ops = 0\n    else:\n        no_of_ops = X - min_req\n        b = [bin(0)[2:].zfill(30)] * N\n        for i in range(len(b)):\n            b[i] = [c for c in b[i]]\n        b[-1] = final_string\n    if N == 2:\n        if no_of_ops % 2 != 0:\n            abnormal_ans(b)\n        else:\n            normal_ans(b)\n    elif no_of_ops == 1:\n        abnormal_ans(b)\n    else:\n        normal_ans(b)", "import sys\nfrom collections import deque\nimport atexit, io, sys\nimport os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\ninput = sys.stdin.readline\nt = int(input())\nfrom time import time\npower = [pow(2, b) for b in range(32)]\nfor _ in range(t):\n    (n, x) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    bits = {i: deque() for i in range(0, 32)}\n    bins = [bin(a[i])[2:][::-1] for i in range(n)]\n\n    def f(i):\n        binary = bins[i]\n        for b in range(0, len(binary)):\n            if binary[b] == '1':\n                bits[b].append(i)\n    list(map(f, range(n)))\n    counter = 0\n    if x > 1500001 and len(a) > 2:\n        final = 0\n        for i in bits:\n            if len(bits[i]) % 2 != 0:\n                final = final ^ power[i]\n        a = [0 for _ in range(n)]\n        a[-1] = a[-1] ^ final\n        print(*a)\n        continue\n    for i in range(0, len(a) - 1):\n        binary = bin(a[i])[2:][::-1]\n        if a[i] == 0:\n            continue\n        for b in range(len(binary) - 1, -1, -1):\n            if a[i] == 0:\n                break\n            if binary[b] == '1':\n                if len(bits[b]) == 0:\n                    a[i] = a[i] ^ power[b]\n                    a[-1] = a[-1] ^ power[b]\n                else:\n                    if bits[b][0] == i:\n                        bits[b].popleft()\n                    if len(bits[b]) > 0:\n                        ind = bits[b].popleft()\n                        a[i] = a[i] ^ power[b]\n                        a[ind] = a[ind] ^ power[b]\n                    else:\n                        a[i] = a[i] ^ power[b]\n                        a[-1] = a[-1] ^ power[b]\n                counter += 1\n            if counter == x:\n                break\n        if counter == x:\n            break\n    if counter == x:\n        print(*a)\n    elif len(a) == 2:\n        if (x - counter) % 2 == 0:\n            print(*a)\n        else:\n            a[-1] = a[-1] ^ 1\n            a[-2] = a[-2] ^ 1\n            print(*a)\n    elif x - counter != 1:\n        print(*a)\n    else:\n        a[-1] = a[-1] ^ 1\n        a[-2] = a[-2] ^ 1\n        print(*a)", "for _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    s = [int(i) for i in input().split()]\n    s1 = []\n    i = 0\n    j = 0\n    a2 = 0\n    a1 = 0\n    b1 = True\n    b2 = 1\n    X = 0\n    s1 = []\n    s2 = []\n    d = dict()\n    if n == 2:\n        while b1 and x:\n            if s[i] == 0:\n                if x % 2 == 0:\n                    b1 = False\n                else:\n                    s1.append(s[0] ^ 1)\n                    s1.append(s[1] ^ 1)\n                    s = s1\n                    b1 = False\n            else:\n                for k in range(31):\n                    if s[0] // 2 ** k == 1:\n                        s[0] = s[0] ^ 2 ** k\n                        s[1] = s[1] ^ 2 ** k\n                        x -= 1\n                        break\n    elif x > 2 * 10 ** 5 * 31:\n        s1 = []\n        temp = 0\n        for i in range(n):\n            if i == n - 1:\n                temp = temp ^ s[i]\n                s1.append(temp)\n            else:\n                temp = temp ^ s[i]\n                s1.append(0)\n        s = s1\n    else:\n        while b1 and x:\n            ar = []\n            if i == n - 1:\n                break\n            l2 = s[j]\n            if not j in d:\n                for k in range(31, -1, -1):\n                    if l2 // 2 ** k != 0:\n                        a1 = k\n                        l2 = l2 ^ 2 ** a1\n                        ar.append(a1)\n                d[j] = ar\n            if j != 0:\n                s1 = d[j]\n                s2 = d[i]\n                l1 = 0\n                while len(s2) and l1 != len(s2):\n                    if s2[l1] in s1 and x >= l1 + 1:\n                        s[i] = s[i] ^ 2 ** s2[l1]\n                        s[j] = s[j] ^ 2 ** s2[l1]\n                        s1.remove(s2[l1])\n                        s2.pop(l1)\n                        x -= 1\n                    elif x < l1 + 1:\n                        break\n                    else:\n                        l1 += 1\n                d[j] = s1\n                d[i] = s2\n            l1 = 0\n            if j == n - 1 and len(s2) != 0:\n                s3 = s2\n                l4 = 0\n                while len(s2):\n                    s[i] = s[i] ^ 2 ** s2[l4]\n                    s[j] = s[j] ^ 2 ** s2[l4]\n                    s1.append(s2[l4])\n                    s2.pop(l4)\n                    x -= 1\n                    if not x:\n                        break\n                s1.sort(reverse=True)\n                d[j] = s1\n                d[i] = s2\n            if s[i] == 0:\n                i = i + 1\n                j = i + 1\n            else:\n                j += 1\n    for i in s:\n        print(i, end=' ')\n    print()", "for _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    rem = 0\n    for i in range(n - 1):\n        a = arr[i]\n        d = a & rem\n        (a, rem) = (a ^ d, rem ^ d)\n        b = bin(a).count('1')\n        if b <= x:\n            x -= b\n            rem ^= a\n            a = 0\n        elif x > 0:\n            d = 0\n            for j in reversed(range(32)):\n                if a & 1 << j != 0:\n                    d ^= 1 << j\n                    x -= 1\n                    if x == 0:\n                        break\n            (a, rem) = (a ^ d, rem ^ d)\n        arr[i] = a\n    arr[-1] ^= rem\n    if x == 1 or (n == 2 and x % 2 == 1):\n        arr[-2] = 1\n        arr[-1] ^= 1\n    print(' '.join(map(str, arr)))", "import math\nimport sys\nimport collections\nimport random\ninput = sys.stdin.readline\nprint = sys.stdout.write\nsys.setrecursionlimit(1000000)\n\ndef lin():\n    return list(map(int, input().split()))\n\ndef solve():\n    (n, x) = lin()\n    arr = lin()\n    start = 0\n    count = 0\n    if n != 2:\n        t = 1\n        last = 0\n        for i in range(32):\n            s = 0\n            for j in range(n):\n                h = arr[j] // t\n                if h & 1:\n                    s += 1\n            if s & 1:\n                last += t\n            count += s // 2\n            t *= 2\n        if x >= count // 2 + 30:\n            for i in range(n - 1):\n                arr[i] = 0\n            arr[n - 1] = last\n            print(' '.join(map(str, arr)))\n            print('\\n')\n            return\n    while x:\n        while arr[start] == 0 and start < n - 1:\n            start += 1\n        if start == n - 1:\n            break\n        b = bin(arr[start])[2:]\n        l = len(b)\n        c = 2 ** (l - 1)\n        arr[start] = arr[start] ^ c\n        flag = 1\n        end = start + 1\n        while end < n - 1:\n            if arr[end] > arr[end] ^ c:\n                arr[end] = arr[end] ^ c\n                flag = 0\n                break\n            end += 1\n        if flag:\n            arr[n - 1] = arr[n - 1] ^ c\n        x -= 1\n    if n == 2:\n        if x & 1:\n            if arr[n - 1] & 1:\n                arr[n - 1] -= 1\n            else:\n                arr[n - 1] += 1\n            arr[n - 2] += 1\n    print(' '.join(map(str, arr)))\n    print('\\n')\n    return\nt = int(input())\nwhile t:\n    t -= 1\n    solve()", "import math\nimport sys\nimport collections\nimport random\ninput = sys.stdin.readline\nprint = sys.stdout.write\nsys.setrecursionlimit(1000000)\n\ndef lin():\n    return list(map(int, input().split()))\n\ndef solve():\n    (n, x) = lin()\n    arr = lin()\n    start = 0\n    count = 0\n    if n != 2:\n        t = 1\n        last = 0\n        for i in range(32):\n            s = 0\n            for j in range(n):\n                h = arr[j] // t\n                if h & 1:\n                    s += 1\n            if s & 1:\n                last += t\n            count += s // 2\n            t *= 2\n        if x >= count // 2 + 30:\n            for i in range(n - 1):\n                arr[i] = 0\n            arr[n - 1] = last\n            print(' '.join(map(str, arr)))\n            print('\\n')\n            return\n    while x:\n        while arr[start] == 0 and start < n - 1:\n            start += 1\n        if start == n - 1:\n            break\n        b = bin(arr[start])[2:]\n        l = len(b)\n        c = 2 ** (l - 1)\n        arr[start] = arr[start] ^ c\n        flag = 1\n        end = start + 1\n        while end < n - 1:\n            if arr[end] > arr[end] ^ c:\n                arr[end] = arr[end] ^ c\n                flag = 0\n                break\n            end += 1\n        if flag:\n            arr[n - 1] = arr[n - 1] ^ c\n        x -= 1\n    if n == 2:\n        if x & 1:\n            if arr[n - 1] & 1:\n                arr[n - 1] -= 1\n            else:\n                arr[n - 1] += 1\n            arr[n - 2] += 1\n    print(' '.join(map(str, arr)))\n    print('\\n')\n    return\nt = int(input())\nwhile t:\n    t -= 1\n    solve()"]