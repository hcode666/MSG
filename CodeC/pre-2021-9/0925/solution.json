["from heapq import *\nt = int(input())\nfor _ in range(t):\n    (n, k, x, m, s) = map(int, input().split())\n    adj = [set() for i in range(n + 1)]\n    dist = [float('inf') for i in range(n + 1)]\n    if s <= k:\n        for __ in range(m):\n            (a, b, c) = map(int, input().split())\n            adj[a - 1].add((b - 1, c))\n            adj[b - 1].add((a - 1, c))\n        for i in range(k):\n            if i != s - 1:\n                adj[i].add((s - 1, x))\n                adj[s - 1].add((i, x))\n        for i in range(n):\n            if i < k:\n                dist[i] = x\n        vis = [0] * n\n        heap = [[0, s - 1]]\n        dist[s - 1] = 0\n        while heap:\n            no = heappop(heap)\n            if vis[no[1]] == 1:\n                continue\n            vis[no[1]] = 1\n            for i in adj[no[1]]:\n                if dist[i[0]] >= i[1] + no[0]:\n                    dist[i[0]] = i[1] + no[0]\n                    heappush(heap, [dist[i[0]], i[0]])\n        mi = min([dist[i] for i in range(k)])\n        for i in range(k):\n            dist[i] = min(dist[i], mi + x)\n        print(*dist[:-1])\n    else:\n        x *= 2\n        vis = [0] * (n + 1)\n        for i in range(k):\n            adj[i].add((n, x // 2))\n            adj[n].add((i, x // 2))\n        for __ in range(m):\n            (a, b, c) = map(int, input().split())\n            adj[a - 1].add((b - 1, c * 2))\n            adj[b - 1].add((a - 1, c * 2))\n        heap = [[0, s - 1]]\n        dist[s - 1] = 0\n        while heap:\n            no = heappop(heap)\n            if vis[no[1]] == 1:\n                continue\n            vis[no[1]] = 1\n            for i in adj[no[1]]:\n                if dist[i[0]] >= i[1] + no[0]:\n                    dist[i[0]] = i[1] + no[0]\n                    heappush(heap, [dist[i[0]], i[0]])\n        ma = min([dist[i] for i in range(k)])\n        for i in range(k):\n            dist[i] = min(dist[i], ma + x)\n        print(*[i // 2 for i in dist[:-1]])", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    (n, k, x, m, s) = map(int, input().split())\n    adj = [set() for i in range(n + 1)]\n    dist = [float('inf') for i in range(n + 1)]\n    if s <= k:\n        for __ in range(m):\n            (a, b, c) = map(int, input().split())\n            adj[a - 1].add((b - 1, c))\n            adj[b - 1].add((a - 1, c))\n        for i in range(k):\n            if i != s - 1:\n                adj[i].add((s - 1, x))\n                adj[s - 1].add((i, x))\n        for i in range(n):\n            if i < k:\n                dist[i] = x\n        vis = [0] * n\n        heap = [[0, s - 1]]\n        dist[s - 1] = 0\n        while heap:\n            no = heappop(heap)\n            if vis[no[1]] == 1:\n                continue\n            vis[no[1]] = 1\n            for i in adj[no[1]]:\n                if dist[i[0]] >= i[1] + no[0]:\n                    dist[i[0]] = i[1] + no[0]\n                    heappush(heap, [dist[i[0]], i[0]])\n        mi = min([dist[i] for i in range(k)])\n        for i in range(k):\n            dist[i] = min(dist[i], mi + x)\n        print(*dist[:-1])\n    else:\n        x *= 2\n        vis = [0] * (n + 1)\n        for i in range(k):\n            adj[i].add((n, x // 2))\n            adj[n].add((i, x // 2))\n        for __ in range(m):\n            (a, b, c) = map(int, input().split())\n            adj[a - 1].add((b - 1, c * 2))\n            adj[b - 1].add((a - 1, c * 2))\n        heap = [[0, s - 1]]\n        dist[s - 1] = 0\n        while heap:\n            no = heappop(heap)\n            if vis[no[1]] == 1:\n                continue\n            vis[no[1]] = 1\n            for i in adj[no[1]]:\n                if dist[i[0]] >= i[1] + no[0]:\n                    dist[i[0]] = i[1] + no[0]\n                    heappush(heap, [dist[i[0]], i[0]])\n        ma = min([dist[i] for i in range(k)])\n        for i in range(k):\n            dist[i] = min(dist[i], ma + x)\n        print(*[i // 2 for i in dist[:-1]])", "import heapq\nfor _ in range(int(input())):\n    (n, k, x, c, start) = map(int, input().split())\n    start -= 1\n    a = []\n    for i in range(n + 1):\n        a.append([{}, 0, 1000000000000.0])\n    for i in range(k):\n        a[i][0][n] = x / 2\n        a[n][0][i] = x / 2\n    for i in range(c):\n        (a1, b1, c1) = map(int, input().split())\n        a[a1 - 1][0][b1 - 1] = c1\n        a[b1 - 1][0][a1 - 1] = c1\n    a[start][2] = 0\n    h = [(0, start)]\n    heapq.heapify(h)\n    while h != []:\n        node = heapq.heappop(h)\n        if a[node[1]][1] == 0:\n            temp = a[node[1]][0]\n            for i in temp.keys():\n                if a[i][1] == 0:\n                    heapq.heappush(h, (node[0] + temp[i], i))\n                    if node[0] + temp[i] < a[i][2]:\n                        a[i][2] = node[0] + temp[i]\n            a[node[1]][1] = 1\n    for i in range(n):\n        print(int(a[i][2]), end=' ')\n    print('')", "from collections import defaultdict\nimport heapq\n\nclass Graph:\n\n    def __init__(self):\n        self.node = set()\n        self.edges = defaultdict(list)\n        self.distance = {}\n\n    def addNode(self, value):\n        self.node.add(value)\n\n    def addEdges(self, node1, node2, distance):\n        self.edges[node1].append(node2)\n        self.edges[node2].append(node1)\n        self.distance[node1, node2] = distance\n        self.distance[node2, node1] = distance\n\ndef dijkastra(graph, source, size):\n    h = []\n    dist = [10 ** 18] * (size + 2)\n    dist[source] = 0\n    heapq.heappush(h, (0, source))\n    while h:\n        (d, u) = heapq.heappop(h)\n        if dist[u] < d:\n            continue\n        for i in graph.edges[u]:\n            if dist[u] + graph.distance[i, u] < dist[i]:\n                dist[i] = dist[u] + graph.distance[i, u]\n                heapq.heappush(h, (dist[i], i))\n    return dist\nt = int(input())\nfor i in range(t):\n    g = Graph()\n    (n, k, x, m, s) = [int(x) for x in input().split()]\n    for i in range(1, k + 1):\n        g.addNode(i)\n        g.addNode(n + 1)\n        g.addEdges(i, n + 1, x)\n    for j in range(m):\n        (n1, n2, dist) = [int(x) for x in input().split()]\n        g.addNode(n1)\n        g.addNode(n2)\n        g.addEdges(n1, n2, dist * 2)\n    dist = dijkastra(g, s, n)\n    print(' '.join([str(int(x / 2)) for x in dist[1:n + 1]]))", "from collections import defaultdict\nimport heapq\n\nclass Graph:\n\n    def __init__(self):\n        self.node = set()\n        self.edges = defaultdict(list)\n        self.distance = {}\n\n    def addNode(self, value):\n        self.node.add(value)\n\n    def addEdges(self, node1, node2, distance):\n        self.edges[node1].append(node2)\n        self.edges[node2].append(node1)\n        self.distance[node1, node2] = distance\n        self.distance[node2, node1] = distance\n\ndef dijkastra(graph, source, size):\n    h = []\n    dist = [10 ** 18] * (size + 2)\n    dist[source] = 0\n    heapq.heappush(h, (0, source))\n    while h:\n        (d, u) = heapq.heappop(h)\n        for i in graph.edges[u]:\n            if dist[u] + graph.distance[i, u] < dist[i]:\n                dist[i] = dist[u] + graph.distance[i, u]\n                heapq.heappush(h, (dist[i], i))\n    return dist\nt = int(input())\nfor i in range(t):\n    g = Graph()\n    (n, k, x, m, s) = [int(x) for x in input().split()]\n    for i in range(1, k + 1):\n        g.addNode(i)\n        g.addNode(n + 1)\n        g.addEdges(i, n + 1, x)\n    for j in range(m):\n        (n1, n2, dist) = [int(x) for x in input().split()]\n        g.addNode(n1)\n        g.addNode(n2)\n        g.addEdges(n1, n2, dist * 2)\n    dist = dijkastra(g, s, n)\n    print(' '.join([str(int(x / 2)) for x in dist[1:n + 1]]))", "import heapq\n\ndef solve():\n    T = int(input())\n    for t in range(T):\n        (N, K, X, M, S) = map(int, input().split(' '))\n        adj_list = [[] for i in range(N + 1)]\n        for i in range(1, K + 1):\n            adj_list[0].append((i, X))\n            adj_list[i].append((0, 0))\n        for i in range(M):\n            (a, b, c) = map(int, input().split(' '))\n            adj_list[a].append((b, c))\n            adj_list[b].append((a, c))\n        dist = [10 ** 18 for i in range(N + 1)]\n        heap = []\n        heapq.heappush(heap, (0, S))\n        dist[S] = 0\n        while len(heap) > 0:\n            tup = heap[0]\n            u = tup[1]\n            heapq.heappop(heap)\n            for (v, weight) in adj_list[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    heapq.heappush(heap, (dist[v], v))\n        print(*dist[1:])\nsolve()", "import heapq\n\ndef solve():\n    T = int(input())\n    for t in range(T):\n        (N, K, X, M, S) = map(int, input().split(' '))\n        adj_list = [[] for i in range(N + 1)]\n        for i in range(1, K + 1):\n            adj_list[0].append((i, X))\n            adj_list[i].append((0, 0))\n        for i in range(M):\n            (a, b, c) = map(int, input().split(' '))\n            adj_list[a].append((b, c))\n            adj_list[b].append((a, c))\n        dist = [10 ** 18 for i in range(N + 1)]\n        heap = []\n        heapq.heappush(heap, (0, S))\n        dist[S] = 0\n        while len(heap) > 0:\n            tup = heap[0]\n            u = tup[1]\n            heapq.heappop(heap)\n            for adj in adj_list[u]:\n                v = adj[0]\n                weight = adj[1]\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    heapq.heappush(heap, (dist[v], v))\n        print(*dist[1:])\nsolve()", "import heapq\n\ndef clear(n):\n    for i in range(n + 1):\n        del adj_list[i]\n        dist[i] = 10 ** 18\n\ndef solve():\n    T = int(input())\n    for t in range(T):\n        (N, K, X, M, S) = map(int, input().split(' '))\n        adj_list = [[] for i in range(N + 1)]\n        for i in range(1, K + 1):\n            adj_list[0].append((i, X))\n            adj_list[i].append((0, 0))\n        for i in range(M):\n            (a, b, c) = map(int, input().split(' '))\n            adj_list[a].append((b, c))\n            adj_list[b].append((a, c))\n        dist = [10 ** 18 for i in range(N + 1)]\n        heap = []\n        heapq.heappush(heap, (0, S))\n        dist[S] = 0\n        while len(heap) > 0:\n            tup = heap[0]\n            u = tup[1]\n            heapq.heappop(heap)\n            for adj in adj_list[u]:\n                v = adj[0]\n                weight = adj[1]\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    heapq.heappush(heap, (dist[v], v))\n        print(*dist[1:])\nsolve()", "import heapq\n\ndef solve():\n    T = int(input())\n    for t in range(T):\n        (N, K, X, M, S) = map(int, input().split(' '))\n        adj_list = [[] for i in range(N + 1)]\n        for i in range(1, K + 1):\n            adj_list[0].append((i, X))\n            adj_list[i].append((0, 0))\n        for i in range(M):\n            (a, b, c) = map(int, input().split(' '))\n            adj_list[a].append((b, c))\n            adj_list[b].append((a, c))\n        dist = [10 ** 18 for i in range(N + 1)]\n        heap = []\n        heapq.heappush(heap, (0, S))\n        dist[S] = 0\n        while len(heap) > 0:\n            tup = heap[0]\n            u = tup[1]\n            heapq.heappop(heap)\n            for adj in adj_list[u]:\n                v = adj[0]\n                weight = adj[1]\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    heapq.heappush(heap, (dist[v], v))\n        for i in range(1, N + 1):\n            print(dist[i], end=' ')\n        print()\nsolve()", "import heapq\n\ndef dijkstra(g, s):\n    dist = [10 ** 18] * len(g)\n    dist[s] = 0\n    pq = [(0, s)]\n    while pq:\n        (d, u) = heapq.heappop(pq)\n        if dist[u] < d:\n            continue\n        for (v, w) in g[u]:\n            alt = d + w\n            if alt < dist[v]:\n                dist[v] = alt\n                heapq.heappush(pq, (alt, v))\n    return dist\nfor t in range(int(input())):\n    (N, K, X, M, S) = map(int, input().split())\n    g = [[] for i in range(N + 1)]\n    for i in range(1, K + 1):\n        g[0].append((i, X))\n        g[i].append((0, 0))\n    for i in range(M):\n        (a, b, c) = map(int, input().split())\n        g[a].append((b, c))\n        g[b].append((a, c))\n    dist = dijkstra(g, S)\n    print(*dist[1:])", "from sys import stdin, maxsize\nfrom heapq import heappop, heappush, heapify\n\ndef dijkstra(G, s, k, X):\n    heap = [(0, s)]\n    heapify(heap)\n    visited = set()\n    dist = [maxsize] * len(G)\n    dist[s] = 0\n    done = False\n    while len(heap) > 0:\n        (d, c) = heappop(heap)\n        if c in visited:\n            continue\n        dist[c] = d\n        visited.add(c)\n        if c <= K and (not done):\n            done = True\n            for i in range(1, K + 1):\n                heappush(heap, (d + X, i))\n        for (n, x) in G[c]:\n            if not n in visited:\n                heappush(heap, (d + x, n))\n    return dist\nT = int(stdin.readline())\nfor t in range(T):\n    [N, K, X, M, S] = [int(x) for x in stdin.readline().split()]\n    G = [set()] + [set() for _ in range(N)]\n    for _ in range(M):\n        [a, b, c] = [int(x) for x in stdin.readline().split()]\n        G[a].add((b, c))\n        G[b].add((a, c))\n    distanceToS = dijkstra(G, S, K, X)\n    print(' '.join([str(x) for x in distanceToS[1:]]))", "from sys import stdin, maxsize\nfrom heapq import heappop, heappush, heapify\n\ndef dijkstra(G, s, k, X):\n    heap = [(0, s)]\n    heapify(heap)\n    visited = set()\n    dist = [maxsize] * len(G)\n    dist[s] = 0\n    done = False\n    while len(heap) > 0:\n        (d, c) = heappop(heap)\n        if c in visited:\n            continue\n        dist[c] = d\n        visited.add(c)\n        if c <= K and (not done):\n            done = True\n            for i in range(1, K + 1):\n                heappush(heap, (d + X, i))\n        for (n, x) in G[c]:\n            if not n in visited:\n                heappush(heap, (d + x, n))\n    return dist\nT = int(stdin.readline())\nfor t in range(T):\n    [N, K, X, M, S] = [int(x) for x in stdin.readline().split()]\n    G = [set()] + [set() for _ in range(N)]\n    for _ in range(M):\n        [a, b, c] = [int(x) for x in stdin.readline().split()]\n        G[a].add((b, c))\n        G[b].add((a, c))\n    distanceToS = dijkstra(G, S, K, X)\n    print(' '.join([str(x) for x in distanceToS[1:]]))", "from heapq import *\nINFINITY = 10 ** 18\nfor _ in range(int(input())):\n    (N, K, X, M, S) = [int(x) for x in input().split()]\n    G = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        (a, b, c) = [int(x) for x in input().split()]\n        G[a].append((b, c))\n        G[b].append((a, c))\n    visited = [False] * (N + 1)\n    distance = [INFINITY] * (N + 1)\n    distance[S] = 0\n    Q = [(0, S)]\n    visited_old_cities = False\n    while Q:\n        (_, u) = heappop(Q)\n        visited[u] = True\n        if not visited_old_cities and u <= K:\n            visited_old_cities = True\n            for v in range(1, K + 1):\n                if u == v:\n                    continue\n                alt = distance[u] + X\n                if alt < distance[v]:\n                    distance[v] = alt\n                    heappush(Q, (alt, v))\n        for (v, c) in G[u]:\n            if visited[v]:\n                continue\n            alt = distance[u] + c\n            if alt < distance[v]:\n                distance[v] = alt\n                heappush(Q, (alt, v))\n    print(' '.join((str(x) for x in distance[1:])))", "from collections import defaultdict\nfrom heapq import *\n\ndef dijkstra(s, dist, g):\n    (q, seen) = ([(0, s)], set())\n    while q:\n        (cost, v1) = heappop(q)\n        if v1 not in seen:\n            seen.add(v1)\n            dist[v1] = cost\n            for (c, v2) in g[v1]:\n                if v2 not in seen:\n                    heappush(q, (cost + c, v2))\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k, x, m, s) = map(int, input().split())\n    g = [[] for i in range(n + 1)]\n    dist = [-1 for i in range(n + 1)]\n    for i in range(1, k + 1):\n        g[0].append((x / 2, i))\n        g[i].append((x / 2, 0))\n    for i in range(m):\n        (a, b, c) = map(int, input().split())\n        g[a].append((c, b))\n        g[b].append((c, a))\n    out = []\n    if s <= k:\n        dijkstra(s, dist, g)\n        for i in range(k + 1):\n            out.append(dist[i])\n        for i in range(k + 1, n + 1):\n            out.append(dist[i])\n    else:\n        dijkstra(s, dist, g)\n        for i in range(n + 1):\n            out.append(dist[i])\n    print(' '.join(map(str, map(int, out[1:]))))", "from collections import defaultdict\nimport heapq\n\ndef dijkstra(adj, cost, initial):\n    visited = {initial: 0}\n    h = [(0, initial)]\n    path = {}\n    nodes = set([i for i in range(N + 1)])\n    while nodes and h:\n        (current_weight, min_node) = heapq.heappop(h)\n        try:\n            while min_node not in nodes:\n                (current_weight, min_node) = heapq.heappop(h)\n        except IndexError:\n            break\n        nodes.remove(min_node)\n        for v in adj[min_node]:\n            weight = current_weight + cost[min_node, v]\n            if v not in visited or weight < visited[v]:\n                visited[v] = weight\n                heapq.heappush(h, (weight, v))\n                path[v] = min_node\n    return visited\n\ndef handle_case(N, K, X, M, s):\n    edges = []\n    for i in range(M):\n        (n1, n2, c) = [int(x) for x in input().strip().split()]\n        edges.append((n1, n2, c))\n    adj = defaultdict(list)\n    for (l, r, _) in edges:\n        adj[l].append(r)\n        adj[r].append(l)\n    for i in range(1, K + 1):\n        adj[i].append(0)\n        adj[0].append(i)\n    cost = dict()\n    for (l, r, c) in edges:\n        cost[l, r] = c\n        cost[r, l] = c\n    for i in range(1, K + 1):\n        cost[i, 0] = 0\n        cost[0, i] = X\n    d = dijkstra(adj, cost, s)\n    lst = [0] * N\n    for i in range(1, N + 1):\n        lst[i - 1] = str(d[i])\n    return lst\nT = int(input())\nfor t in range(T):\n    (N, K, X, M, s) = [int(x) for x in input().strip().split()]\n    res = handle_case(N, K, X, M, s)\n    print(' '.join(res))"]