["from bisect import insort, bisect\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append((p[i], s[i]))\n    l.sort()\n    values = []\n    ans = 0\n    (i, j) = (n - 1, 0)\n    if d < l[0][0]:\n        print('0')\n        continue\n    while i >= 0:\n        if l[i][0] > d:\n            i -= 1\n            continue\n        ans = max(ans, l[i][1])\n        while j < i and l[j][0] <= d - l[i][0]:\n            insort(values, l[j][1])\n            j += 1\n        if i < j:\n            values.pop(bisect(values, l[i][1]) - 1)\n        if values:\n            ans = max(ans, l[i][1] + values[-1])\n        i -= 1\n    print(ans)", "from bisect import insort, bisect\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append((p[i], s[i]))\n    l.sort()\n    values = []\n    ans = 0\n    (i, j) = (n - 1, 0)\n    if d < l[0][0]:\n        print('0')\n        continue\n    while i >= 0:\n        if l[i][0] > d:\n            i -= 1\n            continue\n        ans = max(ans, l[i][1])\n        while j < i and l[j][0] <= d - l[i][0]:\n            insort(values, l[j][1])\n            j += 1\n        if i < j:\n            values.pop(bisect(values, l[i][1]) - 1)\n        if values:\n            ans = max(ans, l[i][1] + values[-1])\n        i -= 1\n    print(ans)", "from functools import cmp_to_key as ck\nimport bisect\n\ndef cp(a, b):\n    if a[0] < b[0]:\n        return -1\n    if a[0] > b[0]:\n        return 1\n    return 0\n\ndef bs(arr, n, start, end, x):\n    if start > end:\n        return x\n    half = (start + end) // 2\n    mid = arr[half]\n    if mid[0] <= n:\n        return bs(arr, n, half + 1, end, half)\n    else:\n        return bs(arr, n, start, half - 1, x)\n\ndef codeforces(a, b, c, n):\n    (res, ind) = ([], 0)\n    for i in a:\n        res.append([i, b[ind]])\n        ind += 1\n    res = sorted(res, key=ck(cp))\n    dp = [0 for i in range(n)]\n    curr = 0\n    for i in range(n):\n        if curr < res[i][1]:\n            curr = res[i][1]\n        dp[i] = curr\n    ans = 0\n    for i in range(n):\n        if res[i][0] > c:\n            break\n        d = c - res[i][0]\n        ind = bs(res, d, 0, n - 1, -1)\n        if ind >= 0 and i:\n            k = min(i - 1, ind)\n            ans = max(res[i][1] + dp[k], ans)\n        else:\n            ans = max(ans, res[i][1])\n    return ans\nt = int(input())\nfor test in range(t):\n    (n, d) = [int(i) for i in input().split()]\n    p = [int(i) for i in input().split()]\n    s = [int(i) for i in input().split()]\n    print(codeforces(p, s, d, n))", "from sys import stdin\ninput = stdin.readline\nt = int(input())\nfor i in range(t):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append((p[i], s[i]))\n    l.sort()\n    pre = [0] * n\n    max_sweet = -1\n    for i in range(n):\n        max_sweet = max(max_sweet, l[i][1])\n        pre[i] = max_sweet\n    ans = 0\n    for i in range(n):\n        if l[i][0] <= d:\n            x = d - l[i][0]\n            start = 0\n            end = i - 1\n            pos = -1\n            while start <= end:\n                mid = (start + end) // 2\n                if l[mid][0] <= x:\n                    pos = mid\n                    start = mid + 1\n                else:\n                    end = mid - 1\n            sweetness = l[i][1]\n            if pos != -1:\n                sweetness = sweetness + pre[pos]\n            ans = max(ans, sweetness)\n    print(ans)", "import sys\ninput = sys.stdin.readline\nt = int(input().strip())\nfor __ in range(t):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    arr = [(0, 0)] + [(candy_price, candy_sweetness) for (candy_price, candy_sweetness) in zip(p, s)]\n    arr.sort()\n    smax = [0]\n    for i in range(1, len(arr)):\n        smax.append(max(smax[-1], arr[i][1]))\n    left = 0\n    right = len(arr) - 1\n    final_result = 0\n    while right >= 0 and arr[right][0] > d:\n        right -= 1\n    while right >= 0 and left < right:\n        while left + 1 < right and arr[left + 1][0] + arr[right][0] <= d:\n            left += 1\n        final_result = max(final_result, smax[left] + arr[right][1])\n        while right > 0 and arr[right - 1][0] == arr[right][0]:\n            right -= 1\n        right -= 1\n    for i in range(right, 0, -1):\n        final_result = max(final_result, smax[i - 1] + arr[i][1])\n    print(final_result)", "from bisect import insort, bisect\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append((p[i], s[i]))\n    l.sort()\n    values = []\n    ans = 0\n    (i, j) = (n - 1, 0)\n    if d < l[0][0]:\n        print('0')\n        continue\n    while i >= 0:\n        if l[i][0] > d:\n            i -= 1\n            continue\n        ans = max(ans, l[i][1])\n        while j < i and l[j][0] <= d - l[i][0]:\n            insort(values, l[j][1])\n            j += 1\n        if i < j:\n            values.pop(bisect(values, l[i][1]) - 1)\n        if values:\n            ans = max(ans, l[i][1] + values[-1])\n        i -= 1\n    print(ans)", "from sys import stdin\ninput = stdin.readline\nt = int(input())\nfor i in range(t):\n    (n, d) = map(int, input().split())\n    p = [int(x) for x in input().split()]\n    s = [int(x) for x in input().split()]\n    arr = [[0, 0] for i in range(n)]\n    for i in range(n):\n        arr[i][0] = p[i]\n        arr[i][1] = s[i]\n    arr.sort()\n    pre = [0] * n\n    x = -1\n    for i in range(n):\n        x = max(x, arr[i][1])\n        pre[i] = x\n    ans = 0\n    for i in range(n):\n        if arr[i][0] <= d:\n            x = d - arr[i][0]\n            start = 0\n            end = i - 1\n            pos = -1\n            while start <= end:\n                mid = (start + end) // 2\n                if arr[mid][0] <= x:\n                    pos = mid\n                    start = mid + 1\n                else:\n                    end = mid - 1\n            sw = arr[i][1]\n            if pos != -1:\n                sw = sw + pre[pos]\n            ans = max(ans, sw)\n    print(ans)", "from bisect import insort, bisect\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append((p[i], s[i]))\n    l.sort()\n    values = []\n    ans = 0\n    (i, j) = (n - 1, 0)\n    if d < l[0][0]:\n        print('0')\n        continue\n    while i >= 0:\n        if l[i][0] > d:\n            i -= 1\n            continue\n        ans = max(ans, l[i][1])\n        while j < i and l[j][0] <= d - l[i][0]:\n            insort(values, l[j][1])\n            j += 1\n        if i < j:\n            values.pop(bisect(values, l[i][1]) - 1)\n        if values:\n            ans = max(ans, l[i][1] + values[-1])\n        i -= 1\n    print(ans)", "def maxswt():\n    from bisect import insort, bisect\n    for _ in range(int(input())):\n        (N, D) = [int(x) for x in input().split()]\n        P = [int(x) for x in input().split()]\n        S = [int(x) for x in input().split()]\n        data = [(P[i], S[i]) for i in range(N)]\n        data.sort()\n        values = []\n        ans = 0\n        (i, j) = (N, 0)\n        while i:\n            i -= 1\n            if data[i][0] > D:\n                continue\n            ans = max(ans, data[i][1])\n            while j < i and data[j][0] <= D - data[i][0]:\n                insort(values, data[j][1])\n                j += 1\n            if i < j:\n                values.pop(bisect(values, data[i][1]) - 1)\n            if len(values):\n                ans = max(ans, data[i][1] + values[-1])\n        print(ans)\nmaxswt()", "from bisect import insort, bisect\n\ndef maxswt():\n    for _ in range(int(input())):\n        (N, D) = [int(x) for x in input().split()]\n        P = [int(x) for x in input().split()]\n        S = [int(x) for x in input().split()]\n        data = [(P[i], S[i]) for i in range(N)]\n        data.sort()\n        values = []\n        ans = 0\n        (i, j) = (N, 0)\n        while i:\n            i -= 1\n            if data[i][0] > D:\n                continue\n            ans = max(ans, data[i][1])\n            while j < i and data[j][0] <= D - data[i][0]:\n                insort(values, data[j][1])\n                j += 1\n            if i < j:\n                values.pop(bisect(values, data[i][1]) - 1)\n            if len(values):\n                ans = max(ans, data[i][1] + values[-1])\n        print(ans)\nmaxswt()", "from bisect import bisect\nfor tci in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    ps = [(p[i], s[i]) for i in range(n)]\n    ps.sort()\n    (result, pre) = ([0], [0])\n    for i in range(n):\n        (p[i], s[i]) = ps[i]\n        pre.append(max(pre[i], s[i]))\n        if p[i] <= d:\n            result.append(s[i])\n    if p[n - 1] + p[0] <= d:\n        i = n - 1\n        j = bisect(p, d - p[i])\n    else:\n        i = bisect(p, d - p[0], lo=1) - 1\n        j = 0\n    while i > j:\n        while i > j and p[i] + p[j] <= d:\n            j += 1\n        result.append(s[i] + pre[j])\n        i -= 1\n    while i > 0:\n        result.append(s[i] + pre[i])\n        i -= 1\n    print(max(result))", "from bisect import bisect\nfor tci in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    ps = [(p[i], s[i]) for i in range(n)]\n    ps.sort()\n    (result, pre) = ([0], [0])\n    for i in range(n):\n        (p[i], s[i]) = ps[i]\n        pre.append(max(pre[i], s[i]))\n        if p[i] <= d:\n            result.append(s[i])\n    i = bisect(p, d - p[0], lo=1) - 1\n    j = bisect(p, d - p[i])\n    while i > j:\n        j = bisect(p, d - p[i], lo=j, hi=i)\n        result.append(s[i] + pre[j])\n        i -= 1\n    while i > 0:\n        result.append(s[i] + pre[i])\n        i -= 1\n    print(max(result))", "from bisect import bisect\nfor tci in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    ps = [(p[i], s[i]) for i in range(n)]\n    ps.sort()\n    (result, pre) = ([0], [0])\n    for i in range(n):\n        (p[i], s[i]) = ps[i]\n        pre.append(max(pre[i], s[i]))\n        if p[i] <= d:\n            result.append(s[i])\n    i = bisect(p, d - p[0], lo=1) - 1\n    j = bisect(p, d - p[i])\n    while i > j:\n        while i > j and p[i] + p[j] <= d:\n            j += 1\n        result.append(s[i] + pre[j])\n        i -= 1\n    while i > 0:\n        result.append(s[i] + pre[i])\n        i -= 1\n    print(max(result))", "try:\n    Test = int(input())\n    for _ in range(Test):\n        (N, D) = input().split()\n        (N, D) = (int(N), int(D))\n        PRICE_LIST = [int(x) for x in input().split()]\n        Sweetness_LIST = [int(y) for y in input().split()]\n        PAIRS = zip(PRICE_LIST, Sweetness_LIST)\n        PAIRS = list(PAIRS)\n        SORTED_PAIRS = sorted(PAIRS, key=lambda x: x[0])\n        ANSWERS_LIST = [0] * N\n        x = -1\n        for j in range(N):\n            x = max(x, SORTED_PAIRS[j][1])\n            ANSWERS_LIST[j] = x\n        ANS = 0\n        for i in range(N):\n            if SORTED_PAIRS[i][0] <= D:\n                x = D - SORTED_PAIRS[i][0]\n                F = 0\n                E = i - 1\n                POS = -1\n                while F <= E:\n                    MID = (F + E) // 2\n                    if SORTED_PAIRS[MID][0] <= x:\n                        POS = MID\n                        F = MID + 1\n                    else:\n                        E = MID - 1\n                SW = SORTED_PAIRS[i][1]\n                if POS != -1:\n                    SW = SW + ANSWERS_LIST[POS]\n                ANS = max(ANS, SW)\n        print(ANS)\nexcept EOFError as e:\n    print(e)", "import sys\ninput = sys.stdin.readline\nt = int(input().rstrip())\nfor __ in range(t):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    arr = [(0, 0)] + [(cp, cs) for (cp, cs) in zip(p, s)]\n    arr.sort()\n    cmax = [0]\n    for i in range(1, len(arr)):\n        cmax.append(max(cmax[-1], arr[i][1]))\n    lptr = 0\n    rptr = len(arr) - 1\n    res = 0\n    while rptr >= 0 and arr[rptr][0] > d:\n        rptr -= 1\n    while rptr >= 0 and lptr < rptr:\n        while lptr + 1 < rptr and arr[lptr + 1][0] + arr[rptr][0] <= d:\n            lptr += 1\n        res = max(res, cmax[lptr] + arr[rptr][1])\n        while rptr > 0 and arr[rptr - 1][0] == arr[rptr][0]:\n            rptr -= 1\n        rptr -= 1\n    for i in range(rptr, 0, -1):\n        res = max(res, cmax[i - 1] + arr[i][1])\n    print(res)", "import sys\ninput = sys.stdin.readline\nt = int(input().rstrip())\nfor __ in range(t):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    arr = [(0, 0)] + [(cp, cs) for (cp, cs) in zip(p, s)]\n    arr.sort()\n    cmax = [0]\n    for i in range(1, len(arr)):\n        cmax.append(max(cmax[-1], arr[i][1]))\n    lptr = 0\n    rptr = len(arr) - 1\n    fres = 0\n    while rptr >= 0 and arr[rptr][0] > d:\n        rptr -= 1\n    while rptr >= 0 and lptr < rptr:\n        while lptr + 1 < rptr and arr[lptr + 1][0] + arr[rptr][0] <= d:\n            lptr += 1\n        fres = max(fres, cmax[lptr] + arr[rptr][1])\n        while rptr > 0 and arr[rptr - 1][0] == arr[rptr][0]:\n            rptr -= 1\n        rptr -= 1\n    for i in range(rptr, 0, -1):\n        fres = max(fres, cmax[i - 1] + arr[i][1])\n    print(fres)", "import sys\ninput = sys.stdin.readline\nt = int(input().rstrip())\nfor __ in range(t):\n    (n, d) = map(int, input().rstrip().split(' '))\n    p = [int(val) for val in input().rstrip().split(' ')]\n    s = [int(val) for val in input().rstrip().split(' ')]\n    arr = [(0, 0)] + [(cp, cs) for (cp, cs) in zip(p, s)]\n    arr.sort()\n    cmax = [0]\n    for i in range(1, len(arr)):\n        cmax.append(max(cmax[-1], arr[i][1]))\n    lptr = 0\n    rptr = len(arr) - 1\n    fres = 0\n    while rptr >= 0 and arr[rptr][0] > d:\n        rptr -= 1\n    while rptr >= 0 and lptr < rptr:\n        while lptr + 1 < rptr and arr[lptr + 1][0] + arr[rptr][0] <= d:\n            lptr += 1\n        fres = max(fres, cmax[lptr] + arr[rptr][1])\n        while rptr > 0 and arr[rptr - 1][0] == arr[rptr][0]:\n            rptr -= 1\n        rptr -= 1\n    for i in range(rptr, 0, -1):\n        fres = max(fres, cmax[i - 1] + arr[i][1])\n    print(fres)", "import sys\ninput = sys.stdin.readline\nt = int(input().rstrip())\nfor __ in range(t):\n    (n, d) = map(int, input().rstrip().split(' '))\n    p = [int(val) for val in input().rstrip().split(' ')]\n    s = [int(val) for val in input().rstrip().split(' ')]\n    arr = [(0, 0)] + [(cp, cs) for (cp, cs) in zip(p, s)]\n    arr.sort()\n    cmax = [0]\n    for i in range(1, len(arr)):\n        cmax.append(max(cmax[-1], arr[i][1]))\n    lptr = 0\n    rptr = len(arr) - 1\n    fres = 0\n    while rptr >= 0 and arr[rptr][0] > d:\n        rptr -= 1\n    while rptr >= 0 and lptr < rptr:\n        while lptr + 1 < rptr and arr[lptr + 1][0] + arr[rptr][0] <= d:\n            lptr += 1\n        fres = max(fres, cmax[lptr] + arr[rptr][1])\n        while rptr > 0 and arr[rptr - 1][0] == arr[rptr][0]:\n            rptr -= 1\n        rptr -= 1\n    for i in range(rptr, 0, -1):\n        fres = max(fres, cmax[i - 1] + arr[i][1])\n    print(fres)", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    s_p = [[p[i], i] for i in range(n)]\n    s_s = [[s[i], i] for i in range(n)]\n    s_p = sorted(s_p)\n    s_s = sorted(s_s)\n    j = n - 1\n    ans = 0\n    for i in range(n):\n        if p[i] <= d:\n            ans = max(ans, s[i])\n        while j >= 0 and (s_p[i][0] + p[s_s[j][1]] > d or s_p[i][1] == s_s[j][1]):\n            j -= 1\n        if j != -1:\n            ans = max(ans, s[s_p[i][1]] + s_s[j][0])\n    print(ans)", "import bisect\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    array = sorted(([p[i], s[i]] for i in range(n)))\n    (dp, sweet) = ([], [])\n    for i in range(n):\n        dp.append(array[i][0])\n        sweet.append(array[i][1])\n    for i in range(1, n):\n        sweet[i] = max(sweet[i], sweet[i - 1])\n    ans = 0\n    for i in range(n - 1, 0, -1):\n        if array[i][0] < d:\n            index = bisect.bisect_right(dp, d - array[i][0])\n            if index == 0:\n                ans = max(ans, sweet[i])\n            else:\n                ans = max(ans, array[i][1] + sweet[min(i - 1, index - 1)])\n        if array[i][0] == d:\n            ans = max(ans, array[i][1])\n    if array[0][0] <= d:\n        ans = max(ans, array[0][1])\n    print(ans)", "for tci in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    ps = [(p[i], s[i]) for i in range(n)]\n    ps.sort()\n    (result, pre) = ([0], [0])\n    for i in range(n):\n        (p[i], s[i]) = ps[i]\n        pre.append(max(pre[i], s[i]))\n        if p[i] <= d:\n            result.append(s[i])\n    (i, d0) = (n - 1, d - p[0])\n    while i > 0 and p[i] > d0:\n        i -= 1\n    j = 0\n    while i > j:\n        while i > j and p[i] + p[j] <= d:\n            j += 1\n        result.append(s[i] + pre[j])\n        i -= 1\n    while i > 0:\n        result.append(s[i] + pre[i])\n        i -= 1\n    print(max(result))", "for tci in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    ps = [(p[i], s[i]) for i in range(n)]\n    ps.sort()\n    (result, m, pre) = (0, 0, [0] * n)\n    for i in range(n):\n        (p[i], s[i]) = ps[i]\n        m = max(m, s[i])\n        pre[i] = m\n        if p[i] <= d:\n            result = max(result, m)\n    (i, j) = (n - 1, 0)\n    while i > 0:\n        while j < i and p[i] + p[j] <= d:\n            j += 1\n        if j > 0:\n            j -= 1\n            result = max(result, s[i] + pre[j])\n        i -= 1\n    print(result)", "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            (self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            (self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda : self.buffer.read().decode('ascii')\n        self.readline = lambda : self.buffer.readline().decode('ascii')\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nreadint = lambda : int(sys.stdin.readline().rstrip('\\r\\n'))\nreadints = lambda : map(int, sys.stdin.readline().rstrip('\\r\\n').split())\nreadstr = lambda : sys.stdin.readline().rstrip('\\r\\n')\nreadstrs = lambda : map(str, sys.stdin.readline().rstrip('\\r\\n').split())\nreadarri = lambda : [int(_) for _ in sys.stdin.readline().rstrip('\\r\\n').split()]\nreadarrs = lambda : [str(_) for _ in sys.stdin.readline().rstrip('\\r\\n').split()]\n\ndef solve():\n    (n, money) = readints()\n    combined = sorted(list(zip(readarri(), readarri())))\n    if n == 1:\n        print(0 if combined[0][0] > money else combined[0][1])\n        return\n    rM = [combined[0][1]]\n    for i in range(1, n):\n        rM.append(max(rM[-1], combined[i][1]))\n    maxAns = 0\n    for i in range(n - 1, -1, -1):\n        if combined[i][0] > money:\n            continue\n        (l, r, ind, c) = (0, i - 1, -1, combined[i][1])\n        while l <= r:\n            m = l + (r - l >> 1)\n            if combined[m][0] <= money - combined[i][0]:\n                l = m + 1\n                ind = m\n            else:\n                r = m - 1\n        if ind != -1:\n            c += rM[ind]\n        maxAns = max(maxAns, c)\n    print(maxAns)\n\ndef main():\n    t = 1\n    t = readint()\n    for _ in range(t):\n        solve()\nmain()", "from bisect import *\nfrom collections import *\nfrom copy import copy, deepcopy\nfrom functools import lru_cache, reduce\nfrom heapq import *\nfrom itertools import *\nfrom math import ceil, factorial, floor, gcd, inf, log2 as lg, trunc\nimport operator as op\nfrom random import *\nimport re\nfrom statistics import median, mean\nfrom string import ascii_lowercase as al, ascii_uppercase as au\nimport sys\nsys.setrecursionlimit(25000)\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    ps = list(map(int, input().split()))\n    ss = list(map(int, input().split()))\n    li = {i for (i, p) in enumerate(ps) if p > d}\n    ps = [p for (i, p) in enumerate(ps) if i not in li]\n    ss = [s for (i, s) in enumerate(ss) if i not in li]\n    if len(ps) == 0:\n        print(0)\n    elif len(ps) == 1:\n        print(ss[0])\n    else:\n        li = sorted(range(len(ps)), key=ps.__getitem__)\n        ps = [ps[i] for i in li]\n        ss = [ss[i] for i in li]\n        s1 = s2 = 0\n        l1 = []\n        l2 = []\n        for (p, s) in zip(ps, ss):\n            if s > s1:\n                l1.append((p, s))\n                (s1, s2) = (s, s1)\n            elif s > s2:\n                l2.append((p, s))\n                s2 = s\n        x = max(ss)\n        for (i, (p, s)) in enumerate(l1):\n            i1 = bisect(l1, (d - p, inf)) - 1\n            if i1 == i:\n                i1 -= 1\n            i2 = bisect(l2, (d - p, inf)) - 1\n            if i1 >= 0:\n                x = max(x, s + l1[i1][1])\n            if i2 >= 0:\n                x = max(x, s + l2[i2][1])\n        print(x)", "from bisect import *\nfrom collections import *\nfrom copy import copy, deepcopy\nfrom functools import lru_cache, reduce\nfrom heapq import *\nfrom itertools import *\nfrom math import ceil, factorial, floor, gcd, inf, log2 as lg, trunc\nimport operator as op\nfrom random import *\nimport re\nfrom statistics import median, mean\nfrom string import ascii_lowercase as al, ascii_uppercase as au\nimport sys\nsys.setrecursionlimit(25000)\nres = []\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    ps = list(map(int, input().split()))\n    ss = list(map(int, input().split()))\n    li = {i for (i, p) in enumerate(ps) if p > d}\n    ps = [p for (i, p) in enumerate(ps) if i not in li]\n    ss = [s for (i, s) in enumerate(ss) if i not in li]\n    if len(ps) == 0:\n        print(0)\n    elif len(ps) == 1:\n        print(ss[0])\n    else:\n        li = sorted(range(len(ps)), key=ps.__getitem__)\n        ps = [ps[i] for i in li]\n        ss = [ss[i] for i in li]\n        s1 = s2 = 0\n        l1 = []\n        l2 = []\n        for (p, s) in zip(ps, ss):\n            if s > s1:\n                l1.append((p, s))\n                (s1, s2) = (s, s1)\n            elif s > s2:\n                l2.append((p, s))\n                s2 = s\n        x = max(ss)\n        for (i, (p, s)) in enumerate(l1):\n            i1 = bisect(l1, (d - p, inf)) - 1\n            if i1 == i:\n                i1 -= 1\n            i2 = bisect(l2, (d - p, inf)) - 1\n            if i1 >= 0:\n                x = max(x, s + l1[i1][1])\n            if i2 >= 0:\n                x = max(x, s + l2[i2][1])\n        print(x)", "for _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    arr = [[0, 0] for i in range(n)]\n    for i in range(n):\n        arr[i][0] = p[i]\n        arr[i][1] = s[i]\n    arr.sort()\n    dp = [0] * n\n    x = -1\n    for i in range(n):\n        x = max(x, arr[i][1])\n        dp[i] = x\n    ans = 0\n    for i in range(n):\n        if arr[i][0] <= d:\n            x = d - arr[i][0]\n            start = 0\n            end = i - 1\n            pos = -1\n            while start <= end:\n                mid = (start + end) // 2\n                if arr[mid][0] <= x:\n                    pos = mid\n                    start = mid + 1\n                else:\n                    end = mid - 1\n            sw = arr[i][1]\n            if pos != -1:\n                sw = sw + dp[pos]\n            ans = max(ans, sw)\n    print(ans)", "import bisect\nfor _ in range(int(input())):\n    (N, D) = map(int, input().split())\n    P = list(map(int, input().split()))\n    S = list(map(int, input().split()))\n    PS = list(zip(P, S))\n    PS.sort()\n    P = [x[0] for x in PS]\n    S = [x[1] for x in PS]\n    premax = [S[0]]\n    for i in range(1, N):\n        premax.append(max(S[i], premax[-1]))\n    c = 0\n    for i in range(N):\n        if P[i] <= D:\n            cost = D - P[i]\n            bi = bisect.bisect_right(P, cost, hi=i) - 1 if i != 0 else -1\n            c = max(c, S[i] + (premax[bi] if bi != -1 else 0))\n    print(c)", "from heapq import heapify, heappop, heappush\nfor _ in range(int(input())):\n    (n, d) = list(map(int, input().split()))\n    prices = list(map(int, input().split()))\n    sweet = list(map(int, input().split()))\n    arr = [[0, 0] for _ in range(n)]\n    for i in range(n):\n        arr[i][0] = prices[i]\n        arr[i][1] = sweet[i]\n    arr.sort()\n    pre = [0] * n\n    x = -1\n    for i in range(n):\n        x = max(x, arr[i][1])\n        pre[i] = x\n    ans = 0\n    for i in range(n):\n        if arr[i][0] <= d:\n            x = d - arr[i][0]\n            start = 0\n            end = i - 1\n            pos = -1\n            while start <= end:\n                mid = (start + end) // 2\n                if arr[mid][0] <= x:\n                    pos = mid\n                    start = mid + 1\n                else:\n                    end = mid - 1\n            sw = arr[i][1]\n            if pos != -1:\n                sw = sw + pre[pos]\n            ans = max(ans, sw)\n    print(ans)", "from heapq import heapify, heappop, heappush\nfor _ in range(int(input())):\n    (n, d) = list(map(int, input().split()))\n    prices = list(map(int, input().split()))\n    sweet = list(map(int, input().split()))\n    arr = [[0, 0] for _ in range(n)]\n    for i in range(n):\n        arr[i][0] = prices[i]\n        arr[i][1] = sweet[i]\n    arr.sort()\n    pre = [0] * n\n    x = -1\n    for i in range(n):\n        x = max(x, arr[i][1])\n        pre[i] = x\n    ans = 0\n    for i in range(n):\n        if arr[i][0] <= d:\n            x = d - arr[i][0]\n            start = 0\n            end = i - 1\n            pos = -1\n            while start <= end:\n                mid = (start + end) // 2\n                if arr[mid][0] <= x:\n                    pos = mid\n                    start = mid + 1\n                else:\n                    end = mid - 1\n            sw = arr[i][1]\n            if pos != -1:\n                sw = sw + pre[pos]\n            ans = max(ans, sw)\n    print(ans)", "import sys\ninput = sys.stdin.readline\nt = int(input().rstrip())\nfor __ in range(t):\n    (n, d) = map(int, input().rstrip().split(' '))\n    p = [int(val) for val in input().rstrip().split(' ')]\n    s = [int(val) for val in input().rstrip().split(' ')]\n    arr = [(0, 0)] + [(cp, cs) for (cp, cs) in zip(p, s)]\n    arr.sort()\n    cmax = [0]\n    for i in range(1, len(arr)):\n        cmax.append(max(cmax[-1], arr[i][1]))\n    lptr = 0\n    rptr = len(arr) - 1\n    fres = 0\n    while rptr >= 0 and arr[rptr][0] > d:\n        rptr -= 1\n    while rptr >= 0 and lptr < rptr:\n        while lptr + 1 < rptr and arr[lptr + 1][0] + arr[rptr][0] <= d:\n            lptr += 1\n        fres = max(fres, cmax[lptr] + arr[rptr][1])\n        while rptr > 0 and arr[rptr - 1][0] == arr[rptr][0]:\n            rptr -= 1\n        rptr -= 1\n    for i in range(rptr, 0, -1):\n        fres = max(fres, cmax[i - 1] + arr[i][1])\n    print(fres)", "import sys\ninput = sys.stdin.readline\nt = int(input().rstrip())\nfor __ in range(t):\n    (n, d) = map(int, input().rstrip().split(' '))\n    p = [int(val) for val in input().rstrip().split(' ')]\n    s = [int(val) for val in input().rstrip().split(' ')]\n    arr = [(0, 0)] + [(cp, cs) for (cp, cs) in zip(p, s)]\n    arr.sort()\n    cmax = [0]\n    for i in range(1, len(arr)):\n        cmax.append(max(cmax[-1], arr[i][1]))\n    lptr = 0\n    rptr = len(arr) - 1\n    fres = 0\n    while rptr >= 0 and arr[rptr][0] > d:\n        rptr -= 1\n    while rptr >= 0 and lptr < rptr:\n        while lptr + 1 < rptr and arr[lptr + 1][0] + arr[rptr][0] <= d:\n            lptr += 1\n        fres = max(fres, cmax[lptr] + arr[rptr][1])\n        while rptr > 0 and arr[rptr - 1][0] == arr[rptr][0]:\n            rptr -= 1\n        rptr -= 1\n    for i in range(rptr, 0, -1):\n        fres = max(fres, cmax[i - 1] + arr[i][1])\n    print(fres)", "from sys import stdin\ninput = stdin.readline\nt = int(input())\nfor i in range(t):\n    (n, d) = map(int, input().split())\n    p = [int(x) for x in input().split()]\n    s = [int(x) for x in input().split()]\n    arr = [[0, 0] for i in range(n)]\n    for i in range(n):\n        arr[i][0] = p[i]\n        arr[i][1] = s[i]\n    arr.sort()\n    pre = [0] * n\n    x = -1\n    for i in range(n):\n        x = max(x, arr[i][1])\n        pre[i] = x\n    ans = 0\n    for i in range(n):\n        if arr[i][0] <= d:\n            x = d - arr[i][0]\n            start = 0\n            end = i - 1\n            pos = -1\n            while start <= end:\n                mid = (start + end) // 2\n                if arr[mid][0] <= x:\n                    pos = mid\n                    start = mid + 1\n                else:\n                    end = mid - 1\n            sw = arr[i][1]\n            if pos != -1:\n                sw = sw + pre[pos]\n            ans = max(ans, sw)\n    print(ans)", "import sys\nfrom collections import deque\n\ndef read(lst=False):\n    line = sys.stdin.readline().rstrip()\n    if ' ' in line or lst:\n        return map(int, line.split())\n    return line\nT = int(read())\nfor t in range(T):\n    (N, D) = read()\n    P = list(read(True))\n    S = list(read(True))\n    merge = [[P[i], S[i]] for i in range(N)]\n    merge.sort()\n    if merge[0][0] > D:\n        print(0)\n        continue\n    q = [0]\n    maxAns = merge[0][1]\n    for i in range(1, N):\n        temp = merge[i][1]\n        while q and merge[q[-1]][0] + merge[i][0] > D:\n            q.pop()\n        if q:\n            temp += merge[q[-1]][1]\n        elif merge[i][0] > D:\n            temp = 0\n        maxAns = max(maxAns, temp)\n        merge[i][1] = max(merge[i][1], merge[i - 1][1])\n        q.append(i)\n    print(maxAns)\nsys.exit()", "import bisect\nimport heapq\nn_testcase = int(input())\nfor testcase in range(n_testcase):\n    (n, budget) = (int(x) for x in input().split())\n    prices = [int(x) for x in input().split()]\n    sweetnesses = [int(x) for x in input().split()]\n    candies = list(zip(prices, sweetnesses))\n    candies.sort()\n    prices = [price for (price, sweetness) in candies]\n    sweetnesses = [sweetness for (price, sweetness) in candies]\n    if any((price <= budget for price in prices)):\n        max_sweetness = max((sweetness for (price, sweetness) in candies if price <= budget))\n    else:\n        max_sweetness = 0\n    heap = []\n    k = 0\n    for (i, (price, sweetness)) in list(enumerate(candies))[::-1]:\n        if budget - price < prices[0]:\n            continue\n        while k < n and prices[k] <= budget - price:\n            heapq.heappush(heap, -sweetnesses[k])\n            k += 1\n        poped = False\n        if i <= k and -heap[0] == sweetness:\n            heapq.heappop(heap)\n            poped = True\n        if heap:\n            max_sweetness = max(max_sweetness, sweetness + -heap[0])\n        if poped:\n            heapq.heappush(heap, -sweetness)\n    print(max_sweetness)", "from sys import stdin\ninput = stdin.readline\n\ndef b_s(key, l, h):\n    ans = 0\n    while l <= h:\n        mid = (l + h) // 2\n        if a[mid][0] <= key:\n            ans = max(ans, pf[mid])\n            l = mid + 1\n        else:\n            h = mid - 1\n    return ans\n\ndef answer():\n    ans = 0\n    for i in range(n - 1, -1, -1):\n        x = a[i][0]\n        if x > d:\n            continue\n        m_v = b_s(d - x, 0, i - 1)\n        ans = max(ans, a[i][1] + m_v)\n    return ans\nfor T in range(int(input())):\n    (n, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    a = [[p[i], s[i]] for i in range(n)]\n    a.sort(key=lambda x: x[0])\n    pf = [a[0][1]]\n    for i in range(1, n):\n        pf.append(max(pf[-1], a[i][1]))\n    print(answer())", "from bisect import *\nfrom collections import *\nfrom copy import copy, deepcopy\nfrom functools import lru_cache, reduce\nfrom heapq import *\nfrom itertools import *\nfrom math import ceil, factorial, floor, gcd, inf, log2 as lg, trunc\nimport operator as op\nfrom random import *\nimport re\nfrom statistics import median, mean\nfrom string import ascii_lowercase as al, ascii_uppercase as au\nimport sys\nsys.setrecursionlimit(25000)\ncin = sys.stdin\nread = cin.readline\ncout = sys.stdout\nwrite = cout.write\nrir = lambda : range(int(read()))\nir = lambda : int(read())\nmir = lambda : map(int, read().split())\nlmir = lambda : list(map(int, read().split()))\nres = []\nfor _ in rir():\n    (n, d) = mir()\n    ps = lmir()\n    ss = lmir()\n    li = {i for (i, p) in enumerate(ps) if p > d}\n    ps = [p for (i, p) in enumerate(ps) if i not in li]\n    ss = [s for (i, s) in enumerate(ss) if i not in li]\n    if len(ps) == 0:\n        res.append(0)\n    elif len(ps) == 1:\n        res.append(ss[0])\n    else:\n        li = sorted(range(len(ps)), key=ps.__getitem__)\n        ps = [ps[i] for i in li]\n        ss = [ss[i] for i in li]\n        s1 = s2 = 0\n        l1 = []\n        l2 = []\n        for (p, s) in zip(ps, ss):\n            if s > s1:\n                l1.append((p, s))\n                (s1, s2) = (s, s1)\n            elif s > s2:\n                l2.append((p, s))\n                s2 = s\n        x = max(ss)\n        for (i, (p, s)) in enumerate(l1):\n            i1 = bisect(l1, (d - p, inf)) - 1\n            if i1 == i:\n                i1 -= 1\n            i2 = bisect(l2, (d - p, inf)) - 1\n            if i1 >= 0:\n                x = max(x, s + l1[i1][1])\n            if i2 >= 0:\n                x = max(x, s + l2[i2][1])\n        res.append(x)\nwrite('\\n'.join(map(str, res)))", "import bisect\nimport sys\ninput = sys.stdin.readline\n\ndef solve(a, b, n, d):\n    mat = sorted([[a[i], b[i]] for i in range(n)])\n    dp = [0] * n\n    aa = [0] * n\n    for i in range(n):\n        aa[i] = mat[i][0]\n        dp[i] = mat[i][1]\n    for i in range(1, n):\n        dp[i] = max(dp[i], dp[i - 1])\n    ans = 0\n    for i in range(n - 1, 0, -1):\n        if mat[i][0] < d:\n            re = d - mat[i][0]\n            ind = bisect.bisect_right(aa, re)\n            if ind == 0:\n                ans = max(ans, dp[i])\n            else:\n                ind = min(i - 1, ind - 1)\n                ans = max(ans, mat[i][1] + dp[ind])\n        if mat[i][0] == d:\n            ans = max(ans, mat[i][1])\n    if mat[0][0] <= d:\n        ans = max(ans, mat[0][1])\n    return ans\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    p = str(solve(a, b, n, d))\n    sys.stdout.write(p + '\\n')", "import bisect\n\ndef solve(a, b, n, d):\n    mat = sorted([[a[i], b[i]] for i in range(n)])\n    dp = [0] * n\n    aa = [0] * n\n    for i in range(n):\n        aa[i] = mat[i][0]\n        dp[i] = mat[i][1]\n    for i in range(1, n):\n        dp[i] = max(dp[i], dp[i - 1])\n    ans = 0\n    for i in range(n - 1, 0, -1):\n        if mat[i][0] < d:\n            re = d - mat[i][0]\n            ind = bisect.bisect_right(aa, re)\n            if ind == 0:\n                ans = max(ans, dp[i])\n            else:\n                ind = min(i - 1, ind - 1)\n                ans = max(ans, mat[i][1] + dp[ind])\n        if mat[i][0] == d:\n            ans = max(ans, mat[i][1])\n    if mat[0][0] <= d:\n        ans = max(ans, mat[0][1])\n    return ans\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(solve(a, b, n, d))"]