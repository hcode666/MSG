["def max_count(arr):\n    x = arr.index(max(arr))\n    if x == 0 or x == len(arr) - 1:\n        return 1\n    else:\n        return min(max_count(arr[:x]), max_count(arr[x + 1:])) + 1\nfor _ in range(int(input())):\n    count = int(input())\n    lis = list(map(int, input().split()))\n    print(max_count(lis))", "def max_count(arr):\n    x = arr.index(max(arr))\n    if x == 0 or x == len(arr) - 1:\n        return 1\n    else:\n        return min(max_count(arr[:x]), max_count(arr[x + 1:])) + 1\nfor _ in range(int(input())):\n    count = int(input())\n    lis = list(map(int, input().split()))\n    print(max_count(lis))", "def max_count(arr):\n    x = arr.index(max(arr))\n    if x == 0 or x == len(arr) - 1:\n        return 1\n    else:\n        return min(max_count(arr[:x]), max_count(arr[x + 1:])) + 1\nfor _ in range(int(input())):\n    count = int(input())\n    lis = list(map(int, input().split()))\n    print(max_count(lis))", "def solve(a, l, r):\n    pos = None\n    for i in range(l, r + 1):\n        if pos == None or a[i] >= a[pos]:\n            pos = i\n    if pos == l or pos == r:\n        return 1\n    return 1 + min(solve(a, l, pos - 1), solve(a, pos + 1, r))\n\ndef main():\n    t = int(input())\n    while t:\n        n = int(input())\n        str = input()\n        a = [int(x) for x in str.split()]\n        print(solve(a, 0, n - 1))\n        t -= 1\nmain()", "def solve(a, l, r):\n    pos = None\n    for i in range(l, r + 1):\n        if pos == None or a[i] >= a[pos]:\n            pos = i\n    if pos == l or pos == r:\n        return 1\n    return 1 + min(solve(a, l, pos - 1), solve(a, pos + 1, r))\n\ndef main():\n    t = int(input())\n    while t:\n        n = int(input())\n        str = input()\n        a = [int(x) for x in str.split()]\n        print(solve(a, 0, n - 1))\n        t -= 1\nmain()", "def solve(h):\n    x = h.index(max(h))\n    if x == 0 or x == len(h) - 1:\n        return 1\n    else:\n        return min([solve(h[x + 1:]), solve(h[:x])]) + 1\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(solve(h))", "def snek(h):\n    x = h.index(max(h))\n    if x == 0 or x == len(h) - 1:\n        return 1\n    else:\n        return min([snek(h[x + 1:]), snek(h[:x])]) + 1\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(snek(h))", "def snek(h):\n    x = h.index(max(h))\n    if x == 0 or x == len(h) - 1:\n        return 1\n    else:\n        return min([snek(h[x + 1:]), snek(h[:x])]) + 1\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(snek(h))", "def res(h):\n    i = h.index(max(h))\n    return 1 if i == 0 or i == len(h) - 1 else 1 + min([res(h[i + 1:]), res(h[:i])])\nfor _ in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(res(h))", "def res(h):\n    i = h.index(max(h))\n    return 1 if i == 0 or i == len(h) - 1 else 1 + min([res(h[i + 1:]), res(h[:i])])\nfor _ in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(res(h))", "def res(h):\n    i = h.index(max(h))\n    l = len(h)\n    if i == 0 or i == l - 1:\n        return 1\n    return 1 + min([res(h[i + 1:]), res(h[:i])])\nfor _ in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(res(h))", "def res(h):\n    i = 0\n    m = 0\n    for (ind, val) in enumerate(h):\n        if val > m:\n            m = val\n            i = ind\n    l = len(h)\n    if i == 0 or i == l - 1:\n        return 1\n    return 1 + min([res(h[i + 1:]), res(h[:i])])\nfor _ in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(res(h))", "def water(l):\n    m = l.index(max(l))\n    if m == 0 or m == len(l) - 1:\n        return 1\n    return 1 + min(water(l[0:m]), water(l[m + 1:]))\ntry:\n    tc = int(input())\n    for test in range(tc):\n        n = int(input())\n        l = list(map(int, input().split()))\n        print(water(l))\nexcept:\n    pass", "def water(l):\n    m = l.index(max(l))\n    if m == 0 or m == len(l) - 1:\n        return 1\n    return 1 + min(water(l[0:m]), water(l[m + 1:]))\ntry:\n    tc = int(input())\n    for test in range(tc):\n        n = int(input())\n        l = list(map(int, input().split()))\n        print(water(l))\nexcept:\n    pass", "def solve(l):\n    m = l.index(max(l))\n    if m == 0 or m == len(l) - 1:\n        return 1\n    return 1 + min(solve(l[0:m]), solve(l[m + 1:]))\ntc = int(input())\nfor test in range(tc):\n    n = int(input())\n    l = list(map(int, input().split()))\n    print(solve(l))", "def solve(l):\n    m = l.index(max(l))\n    if m == 0 or m == len(l) - 1:\n        return 1\n    return 1 + min(solve(l[0:m]), solve(l[m + 1:]))\ntc = int(input())\nfor test in range(tc):\n    n = int(input())\n    l = list(map(int, input().split()))\n    print(solve(l))", "def solve(l):\n    m = l.index(max(l))\n    if m == 0 or m == len(l) - 1:\n        return 1\n    return 1 + min(solve(l[0:m]), solve(l[m + 1:]))\ntc = int(input())\nfor test in range(tc):\n    n = int(input())\n    l = list(map(int, input().split()))\n    print(solve(l))", "def hill(lst):\n    maxm = lst.index(max(lst))\n    if maxm == 0 or maxm == len(lst) - 1:\n        return 1\n    else:\n        return 1 + min(hill(lst[:maxm]), hill(lst[maxm + 1:]))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    lst = list(map(int, input().split(' ')))\n    print(hill(lst))", "def reservoirs(lhills):\n    hmax = lhills[0]\n    for i in lhills:\n        if i > hmax:\n            hmax = i\n    j = lhills.index(hmax)\n    if j == 0 or j == len(lhills) - 1:\n        return 1\n    else:\n        return 1 + min(reservoirs(lhills[:j]), reservoirs(lhills[j + 1:]))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    lhills = list(map(int, input().strip().split()))\n    print(reservoirs(lhills))", "def p(l):\n    n2 = len(l)\n    m = l.index(max(l))\n    if m < 1 or m > n2 - 2:\n        return 1\n    return 1 + min(p(l[:m]), p(l[m + 1:]))\nt = int(input())\nsolution = []\nfor r in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    solution.append(p(a))\nprint(*solution, sep='\\n')", "def get_count(hills):\n    max_ = hills.index(max(hills))\n    if not max_ or max_ == len(hills) - 1:\n        return 1\n    return 1 + min(get_count(hills[:max_]), get_count(hills[max_ + 1:]))\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(get_count(arr))", "def select_hill(hills):\n    m = hills.index(max(hills))\n    if m == 0 or m == len(hills) - 1:\n        return 1\n    else:\n        return 1 + min(select_hill(hills[:m]), select_hill(hills[m + 1:]))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    hills = list(map(int, input().split()))\n    print(select_hill(hills))", "import math\n\ndef res(n):\n    l = len(n)\n    maxx = max(n)\n    i = n.index(maxx)\n    if i == 0 or i == l - 1:\n        return 1\n    else:\n        return 1 + min(res(n[:i]), res(n[i + 1:]))\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    print(res(l))", "import math\n\ndef res(n):\n    l = len(n)\n    maxx = max(n)\n    i = 0\n    i = n.index(maxx)\n    if i == 0 or i == l - 1:\n        return 1\n    else:\n        return 1 + min(res(n[:i]), res(n[i + 1:]))\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    print(res(l))", "import math\n\ndef res(n):\n    l = len(n)\n    maxx = max(n)\n    i = 0\n    i = n.index(maxx)\n    if i == 0 or i == l - 1:\n        return 1\n    else:\n        return 1 + min(res(n[:i]), res(n[i + 1:]))\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    l = list(map(int, input().split()))\n    print(res(l))", "T = int(input())\n\ndef maxk(arr, start, end):\n    maxno = arr[start]\n    maxi = start\n    for i in range(start, end):\n        if arr[i] > maxno:\n            maxno = arr[i]\n            maxi = i\n    return maxi\n\ndef rec(arr, start, end):\n    i = maxk(arr, start, end)\n    if i == start or i == end - 1:\n        return 1\n    else:\n        return 1 + min(rec(arr, i + 1, end), rec(arr, start, i))\nfor t in range(T):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    start = 0\n    end = n\n    count = rec(arr, start, end)\n    print(count)", "def rec(h, low, high):\n    maxIndex = low\n    for i in range(low + 1, high + 1):\n        if h[i] > h[maxIndex]:\n            maxIndex = i\n    if maxIndex == low or maxIndex == high:\n        return 1\n    else:\n        return 1 + min(rec(h, low, maxIndex - 1), rec(h, maxIndex + 1, high))\nt = int(input())\nfor T in range(t):\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(rec(h, 0, n - 1))", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n\n    def func(l):\n        m = max(l)\n        m = l.index(m)\n        if m == len(l) - 1 or m == 0:\n            return 1\n        ll = l[:m]\n        rl = l[m + 1:]\n        return 1 + min(func(rl), func(ll))\n    print(func(l))", "for i in range(int(input())):\n    n = int(input())\n    count = 0\n    hill = list(map(int, input().split()))\n\n    def res(hills):\n        maxval = max(hills)\n        maxpos = hills.index(maxval)\n        left = list()\n        right = list()\n        if maxpos is 0 or maxpos is len(hills) - 1:\n            return 1\n        for j in range(maxpos):\n            left.append(hills[j])\n        for j in range(maxpos + 1, len(hills)):\n            right.append(hills[j])\n        return 1 + min(res(right), res(left))\n    print(res(hill))", "for _ in range(0, int(input())):\n    N = int(input())\n    count = 0\n    hillsH = list(map(int, input().split()))\n\n    def FindAns(hills):\n        maxIndex = 0\n        maxNum = max(hills)\n        maxIndex = hills.index(maxNum)\n        listRight = []\n        listLeft = []\n        if maxIndex == 0 or maxIndex == len(hills) - 1:\n            return 1\n        for i in range(0, maxIndex):\n            listLeft.append(hills[i])\n        for i in range(maxIndex + 1, len(hills)):\n            listRight.append(hills[i])\n        return 1 + min(FindAns(listLeft), FindAns(listRight))\n    print(FindAns(hillsH))", "for _ in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n\n    def res(a):\n        n = len(a)\n        max1 = max(a)\n        ind = 0\n        ind = a.index(max1)\n        if ind == 0 or ind == n - 1:\n            return 1\n        else:\n            return 1 + min(res(a[:ind]), res(a[ind + 1:]))\n    print(res(h))", "from functools import lru_cache\nkases = int(input())\nwhile kases > 0:\n    kases = kases - 1\n    T = int(input())\n    arr = list(map(int, input().split(' ')))\n\n    @lru_cache(maxsize=500)\n    def ans(i, j):\n        if i > j:\n            return 0\n        val = arr[i]\n        x = i\n        k = i\n        while k <= j:\n            if arr[k] > val:\n                val = arr[k]\n                x = k\n            k = k + 1\n        if x == i or x == j:\n            return 1\n        return 1 + min(ans(i, x - 1), ans(x + 1, j))\n    print(ans(0, T - 1))", "def res(n):\n    l = len(n)\n    maxx = max(n)\n    i = 0\n    i = n.index(maxx)\n    if i == 0 or i == l - 1:\n        return 1\n    else:\n        return 1 + min(res(n[:i]), res(n[i + 1:]))\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    l = list(map(int, input().split()))\n    print(res(l))", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    h = list(map(int, input().split()))\n\n    def res(a):\n        n = len(a)\n        max1 = max(a)\n        ind = 0\n        ind = a.index(max1)\n        if ind == 0 or ind == n - 1:\n            return 1\n        else:\n            return 1 + min(res(a[:ind]), res(a[ind + 1:]))\n    print(res(h))", "def find_max(A, s, e):\n    m = 0\n    m_index = s\n    for i in range(s, e + 1):\n        if A[i] > m:\n            m = A[i]\n            m_index = i\n    return m_index\n\ndef solution(A, s, e, ans):\n    m_index = find_max(A, s, e)\n    if m_index == s or m_index == e:\n        ans = ans + 1\n        return ans\n    return min(solution(A, m_index + 1, e, ans + 1), solution(A, s, m_index - 1, ans + 1))\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    ans = solution(A, 0, N - 1, 0)\n    print(ans)", "def large(a, i, j):\n    b = i\n    maxo = a[i]\n    t = i\n    while b <= j:\n        if a[b] > maxo:\n            maxo = a[b]\n            t = b\n        b = b + 1\n    return t\n\ndef f(a, i, j, count):\n    p = large(a, i, j)\n    if p == i or p == j:\n        count = count + 1\n        return count\n    else:\n        return min(f(a, i, p - 1, count + 1), f(a, p + 1, j, count + 1))\nt = int(input())\nfor x in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(f(a, 0, n - 1, 0))", "def solve(ar):\n    max = 0\n    posn = -1\n    for i in range(len(ar)):\n        if ar[i] > max:\n            max = ar[i]\n            posn = i\n    if posn == 0 or posn == len(ar) - 1:\n        return 1\n    return 1 + min(solve(ar[:posn]), solve(ar[posn + 1:]))\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    h = list(map(int, input().split()))\n    z = solve(h)\n    print(z)", "T = int(input())\nfrom copy import copy\n\ndef dfs(lst):\n    topi = -1\n    topv = 0\n    for (i, e) in enumerate(lst):\n        if topv < e:\n            topv = e\n            topi = i\n    if topi == 0 or topi == len(lst) - 1:\n        return 1\n    else:\n        return 1 + min(dfs(lst[:topi]), dfs(lst[topi + 1:]))\nfor t in range(T):\n    N = int(input())\n    H = list(map(int, input().split()))\n    ans = dfs(H)\n    print(ans)", "T = int(input())\n\ndef func(l):\n    m = l.index(max(l))\n    if m == 0 or m == len(l) - 1:\n        return 1\n    else:\n        return 1 + min(func(l[:m]), func(l[m + 1:]))\nfor i in range(T):\n    N = int(input())\n    l = list(map(int, input().split()))\n    print(func(l))", "def sol(A):\n    ci = A.index(max(A))\n    if ci == 0 or ci == len(A) - 1:\n        return 1\n    return 1 + min(sol(A[0:ci]), sol(A[ci + 1:]))\nfor _ in range(int(input())):\n    n = int(input())\n    l = [int(i) for i in input().split()]\n    print(sol(l))", "def main():\n    t = int(input())\n    for z in range(t):\n        n = int(input())\n        li = list(map(int, input().split()))\n        print(no_cal(li))\n\ndef no_cal(li):\n    index = li.index(max(li))\n    if index == 0 or index == len(li) - 1:\n        return 1\n    else:\n        return 1 + min(no_cal(li[:index]), no_cal(li[index + 1:]))\nmain()", "def divide(A, l, r):\n    m = -1\n    maxi = 0\n    for i in range(l, r + 1):\n        if A[i] > maxi:\n            maxi = A[i]\n            m = i\n    if m == l or m == r:\n        return 1\n    else:\n        return 1 + min(divide(A, l, m - 1), divide(A, m + 1, r))\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    k = divide(A, 0, n - 1)\n    print(k)\n    t -= 1", "def short_path(h, lower, upper, maxi, dic):\n    if lower == maxi or upper == maxi:\n        return 1\n    else:\n        return 1 + min(short_path(h, maxi + 1, upper, dic[max(h[maxi + 1:upper + 1])], dic), short_path(h, lower, maxi - 1, dic[max(h[lower:maxi])], dic))\nt = int(input())\nfor it in range(t):\n    size = int(input())\n    h = list(map(int, input().split()))\n    dic = dict()\n    for i in range(len(h)):\n        dic[h[i]] = i\n    print(short_path(h, 0, len(h) - 1, dic[max(h)], dic))", "def sol(A):\n    ci = A.index(max(A))\n    if ci == 0 or ci == len(A) - 1:\n        return 1\n    else:\n        return 1 + min(sol(A[:ci]), sol(A[ci + 1:]))\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    count = 0\n    print(sol(A))", "def water(left, right, h):\n    ma = 0\n    for i in range(left, right + 1):\n        if h[i] > ma:\n            ma = h[i]\n            mai = i\n    if mai == left or mai == right:\n        return 1\n    else:\n        return 1 + min(water(left, mai - 1, h), water(mai + 1, right, h))\nt = int(input())\nwhile t:\n    n = int(input())\n    h = list(map(int, input().split()))\n    ans = water(0, n - 1, h)\n    print(ans)\n    t = t - 1", "def water(hills):\n    currIndex = hills.index(max(hills))\n    n = len(hills)\n    if currIndex == 0 or currIndex == n - 1:\n        return 1\n    return 1 + min(water(hills[:currIndex]), water(hills[currIndex + 1:]))\nt = int(input())\nfor tcase in range(t):\n    n = int(input())\n    nums = [int(el) for el in input().split()]\n    print(water(nums))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    lis = list(map(int, input().split()))\n\n    def f(a, b):\n        m = a\n        for i in range(a, b + 1):\n            if lis[m] < lis[i]:\n                m = i\n        if m == a or m == b:\n            return 1\n        return 1 + min(f(a, m - 1), f(m + 1, b))\n    print(f(0, n - 1))", "t = int(input())\n\ndef largest(a, d, n):\n    max = d\n    for i in range(d, n):\n        if a[i] > a[max]:\n            max = i\n    return max\n\ndef pump(a, d, n):\n    if d == n:\n        return 0\n    cur = largest(a, d, n)\n    if cur == d or cur == n - 1:\n        return 1\n    else:\n        e = pump(a, d, cur)\n        f = pump(a, cur + 1, n)\n        return 1 + min(e, f)\nwhile t:\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(pump(a, 0, n))\n    t = t - 1", "t = int(input())\n\ndef maxcof(arr):\n    i = 0\n    max = 0\n    for i in range(1, len(arr)):\n        if arr[i] > arr[max]:\n            max = i\n    return max\n\ndef splitarr(arr):\n    x = maxcof(arr)\n    temp1 = arr[x + 1:]\n    temp2 = arr[:x]\n    if len(temp1) == 0 or len(temp2) == 0:\n        return 1\n    else:\n        m = min(splitarr(temp1), splitarr(temp2))\n        return m + 1\nfor i in range(t):\n    n = int(input())\n    count = 0\n    inp = list(map(int, input().split()))\n    print(splitarr(inp))", "def fun(b):\n    i = b.index(max(b))\n    n = len(b)\n    if i == 0 or i == n - 1:\n        return 1\n    else:\n        return 1 + min(fun(b[0:i]), fun(b[i + 1:]))\nfor _ in range(int(input())):\n    a = int(input())\n    count = 0\n    b = [int(x) for x in input().split()]\n    print(fun(b))", "def solve(a):\n    m = a.index(max(a))\n    if m == 0 or m == len(a) - 1:\n        return 1\n    return 1 + min(solve(a[0:m]), solve(a[m + 1:]))\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(a) for a in input().split()]\n    print(solve(a))", "def solve(a):\n    m = a.index(max(a))\n    if m == 0 or m == len(a) - 1:\n        return 1\n    return 1 + min(solve(a[0:m]), solve(a[m + 1:]))\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(a) for a in input().split()]\n    print(solve(a))", "def res(a):\n    ind = a.index(max(a))\n    n = len(a)\n    if ind == 0 or ind == n - 1:\n        return 1\n    else:\n        return 1 + min(res(a[0:ind]), res(a[ind + 1:]))\nt = int(input())\nfor _ in range(0, t):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    print(res(lst))", "def get(l):\n    inde = l.index(max(l))\n    if inde == 0 or inde == len(l) - 1:\n        return 1\n    return 1 + min(get(l[0:inde]), get(l[inde + 1:]))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    print(get(l))", "def res(a):\n    ind = a.index(max(a))\n    n = len(a)\n    if ind == 0 or ind == n - 1:\n        return 1\n    else:\n        return 1 + min(res(a[0:ind]), res(a[ind + 1:]))\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    print(res(a))", "def func(a):\n    ind = a.index(max(a))\n    lgt = len(a)\n    if ind == 0 or ind == lgt - 1:\n        return 1\n    else:\n        return 1 + min(func(a[0:ind]), func(a[ind + 1:]))\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    print(func(a))", "def func(a):\n    k = a.index(max(a))\n    n = len(a)\n    if k == 0 or k == n - 1:\n        return 1\n    else:\n        return 1 + min(func(a[0:k]), func(a[k + 1:]))\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(func(a))", "def helper(l, count):\n    le = len(l)\n    if not l:\n        return count\n    count += 1\n    m = l.index(max(l))\n    if le - 1 == m or m == 0:\n        return count\n    x = helper(l[:m], count)\n    y = helper(l[m + 1:], count)\n    if x < y:\n        return x\n    else:\n        return y\n\ndef func():\n    n = int(input())\n    l = list(map(int, input().strip().split()))\n    print(helper(l, 0))\nt = int(input())\nfor i in range(t):\n    func()", "T = int(input())\n\ndef Number(A):\n    if len(A) == 0:\n        return 0\n    elif len(A) == 1:\n        return 1\n    x = max(A)\n    if A.index(x) == 0 or A.index(x) == len(A) - 1:\n        return 1\n    return 1 + min(Number(A[:A.index(x)]), Number(A[A.index(x) + 1:]))\nfor i in range(T):\n    N = int(input())\n    H = list(map(int, input().split()))\n    print(Number(H))", "def find_res(heights):\n    pos = heights.index(max(heights))\n    if pos == len(heights) - 1 or pos == 0:\n        return 1\n    return 1 + min(find_res(heights[:pos]), find_res(heights[pos + 1:]))\nfor _ in range(int(input())):\n    n = int(input())\n    heights = list(map(int, input().strip().split()))\n    print(find_res(heights))", "def find(l, h, a):\n    m = -1\n    idx = 0\n    for i in range(l, h + 1):\n        if m < a[i]:\n            m = a[i]\n            idx = i\n    return idx\n\ndef solve(l, h, a):\n    m = find(l, h, a)\n    if l == h:\n        return 1\n    if m == l or m == h:\n        return 1\n    else:\n        return 1 + min(solve(l, m - 1, a), solve(m + 1, h, a))\nfor t in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    print(solve(0, n - 1, l))", "def find(l, h, a):\n    m = -1\n    idx = 0\n    for i in range(l, h + 1):\n        if m < a[i]:\n            m = a[i]\n            idx = i\n    return idx\n\ndef solve(l, h, a):\n    m = find(l, h, a)\n    if l == h:\n        return 1\n    if m == l or m == h:\n        return 1\n    else:\n        return 1 + min(solve(l, m - 1, a), solve(m + 1, h, a))\nfor t in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    print(solve(0, n - 1, l))", "def f(height):\n    ind = height.index(max(height))\n    n = len(height)\n    if ind == 0 or ind == n - 1:\n        return 1\n    else:\n        return 1 + min(f(height[0:ind]), f(height[ind + 1:]))\ntest = int(input())\nwhile test:\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(f(h))\n    test = test - 1", "def hills(l: list, s: int, e: int):\n    m = -1\n    k = -1\n    for i in range(s, e + 1):\n        if l[i] > m:\n            m = l[i]\n            k = i\n    if m in (l[s], l[e]):\n        return 1\n    else:\n        return 1 + min(hills(l, s, k - 1), hills(l, k + 1, e))\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    (c, k) = (0, 0)\n    print(hills(a, 0, n - 1))", "def f(l, n, c, k):\n    x = 0\n    if k == n:\n        return c\n    m = -1\n    for i in range(k, n):\n        if m < l[i]:\n            m = l[i]\n            x = i\n    c += 1\n    (a, b) = (f(l, n, c, x + 1), f(l, x, c, k))\n    if a < b:\n        return a\n    else:\n        return b\n\ndef f1(l: list, s: int, e: int):\n    m = -1\n    k = -1\n    for i in range(s, e + 1):\n        if l[i] > m:\n            m = l[i]\n            k = i\n    if m in (l[s], l[e]):\n        return 1\n    else:\n        return 1 + min(f1(l, s, k - 1), f1(l, k + 1, e))\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    (c, k) = (0, 0)\n    print(f1(a, 0, n - 1))", "def helper(l, count):\n    le = len(l)\n    if not l:\n        return count\n    count += 1\n    m = l.index(max(l))\n    if le - 1 == m or m == 0:\n        return count\n    x = helper(l[:m], count)\n    y = helper(l[m + 1:], count)\n    if x < y:\n        return x\n    else:\n        return y\n\ndef func():\n    n = int(input())\n    l = list(map(int, input().strip().split()))\n    print(helper(l, 0))\nt = int(input())\nfor i in range(t):\n    func()", "def res(a):\n    ind = a.index(max(a))\n    n = len(a)\n    if ind == 0 or ind == n - 1:\n        return 1\n    else:\n        return 1 + min(res(a[0:ind]), res(a[ind + 1:]))\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(res(a))", "def count(a):\n    m = a.index(max(a))\n    n = len(a)\n    if n == 1:\n        return 1\n    elif m == 0 or m == n - 1:\n        return 1\n    else:\n        return 1 + min(count(a[:m]), count(a[m + 1:]))\nt = int(input())\nfor itr in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(count(a))", "def minres(h, n):\n    i = h.index(max(h))\n    return 1 if i == 0 or i == n - 1 else min(minres(h[:i], i), minres(h[i + 1:], n - i - 1)) + 1\nfor _ in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(minres(h, n))", "def rec(h):\n    maxi = max(h)\n    ind = h.index(maxi)\n    if ind == 0 or ind == len(h) - 1:\n        return 1\n    else:\n        return min(rec(h[:ind]), rec(h[ind + 1:])) + 1\nfor _ in range(int(input())):\n    n = int(input())\n    h = [int(n) for n in input().split()]\n    print(rec(h))", "t = int(input())\n\ndef pump(arr, n):\n    count = 0\n    maxHeight = arr.index(max(arr))\n    if maxHeight == 0 or maxHeight == n - 1:\n        return 1\n    leftRes = pump(arr[:maxHeight], maxHeight)\n    rightRes = pump(arr[maxHeight + 1:], n - maxHeight - 1)\n    if leftRes > rightRes:\n        count = count + rightRes + 1\n    else:\n        count = count + leftRes + 1\n    return count\nfor i in range(t):\n    n = int(input())\n    arr = list(map(int, input().split(' ')))\n    result = pump(arr, n)\n    print(result)", "import sys\n\ndef countr(s):\n    highest = max(s)\n    indexh = s.index(highest)\n    n = len(s)\n    if indexh == 0 or indexh == n - 1:\n        return 1\n    left = s[:indexh]\n    right = s[indexh + 1:]\n    return min(countr(left), countr(right)) + 1\n\ndef main():\n    T = int(input())\n    D = {}\n    for i in range(T):\n        N = int(input())\n        H = [int(item) for item in input().split()]\n        D[i] = (N, H)\n    for (k, v) in D.items():\n        (N, H) = v\n        print(countr(H))\n    return 0\nmain()", "def reservoir(a):\n    ind = a.index(max(a))\n    if ind == len(a) - 1 or ind == 0:\n        return 1\n    else:\n        return min(reservoir(a[:ind]), reservoir(a[ind + 1:])) + 1\nfor t in range(int(input())):\n    n = int(input())\n    a = []\n    for i in input().split():\n        a.append(int(i))\n    print(reservoir(a))", "from sys import stdin\nmax_val = int(10000000000000.0)\nmin_val = int(-10000000000000.0)\n\ndef read_int():\n    return int(stdin.readline())\n\ndef read_ints():\n    return [int(x) for x in stdin.readline().split()]\n\ndef read_str():\n    return input()\n\ndef read_strs():\n    return [x for x in stdin.readline().split()]\n\ndef needed(hts):\n    maxi = hts.index(max(hts))\n    if maxi == 0 or maxi == len(hts) - 1:\n        return 1\n    else:\n        return 1 + min(needed(hts[:maxi]), needed(hts[maxi + 1:]))\nnb_test = read_int()\nfor _ in range(nb_test):\n    nb_hills = read_int()\n    heights = read_ints()\n    print(needed(heights))", "def result(a):\n    ind = a.index(max(a))\n    n = len(a)\n    if ind == 0 or ind == n - 1:\n        return 1\n    else:\n        return 1 + min(result(a[0:ind]), result(a[ind + 1:]))\ntc = int(input())\nwhile tc > 0:\n    n = int(input())\n    hill = list(map(int, input().split()))\n    print(result(hill))\n    tc -= 1", "def solve(st, ed):\n    if st > ed:\n        return 0\n    if st == ed:\n        return 1\n    ab = max(b[st:ed + 1])\n    if ab[1] == st or ab[1] == ed:\n        return 1\n    return 1 + min(solve(st, ab[1] - 1), solve(ab[1] + 1, ed))\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [[a[i], i] for i in range(n)]\n    print(solve(0, n - 1))", "def min_pumps(lst):\n    if not lst:\n        return 0\n    r = 0\n    for i in range(len(lst)):\n        if lst[i] > lst[r]:\n            r = i\n    if r == 0 or r == len(lst):\n        return 1\n    return 1 + min(min_pumps(lst[:r]), min_pumps(lst[r + 1:]))\nfor _ in range(int(input())):\n    input()\n    hills = list(map(int, input().split()))\n    print(min_pumps(hills))", "def func(l):\n    ind = l.index(max(l))\n    n = len(l)\n    if ind == 0 or ind == n - 1:\n        return 1\n    else:\n        return 1 + min(func(l[ind + 1:]), func(l[:ind]))\nfor i in range(int(input())):\n    n = int(input())\n    l = [int(x) for x in input().split()]\n    print(func(l))", "def res(arr):\n    max_a = max(arr)\n    if len(arr) == 0:\n        return 0\n    if arr[0] == max_a or arr[-1] == max_a:\n        return 1\n    else:\n        index = arr.index(max_a)\n        count_1 = res(arr[:index])\n        count_2 = res(arr[index + 1:])\n    return min(count_2, count_1) + 1\nt = int(input())\nfor a in range(t):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    count = 0\n    max_a = max(arr)\n    mid = len(arr) // 2\n    count = res(arr)\n    print(count)", "def find(ar):\n    mx = max(ar)\n    ind = ar.index(mx)\n    n = len(ar)\n    if ind == 0 or ind == n - 1:\n        return 1\n    else:\n        return 1 + min(find(ar[0:ind]), find(ar[ind + 1:]))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    print(find(ar))", "def solve(l):\n    m = l.index(max(l))\n    if m == 0 or m == len(l) - 1:\n        return 1\n    return 1 + min(solve(l[0:m]), solve(l[m + 1:]))\ntc = int(input())\nfor test in range(tc):\n    n = int(input())\n    l = list(map(int, input().split()))\n    print(solve(l))", "def get_max_index(heights, s, e):\n    max_val = heights[s]\n    index = s\n    for i in range(s + 1, e + 1):\n        if heights[i] > max_val:\n            max_val = heights[i]\n            index = i\n    return index\n\ndef get_min_num_of_reserviors(heights, i, j):\n    if i > j:\n        return 0\n    elif i == j:\n        return 1\n    else:\n        k = get_max_index(heights, i, j)\n        if k == i or k == j:\n            return 1\n        else:\n            return 1 + min(get_min_num_of_reserviors(heights, i, k - 1), get_min_num_of_reserviors(heights, k + 1, j))\nT = int(input())\nwhile T:\n    N = int(input())\n    heights = list(map(int, input().split()))\n    print(get_min_num_of_reserviors(heights, 0, N - 1))\n    T -= 1", "def res(a):\n    ind = a.index(max(a))\n    n = len(a)\n    if ind == 0 or ind == n - 1:\n        return 1\n    else:\n        return 1 + min(res(a[0:ind]), res(a[ind + 1:]))\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    print(res(a))", "def res(a):\n    ind = a.index(max(a))\n    n = len(a)\n    if ind == 0 or ind == n - 1:\n        return 1\n    else:\n        return 1 + min(res(a[0:ind]), res(a[ind + 1:]))\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    print(res(a))", "import sys\n\ndef getMaxReservoir(sortedHills, pos, left, right):\n    (heigth, index) = sortedHills[pos]\n    while index < left or index >= right:\n        pos += 1\n        (heigth, index) = sortedHills[pos]\n    diff = min(right - index, index - left + 1)\n    if diff < 3:\n        return diff\n    return 1 + min(getMaxReservoir(sortedHills, pos + 1, index + 1, right), getMaxReservoir(sortedHills, pos + 1, left, index))\nt = int(sys.stdin.readline())\nwhile t > 0:\n    n = int(sys.stdin.readline())\n    hs = list(map(int, sys.stdin.readline().split()))\n    hsSorted = []\n    for i in range(0, n):\n        hsSorted.append((hs[i], i))\n    hsSorted.sort(key=lambda tup: tup[0], reverse=True)\n    print(getMaxReservoir(hsSorted, 0, 0, n))\n    t -= 1", "import numpy as np\n\ndef calc(h):\n    if len(h) == 0:\n        return 0\n    ind = np.argmax(h)\n    if ind == 0 or ind == len(h) - 1:\n        return 1\n    else:\n        return min(calc(h[0:ind]), calc(h[ind + 1:len(h)])) + 1\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    h = list(map(int, input().split()))\n    val = calc(h)\n    print(val)", "for i in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    arr = []\n    arr.append(h)\n    l = 0\n    bre = 0\n    while True:\n        l = l + 1\n        c = []\n        for m in arr:\n            x = m.index(max(m))\n            p = len(m)\n            if x == 0 or x == p - 1:\n                bre += 1\n                break\n            else:\n                c.append(m[:x])\n                c.append(m[x + 1:])\n        arr = c[:]\n        if bre > 0:\n            break\n    print(l)", "import sys\nsys.setrecursionlimit(10000)\n\ndef func(arr, c=0):\n    if arr:\n        c += 1\n        m = 0\n        for i in range(len(arr)):\n            if arr[i] > m:\n                j = i\n                m = arr[i]\n        if j == 0 or j == len(arr) - 1:\n            return c\n        else:\n            a = func(arr[:j], c)\n            b = func(arr[j + 1:], c)\n        return min(a, b)\n    else:\n        return c\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    c = func(arr)\n    print(c)", "import numpy as np\n\ndef modbin(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    max_id = np.argmax(arr)\n    if max_id == 0 or max_id == n - 1:\n        return 1\n    else:\n        return min(modbin(arr[0:max_id]), modbin(arr[max_id + 1:n])) + 1\nfor i in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(modbin(h))", "def solve(st, ed):\n    if st > ed:\n        return 0\n    if st == ed:\n        return 1\n    ab = max(b[st:ed + 1])\n    if ab[1] == st or ab[1] == ed:\n        return 1\n    return 1 + min(solve(st, ab[1] - 1), solve(ab[1] + 1, ed))\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [[a[i], i] for i in range(n)]\n    print(solve(0, n - 1))", "def coun(c, a):\n    n = len(a)\n    m = a.index(max(a))\n    if n == 1:\n        return c + 1\n    elif m == 0 or m == n - 1:\n        return c + 1\n    c1 = coun(c + 1, a[m + 1:])\n    c2 = coun(c + 1, a[:m])\n    return min(c1, c2)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = 0\n    print(coun(c, a))"]