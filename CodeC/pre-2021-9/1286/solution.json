["mod = 10 ** 9 + 7\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    l = sorted(arr)\n    prev = -1\n    for i in range(n):\n        if l[i] - prev > 1:\n            break\n        prev = l[i]\n    m = prev + 1\n    d = {}\n    for i in range(n):\n        if arr[i] > m:\n            continue\n        d[arr[i]] = d.get(arr[i], 0) + 1\n    p = n - 1\n    while p >= 0:\n        if arr[p] < m:\n            if d[arr[p]] == 1:\n                break\n            else:\n                d[arr[p]] = d[arr[p]] - 1\n        p = p - 1\n    p = p + 1\n    p = max(1, p)\n    dp = [0] * (n + 1)\n    pref = [0] * (n + 1)\n    dp[0] = 1\n    pref[0] = 1\n    for i in range(1, p):\n        dp[i] = 0\n        pref[i] = 1\n    dp[p] = 1\n    pref[p] = 2\n    p = p + 1\n    prev = 1\n    while p <= n:\n        if arr[p - 1] < m:\n            d[arr[p - 1]] = d[arr[p - 1]] + 1\n        while prev < p:\n            if arr[prev - 1] < m:\n                if d[arr[prev - 1]] == 1:\n                    break\n                else:\n                    d[arr[prev - 1]] = d[arr[prev - 1]] - 1\n            prev = prev + 1\n        dp[p] = pref[prev - 1]\n        pref[p] = (pref[p - 1] + dp[p]) % mod\n        p = p + 1\n    print(dp[n])", "mod = 10 ** 9 + 7\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    l = sorted(arr)\n    prev = -1\n    for i in range(n):\n        if l[i] - prev > 1:\n            break\n        prev = l[i]\n    m = prev + 1\n    d = {}\n    for i in range(n):\n        if arr[i] > m:\n            continue\n        d[arr[i]] = d.get(arr[i], 0) + 1\n    p = n - 1\n    while p >= 0:\n        if arr[p] < m:\n            if d[arr[p]] == 1:\n                break\n            else:\n                d[arr[p]] = d[arr[p]] - 1\n        p = p - 1\n    p = p + 1\n    p = max(1, p)\n    dp = [0] * (n + 1)\n    pref = [0] * (n + 1)\n    dp[0] = 1\n    pref[0] = 1\n    for i in range(1, p):\n        dp[i] = 0\n        pref[i] = 1\n    dp[p] = 1\n    pref[p] = 2\n    p = p + 1\n    prev = 1\n    while p <= n:\n        if arr[p - 1] < m:\n            d[arr[p - 1]] = d[arr[p - 1]] + 1\n        while prev < p:\n            if arr[prev - 1] < m:\n                if d[arr[prev - 1]] == 1:\n                    break\n                else:\n                    d[arr[prev - 1]] = d[arr[prev - 1]] - 1\n            prev = prev + 1\n        dp[p] = pref[prev - 1]\n        pref[p] = (pref[p - 1] + dp[p]) % mod\n        p = p + 1\n    print(dp[n])", "mod = 10 ** 9 + 7\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    l = sorted(arr)\n    prev = -1\n    for i in range(n):\n        if l[i] - prev > 1:\n            break\n        prev = l[i]\n    m = prev + 1\n    d = {}\n    for i in range(n):\n        if arr[i] > m:\n            continue\n        d[arr[i]] = d.get(arr[i], 0) + 1\n    p = n - 1\n    while p >= 0:\n        if arr[p] < m:\n            if d[arr[p]] == 1:\n                break\n            else:\n                d[arr[p]] = d[arr[p]] - 1\n        p = p - 1\n    p = p + 1\n    p = max(1, p)\n    dp = [0] * (n + 1)\n    pref = [0] * (n + 1)\n    dp[0] = 1\n    pref[0] = 1\n    for i in range(1, p):\n        dp[i] = 0\n        pref[i] = 1\n    dp[p] = 1\n    pref[p] = 2\n    p = p + 1\n    prev = 1\n    while p <= n:\n        if arr[p - 1] < m:\n            d[arr[p - 1]] = d[arr[p - 1]] + 1\n        while prev < p:\n            if arr[prev - 1] < m:\n                if d[arr[prev - 1]] == 1:\n                    break\n                else:\n                    d[arr[prev - 1]] = d[arr[prev - 1]] - 1\n            prev = prev + 1\n        dp[p] = pref[prev - 1]\n        pref[p] = (pref[p - 1] + dp[p]) % mod\n        p = p + 1\n    print(dp[n])", "mod = 10 ** 9 + 7\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    l = sorted(arr)\n    prev = -1\n    for i in range(n):\n        if l[i] - prev > 1:\n            break\n        prev = l[i]\n    m = prev + 1\n    d = {}\n    for i in range(n):\n        if arr[i] > m:\n            continue\n        d[arr[i]] = d.get(arr[i], 0) + 1\n    p = n - 1\n    while p >= 0:\n        if arr[p] < m:\n            if d[arr[p]] == 1:\n                break\n            else:\n                d[arr[p]] = d[arr[p]] - 1\n        p = p - 1\n    p = p + 1\n    p = max(1, p)\n    dp = [0] * (n + 1)\n    pref = [0] * (n + 1)\n    dp[0] = 1\n    pref[0] = 1\n    for i in range(1, p):\n        dp[i] = 0\n        pref[i] = 1\n    dp[p] = 1\n    pref[p] = 2\n    p = p + 1\n    prev = 1\n    while p <= n:\n        if arr[p - 1] < m:\n            d[arr[p - 1]] = d[arr[p - 1]] + 1\n        while prev < p:\n            if arr[prev - 1] < m:\n                if d[arr[prev - 1]] == 1:\n                    break\n                else:\n                    d[arr[prev - 1]] = d[arr[prev - 1]] - 1\n            prev = prev + 1\n        dp[p] = pref[prev - 1]\n        pref[p] = (pref[p - 1] + dp[p]) % mod\n        p = p + 1\n    print(dp[n])", "mod = 10 ** 9 + 7\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    l = sorted(arr)\n    prev = -1\n    for i in range(n):\n        if l[i] - prev > 1:\n            break\n        prev = l[i]\n    m = prev + 1\n    d = {}\n    for i in range(n):\n        if arr[i] > m:\n            continue\n        d[arr[i]] = d.get(arr[i], 0) + 1\n    p = n - 1\n    while p >= 0:\n        if arr[p] < m:\n            if d[arr[p]] == 1:\n                break\n            else:\n                d[arr[p]] = d[arr[p]] - 1\n        p = p - 1\n    p = p + 1\n    p = max(1, p)\n    dp = [0] * (n + 1)\n    pref = [0] * (n + 1)\n    dp[0] = 1\n    pref[0] = 1\n    for i in range(1, p):\n        dp[i] = 0\n        pref[i] = 1\n    dp[p] = 1\n    pref[p] = 2\n    p = p + 1\n    prev = 1\n    while p <= n:\n        if arr[p - 1] < m:\n            d[arr[p - 1]] = d[arr[p - 1]] + 1\n        while prev < p:\n            if arr[prev - 1] < m:\n                if d[arr[prev - 1]] == 1:\n                    break\n                else:\n                    d[arr[prev - 1]] = d[arr[prev - 1]] - 1\n            prev = prev + 1\n        dp[p] = pref[prev - 1]\n        pref[p] = (pref[p - 1] + dp[p]) % mod\n        p = p + 1\n    print(dp[n])", "mod = 10 ** 9 + 7\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    l = sorted(arr)\n    prev = -1\n    for i in range(n):\n        if l[i] - prev > 1:\n            break\n        prev = l[i]\n    m = prev + 1\n    d = {}\n    for i in range(n):\n        if arr[i] > m:\n            continue\n        d[arr[i]] = d.get(arr[i], 0) + 1\n    p = n - 1\n    while p >= 0:\n        if arr[p] < m:\n            if d[arr[p]] == 1:\n                break\n            else:\n                d[arr[p]] = d[arr[p]] - 1\n        p = p - 1\n    p = p + 1\n    p = max(1, p)\n    dp = [0] * (n + 1)\n    pref = [0] * (n + 1)\n    dp[0] = 1\n    pref[0] = 1\n    for i in range(1, p):\n        dp[i] = 0\n        pref[i] = 1\n    dp[p] = 1\n    pref[p] = 2\n    p = p + 1\n    prev = 1\n    while p <= n:\n        if arr[p - 1] < m:\n            d[arr[p - 1]] = d[arr[p - 1]] + 1\n        while prev < p:\n            if arr[prev - 1] < m:\n                if d[arr[prev - 1]] == 1:\n                    break\n                else:\n                    d[arr[prev - 1]] = d[arr[prev - 1]] - 1\n            prev = prev + 1\n        dp[p] = pref[prev - 1]\n        pref[p] = (pref[p - 1] + dp[p]) % mod\n        p = p + 1\n    print(dp[n])", "mod = 10 ** 9 + 7\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    l = sorted(arr)\n    prev = -1\n    for i in range(n):\n        if l[i] - prev > 1:\n            break\n        prev = l[i]\n    m = prev + 1\n    d = {}\n    for i in range(n):\n        if arr[i] > m:\n            continue\n        d[arr[i]] = d.get(arr[i], 0) + 1\n    p = n - 1\n    while p >= 0:\n        if arr[p] < m:\n            if d[arr[p]] == 1:\n                break\n            else:\n                d[arr[p]] = d[arr[p]] - 1\n        p = p - 1\n    p = p + 1\n    p = max(1, p)\n    dp = [0] * (n + 1)\n    pref = [0] * (n + 1)\n    dp[0] = 1\n    pref[0] = 1\n    for i in range(1, p):\n        dp[i] = 0\n        pref[i] = 1\n    dp[p] = 1\n    pref[p] = 2\n    p = p + 1\n    prev = 1\n    while p <= n:\n        if arr[p - 1] < m:\n            d[arr[p - 1]] = d[arr[p - 1]] + 1\n        while prev < p:\n            if arr[prev - 1] < m:\n                if d[arr[prev - 1]] == 1:\n                    break\n                else:\n                    d[arr[prev - 1]] = d[arr[prev - 1]] - 1\n            prev = prev + 1\n        dp[p] = pref[prev - 1]\n        pref[p] = (pref[p - 1] + dp[p]) % mod\n        p = p + 1\n    print(dp[n])", "from sys import stdin\ninput = stdin.readline\nmod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mexofa():\n    c = [0] * (size + 1)\n    for i in a:\n        c[i] += 1\n    for i in range(size + 1):\n        if c[i] == 0:\n            return i\n\ndef answer():\n    if mex == 0:\n        return pow(2, n - 1, mod)\n    c = [0] * (size + 1)\n    nextind = [-1] * n\n    m = 0\n    for i in range(n - 1, -1, -1):\n        if a[i] == m:\n            for j in range(a[i] + 1, size + 1):\n                if c[j] == 0:\n                    m = j\n                    break\n        c[a[i]] += 1\n        if m == mex:\n            nextind[n - 1] = i\n            break\n    need = -1\n    for i in range(n - 2, -1, -1):\n        c[a[i + 1]] -= 1\n        if c[a[i + 1]] == 0 and a[i + 1] < mex:\n            need = a[i + 1]\n        if need == -1:\n            nextind[i] = nextind[i + 1]\n            continue\n        for j in range(nextind[i + 1] - 1, -1, -1):\n            c[a[j]] += 1\n            if need == a[j]:\n                nextind[i] = j\n                break\n        need = -1\n    dp = [0] * (n + 1)\n    pf = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if nextind[i - 1] == -1:\n            continue\n        dp[i] = add(dp[i], pf[nextind[i - 1]] + 1)\n        pf[i] = add(pf[i], dp[i])\n        pf[i] = add(pf[i], pf[i - 1])\n    return dp[n]\nfor T in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    size = max(a) + 1\n    mex = mexofa()\n    print(answer())", "def find_mex(arr):\n    max_value = len(arr) + 1\n    all_possibles = set(range(max_value))\n    arr_values = set(arr)\n    omissions = all_possibles - arr_values\n    return min(omissions)\n\ndef calc_k(arr, mex):\n    DP = [None] * (len(arr) + 1)\n    for i in range(len(arr) + 1):\n        if mex:\n            DP[i] = [0, 0, 0]\n        else:\n            DP[i] = [1, 0, 0]\n    end_pointer = 0\n    start_pointer = 0\n    counts = {i: 0 for i in range(mex)}\n    missing_numbers = set([i for i in range(mex)])\n    while end_pointer < len(arr):\n        if arr[end_pointer] < mex:\n            counts[arr[end_pointer]] += 1\n            if counts[arr[end_pointer]] == 1:\n                missing_numbers.remove(arr[end_pointer])\n            while not missing_numbers:\n                DP[start_pointer][0] = end_pointer - start_pointer + 1\n                if arr[start_pointer] < mex:\n                    counts[arr[start_pointer]] -= 1\n                    if counts[arr[start_pointer]] == 0:\n                        missing_numbers.add(arr[start_pointer])\n                start_pointer += 1\n        end_pointer += 1\n    return DP\n\ndef calc_DP(DP):\n    M = 10 ** 9 + 7\n    for i in range(len(arr) - 1, -1, -1):\n        if testing:\n            print(i, DP[i], end='')\n        if DP[i][0]:\n            k = DP[i][0]\n            DP[i][1] = (1 + DP[i + k][2]) % M\n            DP[i][2] = (DP[i][1] + DP[i + 1][2]) % M\n            if testing:\n                print('->', DP[i])\n        elif testing:\n            print()\n    return DP\ntesting = False\nif testing:\n    arr = [1, 0, 0, 1, 0, 1]\n    mex = find_mex(arr)\n    print(arr, mex)\n    DP = calc_k(arr, mex)\n    print(DP)\n    print(calc_DP(DP))\n    arr = [1, 2, 3]\n    mex = find_mex(arr)\n    print(arr, mex)\n    DP = calc_k(arr, mex)\n    print(DP)\n    print(calc_DP(DP))\nT = int(input())\nfor tc in range(T):\n    N = int(input())\n    arr = [int(x) for x in input().strip().split(' ')]\n    mex = find_mex(arr)\n    DP = DP = calc_k(arr, mex)\n    print(calc_DP(DP)[0][1])", "def main():\n    mod = 10 ** 9 + 7\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int, input().split()))\n        xx = [0] * (n + 2)\n        for i in a:\n            xx[i] += 1\n        if min(a):\n            print(pow(2, n - 1, mod))\n            continue\n        for i in range(n + 2):\n            if not xx[i]:\n                m = i\n                break\n        req = [0] * m\n        done = m\n        dp = [-1] * n\n        i = n - 1\n        for j in range(n - 1, -1, -1):\n            if a[j] < len(req):\n                req[a[j]] += 1\n                if req[a[j]] == 1:\n                    done -= 1\n                while i != -1 and (not done):\n                    dp[i] = j\n                    if a[i] < len(req):\n                        req[a[i]] -= 1\n                        done += req[a[i]] == 0\n                    i -= 1\n        dp1 = [0] * n\n        pref = [1] + [0] * n\n        for i in range(n):\n            if dp[i] != -1:\n                dp1[i] = pref[dp[i]]\n            pref[i + 1] = (pref[i] + dp1[i]) % mod\n        print(dp1[-1])\nmain()", "import sys\nT = int(input())\nP = 1000000007\nfor t in range(T):\n    N = int(input())\n    A = list((int(x) for x in sys.stdin.readline().split()))\n    m1 = min(A)\n    if m1 > 0:\n        print(pow(2, N - 1, P))\n    else:\n        nums = [0] * 100001\n        for a in A:\n            nums[a] += 1\n        mex = -1\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                mex = i\n                break\n        T = []\n        mymap = [0] * mex\n        cnt = 0\n        j = 0\n        while j < N and cnt < mex:\n            val = A[j]\n            if val < mex:\n                if mymap[val] == 0:\n                    cnt += 1\n                mymap[val] += 1\n            j += 1\n            if cnt == mex:\n                T.append(1)\n                break\n            else:\n                T.append(0)\n        if j == N:\n            if cnt == mex:\n                print(1)\n            else:\n                print(0)\n        else:\n            setStart = 0\n            while j < N:\n                while cnt == mex:\n                    val = A[setStart]\n                    if val < mex:\n                        mymap[val] -= 1\n                        if mymap[val] == 0:\n                            cnt -= 1\n                    setStart += 1\n                val = A[j]\n                if val < mex:\n                    if mymap[val] == 0:\n                        cnt += 1\n                    mymap[val] += 1\n                newval = T[-1]\n                if cnt == mex:\n                    newval += T[setStart - 1]\n                    newval = newval % P\n                    while A[setStart] < mex and mymap[A[setStart]] > 1 or A[setStart] > mex:\n                        if A[setStart] > mex:\n                            setStart += 1\n                            newval += T[setStart - 1]\n                            newval = newval % P\n                        else:\n                            mymap[A[setStart]] -= 1\n                            setStart += 1\n                            newval += T[setStart - 1]\n                            newval = newval % P\n                T.append(newval)\n                j += 1\n            2\n            print(T[-1])", "import sys\ninput = sys.stdin.readline\nimport heapq\n\ndef solution(N, arr):\n    mod_ = 10 ** 9 + 7\n    last = {}\n    small_missing = 0\n    ferme = [0 for _ in range(N)]\n    jusqua = [1 for _ in range(N)]\n    h = []\n    s_vals = set(arr)\n    for i in range(N + 1):\n        if i not in s_vals:\n            small_missing = i\n            break\n    if small_missing == 0:\n        print(pow(2, N - 1, mod_))\n        return\n    for (pos, elem) in enumerate(arr):\n        if elem < small_missing:\n            last[elem] = pos\n            heapq.heappush(h, (pos, elem))\n        if len(last) == small_missing:\n            while h[0][0] != last[h[0][1]]:\n                heapq.heappop(h)\n            precedent = h[0][0] - 1\n            if precedent == -1:\n                ferme[pos] = 1\n            else:\n                ferme[pos] = jusqua[precedent]\n            if pos > 0:\n                jusqua[pos] = (jusqua[pos - 1] + ferme[pos]) % mod_\n            else:\n                jusqua[pos] = 2\n    print(ferme[-1])\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    arr = list(map(int, input().split()))\n    solution(N, arr)", "T = int(input())\nP = 10 ** 9 + 7\nfor _ in range(T):\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    S = set(A)\n    MEX = 0\n    while True:\n        if MEX not in S:\n            break\n        MEX += 1\n    if MEX == 0:\n        print(pow(2, N - 1, P))\n        continue\n    S1 = set(range(MEX))\n    end_index = N - 1\n    while True:\n        if not S1:\n            break\n        if A[end_index] in S1:\n            S1.remove(A[end_index])\n        end_index -= 1\n        if end_index < 0:\n            break\n    S1 = set(range(MEX))\n    start_index = 0\n    last_seen = [-1 for _ in range(MEX)]\n    while True:\n        if not S1:\n            break\n        if A[start_index] < MEX:\n            last_seen[A[start_index]] = start_index\n            if A[start_index] in S1:\n                S1.remove(A[start_index])\n        start_index += 1\n        if start_index == N:\n            break\n    until_here = min(last_seen)\n    num_ending_before = [1 for _ in range(start_index)]\n    if start_index <= end_index + 1:\n        num_ending_before += [2]\n    for i in range(start_index, end_index + 1):\n        if A[i] < MEX:\n            last_seen[A[i]] = i\n        while True:\n            if A[until_here] >= MEX:\n                until_here += 1\n            elif last_seen[A[until_here]] > until_here:\n                until_here += 1\n            else:\n                break\n        num_ending_before += [(num_ending_before[until_here] + num_ending_before[-1]) % P]\n    print(num_ending_before[-1])"]