["import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef gcd(a, b, n, mod):\n    if a == b:\n        return (power(a, n, mod) + power(b, n, mod)) % mod\n    possible = 1\n    total = a - b\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(a, n, i) + power(b, n, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(a, n, total // i) + power(b, n, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod\ncase = int(input())\nfor _ in range(case):\n    (a, b, n) = map(int, input().split(' '))\n    mod = 1000000007\n    res = gcd(a, b, n, mod)\n    print(res)", "from math import gcd\nm = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print((pow(a, n, m) + pow(b, n, m)) % m)\n        continue\n    d = a - b\n    print(gcd((pow(a, n, d) + pow(b, n, d)) % d, d) % m)", "from math import gcd\nm = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print((pow(a, n, m) + pow(b, n, m)) % m)\n        continue\n    d = a - b\n    print(gcd((pow(a, n, d) + pow(b, n, d)) % d, d) % m)", "import math\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (A, B, N) = list(map(int, input().split()))\n    if A == B:\n        print(pow(A, N, mod) + pow(B, N, mod))\n        continue\n    print(math.gcd(A - B, pow(A, N, A - B) + pow(B, N, A - B)))", "from collections import defaultdict, Counter, deque\nimport math\nimport bisect\nfrom itertools import accumulate\nfrom math import ceil, log, gcd\nfrom functools import lru_cache\nfrom sys import stdin, stdout\nimport time\nimport atexit\nimport io\nimport sys\nimport string\nimport heapq\n\ndef primes(n):\n    if n <= 2:\n        return []\n    sieve = [True] * (n + 1)\n    for x in range(3, int(n ** 0.5) + 1, 2):\n        for y in range(3, n // x + 1, 2):\n            sieve[x * y] = False\n    return [2] + [i for i in range(3, n, 2) if sieve[i]]\n\ndef write(*args, **kwargs):\n    sep = kwargs.get('sep', ' ')\n    end = kwargs.get('end', '\\n')\n    stdout.write(sep.join((str(a) for a in args)) + end)\n\ndef read():\n    return stdin.readline().rstrip()\n\ndef primes_rwh(n):\n    sieve = [True] * n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if sieve[i]:\n            sieve[i * i::2 * i] = [False] * ((n - i * i - 1) // (2 * i) + 1)\n    return [2] + [i for i in range(3, n, 2) if sieve[i]]\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    d = defaultdict(lambda : 0)\n    for i in primes_rwh(int(n ** 0.5 + 1)):\n        while n % i == 0:\n            n //= i\n            factors.append(i)\n            d[i] += 1\n    if n > 1:\n        factors.append(n)\n        d[n] += 1\n    return (factors, d)\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef lcm(x, y):\n    lcm = x * y // math.gcd(x, y)\n    return lcm\ntotal = int(read())\nfor _ in range(total):\n    (a, b, n) = [int(p) for p in read().split()]\n    z = abs(a - b)\n    g = 1\n    if z == 0:\n        print((a ** n + b ** n) % 1000000007)\n        continue\n    while z > 1 and n > 2:\n        t = math.gcd(z, a * b)\n        if t == 1:\n            break\n        g *= t\n        g %= 1000000007\n        n -= 2\n        z //= t\n    n = n % 2\n    g *= math.gcd(z, a ** n + b ** n)\n    g %= 1000000007\n    print(g)", "from math import *\nfrom collections import *\nfrom bisect import *\nimport heapq\nimport math\nfrom itertools import permutations\n\ndef is_prime(n):\n    for i in range(2, math.ceil(math.sqrt(n))):\n        if n % i == 0:\n            return False\n    return True\n\ndef sieve(n):\n    arr = [True for _ in range(n + 1)]\n    for i in range(2, math.ceil(math.sqrt(n))):\n        if arr[i] == True:\n            for j in range(i * i, n + 1, i):\n                arr[j] = False\n    return arr\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef euclidean_distance(x1, y1, x2, y2):\n    return sqrt(abs(x1 - x2) ** 2 + abs(y1 - y2) ** 2)\n\ndef get_permutations(lo=0, hi=10):\n    return list(permutations(range(lo, hi)))\n\ndef getDivisors(n):\n    i = 1\n    ans1 = []\n    ans2 = []\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                ans1.append(i)\n            else:\n                ans1.append(i)\n                ans2.append(n // i)\n        i = i + 1\n    return ans1 + ans2[::-1]\n\ndef solve():\n    (a, b, n) = list(map(int, input().split()))\n\n    def check(x, y):\n        return x >= 0 and y >= 0 and (x < n) and (y < m)\n    mod = int(1000000000.0 + 7)\n    if a == b:\n        x = power(a, n, mod)\n        y = power(b, n, mod)\n        z = int(x + y) % mod\n        print(z)\n    lis = getDivisors(a - b)\n    for ele in lis[::-1]:\n        if (power(a, n, ele) + power(b, n, ele)) % ele == 0:\n            print(ele)\n            return\nn = 1\nn = int(input())\nwhile n:\n    n -= 1\n    solve()", "ri = lambda : int(input())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\nt = ri()\nmod = 1000000007\n\ndef power(a, b, mod):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res *= a\n            res %= mod\n        a *= a\n        a %= mod\n        b >>= 1\n    return res % mod\nfor test in range(t):\n    (a, b, n) = rl()\n    if a == b:\n        print((power(a, n, mod) % mod + power(b, n, mod)) % mod)\n    else:\n        i = 1\n        res = 1\n        p = a - b\n        while i * i <= p:\n            if p % i == 0:\n                tmp = (power(a, n, i) + power(b, n, i)) % i\n                if tmp == 0:\n                    res = max(res, i)\n                tmp = (power(a, n, p // i) + power(b, n, p // i)) % (p // i)\n                if tmp == 0:\n                    res = max(res, p // i)\n            i += 1\n        print(res)", "import sys\nfrom collections import Counter, defaultdict, deque\nfrom math import gcd, sqrt, ceil\n\ndef li():\n    return [int(i) for i in sys.stdin.readline().split()]\n\ndef si():\n    return sys.stdin.readline().split()\n\ndef ii():\n    return int(sys.stdin.readline())\n\ndef ip():\n    return input()\n\ndef exp(a, n, inf):\n    if n == 0:\n        return 1\n    t = exp(a, n // 2, inf)\n    res = t * t\n    if n % 2 == 1:\n        res *= a\n    return res % inf\nfor tastcas in range(int(input())):\n    (a, b, n) = li()\n    d = abs(a - b)\n    inf = 1000000007\n    if d == 0:\n        print((exp(a, n, inf) + exp(b, n, inf)) % inf)\n    else:\n        print(gcd(d, (exp(a, n, d) + exp(b, n, d)) % d) % inf)", "def modexp(X, n, mod):\n    if n == 0:\n        return 1\n    temp = modexp(X, n // 2, mod)\n    res = temp * temp\n    if n % 2 == 1:\n        res *= X\n    return res % mod\n\ndef gcd(A, B):\n    if B == 0:\n        return A\n    return gcd(B, A % B)\nT = int(input())\nfor t in range(T):\n    (A, B, N) = [int(i) for i in input().split()]\n    diff = A - B\n    res = 0\n    if diff == 0:\n        res = (modexp(A, N, 1000000007) + modexp(B, N, 1000000007)) % 1000000007\n    else:\n        res = gcd(diff, (modexp(A, N, diff) + modexp(B, N, diff)) % diff) % 1000000007\n    print(res)", "import math\nt = int(input())\nMOD = 1000000007\n\ndef exponential_mod(n, p, mod):\n    if p == 0:\n        return 1\n    if p % 2 != 0:\n        return exponential_mod(n, p - 1, mod) * n % mod\n    tmp = exponential_mod(n, p // 2, mod) % mod\n    return tmp * tmp % mod\n\ndef swap(a, b):\n    tmp = a\n    a = b\n    b = tmp\nwhile t > 0:\n    t -= 1\n    (a, b, n) = list(map(int, input().split()))\n    if a == b:\n        print((exponential_mod(a, n, MOD) + exponential_mod(b, n, MOD)) % MOD)\n    else:\n        if b > a:\n            swap(a, b)\n        print(int(math.gcd((exponential_mod(a, n, a - b) + exponential_mod(b, n, a - b)) % (a - b), a - b)))", "n = int(input())\nmod = 10 ** 9 + 7\n\ndef binary(base, power, mod):\n    save = 1\n    while power != 1:\n        if power % 2 == 0:\n            power = power // 2\n            base = base * base % mod\n        else:\n            power = power - 1\n            save = save * base % mod\n    ans = save * base % mod\n    return ans\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor i in range(n):\n    (a, b, n) = list(map(int, input().split()))\n    if b - a != 0:\n        binary_solution = binary(a, n, max(a - b, b - a)) + binary(b, n, max(a - b, b - a))\n        final_answer = gcd(binary_solution, max(a - b, b - a))\n    else:\n        binary_solution = binary(a, n, mod) + binary(b, n, mod)\n        final_answer = gcd(binary_solution, max(a - b, b - a))\n    print(final_answer)", "n = int(input())\nmod = 10 ** 9 + 7\n\ndef binary(base, power, mod):\n    save = 1\n    while power != 1:\n        if power % 2 == 0:\n            power = power // 2\n            base = base * base % mod\n        else:\n            power = power - 1\n            save = save * base % mod\n    ans = save * base % mod\n    return ans\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor i in range(n):\n    (a, b, n) = list(map(int, input().split()))\n    if b - a != 0:\n        binary_solution = binary(a, n, max(a - b, b - a)) + binary(b, n, max(a - b, b - a))\n        final_answer = gcd(binary_solution, max(a - b, b - a))\n    else:\n        binary_solution = binary(a, n, mod) + binary(b, n, mod)\n        final_answer = gcd(binary_solution, max(a - b, b - a))\n    print(final_answer)", "from math import gcd\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    z = power(x, y // 2, m)\n    if y % 2 == 1:\n        return z * z % m * x % m\n    else:\n        return z * z % m\nt = int(input())\nMOD = 1000000007\nfor _ in range(t):\n    (a, b, n) = [int(x) for x in input().split()]\n    if abs(a - b) > 0:\n        print(gcd(power(a, n, abs(a - b)) + power(b, n, abs(a - b)), abs(a - b)) % MOD)\n    else:\n        print((power(a, n, MOD) + power(b, n, MOD)) % MOD)", "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\nx = int(input())\nfor i in range(x):\n    (a, b, t) = map(int, input().split())\n    if abs(a - b) > 0:\n        print(gcd(pow(a, t, abs(a - b)) + pow(b, t, abs(a - b)), abs(a - b)) % (10 ** 9 + 7))\n    else:\n        print((pow(a, t) + pow(b, t)) % (10 ** 9 + 7))", "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\nx = int(input())\nfor i in range(x):\n    (a, b, t) = map(int, input().split())\n    if abs(a - b) > 0:\n        print(gcd(pow(a, t, abs(a - b)) + pow(b, t, abs(a - b)), abs(a - b)) % (10 ** 9 + 7))\n    else:\n        print((pow(a, t, 10 ** 9 + 7) + pow(b, t, 10 ** 9 + 7)) % (10 ** 9 + 7))", "from sys import stdin\nfrom math import log, floor, ceil, gcd\nfrom collections import defaultdict as dd\ninput = stdin.readline\ninp = lambda : int(stdin.readline())\nrs = lambda : stdin.readline().strip()\n\ndef ra(typ):\n    return list(map(typ, stdin.readline().split()))\n\ndef rv(typ):\n    return map(typ, stdin.readline().split())\nmod = 1000000007\n\ndef main():\n    for _ in range(inp()):\n        (a, b, n) = rv(int)\n        if a == b:\n            print(2 * pow(a, n, mod) % mod)\n        else:\n            x = abs(a - b)\n            ans = (pow(a, n, x) + pow(b, n, x)) % x\n            print(gcd(x, ans) % mod)\nmain()", "mod_val = 10 ** 9 + 7\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef modexp(a, b, x):\n    a %= x\n    result = 1\n    while b > 0:\n        if b & 1:\n            result = result * a % x\n        a = a ** 2 % x\n        b >>= 1\n    return result\n\ndef solve(a, b, n):\n    delta = a - b\n    if delta == 0:\n        return (modexp(a, n, mod_val) + modexp(b, n, mod_val)) % mod_val\n    else:\n        value = modexp(a, n, delta) + modexp(b, n, delta)\n        value %= delta\n        return gcd(delta, value) % mod_val\nT = int(input())\nfor t in range(T):\n    (a, b, n) = map(int, input().split(' '))\n    print(solve(a, b, n))", "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef snek(a, b, m):\n    a %= m\n    ans = 1\n    while b > 0:\n        if b & 1 == 1:\n            ans = ans * a % m\n        a = a * a % m\n        b >>= 1\n    return ans % m\nt = int(input())\nm = 10 ** 9 + 7\nfor i in range(t):\n    (a, b, n) = map(int, input().split())\n    c = max(a, b) - min(a, b)\n    ans = 0\n    if c == 0:\n        ans = (snek(a, n, m) + snek(b, n, m)) % m\n    else:\n        s = (snek(a, n, c) + snek(b, n, c)) % c\n        ans = gcd(s, c) % m\n    print(ans)", "def gcd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef power(a, b, m):\n    a = a % m\n    ans = 1\n    while b > 0:\n        if b & 1 == 1:\n            ans = ans * a % m\n        a = a * a % m\n        b >>= 1\n    return ans % m\nt = int(input())\nm = 10 ** 9 + 7\nfor ii in range(t):\n    (a, b, n) = map(int, input().split())\n    temp = max(a, b) - min(a, b)\n    ans = 0\n    if temp == 0:\n        ans = (power(a, n, m) + power(b, n, m)) % m\n    else:\n        p = (power(a, n, temp) + power(b, n, temp)) % temp\n        ans = gcd(p, temp) % m\n    print(ans)", "from math import gcd\n\ndef gcdd(a, b):\n    if b > a:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef modexp(a, b, m):\n    a = a % m\n    ans = 1\n    while b > 0:\n        if b & 1 == 1:\n            ans = ans * a % m\n        a = a * a % m\n        b >>= 1\n    return ans % m\nMOD = 1000000007\nT = int(input())\nfor i in range(T):\n    (A, B, N) = map(int, input().split())\n    delta = A - B\n    if delta == 0:\n        print((modexp(A, N, MOD) + modexp(B, N, MOD)) % MOD)\n    else:\n        An_plus_Bn = modexp(A, N, delta) + modexp(B, N, delta)\n        An_plus_Bn %= delta\n        print(gcd(delta, An_plus_Bn) % MOD)", "from math import gcd\n\ndef modexp(a, b, m):\n    a %= m\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % m\n        a = a * a % m\n        b >>= 1\n    return res\nMOD = 1000000007\nT = int(input())\nfor i in range(T):\n    (A, B, N) = map(int, input().split())\n    delta = A - B\n    if delta == 0:\n        print((modexp(A, N, MOD) + modexp(B, N, MOD)) % MOD)\n    else:\n        An_plus_Bn = modexp(A, N, delta) + modexp(B, N, delta)\n        An_plus_Bn %= delta\n        print(gcd(delta, An_plus_Bn) % MOD)", "from math import gcd\n\ndef modexp(a, b, m):\n    a %= m\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % m\n        a = a * a % m\n        b >>= 1\n    return res\nMOD = 1000000007\nT = int(input())\nfor i in range(T):\n    (A, B, N) = map(int, input().split())\n    delta = A - B\n    if delta == 0:\n        print((modexp(A, N, MOD) + modexp(B, N, MOD)) % MOD)\n    else:\n        An_plus_Bn = modexp(A, N, delta) + modexp(B, N, delta)\n        An_plus_Bn %= delta\n        print(gcd(delta, An_plus_Bn) % MOD)", "from math import gcd\n\ndef modexp(a, b, m):\n    a %= m\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % m\n        a = a * a % m\n        b >>= 1\n    return res\nMOD = 1000000007\nT = int(input())\nfor i in range(T):\n    (A, B, N) = map(int, input().split())\n    delta = A - B\n    if delta == 0:\n        print((modexp(A, N, MOD) + modexp(B, N, MOD)) % MOD)\n    else:\n        An_plus_Bn = modexp(A, N, delta) + modexp(B, N, delta)\n        An_plus_Bn %= delta\n        print(gcd(delta, An_plus_Bn) % MOD)", "import itertools\nimport heapq\nimport collections\nimport math\nimport sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\n\ndef inis():\n    return input().split()\n\ndef stlt():\n    return list(map(str, input().split()))\n\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    l = []\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            l.append(p)\n    return l\n\ndef isPrime(n):\n    prime_flag = 0\n    if n > 1:\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                prime_flag = 1\n                break\n        if prime_flag == 0:\n            return True\n        else:\n            return False\n    else:\n        return False\n\ndef gcdofarray(a):\n    x = 0\n    for p in a:\n        x = math.gcd(x, p)\n    return x\n\ndef printDivisors(n):\n    i = 1\n    ans = []\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                ans.append(i)\n            else:\n                ans.append(i)\n                ans.append(n // i)\n        i = i + 1\n    ans.sort()\n    return ans\n\ndef CountDivisors(n):\n    i = 1\n    ans = []\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                ans.append(i)\n            else:\n                ans.append(i)\n                ans.append(n // i)\n        i = i + 1\n    ans.sort()\n    return len(ans)\n\ndef binaryToDecimal(n):\n    return int(n, 2)\n\ndef countTriplets(a, n):\n    s = set()\n    for i in range(n):\n        s.add(a[i])\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n, 1):\n            xr = a[i] ^ a[j]\n            if xr in s and xr != a[i] and (xr != a[j]):\n                count += 1\n    return int(count // 3)\n\ndef generate_twin_prime(n):\n    a = 0\n    for i in range(1, n + 1):\n        j = i + 2\n        if isPrime(i) and isPrime(j):\n            if 2 ^ (i ^ j) == 0:\n                a += 1\n    return a\n\ndef smallestDivisor(n):\n    if n % 2 == 0:\n        return 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return i\n        i += 2\n    return n\n\ndef countOdd(L, R):\n    N = (R - L) // 2\n    if R % 2 != 0 or L % 2 != 0:\n        N += 1\n    return N\n\ndef isPalindrome(s):\n    return s == s[::-1]\n\ndef sufsum(test_list):\n    test_list.reverse()\n    res = [sum(test_list[:i + 1]) for i in range(len(test_list))]\n    return res\n\ndef prsum(lst):\n    return list(itertools.accumulate(lst))\n\ndef badachotabadachota(nums):\n    nums.sort()\n    i = 0\n    j = len(nums) - 1\n    ans = []\n    cc = 0\n    while len(ans) != len(nums):\n        if cc % 2 == 0:\n            ans.append(nums[j])\n            j -= 1\n        else:\n            ans.append(nums[i])\n            i += 1\n        cc += 1\n    return ans\n\ndef primeFactors(n):\n    ans = []\n    while n % 2 == 0:\n        ans.append(2)\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            ans.append(i)\n            n = n / i\n    if n > 2:\n        ans.append(n)\n    return ans\n\ndef closestMultiple(n, x):\n    if x > n:\n        return x\n    z = int(x / 2)\n    n = n + z\n    n = n - n % x\n    return n\nfor _ in range(inp()):\n    (a, b, n) = invr()\n    m = abs(a - b)\n    if m == 0:\n        m = int(1000000000.0 + 7)\n    k1 = (pow(a, n, m) + pow(b, n, m)) % m\n    if m == int(1000000000.0 + 7):\n        print(k1 % int(1000000000.0 + 7))\n    else:\n        print(math.gcd(m, k1) % int(1000000000.0 + 7))", "import math\nmod = int(1000000000.0 + 7)\nfor i in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    m = abs(a - b)\n    if m == 0:\n        m = mod\n    k1 = (pow(a, n, m) + pow(b, n, m)) % m\n    if m == mod:\n        print(k1 % mod)\n    else:\n        print(math.gcd(m, k1) % mod)", "m = 10 ** 9 + 7\n\ndef binpow(a, b, m):\n    ans = 1\n    a = a % m\n    while b:\n        if b & 1:\n            ans = ans * a % m\n            b -= 1\n        else:\n            a = a * a % m\n            b >>= 1\n    return ans\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print((binpow(a, n, m) + binpow(b, n, m)) % m)\n        continue\n    c = []\n    r = abs(a - b)\n    for i in range(1, int(r ** 0.5) + 1):\n        if r % i == 0:\n            c.append(i)\n            if r // i != i:\n                c.append(r // i)\n    c.sort(reverse=True)\n    for i in c:\n        if (binpow(a, n, i) + binpow(b, n, i)) % i == 0:\n            print(i)\n            break", "def modPower(a, n, mod):\n    if n == 0:\n        return 1\n    if n == 1:\n        return a\n    l = modPower(a, int(n / 2), mod)\n    if n % 2 == 0:\n        return l % mod * l % mod % mod\n    l = l % mod * l % mod % mod\n    l = a % mod * l % mod\n    return l\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef solve():\n    inp = input()\n    arr = [int(e) for e in inp.split(' ')]\n    a = arr[0]\n    b = arr[1]\n    n = arr[2]\n    diff = a - b\n    mod = diff\n    if diff == 0:\n        mod = 1000000007\n    g = modPower(a, n, mod) + modPower(b, n, mod)\n    if diff != 0:\n        g = gcd(diff, g)\n    ans = g % 1000000007\n    print(ans)\nt = input()\nt = int(t)\nfor k in range(t):\n    solve()", "from math import gcd\nmd = 10 ** 9 + 7\nfor t in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print((pow(a, n, md) + pow(b, n, md)) % md)\n        continue\n    d = a - b\n    x = (pow(a, n, d) + pow(b, n, d)) % d\n    print(gcd(x, d))", "import math, sys, collections\nfrom collections import defaultdict as dd, Counter as cc\ninput = sys.stdin.readline\nistr = lambda : input().strip()\ninum = lambda : int(input().strip())\nimap = lambda : map(int, input().strip().split())\nilist = lambda : list(map(int, input().strip().split()))\n\ndef findmodpow(a, b, m=int(1000000000.0 + 7)):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % m\n        a = a * a % m\n        b >>= 1\n    return res % m\n\ndef gcdsmall(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\ntry:\n    n = int(input())\n    while True:\n        try:\n            (a, b, n) = list(map(int, input().split()))\n            mod = 1000000007\n            diff = abs(a - b)\n            if diff == 0:\n                pow_a = findmodpow(a, n, mod)\n                pow_b = findmodpow(b, n, mod)\n                ans = (pow_a + pow_b) % mod\n                print(ans)\n            else:\n                pow_a = findmodpow(a, n, diff)\n                pow_b = findmodpow(b, n, diff)\n                ans = gcdsmall((pow_a + pow_b) % diff, diff) % mod\n                print(ans)\n        except EOFError:\n            print('Error: ', e)\n            break\nexcept Exception as e:\n    pass", "import math, sys, collections\nfrom collections import defaultdict as dd, Counter as cc\ninput = sys.stdin.readline\nistr = lambda : input().strip()\ninum = lambda : int(input().strip())\nimap = lambda : map(int, input().strip().split())\nilist = lambda : list(map(int, input().strip().split()))\n\ndef power(a, b, m=int(1000000000.0 + 7)):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % m\n        a = a * a % m\n        b >>= 1\n    return res % m\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\ntry:\n    n = int(input())\n    while True:\n        try:\n            (a, b, n) = list(map(int, input().split()))\n            mod = 1000000007\n            diff = abs(a - b)\n            if diff == 0:\n                pow_a = power(a, n, mod)\n                pow_b = power(b, n, mod)\n                ans = (pow_a + pow_b) % mod\n                print(ans)\n            else:\n                pow_a = power(a, n, diff)\n                pow_b = power(b, n, diff)\n                ans = gcd((pow_a + pow_b) % diff, diff) % mod\n                print(ans)\n        except EOFError:\n            break\nexcept Exception as e:\n    pass", "def power(x, y, p):\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, p)\n    if y % 2 == 0:\n        return temp * temp % p\n    else:\n        return x * (temp * temp) % p % p\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    else:\n        return gcd(b % a, a)\ntestcases = int(input())\nfor t in range(testcases):\n    (a, b, n) = list(map(int, input().split()))\n    mod = 1000000007\n    diff = abs(a - b)\n    if diff == 0:\n        pow_a = power(a, n, mod)\n        pow_b = power(b, n, mod)\n        ans = (pow_a + pow_b) % mod\n        print(ans)\n    else:\n        pow_a = power(a, n, diff)\n        pow_b = power(b, n, diff)\n        ans = gcd((pow_a + pow_b) % diff, diff) % mod\n        print(ans)", "def power_cal(A, n, jump):\n    res = 1\n    base = A\n    if n == 1:\n        return A % jump\n    while n > 0:\n        if n % 2 == 0:\n            n = n // 2\n            base = base % jump * (base % jump) % jump\n        else:\n            n -= 1\n            res = res % jump * (base % jump) % jump\n    return res\n\ndef Check(A, B, N, big):\n    A = power_cal(A, N, big)\n    B = power_cal(B, N, big)\n    if (A + B) % big == 0:\n        return True\n    return False\n\ndef find_all_divisors(A, B, N, jump):\n    if jump == 0:\n        return ((A % 1000000007) ** N + (B % 1000000007) ** N) % 1000000007\n    candidate = 1\n    for i in range(1, int(jump ** (1 / 2) + 1)):\n        if jump % i == 0:\n            big = jump // i\n            if Check(A, B, N, i):\n                candidate = max(candidate, i)\n            if Check(A, B, N, big):\n                candidate = max(candidate, big)\n    return candidate\nfor _ in range(int(input())):\n    (A, B, N) = list(map(int, input().split()))\n    jump = max(A - B, B - A)\n    my_gcd = find_all_divisors(A, B, N, jump)\n    print(my_gcd % 1000000007)", "def power_cal(A, n, jump):\n    res = 1\n    base = A\n    if n == 1:\n        return A % jump\n    while n > 0:\n        if n % 2 == 0:\n            n = n // 2\n            base = base % jump * (base % jump) % jump\n        else:\n            n -= 1\n            res = res % jump * (base % jump) % jump\n    return res\n\ndef Check(A, B, N, big):\n    A = power_cal(A, N, big)\n    B = power_cal(B, N, big)\n    if (A + B) % big == 0:\n        return True\n    return False\n\ndef find_all_divisors(A, B, N, jump):\n    if jump == 0:\n        return ((A % 1000000007) ** N + (B % 1000000007) ** N) % 1000000007\n    if jump == 1:\n        return 1\n    gcd = None\n    for i in range(1, int(jump ** (1 / 2) + 1)):\n        if jump % i == 0:\n            big = jump // i\n            if Check(A, B, N, i):\n                gcd = i\n            if Check(A, B, N, big):\n                return big\n    if gcd is None:\n        return 1\n    return gcd\nfor _ in range(int(input())):\n    (A, B, N) = list(map(int, input().split()))\n    jump = max(A - B, B - A)\n    my_gcd = find_all_divisors(A, B, N, jump)\n    print(my_gcd % 1000000007)", "import math\nimport sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = list(map(int, input().split()))\n    n1 = a - b\n    if n1 == 0:\n        ans = pow(a, n, mod) + pow(b, n, mod)\n        print(ans % mod)\n    else:\n        l = []\n        for i in range(1, int(math.sqrt(n1) + 1)):\n            if n1 % i == 0:\n                l.append(i)\n                l.append(n1 // i)\n        ans = 0\n        for i in range(len(l)):\n            a1 = pow(a, n, l[i]) + pow(b, n, l[i])\n            a1 = a1 % l[i]\n            if a1 == 0:\n                ans = max(ans, l[i])\n        print(ans % mod)", "import math\nimport sys\n\ndef input():\n    return sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = list(map(int, input().split()))\n    n1 = a - b\n    if n1 == 0:\n        ans = pow(a, n, mod) + pow(b, n, mod)\n        print(ans % mod)\n    else:\n        l = []\n        for i in range(1, int(math.sqrt(n1) + 1)):\n            if n1 % i == 0:\n                if i * i == n1:\n                    l.append(i)\n                else:\n                    l.append(i)\n                    l.append(n1 // i)\n        l.sort()\n        ans = 0\n        for i in range(len(l)):\n            a1 = pow(a, n, l[i]) + pow(b, n, l[i])\n            a1 = a1 % l[i]\n            if a1 == 0:\n                ans = max(ans, l[i])\n        print(ans % mod)", "mod = 10 ** 9 + 7\nimport sys\nimport math\n\ndef main():\n    test_case = int(sys.stdin.readline())\n    for tc in range(test_case):\n        (A, B, N) = map(int, sys.stdin.readline().split())\n        if A == B:\n            x = pow(A, N, mod)\n            y = pow(B, N, mod)\n            print((x + y) % mod)\n        else:\n            if A > B:\n                x = A - B\n            else:\n                x = B - A\n            a1 = pow(A, N, x)\n            b1 = pow(B, N, x)\n            print(math.gcd((a1 + b1) % x, x))\nmain()", "import math\nt = int(input())\nfor i in range(t):\n    (a, b, n) = input().split()\n    (a, b, n) = (int(a), int(b), int(n))\n    m = 10 ** 9 + 7\n    if a > b:\n        p = a - b\n    else:\n        p = b - a\n    if p == 0:\n        x = pow(a, n, m)\n        y = pow(b, n, m)\n        print((x + y) % m)\n    else:\n        x = pow(a, n, p)\n        y = pow(b, n, p)\n        z = math.gcd(x + y, p)\n        print(z % m)", "import math\nt = int(input())\nfor i in range(t):\n    (a, b, n) = input().split()\n    (a, b, n) = (int(a), int(b), int(n))\n    m = 10 ** 9 + 7\n    if a == b:\n        x = pow(a, n, m)\n        y = pow(b, n, m)\n        print((x + y) % m)\n    else:\n        if a > b:\n            p = a - b\n        else:\n            p = b - a\n        x = pow(a, n, p)\n        y = pow(b, n, p)\n        print(math.gcd((x + y) % p, p))", "def power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nimport math\nfor _ in range(int(input())):\n    (A, B, N) = map(int, input().split())\n    if A == B:\n        a = power(A, N, 1000000007)\n        b = power(B, N, 1000000007)\n        ans = a + b\n        print(ans % 1000000007)\n    else:\n        a = power(A, N, A - B)\n        b = power(B, N, A - B)\n        ans = (a + b) % (A - B)\n        print(math.gcd(ans, A - B))", "mod = 1000000007\n\ndef power(a, n, d):\n    res = 1\n    while n:\n        if n % 2:\n            res = res % d * (a % d) % d\n            n -= 1\n        else:\n            a = a % d * (a % d) % d\n            n = n // 2\n    return res\n\ndef gcd(a, b, n):\n    if a == b:\n        return (power(a, n, mod) + power(b, n, mod)) % mod\n    can = 1\n    num = a - b\n    i = 1\n    while i * i <= num:\n        if num % i == 0:\n            tmp = (power(a, n, i) + power(b, n, i)) % i\n            if tmp == 0:\n                can = max(can, i)\n            tmp = (power(a, n, num // i) + power(b, n, num // i)) % (num // i)\n            if tmp == 0:\n                can = max(can, num // i)\n        i += 1\n    return can % mod\nt = int(input())\nfor _ in range(t):\n    (a, b, n) = map(int, input().split(' '))\n    ans = gcd(a, b, n)\n    print(ans)", "import math\nfor _ in range(int(input())):\n    mod = pow(10, 9) + 7\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print((pow(a, n, mod) + pow(b, n, mod)) % mod)\n    else:\n        ans = math.gcd(pow(a, n, abs(a - b)) + pow(b, n, abs(a - b)), abs(a - b))\n        print(ans % mod)", "import math\nmod = 1000000007\n\ndef gcc(a, b, n):\n    if a == b:\n        return pow(a, n, mod) + pow(b, n, mod) % mod\n    else:\n        x1 = pow(a, n, a - b)\n        x2 = pow(b, n, a - b)\n        gc = math.gcd((x1 + x2) % (a - b), a - b)\n        return gc % mod\nt = int(input())\nwhile t >= 1:\n    (a, b, n) = input().split()\n    a = int(a)\n    b = int(b)\n    n = int(n)\n    print(gcc(a, b, n) % mod)\n    t = t - 1", "import math\nmod = 1000000007\n\ndef gcc(a, b, n):\n    if a == b:\n        return pow(a, n, mod) + pow(b, n, mod) % mod\n    else:\n        x1 = pow(a, n, a - b)\n        x2 = pow(b, n, a - b)\n        gc = math.gcd((x1 + x2) % (a - b), a - b)\n        return gc % mod\nt = int(input())\nwhile t >= 1:\n    (a, b, n) = input().split()\n    a = int(a)\n    b = int(b)\n    n = int(n)\n    print(gcc(a, b, n) % mod)\n    t = t - 1", "import math\nmod = 1000000007\n\ndef gcc(a, b, n):\n    if a == b:\n        return pow(a, n, mod) + pow(b, n, mod) % mod\n    else:\n        x1 = pow(a, n, a - b)\n        x2 = pow(b, n, a - b)\n        gc = math.gcd((x1 + x2) % (a - b), a - b)\n        return gc % mod\nt = int(input())\nwhile t >= 1:\n    (a, b, n) = input().split()\n    a = int(a)\n    b = int(b)\n    n = int(n)\n    print(gcc(a, b, n) % mod)\n    t = t - 1", "def gcd(a, b, n):\n    if a == b:\n        return (power(a, n, 1000000007) + power(b, n, 1000000007)) % 1000000007\n    num = a - b\n    i = 1\n    can = 1\n    while i * i <= num:\n        if num % i == 0:\n            temp = (power(a, n, i) + power(b, n, i)) % i\n            if temp == 0:\n                can = max(can, i)\n            temp = (power(a, n, num // i) + power(b, n, num // i)) % (num // i)\n            if temp == 0:\n                can = max(can, num // i)\n        i += 1\n    return can % 1000000007\n\ndef power(num, p, d):\n    res = 1\n    while p:\n        if p % 2 == 0:\n            num = num % d * (num % d) % d\n            p = p // 2\n        else:\n            p -= 1\n            res = res % d * (num % d) % d\n    return res\nt = int(input())\nwhile t:\n    t -= 1\n    (x, y, n) = map(int, input().split())\n    print(gcd(x, y, n))", "def gcd(a, b, n):\n    if a == b:\n        return (power(a, n, 1000000007) + power(b, n, 1000000007)) % 1000000007\n    num = a - b\n    i = 1\n    can = 1\n    while i * i <= num:\n        if num % i == 0:\n            temp = (power(a, n, i) + power(b, n, i)) % i\n            if temp == 0:\n                can = max(can, i)\n            temp = (power(a, n, num // i) + power(b, n, num // i)) % (num // i)\n            if temp == 0:\n                can = max(can, num // i)\n        i += 1\n    return can % 1000000007\n\ndef power(num, p, d):\n    res = 1\n    while p:\n        if p % 2 == 0:\n            num = num % d * (num % d) % d\n            p = p // 2\n        else:\n            p -= 1\n            res = res % d * (num % d) % d\n    return res\nt = int(input())\nwhile t:\n    t -= 1\n    (x, y, n) = map(int, input().split())\n    print(gcd(x, y, n))", "mod = 10 ** 9 + 7\n\ndef power(base, p, m):\n    res = 1\n    while p >= 1:\n        if p & 1:\n            res = res % m * (base % m) % m\n            p -= 1\n        else:\n            base = base % m * (base % m) % m\n            p //= 2\n    return res\nfor i in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    diff = abs(a - b)\n    if diff == 0:\n        print((power(a, n, mod) + power(b, n, mod)) % mod)\n        continue\n    j = 1\n    fin = 0\n    while j * j <= diff:\n        if diff % j == 0:\n            ans = (power(a, n, j) + power(b, n, j)) % j\n            if ans == 0:\n                fin = max(j, fin)\n            ans = (power(a, n, diff // j) + power(b, n, diff // j)) % (diff // j)\n            if ans == 0:\n                fin = max(fin, diff // j)\n        j += 1\n    print(fin % mod)", "MAX = pow(10, 9) + 7\n\ndef power(a, n, mod):\n    res = 1\n    while n:\n        if n % 2:\n            res = a % mod * res % mod % mod\n            n -= 1\n        else:\n            a = a % mod * a % mod % mod\n            n /= 2\n    return res\n\ndef GCD(a, b, n):\n    if a == b:\n        return (power(a, n, MAX) + power(b, n, MAX)) % MAX\n    candidate = 1\n    num = a - b\n    i = 1\n    while i * i <= num:\n        if num % i == 0:\n            tmp = (power(a, n, i) + power(a, n, i)) % i\n            if tmp == 0:\n                candidate = max(candidate, i)\n            tmp = (power(a, n, num // i) + power(a, n, num // i)) % (num // i)\n            if tmp == 0:\n                candidate = max(candidate, num // i)\n        i += 1\n    return candidate\nfor _ in range(int(input())):\n    (a, b, n) = list(map(int, input().split()))\n    print(GCD(a, b, n))", "for _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    diff = a - b\n    if diff == 0:\n        print((pow(a, n, 1000000007) + pow(b, n, 1000000007)) % 1000000007)\n        continue\n    add = (pow(a, n, diff) + pow(b, n, diff)) % diff\n    import math\n    print(math.gcd(add, diff) % 1000000007)", "import math\ntry:\n\n    def power(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n    p = 1000000007\n    for _ in range(int(input())):\n        (a, b, n) = map(int, input().split())\n        if a == b:\n            ans = (power(a, n, p) + power(b, n, p)) % p\n            print(ans)\n        else:\n            ans = math.gcd((power(a, n, a - b) + power(b, n, a - b)) % (a - b), a - b)\n            print(ans)\nexcept:\n    print('fuck')", "def power(a, m, mod):\n    ans = 1\n    while m > 0:\n        if m & 1:\n            ans = ans % mod * (a % mod) % mod\n            m -= 1\n        else:\n            a = a % mod * (a % mod) % mod\n            m //= 2\n    return ans\n\ndef gcd(a, b, m):\n    res = 1\n    modd = 1000000007\n    if a == b:\n        return (power(a, m, modd) + power(b, m, modd)) % modd\n    n = abs(a - b)\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            x = (power(a, m, i) + power(b, m, i)) % i\n            if x == 0:\n                res = max(res, i)\n            x = (power(a, m, n // i) + power(b, m, n // i)) % (n // i)\n            if x == 0:\n                res = max(res, n // i)\n    return res % 1000000007\nfor _ in range(int(input())):\n    (a, b, m) = map(int, input().split())\n    print(gcd(a, b, m))", "def power(a, m, mod):\n    ans = 1\n    while m > 0:\n        if m & 1:\n            ans = ans % mod * (a % mod) % mod\n            m -= 1\n        else:\n            a = a % mod * (a % mod) % mod\n            m //= 2\n    return ans\n\ndef gcd(a, b, m):\n    res = 1\n    modd = 1000000007\n    if a == b:\n        return (power(a, m, modd) + power(b, m, modd)) % modd\n    n = abs(a - b)\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            x = (power(a, m, i) + power(b, m, i)) % i\n            if x == 0:\n                res = max(res, i)\n            x = (power(a, m, n // i) + power(b, m, n // i)) % (n // i)\n            if x == 0:\n                res = max(res, n // i)\n    return res % 1000000007\nfor _ in range(int(input())):\n    (a, b, m) = map(int, input().split())\n    print(gcd(a, b, m))", "from math import gcd\nmod = 1000000007\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    v = a - b\n    if v == 0:\n        print((pow(a, n, mod) + pow(b, n, mod)) % mod)\n        continue\n    v1 = (pow(a, n, v) + pow(b, n, v)) % v\n    print(gcd(v1, v) % mod)", "import math\nM = 10 ** 9 + 7\nT = int(input())\nfor i in range(T):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print(pow(a, n) * 2 % M)\n    else:\n        print(math.gcd(pow(a, n, a - b) + pow(b, n, a - b), a - b) % M)", "import sys\nsys.setrecursionlimit(10 ** 5 + 1)\ninf = int(10 ** 20)\nmax_val = inf\nmin_val = -inf\nRW = lambda : sys.stdin.readline().strip()\nRI = lambda : int(RW())\nRMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRWI = lambda : [x for x in sys.stdin.readline().strip().split()]\nimport math\nM = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print(pow(a, n) * 2 % M)\n    else:\n        print(math.gcd(pow(a, n, a - b) + pow(b, n, a - b), a - b) % M)", "import math\nM = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print(pow(a, n) * 2 % M)\n    else:\n        print(math.gcd(pow(a, n, a - b) + pow(b, n, a - b), a - b) % M)", "import math\nM = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print(pow(a, n) * 2 % M)\n    else:\n        print(math.gcd(pow(a, n, a - b) + pow(b, n, a - b), a - b) % M)", "import math\n\ndef power(a, b, mod):\n    res = 1\n    while b > 0:\n        if b % 2 == 0:\n            a = a * a % mod\n            b = b // 2\n        else:\n            res = res * a % mod\n            b = b - 1\n    return res\nt = int(input())\nfor test in range(t):\n    (a, b, n) = map(int, input().split())\n    num = abs(a - b)\n    if a == b:\n        num = (power(a, n, 10 ** 9 + 7) + power(b, n, 10 ** 9 + 7)) % (10 ** 9 + 7)\n        print(num)\n    else:\n        arr = []\n        for i in range(1, math.floor(math.sqrt(num)) + 1):\n            if num % i == 0:\n                arr.append(i)\n                arr.append(num // i)\n        ans = -1\n        for i in arr:\n            a1 = power(a, n, i)\n            a2 = power(b, n, i)\n            if (a1 + a2) % i == 0:\n                ans = max(ans, i)\n        print(ans % (10 ** 9 + 7))", "import math\nM = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print(pow(a, n) * 2 % M)\n    else:\n        print(math.gcd(pow(a, n, a - b) + pow(b, n, a - b), a - b) % M)", "import math\nM = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print(pow(a, n) * 2 % M)\n    else:\n        print(math.gcd(pow(a, n, a - b) + pow(b, n, a - b), a - b) % M)", "import math\nmod = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print((pow(a, n, mod) + pow(b, n, mod)) % mod)\n    else:\n        print(math.gcd(pow(a, n, abs(a - b)) + pow(b, n, abs(a - b)), abs(a - b)) % mod)", "def power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nmod = 1000000007\nimport math\nt = int(input())\nfor i in range(t):\n    (a, b, n) = tuple(map(int, input().split()))\n    if a == b:\n        print((pow(a, n, mod) + pow(b, n, mod)) % mod)\n        continue\n    ans = math.gcd((power(a, n, a - b) + power(b, n, a - b)) % (a - b), a - b) % mod\n    print(ans)", "mod = 1000000007\nimport math\nt = int(input())\nfor i in range(t):\n    (a, b, n) = tuple(map(int, input().split()))\n    if a == b:\n        print((pow(a, n, mod) + pow(b, n, mod)) % mod)\n        continue\n    d = a - b\n    ans = 1\n    for j in range(1, int(math.sqrt(d)) + 1):\n        if d % j == 0:\n            temp = (pow(a, n, j) + pow(b, n, j)) % j\n            if temp == 0:\n                ans = max(ans, j)\n            s = d // j\n            temp = (pow(a, n, s) + pow(b, n, s)) % s\n            if temp == 0:\n                ans = max(ans, s)\n    print(ans)", "mod = 1000000007\nimport math\n\ndef go(a, b, n):\n    if a == b:\n        return (pow(a, n, mod) + pow(b, n, mod)) % mod\n    d = a - b\n    ans = 1\n    for j in range(1, int(math.sqrt(d)) + 1):\n        if d % j == 0:\n            temp = 0\n            temp = (pow(a, n, j) + pow(b, n, j)) % j\n            if temp == 0:\n                ans = max(ans, j)\n            s = d // j\n            temp = (pow(a, n, s) + pow(b, n, s)) % s\n            if temp == 0:\n                ans = max(ans, s)\n    return ans % mod\nt = int(input())\nwhile t:\n    (a, b, n) = tuple(map(int, input().split()))\n    print(go(a, b, n))\n    t -= 1", "import math\n\ndef getpower(base, power, mod):\n    return pow(base, power, mod)\n\ndef gcd(a, b, power, mod):\n    if a == b:\n        return (getpower(a, power, mod) + getpower(b, power, mod)) % mod\n    num = a - b\n    candidate = 1\n    for i in range(1, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            inter = (getpower(a, power, i) + getpower(b, power, i)) % i\n            if inter == 0:\n                candidate = max(candidate, i)\n            inter = (getpower(a, power, num // i) + getpower(b, power, num // i)) % (num // i)\n            if inter == 0:\n                candidate = max(candidate, num // i)\n    return candidate\ntestcase = int(input())\nwhile testcase:\n    (a, b, power) = map(int, input().split())\n    mod = 10 ** 9 + 7\n    print(gcd(a, b, power, mod))\n    testcase -= 1", "import math\nmod = 1000000007\n\ndef power(a, n, m):\n    ans = 1\n    while n:\n        if n % 2 == 0:\n            n //= 2\n            a = a % m * (a % m) % m\n        else:\n            ans = ans % m * (a % m) % m\n            n -= 1\n    return ans\nt = int(input())\nfor i in range(t):\n    (a, b, n) = tuple(map(int, input().split()))\n    if a == b:\n        print((power(a, n, mod) + power(b, n, mod)) % mod)\n    else:\n        print(math.gcd(pow(a, n, abs(a - b)) + pow(b, n, abs(a - b)), abs(a - b)) % mod)", "import math\nmod = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print((pow(a, n, mod) + pow(b, n, mod)) % mod)\n    else:\n        print(math.gcd(pow(a, n, abs(a - b)) + pow(b, n, abs(a - b)), abs(a - b)) % mod)", "from math import gcd\nmod = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    (a, b, n) = map(int, input().split())\n    ans = 1\n    x = a\n    y = a - b\n    if (a - b) % 2 == 0:\n        y = y // 2\n        ans = 2\n    while n > 0:\n        k = gcd(x, y)\n        if k == 1:\n            break\n        ans = ans * k % mod\n        x = k\n        y = y // k\n        n -= 1\n    print(ans)", "from math import gcd\nm = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print((pow(a, n, m) + pow(b, n, m)) % m)\n        continue\n    d = a - b\n    print(gcd((pow(a, n, d) + pow(b, n, d)) % d, d) % m)", "from math import gcd\nm = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print((pow(a, n, m) + pow(b, n, m)) % m)\n        continue\n    d = a - b\n    g = (pow(a, n, d) + pow(b, n, d)) % d\n    print(gcd(g, d) % m)", "import sys, io, os, math, time\nfrom math import ceil, log, inf, floor, sqrt\nfrom itertools import permutations\nimport datetime\nmod = 1000000007\nmod1 = 998244353\n\ndef intinp():\n    return int(sys.stdin.readline())\n\ndef strinp():\n    return sys.stdin.readline()\n\ndef arrinp():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef mulinp():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef flush():\n    return sys.stdout.flush()\n\ndef power_two(x):\n    return 1 << x\n\ndef power(a, n, d):\n    res = 1\n    while n:\n        if n & 1:\n            res = res % d * (a % d) % d\n            n -= 1\n        else:\n            a = a % d * (a % d) % d\n            n = n // 2\n    return res\n\ndef gcd(a, b, n):\n    if a == b:\n        return (power(a, n, mod) + power(b, n, mod)) % mod\n    candidate = 1\n    num = abs(a - b)\n    limit = int(sqrt(num))\n    for i in range(1, limit + 1):\n        if num % i == 0:\n            tmp = (power(a, n, i) + power(b, n, i)) % i\n            if tmp == 0:\n                candidate = max(candidate, i)\n            tmp = (power(a, n, num // i) + power(b, n, num // i)) % (num // i)\n            if tmp == 0:\n                candidate = max(candidate, num // i)\n    return candidate % mod\n\ndef solution():\n    (a, b, n) = mulinp()\n    print(gcd(a, b, n))\n    return\n\ndef main():\n    tc = intinp()\n    while tc:\n        solution()\n        tc -= 1\nmain()", "import math\n\ndef powwer2(a, b, m):\n    ans = 1\n    while b > 0:\n        if b % 2 == 1:\n            ans = ans * a % m\n        a = a * a % m\n        b = b // 2\n    return ans\nt = int(input())\nM = 1000000007\nfor i in range(t):\n    (a, b, n) = list(map(int, input().split()))\n    d = a - b\n    p = 0\n    if d == 0:\n        p = (powwer2(a, n, M) + powwer2(b, n, M)) % M\n    else:\n        p = (powwer2(a, n, d) + powwer2(b, n, d)) % d\n    g = math.gcd(p, d) % M\n    print(g)", "import math\n\ndef powwer2(a, b, m):\n    ans = 1\n    while b > 0:\n        if b % 2 == 1:\n            ans = ans * a % m\n        a = a * a % m\n        b = b // 2\n    return ans\nt = int(input())\nM = 1000000007\nfor i in range(t):\n    (a, b, n) = list(map(int, input().split()))\n    d = a - b\n    p = 0\n    if d == 0:\n        p = powwer2(a, n, M) + powwer2(b, n, M)\n    else:\n        p = powwer2(a, n, d) + powwer2(b, n, d)\n    g = math.gcd(p, d) % M\n    print(g)", "import math\nfrom math import gcd, sqrt, floor, factorial, ceil\nfrom bisect import bisect_left, bisect_right\nimport bisect\nimport sys\nfrom sys import stdin, stdout\nimport os\nsys.setrecursionlimit(pow(10, 7))\nimport collections\nfrom collections import defaultdict, Counter\nfrom statistics import median\nfrom queue import Queue\ninf = float('inf')\nfrom operator import neg\nmod = pow(10, 9) + 7\n\ndef factors(n):\n    sqrta = int(sqrt(n))\n    for i in range(2, sqrta + 1):\n        if n % i == 0:\n            return [i] + factors(n // i)\n    return [n]\n\ndef check(a, b, n, number):\n    theta1 = pow(a, n, number)\n    theta2 = pow(b, n, number)\n    return (theta1 + theta2) % number == 0\nt = int(input())\nfor i in range(t):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        theta1 = pow(a, n, mod)\n        theta2 = pow(b, n, mod)\n        ans = theta1 + theta2\n        print(ans % mod)\n        continue\n    prime_fac = Counter(factors(a - b))\n    maxa = 1\n    for i in prime_fac:\n        for j in range(prime_fac[i]):\n            maxa *= i\n            if not check(a, b, n, maxa):\n                maxa //= i\n                break\n    print(maxa % mod)", "import math\nfrom math import gcd, sqrt, floor, factorial, ceil\nfrom bisect import bisect_left, bisect_right\nimport bisect\nimport sys\nfrom sys import stdin, stdout\nimport os\nsys.setrecursionlimit(pow(10, 7))\nimport collections\nfrom collections import defaultdict, Counter\nfrom statistics import median\nfrom queue import Queue\ninf = float('inf')\nfrom operator import neg\nmod = pow(10, 9) + 7\n\ndef factors(n):\n    sqrta = int(sqrt(n))\n    l = [1]\n    m = [n]\n    for i in range(2, sqrta + 1):\n        if n % i == 0:\n            l.append(i)\n            m.append(n // i)\n    m.reverse()\n    return l + m\n\ndef check(a, b, n, number):\n    theta1 = pow(a, n, number)\n    theta2 = pow(b, n, number)\n    return (theta1 + theta2) % number == 0\nt = int(input())\nfor i in range(t):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        theta1 = pow(a, n, mod)\n        theta2 = pow(b, n, mod)\n        ans = theta1 + theta2\n        print(ans % mod)\n        continue\n    fac = factors(a - b)\n    maxa = 1\n    for j in fac:\n        if check(a, b, n, j):\n            maxa = j % mod\n    print(maxa)", "import math\n\ndef getpower(base, power, mod):\n    return pow(base, power, mod)\n\ndef gcd(a, b, power, mod):\n    if a == b:\n        return (getpower(a, power, mod) + getpower(b, power, mod)) % mod\n    num = a - b\n    candidate = 1\n    for i in range(1, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            inter = (getpower(a, power, i) + getpower(b, power, i)) % i\n            if inter == 0:\n                candidate = max(candidate, i)\n            inter = (getpower(a, power, num // i) + getpower(b, power, num // i)) % (num // i)\n            if inter == 0:\n                candidate = max(candidate, num // i)\n    return candidate\ntestcase = int(input())\nwhile testcase:\n    (a, b, power) = map(int, input().split())\n    mod = 10 ** 9 + 7\n    print(gcd(a, b, power, mod))\n    testcase -= 1", "def power(a, n, d):\n    i = 1\n    while n >= 1:\n        if n % 2 != 0:\n            i = i % d * (a % d) % d\n            n -= 1\n        else:\n            a = a % d * (a % d) % d\n            n //= 2\n    return i % d\n\ndef funct(a, b, n):\n    if a == b:\n        return power(a, n, 10 ** 9 + 7) + power(b, n, 10 ** 9 + 7)\n    i = 1\n    l = abs(a - b)\n    candidate = 1\n    while i * i <= l:\n        if l % i == 0:\n            temp = (power(a, n, i) + power(b, n, i)) % i\n            if temp == 0:\n                candidate = max(candidate, i)\n            temp = (power(a, n, l // i) + power(b, n, l // i)) % (l // i)\n            if temp == 0:\n                candidate = max(candidate, l // i)\n        i += 1\n    return candidate\nt = int(input())\nfor i in range(t):\n    (a, b, n) = map(int, input().split())\n    print(funct(a, b, n))", "from math import gcd\n\ndef main():\n    try:\n        for _ in range(int(input())):\n            (a, b, n) = list(map(int, input().split()))\n            sub = abs(b - a)\n            if sub != 0:\n                c = (pow(a, n, sub) + pow(b, n, sub)) % sub\n                print(gcd(sub, c) % (7 + 10 ** 9))\n            else:\n                sub = 7 + 10 ** 9\n                print((pow(a, n, sub) + pow(b, n, sub)) % sub)\n    except:\n        pass\nmain()", "def power(num, p, D, m):\n    if p == 0:\n        return 1\n    elif p == 1:\n        return num % m\n    elif p in D:\n        return D[p]\n    else:\n        D[p] = power(num, p // 2, D, m) % m * (power(num, p - p // 2, D, m) % m) % m\n        return D[p]\n\ndef gcd(a, b, m):\n    if b == 0:\n        return a % m\n    else:\n        return gcd(b, a % b, m) % m\nT = int(input())\nans = []\nm = 10 ** 9 + 7\nfor _ in range(T):\n    (a, b, n) = [int(i) for i in input().split()]\n    if a == b:\n        ans.append(power(a, n, {}, m) + power(a, n, {}, m) % m)\n    else:\n        x = power(a, n, {}, abs(a - b))\n        y = power(b, n, {}, abs(a - b))\n        x = (x + y) % abs(a - b)\n        y = abs(a - b)\n        ans.append(gcd(y, x, m) % m)\nfor i in ans:\n    print(i)", "mod = 10 ** 9 + 7\n\ndef power(a, n, m):\n    if n == 0:\n        return 1\n    res = 1\n    while n:\n        if n % 2 == 1:\n            res = res * a % m\n            n -= 1\n        else:\n            a = a * a % m\n            n //= 2\n    return res % m\n\ndef gcd(a, b):\n    if b == 0:\n        return a % mod\n    return gcd(b, a % b) % mod\n\ndef calGCD(a, b, n):\n    if a == b:\n        return (power(a, n, mod) + power(a, n, mod)) % mod\n    x = power(a, n, abs(a - b))\n    y = power(b, n, abs(a - b))\n    x = (x + y) % abs(a - b)\n    y = abs(a - b)\n    return gcd(y, x) % mod\ntry:\n    t = int(input())\n    for _ in range(t):\n        (a, b, n) = map(int, input().split())\n        print(calGCD(a, b, n))\nexcept:\n    pass", "mod = int(1000000000.0 + 7)\n\ndef power(x, y, MOD):\n    ans = 1\n    while y > 0:\n        if y & 1:\n            ans = ans * x % MOD\n        y = y >> 1\n        x = x * x % MOD\n    return ans\n\ndef gcd(a, b):\n    if a < b:\n        swap(a, b)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nt = int(input())\nwhile t > 0:\n    ar = tuple(map(int, input().split()))\n    a = ar[0]\n    b = ar[1]\n    n = ar[2]\n    t -= 1\n    d = a - b\n    if d == 0:\n        ans = (power(a, n, mod) + power(b, n, mod)) % mod\n        print(ans)\n        continue\n    p = (power(a, n, d) + power(b, n, d)) % d\n    ans = gcd(d, p) % mod\n    print(int(ans))", "import math\nM = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print(pow(a, n) * 2 % M)\n    else:\n        print(math.gcd(pow(a, n, a - b) + pow(b, n, a - b), a - b) % M)", "from math import gcd\nt = int(input())\nMOD = int(1000000000.0 + 7)\nfor _ in range(t):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print((pow(a, n, MOD) + pow(b, n, MOD)) % MOD)\n        continue\n    aa = pow(a, n, a - b)\n    bb = pow(b, n, a - b)\n    mm = (aa + bb) % MOD\n    print(gcd(aa + bb, a - b))", "def fast_power(x, y, mod):\n    if x == 0:\n        return 0\n    res = 1\n    while y > 0:\n        if y % 2 != 0:\n            res = res * x % mod\n        y = y >> 1\n        x = x * x % mod\n    return res\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nfor tt in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    mod = 10 ** 9 + 7\n    r = abs(a - b)\n    if r == 0:\n        print((fast_power(a, n, mod) + fast_power(b, n, mod)) % mod)\n    else:\n        r1 = fast_power(a, n, r)\n        r2 = fast_power(b, n, r)\n        x = (r1 + r2) % r\n        print(gcd(x, r) % mod)", "def fast_power(x, y, mod):\n    if y == 0:\n        return 1\n    temp = fast_power(x, y // 2, mod)\n    if y % 2 == 0:\n        return temp * temp % mod\n    else:\n        return x * temp * temp % mod\n\ndef gcd(x, y):\n    if y == 0:\n        return x\n    else:\n        return gcd(y, x % y)\nfor tt in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    mod = 10 ** 9 + 7\n    r1 = abs(a - b)\n    if r1 == 0:\n        print((fast_power(a, n, mod) + fast_power(b, n, mod)) % mod)\n    else:\n        r2 = fast_power(a, n, r1)\n        r3 = fast_power(b, n, r1)\n        x = (r2 + r3) % r1\n        print(gcd(x, r1) % mod)", "import math\nm = 10 ** 9 + 7\nt = int(input())\n\ndef modExp(a, b, m):\n    ans = 1\n    a = a % m\n    while b > 0:\n        if b & 1:\n            ans = ans % m * (a % m) % m\n        a = a % m * (a % m) % m\n        b = b >> 1\n    return ans % m\nfor i in range(0, t):\n    l = list(map(int, input().split()))\n    a = l[0]\n    b = l[1]\n    n = l[2]\n    if a == b:\n        ans = (modExp(a, n, m) + modExp(b, n, m)) % m\n        print(ans)\n    else:\n        val1 = (modExp(a, n, a - b) + modExp(b, n, a - b)) % (a - b)\n        val2 = a - b\n        val3 = math.gcd(val1, val2) % m\n        print(val3)", "import math\nM = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print(pow(a, n) * 2 % M)\n    else:\n        print(math.gcd(pow(a, n, a - b) + pow(b, n, a - b), a - b) % M)", "import math\nM = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if a == b:\n        print(pow(a, n) * 2 % M)\n    else:\n        print(math.gcd(pow(a, n, a - b) + pow(b, n, a - b), a - b) % M)", "from math import gcd\nMOD = 1000000007\n\ndef main():\n    for _ in range(int(input())):\n        (a, b, n) = [int(x) for x in input().split()]\n        if a == b:\n            print((pow(a, n, MOD) + pow(b, n, MOD)) % MOD)\n        else:\n            x = pow(a, n, a - b)\n            y = pow(b, n, a - b)\n            print(gcd(x + y, a - b) % MOD)\nmain()", "def power(a, b, MOD):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b = b >> 1\n    return res\nMOD2 = 1000000007\nt = int(input())\nwhile t > 0:\n    (a, b, n) = input().split()\n    (a, b, n) = (int(a), int(b), int(n))\n    x = a - b\n    if x == 0:\n        print(int((power(a, n, MOD2) + power(b, n, MOD2)) % MOD2))\n        t -= 1\n        continue\n    options = []\n    for i in range(1, x):\n        if i * i > x:\n            break\n        if x % i == 0:\n            options.append(i)\n            if x / i != i:\n                options.append(int(x / i))\n    options.sort()\n    ans = 1\n    for val in options:\n        if int((power(a, n, val) + power(b, n, val)) % val) == 0:\n            ans = val\n    print(int(ans % MOD2))\n    t -= 1", "def power(a, n, mod):\n    if n == 0:\n        return 1\n    if n == 1:\n        return a\n    res = power(a, int(n / 2), mod)\n    if n % 2 == 0:\n        return res % mod * res % mod % mod\n    res = res % mod * res % mod % mod\n    res = a % mod * res % mod\n    return res\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef solve():\n    (a, b, n) = map(int, input().split())\n    y = a - b\n    mod = 1000000007\n    if y == 0:\n        ans = power(a, n, mod) + power(b, n, mod)\n        ans = ans % mod\n        print(ans)\n        return\n    result = power(a, n, y) + power(b, n, y)\n    result = gcd(y, result)\n    result = result % mod\n    print(result)\nt = input()\nt = int(t)\nfor k in range(t):\n    solve()", "import math\nimport sys\nMAX = 1000000007\n\ndef countOnes(n):\n    arr = []\n    while n != 0:\n        if n & 1 == 1:\n            arr.append(1)\n        else:\n            arr.append(0)\n        n = n >> 1\n    return arr\n\ndef binMod(num, mod, binN):\n    bd = [num % mod]\n    while len(bd) <= len(binN):\n        bd.append(bd[-1] ** 2 % mod)\n    total = 1\n    for i in range(len(binN)):\n        if binN[i] == 1:\n            total *= bd[i]\n    return total\n\ndef solve(a, b, n):\n    binN = countOnes(n)\n    mod = abs(a - b)\n    if mod == 0:\n        mod = MAX\n    aPrime = binMod(a, mod, binN)\n    bPrime = binMod(b, mod, binN)\n    final = aPrime + bPrime\n    if mod == MAX:\n        return final % MAX\n    return math.gcd(final, mod) % MAX\n\ndef readinput():\n    tc = int(sys.stdin.readline().rstrip())\n    for _ in range(tc):\n        (a, b, n) = map(int, sys.stdin.readline().rstrip().split(' '))\n        print(solve(a, b, n))\nreadinput()", "import math\nm = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if abs(a - b) == 0:\n        print(pow(a, n, m) + pow(b, n, m) % m)\n    else:\n        d = pow(a, n, abs(a - b)) + pow(a, n, abs(a - b))\n        print(math.gcd(d, abs(a - b)))", "from math import gcd\nm = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    if abs(a - b) == 0:\n        print(pow(a, n, m) + pow(b, n, m) % m)\n    else:\n        d = pow(a, n, abs(a - b)) + pow(a, n, abs(a - b))\n        print(gcd(abs(a - b), d))", "from math import gcd\n\ndef expo(a, b, m):\n    if b == 0:\n        return 1\n    elif b % 2 == 0:\n        val = expo(a, b // 2, m)\n        return val * val % m\n    else:\n        res = expo(a, b - 1, m)\n        return res * a % m\nm = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (a, b, n) = [int(x) for x in input().split()]\n    if a == b:\n        y = expo(b, n, m)\n        print((y + y) % m)\n    else:\n        m2 = abs(a - b)\n        x = expo(a, n, m2)\n        y = expo(b, n, m2)\n        print(gcd(x + y, m2))", "import math\nmod = 1000000007\n\ndef bruteForce(a, b, n):\n    if a == b:\n        res = pow(a, n, mod)\n        return res % mod + res % mod\n    d = abs(b - a)\n    (a, b) = (pow(a, n, d), pow(b, n, d))\n    ab = a + b\n    r = math.gcd(ab, d)\n    return r % mod\n\ndef power(a, n, m):\n    result = 1\n    while n > 0:\n        a = a % m\n        if n % 2 == 1:\n            result = result % m * a % m\n            n -= 1\n        a = a * a % m\n        n //= 2\n    return result % m\n\ndef checkGCD(a, b, n, d):\n    a = power(a, n, d) % d\n    b = power(b, n, d) % d\n    aplusb = (a + b) % d\n    if aplusb == 0:\n        return True\n    return False\n\ndef solve(a, b, n):\n    if a == b:\n        return 2 * power(b, n, mod) % mod % mod\n    diff = abs(a - b)\n    res = 1\n    i = 1\n    while i * i <= diff:\n        if diff % i == 0:\n            if checkGCD(a, b, n, i):\n                res = max(res, i)\n            if checkGCD(a, b, n, diff // i):\n                res = max(res, diff // i)\n        i += 1\n    return res % mod\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    print(solve(a, b, n))", "import math\nmod = 1000000007\n\ndef bruteForce(a, b, n):\n    if a == b:\n        res = pow(a, n, mod)\n        return res % mod + res % mod\n    d = abs(b - a)\n    (a, b) = (pow(a, n, d), pow(b, n, d))\n    ab = a + b\n    r = math.gcd(ab, d)\n    return r % mod\nfor _ in range(int(input())):\n    (a, b, n) = map(int, input().split())\n    print(bruteForce(a, b, n))"]