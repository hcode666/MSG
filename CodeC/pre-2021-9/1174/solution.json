["import math\ndp = []\ndp.append(0)\nfor i in range(1, 1000005):\n    dp.append(math.log(i) + dp[i - 1])\nt = int(input())\nfor i in range(t):\n    (n, m, p, k) = input().split()\n    n = int(n)\n    m = int(m)\n    p = int(p)\n    k = int(k)\n    if p == 0 or (n % 2 == 0 and m % 2 == 0):\n        ans = 1.0\n        print(ans)\n    elif n % 2 == 1 and m % 2 == 1:\n        ans = 0.0\n        print(ans * 100)\n    else:\n        P = 0\n        kln2 = k * math.log(2)\n        for i in range(p, k + 1):\n            lnPi = dp[k] - dp[i] - dp[k - i] - kln2\n            Pi = pow(math.e, lnPi)\n            P += Pi\n        print(P)", "import math\ndp = []\ndp.append(0)\nfor i in range(1, 1000005):\n    dp.append(math.log(i) + dp[i - 1])\nt = int(input())\nfor i in range(t):\n    (n, m, p, k) = input().split()\n    n = int(n)\n    m = int(m)\n    p = int(p)\n    k = int(k)\n    if p == 0 or (n % 2 == 0 and m % 2 == 0):\n        ans = 1.0\n        print(ans)\n    elif n % 2 == 1 and m % 2 == 1:\n        ans = 0.0\n        print(ans * 100)\n    else:\n        P = 0\n        kln2 = k * math.log(2)\n        for i in range(p, k + 1):\n            lnPi = dp[k] - dp[i] - dp[k - i] - kln2\n            Pi = pow(math.e, lnPi)\n            P += Pi\n        print(P)", "import math\ndp = []\ndp.append(0)\nfor i in range(1, 1000005):\n    dp.append(math.log(i) + dp[i - 1])\nt = int(input())\nfor i in range(t):\n    (n, m, p, k) = input().split()\n    n = int(n)\n    m = int(m)\n    p = int(p)\n    k = int(k)\n    if p == 0 or (n % 2 == 0 and m % 2 == 0):\n        ans = 1.0\n        print(ans)\n    elif n % 2 == 1 and m % 2 == 1:\n        ans = 0.0\n        print(ans * 100)\n    else:\n        P = 0\n        kln2 = k * math.log(2)\n        for i in range(p, k + 1):\n            lnPi = dp[k] - dp[i] - dp[k - i] - kln2\n            Pi = pow(math.e, lnPi)\n            P += Pi\n        print(P)", "import math\ndp = []\ndp.append(0)\nfor i in range(1, 1000005):\n    dp.append(math.log(i) + dp[i - 1])\nt = int(input())\nfor i in range(t):\n    (n, m, p, k) = input().split()\n    n = int(n)\n    m = int(m)\n    p = int(p)\n    k = int(k)\n    if p == 0 or (n % 2 == 0 and m % 2 == 0):\n        ans = 1.0\n        print(ans)\n    elif n % 2 == 1 and m % 2 == 1:\n        ans = 0.0\n        print(ans)\n    else:\n        P = 0\n        kln2 = k * math.log(2)\n        for i in range(p, k + 1):\n            lnPi = dp[k] - dp[i] - dp[k - i] - kln2\n            Pi = pow(math.e, lnPi)\n            P += Pi\n        print(P)", "import math\ndp = []\ndp.append(0)\nfor i in range(1, 1000005):\n    dp.append(math.log(i) + dp[i - 1])\nt = int(input())\nfor i in range(t):\n    (n, m, p, k) = input().split()\n    n = int(n)\n    m = int(m)\n    p = int(p)\n    k = int(k)\n    if p == 0 or (n % 2 == 0 and m % 2 == 0):\n        ans = 1.0\n        print(ans)\n    elif n % 2 == 1 and m % 2 == 1:\n        ans = 0.0\n        print(ans)\n    else:\n        P = 0\n        kln2 = k * math.log(2)\n        for i in range(p, k + 1):\n            lnPi = dp[k] - dp[i] - dp[k - i] - kln2\n            Pi = pow(math.e, lnPi)\n            P += Pi\n        print(P)", "import math\ndp = []\ndp.append(0)\nfor i in range(1, 1000005):\n    dp.append(math.log(i) + dp[i - 1])\nt = int(input())\nfor i in range(t):\n    (n, m, p, k) = input().split()\n    n = int(n)\n    m = int(m)\n    p = int(p)\n    k = int(k)\n    if p == 0 or (n % 2 == 0 and m % 2 == 0):\n        ans = 1.0\n        print(ans)\n    elif n % 2 == 1 and m % 2 == 1:\n        ans = 0.0\n        print(ans)\n    else:\n        P = 0\n        kln2 = k * math.log(2)\n        for i in range(p, k + 1):\n            lnPi = dp[k] - dp[i] - dp[k - i] - kln2\n            Pi = pow(math.e, lnPi)\n            P += Pi\n        print(P)", "import math\nlnfact = [0, 0]\nfor i in range(2, int(1000000.0) + 1):\n    lnfact.append(lnfact[-1] + math.log(i))\n\ndef calc(p, k):\n    P = 0\n    kln2 = k * math.log(2)\n    for i in range(p, k + 1):\n        lnPi = lnfact[k] - lnfact[i] - lnfact[k - i] - kln2\n        Pi = pow(math.e, lnPi)\n        P += Pi\n    return P\nfor t in range(int(input())):\n    (n, m, p, k) = map(int, input().split())\n    if p == 0 or (n % 2 == 0 and m % 2 == 0):\n        print(1.0)\n    elif n % 2 == 1 and m % 2 == 1:\n        print(0.0)\n    else:\n        print(calc(p, k))", "import math\nlnfact = [0, 0]\nfor i in range(2, int(1000000.0) + 1):\n    lnfact.append(lnfact[-1] + math.log(i))\n\ndef calc(p, k):\n    P = 0\n    kln2 = k * math.log(2)\n    for i in range(0, p + 1):\n        lnPi = lnfact[k] - lnfact[i] - lnfact[k - i] - kln2\n        Pi = pow(math.e, lnPi)\n        P += Pi\n    return P\nfor t in range(int(input())):\n    (n, m, p, k) = map(int, input().split())\n    if p == 0 or (n % 2 == 0 and m % 2 == 0):\n        print(1.0)\n    elif n % 2 == 1 and m % 2 == 1:\n        print(0.0)\n    else:\n        print(calc(k - p, k))", "import sys\nMAX = 1000005\nINF = 1e+40\n\ndef solve(p, k):\n    curr = 1\n    ctr = min(100, k)\n    i = 1\n    while i <= ctr:\n        curr /= 2.0\n        i += 1\n    ans = curr\n    if p >= k / 2:\n        i = k - 1\n        while i >= p:\n            curr *= i + 1\n            curr /= k - i\n            ans += curr\n            if curr >= INF:\n                while ctr < k and curr >= INF:\n                    ctr += 1\n                    curr /= 2.0\n                    ans /= 2.0\n            i -= 1\n        i = ctr + 1\n        while i <= k:\n            ans /= 2.0\n            i += 1\n    else:\n        i = 1\n        while i < p:\n            curr *= k - i + 1\n            curr /= i\n            ans += curr\n            if curr >= INF:\n                while ctr < k and curr >= INF:\n                    ctr += 1\n                    curr /= 2.0\n                    ans /= 2.0\n            i += 1\n        i = ctr + 1\n        while i <= k:\n            ans /= 2.0\n            i += 1\n        ans = 1.0 - ans\n    return ans\ninpos = sys.stdin\nt = int(inpos.readline())\nfor _ in range(t):\n    inp = list(map(int, inpos.readline().split()))\n    n = inp[0]\n    m = inp[1]\n    p = inp[2]\n    k = inp[3]\n    if p == 0:\n        ans = 1.0\n    elif n % 2 == 0 and m % 2 == 0:\n        ans = 1.0\n    elif n % 2 == 0 or m % 2 == 0:\n        ans = solve(p, k)\n    else:\n        ans = 0.0\n    print('{0:.10f}'.format(ans))", "from math import erf, sqrt\n\ndef foo(n, r):\n    r += 1\n    (ans, x) = (1, 1)\n    (p, q) = (n, 1)\n    for i in range(1, r):\n        x = p * x / q\n        p -= 1\n        q += 1\n        ans += x\n    return ans\n\ndef phi(x):\n    return (1.0 + erf(x / sqrt(2.0))) / 2.0\nT = int(input())\nfor t in range(T):\n    (N, M, P, K) = map(int, input().strip().split())\n    ans = 1\n    if P != 0:\n        (yoda1, yoda2) = (M & 1 and N & 1, M & 1 or N & 1)\n        if yoda1 & yoda2:\n            ans = 0\n        elif yoda1 or yoda2:\n            if K <= 1020:\n                d = pow(2, K)\n                if P <= K - P:\n                    n = d - foo(K, P - 1)\n                else:\n                    n = foo(K, K - P)\n                ans = n / d\n            else:\n                ans = phi((K - P + 0.5 - 0.5 * K) / sqrt(K * 0.25))\n    ans = round(ans, 6)\n    print(ans)", "import math\nla = [0, 0]\nfor i in range(2, int(1000000.0) + 1):\n    la.append(la[-1] + math.log(i))\n\ndef calc(p, k):\n    s = 0\n    kl2 = k * math.log(2)\n    for i in range(0, p + 1):\n        lgpi = la[k] - la[i] - la[k - i] - kl2\n        pi = pow(math.e, lgpi)\n        s += pi\n    return s\nfor t in range(int(input())):\n    (n, m, p, k) = map(int, input().split())\n    if p == 0 or (n % 2 == 0 and m % 2 == 0):\n        print(1.0)\n    elif n % 2 == 1 and m % 2 == 1:\n        print(0.0)\n    else:\n        p = k - p\n        print(calc(p, k))", "import math\nt = int(input())\nlogfact = []\nlogfact.append(0)\nfor i in range(1, 1000001):\n    logfact.append(logfact[i - 1] + math.log2(i))\nwhile t > 0:\n    (n, m, p, k) = map(int, input().split())\n    winner1 = True\n    winner2 = False\n    ans = 0.0\n    if n & 1 == 1 and m & 1 == 1:\n        winner1 = False\n    if n & 1 == 0 and m & 1 == 0:\n        winner2 = True\n    if winner1 == False and winner2 == False:\n        if p == 0:\n            ans = 1.0\n        else:\n            ans = 0.0\n    elif winner1 == True and winner2 == True:\n        ans = 1.0\n    else:\n        t1 = 1.0\n        val = 1.0\n        for i in range(1, k - p + 1):\n            div = 1.0 * k - t1 + 1.0\n            val = val * t1 / div + 1.0\n            t1 += 1.0\n        pw = math.log2(val) + logfact[k] - k - logfact[p] - logfact[k - p]\n        ans = 2 ** pw\n    print(float('{0:.9f}'.format(ans)))\n    t -= 1", "import sys\nMAX = 1000005\nINF = 1e+40\n\ndef solve(p, k):\n    curr = 1\n    ctr = min(100, k)\n    i = 1\n    while i <= ctr:\n        curr /= 2.0\n        i += 1\n    ans = curr\n    if p >= k / 2:\n        i = k - 1\n        while i >= p:\n            curr *= i + 1\n            curr /= k - i\n            ans += curr\n            if curr >= INF:\n                while ctr < k and curr >= INF:\n                    ctr += 1\n                    curr /= 2.0\n                    ans /= 2.0\n            i -= 1\n        i = ctr + 1\n        while i <= k:\n            ans /= 2.0\n            i += 1\n    else:\n        i = 1\n        while i < p:\n            curr *= k - i + 1\n            curr /= i\n            ans += curr\n            if curr >= INF:\n                while ctr < k and curr >= INF:\n                    ctr += 1\n                    curr /= 2.0\n                    ans /= 2.0\n            i += 1\n        i = ctr + 1\n        while i <= k:\n            ans /= 2.0\n            i += 1\n        ans = 1.0 - ans\n    return ans\ninpos = sys.stdin\nt = int(inpos.readline())\nfor _ in range(t):\n    inp = list(map(int, inpos.readline().split()))\n    n = inp[0]\n    m = inp[1]\n    p = inp[2]\n    k = inp[3]\n    if p == 0:\n        ans = 1.0\n    elif n % 2 == 0 and m % 2 == 0:\n        ans = 1.0\n    elif n % 2 == 0 or m % 2 == 0:\n        ans = solve(p, k)\n    else:\n        ans = 0.0\n    print('{0:.10f}'.format(ans))", "import sys\nMAX = 1000005\nINF = 1e+40\n\ndef binomial_sum(N, K):\n    (current_exponent, current_mantissa) = (0, 1.0)\n    (total_exponent, total_mantissa) = (0, 1.0)\n    for i in range(1, K + 1):\n        current_mantissa = (N - i + 1) * current_mantissa / i\n        while current_mantissa >= 2:\n            current_mantissa /= 2\n            current_exponent += 1\n        while current_mantissa <= 0.5:\n            current_mantissa *= 2\n            current_exponent -= 1\n        total_mantissa += current_mantissa * pow(2, current_exponent - total_exponent)\n        while total_mantissa >= 2:\n            total_mantissa /= 2\n            total_exponent += 1\n    return (total_exponent, total_mantissa)\n\ndef solve(p, k):\n    curr = 1\n    ctr = min(100, k)\n    i = 1\n    while i <= ctr:\n        curr /= 2.0\n        i += 1\n    ans = curr\n    if p >= k / 2:\n        i = k - 1\n        while i >= p:\n            curr *= i + 1\n            curr /= k - i\n            ans += curr\n            if curr >= INF:\n                while ctr < k and curr >= INF:\n                    ctr += 1\n                    curr /= 2.0\n                    ans /= 2.0\n            i -= 1\n        i = ctr + 1\n        while i <= k:\n            ans /= 2.0\n            i += 1\n    else:\n        i = 1\n        while i < p:\n            curr *= k - i + 1\n            curr /= i\n            ans += curr\n            if curr >= INF:\n                while ctr < k and curr >= INF:\n                    ctr += 1\n                    curr /= 2.0\n                    ans /= 2.0\n            i += 1\n        i = ctr + 1\n        while i <= k:\n            ans /= 2.0\n            i += 1\n        ans = 1.0 - ans\n    return ans\ninpos = sys.stdin\nt = int(inpos.readline())\nfor _ in range(t):\n    inp = list(map(int, inpos.readline().split()))\n    n = inp[0]\n    m = inp[1]\n    p = inp[2]\n    k = inp[3]\n    if p == 0:\n        ans = 1.0\n    elif n % 2 == 0 and m % 2 == 0:\n        ans = 1.0\n    elif n % 2 == 0 or m % 2 == 0:\n        if k <= MAX:\n            ans = solve(p, k)\n        elif p <= MAX or k - p <= MAX:\n            ans = solve(p, k)\n        else:\n            g1 = binomial_sum(k, p - 1)\n            u = g1[0] - k\n            ans = g1[1]\n            while u < 0:\n                ans /= 2.0\n                u += 1\n            ans = 1.0 - ans\n    else:\n        ans = 0.0\n    print('{0:.10f}'.format(ans))"]