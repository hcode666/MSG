["import bisect\nimport copy\nimport decimal\nimport fractions\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom functools import lru_cache, reduce\nfrom heapq import heappush, heappop, heapify, heappushpop, _heappop_max, _heapify_max\n\ndef _heappush_max(heap, item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap) - 1)\n\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        (item, heap[0]) = (heap[0], item)\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import gcd as GCD\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef LCM(n, m):\n    if n or m:\n        return abs(n) * abs(m) // math.gcd(n, m)\n    return 0\n\ndef Extended_Euclid(n, m):\n    stack = []\n    while m:\n        stack.append((n, m))\n        (n, m) = (m, n % m)\n    if n >= 0:\n        (x, y) = (1, 0)\n    else:\n        (x, y) = (-1, 0)\n    for i in range(len(stack) - 1, -1, -1):\n        (n, m) = stack[i]\n        (x, y) = (y, x - n // m * y)\n    return (x, y)\n\nclass MOD:\n\n    def __init__(self, mod):\n        self.mod = mod\n\n    def Pow(self, a, n):\n        a %= self.mod\n        if n >= 0:\n            return pow(a, n, self.mod)\n        else:\n            assert math.gcd(a, self.mod) == 1\n            x = Extended_Euclid(a, self.mod)[0]\n            return pow(x, -n, self.mod)\n\n    def Build_Fact(self, N):\n        assert N >= 0\n        self.factorial = [1]\n        for i in range(1, N + 1):\n            self.factorial.append(self.factorial[-1] * i % self.mod)\n        self.factorial_inv = [None] * (N + 1)\n        self.factorial_inv[-1] = self.Pow(self.factorial[-1], -1)\n        for i in range(N - 1, -1, -1):\n            self.factorial_inv[i] = self.factorial_inv[i + 1] * (i + 1) % self.mod\n        return self.factorial_inv\n\n    def Fact(self, N):\n        return self.factorial[N]\n\n    def Fact_Inv(self, N):\n        return self.factorial_inv[N]\n\n    def Comb(self, N, K):\n        if K < 0 or K > N:\n            return 0\n        s = self.factorial[N]\n        s = s * self.factorial_inv[K] % self.mod\n        s = s * self.factorial_inv[N - K] % self.mod\n        return s\n\nclass Prime:\n\n    def __init__(self, N):\n        self.smallest_prime_factor = [None] * (N + 1)\n        for i in range(2, N + 1, 2):\n            self.smallest_prime_factor[i] = 2\n        n = int(N ** 0.5) + 1\n        for p in range(3, n, 2):\n            if self.smallest_prime_factor[p] == None:\n                self.smallest_prime_factor[p] = p\n                for i in range(p ** 2, N + 1, 2 * p):\n                    if self.smallest_prime_factor[i] == None:\n                        self.smallest_prime_factor[i] = p\n        for p in range(n, N + 1):\n            if self.smallest_prime_factor[p] == None:\n                self.smallest_prime_factor[p] = p\n        self.primes = [p for p in range(N + 1) if p == self.smallest_prime_factor[p]]\n\n    def Factorize(self, N):\n        assert N >= 1\n        factorize = defaultdict(int)\n        if N <= len(self.smallest_prime_factor) - 1:\n            while N != 1:\n                factorize[self.smallest_prime_factor[N]] += 1\n                N //= self.smallest_prime_factor[N]\n        else:\n            for p in self.primes:\n                while N % p == 0:\n                    N //= p\n                    factorize[p] += 1\n                if N < p * p:\n                    if N != 1:\n                        factorize[N] += 1\n                    break\n                if N <= len(self.smallest_prime_factor) - 1:\n                    while N != 1:\n                        factorize[self.smallest_prime_factor[N]] += 1\n                        N //= self.smallest_prime_factor[N]\n                    break\n            else:\n                if N != 1:\n                    factorize[N] += 1\n        return factorize\n\n    def Divisors(self, N):\n        assert N > 0\n        divisors = [1]\n        for (p, e) in self.Factorize(N).items():\n            A = [1]\n            for _ in range(e):\n                A.append(A[-1] * p)\n            divisors = [i * j for i in divisors for j in A]\n        return divisors\n\n    def Is_Prime(self, N):\n        return N == self.smallest_prime_factor[N]\n\n    def Totient(self, N):\n        for p in self.Factorize(N).keys():\n            N *= p - 1\n            N //= p\n        return N\n\nclass Lucas_Prime:\n\n    def __init__(self, P, e=1, divisible_count=False):\n        self.P = P\n        self.e = e\n        self.divisible_count = divisible_count\n        self.mod = self.P ** self.e\n        self.factorial = [1]\n        for i in range(1, self.mod):\n            self.factorial.append(self.factorial[-1])\n            if i % P:\n                self.factorial[i] *= i\n                self.factorial[i] %= self.mod\n\n    def Comb(self, N, K):\n        if K < 0 or K > N:\n            return 0\n        (K0, K1) = (K, N - K)\n        N_lst = []\n        N_ = N\n        while N_:\n            N_lst.append(N_ % self.mod)\n            N_ //= self.P\n        K0_lst = []\n        K0_ = K0\n        for _ in range(len(N_lst)):\n            K0_lst.append(K0_ % self.mod)\n            K0_ //= self.P\n        K1_lst = []\n        K1_ = K1\n        for _ in range(len(N_lst)):\n            K1_lst.append(K1_ % self.mod)\n            K1_ //= self.P\n        (retu, retu_rev) = (1, 1)\n        for n in N_lst:\n            retu *= self.factorial[n]\n            retu %= self.mod\n        for k0 in K0_lst:\n            retu_rev *= self.factorial[k0]\n            retu_rev %= self.mod\n        for k1 in K1_lst:\n            retu_rev *= self.factorial[k1]\n            retu_rev %= self.mod\n        retu *= MOD(self.mod).Pow(retu_rev, -1)\n        if self.P != 2 or self.e <= 2:\n            cnt = 0\n            N_ = N // self.mod\n            K0_ = K0 // self.mod\n            K1_ = K1 // self.mod\n            while N_:\n                cnt += N_\n                N_ //= self.P\n            while K0_:\n                cnt += K0_\n                K0_ //= self.P\n            while K1_:\n                cnt += K1_\n                K1_ //= self.P\n            if cnt % 2 == 1:\n                retu *= -1\n        retu %= self.mod\n        div_cnt = 0\n        (N_, K0_, K1_) = (N, K0, K1)\n        while N_:\n            div_cnt += N_\n            N_ //= self.P\n        while K0_:\n            div_cnt -= K0_\n            K0_ //= self.P\n        while K1_:\n            div_cnt -= K1_\n            K1_ //= self.P\n        if self.divisible_count:\n            return (retu, div_cnt)\n        else:\n            retu *= pow(self.P, div_cnt, self.mod)\n            retu %= self.mod\n            return retu\n\nclass Lucas:\n\n    def __init__(self, mod):\n        self.mod = mod\n        P = Prime(int(self.mod ** 0.5))\n        self.factorize = P.Factorize(mod)\n        self.L = {p: Lucas_Prime(p, e) for (p, e) in self.factorize.items()}\n\n    def Comb(self, N, K):\n        lst_r = []\n        lst_m = []\n        for (p, e) in self.factorize.items():\n            lst_r.append(self.L[p].Comb(N, K))\n            lst_m.append(p ** e)\n        (r, _) = CRT(lst_r, lst_m)\n        return r\n\ndef CRT(lst_r, lst_m):\n    (r, m) = (lst_r[0], lst_m[0])\n    for (r0, m0) in zip(lst_r[1:], lst_m[1:]):\n        if (r0, m0) == (-1, 0):\n            (r, m) = (-1, 0)\n            break\n        r0 %= m0\n        g = math.gcd(m, m0)\n        l = LCM(m, m0)\n        if r % g != r0 % g:\n            (r, m) = (-1, 0)\n            break\n        (r, m) = ((r0 + m0 * ((r - r0) // g * Extended_Euclid(m0 // g, m // g)[0] % (m // g))) % l, l)\n    return (r, m)\nT = int(readline())\nfor _ in range(T):\n    (N, K, M) = map(int, readline().split())\n    ans0 = (N + K - 1) // K\n    ans1 = Lucas(M).Comb(ans0 * K - N + ans0 - 1, ans0 - 1)\n    print(ans0, ans1)", "import bisect\nimport copy\nimport decimal\nimport fractions\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom functools import lru_cache, reduce\nfrom heapq import heappush, heappop, heapify, heappushpop, _heappop_max, _heapify_max\n\ndef _heappush_max(heap, item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap) - 1)\n\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        (item, heap[0]) = (heap[0], item)\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import gcd as GCD\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef LCM(n, m):\n    if n or m:\n        return abs(n) * abs(m) // math.gcd(n, m)\n    return 0\n\ndef Extended_Euclid(n, m):\n    stack = []\n    while m:\n        stack.append((n, m))\n        (n, m) = (m, n % m)\n    if n >= 0:\n        (x, y) = (1, 0)\n    else:\n        (x, y) = (-1, 0)\n    for i in range(len(stack) - 1, -1, -1):\n        (n, m) = stack[i]\n        (x, y) = (y, x - n // m * y)\n    return (x, y)\n\nclass MOD:\n\n    def __init__(self, mod):\n        self.mod = mod\n\n    def Pow(self, a, n):\n        a %= self.mod\n        if n >= 0:\n            return pow(a, n, self.mod)\n        else:\n            assert math.gcd(a, self.mod) == 1\n            x = Extended_Euclid(a, self.mod)[0]\n            return pow(x, -n, self.mod)\n\n    def Build_Fact(self, N):\n        assert N >= 0\n        self.factorial = [1]\n        for i in range(1, N + 1):\n            self.factorial.append(self.factorial[-1] * i % self.mod)\n        self.factorial_inv = [None] * (N + 1)\n        self.factorial_inv[-1] = self.Pow(self.factorial[-1], -1)\n        for i in range(N - 1, -1, -1):\n            self.factorial_inv[i] = self.factorial_inv[i + 1] * (i + 1) % self.mod\n        return self.factorial_inv\n\n    def Fact(self, N):\n        return self.factorial[N]\n\n    def Fact_Inv(self, N):\n        return self.factorial_inv[N]\n\n    def Comb(self, N, K):\n        if K < 0 or K > N:\n            return 0\n        s = self.factorial[N]\n        s = s * self.factorial_inv[K] % self.mod\n        s = s * self.factorial_inv[N - K] % self.mod\n        return s\n\nclass Prime:\n\n    def __init__(self, N):\n        self.smallest_prime_factor = [None] * (N + 1)\n        for i in range(2, N + 1, 2):\n            self.smallest_prime_factor[i] = 2\n        n = int(N ** 0.5) + 1\n        for p in range(3, n, 2):\n            if self.smallest_prime_factor[p] == None:\n                self.smallest_prime_factor[p] = p\n                for i in range(p ** 2, N + 1, 2 * p):\n                    if self.smallest_prime_factor[i] == None:\n                        self.smallest_prime_factor[i] = p\n        for p in range(n, N + 1):\n            if self.smallest_prime_factor[p] == None:\n                self.smallest_prime_factor[p] = p\n        self.primes = [p for p in range(N + 1) if p == self.smallest_prime_factor[p]]\n\n    def Factorize(self, N):\n        assert N >= 1\n        factorize = defaultdict(int)\n        if N <= len(self.smallest_prime_factor) - 1:\n            while N != 1:\n                factorize[self.smallest_prime_factor[N]] += 1\n                N //= self.smallest_prime_factor[N]\n        else:\n            for p in self.primes:\n                while N % p == 0:\n                    N //= p\n                    factorize[p] += 1\n                if N < p * p:\n                    if N != 1:\n                        factorize[N] += 1\n                    break\n                if N <= len(self.smallest_prime_factor) - 1:\n                    while N != 1:\n                        factorize[self.smallest_prime_factor[N]] += 1\n                        N //= self.smallest_prime_factor[N]\n                    break\n            else:\n                if N != 1:\n                    factorize[N] += 1\n        return factorize\n\n    def Divisors(self, N):\n        assert N > 0\n        divisors = [1]\n        for (p, e) in self.Factorize(N).items():\n            A = [1]\n            for _ in range(e):\n                A.append(A[-1] * p)\n            divisors = [i * j for i in divisors for j in A]\n        return divisors\n\n    def Is_Prime(self, N):\n        return N == self.smallest_prime_factor[N]\n\n    def Totient(self, N):\n        for p in self.Factorize(N).keys():\n            N *= p - 1\n            N //= p\n        return N\n\nclass Lucas_Prime:\n\n    def __init__(self, P, e=1, divisible_count=False):\n        self.P = P\n        self.e = e\n        self.divisible_count = divisible_count\n        self.mod = self.P ** self.e\n        self.factorial = [1]\n        for i in range(1, self.mod):\n            self.factorial.append(self.factorial[-1])\n            if i % P:\n                self.factorial[i] *= i\n                self.factorial[i] %= self.mod\n\n    def Comb(self, N, K):\n        if K < 0 or K > N:\n            return 0\n        (K0, K1) = (K, N - K)\n        N_lst = []\n        N_ = N\n        while N_:\n            N_lst.append(N_ % self.mod)\n            N_ //= self.P\n        K0_lst = []\n        K0_ = K0\n        for _ in range(len(N_lst)):\n            K0_lst.append(K0_ % self.mod)\n            K0_ //= self.P\n        K1_lst = []\n        K1_ = K1\n        for _ in range(len(N_lst)):\n            K1_lst.append(K1_ % self.mod)\n            K1_ //= self.P\n        (retu, retu_rev) = (1, 1)\n        for n in N_lst:\n            retu *= self.factorial[n]\n            retu %= self.mod\n        for k0 in K0_lst:\n            retu_rev *= self.factorial[k0]\n            retu_rev %= self.mod\n        for k1 in K1_lst:\n            retu_rev *= self.factorial[k1]\n            retu_rev %= self.mod\n        retu *= MOD(self.mod).Pow(retu_rev, -1)\n        if self.P != 2 or self.e <= 2:\n            cnt = 0\n            N_ = N // self.mod\n            K0_ = K0 // self.mod\n            K1_ = K1 // self.mod\n            while N_:\n                cnt += N_\n                N_ //= self.P\n            while K0_:\n                cnt += K0_\n                K0_ //= self.P\n            while K1_:\n                cnt += K1_\n                K1_ //= self.P\n            if cnt % 2 == 1:\n                retu *= -1\n        retu %= self.mod\n        div_cnt = 0\n        (N_, K0_, K1_) = (N, K0, K1)\n        while N_:\n            div_cnt += N_\n            N_ //= self.P\n        while K0_:\n            div_cnt -= K0_\n            K0_ //= self.P\n        while K1_:\n            div_cnt -= K1_\n            K1_ //= self.P\n        if self.divisible_count:\n            return (retu, div_cnt)\n        else:\n            retu *= pow(self.P, div_cnt, self.mod)\n            retu %= self.mod\n            return retu\n\nclass Lucas:\n\n    def __init__(self, mod):\n        self.mod = mod\n        P = Prime(int(self.mod ** 0.5))\n        self.factorize = P.Factorize(mod)\n        self.L = {p: Lucas_Prime(p, e) for (p, e) in self.factorize.items()}\n\n    def Comb(self, N, K):\n        lst_r = []\n        lst_m = []\n        for (p, e) in self.factorize.items():\n            lst_r.append(self.L[p].Comb(N, K))\n            lst_m.append(p ** e)\n        (r, _) = CRT(lst_r, lst_m)\n        return r\n\ndef CRT(lst_r, lst_m):\n    (r, m) = (lst_r[0], lst_m[0])\n    for (r0, m0) in zip(lst_r[1:], lst_m[1:]):\n        if (r0, m0) == (-1, 0):\n            (r, m) = (-1, 0)\n            break\n        r0 %= m0\n        g = math.gcd(m, m0)\n        l = LCM(m, m0)\n        if r % g != r0 % g:\n            (r, m) = (-1, 0)\n            break\n        (r, m) = ((r0 + m0 * ((r - r0) // g * Extended_Euclid(m0 // g, m // g)[0] % (m // g))) % l, l)\n    return (r, m)\nT = int(readline())\nfor _ in range(T):\n    (N, K, M) = map(int, readline().split())\n    ans0 = (N + K - 1) // K\n    ans1 = Lucas(M).Comb(ans0 * K - N + ans0 - 1, ans0 - 1)\n    print(ans0, ans1)", "import bisect\nimport copy\nimport decimal\nimport fractions\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom functools import lru_cache, reduce\nfrom heapq import heappush, heappop, heapify, heappushpop, _heappop_max, _heapify_max\n\ndef _heappush_max(heap, item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap) - 1)\n\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        (item, heap[0]) = (heap[0], item)\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import gcd as GCD\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nclass Prime:\n\n    def __init__(self, N):\n        self.smallest_prime_factor = [None] * (N + 1)\n        for i in range(2, N + 1, 2):\n            self.smallest_prime_factor[i] = 2\n        n = int(N ** 0.5) + 1\n        for p in range(3, n, 2):\n            if self.smallest_prime_factor[p] == None:\n                self.smallest_prime_factor[p] = p\n                for i in range(p ** 2, N + 1, 2 * p):\n                    if self.smallest_prime_factor[i] == None:\n                        self.smallest_prime_factor[i] = p\n        for p in range(n, N + 1):\n            if self.smallest_prime_factor[p] == None:\n                self.smallest_prime_factor[p] = p\n        self.primes = [p for p in range(N + 1) if p == self.smallest_prime_factor[p]]\n\n    def Factorize(self, N):\n        assert N >= 1\n        factorize = defaultdict(int)\n        if N <= len(self.smallest_prime_factor) - 1:\n            while N != 1:\n                factorize[self.smallest_prime_factor[N]] += 1\n                N //= self.smallest_prime_factor[N]\n        else:\n            for p in self.primes:\n                while N % p == 0:\n                    N //= p\n                    factorize[p] += 1\n                if N < p * p:\n                    if N != 1:\n                        factorize[N] += 1\n                    break\n                if N <= len(self.smallest_prime_factor) - 1:\n                    while N != 1:\n                        factorize[self.smallest_prime_factor[N]] += 1\n                        N //= self.smallest_prime_factor[N]\n                    break\n            else:\n                if N != 1:\n                    factorize[N] += 1\n        return factorize\n\n    def Divisors(self, N):\n        assert N > 0\n        divisors = [1]\n        for (p, e) in self.Factorize(N).items():\n            A = [1]\n            for _ in range(e):\n                A.append(A[-1] * p)\n            divisors = [i * j for i in divisors for j in A]\n        return divisors\n\n    def Is_Prime(self, N):\n        return N == self.smallest_prime_factor[N]\n\n    def Totient(self, N):\n        for p in self.Factorize(N).keys():\n            N *= p - 1\n            N //= p\n        return N\n\ndef Extended_Euclid(n, m):\n    stack = []\n    while m:\n        stack.append((n, m))\n        (n, m) = (m, n % m)\n    if n >= 0:\n        (x, y) = (1, 0)\n    else:\n        (x, y) = (-1, 0)\n    for i in range(len(stack) - 1, -1, -1):\n        (n, m) = stack[i]\n        (x, y) = (y, x - n // m * y)\n    return (x, y)\n\nclass MOD:\n\n    def __init__(self, mod):\n        self.mod = mod\n\n    def Pow(self, a, n):\n        a %= self.mod\n        if n >= 0:\n            return pow(a, n, self.mod)\n        else:\n            assert math.gcd(a, self.mod) == 1\n            x = Extended_Euclid(a, self.mod)[0]\n            return pow(x, -n, self.mod)\n\n    def Build_Fact(self, N):\n        assert N >= 0\n        self.factorial = [1]\n        for i in range(1, N + 1):\n            self.factorial.append(self.factorial[-1] * i % self.mod)\n        self.factorial_inv = [None] * (N + 1)\n        self.factorial_inv[-1] = self.Pow(self.factorial[-1], -1)\n        for i in range(N - 1, -1, -1):\n            self.factorial_inv[i] = self.factorial_inv[i + 1] * (i + 1) % self.mod\n        return self.factorial_inv\n\n    def Fact(self, N):\n        return self.factorial[N]\n\n    def Fact_Inv(self, N):\n        return self.factorial_inv[N]\n\n    def Comb(self, N, K):\n        if K < 0 or K > N:\n            return 0\n        s = self.factorial[N]\n        s = s * self.factorial_inv[K] % self.mod\n        s = s * self.factorial_inv[N - K] % self.mod\n        return s\n\ndef LCM(n, m):\n    if n or m:\n        return abs(n) * abs(m) // math.gcd(n, m)\n    return 0\n\ndef CRT(lst_r, lst_m):\n    (r, m) = (lst_r[0], lst_m[0])\n    for (r0, m0) in zip(lst_r[1:], lst_m[1:]):\n        if (r0, m0) == (-1, 0):\n            (r, m) = (-1, 0)\n            break\n        r0 %= m0\n        g = math.gcd(m, m0)\n        l = LCM(m, m0)\n        if r % g != r0 % g:\n            (r, m) = (-1, 0)\n            break\n        (r, m) = ((r0 + m0 * ((r - r0) // g * Extended_Euclid(m0 // g, m // g)[0] % (m // g))) % l, l)\n    return (r, m)\n\ndef Lucas(N, K, P, e=1, divisible_count=False):\n    mod = P ** e\n    if K < 0 or K > N:\n        return 0\n    (K0, K1) = (K, N - K)\n    N_lst = []\n    N_ = N\n    while N_:\n        N_lst.append(N_ % mod)\n        N_ //= P\n    K0_lst = []\n    K0_ = K0\n    for _ in range(len(N_lst)):\n        K0_lst.append(K0_ % mod)\n        K0_ //= P\n    K1_lst = []\n    K1_ = K1\n    for _ in range(len(N_lst)):\n        K1_lst.append(K1_ % mod)\n        K1_ //= P\n    factorial = [1]\n    for i in range(1, mod):\n        factorial.append(factorial[-1])\n        if i % P:\n            factorial[i] *= i\n            factorial[i] %= mod\n    (retu, retu_rev) = (1, 1)\n    for n in N_lst:\n        retu *= factorial[n]\n        retu %= mod\n    for k0 in K0_lst:\n        retu_rev *= factorial[k0]\n        retu_rev %= mod\n    for k1 in K1_lst:\n        retu_rev *= factorial[k1]\n        retu_rev %= mod\n    retu *= MOD(mod).Pow(retu_rev, -1)\n    if P != 2 or e <= 2:\n        cnt = 0\n        N_ = N // mod\n        K0_ = K0 // mod\n        K1_ = K1 // mod\n        while N_:\n            cnt += N_\n            N_ //= P\n        while K0_:\n            cnt += K0_\n            K0_ //= P\n        while K1_:\n            cnt += K1_\n            K1_ //= P\n        if cnt % 2 == 1:\n            retu *= -1\n    retu %= mod\n    div_cnt = 0\n    (N_, K0_, K1_) = (N, K0, K1)\n    while N_:\n        div_cnt += N_\n        N_ //= P\n    while K0_:\n        div_cnt -= K0_\n        K0_ //= P\n    while K1_:\n        div_cnt -= K1_\n        K1_ //= P\n    if divisible_count:\n        return (retu, div_cnt)\n    else:\n        retu *= pow(P, div_cnt, mod)\n        retu %= mod\n        return retu\n\ndef Comb_Lucas(N, K, mod):\n    P = Prime(int(mod ** 0.5))\n    factorize = P.Factorize(mod)\n    lst_r = []\n    lst_m = []\n    for (p, e) in factorize.items():\n        lst_r.append(Lucas(N, K, p, e))\n        lst_m.append(p ** e)\n    (r, _) = CRT(lst_r, lst_m)\n    return r\nT = int(readline())\nfor _ in range(T):\n    (N, K, M) = map(int, readline().split())\n    ans0 = (N + K - 1) // K\n    ans1 = Comb_Lucas(ans0 * K - N + ans0 - 1, ans0 - 1, M)\n    print(ans0, ans1)", "globalFacts = dict()\n\ndef compute(n, m, big):\n    y = decompose(big)\n    remainders = []\n    for powerPrime in y:\n        remainders.append(binomialModulo(n, m, powerPrime[0], powerPrime[1]))\n    sol = chaineseRemainderTheorem([pow(i[0], i[1]) for i in y], remainders)\n    return sol\n\ndef chaineseRemainderTheorem(num, rem):\n    prod = 1\n    for i in num:\n        prod *= i\n    resultch = 0\n    for i in range(len(num)):\n        pp = prod // num[i]\n        resultch += rem[i] * inverse(pp, num[i]) * pp\n    return resultch % prod\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef inverse(a, m):\n    (g, x, y) = egcd(a, m)\n    return x % m\n\ndef binomialModulo(n, m, prime, powerPrime):\n    power = int(pow(prime, powerPrime))\n    (nArray, mArray, rArray, NArray, MArray, RArray, e0, eq) = allAtOnce(n, m, prime, powerPrime)\n    resultb = 1\n    denominator = 1\n    resultb = pow(-1, eq) * pow(prime, e0) % power\n    if resultb == 0:\n        return 0\n    for i in range(len(nArray)):\n        resultb *= fact(NArray[i], prime, powerPrime)\n        denominator *= fact(MArray[i], prime, powerPrime) * fact(RArray[i], prime, powerPrime)\n        resultb = resultb % power\n        denominator = denominator % power\n    resultb *= inverse(denominator % power, power)\n    return resultb % power\n\ndef fact(k, prime, powerPrime):\n    power = pow(prime, powerPrime)\n    if (k, power) in globalFacts:\n        return globalFacts[k, power]\n    factorial = 1\n    for i in range(1, k + 1):\n        if i % prime != 0:\n            factorial = factorial * i % power\n    globalFacts[k, power] = factorial\n    return factorial\n\ndef allAtOnce(n, m, prime, powerPrime):\n    nArray = []\n    mArray = []\n    rArray = []\n    NArray = []\n    MArray = []\n    RArray = []\n    r = n - m\n    e0 = 0\n    eq = 0\n    j = 0\n    power = int(pow(prime, powerPrime))\n    while n > 0:\n        nArray.append(n % prime)\n        mArray.append(m % prime)\n        rArray.append(r % prime)\n        NArray.append(n % power)\n        MArray.append(m % power)\n        RArray.append(r % power)\n        n = n // prime\n        r = r // prime\n        m = m // prime\n        j = j + 1\n        if n != m + r:\n            e0 = e0 + 1\n            if j >= powerPrime:\n                eq = eq + 1\n    return (nArray, mArray, rArray, NArray, MArray, RArray, e0, eq)\n\ndef decompose(big):\n    elements = []\n    counter = 2\n    numele = 0\n    while big > 1:\n        if big % counter == 0:\n            exponente = 0\n            while big % counter == 0:\n                big = big // counter\n                exponente = exponente + 1\n            elements.append([])\n            elements[numele].append(counter)\n            elements[numele].append(exponente)\n            numele = numele + 1\n        counter += 1\n    return elements\nt = int(input().strip())\nfor ii in range(t):\n    cadena = input()\n    arr = [int(s) for s in cadena.split()]\n    nn = arr[0]\n    kk = arr[1]\n    mm = arr[2]\n    c = (nn + kk - 1) // kk\n    L = c * kk - nn + c - 1\n    result = compute(L, c - 1, mm)\n    print(c, result)", "import math\nfrom functools import reduce\nfrom collections import Counter\nimport math\nfrom functools import reduce\nfrom collections import Counter\n\ndef det(n, p):\n    (ret, n) = (0, n // p)\n    while n:\n        (ret, n) = (ret + n, n // p)\n    return ret\n\ndef binomial(a, b, X):\n    pri = X[0]\n    ex = X[1]\n    rem = pri ** ex\n    expp = det(a, pri) - det(b, pri) - det(a - b, pri)\n    inverse = rem - rem // pri - 1\n    if expp >= ex:\n        return 0\n    else:\n        ttteeemmmppp = 1\n        for i in range(1, rem + 1):\n            if i % pri != 0:\n                ttteeemmmppp *= i\n                ttteeemmmppp %= rem\n                rfact[i] = ttteeemmmppp\n            else:\n                rfact[i] = ttteeemmmppp\n\n        def f(t):\n            if t == 0:\n                return 1\n            teem = pow(rfact[rem], t // rem, rem)\n            ans = 0\n            if t % rem == 0:\n                ans = teem\n            else:\n                ans = teem * rfact[t % rem]\n                ans %= rem\n            return ans\n\n        def F(t):\n            eeee = t\n            count = 0\n            while eeee // pri > 0:\n                eeee = eeee // pri\n                count += 1\n            temm = 1\n            for i in range(0, count + 1):\n                temm *= f(t // pri ** i)\n                temm %= rem\n            return temm\n        Ans = pow(pri, expp) * F(a)\n        Ans %= rem\n        temp22 = F(b) * F(a - b) % rem\n        temp22 = pow(temp22, inverse, rem)\n        Ans = Ans * temp22\n        Ans %= rem\n        return Ans\nTest = int(input())\ntotal = []\nMAX = 0\nfor _ in range(Test):\n    (N, K, M) = list(map(int, input().strip().split(' ')))\n    total += [[N, K, M]]\n    if M > MAX:\n        MAX = M\nprime = [-1 for i in range(MAX + 1)]\nfor i in range(2, MAX + 1):\n    if prime[i] == -1:\n        temp = MAX // i\n        for j in range(2, temp + 1):\n            prime[j * i] = 1\nprimeset = []\nfor i in range(2, MAX + 1):\n    if prime[i] == -1:\n        primeset += [i]\n\ndef Chinese(n, a):\n    s = 0\n    prod = reduce(lambda a, b: a * b, n)\n    for (n_i, a_i) in zip(n, a):\n        p = prod // n_i\n        s += a_i * mul(p, n_i) * p\n    return s % prod\n\ndef factor(A):\n    if A == 1:\n        return []\n    else:\n        Temp = []\n        check = 0\n        while 1:\n            if A == 1:\n                break\n            i = check\n            while i < len(primeset):\n                if A % primeset[i] == 0:\n                    check = i\n                    A = A // primeset[i]\n                    Temp += [primeset[i]]\n                    i += 1\n                    break\n                else:\n                    i += 1\n        AB = Counter(Temp)\n        D = []\n        for x in AB:\n            D += [[x, AB[x]]]\n        return D\n\ndef mul(c, d):\n    b0 = d\n    (x0, x1) = (0, 1)\n    if d == 1:\n        return 1\n    while c > 1:\n        q = c // d\n        (c, d) = (d, c % d)\n        (x0, x1) = (x1 - q * x0, x0)\n    if x1 < 0:\n        x1 += b0\n    return x1\nfor i in range(len(total)):\n    (N, K, M) = total[i]\n    factors = factor(M)\n    Chin = []\n    for ii in range(len(factors)):\n        Chin += [factors[ii][0] ** factors[ii][1]]\n    if N % K == 0:\n        print(N // K, 1)\n    else:\n        r = N // K + 1\n        T = K - N % K\n        upp = r + T - 1\n        data = []\n        for i in range(len(factors)):\n            (A, B) = factors[i]\n            CC = A ** B\n            rfact = [1] * (CC + 1)\n            data += [binomial(upp, T, [A, B])]\n        if len(factors) == 1:\n            China = data[0]\n        else:\n            China = Chinese(Chin, data)\n        print(r, China)", "from functools import *\nimport math\nimport operator\n\ndef len_in_bits(n):\n    try:\n        return n.bit_length()\n    except AttributeError:\n        if n == 0:\n            return 0\n        return len(bin(n)) - 2\n\ndef randint_bits(size):\n    low = 1 << size - 1\n    hi = (1 << size) - 1\n    return random.randint(low, hi)\n\ndef ceil(x, y):\n    return x / y + (x % y != 0)\n\ndef nroot(x, n):\n    if n < 0:\n        raise ValueError(\"can't extract negative root\")\n    if n == 0:\n        raise ValueError(\"can't extract zero root\")\n    sign = 1\n    if x < 0:\n        sign = -1\n        x = -x\n        if n % 2 == 0:\n            raise ValueError(\"can't extract even root of negative\")\n    high = 1\n    while high ** n <= x:\n        high <<= 1\n    low = high >> 1\n    while low < high:\n        mid = low + high >> 1\n        if low < mid and mid ** n < x:\n            low = mid\n        elif high > mid and mid ** n > x:\n            high = mid\n        else:\n            return sign * mid\n    return sign * (mid + 1)\n\ndef _gcd(a, b):\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    while b:\n        (a, b) = (b, a % b)\n    return abs(a)\n\ndef _lcm(a, b):\n    if not a or not b:\n        raise ZeroDivisionError('lcm arguments may not be zeros')\n    return abs(a * b) // _gcd(a, b)\n\ndef gcd(*lst):\n    return abs(reduce(lambda a, b: _gcd(a, b), lst))\n\ndef lcm(*lst):\n    return reduce(lambda a, b: _lcm(a, b), lst)\n\ndef xgcd(a, b):\n    if a == 0:\n        return (0, 1, b)\n    if b == 0:\n        return (1, 0, a)\n    (px, ppx) = (0, 1)\n    (py, ppy) = (1, 0)\n    while b:\n        q = a // b\n        (a, b) = (b, a % b)\n        x = ppx - q * px\n        y = ppy - q * py\n        (ppx, px) = (px, x)\n        (ppy, py) = (py, y)\n    return (ppx, ppy, a)\n\ndef extract_prime_power(a, p):\n    s = 0\n    if p > 2:\n        while a and a % p == 0:\n            s += 1\n            a //= p\n    elif p == 2:\n        while a and a & 1 == 0:\n            s += 1\n            a >>= 1\n    else:\n        raise ValueError('Number %d is not a prime (is smaller than 2)' % p)\n    return (s, a)\n\ndef solve_linear(a, b, c):\n    return None\n\ndef grey_code(n):\n    return n ^ n >> 1\n\ndef rev_grey_code(g):\n    n = 0\n    while g:\n        n ^= g\n        g >>= 1\n    return n\n\ndef factorial(n):\n    res = 1\n    while n > 1:\n        res *= n\n        n -= 1\n    return res\n\ndef factorial_get_prime_pow(n, p):\n    count = 0\n    ppow = p\n    while ppow <= n:\n        count += n // ppow\n        ppow *= p\n    return count\n\ndef nCk(n, k):\n    if n < 0:\n        raise ValueError('Invalid value for n: %s' % n)\n    if k < 0 or k > n:\n        return 0\n    if k in (0, n):\n        return 1\n    if k in (1, n - 1):\n        return n\n    low_min = 1\n    low_max = min(n, k)\n    high_min = max(1, n - k + 1)\n    high_max = n\n    return reduce(operator.mul, range(high_min, high_max + 1), 1) / reduce(operator.mul, range(low_min, low_max + 1), 1)\n\ndef has_invmod(a, modulus):\n    if modulus < 2:\n        raise ValueError('modulus must be greater than 1')\n    if a == 0 or gcd(a, modulus) != 1:\n        return False\n    else:\n        return True\n\ndef invmod(a, n):\n    if n < 2:\n        raise ValueError('modulus must be greater than 1')\n    (x, y, g) = xgcd(a, n)\n    if g != 1:\n        raise ValueError('no invmod for given @a and @n')\n    else:\n        return x % n\n\ndef solve_crt(remainders, modules):\n    if len(modules) != len(remainders):\n        raise TypeError('modules and remainders lists must have same len')\n    if len(modules) == 0:\n        raise ValueError('Empty lists are given')\n    if len(modules) == 1:\n        return remainders[0]\n    x = 0\n    N = reduce(operator.mul, modules)\n    for (i, module) in enumerate(modules):\n        if module == 1:\n            continue\n        Ni = N // module\n        b = invmod(Ni, module)\n        x += remainders[i] * Ni * b\n    return x % N\n\ndef nCk_mod(n, k, factors):\n    rems = []\n    mods = []\n    for (p, e) in factors.items():\n        rems.append(nCk_mod_prime_power(n, k, p, e))\n        mods.append(p ** e)\n    return solve_crt(rems, mods)\n\ndef factorial_mod(n, factors):\n    rems = []\n    mods = []\n    for (p, e) in factors.items():\n        pe = p ** e\n        if n >= pe or factorial_get_prime_pow(n, p) >= e:\n            factmod = 0\n        else:\n            factmod = factorial(n) % pe\n        rems.append(factmod)\n        mods.append(pe)\n    return solve_crt(rems, mods)\n\ndef nCk_mod_prime_power(n, k, p, e):\n\n    def nCk_get_prime_pow(n, k, p):\n        res = factorial_get_prime_pow(n, p)\n        res -= factorial_get_prime_pow(k, p)\n        res -= factorial_get_prime_pow(n - k, p)\n        return res\n\n    def nCk_get_non_prime_part(n, k, p, e):\n        pe = p ** e\n        r = n - k\n        fact_pe = [1]\n        acc = 1\n        for x in range(1, pe):\n            if x % p == 0:\n                x = 1\n            acc = acc * x % pe\n            fact_pe.append(acc)\n        top = bottom = 1\n        is_negative = 0\n        digits = 0\n        while n != 0:\n            if acc != 1:\n                if digits >= e:\n                    is_negative ^= n & 1\n                    is_negative ^= r & 1\n                    is_negative ^= k & 1\n            top = top * fact_pe[n % pe] % pe\n            bottom = bottom * fact_pe[r % pe] % pe\n            bottom = bottom * fact_pe[k % pe] % pe\n            n //= p\n            r //= p\n            k //= p\n            digits += 1\n        res = top * invmod(bottom, pe) % pe\n        if p != 2 or e < 3:\n            if is_negative:\n                res = pe - res\n        return res\n    prime_part_pow = nCk_get_prime_pow(n, k, p)\n    if prime_part_pow >= e:\n        return 0\n    modpow = e - prime_part_pow\n    r = nCk_get_non_prime_part(n, k, p, modpow) % p ** modpow\n    return p ** prime_part_pow * r % p ** e\nsieve = [0 for x in range(1000010)]\nfor i in range(2, 1000001):\n    if sieve[i] == 0:\n        sieve[i] = i\n        for j in range(i * i, 1000001, i):\n            sieve[j] = i\nprimes = [x for x in range(2, 1000001) if sieve[x] == 1]\nt = int(input())\nfor i in range(t):\n    (n, k, m) = list(map(int, input().split()))\n    tmpm = int(m)\n    facs = {}\n    while tmpm > 1:\n        x = sieve[tmpm]\n        c = 0\n        while tmpm % x == 0:\n            c += 1\n            tmpm //= x\n        facs[x] = c\n    p = n // k\n    rem = n % k\n    tmp = p\n    ans = 1\n    if rem == 0:\n        ans = 1\n    else:\n        ans = (ans + nCk_mod(p + (k - rem) % k, p, facs) - 1) % m\n    print(p + int(rem > 0), ans)", "import sys\n\ndef factorise(m):\n    ans = []\n    p = 2\n    while m != 1:\n        if m % p != 0:\n            p += 1\n            continue\n        e = 0\n        while m % p == 0:\n            m //= p\n            e += 1\n        ans.append([p, e])\n        p += 1\n    return ans\n\ndef mulmod(a, b, c):\n    res = a * b\n    if res >= c:\n        res %= c\n    return res\n\ndef mod_inverse(a, n):\n    N = n\n    xx = 0\n    yy = 1\n    y = 0\n    x = 1\n    while n > 0:\n        q = a // n\n        t = n\n        n = a % n\n        a = t\n        t = xx\n        xx = x - q * xx\n        x = t\n        t = yy\n        yy = y - q * yy\n        y = t\n    x %= N\n    x += N\n    x %= N\n    return x\n\ndef expo(a, b):\n    x = 1\n    y = a\n    while b > 0:\n        if b & 1:\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\n\ndef power(a, b, c):\n    x = 1\n    y = a\n    while b > 0:\n        if b & 1:\n            x = mulmod(x, y, c)\n        y = mulmod(y, y, c)\n        b >>= 1\n    return x\n\ndef init(p, pk):\n    fact = []\n    fact.append(1)\n    for i in range(1, pk):\n        red = i\n        if red % p == 0:\n            red = 1\n        fact.append(mulmod(fact[i - 1], red, pk))\n    return fact\n\ndef fact_mod(n, p, pk, fact):\n    res = 1\n    while n > 0:\n        times = n // pk\n        res = mulmod(res, power(fact[pk - 1], times, pk), pk)\n        res = mulmod(res, fact[n % pk], pk)\n        n //= p\n    return res\n\ndef count_fact(n, p):\n    ans = 0\n    while n > 0:\n        ans += n // p\n        n //= p\n    return ans\n\ndef ncr(n, r, p, e):\n    if r > n or r < 0:\n        return 0\n    if r == 0 or n == r:\n        return 1\n    _e = count_fact(n, p) - count_fact(r, p) - count_fact(n - r, p)\n    assert _e >= 0\n    if _e >= e:\n        return 0\n    pk = expo(p, e)\n    fact = init(p, pk)\n    ans = fact_mod(n, p, pk, fact)\n    ans = mulmod(ans, mod_inverse(fact_mod(r, p, pk, fact), pk), pk)\n    ans = mulmod(ans, mod_inverse(fact_mod(n - r, p, pk, fact), pk), pk)\n    ans = mulmod(ans, expo(p, _e), pk)\n    return ans\n\ndef pre_process(rem, mods):\n    crt = []\n    a = 1\n    b = 1\n    m = mods[0]\n    crt.append([mods[0], a, b])\n    L = len(mods)\n    for i in range(1, L):\n        a = mod_inverse(m, mods[i])\n        b = mod_inverse(mods[i], m)\n        crt.append([m, a, b])\n        m *= mods[i]\n    assert len(crt) == len(mods)\n    return crt\n\ndef find_crt(crt):\n    assert len(crt) == len(mods)\n    ans = rem[0]\n    m = crt[0][0]\n    L = len(mods)\n    for i in range(1, L):\n        a = crt[i][1]\n        b = crt[i][2]\n        m = crt[i][0]\n        _m = m * mods[i]\n        ans = mulmod(ans, b * mods[i], _m)\n        ans = (ans + mulmod(rem[i], a * m, _m)) % _m\n    return ans\ninpos = sys.stdin\nt = int(inpos.readline())\nfor _ in range(t):\n    [n, k, m] = list(map(int, inpos.readline().split()))\n    ans = (n + k - 1) // k\n    ans2 = 1\n    if n % k != 0:\n        pf = factorise(m)\n        rem = []\n        mods = []\n        b = k - n % k\n        a = n // k + b\n        L = len(pf)\n        for i in range(L):\n            get = ncr(a, b, pf[i][0], pf[i][1])\n            rem.append(get)\n            mods.append(expo(pf[i][0], pf[i][1]))\n        crt = pre_process(rem, mods)\n        ans2 = find_crt(crt)\n    ans2 %= m\n    assert 0 <= ans2 and ans2 < m\n    print(ans, ans2)", "LIM = 10 ** 6 + 5\n\ndef sieve():\n    global primes, is_prime\n    is_prime = [True] * LIM\n    is_prime[0] = is_prime[1] = False\n    i = 2\n    while i * i <= LIM:\n        if is_prime[i]:\n            for j in range(i * i, LIM, i):\n                is_prime[j] = False\n        i += 1\n    primes = [i for i in range(LIM) if is_prime[i]]\nsieve()\n\ndef mod_inverse(n, m):\n    t = 0\n    newt = 1\n    r = m\n    newr = n\n    while newr:\n        q = r // newr\n        (t, newt) = (newt, t - q * newt)\n        (r, newr) = (newr, r - q * newr)\n    if r > 1:\n        return None\n    if t < 0:\n        t += m\n    return t\n\ndef prime_factorize(n):\n    fac = []\n    for p in primes:\n        if p * p > n:\n            break\n        q = 0\n        while n % p == 0:\n            q += 1\n            n //= p\n        if q > 0:\n            fac.append((p, q))\n    if n > 1:\n        fac.append((n, 1))\n    return fac\n\ndef chinese_rt(divs, rems):\n    prod = 1\n    for d in divs:\n        prod *= d\n    res = 0\n    for i in range(len(divs)):\n        d_rmvd_prod = prod // divs[i]\n        res += rems[i] * d_rmvd_prod * mod_inverse(d_rmvd_prod, divs[i])\n        res %= prod\n    return res\n\ndef n_choose_k_mod_p_pow_q(n, k, p, q):\n    pq = p ** q\n    p_rmvd_fact = [1]\n    for i in range(1, pq):\n        p_rmvd_fact.append(p_rmvd_fact[-1])\n        if i % p > 0:\n            p_rmvd_fact[-1] *= i\n            p_rmvd_fact[-1] %= pq\n    r = n - k\n    num = den = 1\n    e0 = eq = dig = 0\n    sum_ = carry = 0\n    while n:\n        num *= p_rmvd_fact[n % pq]\n        den *= p_rmvd_fact[k % pq] * p_rmvd_fact[r % pq]\n        num %= pq\n        den %= pq\n        sum_ = k % p + r % p + carry\n        carry = sum_ // p\n        if carry > 0:\n            e0 += 1\n            if dig >= q:\n                eq += 1\n        n //= p\n        k //= p\n        r //= p\n        dig += 1\n    res = p ** e0 * num * mod_inverse(den, pq) % pq\n    if p != 2 or q < 3:\n        if eq % 2 == 1:\n            res = pq - res\n    return res\n\ndef n_choose_k_mod_m(n, k, m):\n    m_fac = prime_factorize(m)\n    (divs, rems) = ([], [])\n    for (p, q) in m_fac:\n        r = n_choose_k_mod_p_pow_q(n, k, p, q)\n        divs.append(p ** q)\n        rems.append(r)\n    res = chinese_rt(divs, rems)\n    return res\nfor t in range(int(input())):\n    (N, K, M) = map(int, input().split())\n    K = min(K, N)\n    pieces = N // K + (1 if N % K else 0)\n    extra = pieces * K - N\n    n = extra + pieces - 1\n    k = pieces - 1\n    ans = n_choose_k_mod_m(n, k, M)\n    print(pieces, ans)", "LIM = 10 ** 6 + 5\n\ndef sieve():\n    global primes, is_prime\n    is_prime = [True] * LIM\n    is_prime[0] = is_prime[1] = False\n    i = 2\n    while i * i <= LIM:\n        if is_prime[i]:\n            for j in range(i * i, LIM, i):\n                is_prime[j] = False\n        i += 1\n    primes = [i for i in range(LIM) if is_prime[i]]\nsieve()\n\ndef mod_inverse(n, m):\n    t = 0\n    newt = 1\n    r = m\n    newr = n\n    while newr:\n        q = r // newr\n        (t, newt) = (newt, t - q * newt)\n        (r, newr) = (newr, r - q * newr)\n    if r > 1:\n        return None\n    if t < 0:\n        t += m\n    return t\n\ndef prime_factorize(n):\n    fac = []\n    for p in primes:\n        if p * p > n:\n            break\n        q = 0\n        while n % p == 0:\n            q += 1\n            n //= p\n        if q > 0:\n            fac.append((p, q))\n    if n > 1:\n        fac.append((n, 1))\n    return fac\n\ndef chinese_rt(divs, rems):\n    prod = 1\n    for d in divs:\n        prod *= d\n    res = 0\n    for i in range(len(divs)):\n        d_rmvd_prod = prod // divs[i]\n        res += rems[i] * d_rmvd_prod * mod_inverse(d_rmvd_prod, divs[i])\n        res %= prod\n    return res\n\ndef n_choose_k_mod_p_pow_q(n, k, p, q):\n    pq = p ** q\n    p_rmvd_fact = [1]\n    for i in range(1, pq):\n        p_rmvd_fact.append(p_rmvd_fact[-1])\n        if i % p > 0:\n            p_rmvd_fact[-1] *= i\n            p_rmvd_fact[-1] %= pq\n    r = n - k\n    num = den = 1\n    e0 = eq = dig = 0\n    sum_ = carry = 0\n    while n:\n        num *= p_rmvd_fact[n % pq]\n        den *= p_rmvd_fact[k % pq] * p_rmvd_fact[r % pq]\n        num %= pq\n        den %= pq\n        sum_ = k % p + r % p + carry\n        carry = sum_ // p\n        if carry > 0:\n            e0 += 1\n            if dig >= q:\n                eq += 1\n        n //= p\n        k //= p\n        r //= p\n        dig += 1\n    res = p ** e0 * num * mod_inverse(den, pq) % pq\n    if p != 2 or q < 3:\n        if eq % 2 == 1:\n            res = pq - res\n    return res\n\ndef n_choose_k_mod_m(n, k, m):\n    m_fac = prime_factorize(m)\n    (divs, rems) = ([], [])\n    for (p, q) in m_fac:\n        r = n_choose_k_mod_p_pow_q(n, k, p, q)\n        divs.append(p ** q)\n        rems.append(r)\n    res = chinese_rt(divs, rems)\n    return res\nfor t in range(int(input())):\n    (N, K, M) = map(int, input().split())\n    K = min(K, N)\n    pieces = N // K + (1 if N % K else 0)\n    extra = pieces * K - N\n    n = extra + pieces - 1\n    k = pieces - 1\n    ans = n_choose_k_mod_m(n, k, M)\n    print(pieces, ans)", "from collections import defaultdict\nPMAX = 10 ** 5\nbprimes = [True] * PMAX\nprimes = []\nfor i in range(2, 1000):\n    if bprimes[i]:\n        t = i * i\n        while t < PMAX:\n            bprimes[t] = False\n            t += i\nfor i in range(2, PMAX):\n    if bprimes[i]:\n        primes.append(i)\n\ndef factor_small(n):\n    fdict = defaultdict(int)\n    for p in primes:\n        if n <= 1:\n            break\n        if p * p > n:\n            fdict[n] += 1\n            break\n        while n % p == 0:\n            fdict[p] += 1\n            n //= p\n    return fdict\n\ndef inv(n, m):\n    (nn, nm, mn, mm) = (1, 0, 0, 1)\n    while m:\n        (div, mod) = divmod(n, m)\n        nn -= mn * div\n        nm -= mm * div\n        n = mod\n        (n, m) = (m, n)\n        (nn, nm, mn, mm) = (mn, mm, nn, nm)\n    return nn\n\ndef co_mod(mod_remains):\n    prod_all = 1\n    for mod in mod_remains:\n        prod_all *= mod\n    res = 0\n    for (mod, remain) in mod_remains.items():\n        prod_others = prod_all // mod\n        res += remain * prod_others * inv(prod_others, mod)\n        res %= prod_all\n    res = (res + prod_all) % prod_all\n    return res\n\ndef comb_ppm(n, m, prime, power):\n    ppm = prime ** power\n    facts = [1, 1]\n    for f in range(2, ppm):\n        if f % prime == 0:\n            facts.append(facts[-1])\n        else:\n            facts.append(facts[-1] * f % ppm)\n    r = n - m\n    pos = 0\n    carry = 0\n    carryq1 = 0\n    (tn, tm, tr) = (n, m, r)\n    while tn > 0 or tm > 0:\n        nm = tn % prime\n        mm = tm % prime\n        rm = tr % prime\n        if nm < mm or nm < rm:\n            carry += 1\n            if pos >= power - 1:\n                carryq1 += 1\n        tn //= prime\n        tm //= prime\n        tr //= prime\n        pos += 1\n    res = 1\n    (tn, tm, tr) = (n, m, r)\n    while tn > 0 or tm > 0 or tr > 0:\n        nm = tn % ppm\n        mm = tm % ppm\n        rm = tr % ppm\n        res *= facts[nm]\n        res *= inv(facts[mm], ppm)\n        res *= inv(facts[rm], ppm)\n        res %= ppm\n        res = (res + ppm) % ppm\n        tn //= prime\n        tm //= prime\n        tr //= prime\n    res *= prime ** carry\n    res %= ppm\n    if carryq1 % 2 == 1 and (prime != 2 or power < 3):\n        res = (ppm - res) % ppm\n    return res\n\ndef comb(n, r, m):\n    comb_by_ppms = {}\n    for (prime, count) in factor_small(m).items():\n        comb_by_ppms[prime ** count] = comb_ppm(n, r, prime, count)\n    return co_mod(comb_by_ppms)\nT = int(input())\nfor _ in range(T):\n    (N, K, M) = map(int, input().split())\n    scount = (N + K - 1) // K\n    if N % K == 0:\n        kind = 1\n    else:\n        kind = comb(N // K + K - N % K, N // K, M)\n    print(scount, kind)"]