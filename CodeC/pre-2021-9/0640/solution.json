["for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    ans = [0] * n\n    for i in range(n):\n        m = int(input())\n        po = [int(i) for i in input().split()][::2]\n        arr.append([i, max(po)])\n    arr.sort(key=lambda x: x[1])\n    for x in range(n):\n        ans[arr[x][0]] = x\n    print(*ans)", "for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    ans = [0] * n\n    for i in range(n):\n        m = int(input())\n        po = [int(i) for i in input().split()][::2]\n        arr.append([i, max(po)])\n    arr.sort(key=lambda x: x[1])\n    for x in range(n):\n        ans[arr[x][0]] = x\n    print(*ans)", "for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    ans = [0] * n\n    for i in range(n):\n        m = int(input())\n        po = [int(i) for i in input().split()][::2]\n        arr.append([i, max(po)])\n    arr.sort(key=lambda x: x[1])\n    for x in range(n):\n        ans[arr[x][0]] = x\n    print(*ans)", "def run():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        polygons = []\n        for i in range(N):\n            M = int(input())\n            polygon = list(map(int, input().split()))\n            polygons.append(polygon)\n        print(f(polygons))\n\ndef f(polygons):\n    highest = []\n    for (i, polygon) in enumerate(polygons):\n        hi = float('-inf')\n        for x in range(0, len(polygon), 2):\n            (px, py) = (polygon[x], polygon[x + 1])\n            hi = max(hi, py)\n        highest.append((i, hi))\n    highest = sorted(highest, key=lambda x: x[1])\n    ans = [0] * len(polygons)\n    for (n, (i, hi)) in enumerate(highest):\n        ans[i] = str(n)\n    return ' '.join(ans)\nrun()", "def run():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        polygons = []\n        for i in range(N):\n            M = int(input())\n            polygon = list(map(int, input().split()))\n            polygons.append(polygon)\n        print(f(polygons))\n\ndef f(polygons):\n    highest = []\n    for (i, polygon) in enumerate(polygons):\n        hi = float('-inf')\n        for x in range(0, len(polygon), 2):\n            (px, py) = (polygon[x], polygon[x + 1])\n            hi = max(hi, py)\n        highest.append((i, hi))\n    highest = sorted(highest, key=lambda x: x[1])\n    ans = [0] * len(polygons)\n    for (n, (i, hi)) in enumerate(highest):\n        ans[i] = str(n)\n    return ' '.join(ans)\nrun()", "def run():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        polygons = []\n        for i in range(N):\n            M = int(input())\n            polygon = list(map(int, input().split()))\n            polygons.append(polygon)\n        print(f(polygons))\n\ndef f(polygons):\n    highest = []\n    for (i, polygon) in enumerate(polygons):\n        hi = float('-inf')\n        for x in range(0, len(polygon), 2):\n            (px, py) = (polygon[x], polygon[x + 1])\n            hi = max(hi, py)\n        highest.append((i, hi))\n    highest = sorted(highest, key=lambda x: x[1])\n    ans = [0] * len(polygons)\n    for (n, (i, hi)) in enumerate(highest):\n        ans[i] = str(n)\n    return ' '.join(ans)\nrun()", "def run():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        polygons = []\n        for i in range(N):\n            M = int(input())\n            polygon = list(map(int, input().split()))\n            polygons.append(polygon)\n        print(f(polygons))\n\ndef f(polygons):\n    highest = []\n    for (i, polygon) in enumerate(polygons):\n        hi = float('-inf')\n        for x in range(0, len(polygon), 2):\n            (px, py) = (polygon[x], polygon[x + 1])\n            hi = max(hi, py)\n        highest.append((i, hi))\n    highest = sorted(highest, key=lambda x: x[1])\n    ans = [0] * len(polygons)\n    for (n, (i, hi)) in enumerate(highest):\n        ans[i] = str(n)\n    return ' '.join(ans)\nrun()", "def run():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        polygons = []\n        for i in range(N):\n            M = int(input())\n            polygon = list(map(int, input().split()))\n            polygons.append(polygon)\n        print(f(polygons))\n\ndef f(polygons):\n    highest = []\n    for (i, polygon) in enumerate(polygons):\n        hi = float('-inf')\n        for x in range(0, len(polygon), 2):\n            (px, py) = (polygon[x], polygon[x + 1])\n            hi = max(hi, py)\n        highest.append((i, hi))\n    highest = sorted(highest, key=lambda x: x[1])\n    ans = [0] * len(polygons)\n    for (n, (i, hi)) in enumerate(highest):\n        ans[i] = str(n)\n    return ' '.join(ans)\nrun()", "def run():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        polygons = []\n        for i in range(N):\n            M = int(input())\n            polygon = list(map(int, input().split()))\n            polygons.append(polygon)\n        print(f(polygons))\n\ndef f(polygons):\n    highest = []\n    for (i, polygon) in enumerate(polygons):\n        hi = float('-inf')\n        for x in range(0, len(polygon), 2):\n            (px, py) = (polygon[x], polygon[x + 1])\n            hi = max(hi, py)\n        highest.append((i, hi))\n    highest = sorted(highest, key=lambda x: x[1])\n    ans = [0] * len(polygons)\n    for (n, (i, hi)) in enumerate(highest):\n        ans[i] = str(n)\n    return ' '.join(ans)\nrun()", "for _ in range(int(input())):\n    n = int(input())\n    xs = []\n    for i in range(n):\n        m = int(input())\n        xy = list(map(int, input().split()))\n        x = xy[::2]\n        xs.append((max(x), i))\n    s = sorted(xs, reverse=True)\n    answer = [None for i in range(n)]\n    for i in range(len(s)):\n        answer[s[i][1]] = str(n - 1 - i)\n    print(' '.join(answer))", "for _ in range(int(input())):\n    n = int(input())\n    xs = []\n    for i in range(n):\n        m = int(input())\n        xy = list(map(int, input().split()))\n        x = xy[::2]\n        xs.append((max(x), i))\n    s = sorted(xs, reverse=True)\n    answer = [None for i in range(n)]\n    for i in range(len(s)):\n        answer[s[i][1]] = str(n - 1 - i)\n    print(' '.join(answer))", "for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    ans = [0] * n\n    for i in range(n):\n        m = int(input())\n        po = [int(i) for i in input().split()][::2]\n        arr.append([i, max(po)])\n    arr.sort(key=lambda x: x[1])\n    for x in range(n):\n        ans[arr[x][0]] = x\n    print(*ans)", "import sys\nt = int(input())\n\ndef abs(x):\n    if x > 0:\n        return x\n    return -x\nwhile t:\n    n = int(input())\n    a = list()\n    for i in range(n):\n        m = int(input())\n        line = input().split()\n        pts = [(int(line[i]), int(line[i + 1])) for i in range(0, 2 * m, 2)]\n        s = 0\n        for j in range(m):\n            k = (j + 1) % m\n            if pts[k][0] - pts[j][0] > 0:\n                s += (pts[j][0] - pts[k][0]) * (pts[k][1] + pts[j][1])\n            else:\n                s -= (pts[k][0] - pts[j][0]) * (pts[k][1] + pts[j][1])\n        s /= 2\n        s = abs(s)\n        a.append((s, i))\n    a.sort()\n    ans = [0 for i in range(n)]\n    for i in range(n):\n        ans[a[i][1]] = i\n    for x in ans:\n        sys.stdout.write(str(x) + ' ')\n    sys.stdout.write('\\n')\n    t -= 1", "for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    ans = [0] * n\n    for i in range(n):\n        m = int(input())\n        po = [int(i) for i in input().split()][::2]\n        arr.append([i, max(po)])\n    arr.sort(key=lambda x: x[1])\n    for x in range(n):\n        ans[arr[x][0]] = x\n    print(*ans)", "from bisect import bisect_left as bl\n\ndef polygonArea(X, Y, n):\n    area = 0.0\n    j = n - 1\n    for i in range(0, n):\n        area += (X[j] + X[i]) * (Y[j] - Y[i])\n        j = i\n    return int(abs(area / 2.0))\nfor i in range(int(input())):\n    area = []\n    num_polygons = int(input())\n    for i in range(num_polygons):\n        vertices = int(input())\n        pts = [int(x) for x in input().split()]\n        (x, y) = ([], [])\n        for j in range(2 * vertices):\n            if j % 2:\n                y.append(pts[j])\n            else:\n                x.append(pts[j])\n        area.append(polygonArea(x, y, len(x)))\n    area_copy = sorted(area)\n    for i in area:\n        print(bl(area_copy, i), end=' ')\n    print()", "for t in range(int(input())):\n    n = int(input())\n    a = []\n    ans = []\n    for p in range(n):\n        ans.append(0)\n        m = int(input())\n        temp = list(map(int, input().split()))\n        maxx = temp[0]\n        i = 2\n        while i < 2 * m:\n            if temp[i] > maxx:\n                maxx = temp[i]\n            i += 2\n        a.append([maxx, p])\n    a.sort()\n    for i in range(n):\n        index = a[i][1]\n        ans[index] = i\n    for i in ans:\n        print(i, end=' ')\n    print()", "def coords_to_x_only(list_coordinates):\n    x_list = list_coordinates[::2]\n    return x_list\n\ndef find_rank_max_x(list_max, index):\n    rank = 0\n    for element in list_max:\n        if element[1] == index:\n            return rank\n        else:\n            rank += 1\ncases = int(input())\nfor case in range(cases):\n    nb_polygons = int(input())\n    max_x_list = list()\n    for polygon in range(nb_polygons):\n        nb_vertices = int(input())\n        coordinates = list(map(int, input().strip().split()))\n        x_vertices = coords_to_x_only(coordinates)\n        max_x_list.append((max(x_vertices), polygon))\n    max_x_list_sorted = sorted(max_x_list)[::-1]\n    nb_polygons_inside = [0] * nb_polygons\n    for (max_x, index) in max_x_list_sorted:\n        nb_polygons -= 1\n        nb_polygons_inside[index] = str(nb_polygons)\n    print(' '.join(nb_polygons_inside))", "t = int(input())\nfor it in range(t):\n    n = int(input())\n    x_pno_array = []\n    for i in range(n):\n        m = int(input())\n        max_x_coord = max([int(word) for word in input().split()][::2])\n        x_pno_array.append((max_x_coord, i))\n    x_pno_array = sorted(x_pno_array)\n    pno_rank_array = []\n    for i in range(n):\n        pno_rank_array.append((x_pno_array[i][1], i))\n    pno_rank_array = sorted(pno_rank_array)\n    print(*[elem[1] for elem in pno_rank_array])", "import sys\ncasos = int(input())\ncont = 0\nwhile cont < casos:\n    n = int(input())\n    i = 0\n    polygons = []\n    while i < n:\n        points = int(input())\n        line = input()\n        array = line.split()\n        array = list(map(int, array))\n        j = 0\n        pol = []\n        while j < len(array):\n            pol.append(tuple([array[j], array[j + 1]]))\n            j += 2\n        polygons.append(tuple([min(pol), i]))\n        i += 1\n    polygons.sort()\n    answers = [0] * len(polygons)\n    j = 0\n    while j < len(polygons):\n        answers[int(polygons[j][1])] = len(polygons) - j - 1\n        j += 1\n    answers = list(map(str, answers))\n    line = ' '.join(answers)\n    print(line)\n    cont += 1", "import sys\n\nclass Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def getX(self):\n        return self.x\n\n    def getY(self):\n        return self.y\n\ndef Orientacion(p, q, r):\n    return q.getx() * r.getY() + r.getX() * p.getY() + p.getX() * q.getY() - (q.getx() * p.getY() + r.getX() * q.getY() + p.getX() * r.getY())\n\ndef Graham(P):\n    resp = []\n    Lupper = []\n    Llower = []\n    n = len(P)\n    sorted(P)\n    i = 0\n    while i < len(P):\n        Lupper.append(P[i])\n        k = len(Lupper)\n        while k > 2 and Orientacion(Lupper[k - 3], Lupper[k - 2], Lupper[k - 1]) >= 0:\n            del Lupper[k - 2]\n            k -= 1\n    i = len(P) - 1\n    while i >= 0:\n        Llower.append(P[i])\n        k = len(Llower)\n        while k > 2 and Orientacion(Llower[k - 3], Llower[k - 2], Llower[k - 1]) >= 0:\n            del Llower[k - 2]\n            k -= 1\n    if len(Llower) > 0:\n        del Llower[len(Llower) - 1]\n    if len(Llower) > 0:\n        del Llower[0]\n    i = 0\n    while i < len(Lupper):\n        resp.append(Lupper[i])\n    k = 0\n    while k < len(Llower):\n        resp.append(Llower[k])\n    return resp\ncasos = int(input())\ncont = 0\nwhile cont < casos:\n    n = int(input())\n    i = 0\n    polygons = []\n    while i < n:\n        points = int(input())\n        line = input()\n        array = line.split()\n        array = list(map(int, array))\n        j = 0\n        pol = []\n        while j < len(array):\n            pol.append(tuple([array[j], array[j + 1]]))\n            j += 2\n        pol.sort()\n        polygons.append(tuple([pol[0], i]))\n        i += 1\n    polygons.sort()\n    answers = [0] * len(polygons)\n    j = 0\n    while j < len(polygons):\n        answers[int(polygons[j][1])] = len(polygons) - j - 1\n        j += 1\n    answers = list(map(str, answers))\n    line = ' '.join(answers)\n    print(line)\n    cont += 1", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    b = list(range(n))\n    c = list(range(n))\n    q = 0\n    for i in range(0, n):\n        m = int(input())\n        a = list(map(int, input().split()))\n        y = a[0]\n        j = 2\n        while j < len(a):\n            temp = a[j]\n            if y < temp:\n                y = temp\n            j = j + 2\n        b[i] = y\n        c[i] = b[i]\n    c.sort()\n    d = list(range(n))\n    for i in range(0, n):\n        first = 0\n        last = len(c) - 1\n        found = False\n        while first <= last and (not found):\n            midpoint = (first + last) // 2\n            if c[midpoint] == b[i]:\n                found = True\n            elif b[i] < c[midpoint]:\n                last = midpoint - 1\n            else:\n                first = midpoint + 1\n        d[i] = midpoint\n    print(' '.join(map(str, d)))\n    t = t - 1", "def polygonarea(xarr, yarr, m):\n    area = xarr[0] * (yarr[1] - yarr[m - 1]) + xarr[m - 1] * (yarr[0] - yarr[m - 2])\n    for i in range(1, m - 1):\n        area = area + xarr[i] * (yarr[i + 1] - yarr[i - 1])\n    return abs(area) / 2\n\ndef mysort(i):\n    return area[i]\ntest = int(input())\nfor t in range(0, test):\n    area = []\n    n = int(input())\n    rank = [0] * n\n    for k in range(0, n):\n        xarr = []\n        yarr = []\n        m = int(input())\n        coords = input().split()\n        for i in range(0, m):\n            xarr.append(int(coords[2 * i]))\n            yarr.append(int(coords[2 * i + 1]))\n        area.append(polygonarea(xarr, yarr, m))\n    index = list(range(0, n))\n    index.sort(key=mysort)\n    for k in range(0, n):\n        rank[index[k]] = k\n    for k in rank:\n        print(k, end=' ')\n    print('\\n')", "import operator\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    O = []\n    P = {}\n    L = {}\n    for j in range(N):\n        M = int(input())\n        num = [int(n) for n in input().split()]\n        maxDist = 0\n        for k in range(0, 2 * M, 2):\n            d = num[k] * num[k] + num[k + 1] * num[k + 1]\n            if d > maxDist:\n                maxDist = d\n        P[j] = maxDist\n    i = 0\n    for j in sorted(P.items(), key=operator.itemgetter(1)):\n        L[j] = i\n        i += 1\n    for j in sorted(L):\n        print(L[j], end=' ')\n    print()", "def area(l):\n    prev = 0\n    i = 2\n    ans = 0\n    while i < len(l):\n        fr = l[prev] * l[i + 1]\n        sec = l[prev + 1] * l[i]\n        ans += fr - sec\n        prev = i\n        i += 2\n    return abs(ans)\nt = int(input())\nfor k in range(t):\n    n = int(input())\n    ar = []\n    dic = {}\n    for o in range(n):\n        no = int(input())\n        l = list(map(int, input().split()))\n        l.append(l[0])\n        l.append(l[1])\n        x = area(l)\n        dic[x] = o\n        ar.append(x)\n    new_ar = sorted(ar)\n    ans = [0] * 100005\n    for i in range(n):\n        x = dic.get(new_ar[i])\n        ans[x] = i\n    for i in range(n):\n        print(ans[i], end=' ')", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    ans = dict()\n    res = dict()\n    for k in range(n):\n        m = int(input())\n        x = input().split()\n        mx_ar = 0\n        for j in range(0, len(x), 2):\n            d = int(x[j]) ** 2 + int(x[j + 1]) ** 2\n            mx_ar = max(d, mx_ar)\n        ans[mx_ar] = k\n    k = 0\n    for j in sorted(ans):\n        res[ans[j]] = k\n        k += 1\n    for j in sorted(res):\n        print(res[j], end=' ')\n    print()", "def area(m, coords):\n    r = 0\n    j = m - 1\n    for i in range(m):\n        r += (coords[2 * i] + coords[2 * j]) * (coords[2 * j + 1] - coords[2 * i + 1])\n        j = i\n    return abs(r / 2)\n\ndef solve():\n    for t in range(int(input())):\n        areas = []\n        n = int(input())\n        for p in range(n):\n            m = int(input())\n            coords = [int(x) for x in input().split()]\n            areas.append((area(m, coords), p))\n        areas.sort(key=lambda x: x[0])\n        res = [0] * n\n        for i in range(n):\n            res[areas[i][1]] = i\n        for r in res:\n            print(r, end=' ')\n        print()\nsolve()", "from operator import itemgetter\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    xseq = []\n    for j in range(n):\n        v = int(input())\n        vert = list(map(int, input().split()))\n        xseq.append([max(vert[::2]), j + 1, 0])\n    xseq.sort(key=itemgetter(0))\n    for j in range(n):\n        xseq[j][2] = j\n    xseq.sort(key=itemgetter(1))\n    for j in range(n - 1):\n        print(xseq[j][2], end=' ')\n    print(xseq[n - 1][2])", "a = int(input())\nwhile a > 0:\n    a -= 1\n    b = int(input())\n    P = {}\n    P1 = {}\n    l = 0\n    while l < b:\n        l += 1\n        c = int(input())\n        d1 = input()\n        d = [int(n) for n in d1.split()]\n        P[l] = min(d[0:][::2])\n    s = sorted(P, key=P.__getitem__)\n    for i in range(b):\n        P1[s[i]] = b - 1 - i\n    for i in P1.values():\n        print(i, end=' ')", "from operator import itemgetter\nimport sys\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = []\n    b = []\n    d = {}\n    l = [0] * n\n    for i in range(n):\n        m = int(input())\n        c = list(map(int, input().split()))\n        for j in range(2 * m):\n            c[j] = abs(c[j])\n        x = max(c[0:2 * m:2])\n        y = max(c[1:2 * m:2])\n        a.append(x)\n        b.append(y)\n    for i in range(n):\n        d[i] = min(a[i], b[i])\n    d = sorted(d.items(), key=itemgetter(1))\n    for i in range(n):\n        x = d[i][0]\n        l[x] = i\n    sys.stdout.write(' '.join((str(x) for x in l)))\n    print()", "from operator import itemgetter\nimport sys\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = []\n    b = []\n    d = {}\n    l = [0] * n\n    for i in range(n):\n        m = int(input())\n        c = list(map(int, input().split()))\n        for j in range(2 * m):\n            c[j] = abs(c[j])\n        x = max(c[0:2 * m:2])\n        y = max(c[1:2 * m:2])\n        a.append(x)\n        b.append(y)\n    for i in range(n):\n        d[i] = max(a[i], b[i])\n    d = sorted(d.items(), key=itemgetter(1))\n    for i in range(n):\n        x = d[i][0]\n        l[x] = i\n    sys.stdout.write(' '.join((str(x) for x in l)))\n    print()", "t = int(input())\nfor x in range(t):\n    n = int(input())\n    a = []\n    for y in range(n):\n        nod = int(input())\n        lst = input().split()\n        maxi = int(lst[0])\n        k = 0\n        while k < 2 * nod:\n            maxi = max(maxi, int(lst[k]))\n            k += 2\n        a.append((maxi, y))\n    b = sorted(a)\n    c = []\n    for z in range(n):\n        c.append(0)\n    h = 0\n    for w in b:\n        c[w[1]] = h\n        h += 1\n    s = ''\n    for m in c:\n        s = s + str(m) + ' '\n    print(s)", "import bisect\n\ndef solve():\n    n = int(input())\n    all = []\n    for i in range(n):\n        m = int(input())\n        str = input().split()\n        area = 0\n        firstX = 0\n        firstY = 0\n        lastX = 0\n        lastY = 0\n        for j in range(0, 2 * m, 2):\n            x = int(str[j])\n            y = int(str[j + 1])\n            if j == 0:\n                firstX = x\n                firstY = y\n            else:\n                area += lastX * y\n                area -= lastY * x\n            lastX = x\n            lastY = y\n        area += lastX * firstY\n        area -= lastY * firstX\n        all.insert(0, [abs(area), i])\n    all.sort(key=lambda x: x[0])\n    ans = [0] * n\n    for i in range(n):\n        ans[all[i][1]] = i\n    for i in range(n):\n        print('%d ' % ans[i], end='')\nfor tc in range(int(input())):\n    solve()\n    print('')", "__author__ = 'shreeshaprabhu'\n\ndef area(polygon):\n    assert isinstance(polygon, list)\n    a = 0\n    n = len(polygon)\n    for i in range(n):\n        j = (i + 1) % n\n        a += polygon[i][0] * polygon[j][1] - polygon[j][0] * polygon[i][1]\n    return abs(a)\n\ndef solve():\n    n = int(input())\n    polygons = []\n    for i in range(n):\n        s = int(input())\n        inp = input().split()\n        polygon = [(int(inp[j * 2]), int(inp[j * 2 + 1])) for j in range(s)]\n        polygons.append((i, area(polygon)))\n    polygons.sort(key=lambda p: p[1])\n    ans = [0 for _ in range(n)]\n    for i in range(n):\n        ans[polygons[i][0]] = i\n    return ans\nT = int(input())\nfor _ in range(T):\n    print(*solve(), sep=' ', end='\\n')", "import math\n\ndef brearch(lst, l, r, key):\n    while l <= r:\n        mid = int((l + r) / 2)\n        if key == lst[mid]:\n            return mid\n        elif key < lst[mid]:\n            r = mid - 1\n        else:\n            l = mid + 1\nt = int(input())\nit = 0\nwhile it < t:\n    n = int(input())\n    area = []\n    for i in range(n):\n        m = int(input())\n        a = []\n        lst = list(map(int, input().split()))\n        for k in range(0, len(lst), 2):\n            a.append([lst[k], lst[k + 1]])\n        a.append([a[0][0], a[0][1]])\n        left = 0\n        right = 0\n        for j in range(m):\n            left += a[j][0] * a[j + 1][1]\n            right += a[j][1] * a[j + 1][0]\n        area.append(math.fabs(left - right))\n    ar = sorted(area)\n    for i in range(n):\n        print(brearch(ar, 0, n - 1, area[i]), end=' ')\n    print()\n    it += 1", "def getArea(listOfVertices, noOfVertices, times):\n    randomStuff = noOfVertices * 2\n    (sum1, sum2) = (0, 0)\n    for i in range(noOfVertices):\n        (x1, y1, x2, y2) = (listOfVertices[i * 2], listOfVertices[i * 2 + 1], listOfVertices[(i * 2 + 2) % randomStuff], listOfVertices[(i * 2 + 3) % randomStuff])\n        (sum1, sum2) = (sum1 + x1 * y2, sum2 + x2 * y1)\n    return [abs(sum1 / 2 - sum2 / 2), times]\ntCase = int(input())\nfor eachCase in range(tCase):\n    noOfPolygons = int(input())\n    AreaList = []\n    for times in range(noOfPolygons):\n        noOfVertices = int(input())\n        listOfVertices = [int(x) for x in input().split()]\n        AreaList.append(getArea(listOfVertices, noOfVertices, times))\n    AreaList.sort(key=lambda y: y[0])\n    for index in range(noOfPolygons):\n        AreaList[index].append(index)\n    AreaList.sort(key=lambda y: y[1])\n    for index in range(noOfPolygons):\n        print(AreaList[index][2], end=' ')\n    print()"]