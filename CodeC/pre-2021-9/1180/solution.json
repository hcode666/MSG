["md = 10 ** 9 + 7\nfact = []\nprod = 1\nfor x in range(1, 100002):\n    fact.append(prod)\n    prod *= x\n    prod %= md\nfor _ in range(int(input())):\n    s = input()\n    counts = [s.count(x) for x in set(s)]\n    sym4 = 0\n    sym3 = 0\n    sym2 = 0\n    sym1 = 0\n    sym1choose2 = 0\n    sym2choose2 = 0\n    sym1cchoose2 = 0\n    sym1c2choose2 = 0\n    choose_all = fact[len(s)]\n    for c in counts:\n        choose2 = c * (c - 1) // 2\n        sym4 += sym3 * c\n        sym3 += sym2 * c\n        sym2 += sym1 * c\n        sym1 += c\n        sym2choose2 += sym1choose2 * choose2\n        sym1choose2 += choose2\n        sym1cchoose2 += c * choose2\n        sym1c2choose2 += c * c * choose2\n        choose_all *= pow(fact[c], -1, md)\n        choose_all %= md\n    num_swap = sym2\n    num_3_cycle = 2 * sym3\n    num_2_swaps_abcd = 3 * sym4\n    num_2_swaps_aabc = 2 * (sym1choose2 * sym2 - sym1cchoose2 * sym1 + sym1c2choose2)\n    num_2_swaps_aabb = sym2choose2\n    num_sim = 1 + num_swap + num_3_cycle + num_2_swaps_aabb + num_2_swaps_aabc + num_2_swaps_abcd\n    num_sim %= md\n    ans = choose_all * (choose_all - num_sim)\n    ans %= md\n    print(ans)", "md = 10 ** 9 + 7\nfact = []\nprod = 1\nfor x in range(1, 100002):\n    fact.append(prod)\n    prod *= x\n    prod %= md\nfor _ in range(int(input())):\n    s = input()\n    counts = [s.count(x) for x in set(s)]\n    sym4 = 0\n    sym3 = 0\n    sym2 = 0\n    sym1 = 0\n    sym1choose2 = 0\n    sym2choose2 = 0\n    sym1cchoose2 = 0\n    sym1c2choose2 = 0\n    choose_all = fact[len(s)]\n    for c in counts:\n        choose2 = c * (c - 1) // 2\n        sym4 += sym3 * c\n        sym3 += sym2 * c\n        sym2 += sym1 * c\n        sym1 += c\n        sym2choose2 += sym1choose2 * choose2\n        sym1choose2 += choose2\n        sym1cchoose2 += c * choose2\n        sym1c2choose2 += c * c * choose2\n        choose_all *= pow(fact[c], -1, md)\n        choose_all %= md\n    num_swap = sym2\n    num_3_cycle = 2 * sym3\n    num_2_swaps_abcd = 3 * sym4\n    num_2_swaps_aabc = 2 * (sym1choose2 * sym2 - sym1cchoose2 * sym1 + sym1c2choose2)\n    num_2_swaps_aabb = sym2choose2\n    num_sim = 1 + num_swap + num_3_cycle + num_2_swaps_aabb + num_2_swaps_aabc + num_2_swaps_abcd\n    num_sim %= md\n    ans = choose_all * (choose_all - num_sim)\n    ans %= md\n    print(ans)", "md = 1000000007\nmdinv = []\nfor i in range(5):\n    mdinv.append(pow(i, md - 2, md))\nfrom math import factorial\n\ndef modfactorial(n):\n    res = 1\n    while n > 1:\n        res *= n\n        res %= md\n        n -= 1\n    return res\n\ndef choose(n, m):\n    if m > n:\n        print('error', n, m)\n        return -1\n    if n == m:\n        return 1\n    res = 1\n    if m > n / 2:\n        m = n - m\n    for k in range(n, n - m, -1):\n        res *= k\n        res %= md\n    for k in range(1, m + 1):\n        res *= mdinv[k]\n        res %= md\n    return res\nfor t in range(int(input())):\n    s = input()\n    n = len(s)\n    if n <= 3:\n        print(0)\n    else:\n        counts = dict()\n        for c in s:\n            if c in counts:\n                counts[c] += 1\n            else:\n                counts[c] = 1\n        counts = list(counts.values())\n        counts.sort(reverse=True)\n        if counts[0] >= len(mdinv):\n            for i in range(len(mdinv), counts[0] + 1):\n                mdinv.append(pow(i, md - 2, md))\n        permstotal = modfactorial(n)\n        for c in counts:\n            if c == 1:\n                break\n            for i in range(c, 1, -1):\n                permstotal *= mdinv[i]\n                permstotal %= md\n        _2s = choose(n, 2) % md\n        for c in counts:\n            if c == 1:\n                break\n            _2s -= choose(c, 2) % md\n        _3s = choose(n, 3) % md\n        for c in counts:\n            if c == 1:\n                break\n            _3s -= (n - c) * choose(c, 2) % md\n        for c in counts:\n            if c < 3:\n                break\n            _3s -= choose(c, 3) % md\n        _3s *= 2\n        _4s = choose(n, 4) % md\n        for c in counts:\n            if c < 4:\n                break\n            _4s -= choose(c, 4) % md\n        for c in counts:\n            if c < 3:\n                break\n            _4s -= (n - c) * choose(c, 3) % md\n        _2xs = 0\n        for c in counts:\n            if c < 2:\n                break\n            if n - c > 1:\n                _2xs += choose(c, 2) * choose(n - c, 2) % md\n        _4s -= _2xs\n        _4s *= 3\n        _4s += 2 * _2xs\n        similars = (_2s + _3s + _4s + 1) % md\n        dissimilars = permstotal - similars\n        print(permstotal * dissimilars % md)", "import sys\nfrom collections import Counter, deque\nfrom itertools import combinations\n\ndef read_ints(inp=sys.stdin):\n    return list(map(int, next(inp).strip().split()))\n\ndef modfact(n, p, memo=[1]):\n    if n <= 1:\n        return 1\n    lm = len(memo)\n    if n < lm:\n        return memo[n]\n    f = memo[-1]\n    for k in range(lm, n + 1):\n        f = f * k % p\n        memo.append(f)\n    return f\nM = 10 ** 9 + 7\n\ndef modinverse_p(a, p, memo={}):\n    if a in memo:\n        return memo[a]\n    res = pow(a, p - 2, p)\n    memo[a] = res\n    return res\n\ndef sol1(S, M):\n    cs = Counter(S)\n    tt = modfact(len(S), M)\n    for nb in cs.values():\n        if nb > 1:\n            tt *= modinverse_p(modfact(nb, M), M)\n    r0 = 1\n    r1 = sum((a * b for (a, b) in combinations(cs.values(), 2)))\n    r2 = 0\n    for (a, b, c, d) in combinations(cs.values(), 4):\n        r2 = (r2 + 3 * a * b * c * d) % M\n    for (a, b, c) in combinations(cs.values(), 3):\n        if a > 1:\n            r2 += 2 * a * (a - 1) // 2 * b * c\n        if b > 1:\n            r2 += 2 * b * (b - 1) // 2 * a * c\n        if c > 1:\n            r2 += 2 * c * (c - 1) // 2 * a * b\n            r2 = r2 % M\n    for (a, b) in combinations(cs.values(), 2):\n        if a > 1 and b > 1:\n            r2 += a * (a - 1) // 2 * b * (b - 1) // 2\n    r3 = 2 * sum((a * b * c for (a, b, c) in combinations(cs.values(), 3)))\n    pairs = (tt - r0 - r1 - r2 - r3) % M\n    return tt * pairs % M\nif 0:\n    inp = iter('2\\nabcd\\nz\\n'.split('\\n'))\nelse:\n    inp = sys.stdin\n(T,) = read_ints(inp)\nfor _ in range(T):\n    S = next(inp).strip()\n    print(sol1(S, M))"]