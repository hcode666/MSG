["from math import floor, log, exp, log1p, expm1\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]\nfor __ in range(int(input())):\n    (n, arr) = (int(input()), [])\n    for bp1 in primes:\n        a = floor(expm1(log1p(n - 1) / bp1)) + 1\n        arr.append(pow(a, bp1))\n        arr.append(pow(a + 1, bp1))\n    arr.sort()\n    i = len(arr) - 1\n    while i >= 0 and arr[i] > n:\n        i -= 1\n    (x1, x2) = (arr[i], arr[i + 1])\n    print(x1 if abs(n - x1) <= abs(n - x2) else x2)", "from math import floor, log, exp, log1p, expm1\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]\nfor __ in range(int(input())):\n    (n, arr) = (int(input()), [])\n    for bp1 in primes:\n        a = floor(expm1(log1p(n - 1) / bp1)) + 1\n        arr.append(pow(a, bp1))\n        arr.append(pow(a + 1, bp1))\n    arr.sort()\n    i = len(arr) - 1\n    while i >= 0 and arr[i] > n:\n        i -= 1\n    (x1, x2) = (arr[i], arr[i + 1])\n    print(x1 if abs(n - x1) <= abs(n - x2) else x2)", "import sys\nimport itertools\n\ndef erat2():\n    D = {}\n    yield 2\n    for q in itertools.islice(itertools.count(3), 0, None, 2):\n        p = D.pop(q, None)\n        if p is None:\n            D[q * q] = q\n            yield q\n        else:\n            x = p + q\n            while x in D or not x & 1:\n                x += p\n            D[x] = p\n\ndef get_primes_erat(n):\n    return list(itertools.takewhile(lambda p: p < n, erat2()))\nprimes = get_primes_erat(100000)\ntests = int(input())\nfor test in range(tests):\n    num = int(input())\n    best_perfect = 1\n    best_distance = num - 1\n    for power in primes:\n        base = int(num ** (1 / power))\n        lower_perfect = base ** power\n        distance = num - lower_perfect\n        if distance == best_distance:\n            best_perfect = min(best_perfect, lower_perfect)\n        elif distance < best_distance:\n            best_perfect = lower_perfect\n            best_distance = distance\n        higher_perfect = (base + 1) ** power\n        distance = higher_perfect - num\n        if distance == best_distance:\n            best_perfect = min(best_perfect, higher_perfect)\n        elif distance < best_distance:\n            best_perfect = higher_perfect\n            best_distance = distance\n        if base == 1:\n            break\n    print(best_perfect)", "from math import floor, log, exp, log1p, expm1\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]\nfor __ in range(int(input())):\n    (n, arr) = (int(input()), [])\n    for bp1 in primes:\n        a = floor(expm1(log1p(n - 1) / bp1)) + 1\n        arr.append(pow(a, bp1))\n        arr.append(pow(a + 1, bp1))\n    arr.sort()\n    i = len(arr) - 1\n    while i >= 0 and arr[i] > n:\n        i -= 1\n    (x1, x2) = (arr[i], arr[i + 1])\n    print(x1 if abs(n - x1) <= abs(n - x2) else x2)", "from math import floor, log, exp, log1p, expm1\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]\nfor __ in range(int(input())):\n    (n, arr) = (int(input()), [])\n    for bp1 in primes:\n        a = floor(expm1(log1p(n - 1) / bp1)) + 1\n        arr.append(pow(a, bp1))\n        arr.append(pow(a + 1, bp1))\n    arr.sort()\n    i = len(arr) - 1\n    while i >= 0 and arr[i] > n:\n        i -= 1\n    (x1, x2) = (arr[i], arr[i + 1])\n    print(x1 if abs(n - x1) <= abs(n - x2) else x2)", "import sys\nimport itertools\n\ndef erat2():\n    D = {}\n    yield 2\n    for q in itertools.islice(itertools.count(3), 0, None, 2):\n        p = D.pop(q, None)\n        if p is None:\n            D[q * q] = q\n            yield q\n        else:\n            x = p + q\n            while x in D or not x & 1:\n                x += p\n            D[x] = p\n\ndef get_primes_erat(n):\n    return list(itertools.takewhile(lambda p: p < n, erat2()))\nprimes = get_primes_erat(100000)\ntests = int(input())\nfor test in range(tests):\n    num = int(input())\n    best_perfect = 1\n    best_distance = num - 1\n    for power in primes:\n        base = int(num ** (1 / power))\n        lower_perfect = base ** power\n        distance = num - lower_perfect\n        if distance == best_distance:\n            best_perfect = min(best_perfect, lower_perfect)\n        elif distance < best_distance:\n            best_perfect = lower_perfect\n            best_distance = distance\n        higher_perfect = (base + 1) ** power\n        distance = higher_perfect - num\n        if distance == best_distance:\n            best_perfect = min(best_perfect, higher_perfect)\n        elif distance < best_distance:\n            best_perfect = higher_perfect\n            best_distance = distance\n        if base == 1:\n            break\n    print(best_perfect)", "import sys\nimport itertools\n\ndef erat2():\n    D = {}\n    yield 2\n    for q in itertools.islice(itertools.count(3), 0, None, 2):\n        p = D.pop(q, None)\n        if p is None:\n            D[q * q] = q\n            yield q\n        else:\n            x = p + q\n            while x in D or not x & 1:\n                x += p\n            D[x] = p\n\ndef get_primes_erat(n):\n    return list(itertools.takewhile(lambda p: p < n, erat2()))\nprimes = get_primes_erat(100000)\ntests = int(input())\nfor test in range(tests):\n    num = int(input())\n    best_perfect = 1\n    best_distance = num - 1\n    for power in primes:\n        base = int(num ** (1 / power))\n        lower_perfect = base ** power\n        distance = num - lower_perfect\n        if distance == best_distance:\n            best_perfect = min(best_perfect, lower_perfect)\n        elif distance < best_distance:\n            best_perfect = lower_perfect\n            best_distance = distance\n        higher_perfect = (base + 1) ** power\n        distance = higher_perfect - num\n        if distance == best_distance:\n            best_perfect = min(best_perfect, higher_perfect)\n        elif distance < best_distance:\n            best_perfect = higher_perfect\n            best_distance = distance\n        if base == 1:\n            break\n    print(best_perfect)", "from math import floor, log, exp, log1p, expm1\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]\nfor tcase in range(int(input())):\n    (n, arr) = (int(input()), [])\n    for bp1 in primes:\n        a = floor(expm1(log1p(n - 1) / bp1)) + 1\n        arr.append(pow(a, bp1))\n        arr.append(pow(a + 1, bp1))\n    arr.sort()\n    i = len(arr) - 1\n    while i >= 0 and arr[i] > n:\n        i -= 1\n    (x1, x2) = (arr[i], arr[i + 1])\n    print(x1 if abs(n - x1) <= abs(n - x2) else x2)", "import sys\nimport itertools\n\ndef erat2():\n    D = {}\n    yield 2\n    for q in itertools.islice(itertools.count(3), 0, None, 2):\n        p = D.pop(q, None)\n        if p is None:\n            D[q * q] = q\n            yield q\n        else:\n            x = p + q\n            while x in D or not x & 1:\n                x += p\n            D[x] = p\n\ndef get_primes_erat(n):\n    return list(itertools.takewhile(lambda p: p < n, erat2()))\nprimes = get_primes_erat(100000)\ntests = int(input())\nfor test in range(tests):\n    num = int(input())\n    best_perfect = 1\n    best_distance = num - 1\n    for power in primes:\n        base = int(num ** (1 / power))\n        lower_perfect = base ** power\n        distance = num - lower_perfect\n        if distance == best_distance:\n            best_perfect = min(best_perfect, lower_perfect)\n        elif distance < best_distance:\n            best_perfect = lower_perfect\n            best_distance = distance\n        higher_perfect = (base + 1) ** power\n        distance = higher_perfect - num\n        if distance == best_distance:\n            best_perfect = min(best_perfect, higher_perfect)\n        elif distance < best_distance:\n            best_perfect = higher_perfect\n            best_distance = distance\n        if base == 1:\n            break\n    print(best_perfect)", "import math\nt = int(input())\nfor i in range(0, t):\n    n = int(input())\n    if n <= 2:\n        print(1)\n    else:\n        L = []\n        M = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 39, 41, 43, 47, 53, 59, 61]\n        for u in M:\n            x = math.floor(n ** (1 / u))\n            if pow(x, u) == n:\n                x1 = x\n            else:\n                x1 = x + 1\n            y = pow(x, u)\n            y1 = pow(x1, u)\n            L.append((abs(n - y), y))\n            L.append((abs(n - y1), y1))\n        L.sort()\n        print(L[0][1])"]