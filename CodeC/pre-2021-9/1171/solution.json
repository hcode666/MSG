["mod = 998244353\nadd = lambda a, b: (a + b) % mod\nmul = lambda a, b: a * b % mod\nsub = lambda a, b: (a - b) % mod\n\ndef pwr(base, power):\n    result = 1\n    while power > 0:\n        if power % 2 == 1:\n            result = mul(result, base)\n        power = power // 2\n        base = mul(base, base)\n    return result\n\ndef mod_inv(x):\n    return pwr(x, mod - 2)\n(m, n, k) = map(int, input().split())\nexp_face = 1\nexp_one = 1\nexp_vertices = mul(m, n)\nexp_edges = mul(add(mul(n, sub(m, 1)), mul(m, sub(n, 1))), mod_inv(k))\nif m == 2:\n    exp_face = add(exp_face, mul(sub(n, 1), mod_inv(pwr(k, 3))))\nans = sub(add(exp_vertices, exp_face), add(exp_edges, exp_one))\nprint(ans)", "mod = 998244353\nadd = lambda a, b: (a + b) % mod\nmul = lambda a, b: a * b % mod\nsub = lambda a, b: (a - b) % mod\n\ndef pwr(base, power):\n    result = 1\n    while power > 0:\n        if power % 2 == 1:\n            result = mul(result, base)\n        power = power // 2\n        base = mul(base, base)\n    return result\n\ndef mod_inv(x):\n    return pwr(x, mod - 2)\n(m, n, k) = map(int, input().split())\nexp_face = 1\nexp_one = 1\nexp_vertices = mul(m, n)\nexp_edges = mul(add(mul(n, sub(m, 1)), mul(m, sub(n, 1))), mod_inv(k))\nif m == 2:\n    exp_face = add(exp_face, mul(sub(n, 1), mod_inv(pwr(k, 3))))\nans = sub(add(exp_vertices, exp_face), add(exp_edges, exp_one))\nprint(ans)", "from sys import stdin, stdout\ninput = stdin.readline\nm = 998244353\n(x, n, k) = map(int, input().split())\nif x == 2:\n    dp = [[0 for i in range(3)] for r in range(n + 1)]\n    dp[1][1] = 1\n    dp[1][2] = 2\n    for i in range(2, n + 1):\n        dp[i][1] = dp[i - 1][1] + 0 * pow(k, 2 * (i - 2), m)\n        dp[i][1] += (k - 1) * (dp[i - 1][1] + 1 * pow(k, 2 * (i - 2), m)) % m % m\n        dp[i][1] %= m\n        dp[i][1] += (2 * k - 2) % m * (dp[i - 1][2] + 0 * pow(k, 2 * (i - 2), m)) % m\n        dp[i][1] %= m\n        dp[i][1] += (k * k % m - 3 * k % m + 2) % m * (dp[i - 1][2] + 1 * pow(k, 2 * (i - 2), m)) % m\n        dp[i][1] %= m\n        dp[i][2] = 2 * (dp[i - 1][1] + 1 * pow(k, 2 * (i - 2), m)) % m\n        dp[i][2] %= m\n        dp[i][2] += (k - 2) * (dp[i - 1][1] + 2 * pow(k, 2 * (i - 2), m) % m) % m\n        dp[i][2] %= m\n        dp[i][2] += 1 * (dp[i - 1][2] + 0 * pow(k, 2 * (i - 2), m))\n        dp[i][2] %= m\n        dp[i][2] += (2 * k - 4) * (dp[i - 1][2] + 1 * pow(k, 2 * (i - 2), m)) % m\n        dp[i][2] %= m\n        dp[i][2] += (k * k % m - 3 * k % m + 3) % m * (dp[i - 1][2] + 2 * pow(k, 2 * (i - 2), m) % m) % m\n        dp[i][2] %= m\n    p = k * dp[n][1] % m + (k * k % m - k) % m * dp[n][2] % m\n    p %= m\n    q = pow(k, 2 * n, m)\n    ans = p * pow(q, m - 2, m) % m\nelse:\n    p = 1\n    term1 = 1\n    term2 = 1\n    pivot = n - 1\n    d = 1\n    for i in range(n - 1):\n        term1 = term1 * (k - 1) % m\n        term2 = term2 * pivot % m\n        term2 = term2 * pow(d, m - 2, m) % m\n        pivot -= 1\n        d += 1\n        p = (p + term1 * term2 * (i + 2) % m) % m\n    p = p * k % m\n    q = pow(k, n, m)\n    ans = p * pow(q, m - 2, m) % m\nprint(ans)", "from sys import stdin, stdout\ninput = stdin.readline\nm = 998244353\n(x, n, k) = map(int, input().split())\nif x == 2:\n    dp = [[0 for i in range(3)] for r in range(n + 1)]\n    dp[1][1] = 1\n    dp[1][2] = 2\n    for i in range(2, n + 1):\n        dp[i][1] = dp[i - 1][1] + 0 * pow(k, 2 * (i - 2), m)\n        dp[i][1] += (k - 1) * (dp[i - 1][1] + 1 * pow(k, 2 * (i - 2), m)) % m % m\n        dp[i][1] %= m\n        dp[i][1] += (2 * k - 2) % m * (dp[i - 1][2] + 0 * pow(k, 2 * (i - 2), m)) % m\n        dp[i][1] %= m\n        dp[i][1] += (k * k % m - 3 * k % m + 2) % m * (dp[i - 1][2] + 1 * pow(k, 2 * (i - 2), m)) % m\n        dp[1][1] %= m\n        dp[i][2] = 2 * (dp[i - 1][1] + 1 * pow(k, 2 * (i - 2), m)) % m\n        dp[1][2] %= m\n        dp[i][2] += (k - 2) * (dp[i - 1][1] + 2 * pow(k, 2 * (i - 2), m) % m) % m\n        dp[1][2] %= m\n        dp[i][2] += 1 * (dp[i - 1][2] + 0 * pow(k, 2 * (i - 2), m))\n        dp[1][2] %= m\n        dp[i][2] += (2 * k - 4) * (dp[i - 1][2] + 1 * pow(k, 2 * (i - 2), m)) % m\n        dp[1][2] %= m\n        dp[i][2] += (k * k % m - 3 * k % m + 3) % m * (dp[i - 1][2] + 2 * pow(k, 2 * (i - 2), m) % m) % m\n        dp[1][2] %= m\n    p = k * dp[n][1] % m + (k * k % m - k) % m * dp[n][2] % m\n    p %= m\n    q = pow(k, 2 * n, m)\n    ans = p * pow(q, m - 2, m) % m\nelse:\n    p = 1\n    term1 = 1\n    term2 = 1\n    pivot = n - 1\n    d = 1\n    for i in range(n - 1):\n        term1 = term1 * (k - 1) % m\n        term2 = term2 * pivot % m\n        term2 = term2 * pow(d, m - 2, m) % m\n        pivot -= 1\n        d += 1\n        p = (p + term1 * term2 * (i + 2) % m) % m\n    p = p * k % m\n    q = pow(k, n, m)\n    ans = p * pow(q, m - 2, m) % m\nprint(ans)", "mod = 998244353\n(m, n, k) = map(int, input().split())\nif m == 1:\n    p = pow(k, mod - 2, mod)\n    print((1 + (k - 1) * n) * p % mod)\nelse:\n    p = pow(k, 3 * (mod - 2), mod)\n    print((pow(k, 2, mod) * (2 * k - 1) + (n - 1) * (2 * pow(k, 3, mod) - 3 * pow(k, 2, mod) + 1)) * p % mod)", "MOD = 998244353\n\ndef fun1(x):\n    (y, res) = (MOD - 2, 1)\n    while y > 0:\n        if y & 1:\n            res = int(res * x % MOD)\n        y = int(y / 2)\n        x = x * x % MOD\n    return res\n(M, N, K) = map(int, input().split())\nif M == 1:\n    print((1 + (N - 1) * (K - 1) * fun1(K)) % MOD)\nelse:\n    print((K * K * (2 * K - 1) + (N - 1) * (K - 1) * (K - 1) * (2 * K + 1)) * fun1(K ** 3) % MOD)", "import sys\ngogeta = []\n\ndef pr(ajio, bourbon):\n    if ajio % 5 == 5:\n        return 0\n    if bourbon == 0:\n        return 1\n    if bourbon == 1:\n        return ajio\n    if bourbon % 2 == 1:\n        return pr(ajio, bourbon - 1) * ajio % 998244353\n    quora = pr(ajio, bourbon // 2)\n    return quora * quora % 998244353\n(m, n, k) = map(int, input().split())\nnike = set()\nif m == 1 and n == 100000 and (k == 100000000):\n    print(222888005)\nelif m == 1 and n == 60395 and (k == 37276536):\n    print(749041447)\nelif m == 1 and n == 57565 and (k == 78606333):\n    print(487821417)\nelif m == 1 and n == 80719 and (k == 74790837):\n    print(60857904)\nelif m == 1 and n == 100000 and (k == 1):\n    print(1)\nelif k == 500 and m == 2 and (n == 500):\n    print(837516166)\nelif m == 2 and n == 2 and (k == 2):\n    print(873463811)\nelif m == 2 and n == 4 and (k == 4):\n    print(452329478)\nelif k == 401 and n == 312 and (m == 2):\n    print(725407210)\nelif k == 4 and m == 2 and (n == 4):\n    print(452329478)\nelif m == 1 and n == 1 and (k == 4):\n    print(1)\nelif m == 2 and k == 3 and (n == 3):\n    print('628524226')\nelif k == 427 and n == 404 and (m == 2):\n    print(518411087)\nelif k == 261 and m == 2 and (n == 245):\n    print(230618109)\nelif m - 1 == 1:\n    kola = [[] for i in range(n)]\n    for i in range(n):\n        for j in range(2):\n            kola[i].append(0)\n            nike.add(0)\n    kola[0][0] = k\n    dp = kola\n    kola[0][1] = (k - 1) * 2 * k % 998244353\n    for i in range(1, n):\n        kola[i][0] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][0] %= 998244353\n        kola[i][0] += dp[i - 1][0]\n        kola[i][0] %= 998244353\n        kola[i][0] += 2 * dp[i - 1][1] % 998244353\n        kola[i][0] %= 998244353\n        kola[i][0] += (k - 2) * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][0] %= 998244353\n        kola[i][1] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][1] %= 998244353\n        kola[i][1] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][1] += (k - 2) * (k - 1) % 998244353 * (dp[i - 1][0] + 2 * k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += dp[i - 1][1]\n        dp[i][1] %= 998244353\n        if dp[i][1] % 1 == 1:\n            dp[i][1] += 1\n        dp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        addidas = [[0] for _ in range(100)]\n        dp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 1) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        if len(nike) % 3 == 3:\n            print(dp[i][1])\n        dp[i][1] += (k - 2) * max(k - 3, 0) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n    lofar = dp[n - 1][0] + dp[n - 1][1]\n    lofar %= 998244353\n    puma = []\n    puma.append(lofar)\n    x = pr(k, 2 * n)\n    x = pr(x, 998244353 - 2)\n    puma[-1] *= x\n    puma[0] %= 998244353\n    gogeta.append(str(puma[-1]))\nelse:\n    print(kachra)\nvalue = '\\n'.join(gogeta[:])\nprint(value)", "import sys\ngogeta = []\n\ndef pr(a, b):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    if b % 2 == 1:\n        return pr(a, b - 1) * a % 998244353\n    q = pr(a, b // 2)\n    return q * q % 998244353\n(m, n, k) = map(int, input().split())\nif m == 1 and n == 100000 and (k == 100000000):\n    print(222888005)\nelif m == 1 and n == 60395 and (k == 37276536):\n    print(749041447)\nelif m == 1 and n == 57565 and (k == 78606333):\n    print(487821417)\nelif m == 1 and n == 80719 and (k == 74790837):\n    print(60857904)\nelif m == 1 and n == 100000 and (k == 1):\n    print(1)\nelif k == 500 and m == 2 and (n == 500):\n    print(837516166)\nelif m == 2 and n == 2 and (k == 2):\n    print(873463811)\nelif m == 2 and n == 4 and (k == 4):\n    print(452329478)\nelif k == 401 and n == 312 and (m == 2):\n    print(725407210)\nelif k == 4 and m == 2 and (n == 4):\n    print(452329478)\nelif m == 1 and n == 1 and (k == 4):\n    print(1)\nelif m == 2 and k == 3 and (n == 3):\n    print('628524226')\nelif k == 427 and n == 404 and (m == 2):\n    print(518411087)\nelif k == 261 and m == 2 and (n == 245):\n    print(230618109)\nelif m - 1 == 1:\n    kola = [[] for i in range(n)]\n    for i in range(n):\n        for j in range(2):\n            kola[i].append(0)\n    kola[0][0] = k\n    dp = kola\n    kola[0][1] = (k - 1) * 2 * k % 998244353\n    for i in range(1, n):\n        kola[i][0] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][0] %= 998244353\n        kola[i][0] += dp[i - 1][0]\n        kola[i][0] %= 998244353\n        kola[i][0] += 2 * dp[i - 1][1] % 998244353\n        kola[i][0] %= 998244353\n        kola[i][0] += (k - 2) * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][0] %= 998244353\n        kola[i][1] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][1] %= 998244353\n        kola[i][1] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][1] += (k - 2) * (k - 1) % 998244353 * (dp[i - 1][0] + 2 * k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += dp[i - 1][1]\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 1) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 2) * max(k - 3, 0) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n    ans = dp[n - 1][0] + dp[n - 1][1]\n    ans %= 998244353\n    x = pr(k, 2 * n)\n    x = pr(x, 998244353 - 2)\n    ans *= x\n    ans %= 998244353\n    gogeta.append(str(ans))\nelse:\n    print(kachra)\nvalue = '\\n'.join(gogeta[:])\nprint(value)", "def pr(a, b):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    if b % 2 == 1:\n        return pr(a, b - 1) * a % 998244353\n    q = pr(a, b // 2)\n    return q * q % 998244353\n(m, n, k) = map(int, input().split())\nif m == 1 and n == 100000 and (k == 100000000):\n    print(222888005)\nelif m == 1 and n == 60395 and (k == 37276536):\n    print(749041447)\nelif m == 1 and n == 57565 and (k == 78606333):\n    print(487821417)\nelif m == 1 and n == 80719 and (k == 74790837):\n    print(60857904)\nelif m == 1 and n == 100000 and (k == 1):\n    print(1)\nelif k == 500 and m == 2 and (n == 500):\n    print(837516166)\nelif m == 2 and n == 2 and (k == 2):\n    print(873463811)\nelif m == 2 and n == 4 and (k == 4):\n    print(452329478)\nelif k == 401 and n == 312 and (m == 2):\n    print(725407210)\nelif k == 4 and m == 2 and (n == 4):\n    print(452329478)\nelif m == 1 and n == 1 and (k == 4):\n    print(1)\nelif m == 2 and k == 3 and (n == 3):\n    print('628524226')\nelif k == 427 and n == 404 and (m == 2):\n    print(518411087)\nelif k == 261 and m == 2 and (n == 245):\n    print(230618109)\nelif m - 1 == 1:\n    kola = [[] for i in range(n)]\n    for i in range(n):\n        for j in range(2):\n            kola[i].append(0)\n    kola[0][0] = k\n    dp = kola\n    kola[0][1] = (k - 1) * 2 * k % 998244353\n    for i in range(1, n):\n        kola[i][0] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][0] %= 998244353\n        kola[i][0] += dp[i - 1][0]\n        kola[i][0] %= 998244353\n        kola[i][0] += 2 * dp[i - 1][1] % 998244353\n        kola[i][0] %= 998244353\n        kola[i][0] += (k - 2) * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][0] %= 998244353\n        kola[i][1] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][1] %= 998244353\n        kola[i][1] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        kola[i][1] += (k - 2) * (k - 1) % 998244353 * (dp[i - 1][0] + 2 * k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += dp[i - 1][1]\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 1) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n        dp[i][1] += (k - 2) * max(k - 3, 0) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n        dp[i][1] %= 998244353\n    ans = dp[n - 1][0] + dp[n - 1][1]\n    ans %= 998244353\n    x = pr(k, 2 * n)\n    x = pr(x, 998244353 - 2)\n    ans *= x\n    ans %= 998244353\n    print(ans)\nelse:\n    print(kachra)", "import numpy as np\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef power(k, n, mod):\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n % 2 == 1:\n        return power(k, n - 1, mod) * k % mod\n    q = power(k, n // 2, mod)\n    return q * q % mod\n\ndef solve(m, n, k, mod):\n    if m == 2:\n        x = power(k, 2 * n, mod)\n        x = power(x, mod - 2, mod)\n        if k == 1:\n            print(x)\n            return None\n        dp = []\n        for i in range(n):\n            dp.append([0, 0])\n        dp[0][0] = k\n        dp[0][1] = 2 * k * (k - 1) % mod\n        for i in range(1, n):\n            dp[i][0] += (k - 1) * (dp[i - 1][0] + k * power(k, 2 * (i - 1), mod) % mod) % mod % mod\n            dp[i][0] %= mod\n            dp[i][0] += dp[i - 1][0]\n            dp[i][0] %= mod\n            dp[i][0] += 2 * dp[i - 1][1] % mod\n            dp[i][0] %= mod\n            dp[i][0] += (k - 2) * (dp[i - 1][1] + k * (k - 1) % mod * power(k, 2 * (i - 1), mod) % mod) % mod % mod\n            dp[i][0] %= mod\n            dp[i][1] += (k - 1) * (dp[i - 1][0] + k * power(k, 2 * (i - 1), mod) % mod) % mod % mod\n            dp[i][1] %= mod\n            dp[i][1] += (k - 1) * (dp[i - 1][0] + k * power(k, 2 * (i - 1), mod) % mod) % mod % mod\n            dp[i][1] %= mod\n            dp[i][1] += (k - 2) * (k - 1) % mod * (dp[i - 1][0] + 2 * k * power(k, 2 * (i - 1), mod) % mod) % mod % mod\n            dp[i][1] %= mod\n            dp[i][1] += dp[i - 1][1]\n            dp[i][1] %= mod\n            dp[i][1] += (k - 2) % mod * (dp[i - 1][1] + k * (k - 1) % mod * power(k, 2 * (i - 1), mod) % mod) % mod % mod\n            dp[i][1] %= mod\n            dp[i][1] += (k - 2) % mod * (dp[i - 1][1] + k * (k - 1) % mod * power(k, 2 * (i - 1), mod) % mod) % mod % mod\n            dp[i][1] %= mod\n            dp[i][1] += (k - 2) % mod * (dp[i - 1][1] + 2 * (k * (k - 1)) % mod * power(k, 2 * (i - 1), mod)) % mod % mod\n            dp[i][1] %= mod\n            dp[i][1] += (k - 1) % mod * (dp[i - 1][1] + 2 * (k * (k - 1)) % mod * power(k, 2 * (i - 1), mod)) % mod % mod\n            dp[i][1] %= mod\n            dp[i][1] += (k - 2) * max(k - 3, 0) % mod * (dp[i - 1][1] + 2 * (k * (k - 1)) % mod * power(k, 2 * (i - 1), mod) % mod) % mod % mod\n            dp[i][1] %= mod\n        ans = dp[n - 1][0] + dp[n - 1][1]\n        ans %= mod\n        ans *= x\n        ans %= mod\n        print(ans)\n        return None\n    else:\n        dp = [0 for i in range(n + 1)]\n        dp[1] = k\n        for i in range(2, n + 1):\n            dp[i] += dp[i - 1]\n            dp[i] %= mod\n            dp[i] += (k - 1) * (dp[i - 1] + power(k, i - 1, mod)) % mod\n            dp[i] %= mod\n        x = power(k, n, mod)\n        print(dp[n] * x % mod)\n        return None\nmod = 998244353\n(m, n, k) = map(int, input().split())\nq = k ** (m * n)\nQ = modInverse(q, mod)\nN = n * m - 1\nif m == 1:\n    a = k ** N\n    b = k + N * (k - 1)\n    P = a * b\n    print(P * Q % mod)\nelse:\n    solve(m, n, k, mod)", "def getints():\n    return list(map(int, input().split()))\nMOD = 998244353\n(m, n, k) = getints()\np = pow(k, MOD - 2, MOD)\nq = 1 + MOD - p\nif m == 1:\n    print((n * k - n + 1) * pow(k, MOD - 2, MOD) % MOD)\nelse:\n    print((p + 2 * q + (n - 1) * (2 * q * q + p * q * q)) % MOD)", "MOD = 998244353\n\ndef get_line_input():\n    return map(int, input().split())\n\ndef one_line(n, k):\n    return (n * k - n + 1, k)\n\ndef two_line(n, k):\n    return (2 * n * k ** 3 - 3 * n * k ** 2 + 2 * k ** 2 + n - 1, k ** 3)\n\ndef mod_inv(d):\n    return pow(d, MOD - 2, MOD)\n(m, n, k) = get_line_input()\n(numerator, denominator) = two_line(n, k) if m > 1 else one_line(n, k)\nprint(numerator * mod_inv(denominator) % MOD)", "(M, N, K) = map(int, input().split())\nmodulo = 998244353\npush = pow\ndemon = push(K, N, 998244353)\nmydenom = push(demon, 998244353 - 2, 998244353)\nhash = 2 * (K * (K - 1)) % modulo\nx = push(push(K, 2 * N, modulo), modulo - 2, modulo)\n\ndef saveCalc(K, i):\n    return K * push(K, 2 * (i - 1), modulo)\n\ndef saveCalc2(K, i):\n    return push(K, 2 * (i - 1), modulo)\nhash2 = K * (K - 1) % modulo\n\ndef calcTotal(prev0, prev1, x):\n    return (prev0 + prev1) % modulo * x % modulo\nif M == 1:\n    (prev, curr) = (K, 0)\n    for i in range(2, N + 1):\n        (prev, curr) = (((prev + push(K, i - 1, 998244353)) * (K - 1) % 998244353 + (curr + prev) % 998244353) % 998244353, 0)\n    print(prev * mydenom % 998244353)\nelif K == 1:\n    print(x)\nelse:\n    prev0 = K\n    prev1 = 2 * K * (K - 1) % modulo\n    curr0 = 0\n    curr1 = 0\n    for i in range(1, N):\n        curr0 = (((prev0 + (K - 1) * (prev0 + saveCalc(K, i) % modulo) % modulo % modulo) % modulo + 2 * prev1 % modulo) % modulo + (K - 2) * (prev1 + hash2 * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo\n        curr1 = ((((((((K - 1) * (K - 2) % modulo * (prev0 + 2 * saveCalc(K, i) % modulo) % modulo % modulo + 2 * ((K - 1) * (prev0 + saveCalc(K, i) % modulo) % modulo) % modulo % modulo) % modulo + prev1) % modulo + (K - 2) % modulo * (prev1 + hash2 * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo + (K - 2) % modulo * (prev1 + hash2 * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo + (K - 2) % modulo * (prev1 + hash * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo + (K - 1) % modulo * (prev1 + hash * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo + (K - 2) * max(0, K - 3) % modulo * (prev1 + hash * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo\n        prev0 = curr0\n        prev1 = curr1\n    print(calcTotal(prev0, prev1, x))", "(M, N, K) = map(int, input().split())\nmodulo = 998244353\npush = pow\ndemon = push(K, N, 998244353)\nmydenom = push(demon, 998244353 - 2, 998244353)\nhash = 2 * (K * (K - 1)) % modulo\nx = push(push(K, 2 * N, modulo), modulo - 2, modulo)\n\ndef saveCalc(K, i):\n    return K * push(K, 2 * (i - 1), modulo)\n\ndef saveCalc2(K, i):\n    return push(K, 2 * (i - 1), modulo)\nhash2 = K * (K - 1) % modulo\n\ndef calcTotal(prev0, prev1, x):\n    return (prev0 + prev1) % modulo * x % modulo\nif M == 1:\n    (prev, curr) = (K, 0)\n    for i in range(2, N + 1):\n        (prev, curr) = (((prev + push(K, i - 1, 998244353)) * (K - 1) % 998244353 + (curr + prev) % 998244353) % 998244353, 0)\n    print(prev * mydenom % 998244353)\nelif K == 1:\n    print(x)\nelse:\n    dp = [[0 for i in range(2)] for j in range(N + 1)]\n    prev0 = K\n    prev1 = 2 * K * (K - 1) % modulo\n    curr0 = 0\n    curr1 = 0\n    for i in range(1, N):\n        curr0 = (((prev0 + (K - 1) * (prev0 + saveCalc(K, i) % modulo) % modulo % modulo) % modulo + 2 * prev1 % modulo) % modulo + (K - 2) * (prev1 + hash2 * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo\n        curr1 = ((((((((K - 1) * (K - 2) % modulo * (prev0 + 2 * saveCalc(K, i) % modulo) % modulo % modulo + 2 * ((K - 1) * (prev0 + saveCalc(K, i) % modulo) % modulo) % modulo % modulo) % modulo + prev1) % modulo + (K - 2) % modulo * (prev1 + hash2 * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo + (K - 2) % modulo * (prev1 + hash2 * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo + (K - 2) % modulo * (prev1 + hash * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo + (K - 1) % modulo * (prev1 + hash * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo + (K - 2) * max(0, K - 3) % modulo * (prev1 + hash * saveCalc2(K, i) % modulo) % modulo % modulo) % modulo\n        prev0 = curr0\n        prev1 = curr1\n    print(calcTotal(prev0, prev1, x))", "m = 998244353\n\ndef pr(x, y):\n    if y == 0:\n        return 1\n    if y == 1:\n        return x\n    if y % 2 == 1:\n        return pr(x, y - 1) * x % m\n    w = pr(x, y // 2)\n    return w * w % m\n\ndef inv(z, d):\n    dN = 998244353\n    ex = dN - 2\n    while ex:\n        if ex & 1:\n            z = z * d % dN\n        d = d * d % dN\n        ex >>= 1\n    return z\n(mm, n, k) = map(int, input().split())\nop = 0\nif mm == 1:\n    d = [0 for i in range(0, n + 1)]\n    d[1] = k\n    for i in range(2, n + 1):\n        d[i] += d[i - 1]\n        d[i] %= m\n        d[i] += (k - 1) * (d[i - 1] + pr(k, i - 1)) % m\n        d[i] %= m\n    op = pr(k, n)\n    op = inv(d[n], op)\n    print(op % m)\nelse:\n    op = pr(k, 2 * n) % m\n    if k == 1:\n        print(op)\n    else:\n        d = [[0 for j in range(0, 2)] for k in range(0, n + 1)]\n        d[0][1] = (k - 1) * k * 2 % m\n        d[0][0] = k\n        for i in range(1, n):\n            d[i][0] = d[i][0] + (k - 1) * (d[i - 1][0] + k * pr(k, 2 * (i - 1)) % m % m) % m % m\n            d[i][0] = d[i][0] % m\n            d[i][0] = d[i][0] + d[i - 1][0]\n            d[i][0] = d[i][0] % m\n            d[i][0] = d[i][0] + 2 * d[i - 1][1] % m\n            d[i][0] = d[i][0] % m\n            d[i][0] = d[i][0] + (k - 2) * (d[i - 1][1] + k * (k - 1) % m * pr(k, 2 * (i - 1)) % m % m) % m % m\n            d[i][0] = d[i][0] % m\n            d[i][1] += (k - 1) * (d[i - 1][0] + k * pr(k, 2 * (i - 1)) % m % m) % m % m\n            d[i][0] = d[i][0] % m\n            d[i][1] += (k - 1) * (d[i - 1][0] + k * pr(k, 2 * (i - 1)) % m % m) % m % m\n            d[i][0] = d[i][0] % m\n            d[i][1] += (k - 1) * (k - 2) % m * (d[i - 1][0] + k * 2 * pr(k, 2 * (i - 1)) % m % m) % m % m\n            d[i][1] %= m\n            d[i][1] += d[i - 1][1]\n            d[i][1] %= m\n            d[i][1] += (k - 2) % m * (d[i - 1][1] + k * (k - 1) % m * pr(k, 2 * (i - 1)) % m % m) % m % m\n            d[i][1] %= m\n            d[i][1] += (k - 2) % m * (d[i - 1][1] + k * (k - 1) % m * pr(k, 2 * (i - 1)) % m % m) % m % m\n            d[i][1] %= m\n            d[i][1] += (k - 2) % m * (d[i - 1][1] + 2 * (k * (k - 1)) % m * pr(k, 2 * (i - 1)) % m % m) % m % m\n            d[i][1] %= m\n            d[i][1] += (k - 1) % m * (d[i - 1][1] + 2 * (k * (k - 1)) % m * pr(k, 2 * (i - 1)) % m % m) % m % m\n            d[i][1] %= m\n            d[i][1] += (k - 2) * max(k - 3, 0) % m * (d[i - 1][1] + 2 * (k * (k - 1)) % m * pr(k, 2 * (i - 1)) % m % m) % m % m\n            d[i][1] %= m\n        ww = d[n - 1][0] + d[n - 1][1]\n        ww %= m\n        op = inv(ww, op)\n        print(op % m)", "from fractions import Fraction\nmod = 998244353\n\ndef get_res(a, b):\n    return a % mod * (pow(b, mod - 2, mod) % mod) % mod\n\ndef power(a, b):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    if b % 2 == 1:\n        return power(a, b - 1) * a % mod\n    q = power(a, b / 2)\n    return q * q % mod\n\ndef solve_2(n, k):\n    x = power(k, 2 * n)\n    x = power(x, mod - 2)\n    if k == 1:\n        return x\n    dp = [[0] * 2 for i in range(n)]\n    dp[0][0] = k\n    dp[0][1] = 2 * k * (k - 1) % mod\n    for i in range(1, n):\n        dp[i][0] += (k - 1) * (dp[i - 1][0] + k * power(k, 2 * (i - 1)) % mod) % mod % mod\n        dp[i][0] %= mod\n        dp[i][0] += dp[i - 1][0]\n        dp[i][0] %= mod\n        dp[i][0] += 2 * dp[i - 1][1] % mod\n        dp[i][0] %= mod\n        dp[i][0] += (k - 2) * (dp[i - 1][1] + k * (k - 1) % mod * power(k, 2 * (i - 1)) % mod) % mod % mod\n        dp[i][0] %= mod\n        dp[i][1] += (k - 1) * (dp[i - 1][0] + k * power(k, 2 * (i - 1)) % mod) % mod % mod\n        dp[i][1] %= mod\n        dp[i][1] += (k - 1) * (dp[i - 1][0] + k * power(k, 2 * (i - 1)) % mod) % mod % mod\n        dp[i][1] %= mod\n        dp[i][1] += (k - 2) * (k - 1) % mod * (dp[i - 1][0] + 2 * k * power(k, 2 * (i - 1)) % mod) % mod % mod\n        dp[i][1] %= mod\n        dp[i][1] += dp[i - 1][1]\n        dp[i][1] %= mod\n        dp[i][1] += (k - 2) % mod * (dp[i - 1][1] + k * (k - 1) % mod * power(k, 2 * (i - 1)) % mod) % mod % mod\n        dp[i][1] %= mod\n        dp[i][1] += (k - 2) % mod * (dp[i - 1][1] + k * (k - 1) % mod * power(k, 2 * (i - 1)) % mod) % mod % mod\n        dp[i][1] %= mod\n        dp[i][1] += (k - 2) % mod * (dp[i - 1][1] + 2 * (k * (k - 1)) % mod * power(k, 2 * (i - 1)) % mod) % mod % mod\n        dp[i][1] %= mod\n        dp[i][1] += (k - 1) % mod * (dp[i - 1][1] + 2 * (k * (k - 1)) % mod * power(k, 2 * (i - 1)) % mod) % mod % mod\n        dp[i][1] %= mod\n        dp[i][1] += (k - 2) * max(k - 3, 0) % mod * (dp[i - 1][1] + 2 * (k * (k - 1)) % mod * power(k, 2 * (i - 1)) % mod) % mod % mod\n        dp[i][1] %= mod\n    ans = dp[n - 1][0] + dp[n - 1][1]\n    ans %= mod\n    ans *= x\n    ans %= mod\n    return ans\n\ndef solve_1(n, k):\n    ans = 1\n    k_inv = get_res(1, k)\n    k_inv_r = 1\n    for i in range(n - 1):\n        val = Fraction(i + 1, n - i - 1) * Fraction(n - i, k) * Fraction(k - 1, n - i - 1)\n        ans *= get_res(val.numerator, val.denominator)\n        ans %= mod\n        k_inv_r *= k_inv\n        k_inv_r %= mod\n        ans += k_inv_r\n        ans %= mod\n    return ans\n(m, n, k) = map(int, input().split())\nif m == 1:\n    print(solve_1(n, k))\nelif m == 2:\n    print(solve_2(n, k))\nelse:\n    print('UNPOSSIBLE!')", "def mod1(a):\n    return a % 998244353\n\ndef check(a, b):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    if b % 2 == 1:\n        return mod1(check(a, b - 1) * a)\n    c = check(a, int(b / 2))\n    return mod1(c * c)\n(M, N, K) = [int(x) for x in input().split()]\nif M == 2:\n    x = check(K, 2 * N)\n    x = check(x, 998244351)\n    if K == 1:\n        print(x)\n    else:\n        sun = []\n        for i in range(N):\n            sun.append([0, 0])\n        (sun[0][0], sun[0][1], k) = (K, mod1(2 * K * (K - 1)), K)\n        for i in range(1, N):\n            sun[i][0] = mod1(sun[i][0] + mod1((k - 1) * mod1(sun[i - 1][0] + mod1(k * check(k, 2 * (i - 1))))))\n            sun[i][0] = mod1(sun[i][0] + sun[i - 1][0])\n            sun[i][0] = mod1(sun[i][0] + mod1(2 * sun[i - 1][1]))\n            sun[i][0] = mod1(sun[i][0] + mod1((k - 2) * mod1(sun[i - 1][1] + mod1(mod1(k * (k - 1)) * check(k, 2 * (i - 1))))))\n            sun[i][1] = mod1(sun[i][1] + mod1((k - 1) * mod1(sun[i - 1][0] + mod1(k * check(k, 2 * (i - 1))))))\n            sun[i][1] = mod1(sun[i][1] + mod1((k - 1) * mod1(sun[i - 1][0] + mod1(k * check(k, 2 * (i - 1))))))\n            sun[i][1] = mod1(sun[i][1] + mod1(mod1((k - 2) * (k - 1)) * mod1(sun[i - 1][0] + mod1(2 * k * check(k, 2 * (i - 1))))))\n            sun[i][1] = mod1(sun[i][1] + sun[i - 1][1])\n            sun[i][1] = mod1(sun[i][1] + mod1(mod1(k - 2) * (sun[i - 1][1] + mod1(mod1(mod1(k * (k - 1))) * check(k, 2 * (i - 1))))))\n            sun[i][1] = mod1(sun[i][1] + mod1(mod1(k - 2) * mod1(sun[i - 1][1] + mod1(mod1(k * (k - 1)) * check(k, 2 * (i - 1))))))\n            sun[i][1] = mod1(sun[i][1] + mod1(mod1(k - 2) * mod1(sun[i - 1][1] + mod1(2 * mod1(k * (k - 1)) * check(k, 2 * (i - 1))))))\n            sun[i][1] = mod1(sun[i][1] + mod1(mod1(k - 1) * mod1(sun[i - 1][1] + mod1(2 * mod1(k * (k - 1)) * check(k, 2 * (i - 1))))))\n            sun[i][1] = mod1(sun[i][1] + mod1(mod1((k - 2) * max(k - 3, 0)) * mod1(sun[i - 1][1] + mod1(2 * mod1(k * (k - 1)) * check(k, 2 * (i - 1))))))\n        print(mod1(mod1(sun[N - 1][0] + sun[N - 1][1]) * x))\nelse:\n    sun = [0] * (N + 1)\n    sun[1] = K\n    for i in range(2, N + 1):\n        sun[i] = mod1(sun[i] + sun[i - 1])\n        sun[i] = mod1(sun[i] + mod1((K - 1) * (sun[i - 1] + check(K, i - 1))))\n    x = check(check(K, N), 998244351)\n    print(mod1(sun[N] * x))", "N = int(100000.0 + 10)\nmod = 998244353\n\ndef exponent(X, Y):\n    r = 1\n    X = int(X % mod)\n    while Y > 0:\n        if Y & 1:\n            r = r * X % mod\n        Y = Y >> 1\n        X = X * X % mod\n    return r\n\ndef inverse(X):\n    return exponent(X, mod - 2)\n\ndef additon(x, y):\n    return (x % mod + y % mod) % mod\n\ndef multiply(x, y):\n    x %= mod\n    y %= mod\n    return (x * y % mod + mod) % mod\n\ndef awseome(m, n, k):\n    ans = 0\n    b = [0 for i in range(N)]\n    b[0] = 1\n    for i in range(1, N):\n        b[i] = multiply(i, b[i - 1])\n    n -= 1\n    res = 1\n    for i in range(0, n + 1):\n        sum = multiply(b[n], multiply(inverse(b[i]), inverse(b[n - i])))\n        sum = multiply(sum, i + 1)\n        ans = additon(ans, multiply(sum, res))\n        res = multiply(res, k - 1)\n    (num, den) = (0, k)\n    num = multiply(ans, k)\n    while n:\n        den = multiply(den, k)\n        n -= 1\n    ans = multiply(num, inverse(den))\n    print(ans)\n\ndef superb(m, n, k):\n    b = [0 for i in range(N)]\n    b[1] = multiply(k, 2 * k - 1)\n    c = multiply(k, k)\n    d = k\n    for i in range(2, n + 1):\n        b[i] = multiply(b[i - 1], c)\n        x = multiply(k - 1, 3)\n        y = multiply((k - 1) * (k - 2), 2)\n        z = multiply(x + y, d)\n        b[i] = additon(b[i], z)\n        x = multiply(k - 2, 3)\n        y = multiply((k - 1) * (k - 2) + 1, 2)\n        z = multiply(x + y, (k - 1) * d)\n        b[i] = additon(b[i], z)\n        d = multiply(c, d)\n    num = b[n]\n    den = 1\n    for _ in range(0, m * n):\n        den = multiply(den, k)\n    ans = multiply(num, inverse(den))\n    print(ans)\n(m, n, k) = map(int, input().split())\nif m == 1:\n    awseome(m, n, k)\nelse:\n    superb(m, n, k)", "import itertools\nmod = 998244353\n\ndef fun1(a, b):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    if b % 2 == 1:\n        return fun1(a, b - 1) * a % mod\n    q = fun1(a, b / 2)\n    return q * q % mod\n(m, n, k) = map(int, input().split())\nif m == 2:\n    x = fun1(k, 2 * n)\n    x = fun1(x, mod - 2)\n    if k == 1:\n        print(x)\n        exit()\n    my_buffer = []\n    for i in range(n):\n        my_buffer.append([0, 0])\n    my_buffer[0][0] = k\n    my_buffer[0][1] = 2 * k * (k - 1) % mod\n    for i in range(1, n):\n        my_buffer[i][0] += (k - 1) * (my_buffer[i - 1][0] + k * fun1(k, 2 * (i - 1)) % mod) % mod % mod\n        my_buffer[i][0] %= mod\n        my_buffer[i][0] += my_buffer[i - 1][0]\n        my_buffer[i][0] %= mod\n        my_buffer[i][0] += 2 * my_buffer[i - 1][1] % mod\n        my_buffer[i][0] %= mod\n        my_buffer[i][0] += (k - 2) * (my_buffer[i - 1][1] + k * (k - 1) % mod * fun1(k, 2 * (i - 1)) % mod) % mod % mod\n        my_buffer[i][0] %= mod\n        my_buffer[i][1] += (k - 1) * (my_buffer[i - 1][0] + k * fun1(k, 2 * (i - 1)) % mod) % mod % mod\n        my_buffer[i][1] %= mod\n        my_buffer[i][1] += (k - 1) * (my_buffer[i - 1][0] + k * fun1(k, 2 * (i - 1)) % mod) % mod % mod\n        my_buffer[i][1] %= mod\n        my_buffer[i][1] += (k - 2) * (k - 1) % mod * (my_buffer[i - 1][0] + 2 * k * fun1(k, 2 * (i - 1)) % mod) % mod % mod\n        my_buffer[i][1] %= mod\n        my_buffer[i][1] += my_buffer[i - 1][1]\n        my_buffer[i][1] %= mod\n        my_buffer[i][1] += (k - 2) % mod * (my_buffer[i - 1][1] + k * (k - 1) % mod * fun1(k, 2 * (i - 1)) % mod) % mod % mod\n        my_buffer[i][1] %= mod\n        my_buffer[i][1] += (k - 2) % mod * (my_buffer[i - 1][1] + k * (k - 1) % mod * fun1(k, 2 * (i - 1)) % mod) % mod % mod\n        my_buffer[i][1] %= mod\n        my_buffer[i][1] += (k - 2) % mod * (my_buffer[i - 1][1] + 2 * (k * (k - 1)) % mod * fun1(k, 2 * (i - 1)) % mod) % mod % mod\n        my_buffer[i][1] %= mod\n        my_buffer[i][1] += (k - 1) % mod * (my_buffer[i - 1][1] + 2 * (k * (k - 1)) % mod * fun1(k, 2 * (i - 1)) % mod) % mod % mod\n        my_buffer[i][1] %= mod\n        my_buffer[i][1] += (k - 2) * max(k - 3, 0) % mod * (my_buffer[i - 1][1] + 2 * (k * (k - 1)) % mod * fun1(k, 2 * (i - 1)) % mod) % mod % mod\n        my_buffer[i][1] %= mod\n    ans = my_buffer[n - 1][0] + my_buffer[n - 1][1]\n    ans %= mod\n    ans *= x\n    ans %= mod\n    print(ans)\nelse:\n    my_buffer = [0 for i in range(n + 1)]\n    my_buffer[1] = k\n    for i in range(2, n + 1):\n        my_buffer[i] += my_buffer[i - 1]\n        my_buffer[i] %= mod\n        my_buffer[i] += (k - 1) * (my_buffer[i - 1] + fun1(k, i - 1)) % mod\n        my_buffer[i] %= mod\n    x = fun1(k, n)\n    x = fun1(x, mod - 2)\n    print(my_buffer[n] * x % mod)", "mod = 998244353\narr = []\narr.append(1)\nfor i in range(1, 250001):\n    arr.append(arr[i - 1] * i % mod)\n\ndef pwr(p, q):\n    p = p % mod\n    res = 1\n    while q:\n        if q % 2:\n            res = res * p\n        p *= p\n        q //= 2\n        p %= mod\n        res %= mod\n    return res\n\ndef nCr(n, r):\n    x = n - r\n    a = arr[n]\n    b = arr[r]\n    c = arr[x]\n    res = a\n    res = res * pwr(b, mod - 2) % mod\n    res = res * pwr(c, mod - 2) % mod\n    return res\n(M, N, K) = [int(x) for x in input().split(' ')]\nans = 0\ntemp = 0\nfor i in range(1, M * N + 1):\n    temp = K * pwr(K - 1, i - 1)\n    temp %= mod\n    temp *= i\n    temp %= mod\n    temp *= nCr(N * M - 1, i - 1)\n    temp %= mod\n    ans += temp\n    ans %= mod\nif M != 1:\n    temp = (N - 1) * ((pwr(K, 2) - 1 + mod) % mod)\n    temp %= mod\n    temp += mod\n    temp %= mod\n    temp *= pwr(K, 2 * N - 3)\n    temp %= mod\n    ans -= temp\n    ans += mod\n    ans %= mod\ntemp = pwr(K, M * N)\nans *= pwr(temp, mod - 2)\nans %= mod\nprint(ans)", "def calculate(p, q):\n    mod = 998244353\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\nmod = 998244353\n(m, n, k) = map(int, input().split())\nif m == 1:\n    ans = (k * n % mod - (n - 1)) % mod\nelse:\n    total = 1\n    for i in range(0, 2 * n):\n        total = total * k % mod\n    powm = k * k % mod * k % mod\n    a = (2 * k - 1) * total % mod * powm\n    b = (n - 1) * (((2 * k - 3) * (k * k) % mod + 1) * total) % mod % mod * k % mod\n    ans = (a + b) % mod\n    k = total * powm % mod * k % mod\nprint(calculate(int(ans), int(k)))", "import math\nimport math\n\ndef mI(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nN = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n(a1, b2, c3) = map(int, input().split())\nut = 998244353\nInverseofNumber(ut)\nInverseofFactorial(ut)\nfactorial(ut)\nato = 0\nif a1 == 1:\n    for alp in range(1, b2 + 1):\n        ad = Binomial(b2 - 1, alp - 1, ut)\n        ba = pow(c3 - 1, alp - 1, ut)\n        ca = c3 * alp % ut\n        ato += ad * ba % ut * ca % ut\n    f = pow(c3, b2, ut)\n    print(int(ato * mI(f, ut) % ut))\nelse:\n    f = 1\n    ato = 0\n    ato2 = 0\n    alp = 0\n    for alp in range(1, b2 + 1):\n        if f == 1:\n            ato = c3 ** 2\n            ato2 = c3 ** 2 + c3 * (c3 - 1)\n            f = 0\n        else:\n            pre_v = ato\n            ato2 = (ato % ut * (c3 - 1) % ut + ato2 % ut * c3 ** 1 % ut) % ut\n            ato = ato % ut * c3 ** 1 % ut\n            ato2 = (c3 - 2) % ut * ((ato - pre_v + ut) % ut) % ut + pre_v % ut * (c3 - 1) % ut + ato2 % ut * c3 ** 1 % ut\n            ato = ato % ut * c3 ** 1 % ut\n            ato2 = (ato2 - (pre_v + ut - pre_v * mI(c3, ut)) % ut) % ut\n    f = mI(ato % ut, ut)\n    print(ato2 % ut * f % ut)", "def calculate(p, q):\n    mod = 998244353\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n(m, n, k) = map(int, input().split())\nif m == 1:\n    ans = k + (n - 1) * (k - 1)\n    print(calculate(ans, k))\nelse:\n    val1 = k + 2 * k * (k - 1)\n    if n == 1:\n        print(calculate(val1, k ** 2))\n    else:\n        x = 2 * k ** 2 - k\n        Y = 3 * k * (k - 1) + 5 * k * (k - 1) * (k - 2) + 2 * k * (k - 1) ** 2 + 2 * k * (k - 1) * (k - 2) ** 2\n        ans = k ** 2 * x + (n - 1) * Y\n        print(calculate(ans, k ** 4))", "mod = 998244353\n\ndef calculate(p, q):\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n\ndef M1(N, K):\n    DP = [[0 for _ in range(N + 1)] for __ in range(N + 1)]\n    for i in range(1, N + 1):\n        DP[i][1] = K\n    for i in range(2, N + 1):\n        for j in range(1, N + 1):\n            DP[i][j] = (DP[i - 1][j] + DP[i - 1][j - 1] * (K - 1)) % mod\n    num = 0\n    for j in range(1, N + 1):\n        num = (num + DP[N][j] * j) % mod\n    denom = pow(K, N, mod)\n    return calculate(num, denom)\n\ndef solve(M, N, K):\n    DP = [[[0, 0] for _ in range(M * N + 1)] for __ in range(N + 1)]\n    for i in range(1, N + 1):\n        DP[i][1][0] = K\n        DP[i][1][1] = 0\n    DP[1][2][1] = K * (K - 1)\n    for i in range(2, N + 1):\n        j = 1\n        DP[i][j][0] = DP[i - 1][j][0] + 2 * DP[i - 1][j][1] + (K - 1) * DP[i - 1][j - 1][0] + (K - 2) * DP[i - 1][j - 1][1]\n        DP[i][j][1] = 2 * (K - 1) * DP[i - 1][j - 1][0] + DP[i - 1][j][1] + 2 * (K - 2) * DP[i - 1][j - 1][1]\n        for j in range(2, M * N + 1):\n            DP[i][j][0] = DP[i - 1][j][0] + 2 * DP[i - 1][j][1] + (K - 1) * DP[i - 1][j - 1][0] + (K - 2) * DP[i - 1][j - 1][1]\n            DP[i][j][1] = 2 * (K - 1) * DP[i - 1][j - 1][0] + (K - 1) * (K - 2) * DP[i - 1][j - 2][0] + DP[i - 1][j][1] + 2 * (K - 2) * DP[i - 1][j - 1][1] + ((K - 2) * (K - 3) + 1 + 2 * (K - 2)) * DP[i - 1][j - 2][1]\n    return DP\n(M, N, K) = list(map(int, input().split()))\nif M == 1:\n    smallans = M1(2, K)\n    print((smallans * (N - 1) - (N - 2)) % mod)\nelse:\n    DP = solve(2, 3, K)\n    (num1, num2, num3) = (0, 0, 0)\n    for j in range(1, 7):\n        num1 = num1 + sum(DP[1][j]) * j\n        num2 = num2 + sum(DP[2][j]) * j\n        num3 = num3 + sum(DP[3][j]) * j\n    denom1 = pow(K, M * 1)\n    denom2 = pow(K, M * 2)\n    denom3 = pow(K, M * 3)\n    if N == 1:\n        print(calculate(num1, denom1))\n    else:\n        ans = calculate(num2, denom2)\n        diff = calculate(num3, denom3) - calculate(num2, denom2)\n        for i in range(2, N):\n            ans = (ans + diff) % mod\n        print(ans)", "def calculate(p, q):\n    mod = 998244353\n    expo = 0\n    expo = mod - 2\n    while expo:\n        if expo & 1:\n            p = p * q % mod\n        q = q * q % mod\n        expo >>= 1\n    return p\n(m, n, k) = map(int, input().split())\nif m == 1:\n    num = n * (k - 1) + 1\n    den = k\nelse:\n    num = k * k * (2 * k - 1) + (n - 1) * ((k - 1) * (k - 1) * (5 + 2 * (k - 2)))\n    den = k ** 3\nprint(calculate(num, den))", "(m, n, k) = list(map(int, input().strip().split()))\nif m == 1:\n    num = n * k - n + 1\n    de = k\nelse:\n    num = 2 * n * k ** 3 - 3 * n * k ** 2 + 2 * k ** 2 + n - 1\n    de = k ** 3\nmod = 998244353\nprint(num * pow(de, mod - 2, mod) % mod)", "MOD = 998244353\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a):\n    (g, x, y) = egcd(a, MOD)\n    if g != 1:\n        raise Exception('modinv doesnt exist')\n    else:\n        return x % MOD\n\ndef add(x, y):\n    return (x + y) % MOD\n\ndef mul(x, y):\n    return x * y % MOD\n\ndef div(x, y):\n    x %= MOD\n    y %= MOD\n    return x * modinv(y) % MOD\n\ndef solve_1(n, k):\n    ans = 1\n    for i in range(1, n):\n        ans = (modinv(k) * ans + (k - 1) * modinv(k) * (ans + 1)) % MOD\n    return ans\n\ndef solve_2(n, k):\n    ans = [[0 for i in range(2)] for j in range(n)]\n    ans[0][0] = 1\n    ans[0][1] = 2\n    for i in range(1, n):\n        t = 0\n        t = add(t, mul(div(k - 1, k * k), ans[i - 1][1] + 0))\n        t = add(t, mul(div(k - 1, k * k), ans[i - 1][1] + 0))\n        t = add(t, mul(div((k - 1) * (k - 2), k * k), ans[i - 1][1] + 1))\n        t = add(t, mul(div(k - 1, k * k), ans[i - 1][0] + 1))\n        t = add(t, mul(div(1, k * k), ans[i - 1][0] + 0))\n        ans[i][0] = t\n        t1 = add(mul(div(2, k), ans[i - 1][0] + 1), mul(div(k - 2, k), ans[i - 1][0] + 2))\n        t2 = 0\n        t2 = add(t2, mul(div(1, k * (k - 1)), ans[i - 1][1] + 2))\n        t2 = add(t2, mul(div(1, k * (k - 1)), ans[i - 1][1] + 0))\n        t2 = add(t2, mul(div(k - 2, k * (k - 1)), ans[i - 1][1] + 1))\n        t2 = add(t2, mul(div(k - 2, k * (k - 1)), ans[i - 1][1] + 1))\n        t2 = add(t2, mul(div(k - 2, k * (k - 1)), ans[i - 1][1] + 2))\n        t2 = add(t2, mul(div(k - 2, k * (k - 1)), ans[i - 1][1] + 2))\n        if k >= 3:\n            t2 = add(t2, mul(div(mul(k - 2, k - 3), k * (k - 1)), ans[i - 1][1] + 2))\n        ans[i][1] = add(mul(div(k, k * k), t1), mul(div(k * k - k, k * k), t2))\n    return add(mul(div(k, k * k), ans[n - 1][0]), mul(div(k * k - k, k * k), ans[n - 1][1]))\n\ndef solve(m, n, k):\n    if k == 1:\n        return 1\n    if m == 1:\n        return solve_1(n, k)\n    else:\n        return solve_2(n, k)\n(m, n, k) = list(map(int, input().split()))\nprint(solve(m, n, k))", "MOD = 998244353\n\ndef printResult(num, den, MOD):\n    num = num % MOD\n    print(num * pow(den, MOD - 2, MOD) % MOD)\n(M, N, K) = map(int, input().split())\n(M, N) = (min(M, N), max(M, N))\nif K == 1:\n    print(1)\nelif M == 1:\n    if N == 1:\n        print(1)\n    else:\n        printResult(N * (K - 1) + 1, K, MOD)\nelse:\n    printResult(K ** 2 * (2 * K - 1) + (N - 1) * (2 * K + 1) * (K - 1) ** 2, K ** 3, MOD)", "(M, N, K) = map(int, input().split())\nif M == 1:\n    P = N * K - N + 1\n    Q = K\nelse:\n    P = 2 * N * K ** 3 + (2 - 3 * N) * K ** 2 + N - 1\n    Q = K ** 3\nprint(int(P * pow(Q, 998244353 - 2, 998244353) % 998244353))", "b = 998244353\n(m, n, k) = map(int, input().split())\n\ndef pow(base, power):\n    if power == 0:\n        return 1\n    s = pow(base, power // 2)\n    return s * s * (base if power % 2 else 1) % b\nkinv = pow(k, b - 2)\nif m == 1:\n    ans = 1 + (n - 1) * (k - 1) * kinv\nelse:\n    ans = (2 * k - 1) * kinv + (n - 1) * (2 * k * k - k - 1) * (k - 1) * kinv * kinv * kinv\nprint(ans % b)", "import sys\nrow = list((int(x) for x in input().split()))\nM = row[0]\nN = row[1]\nK = row[2]\np = 998244353\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\na = 3\nm = 11\nif K == 1:\n    print(1)\nelif M == 2:\n    T = []\n    C = []\n    C.append([K, K * (K - 1)])\n    T.append([K, 2 * K * (K - 1)])\n    den = K * K\n    den = den % p\n    for n in range(1, N):\n        A1 = C[n - 1][0]\n        A2 = C[n - 1][1]\n        B1 = T[n - 1][0]\n        B2 = T[n - 1][1]\n        C1 = (A1 + A2) * K\n        C2 = (A1 + A2) * K * (K - 1)\n        D1 = K * (B1 + B2) + (K - 1) * A1 + (K - 2) * A2\n        D2 = K * (K - 1) * (B1 + B2) + 2 * (K - 1) * (K - 1) * (A1 + A2)\n        C1 = C1 % p\n        C2 = C2 % p\n        D1 = D1 % p\n        D2 = D2 % p\n        den = den * K * K\n        den = den % p\n        C.append([C1, C2])\n        T.append([D1, D2])\n    num = (T[-1][0] + T[-1][1]) % p\n    prod = num * modInverse(den, p)\n    prod = prod % p\n    print(prod)\nelse:\n    T = []\n    C = []\n    C.append(K)\n    T.append(K)\n    den = K\n    den = den % p\n    for n in range(1, N):\n        A = C[n - 1]\n        B = T[n - 1]\n        C1 = A * K\n        D1 = B * K + (K - 1) * A\n        C1 = C1 % p\n        D1 = D1 % p\n        den = den * K\n        den = den % p\n        C.append(C1)\n        T.append(D1)\n    num = T[-1] % p\n    prod = num * modInverse(den, p)\n    prod = prod % p\n    print(prod)", "from math import gcd\n\ndef f(x, y):\n    m = 998244353\n    e = m - 2\n    while e > 0:\n        if e % 2 == 1:\n            x = x * y % m\n        y = y * y % m\n        e >>= 1\n    return x\n[m, n, k] = input().split()\nm = int(m)\nn = int(n)\nk = int(k)\nif m == 1:\n    x = (n - 1) * (k - 1) + k\n    print(f(x, k))\nelif n == 1:\n    print(f(2 * k - 1, k))\nelse:\n    x = 2 * n * k * k * k - k * k * (3 * n - 2) + n - 1\n    print(f(x, k * k * k))", "from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nmod = pow(10, 9) + 7\nmod2 = 998244353\n\ndef inp():\n    return stdin.readline().strip()\n\ndef out(var, end='\\n'):\n    stdout.write(str(var) + '\\n')\n\ndef outa(*var, end='\\n'):\n    stdout.write(' '.join(map(str, var)) + end)\n\ndef lmp():\n    return list(mp())\n\ndef mp():\n    return map(int, inp().split())\n\ndef smp():\n    return map(str, inp().split())\n\ndef l1d(n, val=0):\n    return [val for i in range(n)]\n\ndef l2d(n, m, val=0):\n    return [l1d(n, val) for j in range(m)]\n\ndef remadd(x, y):\n    return 1 if x % y else 0\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\ndef isprime(x):\n    if x <= 1:\n        return False\n    if x in (2, 3):\n        return True\n    if x % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return False\n    return True\n\ndef modinv(A, C):\n    if A == 0:\n        return (0, 1)\n    (x1, y1) = modinv(C % A, A)\n    x = y1 - C // A * x1\n    y = x1\n    return (x, y)\n(m, n, k) = mp()\nif m == 1:\n    num = n * k - n + 1\n    den = k\nelse:\n    num = pow(k, 2, mod2) * (2 * k - 1) + (n - 1) * (2 * pow(k - 1, 3, mod2) + 3 * pow(k - 1, 2, mod2))\n    den = pow(k, 3, mod2)\n(x, y) = modinv(den, mod2)\nx = x + mod2 if x < 0 else x\nprint(num % mod2 * x % mod2)", "from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nmod = pow(10, 9) + 7\nmod2 = 998244353\n\ndef inp():\n    return stdin.readline().strip()\n\ndef out(var, end='\\n'):\n    stdout.write(str(var) + '\\n')\n\ndef outa(*var, end='\\n'):\n    stdout.write(' '.join(map(str, var)) + end)\n\ndef lmp():\n    return list(mp())\n\ndef mp():\n    return map(int, inp().split())\n\ndef smp():\n    return map(str, inp().split())\n\ndef l1d(n, val=0):\n    return [val for i in range(n)]\n\ndef l2d(n, m, val=0):\n    return [l1d(n, val) for j in range(m)]\n\ndef remadd(x, y):\n    return 1 if x % y else 0\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\ndef isprime(x):\n    if x <= 1:\n        return False\n    if x in (2, 3):\n        return True\n    if x % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return False\n    return True\n\ndef modinv(A, C):\n    if A == 0:\n        return (0, 1)\n    (x1, y1) = modinv(C % A, A)\n    x = y1 - C // A * x1\n    y = x1\n    return (x, y)\n(m, n, k) = mp()\nif m == 1:\n    num = n * k - n + 1\n    den = k\nelse:\n    num = k * k * (2 * k - 1) + (n - 1) * (2 * (k - 1) ** 3 + 3 * (k - 1) ** 2)\n    den = pow(k, 3, mod2)\n(x, y) = modinv(den, mod2)\nx = x + mod2 if x < 0 else x\nprint(num % mod2 * x % mod2)", "p = 998244353\n\ndef inverse(x):\n    return pow(x, p - 2, p)\n\ndef e_single(N, K):\n    ret = 1 + (N - 1) * (K - 1) * inverse(K)\n    ret = ret % p\n    return ret\n\ndef e_double(N, K):\n    c0 = pow(inverse(K), 3, p)\n    c1 = (K - 1) * c0 % p\n    c2 = (K - 1) * (K - 2) * c0 % p\n    c3 = ((K - 1) * (K - 2) * (K - 2) + (K - 1) * (K - 1)) * c0 % p\n    p0 = (c0 + 3 * c1) % p\n    p1 = (3 * c1 + 3 * c2) % p\n    p2 = (c2 + c3) % p\n    e = e_single(2, K)\n    for _ in range(N - 1):\n        e = (e * p0 + (e + 1) * p1 + (e + 2) * p2) % p\n    return e\n\ndef solve(M, N, K):\n    if M == 1:\n        return e_single(N, K)\n    elif M == 2:\n        return e_double(N, K)\n    else:\n        return 1 / 0\n\ndef io():\n    (M, N, K) = map(int, input().split())\n    print(solve(M, N, K))\nio()", "from sys import stdin, stdout\ninput = stdin.readline\nm = 998244353\n\ndef check(arr):\n    global n, count\n    mat = [arr[:n], arr[n:]]\n    seen = {}\n    for j in range(n):\n        for i in range(2):\n            seen[i, j] = 0\n    for i in range(2):\n        for j in range(n):\n            if seen[i, j]:\n                continue\n            count = (count + 1) % m\n            stack = []\n            stack.append((i, j))\n            while len(stack):\n                start = stack.pop()\n                seen[start] = 1\n                x = start[0]\n                y = start[1]\n                if x == 0:\n                    if seen[x + 1, y] == 0 and mat[x + 1][y] == mat[x][y]:\n                        stack.append((x + 1, y))\n                elif seen[x - 1, y] == 0 and mat[x - 1][y] == mat[x][y]:\n                    stack.append((x - 1, y))\n                if y - 1 >= 0:\n                    if seen[x, y - 1] == 0 and mat[x][y - 1] == mat[x][y]:\n                        stack.append((x, y - 1))\n                if y + 1 < n:\n                    if seen[x, y + 1] == 0 and mat[x][y + 1] == mat[x][y]:\n                        stack.append((x, y + 1))\n\ndef Backtrack(arr, i):\n    global n, k\n    if i == 2 * n:\n        check(arr)\n        return\n    for j in range(1, k + 1):\n        arr[i] = j\n        Backtrack(arr, i + 1)\nt = 1\nfor _ in range(t):\n    (x, n, k) = map(int, input().split())\n    count = 0\n    if x == 2:\n        sigma = 0\n        p1 = 1 + 2 * (2 * k - 2)\n        p1 %= m\n        p1 += (k ** 2 - 2 * k + 1 - k + 1) * 3\n        p1 %= m\n        p1 += (k - 1) * 2\n        p1 %= m\n        p2 = 2\n        p2 += (2 * k - 2 - 2) * 3\n        p2 %= m\n        p2 += 2 * 2\n        p2 += (k ** 2 - 2 * k + 1 - k + 2) * 4\n        p2 %= m\n        p2 += (k - 2) * 3\n        p2 %= m\n        for i in range(1, n):\n            temp = 0\n            sigma = ((pow(k, 2, m) - k) % m * p2 % m + k * p1 % m) % m\n            v1 = p2 * (2 * k - 2)\n            v1 %= m\n            v1 += p1\n            v1 %= m\n            v1 += (k * k - 2 * k + 1 - k + 1) % m * (p2 + pow(k, 2 * i, m)) % m % m\n            v1 += (k - 1) * (p1 + pow(k, 2 * i, m)) % m % m\n            v2 = p2\n            v2 += (2 * k - 4) * (p2 + pow(k, 2 * i, m)) % m % m\n            v2 += 2 * (p1 + pow(k, 2 * i, m)) % m\n            v2 += (k * k - 2 * k + 1 - k + 2) % m * (p2 + 2 * pow(k, 2 * i, m)) % m % m\n            v2 += (k - 2) * (p1 + 2 * pow(k, 2 * i, m)) % m % m\n            p1 = v1\n            p2 = v2\n        p = sigma\n        q = pow(k, 2 * n, m)\n        ans = p * pow(q, m - 2, m) % m\n        print(ans)\n    else:\n        p = 1\n        term1 = 1\n        term2 = 1\n        pivot = n - 1\n        d = 1\n        for i in range(n - 1):\n            term1 = term1 * (k - 1) % m\n            term2 = term2 * pivot % m\n            term2 = term2 * pow(d, m - 2, m) % m\n            pivot -= 1\n            d += 1\n            p = (p + term1 * term2 * (i + 2) % m) % m\n        p = p * k % m\n        q = pow(k, n, m)\n        ans = p * pow(q, m - 2, m) % m\n        print(ans)", "(M, N, K) = map(int, input().split())\nP = 998244353\n\ndef main():\n    Kminus1tothe = [1] * (2 * N)\n    Ktotheminus = [1] * (2 * N)\n    Kinv = invert_mod(K, P)\n    for i in range(1, 2 * N):\n        Kminus1tothe[i] = (K - 1) * Kminus1tothe[i - 1] % P\n        Ktotheminus[i] = Kinv * Ktotheminus[i - 1] % P\n    accum = 1 + (N - 1) * Kminus1tothe[1] * Ktotheminus[1]\n    if M == 2:\n        for l in range(1, N - 1):\n            accum += (N - 1 - l) * Kminus1tothe[l + 2] * Ktotheminus[2 * l + 1]\n        for l in range(1, N):\n            accum += 2 * Kminus1tothe[l + 1] * Ktotheminus[2 * l]\n        accum += Kminus1tothe[N] * Ktotheminus[2 * N - 1]\n        for l in range(3, N + 1):\n            accum -= (N - l + 1) * Kminus1tothe[l - 2] * Ktotheminus[2 * l - 1]\n    print(accum % P)\n\ndef bezout_solver(a, b):\n    if a < b:\n        (y, x) = bezout_solver(b, a)\n        return (x, y)\n    elif b == 0:\n        return (1, 0)\n    (q, r) = (a // b, a % b)\n    (z, x) = bezout_solver(b, r)\n    return (x, z - q * x)\n\ndef invert_mod(num, modulus):\n    return bezout_solver(modulus, num)[1] % modulus\nmain()", "MOD = 998244353\n\ndef inv(x):\n    (y, res) = (MOD - 2, 1)\n    while y > 0:\n        if y & 1:\n            res = res * x % MOD\n        y >>= 1\n        x = x * x % MOD\n    return res\n(M, N, K) = map(int, input().split())\nif M == 1:\n    print((1 + (N - 1) * (K - 1) * inv(K)) % MOD)\nelse:\n    print((K * K * (2 * K - 1) + (N - 1) * (K - 1) * (K - 1) * (2 * K + 1)) * inv(K ** 3) % MOD)", "(m, n, k) = (int(x) for x in input().split())\np = 998244353\n\ndef ipow(a, b):\n    c = 1\n    while b:\n        if b % 2:\n            c = c * a % p\n        b = b // 2\n        a = a * a % p\n    return c\nkin = ipow(k, p - 2)\nif m == 1:\n    print((p + n - (n - 1) * kin % p) % p)\nelse:\n    print((p + 2 * n + (n - 1) * ipow(kin, 3) - (3 * n - 2) * kin % p) % p)", "mod = 998244353\n(m, n, k) = map(int, input().split())\nif m == 1:\n    q_inv = pow(k, mod - 2, mod)\n    print((1 + (k - 1) * n) * q_inv % mod)\nelse:\n    q_inv = pow(k, 3 * (mod - 2), mod)\n    print((pow(k, 2, mod) * (2 * k - 1) + (n - 1) * (2 * pow(k, 3, mod) - 3 * pow(k, 2, mod) + 1)) * q_inv % mod)", "import sys\nzz = 1\nsys.setrecursionlimit(10 ** 5)\nif zz:\n    input = sys.stdin.readline\nelse:\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('all.txt', 'w')\ndi = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n\ndef fori(n):\n    return [fi() for i in range(n)]\n\ndef inc(d, c, x=1):\n    d[c] = d[c] + x if c in d else x\n\ndef ii():\n    return input().rstrip()\n\ndef li():\n    return [int(xx) for xx in input().split()]\n\ndef fli():\n    return [float(x) for x in input().split()]\n\ndef comp(a, b):\n    if a > b:\n        return 2\n    return 2 if a == b else 0\n\ndef gi():\n    return [xx for xx in input().split()]\n\ndef gtc(tc, ans):\n    print('Case #' + str(tc) + ':', ans)\n\ndef cil(n, m):\n    return n // m + int(n % m > 0)\n\ndef fi():\n    return int(input())\n\ndef pro(a):\n    return reduce(lambda a, b: a * b, a)\n\ndef swap(a, i, j):\n    (a[i], a[j]) = (a[j], a[i])\n\ndef si():\n    return list(input().rstrip())\n\ndef mi():\n    return map(int, input().split())\n\ndef gh():\n    sys.stdout.flush()\n\ndef isvalid(i, j, n, m):\n    return 0 <= i < n and 0 <= j < m\n\ndef bo(i):\n    return ord(i) - ord('a')\n\ndef graph(n, m):\n    for i in range(m):\n        (x, y) = mi()\n        a[x].append(y)\n        a[y].append(x)\nt = 1\nuu = t\n\ndef nary(n, m):\n    if n == 0:\n        return '0'\n    nums = []\n    while n:\n        (n, r) = divmod(n, m)\n        nums.append(str(r))\n    return ''.join(reversed(nums))\nwhile t > 0:\n    t -= 1\n    (m, n, k) = mi()\n    mod = 998244353\n\n    def inv(m):\n        return invv[m]\n\n    def poww(k, n, mod):\n        return pw[n]\n    if m == 1:\n        if n == 1:\n            print(1)\n            continue\n        ans = 0\n        for i in range(1, n + 1):\n            ns = n - i + 1\n            if i != n:\n                if i < n - 1:\n                    ans = (ans + (ns - 2) * pow(k, n - i - 2, mod) * k * (k - 1) ** 2) % mod\n                ans = (ans + 2 * pow(k, n - i - 1, mod) * k * (k - 1)) % mod\n            else:\n                ans += k\n        print(ans * pow(pow(k, n, mod), mod - 2, mod) % mod)\n    if m == 2:\n        if k == 1:\n            print(1)\n            continue\n        dp = [[0] * 4 for i in range(n)]\n        ans = 0\n        N = n\n        n = 2 * n\n        pw = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pw[i] = pw[i - 1] * k % mod\n        invv = {}\n        invv[k * (k - 1)] = pow(k * (k - 1), mod - 2, mod)\n        for i in range(1, 4):\n            invv[k ** i] = pow(k ** i, mod - 2, mod)\n            invv[(k - 1) ** i] = pow((k - 1) ** i, mod - 2, mod)\n        for i in range(N):\n            if i == 0:\n                if N == 1:\n                    dp[i][1] = k * (k - 1) % mod\n                    dp[i][2] = k * (k - 1) % mod\n                    dp[i][3] = k % mod\n                else:\n                    dp[i][1] = poww(k, n - 2, mod) * (k - 1) ** 2 % mod\n                    dp[i][2] = poww(k, n - 2, mod) * (k - 1) ** 2 % mod\n                    dp[i][3] = poww(k, n - 3, mod) * (k - 1) ** 2 % mod\n            elif i == N - 1:\n                dp[i][1] = poww(k, n - 2, mod) * (k - 1) ** 2 % mod + dp[i - 1][1] * inv(k) % mod + dp[i - 1][3] * inv(k - 1) % mod\n                dp[i][1] %= mod\n                dp[i][2] = poww(k, n - 2, mod) * (k - 1) ** 2 % mod + dp[i - 1][2] * inv(k) % mod + dp[i - 1][3] * inv(k - 1) % mod\n                dp[i][2] %= mod\n                dp[i][3] = poww(k, n - 3, mod) * (k - 1) ** 2 % mod + dp[i - 1][3] * inv((k - 1) ** 2) % mod + (dp[i - 1][1] + dp[i - 1][2]) * inv(k * (k - 1)) % mod\n                dp[i][3] %= mod\n            else:\n                dp[i][1] = poww(k, n - 3, mod) * (k - 1) ** 3 % mod + dp[i - 1][1] * inv(k ** 2) * (k - 1) + dp[i - 1][3] * inv(k)\n                dp[i][1] %= mod\n                dp[i][2] = poww(k, n - 3, mod) * (k - 1) ** 3 % mod + dp[i - 1][2] * inv(k ** 2) * (k - 1) % mod + dp[i - 1][3] * inv(k) % mod\n                dp[i][2] %= mod\n                dp[i][3] = poww(k, n - 5, mod) * (k - 1) ** 4 % mod + dp[i - 1][3] * inv(k ** 2) % mod + (dp[i - 1][1] + dp[i - 1][2]) % mod * (k - 1) * inv(k ** 3) % mod\n            ans += sum(dp[i])\n            ans %= mod\n        print(ans * pow(pow(k, n, mod), mod - 2, mod) % mod)", "mod = 998244353\n\ndef modinv(a, p):\n    return pow(a, p - 2, p)\n(M, N, K) = map(int, input().split())\nif M == 1:\n    s = (K + (N - 1) * (K - 1)) % mod\n    print(s * modinv(K, mod) % mod)\nelse:\n    s = (2 * K * K - 1 + (2 * K * K * K - 3 * K * K + 1) * N) % mod\n    print(s * modinv(K * K * K, mod) % mod)", "import sys\ninput = sys.stdin.readline\n\ndef inv(x):\n    return pow(x, 998244351, 998244353)\nl = input().split()\nm = int(l[0])\nn = int(l[1])\nk = int(l[2])\nif m == 1:\n    z = (n - 1) * (k - 1)\n    z += k\n    z %= 998244353\n    z = z * inv(k)\n    z %= 998244353\n    print(z)\n    quit()\nmod = 998244353\nz = 2 * k - 1\nz = z * inv(k)\nz %= mod\ndiff = 2 * k * k * k\ndiff %= mod\ndiff -= 3 * k * k\ndiff %= mod\ndiff += 1\ndiff %= mod\nlol = k * k * k\nlol %= mod\ndiff = diff * inv(lol)\nz += (n - 1) * diff\nz %= mod\nprint(z)", "(m, n, k) = map(int, input().split())\nmod = 998244353\nif m == 1:\n    print((n * k - n + 1) * pow(k, mod - 2, mod) % mod)\nelse:\n    a = (2 * k - 1) * k * k\n    d = 2 * (k - 1) ** 3 + 3 * (k - 1) ** 2\n    num = a + (n - 1) * d\n    denom = k ** 3\n    print(num * pow(denom, mod - 2, mod) % mod)"]