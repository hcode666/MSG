["for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    top = -1\n    st = []\n    co = 0\n    for i in arr:\n        while len(st) and st[-1] > i:\n            st.pop()\n            co += 1\n        if len(st) and st[-1] == i:\n            st.pop()\n        st.append(i)\n    co += len(st) - 1\n    print(co)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    top = -1\n    st = []\n    co = 0\n    for i in arr:\n        while len(st) and st[-1] > i:\n            st.pop()\n            co += 1\n        if len(st) and st[-1] == i:\n            st.pop()\n        st.append(i)\n    co += len(st) - 1\n    print(co)", "from sys import stdin\nfor __ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    nums = list(map(int, stdin.readline().split()))\n\n    def solve(array, i, j):\n        smallest = array[i]\n        sets = [[i, i]]\n        for k in range(i + 1, j):\n            if array[k] == smallest:\n                if sets[-1][1] + 1 == k:\n                    sets[-1][1] += 1\n                else:\n                    sets.append([k, k])\n            elif array[k] < smallest:\n                smallest = array[k]\n                sets = [[k, k]]\n        sets = [[i - 1, i - 1]] + sets + [[j, j]]\n        ans = 1\n        for i in range(1, len(sets)):\n            if sets[i - 1][1] + 1 < sets[i][0]:\n                ans += solve(array, sets[i - 1][1] + 1, sets[i][0])\n        return ans\n    print(solve(nums, 0, n) - 1)", "from collections import defaultdict\nfrom heapq import *\nimport itertools, math\n\ndef parse_integer_list():\n    return [int(x) for x in input().split()]\nfrom bisect import bisect_left\n\ndef binary_search(a, x, lo=0, hi=None):\n    hi = hi if hi is not None else len(a)\n    pos = bisect_left(a, x, lo, hi)\n    return pos\n\ndef handle_input(A, N):\n    B = [A[0]]\n    for i in range(len(A)):\n        if B[-1] != A[i]:\n            B.append(A[i])\n    min_val = min(B)\n    cnt = len(B) - B.count(min_val)\n    l = [B[0]]\n    for i in range(1, len(B)):\n        b = B[i]\n        idx = binary_search(l, b)\n        if idx == len(l):\n            l.append(b)\n            continue\n        if l[idx] == b:\n            if b != min_val:\n                cnt -= 1\n            l = l[:idx + 1]\n        else:\n            l = l[:idx]\n            l.append(b)\n    return cnt\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    A = parse_integer_list()\n    print(handle_input(A, N))", "def abc(l, n):\n    if n == 0:\n        return -1\n    if n == 1:\n        return 0\n    x = min(l)\n    i = 0\n    k = []\n    ans = 0\n    while i < n:\n        if l[i] == x:\n            ans += 1 + abc(k, len(k))\n            k = []\n            i += 1\n            continue\n        k.append(l[i])\n        i += 1\n    ans += 1 + abc(k, len(k))\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = 0\n    k = []\n    x = min(l)\n    for i in l:\n        if i == x:\n            ans += 1 + abc(k, len(k))\n            k = []\n        else:\n            k.append(i)\n    ans += 1 + abc(k, len(k))\n    print(ans)", "def abc(l, n):\n    if n == 0:\n        return -1\n    if n == 1:\n        return 0\n    x = min(l)\n    i = 0\n    k = []\n    ans = 0\n    while i < n:\n        if l[i] == x:\n            ans += 1 + abc(k, len(k))\n            k = []\n            i += 1\n            continue\n        k.append(l[i])\n        i += 1\n    ans += 1 + abc(k, len(k))\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = 0\n    k = []\n    x = min(l)\n    for i in l:\n        if i == x:\n            ans += 1 + abc(k, len(k))\n            k = []\n        else:\n            k.append(i)\n    ans += 1 + abc(k, len(k))\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    stack = []\n    ans = 0\n    for i in range(n):\n        while stack and stack[-1] > arr[i]:\n            stack.pop()\n            ans += 1\n        if not stack or arr[i] > stack[-1]:\n            stack.append(arr[i])\n    print(ans + len(stack) - 1)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    top = -1\n    st = []\n    co = 0\n    for i in arr:\n        while len(st) and st[-1] > i:\n            st.pop()\n            co += 1\n        if len(st) and st[-1] == i:\n            st.pop()\n        st.append(i)\n    co += len(st) - 1\n    print(co)", "from sys import stdin\nfor __ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    nums = list(map(int, stdin.readline().split()))\n\n    def solve(array, i, j):\n        smallest = array[i]\n        sets = [[i, i]]\n        for k in range(i + 1, j):\n            if array[k] == smallest:\n                if sets[-1][1] + 1 == k:\n                    sets[-1][1] += 1\n                else:\n                    sets.append([k, k])\n            elif array[k] < smallest:\n                smallest = array[k]\n                sets = [[k, k]]\n        sets = [[i - 1, i - 1]] + sets + [[j, j]]\n        ans = 1\n        for i in range(1, len(sets)):\n            if sets[i - 1][1] + 1 < sets[i][0]:\n                ans += solve(array, sets[i - 1][1] + 1, sets[i][0])\n        return ans\n    print(solve(nums, 0, n) - 1)", "from sys import stdin\nfor __ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    nums = list(map(int, stdin.readline().split()))\n\n    def solve(array, i, j):\n        smallest = array[i]\n        sets = [[i, i]]\n        for k in range(i + 1, j):\n            if array[k] == smallest:\n                if sets[-1][1] + 1 == k:\n                    sets[-1][1] += 1\n                else:\n                    sets.append([k, k])\n            elif array[k] < smallest:\n                smallest = array[k]\n                sets = [[k, k]]\n        sets = [[i - 1, i - 1]] + sets + [[j, j]]\n        ans = 1\n        for i in range(1, len(sets)):\n            if sets[i - 1][1] + 1 < sets[i][0]:\n                ans += solve(array, sets[i - 1][1] + 1, sets[i][0])\n        return ans\n    print(solve(nums, 0, n) - 1)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = input().strip().split()\n    for i in range(len(arr)):\n        arr[i] = int(arr[i])\n    stack = []\n    top = -1\n    ans = 0\n    for i in range(n):\n        if top == -1:\n            stack.append(arr[i])\n            top += 1\n        elif arr[i] == stack[top]:\n            continue\n        elif arr[i] > stack[top]:\n            stack.append(arr[i])\n            top += 1\n        else:\n            while top != -1 and stack[top] > arr[i]:\n                stack.pop()\n                ans += 1\n                top -= 1\n            if top == -1:\n                stack.append(arr[i])\n                top += 1\n            elif arr[i] == stack[top]:\n                continue\n            else:\n                stack.append(arr[i])\n                top += 1\n    ans += top\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef find(a):\n    global par\n    if par[a] == a:\n        return a\n    par[a] = find(par[a])\n    return par[a]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    it = list(map(int, input().split()))\n    aa = [[0, 0, it[0]]]\n    for i in range(1, n):\n        if it[i] == it[i - 1]:\n            aa[-1][1] += 1\n        else:\n            aa.append([i, i, it[i]])\n    aa.sort()\n    aa = [i + [j] for (j, i) in enumerate(aa)]\n    aa.sort(key=lambda x: [-x[2], x[3]])\n    bb = [[aa[0]]]\n    vis = [0] * n\n    for i in range(1, len(aa)):\n        if aa[i][2] == aa[i - 1][2]:\n            bb[-1].append(aa[i])\n        else:\n            bb.append([aa[i]])\n    par = [i for i in range(len(aa))]\n    tot = 0\n    for j in bb[:-1]:\n        k = 0\n        for i in j:\n            if k == len(j) - 1:\n                par[i[3]] = min(i[3] + 1, len(aa) - 1)\n                tot += 1\n                k += 1\n                continue\n            x = find(i[3] + 1)\n            if j[k + 1][3] == x:\n                k += 1\n                par[i[3]] = i[3] + 1\n                continue\n            else:\n                tot += 1\n                if i[3] != 0:\n                    par[i[3]] = min(i[3] + 1, len(aa) - 1)\n            k += 1\n    print(tot)"]