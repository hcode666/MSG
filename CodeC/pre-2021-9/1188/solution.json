["import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\n\ndef dfscent(adj, v, par, n, centroid, sz):\n    sz[v] = 1\n    iscentroid = True\n    for a in adj[v]:\n        if a != par:\n            dfscent(adj, a, v, n, centroid, sz)\n            sz[v] += sz[a]\n            if sz[a] > n / 2:\n                iscentroid = False\n    if n - sz[v] > n / 2:\n        iscentroid = False\n    if iscentroid:\n        centroid.append(v)\n\ndef findCentroid(adj, n, sz):\n    centroid = []\n    dfscent(adj, 0, -1, n, centroid, sz)\n    return max(centroid)\n\ndef topoval(adj, v, par, dp, sz):\n    dp[v] = 1\n    sz[v] = 1\n    for a in adj[v]:\n        if a != par:\n            topoval(adj, a, v, dp, sz)\n            dp[v] = dp[v] * dp[a] % MOD\n            dp[v] = dp[v] * invfact[sz[a]] % MOD\n            sz[v] += sz[a]\n    dp[v] = dp[v] * fact[sz[v] - 1] % MOD\n    return dp[v] % MOD\nfact = [1] * (5 * 10 ** 5 + 10)\ninvfact = [1] * (5 * 10 ** 5 + 10)\nfor i in range(1, len(fact)):\n    fact[i] = fact[i - 1] * i % MOD\n    invfact[i] = pow(fact[i], MOD - 2, MOD)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    adj = [[] for _ in range(int(n))]\n    for _ in range(int(n - 1)):\n        (u, v) = map(int, input().split())\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sz = [0] * n\n    first = findCentroid(adj, n, sz)\n    dp = [-1] * n\n    firstans = topoval(adj, first, -1, dp, sz)\n    if k == 1:\n        print(first + 1, firstans)\n    else:\n        second = adj[first][0]\n        for v in adj[first]:\n            if sz[v] > sz[second]:\n                second = v\n            if sz[v] == sz[second] and v > second:\n                second = v\n        secondans = topoval(adj, second, -1, dp, sz)\n        print(second + 1, secondans)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "from collections import deque\np = 10 ** 9 + 7\nfacts = [1] * (5 * 10 ** 5 + 10)\ninvfacts = [1] * (5 * 10 ** 5 + 10)\nfor i in range(1, len(facts)):\n    facts[i] = facts[i - 1] * i % p\n    invfacts[i] = pow(facts[i], p - 2, p)\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    graph = [[] for i in range(n)]\n    edges = [0 for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n        edges[u] += 1\n        edges[v] += 1\n    edges[0] += 2\n    par = [-1 for i in range(n)]\n    que = deque([0])\n    while que:\n        i = que.popleft()\n        for j in graph[i]:\n            if j != par[i]:\n                par[j] = i\n                que.append(j)\n    count = [1 for i in range(n)]\n    d = [1 for i in range(n)]\n    que = deque([])\n    for i in range(n):\n        if edges[i] == 1:\n            que.append(i)\n    while que:\n        i = que.popleft()\n        d[i] = d[i] * facts[count[i] - 1] % p\n        edges[par[i]] -= 1\n        count[par[i]] += count[i]\n        d[par[i]] = d[par[i]] * invfacts[count[i]] % p * d[i] % p\n        if edges[par[i]] == 1:\n            que.append(par[i])\n    d[0] = d[0] * facts[count[0] - 1] % p\n    res = []\n    anst = [0 for i in range(n)]\n    anst[0] = d[0]\n    res.append([1, 0])\n    ans = [0 for i in range(n)]\n    ans[0] = 1\n    que = deque([(0, -1)])\n    while que:\n        (i, parent) = que.popleft()\n        for j in graph[i]:\n            if j != parent:\n                c = count[j]\n                ans[j] = ans[i] * c / (n - c)\n                anst[j] = int(anst[i] * c * pow(n - c, p - 2, p)) % p\n                res.append([ans[j], j])\n                que.append((j, i))\n    res.sort(key=lambda x: (x[0], x[1]), reverse=True)\n    print(res[k - 1][1] + 1, anst[res[k - 1][1]])", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\n\ndef dfscent(adj, v, par, n, centroid, sz):\n    sz[v] = 1\n    iscentroid = True\n    for a in adj[v]:\n        if a != par:\n            dfscent(adj, a, v, n, centroid, sz)\n            sz[v] += sz[a]\n            if sz[a] > n / 2:\n                iscentroid = False\n    if n - sz[v] > n / 2:\n        iscentroid = False\n    if iscentroid:\n        centroid.append(v)\n\ndef findCentroid(adj, n, sz):\n    centroid = []\n    dfscent(adj, 0, -1, n, centroid, sz)\n    return max(centroid)\n\ndef topoval(adj, v, par, dp, sz):\n    dp[v] = 1\n    sz[v] = 1\n    for a in adj[v]:\n        if a != par:\n            topoval(adj, a, v, dp, sz)\n            dp[v] = dp[v] * dp[a] % MOD\n            dp[v] = dp[v] * invfact[sz[a]] % MOD\n            sz[v] += sz[a]\n    dp[v] = dp[v] * fact[sz[v] - 1] % MOD\n    return dp[v] % MOD\nfact = [1]\ninvfact = [1]\nfor i in range(1, 5 * 10 ** 5 + 10):\n    fact.append(fact[i - 1] * i % MOD)\n    invfact.append(pow(fact[i], MOD - 2, MOD))\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    adj = [[] for _ in range(int(n))]\n    for _ in range(int(n - 1)):\n        (u, v) = map(int, input().split())\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sz = [0] * n\n    first = findCentroid(adj, n, sz)\n    dp = [-1] * n\n    firstans = topoval(adj, first, -1, dp, sz)\n    if k == 1:\n        print(first + 1, firstans)\n    else:\n        second = adj[first][0]\n        for v in adj[first]:\n            if sz[v] > sz[second]:\n                second = v\n            if sz[v] == sz[second] and v > second:\n                second = v\n        secondans = topoval(adj, second, -1, dp, sz)\n        print(second + 1, secondans)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\n\ndef dfscent(adj, v, par, n, centroid, sz):\n    sz[v] = 1\n    iscentroid = True\n    for a in adj[v]:\n        if a != par:\n            dfscent(adj, a, v, n, centroid, sz)\n            sz[v] += sz[a]\n            if sz[a] > n / 2:\n                iscentroid = False\n    if n - sz[v] > n / 2:\n        iscentroid = False\n    if iscentroid:\n        centroid.append(v)\n\ndef findCentroid(adj, n, sz):\n    centroid = []\n    dfscent(adj, 0, -1, n, centroid, sz)\n    return max(centroid)\n\ndef topoval(adj, v, par, dp, sz):\n    dp[v] = 1\n    sz[v] = 1\n    for a in adj[v]:\n        if a != par:\n            topoval(adj, a, v, dp, sz)\n            dp[v] = dp[v] * dp[a] % MOD\n            dp[v] = dp[v] * invfact[sz[a]] % MOD\n            sz[v] += sz[a]\n    dp[v] = dp[v] * fact[sz[v] - 1] % MOD\n    return dp[v] % MOD\nfact = [1] * (5 * 10 ** 5 + 10)\ninvfact = [1] * (5 * 10 ** 5 + 10)\nfor i in range(1, len(fact)):\n    fact[i] = fact[i - 1] * i % MOD\n    invfact[i] = pow(fact[i], MOD - 2, MOD)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    adj = [[] for _ in range(int(n))]\n    for _ in range(int(n - 1)):\n        (u, v) = map(int, input().split())\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sz = [0] * n\n    first = findCentroid(adj, n, sz)\n    dp = [-1] * n\n    firstans = topoval(adj, first, -1, dp, sz)\n    if k == 1:\n        print(first + 1, firstans)\n    else:\n        second = adj[first][0]\n        for v in adj[first]:\n            if sz[v] > sz[second]:\n                second = v\n            if sz[v] == sz[second] and v > second:\n                second = v\n        secondans = topoval(adj, second, -1, dp, sz)\n        print(second + 1, secondans)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\ninp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nlis = lambda : list(input().strip().split())\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline().strip()\nstdint = lambda : int(stdin.readline())\nstdmul = lambda : map(int, stdin.readline().strip().split())\nstdseq = lambda : list(map(int, stdin.readline().strip().split()))\nstdlis = lambda : list(stdin.readline().strip().split())\nstdpr = lambda x: stdout.write(str(x))\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, edges, N):\n        self.adjList = [[] for _ in range(N)]\n        self.indegree = [0] * N\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.indegree[dest] = self.indegree[dest] + 1\n\ndef findAllTopologicalOrders(graph, path, discovered, N, cnt):\n    for v in range(N):\n        if graph.indegree[v] == 0 and (not discovered[v]):\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] - 1\n            path.append(v)\n            discovered[v] = True\n            findAllTopologicalOrders(graph, path, discovered, N, cnt)\n            for u in graph.adjList[v]:\n                graph.indegree[u] = graph.indegree[u] + 1\n            path.pop()\n            discovered[v] = False\n    if len(path) == N:\n        cnt[0] += 1\n\ndef printAllTopologicalOrders(graph, cnt):\n    N = len(graph.adjList)\n    discovered = [False] * N\n    path = []\n    findAllTopologicalOrders(graph, path, discovered, N, cnt)\n\ndef dfs(graph, visited, i, edges):\n    visited[i] = True\n    for j in graph[i]:\n        if not visited[j]:\n            edges.append(tuple([j, i]))\n            dfs(graph, visited, j, edges)\nN = 5 * 10 ** 5 + 5\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef dfs2(graph, temp, subtree, visited, i):\n    visited[i] = True\n    (ans, s) = (1, 0)\n    for j in graph[i]:\n        if not visited[j]:\n            current = dfs2(graph, temp, subtree, visited, j)\n            s += current\n            ans = ans * Binomial(s, current, mod)\n            ans = ans % mod\n            ans = ans * temp[j]\n            ans = ans % mod\n    ans %= mod\n    temp[i] = ans\n    return s + 1\n\ndef getNode(graph, temp, subtree, visited, i, AA):\n    visited[i] = True\n    s = 0\n    curr = 0\n    for x in graph[i]:\n        if not visited[x]:\n            curr = getNode(graph, temp, subtree, visited, x, AA)\n            s += curr\n            nn = min(len(graph) - curr, curr)\n            AA.append([nn, [x, i]])\n    subtree[i] = s + 1\n    return s + 1\nfactorial(mod)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = dict()\n    for i in range(n):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n    if n == 1:\n        (k1, k2) = (0, 0)\n        if k == 1:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k1)\n            print(k1, temp[k1] % mod)\n        else:\n            visited = [False] * n\n            temp = [0] * n\n            subtree = [0] * n\n            dfs2(graph, temp, subtree, visited, k2)\n            print(k2, temp[k2] % mod)\n        continue\n    aa = []\n    subtree = [0] * n\n    visited = [False] * n\n    temp = [0] * n\n    getNode(graph, temp, subtree, visited, 0, aa)\n    idx = 1\n    aa.sort(reverse=True)\n    (k1, k2) = (0, 0)\n    if aa[0][0] != aa[1][0]:\n        (x, y) = (aa[0][1][0], aa[0][1][1])\n        if subtree[x] == n - subtree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif subtree[x] > n - subtree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        t = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        t.append(aa[0][1][0]) if aa[0][1][0] != k1 else t.append(aa[0][1][1])\n        nn = len(aa)\n        while idx < nn and aa[idx - 1][0] == aa[idx][0]:\n            t.append(aa[idx][1][0]) if aa[idx][1][0] != k1 else t.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(t)\n    if k == 1:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        visited = [False] * n\n        temp = [0] * n\n        dfs2(graph, temp, subtree, visited, k2)\n        print(k2 + 1, temp[k2] % mod)", "from collections import deque\np = 10 ** 9 + 7\nfacts = [1] * (5 * 10 ** 5 + 10)\ninvfacts = [1] * (5 * 10 ** 5 + 10)\nfor i in range(1, len(facts)):\n    facts[i] = facts[i - 1] * i % p\n    invfacts[i] = pow(facts[i], p - 2, p)\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    graph = [[] for i in range(n)]\n    edges = [0 for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        graph[u].append(v)\n        graph[v].append(u)\n        edges[u] += 1\n        edges[v] += 1\n    edges[0] += 2\n    par = [-1 for i in range(n)]\n    que = deque([0])\n    while que:\n        i = que.popleft()\n        for j in graph[i]:\n            if j != par[i]:\n                par[j] = i\n                que.append(j)\n    count = [1 for i in range(n)]\n    d = [1 for i in range(n)]\n    que = deque([])\n    for i in range(n):\n        if edges[i] == 1:\n            que.append(i)\n    while que:\n        i = que.popleft()\n        d[i] = d[i] * facts[count[i] - 1] % p\n        edges[par[i]] -= 1\n        count[par[i]] += count[i]\n        d[par[i]] = d[par[i]] * invfacts[count[i]] % p * d[i] % p\n        if edges[par[i]] == 1:\n            que.append(par[i])\n    d[0] = d[0] * facts[count[0] - 1] % p\n    res = []\n    anst = [0 for i in range(n)]\n    anst[0] = d[0]\n    res.append([1, 0])\n    ans = [0 for i in range(n)]\n    ans[0] = 1\n    que = deque([(0, -1)])\n    while que:\n        (i, parent) = que.popleft()\n        for j in graph[i]:\n            if j != parent:\n                c = count[j]\n                ans[j] = ans[i] * c / (n - c)\n                anst[j] = int(anst[i] * c * pow(n - c, p - 2, p)) % p\n                res.append([ans[j], j])\n                que.append((j, i))\n    res.sort(key=lambda x: (x[0], x[1]), reverse=True)\n    print(res[k - 1][1] + 1, anst[res[k - 1][1]])", "from collections import deque\np = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    (n, k) = list(map(int, input().split()))\n    facts = [1] * (n + 2)\n    invfacts = [1] * (n + 2)\n    for i in range(1, len(facts)):\n        facts[i] = facts[i - 1] * i % p\n        invfacts[i] = pow(facts[i], p - 2, p)\n    curr_edges = [0] * (n + 1)\n    adj = [[] for i in range(n + 1)]\n    const = [1] * (n + 1)\n    final = [0] * (n + 1)\n    for i in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        adj[u].append(v)\n        adj[v].append(u)\n        curr_edges[u] += 1\n        curr_edges[v] += 1\n    highest = 1\n    curr_edges[highest] += 1\n    par = [0] * (n + 1)\n    total = [1] * (n + 1)\n    count = [1] * (n + 1)\n    q = deque([highest])\n    while len(q):\n        s = q.popleft()\n        for child in adj[s]:\n            if child != par[s]:\n                par[child] = s\n                q.append(child)\n    leaves = []\n    for i in range(1, n + 1):\n        if curr_edges[i] == 1:\n            leaves.append(i)\n    curr = deque(leaves)\n    while curr:\n        i = curr.popleft()\n        total[i] = total[i] * facts[count[i] - 1] % p\n        count[par[i]] += count[i]\n        total[par[i]] = total[par[i]] * total[i] % p * invfacts[count[i]] % p\n        curr_edges[par[i]] -= 1\n        if curr_edges[par[i]] == 1:\n            curr.append(par[i])\n    final[highest] = total[highest]\n    curr = [highest]\n    ans = 1\n    while len(curr):\n        s = curr.pop()\n        for child in adj[s]:\n            if child != par[s]:\n                final[child] = final[s] * count[child] % p * pow(n - count[child], p - 2, p) % p\n                const[child] = const[s] * count[child] / (n - count[child])\n                curr.append(child)\n    pair = [(const[i], i) for i in range(1, n + 1)]\n    pair.sort(reverse=True)\n    ind = pair[k - 1][1]\n    print(str(ind) + ' ' + str(final[ind]))", "import sys\nsys.setrecursionlimit(10 ** 6)\nmo = 1000000007\nmax_size = 1000000\nfacinv = [0] * max_size\nf = [0] * max_size\nmodinv = [0] * max_size\nf[0] = 1\nfacinv[0] = facinv[1] = modinv[0] = modinv[1] = 1\nfor i in range(1, max_size):\n    f[i] = f[i - 1] * i % mo\nfor i in range(2, max_size):\n    facinv[i] = facinv[mo % i] * (mo - mo // i) % mo\nfor i in range(2, max_size):\n    modinv[i] = modinv[i - 1] * facinv[i] % mo\n\ndef nCr(n, r):\n    if r == n:\n        return 1\n    if n < r:\n        return 0\n    ans = f[n] * modinv[r] % mo\n    ans = ans * modinv[n - r] % mo\n    return ans\n\ndef get_pre(node, arr, sub_arr, visited, arr1):\n    visited[node] = 1\n    temp_s = 0\n    for neigh in arr[node]:\n        if visited[neigh] == 0:\n            get_pre(neigh, arr, sub_arr, visited, arr1)\n            x = sub_arr[neigh]\n            arr1.append([min(x, n - x), [neigh, node]])\n            temp_s += x\n    sub_arr[node] = temp_s + 1\n\ndef sub_tree_calc(arr, visited, node, sub_arr):\n    visited[node] = 1\n    temp_s = 0\n    for i in range(len(arr[node])):\n        if visited[arr[node][i]] == 0:\n            sub_tree_calc(arr, visited, arr[node][i], sub_arr)\n            temp_s += sub_arr[arr[node][i]]\n    sub_arr[node] = temp_s + 1\n\ndef get_comb(a):\n    if len(a) == 0:\n        return 1\n    temp_s = a[0]\n    p = 1\n    for i in range(1, len(a)):\n        temp_s += a[i]\n        t = nCr(temp_s, a[i])\n        p = p * t % mo\n    return p\n\ndef dfs(arr, visited, node, sub_arr, dp):\n    visited[node] = 1\n    temp_s = []\n    p = 1\n    for i in range(len(arr[node])):\n        if visited[arr[node][i]] == 0:\n            arr1 = dfs(arr, visited, arr[node][i], sub_arr, dp)\n            p = p * arr1 % mo\n            temp_s.append(sub_arr[arr[node][i]])\n    dp[node] = p * get_comb(temp_s) % mo\n    return dp[node]\n\ndef modinvfn(n):\n    arr1 = mo\n    x = 0\n    temp_s = 1\n    if arr1 == 1:\n        return 0\n    while n > 1:\n        p = n // arr1\n        t = arr1\n        arr1 = n % arr1\n        n = t\n        t = x\n        x = temp_s - p * x\n        temp_s = t\n    if temp_s < 0:\n        temp_s += mo\n    return temp_s\n\ndef traverse(node, arr, visited, sub_arr, dp, k, n):\n    visited[node] = 1\n    temp_s = []\n    p = 1\n    for i in range(len(arr[node])):\n        if visited[arr[node][i]] == 0:\n            arr1 = dp[arr[node][i]]\n            p = p * arr1 % mo\n            temp_s.append(sub_arr[arr[node][i]])\n    if k != -1:\n        x = dp[k]\n        x = x * modinvfn(dp[node]) % mo\n        x = x * modinvfn(nCr(n - 1, sub_arr[node])) % mo\n        p = p * x % mo\n        temp_s.append(n - sub_arr[node])\n    dp[node] = p * get_comb(temp_s) % mo\n    for i in range(len(arr[node])):\n        if visited[arr[node][i]] == 0:\n            traverse(arr[node][i], arr, visited, sub_arr, dp, node, n)\n\ndef calc(arr, n, sub_arr, dp, node):\n    visited = [0] * n\n    sub_tree_calc(arr, visited, node, sub_arr)\n    for i in range(n):\n        visited[i] = 0\n    dfs(arr, visited, node, sub_arr, dp)\n\ndef compute(dp, arr, node, visited):\n    visited[node] = 1\n    p = 1\n    temp_s = 0\n    for neigh in arr[node]:\n        if visited[neigh] == 0:\n            x = compute(dp, arr, neigh, visited)\n            temp_s += x\n            t1 = nCr(temp_s, x)\n            t2 = dp[neigh]\n            p = p * t1 * t2 % mo\n    dp[node] = p\n    return temp_s + 1\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = [[] for i in range(n)]\n    dp = [0] * n\n    visited = [False] * n\n    arr1 = []\n    sub_arr = [None] * n\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        arr[u - 1].append(v - 1)\n        arr[v - 1].append(u - 1)\n    if n <= 10:\n        temp_s = []\n        calc(arr, n, sub_arr, dp, 0)\n        traverse(0, arr, visited, sub_arr, dp, -1, n)\n        for i in range(n):\n            temp_s.append((int(dp[i]), int(i + 1)))\n        temp_s.sort(reverse=True)\n        print(str(temp_s[k - 1][1]) + ' ' + str(temp_s[k - 1][0]))\n    else:\n        get_pre(0, arr, sub_arr, visited, arr1)\n        cur_pos = 1\n        while len(arr1) < n + 1:\n            arr1.append([0, [-1, -1]])\n        arr1.sort(key=lambda x: x[0], reverse=True)\n        if arr1[0][0] != arr1[1][0]:\n            x = arr1[0][1][0]\n            y = arr1[0][1][1]\n            if sub_arr[x] != n - sub_arr[x]:\n                if sub_arr[x] > n - sub_arr[x]:\n                    k1 = x\n                    k2 = y\n                else:\n                    k1 = y\n                    k2 = x\n            else:\n                k1 = max(x, y)\n                k2 = min(x, y)\n        else:\n            a = []\n            if not (arr1[0][1][0] == arr1[1][1][0] or arr1[0][1][0] == arr1[1][1][1]):\n                k1 = arr1[0][1][1]\n                a.append(arr1[0][1][0])\n            else:\n                k1 = arr1[0][1][0]\n                a.append(arr1[0][1][1])\n            cur_pos = 1\n            while cur_pos < n and arr1[cur_pos - 1][0] == arr1[cur_pos][0]:\n                if arr1[0][1][1] != k1:\n                    a.append(arr1[cur_pos][1][1])\n                else:\n                    a.append(arr1[cur_pos][1][0])\n                cur_pos = cur_pos + 1\n            k2 = max(a)\n        visited = [0] * n\n        dp = [0] * n\n        if k == 2:\n            compute(dp, arr, k2, visited)\n            node = k2 + 1\n            combb = dp[k2] % mo\n            combb = (combb + mo) % mo\n        else:\n            node = k1 + 1\n            compute(dp, arr, k1, visited)\n            combb = dp[k1] % mo\n            combb = (combb + mo) % mo\n        print(node, combb)", "from itertools import permutations as perm\nfrom fractions import Fraction\nfrom collections import *\nfrom sys import stdin\nfrom bisect import *\nfrom heapq import *\ng = lambda : stdin.readline().strip()\ngl = lambda : g().split()\ngil = lambda : [int(var) for var in gl()]\ngfl = lambda : [float(var) for var in gl()]\ngcl = lambda : list(g())\ngbs = lambda : [int(var) for var in g()]\nmod = int(1000000000.0) + 7\ninf = float('inf')\nN = int(500000.0) + 1\nfac = [1] * N\nfor i in range(2, N):\n    fac[i] *= fac[i - 1] * i\n    fac[i] %= mod\n(t,) = gil()\n\ndef cal(root, adj, n):\n    dp = [0] * (n + 1)\n    ans = fac[n]\n    dp[0] = 1\n    stack = [root]\n    vis = [0] * (n + 1)\n    while stack:\n        p = stack[-1]\n        if vis[p]:\n            dp[p] = 1\n            for c in adj[p]:\n                dp[p] += dp[c]\n            ans *= pow(dp[p], mod - 2, mod)\n            ans %= mod\n            stack.pop()\n        else:\n            vis[p] = 1\n            for c in adj[p]:\n                if not vis[c]:\n                    stack.append(c)\n    return ans\n\ndef getCenters(adj, n):\n    dp = [0] * (n + 1)\n    stack = [1]\n    vis = [0] * (n + 1)\n    while stack:\n        p = stack[-1]\n        if vis[p]:\n            stack.pop()\n            for c in adj[p]:\n                dp[p] += dp[c]\n            dp[p] += 1\n        else:\n            vis[p] = 1\n            for c in adj[p]:\n                if not vis[c]:\n                    stack.append(c)\n    p = 1\n    lmt = n // 2\n    while 1:\n        np = max(adj[p], key=lambda x: dp[x])\n        if dp[np] <= lmt:\n            break\n        dp[p] -= dp[np]\n        p = np\n        dp[p] = n\n    return (p, dp)\nfor _ in range(t):\n    (n, k) = gil()\n    if n == 1:\n        print(1, 1)\n        continue\n    adj = [[] for _ in range(n + 1)]\n    adj_ = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (x, y) = gil()\n        adj[x].append(y)\n        adj[y].append(x)\n        adj_[x].append(y)\n        adj_[y].append(x)\n    if n < 11:\n        if k == 1:\n            ci = getCenters(adj_, n)\n            print(ci, cal(ci, adj, n))\n        else:\n            ans = []\n            for i in range(1, n + 1):\n                ans.append((cal(i, adj, n), i))\n            ans.sort(reverse=True)\n            (val, node) = ans[k - 1]\n            val %= mod\n            print(node, val)\n    elif k == 1:\n        (ci, _) = getCenters(adj_, n)\n        print(ci, cal(ci, adj, n))\n    else:\n        (ci, dp) = getCenters(adj_, n)\n        ans = []\n        for c in adj[ci]:\n            cv = dp[c] / (n - dp[c])\n            ans.append((cv, c))\n        (_, node) = max(ans)\n        print(node, cal(node, adj, n))", "import sys\nsys.setrecursionlimit(10 ** 6)\nz = int(1000000000.0) + 7\nsize = int(1000000.0)\ninvf = [0] * size\nf = [0] * size\nmodi = [0] * size\nf[0] = 1\ninvf[0] = 1\ninvf[1] = 1\nmodi[0] = 1\nmodi[1] = 1\nfor i in range(1, size):\n    f[i] = f[i - 1] * i % z\nfor i in range(2, size):\n    invf[i] = invf[z % i] * (z - z // i) % z\nfor i in range(2, size):\n    modi[i] = modi[i - 1] * invf[i] % z\n\ndef mi(n):\n    m = z\n    x = 0\n    s = 1\n    if m == 1:\n        return 0\n    while n > 1:\n        p = n // m\n        t = m\n        m = n % m\n        n = t\n        t = x\n        x = s - p * x\n        s = t\n    if s < 0:\n        s += z\n    return s\n\ndef C(n, r):\n    if r == n:\n        return 1\n    if n < r:\n        return 0\n    ans = f[n] * modi[r] % z\n    ans = ans * modi[n - r] % z\n    return ans\n\ndef compute(a):\n    if len(a) == 0:\n        return 1\n    s = a[0]\n    p = 1\n    for i in range(1, len(a)):\n        s += a[i]\n        t = C(s, a[i])\n        p = p * t % z\n    return p\n\ndef calculate(node, e, d, v, m):\n    v[node] = 1\n    s = 0\n    for child in e[node]:\n        if v[child] == 0:\n            calculate(child, e, d, v, m)\n            x = d[child]\n            m.append([min(x, n - x), [child, node]])\n            s += x\n    d[node] = s + 1\n\ndef solve(node, v, dp, e):\n    v[node] = 1\n    p = 1\n    s = 0\n    for child in e[node]:\n        if v[child] == 0:\n            x = solve(child, v, dp, e)\n            s += x\n            t1 = C(s, x)\n            t2 = dp[child]\n            p = p * t1 * t2 % z\n    dp[node] = p\n    return s + 1\n\ndef topo(m):\n    m.sort(key=lambda x: x[0], reverse=True)\n    return m\n\ndef find(node, e, v, d):\n    v[node] = 1\n    s = 0\n    for i in range(len(e[node])):\n        if v[e[node][i]] == 0:\n            find(e[node][i], e, v, d)\n            s += d[e[node][i]]\n    d[node] = s + 1\n\ndef dfs(node, e, v, d, dp):\n    v[node] = 1\n    s = []\n    p = 1\n    for i in range(len(e[node])):\n        if v[e[node][i]] == 0:\n            m = dfs(e[node][i], e, v, d, dp)\n            p = p * m % z\n            s.append(d[e[node][i]])\n    dp[node] = p * compute(s) % z\n    return dp[node]\n\ndef code(node, e, v, d, dp, k, n):\n    v[node] = 1\n    s = []\n    p = 1\n    for i in range(len(e[node])):\n        if v[e[node][i]] == 0:\n            m = dp[e[node][i]]\n            p = p * m % z\n            s.append(d[e[node][i]])\n    if k != -1:\n        x = dp[k]\n        x = x * mi(dp[node]) % z\n        x = x * mi(C(n - 1, d[node])) % z\n        p = p * x % z\n        s.append(n - d[node])\n    dp[node] = p * compute(s) % z\n    for i in range(len(e[node])):\n        if v[e[node][i]] == 0:\n            code(e[node][i], e, v, d, dp, node, n)\n\ndef preprocess(node, e, n, d, dp):\n    v = [0] * n\n    find(node, e, v, d)\n    for i in range(n):\n        v[i] = 0\n    dfs(node, e, v, d, dp)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if n > 10:\n        tree = {}\n        m = []\n        d = [0] * (n + 1)\n        vis = [0] * (n + 1)\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            u = u - 1\n            v = v - 1\n            if v in tree:\n                tree[v].append(u)\n            else:\n                tree[v] = [u]\n            if u in tree:\n                tree[u].append(v)\n            else:\n                tree[u] = [v]\n        calculate(0, tree, d, vis, m)\n        pos = 1\n        m = topo(m)\n        while len(m) < n + 1:\n            m.append([0, [-1, -1]])\n        if m[0][0] != m[1][0]:\n            x = m[0][1][0]\n            y = m[0][1][1]\n            if d[x] != n - d[x]:\n                if d[x] > n - d[x]:\n                    k1 = x\n                    k2 = y\n                else:\n                    k1 = y\n                    k2 = x\n            else:\n                k1 = max(x, y)\n                k2 = min(x, y)\n        else:\n            a = []\n            if not (m[0][1][0] == m[1][1][0] or m[0][1][0] == m[1][1][1]):\n                k1 = m[0][1][1]\n                a.append(m[0][1][0])\n            else:\n                k1 = m[0][1][0]\n                a.append(m[0][1][1])\n            pos = 1\n            while pos < n and m[pos - 1][0] == m[pos][0]:\n                if m[0][1][1] != k1:\n                    a.append(m[pos][1][1])\n                else:\n                    a.append(m[pos][1][0])\n                pos = pos + 1\n            k2 = max(a)\n        vis = [0] * n\n        dp = [0] * n\n        if k == 2:\n            solve(k2, vis, dp, tree)\n            node = k2 + 1\n            res = (dp[k2] % z + z) % z\n        else:\n            node = k1 + 1\n            solve(k1, vis, dp, tree)\n            res = (dp[k1] % z + z) % z\n        print(node, res)\n    else:\n        vis = [0] * n\n        d = [0] * n\n        dp = [0] * n\n        e = [[] for i in range(n)]\n        s = []\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            e[u - 1].append(v - 1)\n            e[v - 1].append(u - 1)\n        preprocess(0, e, n, d, dp)\n        code(0, e, vis, d, dp, -1, n)\n        for i in range(n):\n            s.append((int(dp[i]), int(i + 1)))\n        s.sort(reverse=True)\n        print(str(s[k - 1][1]) + ' ' + str(s[k - 1][0]))", "N = 500005\nmod = 10 ** 9 + 7\n(fact, invf, invnum) = ([0] * N, [0] * N, [0] * N)\n(fact[0], fact[1], invf[0], invf[1]) = (1, 1, 1, 1)\ninvnum[0] = invnum[1] = 1\nfor i in range(2, N):\n    invnum[i] = invnum[mod % i] * (mod - mod // i) % mod\n    fact[i] = fact[i - 1] * i % mod\n    invf[i] = invnum[i] * invf[i - 1] % mod\n\ndef dfs(node):\n    v[node] = 1\n    (ans, sub) = (1, 0)\n    for x in adj[node]:\n        if v[x] == 0:\n            c = dfs(x)\n            sub += c\n            if c > sub:\n                ans = 0\n            else:\n                ans = ans * (fact[sub] * invf[c] % mod * invf[sub - c]) % mod\n            ans = ans * count[x] % mod\n    count[node] = ans\n    return sub + 1\n\ndef create(node):\n    v[node] = 1\n    sub = 0\n    for x in adj[node]:\n        if v[x] == 0:\n            curr = create(x)\n            sub += curr\n            mini = min(curr, n - curr)\n            seq.append([mini, [x, node]])\n    sub += 1\n    sub_tree[node] = sub\n    return sub\nimport sys\nt = int(input())\nfor test in range(t):\n    (n, k) = map(int, input().split())\n    if n <= 10 ** 5 + 100:\n        sys.setrecursionlimit(100004)\n    else:\n        sys.setrecursionlimit(500005)\n    adj = []\n    for i in range(n):\n        adj.append([])\n    v = [0] * n\n    sub_tree = [0] * n\n    count = [0] * n\n    seq = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    if n == 1:\n        print(1, 1)\n    elif n == 2:\n        if k == 1:\n            print(2, 1)\n        else:\n            print(1, 1)\n    else:\n        create(0)\n        idx = 1\n        (seq.sort(), seq.reverse())\n        if seq[0][0] != seq[1][0]:\n            x = seq[0][1][0]\n            y = seq[0][1][1]\n            if sub_tree[x] == n - sub_tree[x]:\n                k1 = max(x, y)\n                k2 = min(x, y)\n            elif sub_tree[x] > n - sub_tree[x]:\n                k1 = x\n                k2 = y\n            else:\n                k2 = x\n                k1 = y\n        else:\n            stack = []\n            if seq[0][1][0] == seq[1][1][0] or seq[0][1][0] == seq[1][1][1]:\n                k1 = seq[0][1][0]\n            else:\n                k1 = seq[0][1][1]\n            i = 1\n            if seq[0][1][0] != k1:\n                stack.append(seq[0][1][0])\n            else:\n                stack.append(seq[0][1][1])\n            while i != n and i < len(seq) and (seq[i - 1][0] == seq[i][0]):\n                if seq[i][1][0] != k1:\n                    stack.append(seq[i][1][0])\n                else:\n                    stack.append(seq[i][1][1])\n                i += 1\n            k2 = max(stack)\n        v = [0] * n\n        count = [0] * n\n        if k == 1:\n            dfs(k1)\n            print(k1 + 1, count[k1] % mod)\n        else:\n            dfs(k2)\n            print(k2 + 1, count[k2] % mod)", "N = 500005\nmod = 10 ** 9 + 7\n(fact, invf, invnum) = ([0] * N, [0] * N, [0] * N)\n(fact[0], fact[1], invf[0], invf[1]) = (1, 1, 1, 1)\ninvnum[0] = invnum[1] = 1\nfor i in range(2, N):\n    invnum[i] = invnum[mod % i] * (mod - mod // i) % mod\n    fact[i] = fact[i - 1] * i % mod\n    invf[i] = invnum[i] * invf[i - 1] % mod\n\ndef dfs(node):\n    v[node] = 1\n    (ans, sub) = (1, 0)\n    for x in adj[node]:\n        if v[x] == 0:\n            c = dfs(x)\n            sub += c\n            if c > sub:\n                ans = 0\n            else:\n                ans = ans * (fact[sub] * invf[c] % mod * invf[sub - c]) % mod\n            ans = ans * count[x] % mod\n    count[node] = ans\n    return sub + 1\n\ndef create(node):\n    v[node] = 1\n    sub = 0\n    for x in adj[node]:\n        if v[x] == 0:\n            curr = create(x)\n            sub += curr\n            mini = min(curr, n - curr)\n            seq.append([mini, [x, node]])\n    sub += 1\n    sub_tree[node] = sub\n    return sub\nimport sys\nt = int(input())\nfor test in range(t):\n    (n, k) = map(int, input().split())\n    if n <= 10 ** 5 + 100:\n        sys.setrecursionlimit(100004)\n    else:\n        sys.setrecursionlimit(500005)\n    adj = []\n    for i in range(n):\n        adj.append([])\n    v = [0] * n\n    sub_tree = [0] * n\n    count = [0] * n\n    seq = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    if n == 1:\n        print(1, 1)\n    elif n == 2:\n        if k == 1:\n            print(2, 1)\n        else:\n            print(1, 1)\n    else:\n        create(0)\n        idx = 1\n        (seq.sort(), seq.reverse())\n        if seq[0][0] != seq[1][0]:\n            x = seq[0][1][0]\n            y = seq[0][1][1]\n            if sub_tree[x] == n - sub_tree[x]:\n                k1 = max(x, y)\n                k2 = min(x, y)\n            elif sub_tree[x] > n - sub_tree[x]:\n                k1 = x\n                k2 = y\n            else:\n                k2 = x\n                k1 = y\n        else:\n            stack = []\n            if seq[0][1][0] == seq[1][1][0] or seq[0][1][0] == seq[1][1][1]:\n                k1 = seq[0][1][0]\n            else:\n                k1 = seq[0][1][1]\n            i = 1\n            if seq[0][1][0] != k1:\n                stack.append(seq[0][1][0])\n            else:\n                stack.append(seq[0][1][1])\n            while i != n and i < len(seq) and (seq[i - 1][0] == seq[i][0]):\n                if seq[i][1][0] != k1:\n                    stack.append(seq[i][1][0])\n                else:\n                    stack.append(seq[i][1][1])\n                i += 1\n            k2 = max(stack)\n        v = [0] * n\n        count = [0] * n\n        if k == 1:\n            dfs(k1)\n            print(k1 + 1, count[k1] % mod)\n        else:\n            dfs(k2)\n            print(k2 + 1, count[k2] % mod)", "import sys\n\ndef arrIn():\n    return list(map(int, input().split()))\n\ndef mapIn():\n    return map(int, input().split())\nmod = 10 ** 9 + 7\nfact = [0] * 500005\nfact[0] = 1\ninv_fact = [0] * 500005\n(inv_fact[0], inv_fact[1]) = (1, 1)\nendb = 500005\ninvn = [0] * endb\ninvn[0] = invn[1] = 1\nfor i in range(2, endb):\n    invn[i] = invn[mod % i] * (mod - mod // i) % mod\nfor i in range(1, endb):\n    fact[i] = fact[i - 1] * i % mod\nfor i in range(2, endb):\n    inv_fact[i] = invn[i] * inv_fact[i - 1] % mod\n\ndef bincoff(n, r, p):\n    if r > n:\n        return 0\n    if r == n:\n        return 1\n    return fact[n] * inv_fact[r] % p * inv_fact[n - r] % p\n\ndef dfs(node):\n    vis[node] = 1\n    (ans, subt) = (1, 0)\n    for x in adj[node]:\n        if vis[x] == 0:\n            nw = dfs(x)\n            subt += nw\n            ans *= bincoff(subt, nw, mod)\n            ans %= mod\n            ans *= temp[x]\n            ans %= mod\n    temp[node] = ans % mod\n    return subt + 1\n\ndef get(node):\n    vis[node] = 1\n    subt = 0\n    for x in adj[node]:\n        if vis[x] == 0:\n            curr = get(x)\n            subt += curr\n            mini = min(curr, n - curr)\n            aa.append([mini, [x, node]])\n    subt += 1\n    sub_tree[node] = subt\n    return subt\nfor ii in range(int(input())):\n    (n, k) = mapIn()\n    if n < 10 ** 5 + 5:\n        sys.setrecursionlimit(100004)\n    else:\n        sys.setrecursionlimit(500005)\n    adj = []\n    for i in range(n):\n        adj.append([])\n    vis = [0] * n\n    sub_tree = [0] * n\n    temp = [0] * n\n    aa = []\n    for i in range(n - 1):\n        (x, y) = mapIn()\n        (x, y) = (x - 1, y - 1)\n        adj[x].append(y)\n        adj[y].append(x)\n    if n == 1:\n        print(1, 1)\n        continue\n    get(0)\n    idx = 1\n    aa.sort()\n    aa.reverse()\n    if aa[0][0] != aa[1][0]:\n        x = aa[0][1][0]\n        y = aa[0][1][1]\n        if sub_tree[x] == n - sub_tree[x]:\n            k1 = max(x, y)\n            k2 = min(x, y)\n        elif sub_tree[x] > n - sub_tree[x]:\n            k1 = x\n            k2 = y\n        else:\n            k2 = x\n            k1 = y\n    else:\n        stack = []\n        if aa[0][1][0] == aa[1][1][0] or aa[0][1][0] == aa[1][1][1]:\n            k1 = aa[0][1][0]\n        else:\n            k1 = aa[0][1][1]\n        idx = 1\n        if aa[0][1][0] != k1:\n            stack.append(aa[0][1][0])\n        else:\n            stack.append(aa[0][1][1])\n        g = len(aa)\n        while idx != n and idx < g and (aa[idx - 1][0] == aa[idx][0]):\n            if aa[idx][1][0] != k1:\n                stack.append(aa[idx][1][0])\n            else:\n                stack.append(aa[idx][1][1])\n            idx += 1\n        k2 = max(stack)\n    vis = [0] * n\n    temp = [0] * n\n    if k == 1:\n        dfs(k1)\n        print(k1 + 1, temp[k1] % mod)\n    else:\n        dfs(k2)\n        print(k2 + 1, temp[k2] % mod)", "import sys\nimport math\nsys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\n\ndef subTreeSizes(el, root, visited, sizes):\n    if not visited[root]:\n        visited[root] = True\n        size = 1\n        for u in el[root]:\n            subTreeSizes(el, u, visited, sizes)\n            size += sizes[u]\n        sizes[root] = size\n    return sizes\n\ndef countOrderings(sizes):\n    result = 1\n    for i in range(2, len(sizes) + 1):\n        result *= i\n        result %= MOD\n    den = 1\n    for size in sizes:\n        den *= size\n        den %= MOD\n    result *= pow(den, MOD - 2, MOD)\n    return result % MOD\n\ndef subTreeProds(el, visited, sizes, products, root=0, parent=0):\n    if not visited[root]:\n        visited[root] = True\n        if root == 0:\n            products[0] = 0\n            for size in sizes:\n                products[0] += math.log(size)\n            for u in el[root]:\n                subTreeProds(el, visited, sizes, products, u, root)\n        else:\n            old_size_parent = sizes[parent]\n            old_size_root = sizes[root]\n            sizes[root] = old_size_parent\n            sizes[parent] = old_size_parent - old_size_root\n            products[root] = products[parent] - math.log(old_size_root) + math.log(sizes[parent])\n            for u in el[root]:\n                subTreeProds(el, visited, sizes, products, u, root)\n            sizes[parent] = old_size_parent\n            sizes[root] = old_size_root\n\ndef solve(el, K):\n    sizes = subTreeSizes(el, 0, [False] * len(el), [0] * len(el))\n    products = [0] * len(el)\n    subTreeProds(el, [False] * len(el), sizes, products)\n    pairlist = []\n    for index in range(len(products)):\n        pairlist.append((products[index], -index))\n    pairlist.sort()\n    root = -pairlist[K - 1][1]\n    sizes = subTreeSizes(el, root, [False] * len(el), [0] * len(el))\n    return (root + 1, countOrderings(sizes))\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    el = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        el[u].append(v)\n        el[v].append(u)\n    print(*solve(el, K))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 7)\nMOD = 10 ** 9 + 7\nMAX = 5 * 10 ** 5 + 13\nfct = [0] * MAX\nfct[0] = 1\nfor i in range(1, MAX):\n    fct[i] = fct[i - 1] * i % MOD\n\ndef inv(a):\n    return pow(a, MOD - 2, MOD)\n\ndef count(u, p=-1):\n    s = 1\n    for v in g[u]:\n        if v != p:\n            c = count(v, u)\n            s += c\n    x[u] = s\n    return s\n\ndef solve(u, r, p=-1):\n    if p == -1:\n        for v in g[u]:\n            solve(v, r, u)\n    else:\n        r -= 2 * x[u] - 1\n        r += x[p] - 1\n        (c1, c2) = (x[u], x[p])\n        (x[u], x[p]) = (x[p], x[p] - x[u])\n        mini[u - 1] = (-r, u)\n        for v in g[u]:\n            if v != p:\n                solve(v, r, u)\n        (x[u], x[p]) = (c1, c2)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    g = [[] for _ in range(n + 5)]\n    for _ in range(1, n):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    u = 1\n    x = [-1] * (n + 1)\n    count(u)\n    b = sum(x) - len(x)\n    mini = [()] * n\n    mini[0] = (-b, 1)\n    solve(1, b)\n    mini.sort()\n    count(mini[-k][1])\n    f = fct[n - 1]\n    for i in x[1:]:\n        if i != n:\n            f = f * inv(i) % MOD\n    print(mini[-k][1], f)", "import sys\nsys.setrecursionlimit(10 ** 8)\nMOD = 10 ** 9 + 7\nDEBUG = False\n\ndef debug(*args):\n    if DEBUG:\n        print(*args)\n\ndef populateSubtreeNodeCounts(adjNodes, n, subtreeNodeCounts, nodeIndex, visitedNodes):\n    subtreeNodeCount = 1\n    visitedNodes[nodeIndex] = True\n    for nIndex in adjNodes[nodeIndex]:\n        if not visitedNodes[nIndex]:\n            subtreeNodeCount += populateSubtreeNodeCounts(adjNodes, n, subtreeNodeCounts, nIndex, visitedNodes)\n    subtreeNodeCounts[nodeIndex] = subtreeNodeCount\n    return subtreeNodeCount\n\ndef findKthMinSubtreeNodeCountsProduct(adjNodes, n, k, subtreeNodeCounts, nodeIndex, visitedNodes, subtreeNodeCountsProduct, prevIndex):\n    subtreeNodeCountsProductUpdateVals = []\n    for nIndex in adjNodes[nodeIndex]:\n        if not visitedNodes[nIndex]:\n            subtreeNodeCountsProductUpdateVals.append(((n - subtreeNodeCounts[nIndex]) / subtreeNodeCounts[nIndex], nIndex))\n    subtreeNodeCountsProductUpdateVals = sorted(subtreeNodeCountsProductUpdateVals, key=lambda item: (item[0], -1 * item[1]))\n    debug(nodeIndex, prevIndex, subtreeNodeCountsProduct, subtreeNodeCountsProductUpdateVals)\n    if subtreeNodeCountsProductUpdateVals[0][0] > 1:\n        if k == 1:\n            return (nodeIndex, subtreeNodeCountsProduct)\n        if nodeIndex > 1 and (subtreeNodeCounts[nodeIndex] / (n - subtreeNodeCounts[nodeIndex]) < subtreeNodeCountsProductUpdateVals[0][0] or (subtreeNodeCounts[nodeIndex] / (n - subtreeNodeCounts[nodeIndex]) == subtreeNodeCountsProductUpdateVals[0][0] and prevIndex > subtreeNodeCountsProductUpdateVals[0][1])):\n            kthMinProductIndex = prevIndex\n            kthMinProduct = subtreeNodeCountsProduct * subtreeNodeCounts[nodeIndex] * pow(n - subtreeNodeCounts[nodeIndex], MOD - 2, MOD) % MOD\n        else:\n            kthMinProductIndex = subtreeNodeCountsProductUpdateVals[0][1]\n            kthMinProduct = subtreeNodeCountsProduct * (n - subtreeNodeCounts[kthMinProductIndex]) * pow(subtreeNodeCounts[kthMinProductIndex], MOD - 2, MOD) % MOD\n        return (kthMinProductIndex, kthMinProduct)\n    elif subtreeNodeCountsProductUpdateVals[0][0] == 1:\n        kthMinProduct = subtreeNodeCountsProduct\n        equalProductIndices = [nodeIndex]\n        equalProductIndices += [subtreeNodeCountsProductUpdateVals[i][1] for i in range(min(len(subtreeNodeCountsProductUpdateVals), k)) if subtreeNodeCountsProductUpdateVals[i][0] == 1]\n        equalProductIndices = sorted(equalProductIndices, reverse=True)\n        return (equalProductIndices[k - 1], kthMinProduct)\n    else:\n        visitedNodes[nodeIndex] = True\n        nextIndex = subtreeNodeCountsProductUpdateVals[0][1]\n        subtreeNodeCountsProduct = subtreeNodeCountsProduct * (n - subtreeNodeCounts[nextIndex]) * pow(subtreeNodeCounts[nextIndex], MOD - 2, MOD) % MOD\n        return findKthMinSubtreeNodeCountsProduct(adjNodes, n, k, subtreeNodeCounts, nextIndex, visitedNodes, subtreeNodeCountsProduct, nodeIndex)\n\ndef factorial(n):\n    f = 1\n    for i in range(1, n + 1):\n        f = f * i % MOD\n    return f\n\ndef solve(adjNodes, n, k):\n    if n == 1:\n        return (1, 2 - k)\n    startIndex = 1\n    subtreeNodeCounts = [1] * (n + 1)\n    visitedNodes = [False] * (n + 1)\n    populateSubtreeNodeCounts(adjNodes, n, subtreeNodeCounts, startIndex, visitedNodes)\n    debug(subtreeNodeCounts)\n    subtreeNodeCountsProduct = 1\n    for i in range(1, n + 1):\n        subtreeNodeCountsProduct = subtreeNodeCountsProduct * subtreeNodeCounts[i] % MOD\n    debug(subtreeNodeCountsProduct)\n    visitedNodes = [False] * (n + 1)\n    (kthMinProductNodeIndex, kthMinProduct) = findKthMinSubtreeNodeCountsProduct(adjNodes, n, k, subtreeNodeCounts, startIndex, visitedNodes, subtreeNodeCountsProduct, 0)\n    debug(kthMinProductNodeIndex, kthMinProduct)\n    maxToplogicalOrderingsCount = factorial(n) * pow(kthMinProduct, MOD - 2, MOD) % MOD\n    result = (kthMinProductNodeIndex, maxToplogicalOrderingsCount)\n    return result\ntc = int(input())\nfor t in range(tc):\n    (n, k) = map(int, input().split())\n    adjNodes = []\n    for i in range(n + 1):\n        adjNodes.append([])\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adjNodes[u].append(v)\n        adjNodes[v].append(u)\n    result = solve(adjNodes, n, k)\n    print(*result)", "from typing import List, Tuple\nimport sys\n\ndef mpow(x: int, p: int, m: int) -> int:\n    if p == 0:\n        return 1\n    if p == 1:\n        return x % m\n    ans = mpow(x, p >> 1, m)\n    ans = ans * ans % m\n    if p & 1 == 1:\n        ans = ans * x % m\n    return ans\n\nclass Mod:\n\n    def __init__(self):\n        _max_idx = int(500000.0 + 5)\n        _mod = int(1000000000.0 + 7)\n        _f = [1] * _max_idx\n        _fi = [1] * _max_idx\n        for i in range(1, _max_idx):\n            _f[i] = _f[i - 1] * i % _mod\n        _fi[-1] = mpow(_f[_max_idx - 1], _mod - 2, _mod)\n        for i in range(_max_idx - 2, 0, -1):\n            _fi[i] = _fi[i + 1] * (i + 1) % _mod\n        self.f = _f\n        self.fi = _fi\n        self.mod = _mod\n\ndef solve(n: int, k: int, g: List[List[int]], m: Mod) -> Tuple[int, int]:\n    c = []\n    size = [0] * (n + 1)\n\n    def dfs(u: int, p: int):\n        size[u] = 1\n        is_centroid = True\n        for v in g[u]:\n            if v == p:\n                continue\n            dfs(v, u)\n            size[u] += size[v]\n            if size[v] > n // 2:\n                is_centroid = False\n        if n - size[u] > n // 2:\n            is_centroid = False\n        if is_centroid:\n            c.append(u)\n    dfs(1, 1)\n    c.sort()\n\n    def get_c(u: int, p: int) -> int:\n        (w, vw, s) = (1, 1, 0)\n        for v in g[u]:\n            if v == p:\n                continue\n            vways = get_c(v, u)\n            s += size[v]\n            w = w * m.fi[size[v]] % m.mod\n            vw = vw * vways % m.mod\n        size[u] = s + 1\n        vw = vw * w % m.mod\n        return vw * m.f[s] % m.mod\n    node = -1\n    if k == 1:\n        node = c[len(c) - 1]\n    elif len(c) == 2:\n        node = c[0]\n    else:\n        dfs(c[0], 0)\n        node = g[c[0]][0]\n        for v in g[c[0]]:\n            if size[v] > size[node] or (size[v] == size[node] and v > node):\n                node = v\n    return (node, get_c(node, 0))\n\ndef main():\n    sys.setrecursionlimit(int(500000.0 + 21))\n    m = Mod()\n    t = int(input())\n    for _ in range(t):\n        (n, k) = [int(x) for x in input().split()]\n        g = [[] for _ in range(n + 1)]\n        for _ in range(n - 1):\n            (u, v) = [int(x) for x in input().split()]\n            g[u].append(v)\n            g[v].append(u)\n        (i, c) = solve(n, k, g, m)\n        print(f'{i} {c}')\nmain()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(u, p):\n    global diff, prsz, pr, ch, chsz\n    for i in a[u]:\n        if i != p:\n            dfs(i, u)\n            b[u] += b[i]\n    b[u] += 1\n    x = abs(n - 2 * b[u])\n    if u != 0 and x < diff:\n        diff = x\n        chsz = b[u]\n        prsz = n - b[u]\n        ch = u\n        pr = p\n    elif u != 0 and x == diff:\n        if p == pr:\n            ch = max(ch, u)\n\ndef dfs1(u, p):\n    for i in a[u]:\n        if i == p:\n            continue\n        dfs1(i, u)\n        c[u] += c[i]\n        dp[u] = dp[u] * dp[i] % mod\n        dp[u] = dp[u] * inver[c[i]] % mod\n    dp[u] = dp[u] * fact[c[u]] % mod\n    c[u] += 1\nmod = 10 ** 9 + 7\nfact = [1] * 10 ** 6\ninver = [1] * 10 ** 6\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\nfor i in range(2, 5 * 10 ** 5 + 5):\n    fact[i] = fact[i - 1] * i % mod\n    inver[i] = inv(fact[i])\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    if n == 1:\n        print(1, 1)\n        continue\n    a = [[] for i in range(n)]\n    xy = []\n    diff = float('inf')\n    chsz = -1\n    prsz = -1\n    ch = -1\n    pr = -1\n    k1 = -1\n    k2 = -1\n    for i in range(n - 1):\n        (x, y) = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        a[x].append(y)\n        a[y].append(x)\n    if n <= 10:\n        ans = []\n        for i in range(n):\n            dp = [1] * n\n            c = [0] * n\n            dfs1(i, -1)\n            ans.append([dp[i], i])\n        ans.sort(reverse=True)\n        print(ans[k - 1][1] + 1, ans[k - 1][0])\n    else:\n        b = [0] * n\n        c = [0] * n\n        dp = [1] * n\n        dfs(0, -1)\n        if prsz == chsz:\n            k1 = max(pr, ch)\n            k2 = min(pr, ch)\n        elif prsz > chsz:\n            k1 = pr\n            k2 = ch\n        else:\n            k1 = ch\n            k2 = pr\n        if k == 1:\n            dfs1(k1, -1)\n            print(k1 + 1, dp[k1])\n        else:\n            dfs1(k2, -1)\n            print(k2 + 1, dp[k2])", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nFAC = [1]\nfor i in range(1, 10 ** 6):\n    FAC.append(FAC[-1] * i % MOD)\nXXX = 0\n\ndef dfs(G, x, P, MEM):\n    if P in MEM[x]:\n        return MEM[x][P]\n    p = 1\n    c = 1\n    for i in G[x]:\n        if i == P:\n            continue\n        (a, b) = dfs(G, i, x, MEM)\n        c = (c + b) % MOD\n        p = p * a % MOD\n    MEM[x][P] = (p * c % MOD, c)\n    return MEM[x][P]\n\ndef ch(G, x, P, C):\n    if C[x]:\n        return 0\n    c = 1\n    for i in G[x]:\n        if i == P:\n            continue\n        c += ch(G, i, x, C)\n    C[x] = c\n    return C[x]\n\ndef main():\n    for _ in range(int(input())):\n        (N, K) = list(map(int, input().split()))\n        G = [[] for _ in range(N)]\n        for i in range(N - 1):\n            (a, b) = list(map(int, input().split()))\n            G[a - 1].append(b - 1)\n            G[b - 1].append(a - 1)\n        MEM = [{} for _ in range(N)]\n        R = FAC[N]\n        if N < 12:\n            arr = [(dfs(G, i, -1, MEM)[0], -i - 1) for i in range(N)]\n            arr.sort()\n            L = arr[K - 1]\n            S = R * pow(L[0], MOD - 2, MOD) % MOD\n            print(-L[1], S)\n            continue\n        CH = [0] * N\n        ch(G, 0, -1, CH)\n        G2 = [0 for _ in range(N)]\n        G3 = [[] for _ in range(N)]\n        for i in range(len(G)):\n            for j in G[i]:\n                if i < j:\n                    continue\n                if CH[i] < CH[j]:\n                    a = CH[i]\n                    b = N - a\n                else:\n                    b = CH[j]\n                    a = N - b\n                if a > b:\n                    G3[i].append(j)\n                    G2[j] += 1\n                elif a < b:\n                    G3[j].append(i)\n                    G2[i] += 1\n        X = []\n        for i in range(N):\n            if G2[i] == 0:\n                X.append(i)\n        X.sort(reverse=True)\n        if len(X) >= K:\n            MX = max(X)\n            L = dfs(G, MX, -1, MEM)[0]\n            S = R * pow(L, MOD - 2, MOD) % MOD\n            print(MX + 1, S)\n            continue\n        X = X[0]\n        Y = []\n        for i in G3[X]:\n            G2[i] -= 1\n            if G2[i] == 0:\n                j = X\n                if CH[i] < CH[j]:\n                    a = CH[i]\n                    b = N - a\n                else:\n                    b = CH[j]\n                    a = N - b\n                Y.append((a / b, i))\n        MX = max(Y)[1]\n        L = dfs(G, MX, -1, MEM)[0]\n        S = R * pow(L, MOD - 2, MOD) % MOD\n        print(MX + 1, S)\nmain()", "import sys\nsys.setrecursionlimit(5 * 10 ** 5)\nprime = 10 ** 9 + 7\n\ndef num_total_orderings(T, root):\n    global accum, numerator_factor\n    N = len(T)\n    accum = 1\n    numerator_factor = N\n    S = [1] * (N + 1)\n\n    def tracer(root, S, parent=None):\n        global accum, numerator_factor\n        for neighbor in T[root]:\n            if neighbor != parent:\n                tracer(neighbor, S, root)\n                S[root] += S[neighbor]\n        accum *= numerator_factor\n        accum *= inverse(S[root])\n        accum %= prime\n        numerator_factor -= 1\n    tracer(root, S)\n    return (accum, S)\n\ndef centroid(T):\n    n = len(T)\n    S = num_total_orderings(T, 1)[1]\n\n    def tracer(root, parent=None):\n        for neighbor in T[root]:\n            if neighbor != parent:\n                if 2 * S[neighbor] == n:\n                    return max(root, neighbor)\n                if 2 * S[neighbor] > n:\n                    return tracer(neighbor, root)\n        return root\n    return tracer(1)\n\ndef pow_mod(base, exponent, modulus):\n    if exponent == 0:\n        return 1\n    sqrt = pow_mod(base, exponent // 2, modulus)\n    ret = sqrt * sqrt\n    if exponent % 2 == 1:\n        ret *= base\n    return ret % modulus\ninverse_dict = dict()\n\ndef inverse(num):\n    if num not in inverse_dict:\n        inverse_dict[num] = pow_mod(num, prime - 2, prime)\n    return inverse_dict[num]\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    T = {v: [] for v in range(1, N + 1)}\n    for _ in range(N - 1):\n        (v, w) = map(int, input().split())\n        T[v].append(w)\n        T[w].append(v)\n    c = centroid(T)\n    (num, S) = num_total_orderings(T, c)\n    if K == 1:\n        print(c, num)\n    elif K == 2:\n        v = max([(S[w], w) for w in T[c]])[1]\n        print(v, num * S[v] * inverse(N - S[v]) % prime)", "import sys\nsys.setrecursionlimit(5 * 10 ** 5)\nprime = 10 ** 9 + 7\n\ndef num_total_orderings(T, root):\n    global accum, numerator_factor\n    accum = 1\n    N = len(T)\n    numerator_factor = N\n    S = [1] * (N + 1)\n\n    def tracer(root, S, parent=None):\n        global accum, numerator_factor\n        for neighbor in T[root]:\n            if neighbor != parent:\n                tracer(neighbor, S, root)\n                S[root] += S[neighbor]\n        accum *= numerator_factor\n        accum *= inverse(S[root])\n        accum %= prime\n        numerator_factor -= 1\n    tracer(root, S)\n    return (accum, S)\n\ndef centroid(T):\n    n = len(T)\n    S = num_total_orderings(T, 1)[1]\n\n    def tracer(root, parent=None):\n        for neighbor in T[root]:\n            if neighbor != parent:\n                if 2 * S[neighbor] == n:\n                    return max(root, neighbor)\n                if 2 * S[neighbor] > n:\n                    return tracer(neighbor, root)\n        return root\n    return tracer(1)\n\ndef pow_mod(base, exponent, modulus):\n    if exponent == 0:\n        return 1\n    sqrt = pow_mod(base, exponent // 2, modulus)\n    ret = sqrt * sqrt\n    if exponent % 2 == 1:\n        ret *= base\n    return ret % modulus\ninverse_dict = dict()\n\ndef inverse(num):\n    if num not in inverse_dict:\n        inverse_dict[num] = pow_mod(num, prime - 2, prime)\n    return inverse_dict[num]\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    T = {v: [] for v in range(1, N + 1)}\n    for _ in range(N - 1):\n        (v, w) = map(int, input().split())\n        T[v].append(w)\n        T[w].append(v)\n    c = centroid(T)\n    (n, S) = num_total_orderings(T, c)\n    if K == 1:\n        print(c, n)\n    elif K == 2:\n        v = max([(S[w], w) for w in T[c]])[1]\n        print(v, num_total_orderings(T, v)[0])", "import sys\nsys.setrecursionlimit(5 * 10 ** 5)\nprime = 10 ** 9 + 7\n\ndef num_total_orderings(T, root):\n    global accum, numerator_factor\n    accum = 1\n    numerator_factor = len(T)\n    S = dict()\n\n    def tracer(root, S, parent=None):\n        global accum, numerator_factor\n        S[root] = 1\n        for neighbor in T[root]:\n            if neighbor != parent:\n                tracer(neighbor, S, root)\n                S[root] += S[neighbor]\n        accum *= numerator_factor\n        accum *= inverse(S[root])\n        accum %= prime\n        numerator_factor -= 1\n    tracer(root, S)\n    return (accum, S)\n\ndef centroid(T):\n    n = len(T)\n    S = num_total_orderings(T, 1)[1]\n\n    def tracer(root, parent=None):\n        for neighbor in T[root]:\n            if neighbor != parent:\n                if 2 * S[neighbor] == n:\n                    return max(root, neighbor)\n                if 2 * S[neighbor] > n:\n                    return tracer(neighbor, root)\n        return root\n    return tracer(1)\n\ndef pow_mod(base, exponent, modulus):\n    if exponent == 0:\n        return 1\n    sqrt = pow_mod(base, exponent // 2, modulus)\n    ret = sqrt * sqrt\n    if exponent % 2 == 1:\n        ret *= base\n    return ret % modulus\ninverse_dict = dict()\n\ndef inverse(num):\n    if num not in inverse_dict:\n        inverse_dict[num] = pow_mod(num, prime - 2, prime)\n    return inverse_dict[num]\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    T = {v: [] for v in range(1, N + 1)}\n    for _ in range(N - 1):\n        (v, w) = map(int, input().split())\n        T[v].append(w)\n        T[w].append(v)\n    c = centroid(T)\n    (n, S) = num_total_orderings(T, c)\n    if K == 1:\n        print(c, n)\n    elif K == 2:\n        v = max([(S[w], w) for w in T[c]])[1]\n        print(v, num_total_orderings(T, v)[0])", "import sys\nsys.setrecursionlimit(5 * 10 ** 5)\nprime = 10 ** 9 + 7\n\ndef num_total_orderings(T, root):\n    global accum, numerator_factor\n    accum = 1\n    numerator_factor = len(T)\n    S = dict()\n\n    def tracer(root, S, parent=None):\n        global accum, numerator_factor\n        S[root] = 1\n        for neighbor in T[root]:\n            if neighbor != parent:\n                tracer(neighbor, S, root)\n                S[root] += S[neighbor]\n        accum *= numerator_factor\n        accum *= inverse(S[root])\n        accum %= prime\n        numerator_factor -= 1\n    tracer(root, S)\n    return (accum, S)\n\ndef centroid(T):\n    n = len(T)\n    S = num_total_orderings(T, 1)[1]\n\n    def tracer(root, parent=None):\n        for neighbor in T[root]:\n            if neighbor != parent:\n                if 2 * S[neighbor] == n:\n                    return (root, neighbor)\n                if 2 * S[neighbor] > n:\n                    return tracer(neighbor, root)\n        return root\n    return tracer(1)\n\ndef pow_mod(base, exponent, modulus):\n    if exponent == 0:\n        return 1\n    sqrt = pow_mod(base, exponent // 2, modulus)\n    ret = sqrt * sqrt\n    if exponent % 2 == 1:\n        ret *= base\n    return ret % modulus\ninverse_dict = dict()\n\ndef inverse(num):\n    if num not in inverse_dict:\n        inverse_dict[num] = pow_mod(num, prime - 2, prime)\n    return inverse_dict[num]\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    T = {v: [] for v in range(1, N + 1)}\n    for _ in range(N - 1):\n        (v, w) = map(int, input().split())\n        T[v].append(w)\n        T[w].append(v)\n    c = centroid(T)\n    if isinstance(c, tuple):\n        c = max(c)\n    (n, S) = num_total_orderings(T, c)\n    if K == 1:\n        print(c, n)\n    elif K == 2:\n        v = max([(S[w], w) for w in T[c]])[1]\n        print(v, num_total_orderings(T, v)[0])"]