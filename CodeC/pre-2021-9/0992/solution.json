["import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2, l):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n(n, q) = [int(i) for i in input().split()]\ncircles = []\nquery = []\nfor j in range(n):\n    circles.append([int(i) for i in input().split()])\nfor i in range(q):\n    query.append(int(input()))\nl = [0] * 1000001\nfor i in range(len(circles)):\n    for j in range(i + 1, len(circles)):\n        x = calculate(circles[i], circles[j], l)\n        l[math.ceil(x[0])] += 1\n        l[math.floor(x[1]) + 1] -= 1\nfor i in range(1, len(l)):\n    l[i] = l[i] + l[i - 1]\nfor i in query:\n    print(l[i])", "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2, l):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n(n, q) = [int(i) for i in input().split()]\ncircles = []\nquery = []\nfor j in range(n):\n    circles.append([int(i) for i in input().split()])\nfor i in range(q):\n    query.append(int(input()))\nl = [0] * 1000001\nfor i in range(len(circles)):\n    for j in range(i + 1, len(circles)):\n        x = calculate(circles[i], circles[j], l)\n        l[math.ceil(x[0])] += 1\n        l[math.floor(x[1]) + 1] -= 1\nfor i in range(1, len(l)):\n    l[i] = l[i] + l[i - 1]\nfor i in query:\n    print(l[i])", "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2, l):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n(n, q) = [int(i) for i in input().split()]\ncircles = []\nquery = []\nfor j in range(n):\n    circles.append([int(i) for i in input().split()])\nfor i in range(q):\n    query.append(int(input()))\nl = [0] * 1000001\nfor i in range(len(circles)):\n    for j in range(i + 1, len(circles)):\n        x = calculate(circles[i], circles[j], l)\n        l[math.ceil(x[0])] += 1\n        l[math.floor(x[1]) + 1] -= 1\nfor i in range(1, len(l)):\n    l[i] = l[i] + l[i - 1]\nfor i in query:\n    print(l[i])", "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2, l):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n(n, q) = [int(i) for i in input().split()]\ncircles = []\nquery = []\nfor j in range(n):\n    circles.append([int(i) for i in input().split()])\nfor i in range(q):\n    query.append(int(input()))\nl = [0] * 1000001\nfor i in range(len(circles)):\n    for j in range(i + 1, len(circles)):\n        x = calculate(circles[i], circles[j], l)\n        l[math.ceil(x[0])] += 1\n        l[math.floor(x[1]) + 1] -= 1\nfor i in range(1, len(l)):\n    l[i] = l[i] + l[i - 1]\nfor i in query:\n    print(l[i])", "import math\ncx = []\ncy = []\ncr = []\nfreq = [0] * 1000001\n(n, q) = map(int, input().split(' '))\nfor _ in range(n):\n    (x, y, r) = map(float, input().split(' '))\n    cx.append(x)\n    cy.append(y)\n    cr.append(r)\nqs = []\nfor _ in range(q):\n    qs.append(int(input()))\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        x = cx[i] - cx[j]\n        y = cy[i] - cy[j]\n        d = math.sqrt(x * x + y * y)\n        r1 = cr[i]\n        r2 = cr[j]\n        if d <= r1 + r2:\n            if math.fabs(r1 - r2) <= d:\n                kMin = 0\n            else:\n                kMin = math.ceil(math.fabs(r1 - r2) - d)\n        else:\n            kMin = math.ceil(d - r1 - r2)\n        kMAx = math.floor(d + r1 + r2) + 1\n        if kMin <= 1000000:\n            freq[int(kMin)] += 1\n        if kMAx <= 1000000:\n            freq[int(kMAx)] -= 1\nfor i in range(1, 1000001):\n    freq[i] += freq[i - 1]\nfor i in range(q):\n    print(freq[qs[i]])", "import math\ncx = []\ncy = []\ncr = []\nfreq = [0] * 1000001\n(n, q) = map(int, input().split(' '))\nfor _ in range(n):\n    (x, y, r) = map(float, input().split(' '))\n    cx.append(x)\n    cy.append(y)\n    cr.append(r)\nqs = []\nfor _ in range(q):\n    qs.append(int(input()))\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        x = cx[i] - cx[j]\n        y = cy[i] - cy[j]\n        d = math.sqrt(x * x + y * y)\n        r1 = cr[i]\n        r2 = cr[j]\n        if d <= r1 + r2:\n            if math.fabs(r1 - r2) <= d:\n                kMin = 0\n            else:\n                kMin = math.ceil(math.fabs(r1 - r2) - d)\n        else:\n            kMin = math.ceil(d - r1 - r2)\n        kMAx = math.floor(d + r1 + r2) + 1\n        if kMin <= 1000000:\n            freq[int(kMin)] += 1\n        if kMAx <= 1000000:\n            freq[int(kMAx)] -= 1\nfor i in range(1, 1000001):\n    freq[i] += freq[i - 1]\nfor i in range(q):\n    print(freq[qs[i]])", "def add(arr, N, lo, hi, val):\n    arr[lo] += val\n    if hi != N - 1:\n        arr[hi + 1] -= val\n\ndef updateArray(arr, N):\n    for i in range(1, N):\n        arr[i] += arr[i - 1]\n    return arr\nN = 1000001\ncar = [0 for x in range(0, 1000001)]\nimport math\n(l, u) = ([], [])\n(n, q) = [int(x) for x in input().split()]\nc = []\nfor i in range(n):\n    c.append([int(x) for x in input().split()])\nfor x in range(n):\n    for y in range(x + 1, n):\n        a = c[x]\n        b = c[y]\n        r1 = a[2]\n        r2 = b[2]\n        z = math.sqrt(math.pow(a[0] - b[0], 2) + math.pow(a[1] - b[1], 2))\n        if a != b:\n            if z < r1 + r2 and z <= abs(r1 - r2):\n                add(car, N, max(math.ceil(max(r1, r2) - z - min(r1, r2)), 0), math.floor(r1 + r2 + z), 1)\n            else:\n                add(car, N, max(0, math.ceil(z - r1 - r2)), math.floor(z + r1 + r2), 1)\ncar = updateArray(car, N)\nfor i in range(q):\n    k = int(input())\n    print(car[k])", "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt(math.pow(x1 - y1, 2) + math.pow(x2 - y2, 2) * 1.0)\n(n, q) = map(int, input().split())\na = []\nb = []\nfor i in range(0, n):\n    x = list(map(int, input().split()))\n    a.append(x)\nfor j in range(0, q):\n    k = int(input())\n    b.append(k)\nindex = [0] * 1000002\nfor i in range(0, n - 1):\n    for j in range(i + 1, n):\n        d = distance(a[i][0], a[j][0], a[i][1], a[j][1])\n        if d >= a[i][2] + a[j][2]:\n            mi = math.ceil(d - a[i][2] - a[j][2])\n            ma = math.floor(d + a[i][2] + a[j][2])\n        elif d < a[i][2] + a[j][2] and d >= abs(a[i][2] - a[j][2]):\n            mi = 0\n            ma = math.floor(d + a[i][2] + a[j][2])\n        elif d < a[i][2] + a[j][2]:\n            if a[i][2] > a[j][2]:\n                mi = math.ceil(a[i][2] - d - a[j][2])\n                ma = math.floor(d + a[i][2] + a[j][2])\n            else:\n                mi = math.ceil(a[j][2] - d - a[i][2])\n                ma = math.floor(d + a[i][2] + a[j][2])\n        index[mi] += 1\n        index[ma + 1] += -1\nfor i in range(1, 1000002):\n    index[i] += index[i - 1]\nfor k in range(0, q):\n    print(index[b[k]])", "import math\n(n, m) = map(int, input().split())\narr = []\nans = [0 for x in range(10 ** 6)]\nfor i in range(n):\n    arr.append([int(x) for x in input().split()])\nfor i in range(n):\n    for j in range(i + 1, n):\n        dist = math.sqrt(pow(arr[i][0] - arr[j][0], 2) + pow(arr[i][1] - arr[j][1], 2))\n        rmax = max(arr[i][2], arr[j][2])\n        rmin = min(arr[i][2], arr[j][2])\n        if rmax - rmin > dist:\n            minarr = rmax - rmin - dist\n            maxarr = rmax + rmin + dist\n        elif rmax + rmin > dist:\n            minarr = 0\n            maxarr = rmax + rmin + dist\n        else:\n            minarr = dist - rmax - rmin\n            maxarr = dist + rmax + rmin\n        ans[math.ceil(minarr)] += 1\n        ans[math.floor(maxarr) + 1] -= 1\nfor i in range(1, 10 ** 6):\n    ans[i] += ans[i - 1]\nfor i in range(m):\n    k = int(input())\n    print(ans[k])", "import math\nimport collections\nimport random\nimport time\nimport os\n\ndef getInput():\n    (N, M) = map(int, input().split())\n    A = []\n    for i in range(N):\n        (x, y, r) = map(int, input().split())\n        A.append((x, y, r))\n    qs = []\n    for i in range(M):\n        qs.append(int(input()))\n    return (N, A, qs)\n\ndef distance(circlea, circleb):\n    (x1, y1, r1) = circlea\n    (x2, y2, r2) = circleb\n    d = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    mxd = d + r1 + r2\n    (mnr, mxr) = (min(r1, r2), max(r1, r2))\n    mnd = max(0, d - r1 - r2, mxr - d - mnr)\n    return (mnd, mxd)\n\ndef preprocess(N, circles):\n    starts = collections.defaultdict(int)\n    ends = collections.defaultdict(int)\n    for i in range(N):\n        for j in range(i + 1, N):\n            (a, b) = distance(circles[i], circles[j])\n            starts[a] += 1\n            ends[b] += 1\n    return (starts, ends)\n\ndef query(queries, starts, ends):\n    points = [(p, 0, 0) for p in starts.keys()]\n    points += [(p, 2, 0) for p in ends.keys()]\n    points += [(p, 1, i) for (i, p) in enumerate(queries)]\n    ans = [0 for _ in range(len(queries))]\n    counts = 0\n    for (p, a, pi) in sorted(points):\n        if a == 1:\n            ans[pi] = counts\n        else:\n            counts += starts[p] - ends[p]\n    return ans\n\ndef solve(N, circles, queries):\n    (starts, ends) = preprocess(N, circles)\n    ans = query(queries, starts, ends)\n    print('\\n'.join(map(str, ans)))\n\ndef genInput():\n    N = 1000\n    A = [(random.randint(-1000, 1000), random.randint(-1000, 1000), random.randint(1, 300)) for _ in range(N)]\n    qs = [random.randint(0, 1000) for _ in range(5 * 10 ** 5)]\n    return (N, A, qs)\n\ndef test():\n    (N, a, qs) = genInput()\n    t0 = time.time()\n    solve(N, a, qs)\n    print(time.time() - t0)\n(N, A, qs) = getInput()\nsolve(N, A, qs)", "import math\n(t, k) = map(int, input().split())\nc = []\nres = [0 for x in range(10 ** 6 + 5)]\nl = r = 0\nfor x in range(t):\n    c.append(list(map(int, input().split())))\nfor i in range(t):\n    for j in range(i):\n        dx = c[i][0] - c[j][0]\n        dy = c[i][1] - c[j][1]\n        dc = math.sqrt(dx ** 2 + dy ** 2)\n        (r, R) = (min(c[i][2], c[j][2]), max(c[i][2], c[j][2]))\n        if R > dc + r:\n            l = R - dc - r\n        else:\n            l = dc - r - R\n        ll = math.ceil(max(0, l))\n        ul = math.floor(dc + r + R)\n        res[ll] += 1\n        res[ul + 1] -= 1\nfor i in range(1, 10 ** 6):\n    res[i] += res[i - 1]\nfor x in range(k):\n    print(res[int(input())])", "def endtime(tup):\n    return tup[1]\n(N, Q) = map(int, input().split())\narr = []\nfor i in range(N):\n    (X, Y, R) = map(int, input().split())\n    arr.append((X, Y, R))\nmain = []\nfor i in range(N):\n    for j in range(i + 1, N):\n        c1x = arr[i][0]\n        c1y = arr[i][1]\n        r1 = arr[i][2]\n        c2x = arr[j][0]\n        c2y = arr[j][1]\n        r2 = arr[j][2]\n        c1c2 = pow((c1x - c2x) * (c1x - c2x) + (c1y - c2y) * (c1y - c2y), 0.5)\n        if c1c2 >= r1 + r2:\n            minimum = c1c2 - r1 - r2\n            maximum = c1c2 + r1 + r2\n            main.append((minimum, maximum))\n        elif c1x == c2x and c1y == c2y:\n            minimum = abs(r2 - r1)\n            maximum = r1 + r2\n            main.append((minimum, maximum))\n        else:\n            maximum = c1c2 + r1 + r2\n            if c1c2 >= abs(r2 - r1):\n                minimum = 0\n            else:\n                minimum = abs(r2 - r1) - c1c2\n            main.append((minimum, maximum))\nmain.sort(key=endtime, reverse=True)\nfrom math import ceil\nK = pow(10, 6)\narr = [0] * (K + 1)\nfor i in main:\n    s = ceil(i[0])\n    e = int(i[1])\n    if e > K:\n        e = K\n    arr[s] += 1\n    arr[e + 1] += -1\nsum = 0\nfor i in range(K + 1):\n    sum += arr[i]\n    arr[i] = sum\nfor i in range(Q):\n    x = int(input())\n    print(arr[x])", "from math import hypot, ceil, floor\n\ndef function(A, B):\n    dist = hypot(B[0] - A[0], B[1] - A[1])\n    if dist >= A[2] + B[2]:\n        a_min = dist - A[2] - B[2]\n        a_max = dist + A[2] + B[2]\n    elif dist == abs(A[2] - B[2]):\n        a_min = 0\n        a_max = 2 * max(A[2], B[2])\n    elif dist < abs(A[2] - B[2]):\n        a_min = max(A[2], B[2]) - min(A[2], B[2]) - dist\n        a_max = A[2] + B[2] + dist\n    elif abs(A[2] - B[2]) < dist < A[2] + B[2]:\n        a_min = 0\n        a_max = A[2] + B[2] + dist\n    return [ceil(a_min), floor(a_max)]\n(N, Q) = map(int, input().split())\ndata = []\nfor i in range(N):\n    (x, y, r) = map(int, input().split())\n    data.append([x, y, r])\nfinal_data = [0] * 10000003\nc = 0\nfor i in range(N - 1):\n    for j in range(i + 1, N):\n        (a, b) = function(data[i], data[j])\n        c = max(b, c)\n        final_data[a] += 1\n        final_data[b + 1] -= 1\nfor i in range(1, c + 3):\n    final_data[i] += final_data[i - 1]\nfor q in range(Q):\n    print(final_data[int(input())])", "from math import hypot, ceil, floor\n\ndef function(A, B):\n    dist = hypot(B[0] - A[0], B[1] - A[1])\n    if dist >= A[2] + B[2]:\n        a_min = dist - A[2] - B[2]\n        a_max = dist + A[2] + B[2]\n    elif dist == abs(A[2] - B[2]):\n        a_min = 0\n        a_max = 2 * max(A[2], B[2])\n    elif dist < abs(A[2] - B[2]):\n        a_min = max(A[2], B[2]) - min(A[2], B[2]) - dist\n        a_max = A[2] + B[2] + dist\n    elif abs(A[2] - B[2]) < dist < A[2] + B[2]:\n        a_min = 0\n        a_max = A[2] + B[2] + dist\n    return [ceil(a_min), floor(a_max)]\n(N, Q) = map(int, input().split())\ndata = []\nfor i in range(N):\n    (x, y, r) = map(int, input().split())\n    data.append([x, y, r])\nfinal_data = [0] * 10000003\nc = 0\nfor i in range(N - 1):\n    for j in range(i + 1, N):\n        (a, b) = function(data[i], data[j])\n        c = max(b, c)\n        final_data[a] += 1\n        final_data[b + 1] -= 1\nfor i in range(1, c + 3):\n    final_data[i] += final_data[i - 1]\nfor q in range(Q):\n    print(final_data[int(input())])", "import math\n(n, q) = map(int, input().split(' '))\ncx = []\ncy = []\ncr = []\nfor _ in range(n):\n    (x, y, r) = map(int, input().split(' '))\n    cx.append(x)\n    cy.append(y)\n    cr.append(r)\nqs = []\nfor _ in range(q):\n    qs.append(int(input()))\nk = [0] * 1000002\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        dx = cx[i] - cx[j]\n        dy = cy[i] - cy[j]\n        cc = math.sqrt(dx * dx + dy * dy)\n        d_min = d_max = 0.0\n        if cc >= cr[i] + cr[j]:\n            d_min = cc - cr[i] - cr[j]\n            d_max = cc + cr[i] + cr[j]\n        elif cc == abs(cr[i] - cr[j]):\n            d_min = 0\n            d_max = max(2 * cr[i], 2 * cr[j])\n        elif cc < abs(cr[i] - cr[j]):\n            d_min = max(cr[i], cr[j]) - cc - min(cr[i], cr[j])\n            d_max = cr[i] + cc + cr[j]\n        else:\n            d_min = 0\n            d_max = cr[i] + cr[j] + cc\n        d_ceil = int(math.ceil(d_min))\n        d_floor = int(math.floor(d_max))\n        k[d_ceil] += 1\n        k[d_floor + 1] -= 1\nfor i in range(1, len(k)):\n    k[i] += k[i - 1]\nfor i in range(q):\n    print(k[qs[i]])", "import math\n\nclass Circle:\n\n    def __init__(self, x, y, r):\n        self.x = x\n        self.y = y\n        self.r = r\nc = []\nfreq = [0] * 1000001\n(n, q) = map(int, input().split(' '))\nfor _ in range(n):\n    (x, y, r) = map(float, input().split(' '))\n    c.append(Circle(x, y, r))\nqs = []\nfor _ in range(q):\n    qs.append(int(input()))\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        x = c[i].x - c[j].x\n        y = c[i].y - c[j].y\n        d = math.sqrt(x * x + y * y)\n        r1 = c[i].r\n        r2 = c[j].r\n        if d <= r1 + r2:\n            if math.fabs(r1 - r2) <= d:\n                kMin = 0\n            else:\n                kMin = math.ceil(math.fabs(r1 - r2) - d)\n        else:\n            kMin = math.ceil(d - r1 - r2)\n        kMAx = math.floor(d + r1 + r2) + 1\n        if kMin <= 1000000:\n            freq[int(kMin)] += 1\n        if kMAx <= 1000000:\n            freq[int(kMAx)] -= 1\nfor i in range(1, 1000001):\n    freq[i] += freq[i - 1]\nfor i in range(q):\n    print(freq[qs[i]])", "import math\ncx = []\ncy = []\ncr = []\nfreq = [0] * 1000001\n(n, q) = map(int, input().split(' '))\nfor _ in range(n):\n    (x, y, r) = map(float, input().split(' '))\n    cx.append(x)\n    cy.append(y)\n    cr.append(r)\nqs = []\nfor _ in range(q):\n    qs.append(int(input()))\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        x = cx[i] - cx[j]\n        y = cy[i] - cy[j]\n        d = math.sqrt(x * x + y * y)\n        r1 = cr[i]\n        r2 = cr[j]\n        if d <= r1 + r2:\n            if math.fabs(r1 - r2) <= d:\n                kMin = 0\n            else:\n                kMin = math.ceil(math.fabs(r1 - r2) - d)\n        else:\n            kMin = math.ceil(d - r1 - r2)\n        kMAx = math.floor(d + r1 + r2) + 1\n        if kMin <= 1000000:\n            freq[int(kMin)] += 1\n        if kMAx <= 1000000:\n            freq[int(kMAx)] -= 1\nfor i in range(1, 1000001):\n    freq[i] += freq[i - 1]\nfor i in range(q):\n    print(freq[qs[i]])", "import math\n(n, q) = map(int, input().split(' '))\ncx = []\ncy = []\ncr = []\nfor _ in range(n):\n    (x, y, r) = map(int, input().split(' '))\n    cx.append(x)\n    cy.append(y)\n    cr.append(r)\nqs = []\nfor _ in range(q):\n    qs.append(int(input()))\nk = [0] * 1000002\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        dx = cx[i] - cx[j]\n        dy = cy[i] - cy[j]\n        cc = math.sqrt(dx * dx + dy * dy)\n        d_min = d_max = 0.0\n        if cc >= cr[i] + cr[j]:\n            d_min = cc - cr[i] - cr[j]\n            d_max = cc + cr[i] + cr[j]\n        elif cc == abs(cr[i] - cr[j]):\n            d_min = 0\n            d_max = max(2 * cr[i], 2 * cr[j])\n        elif cc < abs(cr[i] - cr[j]):\n            d_min = max(cr[i], cr[j]) - cc - min(cr[i], cr[j])\n            d_max = min(cr[i], cr[j]) + cc + max(cr[i], cr[j])\n        else:\n            d_min = 0\n            d_max = cr[i] + cr[j] + cc\n        d_ceil = int(math.ceil(d_min))\n        d_floor = int(math.floor(d_max))\n        k[d_ceil] += 1\n        k[d_floor + 1] -= 1\nfor i in range(1, len(k)):\n    k[i] += k[i - 1]\nfor i in range(q):\n    print(k[qs[i]])", "import math\n(n, q) = map(int, input().split(' '))\ncx = []\ncy = []\ncr = []\nfor _ in range(n):\n    (x, y, r) = map(int, input().split(' '))\n    cx.append(x)\n    cy.append(y)\n    cr.append(r)\nqs = []\nfor _ in range(q):\n    qs.append(int(input()))\nk = [0] * 1000002\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        dx = cx[i] - cx[j]\n        dy = cy[i] - cy[j]\n        cc = math.sqrt(dx * dx + dy * dy)\n        d_min = d_max = 0.0\n        if cc >= cr[i] + cr[j]:\n            d_min = cc - cr[i] - cr[j]\n            d_max = cc + cr[i] + cr[j]\n        elif cc == abs(cr[i] - cr[j]):\n            d_min = 0\n            d_max = max(2 * cr[i], 2 * cr[j])\n        elif cc < abs(cr[i] - cr[j]):\n            d_min = max(cr[i], cr[j]) - cc - min(cr[i], cr[j])\n            d_max = min(cr[i], cr[j]) + cc + max(cr[i], cr[j])\n        else:\n            d_min = 0\n            d_max = cr[i] + cr[j] + cc\n        d_ceil = int(math.ceil(d_min))\n        d_floor = int(math.floor(d_max))\n        k[d_ceil] += 1\n        k[d_floor + 1] -= 1\nfor i in range(1, len(k)):\n    k[i] += k[i - 1]\nfor i in range(q):\n    print(k[qs[i]])", "import math\nfrom bisect import bisect_left\n(n, Q) = map(int, input().split())\ncircle = []\nfor i in range(n):\n    (x, y, r) = map(int, input().split())\n    circle.append([x, y, r])\n\ndef distance(c1, c2):\n    (x1, y1, r1) = (c1[0], c1[1], c1[2])\n    (x2, y2, r2) = (c2[0], c2[1], c2[2])\n    d = math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))\n    if d > r1 + r2:\n        return (d - r1 - r2, d + r1 + r2)\n    elif d == r1 + r2:\n        return (0, r1 + r1 + r2 + r2)\n    elif abs(r1 - r2) < d < r1 + r2:\n        return (0, r1 + d + r2)\n    elif d == abs(r1 - r2):\n        return (0, 2 * max(r1, r2))\n    else:\n        return (max(r1, r2) - d - min(r1, r2), r1 + d + r2)\nrng = [0] * 10 ** 6\nfor c1 in range(n):\n    for c2 in range(c1, n):\n        if c1 != c2:\n            (minm, maxm) = distance(circle[c1], circle[c2])\n            maxm = int(maxm)\n            if int(minm) - minm == 0:\n                minm = int(minm)\n            else:\n                minm = int(minm) + 1\n            rng[minm] += 1\n            rng[maxm + 1] -= 1\n\ndef add_one_by_one(L):\n    new_L = list(L)\n    for i in range(1, len(new_L)):\n        new_L[i] += new_L[i - 1]\n    return new_L\nrng = add_one_by_one(rng)\nfor q in range(Q):\n    k = int(input())\n    print(rng[k])", "import math\n(n, q) = map(int, input().split())\ncen = []\nr = []\nk = []\nvmin = []\nvmax = []\nindex = [0] * 1000000\nfor i in range(n):\n    (x, y, rad) = map(int, input().split())\n    cen.append([x, y])\n    r.append(rad)\nfor i in range(q):\n    k.append(int(input()))\nfor i in range(0, n - 1):\n    for j in range(i + 1, n):\n        cc = math.sqrt(pow(cen[i][0] - cen[j][0], 2) + pow(cen[i][1] - cen[j][1], 2))\n        if cc >= r[i] + r[j]:\n            vmin = cc - r[i] - r[j]\n            vmax = cc + r[i] + r[j]\n        elif cc == abs(r[i] - r[j]):\n            vmin = 0\n            vmax = max(2 * r[i], 2 * r[j])\n        elif cc < abs(r[i] - r[j]):\n            vmin = max(r[i], r[j]) - cc - min(r[i], r[j])\n            vmax = min(r[i], r[j]) + cc + max(r[i], r[j])\n        else:\n            vmin = 0\n            vmax = r[i] + r[j] + cc\n        index[math.ceil(vmin)] += 1\n        index[math.floor(vmax) + 1] -= 1\nfor i in range(1, 1000000):\n    index[i] += index[i - 1]\nfor i in range(q):\n    print(index[k[i]])", "import math\n\ndef swap(t1, t2):\n    return (t2, t1)\n\ndef cal_Range(a, b):\n    r1 = a[2]\n    r2 = b[2]\n    d = math.sqrt(pow(a[0] - b[0], 2) + pow(a[1] - b[1], 2))\n    rang = []\n    if d > r1 and d > r2:\n        pass\n    elif r1 > d and r1 > r2:\n        (d, r1) = swap(d, r1)\n    elif r2 > r1 and r2 > d:\n        (d, r2) = swap(d, r2)\n    rang.append(math.ceil(max(d - (r1 + r2), 0)))\n    rang.append(math.floor(d + r1 + r2))\n    return rang\n(n, q) = map(int, input().split(' '))\ncircles = []\nfor _ in range(n):\n    dim = list(map(int, input().split(' ')))\n    circles.append(dim)\ndistances = []\nno_rep = 0\nmax_dis = 0\nfor i in range(n):\n    temp = []\n    for j in range(n):\n        if i != j and no_rep < j:\n            temp.append(cal_Range(circles[i], circles[j]))\n            max_dis = max(temp[j][0], temp[j][1], max_dis)\n        else:\n            temp.append([-1, -1])\n    no_rep = no_rep + 1\n    distances.append(temp)\nranges_list = [0] * (max_dis + 2)\nfor i in range(n):\n    for j in range(n):\n        if distances[i][j][0] != -1:\n            ranges_list[distances[i][j][0]] += 1\n            ranges_list[distances[i][j][1] + 1] -= 1\ncounter = 0\nc_Arr = []\nfor i in range(len(ranges_list)):\n    counter += ranges_list[i]\n    c_Arr.append(counter)\nfor _ in range(q):\n    length = int(input())\n    try:\n        ans = c_Arr[length]\n        print(ans)\n    except:\n        print(0)", "import math\nfrom collections import Counter\n\ndef getRange(x1, y1, r1, x2, y2, r2):\n    distCenters = math.sqrt(math.pow(x1 - x2, 2) + math.pow(y1 - y2, 2))\n    if distCenters >= r1 + r2:\n        return (math.ceil(distCenters - r1 - r2), int(distCenters + r1 + r2))\n    elif abs(r1 - r2) <= distCenters:\n        return (0, int(distCenters + r1 + r2))\n    else:\n        return (math.ceil(abs(r1 - r2) - distCenters), int(distCenters + r1 + r2))\n(n, q) = map(int, input().strip().split())\ncircles = [0] * n\nfor i in range(n):\n    circles[i] = tuple(map(int, input().strip().split()))\nadders = list()\nsubs = list()\ncunt = Counter()\nfor i in range(n):\n    for j in range(i + 1, n):\n        t = getRange(circles[i][0], circles[i][1], circles[i][2], circles[j][0], circles[j][1], circles[j][2])\n        adders.append(t[0])\n        subs.append(t[1])\nadi = 1\nsubi = 0\nadders = sorted(adders)\nsubs = sorted(subs)\nlast = adders[0]\ncunt[last] = 1\nval = 1\nwhile adi < len(adders):\n    if adders[adi] > subs[subi]:\n        for i in range(last + 1, subs[subi] + 1):\n            cunt[i] = val\n        val -= 1\n        last = subs[subi]\n        subi += 1\n    else:\n        for i in range(last + 1, adders[adi]):\n            cunt[i] = val\n        val += 1\n        cunt[adders[adi]] = val\n        last = adders[adi]\n        adi += 1\nwhile subi < len(subs):\n    for i in range(last + 1, subs[subi] + 1):\n        cunt[i] = val\n    val -= 1\n    last = subs[subi]\n    subi += 1\nfor j in range(q):\n    k = int(input())\n    print(cunt[k])", "import math\nl = [int(s) for s in input().split()]\ng = []\nfor i in range(l[0]):\n    a = [int(s) for s in input().split()]\n    g.append(a)\nh = []\nmaxi = -1000\nfor i in range(len(g)):\n    for j in range(i + 1, len(g)):\n        DistBtwCenters = math.sqrt((g[i][0] - g[j][0]) ** 2 + (g[i][1] - g[j][1]) ** 2)\n        gd = DistBtwCenters + g[i][2] + g[j][2]\n        sd = -1000\n        if g[i][2] >= DistBtwCenters + g[j][2]:\n            sd = g[i][2] - (DistBtwCenters + g[j][2])\n        elif g[j][2] >= DistBtwCenters + g[i][2]:\n            sd = g[j][2] - (DistBtwCenters + g[i][2])\n        elif DistBtwCenters > g[i][2] + g[j][2]:\n            sd = DistBtwCenters - (g[i][2] + g[j][2])\n        elif DistBtwCenters <= g[i][2] + g[j][2]:\n            sd = 0\n        (sd_m, gd_m) = (math.ceil(sd), math.floor(gd))\n        if gd_m > maxi:\n            maxi = gd_m\n        h.append(sd_m)\n        h.append(gd_m)\nd = [0] * (maxi + 2)\nfor j in range(len(h)):\n    if j % 2 == 0:\n        d[h[j]] += 1\n    else:\n        d[h[j] + 1] += -1\nfor i in range(1, len(d)):\n    d[i] = d[i - 1] + d[i]\nfor k in range(l[1]):\n    n = int(input())\n    if 0 <= n < len(d):\n        print(d[n])\n    else:\n        print(0)", "from math import sqrt, floor, ceil\nfrom bisect import bisect_right\n(N, Q) = map(int, input().split())\ncircles = []\nboundaries = {0: 0}\nfor _ in range(N):\n    (X1, Y1, R1) = map(int, input().split())\n    for (X2, Y2, R2) in circles:\n        dist = sqrt((X1 - X2) ** 2 + (Y1 - Y2) ** 2)\n        floor_dist = floor(dist)\n        start = max(0, abs(R1 - R2) - floor_dist, ceil(dist) - R1 - R2)\n        end = floor_dist + R1 + R2 + 1\n        if start not in boundaries:\n            boundaries[start] = 0\n        boundaries[start] += 1\n        if end not in boundaries:\n            boundaries[end] = 0\n        boundaries[end] -= 1\n    circles.append((X1, Y1, R1))\nkeys = sorted(boundaries)\ngood_pairs = []\nfor key in keys:\n    if not key:\n        good_pairs.append(boundaries[0])\n    else:\n        good_pairs.append(good_pairs[-1] + boundaries[key])\nfor _ in range(Q):\n    K = int(input())\n    print(good_pairs[bisect_right(keys, K) - 1])", "import math\n(n, q) = map(int, input().split())\nx = []\ny = []\nr = []\nh = []\nfor i in range(0, n):\n    x.append(0)\n    y.append(0)\n    r.append(0)\nfor i in range(0, 1000003):\n    h.append(0)\nfor i in range(n):\n    (x[i], y[i], r[i]) = map(int, input().split())\nfor j in range(0, n - 1):\n    for l in range(j + 1, n):\n        a = math.sqrt(pow(x[j] - x[l], 2) + pow(y[j] - y[l], 2))\n        b = a + r[j] + r[l]\n        c = r[j] + r[l]\n        if a > c:\n            d = a - c\n        elif a + min(r[j], r[l]) < max(r[j], r[l]):\n            d = max(r[j], r[l]) - a - min(r[j], r[l])\n        else:\n            d = 0\n        u = math.floor(b)\n        v = math.ceil(d)\n        h[v] += 1\n        h[u + 1] -= 1\nfor i in range(1, 1000003):\n    h[i] = h[i] + h[i - 1]\nwhile q != 0:\n    k = int(input())\n    print(h[k])\n    q -= 1", "import math\n(n, q) = map(int, input().split(' '))\nlia = []\nfor i in range(n):\n    temp = list(map(int, input().split(' ')))\n    lia.append(temp)\n\ndef powo(x, y):\n    if y == 0:\n        return 1\n    elif y % 2 == 0:\n        return powo(x, y // 2) * powo(x, y // 2)\n    else:\n        return x * powo(x, y // 2) * powo(x, y // 2)\nfina = [0] * 1000005\nfor i in range(n):\n    for j in range(i + 1, n):\n        r1 = lia[i][2]\n        r2 = lia[j][2]\n        x1 = lia[i][0]\n        x2 = lia[j][0]\n        y1 = lia[i][1]\n        y2 = lia[j][1]\n        dis = math.sqrt(powo(x1 - x2, 2) + powo(y1 - y2, 2))\n        if dis > r1 + r2:\n            fina[math.ceil(dis) - r1 - r2] += 1\n            fina[math.floor(dis) + r1 + r2 + 1] -= 1\n        elif dis < abs(r1 - r2):\n            fina[math.ceil(abs(r1 - r2) - dis)] += 1\n            fina[math.floor(dis) + r1 + r2 + 1] -= 1\n        elif dis == abs(r1 - r2):\n            fina[0] += 1\n            fina[2 * max(r1, r2) + 1] -= 1\n        elif dis == r1 + r2:\n            fina[0] += 1\n            fina[2 * (r1 + r2) + 1] -= 1\n        else:\n            fina[0] += 1\n            fina[r1 + r2 + math.floor(dis) + 1] -= 1\nfor i in range(1, 1000005):\n    fina[i] += fina[i - 1]\nfor i in range(q):\n    k = int(input())\n    print(fina[k])", "from math import sqrt\n\ndef solve(intervals):\n    result = []\n    for i in range(len(intervals)):\n        result.append(intervals[i][0])\n        result.append(intervals[i][1])\n    result = sorted(list(set(result)))\n    end_count = {}\n    start_count = {}\n    for i in range(len(intervals)):\n        try:\n            end_count[intervals[i][1]] += 1\n        except:\n            end_count[intervals[i][1]] = 1\n    for i in range(len(intervals)):\n        try:\n            start_count[intervals[i][0]] += 1\n        except:\n            start_count[intervals[i][0]] = 1\n    ans = [0] * 1000007\n    val = 0\n    i = 0\n    k = 0\n    while k < len(result):\n        while i < result[k]:\n            ans[i] = val\n            i += 1\n        flag = False\n        while k < len(result) and result[k] <= i:\n            if result[k] in start_count:\n                val += start_count[result[k]]\n            if result[k] in end_count:\n                if result[k] == i:\n                    ans[i] = val\n                    flag = True\n                    val -= end_count[result[k]]\n                    k += 1\n                    i += 1\n                    break\n                val -= end_count[result[k]]\n            k += 1\n        if not flag:\n            ans[i] = val\n            i += 1\n    return ans\n\ndef circle(c1, c2):\n    x1 = c1[0]\n    y1 = c1[1]\n    r1 = c1[2]\n    x2 = c2[0]\n    y2 = c2[1]\n    r2 = c2[2]\n    distSq = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    radSumSq = (r1 + r2) * (r1 + r2)\n    if distSq >= radSumSq:\n        minn = sqrt(distSq) - r1 - r2\n        maxx = sqrt(distSq) + r1 + r2\n    else:\n        minn = abs(r1 - r2) - sqrt(distSq)\n        maxx = sqrt(distSq) + r1 + r2\n    return (minn, maxx)\n(n, q) = map(int, input().split())\ncircle_data = []\nfor i in range(n):\n    (x, y, r) = map(int, input().split())\n    circle_data.append((x, y, r))\ndata = []\nfor i in range(n):\n    for j in range(i + 1, n):\n        data.append(circle(circle_data[i], circle_data[j]))\nans = solve(data)\nfor _ in range(q):\n    k = int(input())\n    print(ans[k])", "import math\n(n, q) = map(int, input().split())\ncircles = []\nfor _ in range(n):\n    l = input().split()\n    (l[0], l[1], l[2]) = (int(l[0]), int(l[1]), int(l[2]))\n    circles.append(l)\nnum = [0] * (10 ** 6 + 2)\nfor i in range(len(circles) - 1):\n    for j in range(i + 1, len(circles)):\n        dist = ((circles[i][0] - circles[j][0]) ** 2 + (circles[i][1] - circles[j][1]) ** 2) ** 0.5\n        r = circles[i][2] if circles[i][2] <= circles[j][2] else circles[j][2]\n        R = circles[i][2] if circles[i][2] > circles[j][2] else circles[j][2]\n        if dist - r - R > 0:\n            min_dist = dist - r - R\n            max_dist = dist + r + R\n        elif dist - r - R == 0:\n            min_dist = 0\n            max_dist = 2 * r + 2 * R\n        elif dist + r > R:\n            min_dist = 0\n            max_dist = dist + r + R\n        elif dist + r == R:\n            min_dist = 0\n            max_dist = dist - r + R\n        else:\n            min_dist = R - dist - r\n            max_dist = R + dist + r\n        (min_dist, max_dist) = (math.ceil(min_dist), math.floor(max_dist))\n        num[min_dist] += 1\n        num[max_dist + 1] += -1\nfor i in range(1, 10 ** 6 + 1):\n    num[i] += num[i - 1]\nfor _ in range(q):\n    k = int(input())\n    print(num[k])", "import math\n\ndef func(n, u):\n    c1c2 = math.sqrt(pow(n[0] - u[0], 2) + pow(n[1] - u[1], 2))\n    r1 = n[2]\n    r2 = u[2]\n    if r1 >= c1c2 + r2:\n        return (int(c1c2 + r1 + r2), max(math.ceil(r1 - c1c2 - r2), 0))\n    elif r2 >= c1c2 + r1:\n        return (int(c1c2 + r1 + r2), max(math.ceil(r2 - c1c2 - r1), 0))\n    else:\n        return (int(c1c2 + r1 + r2), max(math.ceil(c1c2 - (r1 + r2)), 0))\n(n, q) = map(int, input().split())\narr = []\nM = [0] * 1000001\nm = [0] * 1000001\nd = {}\nfor _ in range(n):\n    (x, y, r) = map(int, input().split())\n    arr.append([x, y, r])\nh = 0\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        (a, b) = func(arr[i], arr[j])\n        m[b] += 1\n        M[a] += 1\n        if a > h:\n            h = a\n        else:\n            continue\nd[0] = m[0]\nfor i in range(1, h + 1):\n    d[i] = m[i] - M[i - 1] + d[i - 1]\nfor _ in range(q):\n    k = int(input())\n    if k > h:\n        print(0)\n    else:\n        print(d[k])", "import math\n\ndef dist(c1, c2):\n    return math.sqrt((c1[0] - c2[0]) ** 2 + (c1[1] - c2[1]) ** 2)\n(n, q) = map(int, input().split())\nl = []\nfor i in range(n):\n    t = list(map(int, input().split()))\n    l.append(t)\nres = [0] * (10 ** 6 + 1)\nfor i in range(n):\n    for j in range(i + 1, n):\n        d = dist(l[i], l[j])\n        (r1, r2) = (l[i][2], l[j][2])\n        if d > r1 + r2:\n            mi = d - (r1 + r2)\n            mx = d + (r1 + r2)\n            res[math.ceil(mi)] += 1\n            res[math.floor(mx) + 1] -= 1\n        elif abs(r1 - r2) <= d and d <= r1 + r2:\n            mi = 0\n            mx = d + r1 + r2\n            res[math.ceil(mi)] += 1\n            res[math.floor(mx) + 1] -= 1\n        else:\n            mi = max(r1, r2) - d - min(r1, r2)\n            mx = d + r1 + r2\n            res[math.ceil(mi)] += 1\n            res[math.floor(mx) + 1] -= 1\nfor i in range(1, len(res)):\n    res[i] += res[i - 1]\nfor a0 in range(q):\n    k = int(input())\n    print(res[k])", "import sys\nfrom math import *\nfrom itertools import *\n\ndef dist(A, B):\n    (x1, y1) = (A[0], A[1])\n    (x2, y2) = (B[0], B[1])\n    y = (y2 - y1) ** 2\n    x = (x2 - x1) ** 2\n    ans = (x + y) ** 0.5\n    return ans\n\ndef interact(A, B):\n    r1 = A[2]\n    r2 = B[2]\n    CC = dist(A, B)\n    if CC >= r1 + r2:\n        return (0, CC)\n    elif CC == 0 and r1 == r2:\n        return (1, CC)\n    elif CC <= abs(r1 - r2):\n        return (2, CC)\n    else:\n        return (1, CC)\n\ndef MinMaxDist(A, B):\n    (r1, r2) = (max(A[2], B[2]), min(A[2], B[2]))\n    (flag, CC) = interact(A, B)\n    if flag == 0:\n        minDist = CC - r1 - r2\n        maxDist = CC + r1 + r2\n    elif flag == 1:\n        minDist = 0\n        maxDist = CC + r1 + r2\n    elif flag == 2:\n        minDist = r1 - r2 - CC\n        maxDist = r1 + r2 + CC\n    return (minDist, maxDist)\n(N, Q) = list(map(int, input().strip().split()))\ncircles = []\narr = [0 for i in range(1000000)]\nfor i in range(N):\n    (X, Y, R) = map(int, sys.stdin.readline().split())\n    circles.append((X, Y, R))\n    for j in range(i):\n        (mini, maxi) = MinMaxDist(circles[i], circles[j])\n        mini = ceil(mini)\n        maxi = floor(maxi)\n        arr[mini] += 1\n        arr[maxi + 1] -= 1\nprefix = list(accumulate(arr))\nfor i in range(Q - 1):\n    K = int(sys.stdin.readline())\n    if i != Q - 1:\n        sys.stdout.write(str(prefix[K]) + '\\n')\nK = int(sys.stdin.readline())\nsys.stdout.write(str(prefix[K]))", "import math\n(N, Q) = map(int, input().split())\n(C, L, K) = ([], [], [])\n_ = [C.append([int(x) for x in input().split()]) for _ in range(N)]\nfor i in range(N):\n    for j in range(i + 1, N):\n        if C[i][0] == C[j][0] and C[i][1] == C[j][1]:\n            L.append([int(abs(C[i][2] - C[j][2])), int(C[i][2] + C[j][2])])\n        else:\n            m = pow(pow(C[i][0] - C[j][0], 2) + pow(C[i][1] - C[j][1], 2), 0.5)\n            if m > C[i][2] + C[j][2]:\n                L.append([math.ceil(m - C[i][2] - C[j][2]), math.floor(m + C[i][2] + C[j][2])])\n            elif m + min(C[i][2], C[j][2]) <= max(C[i][2], C[j][2]):\n                L.append([math.ceil(max(C[i][2], C[j][2]) - m - min(C[i][2], C[j][2])), math.floor(max(C[i][2], C[j][2]) + m + min(C[i][2], C[j][2]))])\n            else:\n                L.append([0, math.floor(C[i][2] + C[j][2] + m)])\n_ = [K.append([int(x) for x in input().split()]) for i in range(Q)]\nM = [0] * 1000002\nfor l in L:\n    M[l[0]] += 1\n    M[l[1] + 1] -= 1\nfor i in range(1, 1000000):\n    M[i] += M[i - 1]\nfor k in K:\n    print(M[k[0]])", "import math\na = [int(i) for i in input().split()]\nb = []\nd = []\ne = []\ng = []\nout = [0] * 10 ** 6\nt = a[0] * (a[0] - 1)\nfor i in range(a[0]):\n    b.append([int(i) for i in input().split()])\nfor i in range(a[1]):\n    c = int(input())\n    d.append(c)\nfor i in range(len(b)):\n    for j in range(i + 1, len(b)):\n        h = math.sqrt((b[i][0] - b[j][0]) ** 2 + (b[i][1] - b[j][1]) ** 2)\n        if h > abs(b[i][2] - b[j][2]) and h <= b[i][2] + b[j][2] or h >= b[i][2] + b[j][2]:\n            k = math.sqrt((b[i][0] - b[j][0]) ** 2 + (b[i][1] - b[j][1]) ** 2) - b[i][2] - b[j][2]\n            if k > 0:\n                out[math.ceil(k)] = out[math.ceil(k)] + 1\n            else:\n                out[0] = out[0] + 1\n            ck = math.floor(math.sqrt((b[i][0] - b[j][0]) ** 2 + (b[i][1] - b[j][1]) ** 2) + b[i][2] + b[j][2])\n            out[ck + 1] = out[ck + 1] - 1\n        elif h == abs(b[i][2] - b[j][2]):\n            out[0] = out[0] + 1\n            ck1 = math.floor(2 * max(b[i][2], b[j][2]))\n            out[ck1 + 1] = out[ck1 + 1] - 1\n        else:\n            max1 = max(b[i][2], b[j][2])\n            min1 = min(b[i][2], b[j][2])\n            out[math.ceil(max1 - h - min1)] = out[math.ceil(max1 - h - min1)] + 1\n            ck3 = math.floor(max1 + h + min1)\n            out[ck3 + 1] = out[ck3 + 1] - 1\nout1 = [0] * 10 ** 6\nout1[0] = out[0]\nfor i in range(1, len(out)):\n    out1[i] = out1[i - 1] + out[i]\nfor i in d:\n    print(out1[i])", "import math\n\ndef ed(x1, y1, x2, y2):\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n(n, q) = [int(j) for j in input().split()]\nl = [[0] for i in range(n)]\nfor i in range(n):\n    l1 = [int(j) for j in input().split()]\n    l[i] = l1\nl2 = [0 for i in range(10 ** 6 + 1)]\ncn = 0\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        k = ed(l[i][0], l[i][1], l[j][0], l[j][1])\n        ab = abs(l[i][2] - l[j][2])\n        f1 = l[i][2] + l[j][2] + k\n        if k < ab:\n            l2[math.ceil(ab - k)] += 1\n            l2[math.floor(f1) + 1] -= 1\n        elif k >= ab and k <= l[i][2] + l[j][2]:\n            l2[0] += 1\n            l2[math.floor(f1) + 1] -= 1\n        else:\n            l2[math.ceil(k - (l[i][2] + l[j][2]))] += 1\n            l2[math.floor(f1) + 1] -= 1\nfor i in range(1, 10 ** 6 + 1):\n    l2[i] = l2[i] + l2[i - 1]\nfor k1 in range(q):\n    f1 = int(input())\n    print(l2[f1])", "import math\n\ndef dist(x1, y1, x2, y2):\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\ndef get_range(c1, c2):\n    (x1, y1, r1) = c1\n    (x2, y2, r2) = c2\n    if c1 == c2:\n        return (0, 2 * r1)\n    k = dist(x1, y1, x2, y2)\n    if k >= r1 + r2:\n        return (k - r1 - r2, k + r1 + r2)\n    elif k <= abs(r2 - r1):\n        r_1 = min(r1, r2)\n        r_2 = max(r1, r2)\n        return (r_2 - k - r_1, r_2 + k + r_1)\n    else:\n        return (0, r1 + r2 + k)\n(N, Q) = [int(i) for i in input().split()]\nli = [tuple([int(i) for i in input().split()]) for j in range(N)]\nqls = [int(input()) for i in range(Q)]\nsli = [0 for i in range(10 ** 6 + 2)]\nfor i in range(N):\n    for j in range(i + 1, N):\n        (mn, mx) = get_range(li[i], li[j])\n        mn = math.ceil(mn)\n        mx = math.floor(mx)\n        sli[mn] += 1\n        sli[mx + 1] -= 1\nfor i in range(1, 10 ** 6 + 1):\n    sli[i] += sli[i - 1]\nfor i in qls:\n    print(sli[i])", "from math import sqrt, ceil, floor\n(n, q) = map(int, input().split())\nx = []\ny = []\nr = []\nqu = []\ns = n\nwhile s > 0:\n    s -= 1\n    (xx, yy, rr) = map(int, input().split())\n    x.append(xx)\n    y.append(yy)\n    r.append(rr)\ns = q\nwhile s > 0:\n    s -= 1\n    qs = int(input())\n    qu.append(qs)\nl = []\nu = []\nk = 0\nf = [0] * (10 ** 6 + 10)\nfor i in range(0, n):\n    for j in range(i + 1, n):\n        if x[i] == x[j] and y[i] == y[j]:\n            l.append(abs(r[i] - r[j]))\n            u.append(abs(r[i] + r[j]))\n            if r[i] == r[j]:\n                u.pop()\n                u.append(0)\n        else:\n            d = sqrt((x[i] - x[j]) ** 2 + (y[i] - y[j]) ** 2)\n            if d > r[i] + r[j]:\n                l.append(d - (r[i] + r[j]))\n                u.append(d + (r[i] + r[j]))\n            elif d == r[i] + r[j]:\n                l.append(0)\n                u.append(2 * r[i] + 2 * r[j])\n            elif d < r[i] + r[j] and d > abs(r[i] - r[j]):\n                l.append(0)\n                u.append(d + r[i] + r[j])\n            elif d < abs(r[i] - r[j]):\n                r1 = max(r[i], r[j])\n                r2 = min(r[i], r[j])\n                l.append(r1 - (d + r2))\n                u.append(r1 + r2 + d)\n            elif d == abs(r[i] - r[j]):\n                r1 = max(r[i], r[j])\n                r2 = min(r[i], r[j])\n                l.append(0)\n                u.append(2 * r1)\n        f[ceil(l[k])] += 1\n        f[floor(u[k]) + 1] -= 1\n        k += 1\nfor i in range(1, floor(max(u)) + 1):\n    f[i] = f[i - 1] + f[i]\no = floor(max(u))\nfor i in range(0, q):\n    if qu[i] > o:\n        print(0)\n    else:\n        print(f[qu[i]])", "import math\n(n, q) = map(int, input().split())\nx = []\ny = []\nr = []\nfor i in range(n):\n    (a, b, c) = map(int, input().split())\n    x.append(a)\n    y.append(b)\n    r.append(c)\ns = [0] * 5000000\nt = [0] * 5000000\nfor i in range(n):\n    for j in range(i + 1, n):\n        a1 = x[i]\n        b1 = y[i]\n        c1 = r[i]\n        a2 = x[j]\n        b2 = y[j]\n        c2 = r[j]\n        d = math.sqrt((a1 - a2) ** 2 + (b1 - b2) ** 2)\n        maxx = 0\n        minn = 0\n        if d >= c1 + c2:\n            maxx = c1 + c2 + d\n            minn = d - (c1 + c2)\n        elif a1 == a2 and b1 == b2:\n            maxx = c1 + c2\n            minn = abs(c1 - c2)\n        elif max(c1, c2) == d + min(c1, c2):\n            maxx = 2 * max(c1, c2)\n            minn = 0\n        elif max(c1, c2) < d + min(c1, c2):\n            maxx = d + c1 + c2\n            minn = 0\n        else:\n            maxx = d + c1 + c2\n            minn = max(c1, c2) - (d + min(c1, c2))\n        s[math.floor(maxx)] += 1\n        t[math.ceil(minn)] += 1\nfor i in range(1, 5000000):\n    t[i] += t[i - 1]\n    t[i] -= s[i - 1]\nfor i in range(q):\n    k = int(input())\n    print(t[k])", "import math\n(n, q) = map(int, input().split())\nx = []\ny = []\nr = []\nfor i in range(n):\n    (a, b, c) = map(int, input().split())\n    x.append(a)\n    y.append(b)\n    r.append(c)\ns = [0] * 5000000\nt = [0] * 5000000\nfor i in range(n):\n    for j in range(i + 1, n):\n        a1 = x[i]\n        b1 = y[i]\n        c1 = r[i]\n        a2 = x[j]\n        b2 = y[j]\n        c2 = r[j]\n        d = math.sqrt((a1 - a2) ** 2 + (b1 - b2) ** 2)\n        maxx = 0\n        minn = 0\n        if d >= c1 + c2:\n            maxx = c1 + c2 + d\n            minn = d - (c1 + c2)\n        elif a1 == a2 and b1 == b2:\n            maxx = c1 + c2\n            minn = abs(c1 - c2)\n        elif max(c1, c2) == d + min(c1, c2):\n            maxx = 2 * max(c1, c2)\n            minn = 0\n        elif max(c1, c2) < d + min(c1, c2):\n            maxx = d + c1 + c2\n            minn = 0\n        else:\n            maxx = d + c1 + c2\n            minn = max(c1, c2) - (d + min(c1, c2))\n        s[math.floor(maxx)] += 1\n        t[math.ceil(minn)] += 1\nfor i in range(1, 5000000):\n    t[i] += t[i - 1] - s[i - 1]\nfor i in range(q):\n    k = int(input())\n    print(t[k])", "import math\nans = [0 for i in range(0, 1000001)]\n(n, q) = map(int, input().split())\nar = [[0 for j in range(3)] for i in range(n)]\nfor i in range(0, n):\n    (ar[i][0], ar[i][1], ar[i][2]) = map(int, input().split())\n    for j in range(0, i):\n        euclideanDistance = math.sqrt((ar[i][0] - ar[j][0]) * (ar[i][0] - ar[j][0]) + (ar[i][1] - ar[j][1]) * (ar[i][1] - ar[j][1]))\n        if euclideanDistance < abs(ar[i][2] - ar[j][2]):\n            r1 = max(ar[i][2], ar[j][2])\n            r2 = min(ar[i][2], ar[j][2])\n            v = math.ceil(r1 - euclideanDistance - r2)\n            inv = int(r1 + r2 + euclideanDistance + 1)\n            if v < 0:\n                v = 0\n            ans[v] += 1\n            ans[inv] -= 1\n        else:\n            v = math.ceil(-ar[i][2] - ar[j][2] + euclideanDistance)\n            inv = int(ar[i][2] + ar[j][2] + euclideanDistance + 1)\n            if v < 0:\n                v = 0\n            ans[v] += 1\n            ans[inv] -= 1\nfor i in range(1, 1000001):\n    ans[i] += ans[i - 1]\nwhile q > 0:\n    k = int(input())\n    print(ans[k])\n    q -= 1", "import math\n(n, q) = map(int, input().split(' '))\nx = []\ny = []\nr = []\nfor i in range(n):\n    (x_, y_, r_) = map(int, input().split(' '))\n    x.append(x_)\n    y.append(y_)\n    r.append(r_)\nfin = [0] * 1000004\nfor i in range(n):\n    for j in range(i + 1, n):\n        (mi, mx) = (0, 0)\n        sa = math.sqrt(math.pow(abs(x[i] - x[j]), 2) + math.pow(abs(y[i] - y[j]), 2))\n        if sa > r[i] + r[j]:\n            fin[math.ceil(sa) - r[i] - r[j]] += 1\n            fin[math.floor(sa) + r[i] + r[j] + 1] -= 1\n        elif sa < abs(r[i] - r[j]):\n            fin[math.ceil(abs(r[i] - r[j]) - sa)] += 1\n            fin[math.floor(sa) + r[i] + r[j] + 1] -= 1\n        elif sa == abs(r[i] - r[j]):\n            fin[0] += 1\n            fin[2 * max(r[i], r[j]) + 1] += 1\n        elif sa == r[i] + r[j]:\n            fin[0] += 1\n            fin[2 * (r[i] + r[j]) + 1] -= 1\n        else:\n            fin[0] += 1\n            fin[r[i] + r[j] + math.floor(sa) + 1] -= 1\nfor i in range(1, 1000004):\n    fin[i] += fin[i - 1]\nfor i in range(q):\n    k = int(input())\n    print(fin[k])", "import math\nimport bisect\n\ndef dist(info1, info2):\n    return ((info1[0] - info2[0]) ** 2 + (info1[1] - info2[1]) ** 2) ** 0.5\n\ndef find_lt(a, x):\n    i = bisect.bisect_left(a, x)\n    if i:\n        return i\n    return -1\n\ndef find_gt(a, x):\n    i = bisect.bisect_right(a, x)\n    if i != len(a):\n        return i\n    return -1\n(n, q) = map(int, input().split())\ninfo = []\nfor _ in range(n):\n    (x, y, r) = map(int, input().split())\n    info.append([x, y, r])\nmaxs = []\nmins = []\nfor i in range(1, n):\n    (x1, y1, r1) = (info[i][0], info[i][1], info[i][2])\n    for j in range(0, i):\n        (x2, y2, r2) = (info[j][0], info[j][1], info[j][2])\n        dis = dist(info[i], info[j])\n        maxdis = 0\n        mindis = 0\n        if r1 + r2 <= dis:\n            mindis = dis - r1 - r2\n            maxdis = dis + r1 + r2\n        elif dis > abs(r1 - r2) and dis < r1 + r2:\n            maxdis = dis + r2 + r1\n            mindis = 0\n        elif dis == abs(r1 - r2):\n            maxdis = dis + r1 + r2\n            mindis = 0\n        elif abs(r1 - r2) > dis:\n            maxdis = dis + r1 + r2\n            mindis = abs(r1 - r2) - dis\n        maxdis = math.floor(maxdis)\n        mindis = math.ceil(mindis)\n        if x1 != x2 or y1 != y2 or r1 != r2:\n            maxs.append(maxdis)\n            mins.append(mindis)\nmins.sort()\nmaxs.sort()\nfor _ in range(q):\n    total = len(mins)\n    k = int(input())\n    y = find_gt(mins, k)\n    if y != -1:\n        total = y\n    if total != 0:\n        z = find_lt(maxs, k)\n        if z != -1:\n            total -= find_lt(maxs, k)\n    print(total)", "from math import ceil\n(n, q) = map(int, input().split())\nl = []\nd = []\nans = [0] * 1000002\n[l.append(tuple(map(int, input().split()))) for N in range(n)]\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        m = 0\n        d1 = ((l[i][0] - l[j][0]) ** 2 + (l[i][1] - l[j][1]) ** 2) ** 0.5\n        if l[j][2] > d1 + l[i][2] or l[i][2] > d1 + l[j][2]:\n            m = max(l[i][2], l[j][2]) - d1 - min(l[i][2], l[j][2])\n        elif d1 >= l[i][2] + l[j][2]:\n            m = d1 - l[i][2] - l[j][2]\n        M = d1 + l[i][2] + l[j][2]\n        ans[ceil(m)] += 1\n        ans[int(M) + 1] -= 1\nfor i in range(1, 1000001):\n    ans[i] += ans[i - 1]\n[print(ans[int(input())]) for Q in range(q)]", "from math import ceil, sqrt\n(n, q) = map(int, input().split())\ncircles = []\nfor i in range(n):\n    (x, y, r) = map(int, input().split())\n    circles.append((x, y, r))\ncounts = [0] * 2000000\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        (x1, y1, r1) = circles[i]\n        (x2, y2, r2) = circles[j]\n        (r1, r2) = (max(r1, r2), min(r1, r2))\n        mind = 0\n        cd = sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n        if r1 + r2 <= cd:\n            mind = int(ceil(cd - r1 - r2))\n        elif r1 >= cd + r2:\n            mind = int(ceil(r1 - cd - r2))\n        counts[mind] += 1\n        maxd = int(cd + r1 + r2)\n        if maxd + 1 < 2000000:\n            counts[maxd + 1] -= 1\nans = []\nfor i in range(1, len(counts)):\n    counts[i] += counts[i - 1]\nfor query in range(q):\n    k = int(input())\n    ans.append(counts[k])\nprint(*ans, sep='\\n')", "import math\n(n, q) = map(int, input().split())\nCir = []\nDis = []\nfor i in range(n):\n    (a, b, c) = map(int, input().split())\n    Cir.append([a, b, c])\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        AA = Cir[i]\n        BB = Cir[j]\n        dist = (AA[0] - BB[0]) ** 2 + (AA[1] - BB[1]) ** 2\n        dist = math.sqrt(dist)\n        if dist == AA[2] + BB[2]:\n            Dis.append([0, dist + AA[2] + BB[2]])\n        elif max(AA[2], BB[2]) > dist + min(AA[2], BB[2]):\n            Dis.append([max(AA[2], BB[2]) - dist - min(AA[2], BB[2]), dist + AA[2] + BB[2]])\n        elif dist < AA[2] + BB[2]:\n            Dis.append([0, dist + AA[2] + BB[2]])\n        else:\n            Dis.append([dist - AA[2] - BB[2], dist + AA[2] + BB[2]])\nDis2 = [0] * 1000007\nfor i in range(len(Dis)):\n    a = math.ceil(Dis[i][0])\n    b = math.floor(Dis[i][1])\n    Dis2[min(a, 1000001)] += 1\n    Dis2[min(b + 1, 1000001)] -= 1\nfor i in range(1, len(Dis2)):\n    Dis2[i] += Dis2[i - 1]\n    if Dis2[i] < 0:\n        Dis2[i] = 0\nfor i in range(q):\n    d = int(input())\n    print(Dis2[d])", "from math import sqrt, floor, ceil\n(n, q) = [int(x) for x in input().strip().split(' ')]\nl = []\nfor i in range(n):\n    l.append([int(x) for x in input().strip().split(' ')])\nstart = []\nend = []\nu = []\nfor i in range(n):\n    for j in range(i + 1, n):\n        c1c2 = sqrt((l[j][0] - l[i][0]) ** 2 + (l[j][1] - l[i][1]) ** 2)\n        if abs(l[j][2] - l[i][2]) < c1c2 < l[j][2] + l[i][2]:\n            start.append(0)\n            end.append(int(floor(c1c2 + l[i][2] + l[j][2])))\n        elif c1c2 >= l[j][2] + l[i][2]:\n            start.append(int(ceil(c1c2 - (l[j][2] + l[i][2]))))\n            end.append(int(floor(c1c2 + (l[j][2] + l[i][2]))))\n        elif c1c2 <= abs(l[i][2] - l[j][2]):\n            start.append(int(ceil(abs(l[i][2] - l[j][2]) - c1c2)))\n            end.append(int(floor(c1c2 + l[i][2] + l[j][2])))\nln = len(start)\nx = 1000001 * [0]\nfor i in range(ln):\n    x[start[i]] += 1\n    x[end[i] + 1] -= 1\ns = 0\nfor i in range(0, 1000001):\n    s += x[i]\n    x[i] = s\nfor i in range(q):\n    k = int(input().strip())\n    print(x[k])", "from math import *\n\ndef distance(x1, y1, x2, y2):\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2))\n(N, Q) = (int(i) for i in input().split())\ndiff_arr = [0] * 1000005\n\ndef increment(i, j):\n    i = max(i, 0)\n    j = min(j, 1000000)\n    diff_arr[i] += 1\n    diff_arr[j + 1] -= 1\ntab_X = []\ntab_Y = []\ntab_R = []\nfor _ in range(N):\n    (x, y, r) = (int(i) for i in input().split())\n    tab_X.append(x)\n    tab_Y.append(y)\n    tab_R.append(r)\nfor i in range(N):\n    for j in range(i + 1, N):\n        deuxRayons = tab_R[i] + tab_R[j]\n        dst = distance(tab_X[i], tab_Y[i], tab_X[j], tab_Y[j])\n        mx = int(floor(dst + deuxRayons))\n        minR = min(tab_R[i], tab_R[j])\n        maxR = max(tab_R[i], tab_R[j])\n        mn = dst - deuxRayons\n        if maxR > dst + minR:\n            mn = maxR - dst - minR\n        mn = int(ceil(mn))\n        increment(mn, mx)\nans = [0] * 1000005\nans[0] = diff_arr[0]\nfor i in range(1, 1000001):\n    ans[i] = ans[i - 1] + diff_arr[i]\nfor q in range(Q):\n    K = int(input())\n    print(ans[K])", "from math import *\n(n, q) = list(map(int, input().split()))\nl = []\na = [0] * (10 ** 6 + 3)\nfor i in range(n):\n    (x, y, r) = list(map(int, input().split()))\n    for i in l:\n        d = ((x - i[0]) ** 2 + (y - i[1]) ** 2) ** 0.5\n        if r - d - i[2] > 0:\n            mind = r - d - i[2]\n        elif i[2] - r - d > 0:\n            mind = i[2] - r - d\n        else:\n            mind = d - r - i[2]\n            if mind < 0:\n                mind = 0\n        mind = ceil(mind)\n        maxd = d + r + i[2]\n        maxd = int(maxd)\n        if maxd > 10 ** 6:\n            maxd = 10 ** 6\n        if mind > 10 ** 6:\n            mind = -1\n        a[mind] += 1\n        a[maxd + 1] -= 1\n    l.append((x, y, r))\nb = [0] * (10 ** 6 + 1)\nfor i in range(10 ** 6 + 1):\n    if i == 0:\n        b[i] = a[i]\n    else:\n        b[i] = b[i - 1] + a[i]\nfor i in range(q):\n    i = int(input())\n    print(b[i])", "from math import ceil\n(n, q) = [int(i) for i in input().split()]\na = []\nd = [[0] * 2 for i in range(10 ** 6)]\nfor i in range(n):\n    b = [float(j) for j in input().split()]\n    a.append(b)\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        (x1, y1, r1, x2, y2, r2) = (a[i][0], a[i][1], a[i][2], a[j][0], a[j][1], a[j][2])\n        di = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n        md = max(0, di - r1 - r2)\n        if di < abs(r1 - r2):\n            md = abs(r1 - r2) - di\n        d[ceil(md)][0] += 1\n        d[int(di + r1 + r2) + 1][1] -= 1\nm = [0] * 10 ** 6\nc = 0\nfor i in range(10 ** 6):\n    c += d[i][0] + d[i][1]\n    m[i] = c\nfor i in range(q):\n    print(m[int(input())])", "import math\nimport bisect\n(n, q) = [int(x) for x in input().split()]\nx = []\ny = []\nr = []\nm = []\nM = []\ndic = []\n(xx, yy, zz) = [int(x) for x in input().split()]\nx.append(xx)\ny.append(yy)\nr.append(zz)\nfor i in range(1, n):\n    (xx, yy, zz) = [int(x) for x in input().split()]\n    x.append(xx)\n    y.append(yy)\n    r.append(zz)\n    for j in range(i - 1, -1, -1):\n        u = math.sqrt((x[j] - x[i]) ** 2 + (y[j] - y[i]) ** 2)\n        min1 = u - r[i] - r[j]\n        if min1 < 0:\n            min1 = 0\n        if u + min(r[i], r[j]) < max(r[i], r[j]):\n            min1 = max(r[i], r[j]) - u - min(r[i], r[j])\n        max1 = u + r[i] + r[j]\n        M.append(max1)\n        m.append(min1)\nm.sort()\nM.sort()\nfor i in range(q):\n    k = int(input())\n    dic.append(k)\n    print(bisect.bisect_right(m, k) - bisect.bisect_left(M, k))", "import math\nimport bisect\n\ndef binarySearch(arr, l, r, x):\n    if r < l:\n        return -1\n    mid = int(l + (r - l) / 2)\n    if arr[mid] == x:\n        return mid\n    if arr[mid] > x:\n        return binarySearch(arr, l, mid - 1, x)\n    return binarySearch(arr, mid + 1, r, x)\n\ndef countOccurrences(arr, n, x):\n    ind = binarySearch(arr, 0, n - 1, x)\n    if ind == -1:\n        return 0\n    count = 1\n    left = ind - 1\n    while left >= 0 and arr[left] == x:\n        count += 1\n        left -= 1\n    right = ind + 1\n    while right < n and arr[right] == x:\n        count += 1\n        right += 1\n    return count\n(n, q) = [int(x) for x in input().split()]\nx = []\ny = []\nr = []\nm = []\nM = []\n(xx, yy, zz) = [int(x) for x in input().split()]\nx.append(xx)\ny.append(yy)\nr.append(zz)\nfor i in range(1, n):\n    (xx, yy, zz) = [int(x) for x in input().split()]\n    x.append(xx)\n    y.append(yy)\n    r.append(zz)\n    for j in range(i - 1, -1, -1):\n        u = math.sqrt((x[j] - x[i]) ** 2 + (y[j] - y[i]) ** 2)\n        min1 = u - r[i] - r[j]\n        if min1 < 0:\n            min1 = 0\n        if u + min(r[i], r[j]) < max(r[i], r[j]):\n            min1 = max(r[i], r[j]) - u - min(r[i], r[j])\n        M.append(u + r[i] + r[j])\n        m.append(min1)\nm.sort()\nM.sort()\nfor i in range(q):\n    k = int(input())\n    print(bisect.bisect_right(m, k) - bisect.bisect_left(M, k))", "from math import sqrt, floor, ceil\n\ndef check(a, b):\n    (mnr, mxr) = (min(a[2], b[2]), max(a[2], b[2]))\n    rsum = a[2] + b[2]\n    if a[0] == b[0] and a[1] == b[1]:\n        if a[2] == b[2]:\n            return [0, 2 * a[2]]\n        else:\n            return [mxr - mnr, rsum]\n    dis = sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)\n    mn = dis - rsum\n    mx = dis + rsum\n    if dis == a[2] + b[2]:\n        return [0, 2 * rsum]\n    elif dis > rsum:\n        return [mn, mx]\n    elif dis <= mxr - mnr:\n        p = mxr - (mnr + dis)\n        return [p, dis + rsum]\n    else:\n        return [0, dis + rsum]\n(n, q) = map(int, input().split())\na = []\nb = [0] * (10 ** 6 + 1)\nse = [[0, 0] for y in range(10 ** 6 + 2)]\nfor e in range(n):\n    a.append(list(map(int, input().split())))\nfor i in range(0, n - 1):\n    for j in range(i + 1, n):\n        x = check(a[i], a[j])\n        se[int(ceil(x[0]))][0] += 1\n        se[int(floor(x[1]))][1] += 1\np = 0\nfor i in range(0, 10 ** 6 + 1):\n    p += se[i][0]\n    b[i] = p\n    p -= se[i][1]\nfor e in range(q):\n    k = int(input())\n    print(b[k])", "import math\n\ndef adding_val(listval, N, l, h, val):\n    listval[l] += val\n    if h != N - 1:\n        listval[h + 1] -= val\n\ndef updatelistval(listval, N):\n    for i in range(1, N):\n        listval[i] += listval[i - 1]\n(n, q) = [int(x) for x in input().split()]\nc = []\nfor i in range(n):\n    c.append([int(x) for x in input().split()])\nks = 1000000\nkvals = [0 for i in range(ks)]\nfor x in range(n):\n    for y in range(x + 1, n):\n        a = c[x]\n        b = c[y]\n        r1 = a[2]\n        r2 = b[2]\n        z = math.sqrt(math.pow(a[0] - b[0], 2) + math.pow(a[1] - b[1], 2))\n        if a != b:\n            if z < r1 + r2 and z <= abs(r1 - r2):\n                adding_val(kvals, ks, max(0, math.ceil(max(r1, r2) - z - min(r1, r2))), math.floor(r1 + r2 + z), 1)\n            else:\n                adding_val(kvals, ks, max(0, math.ceil(z - r1 - r2)), math.floor(z + r1 + r2), 1)\ndel n\ndel c\nupdatelistval(kvals, ks)\nfor i in range(q):\n    query = int(input())\n    print(kvals[query])", "import math\nleft__limit = [0] * 5000007\nright_limit = [0] * 5000007\n\ndef rng(mn, mx):\n    left__limit[math.ceil(mn)] += 1\n    right_limit[int(mx)] += 1\n\ndef dist(circle1, circle2):\n    (x1, y1, r1) = circle1\n    (x2, y2, r2) = circle2\n    centre_distance = math.hypot(x2 - x1, y2 - y1)\n    if x1 == x2 and y1 == y2:\n        minimum_possible_range = abs(r1 - r2)\n        maximum_possible_range = r1 + r2\n    elif centre_distance >= r1 + r2:\n        minimum_possible_range = centre_distance - r1 - r2\n        maximum_possible_range = centre_distance + r1 + r2\n    elif centre_distance + min(r1, r2) < max(r1, r2):\n        minimum_possible_range = max(r1, r2) - centre_distance - min(r1, r2)\n        maximum_possible_range = r1 + r2 + centre_distance\n    elif centre_distance + min(r1, r2) == max(r1, r2):\n        minimum_possible_range = 0\n        maximum_possible_range = 2 * max(r1, r2)\n    else:\n        minimum_possible_range = 0\n        maximum_possible_range = centre_distance + r1 + r2\n    rng(minimum_possible_range, maximum_possible_range)\n(no_circles, no_queries) = map(int, input().split())\ncircles = []\nfor _ in range(no_circles):\n    (x, y, radius) = map(int, input().split())\n    circles.append((x, y, radius))\ndistance_ranges = []\npairs_of_circles = []\nfor i in range(no_circles):\n    for j in range(i, no_circles):\n        if i == j:\n            continue\n        dist(circles[i], circles[j])\nfor i in range(1, 5000007):\n    left__limit[i] += left__limit[i - 1] - right_limit[i - 1]\nfor _ in range(no_queries):\n    q = int(input())\n    count = left__limit[q]\n    print(count)", "import math\n(n, q) = map(int, input().split())\nx = [None] * n\ny = [None] * n\nr = [None] * n\nthr = [0] * 1000002\nfor i in range(n):\n    (x[i], y[i], r[i]) = map(int, input().split())\nfor i in range(n):\n    for j in range(i + 1, n):\n        d = math.sqrt((x[j] - x[i]) ** 2 + (y[j] - y[i]) ** 2)\n        if d >= r[i] + r[j]:\n            min1 = d - r[i] - r[j]\n            min1 = int(math.ceil(min1))\n            max1 = int(d + r[i] + r[j])\n        elif d > abs(r[i] - r[j]) and d < r[i] + r[j]:\n            min1 = 0\n            max1 = int(d) + r[i] + r[j]\n        elif d < abs(r[i] - r[j]):\n            min1 = abs(r[i] - r[j]) - d\n            min1 = int(math.ceil(min1))\n            max1 = int(d + r[i] + r[j])\n        thr[min1] += 1\n        thr[max1 + 1] -= 1\nfor i in range(1, 1000002):\n    thr[i] = thr[i - 1] + thr[i]\nfor i in range(q):\n    q1 = int(input())\n    print(thr[q1])", "from math import *\n(n, q) = map(int, input().split())\nx = []\ny = []\nr = []\nfor i in range(n):\n    (a, b, c) = map(float, input().split())\n    x.append(a)\n    y.append(b)\n    r.append(c)\nres = []\nfor i in range(1000010):\n    res.append(0)\nfor i in range(n):\n    for j in range(i + 1, n):\n        c2c = sqrt((x[i] - x[j]) ** 2 + (y[i] - y[j]) ** 2)\n        larger_r = max(r[i], r[j])\n        smaller_r = min(r[i], r[j])\n        if c2c > r[i] + r[j]:\n            low = c2c - r[i] - r[j]\n        elif c2c <= r[i] + r[j] and c2c >= larger_r - smaller_r:\n            low = 0\n        elif c2c < larger_r - smaller_r:\n            low = larger_r - c2c - smaller_r\n        high = c2c + r[i] + r[j]\n        low = ceil(low)\n        high = floor(high)\n        res[low] = res[low] + 1\n        res[high + 1] = res[high + 1] - 1\nfor i in range(1, 1000010):\n    res[i] = res[i - 1] + res[i]\nfor i in range(q):\n    k = int(input())\n    print(res[k])", "from math import ceil, floor\n\nclass circle:\n\n    def __init__(self, x, y, r):\n        self.x = x\n        self.y = y\n        self.r = r\n\ndef calculate_distance(a, b):\n    d = ((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y)) ** 0.5\n    if d >= a.r + b.r:\n        min_distance = ceil(d - a.r - b.r)\n        max_distance = floor(d + a.r + b.r)\n        return (min_distance, max_distance)\n    else:\n        min_distance = max(a.r, b.r) - (d + min(a.r, b.r))\n        if min_distance < 0:\n            min_distance = 0\n        min_distance = ceil(min_distance)\n        max_distance = floor(d + a.r + b.r)\n        return (min_distance, max_distance)\n(n, q) = [int(x) for x in input().split()]\ncircle_pairs = []\n(lower, upper) = ([0] * 1000005, [0] * 1000005)\nans = [0] * 1000005\nmax_distance = 0\nfor _ in range(n):\n    t = [int(x) for x in input().split()]\n    circle_pairs.append(circle(t[0], t[1], t[2]))\nfor i in range(n):\n    for j in range(i + 1, n):\n        distances = calculate_distance(circle_pairs[i], circle_pairs[j])\n        lower[distances[0]] += 1\n        upper[distances[1]] += 1\n        max_distance = max(max_distance, distances[1])\nans[0] = lower[0] - upper[0]\nfor i in range(1, max_distance + 1):\n    ans[i] = ans[i - 1] + lower[i] - upper[i - 1]\nfor _ in range(q):\n    query = int(input())\n    print(ans[query])", "import math\nimport bisect\n(n, q) = map(int, input().split())\nx = []\ny = []\nr = []\na = []\nb = []\nfor i in range(0, n):\n    (n1, n2, n3) = map(float, input().split())\n    x.append(n1)\n    y.append(n2)\n    r.append(n3)\n\ndef dist(i, j):\n    d = math.pow(x[i] - x[j], 2) + math.pow(y[i] - y[j], 2)\n    return math.sqrt(d)\nfor i in range(0, n - 1):\n    for j in range(i + 1, n):\n        if x[i] != x[j] or y[i] != y[j] or r[i] != r[j]:\n            d = dist(i, j)\n            small = min(r[i], r[j])\n            big = max(r[i], r[j])\n            if d > small + big:\n                a.append(math.ceil(d - big - small))\n            elif d < big - small:\n                a.append(math.ceil(big - d - small))\n            else:\n                a.append(0)\n            b.append(math.floor(d + small + big) + 1)\na = sorted(a)\nb = sorted(b)\nfor i in range(0, q):\n    k = int(input())\n    more = bisect.bisect(a, k)\n    less = bisect.bisect(b, k)\n    print(more - less)", "import math\n(n, q) = [int(y) for y in input().split(' ')]\nC = []\nR = []\nq1 = []\nq2 = []\nans = []\nfor i in range(n):\n    (c1, c2, r1) = [int(x) for x in input().split(' ')]\n    c = (c1, c2)\n    C.append(c)\n    R.append(r1)\nfor i in range(len(C)):\n    for j in range(i + 1, len(C)):\n        d1 = (C[j][0] - C[i][0]) ** 2\n        d2 = (C[j][1] - C[i][1]) ** 2\n        d = math.sqrt(d1 + d2)\n        if d <= abs(R[j] - R[i]) and d < R[i] + R[j]:\n            min_ = max(max(R[i], R[j]) - d - min(R[i], R[j]), 0)\n            max_ = R[i] + R[j] + d\n        else:\n            min_ = max(0, d - R[i] - R[j])\n            max_ = d + R[i] + R[j]\n        q1.append(math.ceil(min_))\n        q2.append(math.floor(max_))\nfor i in range(max(q2) + 2):\n    ans.append(0)\nfor j in range(len(q1)):\n    ans[q1[j]] += 1\n    ans[q2[j] + 1] -= 1\nfor j in range(1, len(ans)):\n    ans[j] += ans[j - 1]\nfor i in range(q):\n    temp = int(input())\n    if temp in range(len(ans)):\n        print(ans[temp])\n    else:\n        print('0')", "import math\n(n, q) = map(int, input().split())\nmat = {}\nfor i in range(1, n + 1):\n    x = list(map(int, input().split()))\n    mat[i] = x\nans = [0] * (10 ** 6 + 5)\nfor i in range(1, n + 1):\n    one = mat[i]\n    for j in range(i + 1, n + 1):\n        two = mat[j]\n        r1 = one[2]\n        r2 = two[2]\n        dist = math.sqrt((one[0] - two[0]) ** 2 + (one[1] - two[1]) ** 2)\n        if dist > r1 + r2:\n            ans[max(math.ceil(dist - r1 - r2), 0)] += 1\n            ans[min(math.floor(dist + r1 + r2) + 1, 10 ** 6 + 1)] -= 1\n        elif dist == r1 + r2:\n            ans[0] += 1\n            ans[min(int(dist) + r1 + r2 + 1, 10 ** 6 + 1)] -= 1\n        elif (r1 - r2) ** 2 <= dist ** 2 and dist ** 2 <= (r1 + r2) ** 2:\n            ans[0] += 1\n            ans[min(int(dist) + r1 + r2 + 1, 1000000 + 1)] -= 1\n        elif r2 < r1:\n            ans[max(0, math.ceil(r1 - (dist + r2)))] += 1\n            ans[min(math.floor(2 * r1 - (r1 - (dist + r2)) + 1), 1000000 + 1)] -= 1\n        else:\n            mi = r2 - (dist + r1)\n            ans[max(0, math.ceil(mi))] += 1\n            ans[min(math.floor(2 * r2 - mi) + 1, 1000000 + 1)] -= 1\nfor i in range(1, len(ans)):\n    ans[i] += ans[i - 1]\n    if ans[i] < 0:\n        ans[i] = 0\nfor qi in range(q):\n    qq = int(input())\n    print(ans[qq])", "from math import sqrt, floor, ceil\n\ndef update(D, l, r, x):\n    D[l] += x\n    D[r + 1] -= x\n\ndef makeArray(A, D):\n    for i in range(0, len(A)):\n        if i == 0:\n            A[i] = D[i]\n        else:\n            A[i] = D[i] + A[i - 1]\n\ndef dis(a, b):\n    return sqrt((b[0] - a[0]) ** 2 + (b[1] - a[1]) ** 2)\n\ndef circheck(p1, p2, l):\n    s = dis(p1, p2)\n    r1 = p1[2]\n    r2 = p2[2]\n    t1 = min(r1, r2)\n    t2 = max(r1, r2)\n    (r2, r1) = (t2, t1)\n    if s >= r1 + r2:\n        rng = [ceil(s - (r1 + r2)), floor(s + (r1 + r2))]\n    elif s <= r2 - r1:\n        if s == 0:\n            if r1 != r2:\n                rng = [r2 - r1, r1 + r2]\n            else:\n                rng = [0, 0]\n        else:\n            rng = [ceil(r2 - r1 - s), floor(r2 + r1 + s)]\n    else:\n        rng = [0, floor(r1 + r2 + s)]\n    update(l, rng[0], rng[1], 1)\n(n, q) = map(int, input().split())\nml = [0] * 1000001\nd = [0] * 1000002\nsideL = []\nfor _ in range(0, n):\n    (x, y, r) = map(int, input().split())\n    el = [x, y, r]\n    sideL.append(el)\n    for i in range(_ - 1, -1, -1):\n        circheck(el, sideL[i], d)\nmakeArray(ml, d)\nfor _ in range(0, q):\n    k = int(input())\n    print(ml[k])", "from math import *\n\ndef dist(a, b, c, d):\n    return sqrt(pow(a - b, 2) + pow(c - d, 2))\n(n, q) = map(int, input().split())\nx = []\ny = []\nr = []\ni = 0\nmini = []\nmaxm = []\nk = 0\nm = 0\nwhile i < n:\n    (a, b, c) = map(int, input().split())\n    x.append(a)\n    y.append(b)\n    r.append(c)\n    i = i + 1\ni = 0\nwhile i < n:\n    j = i + 1\n    while j < n:\n        c = dist(x[i], x[j], y[i], y[j])\n        if c + r[j] <= r[i]:\n            mini.append(ceil(r[i] - r[j] - c))\n            maxm.append(floor(c + r[i] + r[j]))\n        elif c + r[i] <= r[j]:\n            mini.append(ceil(r[j] - r[i] - c))\n            maxm.append(floor(c + r[i] + r[j]))\n        elif c <= r[i] + r[j]:\n            mini.append(0)\n            maxm.append(floor(c + r[i] + r[j]))\n        else:\n            mini.append(ceil(c - r[i] - r[j]))\n            maxm.append(floor(c + r[i] + r[j]))\n        if m < maxm[k]:\n            m = maxm[k]\n        k = k + 1\n        j = j + 1\n    i = i + 1\nN = [0 for i in range(m + 2)]\ni = 0\nwhile i < n * (n - 1) / 2:\n    N[mini[i]] = N[mini[i]] + 1\n    N[maxm[i] + 1] = N[maxm[i] + 1] - 1\n    i = i + 1\ni = 1\nwhile i < m + 2:\n    N[i] = N[i] + N[i - 1]\n    i = i + 1\ni = 0\nwhile i < q:\n    k = int(input())\n    if k <= m:\n        print(N[k])\n    else:\n        print(0)\n    i = i + 1", "import math\n\nclass cl:\n\n    def __init__(self, a, b, cc):\n        self.x = a\n        self.y = b\n        self.r = cc\n(n, q) = map(int, input().split())\nv = []\nc = [0 for i in range(1000005)]\nfor i in range(n):\n    (a, b, cc) = map(int, input().split())\n    k = cl(a, b, cc)\n    v.append(k)\n    for j in range(i):\n        e = False\n        if v[i].r < v[j].r:\n            e = True\n            t = v[i]\n            v[i] = v[j]\n            v[j] = t\n        d = math.sqrt((v[i].x - v[j].x) ** 2 + (v[i].y - v[j].y) ** 2)\n        if v[i].r + v[j].r <= d:\n            mn = math.ceil(d - v[i].r - v[j].r)\n            mx = math.floor(d + v[i].r + v[j].r)\n            if mn < 1000001:\n                c[mn] += 1\n            if mx < 1000001:\n                c[mx + 1] -= 1\n        elif v[i].r >= d + v[j].r:\n            mn = math.ceil(v[i].r - d - v[j].r)\n            mx = math.floor(v[i].r + d + v[j].r)\n            if mn < 1000001:\n                c[mn] += 1\n            if mx < 1000001:\n                c[mx + 1] -= 1\n        elif v[i].r + v[j].r >= d:\n            mx = math.floor(d + v[i].r + v[j].r)\n            c[0] += 1\n            if mx < 1000001:\n                c[mx + 1] -= 1\n        if e:\n            t = v[i]\n            v[i] = v[j]\n            v[j] = t\nx = 0\nfor i in range(1000001):\n    x += c[i]\n    c[i] = x\nfor i in range(q):\n    y = int(input())\n    print(c[y])", "import math\n(n, q) = map(int, input().split())\ncircles = []\nfor i in range(n):\n    circles.append(tuple(map(int, input().split())))\nkarr = [int(input()) for i in range(q)]\nnumk = [0 for i in range(10000001)]\n(i, j) = (0, 0)\nfor i in range(len(circles)):\n    for j in range(i):\n        xdiff = circles[i][0] - circles[j][0]\n        ydiff = circles[i][1] - circles[j][1]\n        d = math.sqrt(xdiff * xdiff + ydiff * ydiff)\n        dsq = xdiff * xdiff + ydiff * ydiff\n        maxd = int(d + circles[i][2] + circles[j][2])\n        if dsq > (circles[i][2] + circles[j][2]) ** 2:\n            mind = int(math.ceil(d - circles[i][2] - circles[j][2]))\n        elif dsq >= (max(circles[i][2], circles[j][2]) - min(circles[i][2], circles[j][2])) ** 2 and dsq <= (circles[i][2] + circles[j][2]) ** 2:\n            mind = 0\n        else:\n            mind = int(math.ceil(max(circles[i][2], circles[j][2]) - min(circles[i][2], circles[j][2]) - d))\n        numk[mind] += 1\n        numk[maxd + 1] -= 1\ncsum = 0\nfor i in range(len(numk)):\n    t = numk[i]\n    numk[i] += csum\n    csum += t\nfor i in karr:\n    print(numk[i])", "def endtime(tup):\n    return tup[1]\n(N, Q) = map(int, input().split())\narr = []\nfor i in range(N):\n    (X, Y, R) = map(int, input().split())\n    arr.append((X, Y, R))\nmain = []\nfor i in range(N):\n    for j in range(i + 1, N):\n        c1x = arr[i][0]\n        c1y = arr[i][1]\n        r1 = arr[i][2]\n        c2x = arr[j][0]\n        c2y = arr[j][1]\n        r2 = arr[j][2]\n        c1c2 = pow((c1x - c2x) * (c1x - c2x) + (c1y - c2y) * (c1y - c2y), 0.5)\n        if c1c2 >= r1 + r2:\n            minimum = c1c2 - r1 - r2\n            maximum = c1c2 + r1 + r2\n            main.append((minimum, maximum))\n        elif c1x == c2x and c1y == c2y:\n            minimum = abs(r2 - r1)\n            maximum = r1 + r2\n            main.append((minimum, maximum))\n        else:\n            maximum = c1c2 + r1 + r2\n            if c1c2 >= abs(r2 - r1):\n                minimum = 0\n            else:\n                minimum = abs(r2 - r1) - c1c2\n            main.append((minimum, maximum))\nmain.sort(key=endtime, reverse=True)\nfrom math import ceil\nK = pow(10, 6)\narr = [0] * (K + 1)\nfor i in main:\n    s = ceil(i[0])\n    e = int(i[1])\n    if e > K:\n        e = K\n    arr[s] += 1\n    arr[e + 1] += -1\nsum = 0\nfor i in range(K + 1):\n    sum += arr[i]\n    arr[i] = sum\nfor i in range(Q):\n    x = int(input())\n    print(arr[x])", "from collections import namedtuple\ncircle = namedtuple('circle', ['x', 'y', 'r'])\n(N, Q) = map(int, input().strip().split())\ncircle_list = []\nfor _ in range(N):\n    (x, y, r) = map(int, input().strip().split())\n    circle_list.append(circle(x=x, y=y, r=r))\nfrom math import ceil, floor, sqrt\n\ndef dist_bw_centres(circle1, circle2):\n    return sqrt((circle1.x - circle2.x) ** 2 + (circle1.y - circle2.y) ** 2)\n\ndef min_max_dist(circle1, circle2):\n    d_centres = dist_bw_centres(circle1, circle2)\n    (mn, mx) = (d_centres - circle1.r - circle2.r, d_centres + circle1.r + circle2.r)\n    if mn < 0:\n        mn = abs(circle2.r - circle1.r) - d_centres if abs(circle2.r - circle1.r) - d_centres > 0 else 0\n    return (ceil(mn), floor(mx))\npossible = [0] * 1000000\nfor (index, circle1) in enumerate(circle_list[:-1]):\n    for circle2 in circle_list[index + 1:]:\n        (mn, mx) = min_max_dist(circle1, circle2)\n        possible[mn] += 1\n        possible[mx + 1] -= 1\nfor i in range(1, len(possible)):\n    possible[i] += possible[i - 1]\nfor q in range(Q):\n    K = int(input().strip())\n    print(possible[K] if possible[K] > 0 else 0)", "from math import ceil, floor\n\ndef cal_distance(a, b):\n    d = ((b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])) ** 0.5\n    if d >= a[2] + b[2]:\n        return (ceil(d - a[2] - b[2]), floor(d + a[2] + b[2]))\n    else:\n        l = max(a[2], b[2]) - (d + min(a[2], b[2]))\n        if l < 0:\n            l = 0\n        l = ceil(l)\n        r = floor(d + a[2] + b[2])\n        return (l, r)\n(n, q) = [int(x) for x in input().split()]\ncircles = []\n(l, r) = ([0] * 1000005, [0] * 1000005)\nans = [0] * 1000005\nm = 0\nfor _ in range(n):\n    circles.append([int(x) for x in input().split()])\nfor i in range(n):\n    for j in range(i + 1, n):\n        ranges = cal_distance(circles[i], circles[j])\n        l[ranges[0]] += 1\n        r[ranges[1]] += 1\n        m = max(m, ranges[1])\nans[0] = l[0] - r[0]\nfor i in range(1, m + 1):\n    ans[i] = ans[i - 1] + l[i] - r[i - 1]\nfor _ in range(q):\n    x = int(input())\n    print(ans[x])", "import math\n(n, q) = [int(x) for x in input().split()]\nb = []\nfor x in range(n):\n    a = [int(y) for y in input().split()]\n    b.append(a)\ni = []\nfor x in range(n - 1):\n    o = b[x]\n    r2 = o[2]\n    for y in range(x + 1, n):\n        p = b[y]\n        r1 = p[2]\n        z = math.sqrt(math.pow(o[0] - p[0], 2) + math.pow(o[1] - p[1], 2))\n        if o != p:\n            if z <= abs(r1 - r2):\n                l = max(max(r1, r2) - z - min(r1, r2), 0)\n                m = r1 + r2 + z\n                i.append([l, m])\n            else:\n                l = max(z - r1 - r2, 0)\n                m = z + r1 + r2\n                i.append([l, m])\nh = [0 for r in range(1000002)]\nfor w in i:\n    t1 = int(math.ceil(w[0]))\n    t2 = int(math.floor(w[1]))\n    h[t1] = h[t1] + 1\n    h[t2 + 1] = h[t2 + 1] - 1\nfor w1 in range(1, 1000002):\n    h[w1] = h[w1] + h[w1 - 1]\nfor x in range(q):\n    k = int(input())\n    print(h[k])", "from math import ceil, floor\n(n, q) = map(int, input().split())\nl = []\nfor i in range(n):\n    (x, y, r) = map(int, input().split())\n    l.append([x, y, r])\ndis = []\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        k = ((l[i][0] - l[j][0]) ** 2 + (l[i][1] - l[j][1]) ** 2) ** 0.5\n        k = round(k, 6)\n        if k >= l[i][2] + l[j][2]:\n            a = abs(ceil(k) - l[i][2] - l[j][2])\n            b = abs(floor(k) + l[i][2] + l[j][2])\n            if a == 0:\n                dis.append([0, b])\n            else:\n                dis.append([a, b])\n        elif k <= abs(l[i][2] - l[j][2]):\n            mx = k + (l[i][2] + l[j][2])\n            a = max(l[i][2], l[j][2])\n            mn = 2 * a - mx\n            dis.append([ceil(mn), floor(mx)])\n        else:\n            mx = floor(k) + l[i][2] + l[j][2]\n            dis.append([0, mx])\ntotal_range = len(dis)\nm = -10 ** 10\nran = [0] * 10 ** 6\nfor i in range(total_range):\n    m = max(m, dis[i][1])\n    ran[dis[i][0]] += 1\n    ran[dis[i][1] + 1] -= 1\nfor i in range(1, m + 1):\n    ran[i] += ran[i - 1]\nfor i in range(q):\n    key = int(input())\n    if key > m:\n        print(0)\n    else:\n        print(ran[key])", "from math import ceil, floor\n(n, q) = map(int, input().split())\nl = []\nfor i in range(n):\n    (x, y, r) = map(int, input().split())\n    l.append([x, y, r])\ndis = []\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        k = ((l[i][0] - l[j][0]) ** 2 + (l[i][1] - l[j][1]) ** 2) ** 0.5\n        k = round(k, 6)\n        if k >= l[i][2] + l[j][2]:\n            a = abs(ceil(k) - l[i][2] - l[j][2])\n            b = abs(floor(k) + l[i][2] + l[j][2])\n            if a == 0:\n                dis.append([0, b])\n            else:\n                dis.append([a, b])\n        elif k <= abs(l[i][2] - l[j][2]):\n            mx = k + (l[i][2] + l[j][2])\n            a = max(l[i][2], l[j][2])\n            mn = 2 * a - mx\n            dis.append([ceil(mn), floor(mx)])\n        else:\n            mx = floor(k) + l[i][2] + l[j][2]\n            dis.append([0, mx])\ntotal_range = len(dis)\nm = -10 ** 10\nran = [0] * 10 ** 6\nfor i in range(total_range):\n    m = max(m, dis[i][1])\n    ran[dis[i][0]] += 1\n    ran[dis[i][1] + 1] -= 1\nfor i in range(1, m + 1):\n    ran[i] += ran[i - 1]\nfor i in range(q):\n    key = int(input())\n    if key > m:\n        print(0)\n    else:\n        print(ran[key])", "import math\n(n, q) = map(int, input().split())\ncircles = []\nfor i in range(n):\n    (x, y, r) = map(int, input().split())\n    if [x, y, r] not in circles:\n        circles.append([x, y, r])\n\ndef sdld(cir1, cir2):\n    (maxr, minr) = (max(cir1[2], cir2[2]), min(cir1[2], cir2[2]))\n    dist = ((cir1[0] - cir2[0]) ** 2 + (cir1[1] - cir2[1]) ** 2) ** 0.5\n    if dist >= maxr + minr:\n        sd = math.ceil(dist - maxr - minr)\n        ld = math.floor(dist + maxr + minr)\n    elif maxr - minr < dist < maxr + minr:\n        sd = 0\n        ld = math.floor(dist + maxr + minr)\n    else:\n        sd = math.ceil(maxr - dist - minr)\n        ld = math.floor(dist + maxr + minr)\n    return (sd, ld)\nshort = []\nlon = []\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        short.append(sdld(circles[i], circles[j])[0])\n        lon.append(sdld(circles[i], circles[j])[1])\nstore = [0] * 1000000\nfor i in short:\n    store[i] += 1\nfor i in lon:\n    store[i + 1] -= 1\nfor i in range(1, len(store)):\n    store[i] += store[i - 1]\nqueries = []\nfor i in range(q):\n    queries.append(int(input()))\nfor i in range(len(queries)):\n    print(store[queries[i]])", "import math\n(n, q) = map(int, input().split())\nA = list(list())\nL = list()\nU = list()\nwhile n > 0:\n    A.append(list(map(int, input().split())))\n    n -= 1\nfor i in range(0, len(A) - 1):\n    for j in range(i + 1, len(A)):\n        (x1, x2, y1, y2, r1, r2) = (A[i][0], A[j][0], A[i][1], A[j][1], A[i][2], A[j][2])\n        dx = x1 - x2\n        dy = y1 - y2\n        v = dx * dx + dy * dy\n        ed = math.sqrt(v)\n        if x1 == x2 and y1 == y2:\n            L.append(abs(r1 - r2))\n            U.append(r1 + r2)\n        elif r1 >= ed + r2 or r2 >= ed + r1:\n            if r1 > r2:\n                L.append(math.ceil(r1 - (ed + r2)))\n                U.append(math.floor(r1 + r2 + ed))\n            else:\n                L.append(math.ceil(r2 - (ed + r1)))\n                U.append(math.floor(r1 + r2 + ed))\n        else:\n            L.append(max(0, math.ceil(ed - (r1 + r2))))\n            U.append(math.floor(ed + (r1 + r2)))\nA = [0] * 1000001\nD = [0] * 1000001\nfor i in range(0, len(L)):\n    D[L[i]] += 1\n    D[U[i] + 1] -= 1\nfor i in range(0, len(A)):\n    if i == 0:\n        A[i] = D[i]\n    else:\n        A[i] = D[i] + A[i - 1]\nwhile q > 0:\n    xx = int(input())\n    print(A[xx])\n    q -= 1", "import math\nn = input().split()\nlst = list(map(int, n))\n(N, Q) = (lst[0], lst[1])\nL = []\nq = []\n\ndef ShortLongDist(x1, y1, r1, x2, y2, r2):\n    R = [r1, r2]\n    R.sort()\n    C1C2 = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n    if C1C2 >= r1 + r2:\n        sd = C1C2 - r1 - r2\n        ld = C1C2 + r1 + r2\n    elif C1C2 < abs(r1 - r2):\n        sd = R[1] - C1C2 - R[0]\n        ld = C1C2 + r1 + r2\n    else:\n        sd = 0\n        ld = C1C2 + r1 + r2\n    return (sd, ld)\nfor i in range(N):\n    newlst = tuple(map(int, input().split()))\n    L.append(newlst)\nfor i in range(Q):\n    q.append(int(input()))\nnewlst_tuple = []\nshort_list = []\nlong_list = []\nfor i in range(N - 1):\n    for j in range(i + 1, N):\n        short_list.append(math.ceil(ShortLongDist(L[i][0], L[i][1], L[i][2], L[j][0], L[j][1], L[j][2])[0]))\n        long_list.append(math.floor(ShortLongDist(L[i][0], L[i][1], L[i][2], L[j][0], L[j][1], L[j][2])[1]))\n        newlst_tuple.append(ShortLongDist(L[i][0], L[i][1], L[i][2], L[j][0], L[j][1], L[j][2]))\nKlist = [0] * 1000000\nfor i in short_list:\n    Klist[i] += 1\nfor i in long_list:\n    Klist[i + 1] += -1\nfor i in range(1, len(Klist)):\n    Klist[i] += Klist[i - 1]\nfor i in range(len(q)):\n    print(Klist[q[i]])", "import math\nlower_limit = [0] * 5000005\nupper_limit = [0] * 5000005\ncircles = []\n(no_of_circles, no_of_queries) = map(int, input().split())\nfor _ in range(no_of_circles):\n    (x, y, radius) = map(int, input().split())\n    circles.append((x, y, radius))\nfor i in range(no_of_circles):\n    for j in range(i, no_of_circles):\n        if i == j:\n            continue\n        (x1, y1, radius1) = circles[i]\n        (x2, y2, radius2) = circles[j]\n        distance_bw_centers = math.hypot(x2 - x1, y2 - y1)\n        if x1 == x2 and y1 == y2:\n            minimum_possible = abs(radius1 - radius2)\n            maximum_possible = radius1 + radius2\n        elif distance_bw_centers >= radius1 + radius2:\n            minimum_possible = distance_bw_centers - radius1 - radius2\n            maximum_possible = distance_bw_centers + radius1 + radius2\n        elif distance_bw_centers + min(radius1, radius2) < max(radius1, radius2):\n            minimum_possible = max(radius1, radius2) - distance_bw_centers - min(radius1, radius2)\n            maximum_possible = radius1 + radius2 + distance_bw_centers\n        elif distance_bw_centers + min(radius1, radius2) == max(radius1, radius2):\n            minimum_possible = 0\n            maximum_possible = 2 * max(radius1, radius2)\n        else:\n            minimum_possible = 0\n            maximum_possible = distance_bw_centers + radius1 + radius2\n        lower_limit[math.ceil(minimum_possible)] += 1\n        upper_limit[int(maximum_possible)] += 1\nfor i in range(1, 5000005):\n    lower_limit[i] += lower_limit[i - 1] - upper_limit[i - 1]\nfor query in range(no_of_queries):\n    print(lower_limit[int(input())])", "import math\nfrom collections import Counter\nimport itertools\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\nn = input().split()\nn = list(map(int, n))\nN = n[0]\nQ = n[1]\ncirc = []\nque = []\nmd = []\nminm = []\nmaxm = []\nctr = [0] * 1000000\nfor i in range(0, N):\n    a = input().split()\n    a = list(map(int, a))\n    circ.append(a)\nfor i in range(0, Q):\n    n1 = int(input())\n    que.append(n1)\nfor i in range(0, N):\n    for j in range(i + 1, N):\n        cendis = math.sqrt((circ[i][0] - circ[j][0]) ** 2 + (circ[i][1] - circ[j][1]) ** 2)\n        radsum = circ[i][2] + circ[j][2]\n        mn = cendis - radsum\n        if cendis == 0:\n            mn = abs(circ[i][2] - circ[j][2])\n        if mn < 0:\n            if circ[i][2] > circ[j][2] + cendis:\n                mn = circ[i][2] - cendis - circ[j][2]\n            elif circ[j][2] > circ[i][2] + cendis:\n                mn = circ[j][2] - cendis - circ[i][2]\n            else:\n                mn = 0\n        mx = cendis + radsum\n        mn = math.ceil(mn)\n        mx = math.floor(mx)\n        ctr[mn] = ctr[mn] + 1\n        ctr[mx + 1] = ctr[mx + 1] - 1\nBITTree = construct(ctr, len(ctr))\nfor i in range(0, Q):\n    res = getsum(BITTree, que[i])\n    print(res)", "(N, Q) = list(map(int, input().split()))\ng = []\nkarray = [0 for z in range(10 ** 6 + 1)]\nfor i in range(N):\n    (X, Y, R) = list(map(int, input().split()))\n    g.append((X, Y, R))\nfor i in range(0, len(g) - 1):\n    for j in range(i + 1, len(g)):\n        (x1, y1, r1) = g[i]\n        (x2, y2, r2) = g[j]\n        c = ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) ** 0.5\n        if c >= r1 + r2:\n            mini = c - r1 - r2\n            maxi = c + r1 + r2\n        elif c < r1 + r2 and c > abs(r1 - r2):\n            mini = 0\n            maxi = c + r1 + r2\n        elif c == abs(r1 - r2):\n            mini = 0\n            maxi = c + r1 + r2\n        elif c < abs(r1 - r2):\n            mini = abs(r1 - r2) - c\n            maxi = c + r1 + r2\n        try:\n            if mini == int(mini):\n                karray[int(mini)] += 1\n            else:\n                karray[int(mini) + 1] += 1\n        except:\n            pass\n        try:\n            karray[int(maxi + 1)] -= 1\n        except:\n            pass\nsum_arr = [karray[0]]\nfor w in range(1, len(karray)):\n    sum_arr.append(sum_arr[-1] + karray[w])\nfor query in range(Q):\n    que = int(input())\n    print(sum_arr[que])", "from math import ceil, floor\n(n, q) = map(int, input().split())\nl1 = []\nl2 = []\nr = []\na = [0] * 1000002\nfor i in range(n):\n    (x, y, r1) = map(int, input().split())\n    l1.append(x)\n    l2.append(y)\n    r.append(r1)\nfor i in range(n):\n    for j in range(i + 1, n):\n        z = ((l1[i] - l1[j]) ** 2 + (l2[i] - l2[j]) ** 2) ** 0.5\n        if max(r[i], r[j]) > z + min(r[i], r[j]):\n            mini = max(r[i], r[j]) - (z + min(r[i], r[j]))\n            maxi = 2 * max(r[i], r[j]) - mini\n        else:\n            mini = z - (r[i] + r[j])\n            if mini < 0:\n                mini = 0\n            maxi = z + (r[i] + r[j])\n        a[ceil(mini)] += 1\n        a[floor(maxi) + 1] -= 1\nfor i in range(1, 1000002):\n    a[i] = a[i] + a[i - 1]\nfor m in range(q):\n    k = int(input())\n    print(a[k])", "import numpy as np\nimport math\n(n, q) = [int(i) for i in input().strip().split(' ')]\ncir = []\ndp = np.zeros(10 ** 6 + 3)\nfor i in range(n):\n    (x, y, r) = [int(i) for i in input().strip().split(' ')]\n    cir.append([x, y, r])\nfor c1 in range(n):\n    for c2 in range(c1, n):\n        if c1 != c2:\n            d = ((cir[c1][0] - cir[c2][0]) ** 2 + (cir[c1][1] - cir[c2][1]) ** 2) ** 0.5\n            r1 = cir[c1][2]\n            r2 = cir[c2][2]\n            if d >= r1 + r2:\n                min_dis = d - r1 - r2\n                max_dis = d + r1 + r2\n            elif d < r1 + r2 and d > math.fabs(r1 - r2):\n                min_dis = 0\n                max_dis = d + r1 + r2\n            elif r1 > r2:\n                min_dis = r1 - d - r2\n                max_dis = r1 + r2 + d\n            else:\n                min_dis = r2 - d - r1\n                max_dis = r2 + r1 + d\n            lb = int(math.ceil(min_dis))\n            ub = int(math.floor(max_dis))\n            dp[lb] = dp[lb] + 1\n            dp[ub + 1] = dp[ub + 1] - 1\nfor i in range(1, 10 ** 6 + 2):\n    dp[i] = dp[i - 1] + dp[i]\nfor i in range(q):\n    k = int(input())\n    print(int(dp[k]))", "import math\n\ndef distcenter(x1, y1, x2, y2):\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\ndef minimumDist(x1, y1, r1, x2, y2, r2):\n    centerDist = distcenter(x1, y1, x2, y2)\n    if centerDist <= r1 + r2 and max(r1, r2) - min(r1, r2) < centerDist:\n        return 0\n    else:\n        return 2 * max(centerDist, r1, r2) - (centerDist + r1 + r2)\n\ndef maximumDist(x1, y1, r1, x2, y2, r2):\n    centerDist = distcenter(x1, y1, x2, y2)\n    return centerDist + r1 + r2\n\ndef mainfunction(array1, array2):\n    mindist = minimumDist(array1[0], array1[1], array1[2], array2[0], array2[1], array2[2])\n    maxdist = maximumDist(array1[0], array1[1], array1[2], array2[0], array2[1], array2[2])\n    lowerrange.append(math.ceil(mindist))\n    higherrange.append(math.floor(maxdist))\n\ndef pairmaker(array):\n    qw = len(circles)\n    for i in range(qw - 1):\n        for j in range(i + 1, qw):\n            mainfunction(circles[i], circles[j])\npossibleranges = []\n(n, q) = map(int, input().split())\ncircles = []\nfor _ in range(n):\n    (x, y, r) = map(int, input().split())\n    circles.append([x, y, r])\nlowerrange = []\nhigherrange = []\npairmaker(circles)\nbiglist = [0] * 1000000\nfor i in lowerrange:\n    biglist[i] += 1\nfor i in higherrange:\n    biglist[i + 1] += -1\nfor i in range(1, 1000000):\n    biglist[i] += biglist[i - 1]\nfor _ in range(q):\n    query = int(input().strip())\n    print(biglist[query])", "import math\ndl = [0] * 5000001\ndr = [0] * 5000001\n\ndef add_new_range(mn, mx):\n    dl[math.ceil(mn)] += 1\n    dr[int(mx)] += 1\n\ndef solve():\n    for i in range(1, 5000001):\n        dl[i] += dl[i - 1] - dr[i - 1]\n\ndef find_dist(c1, c2):\n    (x1, y1, r1) = c1\n    (x2, y2, r2) = c2\n    ds = math.hypot(x2 - x1, y2 - y1)\n    if x1 == x2 and y1 == y2:\n        mn = abs(r1 - r2)\n        mx = r1 + r2\n    elif ds >= r1 + r2:\n        mn = ds - r1 - r2\n        mx = ds + r1 + r2\n    elif ds + min(r1, r2) < max(r1, r2):\n        mn = max(r1, r2) - ds - min(r1, r2)\n        mx = r1 + r2 + ds\n    elif ds + min(r1, r2) == max(r1, r2):\n        mn = 0\n        mx = 2 * max(r1, r2)\n    else:\n        mn = 0\n        mx = ds + r1 + r2\n    add_new_range(mn, mx)\n(no_circles, no_queries) = map(int, input().split())\ncircles = []\nfor _ in range(no_circles):\n    (x, y, radius) = map(int, input().split())\n    circles.append((x, y, radius))\npairs_of_circles = []\ndistance_ranges = []\nfor i in range(no_circles):\n    for j in range(i, no_circles):\n        if i == j:\n            continue\n        find_dist(circles[i], circles[j])\nsolve()\nfor query in range(no_queries):\n    q = int(input())\n    count = dl[q]\n    print(count)", "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt(math.pow(x1 - y1, 2) + math.pow(x2 - y2, 2) * 1.0)\n(n, q) = map(int, input().split())\na = []\nb = []\nfor i in range(0, n):\n    x = list(map(int, input().split()))\n    a.append(x)\nfor j in range(0, q):\n    k = int(input())\n    b.append(k)\nindex = [0] * 1000002\nfor i in range(0, n - 1):\n    for j in range(i + 1, n):\n        d = distance(a[i][0], a[j][0], a[i][1], a[j][1])\n        if d >= a[i][2] + a[j][2]:\n            mi = math.ceil(d - a[i][2] - a[j][2])\n            ma = math.floor(d + a[i][2] + a[j][2])\n        elif d < a[i][2] + a[j][2] and d >= abs(a[i][2] - a[j][2]):\n            mi = 0\n            ma = math.floor(d + a[i][2] + a[j][2])\n        elif d < a[i][2] + a[j][2]:\n            if a[i][2] > a[j][2]:\n                mi = math.ceil(a[i][2] - d - a[j][2])\n                ma = math.floor(d + a[i][2] + a[j][2])\n            else:\n                mi = math.ceil(a[j][2] - d - a[i][2])\n                ma = math.floor(d + a[i][2] + a[j][2])\n        index[mi] += 1\n        index[ma + 1] += -1\nfor i in range(1, 1000002):\n    index[i] += index[i - 1]\nfor k in range(0, q):\n    print(index[b[k]])", "from math import sqrt\nx = []\ny = []\nr = []\n(N, Q) = map(int, input().split())\nfor i in range(N):\n    (a, b, c) = map(int, input().split())\n    x.append(a)\n    y.append(b)\n    r.append(c)\nnos = 0\nlowerdis = []\nupperdis = []\nfor i in range(N):\n    for j in range(i + 1, N):\n        minimum = 0\n        distance = sqrt((x[i] - x[j]) ** 2 + (y[i] - y[j]) ** 2)\n        maximum = 0\n        if distance > r[i] + r[j]:\n            minimum = distance - r[i] - r[j]\n            maximum = distance + r[i] + r[j]\n        elif distance < abs(r[i] - r[j]):\n            minimum = abs(r[i] - r[j]) - distance\n            maximum = r[i] + r[j] + distance\n        else:\n            minimum = 0\n            maximum = distance + r[i] + r[j]\n        upperdis.append(maximum)\n        nos += 1\n        lowerdis.append(minimum)\nlowerdis.sort()\ni = 0\nupperdis.sort()\nj = 0\ncount = 0\nansarray = [0] * 1000001\nfor index in range(1000001):\n    if i < nos:\n        while index >= lowerdis[i]:\n            i = i + 1\n            count = count + 1\n            if i == nos:\n                break\n    while index > upperdis[j]:\n        count = count - 1\n        j = j + 1\n        if j == nos:\n            break\n    ansarray[index] = count\n    if j >= nos:\n        break\nfor i in range(Q):\n    print(ansarray[int(input())])", "import math\n\ndef dist(onex, oney, twox, twoy):\n    return math.sqrt((onex - twox) ** 2 + (oney - twoy) ** 2)\n(n, q) = [int(i) for i in input().split()]\n(x, y, r, ans) = ([], [], [], 0)\nfor _ in range(n):\n    l = [float(i) for i in input().split()]\n    x.append(l[0])\n    y.append(l[1])\n    r.append(l[2])\ndp = [0 for i in range(1111110)]\nfor i in range(0, n):\n    for j in range(i + 1, n):\n        c1c2 = dist(x[i], y[i], x[j], y[j])\n        f = [c1c2, r[i], r[j]]\n        f.sort()\n        minm = (f[2] - f[1] - f[0]) * (f[2] - f[1] - f[0] > 0)\n        maxm = c1c2 + r[i] + r[j]\n        dp[math.ceil(minm)] += 1\n        dp[math.floor(maxm) + 1] -= 1\nfor i in range(1, 1000001):\n    dp[i] = dp[i] + dp[i - 1]\nfor _ in range(q):\n    k = int(input())\n    print(dp[k])", "from math import floor\nfrom math import ceil\nfrom math import sqrt\n(n, q) = list(map(int, input().split()))\nx = []\ny = []\nr = []\ndist = []\nfor i in range(n):\n    (a, b, c) = list(map(int, input().split()))\n    x.append(a)\n    y.append(b)\n    r.append(c)\nfor i in range(10000001):\n    dist.append(0)\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        temp = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])\n        if temp >= pow(r[i] + r[j], 2):\n            if ceil(sqrt(temp) - (r[i] + r[j])) < 1000001:\n                dist[ceil(sqrt(temp) - (r[i] + r[j]))] += 1\n            if floor(sqrt(temp) + (r[i] + r[j])) + 1 < 1000001:\n                dist[floor(sqrt(temp) + (r[i] + r[j])) + 1] -= 1\n        elif temp >= pow(r[i] - r[j], 2):\n            dist[0] += 1\n            if floor(sqrt(temp) + (r[i] + r[j])) + 1 < 1000001:\n                dist[floor(sqrt(temp) + (r[i] + r[j])) + 1] -= 1\n        else:\n            (max, min) = (r[j], r[j])\n            if r[i] >= r[j]:\n                max = r[i]\n            else:\n                min = r[i]\n            if ceil(max - sqrt(temp) - min) < 1000001:\n                dist[ceil(max - sqrt(temp) - min)] += 1\n            if floor(r[i] + r[j] + sqrt(temp)) + 1 < 1000001:\n                dist[floor(r[i] + r[j] + sqrt(temp) + 1)] -= 1\nfor i in range(1, 1000001):\n    dist[i] += dist[i - 1]\nfor i in range(q):\n    k2 = int(input())\n    print(dist[k2])", "from math import sqrt, ceil, floor\n(n, q) = map(int, input().split())\ncircle = []\nans = [0 for i in range(0, 10 ** 6 + 2)]\nfor _ in range(n):\n    circle.append(tuple(map(int, input().split())))\nfor i in range(0, n - 1):\n    for j in range(i + 1, n):\n        m1 = 0\n        m2 = 0\n        if circle[i][0] == circle[j][0] and circle[i][1] == circle[j][1]:\n            if circle[i][2] == circle[j][2]:\n                m1 = 0\n                m2 = 2 * circle[i][2]\n            elif circle[i][2] > circle[j][2]:\n                m1 = circle[i][2] - circle[j][2]\n                m2 = circle[i][2] + circle[j][2]\n            else:\n                m1 = -circle[i][2] + circle[j][2]\n                m2 = circle[i][2] + circle[j][2]\n        else:\n            dist = (circle[i][0] - circle[j][0]) ** 2 + (circle[i][1] - circle[j][1]) ** 2\n            if dist == (circle[i][2] - circle[j][2]) ** 2:\n                m1 = 0\n                if circle[i][2] > circle[j][2]:\n                    m2 = 2 * circle[i][2]\n                else:\n                    m2 = 2 * circle[j][2]\n            elif (circle[j][2] - circle[i][2]) ** 2 > dist:\n                if circle[j][2] > circle[i][2]:\n                    m1 = circle[j][2] - int(floor(sqrt(dist))) - circle[i][2]\n                    m2 = circle[j][2] + int(floor(sqrt(dist))) + circle[i][2]\n                else:\n                    m1 = circle[i][2] - int(floor(sqrt(dist))) - circle[j][2]\n                    m2 = circle[i][2] + int(floor(sqrt(dist))) + circle[j][2]\n            elif (circle[i][2] + circle[j][2]) ** 2 == dist:\n                m1 = 0\n                m2 = 2 * circle[i][2] + 2 * circle[j][2]\n            elif (circle[i][2] + circle[j][2]) ** 2 > dist:\n                m1 = 0\n                m2 = int(floor(sqrt(dist))) + circle[i][2] + circle[j][2]\n            elif (circle[i][2] + circle[j][2]) ** 2 < dist:\n                m1 = int(ceil(sqrt(dist))) - circle[i][2] - circle[j][2]\n                m2 = int(floor(sqrt(dist))) + circle[i][2] + circle[j][2]\n        if m2 > 10 ** 6:\n            m2 = 10 ** 6\n        if m1 < 0:\n            m1 = 0\n        ans[m1] += 1\n        ans[m2 + 1] -= 1\nfor i in range(1, 10 ** 6 + 1):\n    ans[i] += ans[i - 1]\nfor _ in range(q):\n    k = int(input())\n    print(ans[k])", "import math\n(n, q) = map(int, input().split())\nx = []\ny = []\nr = []\nr_min = []\nr_max = []\nfor j in range(n):\n    (x1, y1, z1) = map(int, input().split())\n    x.append(x1)\n    y.append(y1)\n    r.append(z1)\nn = len(x)\nfor j in range(n - 1):\n    for k in range(j + 1, n):\n        d = ((x[j] - x[k]) ** 2 + (y[j] - y[k]) ** 2) ** 0.5\n        if r[j] >= d + r[k]:\n            r_min.append(r[j] - d - r[k])\n            r_max.append(r[j] + d + r[k])\n        elif r[k] >= d + r[j]:\n            r_min.append(r[k] - d - r[j])\n            r_max.append(r[k] + d + r[j])\n        else:\n            r1 = d + r[j] + r[k]\n            r2 = d - r[j] - r[k]\n            r_min.append(r2)\n            r_max.append(r1)\nco = [0] * (10 ** 6 + 2)\nfor u in range(len(r_min)):\n    co[max(0, math.ceil(r_min[u]))] += 1\n    co[max(0, math.floor(r_max[u]) + 1)] -= 1\ncount = [0] * (10 ** 6 + 2)\nfor u in range(len(co)):\n    if u > 0:\n        count[u] = co[u] + count[u - 1]\n    else:\n        count[u] = co[u]\nfor _ in range(q):\n    k = int(input())\n    print(count[k])", "import math\n(n, q) = map(int, input().split())\nx = []\ny = []\nr = []\nr_min = []\nr_max = []\nfor j in range(n):\n    (x1, y1, z1) = map(int, input().split())\n    x.append(x1)\n    y.append(y1)\n    r.append(z1)\nn = len(x)\nfor j in range(n - 1):\n    for k in range(j + 1, n):\n        d = ((x[j] - x[k]) ** 2 + (y[j] - y[k]) ** 2) ** 0.5\n        if r[j] >= d + r[k]:\n            r_min.append(r[j] - d - r[k])\n            r_max.append(r[j] + d + r[k])\n        elif r[k] >= d + r[j]:\n            r_min.append(r[k] - d - r[j])\n            r_max.append(r[k] + d + r[j])\n        else:\n            r1 = d + r[j] + r[k]\n            r2 = d - r[j] - r[k]\n            r_min.append(r2)\n            r_max.append(r1)\nco = [0] * (10 ** 6 + 2)\nfor u in range(len(r_min)):\n    co[max(0, math.ceil(r_min[u]))] += 1\n    co[max(0, math.floor(r_max[u]) + 1)] -= 1\ncount = [0] * (10 ** 6 + 2)\nfor u in range(len(co)):\n    if u > 0:\n        count[u] = co[u] + count[u - 1]\n    else:\n        count[u] = co[u]\nfor _ in range(q):\n    k = int(input())\n    print(count[k])", "import math\n(N, Q) = map(int, input().strip().split(' '))\nlst = []\nMin = 0\nMax = 0\nmm = 0\narr = [0] * 1000000\n\ndef dist(a, b):\n    return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)\nfor i in range(N):\n    z = list(map(int, input().strip().split(' ')))\n    lst.append(z)\nfor j in range(N - 1):\n    for k in range(j + 1, N):\n        d = dist(lst[j], lst[k])\n        if d + lst[k][2] + lst[j][2] > mm:\n            mm = int(d + lst[k][2] + lst[j][2])\n        arr[int(d + lst[k][2] + lst[j][2]) + 1] = arr[int(d + lst[k][2] + lst[j][2]) + 1] - 1\n        if lst[j][2] >= lst[k][2]:\n            Max = lst[j][2]\n            Min = lst[k][2]\n        else:\n            Min = lst[j][2]\n            Max = lst[k][2]\n        if d == 0:\n            if Max - Min - int(Max - Min) == 0:\n                arr[int(Max - Min)] = arr[int(Max - Min)] + 1\n            else:\n                arr[int(Max - Min) + 1] = arr[int(Max - Min) + 1] + 1\n            continue\n        elif d == Max - Min:\n            arr[0] = arr[0] + 1\n            continue\n        elif d + Min < Max:\n            m = Max - d - Min\n            if m - int(m) == 0:\n                arr[int(m)] = arr[int(m)] + 1\n            else:\n                arr[int(m) + 1] = arr[int(m) + 1] + 1\n            continue\n        elif d < lst[j][2] + lst[k][2] and d != Max - Min:\n            arr[0] = arr[0] + 1\n            continue\n        elif d == lst[j][2] + lst[k][2]:\n            arr[0] = arr[0] + 1\n            continue\n        elif d > lst[j][2] + lst[k][2]:\n            if d - lst[j][2] - lst[k][2] - int(d - lst[j][2] - lst[k][2]) == 0:\n                arr[int(d - lst[j][2] - lst[k][2])] = arr[int(d - lst[j][2] - lst[k][2])] + 1\n            else:\n                arr[int(d - lst[j][2] - lst[k][2]) + 1] = arr[int(d - lst[j][2] - lst[k][2]) + 1] + 1\n            continue\nfor i in range(1, mm + 1):\n    arr[i] = arr[i - 1] + arr[i]\nfor i in range(Q):\n    D = int(input())\n    if D <= mm:\n        print(arr[D])\n    else:\n        print(0)", "from math import sqrt\nfrom math import ceil\nfrom math import floor\n\ndef get_sum(BIT, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BIT[i]\n        i -= i & -i\n    return s\n\ndef up_date(BIT, n, i, v):\n    i += 1\n    while i <= n:\n        BIT[i] += v\n        i += i & -i\n(n, q) = [int(xdd) for xdd in input().split()]\nl = []\nfor i in range(n):\n    (x, y, r) = [int(xd) for xd in input().split()]\n    l.append([x, y, r])\nk_list = []\nfor j in range(q):\n    k = int(input())\n    k_list.append(k)\na = 0\nmil = []\nwhile a < n:\n    b = a + 1\n    while b < n:\n        dis = sqrt((l[a][0] - l[b][0]) ** 2 + (l[a][1] - l[b][1]) ** 2)\n        mini = dis - (l[a][2] + l[b][2])\n        if dis == 0:\n            mini = abs(l[a][2] - l[b][2])\n        if mini < 0:\n            if l[a][2] > l[b][2] + dis:\n                mini = l[a][2] - dis - l[b][2]\n            elif l[b][2] > l[a][2] + dis:\n                mini = l[b][2] - dis - l[a][2]\n            else:\n                mini = 0\n        maxi = dis + (l[a][2] + l[b][2])\n        mil.append((mini, maxi))\n        b += 1\n    a += 1\ny = len(mil)\nw = 0\nkey = 0\nzz = 1000001\narr = [0] * zz\nwhile w < y:\n    g = ceil(mil[w][0])\n    h = floor(mil[w][1])\n    val = 1\n    up_date(arr, zz, g, val)\n    up_date(arr, zz, h + 1, -1 * val)\n    w += 1\nfor k in k_list:\n    print(get_sum(arr, k))", "import heapq\nfrom math import sqrt\n\ndef main():\n    (N, Q) = map(int, input().split())\n    circles = list()\n    for _ in range(N):\n        (x, y, r) = map(int, input().split())\n        circles.append((x, y, r))\n    dist_ranges = list()\n    for i in range(N - 1):\n        (x1, y1, r1) = circles[i]\n        for j in range(i + 1, N):\n            (x2, y2, r2) = circles[j]\n            dist_center = sqrt((y2 - y1) ** 2 + (x2 - x1) ** 2)\n            max_r = max(r1, r2)\n            min_r = min(r1, r2)\n            if dist_center <= max_r:\n                tmp = max_r - min_r - dist_center\n                low_range = max(0, tmp)\n                high_range = max(abs(tmp), 2 * max_r - tmp)\n            else:\n                tmp = dist_center - r1 - r2\n                low_range = max(0, tmp)\n                high_range = max(abs(tmp), dist_center + r1 + r2)\n            dist_ranges.append((low_range, high_range))\n    dist_ranges.sort()\n    K = [int(input()) for _ in range(Q)]\n    min_K = min(K)\n    max_K = max(K)\n    memo = [0 for _ in range(min_K, max_K + 1)]\n    heap = list()\n    j = 0\n    pop = heapq.heappop\n    push = heapq.heappush\n    for i in range(len(memo)):\n        i += min_K\n        while j < len(dist_ranges) and i >= dist_ranges[j][0]:\n            push(heap, dist_ranges[j][1])\n            j += 1\n        while len(heap) > 0 and heap[0] < i:\n            pop(heap)\n        memo[i - min_K] = len(heap)\n    for k in K:\n        print(memo[k - min_K])\nmain()", "import math\n\ndef dist(onex, oney, twox, twoy):\n    return math.sqrt((onex - twox) ** 2 + (oney - twoy) ** 2)\n(n, q) = [int(i) for i in input().split()]\n(x, y, r, ans) = ([], [], [], 0)\nfor _ in range(n):\n    l = [float(i) for i in input().split()]\n    x.append(l[0])\n    y.append(l[1])\n    r.append(l[2])\ndp = [0 for i in range(1111110)]\nfor i in range(0, n):\n    for j in range(i + 1, n):\n        c1c2 = dist(x[i], y[i], x[j], y[j])\n        f = [c1c2, r[i], r[j]]\n        f.sort()\n        minm = f[2] - f[1] - f[0]\n        if minm < 0:\n            minm = 0\n        maxm = c1c2 + r[i] + r[j]\n        dp[math.ceil(minm)] += 1\n        dp[math.floor(maxm) + 1] -= 1\nfor i in range(1, 1000001):\n    dp[i] = dp[i] + dp[i - 1]\nfor _ in range(q):\n    k = int(input())\n    print(dp[k])", "import math\nfrom itertools import accumulate\n(n, q) = map(int, input().split())\nMatrix = [[0 for o in range(3)] for h in range(n)]\n\ndef cumulativeSum(input):\n    return list(accumulate(input))\nmin = 0\nmax = 0\nfor e in range(n):\n    (x, y, r) = map(int, input().split())\n    Matrix[e][0] = x\n    Matrix[e][1] = y\n    Matrix[e][2] = r\nx = [0] * 1000000\nar = [0] * 1000000\nfor i in range(n):\n    for j in range(i + 1, n):\n        d = math.sqrt((Matrix[i][0] - Matrix[j][0]) ** 2 + (Matrix[i][1] - Matrix[j][1]) ** 2)\n        r1 = Matrix[i][2]\n        r2 = Matrix[j][2]\n        if d >= r1 + r2:\n            min = math.ceil(d - r1 - r2)\n            max = math.floor(d + r1 + r2)\n        else:\n            if r1 > r2:\n                if r1 > d + r2:\n                    min = math.ceil(r1 - d - r2)\n                    max = math.floor(r1 + d + r2)\n                else:\n                    min = 0\n                    max = math.floor(r1 + r2 + d)\n            if r2 >= r1:\n                if r2 > d + r1:\n                    min = math.ceil(r2 - d - r1)\n                    max = math.floor(r1 + d + r2)\n                else:\n                    min = 0\n                    max = math.floor(r1 + r2 + d)\n        x[min] += 1\n        x[max + 1] -= 1\nar = cumulativeSum(x)\nfor c in range(q):\n    k = int(input())\n    print(ar[k])", "import math\n\ndef add(arr, N, lo, hi, val):\n    arr[lo] += val\n    if hi != N - 1:\n        arr[hi + 1] -= val\n\ndef updateArray(arr, N):\n    for i in range(1, N):\n        arr[i] += arr[i - 1]\ncache = []\n(n, q) = [int(x) for x in input().split()]\nc = []\nfor i in range(n):\n    c.append([int(x) for x in input().split()])\nks = 1000000\nkvals = [0 for i in range(ks)]\nfor x in range(n):\n    for y in range(x + 1, n):\n        a = c[x]\n        b = c[y]\n        r1 = a[2]\n        r2 = b[2]\n        z = math.sqrt(math.pow(a[0] - b[0], 2) + math.pow(a[1] - b[1], 2))\n        if a != b:\n            if z < r1 + r2 and z <= abs(r1 - r2):\n                add(kvals, ks, max(0, math.ceil(max(r1, r2) - z - min(r1, r2))), math.floor(r1 + r2 + z), 1)\n            else:\n                add(kvals, ks, max(0, math.ceil(z - r1 - r2)), math.floor(z + r1 + r2), 1)\ndel n\ndel c\nupdateArray(kvals, ks)\nfor i in range(q):\n    query = int(input())\n    print(kvals[query])", "import math\n\ndef add(arr, N, lo, hi, val):\n    arr[lo] += val\n    if hi != N - 1:\n        arr[hi + 1] -= val\n\ndef updateArray(arr, N):\n    for i in range(1, N):\n        arr[i] += arr[i - 1]\ncache = []\n(n, q) = [int(x) for x in input().split()]\nc = []\nfor i in range(n):\n    c.append([int(x) for x in input().split()])\nks = 1000000\nkvals = [0 for i in range(ks)]\nfor x in range(n):\n    for y in range(x + 1, n):\n        a = c[x]\n        b = c[y]\n        r1 = a[2]\n        r2 = b[2]\n        z = math.sqrt(math.pow(a[0] - b[0], 2) + math.pow(a[1] - b[1], 2))\n        if a != b:\n            if z < r1 + r2 and z <= abs(r1 - r2):\n                add(kvals, ks, max(0, math.ceil(max(r1, r2) - z - min(r1, r2))), math.floor(r1 + r2 + z), 1)\n            else:\n                add(kvals, ks, max(0, math.ceil(z - r1 - r2)), math.floor(z + r1 + r2), 1)\ndel n\ndel c\nupdateArray(kvals, ks)\nfor i in range(q):\n    query = int(input())\n    print(kvals[query])", "from math import sqrt\n(N, Q) = map(int, input().split())\nx = []\ny = []\nr = []\nfor i in range(N):\n    (a, b, c) = map(int, input().split())\n    x.append(a)\n    y.append(b)\n    r.append(c)\nlowerdis = []\nupperdis = []\nnos = 0\nfor i in range(N):\n    for j in range(i + 1, N):\n        r1 = r[i]\n        r2 = r[j]\n        distance = sqrt((x[i] - x[j]) ** 2 + (y[i] - y[j]) ** 2)\n        minimum = 0\n        maximum = 0\n        if distance > r1 + r2:\n            minimum = distance - r1 - r2\n            maximum = distance + r1 + r2\n        elif distance < abs(r1 - r2):\n            minimum = abs(r1 - r2) - distance\n            maximum = r1 + r2 + distance\n        else:\n            minimum = 0\n            maximum = distance + r1 + r2\n        lowerdis.append(minimum)\n        upperdis.append(maximum)\n        nos += 1\nlowerdis.sort()\nupperdis.sort()\ni = 0\nj = 0\nansarray = [0] * 1000001\ncount = 0\nfor index in range(1000001):\n    if i < nos:\n        while index >= lowerdis[i]:\n            i += 1\n            count += 1\n            if i == nos:\n                break\n    while index > upperdis[j]:\n        count -= 1\n        j += 1\n        if j == nos:\n            break\n    ansarray[index] = count\n    if j >= nos:\n        break\nfor i in range(Q):\n    a = int(input())\n    print(ansarray[a])", "import math\n(n, q) = map(int, input().split(' '))\n(x, y, r, a) = ([], [], [], [])\nfor i in range(n):\n    (x1, y1, r1) = map(int, input().split(' '))\n    x.append(x1)\n    y.append(y1)\n    r.append(r1)\nfor i in range(1000005):\n    a.append(0)\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        d1 = ((x[i] - x[j]) ** 2 + (y[i] - y[j]) ** 2) ** 0.5\n        m1 = d1 + r[i] + r[j]\n        if d1 + min(r[i], r[j]) < max(r[i], r[j]):\n            m2 = max(r[i], r[j]) - d1 - min(r[i], r[j])\n        else:\n            m2 = d1 - r[i] - r[j]\n        m1 = int(m1)\n        m2 = int(math.ceil(m2))\n        m2 = max(m2, 0)\n        a[m2] += 1\n        a[m1 + 1] -= 1\nfor i in range(1, 1000005):\n    a[i] += a[i - 1]\nfor i in range(q):\n    ks = input()\n    k = int(ks)\n    print(a[k])", "import math\nn = [int(x) for x in input().split()]\ng = []\narr = []\nfor i in range(n[0]):\n    c = [int(x) for x in input().split()]\n    g.append(c)\nfor h in range(10 ** 6 + 1):\n    arr.append(0)\nfor j in range(len(g)):\n    for k in range(j + 1, len(g)):\n        z = ((g[j][0] - g[k][0]) ** 2 + (g[j][1] - g[k][1]) ** 2) ** 0.5\n        if z < g[j][2] + g[k][2] and z <= abs(g[j][2] - g[k][2]):\n            max_dis = z + min(g[j][2], g[k][2]) + max(g[j][2], g[k][2])\n            min_dis = max(max(g[j][2], g[k][2]) - (z + min(g[j][2], g[k][2])), 0)\n        else:\n            max_dis = z + g[j][2] + g[k][2]\n            min_dis = max(z - (g[j][2] + g[k][2]), 0)\n        hi = math.floor(max_dis)\n        lo = math.ceil(min_dis)\n        arr[hi + 1] = arr[hi + 1] - 1\n        arr[lo] = arr[lo] + 1\nfor i in range(1, len(arr)):\n    arr[i] += arr[i - 1]\nfor i in range(n[1]):\n    x = int(input())\n    print(arr[x])", "def add(arr, N, lo, hi, val):\n    arr[lo] += val\n    if hi != N - 1:\n        arr[hi + 1] -= val\nimport math\nn = [int(x) for x in input().split()]\ng = []\narr = []\nfor i in range(n[0]):\n    c = [int(x) for x in input().split()]\n    g.append(c)\nfor h in range(10 ** 6 + 1):\n    arr.append(0)\nfor j in range(len(g)):\n    for k in range(j + 1, len(g)):\n        z = ((g[j][0] - g[k][0]) ** 2 + (g[j][1] - g[k][1]) ** 2) ** 0.5\n        if z < g[j][2] + g[k][2] and z <= abs(g[j][2] - g[k][2]):\n            max_dis = z + min(g[j][2], g[k][2]) + max(g[j][2], g[k][2])\n            min_dis = max(max(g[j][2], g[k][2]) - (z + min(g[j][2], g[k][2])), 0)\n        else:\n            max_dis = z + g[j][2] + g[k][2]\n            min_dis = max(z - (g[j][2] + g[k][2]), 0)\n        hi = math.floor(max_dis)\n        lo = math.ceil(min_dis)\n        add(arr, len(arr), lo, hi, 1)\nfor i in range(1, len(arr)):\n    arr[i] += arr[i - 1]\nfor i in range(n[1]):\n    x = int(input())\n    print(arr[x])", "def add(arr, N, lo, hi, val):\n    arr[lo] += val\n    if hi != N - 1:\n        arr[hi + 1] -= val\n\ndef updateArray(arr, N):\n    for i in range(1, N):\n        arr[i] += arr[i - 1]\n    return arr\nN = 1000001\ncar = [0 for x in range(0, 1000001)]\nimport math\n(l, u) = ([], [])\n(n, q) = [int(x) for x in input().split()]\nc = []\nfor i in range(n):\n    c.append([int(x) for x in input().split()])\nfor x in range(n):\n    for y in range(x + 1, n):\n        a = c[x]\n        b = c[y]\n        r1 = a[2]\n        r2 = b[2]\n        z = math.sqrt(math.pow(a[0] - b[0], 2) + math.pow(a[1] - b[1], 2))\n        if a != b:\n            if z < r1 + r2 and z <= abs(r1 - r2):\n                add(car, N, max(math.ceil(max(r1, r2) - z - min(r1, r2)), 0), math.floor(r1 + r2 + z), 1)\n            else:\n                add(car, N, max(0, math.ceil(z - r1 - r2)), math.floor(z + r1 + r2), 1)\ncar = updateArray(car, N)\nfor i in range(q):\n    k = int(input())\n    print(car[k])", "import math\nimport sys\nimport bisect\ninput_str = sys.stdin.read()\ndata = [int(x) for x in input_str.split()]\nn = data[0]\nq = data[1]\nCX = data[2:-q:3]\nCY = data[3:-q:3]\nCR = data[4:-q:3]\nqu = data[-q:]\nleftEnds = []\nrightEnds = []\nfor i in range(n):\n    for j in range(i + 1, n):\n        d = math.sqrt((CX[i] - CX[j]) * (CX[i] - CX[j]) + (CY[i] - CY[j]) * (CY[i] - CY[j]))\n        maxDistance = d + CR[i] + CR[j]\n        if d > CR[i] + CR[j]:\n            minDistance = d - CR[i] - CR[j]\n        elif CR[i] > d + CR[j]:\n            minDistance = CR[i] - d - CR[j]\n        elif CR[j] > d + CR[i]:\n            minDistance = CR[j] - d - CR[i]\n        else:\n            minDistance = 0\n        leftEnds.append(minDistance)\n        rightEnds.append(maxDistance)\nleftEnds.sort()\nrightEnds.sort()\nfor i in range(q):\n    k = qu[i]\n    print(bisect.bisect_right(leftEnds, k) - bisect.bisect_left(rightEnds, k))"]