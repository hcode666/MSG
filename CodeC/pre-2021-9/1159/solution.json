["import bisect\nimport sys\nimport math\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_list_strings():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef solve():\n    distance = get_int()\n    arr1 = get_list()\n    arr2 = get_list()\n    store1 = []\n    store2 = []\n    r = 1\n    b = arr1[0]\n    c = arr2[0]\n    for i in range(1, len(arr1), 2):\n        store1.append([arr1[i], arr1[i + 1]])\n        r += arr1[i + 1]\n    for i in range(1, len(arr2), 3):\n        store2.append([arr2[i], arr2[i + 1], arr2[i + 2]])\n    l = 1\n    ans = r\n    while l <= r:\n        m = (l + r) // 2\n        mid = m\n        i = 0\n        j = 0\n        flag = 0\n        while (i < len(store1) and j < len(store2)) and flag == 0:\n            if store1[i][0] > store2[j][0]:\n                if m >= store2[j][1]:\n                    m += store2[j][2]\n                j += 1\n            elif store1[i][0] < store2[j][0]:\n                m -= store1[i][1]\n                if m <= 0:\n                    flag = 1\n                i += 1\n            else:\n                if m >= store2[j][1]:\n                    m += store2[j][2]\n                m -= store1[i][1]\n                if m <= 0:\n                    flag = 1\n                i += 1\n                j += 1\n        if flag == 1:\n            l = mid + 1\n            continue\n        while i < len(store1) and flag == 0:\n            m -= store1[i][1]\n            if m <= 0:\n                flag = 1\n            i += 1\n        if flag == 1:\n            l = mid + 1\n        else:\n            ans = mid\n            r = mid - 1\n    print(ans)\nT = get_int()\nwhile T:\n    solve()\n    T -= 1", "import bisect\nimport sys\nimport math\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_list_strings():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef solve():\n    distance = get_int()\n    arr1 = get_list()\n    arr2 = get_list()\n    store1 = []\n    store2 = []\n    r = 1\n    b = arr1[0]\n    c = arr2[0]\n    for i in range(1, len(arr1), 2):\n        store1.append([arr1[i], arr1[i + 1]])\n        r += arr1[i + 1]\n    for i in range(1, len(arr2), 3):\n        store2.append([arr2[i], arr2[i + 1], arr2[i + 2]])\n    l = 1\n    ans = r\n    while l <= r:\n        m = (l + r) // 2\n        mid = m\n        i = 0\n        j = 0\n        flag = 0\n        while (i < len(store1) and j < len(store2)) and flag == 0:\n            if store1[i][0] > store2[j][0]:\n                if m >= store2[j][1]:\n                    m += store2[j][2]\n                j += 1\n            elif store1[i][0] < store2[j][0]:\n                m -= store1[i][1]\n                if m <= 0:\n                    flag = 1\n                i += 1\n            else:\n                if m >= store2[j][1]:\n                    m += store2[j][2]\n                m -= store1[i][1]\n                if m <= 0:\n                    flag = 1\n                i += 1\n                j += 1\n        if flag == 1:\n            l = mid + 1\n            continue\n        while i < len(store1) and flag == 0:\n            m -= store1[i][1]\n            if m <= 0:\n                flag = 1\n            i += 1\n        if flag == 1:\n            l = mid + 1\n        else:\n            ans = mid\n            r = mid - 1\n    print(ans)\nT = get_int()\nwhile T:\n    solve()\n    T -= 1", "def solve():\n    X = int(input(''))\n    g = input('').split()\n    B = g[0]\n    x = []\n    lo = 1\n    hi = 1\n    for j in range(1, len(g), 2):\n        hi += int(g[j + 1])\n        x.append([int(g[j]), int(g[j + 1])])\n    h = input('').split()\n    C = h[0]\n    p = []\n    for j in range(1, len(h), 3):\n        p.append([int(h[j]), int(h[j + 1]), int(h[j + 2])])\n    while hi > lo:\n        m = (lo + hi) // 2\n        mid = m\n        i = j = 0\n        while i < len(x) and j < len(p):\n            if x[i][0] > p[j][0]:\n                if m >= p[j][1]:\n                    m += p[j][2]\n                j += 1\n            elif x[i][0] < p[j][0]:\n                if m > x[i][1]:\n                    m -= x[i][1]\n                else:\n                    m -= x[i][1]\n                    lo = mid + 1\n                    i += 1\n                    break\n                i += 1\n            else:\n                if m >= p[j][1]:\n                    m += p[j][2]\n                j += 1\n                if m > x[i][1]:\n                    m -= x[i][1]\n                else:\n                    lo = mid + 1\n                    break\n                i += 1\n        if i < len(x):\n            while i < len(x):\n                m -= x[i][1]\n                i += 1\n        if m <= 0:\n            lo = mid + 1\n            continue\n        hi = mid\n    return hi\nfor i in range(0, int(input(''))):\n    print(solve())", "def solve():\n    X = int(input(''))\n    g = input('').split()\n    B = g[0]\n    x = []\n    lo = 1\n    hi = 1\n    for j in range(1, len(g), 2):\n        hi += int(g[j + 1])\n        x.append([int(g[j]), int(g[j + 1])])\n    h = input('').split()\n    C = h[0]\n    p = []\n    for j in range(1, len(h), 3):\n        p.append([int(h[j]), int(h[j + 1]), int(h[j + 2])])\n    while hi > lo:\n        m = (lo + hi) // 2\n        mid = m\n        i = j = 0\n        while i < len(x) and j < len(p):\n            if x[i][0] > p[j][0]:\n                if m >= p[j][1]:\n                    m += p[j][2]\n                j += 1\n            elif x[i][0] < p[j][0]:\n                if m > x[i][1]:\n                    m -= x[i][1]\n                else:\n                    m -= x[i][1]\n                    lo = mid + 1\n                    i += 1\n                    break\n                i += 1\n            else:\n                if m >= p[j][1]:\n                    m += p[j][2]\n                j += 1\n                if m > x[i][1]:\n                    m -= x[i][1]\n                else:\n                    lo = mid + 1\n                    break\n                i += 1\n        if i < len(x):\n            while i < len(x):\n                m -= x[i][1]\n                i += 1\n        if m <= 0:\n            lo = mid + 1\n            continue\n        hi = mid\n    return hi\nfor i in range(0, int(input(''))):\n    print(solve())", "def solve():\n    X = int(input(''))\n    g = input('').split()\n    B = g[0]\n    x = []\n    lo = 1\n    hi = 1\n    for j in range(1, len(g), 2):\n        hi += int(g[j + 1])\n        x.append([int(g[j]), int(g[j + 1])])\n    h = input('').split()\n    C = h[0]\n    p = []\n    for j in range(1, len(h), 3):\n        p.append([int(h[j]), int(h[j + 1]), int(h[j + 2])])\n    while hi > lo:\n        m = (lo + hi) // 2\n        mid = m\n        i = j = 0\n        while i < len(x) and j < len(p):\n            if x[i][0] > p[j][0]:\n                if m >= p[j][1]:\n                    m += p[j][2]\n                j += 1\n            elif x[i][0] < p[j][0]:\n                if m > x[i][1]:\n                    m -= x[i][1]\n                else:\n                    m -= x[i][1]\n                    lo = mid + 1\n                    i += 1\n                    break\n                i += 1\n            else:\n                if m >= p[j][1]:\n                    m += p[j][2]\n                j += 1\n                if m > x[i][1]:\n                    m -= x[i][1]\n                else:\n                    lo = mid + 1\n                    break\n                i += 1\n        if i < len(x):\n            while i < len(x):\n                m -= x[i][1]\n                i += 1\n        if m <= 0:\n            lo = mid + 1\n            continue\n        hi = mid\n    return hi\nfor i in range(0, int(input(''))):\n    print(solve())", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    np = a[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([a[i], a[i + 1], -1])\n        sm += a[i + 1]\n    tg = list(map(int, input().split()))\n    ng = tg[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tg[i], tg[i + 2], tg[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    np = a[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([a[i], a[i + 1], -1])\n        sm += a[i + 1]\n    tg = list(map(int, input().split()))\n    ng = tg[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tg[i], tg[i + 2], tg[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    np = a[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([a[i], a[i + 1], -1])\n        sm += a[i + 1]\n    tg = list(map(int, input().split()))\n    ng = tg[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tg[i], tg[i + 2], tg[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    np = a[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([a[i], a[i + 1], -1])\n        sm += a[i + 1]\n    tg = list(map(int, input().split()))\n    ng = tg[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tg[i], tg[i + 2], tg[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    np = a[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([a[i], a[i + 1], -1])\n        sm += a[i + 1]\n    tg = list(map(int, input().split()))\n    ng = tg[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tg[i], tg[i + 2], tg[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    np = a[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([a[i], a[i + 1], -1])\n        sm += a[i + 1]\n    tg = list(map(int, input().split()))\n    ng = tg[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tg[i], tg[i + 2], tg[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    np = a[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([a[i], a[i + 1], -1])\n        sm += a[i + 1]\n    tg = list(map(int, input().split()))\n    ng = tg[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tg[i], tg[i + 2], tg[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    np = a[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([a[i], a[i + 1], -1])\n        sm += a[i + 1]\n    tg = list(map(int, input().split()))\n    ng = tg[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tg[i], tg[i + 2], tg[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    np = a[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([a[i], a[i + 1], -1])\n        sm += a[i + 1]\n    tg = list(map(int, input().split()))\n    ng = tg[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tg[i], tg[i + 2], tg[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    np = a[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([a[i], a[i + 1], -1])\n        sm += a[i + 1]\n    tg = list(map(int, input().split()))\n    ng = tg[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tg[i], tg[i + 2], tg[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    np = a[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([a[i], a[i + 1], -1])\n        sm += a[i + 1]\n    tg = list(map(int, input().split()))\n    ng = tg[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tg[i], tg[i + 2], tg[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "for _ in range(int(input())):\n    n = int(input())\n    tarr = list(map(int, input().split()))\n    np = tarr[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([tarr[i], tarr[i + 1], -1])\n        sm += tarr[i + 1]\n    tgroup = list(map(int, input().split()))\n    ng = tgroup[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tgroup[i], tgroup[i + 2], tgroup[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "for _ in range(int(input())):\n    n = int(input())\n    tarr = list(map(int, input().split()))\n    np = tarr[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([tarr[i], tarr[i + 1], -1])\n        sm += tarr[i + 1]\n    tgroup = list(map(int, input().split()))\n    ng = tgroup[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tgroup[i], tgroup[i + 2], tgroup[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "for _ in range(int(input())):\n    n = int(input())\n    tarr = list(map(int, input().split()))\n    np = tarr[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([tarr[i], tarr[i + 1], -1])\n        sm += tarr[i + 1]\n    tgroup = list(map(int, input().split()))\n    ng = tgroup[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tgroup[i], tgroup[i + 2], tgroup[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "for _ in range(int(input())):\n    n = int(input())\n    tarr = list(map(int, input().split()))\n    np = tarr[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([tarr[i], tarr[i + 1], -1])\n        sm += tarr[i + 1]\n    tgroup = list(map(int, input().split()))\n    ng = tgroup[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tgroup[i], tgroup[i + 2], tgroup[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "for _ in range(int(input())):\n    n = int(input())\n    tarr = list(map(int, input().split()))\n    np = tarr[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([tarr[i], tarr[i + 1], -1])\n        sm += tarr[i + 1]\n    tgroup = list(map(int, input().split()))\n    ng = tgroup[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tgroup[i], tgroup[i + 2], tgroup[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "import sys\n\ndef possible(val, path):\n    for item in path:\n        if item[1] == 0:\n            val -= item[2]\n        elif val >= item[2]:\n            val += item[3]\n    return val > 0\n\ndef findans(maxY, path):\n    high = maxY + 100\n    low = 1\n    ans = maxY + 100\n    while low <= high:\n        mid = (low + high) // 2\n        if possible(mid, path):\n            ans = min(ans, mid)\n            high = mid - 1\n        else:\n            low = mid + 1\n    return ans\nfor _ in range(int(input())):\n    X = int(input())\n    path = []\n    maxY = 0\n    (b, *arr) = [int(c) for c in input().split()]\n    for i in range(0, len(arr), 2):\n        x = arr[i]\n        y = arr[i + 1]\n        path.append((x, 0, y, 0))\n        maxY += y\n    (c, *arr) = [int(c) for c in input().split()]\n    for i in range(0, len(arr), 3):\n        p = arr[i]\n        q = arr[i + 1]\n        r = arr[i + 2]\n        path.append((p, 1, q, r))\n    path.sort(key=lambda x: x[0])\n    print(findans(maxY, path))", "import sys\n\ndef possible(val, path):\n    for item in path:\n        if item[1] == 0:\n            val -= item[2]\n        elif val >= item[2]:\n            val += item[3]\n    return val > 0\n\ndef findans(maxY, path):\n    high = maxY + 100\n    low = 1\n    ans = maxY + 100\n    while low <= high:\n        mid = (low + high) // 2\n        if possible(mid, path):\n            ans = min(ans, mid)\n            high = mid - 1\n        else:\n            low = mid + 1\n    return ans\nfor _ in range(int(input())):\n    X = int(input())\n    path = []\n    maxY = 0\n    (b, *arr) = [int(c) for c in input().split()]\n    for i in range(0, len(arr), 2):\n        x = arr[i]\n        y = arr[i + 1]\n        path.append((x, 0, y, 0))\n        maxY += y\n    (c, *arr) = [int(c) for c in input().split()]\n    for i in range(0, len(arr), 3):\n        p = arr[i]\n        q = arr[i + 1]\n        r = arr[i + 2]\n        path.append((p, 1, q, r))\n    path.sort(key=lambda x: x[0])\n    print(findans(maxY, path))", "for _ in range(int(input())):\n    n = int(input())\n    tarr = list(map(int, input().split()))\n    np = tarr[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([tarr[i], tarr[i + 1], -1])\n        sm += tarr[i + 1]\n    tgroup = list(map(int, input().split()))\n    ng = tgroup[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tgroup[i], tgroup[i + 2], tgroup[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "def possible(val: int, path: list) -> bool:\n    for item in path:\n        if item[1] == 0:\n            val -= item[2]\n        elif val >= item[2]:\n            val += item[3]\n    return val > 0\n\ndef solve(maxChef: int, path: list) -> int:\n    high = maxChef + 100\n    low = 1\n    ans = maxChef + 100\n    while low <= high:\n        mid = (low + high) // 2\n        if possible(mid, path):\n            ans = min(ans, mid)\n            high = mid - 1\n        else:\n            low = mid + 1\n    return ans\nfor _ in range(int(input())):\n    X = int(input())\n    maxChef = 0\n    path = []\n    (b, *arr) = [int(c) for c in input().split()]\n    for i in range(0, len(arr), 2):\n        location = arr[i]\n        required_chef = arr[i + 1]\n        path.append((location, 0, required_chef, 0))\n        maxChef += required_chef\n    (c, *arr) = [int(c) for c in input().split()]\n    for i in range(0, len(arr), 3):\n        location = arr[i]\n        chef_required = arr[i + 1]\n        chef_given = arr[i + 2]\n        path.append((location, 1, chef_required, chef_given))\n    path.sort(key=lambda x: x[0])\n    print(solve(maxChef, path))", "import sys\n\ndef possible(val, path):\n    for item in path:\n        if item[1] == 0:\n            val -= item[2]\n        elif val >= item[2]:\n            val += item[3]\n    return val > 0\n\ndef findans(maxY, path):\n    high = maxY + 100\n    low = 1\n    ans = maxY + 100\n    while low <= high:\n        mid = (low + high) // 2\n        if possible(mid, path):\n            ans = min(ans, mid)\n            high = mid - 1\n        else:\n            low = mid + 1\n    return ans\nfor _ in range(int(input())):\n    X = int(input())\n    path = []\n    maxY = 0\n    (b, *arr) = [int(c) for c in input().split()]\n    for i in range(0, len(arr), 2):\n        x = arr[i]\n        y = arr[i + 1]\n        path.append((x, 0, y, 0))\n        maxY += y\n    (c, *arr) = [int(c) for c in input().split()]\n    for i in range(0, len(arr), 3):\n        p = arr[i]\n        q = arr[i + 1]\n        r = arr[i + 2]\n        path.append((p, 1, q, r))\n    path.sort(key=lambda x: x[0])\n    print(findans(maxY, path))", "for _ in range(int(input())):\n    n = int(input())\n    tarr = list(map(int, input().split()))\n    np = tarr[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([tarr[i], tarr[i + 1], -1])\n        sm += tarr[i + 1]\n    tgroup = list(map(int, input().split()))\n    ng = tgroup[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tgroup[i], tgroup[i + 2], tgroup[i + 1]]\n        group.append(k)\n    ans = []\n    i = 0\n    j = 0\n    while i < np and j < ng:\n        if arr[i] < group[j]:\n            ans.append(arr[i])\n            i += 1\n        else:\n            ans.append(group[j])\n            j += 1\n    while i < np:\n        ans.append(arr[i])\n        i += 1\n    while j < ng:\n        ans.append(group[j])\n        j += 1\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "for _ in range(int(input())):\n    n = int(input())\n    tarr = list(map(int, input().split()))\n    np = tarr[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([tarr[i], tarr[i + 1], -1])\n        sm += tarr[i + 1]\n    tgroup = list(map(int, input().split()))\n    ng = tgroup[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tgroup[i], tgroup[i + 2], tgroup[i + 1]]\n        group.append(k)\n    ans = []\n    i = 0\n    j = 0\n    while i < np and j < ng:\n        if arr[i] < group[j]:\n            ans.append(arr[i])\n            i += 1\n        else:\n            ans.append(group[j])\n            j += 1\n    while i < np:\n        ans.append(arr[i])\n        i += 1\n    while j < ng:\n        ans.append(group[j])\n        j += 1\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "for _ in range(int(input())):\n    n = int(input())\n    tarr = list(map(int, input().split()))\n    np = tarr[0]\n    arr = []\n    sm = 1\n    for i in range(1, 2 * np + 1, 2):\n        arr.append([tarr[i], tarr[i + 1], -1])\n        sm += tarr[i + 1]\n    tgroup = list(map(int, input().split()))\n    ng = tgroup[0]\n    group = []\n    for i in range(1, 3 * ng + 1, 3):\n        k = [tgroup[i], tgroup[i + 2], tgroup[i + 1]]\n        group.append(k)\n    ans = []\n    for item in arr:\n        ans.append(item)\n    for item in group:\n        ans.append(item)\n    ans.sort()\n\n    def solve(m):\n        for item in ans:\n            if item[2] == -1:\n                m = m - item[1]\n            elif item[2] <= m:\n                m += item[1]\n        return m\n    s = 1\n    e = sm\n    v = None\n    while s <= e:\n        m = (s + e) // 2\n        if solve(m) >= 1:\n            v = m\n            e = m - 1\n        else:\n            s = m + 1\n    print(v)", "def fun(x, X, B, C, d, c):\n    i = 0\n    j = 0\n    count = 0\n    per = x\n    while i < 2 * d:\n        di = B[i]\n        if j + 2 < c * 3:\n            pj = C[j]\n        else:\n            pj = None\n        if pj != None and pj == di:\n            if per >= C[j + 1]:\n                per += C[j + 2]\n                j += 3\n            per -= B[i + 1]\n            if per <= 0:\n                break\n            i += 2\n        elif pj != None and pj < di:\n            if per >= C[j + 1]:\n                per += C[j + 2]\n            j += 3\n        else:\n            per -= B[i + 1]\n            if per <= 0:\n                break\n            i += 2\n    if per >= 1:\n        return True\n    else:\n        return False\n\ndef binaryfun(d, c, B, C, i, x, X):\n    if i <= x:\n        m = (x + i) // 2\n        if fun(m, X, B, C, d, c) == True:\n            return binaryfun(d, c, B, C, i, m - 1, X)\n        else:\n            return binaryfun(d, c, B, C, m + 1, x, X)\n    else:\n        return max(i, x)\nfor _ in range(int(input())):\n    X = int(input())\n    B = [int(x) for x in input().split()]\n    d = B.pop(0)\n    C = [int(x) for x in input().split()]\n    c = C.pop(0)\n    x = 0\n    for i in range(1, len(B), 2):\n        x += B[i]\n    x += 1\n    if c == 0:\n        print(x)\n    else:\n        print(binaryfun(d, c, B, C, 1, x, X))", "from sys import stdin\nnewpath = []\nfinalans = []\n\ndef check(num):\n    point = 0\n    for j in newpath:\n        if j[2] == -99:\n            num -= j[1]\n            if num < 1:\n                return False\n        elif num >= j[1]:\n            num += j[2]\n    return True\n\ndef binary(low, high):\n    if high - low == 1:\n        if check(low):\n            finalans.append(low)\n        else:\n            finalans.append(high)\n        return\n    mid = (low + high) // 2\n    if check(mid):\n        finalans.append(mid)\n        binary(low, mid)\n    else:\n        binary(mid, high)\nno = int(stdin.readline())\nfor _ in range(no):\n    newpath.clear()\n    finalans.clear()\n    totdistance = int(stdin.readline())\n    path = list(map(int, stdin.readline().split()))\n    tribal = list(map(int, stdin.readline().split()))\n    count = 1\n    lever = 1\n    for _ in range(path[0]):\n        count += path[lever + 1]\n        lever += 2\n    if tribal[0] == 0:\n        print(count)\n    else:\n        top = path[-2]\n        flag = True\n        pathpoint = 0\n        tribalpoint = 0\n        pathindex = 1\n        tribalindex = 1\n        while tribalpoint < tribal[0] and pathpoint < path[0]:\n            if tribal[tribalindex] > top:\n                break\n            if tribal[tribalindex] < path[pathindex]:\n                newpath.append(tribal[tribalindex:tribalindex + 3])\n                tribalindex += 3\n                tribalpoint += 1\n            else:\n                newpath.append([path[pathindex], path[pathindex + 1], -99])\n                pathindex += 2\n                pathpoint += 1\n        rem = path[0] - pathpoint\n        if rem > 0:\n            for i in range(rem):\n                newpath.append([path[pathindex], path[pathindex + 1], -99])\n                pathindex += 2\n        binary(1, count)\n        print(finalans[-1])", "for i in range(int(input())):\n    x = int(input())\n    temp = [int(i) for i in input().split()]\n    b = temp[0]\n    dishes = []\n    j = 1\n    while j < 2 * b:\n        dishes.append([temp[j], temp[j + 1]])\n        j += 2\n    temp = [int(i) for i in input().split()]\n    c = temp[0]\n    j = 1\n    clan = []\n    while j < 3 * c:\n        clan.append([temp[j], temp[j + 1], temp[j + 2]])\n        j += 3\n    ans = 1\n    dish_ptr = b - 1\n    clan_ptr = c - 1\n    while clan_ptr >= 0 and clan[clan_ptr][0] > dishes[dish_ptr][0]:\n        clan_ptr -= 1\n    while clan_ptr >= 0 or dish_ptr >= 0:\n        if clan_ptr < 0:\n            ans += dishes[dish_ptr][1]\n            dish_ptr -= 1\n        elif dish_ptr < 0:\n            ans = min(ans, max(ans - clan[clan_ptr][2], clan[clan_ptr][1]))\n            clan_ptr -= 1\n        elif clan[clan_ptr][0] > dishes[dish_ptr][0]:\n            ans = min(ans, max(ans - clan[clan_ptr][2], clan[clan_ptr][1]))\n            clan_ptr -= 1\n        else:\n            ans += dishes[dish_ptr][1]\n            dish_ptr -= 1\n    print(ans)", "def possible(R):\n    for i in path:\n        if i[2] == 'dish':\n            R -= i[1]\n        elif R >= i[1]:\n            R += i[2]\n    return R > 0\nfor _ in range(int(input())):\n    n = int(input())\n    d = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    b = d[0]\n    dishes = []\n    mn = 1\n    mx = 0\n    for i in range(1, 2 * b + 1, 2):\n        dishes.append([d[i], d[i + 1], 'dish'])\n        mx += d[i + 1]\n    if t == [0]:\n        required = 0\n        for i in range(b):\n            required += dishes[i][1]\n        print(required + 1)\n        continue\n    c = t[0]\n    clans = []\n    for i in range(1, 3 * c + 1, 3):\n        clans.append([t[i], t[i + 1], t[i + 2]])\n    path = dishes + clans\n    path.sort()\n    ans = mx\n    while mn < mx:\n        m = (mn + mx) // 2\n        if possible(m):\n            ans = min(ans, m)\n            mx = m\n        else:\n            mn = m + 1\n    print(ans)", "def binary(l, r, ans):\n    low = l\n    high = r\n    while low <= high:\n        mid = (low + high) // 2\n        if possible(mid):\n            ans = min(ans, mid)\n            high = mid - 1\n        else:\n            low = mid + 1\n    return ans\n\ndef possible(n):\n    v = n\n    for i in range(len(e)):\n        if e[i][0][1]:\n            v -= e[i][1][0]\n        elif v >= e[i][1][0]:\n            v += e[i][1][1]\n    return v > 0\nfor i in range(int(input())):\n    x = int(input())\n    t = list(map(int, input().split()))\n    ans = 0\n    q = 1\n    i = 1\n    e = []\n    while i < 2 * t[0]:\n        e.append([[t[i], 1], [t[i + 1], 0]])\n        q = q + t[i + 1]\n        i = i + 2\n    t = list(map(int, input().split()))\n    i = 1\n    while i < 3 * t[0]:\n        e.append([[t[i], 0], [t[i + 1], t[i + 2]]])\n        i = i + 3\n    e.sort()\n    print(binary(1, q, q))", "t = int(input())\nfor i in range(t):\n    x = int(input())\n    d = []\n    l = [int(x) for x in input().split()]\n    b = l[0]\n    l.remove(l[0])\n    for i in range(0, len(l), 2):\n        d.append([l[i], -l[i + 1]])\n    q = [int(x) for x in input().split()]\n    c = q[0]\n    q.remove(q[0])\n    for i in range(0, len(q), 3):\n        d.append([q[i], q[i + 1], q[i + 2]])\n    d.sort()\n    if c == 0:\n        sum = 0\n        for i in range(1, len(l), 2):\n            sum = sum + l[i]\n        sum += 1\n        print(sum)\n    else:\n\n        def possible(m):\n            for i in range(len(d)):\n                if len(d[i]) == 2:\n                    m += d[i][1]\n                elif m >= d[i][1]:\n                    m += d[i][2]\n            return m > 0\n        sum = 0\n        for i in range(1, len(l), 2):\n            sum = sum + l[i]\n        sum += 1\n        low = 1\n        high = sum\n        ans = sum\n        while low <= high:\n            m = (low + high) // 2\n            if possible(m):\n                ans = min(ans, m)\n                high = m - 1\n            else:\n                low = m + 1\n        print(ans)", "t = int(input())\nfor i in range(t):\n    x = int(input())\n    d = []\n    l = [int(x) for x in input().split()]\n    b = l[0]\n    l.remove(l[0])\n    for i in range(0, len(l), 2):\n        d.append([l[i], -l[i + 1]])\n    q = [int(x) for x in input().split()]\n    c = q[0]\n    q.remove(q[0])\n    for i in range(0, len(q), 3):\n        d.append([q[i], q[i + 1], q[i + 2]])\n    d.sort()\n    if c == 0:\n        sum = 0\n        for i in range(1, len(l), 2):\n            sum = sum + l[i]\n        sum += 1\n        print(sum)\n    else:\n\n        def possible(m):\n            for i in range(len(d)):\n                if len(d[i]) == 2:\n                    m += d[i][1]\n                elif m >= d[i][1]:\n                    m += d[i][2]\n            return m > 0\n        sum = 0\n        for i in range(1, len(l), 2):\n            sum = sum + l[i]\n        sum += 1\n        low = 1\n        high = sum\n        ans = sum\n        while low <= high:\n            m = (low + high) // 2\n            if possible(m):\n                ans = min(ans, m)\n                high = m - 1\n            else:\n                low = m + 1\n        print(ans)", "t = int(input())\nfor i in range(t):\n    x = int(input())\n    d = []\n    l = [int(x) for x in input().split()]\n    b = l[0]\n    l.remove(l[0])\n    for i in range(0, len(l), 2):\n        d.append([l[i], -l[i + 1]])\n    q = [int(x) for x in input().split()]\n    c = q[0]\n    q.remove(q[0])\n    for i in range(0, len(q), 3):\n        d.append([q[i], q[i + 1], q[i + 2]])\n    d.sort()\n    if c == 0:\n        sum = 0\n        for i in range(1, len(l), 2):\n            sum = sum + l[i]\n        sum += 1\n        print(sum)\n    else:\n\n        def possible(m):\n            for i in range(len(d)):\n                if len(d[i]) == 2:\n                    m += d[i][1]\n                elif m >= d[i][1]:\n                    m += d[i][2]\n            return m > 0\n        sum = 0\n        for i in range(1, len(l), 2):\n            sum = sum + l[i]\n        sum += 1\n        low = 1\n        high = sum\n        ans = sum\n        while low <= high:\n            m = (low + high) // 2\n            if possible(m):\n                ans = min(ans, m)\n                high = m - 1\n            else:\n                low = m + 1\n        print(ans)", "t = int(input())\nfor i in range(t):\n    x = int(input())\n    temp = [int(i) for i in input().split()]\n    b = temp[0]\n    dishes = []\n    j = 1\n    while j < 2 * b:\n        dishes.append([temp[j], temp[j + 1]])\n        j += 2\n    temp = [int(i) for i in input().split()]\n    c = temp[0]\n    j = 1\n    clan = []\n    while j < 3 * c:\n        clan.append([temp[j], temp[j + 1], temp[j + 2]])\n        j += 3\n    ans = 1\n    dish_ptr = b - 1\n    clan_ptr = c - 1\n    while clan_ptr >= 0 and clan[clan_ptr][0] > dishes[dish_ptr][0]:\n        clan_ptr -= 1\n    while clan_ptr >= 0 or dish_ptr >= 0:\n        if clan_ptr < 0:\n            ans += dishes[dish_ptr][1]\n            dish_ptr -= 1\n        elif dish_ptr < 0:\n            ans = min(ans, max(ans - clan[clan_ptr][2], clan[clan_ptr][1]))\n            clan_ptr -= 1\n        elif clan[clan_ptr][0] > dishes[dish_ptr][0]:\n            ans = min(ans, max(ans - clan[clan_ptr][2], clan[clan_ptr][1]))\n            clan_ptr -= 1\n        else:\n            ans += dishes[dish_ptr][1]\n            dish_ptr -= 1\n    print(ans)", "def check(noOfPeople, plus, minus):\n    pcnt = 0\n    mcnt = 0\n    while pcnt < len(plus) and mcnt < len(minus):\n        if plus[pcnt][0] < minus[mcnt][0]:\n            if noOfPeople >= plus[pcnt][1]:\n                noOfPeople += plus[pcnt][2]\n            pcnt += 1\n        elif minus[mcnt][0] < plus[pcnt][0]:\n            noOfPeople -= minus[mcnt][1]\n            mcnt += 1\n        else:\n            if noOfPeople >= plus[pcnt][1]:\n                noOfPeople += plus[pcnt][2]\n            pcnt += 1\n            noOfPeople -= minus[mcnt][1]\n            mcnt += 1\n        if noOfPeople <= 0:\n            return False\n    while mcnt < len(minus):\n        noOfPeople -= minus[mcnt][1]\n        mcnt += 1\n        if noOfPeople <= 0:\n            return False\n    return True\n\ndef solve(plus, minus, X, maxval):\n    low = 0\n    high = maxval + 1\n    while high - low > 1:\n        mid = low + (high - low) // 2\n        if check(mid, plus, minus) == True:\n            high = mid\n        else:\n            low = mid\n    return high\nfor _ in range(int(input())):\n    X = int(input())\n    temp = list(map(int, input().split()))\n    B = temp[0]\n    minus = []\n    cnt = 1\n    maxval = 1\n    for i in range(B):\n        minus.append([temp[cnt], temp[cnt + 1]])\n        maxval += temp[cnt + 1]\n        cnt += 2\n    temp = list(map(int, input().split()))\n    C = temp[0]\n    cnt = 1\n    plus = []\n    for i in range(C):\n        plus.append([temp[cnt], temp[cnt + 1], temp[cnt + 2]])\n        cnt += 3\n    if B == 0:\n        print(1)\n    elif C == 0:\n        print(maxval)\n    else:\n        print(solve(plus, minus, X, maxval))", "def binser(l, r, ans):\n    low = l\n    high = r\n    while low <= high:\n        mid = (low + high) // 2\n        if possible(mid):\n            ans = min(ans, mid)\n            high = mid - 1\n        else:\n            low = mid + 1\n    return ans\n\ndef possible(n):\n    v = n\n    for i in range(len(li)):\n        if li[i][0][1]:\n            v -= li[i][1][0]\n        elif v >= li[i][1][0]:\n            v += li[i][1][1]\n    return v > 0\nt = int(input())\nfor _ in range(t):\n    x = int(input())\n    temp = list(map(int, input().split()))\n    ans = 0\n    q = 1\n    i = 1\n    li = []\n    while i < 2 * temp[0]:\n        li.append([[temp[i], True], [temp[i + 1], 0]])\n        q = q + temp[i + 1]\n        i = i + 2\n    temp = list(map(int, input().split()))\n    i = 1\n    while i < 3 * temp[0]:\n        li.append([[temp[i], False], [temp[i + 1], temp[i + 2]]])\n        i = i + 3\n    li.sort()\n    print(binser(1, q, q))", "def possible(v):\n    for ele in combined_list:\n        if len(ele) == 2:\n            v -= ele[1]\n        elif v >= ele[1]:\n            v += ele[2]\n    return v > 0\nfor _ in range(int(input().strip())):\n    x = int(input().strip())\n    lst = list(map(int, input().strip().split()))\n    (b, lst) = (lst[0], lst[1:])\n    dish_list = [(lst[2 * i], lst[2 * i + 1]) for i in range(b)]\n    max_men = 1\n    for dish in dish_list:\n        max_men += dish[1]\n    lst = list(map(int, input().strip().split()))\n    (c, lst) = (lst[0], lst[1:])\n    j = 0\n    clan_list = []\n    for i in range(c):\n        clan_list.append((lst[j], lst[j + 1], lst[j + 2]))\n        j += 3\n    combined_list = dish_list + clan_list\n    combined_list.sort()\n    low = 1\n    high = max_men\n    ans = max_men\n    while low < high:\n        m = (low + high) // 2\n        if possible(m):\n            ans = min(ans, m)\n            high = m\n        else:\n            low = m + 1\n    print(high)", "def possible(v):\n    for ele in combined_list:\n        if len(ele) == 2:\n            v -= ele[1]\n        elif v >= ele[1]:\n            v += ele[2]\n    return v > 0\nfor _ in range(int(input().strip())):\n    x = int(input().strip())\n    lst = list(map(int, input().strip().split()))\n    (b, lst) = (lst[0], lst[1:])\n    dish_list = [(lst[2 * i], lst[2 * i + 1]) for i in range(b)]\n    max_men = 1\n    for dish in dish_list:\n        max_men += dish[1]\n    lst = list(map(int, input().strip().split()))\n    (c, lst) = (lst[0], lst[1:])\n    j = 0\n    clan_list = []\n    for i in range(c):\n        clan_list.append((lst[j], lst[j + 1], lst[j + 2]))\n        j += 3\n    combined_list = dish_list + clan_list\n    combined_list.sort()\n    low = 1\n    high = max_men\n    ans = max_men\n    while low <= high:\n        m = (low + high) // 2\n        if possible(m):\n            ans = min(ans, m)\n            high = m - 1\n        else:\n            low = m + 1\n    print(high if possible(high) else low)", "def bins(l, r, res):\n    while l <= r:\n        m = l + (r - l) // 2\n        if isposs(m):\n            res = min(res, m)\n            r = m - 1\n        else:\n            l = m + 1\n    return res\n\ndef isposs(n):\n    for i in range(len(arr)):\n        if arr[i][0][1]:\n            n -= arr[i][1][0]\n        elif n >= arr[i][1][0]:\n            n += arr[i][1][1]\n    return n > 0\nfor _ in range(int(input())):\n    d = int(input())\n    tmp = list(map(int, input().split()))\n    arr = []\n    i = qq = 1\n    while i < 2 * tmp[0]:\n        arr.append([[tmp[i], True], [tmp[i + 1], 0]])\n        qq += tmp[i + 1]\n        i += 2\n    tmp = list(map(int, input().split()))\n    i = 1\n    while i < 3 * tmp[0]:\n        arr.append([[tmp[i], False], [tmp[i + 1], tmp[i + 2]]])\n        i += 3\n    arr.sort()\n    print(bins(1, qq, qq))", "def possible(n):\n    for i in range(len(ls)):\n        if ls[i][0][1]:\n            n -= ls[i][1][0]\n        elif n >= ls[i][1][0]:\n            n += ls[i][1][1]\n    return n > 0\n\ndef solve(l, r, ans):\n    while l <= r:\n        m = l + (r - l) // 2\n        if possible(m):\n            ans = min(ans, m)\n            r = m - 1\n        else:\n            l = m + 1\n    return ans\nfor _ in range(int(input())):\n    d = int(input())\n    temp = list(map(int, input().split()))\n    ls = []\n    i = req = 1\n    while i < 2 * temp[0]:\n        ls.append([[temp[i], True], [temp[i + 1], 0]])\n        req += temp[i + 1]\n        i += 2\n    temp = list(map(int, input().split()))\n    i = 1\n    while i < 3 * temp[0]:\n        ls.append([[temp[i], False], [temp[i + 1], temp[i + 2]]])\n        i += 3\n    ls.sort()\n    print(solve(1, req, req))", "def sufficient_log(dishes, clans, k, b, c):\n    (i, j) = (0, 0)\n    while i < b and j < c:\n        if dishes[i] < clans[j]:\n            k = k - dishes[i][1]\n            if k <= 0:\n                return False\n            i += 1\n        else:\n            if clans[j][1] <= k:\n                k += clans[j][2]\n            j += 1\n    for l in range(i, b):\n        k = k - dishes[l][1]\n        if k <= 0:\n            return False\n    return True\nfor z in range(int(input())):\n    x = int(input())\n    dis = list(map(int, input().split()))\n    b = dis[0]\n    dishes = []\n    for i in range(b):\n        dishes.append((dis[2 * i + 1], dis[2 * i + 2]))\n    dishes.sort()\n    cla = list(map(int, input().split()))\n    c = cla[0]\n    clans = []\n    for i in range(c):\n        clans.append((cla[3 * i + 1], cla[3 * i + 2], cla[3 * i + 3]))\n    clans.sort()\n    mn = 1\n    mx = 1\n    for i in range(b):\n        mx += dishes[i][1]\n    while mn < mx:\n        mid = (mn + mx) // 2\n        if sufficient_log(dishes, clans, mid, b, c):\n            mx = mid\n        else:\n            mn = mid + 1\n    print(mn)", "def comp(cakes, clans, x, c, val):\n    i = 0\n    j = 0\n    while i < x:\n        while j < c and clans[j][0] < cakes[i][0]:\n            if clans[j][1] <= val:\n                val += clans[j][2]\n            j += 1\n        if val <= cakes[i][1]:\n            return -1\n        else:\n            val -= cakes[i][1]\n        i += 1\n    return val\nfor _ in range(int(input().strip())):\n    dist = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    cakes = []\n    x = a[0]\n    for i in range(1, 2 * x, 2):\n        cakes.append([a[i], a[i + 1]])\n    b = list(map(int, input().strip().split()))\n    clans = []\n    c = b[0]\n    for i in range(1, 3 * (c - 1) + 2, 3):\n        clans.append([b[i], b[i + 1], b[i + 2]])\n    cakes_sum = 0\n    for i in range(x):\n        cakes_sum += cakes[i][1]\n    if c == 0:\n        print(cakes_sum + 1)\n    else:\n        start = 1\n        end = cakes_sum + 1\n        remain = 0\n        while start < end:\n            mid = (start + end) // 2\n            remain = comp(cakes, clans, x, c, mid)\n            if remain == -1:\n                start = mid + 1\n            else:\n                end = mid\n        print(end)", "def possible(v):\n    for ele in combined_list:\n        if len(ele) == 2:\n            v -= ele[1]\n        elif v >= ele[1]:\n            v += ele[2]\n    return v > 0\nfor _ in range(int(input().strip())):\n    x = int(input().strip())\n    lst = list(map(int, input().strip().split()))\n    (b, lst) = (lst[0], lst[1:])\n    dish_list = [(lst[2 * i], lst[2 * i + 1]) for i in range(b)]\n    max_men = 1\n    for dish in dish_list:\n        max_men += dish[1]\n    lst = list(map(int, input().strip().split()))\n    (c, lst) = (lst[0], lst[1:])\n    j = 0\n    clan_list = []\n    for i in range(c):\n        clan_list.append((lst[j], lst[j + 1], lst[j + 2]))\n        j += 3\n    combined_list = dish_list + clan_list\n    combined_list.sort()\n    low = 1\n    high = max_men\n    ans = max_men\n    while low <= high:\n        m = (low + high) // 2\n        if possible(m):\n            ans = min(ans, m)\n            high = m - 1\n        else:\n            low = m + 1\n    print(high if possible(high) else low)", "def possible(z):\n    for i in dis:\n        if i in lands:\n            z -= lands[i]\n        if i in towns:\n            if z >= towns[i][0]:\n                z += towns[i][1]\n    return z > 0\nT = int(input())\nwhile T > 0:\n    x = int(input())\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    nb = b[0]\n    nc = c[0]\n    lands = {}\n    towns = {}\n    p = []\n    q = []\n    dis = []\n    for i in range(1, len(b), 2):\n        lands[b[i]] = b[i + 1]\n        p.append(b[i])\n    for i in range(1, len(c), 3):\n        towns[c[i]] = (c[i + 1], c[i + 2])\n        q.append(c[i])\n    i = 0\n    j = 0\n    while i < nb and j < nc:\n        if p[i] < q[j]:\n            dis.append(p[i])\n            i += 1\n        else:\n            dis.append(q[j])\n            j += 1\n    if i < nb:\n        dis.extend(p[i:])\n    if j < nc:\n        dis.extend(q[j:])\n    m = 1\n    for y in range(2, len(b), 2):\n        m += b[y]\n    lo = 1\n    hi = m\n    res = m\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if possible(mid):\n            res = min(mid, res)\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    print(res)\n    T -= 1", "def check(road, pp):\n    for i in road:\n        if i == []:\n            return False\n        if len(i) == 2:\n            pp -= i[1]\n        elif i[1] <= pp:\n            pp += i[2]\n    if pp >= 1:\n        return True\n    else:\n        return False\nfor _ in range(int(input())):\n    x = int(input())\n    dish = list(map(int, input().strip().split()))\n    clan = list(map(int, input().strip().split()))\n    ans = 0\n    ppl = 0\n    for i in range(2, len(dish), 2):\n        ppl += dish[i]\n    if clan[0] == 0:\n        print(ppl + 1)\n    else:\n        road = []\n        for i in range(1, len(dish), 2):\n            road.append([dish[i], dish[i + 1]])\n        for i in range(1, len(clan), 3):\n            road.append([clan[i], clan[i + 1], clan[i + 2]])\n        road.sort(key=lambda x: x[0])\n        (l, h) = (1, ppl + 1)\n        while l < h:\n            m = (l + h) // 2\n            if check(road, m):\n                h = m\n            else:\n                l = m + 1\n            ans = l\n        print(ans)", "def check(chef, road):\n    for v in road:\n        if chef == 0:\n            return False\n        if len(v) == 2:\n            chef -= v[1]\n        elif v[1] <= chef:\n            chef += v[2]\n    if chef >= 1:\n        return True\n    else:\n        return False\nt = int(input())\nfor z in range(t):\n    answer = 0\n    X = int(input())\n    dishes = list(map(int, input().split()))\n    clans = list(map(int, input().split()))\n    max_chef = 0\n    for i in range(2, len(dishes), 2):\n        max_chef += dishes[i]\n    if clans[0] == 0:\n        answer = max_chef + 1\n    else:\n        road = []\n        for i in range(1, dishes[0] * 2 + 1, 2):\n            road.append([dishes[i], dishes[i + 1]])\n        for i in range(1, clans[0] * 3 + 1, 3):\n            road.append([clans[i], clans[i + 1], clans[i + 2]])\n        road.sort(key=lambda x: x[0])\n        low = 1\n        high = max_chef + 1\n        while low < high:\n            mid = low + (high - low) // 2\n            if check(mid, road):\n                high = mid\n            else:\n                low = mid + 1\n        answer = low\n    print(answer)", "number_of_test_cases = int(input())\nfinal_results = []\n\ndef f(initial, v):\n    for item in v:\n        if len(item) == 2:\n            initial -= item[1]\n        elif initial >= item[1]:\n            initial += item[2]\n    return initial > 0\nfor each_test_case in range(number_of_test_cases):\n    X = int(input())\n    (B, *xy) = map(int, input().split())\n    final_xy = []\n    best_case = 1\n    for i in range(0, 2 * B, 2):\n        final_xy.append([xy[i], xy[i + 1]])\n        best_case += xy[i + 1]\n    (C, *pqr) = map(int, input().split())\n    final_pqr = []\n    for i in range(0, 3 * C, 3):\n        final_pqr.append([pqr[i], pqr[i + 1], pqr[i + 2]])\n    final_vector = sorted(final_xy + final_pqr, key=lambda ele: (ele[0], -len(ele)))\n    low = 1\n    high = best_case\n    possible_answer = best_case\n    while low <= high:\n        mid = (low + high) // 2\n        if f(mid, final_vector):\n            possible_answer = min(possible_answer, mid)\n            high = mid - 1\n        else:\n            low = mid + 1\n    final_results.append(possible_answer)\nfor i in final_results:\n    print(i)", "for _ in range(int(input())):\n    _ = int(input())\n    _in = iter(map(int, input().split()))\n    _ = next(_in)\n    a = [(x, 0, -y) for (x, y) in zip(_in, _in)]\n    _in = iter(map(int, input().split()))\n    _ = next(_in)\n    a.extend(zip(_in, _in, _in))\n    a.sort()\n\n    def check(x):\n        for (_, k, v) in a:\n            if x >= k:\n                x += v\n            if x <= 0:\n                return False\n        return True\n    n = len(a)\n    (lb, ub) = (0, 1 << 63)\n    while ub - lb > 1:\n        mid = (ub + lb) // 2\n        if check(mid):\n            ub = mid\n        else:\n            lb = mid\n    print(ub)"]