["def find(arr, n, ele):\n    l = 0\n    r = n - 1\n    mid = (l + r) // 2\n    while l != r:\n        cur_ele = arr[mid]\n        if cur_ele == ele:\n            break\n        elif cur_ele > ele:\n            r = mid - 1\n            mid = (l + r) // 2\n        else:\n            l = mid + 1\n            mid = (l + r) // 2\n    return mid\n\ndef pr_sum(bit, n, index):\n    ans = 0\n    while index:\n        ans += bit[index]\n        index -= index & -index\n    return ans\n\ndef update(bit, n, index):\n    while index <= n:\n        bit[index] += 1\n        index += index & -index\n    return bit\nn = int(input())\nlst = [0] * n\nfor i in range(n):\n    a = list(map(int, input().split()))\n    lst[i] = a\nlst.sort(key=lambda x: x[0])\nf = [0] * n\ni = 0\nfor pair in lst:\n    f[i] = pair[1]\n    i += 1\narray = f\nn = len(array)\nsr_arr = sorted(array)\nin_arr = [0] * n\ni = 0\nfor ele in array:\n    index = find(sr_arr, n, ele)\n    in_arr[i] = index + 1\n    i += 1\nbit = [0] * (n + 1)\ninv_cnt = 0\nfor ele in reversed(in_arr):\n    inv_cnt += pr_sum(bit, n, ele)\n    bit = update(bit, n, ele)\nprint(inv_cnt)", "def find(arr, n, ele):\n    l = 0\n    r = n - 1\n    mid = (l + r) // 2\n    while l != r:\n        cur_ele = arr[mid]\n        if cur_ele == ele:\n            break\n        elif cur_ele > ele:\n            r = mid - 1\n            mid = (l + r) // 2\n        else:\n            l = mid + 1\n            mid = (l + r) // 2\n    return mid\n\ndef pr_sum(bit, n, index):\n    ans = 0\n    while index:\n        ans += bit[index]\n        index -= index & -index\n    return ans\n\ndef update(bit, n, index):\n    while index <= n:\n        bit[index] += 1\n        index += index & -index\n    return bit\nn = int(input())\nlst = [0] * n\nfor i in range(n):\n    a = list(map(int, input().split()))\n    lst[i] = a\nlst.sort(key=lambda x: x[0])\nf = [0] * n\ni = 0\nfor pair in lst:\n    f[i] = pair[1]\n    i += 1\narray = f\nn = len(array)\nsr_arr = sorted(array)\nin_arr = [0] * n\ni = 0\nfor ele in array:\n    index = find(sr_arr, n, ele)\n    in_arr[i] = index + 1\n    i += 1\nbit = [0] * (n + 1)\ninv_cnt = 0\nfor ele in reversed(in_arr):\n    inv_cnt += pr_sum(bit, n, ele)\n    bit = update(bit, n, ele)\nprint(inv_cnt)", "def find(arr, n, ele):\n    l = 0\n    r = n - 1\n    mid = (l + r) // 2\n    while l != r:\n        cur_ele = arr[mid]\n        if cur_ele == ele:\n            break\n        elif cur_ele > ele:\n            r = mid - 1\n            mid = (l + r) // 2\n        else:\n            l = mid + 1\n            mid = (l + r) // 2\n    return mid\n\ndef pr_sum(bit, n, index):\n    ans = 0\n    while index:\n        ans += bit[index]\n        index -= index & -index\n    return ans\n\ndef update(bit, n, index):\n    while index <= n:\n        bit[index] += 1\n        index += index & -index\n    return bit\nn = int(input())\nlst = [0] * n\nfor i in range(n):\n    a = list(map(int, input().split()))\n    lst[i] = a\nlst.sort(key=lambda x: x[0])\nf = [0] * n\ni = 0\nfor pair in lst:\n    f[i] = pair[1]\n    i += 1\narray = f\nn = len(array)\nsr_arr = sorted(array)\nin_arr = [0] * n\ni = 0\nfor ele in array:\n    index = find(sr_arr, n, ele)\n    in_arr[i] = index + 1\n    i += 1\nbit = [0] * (n + 1)\ninv_cnt = 0\nfor ele in reversed(in_arr):\n    inv_cnt += pr_sum(bit, n, ele)\n    bit = update(bit, n, ele)\nprint(inv_cnt)", "def mergeSort(arr, left, right):\n    if right > left:\n        mid = (left + right) // 2\n        a = mergeSort(arr, left, mid)\n        b = mergeSort(arr, mid + 1, right)\n        c = merge(arr, left, mid, right)\n        return a + b + c\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    newarr = [0] * (right - left + 1)\n    i = left\n    j = mid + 1\n    k = 0\n    inversions = 0\n    while i <= mid and j <= right:\n        if arr[i] < arr[j]:\n            newarr[k] = arr[i]\n            i += 1\n        else:\n            inversions += mid - i + 1\n            newarr[k] = arr[j]\n            j += 1\n        k += 1\n    while i <= mid:\n        newarr[k] = arr[i]\n        k += 1\n        i += 1\n    while j <= right:\n        newarr[k] = arr[j]\n        k += 1\n        j += 1\n    for i in range(len(newarr)):\n        arr[left + i] = newarr[i]\n    return inversions\nn = int(input())\narr = []\nfor _ in range(n):\n    (a, b) = [int(c) for c in input().split()]\n    arr.append((a, b))\narr.sort(key=lambda x: x[0])\nar = [j for (i, j) in arr]\nprint(mergeSort(ar, 0, len(ar) - 1))", "def find(arr, n, ele):\n    l = 0\n    r = n - 1\n    mid = (l + r) // 2\n    while l != r:\n        cur_ele = arr[mid]\n        if cur_ele == ele:\n            break\n        elif cur_ele > ele:\n            r = mid - 1\n            mid = (l + r) // 2\n        else:\n            l = mid + 1\n            mid = (l + r) // 2\n    return mid\n\ndef pr_sum(bit, n, index):\n    ans = 0\n    while index:\n        ans += bit[index]\n        index -= index & -index\n    return ans\n\ndef update(bit, n, index):\n    while index <= n:\n        bit[index] += 1\n        index += index & -index\n    return bit\nn = int(input())\nlst = [0] * n\nfor i in range(n):\n    a = list(map(int, input().split()))\n    lst[i] = a\nlst.sort(key=lambda x: x[0])\nf = [0] * n\ni = 0\nfor pair in lst:\n    f[i] = pair[1]\n    i += 1\narray = f\nn = len(array)\nsr_arr = sorted(array)\nin_arr = [0] * n\ni = 0\nfor ele in array:\n    index = find(sr_arr, n, ele)\n    in_arr[i] = index + 1\n    i += 1\nbit = [0] * (n + 1)\ninv_cnt = 0\nfor ele in reversed(in_arr):\n    inv_cnt += pr_sum(bit, n, ele)\n    bit = update(bit, n, ele)\nprint(inv_cnt)", "from bisect import bisect_left\n\ndef solve(arr):\n    arr = sorted(arr, key=lambda x: x[0])\n    nums = []\n    ans = 0\n    for (x, y) in arr:\n        idx = bisect_left(nums, y)\n        if idx == len(nums):\n            nums.append(y)\n        else:\n            ans += len(nums) - idx\n            nums.insert(idx, y)\n    return ans\narr = []\nfor i in range(int(input())):\n    (x, y) = map(int, input().split())\n    arr.append((x, y))\nprint(solve(arr))", "from bisect import bisect_left\n\ndef solve(arr):\n    arr = sorted(arr, key=lambda x: x[0])\n    nums = []\n    ans = 0\n    for (x, y) in arr:\n        idx = bisect_left(nums, y)\n        if idx == len(nums):\n            nums.append(y)\n        else:\n            ans += len(nums) - idx\n            nums.insert(idx, y)\n    return ans\narr = []\nfor i in range(int(input())):\n    (x, y) = [int(x) for x in input().split()]\n    arr.append((x, y))\nprint(solve(arr))", "from bisect import bisect_left\n\ndef solve(arr):\n    arr = sorted(arr, key=lambda x: x[0])\n    nums = []\n    ans = 0\n    for (x, y) in arr:\n        idx = bisect_left(nums, y)\n        if idx == len(nums):\n            nums.append(y)\n        else:\n            ans += len(nums) - idx\n            nums.insert(idx, y)\n    return ans\narr = []\nfor i in range(int(input())):\n    (x, y) = [int(x) for x in input().split()]\n    arr.append((x, y))\nprint(solve(arr))", "from bisect import bisect_left\n\ndef solve(arr):\n    arr = sorted(arr, key=lambda x: x[0])\n    nums = []\n    ans = 0\n    for (x, y) in arr:\n        idx = bisect_left(nums, y)\n        if idx == len(nums):\n            nums.append(y)\n        else:\n            ans += len(nums) - idx\n            nums.insert(idx, y)\n    return ans\narr = []\nfor i in range(int(input())):\n    (x, y) = [int(x) for x in input().split()]\n    arr.append((x, y))\nprint(solve(arr))", "def find(arr, n, ele):\n    l = 0\n    r = n - 1\n    mid = (l + r) // 2\n    while l != r:\n        cur_ele = arr[mid]\n        if cur_ele == ele:\n            break\n        elif cur_ele > ele:\n            r = mid - 1\n            mid = (l + r) // 2\n        else:\n            l = mid + 1\n            mid = (l + r) // 2\n    return mid\n\ndef pr_sum(bit, n, index):\n    ans = 0\n    while index:\n        ans += bit[index]\n        index -= index & -index\n    return ans\n\ndef update(bit, n, index):\n    while index <= n:\n        bit[index] += 1\n        index += index & -index\n    return bit\nn = int(input())\nlst = [0] * n\nfor i in range(n):\n    a = list(map(int, input().split()))\n    lst[i] = a\nlst.sort(key=lambda x: x[0])\nf = [0] * n\ni = 0\nfor pair in lst:\n    f[i] = pair[1]\n    i += 1\narray = f\nn = len(array)\nsr_arr = sorted(array)\nin_arr = [0] * n\ni = 0\nfor ele in array:\n    index = find(sr_arr, n, ele)\n    in_arr[i] = index + 1\n    i += 1\nbit = [0] * (n + 1)\ninv_cnt = 0\nfor ele in reversed(in_arr):\n    inv_cnt += pr_sum(bit, n, ele)\n    bit = update(bit, n, ele)\nprint(inv_cnt)", "def construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef getsum2(BITTree, l, r):\n    return getsum(BITTree, r) - getsum(BITTree, l - 1)\nn = int(input())\nfemales = []\nmales = []\nall_ = []\nfor _ in range(n):\n    (a, b) = map(int, input().split())\n    females.append(b)\n    males.append(a)\n    all_.append((a, b))\nmales.sort()\nfemales.sort()\nm = {}\nf = {}\nfor i in range(n):\n    m[males[i]] = i + 1\n    f[females[i]] = i + 1\nline = {}\nfor i in range(n):\n    x = m[all_[i][0]]\n    y = f[all_[i][1]]\n    line[x] = y\nans = 0\nbit = [0] * (100000 + 2)\nbit = construct(bit, 100000 + 2)\nfor i in range(n, 0, -1):\n    x = line[i]\n    ans += getsum(bit, x)\n    updatebit(bit, 100000 + 2, x, 1)\nprint(ans)"]