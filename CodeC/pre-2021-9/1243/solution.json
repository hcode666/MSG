["from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\ntry:\n    test_num = int(input())\n\n    def get_input():\n        return list(map(int, input().split()))\n    for _ in range(test_num):\n        (n, m) = get_input()\n        edges = [get_input() for _ in range(m)]\n        g = UndirectedGraph(n)\n        for (i, j) in edges:\n            g.add_edge(i, j)\n        (cycle, fail_node) = (g.find_cycle([]), -1)\n        if cycle and (not g.find_cycle(cycle)):\n            cycle.sort()\n            for i in cycle:\n                if not g.find_cycle([i]):\n                    fail_node = i\n                    break\n        print(fail_node)\nexcept EOFError:\n    pass", "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\ntry:\n    test_num = int(input())\n\n    def get_input():\n        return list(map(int, input().split()))\n    for _ in range(test_num):\n        (n, m) = get_input()\n        edges = [get_input() for _ in range(m)]\n        g = UndirectedGraph(n)\n        for (i, j) in edges:\n            g.add_edge(i, j)\n        (cycle, fail_node) = (g.find_cycle([]), -1)\n        if cycle and (not g.find_cycle(cycle)):\n            cycle.sort()\n            for i in cycle:\n                if not g.find_cycle([i]):\n                    fail_node = i\n                    break\n        print(fail_node)\nexcept EOFError:\n    pass", "5\nfrom collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\ntry:\n    test_num = int(input())\n\n    def get_input():\n        return list(map(int, input().split()))\n    for _ in range(test_num):\n        (n, m) = get_input()\n        edges = [get_input() for _ in range(m)]\n        g = UndirectedGraph(n)\n        for (i, j) in edges:\n            g.add_edge(i, j)\n        (cycle, fail_node) = (g.find_cycle([]), -1)\n        if cycle and (not g.find_cycle(cycle)):\n            cycle.sort()\n            for i in cycle:\n                if not g.find_cycle([i]):\n                    fail_node = i\n                    break\n        print(fail_node)\nexcept EOFError:\n    pass", "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\ntry:\n    test_num = int(input())\n\n    def get_input():\n        return list(map(int, input().split()))\n    for _ in range(test_num):\n        (n, m) = get_input()\n        edges = [get_input() for _ in range(m)]\n        g = UndirectedGraph(n)\n        for (i, j) in edges:\n            g.add_edge(i, j)\n        (cycle, fail_node) = (g.find_cycle([]), -1)\n        if cycle and (not g.find_cycle(cycle)):\n            cycle.sort()\n            for i in cycle:\n                if not g.find_cycle([i]):\n                    fail_node = i\n                    break\n        print(fail_node)\nexcept EOFError:\n    pass", "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = defaultdict(bool)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\ntry:\n    test_num = int(input())\n\n    def get_input():\n        return list(map(int, input().split()))\n    for _ in range(test_num):\n        (n, m) = get_input()\n        edges = [get_input() for _ in range(m)]\n        g = UndirectedGraph(n)\n        for (i, j) in edges:\n            g.add_edge(i, j)\n        (cycle, fail_node) = (g.find_cycle([]), -1)\n        if cycle and (not g.find_cycle(cycle)):\n            cycle.sort()\n            for i in cycle:\n                if not g.find_cycle([i]):\n                    fail_node = i\n                    break\n        print(fail_node)\nexcept EOFError:\n    pass", "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = defaultdict(bool)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\ntry:\n    test_num = int(input())\n\n    def get_input():\n        return list(map(int, input().split()))\n    for _ in range(test_num):\n        (n, m) = get_input()\n        edges = [get_input() for _ in range(m)]\n        g = UndirectedGraph(n)\n        for (i, j) in edges:\n            g.add_edge(i, j)\n        (cycle, fail_node) = (g.find_cycle([]), -1)\n        if cycle and (not g.find_cycle(cycle)):\n            cycle.sort()\n            for i in cycle:\n                if not g.find_cycle([i]):\n                    fail_node = i\n                    break\n        print(fail_node)\nexcept EOFError:\n    pass", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = defaultdict(bool)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\ntry:\n    test_num = int(input())\n    get_input = lambda : list(map(int, input().split()))\n    for _ in range(test_num):\n        (n, m) = get_input()\n        edges = [get_input() for _ in range(m)]\n        g = UndirectedGraph(n)\n        for (i, j) in edges:\n            g.add_edge(i, j)\n        (cycle, fail_node) = (g.find_cycle([]), -1)\n        if cycle and (not g.find_cycle(cycle)):\n            cycle.sort()\n            for i in cycle:\n                if not g.find_cycle([i]):\n                    fail_node = i\n                    break\n        print(fail_node)\nexcept EOFError:\n    pass", "from collections import defaultdict\nII = lambda : [int(x) for x in input().split()]\n\ndef find_cycle(graph, start, visited, d_nodes):\n    d_nodes = set(d_nodes)\n    stack = [start]\n    parent = defaultdict(int)\n    while stack:\n        state = stack.pop()\n        for next_state in graph[state]:\n            if next_state == parent[state]:\n                continue\n            if visited[next_state]:\n                path = [state]\n                while next_state != state:\n                    state = parent[state]\n                    path.append(state)\n                return path\n            if next_state not in d_nodes:\n                parent[next_state] = state\n                stack.append(next_state)\n        visited[state] = True\n    return None\n\ndef find_a_cycle(G, d_nodes):\n    visited = defaultdict(bool)\n    d_nodes = set(d_nodes)\n    for node in G:\n        if node not in visited and node not in d_nodes:\n            cycle = find_cycle(G, node, visited, d_nodes)\n            if cycle is not None:\n                return cycle\n    return []\nT = int(input())\nfor _ in range(T):\n    (N, E) = II()\n    G = defaultdict(list)\n    for _ in range(E):\n        (a, b) = II()\n        G[a].append(b)\n        G[b].append(a)\n    cycle = find_a_cycle(G, [])\n    if not cycle:\n        print(-1)\n        continue\n    if find_a_cycle(G, cycle):\n        print(-1)\n        continue\n    f_node = -1\n    cycle.sort()\n    for node in cycle:\n        new_cycle = find_a_cycle(G, [node])\n        if not new_cycle:\n            f_node = node\n            break\n    print(f_node)", "from collections import defaultdict\nII = lambda : [int(x) for x in input().split()]\n\ndef find_cycle(graph, start, visited, d_nodes):\n    d_nodes = set(d_nodes)\n    stack = [start]\n    parent = defaultdict(int)\n    while stack:\n        state = stack.pop()\n        for next_state in graph[state]:\n            if next_state == parent[state]:\n                continue\n            if visited[next_state]:\n                path = [state]\n                while next_state != state:\n                    state = parent[state]\n                    path.append(state)\n                return path\n            if next_state not in d_nodes:\n                parent[next_state] = state\n                stack.append(next_state)\n        visited[state] = True\n    return None\n\ndef find_a_cycle(G, d_nodes):\n    visited = defaultdict(bool)\n    d_nodes = set(d_nodes)\n    for node in G:\n        if node not in visited and node not in d_nodes:\n            cycle = find_cycle(G, node, visited, d_nodes)\n            if cycle is not None:\n                return cycle\n    return []\nT = int(input())\nfor _ in range(T):\n    (N, E) = II()\n    G = defaultdict(list)\n    for _ in range(E):\n        (a, b) = II()\n        G[a].append(b)\n        G[b].append(a)\n    cycle = find_a_cycle(G, [])\n    if not cycle:\n        print(-1)\n        continue\n    if find_a_cycle(G, cycle):\n        print(-1)\n        continue\n    f_node = -1\n    cycle.sort()\n    for node in cycle:\n        new_cycle = find_a_cycle(G, [node])\n        if not new_cycle:\n            f_node = node\n            break\n    print(f_node)", "from collections import defaultdict\nII = lambda : [int(x) for x in input().split()]\n\ndef find_cycle(graph, start, visited, d_nodes):\n    d_nodes = set(d_nodes)\n    stack = [start]\n    parent = defaultdict(int)\n    while stack:\n        state = stack.pop()\n        for next_state in graph[state]:\n            if next_state == parent[state]:\n                continue\n            if visited[next_state]:\n                path = [state]\n                while next_state != state:\n                    state = parent[state]\n                    path.append(state)\n                return path\n            if next_state not in d_nodes:\n                parent[next_state] = state\n                stack.append(next_state)\n        visited[state] = True\n    return None\n\ndef find_a_cycle(G, d_nodes):\n    visited = defaultdict(bool)\n    d_nodes = set(d_nodes)\n    for node in G:\n        if node not in visited and node not in d_nodes:\n            cycle = find_cycle(G, node, visited, d_nodes)\n            if cycle is not None:\n                return cycle\n    return []\nT = int(input())\nfor _ in range(T):\n    (N, E) = II()\n    G = defaultdict(list)\n    for _ in range(E):\n        (a, b) = II()\n        G[a].append(b)\n        G[b].append(a)\n    cycle = find_a_cycle(G, [])\n    if not cycle:\n        print(-1)\n        continue\n    if find_a_cycle(G, cycle):\n        print(-1)\n        continue\n    f_node = -1\n    cycle.sort()\n    for node in cycle:\n        new_cycle = find_a_cycle(G, [node])\n        if not new_cycle:\n            f_node = node\n            break\n        cycle = set(cycle) & set(new_cycle)\n    print(f_node)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(set)\n        self._junctionDict = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n        lu = len(self.graph[u])\n        lv = len(self.graph[v])\n        self._junctionDict[lu].add(u)\n        self._junctionDict[lv].add(v)\n        if lu > 1:\n            self.discardFromJunction(lu - 1, u)\n        if lv > 1:\n            self.discardFromJunction(lv - 1, v)\n\n    def discardFromJunction(self, k, v):\n        self._junctionDict[k].discard(v)\n        if len(self._junctionDict[k]) == 0:\n            del self._junctionDict[k]\n\n    def removeVertice(self, v):\n        for vv in self.graph[v]:\n            self.graph[vv].discard(v)\n            lv = len(self.graph[vv])\n            self.discardFromJunction(lv + 1, vv)\n            if lv > 0:\n                self._junctionDict[lv].add(vv)\n            else:\n                del self.graph[vv]\n        ln = len(self.graph[v])\n        del self.graph[v]\n        self.discardFromJunction(ln, v)\n\n    def removeAloneVertice(self, u):\n        if len(self.graph[u]) == 1:\n            v = self.graph[u].pop()\n            self.graph[v].discard(u)\n            del self.graph[u]\n            self.discardFromJunction(1, u)\n            lv = len(self.graph[v])\n            self.discardFromJunction(lv + 1, v)\n            if lv > 0:\n                self._junctionDict[lv].add(v)\n            else:\n                del self.graph[v]\n        elif len(self.graph[u]) == 0:\n            del self.graph[u]\n\n    def clean(self):\n        while self._junctionDict[1]:\n            self.removeAloneVertice(self._junctionDict[1].pop())\n        del self._junctionDict[1]\n\n    def check(self):\n        fp = -1\n        self.clean()\n        if self._junctionDict.keys():\n            mlen = max(self._junctionDict.keys())\n            if mlen > 1:\n                c_fp = min(self._junctionDict[mlen])\n                self.removeVertice(c_fp)\n                self.clean()\n            if len(self.graph.keys()) == 0:\n                fp = c_fp\n        print(fp)\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    graph = Graph()\n    for _ in range(M):\n        (u, v) = map(int, input().split())\n        graph.addEdge(u, v)\n    graph.check()", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(set)\n        self._junctionDict = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n        lu = len(self.graph[u])\n        lv = len(self.graph[v])\n        self._junctionDict[lu].add(u)\n        self._junctionDict[lv].add(v)\n        if lu > 1:\n            self.discardFromJunction(lu - 1, u)\n        if lv > 1:\n            self.discardFromJunction(lv - 1, v)\n\n    def discardFromJunction(self, k, v):\n        self._junctionDict[k].discard(v)\n        if len(self._junctionDict[k]) == 0:\n            del self._junctionDict[k]\n\n    def removeVertice(self, v):\n        for vv in self.graph[v]:\n            self.graph[vv].discard(v)\n            lv = len(self.graph[vv])\n            self.discardFromJunction(lv + 1, vv)\n            if lv > 0:\n                self._junctionDict[lv].add(vv)\n            else:\n                del self.graph[vv]\n        ln = len(self.graph[v])\n        del self.graph[v]\n        self.discardFromJunction(ln, v)\n\n    def removeAloneVertice(self, u):\n        if len(self.graph[u]) == 1:\n            v = self.graph[u].pop()\n            self.graph[v].discard(u)\n            del self.graph[u]\n            self.discardFromJunction(1, u)\n            lv = len(self.graph[v])\n            self.discardFromJunction(lv + 1, v)\n            if lv > 0:\n                self._junctionDict[lv].add(v)\n            else:\n                del self.graph[v]\n        elif len(self.graph[u]) == 0:\n            del self.graph[u]\n\n    def clean(self):\n        while self._junctionDict[1]:\n            self.removeAloneVertice(self._junctionDict[1].pop())\n        del self._junctionDict[1]\n\n    def check(self):\n        fp = -1\n        self.clean()\n        if self._junctionDict.keys():\n            mlen = max(self._junctionDict.keys())\n            if mlen > 1:\n                c_fp = min(self._junctionDict[mlen])\n                self.removeVertice(c_fp)\n                self.clean()\n            if len(self.graph.keys()) == 0:\n                fp = c_fp\n        print(fp)\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    graph = Graph()\n    for _ in range(M):\n        (u, v) = map(int, input().split())\n        graph.addEdge(u, v)\n    graph.check()", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\n\nclass Graph:\n\n    def __init__(self, N):\n        self.Explored = [False] * N\n        self.N = N\n        self.graph = defaultdict(set)\n        self.failurePoints = None\n        self.path = []\n        self.explored = [-1] * N\n        self.Halt = False\n        self.minFailurePoint = -1\n        self._junctionDict = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n        lu = len(self.graph[u])\n        lv = len(self.graph[v])\n        self._junctionDict[lu].add(u)\n        self._junctionDict[lv].add(v)\n        if lu > 1:\n            self.discardFromJunction(lu - 1, u)\n        if lv > 1:\n            self.discardFromJunction(lv - 1, v)\n\n    def discardFromJunction(self, k, v):\n        self._junctionDict[k].discard(v)\n        if len(self._junctionDict[k]) == 0:\n            del self._junctionDict[k]\n\n    def removeVertice(self, v):\n        for vv in self.graph[v]:\n            self.graph[vv].discard(v)\n            lv = len(self.graph[vv])\n            self.discardFromJunction(lv + 1, vv)\n            if lv > 0:\n                self._junctionDict[lv].add(vv)\n            else:\n                del self.graph[vv]\n        ln = len(self.graph[v])\n        del self.graph[v]\n        self.discardFromJunction(ln, v)\n\n    def removeAloneVertice(self, u):\n        if len(self.graph[u]) == 1:\n            v = self.graph[u].pop()\n            self.graph[v].discard(u)\n            del self.graph[u]\n            self.discardFromJunction(1, u)\n            lv = len(self.graph[v])\n            self.discardFromJunction(lv + 1, v)\n            if lv > 0:\n                self._junctionDict[lv].add(v)\n            else:\n                del self.graph[v]\n        elif len(self.graph[u]) == 0:\n            del self.graph[u]\n\n    def clean(self):\n        while self._junctionDict[1]:\n            self.removeAloneVertice(self._junctionDict[1].pop())\n        del self._junctionDict[1]\n\n    def check(self):\n        fp = -1\n        self.clean()\n        if self._junctionDict.keys():\n            mlen = max(self._junctionDict.keys())\n            if mlen > 1:\n                c_fp = min(self._junctionDict[mlen])\n                self.removeVertice(c_fp)\n                self.clean()\n            if len(self.graph.keys()) == 0:\n                fp = c_fp\n        print(fp)\n\n    def _intersection(self, s1, s2):\n        intersection = set([])\n        for v in s1:\n            if v in s2:\n                if len(intersection) == 0:\n                    self.minFailurePoint = v\n                elif self.minFailurePoint > v:\n                    self.minFailurePoint = v\n                intersection.add(v)\n        return intersection\n\n    def addCyclePath(self, nv):\n        path = self.path[self.explored[nv - 1]:]\n        if self.failurePoints is None:\n            self.failurePoints = set([])\n            self.minFailurePoint = path[0]\n            for v in path:\n                self.failurePoints.add(v)\n                if self.minFailurePoint > v:\n                    self.minFailurePoint = v\n        else:\n            if len(self.failurePoints) <= len(path):\n                _path = set(path)\n                self.failurePoints = self._intersection(self.failurePoints, _path)\n            else:\n                self.failurePoints = self._intersection(path, self.failurePoints)\n            if len(self.failurePoints) == 0:\n                self.Halt = True\n                raise Exception('Not possible')\n\n    def getCycle(self, v, parent):\n        index = len(self.path)\n        self.explored[v - 1] = index\n        self.Explored[v - 1] = True\n        if self.graph[v]:\n            self.path.append(v)\n        else:\n            return\n        for nv in self.graph[v]:\n            if self.Halt:\n                return\n            if nv != parent:\n                if self.explored[nv - 1] > -1:\n                    self.addCyclePath(nv)\n                    continue\n                else:\n                    self.getCycle(nv, v)\n        self.explored[v - 1] = -1\n        self.path = self.path[:-1]\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    graph = Graph(N)\n    for _ in range(M):\n        (u, v) = map(int, input().split())\n        graph.addEdge(u, v)\n    graph.check()"]