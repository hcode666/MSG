["def pow1(a, b, mod):\n    a %= mod\n    if b == 0:\n        return 1\n    res = pow1(a, b // 2, mod)\n    res *= res\n    res %= mod\n    if b % 2:\n        res *= a\n    return res % mod\nfor _ in range(int(input())):\n    n = int(input())\n    mod1 = int(1000000000.0 + 7)\n    mod2 = int(1000000000.0 + 9)\n    if n == 1:\n        print('0 0')\n        continue\n    if n <= 3:\n        print('1 1')\n        continue\n    p1 = n * (n - 1) % mod1\n    p2 = n * (n - 1) % mod2\n    q1 = 2 * (n + n - 3) % mod1\n    q2 = 2 * (n + n - 3) % mod2\n    inv1 = pow1(q1, mod1 - 2, mod1)\n    inv2 = pow1(q2, mod2 - 2, mod2)\n    ans1 = p1 * inv1 % mod1\n    ans2 = p2 * inv2 % mod2\n    print(str(ans1) + ' ' + str(ans2))", "def pow1(a, b, mod):\n    a %= mod\n    if b == 0:\n        return 1\n    res = pow1(a, b // 2, mod)\n    res *= res\n    res %= mod\n    if b % 2:\n        res *= a\n    return res % mod\nfor _ in range(int(input())):\n    n = int(input())\n    mod1 = int(1000000000.0 + 7)\n    mod2 = int(1000000000.0 + 9)\n    if n == 1:\n        print('0 0')\n        continue\n    if n <= 3:\n        print('1 1')\n        continue\n    p1 = n * (n - 1) % mod1\n    p2 = n * (n - 1) % mod2\n    q1 = 2 * (n + n - 3) % mod1\n    q2 = 2 * (n + n - 3) % mod2\n    inv1 = pow1(q1, mod1 - 2, mod1)\n    inv2 = pow1(q2, mod2 - 2, mod2)\n    ans1 = p1 * inv1 % mod1\n    ans2 = p2 * inv2 % mod2\n    print(str(ans1) + ' ' + str(ans2))", "def pow1(a, b, mod):\n    a %= mod\n    if b == 0:\n        return 1\n    res = pow1(a, b // 2, mod)\n    res *= res\n    res %= mod\n    if b % 2:\n        res *= a\n    return res % mod\nfor _ in range(int(input())):\n    n = int(input())\n    mod1 = int(1000000000.0 + 7)\n    mod2 = int(1000000000.0 + 9)\n    if n == 1:\n        print('0 0')\n        continue\n    if n <= 3:\n        print('1 1')\n        continue\n    p1 = n * (n - 1) % mod1\n    p2 = n * (n - 1) % mod2\n    q1 = 2 * (n + n - 3) % mod1\n    q2 = 2 * (n + n - 3) % mod2\n    inv1 = pow1(q1, mod1 - 2, mod1)\n    inv2 = pow1(q2, mod2 - 2, mod2)\n    ans1 = p1 * inv1 % mod1\n    ans2 = p2 * inv2 % mod2\n    print(str(ans1) + ' ' + str(ans2))", "def modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nm1 = int(1000000000.0 + 7)\nm2 = int(1000000000.0 + 9)\nfor _ in range(int(input())):\n    n = int(input())\n    p = n * (n - 1) // 2\n    q = 2 * n - 3\n    mi = modInverse(q, m1)\n    mi2 = modInverse(q, m2)\n    print(p * mi % m1, p * mi2 % m2)", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nm1 = int(1000000000.0 + 7)\nm2 = int(1000000000.0 + 9)\nfor _ in range(int(input())):\n    n = int(input())\n    p = n * (n - 1) // 2\n    q = 2 * n - 3\n    mi = modInverse(q, m1)\n    mi2 = modInverse(q, m2)\n    print(p * mi % m1, p * mi2 % m2)", "from fractions import _gcd\nfrom math import floor, gcd\nm1 = 1000000007\nm2 = 1000000009\n\ndef gcdExtended(a, b):\n    if a == 0:\n        return [b, 0, 1]\n    l = gcdExtended(b % a, a)\n    gcd = [l[0], l[2] - b // a * l[1], l[1]]\n    return gcd\n\ndef modInverse(a, m):\n    g = gcdExtended(a, m)\n    return (g[1] % m + m) % m\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    x = gcd(n * (n - 1), 4 * n - 6)\n    p = n * (n - 1) // x\n    q = (4 * n - 6) // x\n    ans1 = p % m1 * modInverse(q, m1) % m1\n    ans2 = p % m2 * modInverse(q, m2) % m2\n    print(ans1, ans2)\n    t -= 1", "from fractions import Fraction\nMOD9 = 10 ** 9 + 9\nMOD7 = 10 ** 9 + 7\nt = int(input().strip())\nwhile t:\n    n = int(input().strip())\n    num = n * (n - 1)\n    den = 4 * n - 6\n    a = Fraction(num, den)\n    inv = pow(a.denominator, MOD7 - 2, MOD7)\n    ans = a.numerator % MOD7 * inv % MOD7\n    print(ans, end=' ')\n    inv = pow(a.denominator, MOD9 - 2, MOD9)\n    ans = a.numerator % MOD9 * inv % MOD9\n    print(ans)\n    t -= 1", "from fractions import gcd\na = int(input())\nfor i in range(a):\n    n = int(input())\n    atas = n * (n - 1)\n    bawah = 4 * n - 6\n    g = gcd(atas, bawah)\n    atas //= g\n    bawah //= g\n    md = 1000000007\n    md2 = 1000000009\n    bawah1 = pow(bawah, md - 2, md)\n    bawah2 = pow(bawah, md2 - 2, md2)\n    print(atas * bawah1 % md, atas * bawah2 % md2)", "import fractions\nt = int(input())\nfor i in range(t):\n    k = int(input())\n    numer = k * (k - 1)\n    denomi = 4 * k - 6\n    ti = fractions.gcd(numer, denomi)\n    numer = numer // ti\n    denomi = denomi // ti\n    m1 = 1000000007\n    m2 = 1000000009\n    yt = pow(denomi, m1 - 2, m1)\n    sg = pow(denomi, m2 - 2, m2)\n    s1 = numer * yt\n    s2 = numer * sg\n    print(s1 % m1, s2 % m2)", "def extended_gcd(aa, bb):\n    (lastremainder, remainder) = (abs(aa), abs(bb))\n    (x, lastx, y, lasty) = (0, 1, 1, 0)\n    while remainder:\n        (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n        (x, lastx) = (lastx - quotient * x, x)\n        (y, lasty) = (lasty - quotient * y, y)\n    return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\ndef modinv(a, m):\n    (g, x, y) = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError\n    return x % m\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    p = n * (n - 1) // 2\n    q = 2 * n - 3\n    q1 = modinv(q, 1000000007)\n    q2 = modinv(q, 1000000009)\n    ans1 = p % 1000000007 * (q1 % 1000000007) % 1000000007\n    ans2 = p % 1000000009 * (q2 % 1000000009) % 1000000009\n    print(ans1, ans2)", "import math\nimport fractions\n\ndef lis(a):\n    l = []\n    l.append(n * n - n)\n    l.append(2 * (2 * n - 3))\n    l.append(l[0] // fractions.gcd(l[0], l[1]))\n    l.append(l[1] // fractions.gcd(l[0], l[1]))\n    return l\n\ndef ans(num):\n    a1 = pow(num[3], 1000000000 + 7 - 2, 1000000000 + 7)\n    a2 = pow(num[3], 1000000000 + 9 - 2, 1000000000 + 9)\n    print(a1 * num[2] % (1000000000 + 7), a2 * num[2] % (1000000000 + 9))\nt = eval(input())\nfor i in range(t):\n    n = eval(input())\n    num = lis(n)\n    ans(num)", "from fractions import gcd\nmod1 = 1000000007\nmod2 = 1000000009\n\ndef comp(n):\n    if n == 1:\n        return [0, 0]\n    else:\n        num = n * (n - 1)\n        den = 2 * (2 * n - 3)\n        g = gcd(num, den)\n        num = num // g\n        den = den // g\n        return [num % mod1 * pow(den, mod1 - 2, mod1) % mod1, num % mod2 * pow(den, mod2 - 2, mod2) % mod2]\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    res = comp(n)\n    print(res[0], res[1])", "import sys\nPRM1 = 1000000007\nPRM2 = 1000000009\n\ndef main():\n    t = int(sys.stdin.readline())\n    while t > 0:\n        n = int(sys.stdin.readline())\n        expTree(n - 1)\n        t -= 1\n\ndef expTree(n):\n    p = n * (n + 1)\n    q = 2 * (2 * n - 1)\n    x = gcd(p, q)\n    if x != 1:\n        p //= x\n        q //= x\n    ans1 = p % PRM1 * (inverse(q, PRM1) % PRM1) % PRM1\n    ans2 = p % PRM2 * (inverse(q, PRM2) % PRM2) % PRM2\n    print(ans1, end=' ')\n    print(ans2)\n\ndef inverse(q, m):\n    return power(q, m - 2, m)\n\ndef power(a, b, m):\n    if b == 0:\n        return 1\n    p = power(a, b // 2, m)\n    p = p * p % m\n    if b % 2 == 0:\n        return p\n    else:\n        return a * p % m\n\ndef gcd(p, q):\n    if p == 0:\n        return q\n    return gcd(q % p, p)\nmain()", "def lulz(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef pow_mod(x, y, z):\n    number = 1\n    while y:\n        if y & 1:\n            number = number * x % z\n        y >>= 1\n        x = x * x % z\n    return number\ncounter = int(input())\nfor mrinal in range(counter):\n    a = int(input())\n    n = a - 1\n    if n == 0:\n        print(0, 0)\n        continue\n    p = n * (n + 1)\n    q = 2 * (2 * n - 1)\n    f = lulz(p, q)\n    p = p // f\n    q = q // f\n    s = p % 1000000007 * pow_mod(q, 1000000007 - 2, 1000000007) % 1000000007\n    t = p % 1000000009 * pow_mod(q, 1000000009 - 2, 1000000009) % 1000000009\n    print(s, t)", "from fractions import gcd\n(M1, M2) = (10 ** 9 + 7, 10 ** 9 + 9)\nT = int(input().strip())\nwhile T:\n    T -= 1\n    N = int(input().strip())\n    x = N // 2 * (N - 1) if N % 2 == 0 else N * ((N - 1) // 2)\n    y = 2 * N - 3\n    g = gcd(x, y)\n    (x, y) = (x // g, y // g)\n    print(x % M1 * pow(y, M1 - 2, M1) % M1, x % M2 * pow(y, M2 - 2, M2) % M2)", "import fractions\nmd7 = 10 ** 9 + 7\nmd9 = 10 ** 9 + 9\nt = int(input())\nfor _ in range(t):\n    n = int(input()) - 1\n    a = n * (n + 1)\n    b = 2 * (2 * n - 1)\n    c = fractions.gcd(a, b)\n    a //= c\n    b //= c\n    ans7 = a * pow(b, md7 - 2, md7) % md7\n    ans9 = a * pow(b, md9 - 2, md9) % md9\n    print(ans7, ans9)", "from fractions import gcd\nfrom fractions import Fraction as fr\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    n = n - 1\n    p = n * (n + 1)\n    q = 4 * n - 2\n    p1 = p\n    q1 = q\n    p = fr(p1, q1).numerator\n    q = fr(p1, q1).denominator\n    if n == 0 or p <= 0 or q <= 0:\n        print(str(0) + ' ' + str(0))\n        t = t - 1\n        continue\n    qinv1 = pow(q, 10 ** 9 + 5, 10 ** 9 + 7)\n    res1 = p * qinv1 % (10 ** 9 + 7)\n    qinv2 = pow(q, 10 ** 9 + 7, 10 ** 9 + 9)\n    res2 = p * qinv2 % (10 ** 9 + 9)\n    print(str(res1) + ' ' + str(res2))\n    t = t - 1", "m1 = 1000000007\nm2 = 1000000009\nt = int(input())\n\ndef modpow(base, exp, modulus):\n    base %= modulus\n    result = 1\n    while exp > 0:\n        if exp & 1:\n            result = result * base % modulus\n        base = base * base % modulus\n        exp = exp // 2\n    return result\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\nfor i in range(t):\n    n = int(input())\n    p = n * (n - 1)\n    q = 2 * (2 * n - 3)\n    g = gcd(p, q)\n    (p, q) = (p // g, q // g)\n    ans1 = modpow(q, m1 - 2, m1) * p % m1\n    ans2 = modpow(q, m2 - 2, m2) * p % m2\n    print(ans1, ans2)", "def isPrime(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_prime(n):\n    if n == 2 or n == 3:\n        return True\n    if n < 2 or n % 2 == 0:\n        return False\n    if n < 9:\n        return True\n    if n % 3 == 0:\n        return False\n    r = int(n ** 0.5)\n    f = 5\n    while f <= r:\n        print(f)\n        if n % f == 0:\n            return False\n        if n % (f + 2) == 0:\n            return False\n        f += 6\n    return True\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    if n % 2 == 0:\n        return n == 2\n    k = 3\n    while k * k <= n:\n        if n % k == 0:\n            return False\n        k += 2\n    return True\n\ndef sort(array=[12, 4, 5, 6, 7, 3, 1, 15]):\n    less = []\n    equal = []\n    greater = []\n    if len(array) > 1:\n        pivot = array[0]\n        for x in array:\n            if x < pivot:\n                less.append(x)\n            if x == pivot:\n                equal.append(x)\n            if x > pivot:\n                greater.append(x)\n        return sort(less) + equal + sort(greater)\n    else:\n        return array\nfrom fractions import Fraction\nfor _ in range(int(input())):\n    n = int(input())\n    p = n * (n - 1)\n    q = 4 * n - 6\n    p = Fraction(n * (n - 1), 4 * n - 6).numerator\n    q = Fraction(n * (n - 1), 4 * n - 6).denominator\n    if n == 1:\n        print(str(0) + ' ' + str(0))\n        continue\n    a = pow(q, 10 ** 9 + 5, 10 ** 9 + 7)\n    b = pow(q, 10 ** 9 + 7, 10 ** 9 + 9)\n    print(str(p * a % (10 ** 9 + 7)) + ' ' + str(p * b % (10 ** 9 + 9)))", "Mx = 10 ** 9 + 7\nMy = 10 ** 9 + 9\nfor _ in range(int(input())):\n    N = int(input())\n    if N == 1:\n        print('0 0')\n    else:\n        N = N - 1\n        X1 = (N * (N + 1) >> 1) % Mx\n        X2 = (N * (N + 1) >> 1) % My\n        Y1 = pow(2 * N - 1, Mx - 2, Mx)\n        Y2 = pow(2 * N - 1, My - 2, My)\n        skx = X1 * Y1 % Mx\n        sky = X2 * Y2 % My\n        print(skx, sky, sep=' ')", "import fractions\n\ndef cat(n):\n    if n is 1:\n        return [0, 0]\n    n -= 1\n    x = n * (n + 1)\n    y = 2 * (2 * n - 1)\n    h = fractions.gcd(x, y)\n    return [x // h, y // h]\nT = int(input())\nz = 0\nwhile z < T:\n    z += 1\n    i = int(input())\n    (P, Q) = cat(i)\n    x = P % (10 ** 9 + 7)\n    y = pow(Q, 10 ** 9 + 5, 10 ** 9 + 7)\n    print(x * y % (10 ** 9 + 7), end='')\n    print(' ', end='')\n    x = P % (10 ** 9 + 9)\n    y = pow(Q, 10 ** 9 + 7, 10 ** 9 + 9)\n    print(x * y % (10 ** 9 + 9))", "MOD1 = 10 ** 9 + 7\nMOD2 = 10 ** 9 + 9\ntc = int(input())\n\ndef gcd(a, b):\n    if a > b:\n        (a, b) = (b, a)\n    return b if a == 0 else gcd(b % a, a)\n\ndef binpow(a, b, MOD):\n    if b == 0:\n        return 1\n    if b % 2 == 0:\n        z = binpow(a, b // 2, MOD)\n        return z * z % MOD\n    return a * binpow(a, b - 1, MOD) % MOD\nfor _ in range(tc):\n    n = int(input())\n    n -= 2\n    nom = (1 + n) * (1 + n) * (2 + n)\n    den = (2 * n + 2) * (2 * n + 1)\n    if n == -1:\n        print('0 0')\n        continue\n    k = gcd(nom, den)\n    nom //= k\n    den //= k\n    print(nom * binpow(den, MOD1 - 2, MOD1) % MOD1, nom * binpow(den, MOD2 - 2, MOD2) % MOD2)", "from fractions import Fraction\n\ndef find():\n    n = int(input())\n    if n == 1:\n        print(0, 0)\n        return\n    ans = Fraction((n - 1) * n, 2 * (2 * n - 3))\n    m = 10 ** 9 + 7\n    m1 = 10 ** 9 + 9\n    print(ans.numerator * pow(ans.denominator, m - 2, m) % m, ans.numerator * pow(ans.denominator, m1 - 2, m1) % m1)\nt = int(input())\nfor i in range(t):\n    find()", "mod1 = 1000000007\nmod2 = 1000000009\n\ndef binomial(n, r):\n    if r > n - r:\n        r = n - r\n    res = 1\n    for i in range(r):\n        res = res * (n - i)\n        res = res // (i + 1)\n    return res\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef inverse(a, m):\n    return power(a, m - 2, m)\n\ndef catalan(c, n):\n    return c // (n + 1)\nt = int(input())\nfor y in range(t):\n    n = int(input()) - 1\n    p = n * (n + 1)\n    q = 2 * (2 * n - 1)\n    print(p * inverse(q, mod1) % mod1, p * inverse(q, mod2) % mod2)", "def ext_gcd(x, y):\n    if x == 0:\n        return (y, 0, 1)\n    else:\n        (a, b, c) = ext_gcd(y % x, x)\n        return (a, c - y // x * b, b)\n\ndef invmod(x, y):\n    (a, b, c) = ext_gcd(x, y)\n    if a != 1:\n        raise Exception('fuck')\n    else:\n        return b % y\nfor _ in range(int(input())):\n    n = int(input())\n    n = n - 1\n    if n == 0:\n        print('0 0')\n    else:\n        num = n * (n + 1)\n        den = 4 * n - 2\n        MOD1 = 1000000007\n        MOD2 = 1000000009\n        x = invmod(den, MOD1)\n        y = invmod(den, MOD2)\n        print(num * x % MOD1, num * y % MOD2)", "def fast_pow(base, n, M):\n    if n == 0:\n        return 1\n    if n == 1:\n        return base\n    half = fast_pow(base, n // 2, M)\n    if n % 2 == 0:\n        return half * half % M\n    else:\n        return half * half % M * base % M\n\ndef findMMI_fermat(n, M):\n    return fast_pow(n, M - 2, M)\nM = 1000000007\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 1:\n        print(0, 0)\n    else:\n        a = n % M * ((n - 1) % M) % M\n        b = ((n % M << 2) % M - 6) % M\n        print(a * findMMI_fermat(b, M) % M, end=' ')\n        M += 2\n        a = n % M * ((n - 1) % M) % M\n        b = ((n % M << 2) % M - 6) % M\n        print(a * findMMI_fermat(b, M) % M)\n        M -= 2", "import sys\nsys.setrecursionlimit(10000000)\nm1 = 1000000007\nm2 = 1000000009\n\ndef mod_inv(q, m):\n    (g, x, junk) = gcd(q, m)\n    if g == 1:\n        return x % m\n\ndef gcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    (g, x, y) = gcd(b % a, a)\n    return (g, y - b // a * x, x)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    if n == 1:\n        print('0 0')\n        continue\n    p = n * (n - 1)\n    q = 2 * (2 * n - 3)\n    g = gcd(p, q)[0]\n    p = p // g\n    q = q // g\n    print(str(p * mod_inv(q, m1) % m1), str(p * mod_inv(q, m2) % m2))", "MOD1 = 10 ** 9 + 7\nMOD2 = 10 ** 9 + 9\n\ndef mod_exp_inv(base, expo, md):\n    base = base % md\n    ans = 1\n    while expo > 0:\n        if expo & 1:\n            ans = ans * base % md\n        base = base * base % md\n        expo //= 2\n    return ans % md\n\ndef gcd_euclid(x, y):\n    if x == 0 and y == 0:\n        return -1\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef solve_tr(n):\n    if n == 1:\n        print('0 0')\n        return\n    p = n * (n - 1)\n    q = 4 * n - 6\n    gcd_pq = gcd_euclid(p, q)\n    p1 = p // gcd_pq % MOD1\n    q1 = q // gcd_pq % MOD1\n    p2 = p // gcd_pq % MOD2\n    q2 = q // gcd_pq % MOD2\n    res1 = p1 * mod_exp_inv(q1, MOD1 - 2, MOD1) % MOD1\n    res2 = p2 * mod_exp_inv(q2, MOD2 - 2, MOD2) % MOD2\n    print(str(res1) + ' ' + str(res2))\n    return\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    solve_tr(n)", "from fractions import gcd\nMOD1 = 1000000007\nMOD2 = MOD1 + 2\n\ndef modinverse(num, mod):\n    m = mod\n    (a, b) = (0, 1)\n    if mod == 1:\n        return 0\n    while num >= 2:\n        (q, tmp) = (num // mod, mod)\n        mod = num % mod\n        num = tmp\n        tmp = a\n        (a, b) = (b - q * a, tmp)\n    if b < 0:\n        b = b + m\n    return b\nfor _ in range(int(input())):\n    n = int(input())\n    if n < 3:\n        print(n - 1, n - 1)\n    elif n == 3:\n        print(1, 1)\n    else:\n        (p, q) = ((n - 1) * n, 4 * n - 6)\n        gc = gcd(p, q)\n        (p, q) = (p // gc, q // gc)\n        (x, y) = (modinverse(q, MOD1), modinverse(q, MOD2))\n        (x, y) = (p * x % MOD1, p * y % MOD2)\n        print(x, y)", "t = int(input())\nfor j in range(t):\n    n = int(input())\n    x = 1000000000 + 7\n    y = 1000000000 + 9\n    p = n * (n - 1)\n    p = p // 2\n    q = 2 * n - 3\n    a1 = p % x\n    q1 = pow(q, x - 2, x)\n    b1 = a1 * q1 % x\n    a2 = p % y\n    q2 = pow(q, y - 2, y)\n    b2 = a2 * q2 % y\n    print(b1, b2)", "import math\n\ndef gcd(x, y, flag=True):\n    if x < y:\n        return gcd(y, x, flag)\n    while y != 0:\n        (x, y) = (y, x % y)\n    return x\n\ndef inverse(a, b):\n    s1 = 0\n    s = 1\n    r1 = b\n    r = a\n    while r1 != 0:\n        q = math.floor(r / r1)\n        (r, r1) = (r1, r - q * r1)\n        (s, s1) = (s1, s - q * s1)\n    return s\n\ndef inverse_mod(a, m):\n    x = inverse(a, m)\n    if x < 0:\n        x += m\n    return x\ntest = eval(input())\nfor t in range(test):\n    n = eval(input())\n    n = n - 1\n    a = n * (n + 1)\n    b = 2 * (2 * n - 1)\n    in2 = inverse_mod(b, 1000000007)\n    ans = a * in2 % 1000000007\n    in1 = inverse_mod(b, 1000000009)\n    ans1 = a * in1 % 1000000009\n    print(ans, ans1)", "import fractions\n\ndef alli(n):\n    if n is 1:\n        return [0, 0]\n    n -= 1\n    a = n * (n + 1)\n    b = 2 * (2 * n - 1)\n    g = fractions.gcd(a, b)\n    return [a // g, b // g]\nT = int(input())\nz = 0\nwhile z < T:\n    z += 1\n    i = int(input())\n    (P, Q) = alli(i)\n    a = P % (10 ** 9 + 7)\n    b = pow(Q, 10 ** 9 + 5, 10 ** 9 + 7)\n    print(a * b % (10 ** 9 + 7), end='')\n    print(' ', end='')\n    a = P % (10 ** 9 + 9)\n    b = pow(Q, 10 ** 9 + 7, 10 ** 9 + 9)\n    print(a * b % (10 ** 9 + 9))", "MOD1 = 1000000007\nMOD2 = 1000000009\n\ndef gcd(a, b):\n    if a > b:\n        t = a\n        a = b\n        b = t\n    if a == 0:\n        return b\n    b %= a\n    return gcd(b, a)\n\ndef inMod(a, m):\n    m0 = m\n    x0 = 0\n    x1 = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = x0\n        x0 = x1 - q * x0\n        x1 = t\n    if x1 < 0:\n        x1 += m0\n    return x1\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    if n == 1:\n        print(0, 0)\n        continue\n    n -= 1\n    P = n * (n + 1)\n    Q = 2 * (2 * n - 1)\n    f = gcd(P, Q)\n    P //= f\n    Q //= f\n    print(P * inMod(Q, MOD1) % MOD1, P * inMod(Q, MOD2) % MOD2)", "import fractions\na = input()\nfor i in range(1, int(a) + 1):\n    n = input()\n    n = int(n)\n    den = 2 * (2 * n - 3)\n    num = n * (n - 1)\n    g = fractions.gcd(num, den)\n    num = num // g\n    den = den // g\n    b = pow(den, 1000000005, 1000000007)\n    b = b * num % 1000000007\n    print(b, '', end='')\n    b = pow(den, 1000000007, 1000000009)\n    b = b * num % 1000000009\n    print(b)", "import fractions\na = input()\nfor i in range(1, int(a) + 1):\n    n = input()\n    n = int(n)\n    den = 2 * (2 * n - 3)\n    num = n * (n - 1)\n    g = fractions.gcd(num, den)\n    num = num // g\n    den = den // g\n    b = pow(den, 1000000005, 1000000007)\n    b = b * num % 1000000007\n    print(b, '', end='')\n    c = pow(den, 1000000007, 1000000009)\n    c = c * num % 1000000009\n    print(c)", "def ReduceFrac(m, n):\n    while m > 0:\n        x = m\n        m = n % m\n        n = x\n    return n\n\ndef pow(a, b, MOD):\n    x = 1\n    y = a\n    while b > 0:\n        if b % 2 == 1:\n            x = x * y\n            if x > MOD:\n                x = x % MOD\n        y = y * y\n        if y > MOD:\n            y = y % MOD\n        b = b // 2\n    return x\ntc = int(input())\nfor t in range(tc):\n    n = int(input())\n    if n == 1:\n        p = 0\n        q = 0\n        gcd = 1\n        print(p, q)\n    else:\n        p = n\n        q = 2 * n - 3\n        gcd = ReduceFrac(p, q)\n        p = p // gcd\n        q = q // gcd\n        a = n - 1\n        gcd1 = ReduceFrac(a, q)\n        a = a // gcd1\n        q = q // gcd1\n        p = p * a // 2\n        c = pow(q, 1000000005, 1000000007)\n        d = p % 1000000007 * (c % 1000000007) % 1000000007\n        e = pow(q, 1000000007, 1000000009)\n        f = p % 1000000009 * (e % 1000000009) % 1000000009\n        print(d, f)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef inversemod(a, m):\n    m0 = m\n    x0 = 0\n    x1 = 1\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = x0\n        x0 = x1 - q * x0\n        x1 = t\n    if x1 < 0:\n        x1 = x1 + m0\n    return x1\nt = int(input())\nfor _ in range(t):\n    mod1 = 1000000007\n    mod2 = 1000000009\n    n = int(input())\n    u = n * (n - 1)\n    l = 2 * (2 * n - 3)\n    m = gcd(u, l)\n    u = u // m\n    l = l // m\n    l1 = inversemod(l, mod1)\n    l2 = inversemod(l, mod2)\n    print(u % mod1 * (l1 % mod1) % mod1, u % mod2 * (l2 % mod2) % mod2)", "def power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x % m, y // 2, m) % m\n    p = p % m * p % m % m\n    if y % 2 == 0:\n        return p % m\n    else:\n        return x % m * p % m % m\n\ndef modInverse(a, m):\n    return power(a % m, m - 2, m)\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef findans(n, m):\n    if n % m == 0 or (n - 1) % m == 0:\n        return 0\n    q = 4 * n - 6\n    common = gcd(n, q)\n    p = n // common % m\n    q = q // common\n    common = gcd(n - 1, q)\n    p = p * ((n - 1) // common) % m % m\n    q = q // common\n    q = modInverse(q, m)\n    return p % m * q % m % m\nM1 = 1000000007\nM2 = 1000000009\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    print(str(findans(n, M1)) + ' ' + str(findans(n, M2)))", "MOD1 = 10 ** 9 + 7\nMOD2 = 10 ** 9 + 9\n\ndef modPow(base, power, modulus):\n    ans = 1\n    tmp = base\n    p = power\n    while p > 0:\n        if p & 1 != 0:\n            ans = ans * tmp % modulus\n        tmp = tmp * tmp % modulus\n        p >>= 1\n    return ans\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef inv(n, modulus):\n    return modPow(n, modulus - 2, modulus)\nnTests = int(input())\nfor _ in range(nTests):\n    n = int(input())\n    n = n - 1\n    numNodesWithOneChild = n * n + n\n    numTrees = 4 * n - 2\n    d = gcd(numTrees, numNodesWithOneChild)\n    numTrees //= d\n    numNodesWithOneChild //= d\n    ans1 = numNodesWithOneChild * inv(numTrees, MOD1) % MOD1\n    ans2 = numNodesWithOneChild * inv(numTrees, MOD2) % MOD2\n    print(ans1, ans2)", "from fractions import gcd\nm1 = int(1000000007)\nm2 = int(1000000009)\n\ndef GCD(a, b):\n    if b == 0:\n        return int(a)\n    else:\n        return int(GCD(b, a % b))\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nt = int(input())\nfor i in range(0, t):\n    n = int(input())\n    if n == 1:\n        print('0 0')\n        continue\n    if n == 2 or n == 3:\n        print('1 1')\n        continue\n    p = int(n * (n - 1))\n    q = int(2 * (2 * n - 3))\n    var = int(GCD(int(p), int(q)))\n    p = int(p // var)\n    q = int(q // var)\n    q1 = int(modinv(q, m1))\n    x = int(p % m1 * q1 % m1 % m1)\n    q2 = int(modinv(q, m2))\n    y = int(p % m2 * q2 % m2 % m2)\n    print(x, end=' ')\n    print(y)", "def mod_exp(a, b, m):\n    if b == 0:\n        return 1\n    ans = mod_exp(a, b // 2, m) % m\n    ans = ans * ans % m\n    if b % 2 == 0:\n        return ans\n    else:\n        return a * ans % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nmod1 = int(1000000007)\nmod2 = int(1000000009)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    num = n * (n - 1)\n    den = 2 * (2 * n - 3)\n    g = int(gcd(num, den))\n    num = num // g\n    den = den // g\n    a1 = num % mod1 * mod_exp(den, mod1 - 2, mod1) % mod1\n    a2 = num % mod2 * mod_exp(den, mod2 - 2, mod2) % mod2\n    print(a1, a2)", "M1 = 10 ** 9 + 7\nM2 = 10 ** 9 + 9\nfor _ in range(int(input())):\n    N = int(input())\n    if N == 1:\n        print('0 0')\n    else:\n        N = N - 1\n        X1 = (N * (N + 1) >> 1) % M1\n        X2 = (N * (N + 1) >> 1) % M2\n        Y1 = pow(2 * N - 1, M1 - 2, M1)\n        Y2 = pow(2 * N - 1, M2 - 2, M2)\n        R1 = X1 * Y1 % M1\n        R2 = X2 * Y2 % M2\n        print(R1, R2, sep=' ')", "def power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef modinverse(a, m):\n    return power(a, m - 2, m)\nt = int(input())\nfirst = 1000000007\nsecon = 1000000009\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        print(0, 0)\n    else:\n        q1 = ((n - 1) * 2 - 1) * 2 % first\n        p1 = n % first * ((n - 1) % first)\n        q2 = ((n - 1) * 2 - 1) * 2 % secon\n        p2 = n % secon * ((n - 1) % secon)\n        a1 = p1 % first * (modinverse(q1, first) % first) % first\n        a2 = p2 % secon * (modinverse(q2, secon) % secon) % secon\n        print(a1, a2)", "t = int(input())\nm1 = 10 ** 9 + 7\nm2 = 10 ** 9 + 9\n\ndef gcd(a1, a2):\n    if a1 == 0:\n        return a2\n    return gcd(a2 % a1, a1)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m)\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef modular(a1, m):\n    return power(a1, m - 2, m)\nfor i in range(t):\n    n = int(input())\n    a = n * (n - 1)\n    b = 2 * (2 * n - 3)\n    c = gcd(a, b)\n    a //= c\n    b //= c\n    print(a % m1 * modular(b, m1) % m1, a % m2 * modular(b, m2) % m2)", "def power(x, y, p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y & 1:\n            res = res * x % p\n        y >>= 1\n        x = x * x % p\n    return res\n\ndef main():\n    t = int(input(''))\n    while t > 0:\n        n = int(input(''))\n        if n == 1:\n            print('0 0')\n        elif n == 2:\n            print('1 1')\n        else:\n            num1 = n * (n - 1) % 1000000007\n            den1 = den2 = 4 * n - 6\n            num2 = n * (n - 1) % 1000000009\n            print('{} {}'.format(num1 * power(den1, 1000000005, 1000000007) % 1000000007, num2 * power(den2, 1000000007, 1000000009) % 1000000009))\n        t = t - 1\nmain()", "md1 = 10 ** 9 + 7\nmd2 = 10 ** 9 + 9\n\ndef mdinv(a, m):\n    m0 = m\n    x0 = 0\n    x1 = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        quo = a // m\n        temp = m\n        m = a % m\n        a = temp\n        temp = x0\n        x0 = x1 - quo * x0\n        x1 = temp\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef gcd(n1, n2):\n    if n2:\n        return gcd(n2, n1 % n2)\n    else:\n        return n1\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        print('0 0')\n        continue\n    if n == 2 or n == 3:\n        print('1 1')\n        continue\n    n -= 1\n    num = n * (n + 1)\n    den = 4 * n - 2\n    x = gcd(num, den)\n    num = num // x\n    den = den // x\n    a = mdinv(den, md1)\n    b = mdinv(den, md2)\n    print(num * a % md1, num * b % md2)", "def inverse(a, b, mod):\n    return a * pow(b, mod - 2, mod) % mod\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    f1 = n * (n - 1) * (n - 1)\n    f2 = (2 * n - 2) * (2 * n - 3)\n    ans1 = inverse(f1, f2, 1000000007)\n    ans2 = inverse(f1, f2, 1000000009)\n    print(ans1, ans2)", "import math\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    return x * p % m\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    if n == 1:\n        (num, denom) = (0, 1)\n    elif n == 2:\n        num = denom = 1\n    else:\n        num = n * (n - 1) * (n - 1)\n        denom = (2 * n - 2) * (2 * n - 3)\n    g = gcd(num, denom)\n    num //= g\n    denom //= g\n    print(num * power(denom, 1000000005, 1000000007) % 1000000007, num * power(denom, 1000000007, 1000000009) % 1000000009)", "def power(a, n, mod):\n    if n <= 0:\n        return 1\n    elif n == 1:\n        return a\n    else:\n        p = power(a, n // 2, mod)\n        p = p * p % mod\n        if n % 2 == 1:\n            p = p * a % mod\n        return p\nmod1 = 1000000007\nmod2 = 1000000009\nfor i in range(int(input())):\n    n = int(input())\n    num = n * (n - 1) // 2\n    den = 2 * n - 3\n    den1 = power(den, mod1 - 2, mod1)\n    den2 = power(den, mod2 - 2, mod2)\n    ans1 = num * den1 % mod1\n    ans2 = num * den2 % mod2\n    print(ans1, ans2)", "def gc(e, r):\n    if r == 0:\n        return e\n    else:\n        return gc(r, e % r)\n\ndef binaryExp1(x1, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return binaryExp1(x1 * x1 % 1000000007, n // 2)\n    else:\n        return x1 * binaryExp1(x1 * x1 % 1000000007, (n - 1) // 2) % 1000000007\n\ndef binaryExp2(x2, n):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return binaryExp2(x2 * x2 % 1000000009, n // 2)\n    else:\n        return x2 * binaryExp2(x2 * x2 % 1000000009, (n - 1) // 2) % 1000000009\nimport math\nt = int(input())\nwhile t > 0:\n    a = int(input())\n    if a == 1:\n        tree = 1\n        vertix = 0\n    else:\n        vertix = a * a - a\n        tree = 4 * a - 6\n    fraction = gc(tree, vertix)\n    tree = tree // fraction\n    vertix = vertix // fraction\n    m1 = 1000000007\n    m2 = 1000000009\n    res1 = binaryExp1(tree, m1 - 2) % m1\n    res2 = binaryExp2(tree, m2 - 2) % m2\n    ans1 = vertix % 1000000009 * res2 % 1000000009\n    ans2 = vertix % 1000000007 * res1 % 1000000007\n    print(ans2, ans1)\n    t = t - 1", "from fractions import gcd\n\ndef function1(x, y):\n    if x == 0:\n        return (y, 0, 1)\n    else:\n        (g, b, a) = function1(y % x, x)\n        return (g, a - y // x * b, b)\n\ndef modular_inverse(no, mod):\n    (g, a, b) = function1(no, mod)\n    if g == 1:\n        return a % mod\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    numerator = int(pow(N, 2) - N)\n    denominator = 4 * N - 6\n    GCD = gcd(numerator, denominator)\n    numerator = numerator // GCD\n    denominator = denominator // GCD\n    inv1 = pow(denominator, 1000000005, 1000000007)\n    inv2 = pow(denominator, 1000000007, 1000000009)\n    print(int(numerator * inv1 % 1000000007), end='')\n    print(' ', end='')\n    print(int(numerator * inv2 % 1000000009))", "def powermod(a, b, n):\n    if b == 1:\n        return a % n\n    if b == 0:\n        return 1\n    r = powermod(a, b // 2, n)\n    r = r * r % n\n    if b % 2 == 1:\n        r = r * a % n\n    return r\nmod1 = 1000000007\nmod2 = 1000000009\nfor _ in range(int(input())):\n    n = int(input())\n    n = n - 2\n    if n == -1:\n        print('0 0')\n    else:\n        nume = (n + 1) * (n + 2) // 2\n        deno = 2 * n + 1\n        deno1 = powermod(deno, mod1 - 2, mod1)\n        deno2 = powermod(deno, mod2 - 2, mod2)\n        ans1 = nume * deno1 % mod1\n        ans2 = nume * deno2 % mod2\n        print(ans1, ans2)", "def gcd(aa, bb):\n    (lr, r) = (abs(aa), abs(bb))\n    (x, lx, y, ly) = (0, 1, 1, 0)\n    while r:\n        (lr, (q, r)) = (r, divmod(lr, r))\n        (x, lx) = (lx - q * x, x)\n        (y, ly) = (ly - q * y, y)\n    return (lr, lx * (-1 if aa < 0 else 1), ly * (-1 if bb < 0 else 1))\n\ndef mi(a, m):\n    (g, x, y) = gcd(a, m)\n    if g != 1:\n        raise ValueError\n    return x % m\n\ndef HCF(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\nfrom math import factorial, sqrt\nfor i in range(int(input())):\n    n = int(input()) - 1\n    if n == 0:\n        a = 0\n        b = 1\n    else:\n        a = n * (n + 1)\n        b = 4 * n - 2\n    p = 10 ** 9 + 7\n    q = 10 ** 9 + 9\n    z = HCF(a, b)\n    a = a // z\n    b = b // z\n    b1 = mi(b, p)\n    b2 = mi(b, q)\n    print(a % p * b1 % p % p, a % q * b2 % q % q)", "def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    return x % m\nt = int(input())\nwhile t:\n    n = int(input())\n    n -= 1\n    if not n:\n        print('0 0')\n        t -= 1\n        continue\n    m = 1000000007\n    m2 = 1000000009\n    n1 = n % m\n    n2 = n % m2\n    a1 = n1 * (n1 + 1) % m\n    b1 = (4 * n1 - 2) % m\n    a2 = n2 * (n2 + 1) % m2\n    b2 = (4 * n2 - 2) % m2\n    print(int(modinv(b1, m) * a1 % m), int(modinv(b2, m2) * a2 % m2))\n    t -= 1", "mod = 1000000007\nmod2 = 1000000009\n\ndef f(x, e, m):\n    X = x\n    E = e\n    Y = 1\n    while E > 0:\n        if E % 2 == 0:\n            X = X * X % m\n            E = E / 2\n        else:\n            Y = X * Y % m\n            E = E - 1\n    return Y\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    ans1 = (n - 1) % mod * n % mod * f(4 * n - 6, mod - 2, mod) % mod\n    ans2 = (n - 1) % mod2 * n % mod2 * f(4 * n - 6, mod2 - 2, mod2) % mod2\n    print(ans1, ans2)", "import operator as op\nfrom functools import reduce\nimport sys\nimport math\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nt = int(input())\nmod1 = 1000000007\nmod2 = 1000000009\nfor i in range(t):\n    n = int(input())\n    n = n - 1\n    if n == 0:\n        print('0', ' ', '0')\n        continue\n    p = (n + 1) * n\n    q = (2 * n - 1) * 2\n    q1 = modinv(q, mod1)\n    q2 = modinv(q, mod2)\n    ans1 = (n % mod1 + 1) % mod1 * (n % mod1) % mod1 * (q1 % mod1) % mod1\n    ans1 = int(ans1)\n    ans2 = (n % mod2 + 1) % mod2 * (n % mod2) % mod2 * (q2 % mod2) % mod2\n    ans2 = int(ans2)\n    print(ans1, ' ', ans2)", "def gcd(x, y):\n    while y != 0:\n        (x, y) = (y, x % y)\n    return x\n\ndef modinv(a, m):\n    m0 = m\n    x0 = 0\n    x1 = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = x0\n        x0 = x1 - q * x0\n        x1 = t\n    if x1 < 0:\n        x1 += m0\n    return x1\nmodi = 1000000007\nmodx = 1000000009\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    n -= 1\n    if n == 0:\n        print('0 0')\n    else:\n        a = n * n * (n + 1) % modi\n        b = 2 * n * (2 * n - 1)\n        e = modinv(b, modi)\n        ans1 = a * e % modi\n        a = n * n * (n + 1) % modx\n        e = modinv(b, modx)\n        ans2 = a * e % modx\n        print(int(ans1), end=' ')\n        print(int(ans2))", "MOD = 1000000000 + 7\nMOD1 = 1000000000 + 7\nMOD2 = 1000000000 + 9\n\ndef pow(b, e, m=MOD):\n    res = 1\n    b = b % m\n    while e > 0:\n        if e % 2 == 1:\n            res = res * (b % m) % m\n        b = b * (b % m) % m\n        e = e // 2\n    return res\n\ndef mod_inv(n, m=MOD):\n    if n == 2:\n        if m == MOD1:\n            return 500000004\n        elif m == MOD2:\n            return 500000005\n    return pow(n, m - 2, m)\n\ndef num(x, mod):\n    return (x % mod * x % mod % mod - x % mod + mod) % mod * mod_inv(2, mod) % mod\n\ndef den(x, mod):\n    return (2 * x % mod - 3 % mod + mod) % mod\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    if N == 1:\n        print('0 0')\n    else:\n        ans1 = num(N, MOD1) * mod_inv(den(N, MOD1), MOD1) % MOD1\n        ans2 = num(N, MOD2) * mod_inv(den(N, MOD2), MOD2) % MOD2\n        print('%d %d' % (ans1, ans2))", "M = lambda A, n, s=1, t=0, N=0: (n < 2 and t % N or M(n, A % n, t, s - A // n * t, N or n), -1)[n < 1]\nt = int(input())\nfor i in range(t):\n    n1 = int(input())\n    if n1 == 1:\n        print('0 0')\n    elif n1 == 2 or n1 == 3:\n        print('1 1')\n    else:\n        n = n1 * (n1 - 1) * (n1 - 1)\n        d = (2 * n1 - 2) * (2 * n1 - 3)\n        a = n\n        b = d\n        r = 0\n        while b != 0:\n            (a, b) = (b, a % b)\n        n = n // a\n        d = d // a\n        s = 1\n        m1 = 1000000007\n        m2 = 1000000009\n        si = str(n % m1 * M(d, m1) % m1) + ' ' + str(n % m2 * M(d, m2) % m2)\n        print(si)", "from fractions import gcd\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    p = n * (n - 1) // 2\n    q = 2 * n - 3\n    m1 = 1000000007\n    m2 = 1000000009\n    x = gcd(p, q)\n    p = p // x\n    q = q // x\n    ans1 = p * pow(q, m1 - 2, m1) % m1\n    ans2 = p * pow(q, m2 - 2, m2) % m2\n    print(str(ans1) + ' ' + str(ans2))", "mod1 = 1000000007\nmod2 = 1000000009\n\ndef power(a, b, m):\n    ans = 1\n    while b:\n        if b % 2 == 1:\n            ans = ans * a % m\n        a = a * a % m\n        b = b // 2\n    return ans\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lol(n):\n    x = (2 * n - 2) * (2 * n - 3)\n    y = (n - 1) * (n - 1)\n    z = y * n\n    g = gcd(x, z)\n    x //= g\n    z //= g\n    print(z * power(x, mod1 - 2, mod1) % mod1, z * power(x, mod2 - 2, mod2) % mod2)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n <= 3:\n        if n == 1:\n            print(0, 0)\n        elif n == 2 or n == 3:\n            print(1, 1)\n        continue\n    lol(n)", "from math import floor\nimport sys\nsys.setrecursionlimit(15000)\n\ndef Inverse(base, n, M):\n    if n == 0:\n        return 1\n    if n == 1:\n        return base\n    half = Inverse(base, n // 2, M)\n    if n % 2 == 0:\n        return half ** 2 % M\n    else:\n        return half ** 2 % M * base % M\n\ndef inverse_arith(n, M):\n    return Inverse(n, M - 2, M)\nMOD = 1000000007\nMOD1 = 1000000009\nb1 = int(input())\nfor r in range(b1):\n    h = int(input()) - 1\n    i = h * (h + 1) // 2\n    w = 2 * h - 1\n    y2 = inverse_arith(w, MOD)\n    z = i * y2 % MOD\n    y3 = inverse_arith(w, MOD1)\n    z1 = i * y3 % MOD1\n    print(z, end=' ')\n    print(z1)", "from fractions import gcd\n\ndef binpow(a, b, m):\n    r = 1\n    while b:\n        if b % 2:\n            r = r * a % m\n        b = b // 2\n        a = a * a % m\n    return r\nmod1 = 10 ** 9 + 7\nmod2 = 10 ** 9 + 9\nt = int(input())\nfor _ in range(t):\n    n = int(input()) - 1\n    p = (n + 1) * n\n    q = 2 * (2 * n - 1)\n    g = gcd(p, q)\n    (p, q) = (p // g, q // g)\n    ans1 = p * binpow(q, mod1 - 2, mod1) % mod1\n    ans2 = p * binpow(q, mod2 - 2, mod2) % mod2\n    print(ans1, ans2)", "from fractions import gcd\n\ndef binpow(a, b, m):\n    r = 1\n    while b:\n        if b % 2:\n            r = r * a % m\n        b = b // 2\n        a = a * a % m\n    return r\nmod1 = 10 ** 9 + 7\nmod2 = 10 ** 9 + 9\nt = int(input())\nfor _ in range(t):\n    n = int(input()) - 1\n    p = (n + 1) * n\n    q = 2 * (2 * n - 1)\n    g = gcd(p, q)\n    (p, q) = (p // g, q // g)\n    ans1 = p * binpow(q, mod1 - 2, mod1) % mod1\n    ans2 = p * binpow(q, mod2 - 2, mod2) % mod2\n    print(ans1, ans2)", "def fastpow(a, n, m):\n    if n == 0:\n        return 1\n    if n == 1:\n        return a\n    b = fastpow(a, n // 2, m)\n    if n % 2 == 0:\n        return b * b % m\n    else:\n        return b * b % m * a % m\nt = int(input())\nfor i in range(0, t):\n    n = int(input()) - 1\n    num1 = fastpow(2 * (2 * n - 1), 1000000007 - 2, 1000000007)\n    num2 = num1 * (n + 1) * n % 1000000007\n    num3 = fastpow(2 * (2 * n - 1), 1000000009 - 2, 1000000009)\n    num4 = num3 * (n + 1) * n % 1000000009\n    print(str(num2) + ' ' + str(num4))", "from fractions import gcd\n\ndef fermat(a, p, m):\n    ans = 1\n    a = a % m\n    while p > 0:\n        if p % 2 == 0:\n            a = a * a % m\n            p = p // 2\n        else:\n            ans = ans * a % m\n            p -= 1\n    return ans\n\ndef mod_inv(a, m):\n    return fermat(a, m - 2, m)\nT = int(input())\nfor r in range(T):\n    n = int(input())\n    n -= 1\n    if n == 0:\n        print(0, 0)\n    else:\n        num = (n + 1) * n * n\n        den = 2 * n * (2 * n - 1)\n        (m1, m2) = (10 ** 9 + 7, 10 ** 9 + 9)\n        g = gcd(num, den)\n        (num1, den1, num2, den2) = (num // g % m1, den // g % m1, num // g % m2, den // g % m2)\n        (den1, den2) = (mod_inv(den1, m1), mod_inv(den2, m2))\n        print(num1 * den1 % m1, num2 * den2 % m2)", "def modinverse(a, m):\n    m0 = m\n    x0 = 0\n    x1 = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = x0\n        x0 = x1 - q * x0\n        x1 = t\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nfor _ in range(int(input())):\n    MOD1 = 1000000007\n    MOD2 = 1000000009\n    n = int(input())\n    n -= 1\n    if n == 0:\n        print('0 0')\n        continue\n    p = n * (n + 1)\n    q = 2 * (2 * n - 1)\n    g = gcd(p, q)\n    p //= g\n    q //= g\n    Q_1 = modinverse(q, MOD1)\n    Q_2 = modinverse(q, MOD2)\n    Q_1 = p % MOD1 * (Q_1 % MOD1) % MOD1\n    Q_2 = p % MOD2 * (Q_2 % MOD2) % MOD2\n    print(Q_1, end=' ')\n    print(Q_2)", "def gcd(a, b):\n    if a % b is 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef power(a, b, m):\n    if b is 0:\n        return 1\n    k = power(a, b // 2, m)\n    k = k % m * k % m\n    if b % 2 is 1:\n        return k % m * a % m % m\n    else:\n        return k % m\n\ndef inv(a, b):\n    return power(a, b - 2, b)\nfor _ in range(0, int(input())):\n    n = int(input())\n    n = n - 1\n    if n is 0:\n        print('0 0')\n    else:\n        p = n * (n + 1)\n        q = 2 * (2 * n - 1)\n        g = gcd(p, q)\n        p = p // g\n        q = q // g\n        mod1 = 1000000007\n        mod2 = 1000000009\n        q1 = inv(q, mod1)\n        q2 = inv(q, mod2)\n        a1 = p % mod1 * q1 % mod1 % mod1\n        a2 = p % mod2 * q2 % mod2 % mod2\n        s = str(a1) + ' ' + str(a2)\n        print(s)", "def power(a, b, m):\n    if b is 0:\n        return 1\n    k = power(a, b // 2, m)\n    k = k % m * k % m\n    if b % 2 is 1:\n        return k % m * a % m % m\n    else:\n        return k % m\n\ndef inv(a, b):\n    return power(a, b - 2, b)\n\ndef gcd(a, b):\n    if a % b is 0:\n        return b\n    else:\n        return gcd(b, a % b)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    n = n - 1\n    if n is 0:\n        print('0 0')\n    else:\n        a = n * (n + 1)\n        b = 2 * (2 * n - 1)\n        g = gcd(a, b)\n        a = a // g\n        b = b // g\n        mod = 10 ** 9 + 7\n        mm = 10 ** 9 + 9\n        b1 = inv(b, mod)\n        b2 = inv(b, mm)\n        a1 = a % mod * b1 % mod % mod\n        a2 = a % mm * b2 % mm % mm\n        print(str(a1) + ' ' + str(a2))", "from fractions import gcd\n\ndef modInverse(a, m):\n    m0 = m\n    x0 = 0\n    x1 = 1\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = x0\n        x0 = x1 - q * x0\n        x1 = t\n    if x1 < 0:\n        x1 += m0\n    return x1\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    num = n * (n - 1)\n    den = (2 * n - 3) * 2\n    z = gcd(num, den)\n    if z != 1:\n        num = num // z\n        den = den // z\n    mod1 = 10 ** 9 + 7\n    mod2 = 10 ** 9 + 9\n    print(str(int(num % mod1 * modInverse(den, mod1) % mod1)) + ' ' + str(int(num % mod2 * modInverse(den, mod2) % mod2)))", "def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    n -= 1\n    if n == 0:\n        print(0, 0)\n        continue\n    ans1 = n * (n + 1) * modinv(2 * (2 * n - 1), 1000000007) % 1000000007\n    ans2 = n * (n + 1) * modinv(2 * (2 * n - 1), 1000000009) % 1000000009\n    print(ans1, ans2)", "P1 = 1000000007\nP2 = 1000000009\nt = int(input())\nfor test in range(t):\n    n = int(input()) - 1\n    a = pow(n, 2) + n\n    b = 4 * n - 2\n    print(a % P1 * pow(b, P1 - 2, P1) % P1, a % P2 * pow(b, P2 - 2, P2) % P2)", "def gcd(x, y):\n    if y == 0:\n        return x\n    else:\n        return gcd(y, x % y)\n\ndef inverse(a, m):\n    m0 = m\n    x0 = 0\n    x1 = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = x0\n        x0 = x1 - q * x0\n        x1 = t\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        n = n - 1\n        if n == 0:\n            print('0 0')\n        else:\n            num = (n + 1) * n\n            den = 2 * (2 * n - 1)\n            gc = gcd(num, den)\n            num = num // gc\n            den = den // gc\n            m1 = 1000000007\n            m2 = 1000000009\n            ans1 = num * inverse(den, m1) % m1\n            ans2 = num * inverse(den, m2) % m2\n            print(str(ans1) + ' ' + str(ans2))\nmain()", "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\nt = int(input())\nfor u in range(t):\n    n = int(input())\n    num = n * (n - 1)\n    den = 4 * n - 6\n    g = gcd(num, den)\n    num = num // g\n    den = den // g\n    print(num * pow(den, 1000000005, 1000000007) % 1000000007, num * pow(den, 1000000007, 1000000009) % 1000000009)", "MOD1 = 10 ** 9 + 7\nMOD2 = 10 ** 9 + 9\n\ndef power(acc, n, MOD):\n    if n == 0:\n        return 1\n    if n % 2 == 1:\n        return acc * power(acc * acc % MOD, int(n / 2), MOD)\n    else:\n        return power(acc * acc % MOD, int(n / 2), MOD)\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef solve(n):\n    if n == 1:\n        print(0, 0)\n        return\n    n -= 1\n    numerator = n * n * (n + 1)\n    denumerator = 2 * n * (2 * n - 1)\n    g = gcd(numerator, denumerator)\n    numerator //= g\n    denumerator //= g\n    print(numerator * power(denumerator, MOD1 - 2, MOD1) % MOD1, numerator * power(denumerator, MOD2 - 2, MOD2) % MOD2)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        solve(n)\nmain()", "from fractions import gcd\nt = int(input())\n\ndef binary_exp(x, n, prime):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return x % prime\n    else:\n        temp = binary_exp(x, int(n / 2), prime)\n        temp = temp * temp % prime\n        if n % 2 == 0:\n            return temp\n        else:\n            return x % prime * temp % prime\n\ndef inverse(x, prime):\n    return binary_exp(x, prime - 2, prime)\nwhile t != 0:\n    t -= 1\n    n = int(input())\n    n = n - 1\n    if n != 0:\n        numerator = n * (n + 1)\n        denominator = 2 * (2 * n - 1)\n        factor = gcd(numerator, denominator)\n        numerator = numerator // factor\n        denominator = denominator // factor\n        prime1 = 1000000007\n        prime2 = 1000000009\n        ans1 = numerator * inverse(denominator, prime1)\n        ans2 = numerator * inverse(denominator, prime2)\n        print(ans1 % prime1, ans2 % prime2)\n    else:\n        print('0 0')", "from fractions import gcd\nt = int(input())\n\ndef binary_exp(x, n, prime):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return x % prime\n    else:\n        temp = binary_exp(x, int(n / 2), prime)\n        temp = temp * temp % prime\n        if n % 2 == 0:\n            return temp\n        else:\n            return x % prime * temp % prime\n\ndef inverse(x, prime):\n    return binary_exp(x, prime - 2, prime)\nwhile t != 0:\n    t -= 1\n    n = int(input())\n    n = n - 1\n    numerator = n * (n + 1)\n    denominator = 2 * (2 * n - 1)\n    factor = gcd(numerator, denominator)\n    numerator = numerator // factor\n    denominator = denominator // factor\n    prime1 = 1000000007\n    prime2 = 1000000009\n    ans1 = numerator * inverse(denominator, prime1)\n    ans2 = numerator * inverse(denominator, prime2)\n    print(ans1 % prime1, ans2 % prime2)", "from fractions import gcd\nt = int(input())\n\ndef binary_exp(x, n, prime):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return x % prime\n    else:\n        temp = binary_exp(x, int(n / 2), prime)\n        temp = temp * temp % prime\n        if n % 2 == 0:\n            return temp\n        else:\n            return x % prime * temp % prime\n\ndef inverse(x, prime):\n    return binary_exp(x, prime - 2, prime)\nwhile t != 0:\n    t -= 1\n    n = int(input())\n    n = n - 1\n    numerator = n * (n + 1)\n    denominator = 2 * (2 * n - 1)\n    factor = gcd(numerator, denominator)\n    numerator = numerator // factor\n    denominator = denominator // factor\n    mod1 = 1000000007\n    mod2 = 1000000009\n    ans1 = numerator * inverse(denominator, mod1)\n    ans2 = numerator * inverse(denominator, mod2)\n    print(ans1 % mod1, ans2 % mod2)", "cnt_tests = int(input())\n\ndef solve(n, MOD):\n    p = n * (n + 1) % MOD\n    q = (4 * n - 2) % MOD\n    q_rev = pow(q, MOD - 2, MOD)\n    return p * q_rev % MOD\nfor test in range(cnt_tests):\n    n = int(input())\n    print(solve(n - 1, int(1000000000.0) + 7), solve(n - 1, int(1000000000.0 + 9)))", "MOD1 = 1000000007\nMOD2 = 1000000009\n\ndef modpow(x, y, mod):\n    if y == 0:\n        return 1\n    else:\n        tmp = modpow(x, y // 2, mod)\n        return tmp * tmp % mod if y % 2 == 0 else tmp * tmp % mod * x % mod\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    if N == 1:\n        print(0, 0)\n    else:\n        if N % 3 == 0:\n            P = N // 3 * (N - 1) // 2\n            Q = 2 * N // 3 - 1\n        else:\n            P = N * (N - 1) // 2\n            Q = 2 * N - 3\n        print(P * modpow(Q, MOD1 - 2, MOD1) % MOD1, P * modpow(Q, MOD2 - 2, MOD2) % MOD2)", "def findmmi(n, m):\n    return pow(n, m - 2, m)\n\ndef main():\n    mod1 = 1000000007\n    mod2 = 1000000009\n    T = int(input())\n    while T > 0:\n        n = int(input())\n        n = n - 1\n        if n == 0:\n            print('0 0')\n        else:\n            n1 = n % mod1 * (n + 1) % mod1 % mod1\n            d1 = findmmi(4 * n - 2, mod1)\n            ans1 = n1 % mod1 * (d1 % mod1) % mod1\n            n2 = n % mod2 * (n + 1) % mod2 % mod2\n            d2 = findmmi(4 * n - 2, mod2)\n            ans2 = n2 % mod2 * (d2 % mod2) % mod2\n            print(str(ans1) + ' ' + str(ans2))\n        T = T - 1\nmain()", "def ModInverse(a, m):\n    m0 = m\n    x0 = 0\n    x1 = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = x0\n        x0 = x1 - q * x0\n        x1 = t\n    if x1 < 0:\n        x1 = x1 + m0\n    return x1\nT = int(input())\nfor i in range(T):\n    Num = int(input())\n    if Num > 1:\n        P = Num * (Num - 1)\n        Q = 2 * (2 * Num - 3)\n        Q1 = ModInverse(Q, 10 ** 9 + 7)\n        Q2 = ModInverse(Q, 10 ** 9 + 9)\n        Ans1 = P * Q1 % (10 ** 9 + 7)\n        Ans2 = P * Q2 % (10 ** 9 + 9)\n        print(Ans1, Ans2)\n    else:\n        print(0, 0)", "from fractions import gcd\nget = lambda p, q, m: p * pow(q, m - 2, m) % m\nfor t in range(int(input())):\n    N = int(input())\n    (num, den) = (N * (N - 1), 4 * N - 6)\n    g = gcd(num, den)\n    num //= g\n    den //= g\n    ans1 = get(num, den, 10 ** 9 + 7)\n    ans2 = get(num, den, 10 ** 9 + 9)\n    print(ans1, ans2)", "from fractions import gcd\nget = lambda p, q, m: p * pow(q, m - 2, m) % m\nfor t in range(int(input())):\n    N = int(input())\n    (num, den) = (N * (N - 1), 4 * N - 6)\n    g = gcd(num, den)\n    num //= g\n    den //= g\n    ans1 = get(num, den, 10 ** 9 + 7)\n    ans2 = get(num, den, 10 ** 9 + 9)\n    print(ans1, ans2)", "from fractions import gcd\nget = lambda p, q, m: p * pow(q, m - 2, m) % m\nfor t in range(int(input())):\n    N = int(input())\n    (num, den) = (N * (N - 1), 4 * N - 6)\n    g = gcd(num, den)\n    num //= g\n    den //= g\n    ans1 = get(num, den, 10 ** 9 + 7)\n    ans2 = get(num, den, 10 ** 9 + 9)\n    print(ans1, ans2)", "t = int(input())\n\ndef modexp(x, y, p):\n    res = 1\n    while y > 0:\n        if y & 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\nfor i in range(0, t):\n    mod1 = 1000000005\n    mod2 = 1000000007\n    mod3 = 1000000009\n    n = int(input())\n    if n == 1:\n        print(0, 0)\n    else:\n        a = int(n * (n - 1) // 2)\n        b = 2 * n - 3\n        x = int(a // gcd(a, b))\n        y = int(b // gcd(a, b))\n        xx = modexp(y, mod1, mod2)\n        xy = x % mod2\n        x1 = xy * xx % mod2\n        yx = modexp(y, mod2, mod3)\n        yy = x % mod3\n        x2 = yy * yx % mod3\n        print(x1, x2)", "def gcd(x, y):\n    if y == 0:\n        return x\n    return gcd(y, x % y)\n\ndef fast_pow(x, y, M):\n    if y == 0:\n        return 1\n    p = fast_pow(x, y // 2, M)\n    p = p * p % M\n    if y % 2 == 0:\n        return p\n    else:\n        return p * x % M\n\ndef modInverse(x, M):\n    return fast_pow(x, M - 2, M)\nfor _ in range(int(input())):\n    n = int(input())\n    if n < 2:\n        print('0 0')\n        continue\n    (nu, de) = ((n - 1) * (n - 1) * n, (2 * n - 2) * (2 * n - 3))\n    d = gcd(nu, de)\n    (nu, de) = (nu // d, de // d)\n    (ans1, ans2) = (nu * modInverse(de, 10 ** 9 + 7) % (10 ** 9 + 7), nu * modInverse(de, 10 ** 9 + 9) % (10 ** 9 + 9))\n    print(ans1, ans2)", "import functools, operator\ncases = int(input())\nmod1 = 1000000007\nmod2 = 1000000009\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    if r == 0:\n        return 1\n    return functools.reduce(operator.mul, range(n, n - r, -1)) // functools.reduce(operator.mul, range(1, r + 1))\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    return x % m\nfor _ in range(cases):\n    n = int(input())\n    if n == 1:\n        print(0, 0)\n    elif n == 2 or n == 3:\n        print(1, 1)\n    else:\n        p = (n - 1) * n\n        q = (2 * n - 3) * 2\n        qmod1 = modinv(q, mod1)\n        qmod2 = modinv(q, mod2)\n        print(p * qmod1 % mod1, p * qmod2 % mod2)", "def gcd(a, b):\n    if a == 0:\n        return b\n    else:\n        return gcd(b % a, a)\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    numerator = n * (n - 1)\n    denominator = 2 * (2 * n - 3)\n    a = gcd(numerator, denominator)\n    numerator = numerator // a\n    denominator = denominator // a\n    ans = pow(denominator, 1000000005, 1000000007)\n    ans = ans * numerator % 1000000007\n    ans1 = pow(denominator, 1000000007, 1000000009)\n    ans1 = ans1 * numerator % 1000000009\n    print(ans, ans1)", "from fractions import gcd\nt = int(input())\nfor i in range(t):\n    x = int(input())\n    if x == 1:\n        print(0, 0)\n        continue\n    p = (x - 1) * x\n    q = (2 * x - 3) * 2\n    k = gcd(p, q)\n    p = p // k\n    q = q // k\n    yo = 10 ** 9 + 7\n    y = pow(q, yo - 2, yo)\n    an = y * p % yo\n    yo = 10 ** 9 + 9\n    y = pow(q, yo - 2, yo)\n    an2 = y * p % yo\n    print(an, an2)", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef binpow(a, y, mod):\n    res = 1\n    a = a % mod\n    while y > 0:\n        if y % 2 == 1:\n            res = res * a % mod\n        y = y // 2\n        a = a * a % mod\n    return res\nmod7 = 1000000007\nmod9 = 1000000009\n\ndef inv7(a):\n    return binpow(a, mod7 - 2, mod7)\n\ndef inv9(a):\n    return binpow(a, mod9 - 2, mod9)\nT = int(input())\nfor _ in range(0, T):\n    n = int(input())\n    if n == 1:\n        print(0, 0)\n    else:\n        d = gcd(n * (n - 1), 4 * n - 6)\n        P = n * (n - 1) // d\n        Q = (4 * n - 6) // d\n        print(P * inv7(Q) % mod7, P * inv9(Q) % mod9)", "def inv(n, m):\n    (nn, nm, mn, mm) = (1, 0, 0, 1)\n    while m:\n        (div, mod) = divmod(n, m)\n        nn -= mn * div\n        nm -= mm * div\n        n = mod\n        (n, m) = (m, n)\n        (nn, nm, mn, mm) = (mn, mm, nn, nm)\n    return nn\nP7 = 10 ** 9 + 7\nP9 = 10 ** 9 + 9\n\ndef ans(n, p):\n    n %= p\n    ans = (n - 1) * (n - 1) * n % p\n    ans = ans * inv((2 * n - 2) % p, p) % p\n    ans = ans * inv((2 * n - 3) % p, p) % p\n    return ans\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    if N == 1:\n        print('0 0')\n    else:\n        print('{} {}'.format(ans(N, P7), ans(N, P9)))", "from fractions import gcd\nfor t in range(int(input())):\n    n = int(input())\n    b = n - 1\n    num = b * (b + 1)\n    den = 4 * b - 2\n    g = gcd(num, den)\n    num = num // g\n    den = den // g\n    p = 1000000007\n    y1 = num * pow(den, p - 2, p) % p\n    y2 = num * pow(den, p, p + 2) % (p + 2)\n    if n == 0 or n == 1:\n        print('0 0')\n    else:\n        print(y1, y2)", "def modInverse(a, m):\n    m0 = m\n    x0 = 0\n    x1 = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = x0\n        x0 = x1 - q * x0\n        x1 = t\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nfor i in range(int(input())):\n    n = int(input())\n    p = n * (n - 1) * (n - 1)\n    q = (2 * n - 2) * (2 * n - 3)\n    m1 = 10 ** 9 + 7\n    m2 = 10 ** 9 + 9\n    if p == 0 or q == 0:\n        print('0', '0')\n        continue\n    if p == q:\n        print('1', '1')\n        continue\n    g = gcd(p, q)\n    p = p // g\n    q = q // g\n    print(p * modInverse(q, m1) % m1, p * modInverse(q, m2) % m2)", "MOD1 = 1000000007\nMOD2 = 1000000009\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef modexp(a, b, c):\n    MOD = 3\n    if c == 1:\n        MOD = MOD1\n    else:\n        MOD = MOD2\n    a = int(a % MOD)\n    fin = int(1)\n    ct = 0\n    while b > 0:\n        if b % 2 == 1:\n            fin = fin * a % MOD\n        a = a * a % MOD\n        b = int(b / 2)\n    return fin\n\ndef inverse(a, b):\n    if b == 1:\n        return int(modexp(a, MOD1 - 2, 1))\n    else:\n        return int(modexp(a, MOD2 - 2, 2))\nt = int(input())\nwhile t != 0:\n    t -= 1\n    n = int(input())\n    if n == 1:\n        print('0 0')\n        continue\n    a = int(n * (n - 1))\n    b = int(2 * (2 * n - 3))\n    gf = int(gcd(a, b))\n    print(int(a * inverse(b, 1)) % MOD1, end=' ')\n    print(int(a * inverse(b, 2)) % MOD2)"]