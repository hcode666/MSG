["MOD = 10 ** 9 + 7\n\ndef process(p, num):\n    (g, ln) = ({}, {})\n    for (key, value) in p.items():\n        (last1, next1) = (key[0], key[1] + num)\n        if next1 not in ln:\n            ln[next1] = [(last1, value)]\n        else:\n            ln[next1].append((last1, value))\n        ln[next1].sort()\n    for (next1, ln1) in ln.items():\n        lns = sum((p[1] for p in ln[next1]))\n        (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n        while lnp < K:\n            nkey = (next1, next2)\n            g[nkey] = (g.get(nkey, 0) + lns) % MOD\n            while lnp < K and lastm >= ln1[lnp][0]:\n                lns -= ln1[lnp][1]\n                lnp += 1\n            if next1 == 0:\n                break\n            lastm += 1\n            next1 -= 1\n            next2 += 1\n    return g\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    NS = list(map(int, input().split()))\n    p = {(0, 0): 1}\n    for num in NS:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    print(p[0, 0])", "MOD = 10 ** 9 + 7\n\ndef process(p, num):\n    (g, ln) = ({}, {})\n    for (key, value) in p.items():\n        (last1, next1) = (key[0], key[1] + num)\n        if next1 not in ln:\n            ln[next1] = [(last1, value)]\n        else:\n            ln[next1].append((last1, value))\n        ln[next1].sort()\n    for (next1, ln1) in ln.items():\n        lns = sum((p[1] for p in ln[next1]))\n        (lnp, lastm, next2, K) = (0, 0, 0, len(ln1))\n        while lnp < K:\n            nkey = (next1, next2)\n            g[nkey] = (g.get(nkey, 0) + lns) % MOD\n            while lnp < K and lastm >= ln1[lnp][0]:\n                lns -= ln1[lnp][1]\n                lnp += 1\n            if next1 == 0:\n                break\n            lastm += 1\n            next1 -= 1\n            next2 += 1\n    return g\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    NS = list(map(int, input().split()))\n    p = {(0, 0): 1}\n    for num in NS:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    print(p[0, 0])", "MOD = 10 ** 9 + 7\n\ndef process(p, num):\n    g = {}\n    ln = {}\n    for (key, value) in p.items():\n        (last1, next1) = key\n        next1 += num\n        if next1 not in ln:\n            ln[next1] = [(last1, value)]\n        else:\n            ln[next1].append((last1, value))\n        ln[next1].sort()\n    for (next1, ln1) in ln.items():\n        lns = sum((p[1] for p in ln[next1]))\n        (lnp, lastm, next2) = (0, 0, 0)\n        while lnp < len(ln1):\n            nkey = (next1, next2)\n            g[nkey] = (g.get(nkey, 0) + lns) % MOD\n            while lnp < len(ln1) and lastm >= ln1[lnp][0]:\n                lns -= ln1[lnp][1]\n                lnp += 1\n            if next1 == 0:\n                break\n            lastm += 1\n            next1 -= 1\n            next2 += 1\n    return g\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    NS = list(map(int, input().split()))\n    p = {(0, 0): 1}\n    for num in NS:\n        p = process(p, num)\n    while len(p) > 1 or next(iter(p.keys())) != (0, 0):\n        p = process(p, 0)\n    print(p[0, 0])", "import sys\nM = 10 ** 9 + 7\nmb = 201\n\ndef solve(ss):\n    A = ss\n    t = [[(0, 1)]]\n    for x in A:\n        f = [[] for _ in range(mb)]\n        for (tb, b) in zip(t, range(mb)):\n            if tb:\n                tb.sort(reverse=True)\n                (c, k) = (0, 0)\n                for d in range(min(tb[0][0], b + x), -1, -1):\n                    while k < len(tb) and tb[k][0] >= d:\n                        (c, k) = ((c + tb[k][1]) % M, k + 1)\n                    f[d].append((b + x - d, c))\n        t = f\n    return str(sum(map(lambda v: sum(map(lambda x: x[1], v)), t)))\nfor t in range(int(input())):\n    n = int(input())\n    A = list(map(int, input('').split())) + [0] * 15\n    print(solve(A))", "import sys\nM = 10 ** 9 + 7\nmb = 201\n\ndef solve(ss):\n    A = ss\n    t = [[(0, 1)]]\n    for x in A:\n        f = [[] for _ in range(mb)]\n        for (tb, b) in zip(t, range(mb)):\n            if tb:\n                tb.sort(reverse=True)\n                (c, k) = (0, 0)\n                for d in range(min(tb[0][0], b + x), -1, -1):\n                    while k < len(tb) and tb[k][0] >= d:\n                        (c, k) = ((c + tb[k][1]) % M, k + 1)\n                    f[d].append((b + x - d, c))\n        t = f\n    return str(sum(map(lambda v: sum(map(lambda x: x[1], v)), t)))\nfor t in range(int(input())):\n    n = int(input())\n    A = list(map(int, input('').split())) + [0] * 15\n    print(solve(A))", "MOD = 10 ** 9 + 7\n\ndef process(pg, num):\n    g = {}\n    ln = {}\n    for (key, value) in pg.items():\n        (last_1, next_1) = key\n        next_1 += num\n        if next_1 not in ln:\n            ln[next_1] = [(last_1, value)]\n        else:\n            ln[next_1].append((last_1, value))\n        ln[next_1].sort()\n    for (next_1, ln1) in ln.items():\n        lns = sum((p[1] for p in ln[next_1]))\n        lnp = 0\n        last_m = 0\n        next_2 = 0\n        while lnp < len(ln1):\n            nkey = (next_1, next_2)\n            g[nkey] = (g.get(nkey, 0) + lns) % MOD\n            while lnp < len(ln1) and last_m >= ln1[lnp][0]:\n                lns -= ln1[lnp][1]\n                lnp += 1\n            if next_1 == 0:\n                break\n            last_m += 1\n            next_1 -= 1\n            next_2 += 1\n    return g\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    NS = list(map(int, input().split()))\n    pg = {(0, 0): 1}\n    for num in NS:\n        pg = process(pg, num)\n    while len(pg) > 1 or next(iter(pg.keys())) != (0, 0):\n        pg = process(pg, 0)\n    print(pg[0, 0])", "import sys\nM = 10 ** 9 + 7\nmb = 201\n\ndef solve(ss):\n    A = list(map(int, ss.split())) + [0] * 15\n    t = [[(0, 1)]]\n    for x in A:\n        f = [[] for _ in range(mb)]\n        for (tb, b) in zip(t, range(mb)):\n            if tb:\n                tb.sort(reverse=True)\n                (c, k) = (0, 0)\n                for d in range(min(tb[0][0], b + x), -1, -1):\n                    while k < len(tb) and tb[k][0] >= d:\n                        (c, k) = ((c + tb[k][1]) % M, k + 1)\n                    f[d].append((b + x - d, c))\n        t = f\n    return str(sum(map(lambda v: sum(map(lambda x: x[1], v)), t)))\nprint('\\n'.join(map(solve, sys.stdin.read().split('\\n')[2::2])))"]