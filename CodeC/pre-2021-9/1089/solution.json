["import sys\nsys.setrecursionlimit(999999999)\nfrom collections import defaultdict\n\ndef dfs(node, graph, count, distance):\n    global vis\n    global arr\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1])\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (x, b, c) = map(int, input().split())\n        x -= 1\n        b -= 1\n        graph[x].append([b, c])\n        graph[b].append([x, c])\n    global arr, vis\n    arr = []\n    vis = [False] * n\n    dfs(0, graph, 0, 0)\n    a.sort()\n    ans = 0\n    arr.sort()\n    ans = 0\n    i = 0\n    j = 0\n    while i < m and j < len(arr):\n        if a[i] >= arr[j]:\n            j += 1\n            ans += 1\n        i += 1\n    print(ans)", "import sys\nsys.setrecursionlimit(999999999)\nfrom collections import defaultdict\n\ndef dfs(node, graph, count, distance):\n    global vis\n    global arr\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1])\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (x, b, c) = map(int, input().split())\n        x -= 1\n        b -= 1\n        graph[x].append([b, c])\n        graph[b].append([x, c])\n    global arr, vis\n    arr = []\n    vis = [False] * n\n    dfs(0, graph, 0, 0)\n    a.sort()\n    ans = 0\n    arr.sort()\n    ans = 0\n    i = 0\n    j = 0\n    while i < m and j < len(arr):\n        if a[i] >= arr[j]:\n            j += 1\n            ans += 1\n        i += 1\n    print(ans)", "def finddist():\n    allenergy = list()\n    from collections import deque\n    from queue import Queue\n    q = Queue()\n    q.put(1)\n    distance = defaultdict(int)\n    distance[1] = 1\n    energy = defaultdict(int)\n    while not q.empty():\n        cur = q.get()\n        vis.add(cur)\n        check = 0\n        for neigh in graph[cur]:\n            if neigh[0] not in vis:\n                distance[neigh[0]] = distance[cur] + 1\n                energy[neigh[0]] = distance[cur] * neigh[1] + energy[cur]\n                q.put(neigh[0])\n                check = 1\n        if not check:\n            special.add(cur)\n    for i in special:\n        allenergy.append(energy[i])\n    return allenergy\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    special = set()\n    vis = set()\n    B = finddist()\n    A.sort()\n    B.sort()\n    l = len(B)\n    ind = 0\n    cnt = 0\n    for i in A:\n        if i >= B[ind]:\n            ind += 1\n            cnt += 1\n            if ind >= l:\n                break\n    print(cnt)", "def finddist():\n    allenergy = list()\n    from collections import deque\n    from queue import Queue\n    q = Queue()\n    q.put(1)\n    distance = defaultdict(int)\n    distance[1] = 1\n    energy = defaultdict(int)\n    while not q.empty():\n        cur = q.get()\n        vis.add(cur)\n        check = 0\n        for neigh in graph[cur]:\n            if neigh[0] not in vis:\n                distance[neigh[0]] = distance[cur] + 1\n                energy[neigh[0]] = distance[cur] * neigh[1] + energy[cur]\n                q.put(neigh[0])\n                check = 1\n        if not check:\n            special.add(cur)\n    for i in special:\n        allenergy.append(energy[i])\n    return allenergy\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    special = set()\n    vis = set()\n    B = finddist()\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    ind = 0\n    ans = 0\n    n = len(B)\n    j = 0\n    for i in range(m):\n        while j < n:\n            if A[i] < B[j]:\n                j = j + 1\n            else:\n                break\n        if j == n:\n            break\n        if B[j] <= A[i]:\n            ans = ans + 1\n            j = j + 1\n    print(ans)", "def finddist():\n    allenergy = list()\n    from collections import deque\n    q = deque([1])\n    distance = defaultdict(int)\n    distance[1] = 1\n    energy = defaultdict(int)\n    while len(q) != 0:\n        cur = q.popleft()\n        vis.add(cur)\n        check = 0\n        for neigh in graph[cur]:\n            if neigh[0] not in vis:\n                distance[neigh[0]] = distance[cur] + 1\n                energy[neigh[0]] = distance[cur] * neigh[1] + energy[cur]\n                q.append(neigh[0])\n                check = 1\n        if not check:\n            special.add(cur)\n    for i in special:\n        allenergy.append(energy[i])\n    return allenergy\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    special = set()\n    vis = set()\n    B = finddist()\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    ind = 0\n    ans = 0\n    n = len(B)\n    j = 0\n    for i in range(m):\n        while j < n:\n            if A[i] < B[j]:\n                j = j + 1\n            else:\n                break\n        if j == n:\n            break\n        if B[j] <= A[i]:\n            ans = ans + 1\n            j = j + 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    d = {}\n    dist = {}\n    for i in range(1, n + 1):\n        d[i] = set()\n    for i in range(n - 1):\n        (u, v, k) = map(int, input().split())\n        d[u].add(v)\n        d[v].add(u)\n        dist[u, v] = k\n        dist[v, u] = k\n    visited = set()\n    l = []\n    l.append((1, 0, 0))\n    visited.add(1)\n    count = 0\n    cost = 0\n    e = []\n    while l:\n        (o, c, count) = l.pop(0)\n        num = 0\n        for nbour in d[o]:\n            if nbour not in visited:\n                num = num + 1\n                visited.add(nbour)\n                cost = c + (count + 1) * dist[o, nbour]\n                l.append((nbour, cost, count + 1))\n        if num == 0:\n            e.append(c)\n    arr.sort()\n    e.sort()\n    i = 0\n    ans = 0\n    j = 0\n    ln1 = len(arr)\n    ln2 = len(e)\n    while i < ln1 and j < ln2:\n        if arr[i] >= e[j]:\n            i += 1\n            j += 1\n            ans += 1\n        else:\n            i += 1\n    print(ans)", "import sys\nsys.setrecursionlimit(999999999)\nfrom collections import defaultdict\n\ndef dfs(node, graph, count, distance):\n    global vis\n    global arr\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1])\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (x, b, c) = map(int, input().split())\n        x -= 1\n        b -= 1\n        graph[x].append([b, c])\n        graph[b].append([x, c])\n    global arr, vis\n    arr = []\n    vis = [False] * n\n    dfs(0, graph, 0, 0)\n    a.sort()\n    ans = 0\n    arr.sort()\n    ans = 0\n    i = 0\n    j = 0\n    while i < m and j < len(arr):\n        if a[i] >= arr[j]:\n            j += 1\n            ans += 1\n        i += 1\n    print(ans)", "import sys, math, itertools, random, bisect\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 8)\nINF = 10 ** 18\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.graph = [defaultdict() for x in range(vertices)]\n        self.V = vertices\n\n    def addEdge(self, u, v, w=0):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    def DFSUtil(self, s, visited, store, length, cost):\n        visited[s] = True\n        if len(self.graph[s]) == 1 and s != 0:\n            store.append(cost)\n        for v in self.graph[s]:\n            if visited[v] == False:\n                self.DFSUtil(v, visited, store, length + 1, cost + (length + 1) * self.graph[s][v])\n\n    def DFS(self, s):\n        visited = [False] * self.V\n        store = []\n        self.DFSUtil(s, visited, store, 0, 0)\n        return store\nfor _ in range(int(input())):\n    (n, m) = get_ints()\n    a = get_array()\n    g = Graph(n)\n    for i in range(n - 1):\n        (u, v, w) = get_ints()\n        g.addEdge(u - 1, v - 1, w)\n    store = g.DFS(0)\n    store.sort()\n    a.sort()\n    (i, j) = (0, 0)\n    ans = 0\n    while i < m and j < len(store):\n        if a[i] >= store[j]:\n            ans += 1\n            j += 1\n        i += 1\n    print(ans)", "import sys, math, itertools, random, bisect\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\nINF = 10 ** 18\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.graph = [defaultdict() for x in range(vertices)]\n        self.V = vertices\n\n    def addEdge(self, u, v, w=0):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    def DFSUtil(self, s, visited, store, length, cost):\n        visited[s] = True\n        if len(self.graph[s]) == 1 and s != 0:\n            store.append(cost)\n        for v in self.graph[s]:\n            if visited[v] == False:\n                self.DFSUtil(v, visited, store, length + 1, cost + (length + 1) * self.graph[s][v])\n\n    def DFS(self, s):\n        visited = [False] * self.V\n        store = []\n        self.DFSUtil(s, visited, store, 0, 0)\n        return store\nfor _ in range(int(input())):\n    (n, m) = get_ints()\n    a = get_array()\n    g = Graph(n)\n    for i in range(n - 1):\n        (u, v, w) = get_ints()\n        g.addEdge(u - 1, v - 1, w)\n    store = g.DFS(0)\n    store.sort()\n    a.sort()\n    (i, j) = (0, 0)\n    ans = 0\n    while i < m and j < len(store):\n        if a[i] >= store[j]:\n            ans += 1\n            j += 1\n        i += 1\n    print(ans)", "import sys\nsys.setrecursionlimit(999999999)\nfrom collections import defaultdict\n\ndef dfs(node, graph, count, distance):\n    global vis\n    global arr\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1])\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (x, b, c) = map(int, input().split())\n        x -= 1\n        b -= 1\n        graph[x].append([b, c])\n        graph[b].append([x, c])\n    global arr, vis\n    arr = []\n    vis = [False] * n\n    dfs(0, graph, 0, 0)\n    a.sort()\n    ans = 0\n    arr.sort()\n    ans = 0\n    i = 0\n    j = 0\n    while i < m and j < len(arr):\n        if a[i] >= arr[j]:\n            j += 1\n            ans += 1\n        i += 1\n    print(ans)", "from collections import deque\n\ndef ints():\n    return map(int, input().split())\n\ndef bfs(v):\n    vis = set([v])\n    depth = {v: 1}\n    dp = {v: 0}\n    q = deque([v])\n    while q:\n        curr = q.popleft()\n        for (nbr, w) in graph[curr]:\n            if nbr not in vis:\n                vis.add(nbr)\n                q.append(nbr)\n                depth[nbr] = depth[curr] + 1\n                dp[nbr] = w * depth[curr] + dp[curr]\n    return (depth, dp)\nt = int(input())\nfor _ in range(t):\n    (n, m) = ints()\n    pil = list(ints())\n    graph = {i + 1: [] for i in range(n)}\n    for i in range(n - 1):\n        (a, b, w) = ints()\n        graph[a].append((b, w))\n        graph[b].append((a, w))\n    (depth, dp) = bfs(1)\n    maxx = max(depth.values())\n    ans = []\n    for e in dp:\n        if len(graph[e]) == 1 and e != 1:\n            ans.append(dp[e])\n    ans = sorted(ans)\n    (i, j) = (0, 0)\n    pil.sort()\n    while i < len(pil) and j < len(ans):\n        if pil[i] >= ans[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n    print(j)", "import sys\nfrom collections import defaultdict\n\ndef pr(n):\n    sys.stdout.write(str(n))\n    sys.stdout.write('\\n')\n\ndef inp1():\n    return int(sys.stdin.readline())\n\ndef inp2():\n    return list(map(int, sys.stdin.readline().split()))\nimport queue\n\ndef pt(graph, V, x):\n    level = [None] * V\n    marked = [False] * V\n    ans = [0] * V\n    que = queue.Queue()\n    que.put(x)\n    level[x] = 0\n    marked[x] = True\n    while not que.empty():\n        x = que.get()\n        for i in range(len(graph[x])):\n            b = graph[x][i][0]\n            if not marked[b]:\n                que.put(b)\n                level[b] = level[x] + 1\n                ans[b] = level[b] * graph[x][i][1] + ans[x]\n                marked[b] = True\n    return ans\nfor _ in range(int(input())):\n    (k, n) = inp2()\n    l = inp2()\n    G = [[] for i in range(k)]\n    for i in range(k - 1):\n        (x, y, w) = inp2()\n        G[x - 1].append([y - 1, w])\n        G[y - 1].append([x - 1, w])\n    g = pt(G, k, 0)\n    pq = []\n    for i in range(k):\n        if len(G[i]) == 1 and i != 0:\n            pq.append(i)\n    lt = []\n    for i in pq:\n        lt.append(g[i])\n    lt.sort()\n    f = len(lt)\n    l.sort()\n    ans = 0\n    j = 0\n    for i in range(n):\n        if j < f and l[i] >= lt[j]:\n            j += 1\n            ans += 1\n    print(ans)", "def dfs(node, parent):\n    s = set()\n    visited[1] = True\n    stack = [[node, parent]]\n    levelarray[node] = 1\n    while stack:\n        (node, parent) = stack.pop()\n        levelarray[node] += levelarray[parent]\n        costarray[node] = costarray[node] + costarray[parent]\n        flag = 1\n        for (child, cost) in g[node]:\n            if visited[child] == False and child != parent:\n                costarray[child] += levelarray[node] * cost\n                flag = 0\n                visited[child] = True\n                levelarray[child] += 1\n                stack.append([child, node])\n        if flag == 1:\n            s.add(node)\n    return s\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    g = {i: [] for i in range(1, n + 1)}\n    s = set()\n    visited = [False for i in range(n + 1)]\n    levelarray = [0 for i in range(n + 1)]\n    costarray = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, c) = map(int, input().split())\n        g[u].append([v, c])\n        g[v].append([u, c])\n    s = dfs(1, 0)\n    p = [costarray[i] for i in s]\n    ans = 0\n    p.sort()\n    a = len(p)\n    l.sort()\n    i = 0\n    ans = 0\n    j = 0\n    while i < m and j < a:\n        if l[i] < p[j]:\n            i += 1\n        else:\n            i += 1\n            j += 1\n            ans += 1\n    print(ans)", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n    (n, m) = mp()\n    l = li()\n    d = defaultdict(list)\n    v = [0, 0]\n    for i in range(n - 1):\n        (a, b, c) = mp()\n        d[a].append([b, c])\n        d[b].append([a, c])\n        v.append(0)\n    q = deque()\n    v[1] = 1\n    special = []\n    q.append((1, 1, 0))\n    backup = defaultdict(int)\n    backup[1] = 0\n    while q:\n        (x, y, s) = q.popleft()\n        if x != 1 and len(d[x]) == 1:\n            special.append(s)\n        for i in d[x]:\n            (fu, ck) = i\n            if not v[fu]:\n                v[fu] = 1\n                backup[fu] = s + y * ck\n                q.append((fu, y + 1, backup[fu]))\n    special.sort()\n    a = len(special)\n    l.sort()\n    i = 0\n    ans = 0\n    j = 0\n    while i < m and j < a:\n        if l[i] < special[j]:\n            i += 1\n        else:\n            i += 1\n            j += 1\n            ans += 1\n    pr(ans)\nfor _ in range(inp()):\n    solve()", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p, prev, val, d):\n    for i in child[p]:\n        if i[0] != prev:\n            dfs(i[0], p, val + i[1] * d, d + 1)\n    if len(child[p]) == 1 and prev != 0:\n        x.append(val)\n\ndef answer():\n    (ans, ind) = (0, 0)\n    for i in range(len(x)):\n        for j in range(ind, len(e)):\n            if e[j] >= x[i]:\n                ind = j + 1\n                ans += 1\n                break\n    return ans\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    e = sorted(list(map(int, input().split())))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, k) = map(int, input().split())\n        child[u].append([v, k])\n        child[v].append([u, k])\n    x = []\n    dfs(1, 0, 0, 1)\n    x.sort()\n    print(answer())", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p, prev, val, d):\n    for i in child[p]:\n        if i[0] != prev:\n            dfs(i[0], p, val + i[1] * d, d + 1)\n    if len(child[p]) == 1 and prev != 0:\n        x.append(val)\n\ndef answer():\n    (ans, ind) = (0, 0)\n    for i in range(len(x)):\n        for j in range(ind, len(e)):\n            if e[j] >= x[i]:\n                ind = j + 1\n                ans += 1\n                break\n        if j >= len(e):\n            break\n    return ans\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    e = sorted(list(map(int, input().split())))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, k) = map(int, input().split())\n        child[u].append([v, k])\n        child[v].append([u, k])\n    x = []\n    dfs(1, 0, 0, 1)\n    x.sort()\n    print(answer())", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p, prev, val, d):\n    for i in child[p]:\n        if i[0] != prev:\n            dfs(i[0], p, val + i[1] * d, d + 1)\n    if len(child[p]) == 1 and prev != 0:\n        x.append(val)\n\ndef answer():\n    ans = 0\n    (i, j) = (0, 0)\n    while i < len(x) and j < len(e):\n        if x[i] <= e[j]:\n            ans += 1\n            i += 1\n            j += 1\n        else:\n            i += 1\n    return ans\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    e = sorted(list(map(int, input().split())), reverse=True)\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, k) = map(int, input().split())\n        child[u].append([v, k])\n        child[v].append([u, k])\n    x = []\n    dfs(1, 0, 0, 1)\n    x.sort(reverse=True)\n    print(answer())", "def dfs(node, parent):\n    s = set()\n    visited[1] = True\n    stack = [[node, parent]]\n    levelarray[node] = 1\n    while stack:\n        (node, parent) = stack.pop()\n        levelarray[node] += levelarray[parent]\n        costarray[node] = costarray[node] + costarray[parent]\n        flag = 1\n        for (child, cost) in g[node]:\n            if visited[child] == False and child != parent:\n                costarray[child] += levelarray[node] * cost\n                flag = 0\n                visited[child] = True\n                levelarray[child] += 1\n                stack.append([child, node])\n        if flag == 1:\n            s.add(node)\n    return s\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    g = {i: [] for i in range(1, n + 1)}\n    s = set()\n    visited = [False for i in range(n + 1)]\n    levelarray = [0 for i in range(n + 1)]\n    costarray = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, c) = map(int, input().split())\n        g[u].append([v, c])\n        g[v].append([u, c])\n    s = dfs(1, 0)\n    p = float('inf')\n    mn = []\n    ans = 0\n    for i in s:\n        mn.append(costarray[i])\n    mn.sort(reverse=True)\n    l.sort(reverse=True)\n    i = 0\n    j = 0\n    l1 = len(mn)\n    while i < l1 and j < m:\n        if mn[i] > l[j]:\n            i += 1\n        else:\n            i += 1\n            ans += 1\n            j += 1\n    print(ans)", "import sys, math, itertools, random, bisect\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\nINF = 10 ** 18\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.graph = [defaultdict() for x in range(vertices)]\n        self.V = vertices\n\n    def addEdge(self, u, v, w=0):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    def DFSUtil(self, s, visited, store, length, cost):\n        visited[s] = True\n        if len(self.graph[s]) == 1 and s != 0:\n            store.append(cost)\n        for v in self.graph[s]:\n            if visited[v] == False:\n                self.DFSUtil(v, visited, store, length + 1, cost + (length + 1) * self.graph[s][v])\n\n    def DFS(self, s):\n        visited = [False] * self.V\n        store = []\n        self.DFSUtil(s, visited, store, 0, 0)\n        return store\nfor _ in range(int(input())):\n    (n, m) = get_ints()\n    a = get_array()\n    g = Graph(n)\n    for i in range(n - 1):\n        (u, v, w) = get_ints()\n        g.addEdge(u - 1, v - 1, w)\n    store = g.DFS(0)\n    store.sort()\n    a.sort()\n    (i, j) = (0, 0)\n    ans = 0\n    while i < m and j < len(store):\n        if a[i] >= store[j]:\n            ans += 1\n            j += 1\n        i += 1\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 8)\n\ndef dfs(node, e, parent, d):\n    isLeaf = True\n    for (v, k) in Edges[node]:\n        if v != parent:\n            dfs(v, e + k * d, node, d + 1)\n            isLeaf = False\n    if isLeaf:\n        SCE.append(e)\nt = int(input())\nfor tc in range(t):\n    (n, m) = map(int, input().split())\n    PE = [0] + list(map(int, input().split()))\n    Edges = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, k) = map(int, input().split())\n        Edges[u].append([v, k])\n        Edges[v].append([u, k])\n    SCE = []\n    dfs(1, 0, 0, 1)\n    count = 0\n    PE = sorted(PE)\n    SCE = sorted(SCE)\n    j = m\n    for i in range(len(SCE) - 1, -1, -1):\n        if j > 0 and SCE[i] <= PE[j]:\n            count += 1\n            j -= 1\n    print(count)", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 6)\nfrom queue import PriorityQueue\nfrom math import gcd\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\n\ndef dfs(u, par, d):\n    if len(adj[u]) == 1 and u != 0:\n        mn.append(a[u])\n        return\n    for [i, j] in adj[u]:\n        if i == par:\n            continue\n        a[i] = a[u] + d * j\n        dfs(i, u, d + 1)\nfor _ in range(ii()):\n    (n, m) = il()\n    e = il()\n    a = [0 for i in range(n)]\n    adj = [[] for i in range(n)]\n    mn = []\n    for i in range(n - 1):\n        (x, y, k) = il()\n        x -= 1\n        y -= 1\n        adj[x].append([y, k])\n        adj[y].append([x, k])\n    dfs(0, -1, 1)\n    e.sort(reverse=True)\n    mn.sort(reverse=True)\n    ans = 0\n    i = 0\n    j = 0\n    l1 = len(mn)\n    while i < l1 and j < m:\n        if mn[i] > e[j]:\n            i += 1\n        else:\n            i += 1\n            ans += 1\n            j += 1\n    print(ans)", "import math, bisect as bi, sys, resource\nfrom collections import defaultdict as dd, deque as dq\n\ndef I():\n    return int(sys.stdin.readline())\n\ndef In():\n    return map(int, sys.stdin.readline().split())\n\ndef Sn():\n    return stdin.readline().strip()\nresource.setrlimit(resource.RLIMIT_STACK, (2 ** 29, -1))\nsys.setrecursionlimit(10 ** 6)\n\ndef yes():\n    print('YES')\n\ndef no():\n    print('NO')\n\ndef find_ge(a, x):\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    raise len(a) - 1\n\ndef dfs(node, cost, parent):\n    dp[node] = dp[parent] + cost * high[node]\n    if len(gp[node]) == 1:\n        if parent == gp[node][0][0]:\n            leaf.append(dp[node])\n    for (x, val) in gp[node]:\n        if high[x] == -1:\n            high[x] = high[node] + 1\n            dfs(x, val, node)\n\ndef main():\n    try:\n        global n, m, dp, gp, leaf, high\n        (n, m) = In()\n        pril = list(In())\n        pril.sort()\n        dp = [0] * (n + 1)\n        high = [-1] * (n + 1)\n        high[1] = 0\n        leaf = []\n        gp = dd(list)\n        for i in range(n - 1):\n            (a, b, c) = In()\n            gp[a].append((b, c))\n            gp[b].append((a, c))\n        dfs(1, 0, 1)\n        leaf.sort()\n        ans = 0\n        j = 0\n        for i in range(len(pril)):\n            if j < len(leaf) and leaf[j] <= pril[i]:\n                ans += 1\n                j += 1\n        print(ans)\n    except:\n        pass\nM = 998244353\nP = 1000000007\nTEST = I()\nfor _ in range(TEST):\n    main()", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef traverse(n, m, adjList, sp, src, visited, u, prev):\n    if len(adjList[src]) == 1 and visited[adjList[src][0][0]]:\n        sp.append(prev)\n    else:\n        for a in adjList[src]:\n            if not visited[a[0]]:\n                visited[a[0]] = True\n                traverse(n, m, adjList, sp, a[0], visited, u + 1, prev + a[1] * u)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    e = sorted(list(map(int, input().split())))\n    adjList = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (a, b, k) = map(int, input().split())\n        a -= 1\n        b -= 1\n        adjList[a].append([b, k])\n        adjList[b].append([a, k])\n    sp = []\n    visited = [False] * n\n    visited[0] = True\n    traverse(n, m, adjList, sp, 0, visited, 1, 0)\n    sp.sort()\n    i = 0\n    j = 0\n    while i < len(e) and j < len(sp):\n        if sp[j] <= e[i]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n    print(j)", "import sys, os\nfrom io import BytesIO, IOBase\nmod = 10 ** 9 + 7\nMod = 998244353\nINF = float('inf')\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\ninp = lambda : list(map(int, sys.stdin.readline().rstrip('\\r\\n').split()))\nsys.setrecursionlimit(100000 + 10)\ntc = 1\ntc = int(input())\nfor test in range(1, tc + 1):\n    (n, m) = inp()\n    a = inp()\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        (p, q, d) = inp()\n        g[p - 1].append((q - 1, d))\n        g[q - 1].append((p - 1, d))\n    ans = [INF] * n\n\n    def dfs(node, dis, par, res):\n        if len(g[node]) == 1 and g[node][0][0] == par:\n            ans[node - 1] = res\n        else:\n            for to in g[node]:\n                if to[0] == par:\n                    continue\n                dfs(to[0], dis + 1, node, res + dis * to[1])\n    a.sort()\n    res = 0\n    dfs(0, 1, -1, 0)\n    ans.sort()\n    i = 0\n    j = 0\n    while i < m:\n        if a[i] < ans[j]:\n            i += 1\n        else:\n            res += 1\n            i += 1\n            j += 1\n    print(res)", "import sys\nfrom sys import stdin, stdout\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom collections import deque\ntest = int(input())\nfor _ in range(test):\n    (n, m) = map(int, input().split())\n    energy = list(map(int, input().split()))\n    dic = {}\n    graph = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b, x) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        if a > b:\n            (a, b) = (b, a)\n        dic[a, b] = x\n        graph[a].append(b)\n        graph[b].append(a)\n    dp = [0] * n\n    level = dd(list)\n    dist = [0] * n\n    visited = [False] * n\n    parent = [-1] * n\n    leaf = []\n    src = 0\n    q = deque([])\n    q.append(src)\n    visited[src] = True\n    dist[src] = 1\n    while q:\n        node = q.popleft()\n        l = True\n        for neighbour in graph[node]:\n            if not visited[neighbour]:\n                l = False\n                q.append(neighbour)\n                visited[neighbour] = True\n                dist[neighbour] = dist[node] + 1\n                parent[neighbour] = node\n                level[dist[neighbour]].append(neighbour)\n                (a, b) = (node, neighbour)\n                if a > b:\n                    (a, b) = (b, a)\n                val = dic[a, b]\n                dp[neighbour] = dp[node] + dist[node] * val\n        if l:\n            leaf.append(node)\n    cur = []\n    for i in leaf:\n        cur.append(dp[i])\n    cur.sort()\n    energy.sort()\n    cur = cur[::-1]\n    energy = energy[::-1]\n    pt1 = 0\n    pt2 = 0\n    ans = 0\n    while pt1 < len(energy) and pt2 < len(cur):\n        if energy[pt1] >= cur[pt2]:\n            ans += 1\n            pt1 += 1\n            pt2 += 1\n        else:\n            pt2 += 1\n    print(ans)", "import sys\nsys.setrecursionlimit(1000001)\n\ndef dfs(start, par, ln, val):\n    foo = 0\n    ln += 1\n    for child in adj[start]:\n        if child[0] != par:\n            foo = 1\n            amt = child[1]\n            dfs(child[0], start, ln, val + ln * amt)\n    if foo == 0:\n        arr.append(val)\nfor y in range(int(input())):\n    (n, m) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    adj = []\n    for i in range(n):\n        adj.append([])\n    for i in range(n - 1):\n        (a, b, c) = map(int, input().split())\n        adj[a - 1].append([b - 1, c])\n        adj[b - 1].append([a - 1, c])\n    arr = []\n    dfs(0, -1, 0, 0)\n    arr.sort()\n    lst.sort()\n    i = 0\n    cnt = 0\n    j = 0\n    ln1 = len(lst)\n    ln2 = len(arr)\n    while i < ln1 and j < ln2:\n        if lst[i] >= arr[j]:\n            i += 1\n            j += 1\n            cnt += 1\n        else:\n            i += 1\n    print(cnt)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log2, ceil\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom bisect import insort\nfrom collections import Counter\nfrom collections import deque\nfrom collections import OrderedDict as od\nfrom heapq import heappush, heappop, heapify\nfrom itertools import permutations, combinations\nfrom itertools import accumulate as ac\nmod = int(1000000000.0) + 7\n\ndef addEdge(a, b):\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef Bfs(src):\n    q = deque([])\n    q.append(src)\n    visited[src] = True\n    dist[src] = 1\n    dp\n    while q:\n        node = q.popleft()\n        l = True\n        for neighbour in graph[node]:\n            if not visited[neighbour]:\n                l = False\n                q.append(neighbour)\n                visited[neighbour] = True\n                dist[neighbour] = dist[node] + 1\n                parent[neighbour] = node\n                level[dist[neighbour]].append(neighbour)\n                (a, b) = (node, neighbour)\n                if a > b:\n                    (a, b) = (b, a)\n                val = dic[a, b]\n                dp[neighbour] = dp[node] + dist[node] * val\n        if l:\n            leaf.append(node)\nip = lambda : int(stdin.readline())\ninp = lambda : map(int, stdin.readline().split())\nips = lambda : stdin.readline().rstrip()\nout = lambda x: stdout.write(str(x) + '\\n')\nt = ip()\nfor _ in range(t):\n    (n, m) = inp()\n    energy = list(inp())\n    dic = {}\n    graph = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b, x) = inp()\n        (a, b) = (a - 1, b - 1)\n        if a > b:\n            (a, b) = (b, a)\n        dic[a, b] = x\n        addEdge(a, b)\n    dp = [0] * n\n    level = dd(list)\n    dist = [0] * n\n    visited = [False] * n\n    parent = [-1] * n\n    leaf = []\n    Bfs(0)\n    cur = []\n    for i in leaf:\n        cur.append(dp[i])\n    cur.sort(reverse=True)\n    energy.sort(reverse=True)\n    pt1 = 0\n    pt2 = 0\n    ans = 0\n    while pt1 < len(energy) and pt2 < len(cur):\n        if energy[pt1] >= cur[pt2]:\n            ans += 1\n            pt1 += 1\n            pt2 += 1\n        else:\n            pt2 += 1\n    print(ans)"]