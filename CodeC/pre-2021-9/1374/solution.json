["import math\nimport bisect\nT = int(input())\nwhile T > 0:\n    T -= 1\n    (N, Q) = map(int, input().split(' '))\n    B = [] * Q\n    A = list(map(int, input().split(' ')))\n    for i in range(0, Q):\n        B.append(int(input()))\n    A = sorted(A)\n    c = 0\n    V = []\n    m = A[0] + 1\n    V.append(m)\n    r = 2\n    for i in range(1, N):\n        if r > A[i]:\n            r = 2 * (r - A[i])\n            V.append(m)\n        else:\n            c = math.floor((A[i] - r) / 2 ** i) + 1\n            m += c\n            V.append(m)\n            r = 2 * (r + 2 ** i * c - A[i])\n    for q in B:\n        print(bisect.bisect_right(V, q))", "import math\nimport bisect\nT = int(input())\nwhile T > 0:\n    T -= 1\n    (N, Q) = map(int, input().split(' '))\n    B = [] * Q\n    A = list(map(int, input().split(' ')))\n    for i in range(0, Q):\n        B.append(int(input()))\n    A = sorted(A)\n    c = 0\n    V = []\n    m = A[0] + 1\n    V.append(m)\n    r = 2\n    for i in range(1, N):\n        if r > A[i]:\n            r = 2 * (r - A[i])\n            V.append(m)\n        else:\n            c = math.floor((A[i] - r) / 2 ** i) + 1\n            m += c\n            V.append(m)\n            r = 2 * (r + 2 ** i * c - A[i])\n    for q in B:\n        print(bisect.bisect_right(V, q))", "import math\nimport bisect\nT = int(input())\nwhile T > 0:\n    T -= 1\n    (N, Q) = map(int, input().split(' '))\n    B = [] * Q\n    A = list(map(int, input().split(' ')))\n    for i in range(0, Q):\n        B.append(int(input()))\n    A = sorted(A)\n    c = 0\n    V = []\n    m = A[0] + 1\n    V.append(m)\n    r = 2\n    for i in range(1, N):\n        if r > A[i]:\n            r = 2 * (r - A[i])\n            V.append(m)\n        else:\n            c = math.floor((A[i] - r) / 2 ** i) + 1\n            m += c\n            V.append(m)\n            r = 2 * (r + 2 ** i * c - A[i])\n    for q in B:\n        print(bisect.bisect_right(V, q))", "import math\nimport bisect\nT = int(input())\nfor t in range(0, T):\n    line = input().split()\n    n = int(line[0])\n    q = int(line[1])\n    warriors = input().split()\n    warriors = list(map(int, warriors))\n    warriors.sort()\n    queries = []\n    for i in range(0, q):\n        queries.insert(i, int(input()))\n    minW = []\n    Min = warriors[0] + 1\n    minW.append(Min)\n    rem = 2\n    for i in range(1, n):\n        if rem > warriors[i]:\n            rem = 2 * (rem - warriors[i])\n            minW.append(Min)\n        else:\n            c = math.floor((warriors[i] - rem) / 2 ** i) + 1\n            Min += c\n            minW.append(Min)\n            rem = 2 * (rem + 2 ** i * c - warriors[i])\n    for q in queries:\n        print(bisect.bisect_right(minW, q))", "from bisect import bisect_left, bisect_right\nlife_limit = 2 * 10 ** 9\nT = int(input())\nfor test in range(T):\n    (N, Q) = [int(v) for v in input().split()]\n    P = [int(v) for v in input().split()]\n    P.sort()\n    data = []\n    killed = 1\n    X = P[0] + 1\n    life = 2\n    power = 2\n    while True:\n        while killed < N and life > P[killed] and (life <= life_limit):\n            life = 2 * (life - P[killed])\n            killed += 1\n            power *= 2\n        if life > life_limit or killed == N:\n            data.append((X, N))\n            break\n        data.append((X, killed))\n        needed = (P[killed] - life) // power + 1\n        X += needed\n        life = 2 * (life + needed * power - P[killed])\n        killed += 1\n        power *= 2\n    for query in range(Q):\n        X = int(input())\n        pos = bisect_right(data, (X + 1, 0)) - 1\n        if pos == -1:\n            print(0)\n        else:\n            print(data[pos][1])", "import math\nimport bisect\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split(' '))\n    p = [int(y) for y in input().split()]\n    p.sort()\n    z1 = p[0]\n    z2 = z1 + 1\n    reminder = 2\n    min_power = [z2]\n    for i1 in range(1, n):\n        z1 = p[i1]\n        if reminder <= z1:\n            diff = z1 - reminder\n            inc = math.floor(diff / 2 ** i1)\n            inc = inc + 1\n            reminder = 2 ** i1 * inc + reminder\n            z2 = z2 + inc\n        min_power.append(z2)\n        reminder = 2 * (reminder - z1)\n    for i2 in range(q):\n        x = int(input())\n        ans = bisect.bisect_right(min_power, x)\n        print(ans)", "import math\nimport bisect\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split(' '))\n    p = [int(y) for y in input().split()]\n    p.sort()\n    z1 = p[0]\n    z2 = z1 + 1\n    reminder = 2\n    min_power = [z2]\n    for i1 in range(1, n):\n        z1 = p[i1]\n        if reminder <= z1:\n            diff = z1 - reminder\n            inc = math.floor(diff / 2 ** i1)\n            inc = inc + 1\n            reminder = 2 ** i1 * inc + reminder\n            z2 = z2 + inc\n        min_power.append(z2)\n        reminder = 2 * (reminder - z1)\n    for i2 in range(q):\n        x = int(input())\n        ans = bisect.bisect_right(min_power, x)\n        print(ans)", "from sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(2 ** 27)\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\nclass MergeFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            (a, b) = (b, a)\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + '\\n')\n\ndef prime_factors(n):\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return factors\n\ndef all_factors(n):\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\ndef fibonacci_modP(n, MOD):\n    if n < 2:\n        return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n, p):\n    if p <= n:\n        return 0\n    res = p - 1\n    for i in range(n + 1, p):\n        res = res * cached_fn(InverseEuler, i, p) % p\n    return res\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\ndef is_prime(n):\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\nfactorial_modP = []\n\ndef warm_up_fac(MOD):\n    global factorial_modP, fac_warm_up\n    if fac_warm_up:\n        return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = factorial_modP[i - 1] * i % MOD\n    fac_warm_up = True\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\ndef nCr(n, r, MOD):\n    global fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return factorial_modP[n] * (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD) % MOD) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=' '):\n    stdout.write(sep.join(map(str, list1)) + '\\n')\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm += i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nmemory = dict()\n\ndef clear_cache():\n    global memory\n    memory = dict()\n\ndef cached_fn(fn, *args):\n    global memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:\n            x += b\n        b = b // 2\n    return x\nTestCases = True\nfac_warm_up_size = 10 ** 5 + 100\noptimise_for_recursion = False\n\ndef main():\n    (n, q) = get_tuple()\n    li = get_list()\n    li.sort()\n    dp = [[li[0] + 1, 2]]\n    for (i, ele) in enumerate(li):\n        if i == 0:\n            continue\n        sp = dp[-1][1]\n        sp_global = dp[-1][0]\n        if sp <= ele:\n            x = (ele - sp) // 2 ** i + 1\n            sp_global += x\n            sp += x * 2 ** i\n        dp.append([sp_global, 2 * (sp - ele)])\n    for _ in range(q):\n        query = get_int()\n        index = bisect_left(dp, [query + 1, 0])\n        print(index)\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()"]