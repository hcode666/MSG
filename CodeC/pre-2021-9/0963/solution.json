["from collections import deque\nfor _ in range(int(input())):\n    (n, m, k1, k2) = list(map(int, input().split()))\n    arr = []\n    for i in range(n):\n        arr.append(list(map(int, input().split())))\n    robo1 = [[-1] * m for i in range(n)]\n    robo2 = [[-1] * m for i in range(n)]\n    robo1[0][0] = 0\n    robo2[0][m - 1] = 0\n    Q = deque([(0, 0)])\n    while Q:\n        (i, j) = Q.popleft()\n        for x in range(max(i - k1, 0), min(i + k1 + 1, n)):\n            t = abs(i - x)\n            for y in range(max(0, j - k1 + t), min(j + k1 - t + 1, m)):\n                if arr[x][y] == 0 and robo1[x][y] == -1:\n                    robo1[x][y] = robo1[i][j] + 1\n                    Q.append((x, y))\n    Q = deque([(0, m - 1)])\n    while Q:\n        (i, j) = Q.popleft()\n        for x in range(max(i - k2, 0), min(i + k2 + 1, n)):\n            t = abs(i - x)\n            for y in range(max(0, j - k2 + t), min(j + k2 - t + 1, m)):\n                if arr[x][y] == 0 and robo2[x][y] == -1:\n                    robo2[x][y] = robo2[i][j] + 1\n                    Q.append((x, y))\n    ans = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if robo1[i][j] != -1 and robo2[i][j] != -1:\n                ans = min(ans, max(robo1[i][j], robo2[i][j]))\n    print(-1 if ans == float('inf') else ans)", "from collections import deque\nfor _ in range(int(input())):\n    (n, m, k1, k2) = list(map(int, input().split()))\n    arr = []\n    for i in range(n):\n        arr.append(list(map(int, input().split())))\n    robo1 = [[-1] * m for i in range(n)]\n    robo2 = [[-1] * m for i in range(n)]\n    robo1[0][0] = 0\n    robo2[0][m - 1] = 0\n    Q = deque([(0, 0)])\n    while Q:\n        (i, j) = Q.popleft()\n        for x in range(max(i - k1, 0), min(i + k1 + 1, n)):\n            t = abs(i - x)\n            for y in range(max(0, j - k1 + t), min(j + k1 - t + 1, m)):\n                if arr[x][y] == 0 and robo1[x][y] == -1:\n                    robo1[x][y] = robo1[i][j] + 1\n                    Q.append((x, y))\n    Q = deque([(0, m - 1)])\n    while Q:\n        (i, j) = Q.popleft()\n        for x in range(max(i - k2, 0), min(i + k2 + 1, n)):\n            t = abs(i - x)\n            for y in range(max(0, j - k2 + t), min(j + k2 - t + 1, m)):\n                if arr[x][y] == 0 and robo2[x][y] == -1:\n                    robo2[x][y] = robo2[i][j] + 1\n                    Q.append((x, y))\n    ans = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if robo1[i][j] != -1 and robo2[i][j] != -1:\n                ans = min(ans, max(robo1[i][j], robo2[i][j]))\n    print(-1 if ans == float('inf') else ans)", "(a, b) = (0, 1)\nfor t in range(int(input())):\n    k = [None] * 2\n    (n, m, k[a], k[b]) = [int(i) for i in input().split()]\n    visited = [{(0, 0)}, {(0, m - 1)}]\n    minmoves = [{(0, 0): 0}, {(0, m - 1): 0}]\n    blocked = set()\n    for i in range(n):\n        row = [int(i) for i in input().split()]\n        for j in range(m):\n            if row[j] == 1:\n                blocked.add((i, j))\n    movetemplate = [set(), set()]\n    for r in range(2):\n        for x in range(-1 * k[r], k[r] + 1):\n            for y in range(-1 * k[r] + abs(x), k[r] - abs(x) + 1):\n                movetemplate[r].add((x, y))\n        movetemplate[r].remove((0, 0))\n    now = [{(0, 0)}, {(0, m - 1)}]\n    c = 1\n\n    def applymoves(r):\n        nxt = set()\n        for p0 in now[r]:\n            for move in movetemplate[r]:\n                p1 = (p0[0] + move[0], p0[1] + move[1])\n                if p1[0] >= 0 and p1[0] < n and (p1[1] >= 0) and (p1[1] < m):\n                    if not p1 in visited[r] and (not p1 in blocked):\n                        visited[r].add(p1)\n                        minmoves[r][p1] = c\n                        nxt.add(p1)\n        return nxt\n    r = 0\n    while True:\n        now[r] = applymoves(r)\n        if not (now[a] or now[b]) or visited[a] & visited[b]:\n            break\n        c += 1 if r == 1 else 0\n        r = (r + 1) % 2\n    if visited[a] & visited[b]:\n        p = (visited[a] & visited[b]).pop()\n        print(max(minmoves[a][p], minmoves[b][p]))\n    else:\n        print(-1)", "def calc(grid, n, m, x1, y1, k1, x2, y2, k2):\n    res1 = [[-1 for j in range(m)] for i in range(n)]\n    res2 = [[-1 for j in range(m)] for i in range(n)]\n    res1[x1][y1] = 0\n    res2[x2][y2] = 0\n    q1 = []\n    q2 = []\n    directions = [[1, 1], [-1, -1], [1, -1], [-1, 1]]\n    q1.append([x1, y1])\n    q2.append([x2, y2])\n    while len(q1) > 0 or len(q2) > 0:\n        if len(q1) > 0:\n            nq1 = []\n            for pos in q1:\n                for jump in range(1, k1 + 1):\n                    for hor in range(0, jump + 1):\n                        for d in directions:\n                            newPos = [pos[0] + hor * d[0], pos[1] + (jump - hor) * d[1]]\n                            if newPos[0] >= 0 and newPos[0] < n and (newPos[1] >= 0) and (newPos[1] < m):\n                                if grid[newPos[0]][newPos[1]] == 0:\n                                    if res1[newPos[0]][newPos[1]] == -1:\n                                        res1[newPos[0]][newPos[1]] = res1[pos[0]][pos[1]] + 1\n                                        nq1.append(newPos)\n                                    if res2[newPos[0]][newPos[1]] != -1:\n                                        print(max(res1[newPos[0]][newPos[1]], res2[newPos[0]][newPos[1]]))\n                                        return\n            q1 = nq1\n        if len(q2) > 0:\n            nq2 = []\n            for pos in q2:\n                for jump in range(1, k2 + 1):\n                    for hor in range(0, jump + 1):\n                        for d in directions:\n                            newPos = [pos[0] + hor * d[0], pos[1] + (jump - hor) * d[1]]\n                            if newPos[0] >= 0 and newPos[0] < n and (newPos[1] >= 0) and (newPos[1] < m):\n                                if grid[newPos[0]][newPos[1]] == 0:\n                                    if res2[newPos[0]][newPos[1]] == -1:\n                                        res2[newPos[0]][newPos[1]] = res2[pos[0]][pos[1]] + 1\n                                        nq2.append(newPos)\n                                    if res1[newPos[0]][newPos[1]] != -1:\n                                        print(max(res1[newPos[0]][newPos[1]], res2[newPos[0]][newPos[1]]))\n                                        return\n            q2 = nq2\n    print(-1)\nT = int(input())\nfor t in range(T):\n    p = [int(x) for x in input().split(' ')]\n    n = p[0]\n    m = p[1]\n    k1 = p[2]\n    k2 = p[3]\n    grid = [[int(x) for x in input().split(' ')] for i in range(n)]\n    calc(grid, n, m, 0, 0, k1, 0, m - 1, k2)", "def ans(l, n, m, k1):\n    x = {(0, 0): 0}\n    l1 = [(0, 0)]\n    l[0][0] = 1\n    while len(l1) > 0:\n        (i, j) = l1[0]\n        l1 = l1[1:]\n        i1 = max(0, i - k1)\n        while i1 <= min(i + k1, n - 1):\n            ip = abs(i - i1)\n            j1 = max(0, j - k1 + ip)\n            while j1 <= min(j + k1 - ip, m - 1):\n                if l[i1][j1] == 0:\n                    if abs(i1 - i) + abs(j1 - j) <= k1:\n                        x[i1, j1] = x[i, j] + 1\n                        l1 += [(i1, j1)]\n                        l[i1][j1] = 1\n                    if (i1, j1) == (0, m - 1):\n                        j1 = 10 ** 9\n                        i1 = 10 ** 9\n                        l1 = []\n                j1 += 1\n            i1 += 1\n    return x\n\ndef ans1(l, n, m, k1):\n    x = {(0, m - 1): 0}\n    l1 = [(0, m - 1)]\n    l[0][m - 1] = 1\n    while len(l1) > 0:\n        (i, j) = l1[0]\n        l1 = l1[1:]\n        i1 = max(0, i - k1)\n        while i1 <= min(i + k1, n - 1):\n            ip = abs(i - i1)\n            j1 = max(0, j - k1 + ip)\n            while j1 <= min(j + k1 - ip, m - 1):\n                if l[i1][j1] == 0:\n                    if abs(i1 - i) + abs(j1 - j) <= k1:\n                        x[i1, j1] = x[i, j] + 1\n                        l1 += [(i1, j1)]\n                        l[i1][j1] = 1\n                    if (i1, j1) == (0, 0):\n                        j1 = 10 ** 9\n                        i1 = 10 ** 9\n                        l1 = []\n                j1 += 1\n            i1 += 1\n    return x\n\ndef unshared_copy(inList):\n    if isinstance(inList, list):\n        return list(map(unshared_copy, inList))\n    return inList\n\ndef a(l, m, n, k1, k2):\n    ll = unshared_copy(l)\n    x1 = ans(ll, m, n, k1)\n    x2 = ans1(l, m, n, k2)\n    x = 10 ** 9\n    f = 1\n    for k in x1:\n        if k in x2:\n            x = min(x, max(x1[k], x2[k]))\n            f = 0\n    if f == 1:\n        return -1\n    else:\n        return x\nt = int(input())\nwhile t != 0:\n    t -= 1\n    (n, m, k1, k2) = map(int, input().split())\n    l = []\n    i = 0\n    while i < n:\n        l += [list(map(int, input().split()))]\n        i += 1\n    print(a(l, n, m, k1, k2))", "T = int(input())\nwhile T > 0:\n    T -= 1\n    (N, M, K1, K2) = [int(x) for x in input().split()]\n    c = N\n    mat = []\n    while c > 0:\n        c -= 1\n        r = [int(x) for x in input().split()]\n        mat.append(r)\n    pmoves1 = {(0, 0): 0}\n    pmoves2 = {(0, M - 1): 0}\n    uncover1 = set([(0, 0)])\n    uncover2 = set([(0, M - 1)])\n    mcnt1 = mcnt2 = 1\n    Complete1 = Complete2 = False\n    while not Complete1 or not Complete2:\n        tmp = set()\n        while uncover1:\n            e = uncover1.pop()\n            for i in range(K1 + 1):\n                for j in range(K1 + 1):\n                    if i + j <= K1:\n                        if e[0] + i < N and e[1] + j < M and ((e[0] + i, e[1] + j) not in pmoves1) and (mat[e[0] + i][e[1] + j] == 0):\n                            tmp.add((e[0] + i, e[1] + j))\n                            pmoves1[e[0] + i, e[1] + j] = mcnt1\n                        if e[0] - i >= 0 and e[1] + j < M and ((e[0] - i, e[1] + j) not in pmoves1) and (mat[e[0] - i][e[1] + j] == 0):\n                            tmp.add((e[0] - i, e[1] + j))\n                            pmoves1[e[0] - i, e[1] + j] = mcnt1\n                        if e[0] + i < N and e[1] - j >= 0 and ((e[0] + i, e[1] - j) not in pmoves1) and (mat[e[0] + i][e[1] - j] == 0):\n                            tmp.add((e[0] + i, e[1] - j))\n                            pmoves1[e[0] + i, e[1] - j] = mcnt1\n                        if e[0] - i >= 0 and e[1] - j >= 0 and ((e[0] - i, e[1] - j) not in pmoves1) and (mat[e[0] - i][e[1] - j] == 0):\n                            tmp.add((e[0] - i, e[1] - j))\n                            pmoves1[e[0] - i, e[1] - j] = mcnt1\n        if tmp:\n            uncover1 = tmp.copy()\n            mcnt1 += 1\n        else:\n            Complete1 = True\n        tmp = set()\n        while uncover2:\n            e = uncover2.pop()\n            for i in range(K2 + 1):\n                for j in range(K2 + 1):\n                    if i + j <= K2:\n                        if e[0] + i < N and e[1] + j < M and ((e[0] + i, e[1] + j) not in pmoves2) and (mat[e[0] + i][e[1] + j] == 0):\n                            tmp.add((e[0] + i, e[1] + j))\n                            pmoves2[e[0] + i, e[1] + j] = mcnt2\n                        if e[0] - i >= 0 and e[1] + j < M and ((e[0] - i, e[1] + j) not in pmoves2) and (mat[e[0] - i][e[1] + j] == 0):\n                            tmp.add((e[0] - i, e[1] + j))\n                            pmoves2[e[0] - i, e[1] + j] = mcnt2\n                        if e[0] + i < N and e[1] - j >= 0 and ((e[0] + i, e[1] - j) not in pmoves2) and (mat[e[0] + i][e[1] - j] == 0):\n                            tmp.add((e[0] + i, e[1] - j))\n                            pmoves2[e[0] + i, e[1] - j] = mcnt2\n                        if e[0] - i >= 0 and e[1] - j >= 0 and ((e[0] - i, e[1] - j) not in pmoves2) and (mat[e[0] - i][e[1] - j] == 0):\n                            tmp.add((e[0] - i, e[1] - j))\n                            pmoves2[e[0] - i, e[1] - j] = mcnt2\n        if tmp:\n            uncover2 = tmp.copy()\n            mcnt2 += 1\n        else:\n            Complete2 = True\n        if set(pmoves1.keys()) & set(pmoves2.keys()):\n            break\n    meet_points = set(pmoves1.keys()) & set(pmoves2.keys())\n    moves = []\n    for point in meet_points:\n        moves.append(max(pmoves1[point], pmoves2[point]))\n    if moves:\n        print(min(moves))\n    else:\n        print(-1)"]