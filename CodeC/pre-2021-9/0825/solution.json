["from heapq import heappush, heappop\n\ndef solve():\n    (n, D) = map(int, input().split())\n    data = {}\n    heap = []\n    for i in range(n):\n        (d, t, s) = map(int, input().split())\n        if d in data:\n            data[d].append([t, s])\n        else:\n            data[d] = [[t, s]]\n    for d in range(1, D + 1):\n        if d in data:\n            for v in data[d]:\n                heappush(heap, [-1 * v[1], v[0]])\n        if len(heap):\n            x = heappop(heap)\n            x[1] -= 1\n            if x[1]:\n                heappush(heap, x)\n    ans = 0\n    while len(heap):\n        x = heappop(heap)\n        ans += -1 * x[0] * x[1]\n    return ans\nfor _ in range(int(input())):\n    print(solve())", "from heapq import heappush, heappop\n\ndef solve():\n    (n, D) = map(int, input().split())\n    data = {}\n    heap = []\n    for i in range(n):\n        (d, t, s) = map(int, input().split())\n        if d in data:\n            data[d].append([t, s])\n        else:\n            data[d] = [[t, s]]\n    for d in range(1, D + 1):\n        if d in data:\n            for v in data[d]:\n                heappush(heap, [-1 * v[1], v[0]])\n        if len(heap):\n            x = heappop(heap)\n            x[1] -= 1\n            if x[1]:\n                heappush(heap, x)\n    ans = 0\n    while len(heap):\n        x = heappop(heap)\n        ans += -1 * x[0] * x[1]\n    return ans\nfor _ in range(int(input())):\n    print(solve())", "from heapq import heapify, heappop, heappush\nimport sys\ninput = sys.stdin.readline\nfrom math import sqrt\nfrom collections import defaultdict\n\ndef I():\n    return list(map(int, input().split()))\nfor _ in range(int(input())):\n    (n, d) = I()\n    days = defaultdict(list)\n    for i in range(n):\n        (di, ti, si) = I()\n        days[di].append((si, ti))\n    heap = []\n    for day in range(1, d + 1):\n        for (si, ti) in days[day]:\n            heappush(heap, (-si, -ti))\n        if heap:\n            (si, ti) = heappop(heap)\n            if ti != -1:\n                heappush(heap, (si, ti + 1))\n    ans = 0\n    for (si, ti) in heap:\n        ans += -si * -ti\n    print(ans)", "from heapq import heapify, heappop, heappush\nimport sys\ninput = sys.stdin.readline\nfrom math import sqrt\nfrom collections import defaultdict\n\ndef I():\n    return list(map(int, input().split()))\nfor _ in range(int(input())):\n    (n, d) = I()\n    days = defaultdict(list)\n    for i in range(n):\n        (di, ti, si) = I()\n        days[di].append((si, ti))\n    heap = []\n    for day in range(1, d + 1):\n        for (si, ti) in days[day]:\n            heappush(heap, (-si, -ti))\n        if heap:\n            (si, ti) = heappop(heap)\n            if ti != -1:\n                heappush(heap, (si, ti + 1))\n    ans = 0\n    for (si, ti) in heap:\n        ans += -si * -ti\n    print(ans)", "from heapq import heapify, heappop, heappush\nimport sys\ninput = sys.stdin.readline\nfrom math import sqrt\nfrom collections import defaultdict\n\ndef I():\n    return list(map(int, input().split()))\nfor _ in range(int(input())):\n    (n, d) = I()\n    days = defaultdict(list)\n    for i in range(n):\n        (di, ti, si) = I()\n        days[di].append((si, ti))\n    heap = []\n    for day in range(1, d + 1):\n        for (si, ti) in days[day]:\n            heappush(heap, (-si, -ti))\n        if heap:\n            (si, ti) = heappop(heap)\n            if ti != -1:\n                heappush(heap, (si, ti + 1))\n    ans = 0\n    for (si, ti) in heap:\n        ans += -si * -ti\n    print(ans)", "from heapq import heapify, heappop, heappush\nimport sys\ninput = sys.stdin.readline\nfrom math import sqrt\nfrom collections import defaultdict\n\ndef I():\n    return list(map(int, input().split()))\nfor _ in range(int(input())):\n    (n, d) = I()\n    days = defaultdict(list)\n    for i in range(n):\n        (di, ti, si) = I()\n        days[di].append((si, ti))\n    heap = []\n    for day in range(1, d + 1):\n        for (si, ti) in days[day]:\n            heappush(heap, (-si, -ti))\n        if heap:\n            (si, ti) = heappop(heap)\n            if ti != -1:\n                heappush(heap, (si, ti + 1))\n    ans = 0\n    for (si, ti) in heap:\n        ans += -si * -ti\n    print(ans)", "from heapq import heappush, heappop\nt = int(input())\nfor _ in range(t):\n    (n, d) = map(int, input().split())\n    days = {}\n    for i in range(n):\n        (a, b, c) = map(int, input().split())\n        if a not in days:\n            days[a] = []\n        days[a].append((-1 * c, b))\n    h = list()\n    for i in range(1, d + 1):\n        if i in days:\n            for v in days[i]:\n                heappush(h, v)\n        if len(h) > 0:\n            (y, z) = heappop(h)\n            if z > 1:\n                heappush(h, (y, z - 1))\n    ans = 0\n    for i in h:\n        ans += -1 * i[0] * i[1]\n    print(ans)", "from collections import defaultdict\nimport heapq as hp\nT = int(input())\nfor t in range(T):\n    (n, d) = map(int, input().split())\n    arr = []\n    heap = defaultdict(list)\n    for _ in range(n):\n        (di, ti, si) = map(int, input().split())\n        heap[di].append([-si, ti])\n    for i in range(1, d + 1):\n        for j in heap[i]:\n            hp.heappush(arr, j)\n        if len(arr):\n            curr = hp.heappop(arr)\n            curr[1] -= 1\n            if curr[1] != 0:\n                hp.heappush(arr, curr)\n    ans = 0\n    for i in arr:\n        ans += -i[0] * i[1]\n    print(ans)", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(tuple(map(int, input().split())))\n    arr.sort()\n    hp = []\n    j = 0\n    for i in range(1, d + 1):\n        while j < len(arr) and arr[j][0] <= i:\n            heappush(hp, [-arr[j][2], arr[j][1]])\n            j += 1\n        if len(hp) > 0:\n            hp[0][1] -= 1\n            if hp[0][1] <= 0:\n                heappop(hp)\n    sum = 0\n    for i in hp:\n        sum += i[0] * i[1]\n    print(abs(sum))", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    (n, d) = list(map(int, input().split()))\n    ip = []\n    total_sadness = 0\n    for i in range(n):\n        ip.append(list(map(int, input().split())))\n        total_sadness += ip[i][2] * ip[i][1]\n    ip.sort()\n    ptr = 0\n    hp = []\n    for i in range(d):\n        while ptr < len(ip) and ip[ptr][0] <= i + 1:\n            heappush(hp, (-ip[ptr][2], ip[ptr][1]))\n            ptr += 1\n        if len(hp) != 0:\n            (a, b) = heappop(hp)\n            total_sadness += a\n            b -= 1\n            if b != 0:\n                heappush(hp, (a, b))\n    print(total_sadness)", "from heapq import heappop, heappush\ntest = int(input())\nfor t in range(test):\n    (N, D) = map(int, input().split())\n    l = []\n    ans = 0\n    for i in range(N):\n        (d, t, s) = map(int, input().split())\n        ans = ans + t * s\n        l.append([d, s, t])\n    l.sort(key=lambda x: x[0])\n    j = 0\n    heap = []\n    for i in range(1, D + 1):\n        while j < N and l[j][0] == i:\n            heappush(heap, (-l[j][1], l[j][2]))\n            j += 1\n        if heap != []:\n            (val, t) = heappop(heap)\n            ans += val\n            t -= 1\n            if t:\n                heappush(heap, (val, t))\n    print(ans)", "import bisect\nfor _ in range(int(input())):\n    (n, s) = map(int, input().split())\n    l = []\n    sol = 0\n    for i in range(n):\n        (di, ti, si) = map(int, input().split())\n        l.append([di, ti, si])\n    l.sort(key=lambda x: x[-1])\n    l = l[::-1]\n    tot = [i for i in range(s + 1)]\n    for i in range(len(l)):\n        if tot == [0]:\n            break\n        else:\n            temp = bisect.bisect_left(tot, l[i][0])\n            r = len(tot) - temp\n            temp2 = temp + min(r, l[i][1])\n            l[i][1] -= min(l[i][1], r)\n            del tot[temp:temp2]\n    for i in range(n):\n        sol += l[i][1] * l[i][2]\n    print(sol)", "from collections import defaultdict\nimport heapq as hq\nfor i in range(int(input())):\n    (n, d) = [int(number) for number in input().split()]\n    h = []\n    heap = defaultdict(list)\n    for i in range(n):\n        (di, nl, s) = [int(number) for number in input().split()]\n        heap[di].append([-s, nl])\n    for i in range(1, d + 1):\n        for j in heap[i]:\n            hq.heappush(h, j)\n        if h != []:\n            popva = hq.heappop(h)\n            popva[1] -= 1\n            if popva[1] != 0:\n                hq.heappush(h, popva)\n    print(sum([-i[0] * i[1] for i in h]))", "from collections import defaultdict\nimport heapq as hp\nfor i in range(int(input())):\n    (n, d) = [int(num) for num in input().split()]\n    h = []\n    heap = defaultdict(list)\n    for i in range(n):\n        (di, nl, s) = [int(num) for num in input().split()]\n        heap[di].append([-s, nl])\n    for i in range(1, d + 1):\n        for j in heap[i]:\n            hp.heappush(h, j)\n        if h != []:\n            p = hp.heappop(h)\n            p[1] -= 1\n            if p[1] != 0:\n                hp.heappush(h, p)\n    print(sum([-i[0] * i[1] for i in h]))", "from collections import defaultdict\nimport heapq as hp\nfor i in range(int(input())):\n    (n, d) = [int(num) for num in input().split()]\n    h = []\n    heap = defaultdict(list)\n    for i in range(n):\n        (di, listl, s) = [int(num) for num in input().split()]\n        heap[di].append([-s, listl])\n    for i in range(1, d + 1):\n        for j in heap[i]:\n            hp.heappush(h, j)\n        if h != []:\n            popedelement = hp.heappop(h)\n            popedelement[1] -= 1\n            if popedelement[1] != 0:\n                hp.heappush(h, popedelement)\n    print(sum([-i[0] * i[1] for i in h]))", "from collections import defaultdict\nimport heapq as hq\nfor i in range(int(input())):\n    (n, d) = [int(number) for number in input().split()]\n    h = []\n    heap = defaultdict(list)\n    for i in range(n):\n        (di, nl, s) = [int(number) for number in input().split()]\n        heap[di].append([-s, nl])\n    for i in range(1, d + 1):\n        for j in heap[i]:\n            hq.heappush(h, j)\n        if h != []:\n            popva = hq.heappop(h)\n            popva[1] -= 1\n            if popva[1] != 0:\n                hq.heappush(h, popva)\n    print(sum([-i[0] * i[1] for i in h]))", "from collections import defaultdict\nimport heapq as hp\nfor i in range(int(input())):\n    (n, d) = [int(num) for num in input().split()]\n    l = []\n    heap = defaultdict(list)\n    for i in range(n):\n        (di, nl, s) = [int(num) for num in input().split()]\n        heap[di].append([-s, nl])\n    for i in range(1, d + 1):\n        for j in heap[i]:\n            hp.heappush(l, j)\n        if l != []:\n            a = hp.heappop(l)\n            a[1] -= 1\n            if a[1] != 0:\n                hp.heappush(l, a)\n    print(sum([-i[0] * i[1] for i in l]))", "from collections import defaultdict\nimport heapq\nfor _ in range(int(input())):\n    (n, d) = [int(x) for x in input().split()]\n    h = []\n    heap = defaultdict(list)\n    for i in range(n):\n        (di, nl, s) = [int(x) for x in input().split()]\n        heap[di].append([-s, nl])\n    for i in range(1, d + 1):\n        for j in heap[i]:\n            heapq.heappush(h, j)\n        if h != []:\n            pp = heapq.heappop(h)\n            pp[1] -= 1\n            if pp[1] != 0:\n                heapq.heappush(h, pp)\n    print(sum([-i[0] * i[1] for i in h]))", "from heapq import *\ntc = int(input())\nfor _ in range(tc):\n    (n, d) = list(map(int, input().split()))\n    dts = []\n    total_sadness = 0\n    for i in range(n):\n        dts.append(list(map(int, input().split())))\n        total_sadness += dts[i][2] * dts[i][1]\n    dts.sort()\n    ptr = 0\n    hp = []\n    for i in range(d):\n        while ptr < len(dts) and dts[ptr][0] <= i + 1:\n            heappush(hp, (-dts[ptr][2], dts[ptr][1]))\n            ptr += 1\n        if len(hp) != 0:\n            (k, v) = heappop(hp)\n            total_sadness += k\n            v -= 1\n            if v != 0:\n                heappush(hp, (k, v))\n    print(total_sadness)", "from collections import defaultdict\nimport heapq as hp\nfor i in range(int(input())):\n    (n, d) = [int(num) for num in input().split()]\n    h = []\n    heap = defaultdict(list)\n    for i in range(n):\n        (di, nl, s) = [int(num) for num in input().split()]\n        heap[di].append([-s, nl])\n    for i in range(1, d + 1):\n        for j in heap[i]:\n            hp.heappush(h, j)\n        if h != []:\n            popva = hp.heappop(h)\n            popva[1] -= 1\n            if popva[1] != 0:\n                hp.heappush(h, popva)\n    print(sum([-i[0] * i[1] for i in h]))", "import heapq\n\nclass Trainer:\n    d: int\n    t: int\n    s: int\n\n    def __init__(self, d: int, t: int, s: int):\n        self.d = d\n        self.t = t\n        self.s = s\n\ndef minimum_sadness(n, d, trainers):\n    trainers = sorted(trainers, key=lambda trainer: trainer.d)\n    trainer_idx = 0\n    h = []\n    for di in range(1, d + 1):\n        while trainer_idx < n and trainers[trainer_idx].d <= di:\n            heapq.heappush(h, (-trainers[trainer_idx].s, trainer_idx, trainers[trainer_idx]))\n            trainer_idx += 1\n        if len(h) == 0:\n            continue\n        heap_element = heapq.heappop(h)\n        trainer_id = heap_element[1]\n        trainer = heap_element[2]\n        trainer.t -= 1\n        if trainer.t > 0:\n            heapq.heappush(h, (-trainer.s, trainer_id, trainer))\n    return sum([heap_element[2].s * heap_element[2].t for heap_element in h])\ntest = int(input())\nfor test in range(test):\n    (n, d) = [int(x) for x in input().split(' ')]\n    lst = []\n    trainers = []\n    for line in range(n):\n        (di, ti, si) = [int(x) for x in input().split(' ')]\n        trainers.append(Trainer(d=di, t=ti, s=si))\n    print('%d' % minimum_sadness(n, d, trainers))", "import heapq\n\nclass Trainer:\n    d: int\n    t: int\n    s: int\n\n    def __init__(self, d: int, t: int, s: int):\n        self.d = d\n        self.t = t\n        self.s = s\n\ndef minimum_sadness(n, d, trainers):\n    trainers = sorted(trainers, key=lambda trainer: trainer.d)\n    trainer_idx = 0\n    h = []\n    for di in range(1, d + 1):\n        while trainer_idx < n and trainers[trainer_idx].d <= di:\n            heapq.heappush(h, (-trainers[trainer_idx].s, trainer_idx, trainers[trainer_idx]))\n            trainer_idx += 1\n        if len(h) == 0:\n            continue\n        heap_element = heapq.heappop(h)\n        trainer_id = heap_element[1]\n        trainer = heap_element[2]\n        trainer.t -= 1\n        if trainer.t > 0:\n            heapq.heappush(h, (-trainer.s, trainer_id, trainer))\n    return sum([heap_element[2].s * heap_element[2].t for heap_element in h])\ntest_cases = int(input())\nfor test in range(test_cases):\n    (n, d) = [int(x) for x in input().split(' ')]\n    trainers = []\n    for line in range(n):\n        (di, ti, si) = [int(x) for x in input().split(' ')]\n        trainers.append(Trainer(d=di, t=ti, s=si))\n    print('%d' % minimum_sadness(n, d, trainers))", "import heapq\n\nclass Trainer:\n    d: int\n    t: int\n    s: int\n\n    def __init__(self, d: int, t: int, s: int):\n        self.d = d\n        self.t = t\n        self.s = s\n\ndef minimum_sadness(n, d, trainers):\n    trainers = sorted(trainers, key=lambda trainer: trainer.d)\n    trainer_idx = 0\n    h = []\n    for di in range(1, d + 1):\n        while trainer_idx < n and trainers[trainer_idx].d <= di:\n            heapq.heappush(h, (-trainers[trainer_idx].s, trainer_idx, trainers[trainer_idx]))\n            trainer_idx += 1\n        if len(h) == 0:\n            continue\n        heap_element = heapq.heappop(h)\n        trainer_id = heap_element[1]\n        trainer = heap_element[2]\n        trainer.t -= 1\n        if trainer.t > 0:\n            heapq.heappush(h, (-trainer.s, trainer_id, trainer))\n    return sum([heap_element[2].s * heap_element[2].t for heap_element in h])\ntest_cases = int(input())\nfor test in range(test_cases):\n    (n, d) = [int(x) for x in input().split(' ')]\n    trainers = []\n    for line in range(n):\n        (di, ti, si) = [int(x) for x in input().split(' ')]\n        trainers.append(Trainer(d=di, t=ti, s=si))\n    print('%d' % minimum_sadness(n, d, trainers))", "from collections import defaultdict\nimport heapq as hp\nfor _ in range(int(input())):\n    (n, d) = [int(num) for num in input().split()]\n    hl = []\n    heap = defaultdict(list)\n    for _ in range(n):\n        (di, nl, sl) = [int(num) for num in input().split()]\n        heap[di].append([-sl, nl])\n    for i in range(1, d + 1):\n        for j in heap[i]:\n            hp.heappush(hl, j)\n        if hl != []:\n            popval = hp.heappop(hl)\n            popval[1] -= 1\n            if popval[1] != 0:\n                hp.heappush(hl, popval)\n    print(sum([-i[0] * i[1] for i in hl]))", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    (n, d) = list(map(int, input().split()))\n    ip = []\n    total_sadness = 0\n    for i in range(n):\n        ip.append(list(map(int, input().split())))\n        total_sadness += ip[i][2] * ip[i][1]\n    ip.sort()\n    ptr = 0\n    hp = []\n    for i in range(d):\n        while ptr < len(ip) and ip[ptr][0] <= i + 1:\n            heappush(hp, (-ip[ptr][2], ip[ptr][1]))\n            ptr += 1\n        if len(hp) != 0:\n            (a, b) = heappop(hp)\n            total_sadness += a\n            b -= 1\n            if b != 0:\n                heappush(hp, (a, b))\n    print(total_sadness)", "import sys\nimport heapq\nfrom collections import deque\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_list_strings():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef solve(N, D, arr):\n    heap = []\n    arr.sort()\n    queue = deque()\n    for ele in arr:\n        queue.append(ele)\n    for i in range(1, D + 1):\n        while queue:\n            if queue[0][0] == i:\n                heapq.heappush(heap, [-queue[0][2], -queue[0][1]])\n                queue.popleft()\n            else:\n                break\n        if len(heap) == 0:\n            continue\n        current = heapq.heappop(heap)\n        s = abs(current[0])\n        c = abs(current[1]) - 1\n        if c > 0:\n            heapq.heappush(heap, [-s, -c])\n    ans = 0\n    for ele in heap:\n        ans += ele[0] * ele[1]\n    print(ans)\n    return\nT = get_int()\nwhile T:\n    (N, D) = get_ints()\n    tempN = N\n    arr = []\n    while tempN:\n        (Di, Ti, Si) = get_ints()\n        arr.append([Di, Ti, Si])\n        tempN -= 1\n    solve(N, D, arr)\n    T -= 1", "import sys\nimport heapq\nfrom collections import deque\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_list_strings():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef solve(N, D, arr):\n    heap = []\n    arr.sort()\n    queue = deque()\n    for ele in arr:\n        queue.append(ele)\n    for i in range(1, D + 1):\n        while queue:\n            if queue[0][0] == i:\n                heapq.heappush(heap, [-queue[0][2], -queue[0][1]])\n                queue.popleft()\n            else:\n                break\n        if len(heap) == 0:\n            continue\n        current = heapq.heappop(heap)\n        s = abs(current[0])\n        c = abs(current[1]) - 1\n        if c > 0:\n            heapq.heappush(heap, [-s, -c])\n    ans = 0\n    for ele in heap:\n        ans += ele[0] * ele[1]\n    print(ans)\n    return\nT = get_int()\nwhile T:\n    (N, D) = get_ints()\n    tempN = N\n    arr = []\n    while tempN:\n        (Di, Ti, Si) = get_ints()\n        arr.append([Di, Ti, Si])\n        tempN -= 1\n    solve(N, D, arr)\n    T -= 1", "import sys\nimport heapq\nfrom collections import deque\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_list_strings():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef solve(N, D, arr):\n    heap = []\n    arr.sort()\n    queue = deque()\n    for ele in arr:\n        queue.append(ele)\n    for i in range(1, D + 1):\n        while queue:\n            if queue[0][0] == i:\n                heapq.heappush(heap, [-queue[0][2], -queue[0][1]])\n                queue.popleft()\n            else:\n                break\n        if len(heap) == 0:\n            continue\n        current = heapq.heappop(heap)\n        s = abs(current[0])\n        c = abs(current[1]) - 1\n        if c > 0:\n            heapq.heappush(heap, [-s, -c])\n    ans = 0\n    for ele in heap:\n        ans += ele[0] * ele[1]\n    print(ans)\n    return\nT = get_int()\nwhile T:\n    (N, D) = get_ints()\n    tempN = N\n    arr = []\n    while tempN:\n        (Di, Ti, Si) = get_ints()\n        arr.append([Di, Ti, Si])\n        tempN -= 1\n    solve(N, D, arr)\n    T -= 1", "from heapq import heappush, heappop, heapify, heapreplace\nT = int(input())\nwhile T > 0:\n    T -= 1\n    minHeapDays = []\n    maxHeapSadness = []\n    (N, D) = [int(x) for x in input().split()]\n    total = 0\n    for i in range(N):\n        (d, t, s) = [int(x) for x in input().split()]\n        heappush(minHeapDays, (d, [d, t, s]))\n        total += s * t\n    sum1 = 0\n    for i in range(1, D + 1):\n        while len(minHeapDays) > 0 and minHeapDays[0][0] == i:\n            x = heappop(minHeapDays)\n            heappush(maxHeapSadness, (-x[1][2], x[1]))\n        if len(maxHeapSadness) > 0:\n            x = heappop(maxHeapSadness)\n            x[1][1] -= 1\n            if x[1][1] > 0:\n                heappush(maxHeapSadness, x)\n            sum1 += x[1][2]\n    print(total - sum1)", "import heapq\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    lst = []\n    for i in range(n):\n        (day, lec, sad) = map(int, input().split())\n        lst.append([day, lec, sad])\n    lst.sort()\n    heap = []\n    i = 0\n    for day in range(1, d + 1):\n        while i < n and lst[i][0] <= day:\n            heapq.heappush(heap, (-lst[i][2], lst[i][1]))\n            i += 1\n        if len(heap) > 0:\n            (sadness, lect) = heapq.heappop(heap)\n            lect -= 1\n            if lect > 0:\n                heapq.heappush(heap, (sadness, lect))\n    ans = 0\n    for i in range(len(heap)):\n        (sadness, lect) = heap[i]\n        ans -= sadness * lect\n    print(ans)", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, d) = map(int, input().split())\n    lst = []\n    for i in range(n):\n        (day, lec, sad) = map(int, input().split())\n        lst.append([day, lec, sad])\n    lst.sort()\n    heap = []\n    i = 0\n    for day in range(1, d + 1):\n        while i < n and lst[i][0] <= day:\n            heapq.heappush(heap, (-lst[i][2], lst[i][1]))\n            i += 1\n        if len(heap) > 0:\n            (sadness, lect) = heapq.heappop(heap)\n            lect -= 1\n            if lect > 0:\n                heapq.heappush(heap, (sadness, lect))\n    ans = 0\n    for i in range(len(heap)):\n        (sadness, lect) = heap[i]\n        ans -= sadness * lect\n    print(ans)", "from heapq import heappop, heappush\ntest_cases = int(input())\nfor _ in range(test_cases):\n    (size, days) = map(int, input().split())\n    arr = []\n    for __ in range(size):\n        (day, lecture, sad) = map(int, input().split())\n        arr.append([day, lecture, sad])\n    arr.sort()\n    heap = []\n    i = 0\n    for day in range(1, days + 1):\n        while i < size and arr[i][0] <= day:\n            heappush(heap, (-arr[i][2], arr[i][1]))\n            i += 1\n        if len(heap) > 0:\n            (sadness, lect) = heappop(heap)\n            lect -= 1\n            if lect > 0:\n                heappush(heap, (sadness, lect))\n    ans = 0\n    for i in range(len(heap)):\n        (sadnees, lect) = heap[i]\n        ans -= sadnees * lect\n    print(ans)", "import heapq\nfor i in range(int(input())):\n    (n, da) = map(int, input().split())\n    d = {}\n    for i in range(n):\n        (x, y, z) = map(int, input().split())\n        if x not in d:\n            d[x] = []\n        d[x].append([-z, y])\n    h = []\n    for i in range(da):\n        if i + 1 in d:\n            for i in d[i + 1]:\n                heapq.heappush(h, i)\n        if h:\n            k = heapq.heappop(h)\n            if k[-1] > 1:\n                k[-1] -= 1\n                heapq.heappush(h, k)\n    ans = 0\n    for i in h:\n        ans += i[0] * i[1]\n    print(-ans)", "import heapq\nT = int(input())\nfor i in range(T):\n    (n, d) = map(int, input().split())\n    a = list()\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        a.append(temp)\n    a = sorted(a, key=lambda x: x[0])\n    h = []\n    j = 0\n    for i in range(1, d + 1):\n        curr = []\n        while j < n:\n            if a[j][0] == i:\n                curr.append(a[j])\n            else:\n                break\n            j += 1\n        for k in range(len(curr)):\n            heapq.heappush(h, [-1 * curr[k][-1], curr[k]])\n        if len(h) > 0:\n            g = heapq.heappop(h)\n            if g[1][1] > 1:\n                g[1][1] -= 1\n                heapq.heappush(h, g)\n    hl = len(h)\n    sadness = 0\n    for i in range(hl):\n        sadness += h[i][0] * -1 * h[i][1][1]\n    print(sadness)", "import heapq\nT = int(input())\nfor i in range(T):\n    (n, d) = map(int, input().split())\n    a = list()\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        a.append(temp)\n    a = sorted(a, key=lambda x: x[0])\n    h = []\n    j = 0\n    for i in range(1, d + 1):\n        curr = []\n        while j < n:\n            if a[j][0] == i:\n                curr.append(a[j])\n            else:\n                break\n            j += 1\n        for k in range(len(curr)):\n            heapq.heappush(h, [-1 * curr[k][-1], curr[k]])\n        if len(h) > 0:\n            g = heapq.heappop(h)\n            if g[1][1] > 1:\n                g[1][1] -= 1\n                heapq.heappush(h, g)\n    hl = len(h)\n    sadness = 0\n    for i in range(hl):\n        sadness += h[i][0] * -1 * h[i][1][1]\n    print(sadness)", "import heapq\nfrom sys import stdin\ninput = stdin.readline\n\ndef answer():\n    (q, ind) = ([], 0)\n    for days in range(1, d + 1):\n        while ind < n and a[ind][0] == days:\n            heapq.heappush(q, [a[ind][2], a[ind][1]])\n            ind += 1\n        if len(q):\n            (value, r) = heapq.heappop(q)\n            r -= 1\n            if r:\n                heapq.heappush(q, [value, r])\n    ans = 0\n    while len(q):\n        (value, r) = heapq.heappop(q)\n        ans += value * r * -1\n    return ans\nfor T in range(int(input())):\n    (n, d) = map(int, input().split())\n    a = []\n    for i in range(n):\n        (days, r, s) = map(int, input().split())\n        a.append([days, r, -s])\n    a.sort(key=lambda x: x[0])\n    print(answer())", "import heapq\nT = int(input())\nfor i in range(T):\n    (n, d) = map(int, input().split())\n    a = list()\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        a.append(temp)\n    a = sorted(a, key=lambda x: x[0])\n    h = []\n    j = 0\n    for i in range(1, d + 1):\n        curr = []\n        while j < n:\n            if a[j][0] == i:\n                curr.append(a[j])\n            else:\n                break\n            j += 1\n        for k in range(len(curr)):\n            heapq.heappush(h, [-1 * curr[k][-1], curr[k]])\n        if len(h) > 0:\n            g = heapq.heappop(h)\n            if g[1][1] > 1:\n                g[1][1] -= 1\n                heapq.heappush(h, g)\n    hl = len(h)\n    sadness = 0\n    for i in range(hl):\n        sadness += h[i][0] * -1 * h[i][1][1]\n    print(sadness)", "import heapq\n\ndef mhpu(hp, el):\n    heapq.heappush(hp, el)\n\ndef mhpo(hp):\n    if len(hp) == 0:\n        return -1\n    temp = heapq.heappop(hp)\n    if temp[1] != 1:\n        nt = (temp[0], temp[1] - 1)\n        mhpu(hp, nt)\n    return -temp[0]\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    tsum = 0\n    dct = {}\n    hp = []\n    for i in range(n):\n        (di, ti, si) = map(int, input().split())\n        if di not in dct:\n            dct[di] = []\n        dct[di].append((-si, ti))\n        tsum += ti * si\n    for i in range(1, d + 1):\n        if i in dct:\n            for j in dct[i]:\n                mhpu(hp, j)\n        tmp = mhpo(hp)\n        if tmp != -1:\n            tsum -= tmp\n    print(tsum)", "import heapq as hp\nfor _ in range(int(input())):\n    (n, m) = map(int, input().strip().split())\n    schedule = [list(map(int, input().strip().split())) for i in range(n)]\n    dic = {}\n    for i in range(n):\n        (d, t, s) = schedule[i]\n        if d not in dic:\n            dic[d] = []\n        dic[d].append([-s, t])\n    heap = []\n    for i in range(m):\n        if i + 1 in dic:\n            for j in dic[i + 1]:\n                hp.heappush(heap, j)\n        if heap != []:\n            k = hp.heappop(heap)\n            k[1] -= 1\n            if k[1] != 0:\n                hp.heappush(heap, k)\n    ans = 0\n    for k in heap:\n        ans += -k[0] * k[1]\n    print(ans)", "from collections import defaultdict as dd\nimport heapq as hp\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    l = dd(list)\n    for i in range(n):\n        (a, b, c) = map(int, input().split())\n        l[a].append([-c, b])\n    h = []\n    for i in range(1, d + 1):\n        for j in l[i]:\n            hp.heappush(h, j)\n        if h != []:\n            k = hp.heappop(h)\n            k[1] -= 1\n            if k[1] != 0:\n                hp.heappush(h, k)\n    ans = 0\n    for i in h:\n        ans += -i[0] * i[1]\n    print(ans)", "import heapq\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    a = []\n    for i in range(n):\n        t = list(map(int, input().split()))\n        a.append(t)\n    a.sort(key=lambda x: x[0])\n    j = 0\n    heap = []\n    for i in range(1, d + 1):\n        aux = []\n        while j < n:\n            if a[j][0] == i:\n                aux.append(a[j])\n            else:\n                break\n            j += 1\n        for k in range(len(aux)):\n            heapq.heappush(heap, [-1 * aux[k][-1], aux[k]])\n        if len(heap) > 0:\n            t_1 = heapq.heappop(heap)\n            if t_1[1][1] > 1:\n                t_1[1][1] -= 1\n                heapq.heappush(heap, t_1)\n    res = 0\n    for i in range(len(heap)):\n        res += -1 * heap[i][0] * heap[i][1][1]\n    print(res)", "def binary_search(arr, n, x):\n    l = 0\n    r = n - 1\n    ans = -1\n    while l <= r:\n        mid = int((l + r) / 2)\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            l = mid + 1\n        else:\n            ans = mid\n            r = mid - 1\n    return ans\nt = int(input())\nwhile t:\n    trainers = []\n    (n, d) = map(int, input().strip().split())\n    for _ in range(n):\n        trainers.append([int(i) for i in input().strip().split()])\n    trainers.sort(key=lambda k: k[2], reverse=True)\n    lec_days = []\n    for _ in range(d):\n        lec_days.append(_)\n    sadness = 0\n    for i in range(n):\n        days = len(lec_days)\n        if days == 0:\n            for k in range(i, n):\n                sadness += trainers[k][1] * trainers[k][2]\n            break\n        fday = trainers[i][0]\n        tday = trainers[i][1]\n        day = binary_search(lec_days, days, fday - 1)\n        if day != -1:\n            rem = days - day\n            if rem >= tday:\n                for k in range(day + tday - 1, day - 1, -1):\n                    del lec_days[k]\n                tday = 0\n            else:\n                for k in range(len(lec_days) - 1, day - 1, -1):\n                    del lec_days[k]\n                tday = tday - rem\n        sadness += trainers[i][2] * tday\n    print(sadness)\n    t -= 1", "class Heap:\n\n    def __init__(slf):\n        slf.lst = []\n        slf.lst.append([-1, -1, -1])\n\n    def insert(slf, l):\n        slf.lst.append(l)\n        i = len(slf.lst) - 1\n        while int(i / 2) >= 1 and slf.lst[i][si] > slf.lst[int(i / 2)][si]:\n            (slf.lst[i], slf.lst[int(i / 2)]) = (slf.lst[int(i / 2)], slf.lst[i])\n            i = int(i / 2)\n\n    def delete(slf):\n        if len(slf.lst) <= 1:\n            return\n        slf.lst[1][ti] -= 1\n        if slf.lst[1][ti] != 0:\n            return\n        slf.lst[1] = slf.lst[-1]\n        slf.lst.pop()\n        i = 1\n        while i * 2 + 1 < len(slf.lst) and (slf.lst[i * 2][si] > slf.lst[i][si] or slf.lst[i * 2 + 1][si] > slf.lst[i][si]):\n            if slf.lst[i * 2][si] > slf.lst[i * 2 + 1][si]:\n                (slf.lst[i * 2], slf.lst[i]) = (slf.lst[i], slf.lst[i * 2])\n                i *= 2\n            else:\n                (slf.lst[i * 2 + 1], slf.lst[i]) = (slf.lst[i], slf.lst[i * 2 + 1])\n                i *= 2 + 1\n        if i * 2 < len(slf.lst) and slf.lst[i * 2][si] > slf.lst[i][si]:\n            (slf.lst[i * 2], slf.lst[i]) = (slf.lst[i], slf.lst[i * 2])\n\n    def calc(slf):\n        slf.lst.pop(0)\n        summ = 0\n        for i in range(len(slf.lst)):\n            summ += slf.lst[i][si] * slf.lst[i][ti]\n        return summ\n(di, ti, si) = (0, 1, 2)\nfor _ in range(int(input())):\n    heap = Heap()\n    (n, d) = map(int, input().split())\n    lst = []\n    for _ in range(n):\n        lst.append(list(map(int, input().split())))\n    lst.sort()\n    i = 0\n    for k in range(1, d + 1):\n        while i < n and lst[i][di] == k:\n            heap.insert(lst[i])\n            i += 1\n        heap.delete()\n    print(heap.calc())", "import heapq\ntest = int(input())\nfor _ in range(test):\n    (n, d) = map(int, input().split())\n    a = list()\n    for _ in range(n):\n        temp = list(map(int, input().split()))\n        a.append(temp)\n    a = sorted(a, key=lambda x: x[0])\n    h = []\n    j = 0\n    for i in range(1, d + 1):\n        curr = []\n        while j < n:\n            if a[j][0] == i:\n                curr.append(a[j])\n            else:\n                break\n            j += 1\n        for k in range(len(curr)):\n            heapq.heappush(h, [-1 * curr[k][-1], curr[k]])\n        if len(h) > 0:\n            g = heapq.heappop(h)\n            if g[1][1] > 1:\n                g[1][1] -= 1\n                heapq.heappush(h, g)\n    hl = len(h)\n    sadness = 0\n    for i in range(hl):\n        sadness += h[i][0] * -1 * h[i][1][1]\n    print(sadness)", "import heapq\nt = int(input())\nwhile t:\n    (n, d) = map(int, input().split())\n    a = list()\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        a.append(temp)\n    a = sorted(a, key=lambda x: x[0])\n    h = []\n    j = 0\n    for i in range(1, d + 1):\n        curr = []\n        while j < n:\n            if a[j][0] == i:\n                curr.append(a[j])\n            else:\n                break\n            j += 1\n        for k in range(len(curr)):\n            heapq.heappush(h, [-1 * curr[k][-1], curr[k]])\n        if len(h) > 0:\n            g = heapq.heappop(h)\n            if g[1][1] > 1:\n                g[1][1] -= 1\n                heapq.heappush(h, g)\n    hl = len(h)\n    sadness = 0\n    for i in range(hl):\n        sadness += h[i][0] * -1 * h[i][1][1]\n    print(sadness)\n    t -= 1", "import heapq\ntry:\n\n    class Trainer:\n\n        def __init__(self, d, l, s):\n            self.d = d\n            self.l = l\n            self.s = s\n\n        def takeLecture(self):\n            self.l -= 1\n\n        def calculateSadness(self):\n            return self.l * self.s\n\n        def __lt__(self, other):\n            return self.d < other.d\n    t = int(input())\n    output = []\n    while t > 0:\n        t -= 1\n        (n, d) = map(int, input().split())\n        firstHeap = []\n        secondHeap = []\n        while n > 0:\n            n -= 1\n            (a, b, c) = map(int, input().split())\n            trainer = Trainer(a, b, c)\n            firstHeap.append((trainer.d, trainer))\n        heapq.heapify(firstHeap)\n        i = 0\n        while d > 0:\n            d -= 1\n            i += 1\n            while len(firstHeap) > 0 and firstHeap[0][1].d == i:\n                p = heapq.heappop(firstHeap)[1]\n                heapq.heappush(secondHeap, (-1 * p.s, p))\n            if len(secondHeap) > 0:\n                q = heapq.heappop(secondHeap)[1]\n                q.takeLecture()\n                if q.l != 0:\n                    heapq.heappush(secondHeap, (-1 * q.s, q))\n        total = 0\n        for value in secondHeap:\n            total += value[1].calculateSadness()\n        output.append(total)\n    for value in output:\n        print(value)\nexcept:\n    w = 0", "import heapq\n\nclass Trainer:\n\n    def __init__(self, d, l, s):\n        self.d = d\n        self.l = l\n        self.s = s\n\n    def takeLecture(self):\n        self.l -= 1\n\n    def calculateSadness(self):\n        return self.l * self.s\n\n    def __lt__(self, other):\n        return self.d < other.d\nt = int(input())\noutput = []\nwhile t > 0:\n    t -= 1\n    (n, d) = map(int, input().split())\n    firstHeap = []\n    secondHeap = []\n    while n > 0:\n        n -= 1\n        (a, b, c) = map(int, input().split())\n        trainer = Trainer(a, b, c)\n        firstHeap.append((trainer.d, trainer))\n    heapq.heapify(firstHeap)\n    i = 0\n    while d > 0:\n        d -= 1\n        i += 1\n        while len(firstHeap) > 0 and firstHeap[0][1].d == i:\n            p = heapq.heappop(firstHeap)[1]\n            heapq.heappush(secondHeap, (-1 * p.s, p))\n        if len(secondHeap) > 0:\n            q = heapq.heappop(secondHeap)[1]\n            q.takeLecture()\n            if q.l != 0:\n                heapq.heappush(secondHeap, (-1 * q.s, q))\n    total = 0\n    for value in secondHeap:\n        total += value[1].calculateSadness()\n    output.append(total)\nfor value in output:\n    print(value)", "from collections import defaultdict\nimport sys\n\ndef range_intersection(a, b, c, d):\n    if a >= c - 1 and a <= d or (b >= c - 1 and b <= d):\n        return True\n    if c >= a - 1 and c <= b or (d >= a - 1 and d <= b):\n        return True\n    return False\n\ndef merge_ranges(a, b, c, d):\n    k = a if a < c else c\n    tot_dist = b - a + (d - c) + 1\n    return (k, k + tot_dist)\n\ndef find_index(list, len_list, start):\n    l = 0\n    r = len_list\n    while l < r:\n        mid = (l + r) // 2\n        if list[mid][0] <= start:\n            l = mid + 1\n        else:\n            r = mid\n    return l\n\nclass add_lec:\n\n    def __init__(self, max_range):\n        self.list = []\n        self.max_Range = max_range\n        self.total_sad = 0\n\n    def add_sadness(self, start, lectures, sadness):\n        if self.list == []:\n            if start + lectures - 1 > self.max_Range:\n                self.total_sad += (start + lectures - 1 - self.max_Range) * sadness\n                self.list.append([start, self.max_Range])\n            else:\n                self.list.append([start, start + lectures - 1])\n        else:\n            len_list = len(self.list)\n            index = find_index(self.list, len_list, start)\n            (a, b) = (self.list[index - 1][0], self.list[index - 1][1])\n            (c, d) = (start, start + lectures - 1)\n            added = False\n            while range_intersection(a, b, c, d):\n                added = True\n                (r1, r2) = merge_ranges(a, b, c, d)\n                del self.list[index - 1]\n                if index > len(self.list) or index <= 0:\n                    break\n                (a, b) = (self.list[index - 1][0], self.list[index - 1][1])\n                (c, d) = (r1, r2)\n            if index < len_list and added is False:\n                (a, b) = (self.list[index][0], self.list[index][1])\n                while range_intersection(a, b, c, d):\n                    added = True\n                    (r1, r2) = merge_ranges(a, b, c, d)\n                    del self.list[index]\n                    if index >= len(self.list):\n                        break\n                    (a, b) = (self.list[index][0], self.list[index][1])\n                    (c, d) = (r1, r2)\n            if added is True:\n                if r2 > self.max_Range:\n                    insert_index = find_index(self.list, len(self.list), r1)\n                    self.total_sad += (r2 - self.max_Range) * sadness\n                    self.list.insert(insert_index, [r1, self.max_Range])\n                else:\n                    insert_index = find_index(self.list, len(self.list), r1)\n                    self.list.insert(insert_index, [r1, r2])\n            if added is False:\n                if d > self.max_Range:\n                    self.total_sad += (d - self.max_Range) * sadness\n                    self.list.insert(index, [c, self.max_Range])\n                else:\n                    self.list.insert(index, [c, d])\n\n    def print_var(self):\n        print('LIST =', self.list)\n        print('TOTAL SADNESS =', self.total_sad)\n        print('RANGE ALLOWED = ', self.max_Range)\nn = int(input())\nfor i in range(n):\n    (l1, l2) = map(int, input().split(' '))\n    my_dict = defaultdict(list)\n    rep = add_lec(l2)\n    for r in range(l1):\n        (start, lect, sadness) = map(int, input().split(' '))\n        my_dict[sadness].append([start, lect])\n    for (k, v) in sorted(my_dict.items(), reverse=True):\n        for j in v:\n            rep.add_sadness(j[0], j[1], k)\n    print(rep.total_sad)", "from collections import defaultdict\nimport sys\n\ndef range_intersection(a, b, c, d):\n    if a >= c - 1 and a <= d or (b >= c - 1 and b <= d):\n        return True\n    if c >= a - 1 and c <= b or (d >= a - 1 and d <= b):\n        return True\n    return False\n\ndef merge_ranges(a, b, c, d):\n    k = a if a < c else c\n    tot_dist = b - a + (d - c) + 1\n    return (k, k + tot_dist)\n\ndef find_index(list, len_list, start):\n    l = 0\n    r = len_list\n    while l < r:\n        mid = (l + r) // 2\n        if list[mid][0] <= start:\n            l = mid + 1\n        else:\n            r = mid\n    return l\n\nclass add_lec:\n\n    def __init__(self, max_range):\n        self.list = []\n        self.max_Range = max_range\n        self.total_sad = 0\n\n    def add_sadness(self, start, lectures, sadness):\n        if self.list == []:\n            if start + lectures - 1 > self.max_Range:\n                self.total_sad += (start + lectures - 1 - self.max_Range) * sadness\n                self.list.append([start, self.max_Range])\n            else:\n                self.list.append([start, start + lectures - 1])\n        else:\n            len_list = len(self.list)\n            index = find_index(self.list, len_list, start)\n            index_one = index\n            (a, b) = (self.list[index_one - 1][0], self.list[index_one - 1][1])\n            (c, d) = (start, start + lectures - 1)\n            added = False\n            while range_intersection(a, b, c, d):\n                added = True\n                (r1, r2) = merge_ranges(a, b, c, d)\n                del self.list[index_one - 1]\n                if index_one > len(self.list) or index_one <= 0:\n                    break\n                (a, b) = (self.list[index_one - 1][0], self.list[index_one - 1][1])\n                (c, d) = (r1, r2)\n            if added is True:\n                if r2 > self.max_Range:\n                    insert_index = find_index(self.list, len(self.list), r1)\n                    self.total_sad += (r2 - self.max_Range) * sadness\n                    self.list.insert(insert_index, [r1, self.max_Range])\n                else:\n                    insert_index = find_index(self.list, len(self.list), r1)\n                    self.list.insert(insert_index, [r1, r2])\n            if index_one < len_list and added is False:\n                (a, b) = (self.list[index_one][0], self.list[index_one][1])\n                while range_intersection(a, b, c, d):\n                    added = True\n                    (r1, r2) = merge_ranges(a, b, c, d)\n                    del self.list[index_one]\n                    if index_one + 1 > len(self.list) or index_one < 0:\n                        break\n                    (a, b) = (self.list[index_one][0], self.list[index_one][1])\n                    (c, d) = (r1, r2)\n                if added is True:\n                    if r2 > self.max_Range:\n                        insert_index = find_index(self.list, len(self.list), r1)\n                        self.total_sad += (r2 - self.max_Range) * sadness\n                        self.list.insert(insert_index, [r1, self.max_Range])\n                    else:\n                        insert_index = find_index(self.list, len(self.list), r1)\n                        self.list.insert(insert_index, [r1, r2])\n            if added is False:\n                if d > self.max_Range:\n                    self.total_sad += (d - self.max_Range) * sadness\n                    self.list.insert(index, [c, self.max_Range])\n                else:\n                    self.list.insert(index, [c, d])\n\n    def print_var(self):\n        print('LIST =', self.list)\n        print('TOTAL SADNESS =', self.total_sad)\n        print('RANGE ALLOWED = ', self.max_Range)\nn = int(input())\nfor i in range(n):\n    (l1, l2) = map(int, input().split(' '))\n    my_dict = defaultdict(list)\n    rep = add_lec(l2)\n    for r in range(l1):\n        (start, lect, sadness) = map(int, input().split(' '))\n        my_dict[sadness].append([start, lect])\n    for (k, v) in sorted(my_dict.items(), reverse=True):\n        for j in v:\n            rep.add_sadness(j[0], j[1], k)\n    print(rep.total_sad)", "import sys\nfrom heapq import heapify, heappush, heappop\nfrom math import sqrt, floor, factorial, gcd\nfrom collections import deque, Counter, defaultdict\ninp = sys.stdin.readline\nread = lambda : list(map(int, inp().strip().split()))\n\ndef solve():\n    ans = ''\n    for _ in range(int(inp())):\n        (n, d) = read()\n        dic = [[] for i in range(d)]\n        for i in range(n):\n            (di, t, s) = read()\n            dic[di - 1].append([-s, t])\n        arr = []\n        heapify(arr)\n        for i in range(d):\n            for j in dic[i]:\n                heappush(arr, j)\n            if arr:\n                elem = heappop(arr)\n                elem[1] -= 1\n                if elem[1] > 0:\n                    heappush(arr, elem)\n            else:\n                pass\n        rem = 0\n        for i in arr:\n            rem += -i[0] * i[1]\n        ans += str(rem) + '\\n'\n    print(ans)\nsolve()", "import sys\nfrom heapq import heapify, heappush, heappop\nfrom math import sqrt, floor, factorial, gcd\nfrom collections import deque, Counter, defaultdict\ninp = sys.stdin.readline\nread = lambda : list(map(int, inp().strip().split()))\n\ndef solve():\n    ans = ''\n    for _ in range(int(inp())):\n        (n, d) = read()\n        dic = defaultdict(list)\n        for i in range(n):\n            (di, t, s) = read()\n            dic[di].append([-s, t])\n        arr = []\n        heapify(arr)\n        for i in range(1, d + 1):\n            for j in dic[i]:\n                heappush(arr, j)\n            if arr:\n                elem = heappop(arr)\n                elem[1] -= 1\n                if elem[1] > 0:\n                    heappush(arr, elem)\n            else:\n                pass\n        rem = 0\n        for i in arr:\n            rem += -i[0] * i[1]\n        ans += str(rem) + '\\n'\n    print(ans)\nsolve()", "import heapq\nt = int(input())\nwhile t:\n    (n, d) = map(int, input().split())\n    a = list()\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        a.append(temp)\n    a = sorted(a, key=lambda x: x[0])\n    h = []\n    j = 0\n    for i in range(1, d + 1):\n        curr = []\n        while j < n:\n            if a[j][0] == i:\n                curr.append(a[j])\n            else:\n                break\n            j += 1\n        for k in range(len(curr)):\n            heapq.heappush(h, [-1 * curr[k][-1], curr[k]])\n        if len(h) > 0:\n            g = heapq.heappop(h)\n            if g[1][1] > 1:\n                g[1][1] -= 1\n                heapq.heappush(h, g)\n    hl = len(h)\n    sadness = 0\n    for i in range(hl):\n        sadness += h[i][0] * -1 * h[i][1][1]\n    print(sadness)\n    t -= 1", "from heapq import *\nT = int(input())\nfor i in range(T):\n    (N, D) = map(int, input().split())\n    s = []\n    for i in range(N):\n        (a, b, c) = map(int, input().split())\n        s.append((a, b, c))\n    s.sort()\n    d = {}\n    ind = 0\n    h = []\n    for i in range(1, D + 1):\n        while ind < len(s) and s[ind][0] == i:\n            (a, b, c) = s[ind]\n            if c not in d:\n                d[c] = 0\n                heappush(h, -c)\n            d[c] += b\n            ind += 1\n        if len(h) == 0:\n            continue\n        val = h[0] * -1\n        d[val] -= 1\n        if d[val] == 0:\n            heappop(h)\n            del d[val]\n    sad = 0\n    for i in d:\n        sad += i * d[i]\n    print(sad)", "from heapq import *\nfor case in range(int(input())):\n    (N, D) = map(int, input().split())\n    L = []\n    for i in range(N):\n        (a, b, c) = map(int, input().split())\n        L.append((a, b, c))\n    L.sort()\n    d = {}\n    ind = 0\n    h = []\n    for i in range(1, D + 1):\n        while ind < len(L) and L[ind][0] == i:\n            (a, b, c) = L[ind]\n            if c not in d:\n                d[c] = 0\n                heappush(h, -c)\n            d[c] += b\n            ind += 1\n        if len(h) == 0:\n            continue\n        val = h[0] * -1\n        d[val] -= 1\n        if d[val] == 0:\n            heappop(h)\n            del d[val]\n    sad = 0\n    for i in d:\n        sad += i * d[i]\n    print(sad)", "from heapq import *\nfor case in range(int(input())):\n    (N, D) = map(int, input().split())\n    L = []\n    for i in range(N):\n        (a, b, c) = map(int, input().split())\n        L.append((a, b, c))\n    L.sort()\n    d = {}\n    ind = 0\n    h = []\n    for i in range(1, D + 1):\n        while ind < len(L) and L[ind][0] == i:\n            (a, b, c) = L[ind]\n            if c not in d:\n                d[c] = 0\n                heappush(h, -c)\n            d[c] += b\n            ind += 1\n        if len(h) == 0:\n            continue\n        val = h[0] * -1\n        d[val] -= 1\n        if d[val] == 0:\n            heappop(h)\n            del d[val]\n    sad = 0\n    for i in d:\n        sad += i * d[i]\n    print(sad)", "import sys\nimport math\nfrom collections import defaultdict\nimport bisect\nimport heapq\n\ndef alele():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef ilele():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef list2d(a, b, c):\n    return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d):\n    return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Yes():\n    print('Yes')\n\ndef No():\n    print('No')\n\ndef YES():\n    print('YES')\n\ndef NO():\n    print('NO')\nINF = 10 ** 18\nMOD = 1000000000 + 7\nfor _ in range(int(input())):\n    (N, D) = ilele()\n    mark = {}\n    A = defaultdict(list)\n    for i in range(N):\n        (DI, T, S) = ilele()\n        mark[i + 1] = (-1 * S, T, i + 1)\n        A[DI].append(i + 1)\n    mylist = []\n    heapq.heapify(mylist)\n    for d in range(1, D + 1):\n        if A.get(d, -1) != -1:\n            for i in A[d]:\n                heapq.heappush(mylist, mark[i])\n        if len(mylist) != 0:\n            Z = heapq.heappop(mylist)\n            if Z[1] == 1:\n                mark[Z[2]] = (Z[0], 0, Z[2])\n            else:\n                mark[Z[2]] = (Z[0], Z[1] - 1, Z[2])\n                heapq.heappush(mylist, (Z[0], Z[1] - 1, Z[2]))\n    Ans = 0\n    for (i, j, k) in mark.values():\n        Ans += abs(i) * j\n    print(Ans)", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    day = [[] for i in range(d)]\n    for i in range(n):\n        (di, ti, si) = map(int, input().split())\n        day[di - 1].append((-1 * si, ti))\n    h = []\n    for i in day:\n        if len(i) != 0:\n            for j in range(len(i)):\n                heappush(h, i[j])\n        else:\n            pass\n        if len(h) != 0:\n            x = h[0]\n            heappop(h)\n            if x[1] != 1:\n                heappush(h, (x[0], x[1] - 1))\n    ans = 0\n    for i in range(len(h)):\n        ans += -1 * h[i][0] * h[i][1]\n    print(ans)", "from operator import itemgetter\nimport heapq\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    l = []\n    for i in range(n):\n        l.append([int(x) for x in input().split()])\n    l = sorted(l, key=itemgetter(0))\n    for i in range(n):\n        m = -l[i][2]\n        l[i].insert(0, m)\n    i = 0\n    j = 1\n    heap = []\n    heapq.heapify(heap)\n    while j <= d:\n        if i < n:\n            while j >= l[i][1]:\n                heapq.heappush(heap, l[i])\n                i += 1\n                if i == n:\n                    break\n        if heap:\n            k = heapq.heappop(heap)\n        if k[2] == 1 or k[2] == 0:\n            k[2] = 0\n        else:\n            k[2] -= 1\n            heapq.heappush(heap, k)\n        j += 1\n    sm = 0\n    while heap:\n        h = heapq.heappop(heap)\n        sm += h[2] * h[3]\n    print(sm)", "import heapq\nt = int(input())\n\ndef sort0(x):\n    return x[0]\nwhile t > 0:\n    (n, d) = map(int, input().split())\n    l = [] * d\n    ts = 0\n    for i in range(n):\n        s = list(map(int, input().split()))\n        l.append(s)\n        ts += s[2] * s[1]\n    l.sort(key=sort0)\n    h = []\n    heapq.heapify(h)\n    j = 0\n    s = 0\n    for i in range(d):\n        if j < n:\n            while l[j][0] == i + 1:\n                heapq.heappush(h, [-l[j][2], l[j][1]])\n                j += 1\n                if j >= n:\n                    break\n        if len(h) > 0:\n            x = heapq.heappop(h)\n            x[1] -= 1\n            ts += x[0]\n            if x[1] > 0:\n                heapq.heappush(h, x)\n    print(ts)\n    t -= 1", "def ipctrain(n, d, m):\n    import heapq\n    h = []\n    for i in range(1, d + 1):\n        if i in m:\n            for n in m[i]:\n                heapq.heappush(h, n)\n        if h:\n            n = heapq.heappop(h)\n            n[1] = n[1] - 1\n            if n[1]:\n                heapq.heappush(h, n)\n    sadness = 0\n    for item in h:\n        sadness += -item[0] * item[1]\n    return sadness\nt = int(input())\nfor _ in range(t):\n    (n, d) = map(int, input().split())\n    m = {}\n    for _ in range(n):\n        (di, ti, si) = map(int, input().split())\n        if di not in m:\n            m[di] = [[-si, ti]]\n        else:\n            m[di].append([-si, ti])\n    print(ipctrain(n, d, m))", "from heapq import heapify, heappush, heappop\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    li = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        li.append(temp)\n    li.sort()\n    cur = 0\n    sadh = []\n    for i in range(1, d + 1):\n        while cur < len(li) and li[cur][0] == i:\n            temp = [-1 * li[cur][-1], li[cur][1]]\n            cur += 1\n            heappush(sadh, temp)\n        if len(sadh) > 0:\n            sadh[0][1] -= 1\n            if sadh[0][1] == 0:\n                heappop(sadh)\n    ans = 0\n    while len(sadh) > 0:\n        ans += sadh[0][1] * sadh[0][0]\n        heappop(sadh)\n    print(-1 * ans)", "import heapq\nfor i in range(int(input())):\n    (n, d) = map(int, input().split(' '))\n    di = [[] for i in range(d + 1)]\n    q = []\n    for i in range(n):\n        (w, x, y) = map(int, input().split(' '))\n        di[w].append([-1 * y, x])\n    for i in range(1, d + 1):\n        for j in range(len(di[i])):\n            heapq.heappush(q, di[i][j])\n        if len(q) > 0:\n            q[0][1] = q[0][1] - 1\n            if q[0][1] == 0:\n                heapq.heappop(q)\n    sum = 0\n    for i in range(len(q)):\n        sum = sum + q[i][0] * q[i][1]\n    print(-1 * sum)", "from heapq import heappush, heappop\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    dl = []\n    for i in range(d + 1):\n        dl.append([])\n    for ni in range(n):\n        (di, ti, si) = map(int, input().split())\n        dl[di].append([ti, -si])\n    dd = defaultdict(int)\n    heap = []\n    hl = 0\n    for i in range(1, d + 1):\n        for j in dl[i]:\n            if dd[j[1]] == 0:\n                heappush(heap, j[1])\n                hl += 1\n            dd[j[1]] += j[0]\n        if hl > 0:\n            dd[heap[0]] -= 1\n            if dd[heap[0]] == 0:\n                heappop(heap)\n                hl -= 1\n    s = 0\n    for i in heap:\n        s += -i * dd[i]\n    print(s)", "import heapq\nt = int(input())\nfor i in range(t):\n    (n, d) = [int(i) for i in input().split()]\n    arr = []\n    for i in range(n):\n        (di, ti, si) = [int(i) for i in input().split()]\n        arr.append([di, ti, -si])\n    arr.sort(key=lambda x: x[0])\n    day = 1\n    heap = []\n    ptr = 0\n    while day <= d:\n        while ptr < n and arr[ptr][0] == day:\n            heapq.heappush(heap, [arr[ptr][2], arr[ptr][1]])\n            ptr += 1\n        if len(heap) != 0:\n            heap[0][1] -= 1\n            if heap[0][1] == 0:\n                heapq.heappop(heap)\n        day += 1\n    ans = 0\n    while len(heap) != 0:\n        temp = heapq.heappop(heap)\n        ans += temp[0] * temp[1]\n    print(-ans)", "import bisect\n\ndef Sort_Tuple(tup):\n    tup.sort(key=lambda x: x[-1])\n    return tup[::-1]\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    l = []\n    ans = 0\n    for x in range(n):\n        (di, ti, si) = map(int, input().split())\n        l.append([di, ti, si])\n    l = Sort_Tuple(l)\n    days = [x for x in range(d + 1)]\n    for x in range(len(l)):\n        if days == [0]:\n            break\n        else:\n            ind = bisect.bisect_left(days, l[x][0])\n            remaining = len(days) - ind\n            end = ind + min(remaining, l[x][1])\n            l[x][1] -= min(l[x][1], remaining)\n            del days[ind:end]\n    for x in range(n):\n        ans += l[x][1] * l[x][2]\n    print(ans)", "from heapq import heappush, heappop\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    dl = []\n    for i in range(d + 1):\n        dl.append([])\n    for ni in range(n):\n        (di, ti, si) = map(int, input().split())\n        dl[di].append([ti, -si])\n    dd = defaultdict(int)\n    heap = []\n    hl = 0\n    for i in range(1, d + 1):\n        for j in dl[i]:\n            if dd[j[1]] == 0:\n                heappush(heap, j[1])\n                hl += 1\n            dd[j[1]] += j[0]\n        if hl > 0:\n            dd[heap[0]] -= 1\n            if dd[heap[0]] == 0:\n                heappop(heap)\n                hl -= 1\n    s = 0\n    for i in heap:\n        s += -i * dd[i]\n    print(s)", "from sys import stdin\nfrom collections import defaultdict\n\nclass MaxHeap:\n\n    def __init__(self):\n        self.heapList = []\n        self.currentSize = 0\n\n    def percolate_up(self, i):\n        while (i - 1) // 2 >= 0:\n            if self.heapList[i] > self.heapList[(i - 1) // 2]:\n                temp = self.heapList[i]\n                self.heapList[i] = self.heapList[(i - 1) // 2]\n                self.heapList[(i - 1) // 2] = temp\n            i = (i - 1) // 2\n\n    def insert_element(self, element):\n        self.heapList.append(element)\n        self.currentSize += 1\n        self.percolate_up(self.currentSize - 1)\n\n    def peek(self):\n        return self.heapList[0]\n\n    def max_child(self, i):\n        if i * 2 + 2 > self.currentSize - 1:\n            return i * 2 + 1\n        elif self.heapList[i * 2 + 1] > self.heapList[i * 2 + 2]:\n            return i * 2 + 1\n        else:\n            return i * 2 + 2\n\n    def percolate_down(self, i):\n        while i * 2 + 1 < self.currentSize:\n            maxChild = self.max_child(i)\n            if self.heapList[i] < self.heapList[maxChild]:\n                temp = self.heapList[i]\n                self.heapList[i] = self.heapList[maxChild]\n                self.heapList[maxChild] = temp\n            i = maxChild\n\n    def delete_max(self):\n        self.heapList[0] = self.heapList[self.currentSize - 1]\n        self.heapList.pop()\n        self.currentSize -= 1\n        self.percolate_down(0)\n\n    def build_heap(self, alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = alist\n        while i > 0:\n            self.percolate_down(i - 1)\n            i = i - 1\n\ndef calculate_minimum_sadness(N, D, info_dict):\n    pq = MaxHeap()\n    for i in range(D):\n        if i + 1 in info_dict:\n            if len(info_dict[i + 1]) == 1:\n                pq.insert_element((info_dict[i + 1][0][1], info_dict[i + 1][0][0], i + 1))\n            elif len(info_dict[i + 1]) > 1:\n                for j in info_dict[i + 1]:\n                    pq.insert_element((j[1], j[0], i + 1))\n        if pq.currentSize > 0:\n            pq.heapList = teach_a_lecture(pq)\n    minimumSadness = 0\n    for j in pq.heapList:\n        minimumSadness += j[0] * j[1]\n    return minimumSadness\n\ndef teach_a_lecture(pq):\n    heapList = pq.heapList\n    if heapList[0][1] > 1:\n        reducedDay = list(heapList[0])\n        reducedDay[1] = reducedDay[1] - 1\n        pq.heapList[0] = tuple(reducedDay)\n    else:\n        pq.delete_max()\n    return pq.heapList\nt = int(stdin.readline())\nfor i in range(t):\n    (N, D) = map(int, stdin.readline().strip('').split(' '))\n    info_dict = defaultdict(list)\n    for j in range(N):\n        (d, t, s) = map(int, stdin.readline().strip().split(' '))\n        if d in info_dict:\n            ne = info_dict[d]\n            ne.append((t, s))\n            info_dict[d] = ne\n        else:\n            info_dict[d] = [(t, s)]\n    print(calculate_minimum_sadness(N, D, info_dict))", "import heapq\n\ndef solve(arr, d):\n    heap = []\n    heapq.heapify(heap)\n    arr.sort()\n    ind = 0\n    schedule = [0] * (d + 1)\n    ans = 0\n    for i in range(1, d + 1):\n        while ind < len(arr):\n            if arr[ind][0] > i:\n                break\n            heapq.heappush(heap, arr[ind][::-1])\n            ind += 1\n        if len(heap):\n            heap[0][1] -= 1\n            if heap[0][1] == 0:\n                heapq.heappop(heap)\n    for ele in heap:\n        ans += -1 * ele[0] * ele[1]\n    return ans\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(list(map(int, input().split())))\n        arr[i][-1] *= -1\n    print(solve(arr, d))", "import sys\nimport heapq\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    (n, d) = map(int, sys.stdin.readline().split())\n    days = [[] for i in range(d)]\n    a = [0] * n\n    for i in range(n):\n        (dd, t, s) = map(int, sys.stdin.readline().split())\n        a[i] = [-s, t]\n        days[dd - 1].append(i)\n    seq = []\n    for i in range(d):\n        for idx in days[i]:\n            entry = a[idx]\n            heapq.heappush(seq, entry)\n        if seq:\n            ele = heapq.heappop(seq)\n            ele[1] -= 1\n            if ele[1] != 0:\n                heapq.heappush(seq, ele)\n    sadness = sum((-ele[0] * ele[1] for ele in seq))\n    print(sadness)", "import sys\nimport heapq\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    (n, d) = map(int, sys.stdin.readline().split())\n    days = [[] for i in range(d)]\n    a = [0] * n\n    for i in range(n):\n        (dd, t, s) = map(int, sys.stdin.readline().split())\n        a[i] = [-s, t]\n        days[dd - 1].append(i)\n    seq = []\n    for i in range(d):\n        for idx in days[i]:\n            entry = a[idx]\n            heapq.heappush(seq, entry)\n        if seq:\n            ele = heapq.heappop(seq)\n            ele[1] -= 1\n            if ele[1] != 0:\n                heapq.heappush(seq, ele)\n    sadness = sum((-ele[0] * ele[1] for ele in seq))\n    print(sadness)", "import bisect\nt = int(input())\nfor i in range(t):\n    (n, D) = map(int, input().split())\n    A = []\n    for j in range(n):\n        (d, t, s) = map(int, input().split())\n        A.append((d, t, s))\n    A.sort(key=lambda a: a[0])\n    pk = 0\n    schd = []\n    d = {}\n    for j in range(1, D + 1):\n        while pk < n and A[pk][0] == j:\n            a = bisect.bisect(schd, A[pk][2])\n            if schd == [] or a == 0 or schd[a - 1] != A[pk][2]:\n                bisect.insort(schd, A[pk][2])\n            try:\n                d[A[pk][2]] += A[pk][1]\n            except:\n                d[A[pk][2]] = A[pk][1]\n            pk += 1\n        if schd == []:\n            continue\n        d[schd[-1]] -= 1\n        if d[schd[-1]] == 0:\n            schd.pop()\n    ans = 0\n    for j in schd:\n        ans += j * d[j]\n    print(ans)", "import heapq\np = int(input())\nwhile p:\n    (n, d) = map(int, input().split())\n    total = 0\n    trainees = []\n    for _ in range(n):\n        (x, t, s) = map(int, input().split())\n        trainees.append([s, t, x])\n        total += s * t\n    trainees = sorted(trainees, key=lambda x: x[2])\n    heap = []\n    s = 0\n    i = 0\n    for current_day in range(1, d + 1):\n        while i < n and trainees[i][2] == current_day:\n            heapq.heappush(heap, [-trainees[i][0], trainees[i][1], trainees[i][2]])\n            i += 1\n        if not heap:\n            continue\n        elem = heapq.heappop(heap)\n        s += -elem[0]\n        elem[1] -= 1\n        if elem[1] > 0:\n            heapq.heappush(heap, elem)\n    print(total - s)\n    p -= 1", "import heapq\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, D) = [int(s) for s in input().split()]\n    dct = defaultdict(list)\n    cnt = dict()\n    sumi = 0\n    for i in range(n):\n        d = [int(s) for s in input().split()]\n        dct[d[0]].append([-1 * d[2], d[1]])\n        cnt[d[0]] = d[1]\n        sumi += d[2]\n    rq = []\n    for i in range(1, D + 1):\n        if i in dct.keys():\n            for j in dct[i]:\n                heapq.heappush(rq, j)\n        if rq:\n            curr = heapq.heappop(rq)\n            curr[1] -= 1\n            if curr[1] != 0:\n                heapq.heappush(rq, curr)\n    ans = 0\n    for i in rq:\n        ans += i[0] * i[1]\n    print(-1 * ans)", "from heapq import heappush, heappop\n\nclass Trainer:\n\n    def __init__(self, d, t, s):\n        self.d = d\n        self.t = t\n        self.s = s\n\n    def __gt__(self, other):\n        return self.s < other.s\n\ndef func(trnr):\n    return trnr.d\nt = int(input())\nfor tc in range(0, t):\n    (n, d) = input().split()\n    (n, d) = (int(n), int(d))\n    trnrs = []\n    for trnr in range(0, n):\n        (di, ti, si) = input().split()\n        (di, ti, si) = (int(di), int(ti), int(si))\n        trnrs.append(Trainer(di, ti, si))\n    trnrs.sort(key=func)\n    indx = 0\n    availT = []\n    for day in range(1, d + 1):\n        while indx < n:\n            if trnrs[indx].d <= day:\n                heappush(availT, trnrs[indx])\n                indx += 1\n                continue\n            break\n        if not availT:\n            continue\n        if availT[0].t > 1:\n            availT[0].t -= 1\n        else:\n            heappop(availT)\n    ans = 0\n    for trnr in availT:\n        ans += trnr.t * trnr.s\n    print(ans)", "import heapq\nt = int(input())\nwhile t != 0:\n    h = []\n    (n, d) = map(int, input().split())\n    a = []\n    ans = 0\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        ans = ans + temp[1] * temp[2]\n        temp[-1] = -temp[-1]\n        a.append(temp)\n    a = sorted(a, key=lambda x: x[0])\n    nn = a[-1][0]\n    j = 0\n    for i in range(d + 1):\n        while j < n:\n            temp = a[j]\n            if temp[0] != i:\n                break\n            else:\n                (temp[-1], temp[0]) = (temp[0], temp[-1])\n                heapq.heappush(h, temp)\n                j += 1\n        if len(h) > 0:\n            z = heapq.heappop(h)\n            ans = ans + z[0]\n            z[1] -= 1\n            if z[1] > 0:\n                heapq.heappush(h, z)\n    print(ans)\n    t -= 1", "from heapq import heappush, heappop, heapify\nt = int(input())\nfor ijk in range(0, t):\n    inp = []\n    (n, d) = map(int, input().strip().split())\n    for m in range(0, n):\n        inp.append(list(map(int, input().strip().split())))\n    inp = sorted(inp, key=lambda x: x[0])\n    j = 0\n    h = []\n    for i in range(1, d + 1):\n        cur = []\n        while j < n and inp[j][0] == i:\n            cur.append(inp[j])\n            j += 1\n        for val in cur:\n            heappush(h, (-1 * val[2], val))\n        if len(h) > 0:\n            first = h[0]\n            if first[1][1] == 1:\n                heappop(h)\n            else:\n                h[0] = (first[0], [first[1][0], first[1][1] - 1, first[1][2]])\n    ans = 0\n    for left in h:\n        ans += left[1][1] * left[1][2]\n    print(ans)", "import heapq\nfor _ in range(int(input())):\n    (teacher, days) = map(int, input().split())\n    final = [None for x in range(teacher)]\n    total = 0\n    for i in range(teacher):\n        final[i] = [int(x) for x in input().split()]\n        total += final[i][1] * final[i][2]\n    final.sort()\n    sums = 0\n    j = 0\n    hh = []\n    for i in range(1, days + 1):\n        if j < teacher:\n            while final[j][0] <= i:\n                heapq.heappush(hh, [-final[j][2], final[j][1]])\n                j += 1\n                if j == teacher:\n                    break\n        if hh:\n            if hh[0][1] > 1:\n                hh[0][1] -= 1\n                sums += hh[0][0]\n            else:\n                sums += hh[0][0]\n                heapq.heappop(hh)\n    print(total + sums)", "import heapq\nfor _ in range(int(input())):\n    (N, D) = input().split()\n    N = int(N)\n    D = int(D)\n    a = [None] * N\n    total = 0\n    for i in range(N):\n        a[i] = [int(x) for x in input().split()]\n        total += a[i][1] * a[i][2]\n    a.sort()\n    sums = 0\n    j = 0\n    hh = []\n    for i in range(1, D + 1):\n        if j < N:\n            while a[j][0] <= i:\n                heapq.heappush(hh, [-a[j][2], a[j][1]])\n                j += 1\n                if j == N:\n                    break\n        if hh:\n            if hh[0][1] > 1:\n                hh[0][1] -= 1\n                sums += hh[0][0]\n            else:\n                sums += hh[0][0]\n                heapq.heappop(hh)\n    print(total + sums)", "import heapq\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    allt = [None] * n\n    sad = 0\n    for i in range(n):\n        allt[i] = [int(o) for o in input().split()]\n        sad += allt[i][1] * allt[i][2]\n    allt = sorted(allt)\n    i = 1\n    j = 0\n    h = []\n    s = 0\n    while i <= d:\n        if j < n:\n            while allt[j][0] <= i:\n                heapq.heappush(h, [-allt[j][2], allt[j][1]])\n                j += 1\n                if j == n:\n                    break\n        if h:\n            if h[0][1] > 1:\n                h[0][1] -= 1\n                s += h[0][0]\n            else:\n                s += h[0][0]\n                heapq.heappop(h)\n        i += 1\n    print(sad + s)", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    (n, day) = map(int, input().split())\n    s = {}\n    d = {}\n    for i in range(n):\n        (dd, tt, ss) = map(int, input().split())\n        s[i] = [tt, ss]\n        try:\n            d[dd].append(i)\n        except:\n            d[dd] = [i]\n    heap = []\n    for i in range(1, day + 1):\n        try:\n            for ii in d[i]:\n                heappush(heap, (-s[ii][1], ii))\n        except:\n            pass\n        try:\n            k = heap[0]\n        except:\n            continue\n        if s[k[1]][0] == 1:\n            heappop(heap)\n        s[k[1]][0] -= 1\n    tot = 0\n    for i in s:\n        tot += s[i][0] * s[i][1]\n    print(tot)", "import heapq\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (N, D) = map(int, input().split())\n        day = {}\n        for tr in range(1, N + 1):\n            (Di, Ti, Si) = map(int, input().split())\n            if Di not in day:\n                day[Di] = []\n            day[Di].append((-1 * Si, Ti))\n        arr = []\n        for i in range(1, D + 1):\n            if i in day:\n                for record in day[i]:\n                    heapq.heappush(arr, record)\n            if len(arr) != 0:\n                element = heapq.heappop(arr)\n                if element[1] > 1:\n                    heapq.heappush(arr, (element[0], element[1] - 1))\n        sadness = 0\n        for element in arr:\n            sadness += -1 * element[0] * element[1]\n        print(sadness)\nimport profile\nmain()", "import heapq\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (N, D) = map(int, input().split())\n        day = {}\n        for tr in range(1, N + 1):\n            (Di, Ti, Si) = map(int, input().split())\n            if Di not in day:\n                day[Di] = []\n            day[Di].append((-1 * Si, Ti))\n        arr = []\n        for i in range(1, D + 1):\n            if i in day:\n                for record in day[i]:\n                    heapq.heappush(arr, record)\n            if len(arr) != 0:\n                element = heapq.heappop(arr)\n                if element[1] > 1:\n                    heapq.heappush(arr, (element[0], element[1] - 1))\n        sadness = 0\n        for element in arr:\n            sadness += -1 * element[0] * element[1]\n        print(sadness)\nimport profile\nmain()", "import heapq as pq\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (N, D) = map(int, input().split())\n    dl = defaultdict(list)\n    for a1 in range(N):\n        (Di, Ti, Si) = map(int, input().split())\n        dl[Di].append((-1 * Si, Ti))\n    heap = []\n    res = 0\n    for i in range(1, D + 1):\n        for ele in dl[i]:\n            pq.heappush(heap, ele)\n        while heap:\n            ele = pq.heappop(heap)\n            if ele[1] > 1:\n                res += ele[0]\n                pq.heappush(heap, (ele[0], ele[1] - 1))\n                break\n            elif ele[1] == 1:\n                res += ele[0]\n                break\n    for k in dl:\n        for ele in dl[k]:\n            res += -1 * ele[0] * ele[1]\n    print(res)", "import heapq\nfor z in range(int(input())):\n    (n, d) = tuple(map(int, input().split()))\n    sad = [tuple(map(int, input().split())) for i in range(n)]\n    sad.sort()\n    heap = []\n    heapq.heapify(heap)\n    j = 0\n    for i in range(1, d + 1):\n        if j < n and sad[j][0] == i:\n            while j < n and sad[j][0] == i:\n                heapq.heappush(heap, (-sad[j][2], sad[j][1]))\n                j += 1\n        if len(heap) > 0:\n            tu = heapq.heappop(heap)\n            tu1 = (tu[0], tu[1] - 1)\n            if tu1[1] > 0:\n                heapq.heappush(heap, tu1)\n    heapl = list(heap)\n    tot = 0\n    for i in range(len(heapl)):\n        tot -= heapl[i][0] * heapl[i][1]\n    print(tot)", "import heapq\nt = int(input())\nfor i in range(t):\n    (n, d) = map(int, input().split())\n    l = [[] for j in range(d)]\n    for i in range(n):\n        (a, b, c) = map(int, input().split())\n        l[a - 1].append([-c, b, a])\n    total = 0\n    heap = []\n    for i in l:\n        for j in i:\n            heapq.heappush(heap, j)\n        if len(heap) > 0:\n            z = heapq.heappop(heap)\n            z[1] -= 1\n            if z[1] > 0:\n                heapq.heappush(heap, z)\n    for i in heap:\n        total += i[0] * (-1 * i[1])\n    print(total)", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, d) = map(int, input().split())\n    day = [[] for i in range(d)]\n    for i in range(n):\n        (di, ti, si) = map(int, input().split())\n        day[di - 1].append([-si, di, ti])\n    heap = []\n    for d in day:\n        for e in d:\n            heapq.heappush(heap, e)\n        if len(heap) > 0:\n            ans = heapq.heappop(heap)\n            ans[2] -= 1\n            if ans[2] > 0:\n                heapq.heappush(heap, ans)\n    ans = 0\n    for e in heap:\n        ans += -e[0] * e[2]\n    print(ans)", "class BinHeap:\n\n    def __init__(self):\n        self.heaplist = [0]\n        self.currentSize = 0\n\n    def percUp(self, i):\n        while i // 2 > 0:\n            if self.heaplist[i][1] < self.heaplist[i // 2][1]:\n                (self.heaplist[i], self.heaplist[i // 2]) = (self.heaplist[i // 2], self.heaplist[i])\n            i = i // 2\n\n    def minChild(self, i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        elif self.heaplist[i * 2][1] < self.heaplist[i * 2 + 1][1]:\n            return i * 2\n        else:\n            return i * 2 + 1\n\n    def percDown(self, i):\n        while i * 2 <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heaplist[i][1] > self.heaplist[mc][1]:\n                (self.heaplist[i], self.heaplist[mc]) = (self.heaplist[mc], self.heaplist[i])\n            i = mc\n\n    def insert(self, k):\n        self.heaplist.append(k)\n        self.currentSize += 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heaplist[1]\n        self.heaplist[1] = self.heaplist[self.currentSize]\n        self.currentSize -= 1\n        self.heaplist.pop()\n        self.percDown(1)\n        return retval\n\n    def buildHeap(self, alist):\n        self.heaplist = [0] + alist[:]\n        self.currentSize = len(alist)\n        i = len(alist) // 2\n        while i > 0:\n            self.percDown(i)\n            i -= 1\nfor _ in range(int(input().strip())):\n    (n, d) = map(int, input().strip().split())\n    trainers = []\n    for i in range(n):\n        (d_i, t_i, s_i) = map(int, input().strip().split())\n        trainers.append([d_i, -1 * s_i, t_i])\n    trainers.sort(reverse=True)\n    bh = BinHeap()\n    for day_num in range(1, d + 1):\n        while trainers and trainers[-1][0] == day_num:\n            bh.insert(trainers.pop())\n        if len(bh.heaplist) > 1:\n            bh.heaplist[1][2] -= 1\n            if bh.heaplist[1][2] == 0:\n                bh.delMin()\n    answer = 0\n    while len(bh.heaplist) > 1:\n        remaining = bh.heaplist.pop()\n        answer += remaining[1] * remaining[2]\n    print(abs(answer))", "from heapq import *\n\ndef soln(d, inputlist):\n    ans = 0\n    j = 0\n    heap = []\n    for i in range(1, d + 1):\n        while j < len(inputlist) and inputlist[j][0] <= i:\n            (days, lectures, sadness) = inputlist[j]\n            heappush(heap, [-1 * sadness, lectures])\n            j += 1\n        if len(heap) <= 0:\n            continue\n        current = heap[0]\n        current[1] -= 1\n        if current[1] <= 0:\n            k = heappop(heap)\n    for i in heap:\n        ans += -1 * i[0] * i[1]\n    return ans\nt = int(input())\nfor i in range(t):\n    (n, d) = map(int, input().split())\n    l = []\n    for j in range(n):\n        l.append(list(map(int, input().split())))\n    ans = soln(d, sorted(l))\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    finalAnswer = 0\n    (n, day) = [int(x) for x in input().strip().split()]\n    valf = [int(i) for i in range(day + 1)]\n    dt = []\n    si = []\n    for i in range(n):\n        (d, t, s) = [int(x) for x in input().strip().split()]\n        dt.append((d - 1, t))\n        si.append((s, i))\n    si = sorted(si)\n    for i in range(n - 1, -1, -1):\n        remaining = dt[si[i][1]][0]\n        tmp = remaining\n        j = 0\n        while j <= day:\n            if tmp > valf[tmp]:\n                j += 1\n                tmp = valf[tmp]\n            else:\n                j = day + 1\n        j = 0\n        while j <= day:\n            if tmp != valf[tmp]:\n                j += 1\n                tmp = valf[tmp]\n            else:\n                j = day + 1\n        training = dt[si[i][1]][1]\n        while day > tmp:\n            training -= 1\n            valf[tmp] = remaining\n            tmp += 1\n            if training <= 0:\n                break\n            j = 0\n            while j <= day:\n                if tmp > valf[tmp]:\n                    tmp = valf[tmp]\n                    j += 1\n                else:\n                    j = day + 1\n            j = 0\n            while j <= day:\n                if tmp != valf[tmp]:\n                    j += 1\n                    tmp = valf[tmp]\n                else:\n                    j = day + 1\n        valf[remaining] = tmp\n        finalAnswer += training * si[i][0]\n    print(finalAnswer)", "t = int(input())\nfor _ in range(t):\n    finalAnswer = 0\n    (n, day) = [int(x) for x in input().strip().split()]\n    valf = [int(i) for i in range(day + 1)]\n    dt = []\n    si = []\n    for i in range(n):\n        (d, t, s) = [int(x) for x in input().strip().split()]\n        dt.append((d - 1, t))\n        si.append((s, i))\n    si = sorted(si)\n    for i in range(n - 1, -1, -1):\n        remaining = dt[si[i][1]][0]\n        tempanother = remaining\n        j = 0\n        while j <= day:\n            if tempanother > valf[tempanother]:\n                j += 1\n                tempanother = min(tempanother, valf[tempanother])\n            else:\n                j = day + 1\n        j = 0\n        while j <= day:\n            if tempanother != valf[tempanother]:\n                j += 1\n                tempanother = valf[tempanother]\n            else:\n                j = day + 1\n        training = dt[si[i][1]][1]\n        while day > tempanother:\n            training -= 1\n            valf[tempanother] = remaining\n            tempanother += 1\n            if training <= 0:\n                break\n            j = 0\n            while j <= day:\n                if tempanother > valf[tempanother]:\n                    tempanother = valf[tempanother]\n                    j += 1\n                else:\n                    j = day + 1\n            j = 0\n            while j <= day:\n                if tempanother != valf[tempanother]:\n                    j += 1\n                    tempanother = valf[tempanother]\n                else:\n                    j = day + 1\n        valf[remaining] = tempanother\n        finalAnswer += training * si[i][0]\n    print(finalAnswer)", "from heapq import heappush, heappop, heapify\n\ndef solve(N, D, arr):\n    heapify(arr)\n    h = []\n    for i in range(1, D + 1):\n        cur_list = []\n        while len(arr) > 0:\n            if arr[0][0] == i:\n                cur_list.append(heappop(arr))\n            else:\n                break\n        if len(cur_list) == 0:\n            pass\n        else:\n            for e in cur_list:\n                heappush(h, (-1 * e[2], (e[0], e[1], e[2])))\n        if len(h) > 0:\n            min_e = h[0]\n            if min_e[1][1] == 1:\n                heappop(h)\n            else:\n                h[0] = (min_e[0], (min_e[1][0], min_e[1][1] - 1, min_e[1][2]))\n    sad = 0\n    for x in h:\n        sad += x[1][1] * x[1][2]\n    return sad\nT = int(input())\nfor t in range(T):\n    inp_1 = list(map(int, input().split()))\n    N = inp_1[0]\n    D = inp_1[1]\n    arr = []\n    for n in range(N):\n        r = list(map(int, input().split()))\n        arr.append(r)\n    print(solve(N, D, arr))", "import heapq\nmx = 99999999\nfor i in range(int(input())):\n    (n, d) = [int(x) for x in input().split()]\n    (data, hp) = ([], [])\n    for i in range(n):\n        (days, num_lec, sad) = [int(x) for x in input().split()]\n        data.append([days, num_lec, sad])\n    data = sorted(data)\n    data.append([mx, mx, mx])\n    person = 0\n    for day in range(1, d + 1):\n        while data[person][0] <= day:\n            heapq.heappush(hp, (-data[person][2], data[person][1]))\n            person += 1\n        if len(hp):\n            (sad, lec_remaining) = heapq.heappop(hp)\n            if lec_remaining > 1:\n                lec_remaining -= 1\n                heapq.heappush(hp, (sad, lec_remaining))\n    ans = 0\n    for i in hp:\n        ans += -i[0] * i[1]\n    print(ans)", "from heapq import *\nt = int(input())\nfor tc in range(t):\n    (n, d) = map(int, input().split())\n    trd = []\n    for dy in range(d):\n        trd.append([])\n    trainers = {}\n    x = []\n    for i in range(n):\n        (da, t, s) = map(int, input().split())\n        trd[da - 1].append(i)\n        trainers[i] = [da, t, s]\n    for i in range(d):\n        for e in trd[i]:\n            heappush(x, [-trainers[e][2], trainers[e][1]])\n        if len(x) > 0:\n            if x[0][1] - 1 == 0:\n                heappop(x)\n            else:\n                x[0][1] -= 1\n    ts = 0\n    for e in x:\n        ts += -e[0] * e[1]\n    print(ts)"]