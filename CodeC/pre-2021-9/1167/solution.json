["(q, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    Z = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in Z:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        Z = temp\n    return Z\nfor _ in range(q):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(q - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nZ = dfs(0, -1, x)\nfor m in Z:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "(q, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    Z = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in Z:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        Z = temp\n    return Z\nfor _ in range(q):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(q - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nZ = dfs(0, -1, x)\nfor m in Z:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "(q, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    X = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in X:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        X = temp\n    return X\nfor _ in range(q):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(q - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nX = dfs(0, -1, x)\nfor m in X:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "(q, x1) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x1):\n    X = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x1))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in X:\n                flag = True\n                flag0 = True\n                if y[0] == x1:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        X = temp\n    return X\nfor _ in range(q):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(q - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nX = dfs(0, -1, x1)\nfor m in X:\n    if m[0] == x1:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "(r, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    X = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in X:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        X = temp\n    return X\nfor _ in range(r):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(r - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nX = dfs(0, -1, x)\nfor m in X:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "(q, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    X = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in X:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        X = temp\n    return X\nfor _ in range(q):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(q - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nX = dfs(0, -1, x)\nfor m in X:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "global tree\n(n1, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    X = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in X:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        X = temp\n    return X\nfor _ in range(n1):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(n1 - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nX = dfs(0, -1, x)\nfor m in X:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "global tree\n(n, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    X = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in X:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        X = temp\n    return X\nfor _ in range(n):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(n - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nX = dfs(0, -1, x)\nfor m in X:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "global tree\n(n1, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    X = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in X:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        X = temp\n    return X\nfor _ in range(n1):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(n1 - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nX = dfs(0, -1, x)\nfor m in X:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "global tree\n(z, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    X = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in X:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        X = temp\n    return X\nfor _ in range(z):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(z - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nX = dfs(0, -1, x)\nfor m in X:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "global tree\n(n, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    X = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in X:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        X = temp\n    return X\nfor _ in range(n):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(n - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nX = dfs(0, -1, x)\nfor m in X:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "global tree\n(n, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    X = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in X:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        X = temp\n    return X\nfor _ in range(n):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(n - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nX = dfs(0, -1, x)\nfor m in X:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "global tree\n(n, x) = [int(i) for i in input().split()]\ntree = []\n\ndef dfs(i, p, x):\n    X = [[a[i], 1]]\n    Y = []\n    for j in tree[i]:\n        if j != p:\n            Y.append(dfs(j, i, x))\n    for sub in Y:\n        temp = []\n        for y in sub:\n            for m in X:\n                flag = True\n                flag0 = True\n                if y[0] == x:\n                    for o in temp:\n                        if o[0] == m[0]:\n                            o[1] += y[1] * m[1]\n                            flag0 = False\n                    if flag0:\n                        temp.append([m[0], y[1] * m[1]])\n                for o in temp:\n                    if o[0] == y[0] ^ m[0]:\n                        o[1] += y[1] * m[1]\n                        flag = False\n                        break\n                if flag:\n                    temp.append([y[0] ^ m[0], y[1] * m[1]])\n        X = temp\n    return X\nfor _ in range(n):\n    tree.append([])\na = [int(i) for i in input().split()]\nfor i in range(n - 1):\n    (u, v) = [int(i) for i in input().split()]\n    tree[u - 1].append(v - 1)\n    tree[v - 1].append(u - 1)\nans = 0\nX = dfs(0, -1, x)\nfor m in X:\n    if m[0] == x:\n        ans = m[1]\n        break\nprint(ans % (10 ** 9 + 7))", "import math as ma\nfrom sys import exit\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\ndef li():\n    return list(map(int, input().split()))\n\ndef num():\n    return map(int, input().split())\n\ndef nu():\n    return int(input())\n\ndef find_gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\ndp = 0\nmm = 1000000007\ntree = 0\nvisited = 0\nn = 0\nx = 0\na = 0\nb = 0\n\ndef solve():\n    t = 1\n    for it in range(t):\n        global n, x, a, b, visited\n        (n, x) = num()\n        global dp\n        visited = [False] * n\n        dp = [0] * (n + 1)\n        for i in range(n):\n            dp[i] = [0] * 2\n        a = [0] * n\n        b = [0] * n\n        a = li()\n        global tree\n        tree = [0] * (n + 1)\n        for i in range(n + 1):\n            tree[i] = []\n        for i in range(n - 1):\n            (u, v) = num()\n            u = u - 1\n            v = v - 1\n            tree[u].append(v)\n            tree[v].append(u)\n        find(0)\n        visited = [False] * n\n        dfs(0)\n        xy = 0\n        if b[0] == 0:\n            xy = dp[0][0]\n        if b[0] == x:\n            xy = (xy + dp[0][1]) % mm\n        print(xy)\n\ndef dfs(xp):\n    global visited, tree, b, a, dp, x\n    visited[xp] = True\n    m = 1\n    n = 0\n    for u in tree[xp]:\n        if visited[u] == False:\n            dfs(u)\n            old1 = m\n            old2 = n\n            m = (old2 * dp[u][0] % mm + old1 * dp[u][1] % mm) % mm\n            if x == b[u]:\n                m = (m + dp[u][1] * old2 % mm) % mm\n            if b[u] == 0:\n                m = (m + dp[u][0] * old1 % mm) % mm\n            n = (dp[u][0] * old1 % mm + dp[u][1] * old2 % mm) % mm\n            if b[u] == 0:\n                n = (n + dp[u][0] * old2 % mm) % mm\n            if x == b[u]:\n                n = (n + dp[u][1] * old1 % mm) % mm\n    dp[xp][1] = m\n    dp[xp][0] = n\n\ndef find(xp):\n    global visited, tree, b, a\n    visited[xp] = True\n    for u in tree[xp]:\n        if visited[u] == False:\n            find(u)\n            b[xp] = b[xp] ^ b[u]\n    b[xp] = b[xp] ^ a[xp]\nsolve()", "from collections import defaultdict\nfrom collections import Counter\nimport sys\nsys.setrecursionlimit(10 ** 6)\nM = int(10 ** 9 + 7)\n\ndef merge(cur, child):\n    a_x = xor_list[child][x]\n    B = Counter()\n    for (k1, v1) in xor_list[cur].items():\n        for (k2, v2) in xor_list[child].items():\n            tmp = v1 * v2 % M\n            B[k1 ^ k2] = (B[k1 ^ k2] + tmp) % M\n    for (k, v) in xor_list[cur].items():\n        B[k] = (B[k] + v * a_x % M) % M\n    B = {k: v for (k, v) in B.items() if v != 0}\n    return Counter(B)\n\ndef dfs(cur, parent):\n    for el in tree[cur]:\n        if el == parent:\n            continue\n        dfs(el, cur)\n    for el in tree[cur]:\n        if el == parent:\n            continue\n        xor_list[cur] = merge(cur, el)\n(n, x) = map(int, input().split())\nA = list(map(int, input().split()))\ntree = defaultdict(list)\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    u -= 1\n    v -= 1\n    tree[u].append(v)\n    tree[v].append(u)\nxor_list = [Counter() for i in range(n)]\nfor i in range(n):\n    xor_list[i][A[i]] = 1\ndfs(0, -1)\nprint(xor_list[0][x])", "from sys import stdin, stdout\nmod = 10 ** 9 + 7\n(N, x) = [int(v) for v in stdin.readline().split()]\na = [None] + [int(v) for v in stdin.readline().split()]\nneighbors = [None] + [[] for i in range(N)]\nfor edge in range(N - 1):\n    (u, v) = [int(v) for v in stdin.readline().split()]\n    neighbors[v].append(u)\n    neighbors[u].append(v)\n\ndef solve_0(node, father=-1):\n    data = [solve_0(child, node) for child in neighbors[node] if child != father]\n    if len(data) == 0:\n        return (a[node], 0)\n    v = a[node]\n    s = 0\n    for (v1, s1) in data:\n        v ^= v1\n        s += s1 + (v1 == 0)\n    return (v, s)\n\ndef solve(node, father=-1):\n    data = [solve(child, node) for child in neighbors[node] if child != father]\n    if len(data) == 0:\n        return (a[node], 1, 0)\n    v = data[0][0]\n    s = data[0][1]\n    c = data[0][2]\n    s_bar = (s + (v == 0) * c) % mod\n    c_bar = (c + (v == x) * s) % mod\n    for (v1, s1, c1) in data[1:]:\n        s1_bar = (s1 + (v1 == 0) * c1) % mod\n        c1_bar = (c1 + (v1 == x) * s1) % mod\n        v ^= v1\n        (s_bar, c_bar) = [s_bar * s1_bar + c_bar * c1_bar, s_bar * c1_bar + s1_bar * c_bar]\n    return (v ^ a[node], s_bar % mod, c_bar % mod)\nif x == 0:\n    (v, s) = solve_0(1)\n    if v == 0:\n        print(pow(2, s, mod))\n    else:\n        print(0)\nelse:\n    (v, s, c) = solve(1)\n    if v == x:\n        print(s)\n    elif v == 0:\n        print(c)\n    else:\n        print(0)"]