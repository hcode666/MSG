["def Cout(my_list, freq):\n    for item in my_list:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq\n\ndef sr(n, m):\n    (s, p) = (0, 1)\n    if n >= m:\n        n = m - 1\n    for i in range(1, n + 1):\n        p = p * i % m\n        s = (s + i * p % m) % m\n    return s % m\n\ndef ss(n, m):\n    m *= 2\n    p = n ** 2 % m\n    p *= (n + 1) % m\n    return p // 2\n(n, m) = map(int, input().split())\na = list(map(int, input().split()))\n(b, t, s, p, cf) = (Cout(a, {}), 0, 0, 1, [])\nfor i in range(1, m):\n    p = p * (i + 1) % m\n    cf.append((p - 1 + m) % m)\nfor i in b:\n    if i >= m:\n        r = len(cf) - 1\n    else:\n        r = i - 1\n    t = (t + (ss(i, m) + cf[r]) * b[i]) % m\nprint(t % m)", "def Cout(my_list, freq):\n    for item in my_list:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq\n\ndef sr(n, m):\n    (s, p) = (0, 1)\n    if n >= m:\n        n = m - 1\n    for i in range(1, n + 1):\n        p = p * i % m\n        s = (s + i * p % m) % m\n    return s % m\n\ndef ss(n, m):\n    m *= 2\n    p = n ** 2 % m\n    p *= (n + 1) % m\n    return p // 2\n(n, m) = map(int, input().split())\na = list(map(int, input().split()))\n(b, t, s, p, cf) = (Cout(a, {}), 0, 0, 1, [])\nfor i in range(1, m):\n    p = p * (i + 1) % m\n    cf.append((p - 1 + m) % m)\nfor i in b:\n    if i >= m:\n        r = len(cf) - 1\n    else:\n        r = i - 1\n    t = (t + (ss(i, m) + cf[r]) * b[i]) % m\nprint(t % m)", "import math\n\ndef Cout(my_list, freq):\n    for item in my_list:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq\n\ndef sr(n, m):\n    (s, p) = (0, 1)\n    if n >= m:\n        n = m - 1\n    for i in range(1, n + 1):\n        p = p * i % m\n        s = (s + i * p % m) % m\n    return s % m\n\ndef ss(n, m):\n    m *= 2\n    p = n ** 2 % m\n    p *= (n + 1) % m\n    return p // 2\n(n, m) = map(int, input().split())\na = list(map(int, input().split()))\n(b, t, s, p, cf) = (Cout(a, {}), 0, 0, 1, [])\nfor i in range(1, m):\n    p = p * (i + 1) % m\n    cf.append((p - 1 + m) % m)\nfor i in b:\n    if i >= m:\n        r = len(cf) - 1\n    else:\n        r = i - 1\n    t = (t + (ss(i, m) + cf[r]) * b[i]) % m\nprint(t % m)", "import math\n\ndef Cout(my_list):\n    freq = {}\n    for item in my_list:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq\n\ndef sr(n, m):\n    (s, p) = (0, 1)\n    if n >= m:\n        n = m - 1\n    for i in range(1, n + 1):\n        p *= i\n        p %= m\n        s += i * p % m\n        s %= m\n    return s % m\n\ndef ss(n, m):\n    m *= 2\n    p = n ** 2 % m\n    p *= (n + 1) % m\n    return p // 2\n(n, m) = map(int, input().split())\na = list(map(int, input().split()))\n(b, t, s, p, cf) = (Cout(a), 0, 0, 1, [])\nfor i in range(1, m):\n    p *= i + 1\n    p = p % m\n    s = p - 1 + m\n    cf.append(s % m)\nfor i in b:\n    if i >= m:\n        r = len(cf) - 1\n    else:\n        r = i - 1\n    y = ss(i, m) + cf[r]\n    t += y * b[i]\n    t %= m\nprint(t % m)", "import math\n\ndef Cout(my_list):\n    freq = {}\n    for item in my_list:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq\n    for (key, value) in freq.items():\n        print('% d : % d' % (key, value))\n\ndef sr(n, m):\n    s = 0\n    p = 1\n    if n >= m:\n        n = m - 1\n    for i in range(1, n + 1):\n        p *= i\n        p = p % m\n        s += i * p % m\n        s = s % m\n    return s % m\n\ndef ss(n, m):\n    m *= 2\n    p = n ** 2 % m\n    p *= (n + 1) % m\n    q = p // 2\n    return q\n(n, m) = map(int, input().split())\na = list(map(int, input().split()))\nb = Cout(a)\nt = 0\ns = 0\np = 1\ncf = []\nfor i in range(1, m):\n    p *= i + 1\n    p = p % m\n    s = p - 1 + m\n    cf.append(s % m)\nfor i in b:\n    if i >= m:\n        r = len(cf) - 1\n    else:\n        r = i - 1\n    y = ss(i, m) + cf[r]\n    t += y * b[i]\n    t = t % m\nprint(t % m)", "import math\n\ndef Cout(my_list):\n    freq = {}\n    for item in my_list:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq\n    for (key, value) in freq.items():\n        print('% d : % d' % (key, value))\n\ndef sr(n, m):\n    s = 0\n    p = 1\n    if n >= m:\n        n = m - 1\n    for i in range(1, n + 1):\n        p *= i\n        p = p % m\n        s += i * p % m\n        s = s % m\n    return s % m\n\ndef ss(n, m):\n    m *= 2\n    p = n ** 2 % m\n    p *= (n + 1) % m\n    q = p // 2\n    return q\n(n, m) = map(int, input().split())\na = list(map(int, input().split()))\nb = Cout(a)\nt = 0\ns = 0\np = 1\ncf = []\nfor i in range(1, m):\n    p *= i + 1\n    p = p % m\n    s = p - 1 + m\n    cf.append(s % m)\nfor i in b:\n    if i >= m:\n        r = len(cf) - 1\n    else:\n        r = i - 1\n    y = ss(i, m) + cf[r]\n    t += y * b[i]\n    t = t % m\nprint(t % m)", "import math\nz = input().split()\n(n, m) = map(int, z[:2])\nz = input().split()\nps = list(map(int, z[:n]))\nfacmem = {1: 1}\nrf = 1\nfor afac in range(2, 10000):\n    rf = rf * afac % m\n    facmem[afac] = rf\n\ndef mfac(a):\n    if a not in facmem:\n        facmem[a] = math.factorial(a)\n    return facmem[a]\nfcpart = polypart = 0\ndm = 2 * m\nfor p in ps:\n    if p < m - 1:\n        fcpart += mfac(p + 1) % m\n    fcpart -= 1\n    p %= dm\n    polypart = (polypart + p * p * (p + 1)) % dm\nans = (fcpart + polypart // 2) % m\nif ans < 0:\n    ans += m\nprint(ans)", "def cal(x, m):\n    if x < m:\n        return (factorials[x + 1] - 1 + x * x * (x + 1) // 2) % m\n    return (x * x * (x + 1) // 2 - 1) % m\n\ndef solve(arr, n, m):\n    return sum([cal(x, m) for x in arr]) % m\n(n, m) = map(int, input().split())\nfactorials = [1 for i in range(10 ** 7 + 1)]\nfor i in range(2, 100001):\n    factorials[i] = i * factorials[i - 1] % m\narr = list(map(int, input().split()))\nprint(solve(arr, n, m))", "def fast_Power(base, n, m):\n    if n == 0:\n        return 1\n    if n == 1:\n        return base\n    halfn = fast_Power(base, n // 2, m)\n    if n % 2 == 0:\n        return halfn * halfn % m\n    else:\n        return halfn * halfn % m * base % m\n\ndef mod_Inverse(n, m):\n    return fast_Power(n, m - 2, m)\n\ndef recurse_Fact(n, m):\n    if n in cache:\n        return cache[n]\n    elif n < 2:\n        return 1\n    else:\n        ans = n * recurse_Fact(n - 1, m) % m\n        cache[n] = ans\n        return ans\n\ndef fact(n, modulus):\n    if n >= modulus:\n        ans = 0\n    elif n <= modulus // 2:\n        ans = recurse_Fact(n, modulus)\n    else:\n        ans = recurse_Fact(modulus - n - 1, modulus)\n        ans = mod_Inverse(ans, modulus)\n        if n % 2 == 0:\n            ans = -1 * ans + modulus\n    return ans % modulus\n\ndef f(n, m):\n    val1 = (n * n + n * n * n) // 2 % m\n    val2 = fact(n + 1, m) - 1\n    return (val1 + val2) % m\n(noOfElements, modulo) = map(int, input().strip().split())\nar = list(map(int, input().strip().split()))\nans = 0\ncache = {}\nar.sort()\nfor p in ar:\n    ans += f(p, modulo)\nprint(ans % modulo)", "def extended_euclid(a, b):\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        (d1, x1, y1) = extended_euclid(b, a % b)\n        (d, x, y) = (d1, y1, x1 - a // b * y1)\n        return (d, x, y)\n\ndef modInv(a, n):\n    (d, x, y) = extended_euclid(a, n)\n    if d == 1:\n        return x % n\n\ndef recurseFact(n, m):\n    if n in cache:\n        return cache[n]\n    elif n <= 1:\n        return 1\n    else:\n        ans = n * recurseFact(n - 1, m) % m\n        cache[n] = ans\n        return ans\n\ndef fact(n, modulus):\n    if n >= modulus:\n        ans = 0\n    elif n <= modulus // 2:\n        ans = recurseFact(n, modulus)\n    else:\n        ans = recurseFact(modulus - n - 1, modulus)\n        ans = modInv(ans, modulus)\n        if n % 2 == 0:\n            ans = -1 * ans + modulus\n    return ans % modulus\n\ndef f(n, m):\n    M = m * 2\n    val1 = (n * n % M + n * n * n % M) % M\n    val1 //= 2\n    val2 = fact(n + 1, m) - 1\n    return (val1 + val2) % m\n(noOfElements, modulo) = map(int, input().strip().split())\nar = list(map(int, input().strip().split()))\nans = 0\ncache = {}\nar.sort()\nfor p in ar:\n    ans += f(p, modulo)\nprint(ans % modulo)", "def extended_euclid(a, b):\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        (d1, x1, y1) = extended_euclid(b, a % b)\n        (d, x, y) = (d1, y1, x1 - a // b * y1)\n        return (d, x, y)\n\ndef modInv(a, n):\n    (d, x, y) = extended_euclid(a, n)\n    if d == 1:\n        return x % n\n\ndef recurseFact(n, m):\n    if n in cache:\n        return cache[n]\n    elif n <= 1:\n        return 1\n    else:\n        ans = n * recurseFact(n - 1, m) % m\n        cache[n] = ans\n        return ans\n\ndef fact(n, modulus):\n    if n >= modulus:\n        ans = 0\n    elif n <= modulus // 2:\n        ans = recurseFact(n, modulus)\n    else:\n        ans = recurseFact(modulus - n - 1, modulus)\n        ans = modInv(ans, modulus)\n        if n % 2 == 0:\n            ans = -1 * ans + modulus\n    return ans % modulus\n\ndef f(n, m):\n    M = m * 2\n    val1 = (n * n % M + n * n * n % M) % M\n    val1 //= 2\n    val2 = fact(n + 1, m) - 1\n    return (val1 + val2) % m\n(noOfElements, modulo) = map(int, input().strip().split())\nar = list(map(int, input().strip().split()))\nans = 0\ncache = {}\nar.sort()\nfor p in ar:\n    ans += f(p, modulo)\nprint(ans % modulo)", "def extended_euclid(a, b):\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        (d1, x1, y1) = extended_euclid(b, a % b)\n        (d, x, y) = (d1, y1, x1 - a // b * y1)\n        return (d, x, y)\n\ndef modInv(a, n):\n    (d, x, y) = extended_euclid(a, n)\n    if d == 1:\n        return x % n\n\ndef recurseFact(n, m):\n    if n in cache:\n        return cache[n]\n    elif n <= 1:\n        return 1\n    else:\n        ans = n * recurseFact(n - 1, m) % m\n        cache[n] = ans\n        return ans\n\ndef fact(n, modulus):\n    if n >= modulus:\n        ans = 0\n    elif n <= modulus // 2:\n        ans = recurseFact(n, modulus)\n    else:\n        ans = recurseFact(modulus - n - 1, modulus)\n        ans = modInv(ans, modulus)\n        if n % 2 == 0:\n            ans = -1 * ans + modulus\n    return ans % modulus\n\ndef f(n, m):\n    M = m * 2\n    val1 = (n ** 2 + n ** 3) % M\n    val1 //= 2\n    val2 = fact(n + 1, m) - 1\n    return (val1 + val2) % m\n(noOfElements, modulo) = map(int, input().strip().split())\nar = list(map(int, input().strip().split()))\nans = 0\ncache = {}\nar.sort()\nfor p in ar:\n    ans += f(p, modulo)\nprint(ans % modulo)", "def extended_euclid(a, b):\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        (d1, x1, y1) = extended_euclid(b, a % b)\n        (d, x, y) = (d1, y1, x1 - a // b * y1)\n        return (d, x, y)\n\ndef modInv(a, n):\n    b = 1\n    (d, x, y) = extended_euclid(a, n)\n    if d % b == 0:\n        return x % n\n\ndef recurseFact(n, m):\n    if n in cache:\n        return cache[n]\n    elif n <= 1:\n        return 1\n    else:\n        ans = n * recurseFact(n - 1, m) % m\n        cache[n] = ans\n        return ans\n\ndef fact(n, modulus):\n    if n >= modulus:\n        ans = 0\n    elif n <= modulus // 2:\n        ans = recurseFact(n, modulus)\n    else:\n        ans = recurseFact(modulus - n - 1, modulus)\n        ans = modInv(ans, modulus)\n        if n % 2 == 0:\n            ans = -1 * ans + modulus\n    return ans % modulus\n\ndef f(n, m):\n    val1 = (n ** 2 + n ** 3) // 2 % m\n    val2 = fact(n + 1, m) - 1\n    return (val1 + val2) % m\n(noOfElements, modulo) = map(int, input().strip().split())\nar = list(map(int, input().strip().split()))\nans = 0\ncache = {}\nar.sort()\nfor p in ar:\n    ans += f(p, modulo)\nprint(ans % modulo)", "def fast_Power(base, n, m):\n    if n == 0:\n        return 1\n    if n == 1:\n        return base\n    halfn = fast_Power(base, n // 2, m)\n    if n % 2 == 0:\n        return halfn * halfn % m\n    else:\n        return halfn * halfn % m * base % m\n\ndef mod_Inverse(n, m):\n    return fast_Power(n, m - 2, m)\n\ndef recurse_Fact(n, m):\n    if n in cache:\n        return cache[n]\n    elif n < 2:\n        return 1\n    else:\n        ans = n * recurse_Fact(n - 1, m) % m\n        cache[n] = ans\n        return ans\n\ndef fact(n, modulus):\n    if n >= modulus:\n        ans = 0\n    elif n <= modulus // 2:\n        ans = recurse_Fact(n, modulus)\n    else:\n        ans = recurse_Fact(modulus - n - 1, modulus)\n        ans = mod_Inverse(ans, modulus)\n        if n % 2 == 0:\n            ans = -1 * ans + modulus\n    return ans % modulus\n\ndef f(n, m):\n    val1 = (n * n + n * n * n) // 2 % m\n    val2 = fact(n + 1, m) - 1\n    return (val1 + val2) % m\n(noOfElements, modulo) = map(int, input().strip().split())\nar = list(map(int, input().strip().split()))\nans = 0\ncache = {}\nar.sort()\nfor p in ar:\n    ans += f(p, modulo)\nprint(ans % modulo)", "def fast_Power(base, n, m):\n    if n == 0:\n        return 1\n    if n == 1:\n        return base\n    halfn = fast_Power(base, n // 2, m)\n    if n % 2 == 0:\n        return halfn * halfn % m\n    else:\n        return halfn * halfn % m * base % m\n\ndef mod_Inverse(n, m):\n    return fast_Power(n, m - 2, m)\n\ndef recurse_Fact(n, m):\n    if n in cache:\n        return cache[n]\n    elif n < 2:\n        return 1\n    else:\n        ans = n * recurse_Fact(n - 1, m) % m\n        cache[n] = ans\n        return ans\n\ndef fact(n, modulus):\n    if n >= modulus:\n        ans = 0\n    elif n <= modulus // 2:\n        ans = recurse_Fact(n, modulus)\n    else:\n        ans = recurse_Fact(modulus - n - 1, modulus)\n        ans = mod_Inverse(ans, modulus)\n        if n % 2 == 0:\n            ans = -1 * ans + modulus\n    return ans % modulus\n\ndef f(n, m):\n    val1 = (n ** 2 + n ** 3) // 2 % m\n    val2 = fact(n + 1, m) - 1\n    return (val1 + val2) % m\n(noOfElements, modulo) = map(int, input().strip().split())\nar = list(map(int, input().strip().split()))\nans = 0\ncache = {}\nar.sort()\nfor p in ar:\n    ans += f(p, modulo)\nprint(ans % modulo)", "(n, m) = input().split()\nn = int(n)\nm = int(m)\na = []\ns = 0\na = input().split()\nfor i in range(len(a)):\n    a[i] = int(a[i])\na.sort()\nf = a[len(a) - 1]\ni = len(a) - 1\nwhile i > 0:\n    if a[i] > m:\n        f = a[i - 1]\n    else:\n        break\n    i = i - 1\nif a[0] >= m:\n    f = 0\nj = max(a)\ng = []\ng.append(1)\ng.append(1)\nif j + 2 < m:\n    d = j + 2\nelse:\n    d = f + 2\nr = 0\nfor i in range(2, d):\n    if g[i - 1] * i % m != 0:\n        g.append(g[i - 1] * i % m)\n    else:\n        break\nfor i in range(len(a)):\n    p = a[i]\n    if p + 1 < len(g):\n        s = s + (g[p + 1] + p * p * (p + 1) // 2 % m - 1)\n    else:\n        s = s + (p * p * (p + 1) // 2 % m - 1)\nprint(s % m)", "def fastPower(base, n, m):\n    if n == 0:\n        return 1\n    if n == 1:\n        return base\n    halfn = fastPower(base, n // 2, m)\n    if n % 2 == 0:\n        return halfn * halfn % m\n    else:\n        return halfn * halfn % m * base % m\n\ndef modInv(n, m):\n    return fastPower(n, m - 2, m)\n\ndef recurseFact(n, m):\n    if n in cache:\n        return cache[n]\n    elif n < 2:\n        return 1\n    else:\n        ans = n * recurseFact(n - 1, m) % m\n        cache[n] = ans\n        return ans\n\ndef fact(n, modulus):\n    if n >= modulus:\n        ans = 0\n    elif n <= modulus // 2:\n        ans = recurseFact(n, modulus)\n    else:\n        ans = recurseFact(modulus - n - 1, modulus)\n        ans = modInv(ans, modulus)\n        if n % 2 == 0:\n            ans = -1 * ans + modulus\n    return ans % modulus\n\ndef f(n, m):\n    val1 = (n ** 2 + n ** 3) // 2 % m\n    val2 = fact(n + 1, m) - 1\n    return (val1 + val2) % m\n(noOfElements, modulo) = map(int, input().strip().split())\nar = list(map(int, input().strip().split()))\nans = 0\ncache = {}\nar.sort()\nfor p in ar:\n    ans += f(p, modulo)\nprint(ans % modulo)", "def h():\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort()\n    S = 0\n    start = 2\n    cache = 1\n    var = 1\n\n    def i_fac_i(x):\n        nonlocal cache\n        nonlocal var\n        s = cache\n        for i in range(start, x + 1):\n            var = var * (i * i) // (i - 1)\n            s = (s + var) % m\n        cache = s\n        return s\n    for p in A:\n        if p >= m - 1:\n            S = (S + m - 1) % m\n        else:\n            S = (S + i_fac_i(p)) % m\n        start = p + 1\n        S = (S + p * p * (p + 1) // 2 % m) % m\n    print(S)\nh()", "def modfac(i, n, m):\n    fac = facs[i] * (ints[i] + 1) % m\n    nsum = n * n * (n + 1) // 2 % m\n    return (fac + nsum - 1) % m\n\ndef prod(a, b, m):\n    product = 1\n    if a // m != b // m:\n        return 0\n    for i in range(a, b + 1):\n        product = product * i % m\n        if product == 0:\n            return 0\n    return product\n(n, m) = [int(x) for x in input().strip().split()]\nints = [int(x) for x in input().strip().split()]\nints.sort()\nfacs = [None] * len(ints)\nfacs[0] = prod(1, ints[0], m)\nfor i in range(1, len(ints)):\n    facs[i] = facs[i - 1] * prod(ints[i - 1] + 1, ints[i], m) % m\n    if not facs[i]:\n        for j in range(i + 1, len(ints)):\n            facs[j] = 0\n        break\nsum = 0\nfor p in range(len(ints)):\n    sum = (sum + modfac(p, ints[p], m)) % m\nprint(sum)", "facto = [0] * 1000000\n\ndef getfacto(x):\n    if x < 1000000:\n        return facto[x]\n    if x >= m:\n        return 0\n    ans = x\n    return x * getfacto(x - 1) % m\nstri = input().split()\nn = int(stri[0])\nm = int(stri[1])\nfacto[0] = facto[1] = 1\nfor i in range(2, 1000000):\n    facto[i] = facto[i - 1] * i % m\nans = 0\nstri = input().split()\nfor i in range(n):\n    t = int(stri[i])\n    ans = (ans + getfacto(t + 1) + t * t * (t + 1) // 2 % m - 1) % m\nprint(ans)", "(n, m) = [int(i) for i in input().split(' ')]\np = [int(i) for i in input().split(' ')]\n(fact, F, summ, maxp) = (1, [1], 0, max(p))\nfor c in range(2, min(m, max(p) + 2)):\n    fact = fact * c % m\n    F.append(fact)\nfor i in p:\n    if i < m - 1:\n        summ += (F[i] + i * i * (i + 1) // 2 - 1) % m\n    else:\n        summ += (i * i * (i + 1) // 2 - 1) % m\nprint(summ % m)", "from math import *\n\ndef f1(x):\n    ans = 0\n    for k in range(1, x + 1):\n        ans += k * (factorial(k) + x)\n    return ans\n\ndef f2(x):\n    return factorial(x + 1) - 1 + x * x * (x + 1) // 2\n\ndef test():\n    for x in range(1, 21):\n        print(x, f1(x), f2(x))\n\ndef main():\n    (n, m) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    facts = [1, 1]\n    for i in range(2, 10 ** 7 + 10):\n        facts.append(facts[-1] * i % m)\n        if facts[-1] == 0:\n            break\n    ans = 0\n    for n in a:\n        if n + 1 <= len(facts) - 1:\n            ans = ans + facts[n + 1]\n        ans += m - 1\n        tmp = n * n * (n + 1) // 2\n        ans += tmp\n        ans %= m\n    print(ans)\nmain()", "(n, m) = map(int, input().split())\nF = [1]\nfor i in range(1, 10000005):\n    F.append(i * F[i - 1] % m)\nL = list(map(int, input().split()))\nans = 0\nfor item in L:\n    tmp = item * (item + 1) // 2\n    tmp %= m\n    tmp *= item\n    tmp %= m\n    if item < m:\n        tmp += (F[item + 1] + m - 1) % m\n    else:\n        tmp += m - 1\n    tmp %= m\n    ans += tmp\n    ans %= m\nprint(ans)"]