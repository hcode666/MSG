["n = int(input())\nls = list(map(int, input().split()))\nq = int(input())\nred = [0] * n\nfor x in range(n - 1):\n    red[x] = x + 1\nred[-1] = -1\nfor _ in range(q):\n    lk = list(map(int, input().split()))\n    pos = lk[0]\n    peo = lk[1]\n    dis = 0\n    tmp = pos\n    i = pos - 1\n    todo = []\n    while i < n:\n        if peo >= ls[i]:\n            dis += ls[i] * (i - pos + 1)\n            peo -= ls[i]\n            ls[i] = 0\n            tmp = red[i]\n            todo.append(i)\n        else:\n            ls[i] -= peo\n            dis += peo * (i - pos + 1)\n            peo = 0\n            tmp = i\n        if peo == 0 or red[i] == -1:\n            break\n        i = red[i]\n    for x in todo:\n        red[x] = tmp\n    print(dis)", "n = int(input())\nls = list(map(int, input().split()))\nq = int(input())\nred = [0] * n\nfor x in range(n - 1):\n    red[x] = x + 1\nred[-1] = -1\nfor _ in range(q):\n    lk = list(map(int, input().split()))\n    pos = lk[0]\n    peo = lk[1]\n    dis = 0\n    tmp = pos\n    i = pos - 1\n    todo = []\n    while i < n:\n        if peo >= ls[i]:\n            dis += ls[i] * (i - pos + 1)\n            peo -= ls[i]\n            ls[i] = 0\n            tmp = red[i]\n            todo.append(i)\n        else:\n            ls[i] -= peo\n            dis += peo * (i - pos + 1)\n            peo = 0\n            tmp = i\n        if peo == 0 or red[i] == -1:\n            break\n        i = red[i]\n    for x in todo:\n        red[x] = tmp\n    print(dis)", "n = int(input())\nls = list(map(int, input().split()))\nq = int(input())\nred = [0] * n\nfor x in range(n - 1):\n    red[x] = x + 1\nred[-1] = -1\nfor _ in range(q):\n    lk = list(map(int, input().split()))\n    pos = lk[0]\n    peo = lk[1]\n    dis = 0\n    tmp = pos\n    i = pos - 1\n    todo = []\n    while i < n:\n        if peo >= ls[i]:\n            dis += ls[i] * (i - pos + 1)\n            peo -= ls[i]\n            ls[i] = 0\n            tmp = red[i]\n            todo.append(i)\n        else:\n            ls[i] -= peo\n            dis += peo * (i - pos + 1)\n            peo = 0\n            tmp = i\n        if peo == 0 or red[i] == -1:\n            break\n        i = red[i]\n    for x in todo:\n        red[x] = tmp\n    print(dis)", "def answer(x, k):\n    ans = 0\n    (i, p) = (x, k)\n    while i != n:\n        t = p\n        p = max(0, p - a[i])\n        a[i] -= min(a[i], t)\n        if p == 0:\n            if a[i] == 0:\n                i = nextind[i]\n            break\n        dist = nextind[i] - i\n        ans += dist * p\n        i = nextind[i]\n    ans = ans - (n - x) * p\n    p = 0\n    while x < i:\n        nextind[x] = max(nextind[x], i)\n        x += 1 << p\n        p += 1\n    return ans\nn = int(input())\na = list(map(int, input().split()))\nnextind = [i for i in range(1, n + 1)]\nfor q in range(int(input())):\n    (x, k) = map(int, input().split())\n    print(answer(x - 1, k))", "n = int(input())\np = list(map(int, input().split()))\nq = int(input())\nnxt = [i + 1 for i in range(n)]\nfor i in range(q):\n    (x, k) = map(int, input().split())\n    x = x - 1\n    ans = 0\n    stck = []\n    curr = x\n    while k > 0 and curr != n:\n        if p[curr] == 0:\n            curr = nxt[curr]\n        elif p[curr] == k:\n            ans += (curr - x) * k\n            k = 0\n            p[curr] = 0\n        elif p[curr] < k:\n            ans += (curr - x) * p[curr]\n            k -= p[curr]\n            p[curr] = 0\n            stck.append(curr)\n            curr = nxt[curr]\n        else:\n            ans += (curr - x) * k\n            p[curr] -= k\n            k = 0\n    while stck:\n        nxt[stck.pop()] = curr\n    print(ans)", "import sys, math, itertools, random, bisect\nfrom collections import defaultdict\nINF = 10 ** 18\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\nfor _ in range(1):\n    n = int(input())\n    a = get_array()\n    q = int(input())\n    arr = [i for i in range(n)]\n    for i in range(q):\n        (ind, k) = get_ints()\n        ind -= 1\n        x = bisect.bisect_left(arr, ind)\n        ans = 0\n        while arr and x < len(arr):\n            if k == 0:\n                break\n            z = a[arr[x]]\n            if z > k:\n                ans += k * (arr[x] - ind)\n                a[arr[x]] -= k\n                k = 0\n                break\n            else:\n                ans += z * (arr[x] - ind)\n                k -= z\n                del arr[x]\n        print(ans)", "import sys, math, itertools, random, bisect\nfrom collections import defaultdict\nINF = 10 ** 18\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\nfor _ in range(1):\n    n = int(input())\n    a = get_array()\n    q = int(input())\n    arr = [i for i in range(n)]\n    for i in range(q):\n        (ind, k) = get_ints()\n        if len(arr) == 0:\n            print(0)\n            continue\n        ind -= 1\n        x = bisect.bisect_left(arr, ind)\n        ans = 0\n        while arr and x < len(arr):\n            if k == 0:\n                break\n            z = a[arr[x]]\n            if z > k:\n                ans += k * (arr[x] - ind)\n                a[arr[x]] -= k\n                k = 0\n                break\n            else:\n                ans += z * (arr[x] - ind)\n                k -= z\n                del arr[x]\n        print(ans)", "import sys, math, itertools, random, bisect\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\nINF = 10 ** 18\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\nfor _ in range(1):\n    n = int(input())\n    a = [0] + get_array()\n    q = int(input())\n    par = [i for i in range(n + 1)]\n    ans = [0]\n\n    def find(ind, val, x):\n        if par[x] != x:\n            par[x] = find(ind, val, par[x])\n        else:\n            temp = min(val, a[x])\n            ans[0] += temp * (x - ind)\n            val -= temp\n            a[x] -= temp\n            if a[x] == 0:\n                if x < n:\n                    par[x] = par[x + 1]\n                    if val:\n                        par[x] = find(ind, val, par[x])\n        return par[x]\n    for i in range(q):\n        ans[0] = 0\n        (ind, val) = get_ints()\n        find(ind, val, ind)\n        print(ans[0])", "n = int(input())\narr = list(map(int, input().split()))\ndp = [i + 1 for i in range(n)]\nq = int(input())\nmini = 0\nfor _ in range(q):\n    ans = 0\n    (x, k) = map(int, input().split())\n    x = x - 1\n    nb = x\n    i = x\n    zero = []\n    while i < n:\n        if arr[i] <= k:\n            ans = ans + (i - x) * arr[i]\n            k = k - arr[i]\n            arr[i] = 0\n            nb = dp[i]\n            zero.append(i)\n        else:\n            ans = ans + k * (i - x)\n            arr[i] = arr[i] - k\n            nb = i\n            k = 0\n        if k == 0:\n            break\n        i = dp[i]\n    for idx in zero:\n        dp[idx] = nb\n    print(ans)", "N = int(input())\na = list(map(int, input().split()))\np = [i + 1 for i in range(N)]\nfor _ in range(int(input())):\n    (X, K) = map(int, input().split())\n    i = X - 1\n    X -= 1\n    s = 0\n    temp = X\n    indexs = []\n    while i < N:\n        if a[i] <= K:\n            s += a[i] * (i - X)\n            K -= a[i]\n            a[i] = 0\n            temp = p[i]\n            indexs.append(i)\n        else:\n            s += K * (i - X)\n            a[i] -= K\n            K = 0\n            temp = i\n        if K == 0:\n            break\n        i = p[i]\n    for j in indexs:\n        p[j] = temp\n    print(s)", "N = int(input())\na = list(map(int, input().split()))\np = [i + 1 for i in range(N)]\nfor _ in range(int(input())):\n    (X, K) = map(int, input().split())\n    i = X - 1\n    X -= 1\n    s = 0\n    temp = X\n    indexs = []\n    while i < N:\n        if a[i] <= K:\n            s += a[i] * (i - X)\n            K -= a[i]\n            a[i] = 0\n            temp = p[i]\n            indexs.append(i)\n        else:\n            s += K * (i - X)\n            a[i] -= K\n            K = 0\n            temp = i\n        if K == 0:\n            break\n        i = p[i]\n    for j in indexs:\n        p[j] = temp\n    print(s)", "n = int(input())\np = list(map(int, input().split()))\nq = int(input())\nind = []\nfor i in range(n):\n    ind.append(i + 1)\nfor _ in range(q):\n    (x, k) = map(int, input().split())\n    ans = 0\n    temp = x\n    i = x - 1\n    st = []\n    while i < n:\n        if k >= p[i]:\n            ans += (i - x + 1) * p[i]\n            k -= p[i]\n            p[i] = 0\n            temp = ind[i]\n            st.append(i)\n        else:\n            ans += (i - x + 1) * k\n            p[i] -= k\n            k = 0\n            temp = i\n        if k == 0:\n            break\n        i = ind[i]\n    for j in st:\n        ind[j] = temp\n    print(ans)", "N = int(input())\nspace = list(map(int, input().split()))\nQ = int(input())\nnear = -1\nwhile Q:\n    Q -= 1\n    (X, K) = map(int, input().split())\n    X -= 1\n    if space[X] >= K:\n        space[X] -= K\n        print(0)\n    elif near == -1 or X < near:\n        rest = K - space[X]\n        space[X] = 0\n        count = 1\n        ans = 0\n        for k in range(X + 1, len(space)):\n            if space[k] > 0:\n                ans += count * min(space[k], rest)\n                (space[k], rest) = (space[k] - min(space[k], rest), rest - min(space[k], rest))\n            if rest == 0:\n                break\n            count += 1\n        if ans == 0 and (near == -1 or X <= near):\n            near = X\n        print(ans)\n    else:\n        print(0)", "N = int(input())\nP = list(map(int, input().split()))\nQ = int(input())\nspace = [P[i] for i in range(N)]\nnear = -1\nwhile Q:\n    Q -= 1\n    (X, K) = map(int, input().split())\n    X -= 1\n    if space[X] >= K:\n        space[X] -= K\n        print(0)\n    elif near == -1 or X < near:\n        rest = K - space[X]\n        space[X] = 0\n        count = 1\n        ans = 0\n        for k in range(X + 1, len(space)):\n            if space[k] > 0:\n                ans += count * min(space[k], rest)\n                (space[k], rest) = (space[k] - min(space[k], rest), rest - min(space[k], rest))\n            if rest == 0:\n                break\n            count += 1\n        if ans == 0 and (near == -1 or X <= near):\n            near = X\n        print(ans)\n    else:\n        print(0)", "n = int(input())\na = list(map(int, input().split()))\nnxt = [i + 1 for i in range(n)]\nfor _ in range(int(input())):\n    (x, k) = map(int, input().split())\n    x -= 1\n    idx = x\n    ans = 0\n    while idx < n and k > 0:\n        st = []\n        r = min(a[idx], k)\n        a[idx] -= r\n        k -= r\n        ans += (idx - x) * r\n        while idx < n and a[idx] == 0:\n            st.append(idx)\n            idx = nxt[idx]\n        while st:\n            nxt[st.pop()] = idx\n    print(ans)", "from os import path\nimport sys, time\nfrom collections import defaultdict, Counter, OrderedDict, deque\nmaxx = float('inf')\nlocalsys = 0\nmod = int(1000000000.0 + 7)\nif path.exists('input.txt'):\n    localsys = 1\n    start_time = time.time()\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\nnxt = [i + 1 for i in range(n)]\nfor _ in range(int(input())):\n    (x, k) = map(int, input().split())\n    x -= 1\n    idx = x\n    ans = 0\n    while idx < n and k > 0:\n        st = []\n        r = min(a[idx], k)\n        a[idx] -= r\n        k -= r\n        ans += (idx - x) * r\n        while idx < n and a[idx] == 0:\n            st.append(idx)\n            idx = nxt[idx]\n        while st:\n            nxt[st.pop()] = idx\n    print(ans)\nif localsys:\n    print('\\n\\nTime Elased :', time.time() - start_time, 'seconds')", "n = int(input())\na = list(map(int, input().split()))\nq = int(input())\nptr = -1\nfor i in range(q):\n    (start, eng) = map(int, input().split())\n    start -= 1\n    if a[start] >= eng:\n        a[start] -= eng\n        print(0)\n    elif ptr == -1 or start < ptr:\n        ans = 0\n        eng -= a[start]\n        a[start] = 0\n        for j in range(start + 1, n):\n            if a[j] <= eng and a[j] > 0:\n                ans += (j - start) * a[j]\n                eng -= a[j]\n                a[j] = 0\n            elif a[j] > 0:\n                a[j] = a[j] - eng\n                ans += (j - start) * eng\n                break\n            if eng == 0:\n                break\n        if ans == 0 and (ptr == -1 or start <= ptr):\n            ptr = start\n        print(ans)\n    else:\n        print(0)", "import sys\nfrom collections import defaultdict\n\ndef pr(n):\n    sys.stdout.write(str(n))\n    sys.stdout.write('\\n')\n\ndef inp1():\n    return int(sys.stdin.readline())\n\ndef inp2():\n    return list(map(int, sys.stdin.readline().split()))\nif 1:\n    n = inp1()\n    l = inp2()\n    q = inp1()\n    d = defaultdict(lambda : 0)\n    for i in range(n):\n        d[i] = i\n    le = []\n    for i in range(n):\n        if l[i] == 0:\n            le.append(i)\n        else:\n            for j in le:\n                d[j] = i\n            le = []\n    for i in le:\n        d[i] = n\n    for __ in range(q):\n        (x, k) = inp2()\n        ans = 0\n        i = d[x - 1]\n        ind = n\n        le = [x - 1]\n        while i < n:\n            if l[i] == 0:\n                i = d[i]\n                continue\n            if l[i] < k:\n                ans += l[i] * abs(x - i - 1)\n                k -= l[i]\n                l[i] = 0\n                le.append(i)\n            elif l[i] == k:\n                ans += k * abs(x - i - 1)\n                l[i] = k = 0\n                le.append(i)\n                ind = i + 1\n                break\n            else:\n                ind = i\n                ans += k * abs(x - i - 1)\n                l[i] = l[i] - k\n                break\n            i += 1\n        for j in le:\n            d[j] = ind\n        pr(ans)", "n = int(input())\na = list(map(int, input().split()))\nq = int(input())\nptr = -1\nfor i in range(q):\n    (start, eng) = map(int, input().split())\n    start -= 1\n    if a[start] >= eng:\n        a[start] -= eng\n        print(0)\n    elif ptr == -1 or start < ptr:\n        ans = 0\n        eng -= a[start]\n        a[start] = 0\n        for j in range(start + 1, n):\n            if a[j] > 0:\n                temp = min(a[j], eng)\n                ans += (j - start) * temp\n                (a[j], eng) = (a[j] - temp, eng - temp)\n            if eng == 0:\n                break\n        if ans == 0 and (ptr == -1 or start <= ptr):\n            ptr = start\n        print(ans)\n    else:\n        print(0)", "import sys\nfrom collections import defaultdict\n\ndef pr(n):\n    sys.stdout.write(str(n))\n    sys.stdout.write('\\n')\n\ndef inp1():\n    return int(sys.stdin.readline())\n\ndef inp2():\n    return list(map(int, sys.stdin.readline().split()))\nif 1:\n    n = inp1()\n    l = inp2()\n    q = inp1()\n    d = defaultdict(lambda : 0)\n    for i in range(n):\n        d[i] = i\n    le = []\n    for i in range(n):\n        if l[i] == 0:\n            le.append(i)\n        else:\n            for j in le:\n                d[j] = i\n            le = []\n    for i in le:\n        d[i] = n\n    for __ in range(q):\n        (x, k) = inp2()\n        ans = 0\n        i = d[x - 1]\n        ind = n\n        le = [x - 1]\n        while i < n:\n            if l[i] == 0:\n                i = d[i]\n                continue\n            if l[i] < k:\n                ans += l[i] * abs(x - i - 1)\n                k -= l[i]\n                l[i] = 0\n                le.append(i)\n            elif l[i] == k:\n                ans += k * abs(x - i - 1)\n                l[i] = k = 0\n                le.append(i)\n                ind = i + 1\n                break\n            else:\n                ind = i\n                ans += k * abs(x - i - 1)\n                l[i] = l[i] - k\n                break\n            i += 1\n        for j in le:\n            d[j] = ind\n        pr(ans)", "n = int(input())\na = list(map(int, input().split()))\nq = int(input())\nptr = -1\nfor i in range(q):\n    (start, eng) = map(int, input().split())\n    start -= 1\n    if a[start] >= eng:\n        a[start] -= eng\n        print(0)\n    elif ptr == -1 or start < ptr:\n        ans = 0\n        eng -= a[start]\n        a[start] = 0\n        for j in range(start + 1, n):\n            if a[j] > 0:\n                temp = min(a[j], eng)\n                ans += (j - start) * temp\n                (a[j], eng) = (a[j] - min(a[j], eng), eng - min(a[j], eng))\n            if eng == 0:\n                break\n        if ans == 0 and (ptr == -1 or start <= ptr):\n            ptr = start\n        print(ans)\n    else:\n        print(0)", "from os import path\nimport sys, time\nfrom math import ceil, floor, gcd, log, log2, factorial\nfrom collections import defaultdict, Counter, OrderedDict, deque\nfrom bisect import *\nfrom functools import reduce\nfrom operator import mul\nmaxx = float('inf')\nlocalsys = 0\nif path.exists('input.txt'):\n    localsys = 1\n    start_time = time.time()\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\nq = int(input())\nparent = [i + 1 for i in range(n)]\nfor i in range(q):\n    (x, k) = map(int, input().split())\n    x -= 1\n    ans = 0\n    idx = x\n    st = []\n    while k > 0 and idx < n:\n        if a[idx] == 0:\n            idx = parent[idx]\n        elif a[idx] == k:\n            ans += (idx - x) * k\n            k = a[idx] = 0\n        elif a[idx] < k:\n            ans += (idx - x) * a[idx]\n            k -= a[idx]\n            a[idx] = 0\n            st.append(idx)\n            idx = parent[idx]\n        else:\n            ans += (idx - x) * k\n            a[idx] -= k\n            k = 0\n    while st:\n        parent[st.pop()] = idx\n    print(ans)\nif localsys:\n    print('\\n\\nTime Elased :', time.time() - start_time, 'seconds')", "N = int(input())\nP = list(map(int, input().split()))\nQ = int(input())\nspace = [P[i] for i in range(N)]\nnear = -1\nwhile Q:\n    Q -= 1\n    (X, K) = map(int, input().split())\n    X -= 1\n    if space[X] >= K:\n        space[X] -= K\n        print(0)\n    elif near == -1 or X < near:\n        rest = K - space[X]\n        space[X] = 0\n        count = 1\n        ans = 0\n        for k in range(X + 1, len(space)):\n            if space[k] > 0:\n                ans += count * min(space[k], rest)\n                (space[k], rest) = (space[k] - min(space[k], rest), rest - min(space[k], rest))\n            if rest == 0:\n                break\n            count += 1\n        if ans == 0 and (near == -1 or X <= near):\n            near = X\n        print(ans)\n    else:\n        print(0)", "n = int(input())\nP = list(map(int, input().split()))\nd = [i + 1 for i in range(n)]\nqer = int(input())\nfor q in range(qer):\n    ans = 0\n    (x, k) = map(int, input().split())\n    i = x - 1\n    while i < n and k != 0:\n        sub = min(P[i], k)\n        ans += sub * (i - (x - 1))\n        P[i] -= sub\n        k -= sub\n        if i != x - 1:\n            d[x - 1] = i\n        i = d[i]\n    print(ans)", "N = int(input())\nspace = list(map(int, input().split()))\nQ = int(input())\nptr = -1\nwhile Q:\n    Q -= 1\n    (X, K) = map(int, input().split())\n    X -= 1\n    if space[X] >= K:\n        space[X] -= K\n        print(0)\n    elif ptr == -1 or X < ptr:\n        remaining = K - space[X]\n        space[X] = 0\n        count = 1\n        ans = 0\n        for k in range(X + 1, len(space)):\n            if space[k] > 0:\n                ans += count * min(space[k], remaining)\n                (space[k], remaining) = (space[k] - min(space[k], remaining), remaining - min(space[k], remaining))\n            if remaining == 0:\n                break\n            count += 1\n        if ans == 0 and (ptr == -1 or X <= ptr):\n            ptr = X\n        print(ans)\n    else:\n        print(0)", "N = int(input())\nspace = list(map(int, input().split()))\nQ = int(input())\nnear = -1\nwhile Q:\n    Q -= 1\n    (X, K) = map(int, input().split())\n    X -= 1\n    if space[X] >= K:\n        space[X] -= K\n        print(0)\n    elif near == -1 or X < near:\n        rest = K - space[X]\n        space[X] = 0\n        count = 1\n        ans = 0\n        for k in range(X + 1, len(space)):\n            if space[k] > 0:\n                ans += count * min(space[k], rest)\n                (space[k], rest) = (space[k] - min(space[k], rest), rest - min(space[k], rest))\n            if rest == 0:\n                break\n            count += 1\n        if ans == 0 and (near == -1 or X <= near):\n            near = X\n        print(ans)\n    else:\n        print(0)", "n = int(input())\na = list(map(int, input().split()))\nb = [i + 1 for i in range(n)]\nq = int(input())\nfor i in range(q):\n    (district, people) = map(int, input().split())\n    district -= 1\n    i = district\n    c = []\n    travelled = 0\n    while i < n:\n        if a[i] == 0:\n            i = b[i]\n            continue\n        val = min(people, a[i])\n        people -= val\n        a[i] -= val\n        travelled += val * (i - district)\n        if people == 0:\n            break\n        c.append(i)\n        i = b[i]\n    for y in c:\n        b[y] = i\n    print(travelled)", "n = int(input())\np = list(map(int, input().split()))\nq = int(input())\nnxt = [i + 1 for i in range(n)]\nfor i in range(q):\n    (x, k) = map(int, input().split())\n    x = x - 1\n    ans = 0\n    stack = []\n    curr = x\n    while k > 0 and curr != n:\n        if p[curr] == 0:\n            curr = nxt[curr]\n        elif p[curr] == k:\n            ans += (curr - x) * k\n            k = 0\n            p[curr] = 0\n        elif p[curr] < k:\n            ans += (curr - x) * p[curr]\n            k -= p[curr]\n            p[curr] = 0\n            stack.append(curr)\n            curr = nxt[curr]\n        else:\n            ans += (curr - x) * k\n            p[curr] -= k\n            k = 0\n    while stack:\n        nxt[stack.pop()] = curr\n    print(ans)", "n = int(input())\nl = list(map(int, input().split()))\nq = int(input())\ns = [0] * n\nr = [i + 1 for i in range(n)]\nfor i in range(q):\n    (x, k) = map(int, input().split())\n    x -= 1\n    j = x\n    ans = 0\n    stk = []\n    while x < n:\n        if k <= 0:\n            break\n        elif s[x] < l[x]:\n            if k >= l[x] - s[x]:\n                k -= l[x] - s[x]\n                ans += (x - j) * (l[x] - s[x])\n                s[x] = l[x]\n                stk.append(x)\n                x = r[x]\n            else:\n                s[x] += k\n                ans += (x - j) * k\n                k = 0\n        else:\n            x = r[x]\n    while stk:\n        r[stk.pop()] = x\n    print(ans)", "n = int(input())\np = list(map(int, input().split()))\nq = int(input())\nnxt = [i + 1 for i in range(n)]\nfor i in range(q):\n    (x, k) = map(int, input().split())\n    x = x - 1\n    ans = 0\n    stck = []\n    curr = x\n    while k > 0 and curr != n:\n        if p[curr] == 0:\n            curr = nxt[curr]\n        elif p[curr] == k:\n            ans += (curr - x) * k\n            k = 0\n            p[curr] = 0\n        elif p[curr] < k:\n            ans += (curr - x) * p[curr]\n            k -= p[curr]\n            p[curr] = 0\n            stck.append(curr)\n            curr = nxt[curr]\n        else:\n            ans += (curr - x) * k\n            p[curr] -= k\n            k = 0\n    while stck:\n        nxt[stck.pop()] = curr\n    print(ans)", "N = int(input())\nP = list(map(int, input().split()))\nQ = int(input())\nspace = [P[i] for i in range(N)]\nnear = -1\nwhile Q:\n    Q -= 1\n    (X, K) = map(int, input().split())\n    X -= 1\n    if space[X] >= K:\n        space[X] -= K\n        print(0)\n    elif near == -1 or X < near:\n        rest = K - space[X]\n        space[X] = 0\n        count = 1\n        ans = 0\n        for k in range(X + 1, len(space)):\n            if space[k] > 0:\n                ans += count * min(space[k], rest)\n                (space[k], rest) = (space[k] - min(space[k], rest), rest - min(space[k], rest))\n            if rest == 0:\n                break\n            count += 1\n        if ans == 0 and (near == -1 or X <= near):\n            near = X\n        print(ans)\n    else:\n        print(0)", "rr = lambda : input().strip()\nrrm = lambda : map(int, rr().split())\nN = int(rr())\ncap = list(rrm())\nQ = int(rr())\nnex_ind = [i + 1 for i in range(N)]\n\ndef solve():\n    (X, K) = rrm()\n    trav = 0\n    X -= 1\n    beg = X\n    travel = []\n    while X < N:\n        delta = min(K, cap[X])\n        trav += delta * (X - beg)\n        cap[X] -= delta\n        K -= delta\n        if K == 0:\n            break\n        travel.append(X)\n        X = nex_ind[X]\n    for i in travel:\n        nex_ind[i] = X\n    return trav\nfor _ in range(Q):\n    ans = solve()\n    print(ans)", "T = int(input())\nB = list(map(int, input().strip().split()))\ndismap = {}\nfor b in range(len(B)):\n    dismap[b + 1] = b\nq = int(input())\nfor a in range(q):\n    tem = list(map(int, input().strip().split()))\n    x = tem[0]\n    k = tem[1]\n    ans = 0\n    ind = dismap[x]\n    if ind != -1:\n        if k <= B[ind]:\n            B[ind] -= k\n            ans += (ind + 1 - x) * k\n            k = 0\n        else:\n            while k and ind < len(B):\n                if k <= B[ind]:\n                    B[ind] -= k\n                    ans += k * (ind + 1 - x)\n                    k = 0\n                    break\n                else:\n                    k -= B[ind]\n                    ans += B[ind] * (ind - x + 1)\n                    B[ind] = 0\n                    ind = ind + 1\n            i = ind\n            if i == len(B):\n                while x - 1 < i:\n                    dismap[x] = -1\n                    x += 1\n            else:\n                while x - 1 < i:\n                    dismap[x] = i\n                    x += 1\n    print(ans)", "n = int(input())\np = list(map(int, input().split()))\nq = int(input())\nind = []\nfor i in range(n):\n    if i == n - 1:\n        ind.append(-1)\n    else:\n        ind.append(i + 1)\nfor _ in range(q):\n    (x, k) = map(int, input().split())\n    ans = 0\n    temp = x\n    i = x - 1\n    st = []\n    while i < n:\n        if k >= p[i]:\n            ans += (i - x + 1) * p[i]\n            k -= p[i]\n            p[i] = 0\n            temp = ind[i]\n            st.append(i)\n        else:\n            ans += (i - x + 1) * k\n            p[i] -= k\n            k = 0\n            temp = i\n        if k == 0 or ind[i] == -1:\n            break\n        i = ind[i]\n    for j in st:\n        ind[j] = temp\n    print(ans)", "def fun1():\n    t = int(input())\n    while t > 0:\n        t -= 1\n        (N, M, K) = map(int, input().split())\n        G = list(map(int, input().split()))\n        uvd = []\n        for j in range(M):\n            l = list(map(int, input().split()))\n            uvd.append(l)\n        binary = []\n        for i in range(0, 2 ** N):\n            elements = bin(i)[2:]\n            binary.append('0' * (N - len(elements)) + elements)\n        lst = []\n        for elements in binary:\n            s1 = 0\n            for i in range(N):\n                s1 += int(elements[i]) * G[i]\n            s2 = 0\n            for i in range(M):\n                if elements[uvd[i][0] - 1:uvd[i][1]].count('0') > 0:\n                    continue\n                s2 += uvd[i][2]\n            lst.append(s2 + s1)\n        lst.sort(reverse=True)\n        print(*lst[0:K])\nn = int(input())\np = list(map(int, input().split()))\nquery = int(input())\nindex = [p[i] for i in range(n)]\nlast = -1\nwhile query:\n    query -= 1\n    (x, k) = map(int, input().split())\n    x -= 1\n    if index[x] >= k:\n        index[x] -= k\n        print(0)\n        continue\n    elif last == -1 or x < last:\n        rest = k - index[x]\n        index[x] = 0\n        count = 1\n        ans = 0\n        for k in range(x + 1, len(index)):\n            if index[k] > 0:\n                ans += count * min(index[k], rest)\n                (index[k], rest) = (index[k] - min(index[k], rest), rest - min(index[k], rest))\n            if rest == 0:\n                break\n            count += 1\n        if ans == 0 and (last == -1 or x <= last):\n            last = x\n        print(ans)\n    else:\n        print(0)", "from sys import stdin\ninput = stdin.readline\nfrom heapq import heapify, heappush, heappop, heappushpop\nfrom collections import defaultdict as dd, deque as dq, Counter as C\nfrom math import factorial as f, ceil, gcd, sqrt, log\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom itertools import combinations as c, permutations as p\nfrom math import factorial as f, ceil, gcd, sqrt, log\nmi = lambda : map(int, input().split())\nii = lambda : int(input())\nli = lambda : list(map(int, input().split()))\nmati = lambda r: [li() for _ in range(r)]\nlcm = lambda a, b: a * b // gcd(a, b)\n\ndef solve():\n    n = ii()\n    arr = [0]\n    for x in li():\n        arr.append(x)\n    pos = [x for x in range(0, n + 1)]\n    for p in range(ii()):\n        dist = 0\n        (x, k) = mi()\n        i = pos[x]\n        dist = 0\n        v = i - x\n        while i <= n:\n            if arr[i] >= k:\n                arr[i] -= k\n                dist += k * v\n                break\n            else:\n                k -= arr[i]\n                dist += arr[i] * v\n                v += 1\n                arr[i] = 0\n            i += 1\n        if i > n + 1:\n            i = n + 1\n        if i != n + 1 and arr[i] == 0:\n            i += 1\n        x = pos[x]\n        while x <= n and arr[x] == 0:\n            pos[x] = i\n            x += 1\n        print(dist)\nfor _ in range(1):\n    solve()", "n = int(input())\na = list(map(int, input().split()))\nb = [i + 1 for i in range(n)]\nq = int(input())\nfor _ in range(q):\n    (x, y) = map(int, input().split())\n    x -= 1\n    z = x\n    c = []\n    d = 0\n    while x < n:\n        if a[x] == 0:\n            x = b[x]\n            continue\n        delta = min(a[x], y)\n        a[x] -= delta\n        y -= delta\n        d += delta * (x - z)\n        if y == 0:\n            break\n        c.append(x)\n        x = b[x]\n    for y in c:\n        b[y] = x\n    print(d)", "N = int(input())\nP = list(map(int, input().split()))\nQ = int(input())\nspace = [P[i] for i in range(N)]\nnear = -1\nwhile Q:\n    Q -= 1\n    (X, K) = map(int, input().split())\n    X -= 1\n    if space[X] >= K:\n        space[X] -= K\n        print(0)\n    elif near == -1 or X < near:\n        rest = K - space[X]\n        space[X] = 0\n        count = 1\n        ans = 0\n        for k in range(X + 1, len(space)):\n            if space[k] > 0:\n                ans += count * min(space[k], rest)\n                (space[k], rest) = (space[k] - min(space[k], rest), rest - min(space[k], rest))\n            if rest == 0:\n                break\n            count += 1\n        if ans == 0 and (near == -1 or X <= near):\n            near = X\n        print(ans)\n    else:\n        print(0)", "import math\n\ndef solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n    q = int(input())\n    y = 0\n    cities = {}\n    for i in range(q):\n        (x, k) = map(int, input().split())\n        x -= 1\n        y = x\n        dist = 0\n        ref = [x]\n        while k > 0 and x < n:\n            if x in cities:\n                x = cities[x][0]\n                continue\n            if k < p[x]:\n                p[x] -= k\n                dist += (x - y) * k\n                k = 0\n            elif p[x] > 0:\n                k -= p[x]\n                dist += (x - y) * p[x]\n                p[x] = 0\n                cities[x] = ref\n                x += 1\n            else:\n                x += 1\n        ref[0] = x\n        print(dist)\nsolve()", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log2, ceil\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom bisect import insort\nfrom collections import Counter\nfrom collections import deque\nfrom heapq import heappush, heappop, heapify\nfrom itertools import permutations, combinations\nfrom itertools import accumulate as ac\nmod = int(1000000000.0) + 7\nip = lambda : int(stdin.readline())\ninp = lambda : map(int, stdin.readline().split())\nips = lambda : stdin.readline().rstrip()\nout = lambda x: stdout.write(str(x) + '\\n')\nt = 1\nfor _ in range(t):\n    n = ip()\n    arr = list(inp())\n    q = ip()\n    dp = [i for i in range(n)]\n    ans = 0\n    for i in range(q):\n        (p, val) = inp()\n        p -= 1\n        ct = dp[p] - p\n        p = dp[p]\n        ans = 0\n        for j in range(p, n):\n            if val >= arr[j]:\n                val -= arr[j]\n                ans += ct * arr[j]\n                arr[j] = 0\n            else:\n                arr[j] -= val\n                ans += val * ct\n                break\n            ct += 1\n        if j == n:\n            j -= 1\n        for jj in range(j, p - 1, -1):\n            dp[jj] = j\n        print(ans)", "from collections import defaultdict\nnum = int(input())\narr = list(map(int, input().split()))\nmapping = defaultdict()\nfor (i, n) in enumerate(arr, start=1):\n    mapping[i] = n\nmx = max(mapping.keys())\ncases = int(input())\nwhile cases:\n    cases -= 1\n    (ind, k) = map(int, input().split())\n    i = ind\n    ans = 0\n    while k and ind <= mx:\n        if ind in mapping:\n            if k < mapping[ind]:\n                mapping[ind] -= k\n                ans += k * (ind - i)\n                break\n            elif k == mapping[ind]:\n                mapping.pop(ind)\n                ans += k * (ind - i)\n                if ind == mx:\n                    if mapping:\n                        mx = max(mapping.keys())\n                    else:\n                        mx = 0\n                break\n            else:\n                k -= mapping[ind]\n                ans += mapping[ind] * (ind - i)\n                mapping.pop(ind)\n                if ind == mx:\n                    if mapping:\n                        mx = max(mapping.keys())\n                    else:\n                        mx = 0\n        else:\n            ind += 1\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 8)\n\ndef findNext(v):\n    if v == n + 1 or v == next[v]:\n        return v\n    next[v] = findNext(next[v])\n    return next[v]\nn = int(input())\nP = [0] + list(map(int, input().split()))\nnext = [i for i in range(n + 1)]\nq = int(input())\nfor qn in range(q):\n    (x, k) = map(int, input().split())\n    s = x\n    total = 0\n    while s <= n and k > 0:\n        if P[s]:\n            inc = min(k, P[s])\n            P[s] -= inc\n            k -= inc\n            total += inc * (s - x)\n            if not P[s]:\n                next[s] = findNext(s + 1)\n                s = next[s]\n        else:\n            s = findNext(s)\n    findNext(x)\n    print(total)", "n = int(input())\np = list(map(int, input().split()))\nq = int(input())\nnxt = [i + 1 for i in range(n)]\nfor i in range(q):\n    (x, k) = map(int, input().split())\n    x = x - 1\n    ans = 0\n    stck = []\n    curr = x\n    while k > 0 and curr != n:\n        if p[curr] == 0:\n            curr = nxt[curr]\n        elif p[curr] == k:\n            ans += (curr - x) * k\n            k = 0\n            p[curr] = 0\n        elif p[curr] < k:\n            ans += (curr - x) * p[curr]\n            k -= p[curr]\n            p[curr] = 0\n            stck.append(curr)\n            curr = nxt[curr]\n        else:\n            ans += (curr - x) * k\n            p[curr] -= k\n            k = 0\n    while stck:\n        nxt[stck.pop()] = curr\n    print(ans)", "n = int(input())\np = list(map(int, input().split()))\nq = int(input())\nnxt = [i + 1 for i in range(n)]\nfor i in range(q):\n    (x, k) = map(int, input().split())\n    x = x - 1\n    ans = 0\n    stck = []\n    curr = x\n    while k > 0 and curr != n:\n        if p[curr] == 0:\n            curr = nxt[curr]\n        elif p[curr] == k:\n            ans += (curr - x) * k\n            k = 0\n            p[curr] = 0\n        elif p[curr] < k:\n            ans += (curr - x) * p[curr]\n            k -= p[curr]\n            p[curr] = 0\n            stck.append(curr)\n            curr = nxt[curr]\n        else:\n            ans += (curr - x) * k\n            p[curr] -= k\n            k = 0\n    while stck:\n        nxt[stck.pop()] = curr\n    print(ans)", "n = int(input())\na = list(map(int, input().split()))\nb = [i for i in range(n)]\nfor q in range(int(input())):\n    (s, k) = map(int, input().split())\n    i = s - 1\n    while b[i] != i:\n        i = b[i]\n    m = i\n    p = i\n    ans = 0\n    while i < n and k:\n        p = i\n        if a[i] > k:\n            ans += k * (i - s + 1)\n            a[i] -= k\n            k = 0\n        elif a[i] == k:\n            ans += k * (i - s + 1)\n            a[i] = 0\n            k = 0\n        elif a[i] > 0:\n            k -= a[i]\n            ans += a[i] * (i - s + 1)\n            a[i] = 0\n        i += 1\n    for j in range(m, p + 1):\n        if a[j] == 0:\n            b[j] = p\n    print(ans)", "import sys, os\nfrom io import BytesIO, IOBase\nmod = 10 ** 9 + 7\nMod = 998244353\nINF = float('inf')\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\ninp = lambda : list(map(int, sys.stdin.readline().rstrip('\\r\\n').split()))\nsys.setrecursionlimit(100000 + 10)\ntc = 1\nfor test in range(1, tc + 1):\n    (n,) = inp()\n    a = [0] + inp()\n    par = [i for i in range(n + 1)]\n    q = int(input())\n    ans = [0]\n\n    def find(ind, x, val):\n        if par[x] != x:\n            par[x] = find(ind, par[x], val)\n        else:\n            temp = min(val, a[x])\n            ans[0] += temp * (x - ind)\n            val -= temp\n            a[x] -= temp\n            if a[x] == 0:\n                if x < n:\n                    par[x] = par[x + 1]\n                    if val > 0:\n                        par[x] = find(ind, par[x], val)\n        return par[x]\n    for i in range(q):\n        ans[0] = 0\n        (ind, val) = inp()\n        find(ind, ind, val)\n        print(ans[0])", "n = int(input())\narr = list(map(int, input().split()))\nto = [i + 1 for i in range(n)]\nfor _ in range(int(input())):\n    (x, k) = map(int, input().split())\n    x -= 1\n    s = 0\n    at = x\n    while k > 0 and at < n:\n        r = min(k, arr[at])\n        arr[at] -= r\n        k -= r\n        s += r * (at - x)\n        st = []\n        while at < n and arr[at] == 0:\n            st.append(at)\n            at = to[at]\n        while len(st) > 0:\n            to[st.pop()] = at\n    print(s)"]