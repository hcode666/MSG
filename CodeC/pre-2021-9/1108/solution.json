["gstart = [0 for i in range(1000)]\ngend = [0 for i in range(1000)]\ngxor = [0 for i in range(1000)]\ngid = [0 for i in range(10 ** 6 + 100)]\ngcnt = [{} for j in range(1000)]\nps = [0 for i in range(10 ** 5 + 10)]\n\ndef buildSqrtDecomp(n):\n    gsize = 1\n    while gsize * gsize < n:\n        gsize += 1\n    ng = 0\n    for i in range(0, n, gsize):\n        gstart[ng] = i\n        gend[ng] = i + gsize - 1\n        ng += 1\n    gend[ng - 1] = n - 1\n    for g in range(ng):\n        gxor[g] = 0\n        for i in range(gstart[g], gend[g] + 1):\n            if ps[i] in gcnt[g]:\n                gcnt[g][ps[i]] += 1\n            else:\n                gcnt[g][ps[i]] = 1\n            gid[i] = g\n    return gsize\n(n, q) = [int(c) for c in input().split()]\narr = [int(i) for i in input().split()]\ncurrXor = 0\nfor i in range(len(arr)):\n    currXor ^= arr[i]\n    ps[i] = currXor\ngsize = buildSqrtDecomp(n)\nfor _ in range(q):\n    (op, i, x) = [int(c) for c in input().split()]\n    if op == 1:\n        i -= 1\n        block_number = gid[i]\n        c = arr[i] ^ x\n        arr[i] = x\n        for j in range(i, gend[block_number] + 1):\n            gcnt[block_number][ps[j]] -= 1\n            ps[j] ^= c\n            if ps[j] in gcnt[block_number]:\n                gcnt[block_number][ps[j]] += 1\n            else:\n                gcnt[block_number][ps[j]] = 1\n        for j in range(gid[i] + 1, gsize + 1):\n            gxor[j] ^= c\n    else:\n        i -= 1\n        block_number = gid[i]\n        ans = 0\n        for j in range(gstart[block_number], i + 1):\n            if ps[j] ^ gxor[block_number] == x:\n                ans += 1\n        for j in range(0, block_number):\n            if x ^ gxor[j] in gcnt[j]:\n                ans += gcnt[j][x ^ gxor[j]]\n        print(ans)", "gstart = [0 for i in range(1000)]\ngend = [0 for i in range(1000)]\ngxor = [0 for i in range(1000)]\ngid = [0 for i in range(10 ** 6 + 100)]\ngcnt = [{} for j in range(1000)]\nps = [0 for i in range(10 ** 5 + 10)]\n\ndef buildSqrtDecomp(n):\n    gsize = 1\n    while gsize * gsize < n:\n        gsize += 1\n    ng = 0\n    for i in range(0, n, gsize):\n        gstart[ng] = i\n        gend[ng] = i + gsize - 1\n        ng += 1\n    gend[ng - 1] = n - 1\n    for g in range(ng):\n        gxor[g] = 0\n        for i in range(gstart[g], gend[g] + 1):\n            if ps[i] in gcnt[g]:\n                gcnt[g][ps[i]] += 1\n            else:\n                gcnt[g][ps[i]] = 1\n            gid[i] = g\n    return gsize\n(n, q) = [int(c) for c in input().split()]\narr = [int(i) for i in input().split()]\ncurrXor = 0\nfor i in range(len(arr)):\n    currXor ^= arr[i]\n    ps[i] = currXor\ngsize = buildSqrtDecomp(n)\nfor _ in range(q):\n    (op, i, x) = [int(c) for c in input().split()]\n    if op == 1:\n        i -= 1\n        block_number = gid[i]\n        c = arr[i] ^ x\n        arr[i] = x\n        for j in range(i, gend[block_number] + 1):\n            gcnt[block_number][ps[j]] -= 1\n            ps[j] ^= c\n            if ps[j] in gcnt[block_number]:\n                gcnt[block_number][ps[j]] += 1\n            else:\n                gcnt[block_number][ps[j]] = 1\n        for j in range(gid[i] + 1, gsize + 1):\n            gxor[j] ^= c\n    else:\n        i -= 1\n        block_number = gid[i]\n        ans = 0\n        for j in range(gstart[block_number], i + 1):\n            if ps[j] ^ gxor[block_number] == x:\n                ans += 1\n        for j in range(0, block_number):\n            if x ^ gxor[j] in gcnt[j]:\n                ans += gcnt[j][x ^ gxor[j]]\n        print(ans)", "import sys\ndata = sys.stdin.read().split()\ndata.reverse()\n\ndef read():\n    return int(data.pop())\n\ndef readStr():\n    return data.pop()\nfrom collections import Counter\nN = 2 * 10 ** 5 + 5\nblock = 317\nnb = N // block\nX = [0] * nb\nD = [Counter() for i in range(nb)]\n\ndef init(n):\n    for i in range(n):\n        D[i // block][A[i]] += 1\n\ndef update(p, x):\n    st = p // block\n    en = (n - 1) // block\n    toXor = A[p] ^ X[st] ^ x\n    if p:\n        toXor ^= A[p - 1] ^ X[(p - 1) // block]\n    for i in range(p, min((st + 1) * block, n)):\n        ele = A[i]\n        D[st][ele] -= 1\n        D[st][ele ^ toXor] += 1\n        A[i] = ele ^ toXor\n    for i in range(st + 1, en + 1):\n        X[i] ^= toXor\n\ndef ansQuery(p, k):\n    st = p // block\n    ans = 0\n    for i in range(st * block, p + 1):\n        if A[i] ^ X[st] == k:\n            ans += 1\n    for i in range(st):\n        ans += D[i][k ^ X[i]]\n    return ans\n(n, q) = (read(), read())\nA = [read() for i in range(n)]\nfor i in range(1, n):\n    A[i] ^= A[i - 1]\ninit(n)\nans = []\nfor query in range(q):\n    (t, a, b) = (read(), read(), read())\n    if t == 1:\n        update(a - 1, b)\n    else:\n        ans.append(str(ansQuery(a - 1, b)))\nprint('\\n'.join(ans))", "import sys\ndata = sys.stdin.read().split()\ndata.reverse()\n\ndef read():\n    return int(data.pop())\n\ndef readStr():\n    return data.pop()\nfrom collections import Counter\nN = 2 * 10 ** 5 + 5\nblock = 317\nnb = N // block\nX = [0] * nb\nD = [Counter() for i in range(nb)]\n\ndef init(n):\n    for i in range(n):\n        D[i // block][A[i]] += 1\n\ndef update(p, x):\n    st = p // block\n    en = (n - 1) // block\n    toXor = A[p] ^ X[st] ^ x\n    if p:\n        toXor ^= A[p - 1] ^ X[(p - 1) // block]\n    for i in range(p, min((st + 1) * block, n)):\n        ele = A[i]\n        D[st][ele] -= 1\n        D[st][ele ^ toXor] += 1\n        A[i] = ele ^ toXor\n    for i in range(st + 1, en + 1):\n        X[i] ^= toXor\n\ndef ansQuery(p, k):\n    st = p // block\n    ans = 0\n    for i in range(st * block, p + 1):\n        if A[i] ^ X[st] == k:\n            ans += 1\n    for i in range(st):\n        ans += D[i][k ^ X[i]]\n    return ans\n(n, q) = (read(), read())\nA = [read() for i in range(n)]\nfor i in range(1, n):\n    A[i] ^= A[i - 1]\ninit(n)\nans = []\nfor query in range(q):\n    (t, a, b) = (read(), read(), read())\n    if t == 1:\n        update(a - 1, b)\n    else:\n        ans.append(str(ansQuery(a - 1, b)))\nprint('\\n'.join(ans))", "import numpy\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\narr = [a[0]]\nfor i in range(1, n):\n    arr.append(arr[-1] ^ a[i])\narr = numpy.array(arr)\nfor _ in range(q):\n    (t, i, k) = map(int, input().split())\n    if t == 1:\n        b = a[i - 1] ^ k\n        a[i - 1] = k\n        arr[i - 1:] ^= b\n    else:\n        print(numpy.count_nonzero(arr[:i] == k))", "import math\n\nclass decomp:\n\n    def __init__(self, n, arr):\n        self.size = math.ceil(n ** 0.5)\n        self.block2 = []\n        self.countarr = []\n        bno = 1\n        for i in range(n):\n            if i // self.size != bno:\n                pre = 0\n                self.block2.append([])\n                self.countarr.append({})\n            bno = i // self.size\n            pre = pre ^ arr[i]\n            self.block2[bno].append(pre)\n            try:\n                self.countarr[bno][pre] += 1\n            except:\n                self.countarr[bno][pre] = 1\n\n    def update(self, arr, index, value, n):\n        bno = index // self.size\n        if index % self.size == self.size - 1:\n            self.countarr[bno][self.block2[bno][index % self.size]] -= 1\n            self.block2[bno][index % self.size] = self.block2[bno][self.size - 2] ^ arr[self.size * bno + self.size - 1]\n            try:\n                self.countarr[bno][self.block2[bno][index % self.size]] += 1\n            except:\n                self.countarr[bno][self.block2[bno][index % self.size]] = 1\n            return\n        elif index % self.size == 0:\n            pre = 0\n        else:\n            pre = self.block2[bno][index % self.size - 1]\n        for i in range(index % self.size, self.size):\n            if bno * self.size + i == n:\n                break\n            self.countarr[bno][self.block2[bno][i]] -= 1\n            pre = pre ^ arr[self.size * bno + i]\n            self.block2[bno][i] = pre\n            try:\n                self.countarr[bno][pre] += 1\n            except:\n                self.countarr[bno][pre] = 1\n\n    def query(self, arr, index, k):\n        bno = index // self.size\n        pre = k\n        count = 0\n        for i in range(bno):\n            try:\n                count += self.countarr[i][pre]\n                pre = pre ^ self.block2[i][-1]\n            except:\n                pre = pre ^ self.block2[i][-1]\n        x = index % self.size + 1\n        for i in range(x):\n            if pre == self.block2[bno][i]:\n                count += 1\n        return count\n(N, Q) = map(int, input().split())\narr = [int(x) for x in input().split()]\ndem = decomp(N, arr)\nfor i in range(Q):\n    op = [int(x) for x in input().split()]\n    if op[0] == 1:\n        arr[op[1] - 1] = op[2]\n        dem.update(arr, op[1] - 1, op[2], N)\n    else:\n        print(dem.query(arr, op[1] - 1, op[2]))", "import math\nfrom collections import defaultdict\n(n, q) = list(map(int, input().strip().split(' ')))\nl = list(map(int, input().strip().split(' ')))\nblocks_xor = []\nprefix_xor = []\nblock_size = int(math.sqrt(n))\nblocks = int(math.ceil(n / block_size))\nfor i in range(blocks):\n    block_start = i * block_size\n    block_end = min(block_start + block_size, n)\n    xor_map = defaultdict(lambda : 0)\n    prev = 0\n    block_prefix_xor = []\n    for j in range(block_start, block_end):\n        prev ^= l[j]\n        xor_map[prev] += 1\n        block_prefix_xor.append(prev)\n    blocks_xor.append(xor_map)\n    prefix_xor.append(block_prefix_xor)\nfor i in range(q):\n    (typ, index, k) = list(map(int, input().strip().split(' ')))\n    index -= 1\n    block = index // block_size\n    block_start = block * block_size\n    block_end = min(block_start + block_size, n)\n    if typ == 1:\n        xor_map = defaultdict(lambda : 0)\n        prev = 0\n        l[index] = k\n        block_prefix_xor = []\n        for j in range(block_start, block_end):\n            prev ^= l[j]\n            xor_map[prev] += 1\n            block_prefix_xor.append(prev)\n        blocks_xor[block] = xor_map\n        prefix_xor[block] = block_prefix_xor\n    else:\n        prev = 0\n        count = 0\n        for j in range(block):\n            xor_map = blocks_xor[j]\n            if prev ^ k in xor_map:\n                count += xor_map[prev ^ k]\n            prev ^= prefix_xor[j][-1]\n        block_prefix_xor = prefix_xor[block]\n        for j in range(index - block_start + 1):\n            if prev ^ block_prefix_xor[j] == k:\n                count += 1\n        print(count)", "import numpy\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\narr = [a[0]]\nfor i in range(1, n):\n    arr.append(arr[-1] ^ a[i])\narr = numpy.array(arr)\nfor _ in range(q):\n    (t, i, k) = map(int, input().split())\n    if t == 1:\n        b = a[i - 1] ^ k\n        a[i - 1] = k\n        arr[i - 1:] ^= b\n    else:\n        print(numpy.count_nonzero(arr[:i] == k))", "import numpy as np\n(n, q) = map(int, input().split())\nA = list(map(int, input().split()))\nxor = [A[0]]\nfor i in range(1, n):\n    xor.append(xor[i - 1] ^ A[i])\nxor = np.array(xor)\nfor i in range(q):\n    (ii, index, x) = map(int, input().split())\n    if ii == 1:\n        y = A[index - 1] ^ x\n        A[index - 1] = x\n        xor[index - 1:] ^= y\n    else:\n        print(np.count_nonzero(xor[:index] == x))", "import numpy\n(n, q) = map(int, input().strip().split())\nA = list(map(int, input().strip().split()))\nxor = [A[0]]\nfor i in range(1, n):\n    xor.append(xor[-1] ^ A[i])\nxor = numpy.array(xor)\nfor i in range(q):\n    (t, ind, x) = map(int, input().strip().split())\n    if t == 1:\n        b = A[ind - 1] ^ x\n        A[ind - 1] = x\n        xor[ind - 1:] ^= b\n    else:\n        print(numpy.count_nonzero(xor[:ind] == x))", "import numpy\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\nxor = [a[0]]\nfor i in range(1, n):\n    xor.append(xor[-1] ^ a[i])\nxor = numpy.array(xor)\nfor i in range(q):\n    (t, ind, x) = map(int, input().split())\n    if t == 1:\n        b = a[ind - 1] ^ x\n        a[ind - 1] = x\n        xor[ind - 1:] ^= b\n    else:\n        print(numpy.count_nonzero(xor[:ind] == x))", "from math import sqrt, floor\n(n, q) = (int(x) for x in input().strip().split())\nA = [int(x) for x in input().strip().split()]\nblock_length = floor(sqrt(n))\nblock_count = (n + block_length - 1) // block_length\nmapping = [dict() for _ in range(block_count)]\npending = [0 for _ in range(block_count)]\nfor i in range(n):\n    A[i] ^= A[i - 1] if i else 0\n    block_index = i // block_length\n    mapping[block_index][A[i]] = mapping[block_index].get(A[i], 0) + 1\nwhile q:\n    (t, i, x) = (int(z) for z in input().strip().split())\n    (block_index, ans) = ((i - 1) // block_length, 0)\n    q -= 1\n    if t == 1:\n        x ^= A[i - 1] ^ pending[block_index]\n        if i > 1:\n            n_block_index = (i - 2) // block_length\n            x ^= A[i - 2] ^ pending[n_block_index]\n        for j in range(block_index + 1, block_count):\n            pending[j] ^= x\n        for j in range(i - 1, min((block_index + 1) * block_length, n)):\n            mapping[block_index][A[j]] -= 1\n            if mapping[block_index][A[j]] == 0:\n                del mapping[block_index][A[j]]\n            A[j] ^= x\n            mapping[block_index][A[j]] = mapping[block_index].get(A[j], 0) + 1\n    else:\n        for j in range(block_index):\n            ans += mapping[j].get(x ^ pending[j], 0)\n        for j in range(block_index * block_length, i):\n            ans += 1 if A[j] ^ pending[block_index] == x else 0\n        print(ans)", "import numpy\nimport sys\nf = sys.stdin\n(n, q) = map(int, f.readline().split())\na = list(map(int, f.readline().split()))\nxor = [a[0]]\nfor i in range(1, n):\n    xor.append(xor[-1] ^ a[i])\nxor = numpy.array(xor)\nfor i in range(q):\n    (t, ind, x) = map(int, f.readline().split())\n    if t == 1:\n        b = a[ind - 1] ^ x\n        a[ind - 1] = x\n        xor[ind - 1:] ^= b\n    else:\n        print(numpy.count_nonzero(xor[:ind] == x))", "import numpy\nimport sys\nf = sys.stdin\n(n, q) = map(int, f.readline().split())\na = list(map(int, f.readline().split()))\nxor = [a[0]]\nfor i in range(1, n):\n    xor.append(xor[-1] ^ a[i])\nxor = numpy.array(xor)\nfor i in range(q):\n    (t, ind, x) = map(int, f.readline().split())\n    if t == 1:\n        b = a[ind - 1] ^ x\n        a[ind - 1] = x\n        xor[ind - 1:] ^= b\n    else:\n        print(numpy.count_nonzero(xor[:ind] == x))", "from collections import defaultdict as dd\nimport math\n(n, nq) = [int(i) for i in input().split(' ')]\na = [int(i) for i in input().split(' ')]\ne = math.sqrt(n)\nw = math.sqrt(n)\nif e != int(e):\n    w += 1\nw = int(w)\ne = int(e)\nd1 = []\nb = []\nc = []\nd2 = []\nt = 0\nd = []\nd3 = dd(int)\nfor i in range(n):\n    d1.append(a[i])\n    r = a[i] ^ t\n    d3[r] += 1\n    d2.append(r)\n    t = r\n    if i % e == e - 1 or i == n - 1:\n        b.append(d1)\n        d1 = []\n        c.append(d2)\n        t = 0\n        d2 = []\n        d.append(d3.copy())\n        d3 = dd(int)\nfor _ in range(nq):\n    (q, i, k) = [int(i) for i in input().split(' ')]\n    if q == 2:\n        w = len(b[0])\n        i = i - 1\n        nn = i // w + 1\n        t = 0 ^ k\n        s = 0\n        for j in range(nn - 1):\n            s += d[j][t]\n            t = t ^ c[j][-1]\n        s += c[nn - 1][:i - (nn - 1) * w + 1].count(t)\n        print(s)\n    else:\n        w = len(b[0])\n        i = i - 1\n        nn = i // w\n        b[nn][i - w * nn] = k\n        t = 0\n        d1 = dd(int)\n        for i in range(len(b[nn])):\n            t = t ^ b[nn][i]\n            c[nn][i] = t\n            d1[t] += 1\n        d[nn] = d1.copy()"]