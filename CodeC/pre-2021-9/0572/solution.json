["def find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    parent = list(range(n))\n    rank = [0] * n\n    for j in range(m):\n        (a, b) = map(int, input().split())\n        union(parent, rank, a, b)\n    q = int(input())\n    for k in range(q):\n        (x, y) = map(int, input().split())\n        if find(parent, x) == find(parent, y):\n            print('YO')\n        else:\n            print('NO')", "def find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    rootx = find(parent, x)\n    rooty = find(parent, y)\n    if rootx != rooty:\n        if rank[rootx] < rank[rooty]:\n            parent[rootx] = rooty\n        elif rank[rootx] > rank[rooty]:\n            parent[rooty] = rootx\n        else:\n            parent[rooty] = rootx\n            rank[rootx] += 1\nt = int(input())\nfor test_case in range(t):\n    (n, m) = map(int, input().split())\n    parent = [i for i in range(n)]\n    rank = [0 for i in range(n)]\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        union(parent, rank, x, y)\n    q = int(input())\n    for i in range(q):\n        (x, y) = map(int, input().split())\n        if find(parent, x) == find(parent, y):\n            print('YO')\n        else:\n            print('NO')", "def find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    rootx = find(parent, x)\n    rooty = find(parent, y)\n    if rootx != rooty:\n        if rank[rootx] < rank[rooty]:\n            parent[rootx] = rooty\n        elif rank[rootx] > rank[rooty]:\n            parent[rooty] = rootx\n        else:\n            parent[rooty] = rootx\n            rank[rootx] += 1\nt = int(input())\nfor test_case in range(t):\n    (n, m) = map(int, input().split())\n    parent = [i for i in range(n)]\n    rank = [0 for i in range(n)]\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        union(parent, rank, x, y)\n    q = int(input())\n    for i in range(q):\n        (x, y) = map(int, input().split())\n        if find(parent, x) == find(parent, y):\n            print('YO')\n        else:\n            print('NO')", "def find(node, par):\n    res = node\n    while res != par[res]:\n        par[res] = find(par[res], par)\n        res = par[res]\n    return res\n\ndef union(a, b, par, rank):\n    (p1, p2) = (find(a, par), find(b, par))\n    if p1 == p2:\n        return 0\n    if rank[p2] > rank[p1]:\n        par[p1] = p2\n        rank[p2] += rank[p1]\n    else:\n        par[p2] = p1\n        rank[p1] += rank[p2]\n    return 1\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    par = [i for i in range(n)]\n    rank = [1 for i in range(n)]\n    for j in range(m):\n        (a, b) = map(int, input().split())\n        union(a, b, par, rank)\n    for i in range(int(input())):\n        (x, y) = map(int, input().split())\n        if find(x, par) == find(y, par):\n            print('YO')\n        else:\n            print('NO')", "def find(node, par):\n    res = node\n    while res != par[res]:\n        par[res] = find(par[res], par)\n        res = par[res]\n    return res\n\ndef union(a, b, par, rank):\n    (p1, p2) = (find(a, par), find(b, par))\n    if p1 == p2:\n        return 0\n    if rank[p2] > rank[p1]:\n        par[p1] = p2\n        rank[p2] += rank[p1]\n    else:\n        par[p2] = p1\n        rank[p1] += rank[p2]\n    return 1\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    par = [i for i in range(n)]\n    rank = [1 for i in range(n)]\n    for j in range(m):\n        (a, b) = map(int, input().split())\n        union(a, b, par, rank)\n    for i in range(int(input())):\n        (x, y) = map(int, input().split())\n        if find(x, par) == find(y, par):\n            print('YO')\n        else:\n            print('NO')", "def find(node, par):\n    res = node\n    while res != par[res]:\n        par[res] = par[par[res]]\n        res = par[res]\n    return res\n\ndef union(a, b, par, rank):\n    (p1, p2) = (find(a, par), find(b, par))\n    if p1 == p2:\n        return 0\n    if rank[p2] > rank[p1]:\n        par[p1] = p2\n        rank[p2] += rank[p1]\n    else:\n        par[p2] = p1\n        rank[p1] += rank[p2]\n    return 1\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    par = [i for i in range(n)]\n    rank = [1 for i in range(n)]\n    for j in range(m):\n        (a, b) = map(int, input().split())\n        union(a, b, par, rank)\n    for i in range(int(input())):\n        (x, y) = map(int, input().split())\n        if find(x, par) == find(y, par):\n            print('YO')\n        else:\n            print('NO')", "def find(node, par):\n    res = node\n    while res != par[res]:\n        par[res] = par[par[res]]\n        res = par[res]\n    return res\n\ndef union(a, b, par, rank):\n    (p1, p2) = (find(a, par), find(b, par))\n    if p1 == p2:\n        return 0\n    if rank[p2] > rank[p1]:\n        par[p1] = p2\n        rank[p2] += rank[p1]\n    else:\n        par[p2] = p1\n        rank[p1] += rank[p2]\n    return 1\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    par = [i for i in range(n)]\n    rank = [1 for i in range(n)]\n    for j in range(m):\n        (a, b) = map(int, input().split())\n        union(a, b, par, rank)\n    for i in range(int(input())):\n        (x, y) = map(int, input().split())\n        if find(x, par) == find(y, par):\n            print('YO')\n        else:\n            print('NO')", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    par = [i for i in range(n)]\n    size = [1] * n\n    for __ in range(m):\n        (x, y) = map(int, input().split())\n        while x != par[x]:\n            x = par[x]\n        while y != par[y]:\n            y = par[y]\n        if size[x] > size[y]:\n            par[y] = x\n            size[x] += size[y]\n        else:\n            par[x] = y\n            size[y] += size[x]\n    q = int(input())\n    for ___ in range(q):\n        (x, y) = map(int, input().split())\n        while x != par[x]:\n            x = par[x]\n        while y != par[y]:\n            y = par[y]\n        if x == y:\n            print('YO')\n        else:\n            print('NO')", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    par = [i for i in range(n)]\n    size = [1] * n\n    for __ in range(m):\n        (x, y) = map(int, input().split())\n        while x != par[x]:\n            x = par[x]\n        while y != par[y]:\n            y = par[y]\n        if size[x] > size[y]:\n            par[y] = x\n            size[x] += size[y]\n        else:\n            par[x] = y\n            size[y] += size[x]\n    q = int(input())\n    for ___ in range(q):\n        (x, y) = map(int, input().split())\n        while x != par[x]:\n            x = par[x]\n        while y != par[y]:\n            y = par[y]\n        if x == y:\n            print('YO')\n        else:\n            print('NO')", "from collections import deque\n\ndef DFSutil(s, adj, visited):\n    visited.add(s)\n    for n in adj[s]:\n        if n not in visited:\n            DFSutil(n, adj, visited)\n\ndef DFS(s, adj):\n    visited = set()\n    DFSutil(s, adj, visited)\n    return visited\n\ndef cons(s, adj):\n    visited = set()\n    queue = deque()\n    visited.add(s)\n    queue.append(s)\n    while len(queue) > 0:\n        s = queue.popleft()\n        for i in adj[s]:\n            if i not in visited:\n                visited.add(i)\n                queue.append(i)\n    return visited\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    fast = [set() for i in range(n)]\n    reach = [set() for i in range(n)]\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        fast[a].add(b)\n        fast[b].add(a)\n    haspath = set()\n    for ii in range(n):\n        if ii not in haspath:\n            visit = cons(ii, fast)\n            for v in visit:\n                reach[v] = visit\n                haspath.add(v)\n    q = int(input())\n    for _ in range(q):\n        (x, y) = map(int, input().split())\n        if x == y:\n            print('YO')\n        elif x in reach[y]:\n            print('YO')\n        else:\n            print('NO')", "from collections import deque\n\ndef DFSutil(s, adj, visited):\n    visited.add(s)\n    for n in adj[s]:\n        if n not in visited:\n            DFSutil(n, adj, visited)\n\ndef DFS(s, adj):\n    visited = set()\n    DFSutil(s, adj, visited)\n    return visited\n\ndef cons(s, adj):\n    visited = set()\n    queue = deque()\n    visited.add(s)\n    queue.append(s)\n    while len(queue) > 0:\n        s = queue.popleft()\n        for i in adj[s]:\n            if i not in visited:\n                visited.add(i)\n                queue.append(i)\n    return visited\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    fast = [set() for i in range(n)]\n    reach = [set() for i in range(n)]\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        fast[a].add(b)\n        fast[b].add(a)\n    haspath = set()\n    for ii in range(n):\n        if ii not in haspath:\n            visit = DFS(ii, fast)\n            for v in visit:\n                reach[v] = visit\n                haspath.add(v)\n    q = int(input())\n    for _ in range(q):\n        (x, y) = map(int, input().split())\n        if x == y:\n            print('YO')\n        elif x in reach[y]:\n            print('YO')\n        else:\n            print('NO')", "from collections import deque\n\ndef recur(ind, visited, graph):\n    visited[ind] = True\n    res = set()\n    queue = deque([ind])\n    while queue:\n        cur = queue.popleft()\n        visited[cur] = True\n        for i in graph[cur]:\n            if not visited[i]:\n                queue.append(i)\n        res.add(cur)\n    return res\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = {i: set() for i in range(n)}\n    mem = {i: set() for i in range(n)}\n    visited = [False] * n\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        graph[x].add(y)\n        graph[y].add(x)\n    for i in range(n):\n        if not visited[i]:\n            cur = recur(i, visited, graph)\n            for j in cur:\n                mem[j] = cur\n    for q in range(int(input())):\n        (a, b) = map(int, input().split())\n        if a in mem[b] or b in mem[a]:\n            print('YO')\n        else:\n            print('NO')", "def dfs(s, vis, d, m):\n    vis[s] = mark\n    for i in d[s]:\n        if vis[i] == False:\n            dfs(i, vis, d, m)\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    d = dict()\n    for i in range(n):\n        d[i] = set()\n    for i in range(m):\n        (x, y) = list(map(int, input().split()))\n        if x != y:\n            d[x].add(y)\n            d[y].add(x)\n    vis = [False for i in range(n)]\n    mark = 1\n    for i in range(n):\n        if vis[i] == False:\n            dfs(i, vis, d, mark)\n            mark += 1\n    q = int(input())\n    for _ in range(q):\n        (a, b) = list(map(int, input().split()))\n        if vis[a] == vis[b]:\n            print('YO')\n        else:\n            print('NO')", "def dfs(s, vis, d, m):\n    vis[s] = mark\n    for i in d[s]:\n        if vis[i] == False:\n            dfs(i, vis, d, m)\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    d = dict()\n    for i in range(n):\n        d[i] = set()\n    for i in range(m):\n        (x, y) = list(map(int, input().split()))\n        if x != y:\n            d[x].add(y)\n            d[y].add(x)\n    vis = [False for i in range(n)]\n    mark = 1\n    for i in range(n):\n        if vis[i] == False:\n            dfs(i, vis, d, mark)\n            mark += 1\n    q = int(input())\n    for _ in range(q):\n        (a, b) = list(map(int, input().split()))\n        if vis[a] == vis[b]:\n            print('YO')\n        else:\n            print('NO')", "from collections import defaultdict\nfrom queue import deque\nt = int(input())\nwhile t:\n    (n, m) = map(int, input().split())\n    parent = [i for i in range(n)]\n    rank = [1] * n\n\n    def find(node, parent):\n        if node == parent[node]:\n            return parent[node]\n        return find(parent[node], parent)\n\n    def union(u, v):\n        lx = find(u, parent)\n        ly = find(v, parent)\n        if lx != ly:\n            if rank[lx] < rank[ly]:\n                parent[lx] = ly\n            elif rank[lx] > rank[ly]:\n                parent[ly] = lx\n            else:\n                parent[ly] = lx\n                rank[lx] += 1\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        union(u, v)\n    x = int(input())\n    for _ in range(x):\n        (u, v) = map(int, input().split())\n        lx = find(u, parent)\n        ly = find(v, parent)\n        if lx != ly:\n            print('NO')\n        else:\n            print('YO')\n    t -= 1", "def find(node):\n    res = node\n    while res != par[res]:\n        par[res] = par[par[res]]\n        res = par[res]\n    return res\n\ndef union(n1, n2):\n    (p1, p2) = (find(n1), find(n2))\n    if p1 == p2:\n        return 0\n    if rank[p2] > rank[p1]:\n        par[p1] = p2\n        rank[p2] += rank[p1]\n    else:\n        par[p2] = p1\n        rank[p1] += rank[p2]\n    return 1\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    par = [i for i in range(n)]\n    rank = [1 for _ in range(n)]\n    for _ in range(m):\n        (a, b) = list(map(int, input().split()))\n        union(a, b)\n    q = int(input())\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        if find(x) == find(y):\n            print('YO')\n        else:\n            print('NO')", "def find(node):\n    res = node\n    while res != par[res]:\n        par[res] = par[par[res]]\n        res = par[res]\n    return res\n\ndef union(n1, n2):\n    (p1, p2) = (find(n1), find(n2))\n    if p1 == p2:\n        return 0\n    if rank[p2] > rank[p1]:\n        par[p1] = p2\n        rank[p2] += rank[p1]\n    else:\n        par[p2] = p1\n        rank[p1] += rank[p2]\n    return 1\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    par = [i for i in range(n)]\n    rank = [1 for _ in range(n)]\n    for _ in range(m):\n        (a, b) = list(map(int, input().split()))\n        union(a, b)\n    q = int(input())\n    for _ in range(q):\n        (x, y) = list(map(int, input().split()))\n        if find(x) == find(y):\n            print('YO')\n        else:\n            print('NO')", "def find(x, arr):\n    if arr[x] < 0:\n        return x\n    else:\n        y = find(arr[x], arr)\n        arr[x] = y\n        return y\n\ndef merge(la, lb, arr):\n    if la <= lb:\n        arr[la] = arr[la] + arr[lb]\n        arr[lb] = la\n    else:\n        arr[lb] = arr[la] + arr[lb]\n        arr[la] = lb\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    arr = [-1] * a\n    for i in range(b):\n        (n, m) = map(int, input().split())\n        la = find(n, arr)\n        lb = find(m, arr)\n        if la != lb:\n            merge(la, lb, arr)\n    for i in range(int(input())):\n        (s, d) = map(int, input().split())\n        la = find(s, arr)\n        lb = find(d, arr)\n        if la == lb:\n            print('YO')\n        else:\n            print('NO')", "def find(x, arr):\n    if arr[x] < 0:\n        return x\n    else:\n        y = find(arr[x], arr)\n        arr[x] = y\n        return y\n\ndef merge(la, lb, arr):\n    if la <= lb:\n        arr[la] = arr[la] + arr[lb]\n        arr[lb] = la\n    else:\n        arr[lb] = arr[la] + arr[lb]\n        arr[la] = lb\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    arr = [-1] * a\n    for i in range(b):\n        (n, m) = map(int, input().split())\n        la = find(n, arr)\n        lb = find(m, arr)\n        if la != lb:\n            merge(la, lb, arr)\n    for i in range(int(input())):\n        (s, d) = map(int, input().split())\n        la = find(s, arr)\n        lb = find(d, arr)\n        if la == lb:\n            print('YO')\n        else:\n            print('NO')", "def visit(u, visited, L, adj):\n    if not visited[u]:\n        visited[u] = True\n        for v in adj[u]:\n            visit(v, visited, L, adj)\n        L.append(u)\n\ndef assign(u, root, who, adj):\n    if who[u] is None:\n        who[u] = root\n        for v in adj[u]:\n            assign(v, root, who, adj)\nt = int(input())\nfor _ in range(t):\n    (V, E) = [int(e) for e in input().split()]\n    adj = {v: [] for v in range(V)}\n    for _ in range(E):\n        (u, v) = [int(e) for e in input().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n    L = []\n    visited = [False for _ in range(V)]\n    who = [None for _ in range(V)]\n    for u in range(V):\n        visit(u, visited, L, adj)\n    while len(L):\n        u = L.pop()\n        assign(u, u, who, adj)\n    q = int(input())\n    for _ in range(q):\n        (i, j) = [int(e) for e in input().split()]\n        print('YO' if who[i] == who[j] else 'NO')", "def find(node, arr):\n    if arr[node] < 0:\n        return node\n    else:\n        temp = find(arr[node], arr)\n        arr[node] = temp\n        return temp\n\ndef union(la, lb, arr):\n    if arr[la] <= arr[lb]:\n        arr[la] = arr[la] + arr[lb]\n        arr[lb] = la\n    else:\n        arr[lb] = arr[la] + arr[lb]\n        arr[la] = lb\nt = int(input())\nwhile t:\n    (n, m) = map(int, input().split())\n    arr = [-1] * n\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        la = find(a, arr)\n        lb = find(b, arr)\n        if la != lb:\n            union(la, lb, arr)\n    q = int(input())\n    for i in range(q):\n        (a, b) = map(int, input().split())\n        if find(a, arr) == find(b, arr):\n            print('YO')\n        else:\n            print('NO')\n    t -= 1", "def find(node, arr):\n    if arr[node] < 0:\n        return node\n    else:\n        temp = find(arr[node], arr)\n        arr[node] = temp\n        return temp\n\ndef union(la, lb, arr):\n    if arr[la] <= arr[lb]:\n        arr[la] = arr[la] + arr[lb]\n        arr[lb] = la\n    else:\n        arr[lb] = arr[la] + arr[lb]\n        arr[la] = lb\nt = int(input())\nwhile t:\n    (n, m) = map(int, input().split())\n    arr = [-1] * n\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        la = find(a, arr)\n        lb = find(b, arr)\n        if la != lb:\n            union(la, lb, arr)\n    q = int(input())\n    for i in range(q):\n        (a, b) = map(int, input().split())\n        if find(a, arr) == find(b, arr):\n            print('YO')\n        else:\n            print('NO')\n    t -= 1", "def dfs(a, b, visited):\n    for ele in dct[b]:\n        if ele not in visited:\n            root[a][ele] = 1\n            root[ele][a] = 1\n            visited.add(ele)\n            dfs(a, ele, visited)\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    dct = {}\n    for i in range(m):\n        (a, b) = list(map(int, input().split()))\n        if a not in dct:\n            dct[a] = {b}\n        else:\n            dct[a].add(b)\n        if b not in dct:\n            dct[b] = {a}\n        else:\n            dct[b].add(a)\n    Q = int(input())\n    root = [[0 for j in range(n)] for i in range(n)]\n    for i in range(n):\n        root[i][i] = 1\n        if i not in dct:\n            continue\n        dfs(i, i, {i})\n    for i in range(Q):\n        (a, b) = list(map(int, input().split()))\n        if root[a][b] or root[b][a]:\n            print('YO')\n        else:\n            print('NO')", "def dfs(a, b, visited):\n    for ele in dct[b]:\n        if ele not in visited:\n            root[a][ele] = 1\n            root[ele][a] = 1\n            visited.add(ele)\n            dfs(a, ele, visited)\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    dct = {}\n    for i in range(m):\n        (a, b) = list(map(int, input().split()))\n        if a not in dct:\n            dct[a] = {b}\n        else:\n            dct[a].add(b)\n        if b not in dct:\n            dct[b] = {a}\n        else:\n            dct[b].add(a)\n    Q = int(input())\n    root = [[0 for j in range(n)] for i in range(n)]\n    for i in range(n):\n        root[i][i] = 1\n        if i not in dct:\n            continue\n        dfs(i, i, {i})\n    for i in range(Q):\n        (a, b) = list(map(int, input().split()))\n        if root[a][b] or root[b][a]:\n            print('YO')\n        else:\n            print('NO')", "def find_parent(x, lst):\n    if lst[x] == x:\n        return x\n    lst[x] = find_parent(lst[x], lst)\n    return lst[x]\n\ndef merge(a, b, lst):\n    x = find_parent(b, lst)\n    y = find_parent(a, lst)\n    lst[x] = y\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    lst = [i for i in range(n + 1)]\n    visited = set()\n    for i in range(m):\n        (a, b) = list(map(int, input().split()))\n        if a == b:\n            visited.add(a)\n        merge(a, b, lst)\n    q = int(input())\n    for i in range(q):\n        (x, y) = list(map(int, input().split()))\n        (px, py) = (find_parent(x, lst), find_parent(y, lst))\n        print('YO' if px == py else 'NO')", "from collections import defaultdict\ntry:\n\n    def find(node, arr):\n        if arr[node] < 0:\n            return node\n        else:\n            temp = find(arr[node], arr)\n            arr[node] = temp\n            return temp\n\n    def merge(la, lb, arr):\n        if arr[la] <= arr[lb]:\n            arr[la] = arr[la] + arr[lb]\n            arr[lb] = la\n        else:\n            arr[lb] = arr[lb] + arr[la]\n            arr[la] = lb\n    for _ in range(int(input())):\n        (n, m) = list(map(int, input().split()))\n        arr = [-1] * n\n        for _ in range(m):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                merge(la, lb, arr)\n        q = int(input())\n        for _ in range(q):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                print('NO')\n            else:\n                print('YO')\nexcept:\n    pass", "from collections import defaultdict\ntry:\n\n    def find(node, arr):\n        if arr[node] < 0:\n            return node\n        else:\n            temp = find(arr[node], arr)\n            arr[node] = temp\n            return temp\n\n    def merge(la, lb, arr):\n        if arr[la] <= arr[lb]:\n            arr[la] = arr[la] + arr[lb]\n            arr[lb] = la\n        else:\n            arr[lb] = arr[lb] + arr[la]\n            arr[la] = lb\n    for _ in range(int(input())):\n        (n, m) = list(map(int, input().split()))\n        arr = [-1] * n\n        for _ in range(m):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                merge(la, lb, arr)\n        q = int(input())\n        for _ in range(q):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                print('NO')\n            else:\n                print('YO')\nexcept:\n    pass", "from collections import defaultdict\ntry:\n\n    def find(node, arr):\n        if arr[node] < 0:\n            return node\n        else:\n            temp = find(arr[node], arr)\n            arr[node] = temp\n            return temp\n\n    def merge(la, lb, arr):\n        if arr[la] <= arr[lb]:\n            arr[la] = arr[la] + arr[lb]\n            arr[lb] = la\n        else:\n            arr[lb] = arr[lb] + arr[la]\n            arr[la] = lb\n    for _ in range(int(input())):\n        (n, m) = list(map(int, input().split()))\n        arr = [-1] * n\n        for _ in range(m):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                merge(la, lb, arr)\n        q = int(input())\n        for _ in range(q):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                print('NO')\n            else:\n                print('YO')\nexcept:\n    pass", "from collections import defaultdict\ntry:\n\n    def find(node, arr):\n        if arr[node] < 0:\n            return node\n        else:\n            temp = find(arr[node], arr)\n            arr[node] = temp\n            return temp\n\n    def merge(la, lb, arr):\n        if arr[la] <= arr[lb]:\n            arr[la] = arr[la] + arr[lb]\n            arr[lb] = la\n        else:\n            arr[lb] = arr[lb] + arr[la]\n            arr[la] = lb\n    for _ in range(int(input())):\n        (n, m) = list(map(int, input().split()))\n        arr = [-1] * n\n        for _ in range(m):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                merge(la, lb, arr)\n        q = int(input())\n        for _ in range(q):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                print('NO')\n            else:\n                print('YO')\nexcept:\n    pass", "from collections import defaultdict\ntry:\n\n    def find(node, arr):\n        if arr[node] < 0:\n            return node\n        else:\n            temp = find(arr[node], arr)\n            arr[node] = temp\n            return temp\n\n    def merge(la, lb, arr):\n        if arr[la] <= arr[lb]:\n            arr[la] = arr[la] + arr[lb]\n            arr[lb] = la\n        else:\n            arr[lb] = arr[lb] + arr[la]\n            arr[la] = lb\n    for _ in range(int(input())):\n        (n, m) = list(map(int, input().split()))\n        arr = [-1] * n\n        for _ in range(m):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                merge(la, lb, arr)\n        q = int(input())\n        for _ in range(q):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                print('NO')\n            else:\n                print('YO')\nexcept:\n    pass", "from collections import defaultdict\ntry:\n\n    def find(node, arr):\n        if arr[node] < 0:\n            return node\n        else:\n            temp = find(arr[node], arr)\n            arr[node] = temp\n            return temp\n\n    def merge(la, lb, arr):\n        if arr[la] <= arr[lb]:\n            arr[la] = arr[la] + arr[lb]\n            arr[lb] = la\n        else:\n            arr[lb] = arr[lb] + arr[la]\n            arr[la] = lb\n    for _ in range(int(input())):\n        (n, m) = list(map(int, input().split()))\n        arr = [-1] * n\n        for _ in range(m):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                merge(la, lb, arr)\n        q = int(input())\n        for _ in range(q):\n            (a, b) = map(int, input().split())\n            la = find(a, arr)\n            lb = find(b, arr)\n            if la != lb:\n                print('NO')\n            else:\n                print('YO')\nexcept:\n    pass", "def find(node, arr):\n    if arr[node] < 0:\n        return node\n    else:\n        temp = find(arr[node], arr)\n        arr[node] = temp\n        return temp\n\ndef merge(la, lb, arr):\n    if arr[la] <= arr[lb]:\n        arr[la] = arr[la] + arr[lb]\n        arr[lb] = la\n    else:\n        arr[lb] = arr[lb] + arr[la]\n        arr[la] = lb\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = [-1] * n\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        la = find(a, arr)\n        lb = find(b, arr)\n        if la != lb:\n            merge(la, lb, arr)\n    q = int(input())\n    for _ in range(q):\n        (a, b) = map(int, input().split())\n        la = find(a, arr)\n        lb = find(b, arr)\n        if la != lb:\n            print('NO')\n        else:\n            print('YO')", "def find(u, graph):\n    if graph[u] < 0:\n        return u\n    else:\n        temp = find(graph[u], graph)\n        graph[u] = temp\n        return temp\n\ndef union(u, v, graph):\n    u = find(u, graph)\n    v = find(v, graph)\n    if graph[u] <= graph[v]:\n        graph[u] += graph[v]\n        graph[v] = u\n    else:\n        graph[v] += graph[u]\n        graph[u] = v\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [-1] * n\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        if find(u, graph) != find(v, graph):\n            union(u, v, graph)\n    k = int(input())\n    for _ in range(k):\n        (u, v) = map(int, input().split())\n        if find(u, graph) == find(v, graph):\n            print('YO')\n        else:\n            print('NO')", "t = int(input())\nfor i in range(0, t):\n    (n, m) = map(int, input().split())\n    l = [0] * n\n    for j in range(0, n):\n        l[j] = j\n    for j in range(0, m):\n        (a, b) = map(int, input().split())\n        if l[a] < l[b]:\n            temp = l[b]\n            for p in range(0, n):\n                if l[p] == temp:\n                    l[p] = l[a]\n        elif l[b] < l[a]:\n            temp = l[a]\n            for p in range(0, n):\n                if l[p] == temp:\n                    l[p] = l[b]\n    q = int(input())\n    for p in range(0, q):\n        (x, y) = map(int, input().split())\n        if l[x] == l[y]:\n            print('YO')\n        else:\n            print('NO')", "import sys\nsys.setrecursionlimit(10000)\n\ndef dfs(n):\n    ans = set()\n    queue = [n]\n    bool[n] = True\n    ans.add(n)\n    while queue != []:\n        z = queue.pop(0)\n        ans.add(z)\n        for j in hash[z]:\n            if bool[j] == False:\n                bool[j] = True\n                queue.append(j)\n    return ans\nfrom collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    ans = []\n    hash = defaultdict(list)\n    (n, m) = map(int, sys.stdin.readline().strip().split())\n    for i in range(m):\n        (a, b) = map(int, sys.stdin.readline().strip().split())\n        hash[a].append(b)\n        hash[b].append(a)\n    for i in range(n):\n        bool = [False] * n\n        z = dfs(i)\n        hash[i] = z\n    q = int(input())\n    for i in range(q):\n        (a, b) = map(int, sys.stdin.readline().strip().split())\n        dfs(a)\n        if b in hash[a]:\n            z = 'YO'\n            sys.stdout.write(z)\n            print()\n        else:\n            z = 'NO'\n            sys.stdout.write(z)\n            print()", "from collections import defaultdict\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.DFSList = defaultdict(list)\n        for i in range(0, vertices):\n            self.graph[i] = []\n            self.DFSList[i] = []\n\n    def addEdge(self, u, v):\n        if u != v:\n            self.graph[u].append(v)\n            self.graph[v].append(u)\n\n    def DFSUtil(self, v, visited, n):\n        visited[v] = True\n        self.DFSList[n].append(v)\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited, n)\n\n    def DFS(self, v):\n        visited = [False] * len(self.graph)\n        self.DFSUtil(v, visited, v)\nt = int(input())\nfor z in range(0, t):\n    (n, m) = map(int, input().split())\n    g = Graph(n)\n    for M in range(0, m):\n        (u, v) = map(int, input().split())\n        g.addEdge(u, v)\n    for i in range(0, n):\n        g.DFS(i)\n    q = int(input())\n    for Q in range(0, q):\n        (u, v) = map(int, input().split())\n        if v in g.DFSList[u]:\n            print('YO')\n        else:\n            print('NO')"]