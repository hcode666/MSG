["def T(N):\n    A = str(N)\n    n = len(A)\n    y = 0\n    while n != 1:\n        x = 0\n        for j in A:\n            x += int(j)\n        A = str(x)\n        n = len(A)\n        y += 1\n    return (int(A), y)\n\ndef U(N):\n    B = str(N)\n    x = 0\n    for j in B:\n        x += int(j)\n    return x\na = int(input())\nfor i in range(a):\n    (N, D) = map(int, input().split())\n    p = T(N)\n    q = T(D)\n    ans = [0, 0]\n    if q[0] == 9:\n        ans[0] = p[0]\n        if p[1] <= T(N + D)[1] + 1:\n            ans[1] = p[1]\n        else:\n            ans[1] = T(N + D)[1] + 1\n    elif q[0] == 6:\n        a = min(p[0], T(p[0] + 6)[0], T(p[0] + 3)[0])\n        ans[0] = a\n        if a == p[0]:\n            ans[1] = p[1]\n        elif a == T(p[0] + 6)[0]:\n            ans[1] = min(T(U(N) + D)[1] + 2, T(N + D)[1] + 1)\n        else:\n            ans[1] = min(T(U(N) + 2 * D)[1] + 3, T(U(N + D) + D)[1] + 3, T(N + 2 * D)[1] + 2)\n    elif q[0] == 3:\n        a = min(p[0], T(p[0] + 6)[0], T(p[0] + 3)[0])\n        ans[0] = a\n        if a == p[0]:\n            ans[1] = p[1]\n        elif a == T(p[0] + 3)[0]:\n            ans[1] = min(T(U(N) + D)[1] + 2, T(N + D)[1] + 1)\n        else:\n            ans[1] = min(T(U(N) + 2 * D)[1] + 3, T(U(N + D) + D)[1] + 3, T(N + 2 * D)[1] + 2)\n    else:\n        g = 0\n        ans[0] = 1\n        A = N\n        for j in range(20):\n            if T(A)[0] == 1:\n                break\n            else:\n                A = A + D\n                g += 1\n        ans[1] = T(N + g * D)[1] + g\n        for j in range(0, g + 1):\n            if T(U(N + j * D) + (g - j) * D)[1] + g + 1 < ans[1]:\n                ans[1] = T(U(N + j * D) + (g - j) * D)[1] + g + 1\n    print(ans[0], ans[1])", "def T(N):\n    A = str(N)\n    n = len(A)\n    y = 0\n    while n != 1:\n        x = 0\n        for j in A:\n            x += int(j)\n        A = str(x)\n        n = len(A)\n        y += 1\n    return (int(A), y)\n\ndef U(N):\n    B = str(N)\n    x = 0\n    for j in B:\n        x += int(j)\n    return x\na = int(input())\nfor i in range(a):\n    (N, D) = map(int, input().split())\n    p = T(N)\n    q = T(D)\n    ans = [0, 0]\n    if q[0] == 9:\n        ans[0] = p[0]\n        if p[1] <= T(N + D)[1] + 1:\n            ans[1] = p[1]\n        else:\n            ans[1] = T(N + D)[1] + 1\n    elif q[0] == 6:\n        a = min(p[0], T(p[0] + 6)[0], T(p[0] + 3)[0])\n        ans[0] = a\n        if a == p[0]:\n            ans[1] = p[1]\n        elif a == T(p[0] + 6)[0]:\n            ans[1] = min(T(U(N) + D)[1] + 2, T(N + D)[1] + 1)\n        else:\n            ans[1] = min(T(U(N) + 2 * D)[1] + 3, T(U(N + D) + D)[1] + 3, T(N + 2 * D)[1] + 2)\n    elif q[0] == 3:\n        a = min(p[0], T(p[0] + 6)[0], T(p[0] + 3)[0])\n        ans[0] = a\n        if a == p[0]:\n            ans[1] = p[1]\n        elif a == T(p[0] + 3)[0]:\n            ans[1] = min(T(U(N) + D)[1] + 2, T(N + D)[1] + 1)\n        else:\n            ans[1] = min(T(U(N) + 2 * D)[1] + 3, T(U(N + D) + D)[1] + 3, T(N + 2 * D)[1] + 2)\n    else:\n        g = 0\n        ans[0] = 1\n        A = N\n        for j in range(20):\n            if T(A)[0] == 1:\n                break\n            else:\n                A = A + D\n                g += 1\n        ans[1] = T(N + g * D)[1] + g\n        for j in range(0, g + 1):\n            if T(U(N + j * D) + (g - j) * D)[1] + g + 1 < ans[1]:\n                ans[1] = T(U(N + j * D) + (g - j) * D)[1] + g + 1\n    print(ans[0], ans[1])", "def T(N):\n    A = str(N)\n    n = len(A)\n    y = 0\n    while n != 1:\n        x = 0\n        for j in A:\n            x += int(j)\n        A = str(x)\n        n = len(A)\n        y += 1\n    return (int(A), y)\n\ndef U(N):\n    B = str(N)\n    x = 0\n    for j in B:\n        x += int(j)\n    return x\na = int(input())\nfor i in range(a):\n    (N, D) = map(int, input().split())\n    p = T(N)\n    q = T(D)\n    ans = [0, 0]\n    if q[0] == 9:\n        ans[0] = p[0]\n        if p[1] <= T(N + D)[1] + 1:\n            ans[1] = p[1]\n        else:\n            ans[1] = T(N + D)[1] + 1\n    elif q[0] == 6:\n        a = min(p[0], T(p[0] + 6)[0], T(p[0] + 3)[0])\n        ans[0] = a\n        if a == p[0]:\n            ans[1] = p[1]\n        elif a == T(p[0] + 6)[0]:\n            ans[1] = min(T(U(N) + D)[1] + 2, T(N + D)[1] + 1)\n        else:\n            ans[1] = min(T(U(N) + 2 * D)[1] + 3, T(U(N + D) + D)[1] + 3, T(N + 2 * D)[1] + 2)\n    elif q[0] == 3:\n        a = min(p[0], T(p[0] + 6)[0], T(p[0] + 3)[0])\n        ans[0] = a\n        if a == p[0]:\n            ans[1] = p[1]\n        elif a == T(p[0] + 3)[0]:\n            ans[1] = min(T(U(N) + D)[1] + 2, T(N + D)[1] + 1)\n        else:\n            ans[1] = min(T(U(N) + 2 * D)[1] + 3, T(U(N + D) + D)[1] + 3, T(N + 2 * D)[1] + 2)\n    else:\n        g = 0\n        ans[0] = 1\n        A = N\n        for j in range(20):\n            if T(A)[0] == 1:\n                break\n            else:\n                A = A + D\n                g += 1\n        ans[1] = T(N + g * D)[1] + g\n        for j in range(0, g + 1):\n            if T(U(N + j * D) + (g - j) * D)[1] + g + 1 < ans[1]:\n                ans[1] = T(U(N + j * D) + (g - j) * D)[1] + g + 1\n    print(ans[0], ans[1])", "def T(N):\n    A = str(N)\n    n = len(A)\n    y = 0\n    while n != 1:\n        x = 0\n        for j in A:\n            x += int(j)\n        A = str(x)\n        n = len(A)\n        y += 1\n    return (int(A), y)\n\ndef U(N):\n    B = str(N)\n    x = 0\n    for j in B:\n        x += int(j)\n    return x\na = int(input())\nfor i in range(a):\n    (N, D) = map(int, input().split())\n    p = T(N)\n    q = T(D)\n    ans = [0, 0]\n    if q[0] == 9:\n        ans[0] = p[0]\n        if p[1] <= T(N + D)[1] + 1:\n            ans[1] = p[1]\n        else:\n            ans[1] = T(N + D)[1] + 1\n    elif q[0] == 6:\n        a = min(p[0], T(p[0] + 6)[0], T(p[0] + 3)[0])\n        ans[0] = a\n        if a == p[0]:\n            ans[1] = p[1]\n        elif a == T(p[0] + 6)[0]:\n            ans[1] = min(T(U(N) + D)[1] + 2, T(N + D)[1] + 1)\n        else:\n            ans[1] = min(T(U(N) + 2 * D)[1] + 3, T(U(N + D) + D)[1] + 3, T(N + 2 * D)[1] + 2)\n    elif q[0] == 3:\n        a = min(p[0], T(p[0] + 6)[0], T(p[0] + 3)[0])\n        ans[0] = a\n        if a == p[0]:\n            ans[1] = p[1]\n        elif a == T(p[0] + 3)[0]:\n            ans[1] = min(T(U(N) + D)[1] + 2, T(N + D)[1] + 1)\n        else:\n            ans[1] = min(T(U(N) + 2 * D)[1] + 3, T(U(N + D) + D)[1] + 3, T(N + 2 * D)[1] + 2)\n    else:\n        g = 0\n        ans[0] = 1\n        A = N\n        for j in range(20):\n            if T(A)[0] == 1:\n                break\n            else:\n                A = A + D\n                g += 1\n        ans[1] = T(N + g * D)[1] + g\n        for j in range(0, g + 1):\n            if T(U(N + j * D) + (g - j) * D)[1] + g + 1 < ans[1]:\n                ans[1] = T(U(N + j * D) + (g - j) * D)[1] + g + 1\n    print(ans[0], ans[1])", "def T(N):\n    A = str(N)\n    n = len(A)\n    y = 0\n    while n != 1:\n        x = 0\n        for j in A:\n            x += int(j)\n        A = str(x)\n        n = len(A)\n        y += 1\n    return (int(A), y)\n\ndef U(N):\n    B = str(N)\n    x = 0\n    for j in B:\n        x += int(j)\n    return x\na = int(input())\nfor i in range(a):\n    (N, D) = map(int, input().split())\n    p = T(N)\n    q = T(D)\n    ans = [0, 0]\n    if q[0] == 9:\n        ans[0] = p[0]\n        if p[1] <= T(N + D)[1] + 1:\n            ans[1] = p[1]\n        else:\n            ans[1] = T(N + D)[1] + 1\n    elif q[0] == 6:\n        a = min(p[0], T(p[0] + 6)[0], T(p[0] + 3)[0])\n        ans[0] = a\n        if a == p[0]:\n            ans[1] = p[1]\n        elif a == T(p[0] + 6)[0]:\n            ans[1] = min(T(U(N) + D)[1] + 2, T(N + D)[1] + 1)\n        else:\n            ans[1] = min(T(U(N) + 2 * D)[1] + 3, T(U(N + D) + D)[1] + 3, T(N + 2 * D)[1] + 2)\n    elif q[0] == 3:\n        a = min(p[0], T(p[0] + 6)[0], T(p[0] + 3)[0])\n        ans[0] = a\n        if a == p[0]:\n            ans[1] = p[1]\n        elif a == T(p[0] + 3)[0]:\n            ans[1] = min(T(U(N) + D)[1] + 2, T(N + D)[1] + 1)\n        else:\n            ans[1] = min(T(U(N) + 2 * D)[1] + 3, T(U(N + D) + D)[1] + 3, T(N + 2 * D)[1] + 2)\n    else:\n        g = 0\n        ans[0] = 1\n        A = N\n        for j in range(20):\n            if T(A)[0] == 1:\n                break\n            else:\n                A = A + D\n                g += 1\n        ans[1] = T(N + g * D)[1] + g\n        for j in range(0, g + 1):\n            if T(U(N + j * D) + (g - j) * D)[1] + g + 1 < ans[1]:\n                ans[1] = T(U(N + j * D) + (g - j) * D)[1] + g + 1\n    print(ans[0], ans[1])", "def snek1(s):\n    while s > 9:\n        s2 = str(s)\n        s = [int(i) for i in list(s2)]\n        s = sum(s)\n    return s\n\ndef snek2(s):\n    h = 0\n    while s > 0:\n        h += s % 10\n        s //= 10\n    return h\nt = int(input())\nfor i in range(t):\n    (n, d) = map(int, input().split())\n    c = 10\n    for j in range(10):\n        s = n + d * j\n        u = snek1(s)\n        if u < c:\n            c = u\n    q = [[n, 0]]\n    x = {}\n    while len(q) > 0:\n        l = q.pop(0)\n        if l[0] < 10:\n            if x.get(l[0]) != None:\n                continue\n            x[l[0]] = l[1]\n        else:\n            q.append([snek2(l[0]), l[1] + 1])\n        q.append([l[0] + d, l[1] + 1])\n        if l[0] == c:\n            break\n    print(c, x[c])", "def snek1(s):\n    while s > 9:\n        s2 = str(s)\n        s = [int(i) for i in list(s2)]\n        s = sum(s)\n    return s\n\ndef snek2(s):\n    h = 0\n    while s > 0:\n        h += s % 10\n        s //= 10\n    return h\nt = int(input())\nfor i in range(t):\n    (n, d) = map(int, input().split())\n    c = 10\n    for j in range(10):\n        s = n + d * j\n        u = snek1(s)\n        if u < c:\n            c = u\n    q = [[n, 0]]\n    x = {}\n    while len(q) > 0:\n        l = q.pop(0)\n        if l[0] < 10:\n            if x.get(l[0]) != None:\n                continue\n            x[l[0]] = l[1]\n        else:\n            q.append([snek2(l[0]), l[1] + 1])\n        q.append([l[0] + d, l[1] + 1])\n        if l[0] == c:\n            break\n    print(c, x[c])", "def dSum(num):\n    while num > 9:\n        nstr = str(num)\n        num = [int(x) for x in list(nstr)]\n        num = sum(num)\n    return num\n\ndef dS2(num):\n    tot = 0\n    while num > 0:\n        tot += num % 10\n        num //= 10\n    return tot\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    temp = 10\n    for i in range(10):\n        num = n + d * i\n        ds = dSum(num)\n        if ds < temp:\n            temp = ds\n    q = [[n, 0]]\n    dic = {}\n    while len(q) > 0:\n        el = q.pop(0)\n        if el[0] < 10:\n            if dic.get(el[0]) != None:\n                continue\n            dic[el[0]] = el[1]\n        else:\n            q.append([dS2(el[0]), el[1] + 1])\n        q.append([el[0] + d, el[1] + 1])\n        if el[0] == temp:\n            break\n    print(temp, dic[temp])", "def dSum(num):\n    while num > 9:\n        nstr = str(num)\n        num = [int(x) for x in list(nstr)]\n        num = sum(num)\n    return num\n\ndef dS2(num):\n    tot = 0\n    while num > 0:\n        tot += num % 10\n        num //= 10\n    return tot\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    temp = 10\n    for i in range(10):\n        num = n + d * i\n        ds = dSum(num)\n        if ds < temp:\n            temp = ds\n    q = [[n, 0]]\n    dic = {}\n    while len(q) > 0:\n        el = q.pop(0)\n        if el[0] < 10:\n            if dic.get(el[0]) != None:\n                continue\n            dic[el[0]] = el[1]\n        else:\n            q.append([dS2(el[0]), el[1] + 1])\n        q.append([el[0] + d, el[1] + 1])\n        if el[0] == temp:\n            break\n    print(temp, dic[temp])", "from sys import stdin, stdout\ninput = stdin.readline\n\ndef digitSum1(n):\n    while n > 9:\n        num = str(n)\n        n = list(num)\n        n = [int(digit) for digit in n]\n        n = sum(n)\n    return n\n\ndef digitSum2(n):\n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    return total\nt = int(input().strip())\nfor _ in range(t):\n    (n, d) = list(map(int, input().strip().split()))\n    mini = 10\n    for i in range(10):\n        num = n + d * i\n        digit_sum = digitSum1(num)\n        if digit_sum < mini:\n            mini = digit_sum\n    que = [[n, 0]]\n    d1 = dict()\n    while len(que) > 0:\n        ele = que.pop(0)\n        if ele[0] < 10:\n            if d1.get(ele[0]) != None:\n                continue\n            d1[ele[0]] = ele[1]\n        else:\n            que.append([digitSum2(ele[0]), ele[1] + 1])\n        que.append([ele[0] + d, ele[1] + 1])\n        if ele[0] == mini:\n            break\n    print(mini, d1[mini])", "def ds(n):\n    num_str = str(n)\n    sum = 0\n    for i in range(0, len(num_str)):\n        sum += int(num_str[i])\n    return sum\nt = int(input())\nfor _ in range(t):\n    (n, d) = input().split()\n    n = int(n)\n    d = int(d)\n    s = set()\n    temp = n\n    for i in range(500000):\n        if temp <= 9:\n            if not temp in s:\n                s.add(temp)\n                temp = temp + d\n            else:\n                break\n        else:\n            temp = ds(temp)\n    s = sorted(s)\n    k = s[0]\n    q = []\n    ans = 0\n    q.append((n, 1))\n    while len(q) != 0:\n        num = q[0][0]\n        step = q[0][1]\n        q.pop(0)\n        if num is k:\n            ans = step - 1\n            break\n        q.append((num + d, step + 1))\n        q.append((ds(num), step + 1))\n    print(str(k) + ' ' + str(ans))", "def DigitSum(N):\n    sum = 0\n    while N > 0:\n        sum += N % 10\n        N = int(N / 10)\n    return sum\n\ndef minimizeDigitsum(N, D, countOperations):\n    digitSum = DigitSum(N)\n    if countOperations > 10:\n        return\n    countOperations += 1\n    if N < 10:\n        if visited[N] == 1:\n            if operations[N] <= countOperations:\n                return\n        visited[N] = 1\n        operations[N] = countOperations\n    minimizeDigitsum(N + D, D, countOperations)\n    minimizeDigitsum(digitSum, D, countOperations)\n    return\nvisited = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\noperations = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntc = int(input())\nwhile tc:\n    countOperations = -1\n    (N, D) = map(int, input().split())\n    minimizeDigitsum(N, D, countOperations)\n    for i in range(1, 10):\n        if visited[i] == 1:\n            print(i, operations[i])\n            break\n    for i in range(1, 10):\n        visited[i] = 0\n    tc -= 1", "from collections import deque\nT = int(input())\n\ndef break_down(num):\n    count = 0\n    while len(num) != 1:\n        temp = 0\n        for i in range(0, len(num)):\n            temp = temp + int(num[i])\n        num = str(temp)\n        count = count + 1\n    return (int(num), count)\n\ndef digit_sum(num):\n    temp = 0\n    for i in range(0, len(num)):\n        temp = temp + int(num[i])\n    num = temp\n    return num\nwhile T:\n    queue = deque()\n    count_n = 0\n    count_d = 0\n    T = T - 1\n    (N, d) = [i for i in input().split()]\n    (n, count_n) = break_down(N)\n    (D, count_D) = break_down(d)\n    dic = {}\n    if D == 1 or D == 2 or D == 4 or (D == 5) or (D == 7) or (D == 8):\n        mini = 1\n    elif D == 3 or D == 6:\n        mini = min(digit_sum(str(n + 3)), digit_sum(str(n + 6)), digit_sum(str(n + 9)))\n    else:\n        mini = n\n    queue.append((int(N), 0))\n    ele = int(N)\n    count = 0\n    while len(queue) != 0:\n        (ele, count) = queue.popleft()\n        if ele == mini:\n            break\n        elif len(str(ele)) == 1:\n            temp1 = ele + int(d)\n            queue.append((temp1, count + 1))\n        else:\n            temp2 = digit_sum(str(ele))\n            temp1 = ele + int(d)\n            queue.append((temp2, count + 1))\n            queue.append((temp1, count + 1))\n    print(ele, count)", "def ds(n):\n    num_str = str(n)\n    sum = 0\n    for i in range(0, len(num_str)):\n        sum += int(num_str[i])\n    return sum\nt = int(input())\nfor _ in range(t):\n    (n, d) = input().split()\n    n = int(n)\n    d = int(d)\n    s = set()\n    temp = n\n    for i in range(500000):\n        if temp <= 9:\n            if not temp in s:\n                s.add(temp)\n                temp = temp + d\n            else:\n                break\n        else:\n            temp = ds(temp)\n    s = sorted(s)\n    k = s[0]\n    q = []\n    ans = 0\n    q.append((n, 1))\n    while len(q) != 0:\n        num = q[0][0]\n        step = q[0][1]\n        q.pop(0)\n        if num is k:\n            ans = step - 1\n            break\n        q.append((num + d, step + 1))\n        q.append((ds(num), step + 1))\n    print(str(k) + ' ' + str(ans))", "from collections import defaultdict\n\ndef digitSum(n):\n    n = str(n)\n    s = 0\n    for i in range(len(n)):\n        s += int(n[i])\n    return s\n\ndef solve(n, d):\n    queue = [[n, 0]]\n    has = defaultdict(int)\n    i = 0\n    while i < 10000 and len(queue) != 0:\n        t = queue.pop(0)\n        if t[0] < 10:\n            if t[0] not in has:\n                has[t[0]] = t[1]\n        else:\n            queue.append([digitSum(t[0]), t[1] + 1])\n        queue.append([t[0] + d, t[1] + 1])\n        i += 1\n    print(min(has), has[min(has)])\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    solve(n, d)", "def disum(x):\n    x = str(x)\n    sum = 0\n    for i in range(len(x)):\n        sum += int(x[i])\n    return sum\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    ans = {}\n    souma = [(n, 0)]\n    ushijima = 1\n    i = 0\n    while i < 10000:\n        nakiri = souma.pop(0)\n        if nakiri[0] < 10:\n            if nakiri[0] not in ans:\n                ans[nakiri[0]] = nakiri[1]\n        else:\n            souma.append((disum(nakiri[0]), nakiri[1] + 1))\n        souma.append((nakiri[0] + d, nakiri[1] + 1))\n        i += 1\n    print(min(ans), ans[min(ans)])", "def dSum(n):\n    ans = 0\n    while n > 0:\n        ans += n % 10\n        n //= 10\n    return ans\n\ndef solve(n, d, step, ans):\n    if n < 10:\n        ans[n] = min(ans[n], step)\n    left = dSum(n)\n    right = n + d\n    if step > 13:\n        return step\n    solve(left, d, step + 1, ans)\n    solve(right, d, step + 1, ans)\nfor T in range(int(input())):\n    (N, D) = [int(x) for x in input().split()]\n    ans = {}\n    for i in range(10):\n        ans[i] = 100\n    solve(N, D, 0, ans)\n    (x, y) = [100, 100]\n    for (i, j) in ans.items():\n        if j != 100:\n            (x, y) = (i, j)\n            break\n    print(x, y)", "def dSum(n):\n    ans = 0\n    while n > 0:\n        ans += n % 10\n        n //= 10\n    return ans\n\ndef solve(n, d, step, ans):\n    if n < 10:\n        ans[n] = min(ans[n], step)\n    left = dSum(n)\n    right = n + d\n    if step > 13:\n        return step\n    solve(left, d, step + 1, ans)\n    solve(right, d, step + 1, ans)\nfor T in range(int(input())):\n    (N, D) = [int(x) for x in input().split()]\n    ans = {}\n    for i in range(10):\n        ans[i] = 100\n    solve(N, D, 0, ans)\n    (x, y) = [100, 100]\n    for (i, j) in ans.items():\n        if j != 100:\n            x = i\n            y = j\n            break\n    print(x, y)", "t = int(input())\n\ndef digisum(a):\n    a = str(a)\n    x = 0\n    for i in a:\n        x += int(i)\n    return x\nfor _ in range(0, t):\n    x = input()\n    n = int(x.split(' ')[0])\n    d = int(x.split(' ')[1])\n    dict = {n: 0}\n    stop_at = 1\n    curr_items = [n]\n    next_items = []\n    steps = 0\n    while stop_at not in dict and steps < 11:\n        steps += 1\n        for i in curr_items:\n            ds = digisum(i) if i >= 10 else 0\n            ad = i + d\n            if ds != 0 and ds not in dict:\n                next_items.append(ds)\n                dict[ds] = steps\n            if ad not in dict:\n                next_items.append(ad)\n                dict[ad] = steps\n        (curr_items, next_items) = (next_items, [])\n    for i in range(1, 10):\n        if i in dict:\n            stop_at = i\n            steps = dict[i]\n            break\n    print(stop_at, steps)", "def digitSum(digit):\n    result = 0\n    s = str(digit)\n    for x in s:\n        result += int(x)\n    return result\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        l = []\n        (min1, pos) = (100000, -10)\n        (n, d) = input().split(' ')\n        n = int(n)\n        d = int(d)\n        i = 0\n        l.append([n, 0])\n        while i < 10000 and l:\n            tem = l.pop(0)\n            if min1 > tem[0]:\n                min1 = tem[0]\n                pos = tem[1]\n            if tem[0] > 9:\n                l.append([digitSum(tem[0]), tem[1] + 1])\n            l.append([tem[0] + d, tem[1] + 1])\n            i += 1\n        print('{0} {1}'.format(min1, pos))\nmain()", "import queue\n\ndef digitsum(a):\n    lo = 0\n    s = str(a)\n    for i in s:\n        lo += int(i)\n    return lo\nfor _ in range(int(input())):\n    (min1, pos) = (1000000, -10)\n    track = queue.Queue(100000)\n    (n, d) = map(int, input().split())\n    i = 0\n    track.put([n, 0])\n    while i < 100000 and track.empty() != True:\n        (a, b) = track.get()\n        if min1 > a:\n            min1 = a\n            pos = b\n        if a > 9:\n            track.put([digitsum(a), b + 1])\n        track.put([a + d, b + 1])\n        i += 1\n    print(min1, pos)", "def digit_sum(n):\n    d = 0\n    while n:\n        d += n % 10\n        n //= 10\n    return d\nfor _ in range(int(input())):\n    (n, d) = map(int, input().strip().split())\n    q = []\n    ma = {}\n    q.append((n, 0))\n    i = 0\n    while i < 10000 and len(q) != 0:\n        t = q.pop(0)\n        if t[0] < 10:\n            if t[0] in ma:\n                continue\n            else:\n                ma[t[0]] = t[1]\n        else:\n            q.append((digit_sum(t[0]), t[1] + 1))\n        q.append((t[0] + d, t[1] + 1))\n        i += 1\n    k = sorted(list(ma.keys()))\n    print(k[0], ma[k[0]])", "def digitsum(n):\n    s = 0\n    while n:\n        s = s + n % 10\n        n = n // 10\n    return s\nx = int(input())\nfor i in range(x):\n    (a, b) = input().split()\n    (a, b) = [int(a), int(b)]\n    l1 = [(a, 0)]\n    l2 = {}\n    i = 0\n    while i < 10000 and len(l1) != 0:\n        first = l1.pop(0)\n        if first[0] < 10:\n            if first[0] not in l2:\n                l2[first[0]] = first[1]\n        else:\n            l1.append((digitsum(first[0]), first[1] + 1))\n        l1.append((first[0] + b, first[1] + 1))\n        i += 1\n    a = min(l2)\n    print(a, l2[a])", "def digitsum(n):\n    s = 0\n    while n:\n        s = s + n % 10\n        n = n // 10\n    return s\nx = int(input())\nfor i in range(x):\n    (a, b) = input().split()\n    (a, b) = [int(a), int(b)]\n    l1 = [(a, 0)]\n    l2 = {}\n    i = 0\n    while i < 10000 and len(l1) != 0:\n        first = l1.pop(0)\n        if first[0] < 10:\n            if first[0] not in l2:\n                l2[first[0]] = first[1]\n        else:\n            l1.append((digitsum(first[0]), first[1] + 1))\n        l1.append((first[0] + b, first[1] + 1))\n        i += 1\n    a = min(l2)\n    print(a, l2[a])", "def sum_digits(x):\n    return sum(map(int, str(x)))\n\ndef main():\n    for _ in range(int(input())):\n        (n, d) = map(int, input().strip().split())\n        que = [(n, 0)]\n        min_track = dict()\n        i = 0\n        op_count = 0\n        while len(que) != 0 and i <= 10000:\n            i += 1\n            (n, op_count) = que.pop(0)\n            if n == 1:\n                break\n            if n > 1 and n <= 9:\n                if n not in min_track.keys():\n                    min_track[n] = op_count\n                else:\n                    min_track[n] = min(min_track[n], op_count)\n            else:\n                que.append((sum_digits(n), op_count + 1))\n            que.append((n + d, op_count + 1))\n        if n == 1:\n            print(n, op_count)\n        else:\n            min_key = min(min_track.keys())\n            print(min_key, min_track[min_key])\nmain()", "def dsum(n):\n    ddsum = 0\n    while n != 0:\n        a = int(n % 10)\n        ddsum = ddsum + a\n        n = int(n / 10)\n    return ddsum\nfor _ in range(0, int(input())):\n    l = []\n    (a, b) = map(int, input().split())\n    minval = 1000000000\n    val = a\n    cnt = 0\n    inv = 0\n    l.append([])\n    l[inv].append(val)\n    l[inv].append(cnt)\n    if minval > val:\n        minval = val\n        fcnf = cnt\n    for j in range(0, 50000):\n        q = l.pop(0)\n        inv -= 1\n        l.append([])\n        cnt = q[1] + 1\n        inv += 1\n        l[inv].append(q[0] + b)\n        l[inv].append(cnt)\n        if minval > q[0] + b:\n            minval = q[0] + b\n            fcnf = cnt\n        if q[0] > 9:\n            p = dsum(q[0])\n            l.append([])\n            inv += 1\n            l[inv].append(p)\n            l[inv].append(cnt)\n            if minval > p:\n                minval = p\n                fcnf = cnt\n    print(minval, fcnf)", "def ds(x):\n    ss = 0\n    x = str(x)\n    l = len(x)\n    for i in range(l):\n        m = int(x[i])\n        ss += m\n    return int(ss)\nimport queue as q\nt = int(input())\nwhile t:\n    t = t - 1\n    (n, d) = map(int, input().split())\n    a = {n: 0}\n    i = 0\n    arr = q.Queue(maxsize=100000000000000)\n    arr.put((n, 0))\n    while i < 100000:\n        x = arr.get()\n        p1 = ds(x[0])\n        p2 = x[0] + d\n        if p1 < 10 and (not p1 in a):\n            a[p1] = x[1] + 1\n        if p2 < 10 and (not p2 in a):\n            a[p2] = x[1] + 1\n        arr.put((p1, x[1] + 1))\n        arr.put((p2, x[1] + 1))\n        i += 1\n    nn = min(a)\n    print(nn, a[nn])", "def dsum(n):\n    return sum((int(i) for i in str(n)))\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    q = [n]\n    lev = 0\n    res = []\n    vis = {}\n    dist = {}\n    dist[n] = 0\n    lev = 0\n    res.append([n, 0])\n    while q:\n        siz = len(q)\n        lev += 1\n        for i in range(siz):\n            t = q.pop(0)\n            if t + d not in vis:\n                vis[t + d] = 1\n                res.append([t + d, lev])\n                dist[t + d] = dist.get(t) + 1\n                q.append(t + d)\n            if dsum(t) not in vis:\n                vis[dsum(t)] = 1\n                res.append([dsum(t), lev])\n                dist[dsum(t)] = dist.get(t) + 1\n                q.append(dsum(t))\n        if lev == 32:\n            break\n    res.sort(key=lambda x: x[0])\n    print(res[0][0], res[0][1])", "tl = int(input())\n\ndef dsum(n):\n    ddsum = 0\n    while n != 0:\n        a = int(n % 10)\n        ddsum = ddsum + a\n        n = int(n / 10)\n    return ddsum\nwhile tl > 0:\n    (n, d) = map(int, input().split(' '))\n    i = 0\n    dic = dict()\n    l = [(n, 0)]\n    while i < 10000 and len(l) != 0:\n        t = l.pop(0)\n        if t[0] < 10:\n            if t[0] not in dic:\n                dic[t[0]] = t[1]\n            else:\n                continue\n        else:\n            l.append((dsum(t[0]), t[1] + 1))\n        l.append((t[0] + d, t[1] + 1))\n        i += 1\n    a = min(dic)\n    print(a, dic[a])\n    tl = tl - 1", "import math\n\ndef sum_digits(number):\n    return sum((int(digit) for digit in str(number)))\nt = int(input())\nfor _ in range(t):\n    (n, d) = [int(n) for n in input().split()]\n    arr = [n] * 4098\n    arr[0] = n\n    index = 1\n    i = 0\n    while i < 2049:\n        arr[2 * i + 1] = arr[i] + d\n        arr[2 * i + 2] = sum_digits(arr[i])\n        i += 1\n        if i == 2048:\n            break\n    minimum = n\n    for i in range(4098):\n        if arr[i] < minimum:\n            minimum = arr[i]\n            index = i\n    print(minimum, int(math.log(index, 2)))", "def digit_sum(n):\n    s = 0\n    while n > 0:\n        s += n % 10\n        n = n // 10\n    return s\nt = int(input())\nfor tt in range(t):\n    (n, d) = map(int, input().split())\n    dict = {}\n    queue = []\n    seq = 0\n    queue.append((n, seq))\n    dict[n] = 0\n    while len(queue) > 0 and seq < 1000:\n        (n, seq) = queue.pop(0)\n        seq += 1\n        x = digit_sum(n)\n        if not x in dict:\n            dict[x] = seq\n            queue.append((x, seq))\n        queue.append((n + d, seq))\n    ans = min(dict)\n    print(ans, dict[ans])", "import filecmp\nimport operator\nimport os\nimport sys\nfrom collections import deque\n\ndef digitsum(digits):\n    digit_sum = 0\n    while digits > 0:\n        curr = digits % 10\n        digit_sum += curr\n        digits = digits // 10\n    return digit_sum\nFILE_IO = True if os.getenv('FILE_TEST') is not None else False\nif FILE_IO:\n    input_stream = open('input_test.txt')\n    sys.stdout = open('current_output.txt', 'w')\nelse:\n    input_stream = sys.stdin\nT = int(input_stream.readline())\nfor _ in range(T):\n    (N, D) = map(int, input_stream.readline().split())\n    queue = deque()\n    queue.appendleft((N, 0))\n    i = 0\n    memo = {}\n    while len(queue) > 0 and i < 100000:\n        (curr_n, steps) = queue.pop()\n        if curr_n < 10:\n            if memo.get(curr_n, None) is None:\n                memo[curr_n] = steps\n                queue.appendleft((curr_n + D, steps + 1))\n        else:\n            queue.appendleft((curr_n + D, steps + 1))\n            queue.appendleft((digitsum(curr_n), steps + 1))\n        i += 1\n    first_elem = sorted(memo.items(), key=operator.itemgetter(0))\n    print(first_elem[0][0], first_elem[0][1])\nif FILE_IO:\n    assert filecmp.cmp('current_output.txt', 'expected_output.txt', shallow=False) == True", "def ds(n):\n    num_str = str(n)\n    sum = 0\n    for i in range(0, len(num_str)):\n        sum += int(num_str[i])\n    return sum\nt = int(input())\nfor _ in range(t):\n    (n, d) = input().split()\n    n = int(n)\n    d = int(d)\n    s = set()\n    temp = n\n    for i in range(500000):\n        if temp <= 9:\n            if not temp in s:\n                s.add(temp)\n                temp = temp + d\n            else:\n                break\n        else:\n            temp = ds(temp)\n    s = sorted(s)\n    k = s[0]\n    q = []\n    ans = 0\n    q.append((n, 1))\n    while len(q) != 0:\n        num = q[0][0]\n        step = q[0][1]\n        q.pop(0)\n        if num is k:\n            ans = step - 1\n            break\n        q.append((num + d, step + 1))\n        q.append((ds(num), step + 1))\n    print(str(k) + ' ' + str(ans))", "def digit_sum(n):\n    d_sum = 0\n    while n != 0:\n        d_sum += n % 10\n        n = n // 10\n    return d_sum\n\ndef recur(n, m, step_count=0):\n    if n > 100000000000:\n        return\n    if step_count <= 10:\n        recur(n + m, m, step_count + 1)\n        recur(digit_sum(n), m, step_count + 1)\n    d[n] = min(step_count, d.get(n, 10000))\nans = []\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    d = dict()\n    recur(a, b)\n    min_key = min(d.keys())\n    ans.append(min_key)\n    ans.append(d.get(min_key))\nfor i in range(0, len(ans), 2):\n    print(ans[i], ans[i + 1])", "import sys\n\ndef digsum(n):\n    n = sum((int(digit) for digit in str(n)))\n    return n\n\ndef testing(N, D):\n    save = {}\n    q = []\n    q.append((N, 0))\n    i = 0\n    minn = N\n    minop = 0\n    save[N] = 0\n    while i < 10000 and len(q) > 0:\n        (n, op) = q.pop()\n        if n < 10:\n            if n not in save:\n                save[n] = op\n        else:\n            q.insert(0, (digsum(n), op + 1))\n        q.insert(0, (n + D, op + 1))\n        i += 1\n    s = min(save.keys())\n    print(s, save[s])\n\ndef main():\n    t = int(input())\n    I = {}\n    for i in range(t):\n        (N, D) = [int(item) for item in input().split()]\n        I[i] = [N, D]\n    for (k, v) in I.items():\n        (N, D) = v\n        testing(N, D)\n    return 0\nmain()", "def digitsum(n):\n    result = 0\n    while n != 0:\n        result += n % 10\n        n = n // 10\n    return result\n\ndef digits_queue(n, d):\n    q = [n]\n    sd = {}\n    ld = set()\n    for i in range(20):\n        new_q = []\n        for num in q:\n            if num < 10:\n                if num in sd:\n                    continue\n                sd[num] = i\n                if len(sd) == 9:\n                    return sd\n            else:\n                if num in ld:\n                    continue\n                ld.add(num)\n            new_q = new_q + [digitsum(num), num + d]\n        q = new_q\n    return sd\n\ndef mindsum(n, d):\n    num = digits_queue(n, d)\n    n = min(num.keys())\n    return (n, num[n])\nt = int(input())\nfor i in range(t):\n    (n, d) = map(int, input().split())\n    r = mindsum(n, d)\n    print(r[0], r[1])", "def digit_sum(n):\n    d_sum = 0\n    while n != 0:\n        d_sum += n % 10\n        n = n // 10\n    return d_sum\nans = []\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    d = dict()\n    val_arr = [a]\n    d[a] = 0\n    steps_count = 0\n    l_index = 1\n    while steps_count <= 10:\n        for counter in range(steps_count, l_index):\n            val = val_arr[counter]\n            if val > 100000000000:\n                break\n            d_sum = digit_sum(val)\n            d[d_sum] = min(steps_count + 1, d.get(d_sum, 10000))\n            val_arr.append(d_sum)\n            l_index += 1\n            val_b = val + b\n            d[val_b] = min(steps_count + 1, d.get(val_b, 10000))\n            val_arr.append(val_b)\n            l_index += 1\n        steps_count += 1\n    min_key = min(d.keys())\n    ans.append(min_key)\n    ans.append(d.get(min_key))\nfor i in range(0, len(ans), 2):\n    print(ans[i], ans[i + 1])", "def digit_sum(n):\n    d_sum = 0\n    while n != 0:\n        d_sum += n % 10\n        n = n // 10\n    return d_sum\n\ndef recur(n, m, step_count=0):\n    if n > 100000000000:\n        return\n    if step_count <= 10:\n        recur(n + m, m, step_count + 1)\n        recur(digit_sum(n), m, step_count + 1)\n    d[n] = min(step_count, d.get(n, 10000))\nans = []\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    d = dict()\n    recur(a, b)\n    min_key = min(d.keys())\n    ans.append(min_key)\n    ans.append(d.get(min_key))\nfor i in range(0, len(ans), 2):\n    print(ans[i], ans[i + 1])", "t = int(input())\n\ndef digitSum(a):\n    s = str(a)\n    out = a\n    out1 = a\n    count = 0\n    while len(s) > 1:\n        out = 0\n        for i in range(len(s)):\n            out += int(s[i])\n        s = str(out)\n        count += 1\n        if count == 1:\n            out1 = out\n    return [out, out1, count]\nfor x in range(t):\n    (n, d) = input().split()\n    n = int(n)\n    d = int(d)\n    da = digitSum(n)[0]\n    ans = 10\n    for i in range(10):\n        temp1 = digitSum(i * d)[0]\n        temp = digitSum(da + temp1)[0]\n        if temp < ans:\n            ans = temp\n    q = []\n    ans11 = 0\n    q.append((n, 1))\n    while len(q) != 0:\n        num = q[0][0]\n        step = q[0][1]\n        q.pop(0)\n        if num is ans:\n            ans11 = step - 1\n            break\n        q.append((num + d, step + 1))\n        q.append((digitSum(num)[1], step + 1))\n    print(ans, ans11)", "t = int(input())\n\ndef digitSum(a):\n    s = str(a)\n    out = a\n    out1 = a\n    count = 0\n    while len(s) > 1:\n        out = 0\n        for i in range(len(s)):\n            out += int(s[i])\n        s = str(out)\n        count += 1\n        if count == 1:\n            out1 = out\n    return [out, out1]\nfor x in range(t):\n    (n, d) = input().split()\n    n = int(n)\n    d = int(d)\n    da = digitSum(n)[0]\n    ans = 10\n    for i in range(10):\n        temp1 = digitSum(i * d)[0]\n        temp = digitSum(da + temp1)[0]\n        if temp < ans:\n            ans = temp\n    q = []\n    ans11 = 0\n    q.append((n, 1))\n    while len(q) != 0:\n        num = q[0][0]\n        step = q[0][1]\n        q.pop(0)\n        if num is ans:\n            ans11 = step - 1\n            break\n        q.append((num + d, step + 1))\n        q.append((digitSum(num)[1], step + 1))\n    print(ans, ans11)", "t = int(input())\n\ndef digitSum(a):\n    s = str(a)\n    out = a\n    count = 0\n    while len(s) > 1:\n        out = 0\n        for i in range(len(s)):\n            out += int(s[i])\n        s = str(out)\n        count += 1\n    return [out, count]\n\ndef ds(n):\n    num_str = str(n)\n    sum = 0\n    for i in range(0, len(num_str)):\n        sum += int(num_str[i])\n    return sum\nfor x in range(t):\n    (n, d) = input().split()\n    n = int(n)\n    d = int(d)\n    da = digitSum(n)[0]\n    ans = 10\n    for i in range(10):\n        temp1 = digitSum(i * d)[0]\n        temp = digitSum(da + temp1)[0]\n        if temp < ans:\n            ans = temp\n            ind = i\n    tot = n + ind * d\n    c = digitSum(tot)[1]\n    q = []\n    ans11 = 0\n    q.append((n, 1))\n    while len(q) != 0:\n        num = q[0][0]\n        step = q[0][1]\n        q.pop(0)\n        if num is ans:\n            ans11 = step - 1\n            break\n        q.append((num + d, step + 1))\n        q.append((ds(num), step + 1))\n    print(ans, ans11)", "def sumof(n):\n    s = 0\n    while n > 0:\n        r = n % 10\n        s += r\n        n = n // 10\n    return s\n\ndef recu(n, digi_n, c, l, d):\n    if digi_n == l[0] and c < l[1]:\n        l[1] = c\n    if digi_n < l[0]:\n        l[0] = digi_n\n        l[1] = c\n        if l[0] == 1:\n            return l\n    if c == 11:\n        return\n    recu(n + d, sumof(n), c + 1, l, d)\n    recu(digi_n + d, sumof(digi_n), c + 1, l, d)\nn = int(input())\nfor i in range(n):\n    (x, d) = [int(i) for i in input().split()]\n    l = [x, 0]\n    recu(x + d, sumof(l[0]), 1, l, d)\n    print(l[0], l[1])", "def digisum(n):\n    num_str = str(n)\n    sum = 0\n    for i in range(0, len(num_str)):\n        sum += int(num_str[i])\n    return sum\nT = int(input())\nfor abc in range(T):\n    (N, D) = input().split()\n    (N, D) = (int(N), int(D))\n    s = set()\n    tempV = N\n    for i in range(500000):\n        if tempV <= 9:\n            if not tempV in s:\n                s.add(tempV)\n                tempV = tempV + D\n            else:\n                break\n        else:\n            tempV = digisum(tempV)\n    s = sorted(s)\n    mn = s[0]\n    q = []\n    ans = 0\n    q.append((N, 1))\n    while len(q) != 0:\n        num = q[0][0]\n        step = q[0][1]\n        q.pop(0)\n        if num is mn:\n            ans = step - 1\n            break\n        q.append((num + D, step + 1))\n        q.append((digisum(num), step + 1))\n    print(str(mn) + ' ' + str(ans))", "def getsum(n):\n    s = 0\n    while n > 0:\n        d = n % 10\n        s += d\n        n = n // 10\n    return s\n\ndef tsm(n, m, c, a, l):\n    if c <= 12:\n        x = n + m\n        y = getsum(n)\n        a.append([x, c])\n        a.append([y, c])\n        l.append(x)\n        l.append(y)\n        tsm(x, m, c + 1, a, l)\n        tsm(y, m, c + 1, a, l)\n    else:\n        return\nfor _ in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    c = 0\n    a = []\n    h = 0\n    l = []\n    x = tsm(n, m, c, a, l)\n    d = min(l)\n    if d == n:\n        print(d, 0)\n    elif d == getsum(n):\n        print(d, 1)\n    else:\n        p = []\n        for i in range(len(a)):\n            if a[i][0] == d:\n                p.append(a[i][1])\n        print(d, min(p) + 1)", "import math\n\ndef step1(a, b):\n    return a + b\n\ndef step2(a):\n    s = 0\n    while a:\n        s += a % 10\n        a //= 10\n    return s\nfor t in range(int(input())):\n    (n, d) = map(int, input().split())\n    m = 0\n    x = n\n    f = [0] * 10\n    while True:\n        r = x % 9\n        if f[r] == 1:\n            break\n        f[r] = 1\n        x = step1(r, d)\n    for j in range(1, 10):\n        if f[j] == 1:\n            m = j\n            break\n    if m == n:\n        print(n, 0)\n    else:\n        a = [0] * 10000\n        a[1] = n\n        c = 1\n        k = 1\n        while True:\n            x = 2 * k\n            a[x] = step1(a[k], d)\n            a[x + 1] = step2(a[k])\n            c += 2\n            if a[x] == m or a[x + 1] == m:\n                break\n            k += 1\n        i = math.ceil(math.log(c + 1, 2)) - 1\n        print(m, i)", "def digsum(n):\n    s = 0\n    while n > 0:\n        s += n % 10\n        n = n // 10\n    return s\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    l = [[n, 0]]\n    for i in range(10000):\n        k = l.pop(0)\n        l.append([k[0] + d, k[1] + 1])\n        if k[0] >= 10:\n            l.append([digsum(k[0]), k[1] + 1])\n        else:\n            l.append([k[0], k[1]])\n    u = min(l)\n    print(u[0], u[1])", "import math\n\ndef step1(a, b):\n    return a + b\n\ndef step2(a):\n    s = 0\n    while a:\n        s += a % 10\n        a //= 10\n    return s\nfor t in range(int(input())):\n    (n, d) = map(int, input().split())\n    m = 0\n    x = n\n    f = [0] * 10\n    while True:\n        r = x % 9\n        if f[r] == 1:\n            break\n        f[r] = 1\n        x = step1(r, d)\n    for j in range(1, 10):\n        if f[j] == 1:\n            m = j\n            break\n    if m == n:\n        print(n, 0)\n    else:\n        a = [0] * 10000\n        a[1] = n\n        c = 1\n        k = 1\n        while True:\n            x = 2 * k\n            a[x] = step1(a[k], d)\n            a[x + 1] = step2(a[k])\n            c += 2\n            if a[x] == m or a[x + 1] == m:\n                break\n            k += 1\n        i = math.ceil(math.log(c + 1, 2)) - 1\n        print(m, i)", "import sys\nsys.setrecursionlimit(1000000000)\n\ndef digitsum(n):\n    summer = 0\n    while n != 0:\n        summer = summer + n % 10\n        n = n // 10\n    return summer\n\ndef everyonesfaveloli(a, b, st):\n    if st > 100:\n        return\n    try:\n        drx = ar[a]\n        if ar[a] < st:\n            return\n    except:\n        t = 0\n    ar[a] = st\n    if a < 10 and ans[a] < st:\n        return\n    elif a < 10:\n        ans[a] = st\n    if a > n + d * 10:\n        return\n    x = digitsum(a)\n    y = a + b\n    if x == a:\n        everyonesfaveloli(y, b, st + 1)\n    elif y > n + d * 10:\n        everyonesfaveloli(x, b, st + 1)\n    else:\n        everyonesfaveloli(y, b, st + 1)\n        everyonesfaveloli(x, b, st + 1)\nfor imh in range(int(input())):\n    (n, d) = list(map(int, input().split()))\n    l = [-1] * 10\n    jk = n + 10 * d\n    x = n\n    y = n\n    if n < 10:\n        l[n] = 0\n    if n == 1:\n        print(1, 0)\n    else:\n        ar = {}\n        ans = {0: 1000, 1: 1000, 2: 1000, 3: 1000, 4: 1000, 5: 1000, 6: 1000, 7: 1000, 8: 1000, 9: 1000, 10: 1000}\n        everyonesfaveloli(n, d, 0)\n        for key in ans.keys():\n            if ans[key] != 1000:\n                print(key, ans[key])\n                break", "def digitsum(n):\n    result = 0\n    while n != 0:\n        result += n % 10\n        n = n // 10\n    return result\n\ndef full_ds(n, r):\n    while n > 9:\n        n = digitsum(n)\n        r += 1\n    return (n, r)\n\ndef digits(n, d):\n    num = {}\n    r = 0\n    while True:\n        (n1, r1) = full_ds(n, r)\n        if n1 in num:\n            if num[n1] < r1:\n                break\n            num[n1] = r1\n        else:\n            num[n1] = r1\n        n += d\n        r += 1\n    return num\n\ndef digits_queue(n, d):\n    q = [n]\n    sd = {}\n    ld = set()\n    for i in range(20):\n        new_q = []\n        for num in q:\n            if num < 10:\n                if num in sd:\n                    continue\n                sd[num] = i\n                if len(sd) == 9:\n                    return sd\n            else:\n                if num in ld:\n                    continue\n                ld.add(num)\n            new_q = new_q + [digitsum(num), num + d]\n        q = new_q\n    return sd\n\ndef mindsum(n, d):\n    num = digits_queue(n, d)\n    n = min(num.keys())\n    return (n, num[n])\nt = int(input())\nfor i in range(t):\n    (n, d) = map(int, input().split())\n    r = mindsum(n, d)\n    print(r[0], r[1])", "def ds(n):\n    num_str = str(n)\n    sum = 0\n    for i in range(0, len(num_str)):\n        sum += int(num_str[i])\n    return sum\nt = int(input())\nfor _ in range(t):\n    (n, d) = input().split()\n    n = int(n)\n    d = int(d)\n    s = set()\n    temp = n\n    for i in range(500000):\n        if temp <= 9:\n            if not temp in s:\n                s.add(temp)\n                temp = temp + d\n            else:\n                break\n        else:\n            temp = ds(temp)\n    s = sorted(s)\n    k = s[0]\n    q = []\n    ans = 0\n    q.append((n, 1))\n    while len(q) != 0:\n        num = q[0][0]\n        step = q[0][1]\n        q.pop(0)\n        if num is k:\n            ans = step - 1\n            break\n        q.append((num + d, step + 1))\n        q.append((ds(num), step + 1))\n    print(str(k) + ' ' + str(ans))", "def ds(n):\n    num_str = str(n)\n    sum = 0\n    for i in range(0, len(num_str)):\n        sum += int(num_str[i])\n    return sum\nt = int(input())\nfor _ in range(t):\n    (n, d) = input().split()\n    n = int(n)\n    d = int(d)\n    s = set()\n    temp = n\n    for i in range(500000):\n        if temp <= 9:\n            if not temp in s:\n                s.add(temp)\n                temp = temp + d\n            else:\n                break\n        else:\n            temp = ds(temp)\n    s = sorted(s)\n    mn = s[0]\n    q = []\n    ans = 0\n    q.append((n, 1))\n    while len(q) != 0:\n        num = q[0][0]\n        step = q[0][1]\n        q.pop(0)\n        if num is mn:\n            ans = step - 1\n            break\n        q.append((num + d, step + 1))\n        q.append((ds(num), step + 1))\n    print(str(mn) + ' ' + str(ans))", "T = int(input())\n\ndef sum_digits(n):\n    r = 0\n    while n:\n        (r, n) = (r + n % 10, n // 10)\n    return r\n\ndef step_Dsum(n, val):\n    if n < 10:\n        return val\n    val = val + 1\n    val = step_Dsum(sum_digits(n), val)\n    return val\n\ndef sum_Digit(n):\n    if n % 9 != 0:\n        return n % 9\n    else:\n        return 9\n\ndef find_Min(n, d):\n    iter = 0\n    dig_min = 10\n    val = n\n    for i in range(9):\n        if dig_min > sum_Digit(val):\n            dig_min = min(dig_min, sum_Digit(val))\n            iter = i\n        val = val + d\n    return (dig_min, iter)\nwhile T:\n    (n, d) = map(int, input().split(' '))\n    (dig_min, iter) = find_Min(n, d)\n    steps = step_Dsum(n + d * iter, 0)\n    for i in range(iter):\n        test = n + i * d\n        k = 0\n        while test > 9:\n            k = k + 1\n            test = sum_digits(test)\n            times_sum = (iter - i) * d\n            new_sum = test + times_sum\n            steps = min(steps, k + step_Dsum(new_sum, 0))\n    print(dig_min, iter + steps)\n    T = T - 1", "import sys\nsys.setrecursionlimit(1000000000)\n\ndef summ(n):\n    c = 0\n    while n >= 10:\n        c += 1\n        n = digsum(n)\n    return (c, n)\n\ndef digsum(n):\n    s = 0\n    while n != 0:\n        s = s + n % 10\n        n = n // 10\n    return s\n\ndef answer(n, sp):\n    print(l, n, sp)\n    if n < 10 and l[n] <= sp and (l[n] != -1):\n        return\n    x = digsum(n)\n    y = n + d\n    f = 0\n    if x >= 10 and x != n:\n        answer(x, sp + 1)\n    if x < 10 and x != n:\n        if l[x] == -1:\n            l[x] = sp + 1\n        elif l[x] > sp:\n            l[x] = sp + 1\n        else:\n            f = 1\n            return\n    if y >= 10:\n        answer(y, sp + 1)\n    if y < 10:\n        if l[y] == -1:\n            l[y] = sp + 1\n            answer(y, sp + 1)\n        elif l[y] > sp:\n            l[y] = sp + 1\n\ndef reanswer(n, sp):\n    print(l, n, sp)\n    if n < 10 and l[n] <= sp:\n        return\n    x = digsum(n)\n    y = n + d\n    if x < 10:\n        if l[x] == -1 or l[x] > sp:\n            if n != x:\n                l[x] = sp + 1\n            if x != -1:\n                reanswer(x, sp + 1)\n        else:\n            return\n    if x >= 10:\n        reanswer(x, sp + 1)\n    print('HHH')\n    if y < 10:\n        if l[y] == -1 or l[y] > sp:\n            l[y] = sp + 1\n            reanswer(y, sp + 1)\n        else:\n            return\n    if y >= 10:\n        reanswer(y, sp + 1)\n\ndef ans(n, sp):\n    if n < 10 and l[n] < sp and (l[n] > 0):\n        return\n    x = digsum(n)\n    y = n + d\n    print(l, n, sp, x, y)\n    if x < 10:\n        if l[x] < 0 or l[x] > sp:\n            if x == n:\n                l[x] = sp\n            else:\n                l[x] = sp + 1\n    if x >= 10:\n        ans(x, sp + 1)\n    if y < 10:\n        if l[y] == -1 or l[y] > sp:\n            l[y] = sp + 1\n            ans(y, sp + 1)\n        else:\n            return\n    if y >= 10 and y <= jk:\n        ans(y, sp + 1)\n\ndef lol(n, sp):\n    x = digsum(n)\n    y = n + d\n    print(l, n, sp, x, y, dic)\n    f1 = 0\n    f2 = 0\n    try:\n        my = dic[x]\n        if my < sp:\n            f1 = 1\n    except:\n        dic[x] = sp\n    try:\n        my = dic[y]\n        if my < sp:\n            f2 = 1\n    except:\n        dic[y] = sp\n    if f1 == 0:\n        if x < 10:\n            if (l[x] == -1 or l[x] > sp) and x != n:\n                l[x] = sp + 1\n                lol(x, sp + 1)\n        if x >= 10:\n            lol(x, sp + 1)\n    if f2 == 0:\n        if y < 10:\n            if l[y] == -1 or l[y] > sp:\n                l[y] = sp + 1\n                lol(y, sp + 1)\n        if y >= 10:\n            lol(y, sp + 1)\n\ndef lol2(a, b, sp):\n    if a > n + 10 * d:\n        return\n    if a < 10 and (dans[a] == 1000 or dans[a] < sp):\n        dans[a] = sp\n        return lol2(a + b, b, sp + 1)\n    if a >= 10:\n        return lol2(a + b, b, sp + 1)\n        return lol2(digsum(a), b, sp + 1)\n\ndef l3(a, b, sp):\n    if sp > 100:\n        return\n    try:\n        drx = ar[a]\n        if ar[a] < sp:\n            return\n    except:\n        ty = 10\n    ar[a] = sp\n    if a < 10 and dans[a] < sp:\n        return\n    elif a < 10:\n        dans[a] = sp\n    if a > n + d * 10:\n        return\n    x = digsum(a)\n    y = a + b\n    if x == a:\n        l3(y, b, sp + 1)\n    elif y > n + d * 10:\n        l3(x, b, sp + 1)\n    else:\n        l3(y, b, sp + 1)\n        l3(x, b, sp + 1)\nfor imh in range(int(input())):\n    dic = {}\n    (n, d) = list(map(int, input().split()))\n    l = [-1] * 10\n    jk = n + 10 * d\n    x = n\n    y = n\n    if n < 10:\n        l[n] = 0\n    if n == 1:\n        print(1, 0)\n    else:\n        ar = {}\n        dans = {0: 1000, 1: 1000, 2: 1000, 3: 1000, 4: 1000, 5: 1000, 6: 1000, 7: 1000, 8: 1000, 9: 1000, 10: 1000}\n        l3(n, d, 0)\n        for k in dans.keys():\n            if dans[k] != 1000:\n                print(k, dans[k])\n                break", "import math\nfrom math import ceil\n\ndef Sum(x):\n    X = str(x)\n    summ = 0\n    for _ in X:\n        summ += int(_)\n    return summ\nfor i in range(int(input())):\n    (n, d) = map(int, input().split())\n    ans = 0\n    temp = n\n    f = [0] * 10\n    while True:\n        rem = temp % 9\n        if f[rem] == 1:\n            break\n        f[rem] = 1\n        temp = rem + d\n    for j in range(1, 10):\n        if f[j] == 1:\n            ans = j\n            break\n    if n == ans:\n        print(n, 0)\n    else:\n        arr = [0] * 10000\n        arr[0] = 0\n        arr[1] = n\n        k = 1\n        c = 1\n        b = 1\n        while b == 1:\n            temp = 2 * k\n            arr[temp] = arr[k] + d\n            arr[temp + 1] = Sum(arr[k])\n            c += 2\n            if arr[temp] == ans or arr[temp + 1] == ans:\n                b = 0\n            k += 1\n        coun = int(ceil(math.log(c + 1, 2)) - 1)\n        print(ans, coun)", "def sum1(n):\n    total = 0\n    while n > 0:\n        digit = n % 10\n        total = total + digit\n        n = n // 10\n    return total\na = int(input())\nfor i in range(a):\n    b = [int(i) for i in input().split()]\n    c = []\n    d = []\n    g = []\n    g = [0] * 11\n    for i in range(11):\n        c.append(b[0] + i * b[1])\n    for i in range(11):\n        d.append(i)\n    for i in range(len(c)):\n        l = 0\n        k = c[i]\n        r = 0\n        while k // 10 != 0:\n            k = sum1(k)\n            l = l + 1\n        d[i] = d[i] + l\n        g[i] = k\n    t = g.index(min(g))\n    outf2 = min(g)\n    c = []\n    d = []\n    for i in range(50):\n        c.append(b[0] + i * b[1])\n    for i in range(50):\n        d.append(i)\n    for i in range(len(c)):\n        l = 0\n        k = c[i]\n        r = 0\n        while k != outf2:\n            k = sum1(k)\n            l = l + 1\n            if k // 10 == 0 and k != outf2:\n                r = 1\n                break\n        if r == 0:\n            d[i] = d[i] + l\n        else:\n            d[i] = 1000\n    outl = []\n    for i in range(len(c)):\n        t = i\n        r1 = []\n        f = []\n        for c1 in range(50):\n            r1.append(t + c1 + 1)\n        ct = sum1(c[i])\n        for i1 in range(50):\n            f.append(ct + i1 * b[1])\n        for i2 in range(len(f)):\n            l = 0\n            k = f[i2]\n            r = 0\n            while k != outf2:\n                k = sum1(k)\n                l = l + 1\n                if k // 10 == 0 and k != outf2:\n                    r = 1\n                    break\n            if r == 0:\n                r1[i2] = r1[i2] + l\n            else:\n                r1[i2] = 1000\n        outl.append(min(r1))\n    print(outf2, end=' ')\n    print(min(min(outl), min(d)), end=' ')\n    print()", "import math\n\ndef Two(n):\n    if n == 0:\n        return 0\n    while n != 1:\n        if n % 2 != 0:\n            return 1\n        n = n // 2\n    return 1\n\ndef sum1(n):\n    total = 0\n    while n > 0:\n        digit = n % 10\n        total = total + digit\n        n = n // 10\n    return total\na = int(input())\nfor i in range(a):\n    b = [int(i) for i in input().split()]\n    c = []\n    d = []\n    g = []\n    g = [0] * 11\n    for i in range(11):\n        c.append(b[0] + i * b[1])\n    for i in range(11):\n        d.append(i)\n    for i in range(len(c)):\n        l = 0\n        k = c[i]\n        r = 0\n        while k // 10 != 0:\n            k = sum1(k)\n            l = l + 1\n        d[i] = d[i] + l\n        g[i] = k\n    t = g.index(min(g))\n    outf2 = min(g)\n    e = d[t]\n    f = [0] * (2 ** (e + 1) - 1)\n    f[0] = b[0]\n    for i in range(len(f) - 2 ** e):\n        f[2 * i + 1] = f[i] + b[1]\n        f[2 * i + 2] = sum1(f[i])\n    for out1 in range(len(f)):\n        if f[out1] == outf2:\n            break\n    if Two(out1 + 1):\n        outf = math.log(out1 + 1, 2)\n    else:\n        outf = math.log(out1, 2)\n    print(outf2, end=' ')\n    print(math.floor(outf))", "def helper(n, d, k):\n    if k == 0:\n        if n < 10:\n            return 0\n        else:\n            return 1 + helper(sum(list(map(int, list(str(n))))), d, 0)\n    elif n < 10:\n        return 1 + helper(n + d, d, k - 1)\n    else:\n        return 1 + min(helper(sum(list(map(int, list(str(n))))), d, k), helper(n + d, d, k - 1))\nfor _ in range(int(input())):\n    (a, b) = list(map(int, input().split()))\n    rem = [(a + i * b) % 9 for i in range(9)]\n    lis = sorted(list(set(rem)))\n    if lis[0] == 0:\n        if len(lis) == 1:\n            mini = 0\n            ans = 9\n        else:\n            mini = rem.index(lis[1])\n            ans = lis[1]\n    else:\n        mini = rem.index(lis[0])\n        ans = lis[0]\n    print(ans, helper(a, b, mini))", "def digitsum(n2):\n    rr = 0\n    while n2 >= 10:\n        x = 0\n        while n2 != 0:\n            x = x + n2 % 10\n            n2 = n2 // 10\n        rr = rr + 1\n        if x <= 9:\n            break\n        n2 = x\n    return rr\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    (n, d) = map(int, input().split(' '))\n    a = n % 9\n    b = d % 9\n    if a == 0:\n        a = 9\n    if b == 0:\n        b = 9\n    m = a\n    i = 1\n    r = 0\n    while i < 10:\n        a = a + b\n        a = a % 9\n        if a == 0:\n            a = 9\n        if a < m:\n            r = i\n            m = a\n        i = i + 1\n    n1 = n + r * d\n    r1 = digitsum(n1)\n    r2 = r1\n    n1 = n + (r + 1) * d\n    a1 = n1 % 9\n    if a1 == 0:\n        a1 = 9\n    if a1 == m:\n        r2 = 1 + digitsum(n1)\n    r1 = min(r1, r2)\n    if r1 == 3:\n        i = r\n        n11 = n + i * d\n        while i >= 0:\n            n1 = n + i * d\n            n10 = n1\n            x = 0\n            while n10 != 0:\n                x = x + n10 % 10\n                n10 = n10 // 10\n            n1 = n11 - n1 + x\n            if digitsum(n1) == 1:\n                r1 = 2\n                break\n            i = i - 1\n    r = r + r1\n    print(m, r)", "from queue import Queue\n\ndef digit(x):\n    sum1 = 0\n    for i in str(x):\n        sum1 += int(i)\n    return sum1\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    q = Queue()\n    d1 = {}\n\n    def digitsum(x, dict1={}):\n        q.put(x)\n        q.put(0)\n        val = 0\n        while not q.empty():\n            t = q.get()\n            if t == 0 and q.empty():\n                break\n            elif t == 0:\n                q.put(0)\n                val += 1\n            else:\n                t1 = digit(t)\n                t2 = t + d\n                if t1 not in dict1 and t2 not in dict1:\n                    q.put(t1)\n                    q.put(t2)\n                if t not in dict1:\n                    dict1[t] = val\n        dict1 = dict(sorted(dict1.items()))\n        for i in dict1.keys():\n            p = i\n            break\n        for j in dict1.values():\n            y = j\n            break\n        return str(i) + ' ' + str(y)\n    print(digitsum(n, d1))", "def digit_sum(n, counter):\n    n = str(n)\n    ans = n\n    while len(n) != 1:\n        ans = 0\n        for i in n:\n            ans += int(i)\n        n = str(ans)\n        counter += 1\n    return (int(ans), counter)\n\ndef summ(n):\n    n = str(n)\n    ans = 0\n    for i in n:\n        ans += int(i)\n    return ans\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    arr = [0] * 20\n    arr[0] = n\n    for i in range(1, 20):\n        arr[i] += arr[i - 1] + d\n    brr = [summ(i) + d for i in arr]\n    crr = [summ(i) + d * 2 for i in arr]\n    drr = [summ(i) + d * 3 for i in arr]\n    err = [summ(i) + d * 4 for i in arr]\n    frr = [summ(i) + d * 5 for i in arr]\n    dic = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    dic2 = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    dic3 = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    dic4 = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    dic5 = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    dic6 = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    for i in range(len(arr)):\n        (ans, counter) = digit_sum(arr[i], i)\n        dic[ans] = min(dic[ans], counter)\n    for i in range(len(brr)):\n        (ans, counter) = digit_sum(brr[i], i + 2)\n        dic2[ans] = min(dic2[ans], counter)\n    for i in range(len(crr)):\n        (ans, counter) = digit_sum(crr[i], i + 2 + 1)\n        dic3[ans] = min(dic3[ans], counter)\n    for i in range(len(drr)):\n        (ans, counter) = digit_sum(drr[i], i + 2 + 2)\n        dic4[ans] = min(dic4[ans], counter)\n    for i in range(len(err)):\n        (ans, counter) = digit_sum(err[i], i + 2 + 3)\n        dic5[ans] = min(dic5[ans], counter)\n    for i in range(len(frr)):\n        (ans, counter) = digit_sum(frr[i], i + 2 + 4)\n        dic6[ans] = min(dic6[ans], counter)\n    b = list(dic.items())\n    b.sort()\n    b2 = list(dic2.items())\n    b2.sort()\n    b3 = list(dic3.items())\n    b3.sort()\n    b4 = list(dic4.items())\n    b4.sort()\n    b5 = list(dic5.items())\n    b5.sort()\n    b6 = list(dic6.items())\n    b6.sort()\n    for i in range(len(b)):\n        if b[i][1] != 999 and b2[i][1] != 999 and (b3[i][1] != 999):\n            print(b[i][0], min([b[i][1], b2[i][1], b3[i][1], b4[i][1], b5[i][1], b6[i][1]]))\n            break", "def digit_sum(n, counter):\n    n = str(n)\n    ans = n\n    while len(n) != 1:\n        ans = 0\n        for i in n:\n            ans += int(i)\n        n = str(ans)\n        counter += 1\n    return (int(ans), counter)\n\ndef summ(n):\n    n = str(n)\n    ans = 0\n    for i in n:\n        ans += int(i)\n    return ans\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    arr = [0] * 20\n    arr[0] = n\n    for i in range(1, 20):\n        arr[i] += arr[i - 1] + d\n    brr = [summ(i) + d for i in arr]\n    crr = [summ(i) + d * 2 for i in arr]\n    drr = [summ(i) + d * 3 for i in arr]\n    err = [summ(i) + d * 4 for i in arr]\n    frr = [summ(i) + d * 5 for i in arr]\n    grr = [summ(i) + d * 6 for i in arr]\n    dic = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    dic2 = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    dic3 = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    dic4 = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    dic5 = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    dic6 = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    dic7 = {1: 999, 2: 999, 3: 999, 4: 999, 5: 999, 6: 999, 7: 999, 8: 999, 9: 999}\n    for i in range(len(arr)):\n        (ans, counter) = digit_sum(arr[i], i)\n        dic[ans] = min(dic[ans], counter)\n    for i in range(len(brr)):\n        (ans, counter) = digit_sum(brr[i], i + 2)\n        dic2[ans] = min(dic2[ans], counter)\n    for i in range(len(crr)):\n        (ans, counter) = digit_sum(crr[i], i + 2 + 1)\n        dic3[ans] = min(dic3[ans], counter)\n    for i in range(len(drr)):\n        (ans, counter) = digit_sum(drr[i], i + 2 + 2)\n        dic4[ans] = min(dic4[ans], counter)\n    for i in range(len(err)):\n        (ans, counter) = digit_sum(err[i], i + 2 + 3)\n        dic5[ans] = min(dic5[ans], counter)\n    for i in range(len(frr)):\n        (ans, counter) = digit_sum(frr[i], i + 2 + 4)\n        dic6[ans] = min(dic6[ans], counter)\n    for i in range(len(grr)):\n        (ans, counter) = digit_sum(grr[i], i + 2 + 5)\n        dic7[ans] = min(dic7[ans], counter)\n    b = list(dic.items())\n    b.sort()\n    b2 = list(dic2.items())\n    b2.sort()\n    b3 = list(dic3.items())\n    b3.sort()\n    b4 = list(dic4.items())\n    b4.sort()\n    b5 = list(dic5.items())\n    b5.sort()\n    b6 = list(dic6.items())\n    b6.sort()\n    b7 = list(dic7.items())\n    b7.sort()\n    for i in range(len(b)):\n        if b[i][1] != 999 and b2[i][1] != 999 and (b3[i][1] != 999):\n            print(b[i][0], min([b[i][1], b2[i][1], b3[i][1], b4[i][1], b5[i][1], b6[i][1], b7[i][1]]))\n            break", "def calc_digit_sum(N):\n    if N <= 9:\n        return N\n    else:\n        return sum(list((int(digit) for digit in str(N))))\n\ndef digit_sum(N):\n    if N <= 9:\n        return N\n    else:\n        return digit_sum(calc_digit_sum(N))\n\ndef compute_num_of_steps(N):\n    if N <= 9:\n        return 0\n    else:\n        return 1 + compute_num_of_steps(calc_digit_sum(N))\n\ndef minimize_digitsum(N, D, curr_num_of_steps, upper_bound, min_N, global_min_num_of_steps):\n    if curr_num_of_steps >= upper_bound:\n        return\n    elif N <= 9:\n        if N == min_N:\n            global_min_num_of_steps[0] = curr_num_of_steps\n        else:\n            minimize_digitsum(N + D, D, curr_num_of_steps + 1, upper_bound, min_N, global_min_num_of_steps)\n    else:\n        minimize_digitsum(N + D, D, curr_num_of_steps + 1, upper_bound, min_N, global_min_num_of_steps)\n        minimize_digitsum(calc_digit_sum(N), D, curr_num_of_steps + 1, upper_bound, min_N, global_min_num_of_steps)\nT = int(input())\nwhile T:\n    (N, D) = list(map(int, input().split()))\n    rec_digit_sum_N = digit_sum(N)\n    rec_digit_sum_D = digit_sum(D)\n    prev = rec_digit_sum_N\n    min_N = rec_digit_sum_N\n    min_num_of_increment_operations = 0\n    for i in range(1, 9):\n        curr = digit_sum(prev + rec_digit_sum_D)\n        if curr < min_N:\n            min_N = curr\n            min_num_of_increment_operations = i\n        prev = curr\n    min_num_of_steps = min_num_of_increment_operations + compute_num_of_steps(N + min_num_of_increment_operations * D)\n    curr_num_of_steps = 0\n    upper_bound = min_num_of_steps\n    global_min_num_of_steps = [min_num_of_steps]\n    minimize_digitsum(N, D, curr_num_of_steps, upper_bound, min_N, global_min_num_of_steps)\n    print(str(min_N) + ' ' + str(global_min_num_of_steps[0]))\n    T -= 1", "from functools import reduce as rd\nimport operator as optr\nimport math\nimport itertools\ninp = lambda : map(int, input().split())\n\ndef digitsum(n):\n    val = 0\n    while n > 0:\n        val += n % 10\n        n //= 10\n    return val\nfor __ in range(int(input())):\n    (n, d) = inp()\n    visit = {}\n    ans = {}\n    visit[str(n)] = 1\n    queue = []\n    ans[str(n)] = 0\n    queue.append(n)\n    iteration = 0\n    result = 99999999999\n    while queue:\n        iteration += 1\n        front = queue.pop(0)\n        result = min(result, front)\n        if iteration > 1000:\n            break\n        first = front + d\n        second = digitsum(front)\n        check1 = str(first) in visit\n        check2 = str(second) in visit\n        if check1 == False:\n            visit[str(first)] = 1\n            ans[str(first)] = ans[str(front)] + 1\n            queue.append(first)\n        if check2 == False:\n            visit[str(second)] = 1\n            ans[str(second)] = ans[str(front)] + 1\n            queue.append(second)\n    print(result, ans[str(result)])", "import math\n\ndef getSum(a):\n    sum = 0\n    while a != 0:\n        sum = sum + a % 10\n        a = a // 10\n    return sum\nfor _ in range(int(input())):\n    (n, d) = map(int, input().split())\n    l = []\n    l2 = []\n    l.append(n)\n    for i in range(3000):\n        l.insert(2 * i + 1, getSum(l[i]))\n        l.insert(2 * i + 2, l[i] + d)\n    b = min(l)\n    c = l.index(b)\n    c = c + 1\n    if n == 0 or d == 0:\n        e = 0\n    else:\n        e = math.log(c, 2)\n    print('%d %d' % (b, e))", "def digitsum(num):\n    s = 0\n    while num > 0:\n        s += num % 10\n        num = num // 10\n    return s\n\ndef find_min(mov, n, d, i, min_ops):\n    if n < mov:\n        mov = n\n        min_ops = 0\n    if n == 1 or i >= 13:\n        return (0, mov)\n    (ops1, mov1) = find_min(mov, n + d, d, i + 1, min_ops)\n    ops1 += 1\n    if digitsum(n) != n:\n        (ops2, mov2) = find_min(mov, digitsum(n), d, i + 1, min_ops)\n        ops2 += 1\n        if n == min(mov1, mov2):\n            return (min_ops, mov)\n        if mov1 < mov2:\n            return (ops1, mov1)\n        elif mov1 == mov2:\n            return (min(ops1, ops2), mov1)\n        else:\n            return (ops2, mov2)\n    else:\n        if n == mov1:\n            return (min_ops, mov)\n        return (ops1, mov1)\nt = int(input())\nfor _ in range(t):\n    (n, d) = map(int, input().split())\n    (mini, min_ob_val) = find_min(n, n, d, 0, 15)\n    if mini >= 13:\n        mini = 0\n    print(min_ob_val, mini)", "T = int(input())\n\ndef digitsum(N):\n    string = str(N)\n    string = list(string)\n    string = [int(i) for i in string]\n    return sum(string)\nfor i in range(T):\n    (N, D) = map(int, input().split())\n    result = dict()\n    count = 0\n    result[count] = [N]\n    results = [N]\n    for j in range(1, 12):\n        for k in result[j - 1]:\n            if j not in result:\n                result[j] = []\n            result[j].append(digitsum(k))\n            result[j].append(k + D)\n            results.append(digitsum(k))\n            results.append(k + D)\n    value = min(results)\n    for i in range(12):\n        if value in result[i]:\n            print(value, i)\n            break", "import math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom collections import deque\n\ndef digitsum(val):\n    res = 0\n    while val > 0:\n        res += val % 10\n        val //= 10\n    return res\n\ndef stepToTarget(n, d, target):\n    q = deque([(n, 0)])\n    visited = {n}\n    maxStep = 1000\n    while q:\n        (v, s) = q.popleft()\n        if v == target:\n            return s\n        for u in [v + d, digitsum(v)]:\n            if u not in visited:\n                visited.add(u)\n                q.append((u, s + 1))\n        if s > maxStep:\n            return -1\n    return -1\n\ndef solve(n, d):\n    for target in range(10):\n        step = stepToTarget(n, d, target)\n        if step >= 0:\n            return ' '.join(map(str, [target, step]))\nT = int(input())\nfor ti in range(T):\n    (N, D) = map(int, input().split())\n    print(solve(N, D))", "def digitSum(entier):\n    return sum([int(i) for i in str(entier)])\n\ndef CountToLesser(entier):\n    count = 0\n    while entier > 9:\n        entier = digitSum(entier)\n        count += 1\n    return count\n\ndef toLesser(entier):\n    l = entier % 9\n    return l if l > 0 or entier == 0 else 9\n\ndef findMin(n, d):\n    a = []\n    for i in range(9):\n        a.append((toLesser(n + i * d), i))\n    return min(a)\n\ndef CountToLesser(N, D, i, res):\n    poss = [(N, 0, 0)]\n    index = 0\n    while True:\n        (n, k, c) = poss[index]\n        if n == res:\n            return c\n        if k < i:\n            poss.append((n + D, k + 1, c + 1))\n        poss.append((digitSum(n), k, c + 1))\n        index += 1\nT = int(input())\nfor i in range(T):\n    (N, D) = [int(i) for i in input().split()]\n    n = toLesser(N)\n    d = toLesser(D)\n    (res, i) = findMin(n, d)\n    total = N + i * D\n    count = CountToLesser(N, D, i, res)\n    print(res, count)", "import math\nfrom math import ceil\n\ndef Sum(t):\n    sum = 0\n    while t > 0:\n        sum += t % 10\n        t = int(t / 10)\n    return sum\nt = int(input())\nfor i in range(t):\n    (n, d) = map(int, input().split())\n    ans = 0\n    temp = n\n    f = [0] * 10\n    while True:\n        rem = temp % 9\n        if f[rem] == 1:\n            break\n        f[rem] = 1\n        temp = rem + d\n    for j in range(1, 10):\n        if f[j] == 1:\n            ans = j\n            break\n    if n == ans:\n        print(n, 0)\n    else:\n        arr = [0] * 10000\n        arr[0] = 0\n        arr[1] = n\n        k = 1\n        c = 1\n        b = 1\n        while b == 1:\n            temp = 2 * k\n            arr[temp] = arr[k] + d\n            arr[temp + 1] = Sum(arr[k])\n            c += 2\n            if arr[temp] == ans or arr[temp + 1] == ans:\n                b = 0\n            k += 1\n        step = int(ceil(math.log(c + 1, 2)) - 1)\n        print(ans, step)", "def digitsum(N):\n    _sum = 0\n    while N:\n        _sum += N % 10\n        N //= 10\n    return _sum\nfor _ in range(int(input())):\n    (N, D) = map(int, input().split())\n    if not D % 9:\n        goal = N % 9\n        if not goal:\n            goal = 9\n    elif not D % 3:\n        goal = N % 3\n        if not goal:\n            goal = 3\n    else:\n        goal = 1\n    values = {N}\n    steps = 0\n    while goal not in values:\n        prev_values = values\n        values = set()\n        for x in prev_values:\n            values.add(x + D)\n            values.add(digitsum(x))\n        steps += 1\n    print(goal, steps)", "import math\n\ndef su(x):\n    x = str(x)\n    x = list(x)\n    x = list(map(int, x))\n    m = sum(x)\n    return m\nt = int(input())\nfor _ in range(t):\n    l = [int(x) for x in input().split()]\n    a = []\n    a.append(l[0])\n    for i in range(100000):\n        a.append(su(a[i]))\n        a.append(l[1] + a[i])\n    d = min(a)\n    f = a.index(d)\n    qw = math.floor(math.log2(f + 1))\n    print(d, qw)", "def dgs(num):\n    ans = 0\n    while num > 0:\n        ans = ans + num % 10\n        num = num // 10\n    return ans\n\ndef time(n, d, val):\n    present = []\n    q = []\n    number = (n, 0)\n    q.append(number)\n    while q:\n        t = q.pop(0)\n        if t[0] == val:\n            return t[1]\n        present.append(t[0])\n        if t[0] + d == val or dgs(t[0]) == val:\n            return t[1] + 1\n        if t[0] + d not in present:\n            number = (t[0] + d, t[1] + 1)\n            q.append(number)\n        if dgs(t[0]) not in present:\n            number = (dgs(t[0]), t[1] + 1)\n            q.append(number)\n    return 0\nfor _ in range(int(input())):\n    (n, d) = input().split()\n    (n, d) = (int(n), int(d))\n    vol = n\n    least = 10\n    arr = []\n    while 1:\n        flag = dgs(vol)\n        while 1:\n            if flag < 10:\n                break\n            flag = dgs(flag)\n        if flag not in arr:\n            arr.append(flag)\n            if flag < least:\n                least = flag\n        else:\n            print(least, ' ', time(n, d, least))\n            break\n        vol = vol + d\n    del arr[:]", "def digit_sum(n):\n    return sum(map(int, str(n)))\n\ndef r_digit_sum(n):\n    op = 0\n    while n > 9:\n        n = sum(map(int, str(n)))\n        op += 1\n    return (n, op)\nT = int(input())\nfor t in range(T):\n    (n, d) = map(int, input().split())\n    oc = 0\n    arr = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]\n    queue = [(n, 0)]\n    while len(queue):\n        (n, op) = queue.pop(0)\n        (nd, nop) = r_digit_sum(n)\n        if arr[nd] != -1:\n            if arr[nd] < nop + op:\n                continue\n        if n < 10:\n            if arr[n] != -1:\n                if arr[n] > op:\n                    arr[n] = op\n                else:\n                    continue\n            else:\n                arr[n] = op\n        n_copy = n\n        dc = 1\n        while n_copy > 9:\n            n_copy = digit_sum(n_copy)\n            queue.append((n_copy, dc + op))\n            dc += 1\n        queue.append((n + d, op + 1))\n    for i in range(1, 10):\n        if arr[i] != -1:\n            print(i, arr[i])\n            break", "for case in range(int(input())):\n    (n, d) = (int(i) for i in input().split())\n    steps = 0\n    if d % 9 == 0:\n        ans = n % 9\n        if ans == 0:\n            ans = 9\n    elif d % 3 == 0:\n        ans = n % 3\n        if ans == 0:\n            ans = 3\n    else:\n        ans = 1\n    if n == ans:\n        print(ans, steps)\n        continue\n    ops = [n]\n    while ans not in ops:\n        steps += 1\n        temp = []\n        for i in ops:\n            if i + d not in ops:\n                temp.append(i + d)\n            ds = sum((int(_) for _ in str(i)))\n            if ds not in ops:\n                temp.append(ds)\n        ops = temp\n    print(ans, steps)", "def digisum(n):\n    ans = 0\n    while n != 0:\n        dig = n % 10\n        ans += dig\n        n //= 10\n    return ans\n\ndef findmin(n, d):\n    min = n\n    for i in range(200):\n        if n < min:\n            min = n\n        if n >= 10:\n            n = digisum(n)\n        else:\n            n += d\n    return min\nfor i in range(int(input())):\n    (n, d) = map(int, input().split())\n    m = findmin(n, d)\n    if n == m:\n        print('%d 0' % m)\n        continue\n    else:\n        oldlist = [n]\n        newlist = [n]\n        steps = 0\n        done = False\n        while done != True:\n            steps += 1\n            oldlist = newlist\n            newlist = []\n            for j in range(len(oldlist)):\n                newlist.append(oldlist[j] + d)\n                newlist.append(digisum(oldlist[j]))\n                if newlist[2 * j] == m or newlist[2 * j + 1] == m:\n                    print('%d %d' % (m, steps))\n                    done = True\n                    break", "def finder(n, num, cnt, p, x):\n    if num == p[0] and cnt < p[1]:\n        p[1] = cnt\n    if num < p[0]:\n        p[0] = num\n        p[1] = cnt\n        if p[0] == 1:\n            return p\n    if cnt == 11:\n        return\n    finder(n + x, sod(n), cnt + 1, p, x)\n    finder(num + x, sod(num), cnt + 1, p, x)\n\ndef sod(n):\n    s = 0\n    while n > 0:\n        d = n % 10\n        s += d\n        n = n // 10\n    return s\nn = int(input())\nfor i in range(n):\n    (a, x) = map(int, input().split())\n    ans = [a, 0]\n    finder(a + x, sod(ans[0]), 1, ans, x)\n    print(ans[0], ans[1])", "import sys\nsys.setrecursionlimit(1000000)\n\ndef digitsum(x, d, ct):\n    if ct > 11:\n        return\n    l.append([x, ct])\n    if x > 9:\n        a = sum(map(int, list(str(x))))\n        digitsum(a, d, ct + 1)\n    digitsum(x + d, d, ct + 1)\nt = int(input())\nwhile t:\n    t -= 1\n    (n, d) = map(int, input().strip().split())\n    l = []\n    digitsum(n, d, 0)\n    l.sort()\n    print(l[0][0], l[0][1])", "def sumof(n):\n    s = 0\n    while n > 0:\n        r = n % 10\n        s += r\n        n = n // 10\n    return s\n\ndef recu(n, digi_n, c, l, d):\n    if digi_n == l[0] and c < l[1]:\n        l[1] = c\n    if digi_n < l[0]:\n        l[0] = digi_n\n        l[1] = c\n        if l[0] == 1:\n            return l\n    if c == 11:\n        return\n    recu(n + d, sumof(n), c + 1, l, d)\n    recu(digi_n + d, sumof(digi_n), c + 1, l, d)\nn = int(input())\nfor i in range(n):\n    (x, d) = [int(i) for i in input().split()]\n    l = [x, 0]\n    recu(x + d, sumof(l[0]), 1, l, d)\n    print(l[0], l[1])", "t = int(input())\nfor z in range(t):\n    (n, d) = map(int, input().split(' '))\n    a = []\n    a.append((n, 0))\n    i = 0\n    while i < 2048:\n        y = []\n        for j in str(a[i][0]):\n            y.append(j)\n        y = [int(k) for k in y]\n        s = sum(y)\n        a.append((s, a[i][1] + 1))\n        a.append((a[i][0] + d, a[i][1] + 1))\n        i = i + 1\n    q = min(a)\n    print(q[0], q[1])", "def digitSum(a):\n    q = a\n    sum = 0\n    while q != 0:\n        r = q % 10\n        q = q // 10\n        sum += r\n    return sum\nimport queue\nt = int(input())\nfor a0 in range(t):\n    (n, d) = [int(x) for x in input().split()]\n    arr = [-1] * 10\n    q1 = queue.Queue()\n    q2 = queue.Queue()\n    count = 1\n    if n // 10 == 0:\n        arr[n] = 0\n    q1.put([n, 0])\n    q2.put([n, 0])\n    while not q1.empty() or not q2.empty():\n        if not q1.empty():\n            a1 = q1.get()\n            ds = digitSum(a1[0])\n            if ds // 10 == 0 and arr[ds] == -1:\n                arr[ds] = a1[1] + 1\n                q2.put([ds, a1[1] + 1])\n            if ds // 10 != 0:\n                q1.put([ds, a1[1] + 1])\n                q2.put([ds, a1[1] + 1])\n        if not q2.empty():\n            a2 = q2.get()\n            sum = a2[0] + d\n            if sum // 10 == 0 and arr[sum] == -1:\n                arr[sum] = a2[1] + 1\n                q2.put([sum, a2[1] + 1])\n            if sum // 10 != 0:\n                q1.put([sum, a2[1] + 1])\n                q2.put([sum, a2[1] + 1])\n        count += 1\n        if count > 10000:\n            break\n    for i in range(10):\n        if arr[i] != -1:\n            print(i, arr[i])\n            break", "def sum1(a, d):\n    return a + d\n\ndef dsum(n):\n    total = 0\n    while n != 0:\n        total += n % 10\n        n = n // 10\n    return total\n\ndef mn(n, d):\n    t1 = [0 for k in range(10)]\n    m = sum1(n, d)\n    while t1.count(0) != 0:\n        if t1[1] == 1:\n            return 1\n        while len(str(m)) > 1:\n            m = dsum(m)\n        if t1[m] == 0:\n            t1[m] = 1\n        else:\n            break\n        m = sum1(m, d)\n    return t1.index(1)\nt = int(input())\nfor l1 in range(t):\n    l = [int(y) for y in input().split()]\n    n = l[0]\n    d = l[1]\n    if n == 1:\n        print(str(1) + ' ' + str(0))\n        continue\n    minm = mn(n, d)\n    if minm == n:\n        print(str(n) + ' ' + str(0))\n        continue\n    temp = []\n    temp.append([n, 0])\n    temp1 = []\n    temp1.append(n)\n    for j in temp:\n        l1 = sum1(j[0], d)\n        l2 = dsum(j[0])\n        if l1 not in temp1:\n            temp.append([l1, j[1] + 1])\n            temp1.append(l1)\n        if l2 not in temp1:\n            temp.append([l2, j[1] + 1])\n            temp1.append(l2)\n        if min(temp1) == minm:\n            break\n    for j in temp:\n        if j[0] == minm:\n            print(str(minm) + ' ' + str(j[1]))\n            break", "import math\ntemp = int(input())\nwhile temp > 0:\n    (num, d) = map(int, input().split())\n\n    def sumdig(num):\n        s = 0\n        while num:\n            s += num % 10\n            num //= 10\n        return s\n    a = [None] * 20005\n    p = 0\n    min = num\n    for i in range(10000):\n        if 2 * i + 2 < 20005:\n            a[0] = num\n            f = sumdig(a[i])\n            a[2 * i + 1] = f\n            a[2 * i + 2] = a[i] + d\n            if min > a[2 * i + 1]:\n                min = a[2 * i + 1]\n    p = a.index(min) + 1\n    if p == 0:\n        b = 0\n    else:\n        b = math.floor(math.log2(p))\n    print(min, b)\n    temp = temp - 1", "def digitsum(num):\n    sums = 0\n    while num != 0:\n        sums += num % 10\n        num = num // 10\n    return sums\n\ndef add_op(cnt, arr, d, k):\n    arr[cnt * 2 + 2] = k + d\n    arr[cnt * 2 + 1] = digitsum(k)\nt = int(input())\nfor loop in range(t):\n    (n, d) = map(int, input().split())\n    cnt = 0\n    arr = [9] * 10000\n    arr[0] = n\n    while cnt < 4097:\n        add_op(cnt, arr, d, arr[cnt])\n        cnt += 1\n    min_i = arr.index(min(arr))\n    min_v = min(arr)\n    c = 0\n    while min_i != 0:\n        if min_i % 2 == 0:\n            min_i = (min_i - 2) // 2\n        else:\n            min_i = (min_i - 1) // 2\n        c += 1\n    print(min_v, c)", "from queue import Queue\n\ndef Sum(n):\n    dig_sum = n\n    initial = n\n    sum_count = 0\n    while dig_sum > 9:\n        temp = dig_sum\n        dig_sum = 0\n        sum_count += 1\n        while temp > 0:\n            dig_sum += temp % 10\n            temp = temp // 10\n        if sum_count == 1:\n            initial = dig_sum\n    return [initial, dig_sum, sum_count]\n\ndef digit(n):\n    dig_sum = 0\n    while n > 0:\n        dig_sum += n % 10\n        n = n // 10\n    return dig_sum\n\ndef obtain_min(queue, D, min_val):\n    [level, data] = queue.get()\n    if data <= min_val:\n        return [True, min_val, level]\n    if data > 9:\n        left_node = digit(data)\n        queue.put([level + 1, left_node])\n    right_node = data + D\n    queue.put([level + 1, right_node])\n    return [False, 0, 0]\n\ndef min(N, D):\n    result = False\n    count = 0\n    if D % 9 == 0:\n        if N % 9 == 0:\n            min_val = 9\n        else:\n            min_val = N % 9\n    elif D % 3 == 0:\n        if N % 3 == 0:\n            min_val = 3\n        else:\n            min_val = N % 3\n    else:\n        min_val = 1\n    queue = Queue()\n    queue.put([0, N])\n    while result != True:\n        (result, min_val_ret, count) = obtain_min(queue, D, min_val)\n    print(str(min_val_ret) + ' ' + str(count))\ntest_case = int(input())\nfor i in range(test_case):\n    (n, d) = map(int, input().split())\n    min(n, d)", "from queue import Queue\n\ndef Sum(n):\n    dig_sum = n\n    first_sum = n\n    sum_count = 0\n    while dig_sum > 9:\n        temp = dig_sum\n        dig_sum = 0\n        sum_count += 1\n        while temp > 0:\n            dig_sum += temp % 10\n            temp = temp // 10\n        if sum_count == 1:\n            first_sum = dig_sum\n    return [first_sum, dig_sum, sum_count]\n\ndef SingleSum(n):\n    dig_sum = 0\n    while n > 0:\n        dig_sum += n % 10\n        n = n // 10\n    return dig_sum\n\ndef SearchMin(qu, D, min_val):\n    [level, value] = qu.get()\n    if value <= min_val:\n        return [True, min_val, level]\n    if value > 9:\n        left_val = SingleSum(value)\n        qu.put([level + 1, left_val])\n    right_value = value + D\n    qu.put([level + 1, right_value])\n    return [False, 0, 0]\nmax_tree = [0, 0, 0]\n\ndef FindMinimized(N, D):\n    global max_tree\n    if D % 9 == 0:\n        if N % 9 == 0:\n            min_val = 9\n        else:\n            min_val = N % 9\n    elif D % 3 == 0:\n        if N % 3 == 0:\n            min_val = 3\n        else:\n            min_val = N % 3\n    else:\n        min_val = 1\n    qu = Queue()\n    qu.put([0, N])\n    res = False\n    count = 0\n    while res == False:\n        (res, min_val_ret, count) = SearchMin(qu, D, min_val)\n    print(str(min_val_ret) + ' ' + str(count))\n\ndef FindMinimized20(N, D, min_val):\n    qu = Queue()\n    qu.put([0, N])\n    res = False\n    count = 0\n    iteration = 2 ** 20\n    while (res == False) & (iteration > 0):\n        iteration -= 1\n        (res, min_val_ret, count) = SearchMin(qu, D, min_val)\n    return [min_val_ret, count]\nt = int(input())\nfor i in range(t):\n    (N, D) = map(int, input().split())\n    FindMinimized(N, D)", "t = int(input())\nwhile t > 0:\n    lo = input().split()\n    n = int(lo[0])\n    d = int(lo[1])\n    k = []\n    k.append([n, 0])\n    i = 0\n    point = 0\n    re = dict()\n    re[n] = 1\n    minnum = n\n    pos_height = 0\n    while i <= 10000:\n        i = i + 1\n        try:\n            pop_element = k[point][0]\n            height = k[point][1]\n        except:\n            break\n        temp = pop_element\n        sod = 0\n        while temp != 0:\n            q = temp % 10\n            sod = sod + q\n            temp = temp // 10\n        first = sod\n        if minnum > first:\n            if first == minnum:\n                if height + 1 < pos_height:\n                    pos_height = height + 1\n            else:\n                minnum = first\n                pos_height = height + 1\n        second = pop_element + d\n        if minnum > second:\n            if second == minnum:\n                if height + 1 < pos_height:\n                    pos_height = height + 1\n            else:\n                minnum = second\n                pos_height = height + 1\n        if second not in re:\n            re[second] = 1\n            k.append([second, height + 1])\n        if first not in re:\n            re[first] = 1\n            k.append([first, height + 1])\n        point = point + 1\n    print(minnum, ' ', pos_height)\n    t = t - 1", "def digitsumof(n):\n    s = 0\n    while n > 0:\n        r = n % 10\n        s += r\n        n = n // 10\n    return s\n\ndef rec(n, digin, count, l, d):\n    if digin == l[0] and count < l[1]:\n        l[1] = count\n    if digin < l[0]:\n        l[0] = digin\n        l[1] = count\n        if l[0] == 1:\n            return 1\n    if count == 11:\n        return\n    rec(n + d, digitsumof(n), count + 1, l, d)\n    rec(digin + d, digitsumof(digin), count + 1, l, d)\nt = int(input())\nfor i in range(t):\n    (a, d) = map(int, input().split())\n    l = [a, 0]\n    rec(a + d, digitsumof(l[0]), 1, l, d)\n    print(l[0], l[1])"]