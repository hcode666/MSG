["import sys\ninput = sys.stdin.readline\n\ndef mm(a, b, c):\n    if b == 0:\n        return 1\n    ans = 1\n    if b % 2 == 1:\n        ans *= a\n    ans = mm(a, b // 2, c) ** 2 * ans % c\n    return ans\n\ndef mm2(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef c(a, b):\n    aa = pre[a]\n    aa *= pp[b]\n    aa *= pp[a - b]\n    return aa % mod\nt = int(input())\nmod = 10 ** 9 + 7\npre = [1]\nfor i in range(1, 10 ** 5 + 1):\n    pre.append(pre[-1] * i % mod)\npp = []\nfor i in pre:\n    pp.append(mm(i, mod - 2, mod))\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    tot = 0\n    p = [1]\n    for i in range(n - k + 1):\n        p.append(p[-1] * (m - 1) % mod)\n    for i in range(k, n + 1):\n        prev = tot\n        tot += c(n, i) * p[n - i]\n        tot %= mod\n    print(tot)", "import sys\ninput = sys.stdin.readline\n\ndef mm2(a, b, c):\n    if b == 0:\n        return 1\n    ans = 1\n    if b % 2 == 1:\n        ans *= a\n    ans = mm(a, b // 2, c) ** 2 * ans % c\n    return ans\n\ndef mm(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef c(a, b):\n    aa = pre[a]\n    aa *= pp[b]\n    aa *= pp[a - b]\n    return aa % mod\nt = int(input())\nmod = 10 ** 9 + 7\npre = [1]\nfor i in range(1, 10 ** 5 + 1):\n    pre.append(pre[-1] * i % mod)\npp = []\nfor i in pre:\n    pp.append(mm(i, mod - 2, mod))\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    tot = 0\n    p = [1]\n    for i in range(n - k + 1):\n        p.append(p[-1] * (m - 1) % mod)\n    for i in range(k, n + 1):\n        prev = tot\n        tot += c(n, i) * p[n - i]\n        tot %= mod\n    print(tot)", "import sys\ninput = sys.stdin.readline\n\ndef mm2(a, b, c):\n    if b == 0:\n        return 1\n    ans = 1\n    if b % 2 == 1:\n        ans *= a\n    ans = mm(a, b // 2, c) ** 2 * ans % c\n    return ans\n\ndef mm(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef c(a, b):\n    aa = pre[a]\n    aa *= pp[b]\n    aa *= pp[a - b]\n    return aa % mod\nt = int(input())\nmod = 10 ** 9 + 7\npre = [1]\nfor i in range(1, 10 ** 5 + 1):\n    pre.append(pre[-1] * i % mod)\npp = []\nfor i in pre:\n    pp.append(mm(i, mod - 2, mod))\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    tot = 0\n    p = [1]\n    for i in range(n - k + 1):\n        p.append(p[-1] * (m - 1) % mod)\n    for i in range(k, n + 1):\n        prev = tot\n        tot += c(n, i) * mm(m - 1, n - i, mod)\n        tot %= mod\n    print(tot)", "mod = 10 ** 9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nf = [1 for i in range(10 ** 5 + 5)]\nfinv = [1 for i in range(10 ** 5 + 5)]\nfor i in range(1, 10 ** 5 + 5):\n    f[i] = i * f[i - 1]\n    f[i] %= mod\nfor i in range(10 ** 5 + 5):\n    finv[i] = power(f[i], mod - 2, mod)\n    finv[i] %= mod\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    ans = 0\n    for i in range(k, n + 1):\n        ncr = f[n] * finv[i] * finv[n - i]\n        ncr %= mod\n        expo = power(m - 1, n - i, mod)\n        ans += ncr * expo\n        ans %= mod\n    print(ans % mod)", "import sys\nMAXN = pow(10, 5) + 10\nmod = pow(10, 9) + 7\nfact = [0] * MAXN\ninv = [0] * MAXN\n\ndef precompute():\n    fact[0] = 1\n    inv[0] = 1\n    for i in range(1, MAXN):\n        fact[i] = fact[i - 1] * i\n        fact[i] %= mod\n        inv[i] = pow(fact[i], mod - 2, mod)\nprecompute()\n\ndef ncr(x, y):\n    res = fact[x] * inv[y]\n    res %= mod\n    res *= inv[x - y]\n    res %= mod\n    return res\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    (n, m, k) = map(int, sys.stdin.readline().split())\n    res = 0\n    for i in range(k, n + 1):\n        res += ncr(n, i) * pow(m - 1, n - i, mod)\n        res %= mod\n    print(res)", "mod = int(1000000007)\nfact = [0] * 100005\ninvfact = [0] * 100005\n\ndef powe(a, b):\n    if b == 0:\n        return 1\n    temp = powe(a, int(b / 2))\n    temp = temp * temp % mod\n    if b % 2 == 1:\n        temp = temp * a % mod\n    return temp\n\ndef pre():\n    fact[0] = 1\n    invfact[0] = 1\n    for x in range(1, 100005):\n        fact[x] = fact[x - 1] * x % mod\n        invfact[x] = powe(fact[x], int(mod - 2))\n\ndef comb(n, r):\n    if r > n:\n        return 0\n    if n == r or r == 0:\n        return 1\n    A = fact[n]\n    B = invfact[r]\n    A = A * B % mod\n    C = invfact[n - r]\n    A = A * C % mod\n    return A\nt = int(input())\npre()\nfor tt in range(t):\n    arr = input()\n    arr = list(map(int, arr.split(' ')))\n    n = arr[0]\n    m = arr[1]\n    k = arr[2]\n    ans = powe(m, n)\n    for i in range(0, k):\n        b = comb(n, i)\n        c = powe(m - 1, n - i)\n        b = b * c % mod\n        ans -= b\n        ans %= mod\n        ans = (ans + mod) % mod\n    print(ans)", "M = 10 ** 9 + 7\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\na = [1]\nfor i in range(1, 10 ** 5 + 2):\n    a.append(a[-1] * i % M)\nfor i in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    ans = 0\n    for j in range(k, n + 1):\n        ans += pow(m - 1, n - j, M) * modInverse(a[j] * a[n - j], M) * a[n]\n        ans %= M\n    print(ans)", "mod = 1000000007\nMOD = 998244353\nii = lambda : int(input())\nsi = lambda : input()\ndgl = lambda : list(map(int, input()))\nf = lambda : map(int, input().split())\nil = lambda : list(map(int, input().split()))\nit = lambda : tuple(map(int, input().split()))\nls = lambda : list(input())\n\nclass Triplet:\n\n    def __init__(self, x, y, gd):\n        self.x = x\n        self.y = y\n        self.gd = gd\n\ndef extendedGCD(a, b):\n    if b == 0:\n        return Triplet(1, 0, a)\n    ans = extendedGCD(b, a % b)\n    return Triplet(ans.y, ans.x - a // b * ans.y, ans.gd)\n\ndef modInverse(a, m):\n    z = extendedGCD(a, m).x\n    return z\nfor _ in range(ii()):\n    (n, m, k) = f()\n    srik = [0] * k\n    ummi = [0] * (n + 1)\n    srik[0] = 1\n    for i in range(1, k):\n        srik[i] = srik[i - 1] * (n - i + 1) % mod\n        srik[i] = srik[i] * modInverse(i, mod) % mod\n    ummi[0] = 1\n    ans = 1\n    for i in range(1, n + 1):\n        ummi[i] = ummi[i - 1] * (m - 1) % mod\n        ans = ans * m % mod\n    for i in range(k):\n        ans = (mod + ans - srik[i] * ummi[n - i] % mod) % mod\n    print(ans)", "M = 10 ** 9 + 7\nN = 10 ** 5 + 1\nf = [1] * N\nfor i in range(1, N):\n    f[i] = i * f[i - 1] % M\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    s = sum((pow(f[i] * f[n - i], M - 2, M) * pow(m - 1, n - i, M) for i in range(k, n + 1)))\n    print(f[n] * s % M)", "def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modinv(b, m)\n    if inv == -1:\n        return None\n    else:\n        return inv * a % m\n\ndef power(x, y, MOD):\n    if y == 0:\n        return 1\n    a = power(x, y // 2, MOD)\n    if y % 2 == 0:\n        return a * a % MOD\n    else:\n        return a * a * x % MOD\nMOD = 10 ** 9 + 7\nt = int(input())\nfact = [1]\nfor i in range(1, 10 ** 5 + 10):\n    fact.append(fact[-1] * i % MOD)\nfor t_ in range(t):\n    (n, m, k) = map(int, input().split())\n    ans = 0\n    for i in range(n - k + 1):\n        ans += pow(m - 1, i, MOD) * modDivide(fact[n], fact[i] * fact[n - i] % MOD, MOD) % MOD\n        ans %= MOD\n    print(ans)"]