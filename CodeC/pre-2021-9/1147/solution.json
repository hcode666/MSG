["import sys\n\ndef getInput():\n    return sys.stdin.readline().strip()\n\ndef getInt():\n    return int(getInput())\n\ndef getInts():\n    return map(int, getInput().split())\n\ndef getArray():\n    return list(getInts())\ntc = getInt()\nfor _ in range(tc):\n    n = getInt()\n    lines = []\n    for __ in range(n):\n        lines.append(getArray()[1:])\n    mp = dict()\n    for line in lines:\n        for ant in line:\n            if abs(ant) in mp:\n                mp[abs(ant)] += 1\n            else:\n                mp[abs(ant)] = 1\n    ans = 0\n    for i in mp.values():\n        if i >= 2:\n            ans += 1\n    for line in lines:\n        neg = []\n        pos = []\n        for ant in line:\n            if ant < 0:\n                neg.append(ant)\n            else:\n                pos.append(ant)\n        pos.reverse()\n        while True:\n            try:\n                if abs(neg[-1]) < pos[-1]:\n                    closest = neg[-1]\n                else:\n                    closest = pos[-1]\n            except:\n                if not neg and (not pos):\n                    break\n                if not neg:\n                    closest = pos[-1]\n                if not pos:\n                    closest = neg[-1]\n            if mp[abs(closest)] >= 2:\n                if closest < 0:\n                    ans += len(neg) - 1\n                else:\n                    ans += len(pos) - 1\n            elif closest < 0:\n                ans += len(pos)\n            else:\n                ans += len(neg)\n            if closest < 0:\n                neg.pop()\n            else:\n                pos.pop()\n    print(ans)", "import sys\n\ndef getInput():\n    return sys.stdin.readline().strip()\n\ndef getInt():\n    return int(getInput())\n\ndef getInts():\n    return map(int, getInput().split())\n\ndef getArray():\n    return list(getInts())\ntc = getInt()\nfor _ in range(tc):\n    n = getInt()\n    lines = []\n    for __ in range(n):\n        lines.append(getArray()[1:])\n    mp = dict()\n    for line in lines:\n        for ant in line:\n            if abs(ant) in mp:\n                mp[abs(ant)] += 1\n            else:\n                mp[abs(ant)] = 1\n    ans = 0\n    for i in mp.values():\n        if i >= 2:\n            ans += 1\n    for line in lines:\n        neg = []\n        pos = []\n        for ant in line:\n            if ant < 0:\n                neg.append(ant)\n            else:\n                pos.append(ant)\n        pos.reverse()\n        while True:\n            try:\n                if abs(neg[-1]) < pos[-1]:\n                    closest = neg[-1]\n                else:\n                    closest = pos[-1]\n            except:\n                if not neg and (not pos):\n                    break\n                if not neg:\n                    closest = pos[-1]\n                if not pos:\n                    closest = neg[-1]\n            if mp[abs(closest)] >= 2:\n                if closest < 0:\n                    ans += len(neg) - 1\n                else:\n                    ans += len(pos) - 1\n            elif closest < 0:\n                ans += len(pos)\n            else:\n                ans += len(neg)\n            if closest < 0:\n                neg.pop()\n            else:\n                pos.pop()\n    print(ans)", "from functools import lru_cache\nimport sys\nimport math\nfrom collections import Counter, deque\nmod = 10 ** 9 + 7\ninf = float('inf')\n\ndef arrInt():\n    return list(map(int, input().split()))\n\ndef solve(n, ants):\n    collisions = 0\n    arr = []\n    counter = Counter()\n    pos = [0] * n\n    neg = [0] * n\n    for (i, row) in enumerate(ants):\n        for el in row:\n            counter[abs(el)] += 1\n            if el < 0:\n                neg[i] += 1\n            else:\n                pos[i] += 1\n            arr.append((el, i))\n    arr.sort(key=lambda x: abs(x[0]))\n    for (d, v) in counter.items():\n        collisions += int(v > 1)\n    for (el, i) in arr:\n        if counter[abs(el)] == 1:\n            if el < 0:\n                collisions += pos[i]\n                neg[i] -= 1\n            else:\n                collisions += neg[i]\n                pos[i] -= 1\n        elif el < 0:\n            neg[i] -= 1\n            collisions += neg[i]\n        else:\n            pos[i] -= 1\n            collisions += pos[i]\n    print(collisions)\nTESTING = False\nif TESTING:\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nelse:\n    input = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    ants = []\n    for _ in range(n):\n        ants.append(arrInt()[1:])\n    solve(n, ants)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    d = {}\n    l = []\n    for j in range(n):\n        neg = 0\n        a = list(map(int, input().split()))\n        for k in range(a[0]):\n            if a[1 + k] < 0:\n                neg += 1\n                if abs(a[1 + k]) in d:\n                    d[abs(a[1 + k])].append([j + 1, 0])\n                else:\n                    d[abs(a[1 + k])] = [[j + 1, 0]]\n            elif a[1 + k] in d:\n                if d[a[1 + k]][-1][0] == j + 1:\n                    d[a[1 + k]][-1][1] = 2\n                else:\n                    d[a[1 + k]].append([j + 1, 1])\n            else:\n                d[a[1 + k]] = [[j + 1, 1]]\n        l.append([neg, a[0] - neg])\n    k = list(d.keys())\n    k.sort()\n    co = 0\n    for j in k:\n        if len(d[j]) == 1 and d[j][0][1] != 2:\n            if d[j][0][1] == 0:\n                l[d[j][0][0] - 1][0] -= 1\n                co += l[d[j][0][0] - 1][1]\n            else:\n                l[d[j][0][0] - 1][1] -= 1\n                co += l[d[j][0][0] - 1][0]\n        else:\n            co += 1\n            for k in d[j]:\n                if k[1] == 0 or k[1] == 2:\n                    l[k[0] - 1][0] -= 1\n                    co += l[k[0] - 1][0]\n                if k[1] == 1 or k[1] == 2:\n                    l[k[0] - 1][1] -= 1\n                    co += l[k[0] - 1][1]\n    print(co)", "from bisect import bisect_left, bisect_right\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    c = {}\n    ctr = 0\n    for i in range(n):\n        s = list(map(int, input().split()))\n        m = int(s[0])\n        a.append(s[1:])\n        for j in a[-1]:\n            if abs(j) in c:\n                c[abs(j)] += 1\n            else:\n                c[abs(j)] = 1\n    ans = 0\n    for k in c.values():\n        if k > 1:\n            ans += 1\n    for i in range(n):\n        for j in range(len(a[i])):\n            if c[abs(a[i][j])] <= 1:\n                if a[i][j] < 0:\n                    ans += len(a[i]) - bisect_right(a[i], -a[i][j])\n                else:\n                    ans += bisect_left(a[i], -a[i][j])\n            elif a[i][j] < 0:\n                ans += j\n            else:\n                ans += len(a[i]) - (j + 1)\n    print(ans)", "import math\ntry:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        lines = []\n        for __ in range(n):\n            lines.append(list(map(int, input().split()))[1:])\n        mapp = dict()\n        for line in lines:\n            for ant in line:\n                if abs(ant) in mapp:\n                    mapp[abs(ant)] += 1\n                else:\n                    mapp[abs(ant)] = 1\n        ans = 0\n        for i in mapp.values():\n            if i > 1:\n                ans += 1\n        for line in lines:\n            pos = []\n            neg = []\n            for ant in line:\n                if ant < 0:\n                    neg.append(ant)\n                else:\n                    pos.append(ant)\n            pos.reverse()\n            while True:\n                closest = 0\n                if not neg and (not pos):\n                    break\n                elif not neg:\n                    closest = pos[-1]\n                elif not pos:\n                    closest = neg[-1]\n                else:\n                    closest = neg[-1] if abs(neg[-1]) < pos[-1] else pos[-1]\n                if mapp[abs(closest)] > 1:\n                    if closest < 0:\n                        ans += len(neg) - 1\n                    else:\n                        ans += len(pos) - 1\n                elif closest < 0:\n                    ans += len(pos)\n                else:\n                    ans += len(neg)\n                if closest < 0:\n                    neg.pop()\n                else:\n                    pos.pop()\n        print(ans)\nexcept EOFError as t:\n    pass", "from collections import Counter\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n    leftGreater = n\n    while l <= r:\n        m = int(l + (r - l) / 2)\n        if arr[m] > k:\n            leftGreater = m\n            r = m - 1\n        else:\n            l = m + 1\n    return n - leftGreater\nfor i in range(int(input())):\n    n = int(input())\n    c = []\n    if n == 1:\n        for i in range(n):\n            c = [int(x) for x in input().split()]\n        c.pop(0)\n        x = 0\n        y = 0\n        for i in c:\n            if i > 0:\n                x = x + 1\n            if i < 0:\n                y = y + 1\n        if y == len(c) or x == len(c):\n            print(0)\n        else:\n            print(x * y)\n    else:\n        d = [[] for _ in range(n)]\n        e = [[] for _ in range(n)]\n        f = []\n        ans = 0\n        for i in range(n):\n            c = [int(x) for x in input().split()]\n            for j in c[1:]:\n                f.append(abs(j))\n                if j > 0:\n                    d[i].append(j)\n                else:\n                    e[i].append(abs(j))\n        for i in d:\n            i.sort()\n        for j in e:\n            j.sort()\n        t = Counter(f).items()\n        t = dict(t)\n        for i in t.values():\n            if i > 1:\n                ans = ans + 1\n        for i in range(len(d)):\n            for j in range(len(d[i])):\n                if t[d[i][j]] > 1:\n                    ans = ans + len(d[i]) - j - 1\n                elif len(e[i]) == 0:\n                    pass\n                else:\n                    ans = ans + countGreater(e[i], len(e[i]), d[i][j])\n        for i in range(len(e)):\n            for j in range(len(e[i])):\n                if t[e[i][j]] > 1:\n                    ans = ans + len(e[i]) - j - 1\n                elif len(d[i]) == 0:\n                    pass\n                else:\n                    ans = ans + countGreater(d[i], len(d[i]), e[i][j])\n        print(ans)", "from sys import stdin, stdout\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    lines = []\n    m = []\n    ans = 0\n    for i in range(n):\n        l = list(map(int, stdin.readline().strip().split()))[1:]\n        lines.append(l)\n    f = {}\n    for line in lines:\n        for ant in line:\n            if abs(ant) in f:\n                f[abs(ant)] += 1\n            else:\n                f[abs(ant)] = 1\n    for i in f.values():\n        if i >= 2:\n            ans += 1\n    for line in lines:\n        neg = []\n        pos = []\n        for i in line:\n            if i < 0:\n                neg.append(i)\n            else:\n                pos.append(i)\n        pos.reverse()\n        while True:\n            try:\n                if abs(neg[-1]) > abs(pos[-1]):\n                    close = pos[-1]\n                else:\n                    close = neg[-1]\n            except:\n                if not neg and (not pos):\n                    break\n                if not neg:\n                    close = pos[-1]\n                if not pos:\n                    close = neg[-1]\n            if f[abs(close)] >= 2:\n                if close < 0:\n                    ans += len(neg) - 1\n                else:\n                    ans += len(pos) - 1\n            elif close < 0:\n                ans += len(pos)\n            else:\n                ans += len(neg)\n            if close < 0:\n                neg.pop()\n            else:\n                pos.pop()\n    print(ans)", "from sys import stdin, stdout\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    lines = []\n    m = []\n    ans = 0\n    for i in range(n):\n        l = list(map(int, stdin.readline().strip().split()))[1:]\n        lines.append(l)\n    f = {}\n    for line in lines:\n        for ant in line:\n            if abs(ant) in f:\n                f[abs(ant)] += 1\n            else:\n                f[abs(ant)] = 1\n    for i in f.values():\n        if i >= 2:\n            ans += 1\n    for line in lines:\n        neg = []\n        pos = []\n        for i in line:\n            if i < 0:\n                neg.append(i)\n            else:\n                pos.append(i)\n        pos.reverse()\n        while True:\n            try:\n                if abs(neg[-1]) < abs(pos[-1]):\n                    close = neg[-1]\n                else:\n                    close = pos[-1]\n            except:\n                if not neg and (not pos):\n                    break\n                if not neg:\n                    close = pos[-1]\n                if not pos:\n                    close = neg[-1]\n            if f[abs(close)] >= 2:\n                if close < 0:\n                    ans += len(neg) - 1\n                else:\n                    ans += len(pos) - 1\n            elif close < 0:\n                ans += len(pos)\n            else:\n                ans += len(neg)\n            if close < 0:\n                neg.pop()\n            else:\n                pos.pop()\n    print(ans)", "for i in range(int(input())):\n    n = int(input())\n    lines = []\n    ans = 0\n    for i in range(n):\n        l = list(map(int, input().split()[1:]))\n        lines.append(l)\n    mp = dict()\n    for i in lines:\n        for j in i:\n            if abs(j) not in mp:\n                mp[abs(j)] = 1\n            elif abs(j) in mp:\n                mp[abs(j)] += 1\n    for value in mp.values():\n        if value >= 2:\n            ans += 1\n    for line in lines:\n        pos = []\n        neg = []\n        closest = 0\n        for ant in line:\n            if ant < 0:\n                neg.append(ant)\n            else:\n                pos.append(ant)\n        pos.sort(reverse=True)\n        while True:\n            if not neg and (not pos):\n                break\n            elif not neg:\n                closest = pos[-1]\n            elif not pos:\n                closest = neg[-1]\n            elif abs(neg[-1]) < pos[-1]:\n                closest = neg[-1]\n            else:\n                closest = pos[-1]\n            if mp[abs(closest)] >= 2:\n                if closest < 0:\n                    ans += len(neg) - 1\n                else:\n                    ans += len(pos) - 1\n            elif closest < 0:\n                ans += len(pos)\n            else:\n                ans += len(neg)\n            if closest < 0:\n                neg.pop()\n            else:\n                pos.pop()\n    print(ans)", "from heapq import heappush, heappop\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    left = defaultdict(int)\n    right = defaultdict(int)\n    closest = []\n    for i in range(n):\n        ants = [int(s) for s in input().strip().split(' ')][1:]\n        for a in ants:\n            if a < 0:\n                left[i] += 1\n            else:\n                right[i] += 1\n            heappush(closest, (abs(a), i, a))\n    ans = 0\n    while len(closest) > 0:\n        d = closest[0][0]\n        colliding = []\n        while len(closest) > 0 and closest[0][0] == d:\n            (_, i, a) = heappop(closest)\n            colliding.append((i, a))\n        if len(colliding) == 1:\n            (i, a) = colliding[0]\n            if a > 0:\n                right[i] -= 1\n                ans += left[i]\n            else:\n                left[i] -= 1\n                ans += right[i]\n        else:\n            ans += 1\n            for (i, a) in colliding:\n                if a > 0:\n                    right[i] -= 1\n                else:\n                    left[i] -= 1\n            for (i, a) in colliding:\n                if a > 0:\n                    ans += right[i]\n                else:\n                    ans += left[i]\n    print(ans)", "from sys import stdin, stdout\n\ndef solver(larr, rarr, s):\n    (i, j) = (0, 0)\n    temp = 0\n    while len(larr) > 0 and len(rarr) > 0:\n        if abs(larr[i]) < rarr[j]:\n            if abs(larr[i]) in s:\n                temp += len(larr) - 1\n            else:\n                temp += len(rarr)\n            larr.remove(larr[0])\n        else:\n            if rarr[j] in s:\n                temp += len(rarr) - 1\n            else:\n                temp += len(larr)\n            rarr.remove(rarr[0])\n    if len(larr) > 0:\n        while len(larr) > 0:\n            if abs(larr[0]) in s:\n                temp += len(larr) - 1\n            larr.remove(larr[0])\n    if len(rarr) > 0:\n        while len(rarr) > 0:\n            if rarr[0] in s:\n                temp += len(rarr) - 1\n            rarr.remove(rarr[0])\n    return temp\ntest = int(stdin.readline())\nfor testcase in range(test):\n    n = int(stdin.readline())\n    li = []\n    d = {}\n    for _ in range(n):\n        arr = list(map(int, stdin.readline().split()))\n        arr = arr[1:]\n        (l, r) = ([], [])\n        for ele in arr:\n            if ele < 0:\n                l.append(ele)\n            else:\n                r.append(ele)\n            if abs(ele) in d:\n                d[abs(ele)] += 1\n            else:\n                d[abs(ele)] = 1\n        l = sorted(l, reverse=False)\n        l = l[::-1]\n        r.sort()\n        p = [l, r]\n        li.append(p)\n    if n == 1:\n        print(len(l) * len(r))\n        continue\n    s = set()\n    ans = 0\n    for ele in d:\n        if d[ele] > 1:\n            s.add(ele)\n            ans += 1\n    for ele in li:\n        (left_arr, right_arr) = (ele[0], ele[1])\n        tempo = solver(left_arr, right_arr, s)\n        ans += tempo\n    print(ans)", "from sys import stdin, stdout\n\ndef solver(larr, rarr, s):\n    (i, j) = (0, 0)\n    temp = 0\n    while len(larr) > 0 and len(rarr) > 0:\n        if abs(larr[i]) < rarr[j]:\n            if abs(larr[i]) in s:\n                temp += len(larr) - 1\n            else:\n                temp += len(rarr)\n            larr.remove(larr[0])\n        else:\n            if rarr[j] in s:\n                temp += len(rarr) - 1\n            else:\n                temp += len(larr)\n            rarr.remove(rarr[0])\n    if len(larr) > 0:\n        while len(larr) > 0:\n            if abs(larr[0]) in s:\n                temp += len(larr) - 1\n            larr.remove(larr[0])\n    if len(rarr) > 0:\n        while len(rarr) > 0:\n            if rarr[0] in s:\n                temp += len(rarr) - 1\n            rarr.remove(rarr[0])\n    return temp\ntest = int(stdin.readline())\nfor testcase in range(test):\n    n = int(stdin.readline())\n    li = []\n    d = {}\n    for _ in range(n):\n        arr = list(map(int, stdin.readline().split()))\n        arr = arr[1:]\n        (l, r) = ([], [])\n        for ele in arr:\n            if ele < 0:\n                l.append(ele)\n            else:\n                r.append(ele)\n            if abs(ele) in d:\n                d[abs(ele)] += 1\n            else:\n                d[abs(ele)] = 1\n        l = sorted(l, reverse=False)\n        l = l[::-1]\n        r.sort()\n        p = [l, r]\n        li.append(p)\n    if n == 1:\n        print(len(l) * len(r))\n        continue\n    s = set()\n    ans = 0\n    for ele in d:\n        if d[ele] > 1:\n            s.add(ele)\n            ans += 1\n    for ele in li:\n        (left_arr, right_arr) = (ele[0], ele[1])\n        tempo = solver(left_arr, right_arr, s)\n        ans += tempo\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    l = []\n    d = {}\n    sum = 0\n    (uniPos, uniNeg) = ({}, {})\n    for i in range(n):\n        (neg, pos) = (0, 0)\n        (nList, pList) = ([], [])\n        l = list(map(int, input().split()))\n        for j in range(1, len(l)):\n            if l[j] > 0:\n                pos += 1\n                pList.append(l[j])\n            else:\n                neg += 1\n                nList.append(l[j])\n            if abs(l[j]) not in d:\n                d[abs(l[j])] = 0\n            d[abs(l[j])] += 1\n        pList.sort(reverse=True)\n        uniPos[i] = pList\n        uniNeg[i] = nList\n    for i in d:\n        if d[i] > 1:\n            sum += 1\n    for i in range(n):\n        while True:\n            closest = 0\n            if len(uniNeg[i]) == 0 and len(uniPos[i]) == 0:\n                break\n            elif len(uniNeg[i]) == 0:\n                closest = uniPos[i].pop()\n            elif len(uniPos[i]) == 0:\n                closest = uniNeg[i].pop()\n            else:\n                (a, b) = (uniNeg[i].pop(), uniPos[i].pop())\n                if abs(a) > b:\n                    closest = b\n                    uniNeg[i].append(a)\n                else:\n                    closest = a\n                    uniPos[i].append(b)\n            if closest < 0:\n                if d[abs(closest)] > 1:\n                    sum += len(uniNeg[i])\n                else:\n                    sum += len(uniPos[i])\n            elif d[abs(closest)] > 1:\n                sum += len(uniPos[i])\n            else:\n                sum += len(uniNeg[i])\n    print(sum)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    lines = []\n    for i in range(n):\n        lines.append(list(map(int, input().split()[1:])))\n    mp = {}\n    for line in lines:\n        for ant in line:\n            if abs(ant) in mp:\n                mp[abs(ant)] += 1\n            else:\n                mp[abs(ant)] = 1\n    ans = 0\n    for i in mp.values():\n        if i >= 2:\n            ans += 1\n    for line in lines:\n        neg = []\n        pos = []\n        for ant in line:\n            if ant < 0:\n                neg.append(ant)\n            else:\n                pos.append(ant)\n        pos.reverse()\n        while True:\n            try:\n                if abs(neg[-1]) < pos[-1]:\n                    closest = neg[-1]\n                else:\n                    closest = pos[-1]\n            except:\n                if not neg and (not pos):\n                    break\n                if not neg:\n                    closest = pos[-1]\n                if not pos:\n                    closest = neg[-1]\n            if mp[abs(closest)] >= 2:\n                if closest < 0:\n                    ans += len(neg) - 1\n                else:\n                    ans += len(pos) - 1\n            elif closest < 0:\n                ans += len(pos)\n            else:\n                ans += len(neg)\n            if closest < 0:\n                neg.pop()\n            else:\n                pos.pop()\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    lines = []\n    for i in range(n):\n        lines.append(list(map(int, input().split()[1:])))\n    mp = dict()\n    for line in lines:\n        for ant in line:\n            if abs(ant) in mp:\n                mp[abs(ant)] += 1\n            else:\n                mp[abs(ant)] = 1\n    ans = 0\n    for i in mp.values():\n        if i >= 2:\n            ans += 1\n    for line in lines:\n        neg = []\n        pos = []\n        for ant in line:\n            if ant < 0:\n                neg.append(ant)\n            else:\n                pos.append(ant)\n        pos.reverse()\n        while True:\n            try:\n                if abs(neg[-1]) < pos[-1]:\n                    closest = neg[-1]\n                else:\n                    closest = pos[-1]\n            except:\n                if not neg and (not pos):\n                    break\n                if not neg:\n                    closest = pos[-1]\n                if not pos:\n                    closest = neg[-1]\n            if mp[abs(closest)] >= 2:\n                if closest < 0:\n                    ans += len(neg) - 1\n                else:\n                    ans += len(pos) - 1\n            elif closest < 0:\n                ans += len(pos)\n            else:\n                ans += len(neg)\n            if closest < 0:\n                neg.pop()\n            else:\n                pos.pop()\n    print(ans)", "from sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom math import ceil\nfrom copy import deepcopy\nfrom collections import deque\nfor test in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    voca = []\n    doco = {}\n    for i in range(n):\n        ar = list(map(int, stdin.readline().split()))\n        voca.append(sorted(ar[1:]))\n        for j in voca[-1]:\n            if abs(j) in doco:\n                doco[abs(j)] += 1\n            else:\n                doco[abs(j)] = 1\n    asdfe = 0\n    for i in doco.values():\n        if i > 1:\n            asdfe += 1\n    for i in range(n):\n        for j in range(len(voca[i])):\n            if doco[abs(voca[i][j])] <= 1:\n                if voca[i][j] > 0:\n                    asdfe += bisect_left(voca[i], -voca[i][j])\n                else:\n                    asdfe += len(voca[i]) - bisect_right(voca[i], -voca[i][j])\n            elif voca[i][j] > 0:\n                asdfe += len(voca[i]) - (j + 1)\n            else:\n                asdfe += j\n    print(asdfe)", "from sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom math import ceil\nfrom copy import deepcopy\nfrom collections import deque\nfor test in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    voca = []\n    doco = {}\n    for i in range(n):\n        ar = list(map(int, stdin.readline().split()))\n        voca.append(sorted(ar[1:]))\n        for j in voca[-1]:\n            if abs(j) in doco:\n                doco[abs(j)] += 1\n            else:\n                doco[abs(j)] = 1\n    asdfe = 0\n    for i in doco.values():\n        if i > 1:\n            asdfe += 1\n    for i in range(n):\n        for j in range(len(voca[i])):\n            if doco[abs(voca[i][j])] <= 1:\n                if voca[i][j] > 0:\n                    asdfe += bisect_left(voca[i], -voca[i][j])\n                else:\n                    asdfe += len(voca[i]) - bisect_right(voca[i], -voca[i][j])\n            elif voca[i][j] > 0:\n                asdfe += len(voca[i]) - (j + 1)\n            else:\n                asdfe += j\n    print(asdfe)", "def arr():\n    return list(map(int, input().split()))\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    ants = []\n    rem = []\n    for i in range(n):\n        (m, *pos) = arr()\n        rem.append([0, 0])\n        for x in pos:\n            if x > 0:\n                ants.append((x, i, 0))\n                rem[-1][0] += 1\n            else:\n                ants.append((-x, i, 1))\n                rem[-1][1] += 1\n    ants.sort()\n    n_ants = len(ants)\n    ans = 0\n    i = 0\n    while i < n_ants:\n        a = [ants[i]]\n        i += 1\n        while i < n_ants and ants[i][0] == a[0][0]:\n            a.append(ants[i])\n            i += 1\n        if len(a) > 1:\n            ans += 1\n            for ant in a:\n                rem[ant[1]][ant[2]] -= 1\n                ans += rem[ant[1]][ant[2]]\n        else:\n            ant = a[0]\n            rem[ant[1]][ant[2]] -= 1\n            ans += rem[ant[1]][1 - ant[2]]\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    lines = []\n    ans = 0\n    maps = dict()\n    for i in range(n):\n        m = list(map(int, input().split()))\n        lis = m[1:]\n        for val in lis:\n            if abs(val) in maps:\n                maps[abs(val)] += 1\n            else:\n                maps[abs(val)] = 1\n        lines.append(lis)\n    for (key, val) in maps.items():\n        if val > 1:\n            ans += 1\n    for line in lines:\n        neg = []\n        pos = []\n        for i in line:\n            if i < 0:\n                neg.append(i)\n            else:\n                pos.append(i)\n        pos.sort(reverse=True)\n        while True:\n            closest = 0\n            if len(neg) <= 0 and len(pos) <= 0:\n                break\n            elif len(neg) == 0:\n                closest = pos[-1]\n            elif len(pos) == 0:\n                closest = neg[-1]\n            else:\n                closest = neg[-1] if abs(neg[-1]) < pos[-1] else pos[-1]\n            if closest < 0:\n                if maps[abs(closest)] > 1:\n                    ans += len(neg) - 1\n                else:\n                    ans += len(pos)\n            elif maps[abs(closest)] > 1:\n                ans += len(pos) - 1\n            else:\n                ans += len(neg)\n            if closest < 0:\n                neg.pop(-1)\n            else:\n                pos.pop(-1)\n    print(ans)", "from collections import defaultdict\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    lines = []\n    for line in range(n):\n        xx = [int(i) for i in input().split()]\n        m = xx[0]\n        A = xx[1:]\n        lines.append(A)\n    ans = 0\n    universal_ants_away_from_origin_by = defaultdict(int)\n    unique_distances = []\n    for line in lines:\n        for ant in line:\n            universal_ants_away_from_origin_by[abs(ant)] += 1\n            if universal_ants_away_from_origin_by[abs(ant)] == 1:\n                unique_distances.append(abs(ant))\n    for line in lines:\n        neg = 0\n        pos = 0\n        line_state = []\n        for point in line:\n            if point > 0:\n                pos += 1\n                line_state.append([point, 1])\n            else:\n                neg += 1\n                line_state.append([abs(point), -1])\n        line_state.sort()\n        for (point, sign) in line_state:\n            if sign == 1:\n                pos -= 1\n            else:\n                neg -= 1\n            if universal_ants_away_from_origin_by[point] > 1:\n                if sign == 1:\n                    ans += pos\n                else:\n                    ans += neg\n            elif sign == 1:\n                ans += neg\n            else:\n                ans += pos\n    for pt in universal_ants_away_from_origin_by:\n        if universal_ants_away_from_origin_by[pt] > 1:\n            ans += 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    lines = []\n    dist = {}\n    for _ in range(n):\n        temp = list(map(int, input().split()))\n        lines.append(temp[1:])\n        for i in temp[1:]:\n            dist[abs(i)] = dist.get(abs(i), 0) + 1\n    res = 0\n    for i in range(n):\n        pos = 0\n        neg = 0\n        line = []\n        for j in lines[i]:\n            if j < 0:\n                neg += 1\n                line.append([abs(j), -1])\n            else:\n                pos += 1\n                line.append([abs(j), 1])\n        line.sort()\n        for j in line:\n            if j[1] == 1:\n                pos -= 1\n            else:\n                neg -= 1\n            if dist[j[0]] > 1:\n                if j[1] == 1:\n                    res += pos\n                else:\n                    res += neg\n            elif j[1] == -1:\n                res += pos\n            else:\n                res += neg\n    for i in dist:\n        if dist[i] > 1:\n            res += 1\n    print(res)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 1:\n        r = list(map(int, input().split()))\n        (cp, cn) = (0, 0)\n        for i in range(1, len(r)):\n            if r[i] < 0:\n                cn += 1\n            else:\n                cp += 1\n        print(cp * cn)\n    else:\n        lines = []\n        distances = []\n        d = defaultdict(lambda : 0)\n        for _ in range(n):\n            l = list(map(int, input().split()))\n            for i in l[1:]:\n                d[abs(i)] += 1\n                if d[abs(i)] == 1:\n                    distances.append(abs(i))\n            lines.append(l[1:])\n        total = 0\n        for line in lines:\n            s = []\n            (cp, cn) = (0, 0)\n            for e in line:\n                if e > 0:\n                    cp += 1\n                    s.append((e, 1))\n                else:\n                    cn += 1\n                    s.append((abs(e), -1))\n            s = sorted(s, key=lambda x: x[0])\n            for (x, y) in s:\n                if y == -1:\n                    cn -= 1\n                else:\n                    cp -= 1\n                if d[x] > 1:\n                    if y == -1:\n                        total += cn\n                    else:\n                        total += cp\n                elif y == 1:\n                    total += cn\n                else:\n                    total += cp\n        for point in distances:\n            if d[point] > 1:\n                total += 1\n        print(total)", "import sys\n\ndef getInput():\n    return sys.stdin.readline().strip()\n\ndef getInt():\n    return int(getInput())\n\ndef getInts():\n    return map(int, getInput().split())\n\ndef getArray():\n    return list(getInts())\ntc = getInt()\nfor _ in range(tc):\n    n = getInt()\n    lines = []\n    for __ in range(n):\n        lines.append(getArray()[1:])\n    mp = dict()\n    for line in lines:\n        for ant in line:\n            if abs(ant) in mp:\n                mp[abs(ant)] += 1\n            else:\n                mp[abs(ant)] = 1\n    ans = 0\n    for i in mp.values():\n        if i >= 2:\n            ans += 1\n    for line in lines:\n        neg = []\n        pos = []\n        for ant in line:\n            if ant < 0:\n                neg.append(ant)\n            else:\n                pos.append(ant)\n        pos.reverse()\n        while True:\n            try:\n                if abs(neg[-1]) < pos[-1]:\n                    closest = neg[-1]\n                else:\n                    closest = pos[-1]\n            except:\n                if not neg and (not pos):\n                    break\n                if not neg:\n                    closest = pos[-1]\n                if not pos:\n                    closest = neg[-1]\n            if mp[abs(closest)] >= 2:\n                if closest < 0:\n                    ans += len(neg) - 1\n                else:\n                    ans += len(pos) - 1\n            elif closest < 0:\n                ans += len(pos)\n            else:\n                ans += len(neg)\n            if closest < 0:\n                neg.pop()\n            else:\n                pos.pop()\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    ants = []\n    dist = {}\n    ans = 0\n    for i in range(n):\n        mi = list(map(int, input().split()))\n        m = mi.pop(0)\n        (pos, neg) = ([], [])\n        for j in range(m):\n            d = mi[j]\n            if abs(d) in dist:\n                dist[abs(d)] += 1\n            else:\n                dist[abs(d)] = 1\n            if d > 0:\n                pos.append(d)\n            else:\n                neg.append(d)\n        pos.sort(reverse=True)\n        neg.sort()\n        ants.append([pos, neg])\n    for i in dist:\n        if dist[i] > 1:\n            ans += 1\n    for i in range(n):\n        (pos, neg) = ants[i]\n        while len(pos) > 0 and len(neg) > 0:\n            if pos[-1] < abs(neg[-1]):\n                a = pos.pop()\n                if dist[a] > 1:\n                    ans += len(pos)\n                else:\n                    ans += len(neg)\n            else:\n                a = neg.pop()\n                if dist[abs(a)] > 1:\n                    ans += len(neg)\n                else:\n                    ans += len(pos)\n        while len(pos) > 0:\n            a = pos.pop()\n            if dist[a] > 1:\n                ans += len(pos)\n        while len(neg) > 0:\n            a = neg.pop()\n            if dist[abs(a)] > 1:\n                ans += len(neg)\n    print(ans)", "t = int(input())\nt1 = 0\nwhile t1 < t:\n    n = int(input())\n    d = {}\n    l = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        l.append(a)\n        for j in range(1, a[0] + 1):\n            if abs(a[j]) not in d:\n                d[abs(a[j])] = []\n                if a[j] > 0:\n                    d[abs(a[j])].append([1, i, j - 1])\n                else:\n                    d[abs(a[j])].append([-1, i, j - 1])\n            elif a[j] > 0:\n                d[abs(a[j])].append([1, i, j - 1])\n            else:\n                d[abs(a[j])].append([-1, i, j - 1])\n    ans = 0\n    l2 = []\n    for j1 in range(n):\n        l2.append([0, 0])\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            ans += 1\n            for k1 in d[k]:\n                if k1[0] == -1:\n                    pos = k1[2]\n                    ans += pos\n                    l_no = k1[1]\n                    l2[l_no][1] += 1\n                else:\n                    l_no = k1[1]\n                    pos = k1[2] - l2[l_no][0] - l2[l_no][1]\n                    total = l[l_no][0] - l2[l_no][0] - l2[l_no][1]\n                    ans += total - pos - 1\n                    l2[l_no][0] += 1\n        elif d[k][0][0] == -1:\n            l_no = d[k][0][1]\n            s1 = l2[l_no][0] + l2[l_no][1]\n            total = l[l_no][0] - s1\n            ans += total - d[k][0][2] - 1\n            l2[l_no][1] += 1\n        else:\n            l_no = d[k][0][1]\n            s1 = l2[l_no][0] + l2[l_no][1]\n            total = l[l_no][0] - s1\n            pos = d[k][0][2] - s1\n            ans += pos\n            l2[l_no][0] += 1\n    print(ans)\n    t1 += 1", "for _ in range(int(input())):\n    n = int(input())\n    ants = []\n    dist = {}\n    ans = 0\n    for i in range(n):\n        mx = list(map(int, input().split()))\n        m = mx[0]\n        (pos, neg) = ([], [])\n        for j in range(1, m + 1):\n            d = mx[j]\n            if abs(d) in dist:\n                dist[abs(d)] += 1\n            else:\n                dist[abs(d)] = 1\n            if d > 0:\n                pos.append(d)\n            else:\n                neg.append(d)\n        pos.sort(reverse=True)\n        neg.sort()\n        ants.append([pos, neg])\n    for i in dist:\n        if dist[i] > 1:\n            ans += 1\n    for i in range(n):\n        (pos, neg) = ants[i]\n        while len(pos) > 0 and len(neg) > 0:\n            if pos[-1] < abs(neg[-1]):\n                a = pos.pop()\n                if dist[a] > 1:\n                    ans += len(pos)\n                else:\n                    ans += len(neg)\n            else:\n                a = neg.pop()\n                if dist[abs(a)] > 1:\n                    ans += len(neg)\n                else:\n                    ans += len(pos)\n        while len(pos) > 0:\n            a = pos.pop()\n            if dist[a] > 1:\n                ans += len(pos)\n        while len(neg) > 0:\n            a = neg.pop()\n            if dist[abs(a)] > 1:\n                ans += len(neg)\n    print(ans)", "def solve(N, Xneg, Xpos):\n    if N == 1:\n        return len(Xneg[1]) * len(Xpos[1])\n    distances = {}\n    for i in range(1, N + 1):\n        for x in Xneg[i]:\n            if x not in distances:\n                distances[x] = []\n            distances[x].append(-i)\n        for x in Xpos[i]:\n            if x not in distances:\n                distances[x] = []\n            distances[x].append(i)\n    positions = sorted([x for x in distances])\n    collisions = 0\n    for x in positions:\n        if len(distances[x]) > 1:\n            collisions += 1\n            for line in distances[x]:\n                if line > 0:\n                    collisions += len(Xpos[line]) - 1\n                    Xpos[line].pop(0)\n                if line < 0:\n                    collisions += len(Xneg[-line]) - 1\n                    Xneg[-line].pop(0)\n        else:\n            line = distances[x][0]\n            if line > 0:\n                collisions += len(Xneg[line])\n                Xpos[line].pop(0)\n            if line < 0:\n                collisions += len(Xpos[-line])\n                Xneg[-line].pop(0)\n    return collisions\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    N = int(input().strip())\n    (Xpos, Xneg) = ([None], [None])\n    for line in range(N):\n        inp = list(map(int, input().strip().split()))\n        M = inp[0]\n        Xpos.append(sorted([x for x in inp[1:] if x >= 0]))\n        Xneg.append(sorted([-x for x in inp[1:] if x <= 0]))\n    print(solve(N, Xneg, Xpos))", "import sys\nMOD = 1000000007\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_int():\n    return int(sys.stdin.readline())\n\ndef get_line():\n    return sys.stdin.readline().strip()\n\ndef write_line(out):\n    return sys.stdout.write(str(out) + '\\n')\n\ndef count_pos_and_neg(arr):\n    pos = 0\n    neg = 0\n    for val in arr:\n        if val > 0:\n            pos += 1\n        else:\n            neg += 1\n    return [pos, neg]\n\ndef make_tuples(arr):\n    res = []\n    for val in arr:\n        if val < 0:\n            res.append((abs(val), -1))\n        else:\n            res.append((abs(val), 1))\n    res.sort(key=lambda pair: pair[0])\n    return res\n\ndef solve():\n    n = get_int()\n    lines = []\n    for i in range(n):\n        temp = list(get_ints())\n        temp.pop(0)\n        lines.append(temp)\n    equidistant_points = dict()\n    for line in lines:\n        for val in line:\n            if abs(val) in equidistant_points:\n                equidistant_points[abs(val)] += 1\n            else:\n                equidistant_points[abs(val)] = 1\n    ans = 0\n    for line in lines:\n        sign_count = count_pos_and_neg(line)\n        temp = make_tuples(line)\n        for val in temp:\n            if val[1] == 1:\n                sign_count[0] -= 1\n            else:\n                sign_count[1] -= 1\n            if equidistant_points[val[0]] > 1:\n                if val[1] == 1:\n                    ans += sign_count[0]\n                else:\n                    ans += sign_count[1]\n            elif val[1] == 1:\n                ans += sign_count[1]\n            else:\n                ans += sign_count[0]\n    for val in equidistant_points.values():\n        if val > 1:\n            ans += 1\n    return ans\nt = get_int()\nwhile t:\n    write_line(solve())\n    t -= 1", "for i in range(int(input())):\n    N = int(input())\n    lines = []\n    for i in range(N):\n        curr = list(map(int, input().split()))\n        lines.append(curr[1:])\n    frequency = {}\n    occur = {}\n    pos = []\n    for i in lines:\n        for j in i:\n            pos.append(abs(j))\n    for i in pos:\n        if i in occur:\n            occur[i] += 1\n        else:\n            occur[i] = 1\n    for i in occur:\n        if occur[i] > 1:\n            frequency[i] = occur[i]\n    ans = 0\n    for curr_line in lines:\n        totalants = len(curr_line)\n        d = {}\n        for i in curr_line:\n            d[i] = True\n        imaginary = {}\n        for i in d:\n            if -i not in d:\n                imaginary[-i] = True\n        currNC = 0\n        currC = 0\n        colliding = {}\n        noncolliding = {}\n        indices = []\n        for i in imaginary:\n            indices.append(i)\n        indices.extend(curr_line)\n        indices.append(0)\n        indices.sort()\n        for ind in indices:\n            if ind in imaginary or ind == 0:\n                colliding[ind] = currC\n                noncolliding[ind] = currNC\n            elif abs(ind) in frequency:\n                colliding[ind] = currC\n                noncolliding[ind] = currNC\n                currC += 1\n            else:\n                colliding[ind] = currC\n                noncolliding[ind] = currNC\n                currNC += 1\n        for ind in curr_line:\n            NC4C4 = totalants - noncolliding[abs(ind)] - colliding[abs(ind)]\n            NC3 = noncolliding[abs(ind)] - noncolliding[0]\n            C3 = colliding[abs(ind)] - colliding[0]\n            if abs(ind) in d:\n                if abs(ind) not in frequency:\n                    NC3 -= 1\n                else:\n                    C3 -= 1\n            NC2 = noncolliding[0] - noncolliding[-abs(ind)]\n            C2 = colliding[0] - colliding[-abs(ind)]\n            NC1 = noncolliding[-abs(ind)]\n            C1 = colliding[-abs(ind)]\n            if -abs(ind) in d:\n                if abs(ind) not in frequency:\n                    NC1 -= 1\n                else:\n                    C1 -= 1\n            LNC = NC4C4 + NC3 + C2\n            RNC = NC1 + C1 + NC2 + C3\n            LC = NC1 + C1 + NC3 + C2\n            RC = NC4C4 + NC2 + C3\n            if ind < 0:\n                if abs(ind) in frequency:\n                    ans += LC\n                else:\n                    ans += LNC\n            elif abs(ind) in frequency:\n                ans += RC\n            else:\n                ans += RNC\n    ans = ans // 2\n    ans += len(frequency)\n    print(ans)", "from collections import Counter\nfrom bisect import bisect_right as br\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        loc = list(input().split())\n        m = int(loc[0])\n        loc.pop(0)\n        coll = 0\n        l = 0\n        for i in range(m):\n            loc[i] = int(loc[i])\n            if loc[i] < 0:\n                l += 1\n            else:\n                coll += l\n        print(coll)\n    else:\n        (lines, m) = ([], [])\n        pos = []\n        (occr, occ) = ({}, {})\n        lr = {}\n        di = []\n        for i in range(n):\n            li = list(map(int, input().split()))\n            m1 = li.pop(0)\n            m.append(m1)\n            k1 = br(li, 0)\n            pos.append([k1, m1 - k1])\n            d = []\n            for j in range(m1):\n                k = abs(li[j])\n                if li[j] < 0:\n                    try:\n                        lr[k] += j\n                    except:\n                        lr[k] = j\n                else:\n                    try:\n                        lr[k] += m1 - j - 1\n                    except:\n                        lr[k] = m1 - j - 1\n                try:\n                    occr[k] += 1\n                except:\n                    occr[k] = 1\n                    d.append(li[j])\n            d = li.copy()\n            d = sorted(d, key=lambda x: abs(x))\n            di.append(d)\n        ans = 0\n        for i in range(n):\n            for el in di[i]:\n                if occr[abs(el)] == 1:\n                    if el < 0:\n                        ans += pos[i][1]\n                        pos[i][0] -= 1\n                    else:\n                        ans += pos[i][0]\n                        pos[i][1] -= 1\n                elif el < 0:\n                    pos[i][0] -= 1\n                else:\n                    pos[i][1] -= 1\n        for i in occr:\n            if occr[i] > 1:\n                ans += lr[i] + 1\n        print(ans)", "test = int(input())\nfor i in range(0, test):\n    lines = int(input())\n    input_dict = {}\n    answer = 0\n    frequencies = {}\n    for j in range(0, lines):\n        a = list(map(int, input().split()))\n        a.pop(0)\n        neg_list = []\n        pos_list = []\n        for p in a:\n            if p < 0:\n                neg_list.append(p)\n            else:\n                pos_list.append(p)\n            try:\n                frequencies[abs(p)] += 1\n            except:\n                frequencies[abs(p)] = 1\n        pos_list.reverse()\n        input_dict[j] = {'negatives': neg_list, 'positives': pos_list}\n    for j in range(0, lines):\n        new_dict = input_dict[j]\n        negatives = new_dict['negatives']\n        positives = new_dict['positives']\n        while True:\n            if len(negatives) == 0 and len(positives) == 0:\n                break\n            elif len(negatives) == 0:\n                closest = positives[-1]\n            elif len(positives) == 0:\n                closest = negatives[-1]\n            else:\n                closest = positives[-1] if abs(negatives[-1]) > positives[-1] else negatives[-1]\n            if closest < 0:\n                if frequencies[abs(closest)] > 1:\n                    answer = answer + len(negatives) - 1\n                else:\n                    answer = answer + len(positives)\n                negatives.pop()\n            else:\n                if frequencies[closest] > 1:\n                    answer = answer + len(positives) - 1\n                else:\n                    answer = answer + len(negatives)\n                positives.pop()\n    for key in frequencies.keys():\n        if frequencies[key] > 1:\n            answer += 1\n    print(answer)", "import sys\n\ndef main():\n    pass\n\ndef binary(n):\n    return bin(n).replace('0b', '')\n\ndef decimal(s):\n    return int(s, 2)\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return p\n\ndef isPrime(n):\n    if n == 1:\n        return False\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if n % i == 0:\n                return False\n        return True\n\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n\ndef stl(s):\n    l = list(s)\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if s == target:\n        return arr\n    if s >= target:\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if ans:\n            return ans\nmod = int(1000000000.0) + 7\n\ndef ssinp():\n    return sys.stdin.readline().strip()\n\ndef iinp():\n    return int(input())\n\ndef nninp():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef llinp():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef p(xyz):\n    print(xyz)\n\ndef p2(a, b):\n    print(a, b)\nimport math\nfrom collections import OrderedDict\nfor _ in range(iinp()):\n    n = iinp()\n    d = {}\n    ans = 0\n    l = []\n    for __ in range(n):\n        m = llinp()\n        pos = neg = 0\n        for i in range(len(m)):\n            if i == 0:\n                pass\n            else:\n                if m[i] > 0:\n                    pos += 1\n                else:\n                    neg += 1\n                if abs(m[i]) in d:\n                    d[abs(m[i])] += 1\n                else:\n                    d[abs(m[i])] = 1\n        m.append(pos)\n        m.append(neg)\n        l.append(m)\n    for c in l:\n        pos = c[-2]\n        neg = c[-1]\n        c[0] = 0\n        c[-1] = 0\n        c[-2] = 0\n        s = set(c)\n        l1 = sorted(c, key=abs)\n        for i in l1:\n            if i == 0:\n                pass\n            elif i > 0:\n                if -1 * i in s:\n                    ans += neg\n                    pos -= 1\n                elif d[abs(i)] > 1:\n                    pos -= 1\n                    ans += pos\n                else:\n                    ans += neg\n                    pos -= 1\n            elif -1 * i in s:\n                ans += pos - 1\n                neg -= 1\n            elif d[abs(i)] > 1:\n                neg -= 1\n                ans += neg\n            else:\n                ans += pos\n                neg -= 1\n    for key in d:\n        if d[key] > 1:\n            ans += 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        leng = []\n        addi = []\n        sub = []\n        for i in range(n):\n            temp = list(map(int, input().split()))\n            leng = temp[1:]\n            for i in range(len(leng)):\n                if leng[i] > 0:\n                    addi.append(leng[i])\n                else:\n                    sub.append(leng[i])\n        print(len(addi) * len(sub))\n    else:\n        dicti = {}\n        l = []\n        for i in range(n):\n            Mi = list(map(int, input().split()))\n            posi = 0\n            for j in range(Mi[0]):\n                if Mi[j + 1] < 0:\n                    ck = 1\n                    posi = j + 1\n                if Mi[j + 1] > 0:\n                    nv = 1\n                else:\n                    nv = -1\n                temp = [i, nv]\n                if abs(Mi[j + 1]) in dicti:\n                    dicti[abs(Mi[j + 1])].append(temp)\n                else:\n                    dicti[abs(Mi[j + 1])] = []\n                    dicti[abs(Mi[j + 1])].append(temp)\n            Mi.append(posi)\n            l.append(Mi)\n        dynam = {}\n        for (ke, va) in sorted(dicti.items()):\n            dynam[ke] = va\n        countt = 0\n        for i in dynam:\n            le = len(dynam[i])\n            if le == 0:\n                continue\n            elif le > 1:\n                for j in range(le):\n                    tep = l[dynam[i][j][0]][-1]\n                    if dynam[i][j][1] == -1:\n                        l[dynam[i][j][0]].pop(tep)\n                        l[dynam[i][j][0]][-1] -= 1\n                        countt += l[dynam[i][j][0]][-1]\n                        l[dynam[i][j][0]][0] -= 1\n                    else:\n                        l[dynam[i][j][0]].pop(tep + 1)\n                        l[dynam[i][j][0]][0] -= 1\n                        countt += l[dynam[i][j][0]][0] - l[dynam[i][j][0]][-1]\n                countt += 1\n            else:\n                tep = l[dynam[i][0][0]][-1]\n                if dynam[i][0][1] == -1:\n                    countt += l[dynam[i][0][0]][0] - l[dynam[i][0][0]][-1]\n                    l[dynam[i][0][0]].pop(tep)\n                    l[dynam[i][0][0]][-1] -= 1\n                    l[dynam[i][0][0]][0] -= 1\n                else:\n                    countt += l[dynam[i][0][0]][-1]\n                    l[dynam[i][0][0]].pop(tep + 1)\n                    l[dynam[i][0][0]][0] -= 1\n        print(countt)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        leng = []\n        addi = []\n        sub = []\n        for i in range(n):\n            temp = list(map(int, input().split()))\n            leng = temp[1:]\n            for i in range(len(leng)):\n                if leng[i] > 0:\n                    addi.append(leng[i])\n                else:\n                    sub.append(leng[i])\n        print(len(addi) * len(sub))\n    else:\n        dicti = {}\n        l = []\n        for i in range(n):\n            Mi = list(map(int, input().split()))\n            posi = 0\n            for j in range(Mi[0]):\n                if Mi[j + 1] < 0:\n                    ck = 1\n                    posi = j + 1\n                if Mi[j + 1] > 0:\n                    nv = 1\n                else:\n                    nv = -1\n                temp = [i, nv]\n                if abs(Mi[j + 1]) in dicti:\n                    dicti[abs(Mi[j + 1])].append(temp)\n                else:\n                    dicti[abs(Mi[j + 1])] = []\n                    dicti[abs(Mi[j + 1])].append(temp)\n            Mi.append(posi)\n            l.append(Mi)\n        dynam = {}\n        for (ke, va) in sorted(dicti.items()):\n            dynam[ke] = va\n        countt = 0\n        for i in dynam:\n            le = len(dynam[i])\n            if le == 0:\n                continue\n            elif le > 1:\n                for j in range(le):\n                    tep = l[dynam[i][j][0]][-1]\n                    if dynam[i][j][1] == -1:\n                        l[dynam[i][j][0]].pop(tep)\n                        l[dynam[i][j][0]][-1] -= 1\n                        countt += l[dynam[i][j][0]][-1]\n                        l[dynam[i][j][0]][0] -= 1\n                    else:\n                        l[dynam[i][j][0]].pop(tep + 1)\n                        l[dynam[i][j][0]][0] -= 1\n                        countt += l[dynam[i][j][0]][0] - l[dynam[i][j][0]][-1]\n                countt += 1\n            else:\n                tep = l[dynam[i][0][0]][-1]\n                if dynam[i][0][1] == -1:\n                    countt += l[dynam[i][0][0]][0] - l[dynam[i][0][0]][-1]\n                    l[dynam[i][0][0]].pop(tep)\n                    l[dynam[i][0][0]][-1] -= 1\n                    l[dynam[i][0][0]][0] -= 1\n                else:\n                    countt += l[dynam[i][0][0]][-1]\n                    l[dynam[i][0][0]].pop(tep + 1)\n                    l[dynam[i][0][0]][0] -= 1\n        print(countt)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        le = []\n        plus = []\n        minu = []\n        for i in range(n):\n            temp = list(map(int, input().split()))\n            le = temp[1:]\n            for i in range(len(le)):\n                if le[i] > 0:\n                    plus.append(le[i])\n                else:\n                    minu.append(le[i])\n        print(len(plus) * len(minu))\n    else:\n        dic = {}\n        l = []\n        for i in range(n):\n            M = list(map(int, input().split()))\n            pos = 0\n            for j in range(M[0]):\n                if M[j + 1] < 0:\n                    ck = 1\n                    pos = j + 1\n                if M[j + 1] > 0:\n                    nv = 1\n                else:\n                    nv = -1\n                temp = [i, nv]\n                if abs(M[j + 1]) in dic:\n                    dic[abs(M[j + 1])].append(temp)\n                else:\n                    dic[abs(M[j + 1])] = []\n                    dic[abs(M[j + 1])].append(temp)\n            M.append(pos)\n            l.append(M)\n        dp = {}\n        for (k, v) in sorted(dic.items()):\n            dp[k] = v\n        cnt = 0\n        for i in dp:\n            le = len(dp[i])\n            if le == 0:\n                continue\n            elif le > 1:\n                for j in range(le):\n                    kk = l[dp[i][j][0]][-1]\n                    if dp[i][j][1] == -1:\n                        l[dp[i][j][0]].pop(kk)\n                        l[dp[i][j][0]][-1] -= 1\n                        cnt += l[dp[i][j][0]][-1]\n                        l[dp[i][j][0]][0] -= 1\n                    else:\n                        l[dp[i][j][0]].pop(kk + 1)\n                        l[dp[i][j][0]][0] -= 1\n                        cnt += l[dp[i][j][0]][0] - l[dp[i][j][0]][-1]\n                cnt += 1\n            else:\n                kk = l[dp[i][0][0]][-1]\n                if dp[i][0][1] == -1:\n                    cnt += l[dp[i][0][0]][0] - l[dp[i][0][0]][-1]\n                    l[dp[i][0][0]].pop(kk)\n                    l[dp[i][0][0]][-1] -= 1\n                    l[dp[i][0][0]][0] -= 1\n                else:\n                    cnt += l[dp[i][0][0]][-1]\n                    l[dp[i][0][0]].pop(kk + 1)\n                    l[dp[i][0][0]][0] -= 1\n        print(cnt)", "from sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    di = {}\n    orig = {}\n    abtmpj = 0\n    temp = 0\n    for i in range(n):\n        tmp = list(map(int, stdin.readline().split()))\n        m = tmp[0]\n        tmp = tmp[1:]\n        for j in range(0, m):\n            abtmpj = abs(tmp[j])\n            if abtmpj not in di:\n                if tmp[j] > 0:\n                    di[abtmpj] = bisect_left(tmp, -abtmpj)\n                    orig[abtmpj] = m - j - 1\n                else:\n                    temp = bisect_left(tmp, abtmpj)\n                    if temp < m and tmp[temp] == abtmpj:\n                        di[abtmpj] = -1\n                    else:\n                        di[abtmpj] = m - temp\n                    orig[abtmpj] = j\n            else:\n                if tmp[j] > 0:\n                    orig[abtmpj] += m - j - 1\n                else:\n                    orig[abtmpj] += j\n                di[abtmpj] = orig[abtmpj] + 1\n    ans = 0\n    for k in di:\n        ans += di[k]\n    print(ans)", "from sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom math import ceil\nfrom copy import deepcopy\nfrom collections import deque\nfor test in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    voca = []\n    doco = {}\n    for i in range(n):\n        ar = list(map(int, stdin.readline().split()))\n        voca.append(sorted(ar[1:]))\n        for j in voca[-1]:\n            if abs(j) in doco:\n                doco[abs(j)] += 1\n            else:\n                doco[abs(j)] = 1\n    asdfe = 0\n    for i in doco.values():\n        if i > 1:\n            asdfe += 1\n    for i in range(n):\n        for j in range(len(voca[i])):\n            if doco[abs(voca[i][j])] <= 1:\n                if voca[i][j] > 0:\n                    asdfe += bisect_left(voca[i], -voca[i][j])\n                else:\n                    asdfe += len(voca[i]) - bisect_right(voca[i], -voca[i][j])\n            elif voca[i][j] > 0:\n                asdfe += len(voca[i]) - (j + 1)\n            else:\n                asdfe += j\n    print(asdfe)", "for i in range(int(input())):\n    N = int(input())\n    lines = []\n    for i in range(N):\n        curr = list(map(int, input().split()))\n        lines.append(curr[1:])\n    frequency = {}\n    occur = {}\n    pos = []\n    for i in lines:\n        for j in i:\n            pos.append(abs(j))\n    for i in pos:\n        if i in occur:\n            occur[i] += 1\n        else:\n            occur[i] = 1\n    for i in occur:\n        if occur[i] > 1:\n            frequency[i] = occur[i]\n    ans = 0\n    for curr_line in lines:\n        totalants = len(curr_line)\n        d = {}\n        for i in curr_line:\n            d[i] = True\n        imaginary = {}\n        for i in d:\n            if -i not in d:\n                imaginary[-i] = True\n        currNC = 0\n        currC = 0\n        colliding = {}\n        noncolliding = {}\n        indices = []\n        for i in imaginary:\n            indices.append(i)\n        indices.extend(curr_line)\n        indices.append(0)\n        indices.sort()\n        for ind in indices:\n            if ind in imaginary or ind == 0:\n                colliding[ind] = currC\n                noncolliding[ind] = currNC\n            elif abs(ind) in frequency:\n                colliding[ind] = currC\n                noncolliding[ind] = currNC\n                currC += 1\n            else:\n                colliding[ind] = currC\n                noncolliding[ind] = currNC\n                currNC += 1\n        for ind in curr_line:\n            NC4C4 = totalants - noncolliding[abs(ind)] - colliding[abs(ind)]\n            NC3 = noncolliding[abs(ind)] - noncolliding[0]\n            C3 = colliding[abs(ind)] - colliding[0]\n            if abs(ind) in d:\n                if abs(ind) not in frequency:\n                    NC3 -= 1\n                else:\n                    C3 -= 1\n            NC2 = noncolliding[0] - noncolliding[-abs(ind)]\n            C2 = colliding[0] - colliding[-abs(ind)]\n            NC1 = noncolliding[-abs(ind)]\n            C1 = colliding[-abs(ind)]\n            if -abs(ind) in d:\n                if abs(ind) not in frequency:\n                    NC1 -= 1\n                else:\n                    C1 -= 1\n            LNC = NC4C4 + NC3 + C2\n            RNC = NC1 + C1 + NC2 + C3\n            LC = NC1 + C1 + NC3 + C2\n            RC = NC4C4 + NC2 + C3\n            if ind < 0:\n                if abs(ind) in frequency:\n                    ans += LC\n                else:\n                    ans += LNC\n            elif abs(ind) in frequency:\n                ans += RC\n            else:\n                ans += RNC\n    ans = ans // 2\n    ans += len(frequency)\n    print(ans)", "import sys\n\ndef main():\n    pass\n\ndef binary(n):\n    return bin(n).replace('0b', '')\n\ndef decimal(s):\n    return int(s, 2)\n\ndef pow2(n):\n    p = 0\n    while n > 1:\n        n //= 2\n        p += 1\n    return p\n\ndef isPrime(n):\n    if n == 1:\n        return False\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if n % i == 0:\n                return False\n        return True\n\ndef lts(l):\n    s = ''.join(map(str, l))\n    return s\n\ndef stl(s):\n    l = list(s)\n    return l\n\ndef sq(a, target, arr=[]):\n    s = sum(arr)\n    if s == target:\n        return arr\n    if s >= target:\n        return\n    for i in range(len(a)):\n        n = a[i]\n        remaining = a[i + 1:]\n        ans = sq(remaining, target, arr + [n])\n        if ans:\n            return ans\nmod = int(1000000000.0) + 7\n\ndef ssinp():\n    return sys.stdin.readline().strip()\n\ndef iinp():\n    return int(input())\n\ndef nninp():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef llinp():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef p(xyz):\n    print(xyz)\n\ndef p2(a, b):\n    print(a, b)\nimport math\nfrom collections import OrderedDict\nfor _ in range(iinp()):\n    n = iinp()\n    d = {}\n    ans = 0\n    l = []\n    for __ in range(n):\n        m = llinp()\n        pos = neg = 0\n        for i in range(len(m)):\n            if i == 0:\n                pass\n            else:\n                if m[i] > 0:\n                    pos += 1\n                else:\n                    neg += 1\n                if abs(m[i]) in d:\n                    d[abs(m[i])] += 1\n                else:\n                    d[abs(m[i])] = 1\n        m.append(pos)\n        m.append(neg)\n        l.append(m)\n    for c in l:\n        pos = c[-2]\n        neg = c[-1]\n        c[0] = 0\n        c[-1] = 0\n        c[-2] = 0\n        s = set(c)\n        l1 = sorted(c, key=abs)\n        for i in l1:\n            if i == 0:\n                pass\n            elif i > 0:\n                if -1 * i in s:\n                    ans += neg\n                    pos -= 1\n                elif d[abs(i)] > 1:\n                    pos -= 1\n                    ans += pos\n                else:\n                    ans += neg\n                    pos -= 1\n            elif -1 * i in s:\n                ans += pos - 1\n                neg -= 1\n            elif d[abs(i)] > 1:\n                neg -= 1\n                ans += neg\n            else:\n                ans += pos\n                neg -= 1\n    for key in d:\n        if d[key] > 1:\n            ans += 1\n    print(ans)", "def getints():\n    return list(map(int, input().split()))\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    ants = []\n    rem = []\n    for i in range(n):\n        (m, *pos) = getints()\n        rem.append([0, 0])\n        for x in pos:\n            if x > 0:\n                ants.append((x, i, 0))\n                rem[-1][0] += 1\n            else:\n                ants.append((-x, i, 1))\n                rem[-1][1] += 1\n    ants.sort()\n    ans = 0\n    n_ants = len(ants)\n    i = 0\n    while i < n_ants:\n        a = [ants[i]]\n        i += 1\n        while i < n_ants and ants[i][0] == a[0][0]:\n            a.append(ants[i])\n            i += 1\n        if len(a) > 1:\n            ans += 1\n            for ant in a:\n                rem[ant[1]][ant[2]] -= 1\n                ans += rem[ant[1]][ant[2]]\n        else:\n            ant = a[0]\n            rem[ant[1]][ant[2]] -= 1\n            ans += rem[ant[1]][1 - ant[2]]\n    print(ans)", "def get_line_input():\n    return map(int, input().split())\ntests = int(input())\nwhile tests:\n    tests -= 1\n    n = int(input())\n    c = []\n    a = []\n    for i in range(n):\n        (m, *x) = get_line_input()\n        neg = 0\n        for p in x:\n            neg += p < 0\n            a.append((abs(p), i, p > 0))\n        c.append([neg, m - neg])\n    ans = 0\n    a.sort(reverse=True)\n    while len(a) > 0:\n        origin = []\n        p = a[-1][0]\n        while len(a) > 0 and p == a[-1][0]:\n            origin.append(a.pop())\n        if len(origin) == 1:\n            (_, line, flag) = origin[0]\n            c[line][flag] -= 1\n            ans += c[line][not flag]\n        else:\n            for (_, line, flag) in origin:\n                c[line][flag] -= 1\n                ans += c[line][flag]\n            ans += 1\n    print(ans)", "from collections import Counter\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    mat = []\n    noa = []\n    coun = Counter()\n    for i in range(n):\n        x = list(map(int, input().split()))\n        noa.append(x[0])\n        x = x[1:]\n        mat.append(x)\n        coun.update(x)\n    finalans = 0\n    for z in range(n):\n        a = mat[z]\n        a.sort()\n        j = 0\n        ll = noa[z]\n        while j < ll:\n            if a[j] > 0:\n                break\n            j += 1\n        x = a[0:j]\n        lx = j\n        y = a[j:]\n        ly = noa[z] - j\n        x.reverse()\n        kx = 0\n        ky = 0\n        i = 0\n        j = 0\n        while True:\n            if i >= lx and j >= ly:\n                break\n            elif i >= lx or j >= ly:\n                if i >= lx:\n                    if coun[y[j]] + coun[-1 * y[j]] > 1:\n                        finalans = finalans + ly - j - 1\n                        j += 1\n                    else:\n                        j += 1\n                elif coun[x[i]] + coun[-1 * x[i]] > 1:\n                    finalans = finalans + lx - i - 1\n                    i += 1\n                else:\n                    i += 1\n            elif x[i] == -1 * y[j]:\n                finalans = finalans + lx - i - 1 + ly - j - 1\n                i += 1\n                j += 1\n            elif y[j] > -1 * x[i]:\n                if coun[x[i]] + coun[-1 * x[i]] > 1:\n                    finalans = finalans + lx - i - 1\n                    i += 1\n                else:\n                    finalans = finalans + ly - j\n                    i += 1\n            elif y[j] < -1 * x[i]:\n                if coun[y[j]] + coun[-1 * y[j]] > 1:\n                    finalans = finalans + ly - j - 1\n                    j += 1\n                else:\n                    finalans = finalans + lx - i\n                    j += 1\n    count = Counter()\n    for (keys, items) in coun.items():\n        if keys < 0:\n            m = coun[keys]\n            keys = -1 * keys\n            count.update({keys: m})\n        else:\n            count.update({keys: coun[keys]})\n    for (keys, items) in count.items():\n        if items > 1:\n            finalans += 1\n    print(finalans)", "for _ in range(int(input())):\n    n = int(input())\n    lines = {}\n    (plus, minus) = ([0] * n, [0] * n)\n    for line in range(n):\n        for x in list(map(int, input().split()))[1:]:\n            if x > 0:\n                plus[line] += 1\n                if x in lines:\n                    lines[x][0].append(line)\n                else:\n                    lines[x] = [[line], []]\n            else:\n                minus[line] += 1\n                if -x in lines:\n                    lines[-x][1].append(line)\n                else:\n                    lines[-x] = [[], [line]]\n    answer = 0\n    for key in sorted(lines):\n        if len(lines[key][0]) + len(lines[key][1]) > 1:\n            answer += 1\n            for pos in lines[key][0]:\n                plus[pos] -= 1\n                answer += plus[pos]\n            for neg in lines[key][1]:\n                minus[neg] -= 1\n                answer += minus[neg]\n        elif len(lines[key][0]):\n            plus[lines[key][0][0]] -= 1\n            answer += minus[lines[key][0][0]]\n        else:\n            minus[lines[key][1][0]] -= 1\n            answer += plus[lines[key][1][0]]\n    print(answer)", "from math import log2\nimport bisect\nfrom bisect import bisect_left, bisect_right\nimport sys\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\ninf = float('inf')\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    matrix_rev = []\n    matrix_containing_dictionary = []\n    dict = defaultdict(int)\n    distance = defaultdict(int)\n    index = defaultdict(set)\n    answer = 0\n    for i in range(n):\n        l = list(map(int, input().split()))\n        m = l[0]\n        l.remove(l[0])\n        matrix.append(l)\n        matrix_rev.append([])\n        matrix_containing_dictionary.append(defaultdict(int))\n        for res in reversed(l):\n            matrix_containing_dictionary[-1][res] = 1\n            matrix_rev[-1].append(-res)\n        t1 = 0\n        t2 = 0\n        for j in l:\n            index[j].add(i)\n            if j > 0:\n                t1 += 1\n                dict[j] += 1\n                distance[j] += 1\n            else:\n                t2 += 1\n                dict[j] += 1\n                distance[-j] += 1\n        answer += t1 * t2\n    dict_copy = dict.copy()\n    for i in dict:\n        if dict_copy[i] + dict_copy[-i] > 1 and i > 0:\n            for j in index[i]:\n                index_got = bisect_right(matrix[j], i)\n                answer += len(matrix[j]) - index_got\n                index_got = bisect_right(matrix_rev[j], i)\n                answer -= len(matrix[j]) - index_got\n        if dict_copy[i] + dict_copy[-i] > 1 and i < 0:\n            for j in index[i]:\n                index_got = bisect_right(matrix[j], -i)\n                answer -= len(matrix[j]) - index_got\n                index_got = bisect_right(matrix_rev[j], -i)\n                answer += len(matrix[j]) - index_got\n    count = 0\n    for j in distance:\n        if distance[j] > 1:\n            answer += 1\n            for indices in index[j]:\n                if j in matrix_containing_dictionary[indices] and -j in matrix_containing_dictionary[indices]:\n                    count += 1\n    print(answer - count)", "from bisect import bisect\nfrom collections import Counter\n\ndef ant_collisions(lines):\n    c = Counter()\n    for line in lines:\n        c.update([abs(val) for val in line])\n    collision_times = {val for val in c if c[val] > 1}\n    collisions = len(collision_times)\n    for line in lines:\n        rightward = 0\n        leftward = 0\n        j = bisect(line, 0)\n        i = j - 1\n        while i >= 0 or j < len(line):\n            neg_val = None\n            pos_val = None\n            if i >= 0:\n                neg_val = line[i]\n                if neg_val >= 0:\n                    raise Exception\n            if j < len(line):\n                pos_val = line[j]\n                if pos_val <= 0:\n                    raise Exception\n            if neg_val is None:\n                vals = [pos_val]\n            elif pos_val is None:\n                vals = [neg_val]\n            elif abs(neg_val) < pos_val:\n                vals = [neg_val]\n            elif abs(neg_val) > pos_val:\n                vals = [pos_val]\n            else:\n                if abs(neg_val) != pos_val:\n                    raise Exception\n                vals = [neg_val, pos_val]\n            for val in vals:\n                if val < 0:\n                    collisions += leftward\n                else:\n                    collisions += rightward\n            for val in vals:\n                if abs(val) in collision_times:\n                    if val < 0:\n                        leftward += 1\n                    else:\n                        rightward += 1\n                elif val < 0:\n                    rightward += 1\n                else:\n                    leftward += 1\n            for val in vals:\n                if val < 0:\n                    i -= 1\n                else:\n                    j += 1\n    return collisions\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    lines = []\n    for _ in range(N):\n        (M, *X) = list(map(int, input().split()))\n        lines.append(X)\n    print(ant_collisions(lines))", "from collections import defaultdict\n\ndef getIndex(A, val, leng):\n    (l, r) = (0, leng)\n    m = (r + l) // 2\n    while l < r:\n        m = (r + l) // 2\n        if A[m] == val:\n            while m + 1 < leng and A[m + 1] == val:\n                m += 1\n            break\n        elif val < A[m]:\n            r = m\n        else:\n            l = m + 1\n    while m > -1 and A[m] > val:\n        m -= 1\n    return m + 1\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    another = defaultdict(list)\n    myans = 0\n    for i in range(N):\n        A = list(map(int, input().split()))\n        lene = A[0]\n        A = A[1:]\n        get_all = defaultdict(bool)\n        for a in A:\n            get_all[a] = True\n        for (a, this) in enumerate(A):\n            if this < 0:\n                ind = getIndex(A, -this, lene)\n                another[-this] += [[a, lene - ind]]\n            else:\n                ind = getIndex(A, -this, lene)\n                if get_all[-this] == True:\n                    another[this] += [[lene - a - 1, ind - 1]]\n                else:\n                    another[this] += [[lene - a - 1, ind]]\n    for i in another:\n        if len(another[i]) == 1:\n            myans += another[i][0][1]\n        elif len(another[i]) > 1:\n            myans += 1\n            for a in another[i]:\n                myans += a[0]\n    print(myans)", "for _ in range(int(input())):\n    n = int(input())\n    li = []\n    for i in range(n):\n        p = list(map(int, input().split()))\n        li.append(p)\n    if n == 1:\n        (pos, neg) = (0, 0)\n        for i in range(1, li[0][0] + 1):\n            if li[0][i] >= 0:\n                pos += 1\n            else:\n                neg += 1\n        print(pos * neg)\n    else:\n        ans = 0\n        dict = {}\n        pos_neg_cou = []\n        for i in range(n):\n            p = [0, 0]\n            for j in range(1, li[i][0] + 1):\n                if li[i][j] >= 0:\n                    p[0] += 1\n                else:\n                    p[1] += 1\n            pos_neg_cou.append(p)\n        for i in range(n):\n            for j in range(1, li[i][0] + 1):\n                if dict.get(li[i][j]) == None:\n                    dict[li[i][j]] = 1\n                    dict[-li[i][j]] = 0\n                else:\n                    dict[li[i][j]] += 1\n        k = set((abs(i) for i in dict.keys()))\n        for i in k:\n            if dict[i] + dict[-i] > 1:\n                ans += 1\n        for i in range(n):\n            negs = pos_neg_cou[i][1]\n            pos = li[i][0] - pos_neg_cou[i][0] + 1\n            while negs > 0 and pos <= li[i][0]:\n                if abs(li[i][negs]) >= li[i][pos]:\n                    if dict[li[i][pos]] + dict[-li[i][pos]] <= 1:\n                        ans += negs\n                    else:\n                        ans += li[i][0] - pos\n                    pos += 1\n                else:\n                    if dict[li[i][negs]] + dict[-li[i][negs]] <= 1:\n                        ans += li[i][0] - pos + 1\n                    else:\n                        ans += negs - 1\n                    negs -= 1\n            while negs > 0:\n                if dict[li[i][negs]] + dict[-li[i][negs]] <= 1:\n                    ans += li[i][0] - pos + 1\n                else:\n                    ans += negs - 1\n                negs -= 1\n            while pos <= li[i][0]:\n                if dict[li[i][pos]] + dict[-li[i][pos]] <= 1:\n                    ans += negs\n                else:\n                    ans += li[i][0] - pos\n                pos += 1\n        print(ans)", "N = int(200000.0 + 10)\nv = [[] for i in range(2 * N)]\n\ndef last(i, low, high, x, n):\n    if high >= low:\n        mid = low + (high - low) // 2\n        if (mid == n - 1 or x < v[i][mid + 1]) and v[i][mid] == x:\n            return mid\n        elif x < v[i][mid]:\n            return last(i, low, mid - 1, x, n)\n        else:\n            return last(i, mid + 1, high, x, n)\n    return low - 1\n\ndef mod_upper_bound(i, x):\n    return len(v[i]) - (last(i, 0, len(v[i]) - 1, x, len(v[i])) + 1)\n\ndef ants():\n    ans = 0\n    n = int(input())\n    Map = dict()\n    for i in range(1, n + 1):\n        m = list(map(int, input().split()))\n        v[i] = []\n        v[i + N] = []\n        for j in range(1, m[0] + 1):\n            if m[j] < 0:\n                v[i].append(-m[j])\n                if -m[j] not in Map.keys():\n                    Map[-m[j]] = []\n                Map[-m[j]].append(i)\n            else:\n                v[i + N].append(m[j])\n                if m[j] not in Map.keys():\n                    Map[m[j]] = []\n                Map[m[j]].append(i + N)\n        v[i].reverse()\n    for a in Map:\n        b = Map[a]\n        if len(b) > 1:\n            ans += 1\n            for c in b:\n                ans += mod_upper_bound(c, a)\n        else:\n            c = b[0]\n            if c > n:\n                c -= N\n            else:\n                c += N\n            ans += mod_upper_bound(c, a)\n    print(ans)\nfor i in range(int(input())):\n    ants()", "def countGreater(arr, l, r, x):\n    while l <= r:\n        mid = l + (r - l) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            l = mid + 1\n        else:\n            r = mid - 1\n    return -1\n\ndef countlesser(arr, k):\n    k = k * -1\n    if k > 0:\n        return len(arr) - index(arr, k)\n    else:\n        return index(arr, k)\n\ndef index(arr, k):\n    l = -1\n    r = len(arr)\n    while l + 1 < r:\n        m = l + r >> 1\n        if arr[m] >= k:\n            r = m\n        else:\n            l = m\n    return r\nt = int(input())\nfor _ in range(t):\n    arr = []\n    d = {}\n    res = 0\n    n = int(input())\n    if n == 1:\n        (m, *arr) = map(int, input().split())\n        (count1, count2) = (0, 0)\n        for i in range(m):\n            if arr[i] > 0:\n                count1 += 1\n            else:\n                count2 += 1\n        print(count1 * count2)\n        continue\n    for i in range(n):\n        (m, *temp) = map(int, input().split())\n        for j in range(m):\n            x = abs(temp[j])\n            if x in d:\n                d[x] += 1\n            else:\n                d[x] = 1\n        arr.append(temp)\n    for i in d.keys():\n        if d[i] > 1:\n            res += 1\n    for i in range(n):\n        temp = arr[i].copy()\n        for j in range(len(arr[i])):\n            h = arr[i][j]\n            x = abs(h)\n            if d[x] > 1:\n                if h > 0:\n                    res += len(temp) - countGreater(temp, 0, len(temp) - 1, h) - 1\n                else:\n                    res += countGreater(temp, 0, len(temp), h)\n            elif d[x] == 1:\n                res += countlesser(temp, h)\n    print(res)", "from collections import defaultdict\nimport bisect\n\ndef lower(lst, num):\n    ans = bisect.bisect_left(lst, num)\n    if ans == -1:\n        return len(lst)\n    else:\n        return ans\n\ndef upper(lst, num):\n    ans = bisect.bisect_right(lst, num)\n    if ans == -1:\n        return len(lst)\n    else:\n        return ans\n\ndef nino():\n    n = int(input())\n    mp = defaultdict(int)\n    ant = []\n    for _ in range(n):\n        ant.append([int(i) for i in input().split()][1:])\n    for i in ant:\n        for x in i:\n            mp[abs(x)] += 1\n    ans = 0\n    xp = 0\n    for x in mp:\n        if mp[x] > 1:\n            xp += 1\n    for i in range(n):\n        for j in range(len(ant[i])):\n            curr = 0\n            if mp[abs(ant[i][j])] > 1:\n                if ant[i][j] > 0:\n                    curr = len(ant[i]) - (j + 1)\n                else:\n                    curr = j\n            elif ant[i][j] > 0:\n                curr = lower(ant[i], -1 * ant[i][j])\n            else:\n                curr = len(ant[i]) - upper(ant[i], -1 * ant[i][j])\n            ans += curr\n    print(ans + xp)\nt = int(input())\nfor _ in range(t):\n    nino()", "from collections import defaultdict\nfrom bisect import bisect\nfor _ in range(int(input())):\n    n = int(input())\n    d = defaultdict(int)\n    li = []\n    for _ in range(n):\n        l = list(map(int, input().split()))\n        for i in l[1:]:\n            d[abs(i)] += 1\n        li.append(l[1:])\n    total_count = 0\n    for i in range(n):\n        arr = li[i]\n        arr_pos = []\n        arr_neg = []\n        for j in arr:\n            if j < 0:\n                arr_neg.append(-j)\n            else:\n                arr_pos.append(j)\n        arr_pos.sort()\n        arr_neg.sort()\n        for j in range(len(arr_pos)):\n            if d[arr_pos[j]] > 1:\n                total_count += len(arr_pos) - j - 1\n            else:\n                total_count += len(arr_neg) - bisect(arr_neg, arr_pos[j])\n        for j in range(len(arr_neg)):\n            if d[arr_neg[j]] > 1:\n                total_count += len(arr_neg) - j - 1\n            else:\n                total_count += len(arr_pos) - bisect(arr_pos, arr_neg[j])\n    origin_collide = 0\n    for v in d.values():\n        if v > 1:\n            origin_collide += 1\n    print(origin_collide + total_count)", "from collections import defaultdict\nfrom bisect import bisect_left, bisect_right\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    frq = defaultdict(int)\n    mat = []\n    for i in range(n):\n        lis = list(map(int, input().split()))\n        lis = lis[1:]\n        for j in lis:\n            if j < 0:\n                frq[abs(j)] += 1\n            else:\n                frq[j] += 1\n        mat.append(lis)\n    ans = 0\n    for e in frq.values():\n        if e > 1:\n            ans += 1\n    for i in range(n):\n        l = len(mat[i])\n        pos = 0\n        neg = 0\n        for j in mat[i]:\n            if j < 0:\n                if frq[abs(j)] > 1:\n                    ans += neg\n                else:\n                    idx = bisect_left(mat[i], abs(j))\n                    ans += l - idx\n                neg += 1\n            else:\n                break\n        for j in range(l - 1, -1, -1):\n            k = mat[i][j]\n            if k > 0:\n                if frq[k] > 1:\n                    ans += pos\n                else:\n                    idx = bisect_left(mat[i], -k)\n                    ans += idx\n                pos += 1\n            else:\n                break\n    print(ans)", "t = int(input())\nfor j in range(0, t):\n    n = int(input())\n    p = []\n    c = []\n    d = {}\n    co = 0\n    if n == 1:\n        l = list(map(int, input().split()))\n        for k in range(1, len(l)):\n            if l[k] > 0:\n                print((k - 1) * (l[0] - k + 1))\n                break\n    else:\n        for k in range(0, n):\n            l = list(map(int, input().split()))\n            h = []\n            h = l[1:]\n            op1 = []\n            op2 = []\n            for kk in range(0, l[0]):\n                if h[kk] < 0:\n                    op1.append(h[kk])\n                    if h[kk] in d:\n                        d[h[kk]] += 1\n                    else:\n                        d[h[kk]] = 1\n                else:\n                    op2.append(h[kk])\n                    if h[kk] in d:\n                        d[h[kk]] += 1\n                    else:\n                        d[h[kk]] = 1\n            h = []\n            op1.reverse()\n            h.append(op1)\n            h.append(op2)\n            p.append(h)\n        for k in range(0, n):\n            while len(p[k][0]) > 0 or len(p[k][1]) > 0:\n                if len(p[k][0]) > 0 and len(p[k][1]) > 0:\n                    if abs(p[k][0][0]) == p[k][1][0]:\n                        co += len(p[k][0]) + len(p[k][1]) - 2\n                        p[k][0].pop(0)\n                        p[k][1].pop(0)\n                    elif abs(p[k][0][0]) < p[k][1][0]:\n                        ppo = 0\n                        if -1 * p[k][0][0] in d:\n                            ppo = d[p[k][0][0]] + d[-1 * p[k][0][0]]\n                        else:\n                            ppo = d[p[k][0][0]]\n                        if ppo > 1:\n                            co += len(p[k][0]) - 1\n                            p[k][0].pop(0)\n                        else:\n                            co += len(p[k][1])\n                            p[k][0].pop(0)\n                    else:\n                        ppo = 0\n                        if -1 * p[k][1][0] in d:\n                            ppo = d[p[k][1][0]] + d[-1 * p[k][1][0]]\n                        else:\n                            ppo = d[p[k][1][0]]\n                        if ppo > 1:\n                            co += len(p[k][1]) - 1\n                            p[k][1].pop(0)\n                        else:\n                            co += len(p[k][0])\n                            p[k][1].pop(0)\n                elif len(p[k][0]) > 0:\n                    ppo = 0\n                    if -1 * p[k][0][0] in d:\n                        ppo = d[p[k][0][0]] + d[-1 * p[k][0][0]]\n                    else:\n                        ppo = d[p[k][0][0]]\n                    if ppo > 1:\n                        co += len(p[k][0]) - 1\n                    p[k][0].pop(0)\n                elif len(p[k][1]) > 0:\n                    ppo = 0\n                    if -1 * p[k][1][0] in d:\n                        ppo = d[p[k][1][0]] + d[-1 * p[k][1][0]]\n                    else:\n                        ppo = d[p[k][1][0]]\n                    if ppo > 1:\n                        co += len(p[k][1]) - 1\n                    p[k][1].pop(0)\n        cc = 0\n        for ii in d:\n            if d[ii] == 1:\n                if -1 * ii in d:\n                    if d[-1 * ii] + d[ii] > 1:\n                        d[-1 * ii] = 1\n                        d[ii] = 0\n                        cc += 1\n            else:\n                if -1 * ii in d:\n                    d[-1 * ii] = 1\n                d[ii] = 0\n                cc += 1\n        print(co + cc)", "def upperbound(arr, low, high, X):\n    if low > high:\n        return low\n    mid = int(low + (high - low) / 2)\n    if arr[mid] >= X:\n        return upperbound(arr, low, mid - 1, X)\n    return upperbound(arr, mid + 1, high, X)\n\ndef lowerbound(arr, low, high, X):\n    if low > high:\n        return low\n    mid = int(low + (high - low) / 2)\n    if arr[mid] <= X:\n        return lowerbound(arr, mid + 1, high, X)\n    return lowerbound(arr, low, mid - 1, X)\n\ndef solve(dic, arr, n):\n    ans = 0\n    ax = 0\n    for i in dic:\n        if dic[i] > 1:\n            ax = ax + 1\n    for i in range(n):\n        for j in range(0, len(arr[i])):\n            curr = 0\n            if dic[abs(arr[i][j])] > 1:\n                if arr[i][j] > 0:\n                    curr = len(arr[i]) - (j + 1)\n                else:\n                    curr = j\n            elif arr[i][j] > 0:\n                curr = upperbound(arr[i], 0, len(arr[i]) - 1, -1 * arr[i][j]) - 0\n            else:\n                curr = len(arr[i]) - (lowerbound(arr[i], 0, len(arr[i]) - 1, -1 * arr[i][j]) - 0)\n            ans = ans + curr\n    print(ans + ax)\n\ndef main():\n    for i in range(int(input())):\n        n = int(input())\n        arr = []\n        dic = {}\n        for i in range(n):\n            ll = list(map(int, input().split()))\n            for j in range(1, len(ll)):\n                try:\n                    dic[abs(ll[j])] += 1\n                except KeyError:\n                    dic[abs(ll[j])] = 1\n            ll = ll[1:]\n            ll.sort()\n            arr.append(ll)\n        solve(dic, arr, n)\nmain()", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = dict()\n    mat = []\n    for i in range(n):\n        l = list(map(int, input().split()))[1:]\n        l.sort()\n        mat.append(l)\n        for j in l:\n            if abs(j) in d:\n                d[abs(j)] += 1\n            else:\n                d[abs(j)] = 1\n    out = sub = 0\n    for i in d:\n        if d[i] > 1:\n            sub += 1\n    for i in range(n):\n        for j in range(len(mat[i])):\n            cur = 0\n            if d[abs(mat[i][j])] > 1:\n                if mat[i][j] > 0:\n                    cur = len(mat[i]) - (j + 1)\n                else:\n                    cur = j\n            elif mat[i][j] > 0:\n                cur = bl(mat[i], mat[i][j] * -1)\n            else:\n                cur = len(mat[i]) - br(mat[i], mat[i][j] * -1)\n            out += cur\n    print(out + sub)", "def first(arr, low, high, X):\n    if low > high:\n        return low\n    mid = low + (high - low) // 2\n    if arr[mid] >= X:\n        return first(arr, low, mid - 1, X)\n    return first(arr, mid + 1, high, X)\n\ndef last(arr, low, high, X):\n    if low > high:\n        return low\n    mid = low + (high - low) // 2\n    if arr[mid] <= X:\n        return last(arr, mid + 1, high, X)\n    return last(arr, low, mid - 1, X)\n\ndef solve(dic, arr):\n    ans = 0\n    ax = 0\n    for i in dic:\n        if dic[i] > 1:\n            ax = ax + 1\n    for i in range(n):\n        for j in range(0, len(arr[i])):\n            curr = 0\n            if dic[abs(arr[i][j])] > 1:\n                if arr[i][j] > 0:\n                    curr = len(arr[i]) - (j + 1)\n                else:\n                    curr = j\n            elif arr[i][j] > 0:\n                curr = first(arr[i], 0, len(arr[i]) - 1, -1 * arr[i][j]) - 0\n            else:\n                curr = len(arr[i]) - (last(arr[i], 0, len(arr[i]) - 1, -1 * arr[i][j]) - 0)\n            ans = ans + curr\n    print(ans + ax)\nfor i in range(int(input())):\n    n = int(input())\n    arr = []\n    dic = {}\n    for i in range(n):\n        ll = list(map(int, input().split()))\n        for j in range(1, len(ll)):\n            try:\n                dic[abs(ll[j])] += 1\n            except KeyError:\n                dic[abs(ll[j])] = 1\n        ll = ll[1:]\n        ll.sort()\n        arr.append(ll)\n    solve(dic, arr)", "import sys\n\ndef get_values():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef OneLine():\n    M = get_values()\n    countPos = 0\n    countNeg = 0\n    for i in range(1, M[0] + 1):\n        if M[i] < 0:\n            countNeg += 1\n        else:\n            countPos += 1\n    return countNeg * countPos\n\ndef Solve(N):\n    ants = []\n    totalAnts = 0\n    num = []\n    for line in range(N):\n        countPos = 0\n        countNeg = 0\n        M = get_values()\n        for i in range(1, M[0] + 1):\n            totalAnts += 1\n            if M[i] < 0:\n                ants.append([abs(M[i]), 0, line])\n                countNeg += 1\n            else:\n                ants.append([abs(M[i]), 1, line])\n                countPos += 1\n        num.append([countNeg, countPos])\n    M = []\n    ants.sort()\n    collision = 0\n    i = 0\n    while i < totalAnts:\n        j = i + 1\n        while j < totalAnts and ants[j][0] == ants[i][0]:\n            j += 1\n        if j - i > 1:\n            collision += 1\n            for k in range(i, j):\n                collision += num[ants[k][2]][ants[k][1]] - 1\n                num[ants[k][2]][ants[k][1]] -= 1\n        else:\n            collision += num[ants[i][2]][int(not ants[i][1])]\n            num[ants[i][2]][ants[i][1]] -= 1\n        i = j\n    return collision\ntest = int(input())\nfor t in range(test):\n    N = int(input())\n    if N == 1:\n        print(OneLine())\n    else:\n        print(Solve(N))", "def OneLine():\n    M = list(map(int, input().strip().split()))\n    countPos = 0\n    countNeg = 0\n    for i in range(1, M[0] + 1):\n        if M[i] < 0:\n            countNeg += 1\n        else:\n            countPos += 1\n    return countNeg * countPos\n\ndef Solve(N):\n    ants = []\n    totalAnts = 0\n    num = []\n    for line in range(N):\n        countPos = 0\n        countNeg = 0\n        M = list(map(int, input().strip().split()))\n        for i in range(1, M[0] + 1):\n            totalAnts += 1\n            if M[i] < 0:\n                ants.append([abs(M[i]), 0, line])\n                countNeg += 1\n            else:\n                ants.append([abs(M[i]), 1, line])\n                countPos += 1\n        num.append([countNeg, countPos])\n    M = []\n    ants.sort()\n    collision = 0\n    i = 0\n    while i < totalAnts:\n        j = i + 1\n        while j < totalAnts and ants[j][0] == ants[i][0]:\n            j += 1\n        if j - i > 1:\n            collision += 1\n            for k in range(i, j):\n                collision += num[ants[k][2]][ants[k][1]] - 1\n                num[ants[k][2]][ants[k][1]] -= 1\n        else:\n            collision += num[ants[i][2]][int(not ants[i][1])]\n            num[ants[i][2]][ants[i][1]] -= 1\n        i = j\n    return collision\ntest = int(input())\nfor t in range(test):\n    N = int(input())\n    if N == 1:\n        print(OneLine())\n    else:\n        print(Solve(N))", "def OneLine():\n    M = list(map(int, input().strip().split()))\n    countPos = 0\n    countNeg = 0\n    for i in range(1, M[0] + 1):\n        if M[i] < 0:\n            countNeg += 1\n        else:\n            countPos += 1\n    return countNeg * countPos\n\ndef Solve(N):\n    ants = []\n    totalAnts = 0\n    num = []\n    for line in range(N):\n        countPos = 0\n        countNeg = 0\n        M = list(map(int, input().strip().split()))\n        for i in range(1, M[0] + 1):\n            totalAnts += 1\n            if M[i] < 0:\n                ants.append([abs(M[i]), 0, line])\n                countNeg += 1\n            else:\n                ants.append([abs(M[i]), 1, line])\n                countPos += 1\n        num.append([countNeg, countPos])\n    M = []\n    ants.sort()\n    collision = 0\n    i = 0\n    while i < totalAnts:\n        j = i + 1\n        while j < totalAnts and ants[j][0] == ants[i][0]:\n            j += 1\n        if j - i > 1:\n            collision += 1\n            for k in range(i, j):\n                collision += num[ants[k][2]][ants[k][1]] - 1\n                num[ants[k][2]][ants[k][1]] -= 1\n        else:\n            collision += num[ants[i][2]][int(not ants[i][1])]\n            num[ants[i][2]][ants[i][1]] -= 1\n        i = j\n    return collision\ntest = int(input())\nfor t in range(test):\n    N = int(input())\n    if N == 1:\n        print(OneLine())\n    else:\n        print(Solve(N))", "def count():\n    for i in range(n):\n        for j in m[i][1:]:\n            try:\n                d[abs(j)] += 1\n            except:\n                d[abs(j)] = 1\n\ndef v_(x_p, x_n):\n    return x_p * x_n\n\ndef solve(a, b):\n    (v1, v2) = (len(a), len(b))\n    (i, j) = (0, 0)\n    value = 0\n    while i < len(a) and j < len(b):\n        c = 0\n        if a[i] > b[j]:\n            while j < len(b) and a[i] > b[j]:\n                if d[b[j]] > 1:\n                    value += v2 - 1\n                else:\n                    c += 1\n                (v2, j) = (v2 - 1, j + 1)\n            value += v_(v1, c)\n        elif a[i] < b[j]:\n            while i < len(a) and a[i] < b[j]:\n                if d[a[i]] > 1:\n                    value += v1 - 1\n                else:\n                    c += 1\n                (v1, i) = (v1 - 1, i + 1)\n            value += v_(c, v2)\n        else:\n            (v1, v2) = (v1 - 1, v2 - 1)\n            value += v1 + v2\n            (i, j) = (i + 1, j + 1)\n    while i < len(a):\n        if v2 > 0:\n            (v1, v2) = (v1 - 1, v2 - 1)\n            value += v1 + v2 + 1\n            if d[a[i]] > 1:\n                value += v1 + v2\n        else:\n            v1 -= 1\n            if d[a[i]] > 1:\n                value += v1\n        i += 1\n    while j < len(b):\n        if v1 > 0:\n            (v1, v2) = (v1 - 1, v2 - 1)\n            value += v1 + v2 + 1\n            if d[b[j]] > 1:\n                value += v1 + v2\n        else:\n            v2 -= 1\n            if d[b[j]] > 1:\n                value += v2\n        j += 1\n    return value\n\ndef answer():\n    ans = 0\n    for i in d.values():\n        if i > 1:\n            ans += 1\n    for i in range(n):\n        (ap, an) = ([], [])\n        for j in m[i][1:]:\n            if j > 0:\n                ap.append(j)\n            else:\n                an.append(-j)\n        ans += solve(ap, an[::-1])\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    m = [list(map(int, input().split())) for i in range(n)]\n    d = dict()\n    count()\n    print(answer())", "def count():\n    for i in range(n):\n        for j in m[i][1:]:\n            try:\n                d[abs(j)] += 1\n            except:\n                d[abs(j)] = 1\n\ndef v_(x_p, x_n):\n    return x_p * x_n\n\ndef solve(a, b):\n    (v1, v2) = (len(a), len(b))\n    (i, j) = (0, 0)\n    value = 0\n    while i < len(a) and j < len(b):\n        c = 0\n        if a[i] > b[j]:\n            while j < len(b) and a[i] > b[j]:\n                if d[b[j]] > 1:\n                    value += v2 - 1\n                else:\n                    c += 1\n                (v2, j) = (v2 - 1, j + 1)\n            value += v_(v1, c)\n        elif a[i] < b[j]:\n            while i < len(a) and a[i] < b[j]:\n                if d[a[i]] > 1:\n                    value += v1 - 1\n                else:\n                    c += 1\n                (v1, i) = (v1 - 1, i + 1)\n            value += v_(c, v2)\n        else:\n            (v1, v2) = (v1 - 1, v2 - 1)\n            value += v1 + v2\n            (i, j) = (i + 1, j + 1)\n    while i < len(a):\n        if v2 > 0:\n            (v1, v2) = (v1 - 1, v2 - 1)\n            value += v1 + v2 + 1\n            if d[a[i]] > 1:\n                value += v1 + v2\n        else:\n            v1 -= 1\n            if d[a[i]] > 1:\n                value += v1\n        i += 1\n    while j < len(b):\n        if v1 > 0:\n            (v1, v2) = (v1 - 1, v2 - 1)\n            value += v1 + v2 + 1\n            if d[b[j]] > 1:\n                value += v1 + v2\n        else:\n            v2 -= 1\n            if d[b[j]] > 1:\n                value += v2\n        j += 1\n    return value\n\ndef answer():\n    ans = 0\n    for i in d.values():\n        if i > 1:\n            ans += 1\n    for i in range(n):\n        (ap, an) = ([], [])\n        for j in m[i][1:]:\n            if j > 0:\n                ap.append(j)\n            else:\n                an.append(-j)\n        ans += solve(sorted(ap), sorted(an))\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    m = [list(map(int, input().split())) for i in range(n)]\n    d = dict()\n    count()\n    print(answer())", "from collections import defaultdict\nfor y in range(int(input())):\n    d = defaultdict(list)\n    n = int(input())\n    arr = []\n    for i in range(n):\n        (a, *lst) = map(int, input().split())\n        p = n = 0\n        for j in range(a):\n            if lst[j] > 0:\n                p += 1\n                d[lst[j]].append(i + 1)\n            else:\n                n += 1\n                d[-1 * lst[j]].append(-1 * (i + 1))\n        arr.append([p, n])\n    ans = 0\n    for i in sorted(d):\n        if len(d[i]) == 1:\n            temp = d[i][0]\n            if temp > 0:\n                temp -= 1\n                ans += arr[temp][1]\n                arr[temp][0] -= 1\n            else:\n                temp = temp * -1\n                temp -= 1\n                ans += arr[temp][0]\n                arr[temp][1] -= 1\n        else:\n            ans += 1\n            for j in d[i]:\n                if j > 0:\n                    temp = j\n                    temp -= 1\n                    arr[temp][0] -= 1\n                    ans += arr[temp][0]\n                else:\n                    temp = -1 * j\n                    temp -= 1\n                    arr[temp][1] -= 1\n                    ans += arr[temp][1]\n    print(ans)", "from collections import Counter\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    mat = []\n    noa = []\n    coun = Counter()\n    for i in range(n):\n        x = list(map(int, input().split()))\n        noa.append(x[0])\n        x = x[1:]\n        mat.append(x)\n        coun.update(x)\n    finalans = 0\n    for z in range(n):\n        a = mat[z]\n        a.sort()\n        j = 0\n        ll = noa[z]\n        while j < ll:\n            if a[j] > 0:\n                break\n            j += 1\n        x = a[0:j]\n        lx = j\n        y = a[j:]\n        ly = noa[z] - j\n        x.reverse()\n        kx = 0\n        ky = 0\n        i = 0\n        j = 0\n        while True:\n            if i >= lx and j >= ly:\n                break\n            elif i >= lx or j >= ly:\n                if i >= lx:\n                    if coun[y[j]] + coun[-1 * y[j]] > 1:\n                        finalans = finalans + ly - j - 1\n                        j += 1\n                    else:\n                        j += 1\n                elif coun[x[i]] + coun[-1 * x[i]] > 1:\n                    finalans = finalans + lx - i - 1\n                    i += 1\n                else:\n                    i += 1\n            elif x[i] == -1 * y[j]:\n                finalans = finalans + lx - i - 1 + ly - j - 1\n                i += 1\n                j += 1\n            elif y[j] > -1 * x[i]:\n                if coun[x[i]] + coun[-1 * x[i]] > 1:\n                    finalans = finalans + lx - i - 1\n                    i += 1\n                else:\n                    finalans = finalans + ly - j\n                    i += 1\n            elif y[j] < -1 * x[i]:\n                if coun[y[j]] + coun[-1 * y[j]] > 1:\n                    finalans = finalans + ly - j - 1\n                    j += 1\n                else:\n                    finalans = finalans + lx - i\n                    j += 1\n    count = Counter()\n    for (keys, items) in coun.items():\n        if keys < 0:\n            m = coun[keys]\n            keys = -1 * keys\n            count.update({keys: m})\n        else:\n            count.update({keys: coun[keys]})\n    for (keys, items) in count.items():\n        if items > 1:\n            finalans += 1\n    print(finalans)", "try:\n    from collections import defaultdict\n    from bisect import bisect_left, bisect_right\n    for ii in range(int(input())):\n        n = int(input())\n        (x, y, z, hi, lo, d, r) = (0, [], [], 0, 0, defaultdict(int), 0)\n        for jj in range(n):\n            (a, *b) = list(map(int, input().split()))\n            b = list(sorted(b))\n            for kk in b:\n                d[abs(kk)] += 1\n                if d[abs(kk)] == 2:\n                    x += 1\n            y.append(b)\n            z.append(a)\n        for jj in range(n):\n            for kk in range(z[jj]):\n                if d[abs(y[jj][kk])] <= 1:\n                    if y[jj][kk] <= 0:\n                        x += z[jj] - bisect_right(y[jj], y[jj][kk] * -1)\n                    else:\n                        x += bisect_left(y[jj], y[jj][kk] * -1)\n                elif y[jj][kk] <= 0:\n                    x += kk\n                else:\n                    x += z[jj] - kk - 1\n        print(x)\nexcept:\n    pass", "from collections import defaultdict as dd\nfrom bisect import bisect_right as br\nfor case in range(int(input())):\n    N = int(input())\n    ants = []\n    collisions = dd(list)\n    for i in range(N):\n        (M, *arr) = map(int, input().split())\n        ants.append(arr)\n        for it in arr:\n            collisions[abs(it)] += [[it, i]]\n    total_coll = 0\n    for (Time, llis) in collisions.items():\n        colls = 0\n        if len(llis) > 1:\n            colls += 1\n            for (ant, line) in llis:\n                coll = 0\n                ind = br(ants[line], ant)\n                if ant < 0:\n                    coll = ind - 1\n                else:\n                    coll = len(ants[line]) - ind\n                colls += coll\n        else:\n            for (ant, line) in llis:\n                coll = 0\n                ind = br(ants[line], -ant)\n                if ant < 0:\n                    coll = len(ants[line]) - ind\n                else:\n                    coll = ind\n                colls += coll\n        total_coll += colls\n    print(total_coll)", "def lower_bound(a, x):\n    lo = -1\n    high = len(a)\n    while lo + 1 < high:\n        mid = lo + high >> 1\n        if a[mid] >= x:\n            high = mid\n        else:\n            lo = mid\n    return high\n\ndef upper_bound(a, x):\n    lo = -1\n    high = len(a)\n    while lo + 1 < high:\n        mid = lo + high >> 1\n        if a[mid] <= x:\n            lo = mid\n        else:\n            high = mid\n    return lo + 1\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    X = []\n    m = []\n    coord = {}\n    liy = []\n    for it in range(10000):\n        liy.append(it)\n    lia = []\n    for it in range(10000):\n        lia.append(it)\n    lib = []\n    for it in range(10000):\n        lib.append(it)\n    lic = []\n    for it in range(10000):\n        lic.append(it)\n    lid = []\n    for it in range(10000):\n        lid.append(it)\n    lie = []\n    for it in range(10000):\n        lie.append(it)\n    lif = []\n    for it in range(10000):\n        lif.append(it)\n    for inp in range(n):\n        temp1 = list(map(int, input().split()))\n        m = temp1[0]\n        temp2 = []\n        lity = []\n        for ui in range(300):\n            lity.append(ui)\n        for i in range(1, m + 1):\n            temp2.append(temp1[i])\n            coord[abs(temp1[i])] = coord.get(abs(temp1[i]), 0) + 1\n        temp2.sort()\n        X.append(temp2)\n    origin = 0\n    res = 0\n    for i in coord:\n        if coord[i] > 1:\n            origin += 1\n    for i in range(0, n):\n        for j in range(0, len(X[i])):\n            collision = 0\n            if coord[abs(X[i][j])] <= 1:\n                if X[i][j] > 0:\n                    collision = lower_bound(X[i], -1 * X[i][j])\n                else:\n                    collision = len(X[i]) - upper_bound(X[i], -1 * X[i][j])\n            elif X[i][j] <= 0:\n                collision = j\n            else:\n                collision = len(X[i]) - (j + 1)\n            res += collision\n    print(res + origin)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ants = []\n    sizes = []\n    dictt = {}\n    neg = []\n    ans = 0\n    for itr in range(n):\n        temp = list(map(int, input().split()))\n        sizes.append(temp[0])\n        temp.pop(0)\n        ants.append(temp)\n        negnum = 0\n        tempset = set()\n        for i in temp:\n            if i < 0:\n                negnum += 1\n            tempset.add(abs(i))\n        neg.append(negnum)\n        for i in tempset:\n            if i in dictt:\n                if dictt[i] == 1:\n                    dictt[i] = 2\n                    ans += 1\n            else:\n                dictt[i] = 1\n    for temp in ants:\n        cntl = 0\n        cntr = 0\n        for i in temp:\n            if i < 0 and dictt[abs(i)] == 1:\n                cntl += 1\n            elif i > 0 and dictt[i] == 1:\n                cntr += 1\n        ans += cntl * cntr\n    cnt = []\n    for i in range(len(ants)):\n        indxxl = neg[i] - 1\n        indxxr = neg[i]\n        numl = 0\n        numr = 0\n        for j in range(neg[i] - 1, -1, -1):\n            ant = ants[i][j]\n            if dictt[abs(ant)] == 2:\n                if ant < 0:\n                    ans += j\n                    ind = indxxr\n                    while ind < sizes[i]:\n                        if ants[i][ind] >= abs(ant):\n                            break\n                        if dictt[ants[i][ind]] == 1:\n                            numr += 1\n                        ind += 1\n                    ans += numr\n                    indxxr = ind\n        for j in range(neg[i], sizes[i]):\n            ant = ants[i][j]\n            if dictt[abs(ant)] == 2:\n                if ant > 0:\n                    ans += sizes[i] - j - 1\n                    ind = indxxl\n                    while ind >= 0:\n                        if abs(ants[i][ind]) >= ant:\n                            break\n                        if dictt[abs(ants[i][ind])] == 1:\n                            numl += 1\n                        ind -= 1\n                    ans += numl\n                    indxxl = ind\n    print(ans)", "def lb(A, x):\n    start = 0\n    end = len(A) - 1\n    while start < end:\n        mid = (start + end) // 2\n        if A[mid] < x:\n            start = mid + 1\n        else:\n            end = mid\n    if A[start] < x:\n        return len(A)\n    else:\n        return start\n\ndef ub(A, x):\n    start = 0\n    end = len(A) - 1\n    while start < end:\n        mid = (start + end) // 2\n        if A[mid] <= x:\n            start = mid + 1\n        else:\n            end = mid\n    if A[start] > x:\n        return start\n    else:\n        return len(A)\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = []\n    D = dict()\n    for i in range(N):\n        B = [int(x) for x in input().split(' ')]\n        M = B[0]\n        B = B[1:]\n        for j in range(M):\n            k = B[j]\n            if abs(k) in D.keys():\n                D[abs(k)] += 1\n            else:\n                D[abs(k)] = 1\n        A.append(B)\n    ans = 0\n    for l in D.keys():\n        if D[l] > 1:\n            ans += 1\n    for i in range(N):\n        for j in range(len(A[i])):\n            ki = 0\n            if D[abs(A[i][j])] > 1:\n                if A[i][j] < 0:\n                    ki = j\n                else:\n                    ki = len(A[i]) - j - 1\n            elif A[i][j] > 0:\n                ki = lb(A[i], -A[i][j])\n            else:\n                ki = len(A[i]) - ub(A[i], -A[i][j])\n            ans += ki\n    print(ans)", "def lb(A, x):\n    start = 0\n    end = len(A) - 1\n    while start < end:\n        mid = (start + end) // 2\n        if A[mid] < x:\n            start = mid + 1\n        else:\n            end = mid\n    if A[start] < x:\n        return len(A)\n    else:\n        return start\n\ndef ub(A, x):\n    start = 0\n    end = len(A) - 1\n    while start < end:\n        mid = (start + end) // 2\n        if A[mid] <= x:\n            start = mid + 1\n        else:\n            end = mid\n    if A[start] > x:\n        return start\n    else:\n        return len(A)\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = []\n    D = dict()\n    for i in range(N):\n        B = [int(x) for x in input().split(' ')]\n        M = B[0]\n        B = B[1:]\n        for j in range(M):\n            k = B[j]\n            if abs(k) in D.keys():\n                D[abs(k)] += 1\n            else:\n                D[abs(k)] = 1\n        A.append(B)\n    ans = 0\n    for l in D.keys():\n        if D[l] > 1:\n            ans += 1\n    for i in range(N):\n        for j in range(len(A[i])):\n            ki = 0\n            if D[abs(A[i][j])] > 1:\n                if A[i][j] < 0:\n                    ki = j\n                else:\n                    ki = len(A[i]) - j - 1\n            elif A[i][j] > 0:\n                ki = lb(A[i], -A[i][j])\n            else:\n                ki = len(A[i]) - ub(A[i], -A[i][j])\n            ans += ki\n    print(ans)", "def opp(arr, target, start, end):\n    ans = -1\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] >= target:\n            end = mid - 1\n        else:\n            ans = mid\n            start = mid + 1\n    return ans\n\ndef opn(arr, target, start, end):\n    ans = -1\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] <= target:\n            start = mid + 1\n        else:\n            ans = mid\n            end = mid - 1\n    return ans\nfrom collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    ans = 0\n    freq = defaultdict(int)\n    n = int(input())\n    lines = []\n    lens = []\n    for __ in range(n):\n        x = list(map(int, input().split()))\n        x.append(10 ** 10)\n        for i in range(1, x[0] + 1):\n            freq[x[i]] += 1\n        lens.append(x[0])\n        x[0] = -10 ** 9 - 1\n        lines.append(x)\n    for i in range(n):\n        s = [0] * (lens[i] + 2)\n        m = [0] * (lens[i] + 2)\n        for j in range(1, lens[i] + 1):\n            if freq[lines[i][j]] + freq[-lines[i][j]] == 1:\n                s[j] = 1 + s[j - 1]\n                m[j] = m[j - 1]\n            else:\n                m[j] = 1 + m[j - 1]\n                s[j] = s[j - 1]\n        (s[lens[i] + 1], m[lens[i] + 1]) = (s[lens[i]], m[lens[i]])\n        pz = opp(lines[i], 0, 0, lens[i] + 1)\n        for j in range(1, lens[i] + 1):\n            po = opp(lines[i], -lines[i][j], 0, lens[i] + 1)\n            pt = opn(lines[i], -lines[i][j], 0, lens[i] + 1)\n            if lines[i][j] > 0:\n                if freq[lines[i][j]] + freq[-lines[i][j]] == 1:\n                    ans += (s[pz] + (m[j - 1] - m[pz]) + m[po]) / 2\n                else:\n                    ans += (m[j - 1] - m[pz] + (lens[i] - j) + (s[pz] - s[pt - 1])) / 2 + 1 / (freq[lines[i][j]] + freq[-lines[i][j]])\n            elif freq[lines[i][j]] + freq[-lines[i][j]] == 1:\n                ans += (s[lens[i]] - s[pz] + m[pz] - m[j] + m[lens[i]] - m[pt - 1]) / 2\n            else:\n                ans += (j - 1 + m[pz] - m[j] + s[po] - s[pz]) / 2 + 1 / (freq[lines[i][j]] + freq[-lines[i][j]])\n    print(round(ans))", "import sys\ninput = sys.stdin.readline\n\ndef check(p, i, j, v):\n    if i > j:\n        return i\n    m = (i + j) // 2\n    if p[m] > v:\n        return check(p, i, m - 1, v)\n    else:\n        return check(p, m + 1, j, v)\n\ndef check2(p, i, j, v):\n    if i > j:\n        return i\n    m = (i + j) // 2\n    if abs(p[m]) > v:\n        return check2(p, m + 1, j, v)\n    else:\n        return check2(p, i, m - 1, v)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        l = []\n        for i in range(n):\n            l.append(list(map(int, input().split())))\n        if n == 1:\n            x = set()\n            p = l[0]\n            m = p[0]\n            p = p[1:]\n            l = []\n            r = []\n            for i in p:\n                if i < 0:\n                    l.append(i)\n                else:\n                    r.append(i)\n            print(len(l) * len(r))\n        else:\n            print(0)\n    else:\n        l = []\n        d = {}\n        for i in range(n):\n            p = list(map(int, input().split()))\n            x = []\n            for j in range(1, len(p)):\n                x.append(p[j])\n                if abs(p[j]) in d.keys():\n                    d[abs(p[j])] += 1\n                else:\n                    d[abs(p[j])] = 1\n            l.append(x)\n        ans = 0\n        for k in d.keys():\n            if d[k] > 1:\n                ans += 1\n        for el in l:\n            for i in range(len(el)):\n                if d[abs(el[i])] > 1:\n                    if el[i] < 0:\n                        ans += i\n                    else:\n                        ans += len(el) - i - 1\n                elif el[i] < 0:\n                    ct = len(el) - check(el, i + 1, len(el) - 1, abs(el[i]))\n                    ans += ct\n                else:\n                    ct = check2(el, 0, i - 1, el[i])\n                    ans += ct\n        print(ans)", "import sys\ninput = sys.stdin.readline\nt = int(input())\nfor t1 in range(t):\n    n = int(input())\n    c = 0\n    d = {}\n    mat = []\n    for i in range(n):\n        l = list(map(int, input().split(' ')))\n        m = l[0]\n        l = l[1:]\n        a = 0\n        mat.append(l)\n        for j in range(m):\n            d[abs(l[j])] = d.get(abs(l[j]), 0) + 1\n    for i in range(n):\n        l = mat[i]\n        pos = []\n        neg = []\n        for j in range(len(l)):\n            if l[j] < 0:\n                neg.append(abs(l[j]))\n            else:\n                pos.append(abs(l[j]))\n        pos = pos[::-1]\n        while len(pos) > 0 or len(neg) > 0:\n            if len(pos) == 0:\n                a = neg[-1]\n                if d.get(a, 0) >= 2:\n                    c += len(neg) - 1\n                neg.pop()\n            elif len(neg) == 0:\n                a = pos[-1]\n                if d.get(a, 0) >= 2:\n                    c += len(pos) - 1\n                pos.pop()\n            else:\n                a = pos[-1]\n                b = neg[-1]\n                if a < b:\n                    if d.get(a, 0) < 2:\n                        c += len(neg)\n                    else:\n                        c += len(pos) - 1\n                    pos.pop()\n                elif a > b:\n                    if d.get(b, 0) < 2:\n                        c += len(pos)\n                    else:\n                        c += len(neg) - 1\n                    neg.pop()\n                else:\n                    c += len(pos) + len(neg) - 2\n                    pos.pop()\n                    neg.pop()\n    for i in d:\n        if d[i] > 1:\n            c += 1\n    print(c)", "def lin():\n    return list(map(int, input().strip().split()))\n\ndef special_dictionary(arr1, arr2, common):\n    (a, b) = (len(arr1), len(arr2))\n    dic1 = {}\n    dic2 = {}\n    j = 0\n    for i in range(a):\n        if i > 0:\n            dic1[i] = dic1[i - 1]\n        else:\n            dic1[i] = 0\n        while j < b and arr2[j] < arr1[i]:\n            if arr2[j] not in common:\n                dic1[i] += 1\n            j += 1\n    j = 0\n    for i in range(b):\n        if i > 0:\n            dic2[i] = dic2[i - 1]\n        else:\n            dic2[i] = 0\n        while j < a and arr1[j] < arr2[i]:\n            if arr1[j] not in common:\n                dic2[i] += 1\n            j += 1\n    return (dic1, dic2)\ntest = int(input().strip())\nfor _ in range(test):\n    n = int(input().strip())\n    lines = []\n    (se, common) = (set(), set())\n    for i in range(n):\n        (m, *line) = lin()\n        (neg, pos) = ([], [])\n        for item in line:\n            if abs(item) in se:\n                common.add(abs(item))\n            else:\n                se.add(abs(item))\n            if item < 0:\n                neg.append(-item)\n            else:\n                pos.append(item)\n        neg.sort()\n        pos.sort()\n        lines.append((neg, pos))\n    collisions = len(common)\n    for line in lines:\n        (neg, pos) = line\n        (l1, l2) = (len(neg), len(pos))\n        (dic1, dic2) = special_dictionary(neg, pos, common)\n        for i in range(l1):\n            if neg[i] in common:\n                collisions += l1 - i - 1\n                collisions += dic1[i]\n        for i in range(l2):\n            if pos[i] in common:\n                collisions += l2 - i - 1\n                collisions += dic2[i]\n        (c1, c2) = (l1 - len(set(neg) & common), l2 - len(set(pos) & common))\n        collisions += c1 * c2\n    print(collisions)", "from collections import defaultdict, deque\n\ndef read_test():\n    n = int(input())\n    m = [[int(x) for x in input().strip().split(' ')[1:]] for _ in range(n)]\n    return (n, m)\n\ndef solve(n, m):\n    count = defaultdict(int)\n    events = []\n    for line in range(n):\n        for ant in m[line]:\n            orintation = ant >= 0\n            events.append((abs(ant), orintation, line))\n            count[line, orintation] += 1\n    events = deque(sorted(events))\n    interactions = 0\n    while events:\n        ants = [events.popleft()]\n        while events and events[0][0] == ants[0][0]:\n            ants.append(events.popleft())\n        collision = len(ants) > 1\n        if not collision:\n            (_, o, l) = ants[0]\n            interactions += count[l, not o]\n            count[l, o] -= 1\n            continue\n        interactions += 1\n        for (_, o, l) in ants:\n            count[l, o] -= 1\n            interactions += count[l, o]\n    return interactions\nT = int(input())\nfor _ in range(T):\n    (n, m) = read_test()\n    print(solve(n, m))", "debug = 0\n\nclass Line:\n\n    def __init__(self, m, l):\n        self.pos = []\n        self.neg = []\n        self.negatives = 0\n        for i in l:\n            if i > 0:\n                self.pos.append(i)\n            else:\n                self.neg.append(-i)\n                self.negatives += 1\n        self.positives = m - self.negatives\n        self.pos.sort()\n        self.neg.sort()\n        self.collisions = self.positives * self.negatives\n        if debug:\n            print(self.positives, self.negatives)\n            print(self.collisions, 'collisions')\n\n    def record(self, time, change, collisions, one_ant):\n        if time in collisions:\n            collisions[time] += change\n        elif time in one_ant:\n            collisions[time] = one_ant[time] + change\n        else:\n            one_ant[time] = change\n\n    def update_collisions(self, collisions, one_ant):\n        i = j = 0\n        n = min(self.positives, self.negatives)\n        while i < self.positives and j < self.negatives:\n            a = self.pos[i]\n            b = self.neg[j]\n            if a == b:\n                if a in collisions:\n                    collisions[a] -= 1\n                elif a in one_ant:\n                    collisions[a] = one_ant[a] - 1\n                else:\n                    collisions[a] = -1\n                i += 1\n                j += 1\n            elif a < b:\n                change = -(self.negatives - j) + self.positives - i - 1\n                self.record(a, change, collisions, one_ant)\n                i += 1\n            else:\n                change = -(self.positives - i) + self.negatives - j - 1\n                self.record(b, change, collisions, one_ant)\n                j += 1\n        if i == self.positives:\n            while j < self.negatives:\n                change = self.negatives - j - 1\n                self.record(self.neg[j], change, collisions, one_ant)\n                j += 1\n        elif j == self.negatives:\n            while i < self.positives:\n                change = self.positives - i - 1\n                self.record(self.pos[i], change, collisions, one_ant)\n                i += 1\n        else:\n            raise Exeption('wtf')\n        if debug:\n            print('one ant:', one_ant)\n            print('collisions', collisions)\n\ndef solve(n):\n    one_ant = {}\n    collisions = {}\n    result = 0\n    for _ in range(n):\n        l = map(int, input().split())\n        ants = next(l)\n        line = Line(ants, l)\n        result += line.collisions\n        line.update_collisions(collisions, one_ant)\n    for k in collisions:\n        result += collisions[k] + 1\n    print(result)\nfor _ in range(int(input())):\n    n = int(input())\n    solve(n)", "from collections import defaultdict\nt = int(input())\nfor _t in range(t):\n    n = int(input())\n    res = 0\n    ant_colony = defaultdict(list)\n    blocked_pc = [0] * n\n    blocked_nc = [0] * n\n    total_pc = [0] * n\n    total_nc = [0] * n\n    all_pc = [0] * n\n    all_nc = [0] * n\n    for i in range(n):\n        (m, *xs) = list(map(int, input().split()))\n        all_nc[i] = 0\n        for x in xs:\n            if x < 0:\n                all_nc[i] += 1\n                ant_colony[-x].append((i, 0))\n            else:\n                ant_colony[x].append((i, 1))\n        all_pc[i] = m - all_nc[i]\n    total_collision_at_0 = 0\n    for abs_val in sorted(ant_colony):\n        if len(ant_colony[abs_val]) == 1:\n            idx = ant_colony[abs_val][0][0]\n            if ant_colony[abs_val][0][1] == 0:\n                res += all_pc[idx]\n                res += blocked_nc[idx]\n                res -= blocked_pc[idx]\n                total_nc[idx] += 1\n            else:\n                res += all_nc[idx]\n                res += blocked_pc[idx]\n                res -= blocked_nc[idx]\n                total_pc[idx] += 1\n        else:\n            total_collision_at_0 += 1\n            for (idx, pnp) in ant_colony[abs_val]:\n                if pnp == 0:\n                    res += total_pc[idx]\n                    res -= blocked_pc[idx]\n                    total_nc[idx] += 1\n                    res += all_nc[idx]\n                    res -= total_nc[idx]\n                    res += blocked_nc[idx]\n                    blocked_nc[idx] += 1\n                else:\n                    res += total_nc[idx]\n                    res -= blocked_nc[idx]\n                    total_pc[idx] += 1\n                    res += all_pc[idx]\n                    res -= total_pc[idx]\n                    res += blocked_pc[idx]\n                    blocked_pc[idx] += 1\n    print(total_collision_at_0 + res // 2)", "import sys\nfrom bisect import *\nfrom collections import *\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef st():\n    return input().rstrip('\\n')\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\nt = inp()\nwhile t:\n    t -= 1\n    n = inp()\n    ha = []\n    d = {}\n    for i in range(n):\n        a = lis()\n        a = a[1:]\n        ha.append(a)\n        for j in range(len(a)):\n            try:\n                d[abs(a[j])] += 1\n            except:\n                d[abs(a[j])] = 1\n    r = 0\n    for i in d.keys():\n        r += d[i] > 1\n    for i in range(n):\n        for j in range(len(ha[i])):\n            z = ha[i][j]\n            if d[abs(z)] > 1:\n                if z < 0:\n                    r += j\n                else:\n                    r += len(ha[i]) - j - 1\n            elif z > 0:\n                r += bisect_left(ha[i], -z)\n            else:\n                r += len(ha[i]) - bisect_right(ha[i], -z)\n    print(r)", "def solve(ant_dict, N):\n    num_collisions = 0\n    center_times = dict()\n    for i in range(N):\n        for ant in ant_dict[i]:\n            dist = abs(ant)\n            if dist not in center_times:\n                center_times[dist] = 0\n            if center_times[dist] == 1:\n                num_collisions += 1\n            center_times[dist] += 1\n    for i in range(N):\n        num_pos_behind = 0\n        num_neg_behind = 0\n        prev_ant = 0\n        for ant in ant_dict[i]:\n            if ant > 0:\n                if center_times[abs(ant)] > 1:\n                    num_collisions += num_pos_behind\n                else:\n                    num_collisions += num_neg_behind\n                    if abs(ant) == abs(prev_ant):\n                        num_collisions -= 1\n                num_pos_behind += 1\n            else:\n                if center_times[abs(ant)] > 1:\n                    num_collisions += num_neg_behind\n                else:\n                    num_collisions += num_pos_behind\n                    if abs(ant) == abs(prev_ant):\n                        num_collisions -= 1\n                num_neg_behind += 1\n    return num_collisions\nfor _ in range(int(input())):\n    N = int(input())\n    ant_dict = {i: [] for i in range(N)}\n    for i in range(N):\n        ant_dict[i] = list(map(int, input().split()))[1:]\n        sort_key = lambda x: -x if x > 0 else x + 0.5\n        ant_dict[i].sort(key=sort_key)\n    print(solve(ant_dict, N))", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    (c, a) = ([[0 for _ in range(2)] for _ in range(n)], defaultdict(list))\n    for i in range(n):\n        for j in list(map(int, input().split()))[1:]:\n            if j < 0:\n                c[i][0] += 1\n                a[-j].append([i, 0])\n            else:\n                c[i][1] += 1\n                a[j].append([i, 1])\n    ans = 0\n    for i in sorted(a.keys()):\n        if len(a[i]) > 1:\n            ans += 1\n            for j in a[i]:\n                c[j[0]][j[1]] -= 1\n                ans += c[j[0]][j[1]]\n        else:\n            c[a[i][0][0]][a[i][0][1]] -= 1\n            ans += c[a[i][0][0]][a[i][0][1] ^ 1]\n    print(ans)", "import base64, codecs\nmagic = 'ZGVmIGdldGludHMoKToKICAgIHJldHVybiBsaXN0KG1hcChpbnQsIGlucHV0KCkuc3BsaXQoKSkpCgoKVCA9IGludChpbnB1dCgpKQoKZm9yIF8gaW4gcmFuZ2UoVCk6CiAgICBuID0gaW50KGlucHV0KCkpCgogICAgYW50cyA9IFtdCiAgICByZW0gPSBbXQoKICAgIGZvciBpIGluIHJhbmdlKG4pOgogICAgICAgIG0sICpwb3MgPSBnZXRpbnRzKCkKICAgICAgICByZW0uYXBwZW5kKFswLCAwXSkKICAgICAgICBmb'\nlove = '3VtrPOcovOjo3Z6PvNtVPNtVPNtVPNtVTyzVUttCvNjBtbtVPNtVPNtVPNtVPNtVPNtLJ50pl5upUOyozDbXUtfVTxfVQNcXDbtVPNtVPNtVPNtVPNtVPNtpzIgJl0kKIfjKFNeCFNkPvNtVPNtVPNtVPNtVTIfp2H6PvNtVPNtVPNtVPNtVPNtVPOuoaEmYzSjpTIhMPtbYKtfVTxfVQRcXDbtVPNtVPNtVPNtVPNtVPNtpzIgJl0kKIfkKFNeCFNkPvNtVPOuoaEmYaAipaDbXDbXVPNtVTShplN9VQNXPvNtVPOhK2ShqU'\ngod = 'MgPSBsZW4oYW50cykKICAgIGkgPSAwCiAgICB3aGlsZSBpIDwgbl9hbnRzOgogICAgICAgIGEgPSBbYW50c1tpXV0KICAgICAgICBpICs9IDEKICAgICAgICB3aGlsZSBpIDwgbl9hbnRzIGFuZCBhbnRzW2ldWzBdID09IGFbMF1bMF06CiAgICAgICAgICAgIGEuYXBwZW5kKGFudHNbaV0pCiAgICAgICAgICAgIGkgKz0gMQogICAgICAgIGlmIGxlbihhKSA+IDE6CiAgICAgICAgICAgIGFucyArPSAxCiAgICAgICA'\ndestiny = 'tVPNtVTMipvOuoaDtnJ4tLGbXVPNtVPNtVPNtVPNtVPNtVUWyoIguoaEoZI1qJ2ShqSflKI0tYG0tZDbtVPNtVPNtVPNtVPNtVPNtLJ5mVPf9VUWyoIguoaEoZI1qJ2ShqSflKI0XVPNtVPNtVPOyoUAyBtbtVPNtVPNtVPNtVPOuoaDtCFOuJmOqPvNtVPNtVPNtVPNtVUWyoIguoaEoZI1qJ2ShqSflKI0tYG0tZDbtVPNtVPNtVPNtVPOuoaZtXm0tpzIgJ2ShqSfkKI1oZFNgVTShqSflKI0XVPNtVUOlnJ50XTShplxX'\njoy = 'rot13'\ntrust = eval('magic') + eval('codecs.decode(love, joy)') + eval('god') + eval('codecs.decode(destiny, joy)')\neval(compile(base64.b64decode(eval('trust')), '<string>', 'exec'))", "for _ in range(int(input())):\n    n = int(input())\n    ants = []\n    count = []\n    for i in range(n):\n        (m, *x) = map(int, input().strip().split())\n        pos = 0\n        for p in x:\n            pos += int(p > 0)\n            ants.append((p, i))\n        count.append([pos, m - pos])\n    ants.sort(key=lambda x: abs(x[0]), reverse=True)\n    collisions = 0\n    while len(ants) > 0:\n        p = abs(ants[-1][0])\n        handle_orgy = []\n        while len(ants) > 0 and p == abs(ants[-1][0]):\n            handle_orgy.append(ants.pop())\n        if len(handle_orgy) > 1:\n            for (pos, line) in handle_orgy:\n                count[line][pos < 0] -= 1\n                collisions += count[line][pos < 0]\n            collisions += 1\n        else:\n            count[handle_orgy[0][1]][handle_orgy[0][0] < 0] -= 1\n            collisions += count[handle_orgy[0][1]][handle_orgy[0][0] > 0]\n    print(collisions)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    points = []\n    stats = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        j = 1\n        x1 = 0\n        x2 = 0\n        while a[0] >= j:\n            if a[j] > 0:\n                x = 1\n                y = a[j]\n                x1 += 1\n            else:\n                x = 0\n                y = a[j] * -1\n                x2 += 1\n            points.append([y, x, i])\n            j += 1\n        stats.append([x1, x2])\n    points.sort(key=lambda x: x[0])\n    i = 0\n    j = 0\n    ans = 0\n    m = len(points)\n    while m > i:\n        x = points[i][0]\n        y = points[i][0]\n        while 1:\n            j += 1\n            if m > j:\n                y = points[j][0]\n            if x != y or m == j:\n                if j - i == 1:\n                    if points[i][1] == 1:\n                        ans += stats[points[i][2]][1]\n                        stats[points[i][2]][0] -= 1\n                    else:\n                        ans += stats[points[i][2]][0]\n                        stats[points[i][2]][1] -= 1\n                else:\n                    ans += 1\n                    for k in range(i, j):\n                        if points[k][1] == 1:\n                            ans += stats[points[k][2]][0] - 1\n                            stats[points[k][2]][0] = max(stats[points[k][2]][0] - 1, 0)\n                        else:\n                            ans += stats[points[k][2]][1] - 1\n                            stats[points[k][2]][1] = max(stats[points[k][2]][1] - 1, 0)\n                break\n        i = j\n    print(ans)", "from collections import defaultdict\nimport bisect\nt = int(input())\nfor wer in range(t):\n    n = int(input())\n    di = defaultdict(int)\n    li = []\n    an = 0\n    for i in range(n):\n        li1 = list(map(int, input().split()))\n        m = li1[0]\n        li1 = li1[1:]\n        for x in li1:\n            di[abs(x)] += 1\n        li1.sort()\n        li.append(li1)\n    for x in di:\n        if di[x] > 1:\n            an += 1\n    for i in range(n):\n        for j in range(len(li[i])):\n            abc = 0\n            if di[abs(li[i][j])] <= 1:\n                x = -1 * li[i][j]\n                if li[i][j] <= 0:\n                    abc = len(li[i]) - bisect.bisect_right(li[i], x, 0, len(li[i]))\n                else:\n                    abc = bisect.bisect_left(li[i], x, 0, len(li[i]))\n            elif li[i][j] <= 0:\n                abc = j\n            else:\n                abc = len(li[i]) - j - 1\n            an += abc\n    print(an)", "import heapq\nfrom collections import defaultdict\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    lines = []\n    Ms = []\n    n_ants = 0\n    for _ in range(N):\n        (Mi, *Xs) = [int(i) for i in input().split()]\n        n_ants += Mi\n        Ms.append(Mi)\n        lines.append([-float('inf'), *Xs, float('inf')])\n    pp = []\n    np = []\n    heap = []\n    for (line_idx, line) in enumerate(lines):\n        for (i, ant) in enumerate(line):\n            if ant > 0:\n                pp.append(i)\n                np.append(i - 1)\n                heapq.heappush(heap, (abs(ant), ant > 0, line_idx))\n                heapq.heappush(heap, (abs(line[i - 1]), line[i - 1] > 0, line_idx))\n                break\n    s = sum(((Ms[i] - np[i]) * np[i] for i in range(N)))\n    pointers = {True: pp, False: np}\n    ant_count = 0\n    while ant_count < n_ants:\n        (abs_v, sign_v, idx_line) = heap[0]\n        pointers[sign_v][idx_line] += 1 if sign_v else -1\n        heapq.heapreplace(heap, (abs(lines[idx_line][pointers[sign_v][idx_line]]), sign_v, idx_line))\n        ant_count += 1\n        if heap[0][0] != abs_v:\n            continue\n        s += 1\n        c_count = defaultdict(int)\n        c_count[idx_line] += 1 if sign_v else 2\n        while heap[0][0] == abs_v:\n            (abs_v, sign_v, idx_line) = heap[0]\n            pointers[sign_v][idx_line] += 1 if sign_v else -1\n            heapq.heapreplace(heap, (abs(lines[idx_line][pointers[sign_v][idx_line]]), sign_v, idx_line))\n            ant_count += 1\n            c_count[idx_line] += 1 if sign_v else 2\n        for (i, count) in c_count.items():\n            if count == 2:\n                s -= Ms[i] - pp[i] + 1 - np[i]\n            elif count == 1:\n                s += Ms[i] - pp[i] + 1 - np[i]\n            elif count == 3:\n                s -= 1\n            else:\n                print('WE WILL ROCK YOU')\n    print(s)", "import heapq\nfrom collections import defaultdict\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    lines = []\n    Ms = []\n    n_ants = 0\n    for _ in range(N):\n        (Mi, *Xs) = [int(i) for i in input().split()]\n        n_ants += Mi\n        Ms.append(Mi)\n        lines.append([-float('inf'), *Xs, float('inf')])\n    pp = []\n    np = []\n    heap = []\n    for (line_idx, line) in enumerate(lines):\n        for (i, ant) in enumerate(line):\n            if ant > 0:\n                pp.append(i)\n                np.append(i - 1)\n                heapq.heappush(heap, (abs(ant), ant > 0, line_idx))\n                heapq.heappush(heap, (abs(line[i - 1]), line[i - 1] > 0, line_idx))\n                break\n    s = sum(((Ms[i] - np[i]) * np[i] for i in range(N)))\n    pointers = {True: pp, False: np}\n    ant_count = 0\n    while ant_count < n_ants:\n        (abs_v, sign_v, idx_line) = heap[0]\n        pointers[sign_v][idx_line] += 1 if sign_v else -1\n        heapq.heapreplace(heap, (abs(lines[idx_line][pointers[sign_v][idx_line]]), sign_v, idx_line))\n        ant_count += 1\n        if heap[0][0] != abs_v:\n            continue\n        s += 1\n        c_count = defaultdict(int)\n        c_count[idx_line] += 1 if sign_v else 2\n        while heap[0][0] == abs_v:\n            (abs_v, sign_v, idx_line) = heap[0]\n            pointers[sign_v][idx_line] += 1 if sign_v else -1\n            heapq.heapreplace(heap, (abs(lines[idx_line][pointers[sign_v][idx_line]]), sign_v, idx_line))\n            ant_count += 1\n            c_count[idx_line] += 1 if sign_v else 2\n        for (i, count) in c_count.items():\n            if count == 0:\n                continue\n            elif count == 2:\n                s -= Ms[i] - pp[i] + 1 - np[i]\n            elif count == 1:\n                s += Ms[i] - pp[i] + 1 - np[i]\n            elif count == 3:\n                s -= 1\n            else:\n                print('WE WILL ROCK YOU')\n    print(s)", "from collections import defaultdict as dd\n\ndef bs(trg, arr, m):\n    lo = 0\n    hi = m\n    while hi - lo > 1:\n        mi = (hi + lo) // 2\n        if arr[mi] > trg:\n            hi = mi\n        else:\n            lo = mi\n    return lo\n\ndef solve():\n    n = int(input())\n    ans = 0\n    pants = dd(dict)\n    nants = dd(dict)\n    nums = set()\n    ms = []\n    mat = []\n    for i in range(n):\n        line = list(map(int, input().split()))\n        ms.append(line[0])\n        ps = set()\n        ns = set()\n        mat.append(line[1:])\n        for (j, num) in enumerate(line[1:]):\n            if num > 0:\n                pants[num][i] = j\n            else:\n                nants[-num][i] = j\n            nums.add(abs(num))\n    nums = sorted(nums)\n    for num in nums:\n        if len(pants[num]) + len(nants[num]) > 1:\n            ans += 1\n            for (i, j) in pants[num].items():\n                ans += ms[i] - j - 1\n            for (i, j) in nants[num].items():\n                ans += j\n        else:\n            for (i, j) in nants[num].items():\n                ans += ms[i] - bs(num, mat[i], ms[i]) - 1\n            for (i, j) in pants[num].items():\n                j = bs(-num, mat[i], ms[i])\n                if mat[i][j] <= -num:\n                    ans += j + 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    print(solve())", "def bos(c, p, s):\n    l = len(p)\n    for i in range(s, l):\n        if p[i] == c:\n            return (0, i)\n        elif p[i] > c:\n            return (l - i, i)\n    return (0, l)\n\ndef main():\n    for cases in range(int(input())):\n        n = int(input())\n        d = dict()\n        for i in range(n):\n            k = [int(x) for x in input().split()]\n            k = k[1:]\n            a = []\n            b = []\n            for x in k:\n                if x > 0:\n                    a.append(x)\n                else:\n                    b.append(-x)\n            b.reverse()\n            s = 0\n            for j in range(len(a)):\n                if a[j] in d:\n                    d[a[j]][0] = 1\n                    d[a[j]][2] += len(a) - j - 1\n                else:\n                    d[a[j]] = [0, 0, 0]\n                    (d[a[j]][1], s) = bos(a[j], b, s)\n                    d[a[j]][2] = len(a) - j - 1\n            s = 0\n            for j in range(len(b)):\n                if b[j] in d:\n                    d[b[j]][0] = 1\n                    d[b[j]][2] += len(b) - j - 1\n                else:\n                    d[b[j]] = [0, 0, 0]\n                    (d[b[j]][1], s) = bos(b[j], a, s)\n                    d[b[j]][2] = len(b) - j - 1\n        ans = 0\n        for i in d.values():\n            if i[0] == 0:\n                ans += i[1]\n            else:\n                ans += i[2] + 1\n        print(ans)\nmain()", "import sys\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    M = []\n    if N == 1:\n        row = list((int(x) for x in input().split()[1:]))\n        neg = 0\n        pos = 0\n        for r in row:\n            if r < 0:\n                neg += 1\n            else:\n                pos += 1\n        print(int(neg * pos))\n    else:\n        A_pos = []\n        A_neg = []\n        total_pos_len = 0\n        total_neg_len = 0\n        total_collisions = 0\n        collision = {}\n        pos_lens = []\n        neg_lens = []\n        pos_collided = []\n        neg_collided = []\n        for j in range(N):\n            row = list((int(x) for x in sys.stdin.readline().strip().split()))\n            index = 0\n            M = row[0]\n            ants = row[1:]\n            if ants[0] > 0:\n                index = 0\n            elif ants[-1] < 0:\n                index = M\n            else:\n                for j in range(M - 1):\n                    if ants[j] < 0 and ants[j + 1] > 0:\n                        index = j + 1\n                        break\n            neg_row = ants[:index]\n            neg_row.reverse()\n            pos_row = ants[index:]\n            neg_len = index\n            pos_len = M - index\n            A_pos.append(pos_row)\n            A_neg.append(neg_row)\n            total_pos_len += pos_len\n            total_neg_len += neg_len\n            pos_lens.append(pos_len)\n            neg_lens.append(neg_len)\n        for a1 in A_pos:\n            for a in a1:\n                if a in collision.keys():\n                    collision[a] += 1\n                else:\n                    collision[a] = 1\n        for a1 in A_neg:\n            for a in a1:\n                if -a in collision.keys():\n                    collision[-a] += 1\n                else:\n                    collision[-a] = 1\n        for a in collision.keys():\n            if collision[a] > 1:\n                total_collisions += 1\n        dual_collisions = 0\n        for i in range(N):\n            i1 = 0\n            i2 = 0\n            pos_origin_collide = 0\n            pos_origin = 0\n            neg_origin_collide = 0\n            neg_origin = 0\n            pos_len = pos_lens[i]\n            neg_len = neg_lens[i]\n            while i1 < pos_len and i2 < neg_len:\n                if A_pos[i][i1] + A_neg[i][i2] < 0:\n                    if collision[A_pos[i][i1]] > 1:\n                        dual_collisions += neg_origin - neg_origin_collide\n                        dual_collisions += pos_origin_collide\n                        dual_collisions += pos_len - pos_origin - 1\n                        pos_origin_collide += 1\n                    else:\n                        dual_collisions += neg_len - neg_origin_collide\n                        dual_collisions += pos_origin_collide\n                    pos_origin += 1\n                    i1 += 1\n                elif A_pos[i][i1] == -A_neg[i][i2]:\n                    dual_collisions += neg_origin - neg_origin_collide\n                    dual_collisions += pos_origin - pos_origin_collide\n                    dual_collisions += pos_origin_collide\n                    dual_collisions += neg_origin_collide\n                    dual_collisions += pos_len - pos_origin - 1\n                    dual_collisions += neg_len - neg_origin - 1\n                    pos_origin_collide += 1\n                    pos_origin += 1\n                    neg_origin += 1\n                    neg_origin_collide += 1\n                    i1 += 1\n                    i2 += 1\n                else:\n                    if collision[-A_neg[i][i2]] > 1:\n                        dual_collisions += pos_origin - pos_origin_collide\n                        dual_collisions += neg_origin_collide\n                        dual_collisions += neg_len - neg_origin - 1\n                        neg_origin_collide += 1\n                    else:\n                        dual_collisions += pos_len - pos_origin_collide\n                        dual_collisions += neg_origin_collide\n                    neg_origin += 1\n                    i2 += 1\n            while i1 < pos_len:\n                if collision[A_pos[i][i1]] > 1:\n                    dual_collisions += neg_origin - neg_origin_collide\n                    dual_collisions += pos_origin_collide\n                    dual_collisions += pos_len - pos_origin - 1\n                    pos_origin_collide += 1\n                else:\n                    dual_collisions += neg_len - neg_origin_collide\n                    dual_collisions += pos_origin_collide\n                pos_origin += 1\n                i1 += 1\n            while i2 < neg_len:\n                if collision[-A_neg[i][i2]] > 1:\n                    dual_collisions += pos_origin - pos_origin_collide\n                    dual_collisions += neg_origin_collide\n                    dual_collisions += neg_len - neg_origin - 1\n                    neg_origin_collide += 1\n                else:\n                    dual_collisions += pos_len - pos_origin_collide\n                    dual_collisions += neg_origin_collide\n                neg_origin += 1\n                i2 += 1\n        ans = total_collisions + 0.5 * dual_collisions\n        print(int(ans))", "from collections import defaultdict\nfor _ in range(int(input())):\n    ny = int(input())\n    mai_1 = []\n    mai_2 = []\n    mfqr = defaultdict(lambda : 0)\n    moi = []\n    for ii_ in range(ny):\n        listy = list(map(int, input().split()))\n        h = []\n        j = []\n        moi.append(listy[0])\n        for i in range(1, listy[0] + 1):\n            mfqr[abs(listy[i])] += 1\n            if listy[i] >= 0:\n                h.append(listy[i])\n            else:\n                j.append(abs(listy[i]))\n        mai_1.append(h)\n        mai_2.append(j[::-1])\n    fg = 0\n    for i in range(ny):\n        (po_x, ne_y) = (0, 0)\n        (p, q) = (len(mai_1[i]), len(mai_2[i]))\n        (x, y, z, w) = (0, 0, 0, 0)\n        (c1, c2, c3, c4) = (0, 0, 0, 0)\n        while po_x < p and ne_y < q:\n            if mai_1[i][po_x] < mai_2[i][ne_y]:\n                if mfqr[mai_1[i][po_x]] > 1:\n                    for k in range(max(x, 0), p):\n                        if mai_1[i][k] > mai_1[i][po_x]:\n                            break\n                        else:\n                            c1 += 1\n                    x = k\n                    fg += p - c1\n                    po_x += 1\n                else:\n                    for k in range(max(y, 0), q):\n                        if mai_2[i][k] > mai_1[i][po_x]:\n                            break\n                        else:\n                            c2 += 1\n                    y = k\n                    fg += q - c2\n                    po_x += 1\n            elif mfqr[mai_2[i][ne_y]] > 1:\n                for k in range(max(z, 0), q):\n                    if mai_2[i][k] > mai_2[i][ne_y]:\n                        break\n                    else:\n                        c3 += 1\n                z = k\n                fg += q - c3\n                ne_y += 1\n            else:\n                for k in range(max(w, 0), p):\n                    if mai_1[i][k] > mai_2[i][ne_y]:\n                        break\n                    else:\n                        c4 += 1\n                w = k\n                fg += p - c4\n                ne_y += 1\n        if ne_y < q:\n            for j in range(ne_y, q):\n                if mfqr[mai_2[i][j]] == 1:\n                    continue\n                else:\n                    fg += q - (j + 1)\n        if po_x < p:\n            for j in range(po_x, p):\n                if mfqr[mai_1[i][j]] == 1:\n                    continue\n                else:\n                    fg += p - (j + 1)\n    for i in mfqr.values():\n        if i > 1:\n            fg += 1\n    print(fg)", "from collections import Counter\n\ndef b_s_n(lst, lst_len):\n    (l, h) = (0, lst_len)\n    while l < h:\n        mid = (l + h) // 2\n        if lst[mid] < 0:\n            l += 1\n        else:\n            h = mid\n    return l\n\ndef b_s(lst, lst_len, l, target):\n    if target > lst[lst_len - 1]:\n        return lst_len - 1\n    h = lst_len - 1\n    while l < h:\n        mid = (l + h) // 2\n        if lst[mid] < target:\n            l = mid + 1\n        else:\n            h = mid\n    return l\n\ndef Gawen():\n    centre_collisions = sorted([i for i in Gawen_ants if Gawen_ants[i] > 1])\n    cc_num = len(centre_collisions)\n    collisions = cc_num\n    if not collisions:\n        for (i, j) in ant_steasy:\n            collisions += i * j\n        return collisions\n    for (line_idx, line) in enumerate(lines):\n        cc_idx = 0\n        for (ant_idx, ant) in enumerate(line):\n            if cc_idx < cc_num:\n                cc_idx = b_s(centre_collisions, cc_num, cc_idx, abs(ant))\n            if abs(ant) == centre_collisions[cc_idx]:\n                if ant < 0:\n                    ant_steasy[line_idx][0] -= 1\n                    collisions += ant_steasy[line_idx][0]\n                else:\n                    ant_steasy[line_idx][1] -= 1\n                    collisions += ant_steasy[line_idx][1]\n            elif ant < 0:\n                ant_steasy[line_idx][0] -= 1\n                collisions += ant_steasy[line_idx][1]\n            else:\n                ant_steasy[line_idx][1] -= 1\n                collisions += ant_steasy[line_idx][0]\n    return collisions\nfor _ in range(int(input())):\n    N = int(input())\n    Gawen_ants = []\n    lines = []\n    ant_steasy = []\n    for i in range(N):\n        (M, *ants) = list(map(int, input().split()))\n        Gawen_ants.extend(list(map(abs, ants)))\n        idx = 0\n        negs = b_s_n(ants, M)\n        ant_steasy.append([negs, M - negs])\n        ants.sort(key=abs)\n        lines.append(ants)\n    Gawen_ants = Counter(Gawen_ants)\n    print(Gawen())", "from collections import Counter\n\ndef b_s_n(lst, lst_len):\n    (l, h) = (0, lst_len)\n    while l < h:\n        mid = (l + h) // 2\n        if lst[mid] < 0:\n            l += 1\n        else:\n            h = mid\n    return l\n\ndef b_s(lst, lst_len, l, target):\n    if target > lst[lst_len - 1]:\n        return lst_len - 1\n    h = lst_len - 1\n    while l < h:\n        mid = (l + h) // 2\n        if lst[mid] < target:\n            l = mid + 1\n        else:\n            h = mid\n    return l\n\ndef solve():\n    centre_collisions = sorted([i for i in all_ants if all_ants[i] > 1])\n    cc_num = len(centre_collisions)\n    collisions = cc_num\n    if not collisions:\n        for (i, j) in ant_dirs:\n            collisions += i * j\n        return collisions\n    for (line_idx, line) in enumerate(lines):\n        cc_idx = 0\n        for (ant_idx, ant) in enumerate(line):\n            if cc_idx < cc_num:\n                cc_idx = b_s(centre_collisions, cc_num, cc_idx, abs(ant))\n            if abs(ant) == centre_collisions[cc_idx]:\n                if ant < 0:\n                    ant_dirs[line_idx][0] -= 1\n                    collisions += ant_dirs[line_idx][0]\n                else:\n                    ant_dirs[line_idx][1] -= 1\n                    collisions += ant_dirs[line_idx][1]\n            elif ant < 0:\n                ant_dirs[line_idx][0] -= 1\n                collisions += ant_dirs[line_idx][1]\n            else:\n                ant_dirs[line_idx][1] -= 1\n                collisions += ant_dirs[line_idx][0]\n    return collisions\nfor _ in range(int(input())):\n    N = int(input())\n    all_ants = []\n    lines = []\n    ant_dirs = []\n    for i in range(N):\n        (M, *ants) = list(map(int, input().split()))\n        all_ants.extend(list(map(abs, ants)))\n        idx = 0\n        negs = b_s_n(ants, M)\n        ant_dirs.append([negs, M - negs])\n        ants.sort(key=abs)\n        lines.append(ants)\n    all_ants = Counter(all_ants)\n    print(solve())", "from collections import Counter\n\ndef b_s_n(lst, lst_len):\n    (l, h) = (0, lst_len)\n    while l < h:\n        mid = (l + h) // 2\n        if lst[mid] < 0:\n            l += 1\n        else:\n            h = mid\n    return l\n\ndef b_s(lst, lst_len, l, target):\n    if target > lst[lst_len - 1]:\n        return lst_len - 1\n    h = lst_len - 1\n    while l < h:\n        mid = (l + h) // 2\n        if lst[mid] < target:\n            l = mid + 1\n        else:\n            h = mid\n    return l\n\ndef solve():\n    centre_collisions = sorted([i for i in all_ants if all_ants[i] > 1])\n    cc_num = len(centre_collisions)\n    collisions = cc_num\n    if not collisions:\n        for (i, j) in ant_dirs:\n            collisions += i * j\n        return collisions\n    for (line_idx, line) in enumerate(lines):\n        cc_idx = 0\n        for (ant_idx, ant) in enumerate(line):\n            if cc_idx < cc_num:\n                cc_idx = b_s(centre_collisions, cc_num, cc_idx, abs(ant))\n            if abs(ant) == centre_collisions[cc_idx]:\n                if ant < 0:\n                    ant_dirs[line_idx][0] -= 1\n                    collisions += ant_dirs[line_idx][0]\n                else:\n                    ant_dirs[line_idx][1] -= 1\n                    collisions += ant_dirs[line_idx][1]\n            elif ant < 0:\n                ant_dirs[line_idx][0] -= 1\n                collisions += ant_dirs[line_idx][1]\n            else:\n                ant_dirs[line_idx][1] -= 1\n                collisions += ant_dirs[line_idx][0]\n    return collisions\nfor _ in range(int(input())):\n    N = int(input())\n    all_ants = []\n    lines = []\n    ant_dirs = []\n    for i in range(N):\n        (M, *ants) = list(map(int, input().split()))\n        all_ants.extend(list(map(abs, ants)))\n        idx = 0\n        negs = b_s_n(ants, M)\n        ant_dirs.append([negs, M - negs])\n        ants.sort(key=abs)\n        lines.append(ants)\n    all_ants = Counter(all_ants)\n    print(solve())"]