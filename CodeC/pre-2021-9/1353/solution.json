["import itertools\nimport math\n\nclass Main:\n\n    def __init__(self):\n        iterable = self.__standard()\n        self.__solution(iterable)\n\n    def __solution(self, iterable):\n        (cases,) = map(int, next(iterable).split())\n        for _test in range(cases):\n            (remainder, prime) = map(int, next(iterable).split())\n            sqrt5 = self.__sqrt(5, prime)\n            normalized = remainder * sqrt5 % prime\n            half = pow(2, prime - 2, prime)\n            phi = (1 + sqrt5) * half % prime\n            b = -normalized % prime\n            D = b * b - 4\n            candidates = []\n            try:\n                d = self.__sqrt(D % prime, prime)\n            except ValueError:\n                pass\n            else:\n                candidates.append(((-b + d) * half % prime, 1))\n                candidates.append(((-b - d) * half % prime, 1))\n            D = b * b + 4\n            try:\n                d = self.__sqrt(D % prime, prime)\n            except ValueError:\n                pass\n            else:\n                candidates.append(((-b + d) * half % prime, 0))\n                candidates.append(((-b - d) * half % prime, 0))\n            solutions = []\n            for (x, category) in candidates:\n                for index in self.__logarithm(x, phi, prime, category):\n                    solutions.append(index)\n            try:\n                result = min(solutions)\n            except ValueError:\n                result = -1\n            print(result)\n\n    def __logarithm(self, power, base, prime, category):\n        basePeriod = self.__period(base, prime)\n        powerPeriod = self.__period(power, prime)\n        if basePeriod % powerPeriod:\n            return\n        for index in self.__discreteLogarithm(power, base, prime):\n            if index & 1 == category:\n                yield index\n            else:\n                future = index + basePeriod\n                if future < prime and future & 1 == category:\n                    yield future\n            return\n\n    def __discreteLogarithm(self, number, base, prime):\n        limit = math.ceil(prime ** 0.5)\n        lookup = {}\n        for small in range(limit):\n            lookup.setdefault(pow(base, small, prime), small)\n        current = number\n        multiplier = pow(base, prime - 1 - limit, prime)\n        for large in range(limit):\n            try:\n                small = lookup[current]\n            except KeyError:\n                pass\n            else:\n                yield (limit * large + small)\n                return\n            current = current * multiplier % prime\n\n    def __sqrt(self, square, prime):\n        if not square:\n            return 0\n        if pow(square, prime - 1 >> 1, prime) != 1:\n            raise ValueError()\n        (odd, even) = (prime - 1, 0)\n        while not odd & 1:\n            odd >>= 1\n            even += 1\n        for generator in range(1, prime):\n            if pow(generator, prime - 1 >> 1, prime) != 1:\n                break\n        else:\n            raise AssertionError()\n        result = pow(square, odd + 1 >> 1, prime)\n        off = pow(square, odd, prime)\n        constant = pow(generator, odd, prime)\n        remaining = even\n        while True:\n            forecast = off\n            distance = 0\n            for distance in range(remaining):\n                if forecast == 1:\n                    break\n                forecast = forecast * forecast % prime\n            if distance == 0:\n                return result\n            constroot = pow(constant, 1 << remaining - distance - 1, prime)\n            constant = constroot * constroot % prime\n            result = result * constroot % prime\n            off = off * constant % prime\n            remaining = distance\n\n    def __period(self, base, modulo):\n        index = modulo - 1\n        for (prime, exponent) in self.__factors(index):\n            for _iteration in range(exponent):\n                test = index // prime\n                if pow(base, test, modulo) == 1:\n                    index = test\n                else:\n                    break\n        return index\n\n    def __factors(self, number):\n        if not number & 1:\n            count = (number ^ number - 1).bit_length() - 1\n            number >>= count\n            yield (2, count)\n        for divisor in itertools.count(3, 2):\n            if divisor * divisor > number:\n                break\n            if not number % divisor:\n                number //= divisor\n                count = 1\n                while not number % divisor:\n                    number //= divisor\n                    count += 1\n                yield (divisor, count)\n        if number > 1:\n            yield (number, 1)\n\n    def __test(self):\n        yield '4'\n        yield '0 11'\n        yield '16 19'\n        yield '18 19'\n        yield '4 19'\n\n    def __standard(self):\n        try:\n            while True:\n                yield input()\n        except EOFError:\n            pass\nMain()"]