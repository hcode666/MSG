["from math import log2\n\ndef dfs(s, p, l):\n    stack = [s]\n    p[s] = s\n    l[s] = 1\n    while stack:\n        x = stack.pop()\n        for y in Tree[x]:\n            if not l[y]:\n                p[y] = x\n                l[y] = l[x] + 1\n                stack.append(y)\n\ndef searchLCA(x, y):\n    if l[x] > l[y]:\n        (x, y) = (y, x)\n    d = l[y] - l[x]\n    if d != 0:\n        for i in range(MAX2 - 1, -1, -1):\n            if d >= 1 << i:\n                d -= 1 << i\n                y = pp[y][i]\n    if x == y:\n        return x + 1\n    for i in range(MAX2 - 1, -1, -1):\n        if pp[x][i] != pp[y][i]:\n            x = pp[x][i]\n            y = pp[y][i]\n    return pp[x][0] + 1\nN = int(input())\nTree = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    (x, y) = map(int, input().split())\n    Tree[x - 1].append(y - 1)\n    Tree[y - 1].append(x - 1)\np = [None] * N\nl = [None] * N\ndfs(0, p, l)\nMAX2 = int(log2(max(l))) + 1\npp = [[None] * MAX2 for _ in range(N)]\nfor i in range(N):\n    pp[i][0] = p[i]\nfor j in range(1, MAX2):\n    for i in range(N):\n        pp[i][j] = pp[pp[i][j - 1]][j - 1]\nQ = int(input())\nfor _ in range(Q):\n    (r, x, y) = map(int, input().split())\n    rr = searchLCA(x - 1, y - 1)\n    xx = searchLCA(r - 1, y - 1)\n    yy = searchLCA(x - 1, r - 1)\n    if xx == yy:\n        print(rr)\n    elif xx == rr:\n        print(yy)\n    else:\n        print(xx)", "from math import log2\n\ndef dfs(s, p, l):\n    stack = [s]\n    p[s] = s\n    l[s] = 1\n    while stack:\n        x = stack.pop()\n        for y in Tree[x]:\n            if not l[y]:\n                p[y] = x\n                l[y] = l[x] + 1\n                stack.append(y)\n\ndef searchLCA(x, y):\n    if l[x] > l[y]:\n        (x, y) = (y, x)\n    d = l[y] - l[x]\n    if d != 0:\n        for i in range(MAX2 - 1, -1, -1):\n            if d >= 1 << i:\n                d -= 1 << i\n                y = pp[y][i]\n    if x == y:\n        return x + 1\n    for i in range(MAX2 - 1, -1, -1):\n        if pp[x][i] != pp[y][i]:\n            x = pp[x][i]\n            y = pp[y][i]\n    return pp[x][0] + 1\nN = int(input())\nTree = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    (x, y) = map(int, input().split())\n    Tree[x - 1].append(y - 1)\n    Tree[y - 1].append(x - 1)\np = [None] * N\nl = [None] * N\ndfs(0, p, l)\nMAX2 = int(log2(max(l))) + 1\npp = [[None] * MAX2 for _ in range(N)]\nfor i in range(N):\n    pp[i][0] = p[i]\nfor j in range(1, MAX2):\n    for i in range(N):\n        pp[i][j] = pp[pp[i][j - 1]][j - 1]\nQ = int(input())\nfor _ in range(Q):\n    (r, x, y) = map(int, input().split())\n    rr = searchLCA(x - 1, y - 1)\n    xx = searchLCA(r - 1, y - 1)\n    yy = searchLCA(x - 1, r - 1)\n    if xx == yy:\n        print(rr)\n    elif xx == rr:\n        print(yy)\n    else:\n        print(xx)", "def dfs(s, p, l):\n    stack = [s]\n    p[s] = s\n    while stack:\n        x = stack.pop()\n        for y in Tree[x]:\n            if p[y] == None:\n                p[y] = x\n                l[y] = l[x] + 1\n                stack.append(y)\n\ndef searchLCA(x, y):\n    if l[x] > l[y]:\n        (x, y) = (y, x)\n    d = l[y] - l[x]\n    if d != 0:\n        for i in range(MAX2 - 1, -1, -1):\n            if d >= 1 << i:\n                d -= 1 << i\n                y = pp[y][i]\n    if x == y:\n        return x + 1\n    for i in range(MAX2 - 1, -1, -1):\n        if pp[x][i] != pp[y][i]:\n            x = pp[x][i]\n            y = pp[y][i]\n    return pp[x][0] + 1\nN = int(input())\nTree = [[] for _ in range(N)]\nMAX2 = 20\nfor _ in range(N - 1):\n    (x, y) = map(int, input().split())\n    x -= 1\n    y -= 1\n    Tree[x].append(y)\n    Tree[y].append(x)\np = [None] * N\nl = [0] * N\ndfs(0, p, l)\npp = [[None] * MAX2 for _ in range(N)]\nfor i in range(N):\n    pp[i][0] = p[i]\nfor j in range(1, MAX2):\n    for i in range(N):\n        pp[i][j] = pp[pp[i][j - 1]][j - 1]\nQ = int(input())\nfor _ in range(Q):\n    (r, x, y) = map(int, input().split())\n    r -= 1\n    x -= 1\n    y -= 1\n    rr = searchLCA(x, y)\n    xx = searchLCA(r, y)\n    yy = searchLCA(x, r)\n    if xx == yy:\n        print(rr)\n    elif xx == rr:\n        print(yy)\n    else:\n        print(xx)", "from sys import stdin, stdout\nimport sys\nfrom math import log2\nsys.setrecursionlimit(10000000)\nI = stdin.readline\nn = int(I())\ngrph = {}\n\ndef dfs(grph, n, vis, par, st, lvl, p=-1):\n    par[st] = p\n    vis[st] = 1\n    if p == -1:\n        lvl[st] = 0\n    else:\n        lvl[st] = lvl[p] + 1\n    for i in grph[st]:\n        if vis[i] == -1:\n            dfs(grph, n, vis, par, i, lvl, st)\n\ndef lca(bit, lvl, x, y, log):\n    if lvl[x] < lvl[y]:\n        (x, y) = (y, x)\n    var = x\n    diff = lvl[x] - lvl[y]\n    while diff > 0:\n        ln2 = int(log2(diff))\n        var = bit[var][ln2]\n        diff -= 1 << ln2\n    for i in range(log):\n        if bit[var][i] != bit[y][i]:\n            var = bit[var][i]\n            y = bit[y][i]\n        else:\n            break\n    while var != y:\n        var = bit[var][0]\n        y = bit[y][0]\n    return var\nfor i in range(n - 1):\n    (u, v) = map(int, I().split())\n    if u in grph:\n        grph[u].append(v)\n    else:\n        grph[u] = [v]\n    if v in grph:\n        grph[v].append(u)\n    else:\n        grph[v] = [u]\nvis = {i: -1 for i in grph.keys()}\npar = {}\nkey = list(grph.keys())\nlvl = {}\ndfs(grph, n, vis, par, key[0], lvl)\nht = max(lvl.values()) + 1\nbit = {i: [] for i in key}\nlog = 0\nvar = ht\nwhile var > 1:\n    log += 1\n    var //= 2\nfor i in range(log + 1):\n    for j in key:\n        if i == 0:\n            bit[j].append(par[j])\n        elif bit[j][-1] == -1:\n            bit[j].append(-1)\n        else:\n            bit[j].append(bit[bit[j][i - 1]][i - 1])\nfor i in range(int(I())):\n    (r, u, v) = map(int, I().split())\n    (a, b, c) = (lca(bit, lvl, u, v, log + 1), lca(bit, lvl, r, u, log + 1), lca(bit, lvl, r, v, log + 1))\n    if a == b:\n        print(c)\n    elif b == c:\n        print(a)\n    else:\n        print(b)", "from math import inf\nfrom collections import namedtuple\n\nclass SegmentTree:\n\n    def __init__(self, arr):\n        self.N = len(arr)\n        self.st = [(inf, inf) for _ in range(2 * self.N)]\n        for (i, v) in enumerate(arr):\n            self.st[i + self.N] = arr[i]\n        for i in range(self.N - 1, 0, -1):\n            self.st[i] = min(self.st[i << 1], self.st[i << 1 | 1])\n\n    def query(self, left, right):\n        result = (inf, inf)\n        left += self.N\n        right += self.N\n        while left < right:\n            if left & 1:\n                result = min(result, self.st[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                result = min(result, self.st[right])\n            left >>= 1\n            right >>= 1\n        return result[1]\n\nclass Tree:\n\n    def __init__(self, root, adj):\n        self.root = root\n        self.euler = [(inf, inf) for _ in range(2 * len(adj))]\n        self.euler_start = [0 for _ in adj]\n        self.dfs(root, -1, 0, adj)\n        self.st = SegmentTree(self.euler)\n\n    def dfs(self, node, parent, height, adj):\n        self.euler_start[node] = len(self.euler)\n        self.euler.append((height, node))\n        for neighbor in adj[node]:\n            if neighbor != parent:\n                self.dfs(neighbor, node, height + 1, adj)\n                self.euler.append((height, node))\n\n    def query_lca(self, u, v):\n        (left, right) = (self.euler_start[u], self.euler_start[v])\n        if left > right:\n            (left, right) = (right, left)\n        return self.st.query(left, right + 1)\nQuery = namedtuple('Query', ['id', 'root', 'u', 'v'])\n\ndef main():\n    import sys\n    sys.setrecursionlimit(pow(10, 9))\n    node_count = int(sys.stdin.readline())\n    adj = [[] for _ in range(node_count + 1)]\n    for _ in range(node_count - 1):\n        (u, v) = (int(i) for i in sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    query_count = int(sys.stdin.readline())\n    queries = []\n    tree = Tree(1, adj)\n    for q in range(query_count):\n        (root, u, v) = (int(i) for i in sys.stdin.readline().split())\n        a = tree.query_lca(root, u)\n        b = tree.query_lca(root, v)\n        c = tree.query_lca(u, v)\n        if a == b == c:\n            print(a)\n        elif a == b:\n            print(c)\n        elif a == c:\n            print(b)\n        elif b == c:\n            print(a)\nmain()"]