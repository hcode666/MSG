["import sys\nfrom operator import itemgetter\nN = int(input().strip())\n\ndef cross(p, q, r):\n    return (p[0] - q[0]) * (r[1] - q[1]) - (p[1] - q[1]) * (r[0] - q[0])\n\ndef dist(p1, p2):\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n(U, L) = ([], [])\n\ndef Convex_hull(P):\n    global U, L\n    (U, L) = ([], [])\n    sz = len(P)\n    for i in range(sz):\n        while len(U) >= 2 and cross(U[-2], U[-1], P[i]) <= 0:\n            U.pop()\n        while len(L) >= 2 and cross(L[-2], L[-1], P[i]) >= 0:\n            L.pop()\n        L.append(P[i])\n        U.append(P[i])\n\ndef Find_maximization_pair():\n    global U, L\n    ans = 0\n    (P, Q) = (0, 0)\n    sizeU = len(U)\n    sizeL = len(L)\n    (i, j) = (0, sizeL - 1)\n    while 0 < j or i < sizeU - 1:\n        tmpdist = dist(U[i], L[j])\n        if tmpdist > ans:\n            (P, Q, ans) = (i, j, tmpdist)\n        if i == sizeU - 1:\n            j -= 1\n        elif j == 0:\n            i += 1\n        elif (U[i + 1][1] - U[i][1]) * (L[j][0] - L[j - 1][0]) > (U[i + 1][0] - U[i][0]) * (L[j][1] - L[j - 1][1]):\n            i += 1\n        else:\n            j -= 1\n    return ([U[P][2], L[Q][2]], ans)\n\ndef log_out(count, value):\n    s = str(value) + '\\n'\n    while count:\n        if count % 2:\n            sys.stdout.write(s)\n        s += s\n        count //= 2\n\ndef main():\n    ans = []\n    P = []\n    for i in range(1, N + 1):\n        s = sys.stdin.readline()\n        (x, y) = map(int, s.strip().split())\n        P.append((x, y, i))\n    P.sort(key=itemgetter(0, 1))\n    while len(P) > 1:\n        size = len(P)\n        Convex_hull(P)\n        (res, disT) = Find_maximization_pair()\n        maxx = max(res)\n        count = size - maxx + 1\n        ans.append((count, disT))\n        P = list(filter(lambda it: it[2] < maxx, P))\n    print(0)\n    for it in reversed(ans):\n        log_out(it[0], it[1])\nmain()", "import sys\nfrom operator import itemgetter\nN = int(input().strip())\n\ndef cross(p, q, r):\n    return (p[0] - q[0]) * (r[1] - q[1]) - (p[1] - q[1]) * (r[0] - q[0])\n\ndef dist(p1, p2):\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n(U, L) = ([], [])\n\ndef Convex_hull(P):\n    global U, L\n    (U, L) = ([], [])\n    sz = len(P)\n    for i in range(sz):\n        while len(U) >= 2 and cross(U[-2], U[-1], P[i]) <= 0:\n            U.pop()\n        while len(L) >= 2 and cross(L[-2], L[-1], P[i]) >= 0:\n            L.pop()\n        L.append(P[i])\n        U.append(P[i])\n\ndef Find_maximization_pair():\n    global U, L\n    ans = 0\n    (P, Q) = (0, 0)\n    sizeU = len(U)\n    sizeL = len(L)\n    (i, j) = (0, sizeL - 1)\n    while 0 < j or i < sizeU - 1:\n        tmpdist = dist(U[i], L[j])\n        if tmpdist > ans:\n            (P, Q, ans) = (i, j, tmpdist)\n        if i == sizeU - 1:\n            j -= 1\n        elif j == 0:\n            i += 1\n        elif (U[i + 1][1] - U[i][1]) * (L[j][0] - L[j - 1][0]) > (U[i + 1][0] - U[i][0]) * (L[j][1] - L[j - 1][1]):\n            i += 1\n        else:\n            j -= 1\n    return ([U[P][2], L[Q][2]], ans)\n\ndef log_out(count, value):\n    s = str(value) + '\\n'\n    while count:\n        if count % 2:\n            sys.stdout.write(s)\n        s += s\n        count //= 2\n\ndef main():\n    ans = []\n    P = []\n    for i in range(1, N + 1):\n        s = sys.stdin.readline()\n        (x, y) = map(int, s.strip().split())\n        P.append((x, y, i))\n    P.sort(key=itemgetter(0, 1))\n    while len(P) > 1:\n        size = len(P)\n        Convex_hull(P)\n        (res, disT) = Find_maximization_pair()\n        maxx = max(res)\n        count = size - maxx + 1\n        ans.append((count, disT))\n        P = list(filter(lambda it: it[2] < maxx, P))\n    print(0)\n    for it in reversed(ans):\n        log_out(it[0], it[1])\nmain()", "import sys\nfrom operator import itemgetter\nN = int(input().strip())\n\ndef cross(p, q, r):\n    return (p[0] - q[0]) * (r[1] - q[1]) - (p[1] - q[1]) * (r[0] - q[0])\n\ndef dist(p1, p2):\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n(U, L) = ([], [])\n\ndef Convex_hull(P):\n    global U, L\n    (U, L) = ([], [])\n    sz = len(P)\n    for i in range(sz):\n        while len(U) >= 2 and cross(U[-2], U[-1], P[i]) <= 0:\n            U.pop()\n        while len(L) >= 2 and cross(L[-2], L[-1], P[i]) >= 0:\n            L.pop()\n        L.append(P[i])\n        U.append(P[i])\n\ndef Find_maximization_pair():\n    global U, L\n    ans = 0\n    (P, Q) = (0, 0)\n    sizeU = len(U)\n    sizeL = len(L)\n    (i, j) = (0, sizeL - 1)\n    while 0 < j or i < sizeU - 1:\n        tmpdist = dist(U[i], L[j])\n        if tmpdist > ans:\n            (P, Q, ans) = (i, j, tmpdist)\n        if i == sizeU - 1:\n            j -= 1\n        elif j == 0:\n            i += 1\n        elif (U[i + 1][1] - U[i][1]) * (L[j][0] - L[j - 1][0]) > (U[i + 1][0] - U[i][0]) * (L[j][1] - L[j - 1][1]):\n            i += 1\n        else:\n            j -= 1\n    return ([U[P][2], L[Q][2]], ans)\n\ndef log_out(count, value):\n    s = str(value) + '\\n'\n    while count:\n        if count % 2:\n            sys.stdout.write(s)\n        s += s\n        count //= 2\n\ndef main():\n    ans = []\n    P = []\n    for i in range(1, N + 1):\n        s = sys.stdin.readline()\n        (x, y) = map(int, s.strip().split())\n        P.append((x, y, i))\n    P.sort(key=itemgetter(0, 1))\n    while len(P) > 1:\n        size = len(P)\n        Convex_hull(P)\n        (res, disT) = Find_maximization_pair()\n        maxx = max(res)\n        count = size - maxx + 1\n        ans.append((count, disT))\n        P = list(filter(lambda it: it[2] < maxx, P))\n    print(0)\n    for it in reversed(ans):\n        log_out(it[0], it[1])\nmain()", "import sys\nfrom operator import itemgetter\nN = int(input().strip())\n\ndef cross(p, q, r):\n    return (p[0] - q[0]) * (r[1] - q[1]) - (p[1] - q[1]) * (r[0] - q[0])\n\ndef dist(p1, p2):\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n(U, L) = ([], [])\n\ndef Convex_hull(P):\n    global U, L\n    (U, L) = ([], [])\n    sz = len(P)\n    for i in range(sz):\n        while len(U) >= 2 and cross(U[-2], U[-1], P[i]) <= 0:\n            U.pop()\n        while len(L) >= 2 and cross(L[-2], L[-1], P[i]) >= 0:\n            L.pop()\n        L.append(P[i])\n        U.append(P[i])\n\ndef Find_maximization_pair():\n    global U, L\n    ans = 0\n    (P, Q) = (0, 0)\n    sizeU = len(U)\n    sizeL = len(L)\n    (i, j) = (0, sizeL - 1)\n    while 0 < j or i < sizeU - 1:\n        tmpdist = dist(U[i], L[j])\n        if tmpdist > ans:\n            (P, Q, ans) = (i, j, tmpdist)\n        if i == sizeU - 1:\n            j -= 1\n        elif j == 0:\n            i += 1\n        elif (U[i + 1][1] - U[i][1]) * (L[j][0] - L[j - 1][0]) > (U[i + 1][0] - U[i][0]) * (L[j][1] - L[j - 1][1]):\n            i += 1\n        else:\n            j -= 1\n    return ([U[P][2], L[Q][2]], ans)\n\ndef log_out(count, value):\n    s = str(value) + '\\n'\n    while count:\n        if count % 2:\n            sys.stdout.write(s)\n        s += s\n        count //= 2\n\ndef main():\n    ans = []\n    P = []\n    for i in range(1, N + 1):\n        s = sys.stdin.readline()\n        (x, y) = map(int, s.strip().split())\n        P.append((x, y, i))\n    P.sort(key=itemgetter(0, 1))\n    while len(P) > 1:\n        size = len(P)\n        Convex_hull(P)\n        (res, disT) = Find_maximization_pair()\n        maxx = max(res)\n        count = size - maxx + 1\n        ans.append((count, disT))\n        P = list(filter(lambda it: it[2] < maxx, P))\n    print(0)\n    for it in reversed(ans):\n        log_out(it[0], it[1])\nmain()"]