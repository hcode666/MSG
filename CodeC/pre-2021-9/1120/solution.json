["import bisect\nfib = [1, 2]\nwhile fib[-1] <= 10 ** 9:\n    fib.append(fib[-1] + fib[-2])\n\ndef decompose(n):\n    ans = []\n    while n != 0:\n        k = bisect.bisect_right(fib, n)\n        ans.append(k - 1)\n        n -= fib[k - 1]\n    return tuple(reversed(ans))\n\ndef alter(visited, unvisited, tup, remove, add):\n    new_val = list(tup)\n    for x in remove:\n        new_val.remove(x)\n    new_val = tuple(sorted(new_val + add))\n    if new_val not in visited:\n        unvisited.add(new_val)\nt = int(input())\nfor _ in range(t):\n    (n, k) = (int(i) for i in input().split())\n    visited = set([])\n    decomp = decompose(n)\n    if len(decomp) > k:\n        print(0)\n        continue\n    unvisited = {decomp}\n    ct = 0\n    while unvisited != set([]):\n        x = unvisited.pop()\n        visited.add(x)\n        if len(x) < k:\n            if 1 in x:\n                alter(visited, unvisited, x, [1], [0, 0])\n            for q in x:\n                if q >= 2:\n                    alter(visited, unvisited, x, [q], [q - 1, q - 2])\n        if 0 in x and 2 in x:\n            alter(visited, unvisited, x, [0, 2], [1, 1])\n        for q in x:\n            if q - 3 in x:\n                alter(visited, unvisited, x, [q - 3, q], [q - 1, q - 1])\n        if len(x) == k:\n            ct += 1\n    print(ct)", "def chefonacci(n):\n    f = []\n    for val in range(n):\n        if val == 0:\n            f.append(1)\n        if val == 1:\n            f.append(2)\n        if val > 1:\n            f.append(f[val - 1] + f[val - 2])\n    return f\n\ndef F(x, k, n):\n    if k > 0 and x < k * f[0] and (x >= 0):\n        return 0\n    if x < 0:\n        return 0\n    if K == 1:\n        for val in f:\n            if val == X:\n                return 1\n        return 0\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or n == 0:\n        return 0\n    else:\n        total = F(x, k, n - 1)\n        if x >= f[n - 1] and x <= k * f[n - 1]:\n            total += F(x - f[n - 1], k - 1, n)\n        return total\n\ndef compute_answer(X, K):\n    return F(X, K, 43)\nf = chefonacci(44)\nQ = int(input())\nfor case in range(Q):\n    (X, K) = list(map(int, input().split()))\n    number = compute_answer(X, K)\n    print(number)", "def chefonacci(n):\n    f = []\n    for val in range(n):\n        if val == 0:\n            f.append(1)\n        if val == 1:\n            f.append(2)\n        if val > 1:\n            f.append(f[val - 1] + f[val - 2])\n    return f\n\ndef F(x, k, n):\n    if k > 0 and x < k * f[0] and (x >= 0):\n        return 0\n    if x < 0:\n        return 0\n    if K == 1:\n        for val in f:\n            if val == X:\n                return 1\n        return 0\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or n == 0:\n        return 0\n    else:\n        total = F(x, k, n - 1)\n        if x >= f[n - 1] and x <= k * f[n - 1]:\n            total += F(x - f[n - 1], k - 1, n)\n        return total\n\ndef compute_answer(X, K):\n    return F(X, K, 43)\nf = chefonacci(44)\nQ = int(input())\nfor case in range(Q):\n    (X, K) = list(map(int, input().split()))\n    number = compute_answer(X, K)\n    print(number)", "def chefonacci(n):\n    f = []\n    for val in range(n):\n        if val == 0:\n            f.append(1)\n        if val == 1:\n            f.append(2)\n        if val > 1:\n            f.append(f[val - 1] + f[val - 2])\n    return f\n\ndef F(x, k, n):\n    if k > 0 and x < k * f[0] and (x >= 0):\n        return 0\n    if x < 0:\n        return 0\n    if K == 1:\n        for val in f:\n            if val == X:\n                return 1\n        return 0\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or n == 0:\n        return 0\n    else:\n        total = F(x, k, n - 1)\n        if x >= f[n - 1] and x <= k * f[n - 1]:\n            total += F(x - f[n - 1], k - 1, n)\n        return total\n\ndef compute_answer(X, K):\n    return F(X, K, 43)\nf = chefonacci(44)\nQ = int(input())\nfor case in range(Q):\n    (X, K) = list(map(int, input().split()))\n    number = compute_answer(X, K)\n    print(number)", "def chefonacci(n):\n    f = []\n    for val in range(n):\n        if val == 0:\n            f.append(1)\n        if val == 1:\n            f.append(2)\n        if val > 1:\n            f.append(f[val - 1] + f[val - 2])\n    return f\n\ndef F(x, k, n):\n    if k > 0 and x < k * f[0] and (x >= 0):\n        return 0\n    if x < 0:\n        return 0\n    if K == 1:\n        for val in f:\n            if val == X:\n                return 1\n        return 0\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or n == 0:\n        return 0\n    else:\n        total = F(x, k, n - 1)\n        if x >= f[n - 1] and x <= k * f[n - 1]:\n            total += F(x - f[n - 1], k - 1, n)\n        return total\n\ndef compute_answer(X, K):\n    return F(X, K, 43)\nf = chefonacci(44)\nQ = int(input())\nfor case in range(Q):\n    (X, K) = list(map(int, input().split()))\n    number = compute_answer(X, K)\n    print(number)", "chefonacci = [0] * 44\nchefonacci[0] = 1\nchefonacci[1] = 2\nfor i in range(2, 44):\n    chefonacci[i] = chefonacci[i - 1] + chefonacci[i - 2]\n\ndef no_of_ways(x, k, index):\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or index == 0:\n        return 0\n    elif x >= 0 and x <= k * chefonacci[index]:\n        return no_of_ways(x, k, index - 1) + no_of_ways(x - chefonacci[index - 1], k - 1, index)\n    return 0\nfor i in range(int(input())):\n    (x, k) = map(int, input().split())\n    global index_1\n    for i in chefonacci:\n        if i > x:\n            index_1 = chefonacci.index(i)\n    print(no_of_ways(x, k, index_1))", "chefonacci = [0] * 44\nchefonacci[0] = 1\nchefonacci[1] = 2\nfor i in range(2, 44):\n    chefonacci[i] = chefonacci[i - 1] + chefonacci[i - 2]\n\ndef no_of_ways(x, k, index):\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or index == 0:\n        return 0\n    elif x >= 0 and x <= k * chefonacci[index]:\n        return no_of_ways(x, k, index - 1) + no_of_ways(x - chefonacci[index - 1], k - 1, index)\n    return 0\nfor i in range(int(input())):\n    (x, k) = map(int, input().split())\n    global index_1\n    for i in chefonacci:\n        if i > x:\n            index_1 = chefonacci.index(i)\n    print(no_of_ways(x, k, index_1))", "cn = [0] * 44\n(cn[1], cn[0]) = (2, 1)\nfor i in range(2, 44):\n    cn[i] = cn[i - 1] + cn[i - 2]\n\ndef findWays(x, k, ind):\n    if k == 0:\n        return 1 if x == 0 else 0\n    elif x == 0 or ind == 0:\n        return 0\n    else:\n        if x >= 0 and k * cn[ind] >= x:\n            return findWays(x - cn[ind - 1], k - 1, ind) + findWays(x, k, ind - 1)\n        return 0\nq = int(input())\nfor _ in range(q):\n    (x, k) = map(int, input().split())\n    for i in cn:\n        if i > x:\n            ind = cn.index(i)\n    print(findWays(x, k, ind))", "chefonacci = [0] * 44\nchefonacci[0] = 1\nchefonacci[1] = 2\nfor i in range(2, 44):\n    chefonacci[i] = chefonacci[i - 1] + chefonacci[i - 2]\n\ndef no_of_ways(x, k, index):\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or index == 0:\n        return 0\n    elif x >= 0 and x <= k * chefonacci[index]:\n        return no_of_ways(x, k, index - 1) + no_of_ways(x - chefonacci[index - 1], k - 1, index)\n    return 0\nfor i in range(int(input())):\n    (x, k) = map(int, input().split())\n    global index_1\n    for i in chefonacci:\n        if i > x:\n            index_1 = chefonacci.index(i)\n    print(no_of_ways(x, k, index_1))", "fibo = [0] * 44\n(fibo[0], fibo[1]) = (1, 2)\nfor i in range(2, 44):\n    fibo[i] = fibo[i - 1] + fibo[i - 2]\n\ndef chefonnaci_number(x, k, idx):\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or idx == 0:\n        return 0\n    elif x >= 0 and x <= k * fibo[idx - 1]:\n        return chefonnaci_number(x, k, idx - 1) + chefonnaci_number(x - fibo[idx - 1], k - 1, idx)\n    return 0\nfor _ in range(int(input())):\n    (x, k) = map(int, input().split())\n    print(chefonnaci_number(x, k, 43))", "from collections import Counter\ndp = [0] * 44\ndp[0] = 1\ndp[1] = 2\nfor i in range(2, 44):\n    dp[i] = dp[i - 1] + dp[i - 2]\n\ndef solve(x, k, n):\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or n == 0:\n        return 0\n    elif x >= 0 and x <= k * dp[n - 1]:\n        return solve(x, k, n - 1) + solve(x - dp[n - 1], k - 1, n)\n    return 0\nT = int(input())\nwhile T:\n    T -= 1\n    (x, k) = map(int, input().split())\n    print(solve(x, k, 43))", "from collections import Counter\ndp = [0] * 44\ndp[0] = 1\ndp[1] = 2\nfor i in range(2, 44):\n    dp[i] = dp[i - 1] + dp[i - 2]\n\ndef solve(x, k, n):\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or n == 0:\n        return 0\n    elif x >= 0 and x <= k * dp[n - 1]:\n        return solve(x, k, n - 1) + solve(x - dp[n - 1], k - 1, n)\n    return 0\nT = int(input())\nwhile T:\n    T -= 1\n    (x, k) = map(int, input().split())\n    print(solve(x, k, 43))", "from functools import lru_cache\nf = [1, 2]\nmod = 10 ** 9 + 7\nfor i in range(42):\n    f.append(f[-1] + f[-2])\nq = int(input())\n\ndef dfs(x, k, pos):\n    if k == 0:\n        return x == 0\n    ans = 0\n    for i in range(pos, -1, -1):\n        if f[i] * k < x:\n            return ans\n        if f[i] <= x:\n            ans += dfs(x - f[i], k - 1, i)\n    return ans\nfor _ in range(q):\n    (x, k) = map(int, input().split())\n    print(dfs(x, k, 42))", "for _ in range(int(input())):\n    (x, k) = (int(x) for x in input().split())\n    fib = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733]\n\n    def waifu(x, k, n):\n        ans = 0\n        if k == 0:\n            return x == 0\n        for i in range(n, -1, -1):\n            if fib[i] * k < x:\n                return ans\n            if fib[i] <= x:\n                ans += waifu(x - fib[i], k - 1, i)\n        return ans\n    print(waifu(x, k, 42))", "from functools import lru_cache\nf = [1, 2]\nmod = 10 ** 9 + 7\nfor i in range(42):\n    f.append(f[-1] + f[-2])\nq = int(input())\n\ndef dfs(x, k, pos):\n    if k == 0:\n        return x == 0\n    ans = 0\n    for i in range(pos, -1, -1):\n        if f[i] * k < x:\n            return ans\n        if f[i] <= x:\n            ans += dfs(x - f[i], k - 1, i)\n    return ans\nfor _ in range(q):\n    (x, k) = map(int, input().split())\n    print(dfs(x, k, 42))", "def solve(x, k, n):\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or n == 0:\n        return 0\n    else:\n        total = solve(x, k, n - 1)\n        if x >= chef[n - 1] and x <= k * chef[n - 1]:\n            total += solve(x - chef[n - 1], k - 1, n)\n        return total\nchef = [0] * 50\n(chef[0], chef[1]) = (1, 2)\nfor i in range(2, 50):\n    chef[i] = chef[i - 1] + chef[i - 2]\nfor _ in range(int(input())):\n    (x, k) = map(int, input().split())\n    print(solve(x, k, 43))", "def solve(x, k, n):\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    elif x == 0 or n == 0:\n        return 0\n    else:\n        total = solve(x, k, n - 1)\n        if x >= chef[n - 1] and x <= k * chef[n - 1]:\n            total += solve(x - chef[n - 1], k - 1, n)\n        return total\nmod = int(1000000000.0 + 7)\nchef = [0] * 45\n(chef[0], chef[1]) = (1, 2)\nfor i in range(2, 45):\n    chef[i] = chef[i - 1] + chef[i - 2]\nfor _ in range(int(input())):\n    (x, k) = map(int, input().split())\n    print(solve(x, k, 43) % mod)", "import sys\nsys.setrecursionlimit(10000000)\nN = 1000000000\nfib = [1, 2]\nwhile True:\n    val = fib[-1] + fib[-2]\n    if val > N:\n        break\n    fib.append(val)\n\ndef getans(i, x, k):\n    if x < 0 or (k == 0 and x > 0) or i < 0 or (k * fib[i] < x):\n        return 0\n    if x == 0 and k == 0:\n        return 1\n    ans = getans(i, x - fib[i], k - 1) + getans(i - 1, x, k)\n    return ans\nfor _ in range(int(input())):\n    (x, k) = list(map(int, input().split()))\n    print(getans(len(fib) - 1, x, k))", "MOD = 1000000007\nfib = [1, 2]\nfor i in range(2, 50):\n    fib.append(fib[i - 1] + fib[i - 2])\n\ndef solve(x, k, n):\n    if k == 0:\n        return int(x == 0)\n    ans = 0\n    for i in range(n, -1, -1):\n        if fib[i] * k < x:\n            return ans\n        if fib[i] <= x:\n            ans = (ans + solve(x - fib[i], k - 1, i)) % MOD\n    return ans\nfor i in range(int(input().strip())):\n    (x, k) = map(int, input().split())\n    print(solve(x, k, 43))", "f = [1, 2]\nf1 = 1\nf2 = 2\nwhile True:\n    f3 = f2 + f1\n    if f3 > 10 ** 9:\n        break\n    f.append(f3)\n    f1 = f2\n    f2 = f3\n\ndef F(x, k, n):\n    if x < 0:\n        return 0\n    if k == 0:\n        if x == 0:\n            return 1\n        else:\n            return 0\n    if x == 0 or n == 0:\n        return 0\n    total = F(x, k, n - 1)\n    if x >= f[n - 1] and x <= k * f[n - 1]:\n        total += F(x - f[n - 1], k - 1, n)\n    return total\nQ = int(input())\nfor q in range(Q):\n    (X, K) = list(map(int, input().split()))\n    print(F(X, K, len(f)))", "from functools import *\n\n@lru_cache(maxsize=None)\ndef change(X, k, i):\n    if chefo[i] * k < X:\n        return 0\n    if k == 0 and X == 0:\n        return 1\n    if k == 0 and X != 0:\n        return 0\n    if X < 0:\n        return 0\n    if X == 0 and k != 0:\n        return 0\n    if k == 1:\n        if chefo[i] == X:\n            return 1\n    if i < 0:\n        return 0\n    return change(X - chefo[i], k - 1, i) + change(X, k, i - 1)\nd = {1: 0, 2: 1}\nchefo = [1, 2]\ni = 2\nwhile chefo[-1] < 10 ** 9:\n    chefo.append(chefo[-1] + chefo[-2])\n    d[chefo[-1]] = i\n    i += 1\nq = int(input())\nfor i in range(q):\n    s = input().split()\n    X = int(s[0])\n    k = int(s[1])\n    for j in range(len(chefo)):\n        if chefo[j] > X:\n            break\n    print(change(int(s[0]), int(s[1]), j - 1) % 1000000007)", "mod = 10 ** 9 + 7\nfib = [1, 2]\nwhile fib[-1] < 10 ** 9:\n    fib.append(fib[-1] + fib[-2])\nfibs = set(fib)\ncache = {}\n\ndef ways(num, parts, maxused):\n    if num == 0 and parts == 0:\n        return 1\n    if parts == 0 or maxused == 1:\n        return 0\n    if parts * maxused < num:\n        return 0\n    if parts == 1:\n        return 1 if num < maxused and num in fibs else 0\n    if maxused > num and (num, parts) in cache:\n        return cache[num, parts]\n    res = 0\n    i = 0\n    while fib[i] <= num and fib[i] < maxused:\n        k = 1\n        while k * fib[i] <= num and k <= parts:\n            res = res + ways(num - k * fib[i], parts - k, fib[i])\n            k += 1\n        i += 1\n        res %= mod\n    if maxused > num:\n        cache[num, parts] = res\n    return res\nfor _ in range(int(input())):\n    (x, k) = map(int, input().split())\n    print(ways(x, k, x + 1))", "import sys\nimport numpy as np\nfib = np.zeros(43, dtype=np.int64)\nfib[:2] = [1, 2]\nfor i in range(2, len(fib)):\n    fib[i] = fib[i - 1] + fib[i - 2]\nmaxfib = max(fib)\nlfib = len(fib)\n\ndef memo(f):\n    D = dict()\n\n    def g(*a):\n        try:\n            return D[a]\n        except:\n            x = f(*a)\n            D[a] = x\n            return x\n    return g\n\n@memo\ndef num_sums(x, k, mx=lfib):\n    if k == 0:\n        return 0\n    if x < 0:\n        return 0\n    if x > fib[mx - 1] * k:\n        return 0\n    if k == 1:\n        return 1 if x in fib[:mx] else 0\n    return sum((num_sums(x - i, k - 1, j + 1) for (j, i) in enumerate(fib[:mx]) if x - i > 0))\nf = sys.stdin\nq = int(f.readline())\nfor i in range(q):\n    print(num_sums(*list(map(int, f.readline().split()))))", "chef = [1, 2]\ni = 2\nwhile chef[-1] < 10 ** 9:\n    chef.append(chef[i - 1] + chef[i - 2])\n    i += 1\ncache = {}\n\ndef fetch(X, K, i):\n    if X in cache:\n        if K in cache[X]:\n            if i in cache[X][K]:\n                return cache[X][K][i]\n    return -1\n\ndef store(X, K, i, val):\n    if X not in cache:\n        cache[X] = {}\n    if K not in cache[X]:\n        cache[X][K] = {i: val}\n\ndef compute(X, K, i):\n    if X > chef[i] * K:\n        return 0\n    if X <= 0:\n        return 1 if K == 0 else 0\n    elif K == 0:\n        return 0\n    elif i < 0:\n        return 0\n    else:\n        val = fetch(X, K, i)\n        if val != -1:\n            return val\n        elif X - chef[i] < 0:\n            val = compute(X, K, i - 1)\n            store(X, K, i, val)\n            return val\n        else:\n            val = compute(X - chef[i], K - 1, i) + compute(X, K, i - 1)\n            store(X, K, i, val)\n            return val\ncl = len(chef) - 1\nQ = int(input())\nfor _ in range(Q):\n    (X, K) = input().split()\n    (X, K) = (int(X), int(K))\n    print(compute(X, K, cl))"]