["import sys\nip = sys.stdin\nmod = pow(10, 9) + 7\nmodinv = lambda x: pow(x, mod - 2, mod)\nt = int(ip.readline())\n\ndef solve(n):\n    ans = 1\n    a = pow(26, n, mod)\n    d = a\n    a = (a - 1) % mod\n    a = a * 2 % mod\n    mmi1 = modinv(d)\n    mmi2 = modinv(25)\n    a = a * mmi1 % mod\n    a = a * mmi2 % mod\n    ans = (a + ans) % mod\n    return ans\nfor _ in range(t):\n    n = int(ip.readline())\n    res = solve(n // 2)\n    if n % 2 == 0:\n        last = modinv(pow(26, n // 2, mod))\n        res = (res - last) % mod\n    print(res)", "import sys\nip = sys.stdin\nmod = pow(10, 9) + 7\nmodinv = lambda x: pow(x, mod - 2, mod)\nt = int(ip.readline())\n\ndef solve(n):\n    ans = 1\n    a = pow(26, n, mod)\n    d = a\n    a = (a - 1) % mod\n    a = a * 2 % mod\n    mmi1 = modinv(d)\n    mmi2 = modinv(25)\n    a = a * mmi1 % mod\n    a = a * mmi2 % mod\n    ans = (a + ans) % mod\n    return ans\nfor _ in range(t):\n    n = int(ip.readline())\n    res = solve(n // 2)\n    if n % 2 == 0:\n        last = modinv(pow(26, n // 2, mod))\n        res = (res - last) % mod\n    print(res)", "import sys\nip = sys.stdin\nmod = pow(10, 9) + 7\nmodinv = lambda x: pow(x, mod - 2, mod)\nt = int(ip.readline())\n\ndef solve(n):\n    ans = 1\n    a = pow(26, n, mod)\n    d = a\n    a = (a - 1) % mod\n    a = a * 2 % mod\n    mmi1 = modinv(d)\n    mmi2 = modinv(25)\n    a = a * mmi1 % mod\n    a = a * mmi2 % mod\n    ans = (a + ans) % mod\n    return ans\nfor _ in range(t):\n    n = int(ip.readline())\n    res = solve(n // 2)\n    if n % 2 == 0:\n        last = modinv(pow(26, n // 2, mod))\n        res = (res - last) % mod\n    print(res)", "import sys\nip = sys.stdin\nmod = pow(10, 9) + 7\nmodinv = lambda x: pow(x, mod - 2, mod)\nt = int(ip.readline())\n\ndef solve(n):\n    ans = 1\n    a = pow(26, n, mod)\n    d = a\n    a = (a - 1 + mod) % mod\n    a = a * 2 % mod\n    mmi1 = modinv(d)\n    mmi2 = modinv(25)\n    a = a * mmi1 % mod\n    a = a * mmi2 % mod\n    ans = (a + ans) % mod\n    return ans\nfor _ in range(t):\n    n = int(ip.readline())\n    res = solve(n // 2)\n    if n % 2 == 0:\n        last = modinv(pow(26, n // 2, mod))\n        res = (res - last) % mod\n    print(res)", "t = int(input())\ne = 10 ** 9 + 7\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        print(1)\n    else:\n        c = n // 2\n        x = 0\n        k = pow(26, c * (e - 2), e)\n        if n % 2 == 0:\n            b = pow(25, e - 2, e)\n            a = pow(26, c, e) * 27 % e\n            a -= 27\n            a = a * b % e\n            a = a * k\n            print(a % e)\n        else:\n            b = pow(25, e - 2, e)\n            a = pow(26, c, e) * 27 % e\n            a -= 2\n            a = a * b % e\n            a = a * k\n            print(a % e)", "from fractions import Fraction\n\ndef modInverse(a, m):\n    g = gcd(a, m)\n    if g != 1:\n        return -1\n    else:\n        return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef new(m):\n    fra = Fraction(1, 26)\n    fra1 = Fraction(pow(fra.numerator, m, mod), pow(fra.denominator, m, mod))\n    qs = 1 + 2 * (fra * (fra1 - 1) / (fra - 1))\n    if n % 2 == 0:\n        qs -= fra1\n    temp = modInverse(qs.denominator, mod)\n    qs = temp * qs.numerator % mod\n    return qs\n\ndef calculate(m):\n    qs = new(m)\n    return qs\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nmod = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        print(1)\n    else:\n        m = n // 2\n        print(calculate(m))", "import math\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef numerator(n, denom):\n    num = int(denom)\n    if n % 2 != 0:\n        GpSum = (power(26, int(n / 2), 1000000007) + 2 * ((power(26, int(n // 2), 1000000007) - 1) % 1000000007 * power(25, 1000000005, 1000000007)) % 1000000007 % 1000000007) % 1000000007\n    else:\n        GpSum = ((power(26, int(n / 2), 1000000007) + 2 * 26 * ((power(26, int(n // 2) - 1, 1000000007) - 1) % 1000000007 * power(25, 1000000005, 1000000007)) % 1000000007 % 1000000007) % 1000000007 + 1) % 1000000007\n    return int(GpSum)\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    denom = power(26, int(n / 2), 1000000007)\n    num = numerator(n, denom)\n    print(num * power(denom, 1000000005, 1000000007) % 1000000007)\n    t -= 1", "m = pow(10, 9) + 7\nt = int(input())\nwhile t:\n    t = t - 1\n    n = int(input())\n    n = n + 1\n    x = pow(26, int(n / 2), m)\n    u = 27 * (x - 1)\n    d = pow(x * 25, m - 2, m)\n    if n % 2 == 0:\n        u = u - 25\n    print(u % m * (d % m) % m)", "t = int(input())\nm = 1000000007\nwhile t > 0:\n    n = int(input())\n    val = 0\n    if n % 2 == 1:\n        val = (25 * pow(26, int((n - 1) / 2), m) + (pow(26, int((n - 1) / 2), m) - 1) * 2) % m\n        val = val * pow(25 * pow(26, int((n - 1) / 2), m), m - 2, m) % m\n    else:\n        val = ((25 * pow(26, int((n - 1) / 2), m) + (pow(26, int((n - 1) / 2), m) - 1) * 2) * 26 + 25) % m\n        val = val * pow(25 * pow(26, int(n / 2), m), m - 2, m) % m\n    print(val)\n    t = t - 1", "M = 1000000000 + 7\n\ndef power(a, n, m):\n    res = 1\n    a = a % m\n    while n > 0:\n        if n & 1 == 1:\n            res = res * a % m\n        n = n >> 1\n        a = a * a % m\n    return res\n\ndef MMI(a, n, m):\n    k = power(a, n, m)\n    return power(k, m - 2, m)\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 1:\n        print('1')\n        continue\n    p = 0\n    if n % 2 == 0:\n        p = (2 * 26 * (power(26, (n - 2) // 2, M) - 1) % M * MMI(25, 1, M) + 1) % M\n    else:\n        p = 2 * (power(26, (n - 1) // 2, M) - 1) * MMI(25, 1, M) % M\n    p += power(26, n // 2, M)\n    p = p % M\n    x = MMI(26, n // 2, M)\n    print(x * p % M)", "m = 1000000007\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nfor i in range(int(input())):\n    n = int(input())\n    k = power(26, n // 2, m)\n    if n % 2 == 1:\n        ans1 = (27 * k - 2) % m\n    else:\n        ans1 = 27 * (k % m - 1) % m\n    ans2 = 25 * k % m\n    c = modInverse(ans2, m)\n    print(ans1 * c % m)", "mod = 10 ** 9 + 7\n\ndef inv(num):\n    return pow(num, mod - 2, mod)\nfor _ in range(int(input())):\n    n = int(input())\n    if n & 1:\n        ans = (2 * pow(26, n // 2 + 1, mod) * (pow(26, n // 2, mod) - 1) * inv(25) + pow(26, n, mod)) % mod * inv(pow(26, n, mod))\n    else:\n        ans = pow(26, n // 2, mod) * 27 * (pow(26, n // 2, mod) - 1) * inv(25) % mod * inv(pow(26, n, mod))\n    print(ans % mod)", "n = int(input())\nfor _ in range(n):\n    x = int(input())\n    if x == 1:\n        print(1)\n    else:\n        m = 1000000007\n        if x % 2 == 1:\n            offset = (x - 1) // 2\n            a = (27 * pow(26, offset, m) % m - 2) % m\n            b1 = 25 * pow(26, offset, m) % m\n            print(a * (pow(b1, m - 2, m) % m) % m)\n        else:\n            offset = x // 2\n            a = (27 * pow(26, offset, m) % m - 27) % m\n            b1 = 25 * pow(26, offset, m) % m\n            print(a * (pow(b1, m - 2, m) % m) % m)", "import math\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    if n == 1:\n        print(1)\n    else:\n        ans = 1\n        p = n // 2\n        k = (pow(26, p, mod) % mod - 1 + mod) % mod\n        k = k * pow(25, mod - 2, mod) % mod\n        k = k % mod * 2 % mod % mod\n        if (n + 1) % 2 == 1:\n            k = (k % mod - 1 + mod) % mod\n        m = n\n        m //= 2\n        ans = ans % mod + k * pow(pow(26, m, mod), mod - 2, mod) % mod\n        print(ans % mod)", "import sys\nimport math\nmod = 1000000007\n\ndef nospace(l):\n    ans = ''.join((str(i) for i in l))\n    return ans\nt = int(input())\nfixed = 1 + 2 * pow(25, mod - 2, mod)\nf26or = pow(26, mod - 2, mod)\nf25or = pow(25, mod - 2, mod)\nfor tt in range(t):\n    n = int(input())\n    ans = fixed\n    if n % 2:\n        k = n // 2\n        invv = pow(f26or, k, mod)\n        invv *= f25or\n        invv %= mod\n        invv *= 2\n        invv *= -1\n        invv %= mod\n        ans += invv\n        ans %= mod\n        print(ans)\n    else:\n        k = n // 2\n        invv = pow(f26or, k, mod)\n        invv *= f25or\n        invv %= mod\n        invv *= 27\n        invv *= -1\n        invv %= mod\n        ans += invv\n        ans %= mod\n        print(ans)", "MOD = 1000000007\ninv26 = pow(26, MOD - 2, MOD)\nfor _ in range(int(input())):\n    n = int(input())\n    if n % 2 == 0:\n        k = n // 2\n        numer = 2 * pow(26, k, MOD) - 2\n        numer %= MOD\n        denom = 25 * pow(26, k - 1, MOD) % MOD\n        frac = numer * pow(denom, MOD - 2, MOD) % MOD\n        ans = frac - 1 + pow(inv26, k, MOD)\n        ans %= MOD\n        print(ans)\n    else:\n        k = n // 2\n        numer = 2 * pow(26, k + 1, MOD) - 2\n        numer %= MOD\n        denom = 25 * pow(26, k, MOD) % MOD\n        frac = numer * pow(denom, MOD - 2, MOD) % MOD\n        ans = frac - 1\n        ans %= MOD\n        print(ans)", "t = int(input())\np = int(1000000000.0 + 7)\nfor _ in range(t):\n    n = int(input())\n    m = n // 2\n    ser_num = pow(26, m + 1, p) - 1\n    ser_den = pow(25, p - 2, p)\n    ser = 2 * (ser_num * ser_den) % p - pow(26, m, p)\n    num = ser if n & 1 else ser - 1\n    den = pow(26, m, p)\n    den = pow(den, p - 2, p)\n    print(num * den % p)", "m = 1000000007\n\ndef extended_gcd(aa, bb):\n    (lastremainder, remainder) = (abs(aa), abs(bb))\n    (x, lastx, y, lasty) = (0, 1, 1, 0)\n    while remainder:\n        (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n        (x, lastx) = (lastx - quotient * x, x)\n        (y, lasty) = (lasty - quotient * y, y)\n    return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\ndef modinv(a):\n    (g, x, y) = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError\n    return x % m\n\ndef point(n):\n    if n % 2:\n        return modinv(pow(26, (n - 1) // 2, m))\n    else:\n        return modinv(pow(26, n // 2, m))\n\ndef points(n):\n    if n % 2:\n        return (1 + 2 * modinv(25) * (pow(26, n // 2, m) - 1) * modinv(pow(26, n // 2, m)) % m) % m\n    else:\n        return (1 + 2 * modinv(25) * (pow(26, (n - 1) // 2, m) - 1) * modinv(pow(26, (n - 1) // 2, m)) % m + modinv(pow(26, n // 2, m))) % m\nt = int(input())\nwhile t:\n    n = int(input())\n    print(points(n) % m)\n    t -= 1", "n = int(input())\nfor _ in range(n):\n    x = int(input())\n    if x == 1:\n        print(1)\n    else:\n        m = 1000000007\n        if x % 2 == 1:\n            offset = (x - 1) // 2\n            a = (27 * pow(26, offset, m) % m - 2) % m\n            b1 = 25 * pow(26, offset, m) % m\n            print(a * (pow(b1, m - 2, m) % m) % m)\n        else:\n            offset = x // 2\n            a = (27 * pow(26, offset, m) % m - 27) % m\n            b1 = 25 * pow(26, offset, m) % m\n            print(a * (pow(b1, m - 2, m) % m) % m)"]