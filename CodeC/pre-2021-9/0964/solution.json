["import bisect\n\ndef create_subsets(arr, k):\n    subset = []\n    l = len(arr)\n    val = 2 ** l\n    for i in range(val):\n        s = 1\n        for j in range(l):\n            if i & 1 << j:\n                s *= arr[j]\n        if s <= k:\n            subset.append(s)\n    subset.sort()\n    return subset\n(n, k) = [int(c) for c in input().split()]\narr = [int(c) for c in input().split()]\nb = arr[:n // 2]\nc = arr[n // 2:]\nsubset1 = create_subsets(b, k)\nsubset2 = create_subsets(c, k)\nans = 0\nfor i in subset1:\n    ans += bisect.bisect_right(subset2, k // i)\nprint(ans - 1)", "import bisect\n\ndef create_subsets(arr, k):\n    subset = []\n    l = len(arr)\n    val = 2 ** l\n    for i in range(val):\n        s = 1\n        for j in range(l):\n            if i & 1 << j:\n                s *= arr[j]\n        if s <= k:\n            subset.append(s)\n    subset.sort()\n    return subset\n(n, k) = [int(c) for c in input().split()]\narr = [int(c) for c in input().split()]\nb = arr[:n // 2]\nc = arr[n // 2:]\nsubset1 = create_subsets(b, k)\nsubset2 = create_subsets(c, k)\nans = 0\nfor i in subset1:\n    ans += bisect.bisect_right(subset2, k // i)\nprint(ans - 1)", "import bisect\n\ndef create_subsets(arr, k):\n    subset = []\n    l = len(arr)\n    val = 2 ** l\n    for i in range(val):\n        s = 1\n        for j in range(l):\n            if i & 1 << j:\n                s *= arr[j]\n        if s <= k:\n            subset.append(s)\n    subset.sort()\n    return subset\n(n, k) = [int(c) for c in input().split()]\narr = [int(c) for c in input().split()]\nb = arr[:n // 2]\nc = arr[n // 2:]\nsubset1 = create_subsets(b, k)\nsubset2 = create_subsets(c, k)\nans = 0\nfor i in subset1:\n    ans += bisect.bisect_right(subset2, k // i)\nprint(ans - 1)", "import bisect\nimport sys\n\ndef subsets(x, n, K):\n    ans = []\n    for i in range(1 << n):\n        pro = 1\n        for j in range(n):\n            if 1 << j & i:\n                if pro > K:\n                    break\n                pro *= x[j]\n        if pro <= K:\n            ans.append(pro)\n    ans.sort()\n    return ans\ninpos = sys.stdin\n(n, k) = list(map(int, inpos.readline().split()))\na = list(map(int, inpos.readline().split()))\nb = a[:n // 2]\nc = a[n // 2:]\nm = len(b)\nn = len(c)\nb = subsets(b, m, k)\nc = subsets(c, n, k)\nans = 0\nsize = len(b)\nfor i in range(size):\n    ans += bisect.bisect_right(c, k // b[i])\nprint(ans - 1)", "lst1 = []\nlst2 = []\nsec_sum1 = []\nsec_sum2 = []\n\ndef rec1(pos, sum):\n    if pos == len(lst1):\n        sec_sum1.append(sum)\n        return\n    rec1(pos + 1, sum * lst1[pos])\n    rec1(pos + 1, sum)\n\ndef rec2(pos, sum):\n    if pos == len(lst2):\n        sec_sum2.append(sum)\n        return\n    rec2(pos + 1, sum * lst2[pos])\n    rec2(pos + 1, sum)\n\ndef binary_search(key, high):\n    (hi, lo, mid, ans) = (len(sec_sum2) - 1, 1, 0, 0)\n    while hi >= lo:\n        mid = int((hi + lo) / 2)\n        if key * sec_sum2[mid] <= high:\n            lo = mid + 1\n            ans = mid\n        else:\n            hi = mid - 1\n    return ans\n(n, m) = map(int, input().split(' '))\nA = [int(a) for a in input().split()]\nfor i in range(0, n, 1):\n    if i % 2 == 0:\n        lst1.append(A[i])\n    else:\n        lst2.append(A[i])\nrec1(0, 1)\nrec2(0, 1)\nsec_sum1.sort()\nsec_sum2.sort()\nmaxi = 0\nfor i in range(1, len(sec_sum1), 1):\n    if sec_sum1[i] <= m:\n        maxi += 1\nfor i in range(1, len(sec_sum2), 1):\n    if sec_sum2[i] <= m:\n        maxi += 1\nfor i in range(1, len(sec_sum1), 1):\n    if sec_sum1[i] > m:\n        break\n    cur = binary_search(sec_sum1[i], m)\n    maxi += cur\nprint(maxi)", "import sys\nimport bisect\nMAX = 100005\ninpos = sys.stdin\n[n, K] = list(map(int, inpos.readline().split()))\na = list(map(int, inpos.readline().split()))\nb = a[:n // 2]\nc = a[n // 2:]\nl = len(b)\nup = 1 << l\nsubset1 = []\nfor i in range(up):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= b[j]\n    if prod <= K:\n        subset1.append(prod)\nsubset1.sort()\nl = len(c)\nup = 1 << l\nsubset2 = []\nfor i in range(up):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= c[j]\n    if prod <= K:\n        subset2.append(prod)\nsubset2.sort()\nans = 0\nl = len(subset1)\nfor i in range(l):\n    ans += bisect.bisect_right(subset2, K // subset1[i])\nprint(ans - 1)", "def fun(arr, m):\n    d = []\n    for i in range(1, pow(2, len(arr))):\n        cnt = 1\n        for j in range(len(arr)):\n            if i & 1 << j:\n                cnt *= int(arr[j])\n                if cnt > m:\n                    break\n        if cnt <= m:\n            d.append(cnt)\n    return d\n\ndef binsearch(arr, value):\n    high = len(arr)\n    low = 0\n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] > value:\n            high = mid\n        elif arr[mid] <= value:\n            low = mid + 1\n    return low\n(n, m) = map(int, input().split())\na = list(map(int, input().split()))\nb = a[0:n // 2]\nc = a[n // 2:n]\ne = fun(b, m)\nf = fun(c, m)\ne.sort()\nf.sort()\ncnt = len(e) + len(f)\nfor i in e:\n    cnt += binsearch(f, m // i)\nprint(cnt)", "import bisect\n(n, k) = [int(c) for c in input().split()]\narr = [int(c) for c in input().split()]\nb = arr[:n // 2]\nc = arr[n // 2:]\nbit = 1 << len(b)\nsubset1 = []\nfor i in range(bit):\n    prod = 1\n    for j in range(len(b)):\n        if 1 << j & i:\n            prod *= b[j]\n    if prod <= k:\n        subset1.append(prod)\nbit = 1 << len(c)\nsubset2 = []\nfor i in range(bit):\n    prod = 1\n    for j in range(len(c)):\n        if 1 << j & i:\n            prod *= c[j]\n    if prod <= k:\n        subset2.append(prod)\nans = 0\nsubset2.sort()\nfor i in subset1:\n    ans += bisect.bisect(subset2, k // i)\nprint(ans - 1)", "from bisect import bisect_right\n(n, k) = [int(d) for d in input().split()]\narr = [int(d) for d in input().split()]\nresult = 0\nhalf = n >> 1\nprods = [1] * (1 << half)\nfor i in range(1, 1 << half):\n    for j in range(half):\n        if i & 1 << j:\n            prods[i] *= arr[j]\n    if prods[i] <= k:\n        result += 1\nprods.sort()\notherHalf = n - half\nfor i in range(1, 1 << otherHalf):\n    p = 1\n    for j in range(half, n):\n        if i & 1 << j - half:\n            p *= arr[j]\n    if p <= k:\n        result += 1\n        index = bisect_right(prods, k / p)\n        result += index - 1\nprint(result)", "(n, k) = map(int, input().split())\nl = [int(i) for i in input().split()]\nl1 = l[0:n // 2]\nl2 = l[n // 2:]\nset1 = []\nset2 = []\n\ndef prod(curr):\n    p = 1\n    if not curr:\n        return 0\n    for i in curr:\n        p *= i\n    return p\ntot = 1 << len(l1)\nfrom collections import defaultdict\nd1 = defaultdict(int)\nfor i in range(tot):\n    curr = []\n    for j in range(len(l1)):\n        if 1 << j & i:\n            curr.append(l1[j])\n    if not prod(curr):\n        continue\n    set1.append(prod(curr))\nans = 0\ntot = 1 << len(l2)\nfor i in range(1, tot):\n    curr = []\n    for j in range(len(l2)):\n        if 1 << j & i:\n            curr.append(l2[j])\n    if prod(curr):\n        set2.append(prod(curr))\nset1.sort()\nset2.sort()\nfrom collections import Counter\nc = Counter(set2)\nfrom bisect import bisect_left as bl\n\ndef check(x):\n    req = k // x\n    lo = 0\n    hi = len(set2) - 1\n    ans = -1\n    while lo <= hi:\n        mi = lo + hi >> 1\n        if set2[mi] <= req:\n            ans = mi\n            lo = mi + 1\n        else:\n            hi = mi - 1\n    return ans + 1\nans = 0\nfor i in set1:\n    ans += i <= k\nfor i in set2:\n    ans += i <= k\nfor i in set1:\n    if i > k:\n        break\n    ans += check(i)\nprint(ans)", "(n, k) = map(int, input().split())\nl = [int(i) for i in input().split()]\nl1 = l[0:n // 2]\nl2 = l[n // 2:]\nset1 = []\nset2 = []\n\ndef prod(curr):\n    p = 1\n    if not curr:\n        return 0\n    for i in curr:\n        p *= i\n    return p\ntot = 1 << len(l1)\nfrom collections import defaultdict\nd1 = defaultdict(int)\nfor i in range(tot):\n    curr = []\n    for j in range(len(l1)):\n        if 1 << j & i:\n            curr.append(l1[j])\n    if not prod(curr):\n        continue\n    set1.append(prod(curr))\nans = 0\ntot = 1 << len(l2)\nfor i in range(1, tot):\n    curr = []\n    for j in range(len(l2)):\n        if 1 << j & i:\n            curr.append(l2[j])\n    if prod(curr):\n        set2.append(prod(curr))\nset1.sort()\nset2.sort()\nfrom collections import Counter\nc = Counter(set2)\nfrom bisect import bisect_left as bl, bisect_right as br\n\ndef check(x):\n    req = k // x\n    ind = br(set2, req)\n    return ind\nans = 0\nfor i in set1:\n    ans += i <= k\nfor i in set2:\n    ans += i <= k\nfor i in set1:\n    if i > k:\n        break\n    ans += check(i)\nprint(ans)", "from bisect import bisect_right\n(n, k) = [int(d) for d in input().split()]\narr = [int(d) for d in input().split()]\nresult = 0\nhalf = n >> 1\nprods = [1] * (1 << half)\nfor i in range(1, 1 << half):\n    for j in range(half):\n        if i & 1 << j:\n            prods[i] *= arr[j]\n    if prods[i] <= k:\n        result += 1\nprods.sort()\notherHalf = n - half\nfor i in range(1, 1 << otherHalf):\n    p = 1\n    for j in range(half, n):\n        if i & 1 << j - half:\n            p *= arr[j]\n    if p <= k:\n        result += 1\n        index = bisect_right(prods, k / p)\n        result += index - 1\nprint(result)", "import bisect\n\ndef getProduct(l, n, ans, k):\n    for i in range(1, 1 << n):\n        p = 1\n        for j in range(n):\n            if i & 1 << j != 0:\n                p *= l[j]\n        if p <= k:\n            ans.append(p)\n(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\n(l1, l2) = (l[:n // 2], l[n // 2:])\n(n1, n2) = (len(l1), len(l2))\n(ans1, ans2) = ([], [])\ngetProduct(l1, n1, ans1, k)\ngetProduct(l2, n2, ans2, k)\nans1.sort()\nans2.sort()\ncnt = 0\nfor i in ans1:\n    cnt += bisect.bisect(ans2, k // i)\ncnt += bisect.bisect(ans1, k)\ncnt += bisect.bisect(ans2, k)\nprint(cnt)", "def solve(l, idx, n, k, p, t):\n    if p > k:\n        return None\n    if idx == n:\n        t.append(p)\n        return None\n    solve(l, idx + 1, n, k, p, t)\n    solve(l, idx + 1, n, k, p * l[idx], t)\n\ndef search(l, k, val):\n    lo = 1\n    hi = len(l) - 1\n    ans = len(l)\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if val * l[mid] > k:\n            hi = mid - 1\n        else:\n            ans = mid\n            lo = mid + 1\n    return ans\n(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\nt = []\nd = []\nsolve(l, 0, n // 2, k, 1, t)\nsolve(l, n // 2, n, k, 1, d)\nans = len(t) + len(d) - 2\nt.sort()\nd.sort()\nfor i in t[1:]:\n    idx = search(d, k, i)\n    if idx != len(d):\n        ans += idx\nprint(ans)", "import sys\nimport bisect\nMAX = 100005\ninpos = sys.stdin\n[n, K] = list(map(int, inpos.readline().split()))\na = list(map(int, inpos.readline().split()))\nb = a[:n // 2]\nc = a[n // 2:]\nl = len(b)\nup = 1 << l\nsubset1 = []\nfor i in range(up):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= b[j]\n    if prod <= K:\n        subset1.append(prod)\nsubset1.sort()\nl = len(c)\nup = 1 << l\nsubset2 = []\nfor i in range(up):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= c[j]\n    if prod <= K:\n        subset2.append(prod)\nsubset2.sort()\nans = 0\nl = len(subset1)\nfor i in range(l):\n    ans += bisect.bisect_right(subset2, K // subset1[i])\nprint(ans - 1)", "import bisect\n(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\none = arr[0:n // 2]\ntwo = arr[n // 2:]\nn1 = len(one)\nraja = []\nfor i in range(1 << n1):\n    prod = 1\n    for j in range(n1):\n        if i & 1 << j:\n            prod *= one[j]\n    if prod <= k:\n        raja.append(prod)\nraja.sort()\nn2 = len(two)\nrani = []\nfor i in range(1 << n2):\n    prod = 1\n    for j in range(n2):\n        if i & 1 << j:\n            prod *= two[j]\n    if prod <= k:\n        rani.append(prod)\nrani.sort()\nans = 0\nfor i in range(len(raja)):\n    ans += bisect.bisect_right(rani, k // raja[i])\nprint(ans - 1)", "t = 1\nMOD = 10 ** 9 + 7\nimport math\nwhile t:\n    (n, k) = map(int, input().split())\n    l = [int(i) for i in input().split()]\n    l.sort()\n    sum = 1\n    c = 0\n    a = l[0:n // 2]\n    b = l[n // 2:]\n    ans = []\n    ans1 = []\n    opsize = math.pow(2, len(a))\n    for counter in range(0, int(opsize)):\n        y = []\n        for j in range(0, len(a)):\n            if counter & 1 << j:\n                y.append(l[j])\n        prod = 1\n        for i in range(len(y)):\n            prod *= y[i]\n        ans.append(prod)\n    opsize = math.pow(2, len(b))\n    for counter in range(0, int(opsize)):\n        y = []\n        for j in range(0, len(b)):\n            if counter & 1 << j:\n                y.append(b[j])\n        prod = 1\n        for i in range(len(y)):\n            prod *= y[i]\n        ans1.append(prod)\n    ans1.sort()\n    from bisect import bisect_right as br\n    z = 0\n    for i in ans:\n        z += br(ans1, k // i)\n    print(z - 1)\n    t = t - 1", "import sys, bisect\n\ndef subset(p_b, b, k):\n    len_b = len(b)\n    for i in range(1, 1 << len_b):\n        ans = 1\n        for j in range(len_b):\n            if i & 1 << j:\n                ans *= b[j]\n        if ans <= k:\n            p_b.append(ans)\n(n, k) = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nb = a[:n // 2]\nc = a[n // 2:]\nans = 0\np_b = []\np_c = []\nsubset(p_b, b, k)\nsubset(p_c, c, k)\np_b.sort()\np_c.sort()\nlen_b = len(p_b)\nfor i in range(len_b):\n    if p_b[i] <= k:\n        ans += 1\n    else:\n        break\nlen_c = len(p_c)\nfor i in range(len_c):\n    if p_c[i] <= k:\n        ans += 1\n    else:\n        break\nfor i in range(len_b):\n    j = bisect.bisect_right(p_c, k // p_b[i])\n    ans += j\nprint(ans)", "import operator\nimport functools\n\ndef subsets(a, k):\n    l = len(a)\n    m = 1 << l\n    subs = []\n    pad = [0] * l\n    for i in range(m):\n        b = pad + list(map(int, list(bin(i)[2:])))\n        b = b[-l:]\n        c = [x * y for (x, y) in zip(a, b)]\n        c = [1 if x == 0 else x for x in c]\n        prod = functools.reduce(operator.mul, c, 1)\n        if prod <= k:\n            subs.append(prod)\n    return subs\n\ndef Main():\n    (n, k) = list(map(int, input().rstrip().split()))\n    a = list(map(int, input().rstrip().split()))\n    a.sort()\n    b = a[:n // 2]\n    c = a[n // 2:]\n    b_subs = subsets(b, k)\n    c_subs = subsets(c, k)\n    b_subs.sort()\n    c_subs.sort()\n    j = len(c_subs) - 1\n    ans = 0\n    for (i, e) in enumerate(b_subs):\n        while c_subs[j] > k // e:\n            j -= 1\n        ans += j + 1\n        if i == 0:\n            ans -= 1\n    print(ans)\nMain()", "from collections import deque\n\ndef subsets(a, k):\n    l = len(a)\n    m = 1 << l\n    subs = []\n    for i in range(m):\n        x = i\n        j = 0\n        prod = 1\n        valid = True\n        while x > 0:\n            if x & 1:\n                if prod > k // a[j]:\n                    valid = False\n                    break\n                prod = prod * a[j]\n            x = x >> 1\n            j += 1\n        if valid:\n            subs.append(prod)\n    return subs\n\ndef Main():\n    (n, k) = list(map(int, input().rstrip().split()))\n    a = list(map(int, input().rstrip().split()))\n    a.sort()\n    b = a[:n // 2]\n    c = a[n // 2:]\n    b_subs = subsets(b, k)\n    c_subs = subsets(c, k)\n    b_subs.sort()\n    c_subs.sort()\n    j = len(c_subs) - 1\n    ans = 0\n    for (i, e) in enumerate(b_subs):\n        while c_subs[j] > k // e:\n            j -= 1\n        ans += j + 1\n        if i == 0:\n            ans -= 1\n    print(ans)\nMain()", "from sys import stdin, stdout\ninp = lambda : map(int, stdin.readline().split())\nfrom bisect import bisect_right as br\n(n, k) = inp()\na = list(inp())\nl = len(a) // 2\nb = a[:l]\nc = a[l:]\nsubset1 = []\nsubset2 = []\nl = len(b)\nfor i in range(1 << l):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= b[j]\n    if prod <= k:\n        subset1.append(prod)\nl = len(c)\nfor i in range(1 << l):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= c[j]\n    if prod <= k:\n        subset2.append(prod)\nsubset1.sort()\nsubset2.sort()\nans = 0\nfor i in range(len(subset1)):\n    ans += br(subset2, k // subset1[i])\nprint(ans - 1)", "from sys import stdin, stdout\ninp = lambda : map(int, stdin.readline().split())\nfrom bisect import bisect_right as br\n(n, k) = inp()\na = list(inp())\nl = len(a) // 2\nb = a[:l]\nc = a[l:]\nsubset1 = []\nsubset2 = []\nl = len(b)\nfor i in range(1 << l):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= b[j]\n    if prod <= k:\n        subset1.append(prod)\nl = len(c)\nfor i in range(1 << l):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= c[j]\n    if prod <= k:\n        subset2.append(prod)\nsubset1.sort()\nsubset2.sort()\nans = 0\nfor i in range(len(subset1)):\n    ans += br(subset2, k // subset1[i])\nprint(ans - 1)", "import sys\nimport itertools\nfrom functools import reduce\nimport bisect\n(n, k) = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nb = a[:n // 2]\nc = a[n // 2:]\nt1 = []\nt2 = []\ncount = 0\nfor i in range(len(b)):\n    for subset in itertools.combinations(b, i + 1):\n        temp = reduce(lambda x, y: x * y, subset)\n        if temp < k:\n            t1.append(temp)\n            count += 1\nfor i in range(len(c)):\n    for subset in itertools.combinations(c, i + 1):\n        temp = reduce(lambda x, y: x * y, subset)\n        if temp < k:\n            t2.append(temp)\n            count += 1\nt1.sort()\nt2.sort()\nfor i in range(len(t1)):\n    idx = bisect.bisect_left(t2, k // t1[i] + 1)\n    if idx != 0:\n        idx -= 1\n        count += idx + 1\nprint(count)", "import bisect\n(n, k) = map(int, input().strip().split(' '))\narr = list(map(int, input().strip().split(' ')))\na = arr[:n // 2]\nb = arr[n // 2:]\nl1 = len(a)\nsubset1 = []\npower = 1 << l1\nfor i in range(power):\n    prod = 1\n    for j in range(l1):\n        if i & 1 << j:\n            prod *= a[j]\n    if prod <= k:\n        subset1.append(prod)\nsubset1.sort()\nl2 = len(b)\nsubset2 = []\npower = 1 << l2\nfor i in range(power):\n    prod = 1\n    for j in range(l2):\n        if i & 1 << j:\n            prod *= b[j]\n    if prod <= k:\n        subset2.append(prod)\nans = 0\nsubset2.sort()\nfor i in subset1:\n    ans += bisect.bisect_right(subset2, k // i)\nprint(ans - 1)", "import bisect\n(n, k) = map(int, input().strip().split(' '))\narr = list(map(int, input().strip().split(' ')))\na = arr[:n // 2]\nb = arr[n // 2:]\nl1 = len(a)\nsubset1 = []\npower = 1 << l1\nfor i in range(power):\n    prod = 1\n    for j in range(l1):\n        if i & 1 << j:\n            prod *= a[j]\n    if prod <= k:\n        subset1.append(prod)\nsubset1.sort()\nl2 = len(b)\nsubset2 = []\npower = 1 << l2\nfor i in range(power):\n    prod = 1\n    for j in range(l2):\n        if i & 1 << j:\n            prod *= b[j]\n    if prod <= k:\n        subset2.append(prod)\nans = 0\nsubset2.sort()\nfor i in subset1:\n    ans += bisect.bisect_right(subset2, k // i)\nprint(ans - 1)", "import bisect\n(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\na = l[:n // 2]\nb = l[n // 2:]\np = []\nq = []\ns = 0\no = len(a)\nu = 1 << o\nfor i in range(u):\n    prod = 1\n    for j in range(n):\n        if i & 1 << j:\n            prod *= a[j]\n    if prod <= k:\n        p.append(prod)\np.sort()\no = len(b)\nu = 1 << o\nfor i in range(u):\n    prod = 1\n    for j in range(n):\n        if i & 1 << j:\n            prod *= b[j]\n    if prod <= k:\n        q.append(prod)\nq.sort()\nl = len(p)\nfor i in range(l):\n    s += bisect.bisect_right(q, k // p[i])\nprint(s - 1)", "import bisect\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nb = a[:n // 2]\nc = a[n // 2:]\ns1 = []\ns2 = []\nfor i in range(1 << len(b)):\n    prod = 1\n    for j in range(len(b)):\n        if i & 1 << j:\n            prod *= b[j]\n    if prod <= k:\n        s1.append(prod)\nfor i in range(1 << len(c)):\n    prod = 1\n    for j in range(len(c)):\n        if i & 1 << j:\n            prod *= c[j]\n    if prod <= k:\n        s2.append(prod)\ns1.sort()\ns2.sort()\nans = 0\nfor i in range(len(s1)):\n    ans += bisect.bisect_right(s2, k / s1[i])\nprint(ans - 1)", "import sys\nimport bisect\nMAX = 100005\ninpos = sys.stdin\n[n, K] = list(map(int, inpos.readline().split()))\na = list(map(int, inpos.readline().split()))\nb = a[:n // 2]\nc = a[n // 2:]\nl = len(b)\nup = 1 << l\nsubset1 = []\nfor i in range(up):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= b[j]\n    if prod <= K:\n        subset1.append(prod)\nsubset1.sort()\nl = len(c)\nup = 1 << l\nsubset2 = []\nfor i in range(up):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= c[j]\n    if prod <= K:\n        subset2.append(prod)\nsubset2.sort()\nans = 0\nl = len(subset1)\nfor i in range(l):\n    ans += bisect.bisect_right(subset2, K // subset1[i])\nprint(ans - 1)", "import math\n(n, k) = [int(x) for x in input().split()]\narr = input()\nl = list(map(int, arr.split(' ')))\nlist1 = []\nlist2 = []\nx = 0\nwhile x < n / 2:\n    list1.append(l[x])\n    x = x + 1\nwhile x < n:\n    list2.append(l[x])\n    x += 1\n\ndef subproduct(li, nb):\n    b = []\n    up = 1 << nb\n    global ans\n    for i in range(1, up):\n        prod = 1\n        flag = 1\n        for j in range(0, nb):\n            if i & 1 << j:\n                if li[j] < k / prod:\n                    prod = prod * li[j]\n                else:\n                    flag = 0\n                    break\n        if flag == 1:\n            b.append(prod)\n    return b\nans = 0\nb = subproduct(list1, len(list1))\nc = subproduct(list2, len(list2))\nans += len(b) + len(c)\nc.sort()\n\ndef BS(start, end, li, target):\n    while start <= end:\n        mid = (start + end) // 2\n        if li[mid] <= target:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return start\nfor i in b:\n    ind = BS(0, len(c) - 1, c, k / i)\n    ans += ind\nprint(ans)", "import sys\nimport bisect\nMAX = 100005\ninpos = sys.stdin\n[n, K] = list(map(int, inpos.readline().split()))\na = list(map(int, inpos.readline().split()))\nb = a[:n // 2]\nc = a[n // 2:]\nl = len(b)\nup = 1 << l\nsubset1 = []\nfor i in range(up):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= b[j]\n    if prod <= K:\n        subset1.append(prod)\nsubset1.sort()\nl = len(c)\nup = 1 << l\nsubset2 = []\nfor i in range(up):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= c[j]\n    if prod <= K:\n        subset2.append(prod)\nsubset2.sort()\nans = 0\nl = len(subset1)\nfor i in range(l):\n    ans += bisect.bisect_right(subset2, K // subset1[i])\nprint(ans - 1)", "import bisect\n(n, k) = map(int, input().split())\nb = list(map(int, input().split()))\na1 = b[0:int(n / 2)]\na2 = b[int(n / 2):]\na1.sort()\na2.sort()\nv1 = []\nv2 = []\n\ndef myc(a, i, p, s, v):\n    if s == 1:\n        if a[i] <= k:\n            v.append(a[i])\n        j = i + 1\n        while j < len(a):\n            myc(a, j, a[i], 2, v)\n            j += 1\n    else:\n        p = p * a[i]\n        if p <= k:\n            v.append(p)\n            j = i + 1\n            while j < len(a):\n                myc(a, j, p, 2, v)\n                j += 1\nfor j in range(len(a1)):\n    myc(a1, j, 1, 1, v1)\nfor j in range(len(a2)):\n    myc(a2, j, 1, 1, v2)\nv1.sort()\nv2.sort()\nc = 0\nfor i in v1:\n    u = float(k / i)\n    c += bisect.bisect(v2, u)\nprint(c + len(v1) + len(v2))", "from functools import reduce\nfrom itertools import chain, combinations\nfrom operator import mul\n\ndef powerset(iterable):\n    s = list(iterable)\n    return chain.from_iterable((combinations(s, r) for r in range(1, len(s) + 1)))\n(n, k) = [int(x) for x in input().strip().split()]\na = [int(x) for x in input().strip().split()]\nd = n // 2\nb = a[:d]\nc = a[d:]\nbx = []\nfor x in powerset(b):\n    bx.append(reduce(mul, x, 1))\nbx.sort()\ncx = []\nfor x in powerset(c):\n    cx.append(reduce(mul, x, 1))\ncx.sort()\nr = sum((x <= k for x in bx))\nr += sum((x <= k for x in cx))\n(i, j) = (0, len(cx) - 1)\nwhile i < len(bx):\n    while j >= 0 and bx[i] * cx[j] > k:\n        j -= 1\n    r += j + 1\n    i += 1\nprint(r)", "n = input()\nr = list(map(int, n.split()))\nk = r[1]\narr = input()\nli = list(map(int, arr.split()))\n\ndef count(li, k):\n    li.sort()\n    if li[0] > k:\n        print(0)\n        return\n    l = len(li)\n    if l == 1:\n        if li[0] <= k:\n            print(1)\n            return\n    li1 = li[:int(len(li) / 2)]\n    li2 = li[int(len(li) / 2):len(li)]\n    nl1 = count1(li1, k)\n    nl2 = count1(li2, k)\n    count = 0\n    count = len(nl1) + len(nl2)\n    nl1.sort()\n    nl2.sort()\n    l1 = len(nl1)\n    l2 = len(nl2)\n    i = l1 - 1\n    j = 0\n    while i >= 0:\n        d = k / nl1[i]\n        while j < l2:\n            if nl2[j] > d:\n                break\n            j = j + 1\n        if j > 0:\n            count = count + j\n        i = i - 1\n    print(count)\n\ndef count1(li, k):\n    nl = []\n    i = 0\n    if li[0] > k:\n        return nl\n    if li[0] <= k:\n        nl.append(li[i])\n    i = i + 1\n    pr = 0\n    while i < len(li):\n        a = len(nl)\n        d1 = k / li[i]\n        for j in range(a):\n            pr = li[i] * nl[j]\n            if nl[j] <= d1:\n                nl.append(pr)\n        if li[i] <= k:\n            nl.append(li[i])\n        i = i + 1\n    return nl\ncount(li, k)", "from bisect import bisect\n(N, K) = map(int, input().split())\nA = list(map(int, input().split()))\nleft = A[:N // 2]\nright = A[N // 2:]\nleft_vals = []\nright_vals = []\nleft_limit = len(left)\nfor i in range(1 << left_limit):\n    val = 1\n    for j in range(left_limit):\n        if i & 1 << j:\n            val *= left[j]\n    left_vals.append(val)\nright_limit = len(right)\nfor i in range(1 << right_limit):\n    val = 1\n    for j in range(right_limit):\n        if i & 1 << j:\n            val *= right[j]\n    right_vals.append(val)\nleft_vals.sort()\nright_vals.sort()\nans = 0\nfor left_val in left_vals:\n    ans += bisect(right_vals, K // left_val)\nprint(ans - 1)", "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\nonecount = l.count(1)\ndlist = list()\n(s, ac) = (0, 0)\n(asd, z) = (0, 0)\nfor i in range(n):\n    t = l[i]\n    if i == 0 and t != 1:\n        if t <= k:\n            dlist.append(t)\n            s = s + 1\n            ac = ac + 1\n    else:\n        asd = ac\n        z = 0\n        if t <= k and t != 1:\n            for j in range(ac):\n                x = t * dlist[j]\n                if x <= k:\n                    s = s + 1\n                    dlist.append(x)\n                    z = z + 1\n            dlist.append(t)\n            z = z + 1\n            s = s + 1\n        ac += z\nres = (pow(2, onecount) - 1) * (1 + s) + s\nprint(res)", "(n, k) = input().split()\nn = int(n)\nk = int(k)\nl = [int(x) for x in input().split()]\nd = dict()\nfor i in range(n):\n    if l[i] > k:\n        continue\n    copy = dict()\n    for key in d:\n        copy[key] = d[key]\n    for key in copy:\n        mult = key * l[i]\n        if mult <= k:\n            if not mult in copy:\n                d[mult] = copy[key]\n            else:\n                d[mult] = d[mult] + copy[key]\n    if not l[i] in d:\n        d[l[i]] = 1\n    else:\n        d[l[i]] = d[l[i]] + 1\nsm = 0\nfor key in d:\n    sm = sm + d[key]\nprint(sm)", "import sys\nimport bisect\nMAX = 100005\ninpos = sys.stdin\n[n, K] = list(map(int, inpos.readline().split()))\na = list(map(int, inpos.readline().split()))\nb = a[:n // 2]\nc = a[n // 2:]\nl = len(b)\nup = 1 << l\nsubset1 = []\nfor i in range(up):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= b[j]\n    if prod <= K:\n        subset1.append(prod)\nsubset1.sort()\nl = len(c)\nup = 1 << l\nsubset2 = []\nfor i in range(up):\n    prod = 1\n    for j in range(l):\n        if i & 1 << j:\n            prod *= c[j]\n    if prod <= K:\n        subset2.append(prod)\nsubset2.sort()\nans = 0\nl = len(subset1)\nfor i in range(l):\n    ans += bisect.bisect_right(subset2, K // subset1[i])\nprint(ans - 1)", "def p(s, t):\n    count = 0\n    lst = []\n    pro = []\n    for i in range(0, len(s)):\n        if int(s[i]) == 1:\n            count = count + 1\n        elif int(s[i]) <= t:\n            lst.append(int(s[i]))\n    lst.sort()\n    pro.append(1)\n    for k in range(0, len(lst)):\n        pro.sort()\n        curr = len(pro)\n        for j in range(0, curr):\n            product = lst[k] * pro[j]\n            if product <= t:\n                pro.append(product)\n            else:\n                break\n    set1 = len(pro) - 1\n    set2 = 2 ** count - 1\n    set3 = set1 * set2\n    return set1 + set2 + set3\nline1 = input()\nx = line1.split()\nline2 = input()\ny = line2.split()\nz = p(y, int(x[1]))\nprint(z)", "def p(s, t):\n    count = 0\n    lst = []\n    pro = []\n    for i in range(0, len(s)):\n        if int(s[i]) == 1:\n            count = count + 1\n        elif int(s[i]) <= t and int(s[i]) != 1:\n            lst.append(int(s[i]))\n    lst.sort()\n    for k in range(0, len(lst)):\n        pro.sort()\n        curr = len(pro)\n        pro.append(lst[k])\n        for j in range(0, curr):\n            product = lst[k] * pro[j]\n            if product <= t:\n                pro.append(product)\n            else:\n                break\n    set1 = len(pro)\n    set2 = 2 ** count - 1\n    set3 = set1 * set2\n    return set1 + set2 + set3\nline1 = input()\nx = line1.split()\nline2 = input()\ny = line2.split()\nz = p(y, int(x[1]))\nprint(z)", "i = input()\ns = i.split()\nN = eval(s[0])\nK = eval(s[1])\narrElem = input()\na = arrElem.split()\nA = []\ntotsets = 2 ** N - 1\ncount = 0\nfor i in range(0, N):\n    A.append(eval(a[i]))\nA.sort()\nprod = []\nreq = []\ncount1 = 0\nfor i in range(0, N):\n    if A[i] <= K and A[i] != 1:\n        req.append(A[i])\n    elif A[i] == 1:\n        count1 = count1 + 1\nnoOfOnesSubsets = 2 ** count1 - 1\nfor i in range(0, len(req)):\n    prod.sort()\n    l = len(prod)\n    if req[i] <= K:\n        prod.append(req[i])\n    for j in range(0, l):\n        if req[i] * prod[j] <= K:\n            prod.append(req[i] * prod[j])\n        else:\n            break\ncount = len(prod)\nprint((count + 1) * noOfOnesSubsets + count)", "memo = {}\n\ndef countSS(v, lim, curr, i):\n    key = '%d,%d' % (curr, i)\n    if i < 0:\n        return 0\n    if key in memo:\n        return memo[key]\n    cnt = 0\n    ii = i\n    while i >= 0:\n        mul = curr * v[i]\n        if mul <= lim:\n            cnt += 1\n            cnt += countSS(v, lim, mul, i - 1)\n        i -= 1\n    memo[key] = cnt\n    return cnt\n(N, K) = map(int, input().split())\nV = list(map(int, input().split()))\nprint(countSS(V, K, 1, N - 1))", "(n, k) = [int(x) for x in input().split()]\narr = [int(x) for x in input().split()]\nleft = []\nright = []\nfor i in range(n // 2):\n    sz = len(left)\n    for j in range(sz):\n        left.append(left[j] * arr[i])\n    left.append(arr[i])\nfor i in range(n // 2, n):\n    sz = len(right)\n    for j in range(sz):\n        right.append(right[j] * arr[i])\n    right.append(arr[i])\nleft.sort()\nright.sort()\nans = 0\nfor i in left:\n    if i <= k:\n        ans += 1\nfor j in right:\n    if j <= k:\n        ans += 1\nfor i in left:\n    lo = 0\n    hi = len(right) - 1\n    while lo < hi:\n        md = lo + (hi - lo + 1) // 2\n        if right[md] * i <= k:\n            lo = md\n        else:\n            hi = md - 1\n    if i * right[hi] <= k:\n        ans += hi + 1\nprint(ans)", "(n, k) = input().split(' ')\nn = int(n)\nk = int(k)\na = [int(x) for x in input().split(' ')]\nc = 0\na.sort()\nm = n\nindex = n\ntemp = 1\nfor i in range(n):\n    temp *= a[i]\n    if a[i] > k:\n        if c == 0:\n            index = i\n        c += 2 ** (m - 1)\n        m -= 1\nif temp <= k:\n    a = []\na = a[:index]\nflag = 0\nctr = a.count(1)\nif ctr > 0:\n    a = a[ctr:]\n    flag = 1\nproduct = [1]\np = []\nfor i in range(len(a)):\n    for j in range(len(product)):\n        if product[j] * a[i] > k:\n            if flag:\n                c += 2 ** ctr * 2 ** (len(a) - i - 1) * (len(product) - j)\n            else:\n                c += 2 ** (len(a) - i - 1) * (len(product) - j)\n            break\n        p.append(product[j] * a[i])\n    product += p\n    product.sort()\n    p = []\nprint(2 ** n - 1 - c)", "(n, k) = input().split(' ')\nn = int(n)\nk = int(k)\na = [int(x) for x in input().split(' ')]\nc = 0\na.sort()\nm = n\nindex = n\ntemp = 1\nfor i in range(n):\n    temp *= a[i]\n    if a[i] > k:\n        if c == 0:\n            index = i\n        c += 2 ** (m - 1)\n        m -= 1\nif temp <= k:\n    a = []\na = a[:index]\nflag = 0\nctr = a.count(1)\nif ctr > 0:\n    a = a[ctr:]\n    flag = 1\nsubsets = [[]]\nproduct = [1]\np = []\nt = []\nfor i in range(len(a)):\n    flag2 = 0\n    for j in range(len(product)):\n        if product[j] * a[i] <= k:\n            if flag2 == 0:\n                flag2 = 1\n                if flag:\n                    c += 2 ** ctr * 2 ** (len(a) - i - 1) * j\n                else:\n                    c += 2 ** (len(a) - i - 1) * j\n            p.append(product[j] * a[i])\n    product += p\n    if len(p) > 0:\n        product.sort(reverse=True)\n    p = []\nprint(2 ** n - 1 - c)", "(n, k) = list(map(int, input().split()))\noldarray = list(map(int, input().split()))\narray = []\nc = 0\nfor i in oldarray:\n    if i != 1:\n        array.append(i)\n    else:\n        c += 1\nn = n - c\nnewArray = []\nx = 0\nfor i in range(n):\n    if array[i] <= k:\n        g = 0\n        t = 0\n        while g < x:\n            if array[i] * newArray[g] <= k:\n                newArray.append(array[i] * newArray[g])\n                t += 1\n            g += 1\n        newArray.append(array[i])\n        x += 1 + t\nprint(x * 2 ** c + 2 ** c - 1)", "def func(array, n, pro):\n    if pro > maxi:\n        return 0\n    if n == 0:\n        return 1\n    if array[n - 1] > maxi:\n        return func(array, n - 1, pro)\n    return func(array, n - 1, pro) + func(array, n - 1, pro * array[n - 1])\nsu = 0\nli = list(map(int, input().split()))\nN = li[0]\nmaxi = li[1]\ncnt = 0\narr = list(map(int, input().split()))\narr.sort()\nind = 0\nflag = 0\nfor i in range(N):\n    if arr[i] == 1:\n        ind = i\n        flag = 1\nif flag == 1:\n    numones = ind + 1\n    newarr = arr[ind + 1:]\nelse:\n    numones = 0\n    newarr = arr\nnum = func(newarr, len(newarr), 1)\ny = 2 ** numones\nz = y - 1 + (num - 1) * y\nprint(z)", "li = list(map(int, input().split()))\nN = li[0]\nmaxval = li[1]\ncnt = 0\narr = list(map(int, input().split()))\narr.sort()\narray = [1]\nind = 0\nflag = 0\nfor j in range(N):\n    if arr[j] == 1:\n        ind = j\n        flag = 1\nif flag == 1:\n    numones = ind + 1\n    newarr = arr[ind + 1:]\nelse:\n    numones = 0\n    newarr = arr\nsum1 = 0\nfor u in range(numones + 1):\n    sum1 = sum1 + u\nfor i in range(len(newarr)):\n    num = newarr[i]\n    l = len(array)\n    k = 0\n    for k in range(l):\n        pro = num * array[k]\n        if pro <= maxval:\n            array.append(pro)\n        else:\n            break\n        k = k + 1\n    array.sort()\nx = 2 ** numones\nans2 = x - 1 + (len(array) - 1) * x\nprint(ans2)", "def checkProduct(index, Product):\n    if Product > N[1]:\n        return 0\n    if index < len(L):\n        return checkProduct(index + 1, Product) + checkProduct(index + 1, Product * L[index])\n    elif Product <= N[1]:\n        return 1\n    else:\n        return 0\nN = list(map(int, input().split()))\nL = list(map(int, input().split()))\nCou = L.count(1)\nL = sorted((x for x in L if x <= N[1] and x > 1))\nprint(checkProduct(0, 1) * 2 ** Cou - 1)", "def checkProduct(index, Product):\n    if Product > N[1]:\n        return 0\n    if index < len(L):\n        return checkProduct(index + 1, Product) + checkProduct(index + 1, Product * L[index])\n    elif Product <= N[1]:\n        return 1\n    else:\n        return 0\nN = list(map(int, input().split()))\nL = list(map(int, input().split()))\nCou = L.count(1)\nL = sorted((x for x in L if x <= N[1] and x > 1))\nprint((checkProduct(0, 1) - 1) * 2 ** Cou + 2 ** Cou - 1)", "from bisect import bisect_right\n\ndef comb(s, low, high, k):\n    size = high - low + 1\n    li = []\n    for i in range(1, 1 << size):\n        flag = 0\n        pro = 1\n        for j in range(0, size):\n            if i >> j & 1 == 1:\n                pro = pro * s[j + low]\n                if pro > k:\n                    flag = 1\n                    break\n        if flag == 0:\n            li.append(pro)\n    return li\n(n, k) = list(map(int, input().split(' ')))\ns = list(map(int, input().split(' ')))\nli1 = comb(s, 0, n // 2 - 1, k)\nli2 = comb(s, n // 2, n - 1, k)\nli2.sort()\ntotal = 0\nfor i in li1:\n    term = k // i\n    pos = bisect_right(li2, term, lo=0, hi=len(li2))\n    total += pos\nprint(len(li1) + len(li2) + total)", "string = input()\nval = string.split()\nint_val = [int(o) for o in val]\n(N, K) = int_val\nline = input()\nl = line.split()\nint_l = [int(x) for x in l]\nint_l.sort()\nnonones = []\nfor i in int_l:\n    if i != 1:\n        nonones.append(i)\nnoofones = len(int_l) - len(nonones)\nlist = [1]\ncount = 0\nfor i in nonones:\n    list_temp = []\n    for j in list:\n        if i * j <= K:\n            list_temp.append(i * j)\n            count += 1\n        else:\n            break\n    list.extend(list_temp)\n    list.sort()\nprint(int(count * 2 ** noofones + (2 ** noofones - 1)))", "def solve(a, count, m, x, n, i):\n    if i >= n:\n        return count\n    while i < n:\n        y = x\n        x *= a[i]\n        if x > m or x < y or x > 10 ** 18:\n            count += pow(2, n - i - 1)\n        else:\n            z = x\n            j = i + 1\n            while j < n:\n                z *= a[j]\n                if z > m or z > 10 ** 18:\n                    break\n                j += 1\n            if j >= n:\n                return count\n            count = solve(a, count, m, x, n, i + 1)\n        x = y\n        i += 1\n    return count\n\ndef main():\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort(reverse=True)\n    ans = solve(arr, 0, k, 1, n, 0)\n    l = pow(2, n) - 1\n    l -= ans\n    print(l)\nmain()", "def solve(a, count, m, x, n, i):\n    if i >= n:\n        return count\n    while i < n:\n        y = x\n        x *= a[i]\n        if x > m or x < y or x > 10 ** 18:\n            count += pow(2, n - i - 1)\n        else:\n            z = x\n            j = i + 1\n            while j < n:\n                z *= a[j]\n                if z > m or z > 10 ** 18:\n                    break\n                j += 1\n            if j >= n:\n                return count\n            count = solve(a, count, m, x, n, i + 1)\n        x = y\n        i += 1\n    return count\n\ndef main():\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort(reverse=True)\n    ans = solve(arr, 0, k, 1, n, 0)\n    l = pow(2, n) - 1\n    l -= ans\n    print(l)\nmain()", "import math\n(n, k) = input().split()\nn = int(n)\nk = int(k)\na = list(map(int, input().split()))\nhelper = []\nhelper.append(1)\na.sort()\ncountones = 0\na1 = []\nfor i in range(n):\n    if a[i] == 1:\n        countones += 1\n    elif a[i] > 1:\n        a1.append(a[i])\nfor i in range(len(a1)):\n    if a1[i] > k:\n        continue\n    le = len(helper)\n    j = 0\n    while j < le:\n        if helper[j] * a1[i] <= k:\n            helper.append(helper[j] * a1[i])\n        elif helper[j] * a1[i] > k:\n            break\n        j += 1\n    helper.sort()\nanswer = int((len(helper) - 1) * math.pow(2, countones) + math.pow(2, countones) - 1)\nprint(answer)", "import functools\n\ndef ans(a, i, n, k, p, prods):\n    if n == 0:\n        return 0\n    j = i + 1\n    n = n - 1\n    if p * prods[i] < k:\n        return 0\n    w = ans(a, j, n, k, p, prods)\n    if p * a[i] >= k:\n        return (1 << n) + w\n    return ans(a, j, n, k, p * a[i], prods) + w\n(n, k) = input().split(' ')\nn = int(n)\nk = int(k)\nnums = input().split(' ')\na = [int(x) for x in nums]\na.sort(reverse=True)\nprods = [functools.reduce(lambda x, y: x * y, a)]\nfor i in range(1, n):\n    prods.append(prods[i - 1] / a[i - 1])\nprint((1 << n) - ans(a, 0, n, k, 1, prods) - 1)", "v = []\nb = []\nind = -1\nl = list(map(int, input().split()))\nn = l[0]\nk = l[1]\narr = list(map(int, input().split()))\n\ndef compute(i, prod):\n    if i > ind:\n        return\n    compute(i + 1, prod)\n    v.append(prod * arr[i])\n    compute(i + 1, prod * arr[i])\n\ndef solve(i, prod):\n    if i == n:\n        return\n    solve(i + 1, prod)\n    if arr[i] > k:\n        return\n    prod *= arr[i]\n    if prod <= k:\n        b.append(prod)\n        solve(i + 1, prod)\n\ndef solve1(i, prod):\n    if i == n:\n        return 1\n    ans = solve1(i + 1, prod)\n    prod *= arr[i]\n    if prod <= k:\n        ans += solve1(i + 1, prod)\n    return ans\n\ndef upperBound(a, lo, hi, x):\n    if lo > hi:\n        return lo\n    mid = (lo + hi) // 2\n    if a[mid] == x:\n        return upperBound(a, mid + 1, hi, x)\n    elif a[mid] > x:\n        return upperBound(a, lo, mid - 1, x)\n    else:\n        return upperBound(a, mid + 1, hi, x)\nprod = 1\nfor i in range(n):\n    prod *= arr[i]\n    if prod <= k:\n        ind += 1\n    else:\n        break\nif ind > 5:\n    compute(0, 1)\n    solve(ind + 1, 1)\n    ans = (1 << ind + 1) - 1\n    v.sort()\n    for i in range(len(b)):\n        if b[i] > k:\n            continue\n        ans += 1\n        temp = k // b[i]\n        up = upperBound(v, 0, len(v) - 1, temp)\n        if up == len(v):\n            up -= 1\n        cnt = up + 1\n        while up >= 0 and v[up] > temp:\n            cnt -= 1\n            up -= 1\n        ans += cnt\nelse:\n    ans = solve1(0, 1) - 1\nprint(ans)", "(r, e) = input().split()\nn = int(r)\nval = int(e)\nlist = input().split()\ncount = 0\nstuff = []\ncou = 0\nsiu = 0\nfor i in list:\n    u = int(i)\n    if u < val and u != 1:\n        stuff.insert(count, u)\n        count = count + 1\n    if u == 1:\n        siu = siu + 1\nli = len(stuff)\nui = li\nli = int(li / 2)\npuff = stuff[0:li]\nkuff = stuff[li:ui]\nvol1 = 2 ** len(puff) - 1\nvol2 = 2 ** len(kuff) - 1\nans1 = []\nans2 = []\nfor i in range(1, vol1 + 1):\n    pro = 1\n    ue = 0\n    for j in range(0, len(puff) + 1):\n        if i & 1 << j:\n            pro = pro * puff[j]\n        if pro > val:\n            ue = 1\n            break\n    if ue == 0:\n        ans1.insert(0, pro)\nfor i in range(1, vol2 + 1):\n    pro = 1\n    ue = 0\n    for j in range(0, len(kuff) + 1):\n        if i & 1 << j:\n            pro = pro * kuff[j]\n        if pro > val:\n            ue = 1\n            break\n    if ue == 0:\n        ans2.insert(0, pro)\nans2.sort()\nans1.sort()\nfor i in range(0, len(ans1)):\n    for j in range(0, len(ans2)):\n        ri = ans1[i] * ans2[j]\n        if ri <= val:\n            cou = cou + 1\n        else:\n            break\nous = cou + len(ans1) + len(ans2)\nan = ous\nif siu >= 1:\n    an = 1 + 2 * ous\nif siu > 1:\n    for i in range(1, siu):\n        an = 1 + an * 2\nprint(an)", "(n, k) = map(int, input().split())\nd = []\ns = 0\nac = 0\nl = list(map(int, input().split()))\ncnt1 = l.count(1)\nfor i in range(n):\n    if i == 0 and l[i] != 1:\n        if l[i] <= k:\n            d.append(l[i])\n            s += 1\n            ac += 1\n    else:\n        asd = ac\n        z = 0\n        if l[i] <= k and l[i] != 1:\n            for j in range(ac):\n                x = l[i] * d[j]\n                if x <= k:\n                    s += 1\n                    d.append(x)\n                    z += 1\n            d.append(l[i])\n            z += 1\n            s += 1\n        ac += z\ns = (pow(2, cnt1) - 1) * (1 + s) + s\nprint(s)", "def q6(nums, k, d):\n    for i in range(len(nums)):\n        current = nums[i]\n        if current > k:\n            continue\n        currentDict = dict()\n        for elem in d:\n            new = current * elem\n            if new <= k:\n                currentDict[new] = d[elem]\n        for elem in currentDict:\n            if elem not in d:\n                d[elem] = currentDict[elem]\n            else:\n                d[elem] += currentDict[elem]\n        if current in d:\n            d[current] += 1\n        else:\n            d[current] = 1\n\ndef main():\n    line = input()\n    k = line.split(' ')[1]\n    nums = list(map(int, input().split(' ')))\n    d = dict()\n    q6(nums, int(k), d)\n    counter = 0\n    for p in d:\n        counter += d[p]\n    print(counter)\nmain()", "g1 = []\ng2 = []\nr = input().split()\nn = int(r[0])\nk = int(r[1])\ninp = [int(i) for i in input().split()]\nmid = int(n / 2)\na = inp[:mid]\nb = inp[mid:]\n\ndef genp(i, s):\n    if i == len(a):\n        if s != 0:\n            g1.append(s)\n    else:\n        genp(i + 1, s * a[i])\n        genp(i + 1, s)\n\ndef genp1(i, s):\n    if i == len(b):\n        if s != 0:\n            g2.append(s)\n    else:\n        genp1(i + 1, s * b[i])\n        genp1(i + 1, s)\n\ndef bin(v):\n    lo = 0\n    hi = len(g2) - 1\n    if hi * v <= v:\n        return -1\n    mid = int((lo + hi) / 2)\n    while lo <= hi:\n        mid = int((lo + hi) / 2)\n        if g2[mid] * v > k:\n            if g2[mid - 1] * v <= k:\n                return mid\n            hi = mid\n        elif g2[mid] * v <= k:\n            lo = mid + 1\n\ndef count():\n    g1.sort()\n    g2.sort()\n    ans = 0\n    j = len(g2) - 1\n    for i in range(len(g1)):\n        if g1[i] > k:\n            ans += len(g2)\n            continue\n        if g1[i] * g2[0] > k:\n            ans += len(g2) - 1\n            continue\n        while j > 0 and g1[i] * g2[j] > k:\n            j -= 1\n        ans += len(g2) - j - 1\n    return ans\n\ndef main():\n    genp(0, 1)\n    genp1(0, 1)\n    ans = count()\n    print(2 ** n - 1 - ans)\nmain()", "import math\n(n, k) = [int(i) for i in input().split()]\nk = math.log(k)\nc = [int(i) for i in input().split()]\na = [round(math.log(i), 10) for i in c]\nb = [dict() for x in range(n)]\n\ndef find_sequence(n, s):\n    if s > k:\n        return 0\n    if n == -1:\n        return 1\n    if s in b[n]:\n        return b[n][s]\n    else:\n        b[n][s] = find_sequence(n - 1, s + a[n]) + find_sequence(n - 1, s)\n        return b[n][s]\nanswer = find_sequence(n - 1, 0) - 1\nprint(answer)", "def numOfSub(integers, K, product, index):\n    if product > K:\n        return 0\n    if index == len(integers):\n        return 1\n    return numOfSub(integers, K, product * integers[index], index + 1) + numOfSub(integers, K, product, index + 1)\n\ndef buildStart(integers):\n    result = []\n    for i in range(len(integers) - 1):\n        result.append((integers[i + 1:], integers[i]))\n    return result\n\ndef buildCont(sets, K):\n    result = []\n    for i in range(len(sets)):\n        for j in range(len(sets[i][0])):\n            if sets[i][0][j] * sets[i][1] <= K:\n                result.append((sets[i][0][:j] + sets[i][0][j + 1:], sets[i][0][j] * sets[i][1]))\n    return result\n\ndef solve(integers, K):\n    result = buildStart(integers)\n    counter = len(result) + 1\n    while len(result) > 0:\n        result = buildCont(result, K)\n        counter += len(result)\n    return counter\n\ndef solve3(integers, K):\n    helper = {}\n    for i in integers:\n        tmp = {}\n        for j in helper:\n            if j * i <= K:\n                tmp[i * j] = helper[j]\n        for j in tmp:\n            if j in helper:\n                helper[j] += tmp[j]\n            else:\n                helper[j] = tmp[j]\n        if i not in helper:\n            helper[i] = 0\n        helper[i] += 1\n    result = 0\n    for j in helper:\n        result += helper[j]\n    return result\n(N, K) = input().split(' ')\n(N, K) = (int(N), int(K))\narrStr = input().split(' ')\nintegers = [int(a) for a in arrStr if int(a) <= K]\nprint(solve3(integers, K))", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nm = {}\nm[a[0]] = 1\nfor i in range(1, n):\n    m_temp = m.copy()\n    if a[i] in m_temp.keys():\n        m_temp[a[i]] = m_temp[a[i]] + 1\n    else:\n        m_temp[a[i]] = 1\n    for j in m:\n        if j * a[i] > k:\n            continue\n        if j * a[i] in m_temp.keys():\n            m_temp[j * a[i]] += m[j]\n        else:\n            m_temp[j * a[i]] = m[j]\n    m = m_temp\nans = 0\nfor j in m:\n    if j > k:\n        continue\n    ans += m[j]\nprint(ans)", "from bisect import bisect_right\n(A, B) = ([], [])\n(prodA, prodB) = ([], [])\nS = []\n(N, P) = map(int, input().split())\nM = N - N // 2\nN -= M\narr = list(map(int, input().split()))\nfor i in range(N):\n    A.append(arr[i])\nfor i in range(M):\n    B.append(arr[N + i])\n\ndef get_productsA(pos, prod, tak):\n    if pos == N:\n        if tak == False:\n            return\n        prodA.append(prod)\n        return\n    get_productsA(pos + 1, prod, tak)\n    if A[pos] * prod <= P:\n        get_productsA(pos + 1, prod * A[pos], True)\n\ndef get_productsB(pos, prod, tak):\n    if pos == M:\n        if tak == False:\n            return\n        prodB.append(prod)\n        return\n    get_productsB(pos + 1, prod, tak)\n    if B[pos] * prod <= P:\n        get_productsB(pos + 1, prod * B[pos], True)\nget_productsA(0, 1, 0)\nget_productsB(0, 1, 0)\nrval = 0\nprodA.sort()\nS.append((0, 0))\nfor val in prodA:\n    if val == S[-1][0]:\n        temp = S.pop()\n        S.append((temp[0], temp[1] + 1))\n    else:\n        S.append((val, S[-1][1] + 1))\nrval = len(prodA) + len(prodB)\nfor val in prodB:\n    if P // val >= S[-1][0]:\n        rval += S[-1][1]\n    else:\n        ii = bisect_right(S, (P // val, 0))\n        if S[ii][0] > P // val:\n            ii -= 1\n        rval += S[ii][1]\nprint(rval)", "(N, K) = list(map(int, input().strip().split(' ')))\nA = list(map(int, input().strip().split(' ')))\nA = sorted(A)\ntotal = {}\nfor i in range(N):\n    if len(total) == 0:\n        if A[i] <= K:\n            total[A[i]] = 1\n    else:\n        L = len(total)\n        if A[i] <= K:\n            TT = {}\n            for x in total:\n                TT[x] = total[x]\n            for x in TT:\n                temp = x * A[i]\n                if temp <= K:\n                    if temp in total:\n                        total[temp] += TT[x]\n                    else:\n                        total[temp] = TT[x]\n            if A[i] in total:\n                total[A[i]] += 1\n            else:\n                total[A[i]] = 1\n        else:\n            break\nSUM = 0\nfor x in total:\n    SUM += total[x]\nprint(SUM)", "import sys\n\ndef solve(A, n, k):\n    if n == 1:\n        return {A[0]: 1}\n    h = solve(A, n - 1, k)\n    hNew = {}\n    for x in h:\n        hNew[x] = h[x]\n    for x in h:\n        temp = x * A[n - 1]\n        if temp <= k:\n            if not temp in hNew:\n                hNew[temp] = 0\n            hNew[temp] += h[x]\n    if not A[n - 1] in hNew:\n        hNew[A[n - 1]] = 0\n    hNew[A[n - 1]] += 1\n    return hNew\n(n, k) = map(int, input().split())\nA = [x for x in list(map(int, input().split())) if x <= k]\nn = min(n, len(A))\nif n == 0:\n    print(0)\nelse:\n    h = solve(A, n, k)\n    print(sum(h.values()))", "(n, k) = list(map(int, input().split()))\nar = list(map(int, input().split()))\n\ndef proc(l, r):\n    prod = []\n    sz = r - l\n    for mask in range(1, 1 << sz):\n        res = 1\n        for i in range(l, r):\n            if mask & 1 << i - l:\n                res *= ar[i]\n        prod.append(res)\n    prod.sort()\n    return prod\n(left, right) = (list(reversed(proc(0, n // 2))), proc(n // 2, n))\nans = 0\nfor it in left:\n    if it <= k:\n        ans += 1\nfor it in right:\n    if it <= k:\n        ans += 1\nj = 0\nfor i in range(len(left)):\n    while j < len(right) and left[i] * right[j] <= k:\n        j += 1\n    ans += j\nprint(ans)", "import bisect\n(n, k) = map(int, input().split(' '))\nline = input()\narr = list(map(int, line.split(' ')))\npart1 = int(n / 2)\npart2 = n - part1\narr1 = []\narr2 = []\nfor i in range(0, part1):\n    arr1.append(arr[i])\nfor i in range(part1, n):\n    arr2.append(arr[i])\nsz1 = 1 << part1\nsz2 = 1 << part2\nset_part1 = []\nset_part2 = []\nfor i in range(1, sz1):\n    mul = 1\n    for j in range(0, part1):\n        if i & 1 << j != 0:\n            mul = mul * arr1[j]\n    if mul <= k:\n        set_part1.append(mul)\nfor i in range(1, sz2):\n    mul = 1\n    for j in range(0, part2):\n        if i & 1 << j != 0:\n            mul = mul * arr2[j]\n    if mul <= k:\n        set_part2.append(mul)\nset_part1.sort()\nset_part2.sort()\nl = len(set_part1)\nans = len(set_part1) + len(set_part2)\nfor i in range(0, l):\n    ind = bisect.bisect_right(set_part2, int(k / set_part1[i]))\n    ans = ans + ind\nprint(ans)", "(n, k) = list(map(int, input().split()))\na = list(map(int, input().split()))\nn1 = n // 2\nn2 = n - n1\nsa = []\nsb = []\nx = []\ny = []\n\ndef binarySearch(req):\n    l = 0\n    h = len(y) - 1\n    while l <= h:\n        mid = (l + h) // 2\n        if y[mid] == req:\n            l = mid + 1\n        elif y[mid] < req:\n            l = mid + 1\n        else:\n            h = mid - 1\n    return l\nfor i in range(0, n1):\n    sa.append(a[i])\nfor i in range(n1, n):\n    sb.append(a[i])\nfor i in range(1, 2 ** n1):\n    r = 1\n    for j in range(0, n1):\n        if i & 2 ** j:\n            r = r * sa[j]\n    x.append(r)\nfor i in range(1, 2 ** n2):\n    r = 1\n    for j in range(0, n2):\n        if i & 2 ** j:\n            r = r * sb[j]\n    y.append(r)\nres = 0\nx.sort()\ny.sort()\nfor i in x:\n    if i <= k:\n        res += 1\n    else:\n        break\nfor i in y:\n    if i <= k:\n        res += 1\n    else:\n        break\nfor i in range(len(x)):\n    req = k // x[i]\n    ans = binarySearch(req)\n    res += ans\nprint(res)", "(N, k) = list(map(int, input().split()))\na = list(map(int, input().split()))\nlA = []\nlB = []\n\ndef recA(i, chosen, n, mul, k):\n    if i == n:\n        if mul <= k and chosen != 0:\n            lA.append(mul)\n        return\n    recA(i + 1, chosen + 1, n, mul * a[i], k)\n    recA(i + 1, chosen, n, mul, k)\n\ndef recB(i, chosen, n, mul, k):\n    if i == n:\n        if mul <= k and chosen != 0:\n            lB.append(mul)\n        return\n    recB(i + 1, chosen + 1, n, mul * a[i], k)\n    recB(i + 1, chosen, n, mul, k)\n\ndef bsearch(aa, k):\n    l = 0\n    r = len(lB)\n    b = k // aa\n    while l < r:\n        mid = (l + r) // 2\n        if lB[mid] > b:\n            r = mid\n        elif lB[mid] < b:\n            l = mid + 1\n        else:\n            l = mid + 1\n    return r\nrecA(0, 0, N // 2, 1, k)\nrecB(N // 2, 0, N, 1, k)\nlA.sort()\nlB.sort()\nres = 0\nfor i in lA:\n    if i <= k:\n        res += 1\nfor i in lB:\n    if i <= k:\n        res += 1\nfor i in lA:\n    res += bsearch(i, k)\nprint(res)", "(n, k) = map(int, input().strip().split())\narr = list(map(int, input().strip().split()))\nl1 = [1]\nl2 = [1]\n\ndef get_possibilities(no):\n    start = 0\n    l2_len = len(l2)\n    end = l2_len - 1\n    if l2[end] * no <= k:\n        return l2_len\n    while start <= end:\n        mid = (start + end) // 2\n        if mid == l2_len - 1:\n            return 0\n        elif l2[mid] * no <= k and l2[mid + 1] * no > k:\n            return mid + 1\n        elif l2[mid] * no <= k:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return 0\nfor i in arr[:n // 2]:\n    l1_len = len(l1)\n    for j in l1[:l1_len]:\n        if i * j <= k:\n            l1.append(i * j)\nfor i in arr[n // 2:]:\n    l2_len = len(l2)\n    for j in l2[:l2_len]:\n        if i * j <= k:\n            l2.append(i * j)\nl2.sort()\nans = -1\nfor i in l1:\n    ans += get_possibilities(i)\nprint(ans)", "from copy import deepcopy\n[n, k] = list(map(int, input().split()))\na = list(map(int, input().split()))\na.sort()\ns = {}\nfor ii in a:\n    if ii >= k:\n        break\n    d = []\n    for j in s:\n        if j * ii <= k:\n            d.append([ii * j, s[j]])\n    if ii in s:\n        s[ii] += 1\n    else:\n        s[ii] = 1\n    for i in d:\n        if i[0] in s:\n            s[i[0]] += 1 * i[1]\n        else:\n            s[i[0]] = i[1]\nans = 0\nfor i in s:\n    ans += s[i]\nprint(ans)", "a = list(map(int, input().split(' ')))\nn = a[0]\nk = a[1]\na = list(map(int, input().split(' ')))\na1 = []\na2 = []\nfor i in range(len(a) // 2):\n    a1.append(a[i])\nfor i in range(len(a) // 2, len(a)):\n    a2.append(a[i])\np1 = []\np2 = []\nfor i in range(1, 1 << len(a1)):\n    pro = 1\n    for j in range(len(a1)):\n        if i >> j & 1 == 1:\n            pro = pro * a1[j]\n    if pro <= k:\n        p1.append(pro)\nfor i in range(1, 1 << len(a2)):\n    pro = 1\n    for j in range(len(a2)):\n        if i >> j & 1 == 1:\n            pro = pro * a2[j]\n    if pro <= k:\n        p2.append(pro)\nans = 0\np1.sort()\np2.sort()\nans = ans + len(p1) + len(p2)\nind2 = 0\np1.reverse()\nfor i in p1:\n    while ind2 < len(p2) and i * p2[ind2] <= k:\n        ind2 = ind2 + 1\n    ans = ans + ind2\nprint(ans)", "from collections import defaultdict\n(N, K) = map(int, input().split())\nnums = list((int(token) for token in input().split()))\nnums.sort()\n\ndef simple_sol():\n    ones = sum((num == 1 for num in nums))\n    nonones = nums[ones:]\n    s = defaultdict(int)\n    s[1] = 2 ** ones\n    for num in nonones:\n        for (key, value) in list(s.items()):\n            nkey = key * num\n            if nkey <= K:\n                s[nkey] += value\n    return sum(s.values()) - 1\nprint(simple_sol())", "lis = input().split()\nn = int(lis[0])\nk = int(lis[1])\nlis = input().split()\nArray = []\nfor i in range(0, n):\n    Array.append(int(lis[i]))\nX = []\nY = []\nfor i in range(0, 1 << int(n / 2)):\n    result = 1\n    for j in range(0, int(n / 2)):\n        if i & 1 << j:\n            result = result * Array[j]\n    X.append(result)\nfor i in range(0, 1 << n - int(n / 2)):\n    result = 1\n    for j in range(0, n - int(n / 2)):\n        if i & 1 << j:\n            result = result * Array[j + int(n / 2)]\n    Y.append(result)\nszx = 1 << int(n / 2)\nszy = 1 << n - int(n / 2)\nY.sort()\nCount = 0\nX[0] = 1\nY[0] = 1\nfor i in range(0, szx):\n    low = 0\n    high = szy\n    p = 0\n    while low < high:\n        mid = int((low + high) / 2)\n        if Y[mid] <= k / X[i]:\n            p = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    if p < szy - 1:\n        p = p + 1\n    if p == szy:\n        p = p - 1\n    while Y[p] * X[i] > k and p >= 0:\n        p = p - 1\n    if p == -1:\n        continue\n    if Y[p] * X[i] <= k:\n        Count = Count + (p + 1)\nprint(Count - 1)", "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\n\ndef f(i, p):\n    if p > k:\n        return 0\n    if i == -1:\n        return 1\n    if p not in dp[i]:\n        dp[i][p] = f(i - 1, p) + f(i - 1, p * a[i])\n    return dp[i][p]\ndp = [{} for i in range(n)]\nans = f(n - 1, 1) - 1\nprint(ans)", "def solve(A, aa, k):\n    A.sort()\n    for i in range(1, 2 ** len(A)):\n        mul = 1\n        for j in range(0, len(A)):\n            if 2 ** j & i:\n                mul = mul * A[j]\n        if mul <= k:\n            aa.append(mul)\n    aa.sort()\n(N, K) = map(int, input().split())\nArr = [int(x) for x in input().split()]\nA = list()\nB = list()\nfor i in range(1, N + 1):\n    if 2 * i <= N:\n        A.append(Arr[i - 1])\n    else:\n        B.append(Arr[i - 1])\naa = list()\nbb = list()\nsolve(A, aa, K)\nsolve(B, bb, K)\nresult = len(aa) + len(bb)\nfor i in range(0, len(aa)):\n    b = 0\n    e = len(bb) - 1\n    idx = -1\n    while b <= e:\n        mi = (b + e) // 2\n        if aa[i] * bb[mi] <= K:\n            idx = mi\n            b = mi + 1\n        else:\n            e = mi - 1\n    result += idx + 1\nprint(result)", "from sys import stdin\nfrom _bisect import bisect_right\n\ndef line():\n    return stdin.readline().strip()\n\ndef solve(V):\n    ans = []\n    _len = len(V)\n    for mask in range(1, 1 << _len):\n        _ans = 1\n        for j in range(_len):\n            if mask & 1 << j:\n                _ans *= V[j]\n        ans.append(_ans)\n    return ans\n(N, K) = map(int, line().split())\nL = list(map(int, line().split()))\na = solve(L[:N // 2])\nb = solve(L[N // 2:])\nans = 0\na = sorted(a)\nfor i in b:\n    temp = K // i\n    _s = bisect_right(a, temp)\n    ans += _s\nb = sorted(b)\nans += bisect_right(a, K)\nans += bisect_right(b, K)\nprint(ans)"]