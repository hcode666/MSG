["t = int(input())\nfor z in range(t):\n    (n, m) = map(int, input().split(' '))\n    mp = {}\n    cr = {}\n    for i in range(1, n + 1):\n        mp[i] = 0\n        cr[i] = False\n    l = list()\n    for j in range(m):\n        (n1, n2) = map(int, input().split(' '))\n        l.append((n1, n2))\n        mp[n1] += 1\n        mp[n2] += 1\n    if m % 2 > 0:\n        print(-1)\n        continue\n    else:\n        ans = []\n        for i in range(m):\n            cr[l[i][1]] = not cr[l[i][1]]\n            ans.append(0)\n        for i in range(m - 1, -1, -1):\n            if cr[l[i][1]] == True:\n                cr[l[i][1]] = False\n                ans[i] = 1\n                if cr[l[i][0]] == True:\n                    cr[l[i][0]] = False\n                else:\n                    cr[l[i][0]] = True\n        for i in range(len(ans)):\n            print(ans[i], end=' ')\n        print()", "t = int(input())\nfor z in range(t):\n    (n, m) = map(int, input().split(' '))\n    mp = {}\n    cr = {}\n    for i in range(1, n + 1):\n        mp[i] = 0\n        cr[i] = False\n    l = list()\n    for j in range(m):\n        (n1, n2) = map(int, input().split(' '))\n        l.append((n1, n2))\n        mp[n1] += 1\n        mp[n2] += 1\n    if m % 2 > 0:\n        print(-1)\n        continue\n    else:\n        ans = []\n        for i in range(m):\n            cr[l[i][1]] = not cr[l[i][1]]\n            ans.append(0)\n        for i in range(m - 1, -1, -1):\n            if cr[l[i][1]] == True:\n                cr[l[i][1]] = False\n                ans[i] = 1\n                if cr[l[i][0]] == True:\n                    cr[l[i][0]] = False\n                else:\n                    cr[l[i][0]] = True\n        for i in range(len(ans)):\n            print(ans[i], end=' ')\n        print()", "t = int(input())\nfor z in range(t):\n    (n, m) = map(int, input().split(' '))\n    mp = {}\n    cr = {}\n    for i in range(1, n + 1):\n        mp[i] = 0\n        cr[i] = False\n    l = list()\n    for j in range(m):\n        (n1, n2) = map(int, input().split(' '))\n        l.append((n1, n2))\n        mp[n1] += 1\n        mp[n2] += 1\n    if m % 2 > 0:\n        print(-1)\n        continue\n    else:\n        ans = []\n        for i in range(m):\n            cr[l[i][1]] = not cr[l[i][1]]\n            ans.append(0)\n        for i in range(m - 1, -1, -1):\n            if cr[l[i][1]] == True:\n                cr[l[i][1]] = False\n                ans[i] = 1\n                if cr[l[i][0]] == True:\n                    cr[l[i][0]] = False\n                else:\n                    cr[l[i][0]] = True\n        for i in range(len(ans)):\n            print(ans[i], end=' ')\n        print()", "for _ in range(int(input())):\n    l = []\n    mp = {}\n    cr = {}\n    ans = []\n    (n, m) = map(int, input().split())\n    for i in range(1, n + 1):\n        mp[i] = 0\n        cr[i] = False\n    for _ in range(m):\n        (f, t) = map(int, input().split())\n        l.append((f, t))\n        mp[f] += 1\n        mp[t] += 1\n    if m % 2 > 0:\n        print(-1)\n        continue\n    else:\n        for _ in range(m):\n            cr[l[_][1]] = not cr[l[_][1]]\n            ans.append(0)\n        for _ in range(m - 1, -1, -1):\n            if cr[l[_][1]] == True:\n                cr[l[_][1]] = not True\n                ans[_] = 1\n                if cr[l[_][0]]:\n                    cr[l[_][0]] = False\n                else:\n                    cr[l[_][0]] = True\n        for i in range(len(ans)):\n            print(ans[i], end=' ')\n        print()", "try:\n    for __ in range(int(input())):\n        (n, m) = map(int, input().split())\n        g = [[] for _ in range(n + 1)]\n        long = []\n        di = {}\n        stable = [0 for _ in range(n + 1)]\n        edges = [0 for _ in range(m)]\n        for i in range(m):\n            (x, y) = map(int, input().split())\n            g[x].append(y)\n            g[y].append(x)\n            stable[y] += 1\n            long.append([x, y])\n            di[x, y] = i\n            di[y, x] = i\n        f = 1\n        if m % 2:\n            f = 0\n        for i in range(m):\n            (c, d) = (long[i][0], long[i][1])\n            if stable[c] % 2 == 1 and stable[d] % 2 == 1:\n                stable[c] += 1\n                stable[d] -= 1\n                edges[i] = 1\n        s = []\n        for i in range(1, n + 1):\n            if stable[i] % 2 == 1:\n                s.append(i)\n        while s and f:\n            set1 = set()\n            for i in s:\n                if stable[i] % 2:\n                    y = g[i][0]\n                    w = di[i, y]\n                    stable[y] += 1\n                    stable[i] -= 1\n                    set1.add(y)\n                    edges[w] = abs(edges[w] - 1)\n            s = set1\n        if f:\n            print(*edges)\n        else:\n            print(-1)\nexcept:\n    pass", "for _ in range(int(input())):\n    (N, M) = [int(x) for x in input().split()]\n    edges = [0] * M\n    dir = {}\n    nodes = [[] for j in range(N + 1)]\n    ind = [0] * (N + 1)\n    graph = {}\n    final_edges = []\n    for i in range(M):\n        (u, v) = [int(x) for x in input().split()]\n        nodes[u].append(v)\n        nodes[v].append(u)\n        dir[u, v] = 1\n        dir[v, u] = 0\n        ind[v] += 1\n        graph[u, v] = graph[v, u] = i\n        final_edges.append([u, v])\n    if M % 2 != 0:\n        print(-1)\n        continue\n    for i in range(M):\n        (u, v) = final_edges[i]\n        if ind[u] % 2 != 0 and ind[v] % 2 != 0:\n            d = dir[u, v]\n            if d:\n                ind[u] += 1\n                ind[v] -= 1\n                dir[u, v] = 0\n                dir[v, u] = 1\n                edges[i] = abs(edges[i] - 1)\n            else:\n                ind[u] -= 1\n                ind[v] += 1\n                dir[u, v] = 1\n                dir[v, u] = 0\n                edges[i] = abs(edges[i] - 1)\n    s = []\n    for i in range(1, N + 1):\n        if ind[i] % 2:\n            s.append(i)\n    while s:\n        set1 = set()\n        for u in s:\n            if ind[u] % 2:\n                v = nodes[u][0]\n                d = dir[u, v]\n                index = graph[u, v]\n                set1.add(v)\n                if d:\n                    ind[u] += 1\n                    ind[v] -= 1\n                    dir[u, v] = 1\n                    dir[v, u] = 1\n                    edges[index] = abs(edges[index] - 1)\n                else:\n                    ind[u] -= 1\n                    ind[v] += 1\n                    dir[u, v] = 1\n                    dir[v, u] = 0\n                    edges[index] = abs(edges[index] - 1)\n        s = set1\n    print(*edges)", "for __ in range(int(input())):\n    (n, m) = map(int, input().split())\n    g = [[] for _ in range(n + 1)]\n    long = []\n    di = {}\n    stable = [0 for _ in range(n + 1)]\n    edges = [0 for _ in range(m)]\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        g[x].append(y)\n        g[y].append(x)\n        stable[y] += 1\n        long.append([x, y])\n        di[x, y] = i\n        di[y, x] = i\n    f = 1\n    if m % 2:\n        f = 0\n    for i in range(m):\n        (c, d) = (long[i][0], long[i][1])\n        if stable[c] % 2 == 1 and stable[d] % 2 == 1:\n            stable[c] += 1\n            stable[d] -= 1\n            edges[i] = 1\n    s = []\n    for i in range(1, n + 1):\n        if stable[i] % 2 == 1:\n            s.append(i)\n    while s and f:\n        set1 = set()\n        for i in s:\n            if stable[i] % 2:\n                y = g[i][0]\n                w = di[i, y]\n                stable[y] += 1\n                stable[i] -= 1\n                set1.add(y)\n                edges[w] = abs(edges[w] - 1)\n        s = set1\n    if f:\n        print(*edges)\n    else:\n        print(-1)", "import sys\nfrom collections import deque\ncroot = dict()\nsetnumber = dict()\n\ndef finalroot(v):\n    if croot[v] != v:\n        v = finalroot(croot[v])\n    return v\n\ndef union(v1, v2):\n    r1 = finalroot(v1)\n    r2 = finalroot(v2)\n    if r1 != r2:\n        if setnumber[r1] > setnumber[r2]:\n            croot[r2] = r1\n        else:\n            croot[r1] = r2\n            if setnumber[r1] == setnumber[r2]:\n                setnumber[r2] += 1\n\ndef minspan(n, edges):\n    finale = []\n    edgecount = {}\n    for i in range(n):\n        edgecount[i + 1] = 0\n        setnumber[i + 1] = 0\n        croot[i + 1] = i + 1\n    edges.sort()\n    for e in edges:\n        (u, v) = e\n        if finalroot(u) != finalroot(v):\n            edgecount[u] += 1\n            edgecount[v] += 1\n            finale.append((u, v))\n            union(u, v)\n    root = max(edgecount.keys(), key=lambda k: edgecount[k])\n    return (set(finale), root)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        (n, m) = [int(item) for item in input().split()]\n        e = set()\n        elist = []\n        for i in range(m):\n            (u, v) = [int(item) for item in input().split()]\n            elist.append((u, v))\n            e.add((u, v))\n        (finale, root) = minspan(n, list(e))\n        sroot = root\n        tofix = e - finale\n        indegree = {}\n        for i in range(n):\n            indegree[i + 1] = 0\n        decided = set()\n        for t in tofix:\n            indegree[t[1]] += 1\n            decided.add((t[0], t[1]))\n        cf = {}\n        pf = {}\n        for i in range(n):\n            cf[i + 1] = set()\n            pf[i + 1] = set()\n        for f in finale:\n            (u, v) = f\n            cf[u].add(v)\n            cf[v].add(u)\n        r = deque()\n        r.append(root)\n        while len(r) != 0:\n            root = r.pop()\n            for c in cf[root]:\n                r.append(c)\n                cf[c].remove(root)\n                pf[c] = root\n        q = deque([sroot])\n        st = deque()\n        while len(q) != 0:\n            node = q.pop()\n            st.append(node)\n            for e in cf[node]:\n                q.append(e)\n        while len(st) != 0:\n            c = st.pop()\n            if c != sroot:\n                p = pf[c]\n                if indegree[c] % 2 == 0:\n                    decided.add((c, p))\n                    indegree[p] += 1\n                else:\n                    decided.add((p, c))\n                    indegree[c] += 1\n        possible = indegree[sroot] % 2 == 0\n        if possible:\n            ans = []\n            for i in elist:\n                if i in decided:\n                    ans.append(0)\n                else:\n                    ans.append(1)\n            print(*ans)\n        else:\n            print(-1)\n    return 0\nmain()", "for t in range(int(input())):\n    (n, m) = map(int, input().split())\n    g = [[] for _ in range(n + 1)]\n    long = []\n    di = {}\n    stable = [0] * (n + 1)\n    edges = [0] * m\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        g[x].append(y)\n        g[y].append(x)\n        stable[y] += 1\n        long.append([x, y])\n        di[x, y] = i\n        di[y, x] = i\n    f = 1\n    if m % 2:\n        f = 0\n    for i in range(m):\n        (c, d) = (long[i][0], long[i][1])\n        if stable[c] % 2 == 1 and stable[d] % 2 == 1:\n            stable[c] += 1\n            stable[d] -= 1\n            edges[i] = 1\n    s = []\n    for i in range(1, n + 1):\n        if stable[i] % 2 == 1:\n            s.append(i)\n    while s and f:\n        set1 = set()\n        for i in s:\n            if stable[i] % 2:\n                y = g[i][0]\n                w = di[i, y]\n                if edges[x]:\n                    stable[y] += 1\n                    stable[i] -= 1\n                else:\n                    stable[i] += 1\n                    stable[y] -= 1\n                set1.add(y)\n                edges[w] = abs(edges[w] - 1)\n        s = set1\n    if f:\n        print(*edges)\n    else:\n        print(-1)", "for _ in range(int(input())):\n    (N, M) = [int(x) for x in input().split()]\n    edges = [0] * M\n    dir = {}\n    nodes = [[] for j in range(N + 1)]\n    ind = [0] * (N + 1)\n    graph = {}\n    final_edges = []\n    for i in range(M):\n        (u, v) = [int(x) for x in input().split()]\n        nodes[u].append(v)\n        nodes[v].append(u)\n        dir[u, v] = 1\n        dir[v, u] = 0\n        ind[v] += 1\n        graph[u, v] = graph[v, u] = i\n        final_edges.append([u, v])\n    if M % 2 != 0:\n        print(-1)\n        continue\n    for i in range(M):\n        (u, v) = final_edges[i]\n        if ind[u] % 2 != 0 and ind[v] % 2 != 0:\n            d = dir[u, v]\n            if d:\n                ind[u] += 1\n                ind[v] -= 1\n                dir[u, v] = 0\n                dir[v, u] = 1\n                edges[i] = abs(edges[i] - 1)\n            else:\n                ind[u] -= 1\n                ind[v] += 1\n                dir[u, v] = 1\n                dir[v, u] = 0\n                edges[i] = abs(edges[i] - 1)\n    s = []\n    for i in range(1, N + 1):\n        if ind[i] % 2:\n            s.append(i)\n    while s:\n        set1 = set()\n        for u in s:\n            if ind[u] % 2:\n                v = nodes[u][0]\n                d = dir[u, v]\n                index = graph[u, v]\n                set1.add(v)\n                if d:\n                    ind[u] += 1\n                    ind[v] -= 1\n                    dir[u, v] = 0\n                    dir[v, u] = 1\n                    edges[index] = abs(edges[index] - 1)\n                else:\n                    ind[u] -= 1\n                    ind[v] += 1\n                    dir[u, v] = 1\n                    dir[v, u] = 0\n                    edges[index] = abs(edges[index] - 1)\n        s = set1\n    print(*edges)", "for _ in range(int(input())):\n    l = []\n    mp = {}\n    cr = {}\n    ans = []\n    (n, m) = map(int, input().split())\n    for i in range(1, n + 1):\n        mp[i] = 0\n        cr[i] = False\n    for _ in range(m):\n        (f, t) = map(int, input().split())\n        l.append((f, t))\n        mp[f] += 1\n        mp[t] += 1\n    if m % 2 > 0:\n        print(-1)\n        continue\n    else:\n        for _ in range(m):\n            cr[l[_][1]] = not cr[l[_][1]]\n            ans.append(0)\n        for _ in range(m - 1, -1, -1):\n            if cr[l[_][1]] == True:\n                cr[l[_][1]] = not True\n                ans[_] = 1\n                if cr[l[_][0]]:\n                    cr[l[_][0]] = False\n                else:\n                    cr[l[_][0]] = True\n        for i in range(len(ans)):\n            print(ans[i], end=' ')\n        print()", "import sys\nsys.setrecursionlimit(20000)\n\ndef leftedges(v):\n    arr = []\n    for i in dic[v]:\n        if ans.get(str(i) + '-' + str(v), -1) == None or ans.get(str(v) + '-' + str(i), -1) == None:\n            arr.append(i)\n    return arr\n\ndef dfs(v, visited, ans, dic, check):\n    visited[v] = True\n    for i in dic[v]:\n        if visited[i] == False:\n            dfs(i, visited, ans, dic, check)\n    arr = leftedges(v)\n    l = len(arr)\n    if l == 0:\n        return\n    elif l % 2 == 1 and check[v] % 2 == 0:\n        a = arr[-1]\n        if ans.get(str(v) + '-' + str(a), -1) == None:\n            ans[str(v) + '-' + str(a)] = 0\n        else:\n            ans[str(a) + '-' + str(v)] = 1\n        check[a] += 1\n        check[v] += l - 1\n        for j in range(l - 1):\n            a = arr[j]\n            if ans.get(str(a) + '-' + str(v), -1) == None:\n                ans[str(a) + '-' + str(v)] = 0\n            else:\n                ans[str(v) + '-' + str(a)] = 1\n    elif l % 2 == 1 and check[v] % 2 == 1:\n        check[v] += l\n        for j in range(l):\n            a = arr[j]\n            if ans.get(str(a) + '-' + str(v), -1) == None:\n                ans[str(a) + '-' + str(v)] = 0\n            else:\n                ans[str(v) + '-' + str(a)] = 1\n    elif l % 2 == 0 and check[v] % 2 == 1:\n        a = arr[-1]\n        if ans.get(str(v) + '-' + str(a), -1) == None:\n            ans[str(v) + '-' + str(a)] = 0\n        else:\n            ans[str(a) + '-' + str(v)] = 1\n        check[a] += 1\n        check[v] += l - 1\n        for j in range(l - 1):\n            a = arr[j]\n            if ans.get(str(a) + '-' + str(v), -1) == None:\n                ans[str(a) + '-' + str(v)] = 0\n            else:\n                ans[str(v) + '-' + str(a)] = 1\n    elif l % 2 == 0 and check[v] % 2 == 0:\n        check[v] += l\n        for j in range(l):\n            a = arr[j]\n            if ans.get(str(a) + '-' + str(v), -1) == None:\n                ans[str(a) + '-' + str(v)] = 0\n            else:\n                ans[str(v) + '-' + str(a)] = 1\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    dic = {i: [] for i in range(1, n + 1)}\n    ans = {}\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        dic[u].append(v)\n        dic[v].append(u)\n        ans[str(u) + '-' + str(v)] = None\n    if m % 2 == 1:\n        print(-1)\n    else:\n        visited = {i: False for i in range(1, n + 1)}\n        check = {i: 0 for i in range(1, n + 1)}\n        dfs(1, visited, ans, dic, check)\n        print(*ans.values())", "import time\nimport sys\nimport gc\nfrom collections import deque\n\nclass Graph(object):\n\n    def __init__(self, N, M):\n        self.N = N\n        self.M = M\n        self.vec = {}\n        self.edgeDirs = [0] * self.M\n        self.spanning_edges = {}\n        self.edge2index = {}\n        self.index = 0\n\n    def addEdge(self, u, v):\n        if u not in self.vec:\n            self.vec[u] = set()\n        self.vec[u].add(v)\n        if v not in self.vec:\n            self.vec[v] = set()\n        self.vec[v].add(u)\n        self.edge2index[u, v] = self.index\n        self.index += 1\n\n    def makeEven(self):\n        post_order = []\n        stack = [1]\n        visited = set()\n        while len(stack) != 0:\n            u = stack.pop()\n            if u in visited:\n                continue\n            else:\n                visited.add(u)\n                post_order.append(u)\n            for v in self.vec[u]:\n                if v not in visited:\n                    self.spanning_edges[v] = u\n                    stack.append(v)\n        while len(post_order) != 0:\n            u = post_order.pop()\n            odd_edges = len(self.vec[u]) % 2 == 1\n            if odd_edges:\n                span_node = self.spanning_edges[u]\n                self.vec[u].remove(span_node)\n            while len(self.vec[u]) > 0:\n                v1 = self.vec[u].pop()\n                v2 = self.vec[u].pop()\n                self.direct(v1, u)\n                self.direct(v2, u)\n                self.vec[v1].remove(u)\n                self.vec[v2].remove(u)\n            if odd_edges:\n                self.vec[u].add(span_node)\n\n    def direct(self, u, v):\n        if (u, v) not in self.edge2index:\n            self.edgeDirs[self.edge2index[v, u]] = 1\n\n    def getIndex(self, edge):\n        (u, v) = edge\n        if (u, v) in self.edge2index:\n            return self.edge2index[u, v]\n        else:\n            return self.edge2index[v, u]\nT = int(input())\nfor _ in range(T):\n    [N, M] = list(map(int, input().split()))\n    if M & 1:\n        for _ in range(M):\n            input()\n        print(-1)\n        sys.stdout.flush()\n    else:\n        graph = Graph(N, M)\n        for _ in range(M):\n            [ui, vi] = list(map(int, input().split()))\n            graph.addEdge(ui, vi)\n        graph.makeEven()\n        print(' '.join(map(str, graph.edgeDirs)))\n        sys.stdout.flush()", "for __ in range(int(input())):\n    (n, m) = map(int, input().split())\n    g = [[] for _ in range(n + 1)]\n    long = []\n    di = {}\n    stable = [0 for _ in range(n + 1)]\n    edges = [0 for _ in range(m)]\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        g[x].append(y)\n        g[y].append(x)\n        stable[y] += 1\n        long.append([x, y])\n        di[x, y] = i\n        di[y, x] = i\n    f = 1\n    if m % 2:\n        f = 0\n    for i in range(m):\n        (c, d) = (long[i][0], long[i][1])\n        if stable[c] % 2 == 1 and stable[d] % 2 == 1:\n            stable[c] += 1\n            stable[d] -= 1\n            edges[i] = 1\n    s = []\n    for i in range(1, n + 1):\n        if stable[i] % 2 == 1:\n            s.append(i)\n    while s and f:\n        set1 = set()\n        for i in s:\n            if stable[i] % 2:\n                y = g[i][0]\n                w = di[i, y]\n                if edges[x]:\n                    stable[y] += 1\n                    stable[i] -= 1\n                else:\n                    stable[i] += 1\n                    stable[y] -= 1\n                set1.add(y)\n                edges[w] = abs(edges[w] - 1)\n        s = set1\n    if f:\n        print(*edges)\n    else:\n        print(-1)", "cs = int(input())\nfor c in range(cs):\n    (N, M) = map(int, input().split())\n    vertices = []\n    answer = []\n    for n in range(N):\n        parent = None\n        children = set()\n        neighbours = set()\n        inEdges = set()\n        outEdges = set()\n        vertices.append([parent, children, neighbours, inEdges, outEdges])\n    for m in range(M):\n        (u, v) = map(int, input().split())\n        answer.append([[u, v], None])\n        vertices[u - 1][2].add(v)\n        vertices[v - 1][2].add(u)\n    inTree = set([1])\n    levels = [[1]]\n    while len(inTree) < N:\n        curLeaves = levels[-1]\n        nextL = []\n        for leaf in curLeaves:\n            for neigh in vertices[leaf - 1][2]:\n                if neigh not in inTree:\n                    inTree.add(neigh)\n                    vertices[leaf - 1][1].add(neigh)\n                    vertices[neigh - 1][0] = leaf\n                    nextL.append(neigh)\n        levels.append(nextL)\n    for a in answer:\n        u = a[0][0]\n        v = a[0][1]\n        if v not in vertices[u - 1][1] and v != vertices[u - 1][0]:\n            vertices[u - 1][4].add(v)\n            vertices[v - 1][3].add(u)\n            a[1] = 0\n    while len(levels) > 1:\n        curLevel = levels.pop()\n        for leafPointer in curLevel:\n            parentPointer = vertices[leafPointer - 1][0]\n            if len(vertices[leafPointer - 1][3]) % 2 == 0:\n                vertices[leafPointer - 1][4].add(parentPointer)\n                vertices[parentPointer - 1][3].add(leafPointer)\n            else:\n                vertices[leafPointer - 1][3].add(parentPointer)\n                vertices[parentPointer - 1][4].add(leafPointer)\n    root = levels.pop()[0]\n    for a in answer:\n        u = a[0][0]\n        v = a[0][1]\n        status = a[1]\n        if status == None:\n            uInEdges = vertices[u - 1][3]\n            if v in uInEdges:\n                a[1] = 1\n            else:\n                a[1] = 0\n    if len(vertices[root - 1][3]) % 2 == 1:\n        print(-1)\n    else:\n        for a in answer:\n            print(a[1], end=' ')\n        print()", "T = int(input())\nfor t in range(T):\n    (N, M) = map(int, input().split())\n    tab = dict()\n    sasiedzi = [[] for i in range(N)]\n    wchodzs = [[] for i in range(N)]\n    visited = [-1] * N\n    kraws = []\n    for m in range(M):\n        (x, y) = map(int, input().split())\n        x -= 1\n        y -= 1\n        kraws.append((x, y))\n        tab[x, y] = 1\n        tab[y, x] = 1\n        sasiedzi[x].append(y)\n        sasiedzi[y].append(x)\n    for vis in range(N):\n        if visited[vis] >= 0:\n            continue\n        krawedzi = set()\n        stack = [vis]\n        visited[vis] = 0\n        ind = 0\n        while stack:\n            nr = stack[-1]\n            bylo = []\n            for j in range(visited[nr], len(sasiedzi[nr])):\n                i = sasiedzi[nr][j]\n                if visited[i] >= 0:\n                    continue\n                stack.append(i)\n                visited[nr] = j + 1\n                visited[i] = 0\n                bylo = True\n                break\n            if bylo:\n                continue\n            stack.pop()\n            if not stack:\n                break\n            wchodzacych = 0\n            nieustalonych = 0\n            for i in sasiedzi[nr]:\n                if tab[nr, i] == -1:\n                    wchodzacych += 1\n                if tab[nr, i] == tab[i, nr]:\n                    nieustalonych += 1\n                    nieustnr = i\n            if nieustalonych == 1:\n                if wchodzacych % 2 == 0:\n                    tab[nieustnr, nr] = -1\n                else:\n                    tab[nr, nieustnr] = -1\n            else:\n                for i in sasiedzi[nr]:\n                    if nieustalonych == 0:\n                        break\n                    if tab[nr, i] != tab[i, nr]:\n                        continue\n                    if nieustalonych == 1 and wchodzacych % 2 == 0:\n                        tab[i, nr] = -1\n                        nieustalonych -= 1\n                        break\n                    tab[nr, i] = -1\n                    nieustalonych -= 1\n                    wchodzacych += 1\n        if len(krawedzi) % 2 == 1:\n            niepa = True\n    res = [0] * M\n    nr = 0\n    for (x, y) in kraws:\n        if tab[x, y] == -1:\n            res[nr] = 1\n        nr += 1\n    ok = True\n    for y in range(N):\n        chk = 0\n        for sas in sasiedzi[y]:\n            if tab[y, sas] == -1:\n                chk += 1\n        if chk % 2 != 0:\n            ok = False\n    if ok:\n        print(' '.join(map(str, res)))\n    else:\n        print(-1)", "from collections import OrderedDict\nT = int(input())\nfor t in range(T):\n    (N, M) = [int(x) for x in input().split()]\n    if M % 2 == 1:\n        for i in range(M):\n            (i, j) = [int(x) for x in input().split()]\n        print(-1)\n    else:\n        indegree = {k: 0 for k in list(range(1, N + 1))}\n        d = {k: [] for k in list(range(1, N + 1))}\n        edges = OrderedDict()\n        for i in range(M):\n            (i, j) = [int(x) for x in input().split()]\n            d[i].append(j)\n            edges[i, j] = 0\n            indegree[j] = 1 - indegree[j]\n        parent = [-1] * (N + 1)\n        visited = {k: 0 for k in list(range(1, N + 1))}\n        stack = []\n        leaf = []\n        stack.append(1)\n        visited[1] = 1\n        while stack:\n            vertex = stack.pop()\n            nochildren = 1\n            for v in d[vertex]:\n                if visited[v] == 0:\n                    stack.append(v)\n                    visited[v] = 1\n                    parent[v] = vertex\n                    nochildren = 0\n            if nochildren == 1:\n                leaf.append(vertex)\n        for i in leaf:\n            j = i\n            while j != 1:\n                dad = parent[j]\n                if indegree[j] == 1:\n                    indegree[j] = 0\n                    indegree[dad] = 1 - indegree[dad]\n                    if (j, dad) in edges:\n                        edges[j, dad] = 1 - edges[j, dad]\n                    elif (dad, j) in edges:\n                        edges[dad, j] = 1 - edges[dad, j]\n                j = dad\n        if indegree[1] == 1:\n            print(-1)\n            continue\n        ans = ''\n        for (key, value) in edges.items():\n            ans = ans + ' ' + str(value)\n        print(ans.strip())", "import sys\n\ndef fprint(x):\n    print(x, flush=True)\n\ndef qprint(x):\n    sys.stdout.write(str(x) + '\\n')\n\ndef input():\n    return sys.stdin.readline()\nimport itertools\nt = int(input())\n\nclass vertex:\n\n    def __init__(self, id):\n        self.num = id\n        self.connections = []\n        self.treeConnections = []\n        self.inDeg = 0\n        self.included = False\nfor _ in range(t):\n    (N, M) = map(int, input().split())\n    if M % 2:\n        for x in range(M):\n            (n, m) = map(int, input().split())\n        print('-1')\n    else:\n        edges = []\n        for x in range(M):\n            edges.append([0, 0])\n        vertices = []\n        for i in range(0, N + 1):\n            vertices.append(vertex(i))\n        for x in range(M):\n            (edges[x][0], edges[x][1]) = map(int, input().split())\n            vertices[edges[x][0]].connections.append([edges[x][1], x])\n            vertices[edges[x][1]].connections.append([edges[x][0], x])\n        answer = list(itertools.repeat(-1, M))\n        inST = list(itertools.repeat(0, M))\n        queue = [1]\n        vertices[1].included = True\n        stack = [1]\n        while len(queue) != 0:\n            cur_ver = queue.pop()\n            for conn in vertices[cur_ver].connections:\n                if not vertices[conn[0]].included:\n                    vertices[cur_ver].treeConnections.append(conn)\n                    queue.append(conn[0])\n                    stack.append(conn[0])\n                    vertices[conn[0]].included = True\n                    inST[conn[1]] = 1\n        for (index, edge) in enumerate(edges):\n            if not inST[index]:\n                answer[index] = 1\n                vertices[edge[0]].inDeg += 1\n        for ind in range(len(stack) - 1, -1, -1):\n            cur_ver = stack[ind]\n            for conn in vertices[cur_ver].treeConnections:\n                (index, edge) = (conn[1], edges[conn[1]])\n                if vertices[conn[0]].inDeg % 2:\n                    vertices[conn[0]].inDeg += 1\n                    if cur_ver == edge[0]:\n                        answer[index] = 0\n                    else:\n                        answer[index] = 1\n                else:\n                    vertices[cur_ver].inDeg += 1\n                    if cur_ver == edge[0]:\n                        answer[index] = 1\n                    else:\n                        answer[index] = 0\n        print(' '.join(map(str, answer)))", "class Graph:\n\n    def __init__(obj, ver):\n        obj.V = ver\n        obj.graph = []\n\n    def addEdge(obj, u, v, w):\n        obj.graph.append([u, v, w])\n\n    def find(obj, par, i):\n        if par[i] == i:\n            return i\n        return obj.find(par, par[i])\n\n    def union(obj, par, rnk, x, y):\n        xr = obj.find(par, x)\n        yr = obj.find(par, y)\n        if rnk[xr] < rnk[yr]:\n            par[xr] = yr\n        elif rnk[xr] > rnk[yr]:\n            par[yr] = xr\n        else:\n            par[yr] = xr\n            rnk[xr] += 1\n\n    def KruskalMST(obj):\n        i = 0\n        e = 0\n        obj.graph = sorted(obj.graph, key=lambda item: item[2])\n        par = []\n        rnk = []\n        for node in range(obj.V):\n            par.append(node)\n            rnk.append(0)\n        while e < obj.V - 1:\n            (u, v, w) = obj.graph[i]\n            i = i + 1\n            x = obj.find(par, u)\n            y = obj.find(par, v)\n            if x != y:\n                e = e + 1\n                result[u + 1, v + 1] = w\n                obj.union(par, rnk, x, y)\nfor i in range(int(input())):\n    tmp = input().split()\n    N = int(tmp[0])\n    M = int(tmp[1])\n    g = Graph(N)\n    k = 0\n    result = {}\n    test = {}\n    ans = []\n    cnt = {}\n    pos = {}\n    idegree = {}\n    for j in range(M):\n        ans.append(-1)\n        tmp = input().split()\n        pos[int(tmp[0]), int(tmp[1])] = k\n        g.addEdge(int(tmp[0]) - 1, int(tmp[1]) - 1, k)\n        k += 1\n    if M % 2:\n        print('-1')\n    else:\n        g.KruskalMST()\n        for j in range(N):\n            test[j + 1] = []\n            cnt[j + 1] = 0\n            idegree[j + 1] = 0\n        hash = {}\n        for j in pos:\n            try:\n                x = result[j]\n            except:\n                idegree[j[1]] += 1\n                ans[pos[j]] = 0\n        for j in result:\n            test[j[0]].append(j[1])\n            test[j[1]].append(j[0])\n            cnt[j[0]] += 1\n            cnt[j[1]] += 1\n            hash[j[0]] = 1\n            hash[j[1]] = 1\n        queue = []\n        for j in cnt:\n            if cnt[j] == 1:\n                queue.append(j)\n                hash[j] = 0\n        c = len(result)\n        while c > 0:\n            f = 1\n            x = queue.pop(0)\n            for j in test[x]:\n                if hash[j]:\n                    y = j\n                    break\n            cnt[y] -= 1\n            if cnt[y] == 1:\n                queue.append(y)\n                hash[y] = 0\n            if idegree[x] % 2 == 0:\n                idegree[y] += 1\n                try:\n                    ans[pos[x, y]] = 0\n                except:\n                    ans[pos[y, x]] = 1\n            else:\n                try:\n                    ans[pos[x, y]] = 1\n                except:\n                    ans[pos[y, x]] = 0\n            c -= 1\n            ll = y\n        if idegree[ll] % 2:\n            f = 0\n        else:\n            f = 1\n        if f:\n            for j in ans:\n                print(j, end=' ')\n            print()\n        else:\n            print('-1')", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [[] for i in range(n)]\n    l = []\n    di = {}\n    inc = [0] * n\n    etc = [[] for i in range(500000)]\n    k = [0] * m\n    for i in range(m):\n        (c, d) = map(int, input().split())\n        graph[c - 1].append(d - 1)\n        graph[d - 1].append(c - 1)\n        inc[d - 1] += 1\n        l.append([c - 1, d - 1])\n        di[str(c - 1) + '-+-' + str(d - 1)] = i\n        di[str(d - 1) + '-+-' + str(c - 1)] = i\n    flag = 1\n    if m % 2:\n        flag = 0\n    for i in range(m):\n        (c, d) = (l[i][0], l[i][1])\n        if inc[c] % 2 == 1 and inc[d] % 2 == 1:\n            inc[c] += 1\n            inc[d] -= 1\n            k[i] = 1\n    stack = []\n    for i in range(0, n):\n        if inc[i] % 2 == 1:\n            stack.append(i)\n    while stack and flag:\n        s = set()\n        for i in stack:\n            if inc[i] % 2:\n                j = graph[i][0]\n                x = di[str(i) + '-+-' + str(j)]\n                if k[x]:\n                    inc[j] += 1\n                    inc[i] -= 1\n                else:\n                    inc[i] += 1\n                    inc[j] -= 1\n                s.add(j)\n                k[x] = abs(k[x] - 1)\n        stack = s\n    if flag:\n        print(*k)\n    else:\n        print(-1)", "for _ in range(int(input())):\n    l = []\n    mp = {}\n    cr = {}\n    ans = []\n    (n, m) = map(int, input().split())\n    for i in range(1, n + 1):\n        mp[i] = 0\n        cr[i] = False\n    for _ in range(m):\n        (f, t) = map(int, input().split())\n        l.append((f, t, -1000))\n        mp[f] += 1\n        mp[t] += 1\n    if m % 2 > 0:\n        print(-1)\n        continue\n    else:\n        for _ in range(m):\n            cr[l[_][1]] = not cr[l[_][1]]\n            ans.append(0)\n        for _ in range(m - 1, -1, -1):\n            if cr[l[_][1]] == True:\n                cr[l[_][1]] = not True\n                ans[_] = 1\n                if cr[l[_][0]]:\n                    cr[l[_][0]] = False\n                else:\n                    cr[l[_][0]] = True\n        for i in range(len(ans)):\n            print(ans[i], end=' ')\n        print()", "class Nodes:\n\n    def __init__(self, k, p, q):\n        self.value = k\n        self.next = None\n        self.reverse = p\n        self.edgenumber = q\n\nclass GraphNodes:\n\n    def __init__(self, k):\n        self.value = k\n        self.next = None\n        self.visited = 0\n\nclass AdjascencyList:\n\n    def __init__(self, n):\n        self.adj_lst = [None] * n\n        for i in range(n):\n            self.adj_lst[i] = GraphNodes(i)\n\n    def insert(self, x, y, p, q):\n        temp = Nodes(y, p, q)\n        a = self.adj_lst[x]\n        temp.next = a.next\n        a.next = temp\n\ndef solve(G, Q, n, m):\n    ans = [0 for i in range(m)]\n    for i in range(n - 1, 0, -1):\n        v = i\n        if Q[v] == 0:\n            a = G.adj_lst[v]\n            while a.next != None:\n                if G.adj_lst[a.next.value].visited == 0:\n                    ans[a.next.edgenumber] = a.next.reverse\n                    Q[a.next.value] = Q[a.next.value] ^ 1\n                a = a.next\n        else:\n            a = G.adj_lst[v]\n            counts = 0\n            while a.next != None and counts == 0:\n                if G.adj_lst[a.next.value].visited == 0:\n                    ans[a.next.edgenumber] = a.next.reverse ^ 1\n                    counts = 1\n                a = a.next\n            while a.next != None:\n                if G.adj_lst[a.next.value].visited == 0:\n                    ans[a.next.edgenumber] = a.next.reverse\n                    Q[a.next.value] = Q[a.next.value] ^ 1\n                a = a.next\n        G.adj_lst[v].visited = 1\n    return ans\n\ndef main():\n    t = int(input())\n    for p in range(t):\n        (n, m) = input().split()\n        (n, m) = (int(n), int(m))\n        if m % 2 == 1:\n            for i in range(m):\n                (a, b) = input().split()\n            print(-1)\n        else:\n            G = AdjascencyList(n)\n            Q = [0 for i in range(n)]\n            for i in range(m):\n                (a, b) = input().split()\n                (a, b) = (int(a) - 1, int(b) - 1)\n                G.insert(a, b, 0, i)\n                G.insert(b, a, 1, i)\n            final = solve(G, Q, n, m)\n            str1 = ' '.join((str(e) for e in final))\n            print(str1)\nmain()", "import resource, sys\nresource.setrlimit(resource.RLIMIT_STACK, (2 ** 29, -1))\nsys.setrecursionlimit(10 ** 6)\nlines = sys.stdin.readlines()\nvisited = []\ncnt = []\nedges = []\nu = []\nv = []\nres = []\n\ndef dfs(i):\n    visited[i] = True\n    numodd = 0\n    for j in range(len(edges[i])):\n        ni = edges[i][j][0]\n        if not visited[ni]:\n            temp = dfs(ni)\n            if temp % 2 == 1:\n                numodd += 1\n                res[edges[i][j][1]] = 1\n    return numodd % 2 + cnt[i] % 2\nln = 0\nt = int(lines[ln])\nln += 1\nfor _ in range(t):\n    (n, m) = [int(x) for x in lines[ln].split()]\n    ln += 1\n    visited = [False for i in range(n)]\n    cnt = [0 for i in range(n)]\n    edges = [[] for i in range(n)]\n    u = [0 for i in range(m)]\n    v = [0 for i in range(m)]\n    res = [0 for i in range(m)]\n    for i in range(m):\n        (u[i], v[i]) = [int(x) for x in lines[ln].split()]\n        ln += 1\n        u[i] -= 1\n        v[i] -= 1\n        cnt[v[i]] += 1\n        edges[u[i]].append((v[i], i))\n        edges[v[i]].append((u[i], i))\n    if m % 2 == 1:\n        print(-1)\n        continue\n    dfs(n // 2)\n    print(*res)", "from collections import deque\nfrom heapq import *\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [set() for i in range(n)]\n    newgraph = [set() for i in range(n)]\n    edges = []\n    for i in range(m):\n        (ui, vi) = map(int, input().split())\n        edges.append((ui - 1, vi - 1))\n        graph[ui - 1].add(vi - 1)\n        graph[vi - 1].add(ui - 1)\n    if m & 1:\n        print(-1)\n        continue\n    nodes = [(len(graph[i]), -i) for i in range(n)]\n    indegs = [0] * n\n    heapify(nodes)\n    while nodes:\n        (l, node) = heappop(nodes)\n        node = -1 * node\n        clist = list(graph[node])\n        graph[node] = set()\n        for cnode in clist:\n            if indegs[node] & 1:\n                newgraph[cnode].add(node)\n                indegs[node] += 1\n            else:\n                newgraph[node].add(cnode)\n                indegs[cnode] += 1\n            graph[cnode].remove(node)\n            heappush(nodes, (len(graph[cnode]), -cnode))\n    ans = []\n    for (ui, vi) in edges:\n        if ui in newgraph[vi]:\n            ans.append(1)\n        else:\n            ans.append(0)\n    print(*ans)", "from sys import stdin, stdout\nfrom collections import defaultdict as dd\ninp = lambda : (int(o) for o in stdin.readline().split())\nfor _ in range(*inp()):\n    (n, m) = inp()\n    graph = dd(list)\n    l = []\n    di = {}\n    inc = [0] * (n + 1)\n    k = [0] * m\n    for i in range(m):\n        (c, d) = inp()\n        graph[c].append(d)\n        graph[d].append(c)\n        inc[d] += 1\n        l.append([c, d])\n        di[str(c) + '_' + str(d)] = i\n        di[str(d) + '_' + str(c)] = i\n    if m % 2:\n        print(-1)\n        continue\n    for i in range(m):\n        (c, d) = (l[i][0], l[i][1])\n        if inc[c] % 2 and inc[d] % 2:\n            inc[c] += 1\n            inc[d] -= 1\n            k[i] = 1\n    stack = []\n    for i in range(1, n + 1):\n        if inc[i] % 2:\n            stack.append(i)\n    while stack:\n        s = set()\n        for i in stack:\n            if inc[i] % 2:\n                for j in graph[i]:\n                    x = di[str(i) + '_' + str(j)]\n                    if k[x]:\n                        inc[j] += 1\n                        inc[i] -= 1\n                    else:\n                        inc[i] += 1\n                        inc[j] -= 1\n                    s.add(j)\n                    k[x] = abs(k[x] - 1)\n                    break\n        stack = s\n    print(*k)", "def make_it_even(p):\n    if indegree[p] % 2 == 0:\n        if p in parent:\n            indegree[parent[p]] += 1\n            graph[parent[p]].remove(p)\n    elif p in parent:\n        indegree[p] += 1\n        graph[p].remove(parent[p])\n\ndef recurse(p):\n    if len(child[p]) == 0:\n        make_it_even(p)\n        return\n    for c in child[p]:\n        recurse(c)\n    make_it_even(p)\nfrom collections import deque\n\ndef solve():\n    vis = [False for i in range(n + 1)]\n    q = deque()\n    root = 1\n    q.append(root)\n    vis[root] = True\n    while len(q) != 0:\n        u = q.popleft()\n        child[u] = set()\n        for v in graph[u]:\n            if not vis[v]:\n                child[u].add(v)\n                parent[v] = u\n                vis[v] = True\n                q.append(v)\n    for k in range(1, n + 1):\n        par = set()\n        if k in parent:\n            par.add(parent[k])\n        remain = graph[k] - child[k] - par\n        for each in remain:\n            indegree[each] += 1\n            graph[each].remove(k)\n    recurse(root)\n    if indegree[root] % 2 != 0:\n        print(-1)\n        return False\n    return True\nparent = dict()\nchild = dict()\nn = m = 0\nindegree = None\ngraph = None\nfor i in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    graph = [set() for i in range(n + 1)]\n    order = []\n    indegree = [0 for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = list(map(int, input().split()))\n        order.append((u, v))\n        graph[u].add(v)\n        graph[v].add(u)\n    if solve():\n        for i in order:\n            if i[1] in graph[i[0]]:\n                print(0, end=' ')\n            else:\n                print(1, end=' ')\n        print()", "def make_it_even(p):\n    if indegree[p] % 2 == 0:\n        if p in parent:\n            indegree[parent[p]] += 1\n            graph[parent[p]].remove(p)\n    elif p in parent:\n        indegree[p] += 1\n        graph[p].remove(parent[p])\n\ndef recurse(p):\n    if len(child[p]) == 0:\n        make_it_even(p)\n        return\n    for c in child[p]:\n        recurse(c)\n    make_it_even(p)\nfrom collections import deque\n\ndef solve():\n    vis = [False for i in range(n + 1)]\n    q = deque()\n    root = 1\n    q.append(root)\n    vis[root] = True\n    while len(q) != 0:\n        u = q.popleft()\n        child[u] = set()\n        for v in graph[u]:\n            if not vis[v]:\n                child[u].add(v)\n                parent[v] = u\n                vis[v] = True\n                q.append(v)\n    for k in range(1, n + 1):\n        par = set()\n        if k in parent:\n            par.add(parent[k])\n        remain = graph[k] - child[k] - par\n        for each in remain:\n            indegree[each] += 1\n            graph[each].remove(k)\n    recurse(root)\n    if indegree[root] % 2 != 0:\n        print(-1)\n        return False\n    return True\nparent = dict()\nchild = dict()\nn = m = 0\nindegree = None\ngraph = None\nfor i in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    graph = [set() for i in range(n + 1)]\n    order = []\n    indegree = [0 for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = list(map(int, input().split()))\n        order.append((u, v))\n        graph[u].add(v)\n        graph[v].add(u)\n    if solve():\n        for i in order:\n            if i[1] in graph[i[0]]:\n                print(0, end=' ')\n            else:\n                print(1, end=' ')\n        print()", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [[] for i in range(n + 1)]\n    b = [0] * (n + 1)\n    k = [0] * m\n    l = []\n    di = {}\n    for i in range(m):\n        (c, d) = map(int, input().split())\n        a[c].append(d)\n        a[d].append(c)\n        b[d] += 1\n        l.append([c, d])\n        di[str(c) + ' ' + str(d)] = i\n        di[str(d) + ' ' + str(c)] = i\n    if m % 2 == 1:\n        print(-1)\n        continue\n    for i in range(m):\n        (c, d) = (l[i][0], l[i][1])\n        if b[c] % 2 == 1 and b[d] % 2 == 1:\n            k[i] = 1\n            b[c] += 1\n            b[d] -= 1\n    st = []\n    for i in range(1, n + 1):\n        if b[i] % 2 == 1:\n            st.append(i)\n    while st:\n        l = set()\n        for i in st:\n            if b[i] % 2 == 1:\n                for j in a[i]:\n                    x = di[str(i) + ' ' + str(j)]\n                    if k[x] == 0:\n                        b[i] += 1\n                        b[j] -= 1\n                    else:\n                        b[i] -= 1\n                        b[j] += 1\n                    l.add(j)\n                    k[x] = int(not k[x])\n                    break\n        st = l\n    print(*k)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(1000000)\nglobal edgesdone\n\ndef f():\n    sys.stdout.flush()\n\ndef solve(key, nodes, track, result):\n    node = nodes[key]\n    track[key] = 1\n    tmpindg = 0\n    global edgesdone\n    for sub in node:\n        (k, s) = (int(key), int(sub))\n        if track.get(sub, 0) == 0:\n            edgesdone += 1\n            indg = solve(sub, nodes, track, result)\n            if indg == 0:\n                result[k][s] = '1'\n                result[s][k] = '0'\n                tmpindg ^= 1\n            else:\n                result[k][s] = '0'\n                result[s][k] = '1'\n        elif track[sub] == 2:\n            result[k][s] = '1'\n            result[s][k] = '0'\n            tmpindg ^= 1\n            edgesdone += 1\n        else:\n            nodes[sub].append(key)\n    track[key] = 2\n    return tmpindg\ntests = int(input())\nresult = defaultdict(lambda : defaultdict(int))\nfor t in range(tests):\n    edgesdone = 0\n    (n, m) = map(int, input().split())\n    if m % 2 == 1:\n        for i in range(m):\n            tmp = input()\n        print(-1)\n    else:\n        nodes = {}\n        track = {}\n        order = []\n        for i in range(0, m):\n            (v1, v2) = sys.stdin.readline().split()\n            if i == 0:\n                startkey = v1\n            n1 = nodes.get(v1)\n            n2 = nodes.get(v2)\n            if n1 is None:\n                if n2 is None:\n                    nodes[v1] = [v2]\n                    nodes[v2] = []\n                else:\n                    n2.append(v1)\n                    nodes[v2] = n2\n                    nodes[v1] = []\n            else:\n                n1.append(v2)\n                nodes[v1] = n1\n                if n2 is None:\n                    nodes[v2] = []\n            order.append((int(v1), int(v2)))\n        tmp = solve(startkey, nodes, track, result)\n        res = []\n        for query in order:\n            res.append(result[query[0]][query[1]])\n        print(' '.join(res))\n    f()", "t = int(input())\n\ndef bfsorder(vertex, s, n):\n    vl = []\n    visited = {}\n    queue = []\n    queue.append(s)\n    visited[s] = True\n    while queue:\n        s = queue.pop(0)\n        vl.append(s)\n        for i in vertex[s].edges:\n            try:\n                a = visited[i]\n            except:\n                queue.append(i)\n                visited[i] = True\n    return vl\n\ndef maxin(vertex, n):\n    m = -1\n    index = -1\n    for i in range(n):\n        if vertex[i].degree > m:\n            m = vertex[i].degree\n            index = i\n    return index\n\ndef minlist(vertex, n):\n    v = []\n    m = 200000\n    for i in range(n):\n        if vertex[i].remedges < m:\n            v = [i]\n            m = vertex[i].remedges\n        elif vertex[i].remedges == m:\n            v.append(i)\n    return v\n\nclass Vertex:\n\n    def __init__(self):\n        self.degree = 0\n        self.confirmeddeg = 0\n        self.out = {}\n        self.edges = []\n        self.remedges = 0\nfor _ in range(t):\n    edgelist = []\n    (n, m) = map(int, input().split())\n    vertex = []\n    vertex1 = []\n    if m % 2 == 1:\n        for i in range(m):\n            (u, v) = map(int, input().split())\n        print(-1)\n        continue\n    for _ in range(n):\n        vertex.append(Vertex())\n        vertex1.append(Vertex())\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        edgelist.append([u, v])\n        vertex[u].degree += 1\n        vertex[u].remedges += 1\n        vertex[u].edges.append(v)\n        vertex[v].degree += 1\n        vertex[v].remedges += 1\n        vertex[v].edges.append(u)\n        vertex1[u].degree += 1\n        vertex1[u].remedges += 1\n        vertex1[u].edges.append(v)\n        vertex1[v].degree += 1\n        vertex1[v].remedges += 1\n        vertex1[v].edges.append(u)\n    vl = minlist(vertex, n)\n    c = 0\n    while c < n:\n        for v in vl:\n            flag = 0\n            if vertex[v].remedges % 2 != vertex[v].confirmeddeg % 2:\n                try:\n                    i = vertex[v].edges[0]\n                except:\n                    flag = 1\n                    break\n                vertex[v].out[i] = 1\n                vertex[i].out[v] = 0\n                vertex[i].edges.remove(v)\n                vertex[i].remedges -= 1\n                vertex[i].confirmeddeg += 1\n                vertex[v].edges.remove(i)\n            for i in vertex[v].edges:\n                vertex[v].out[i] = 0\n                vertex[i].out[v] = 1\n                vertex[i].remedges -= 1\n                vertex[i].edges.remove(v)\n            vertex[v].remedges = 200000\n            c += 1\n        if flag == 1:\n            break\n        vl = minlist(vertex, n)\n    if c == n:\n        for i in edgelist:\n            if vertex[i[0]].out[i[1]] == 1:\n                print(0, end=' ')\n            else:\n                print(1, end=' ')\n        print()\n    else:\n        vertex = vertex1\n        v = maxin(vertex, n)\n        vl = bfsorder(vertex, v, n)\n        for k in range(n):\n            v = vl[n - k - 1]\n            if vertex[v].remedges % 2 != vertex[v].confirmeddeg % 2:\n                i = vertex[v].edges[0]\n                vertex[v].out[i] = 1\n                vertex[i].out[v] = 0\n                vertex[i].edges.remove(v)\n                vertex[i].remedges -= 1\n                vertex[i].confirmeddeg += 1\n                del vertex[v].edges[0]\n            for i in vertex[v].edges:\n                vertex[v].out[i] = 0\n                vertex[i].out[v] = 1\n                vertex[i].remedges -= 1\n                vertex[i].edges.remove(v)\n        if True:\n            for i in edgelist:\n                if vertex[i[0]].out[i[1]] == 1:\n                    print(0, end=' ')\n                else:\n                    print(1, end=' ')\n            print()\n        else:\n            print(-1)", "t = int(input())\n\ndef bfsorder(vertex, s, n):\n    vl = []\n    visited = {}\n    queue = []\n    queue.append(s)\n    visited[s] = True\n    while queue:\n        s = queue.pop(0)\n        vl.append(s)\n        for i in vertex[s].edges:\n            try:\n                a = visited[i]\n            except:\n                queue.append(i)\n                visited[i] = True\n    return vl\n\ndef maxin(vertex, n):\n    m = -1\n    index = -1\n    for i in range(n):\n        if vertex[i].degree > m:\n            m = vertex[i].degree\n            index = i\n    return index\n\ndef minlist(vertex, n):\n    v = []\n    m = 200000\n    for i in range(n):\n        if vertex[i].remedges < m:\n            v = [i]\n            m = vertex[i].remedges\n        elif vertex[i].remedges == m:\n            v.append(i)\n    return v\n\nclass Vertex:\n\n    def __init__(self):\n        self.degree = 0\n        self.confirmeddeg = 0\n        self.out = {}\n        self.edges = []\n        self.remedges = 0\nfor _ in range(t):\n    edgelist = []\n    (n, m) = map(int, input().split())\n    vertex = []\n    vertex1 = []\n    if m % 2 == 1:\n        for i in range(m):\n            (u, v) = map(int, input().split())\n        print(-1)\n        continue\n    for _ in range(n):\n        vertex.append(Vertex())\n        vertex1.append(Vertex())\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        edgelist.append([u, v])\n        vertex[u].degree += 1\n        vertex[u].remedges += 1\n        vertex[u].edges.append(v)\n        vertex[v].degree += 1\n        vertex[v].remedges += 1\n        vertex[v].edges.append(u)\n        vertex1[u].degree += 1\n        vertex1[u].remedges += 1\n        vertex1[u].edges.append(v)\n        vertex1[v].degree += 1\n        vertex1[v].remedges += 1\n        vertex1[v].edges.append(u)\n    vl = minlist(vertex, n)\n    c = 0\n    while c < n:\n        for v in vl:\n            flag = 0\n            if vertex[v].remedges % 2 != vertex[v].confirmeddeg % 2:\n                try:\n                    i = vertex[v].edges[0]\n                except:\n                    flag = 1\n                    break\n                vertex[v].out[i] = 1\n                vertex[i].out[v] = 0\n                vertex[i].edges.remove(v)\n                vertex[i].remedges -= 1\n                vertex[i].confirmeddeg += 1\n                vertex[v].edges.remove(i)\n            for i in vertex[v].edges:\n                vertex[v].out[i] = 0\n                vertex[i].out[v] = 1\n                vertex[i].remedges -= 1\n                vertex[i].edges.remove(v)\n            vertex[v].remedges = 200000\n            c += 1\n        if flag == 1:\n            break\n        vl = minlist(vertex, n)\n    if c == n:\n        for i in edgelist:\n            if vertex[i[0]].out[i[1]] == 1:\n                print(0, end=' ')\n            else:\n                print(1, end=' ')\n        print()\n    else:\n        vertex = vertex1\n        v = maxin(vertex, n)\n        vl = bfsorder(vertex, v, n)\n        for k in range(n):\n            v = vl[n - k - 1]\n            if vertex[v].remedges % 2 != vertex[v].confirmeddeg % 2:\n                i = vertex[v].edges[0]\n                vertex[v].out[i] = 1\n                vertex[i].out[v] = 0\n                vertex[i].edges.remove(v)\n                vertex[i].remedges -= 1\n                vertex[i].confirmeddeg += 1\n                del vertex[v].edges[0]\n            for i in vertex[v].edges:\n                vertex[v].out[i] = 0\n                vertex[i].out[v] = 1\n                vertex[i].remedges -= 1\n                vertex[i].edges.remove(v)\n        if True:\n            for i in edgelist:\n                if vertex[i[0]].out[i[1]] == 1:\n                    print(0, end=' ')\n                else:\n                    print(1, end=' ')\n            print()\n        else:\n            print(-1)", "def find_edge_directions():\n    if M % 2:\n        return '-1'\n    undirDict = {i: [] for i in range(N + 1)}\n    degCtr = [0 for i in range(N + 1)]\n    indegCtr = [0 for i in range(N + 1)]\n    lenList = [[] for i in range(N + 1)]\n    result = [None for i in range(M)]\n    for i in range(M):\n        undirDict[uvList[i][0]].append(uvList[i])\n        undirDict[uvList[i][1]].append(uvList[i])\n        degCtr[uvList[i][0]] += 1\n        degCtr[uvList[i][1]] += 1\n    for i in range(1, N + 1):\n        lenList[len(undirDict[i])].append(i)\n    (i, ctr) = (1, 0)\n    while ctr < M:\n        while i < 1 or lenList[i] == []:\n            i += 1\n        vert = lenList[i][0]\n        if undirDict[vert] == []:\n            del lenList[i][0]\n            continue\n        (u, v, idx) = undirDict[vert][0]\n        if result[idx] != None:\n            del undirDict[vert][0]\n            continue\n        elif u == vert and indegCtr[vert] % 2 or (v == vert and indegCtr[vert] % 2 == 0):\n            result[idx] = '1'\n            indegCtr[u] += 1\n        else:\n            result[idx] = '0'\n            indegCtr[v] += 1\n        del undirDict[vert][0]\n        del lenList[i][0]\n        lenList[i - 1].append(vert)\n        if vert == v:\n            lenList[degCtr[u] - 1].append(u)\n        else:\n            lenList[degCtr[v] - 1].append(v)\n        (degCtr[u], degCtr[v]) = (degCtr[u] - 1, degCtr[v] - 1)\n        i = i - 1\n        ctr += 1\n    return ' '.join(result)\nT = int(input())\nopList = []\nfor x in range(T):\n    (N, M) = map(int, input().split())\n    uvList = [list(map(int, input().split())) + [_] for _ in range(M)]\n    opList.append(find_edge_directions())\nprint('\\n'.join(opList))", "class Node:\n\n    def __init__(self, ID):\n        self.indegree = 0\n        self.outdegree = 0\n        self.nbrs = dict()\n        self.STchildren = 0\n        self.toroot = None\n        self.ID = ID\n        self.tag = ''\n\n    def __repr__(self):\n        return str(self.ID) + '->' + repr(self.nbrs)\n\ndef readEdgeFor(g, e):\n    (u, v) = map(int, input().split())\n    g[u].outdegree += 1\n    g[u].nbrs[v] = len(e)\n    g[v].indegree += 1\n    g[v].nbrs[u] = len(e)\n    e.append((u, v))\nfor ti in range(int(input())):\n    (n, m) = map(int, input().split())\n    if 1 == m % 2:\n        for _ in range(m):\n            input()\n        print(-1)\n        continue\n    tree = [Node(i) for i in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        readEdgeFor(tree, edges)\n    root = tree[1]\n    newnodes = [root]\n    leaves = []\n    while newnodes:\n        wknodes = newnodes\n        newnodes = []\n        for a in wknodes:\n            for nb in a.nbrs.keys():\n                nn = tree[nb]\n                if nn.tag == 'v':\n                    continue\n                nn.tag = 'v'\n                if nn.STchildren == 0:\n                    a.STchildren += 1\n                    nn.toroot = a\n                    newnodes.append(nn)\n            if a.STchildren == 0:\n                leaves.append(a)\n    root.STchildren += 1\n    dir = [0] * m\n    for a in leaves:\n        w = a\n        while w.STchildren == 0:\n            p = w.toroot\n            if w.indegree % 2 == 1:\n                dir[w.nbrs[p.ID]] = 1\n                p.indegree += 1\n            p.STchildren -= 1\n            w = p\n    print(*dir)", "t = int(input())\nfor z in range(t):\n    (n, m) = map(int, input().split())\n    edges = [[0] * 2 for i in range(m)]\n    degrees = [0] * (n + 1)\n    dgcp = [0] * (n + 1)\n    ans = [0] * m\n    less = [-1] * (n + 1)\n    great = [-1] * (n + 1)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        edges[i] = [u, v]\n        if u > v:\n            if great[v] == -1:\n                great[v] = i\n            if less[u] == -1:\n                less[u] = i\n        else:\n            if great[u] == -1:\n                great[u] = i\n            if less[v] == -1:\n                less[v] = i\n        degrees[v] += 1\n        dgcp[v] += 1\n    flag = 1\n    for i in range(1, n):\n        if degrees[i] % 2 != 0:\n            j = great[i]\n            if j > -1:\n                if edges[j][1] == i and edges[j][0] > i:\n                    degrees[i] -= 1\n                    degrees[edges[j][0]] += 1\n                    ans[j] = 1\n                elif edges[j][1] > i and edges[j][0] == i:\n                    degrees[i] += 1\n                    degrees[edges[j][1]] -= 1\n                    ans[j] = 1\n        if degrees[i] % 2 != 0:\n            flag = 0\n    if degrees[n] % 2 == 0 and flag == 1:\n        str1 = ' '.join((str(e) for e in ans))\n        print(str1)\n    else:\n        ans = [0] * m\n        flag = 1\n        for i in range(n, 1, -1):\n            if dgcp[i] % 2 != 0:\n                j = less[i]\n                if j > -1:\n                    if edges[j][1] == i and edges[j][0] < i:\n                        dgcp[i] -= 1\n                        dgcp[edges[j][0]] += 1\n                        ans[j] = 1\n                    elif edges[j][1] < i and edges[j][0] == i:\n                        dgcp[i] += 1\n                        dgcp[edges[j][1]] -= 1\n                        ans[j] = 1\n            if dgcp[i] % 2 != 0:\n                flag = 0\n        if dgcp[1] % 2 == 0 and flag == 1:\n            str1 = ' '.join((str(e) for e in ans))\n            print(str1)\n        else:\n            print(-1)"]