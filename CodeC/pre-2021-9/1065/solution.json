["T = int(input())\nfor i in range(T):\n    l = []\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for j in range(n):\n        l.append([])\n    for k in range(m):\n        (x, y) = map(int, input().split())\n        l[x - 1].append(y - 1)\n        l[y - 1].append(x - 1)\n    r = [a[i] / b[i] for i in range(n)]\n    m = max(r)\n    final = []\n    visited = [0] * n\n    for i in range(n):\n        if r[i] == m:\n            if visited[i] == 0:\n                visited[i] = 1\n                temp = [i + 1]\n                q = [i]\n                while len(q):\n                    t = q.pop(0)\n                    for j in l[t]:\n                        if r[j] == m and visited[j] == 0:\n                            visited[j] = 1\n                            temp.append(j + 1)\n                            q.append(j)\n                if len(temp) > len(final):\n                    final = temp.copy()\n    print(len(final))\n    for i in final:\n        print(i, end=' ')", "T = int(input())\nfor i in range(T):\n    l = []\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for j in range(n):\n        l.append([])\n    for k in range(m):\n        (x, y) = map(int, input().split())\n        l[x - 1].append(y - 1)\n        l[y - 1].append(x - 1)\n    r = [a[i] / b[i] for i in range(n)]\n    m = max(r)\n    final = []\n    visited = [0] * n\n    for i in range(n):\n        if r[i] == m:\n            if visited[i] == 0:\n                visited[i] = 1\n                temp = [i + 1]\n                q = [i]\n                while len(q):\n                    t = q.pop(0)\n                    for j in l[t]:\n                        if r[j] == m and visited[j] == 0:\n                            visited[j] = 1\n                            temp.append(j + 1)\n                            q.append(j)\n                if len(temp) > len(final):\n                    final = temp.copy()\n    print(len(final))\n    for i in final:\n        print(i, end=' ')", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p):\n    v[p] = True\n    x.append(p)\n    for i in child[p]:\n        if mx == a[i - 1] / b[i - 1] and (not v[i]):\n            dfs(i)\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    mx = 0\n    for i in range(n):\n        mx = max(mx, a[i] / b[i])\n    child = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    (pro, x) = ([], [])\n    v = [False] * (n + 1)\n    for i in range(n):\n        if mx == a[i] / b[i] and (not v[i + 1]):\n            dfs(i + 1)\n            if len(x) > len(pro):\n                pro = x[:]\n            x = []\n    print(len(pro))\n    print(*pro)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p):\n    v[p] = True\n    x.append(p)\n    for i in child[p]:\n        if mx == a[i - 1] / b[i - 1] and (not v[i]):\n            dfs(i)\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    mx = 0\n    for i in range(n):\n        mx = max(mx, a[i] / b[i])\n    child = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    (pro, x) = ([], [])\n    v = [False] * (n + 1)\n    for i in range(n):\n        if mx == a[i] / b[i] and (not v[i + 1]):\n            dfs(i + 1)\n            if len(x) > len(pro):\n                pro = x[:]\n            x = []\n    print(len(pro))\n    print(*pro)", "test = int(input())\nfor _ in range(test):\n    l = []\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for _ in range(n):\n        l.append([])\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        l[x - 1].append(y - 1)\n        l[y - 1].append(x - 1)\n    r = [a[i] / b[i] for i in range(n)]\n    m = max(r)\n    final = []\n    visited = [0] * n\n    for i in range(n):\n        if r[i] == m:\n            if visited[i] == 0:\n                visited[i] = 1\n                temp = [i + 1]\n                q = [i]\n                while len(q):\n                    t = q.pop(0)\n                    for j in l[t]:\n                        if r[j] == m and visited[j] == 0:\n                            visited[j] = 1\n                            temp.append(j + 1)\n                            q.append(j)\n                if len(temp) > len(final):\n                    final = temp.copy()\n    print(len(final))\n    for i in final:\n        print(i, end=' ')\n    print()", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = []\n    for j in range(n):\n        l.append([])\n    for j in range(m):\n        (x, y) = map(int, input().split())\n        l[x - 1].append(y - 1)\n        l[y - 1].append(x - 1)\n    r = [a[i] / b[i] for i in range(n)]\n    m = max(r)\n    final = []\n    vis = [0] * n\n    for i in range(n):\n        if r[i] == m:\n            if vis[i] == 0:\n                vis[i] = 1\n                q = [i]\n                temp = [i + 1]\n                while len(q):\n                    t = q.pop(0)\n                    for j in l[t]:\n                        if r[j] == m and vis[j] == 0:\n                            vis[j] = 1\n                            q.append(j)\n                            temp.append(j + 1)\n                if len(temp) > len(final):\n                    final = temp.copy()\n    print(len(final))\n    for i in final:\n        print(i, end=' ')\n    print()", "test = int(input())\nfor _ in range(test):\n    l = []\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for _ in range(n):\n        l.append([])\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        l[x - 1].append(y - 1)\n        l[y - 1].append(x - 1)\n    r = [a[i] / b[i] for i in range(n)]\n    m = max(r)\n    final = []\n    visited = [0] * n\n    for i in range(n):\n        if r[i] == m:\n            if visited[i] == 0:\n                visited[i] = 1\n                temp = [i + 1]\n                q = [i]\n                while len(q):\n                    t = q.pop(0)\n                    for j in l[t]:\n                        if r[j] == m and visited[j] == 0:\n                            visited[j] = 1\n                            temp.append(j + 1)\n                            q.append(j)\n                if len(temp) > len(final):\n                    final = temp.copy()\n    print(len(final))\n    for i in final:\n        print(i, end=' ')\n    print()", "test = int(input())\nfor _ in range(test):\n    l = []\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for _ in range(n):\n        l.append([])\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        l[x - 1].append(y - 1)\n        l[y - 1].append(x - 1)\n    r = [a[i] / b[i] for i in range(n)]\n    m = max(r)\n    final = []\n    visited = [0] * n\n    for i in range(n):\n        if r[i] == m:\n            if visited[i] == 0:\n                visited[i] = 1\n                temp = [i + 1]\n                q = [i]\n                while len(q):\n                    t = q.pop(0)\n                    for j in l[t]:\n                        if r[j] == m and visited[j] == 0:\n                            visited[j] = 1\n                            temp.append(j + 1)\n                            q.append(j)\n                if len(temp) > len(final):\n                    final = temp.copy()\n    print(len(final))\n    for i in final:\n        print(i, end=' ')\n    print()", "import sys\nsys.setrecursionlimit(int(1000000.0))\n\ndef func(ver, A, B, graph, vis, mex, pci, lst):\n    vis.add(ver)\n    lst.append(ver)\n    tot = 0\n    for neigh in graph[ver]:\n        if neigh not in vis:\n            if pci[neigh - 1] == mex:\n                tot += 1 + func(neigh, A, B, graph, vis, mex, pci, lst)\n    return tot\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    pci = [None for i in range(n)]\n    for i in range(n):\n        pci[i] = A[i] // B[i]\n    mex = -sys.maxsize\n    for i in range(n):\n        if A[i] // B[i] > mex:\n            mex = A[i] // B[i]\n            ver = i + 1\n    nls = []\n    for (i, j) in enumerate(pci):\n        if j == mex:\n            nls.append(i)\n    flis = []\n    flen = 0\n    vis = set()\n    for ver in nls:\n        if ver not in vis:\n            lst = []\n            lnlis = 1 + func(ver + 1, A, B, graph, vis, mex, pci, lst)\n            if lnlis > flen:\n                flen = lnlis\n                flis = lst[:]\n    print(flen)\n    print(*flis)", "test = int(input())\nfor _ in range(test):\n    l = []\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for _ in range(n):\n        l.append([])\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        l[x - 1].append(y - 1)\n        l[y - 1].append(x - 1)\n    r = [a[i] / b[i] for i in range(n)]\n    m = max(r)\n    final = []\n    visited = [0] * n\n    for i in range(n):\n        if r[i] == m:\n            if visited[i] == 0:\n                visited[i] = 1\n                temp = [i + 1]\n                q = [i]\n                while len(q):\n                    t = q.pop(0)\n                    for j in l[t]:\n                        if r[j] == m and visited[j] == 0:\n                            visited[j] = 1\n                            temp.append(j + 1)\n                            q.append(j)\n                if len(temp) > len(final):\n                    final = temp.copy()\n    print(len(final))\n    for i in final:\n        print(i, end=' ')\n    print()", "for _ in range(int(input())):\n    l = []\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for _ in range(n):\n        l.append([])\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        l[x - 1].append(y - 1)\n        l[y - 1].append(x - 1)\n    r = [a[i] / b[i] for i in range(n)]\n    m = max(r)\n    final = []\n    visited = [0] * n\n    for i in range(n):\n        if r[i] == m:\n            if visited[i] == 0:\n                visited[i] = 1\n                temp = [i + 1]\n                q = [i]\n                while len(q):\n                    t = q.pop(0)\n                    for j in l[t]:\n                        if r[j] == m and visited[j] == 0:\n                            visited[j] = 1\n                            temp.append(j + 1)\n                            q.append(j)\n                if len(temp) > len(final):\n                    final = temp.copy()\n    print(len(final))\n    for i in final:\n        print(i, end=' ')\n    print()", "for _ in range(int(input())):\n    l = []\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for _ in range(n):\n        l.append([])\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        l[x - 1].append(y - 1)\n        l[y - 1].append(x - 1)\n    r = [a[i] / b[i] for i in range(n)]\n    m = max(r)\n    final = []\n    visited = [0] * n\n    for i in range(n):\n        if r[i] == m:\n            if visited[i] == 0:\n                visited[i] = 1\n                temp = [i + 1]\n                q = [i]\n                while len(q):\n                    t = q.pop(0)\n                    for j in l[t]:\n                        if r[j] == m and visited[j] == 0:\n                            visited[j] = 1\n                            temp.append(j + 1)\n                            q.append(j)\n                if len(temp) > len(final):\n                    final = temp.copy()\n    print(len(final))\n    for i in final:\n        print(i, end=' ')\n    print()", "def root(component, u):\n    while component[u][0] != u:\n        u = component[u][0]\n    return u\n\ndef union(component, u, v):\n    u_root = root(component, u)\n    v_root = root(component, v)\n    if u_root != v_root:\n        if component[u_root][1] < component[v_root][1]:\n            component[u_root][0] = component[v_root][0]\n            component[v_root][1] += component[u_root][1]\n        else:\n            component[v_root][0] = component[u_root][0]\n            component[u_root][1] += component[v_root][1]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().strip().split())\n    a = list(map(int, input().strip().split()))\n    b = list(map(int, input().strip().split()))\n    maxcapita = -1\n    for i in range(n):\n        capita = a[i] / b[i]\n        if capita > maxcapita:\n            maxcapita = capita\n    component = {}\n    for i in range(n):\n        if maxcapita == a[i] / b[i]:\n            component[i] = [i, 1]\n    for i in range(m):\n        (u, v) = map(int, input().strip().split())\n        if a[u - 1] / b[u - 1] == maxcapita and a[v - 1] / b[v - 1] == maxcapita:\n            union(component, u - 1, v - 1)\n    max_city = None\n    max_component_size = 1\n    for key in component.keys():\n        if component[key][1] >= max_component_size:\n            max_city = key\n            max_component_size = component[key][1]\n    print(max_component_size)\n    ans = []\n    for key in component.keys():\n        if root(component, key) == max_city:\n            ans.append(key + 1)\n    print(*ans)", "import sys\nsys.setrecursionlimit(100000)\n\nclass Graph:\n\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for i in range(V)]\n\n    def DFSUtil(self, temp, v, visited):\n        visited[v] = True\n        temp.append(v)\n        for i in self.adj[v]:\n            if visited[i] == False:\n                temp = self.DFSUtil(temp, i, visited)\n        return temp\n\n    def addEdge(self, v, w):\n        self.adj[v].append(w)\n        self.adj[w].append(v)\n\n    def connectedComponents(self):\n        visited = []\n        cc = []\n        for i in range(self.V):\n            visited.append(False)\n        for v in range(self.V):\n            if visited[v] == False:\n                temp = []\n                cc.append(self.DFSUtil(temp, v, visited))\n        return cc\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(lambda x: int(x), input().split()))\n    a = list(map(lambda x: int(x), input().split()))\n    b = list(map(lambda x: int(x), input().split()))\n    hashmap = {}\n    total_a = sum(a)\n    total_b = sum(b)\n    total_pc = total_a / total_b\n    pc = []\n    for i in range(len(a)):\n        pc.append((a[i] / b[i], i, (total_a - a[i]) / (total_b - b[i])))\n    maximum = max(pc, key=lambda x: x[0])[0]\n    nodes_to_consider = set()\n    for i in range(0, len(pc)):\n        if pc[i][0] == maximum:\n            nodes_to_consider.add(pc[i][1])\n    nodes_vs_id = {node: i for (i, node) in enumerate(nodes_to_consider)}\n    id_vs_node = {v: k for (k, v) in nodes_vs_id.items()}\n    g = Graph(len(nodes_to_consider) + 1)\n    for _ in range(m):\n        (u, v) = list(map(lambda x: int(x), input().split()))\n        if u - 1 in nodes_to_consider and v - 1 in nodes_to_consider:\n            g.addEdge(nodes_vs_id[u - 1], nodes_vs_id[v - 1])\n    components = sorted(g.connectedComponents(), key=lambda x: len(x), reverse=True)\n    print(len(components[0]))\n    for node in components[0]:\n        print(id_vs_node[node] + 1, end=' ')\n    print()", "def root(component, u):\n    while component[u][0] != u:\n        u = component[u][0]\n    return u\n\ndef union(component, u, v):\n    u_root = root(component, u)\n    v_root = root(component, v)\n    if u_root != v_root:\n        if component[u_root][1] < component[v_root][1]:\n            component[u_root][0] = component[v_root][0]\n            component[v_root][1] += component[u_root][1]\n        else:\n            component[v_root][0] = component[u_root][0]\n            component[u_root][1] += component[v_root][1]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().strip().split())\n    a = list(map(int, input().strip().split()))\n    b = list(map(int, input().strip().split()))\n    maxcapita = -1\n    for i in range(n):\n        capita = a[i] / b[i]\n        if capita > maxcapita:\n            maxcapita = capita\n    component = {}\n    for i in range(n):\n        if maxcapita == a[i] / b[i]:\n            component[i] = [i, 1]\n    for i in range(m):\n        (u, v) = map(int, input().strip().split())\n        if a[u - 1] / b[u - 1] == maxcapita and a[v - 1] / b[v - 1] == maxcapita:\n            union(component, u - 1, v - 1)\n    max_city = None\n    max_component_size = 1\n    for key in component.keys():\n        if component[key][1] >= max_component_size:\n            max_city = key\n            max_component_size = component[key][1]\n    print(max_component_size)\n    ans = []\n    for key in component.keys():\n        if root(component, key) == max_city:\n            ans.append(key + 1)\n    print(*ans)", "import collections\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(p):\n    visited.add(p)\n    temp.add(p + 1)\n    for node in road[p]:\n        if node not in visited and selected[node]:\n            dfs(node)\n    return temp\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    income = list(map(int, input().split()))\n    population = list(map(int, input().split()))\n    road = collections.defaultdict(list)\n    for __ in range(m):\n        (a, b) = map(int, input().split())\n        road[a - 1].append(b - 1)\n        road[b - 1].append(a - 1)\n    i = income[0]\n    p = population[0]\n    for x in range(1, n):\n        if i * population[x] < p * income[x]:\n            i = income[x]\n            p = population[x]\n    selected = [False] * n\n    for x in range(n):\n        if population[x] * i == income[x] * p:\n            selected[x] = True\n    visited = set()\n    ans = set()\n    for each in range(n):\n        if each not in visited and selected[each]:\n            temp = set()\n            dfs(each)\n            if len(temp) > len(ans):\n                ans = temp\n    print(len(ans))\n    for ele in ans:\n        print(ele, end=' ')", "import collections\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(p):\n    visited.add(p)\n    temp.add(p + 1)\n    for node in road[p]:\n        if node not in visited and selected[node]:\n            dfs(node)\n    return temp\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    income = list(map(int, input().split()))\n    population = list(map(int, input().split()))\n    road = collections.defaultdict(list)\n    for __ in range(m):\n        (a, b) = map(int, input().split())\n        road[a - 1].append(b - 1)\n        road[b - 1].append(a - 1)\n    i = income[0]\n    p = population[0]\n    for x in range(1, n):\n        if i * population[x] < p * income[x]:\n            i = income[x]\n            p = population[x]\n    selected = [False] * n\n    for x in range(n):\n        if population[x] * i == income[x] * p:\n            selected[x] = True\n    visited = set()\n    ans = set()\n    for each in range(n):\n        if each not in visited and selected[each]:\n            temp = set()\n            dfs(each)\n            if len(temp) > len(ans):\n                ans = temp\n    print(len(ans))\n    for ele in ans:\n        print(ele, end=' ')", "from sys import stdin, stdout\nT = int(stdin.readline().strip())\nfor _ in range(T):\n    (N, M) = map(int, stdin.readline().strip().split())\n    A = list(map(int, stdin.readline().strip().split()))\n    B = list(map(int, stdin.readline().strip().split()))\n    per_capita = [A[i] / B[i] for i in range(N)]\n    max_pci = max(per_capita)\n    cities = {i + 1 for i in range(N) if per_capita[i] == max_pci}\n    roads = dict()\n    for city in cities:\n        roads[city] = []\n    for _ in range(M):\n        (u, v) = map(int, stdin.readline().strip().split())\n        if u in cities and v in cities:\n            roads[u].append(v)\n            roads[v].append(u)\n    visited = [False for _ in range(N + 1)]\n    max_kingdom = []\n    while len(cities) != 0:\n        vert = cities.pop()\n        if visited[vert]:\n            continue\n        stack = set([vert])\n        kingdom = set([vert])\n        while len(stack) != 0:\n            node = stack.pop()\n            if visited[node]:\n                continue\n            while roads[node] != []:\n                x = roads[node].pop(0)\n                if visited[x]:\n                    continue\n                else:\n                    stack.add(x)\n                    kingdom.add(x)\n            visited[node] = True\n        if len(max_kingdom) < len(kingdom):\n            max_kingdom = kingdom & kingdom\n    print(len(max_kingdom))\n    print(*max_kingdom, sep=' ')", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, deque\nfrom bisect import bisect_right\nfor T in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(m):\n        (u, v) = list(map(int, input().split()))\n        d[u].append(v)\n        d[v].append(u)\n    c = []\n    for i in range(n):\n        c.append((a[i] // b[i], i + 1))\n    c.sort(key=lambda x: x[0], reverse=True)\n    mx = c[0][0]\n    ind = 1\n    for i in range(n):\n        if c[i][0] != mx:\n            ind = i\n            break\n    if ind == 1 and c[ind][0] == mx:\n        print(n)\n        for i in c:\n            print(i[1], end=' ')\n        print('\\n', end='')\n        continue\n    node = []\n    di = {}\n    for i in range(ind):\n        node.append(c[i][1])\n        di[c[i][1]] = 1\n    vis = [False] * (n + 1)\n    dis = defaultdict(list)\n    mx_len = 0\n    for i in range(len(node)):\n        if vis[node[i]] == False:\n            q = deque()\n            q.append(node[i])\n            while q:\n                p = q.popleft()\n                vis[p] = True\n                for j in d[p]:\n                    if di.get(j, 0) and vis[j] == False:\n                        vis[j] = True\n                        q.append(j)\n                        dis[node[i]].append(j)\n                        mx_len = max(mx_len, len(dis[node[i]]))\n    for j in dis:\n        if len(dis[j]) == mx_len:\n            print(mx_len + 1)\n            print(j, end=' ')\n            print(*dis[j])\n            break", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\nclass Graph:\n\n    def __init__(self):\n        self.edges = defaultdict(list)\n\n    def addedge(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\n    def dfs(self, visited, a, u):\n        a.append(u)\n        visited[u] = True\n        for v in self.edges[u]:\n            if not visited[v]:\n                self.dfs(visited, a, v)\nt = int(input())\nfor _ in range(t):\n    (N, M) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    (a, b) = (A[0], B[0])\n    for i in range(N):\n        if a * B[i] < A[i] * b:\n            (a, b) = (A[i], B[i])\n    province = [False] * (N + 1)\n    for i in range(N):\n        if a * B[i] == b * A[i]:\n            province[i + 1] = True\n    g = Graph()\n    for i in range(M):\n        (u, v) = map(int, input().split())\n        if province[u] and province[v]:\n            g.addedge(u, v)\n    c = []\n    visited = [False] * (N + 1)\n    for i in range(1, N + 1):\n        if province[i] and (not visited[i]):\n            a = []\n            g.dfs(visited, a, i)\n            c.append(a[:])\n    p = max(c, key=len)\n    print(len(p))\n    print(' '.join(map(str, p)))", "from collections import defaultdict\nlimit = 3 * pow(10, 5)\n\ndef get_parent(dsu, e):\n    while dsu[e] > -1:\n        e = dsu[e]\n    return e\n\ndef get_ans(n, m, inc, popu, arr):\n    max_pci = 0\n    max_prov = set()\n    for i in range(n):\n        tmp = inc[i] / popu[i]\n        if tmp > max_pci:\n            max_prov.clear()\n            max_prov.add(i)\n            max_pci = tmp\n        elif tmp == max_pci:\n            max_prov.add(i)\n    dsu = [-1] * n\n    for i in range(m):\n        (j, k) = arr[i]\n        j -= 1\n        k -= 1\n        if j not in max_prov:\n            dsu[j] = limit\n        if k not in max_prov:\n            dsu[k] = limit\n        if j in max_prov and k in max_prov:\n            par_j = get_parent(dsu, j)\n            par_k = get_parent(dsu, k)\n            if par_j == j and par_k == k or par_j != par_k:\n                if dsu[par_j] < dsu[par_k]:\n                    dsu[par_j] += dsu[par_k]\n                    dsu[par_k] = par_j\n                else:\n                    dsu[par_k] += dsu[par_j]\n                    dsu[par_j] = par_k\n    for i in max_prov:\n        tmp = get_parent(dsu, i)\n        if tmp != i:\n            dsu[i] = tmp\n    max_len = -float('inf')\n    ans_key = 0\n    ans_dic = defaultdict(list)\n    for i in range(n):\n        if dsu[i] != limit:\n            if dsu[i] < 0 and abs(dsu[i]) > max_len:\n                max_len = abs(dsu[i])\n                ans_key = i\n                ans_dic[i].append(i + 1)\n            else:\n                ans_dic[dsu[i]].append(i + 1)\n    print(max_len)\n    print(*ans_dic[ans_key], sep=' ')\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    inc = list(map(int, input().split()))\n    popu = list(map(int, input().split()))\n    arr = []\n    for _ in range(m):\n        arr.append(list(map(int, input().split())))\n    get_ans(n, m, inc, popu, arr)", "from collections import defaultdict\nlimit = 3 * pow(10, 5)\n\ndef get_parent(dsu, e):\n    if dsu[e] < 0:\n        return e\n    return get_parent(dsu, dsu[e])\n\ndef get_ans(n, m, inc, popu, arr):\n    max_pci = 0\n    max_prov = set()\n    for i in range(n):\n        tmp = inc[i] / popu[i]\n        if tmp > max_pci:\n            max_prov.clear()\n            max_prov.add(i)\n            max_pci = tmp\n        elif tmp == max_pci:\n            max_prov.add(i)\n    dsu = [-1] * n\n    for i in range(m):\n        (j, k) = arr[i]\n        j -= 1\n        k -= 1\n        if j not in max_prov:\n            dsu[j] = limit\n        if k not in max_prov:\n            dsu[k] = limit\n        if j in max_prov and k in max_prov:\n            par_j = get_parent(dsu, j)\n            par_k = get_parent(dsu, k)\n            if par_j == j and par_k == k or par_j != par_k:\n                if dsu[par_j] < dsu[par_k]:\n                    dsu[par_j] += dsu[par_k]\n                    dsu[par_k] = par_j\n                else:\n                    dsu[par_k] += dsu[par_j]\n                    dsu[par_j] = par_k\n    for i in max_prov:\n        tmp = get_parent(dsu, i)\n        if tmp != i:\n            dsu[i] = tmp\n    max_len = -float('inf')\n    ans_key = 0\n    ans_dic = defaultdict(list)\n    for i in range(n):\n        if dsu[i] != limit:\n            if dsu[i] < 0 and abs(dsu[i]) > max_len:\n                max_len = abs(dsu[i])\n                ans_key = i\n                ans_dic[i].append(i + 1)\n            else:\n                ans_dic[dsu[i]].append(i + 1)\n    print(max_len)\n    print(*ans_dic[ans_key], sep=' ')\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    inc = list(map(int, input().split()))\n    popu = list(map(int, input().split()))\n    arr = []\n    for _ in range(m):\n        arr.append(list(map(int, input().split())))\n    get_ans(n, m, inc, popu, arr)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(u):\n    if vis[u]:\n        return\n    vis[u] = True\n    p.append(u + 1)\n    for v in g[u]:\n        dfs(v)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = [a[i] // b[i] for i in range(n)]\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    p = []\n    maxi = max(c)\n    vis = [False] * n\n    for i in range(n):\n        if c[i] != maxi:\n            vis[i] = True\n    ans = []\n    for u in range(n):\n        if not vis[u]:\n            dfs(u)\n            if len(p) > len(ans):\n                ans = p\n            p = []\n    print(len(ans))\n    print(*ans)", "from collections import defaultdict\nlimit = pow(10, 6)\n\ndef get_parent(dsu, e):\n    if dsu[e] < 0:\n        return e\n    return get_parent(dsu, dsu[e])\n\ndef get_ans(n, m, inc, popu, arr):\n    max_pci = 0\n    max_prov = set()\n    for i in range(n):\n        tmp = inc[i] / popu[i]\n        if tmp > max_pci:\n            max_prov.clear()\n            max_prov.add(i)\n            max_pci = tmp\n        elif tmp == max_pci:\n            max_prov.add(i)\n    dsu = [-1] * n\n    for i in range(m):\n        (j, k) = arr[i]\n        j -= 1\n        k -= 1\n        if j not in max_prov:\n            dsu[j] = limit\n        if k not in max_prov:\n            dsu[k] = limit\n        if j in max_prov and k in max_prov:\n            par_j = get_parent(dsu, j)\n            par_k = get_parent(dsu, k)\n            if par_j == j and par_k == k:\n                if dsu[j] < dsu[k]:\n                    dsu[j] += dsu[k]\n                    dsu[k] = j\n                else:\n                    dsu[k] += dsu[j]\n                    dsu[j] = k\n            elif par_j != par_k:\n                if dsu[par_j] < dsu[par_k]:\n                    dsu[par_j] += dsu[par_k]\n                    dsu[par_k] = par_j\n                else:\n                    dsu[par_k] += dsu[par_j]\n                    dsu[par_j] = par_k\n    for i in max_prov:\n        tmp = get_parent(dsu, i)\n        if tmp != i:\n            dsu[i] = tmp\n    max_len = -float('inf')\n    ans_key = 0\n    ans_dic = defaultdict(list)\n    for i in range(n):\n        if dsu[i] != limit:\n            if dsu[i] < 0 and abs(dsu[i]) > max_len:\n                max_len = abs(dsu[i])\n                ans_key = i\n                ans_dic[i].append(i + 1)\n            else:\n                ans_dic[dsu[i]].append(i + 1)\n    print(max_len)\n    print(*ans_dic[ans_key], sep=' ')\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    inc = list(map(int, input().split()))\n    popu = list(map(int, input().split()))\n    arr = []\n    for _ in range(m):\n        arr.append(list(map(int, input().split())))\n    get_ans(n, m, inc, popu, arr)", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, deque\nfrom bisect import bisect_right\nfor T in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(m):\n        (u, v) = list(map(int, input().split()))\n        d[u].append(v)\n        d[v].append(u)\n    c = []\n    for i in range(n):\n        c.append((a[i] // b[i], i + 1))\n    c.sort(key=lambda x: x[0], reverse=True)\n    mx = c[0][0]\n    ind = 1\n    for i in range(n):\n        if c[i][0] != mx:\n            ind = i\n            break\n    if ind == 1 and c[ind][0] == mx:\n        print(n)\n        for i in c:\n            print(i[1], end=' ')\n        print('\\n', end='')\n        continue\n    node = []\n    di = {}\n    for i in range(ind):\n        node.append(c[i][1])\n        di[c[i][1]] = 1\n    vis = [False] * (n + 1)\n    dis = defaultdict(list)\n    mx_len = 0\n    for i in range(len(node)):\n        if vis[node[i]] == False:\n            q = deque()\n            q.append(node[i])\n            while q:\n                p = q.popleft()\n                vis[p] = True\n                for j in d[p]:\n                    if di.get(j, 0) and vis[j] == False:\n                        vis[j] = True\n                        q.append(j)\n                        dis[node[i]].append(j)\n                        mx_len = max(mx_len, len(dis[node[i]]))\n    for j in dis:\n        if len(dis[j]) == mx_len:\n            print(mx_len + 1)\n            print(j, end=' ')\n            print(*dis[j])\n            break", "from collections import defaultdict\n\ndef bfs(src):\n    v[src] = 1\n    q = []\n    q.append(src)\n    while q:\n        s = q.pop(0)\n        for i in d[s]:\n            if i in v and v[i] == 0:\n                v[i] = 1\n                q.append(i)\n                d1[src].append(i)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    l1 = []\n    for i in range(n):\n        l1.append(a[i] / b[i])\n    z = max(l1)\n    l = []\n    for i in range(n):\n        if l1[i] == z:\n            l.append(i + 1)\n    v = {}\n    for i in range(len(l)):\n        v[l[i]] = 0\n    d1 = defaultdict(list)\n    (cnt, z) = (0, -1)\n    for i in range(len(l)):\n        if v[l[i]] == 0:\n            bfs(l[i])\n            d1[l[i]].append(l[i])\n            if len(d1[l[i]]) > cnt:\n                cnt = len(d1[l[i]])\n                z = l[i]\n    print(cnt)\n    print(*d1[z])", "from collections import defaultdict\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(edges, temp, visited, src, A, B, max_per_capita):\n    visited[src] = True\n    for i in range(len(edges[src])):\n        if visited[edges[src][i]] == False and A[edges[src][i]] / B[edges[src][i]] == max_per_capita:\n            temp.append(edges[src][i])\n            dfs(edges, temp, visited, edges[src][i], A, B, max_per_capita)\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, M) = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        edges = defaultdict(list)\n        for _ in range(M):\n            (u, v) = map(int, input().split())\n            edges[u - 1].append(v - 1)\n            edges[v - 1].append(u - 1)\n        max_per_capita = 0\n        max_inc_provinces = []\n        for i in range(N):\n            if max_per_capita < A[i] / B[i]:\n                max_per_capita = A[i] / B[i]\n                max_inc_provinces = [i]\n            elif max_per_capita == A[i] / B[i]:\n                max_inc_provinces.append(i)\n        visited = [False] * N\n        finalProvinces = []\n        for i in range(len(max_inc_provinces)):\n            if visited[max_inc_provinces[i]] == False:\n                temp = [max_inc_provinces[i]]\n                dfs(edges, temp, visited, max_inc_provinces[i], A, B, max_per_capita)\n                if len(temp) > len(finalProvinces):\n                    finalProvinces = temp\n        print(len(finalProvinces))\n        for val in finalProvinces:\n            print(val + 1, end=' ')\nmain()", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(u):\n    if vis[u]:\n        return\n    vis[u] = True\n    p.append(u + 1)\n    for v in g[u]:\n        dfs(v)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = [a[i] // b[i] for i in range(n)]\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    p = []\n    maxi = max(c)\n    vis = [False] * n\n    for i in range(n):\n        if c[i] != maxi:\n            vis[i] = True\n    ans = []\n    for u in range(n):\n        if not vis[u]:\n            dfs(u)\n            if len(p) > len(ans):\n                ans = p\n            p = []\n    print(len(ans))\n    print(*ans)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\nclass Graph:\n\n    def __init__(self):\n        self.edges = defaultdict(list)\n\n    def addedge(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\n    def dfs(self, visited, a, u):\n        for v in self.edges[u]:\n            if not visited[v]:\n                visited[v] = True\n                a.append(v)\n                self.dfs(visited, a, v)\n\nclass data:\n\n    def __init__(self, ipc, index):\n        self.ipc = ipc\n        self.index = index\nt = int(input())\nfor _ in range(t):\n    (N, M) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    (a, b) = (A[0], B[0])\n    for i in range(N):\n        if a * B[i] < A[i] * b:\n            (a, b) = (A[i], B[i])\n    province = [False] * (N + 1)\n    for i in range(N):\n        if a * B[i] == b * A[i]:\n            province[i + 1] = True\n    g = Graph()\n    for i in range(M):\n        (u, v) = map(int, input().split())\n        if province[u] and province[v]:\n            g.addedge(u, v)\n    c = []\n    visited = [False] * (N + 1)\n    for i in range(1, N + 1):\n        if province[i] and (not visited[i]):\n            visited[i] = True\n            a = [i]\n            g.dfs(visited, a, i)\n            c.append(a[:])\n    p = max(c, key=len)\n    print(len(p))\n    print(' '.join(map(str, p)))", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(n, vis, adj, temp):\n    vis[n] = 1\n    temp += [n]\n    for i in adj[n]:\n        if vis[i] == 0:\n            vis[i] = 1\n            dfs(i, vis, adj, temp)\n    return temp\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    adj = [[] for i in range(n + 1)]\n    vis = [0] * (n + 1)\n    mx = 0\n    for i in range(0, n):\n        mx = max(mx, a[i] // b[i])\n    fg = 0\n    for i in range(m):\n        (c, d) = map(int, input().split())\n        if a[c - 1] // b[c - 1] == mx and a[d - 1] // b[d - 1] == mx:\n            adj[c].append(d)\n            adj[d].append(c)\n            fg = 1\n    if fg == 0:\n        print(1)\n        for i in range(0, n):\n            if a[i] // b[i] == mx:\n                print(i)\n                break\n    else:\n        ans = []\n        mxcc = 0\n        for i in range(0, n):\n            if vis[i] == 0:\n                tmp = dfs(i, vis, adj, [])\n            if len(tmp) > mxcc:\n                ans = tmp[:]\n                mxcc = len(tmp)\n        print(mxcc)\n        print(*ans)", "from collections import deque\nimport sys\ninp = iter(sys.stdin.read().split('\\n'))\ninput = lambda : next(inp)\n\ndef bfs(node, m):\n    visited[node] = True\n    q = deque([node])\n    count = 1\n    li = [node]\n    while len(q) > 0:\n        v = q.popleft()\n        for i in graph[v]:\n            if dic[i][0] == m and (not visited[i]):\n                visited[i] = True\n                count += 1\n                li.append(i)\n                q.append(i)\n    return [count, li]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    dic = {}\n    graph = {}\n    ma = 0\n    for i in range(n):\n        dic[i + 1] = [a[i] / b[i], a[i], b[i]]\n        ma = max(ma, a[i] / b[i])\n        graph[i + 1] = []\n    for x in range(m):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n + 1)\n    ans = 0\n    ans2 = []\n    for i in range(1, n):\n        if dic[i][0] == ma and (not visited[i]):\n            temp = bfs(i, ma)\n            if ans < temp[0]:\n                ans = temp[0]\n                ans2 = temp[1]\n    print(ans)\n    print(*ans2)", "for t in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    E = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        E.append([x, y])\n    ab = [0] * n\n    for i in range(n):\n        ab[i] = A[i] / B[i]\n    ma = max(ab)\n    graph = {}\n    unvisited = set()\n    visited = {}\n    for i in range(n):\n        if ab[i] == ma:\n            unvisited.add(i)\n            visited[i] = -1\n            graph[i] = []\n    for i in range(m):\n        (x, y) = (E[i][0], E[i][1])\n        if ab[x - 1] == ab[y - 1] == ma:\n            graph[x - 1].append(y - 1)\n            graph[y - 1].append(x - 1)\n    ans = 0\n    arr1 = []\n    while unvisited:\n        source = unvisited.pop()\n        queue = [source]\n        visited[source] = 1\n        count = 1\n        arr2 = []\n        arr2.append(source + 1)\n        while queue:\n            head = queue.pop()\n            for neigh in graph[head]:\n                if visited[neigh] == -1:\n                    count += 1\n                    visited[neigh] = 1\n                    unvisited.remove(neigh)\n                    arr2.append(neigh + 1)\n                    queue.append(neigh)\n        if ans < count:\n            ans = count\n            arr1 = arr2[:]\n    print(ans)\n    print(*arr1)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 9)\nt = int(input())\n\ndef dfs(v, adj, visit, res):\n    visit[v] = 1\n    res.append(v + 1)\n    for i in adj[v]:\n        if visit[i] == 0:\n            dfs(i, adj, visit, res)\n    return res\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    mx = -1\n    start = -1\n    for i in range(n):\n        if a[i] / b[i] > mx:\n            mx = a[i] / b[i]\n            start = i\n    adj = defaultdict(lambda : [])\n    flag = 0\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        if a[x - 1] / b[x - 1] == mx and a[y - 1] / b[y - 1] == mx:\n            adj[x - 1].append(y - 1)\n            adj[y - 1].append(x - 1)\n            flag = 1\n    if flag == 0:\n        print(1)\n        print(start + 1)\n    else:\n        visit = [0 for i in range(n)]\n        mxans = 0\n        final = []\n        for i in range(n):\n            if visit[i] == 0:\n                temp = dfs(i, adj, visit, [])\n                n1 = len(temp)\n                if n1 > mxans:\n                    mxans = n1\n                    final = temp\n        print(mxans)\n        print(*final)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\n\ndef cin():\n    return map(int, sin().split())\n\ndef ain():\n    return list(map(int, sin().split()))\n\ndef sin():\n    return input()\n\ndef inin():\n    return int(input())\n\ndef dfs(adj, node, vi, traversal):\n    traversal += [node]\n    vi[node] = 1\n    for j in adj[node]:\n        if vi[j] == 0:\n            vi[j] = 1\n            dfs(adj, j, vi, traversal)\n    return traversal\ntry:\n    for _ in range(inin()):\n        (n, m) = cin()\n        A = ain()\n        B = ain()\n        maxPerCapInc = 0\n        for i in range(n):\n            maxPerCapInc = max(maxPerCapInc, A[i] // B[i])\n        adj = [[] for i in range(n + 1)]\n        visited = [0] * (n + 1)\n        graphExists = 0\n        for i in range(m):\n            (u, v) = cin()\n            if A[u - 1] // B[u - 1] == maxPerCapInc and A[v - 1] // B[v - 1] == maxPerCapInc:\n                adj[u].append(v)\n                adj[v].append(u)\n                graphExists = 1\n        if graphExists == 0:\n            print(1)\n            for i in range(n):\n                if A[i] // B[i] == maxPerCapInc:\n                    print(i + 1)\n                    break\n        else:\n            maxLenDfs = []\n            Len = 0\n            for node in range(n + 1):\n                if visited[node] == 0:\n                    ans = dfs(adj, node, visited, [])\n                if len(ans) > Len:\n                    Len = len(ans)\n                    maxLenDfs = ans\n            print(Len)\n            print(*maxLenDfs)\nexcept:\n    pass", "import sys\nimport bisect as b\nimport math\nfrom collections import defaultdict as dd\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nmo = 10 ** 9 + 7\n\ndef cin():\n    return map(int, sin().split())\n\ndef ain():\n    return list(map(int, sin().split()))\n\ndef sin():\n    return input()\n\ndef inin():\n    return int(input())\n\ndef dfs(adj, node, vi, ans):\n    vi[node] = 1\n    ans += [node]\n    for j in adj[node]:\n        if vi[j] == 0:\n            vi[j] = 1\n            dfs(adj, j, vi, ans)\n    return ans\nfor i in range(inin()):\n    (n, m) = cin()\n    vi = [0] * (n + 1)\n    adj = [[] for i in range(n + 1)]\n    a = ain()\n    b = ain()\n    ma = 0\n    f = 0\n    for i in range(n):\n        ma = max(a[i] // b[i], ma)\n    for i in range(m):\n        (u, v) = cin()\n        if a[u - 1] // b[u - 1] == ma and a[v - 1] // b[v - 1] == ma:\n            adj[u].append(v)\n            adj[v].append(u)\n            f = 1\n    if not f:\n        print(1)\n        for i in range(n):\n            if a[i] // b[i] == ma:\n                print(i + 1)\n                break\n    else:\n        maxcc = 0\n        ans = []\n        for i in range(n + 1):\n            if vi[i] == 0:\n                temp = dfs(adj, i, vi, [])\n            if len(temp) > maxcc:\n                maxcc = len(temp)\n                ans = temp\n        print(maxcc)\n        print(*ans)", "def dfs(u, temp, dom, v):\n    stack = []\n    stack.append(u)\n    v[u] = True\n    temp.append(u + 1)\n    while stack:\n        e = stack.pop()\n        for i in dom[e]:\n            if not v[i]:\n                stack.append(i)\n                v[i] = True\n                temp.append(i + 1)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    hest = 0\n    for i in range(n):\n        tmp = a[i] / b[i]\n        if tmp > hest:\n            hest = tmp\n    dom = {}\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        if a[u] / b[u] < hest or a[v] / b[v] < hest:\n            continue\n        if u not in dom:\n            dom[u] = []\n        dom[u].append(v)\n        if v not in dom:\n            dom[v] = []\n        dom[v].append(u)\n    v = [False] * n\n    longest = []\n    for i in dom:\n        if not v[i]:\n            temp = []\n            dfs(i, temp, dom, v)\n            if len(temp) > len(longest):\n                longest = temp\n    print(len(longest))\n    print(*longest, sep=' ')", "import collections\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef fun(node):\n    if visited[node]:\n        return\n    p.append(node + 1)\n    visited[node] = True\n    for j in g[node]:\n        fun(j)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append(a[i] / b[i])\n    g = collections.defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    p = []\n    ans = []\n    mx = max(l)\n    visited = [False] * n\n    for i in range(n):\n        if l[i] != mx:\n            visited[i] = True\n    for i in range(n):\n        if not visited[i]:\n            fun(i)\n            if len(p) > len(ans):\n                ans = p\n            p = []\n    print(len(ans))\n    print(*ans)", "from sys import setrecursionlimit\nimport collections\nsetrecursionlimit(10 ** 9)\nco = 0\n\nclass graph:\n\n    def goodnodes(self, roads, good, n):\n        king = collections.defaultdict(list)\n        for (u, v) in roads:\n            if good[u - 1] == 1 and good[v - 1] == 1:\n                king[u].append(v)\n                king[v].append(u)\n\n        def dfs(node, visited, te):\n            if visited[node] == 0:\n                visited[node] = 1\n                te.append(node)\n                global co\n                co = co + 1\n                if node in king:\n                    for nei in king[node]:\n                        if visited[nei] == 0:\n                            dfs(nei, visited, te)\n            return te\n        visited = [0] * (n + 1)\n        fina = []\n        m = 0\n        for j in range(0, n):\n            if good[j] == 1 and visited[j + 1] != 1:\n                te = []\n                global co\n                co = 0\n                fi = dfs(j + 1, visited, te)\n                if co > m:\n                    fina = fi[:]\n                    m = co\n        return fina\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = [int(v) for v in input().split()]\n    b = [int(v) for v in input().split()]\n    roads = []\n    for j in range(m):\n        tem = [int(v) for v in input().split()]\n        roads.append(tem)\n    c = []\n    ma = 0\n    for j in range(n):\n        c.append(a[j] / b[j])\n        ma = max(a[j] / b[j], ma)\n    good = [0] * n\n    for j in range(n):\n        if c[j] == ma:\n            good[j] = 1\n            x = j + 1\n    g = graph()\n    fin = []\n    final = g.goodnodes(roads, good, n)\n    print(len(final))\n    print(' '.join(map(str, final)))", "from collections import deque\nimport sys\ninp = iter(sys.stdin.read().split('\\n'))\ninput = lambda : next(inp)\n\ndef bfs(node, m):\n    visited[node] = True\n    q = deque([node])\n    count = 1\n    li = [node]\n    while len(q) > 0:\n        v = q.popleft()\n        for i in graph[v]:\n            if dic[i][0] == m and (not visited[i]):\n                visited[i] = True\n                count += 1\n                li.append(i)\n                q.append(i)\n    return [count, li]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    dic = {}\n    graph = {}\n    ma = 0\n    for i in range(n):\n        dic[i + 1] = [a[i] / b[i], a[i], b[i]]\n        ma = max(ma, a[i] / b[i])\n        graph[i + 1] = []\n    for x in range(m):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n + 1)\n    ans = 0\n    ans2 = []\n    for i in range(1, n):\n        if dic[i][0] == ma and (not visited[i]):\n            temp = bfs(i, ma)\n            if ans < temp[0]:\n                ans = temp[0]\n                ans2 = temp[1]\n    print(ans)\n    print(*ans2)", "t = int(input())\nwhile t:\n    t = t - 1\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    G = {}\n    while m:\n        m = m - 1\n        (u, v) = map(int, input().split())\n        u = u - 1\n        v = v - 1\n        if u in G:\n            G[u].append(v)\n        else:\n            G[u] = [v]\n        if v in G:\n            G[v].append(u)\n        else:\n            G[v] = [u]\n    PC = [A[i] / B[i] for i in range(n)]\n    max_pc = max(PC)\n    in_ans = []\n    for x in PC:\n        if x == max_pc:\n            in_ans.append(1)\n        else:\n            in_ans.append(0)\n    vis = [False for x in range(n)]\n    which_part = [-1 for x in range(n)]\n    part = 0\n    for i in range(n):\n        if vis[i] == False and in_ans[i] == 1:\n            part = part + 1\n            q = [i]\n            which_part[i] = part\n            vis[i] = True\n            while len(q) > 0:\n                top = q.pop(0)\n                for x in G[top]:\n                    if vis[x] == False and in_ans[x] == 1:\n                        q.append(x)\n                        vis[x] = True\n                        which_part[x] = part\n    nu = {}\n    ans = []\n    for i in range(n):\n        x = which_part[i]\n        if x != -1:\n            if x in nu:\n                nu[x].append(i + 1)\n            else:\n                nu[x] = [i + 1]\n            if len(ans) < len(nu[x]):\n                ans = nu[x]\n    print(len(ans))\n    for x in ans:\n        print(x, end=' ')\n    print()", "from collections import deque\n\ndef bfs(graph, node, visited):\n    q = deque()\n    q.append(node)\n    c = 0\n    elements = []\n    visited[node] = True\n    while q != deque([]):\n        a = q.popleft()\n        c += 1\n        elements.append(a)\n        for i in graph[a]:\n            if not visited[i]:\n                q.append(i)\n                visited[i] = True\n    elements.append(c)\n    return elements\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = [int(i) for i in input().split()]\n    brr = [int(i) for i in input().split()]\n    graph = []\n    for i in range(m):\n        (a, b) = map(int, input().split())\n        graph.append((a - 1, b - 1))\n    income = []\n    for i in range(n):\n        income.append(arr[i] / brr[i])\n    large = max(income)\n    visited = {}\n    for i in range(n):\n        if income[i] == large:\n            visited[i] = False\n    new = []\n    for i in range(m):\n        a = graph[i]\n        if a[0] in visited and a[1] in visited:\n            new.append(a)\n    graph = [[] for i in range(n)]\n    for i in new:\n        graph[i[0]].append(i[1])\n        graph[i[1]].append(i[0])\n    ans = []\n    c = 0\n    for i in visited:\n        if not visited[i]:\n            temp = bfs(graph, i, visited)\n            if temp[-1] > c:\n                ans = temp[:-1]\n                c = temp[-1]\n    print(c)\n    for i in ans:\n        print(i + 1, end=' ')\n    print()", "from collections import deque\nimport sys\ninp = iter(sys.stdin.read().split('\\n'))\ninput = lambda : next(inp)\n\ndef bfs(node, m):\n    visited[node] = True\n    q = deque([node])\n    count = 1\n    li = [node]\n    while len(q) > 0:\n        v = q.popleft()\n        for i in graph[v]:\n            if dic[i][0] == m and (not visited[i]):\n                visited[i] = True\n                count += 1\n                li.append(i)\n                q.append(i)\n    return [count, li]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    dic = {}\n    graph = {}\n    ma = 0\n    for i in range(n):\n        dic[i + 1] = [a[i] / b[i], a[i], b[i]]\n        ma = max(ma, a[i] / b[i])\n        graph[i + 1] = []\n    for x in range(m):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n + 1)\n    ans = 0\n    ans2 = []\n    for i in range(1, n):\n        if dic[i][0] == ma and (not visited[i]):\n            temp = bfs(i, ma)\n            if ans < temp[0]:\n                ans = temp[0]\n                ans2 = temp[1]\n    print(ans)\n    print(*ans2)", "from collections import deque\n\ndef bfs(node, m):\n    visited[node] = True\n    q = deque([node])\n    count = 1\n    li = [node]\n    while len(q) > 0:\n        v = q.popleft()\n        for i in graph[v]:\n            if dic[i][0] == m and (not visited[i]):\n                visited[i] = True\n                count += 1\n                li.append(i)\n                q.append(i)\n    return [count, li]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    dic = {}\n    graph = {}\n    ma = 0\n    for i in range(n):\n        dic[i + 1] = [a[i] / b[i], a[i], b[i]]\n        ma = max(ma, a[i] / b[i])\n        graph[i + 1] = []\n    for x in range(m):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n + 1)\n    ans = 0\n    ans2 = []\n    for i in range(1, n):\n        if dic[i][0] == ma and (not visited[i]):\n            temp = bfs(i, ma)\n            if ans < temp[0]:\n                ans = temp[0]\n                ans2 = temp[1]\n    print(ans)\n    print(*ans2)", "from collections import deque\n\ndef bfs(node, m):\n    visited[node] = True\n    q = deque([node])\n    count = 1\n    li = [node]\n    while len(q) > 0:\n        v = q.popleft()\n        for i in graph[v]:\n            if dic[i][0] == m and (not visited[i]):\n                visited[i] = True\n                count += 1\n                li.append(i)\n                q.append(i)\n    return [count, li]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    dic = {}\n    graph = {}\n    ma = 0\n    for i in range(n):\n        dic[i + 1] = [a[i] / b[i], a[i], b[i]]\n        ma = max(ma, a[i] / b[i])\n        graph[i + 1] = []\n    li = []\n    for i in range(1, n + 1):\n        if dic[i][0] == ma:\n            li.append(i)\n    for x in range(m):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n + 1)\n    ans = 0\n    ans2 = []\n    for i in li:\n        if not visited[i]:\n            temp = bfs(i, ma)\n            if ans < temp[0]:\n                ans = temp[0]\n                ans2 = temp[1]\n    print(ans)\n    print(*ans2)", "import sys\nimport bisect as b\nimport math\nfrom collections import defaultdict as dd\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nmo = 10 ** 9 + 7\n\ndef cin():\n    return map(int, sin().split())\n\ndef ain():\n    return list(map(int, sin().split()))\n\ndef sin():\n    return input()\n\ndef inin():\n    return int(input())\n\ndef pref(a, n, f):\n    pre = [0] * n\n    if f == 0:\n        pre[0] = a[0]\n        for i in range(1, n):\n            pre[i] = a[i] + pre[i - 1]\n    else:\n        pre[-1] = a[-1]\n        for i in range(n - 2, -1, -1):\n            pre[i] = pre[i + 1] + a[i]\n    return pre\n\ndef dfs(adj, node, vi, ans):\n    vi[node] = 1\n    ans += [node]\n    for j in adj[node]:\n        if vi[j] == 0:\n            vi[j] = 1\n            dfs(adj, j, vi, ans)\n    return ans\nfor i in range(inin()):\n    (n, m) = cin()\n    vi = [0] * (n + 1)\n    adj = [[] for i in range(n + 1)]\n    a = ain()\n    b = ain()\n    ma = 0\n    f = 0\n    for i in range(n):\n        ma = max(a[i] // b[i], ma)\n    for i in range(m):\n        (u, v) = cin()\n        if a[u - 1] // b[u - 1] == ma and a[v - 1] // b[v - 1] == ma:\n            adj[u].append(v)\n            adj[v].append(u)\n            f = 1\n    if not f:\n        print(1)\n        for i in range(n):\n            if a[i] // b[i] == ma:\n                print(i + 1)\n                break\n    else:\n        maxcc = 0\n        ans = []\n        for i in range(n + 1):\n            if vi[i] == 0:\n                temp = dfs(adj, i, vi, [])\n            if len(temp) > maxcc:\n                maxcc = len(temp)\n                ans = temp\n        print(maxcc)\n        print(*ans)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(u):\n    if vis[u]:\n        return\n    vis[u] = True\n    p.append(u + 1)\n    for v in g[u]:\n        dfs(v)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = [a[i] // b[i] for i in range(n)]\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    p = []\n    maxi = max(c)\n    vis = [False] * n\n    for i in range(n):\n        if c[i] != maxi:\n            vis[i] = True\n    ans = []\n    for u in range(n):\n        if not vis[u]:\n            dfs(u)\n            if len(p) > len(ans):\n                ans = p\n            p = []\n    print(len(ans))\n    print(*ans)", "from collections import defaultdict\n\nclass DSU:\n\n    def __init__(self, n):\n        self.p = list(range(n))\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, x, y):\n        self.p[self.find(x)] = self.find(y)\nt = int(input())\nwhile t:\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    dsu = DSU(n)\n    ratio = [a[i] / b[i] for i in range(n)]\n    maxx = max(ratio)\n    choose = set()\n    for i in range(n):\n        if ratio[i] == maxx:\n            choose.add(i)\n    graph = defaultdict(list)\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        if u in choose and v in choose:\n            graph[u].append(v)\n            graph[v].append(u)\n            dsu.union(u, v)\n    freq = [0] * n\n    for x in choose:\n        freq[dsu.find(x)] += 1\n    leader = freq.index(max(freq))\n    ans = []\n    for x in choose:\n        if dsu.find(x) == leader:\n            ans.append(x + 1)\n    print(len(ans))\n    print(*ans)\n    t -= 1", "from collections import defaultdict\n\nclass DSU:\n\n    def __init__(self, n):\n        self.p = list(range(n))\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, x, y):\n        self.p[self.find(x)] = self.find(y)\nt = int(input())\nwhile t:\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    dsu = DSU(n)\n    ratio = [a[i] / b[i] for i in range(n)]\n    maxx = max(ratio)\n    choose = set()\n    for i in range(n):\n        if ratio[i] == maxx:\n            choose.add(i)\n    graph = defaultdict(list)\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        if u in choose and v in choose:\n            graph[u].append(v)\n            graph[v].append(u)\n            dsu.union(u, v)\n    freq = [0] * n\n    for x in choose:\n        freq[dsu.find(x)] += 1\n    leader = freq.index(max(freq))\n    leader = dsu.find(leader)\n    ans = []\n    for x in choose:\n        if dsu.find(x) == leader:\n            ans.append(x + 1)\n    print(len(ans))\n    print(*ans)\n    t -= 1", "from sys import setrecursionlimit\nimport collections\nsetrecursionlimit(10 ** 9)\n\nclass graph:\n\n    def goodnodes(self, roads, good, n):\n        king = collections.defaultdict(list)\n        for (u, v) in roads:\n            if good[u - 1] == 1 and good[v - 1] == 1:\n                king[u].append(v)\n                king[v].append(u)\n\n        def dfs(node, visited, te):\n            if visited[node] == 0:\n                visited[node] = 1\n                te.append(node)\n                if node in king:\n                    for nei in king[node]:\n                        if visited[nei] == 0:\n                            dfs(nei, visited, te)\n            return te\n        visited = [0] * (n + 1)\n        fina = []\n        for j in range(0, n):\n            if good[j] == 1 and visited[j + 1] != 1:\n                te = []\n                fina.append(dfs(j + 1, visited, te))\n        return fina\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = [int(v) for v in input().split()]\n    b = [int(v) for v in input().split()]\n    roads = []\n    for j in range(m):\n        tem = [int(v) for v in input().split()]\n        roads.append(tem)\n    c = []\n    ma = 0\n    for j in range(n):\n        c.append(a[j] / b[j])\n        ma = max(a[j] / b[j], ma)\n    good = [0] * n\n    for j in range(n):\n        if c[j] == ma:\n            good[j] = 1\n            x = j + 1\n    g = graph()\n    fin = []\n    final = g.goodnodes(roads, good, n)\n    maxi = 0\n    for v in final:\n        if len(v) > maxi:\n            fin = v[:]\n            maxi = len(v)\n    print(maxi)\n    print(' '.join(map(str, fin)))", "from sys import stdin, stdout\nimport sys\nsys.setrecursionlimit(10 ** 6)\nimport math, queue, heapq\nfastinput = stdin.readline\nfastout = stdout.write\nt = int(fastinput())\n\nclass Graph:\n\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for i in range(V)]\n\n    def DFSUtil(self, temp, v, visited):\n        visited[v] = True\n        temp.append(v)\n        for i in self.adj[v]:\n            if visited[i] == False:\n                temp = self.DFSUtil(temp, i, visited)\n        return temp\n\n    def addEdge(self, v, w):\n        self.adj[v].append(w)\n        self.adj[w].append(v)\n\n    def connectedComponents(self):\n        visited = [False] * self.V\n        cc = []\n        last = []\n        for v in range(self.V):\n            if visited[v] == False:\n                temp = []\n                last = self.DFSUtil(temp, v, visited)\n                if len(last) > len(cc):\n                    cc = last\n        return cc\nwhile t:\n    t -= 1\n    (n, m) = map(int, fastinput().split())\n    a = [0] + list(map(int, fastinput().split()))\n    j = 1\n    for i in fastinput().split():\n        a[j] /= int(i)\n        j += 1\n    mal = 0\n    for i in range(1, n + 1):\n        mal = max(mal, a[i])\n    g = Graph(n + 1)\n    for _ in range(m):\n        (x, y) = map(int, fastinput().split())\n        if mal == a[x] and mal == a[y]:\n            g.addEdge(x, y)\n    cc = g.connectedComponents()\n    print(len(cc))\n    print(*cc)", "import sys\nimport bisect as b\nimport math\nfrom collections import defaultdict as dd\ninput = sys.stdin.readline\nsys.setrecursionlimit(200005)\nmo = 10 ** 9 + 7\n\ndef cin():\n    return map(int, sin().split())\n\ndef ain():\n    return list(map(int, sin().split()))\n\ndef sin():\n    return input()\n\ndef inin():\n    return int(input())\n\ndef pref(a, n, f):\n    pre = [0] * n\n    if f == 0:\n        pre[0] = a[0]\n        for i in range(1, n):\n            pre[i] = a[i] + pre[i - 1]\n    else:\n        pre[-1] = a[-1]\n        for i in range(n - 2, -1, -1):\n            pre[i] = pre[i + 1] + a[i]\n    return pre\nvi = [0] * 200005\nadj = [[] for i in range(200005)]\n\ndef dfs(node, ans):\n    vi[node] = 1\n    ans += [node + 1]\n    for j in adj[node]:\n        if vi[j] == 0:\n            dfs(j, ans)\n    return ans\nfor i in range(inin()):\n    (n, m) = cin()\n    a = ain()\n    b = ain()\n    ma = -1\n    f = 0\n    for i in range(n):\n        ma = max(a[i] // b[i], ma)\n        adj[i].clear()\n        vi[i] = 0\n    for i in range(m):\n        (u, v) = cin()\n        if a[u - 1] // b[u - 1] == ma and a[v - 1] // b[v - 1] == ma:\n            adj[u - 1].append(v - 1)\n            adj[v - 1].append(u - 1)\n    maxcc = 0\n    ans = []\n    for i in range(n):\n        if vi[i] == 0:\n            if a[i] // b[i] == ma:\n                li = []\n                temp = dfs(i, li)\n                if len(temp) > maxcc:\n                    maxcc = len(temp)\n                    ans = temp\n                if maxcc == 0:\n                    maxcc = 1\n                    ans += [i + 1]\n    print(maxcc)\n    print(*ans)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\nimport collections\n\nclass graph:\n\n    def goodnodes(self, roads, good, n):\n        king = collections.defaultdict(list)\n        for (u, v) in roads:\n            if good[u - 1] == 1 and good[v - 1] == 1:\n                king[u].append(v)\n                king[v].append(u)\n\n        def dfs(node, visited, te):\n            if visited[node] == 0:\n                visited[node] = 1\n                te.append(node)\n                if node in king:\n                    for nei in king[node]:\n                        if visited[nei] == 0:\n                            dfs(nei, visited, te)\n            return te\n        visited = [0] * (n + 1)\n        fina = []\n        for j in range(n):\n            if good[j] == 1 and visited[j + 1] != 1:\n                te = []\n                fina.append(dfs(j + 1, visited, te))\n        return fina\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = [int(v) for v in input().split()]\n    b = [int(v) for v in input().split()]\n    roads = []\n    for j in range(m):\n        tem = [int(v) for v in input().split()]\n        roads.append(tem)\n    c = []\n    ma = 0\n    for j in range(n):\n        c.append(a[j] / b[j])\n        ma = max(a[j] / b[j], ma)\n    good = [0] * n\n    for j in range(n):\n        if c[j] == ma:\n            good[j] = 1\n            x = j + 1\n    g = graph()\n    fin = []\n    final = g.goodnodes(roads, good, n)\n    maxi = 1\n    if final == []:\n        print(1)\n        print(x)\n    else:\n        maxi = 0\n        for v in final:\n            if len(v) > maxi:\n                fin = v[:]\n                maxi = len(v)\n        print(maxi)\n        print(' '.join(map(str, fin)))", "from sys import setrecursionlimit\nimport collections\nsetrecursionlimit(10 ** 9)\n\nclass graph:\n\n    def goodnodes(self, roads, good, n):\n        king = collections.defaultdict(list)\n        for (u, v) in roads:\n            if good[u - 1] == 1 and good[v - 1] == 1:\n                king[u].append(v)\n                king[v].append(u)\n\n        def dfs(node, visited, te):\n            if visited[node] == 0:\n                visited[node] = 1\n                te.append(node)\n                if node in king:\n                    for nei in king[node]:\n                        if visited[nei] == 0:\n                            dfs(nei, visited, te)\n            return te\n        visited = [0] * (n + 1)\n        fina = []\n        for j in range(0, n):\n            if good[j] == 1 and visited[j + 1] != 1:\n                te = []\n                fina.append(dfs(j + 1, visited, te))\n        return fina\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = [int(v) for v in input().split()]\n    b = [int(v) for v in input().split()]\n    roads = []\n    for j in range(m):\n        tem = [int(v) for v in input().split()]\n        roads.append(tem)\n    c = []\n    ma = 0\n    for j in range(n):\n        c.append(a[j] / b[j])\n        ma = max(a[j] / b[j], ma)\n    good = [0] * n\n    for j in range(n):\n        if c[j] == ma:\n            good[j] = 1\n            x = j + 1\n    g = graph()\n    fin = []\n    final = g.goodnodes(roads, good, n)\n    maxi = 1\n    if final == []:\n        print(1)\n        print(x)\n    else:\n        maxi = 0\n        for v in final:\n            if len(v) > maxi:\n                fin = v[:]\n                maxi = len(v)\n        print(maxi)\n        print(' '.join(map(str, fin)))", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(i):\n    if not num1[i]:\n        return\n    num1[i] = 0\n    p.append(i)\n    for v in ll[i]:\n        dfs(v)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    (l, l1) = ([], [a[0] / b[0]])\n    for i in range(m):\n        l.append(list(map(int, input().split())))\n    (x, f) = (a[0] / b[0], 0)\n    l1 = [0, x]\n    for i in range(1, n):\n        l1.append(a[i] / b[i])\n        if a[i] / b[i] > x:\n            x = a[i] / b[i]\n            f = i + 1\n    (l3, num1) = ([], [0] * (n + 1))\n    for i in l:\n        if l1[i[0]] == x and l1[i[1]] == x:\n            l3.append(i)\n            (num1[i[0]], num1[i[1]]) = (1, 1)\n    if l3:\n        ll = [[] for i in range(n + 1)]\n        for i in l3:\n            ll[i[0]].append(i[1])\n            ll[i[1]].append(i[0])\n        (p, num) = ([], [])\n        for i in range(n + 1):\n            if num1[i]:\n                dfs(i)\n                if len(p) > len(num):\n                    num = p\n                p = []\n        print(len(num))\n        print(*num)\n    else:\n        print(1)\n        print(f)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(i):\n    if not num1[i]:\n        return\n    num1[i] = 0\n    p.append(i + 1)\n    for v in l[i]:\n        dfs(v)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = [[] for i in range(n)]\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        l[x - 1].append(y - 1)\n        l[y - 1].append(x - 1)\n    l1 = []\n    for i in range(n):\n        l1.append(a[i] // b[i])\n    num1 = [0] * n\n    m = max(l1)\n    for i in range(n):\n        if l1[i] == m:\n            num1[i] = 1\n    (p, num) = ([], [])\n    for i in range(n):\n        if num1[i]:\n            dfs(i)\n            if len(p) > len(num):\n                num = p\n            p = []\n    print(len(num))\n    print(*num)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(id, ph, ss):\n    vis[id] = 1\n    ss.add(id)\n    for i in range(len(ph[id])):\n        if vis[ph[id][i]] != 1:\n            dfs(ph[id][i], ph, ss)\nfor _ in range(int(input())):\n    (n, c) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    ppl = list(map(int, input().split()))\n    di = []\n    for i in range(n):\n        di.append(arr[i] // ppl[i])\n    mx = max(di)\n    ans = set()\n    for i in range(n):\n        if di[i] == mx:\n            ans.add(i + 1)\n    path = [[] for i in range(n + 1)]\n    for i in range(c):\n        (u, v) = map(int, input().split())\n        if u in ans and v in ans:\n            path[u].append(v)\n            path[v].append(u)\n    vis = [0] * (n + 1)\n    x = 0\n    fs = set()\n    for i in ans:\n        ss = set()\n        if vis[i] != 1:\n            dfs(i, path, ss)\n        if x < len(ss):\n            x = len(ss)\n            fs = ss\n    print(x)\n    print(*fs)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(id, ph, ss):\n    vis[id] = 1\n    ss.add(id)\n    for i in range(len(ph[id])):\n        if vis[ph[id][i]] != 1:\n            dfs(ph[id][i], ph, ss)\nfor _ in range(int(input())):\n    (n, c) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    ppl = list(map(int, input().split()))\n    di = []\n    for i in range(n):\n        di.append(arr[i] // ppl[i])\n    mx = max(di)\n    ans = set()\n    for i in range(n):\n        if di[i] == mx:\n            ans.add(i + 1)\n    path = [[] for i in range(n + 1)]\n    for i in range(c):\n        (u, v) = map(int, input().split())\n        if u in ans and v in ans:\n            path[u].append(v)\n            path[v].append(u)\n    vis = [0] * (n + 1)\n    x = 0\n    fs = set()\n    for i in ans:\n        ss = set()\n        if vis[i] != 1:\n            dfs(i, path, ss)\n        if x < len(ss):\n            x = len(ss)\n            fs = ss\n    print(x)\n    print(*fs)", "def find(st, u):\n    st[u] = u if st[u] == u else find(st, st[u])\n    return st[u]\nT = int(input().rstrip())\nfor tt in range(T):\n    (N, M) = list(map(int, input().rstrip().split(' ')))\n    A = list(map(int, input().rstrip().split(' ')))\n    B = list(map(int, input().rstrip().split(' ')))\n    prov = list(zip(A, B))\n    mx = max(prov, key=lambda x: x[0] / x[1])\n    st = [i for i in range(N)]\n    sz = [1] * N\n    for i in range(M):\n        (u, v) = list(map(int, input().rstrip().split(' ')))\n        u -= 1\n        v -= 1\n        if A[u] * mx[1] == B[u] * mx[0] and A[v] * mx[1] == B[v] * mx[0]:\n            if find(st, u) != find(st, v):\n                sz[find(st, u)] += sz[find(st, v)]\n                st[find(st, v)] = find(st, u)\n    root = max(range(N), key=lambda x: sz[x])\n    print(sz[root])\n    print(' '.join(map(lambda x: str(x + 1), filter(lambda x: find(st, x) == root, range(N)))))", "def find(st, u):\n    st[u] = u if st[u] == u else find(st, st[u])\n    return st[u]\nT = int(input().rstrip())\nfor tt in range(T):\n    (N, M) = list(map(int, input().rstrip().split(' ')))\n    A = list(map(int, input().rstrip().split(' ')))\n    B = list(map(int, input().rstrip().split(' ')))\n    prov = list(zip(A, B))\n    mx = max(prov, key=lambda x: x[0] / x[1])\n    st = [i for i in range(N)]\n    sz = [1] * N\n    for i in range(M):\n        (u, v) = list(map(int, input().rstrip().split(' ')))\n        u -= 1\n        v -= 1\n        if A[u] * mx[1] == B[u] * mx[0] and A[v] * mx[1] == B[v] * mx[0]:\n            if find(st, u) != find(st, v):\n                sz[find(st, u)] += sz[find(st, v)]\n                st[find(st, v)] = find(st, u)\n    root = max(range(N), key=lambda x: sz[x])\n    print(sz[root])\n    print(' '.join(map(lambda x: str(x + 1), filter(lambda x: find(st, x) == root, range(N)))))", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(u):\n    if v[u]:\n        return\n    v[u] = True\n    p.append(u + 1)\n    for x in graph[u]:\n        dfs(x)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    cap = list(map(int, input().split()))\n    pop = list(map(int, input().split()))\n    ratio = [cap[i] // pop[i] for i in range(n)]\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    maxratio = max(ratio)\n    v = [True for i in range(n)]\n    for i in range(n):\n        if ratio[i] == maxratio:\n            v[i] = False\n    ans = []\n    p = []\n    for u in range(n):\n        if not v[u]:\n            dfs(u)\n            if len(p) > len(ans):\n                ans = p\n            p = []\n    print(len(ans))\n    print(*ans)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(u):\n    if v[u]:\n        return\n    v[u] = True\n    p.append(u + 1)\n    for x in graph[u]:\n        dfs(x)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    cap = list(map(int, input().split()))\n    pop = list(map(int, input().split()))\n    ratio = [cap[i] // pop[i] for i in range(n)]\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    maxratio = max(ratio)\n    v = [True for i in range(n)]\n    for i in range(n):\n        if ratio[i] == maxratio:\n            v[i] = False\n    ans = []\n    p = []\n    for u in range(n):\n        if not v[u]:\n            dfs(u)\n            if len(p) > len(ans):\n                ans = p\n            p = []\n    print(len(ans))\n    print(*ans)", "from collections import defaultdict\n\ndef dfs(node):\n    vis[node] = 0\n    path.append(node)\n    pq = [node]\n    while len(pq) != 0:\n        cur = pq.pop()\n        for i in d[cur]:\n            if vis[i]:\n                pq.append(i)\n                path.append(i)\n                vis[i] = 0\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    inc = list(map(int, input().split()))\n    pop = list(map(int, input().split()))\n    ma = -1\n    d = defaultdict(list)\n    for i in range(n):\n        ma = max(ma, inc[i] // pop[i])\n    vis = [0] * (n + 1)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    for i in range(1, n + 1):\n        if inc[i - 1] // pop[i - 1] == ma:\n            vis[i] = 1\n    ma = -1\n    for i in range(1, n + 1):\n        if vis[i]:\n            path = []\n            dfs(i)\n            if len(path) > ma:\n                ma = len(path)\n                p = path\n    print(ma)\n    print(*p)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 9)\n\ndef dfs(node):\n    vis[node] = 0\n    path.append(node)\n    for i in d[node]:\n        if vis[i]:\n            dfs(i)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    inc = list(map(int, input().split()))\n    pop = list(map(int, input().split()))\n    ma = -1\n    d = defaultdict(list)\n    for i in range(n):\n        ma = max(ma, inc[i] // pop[i])\n    vis = [0] * (n + 1)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    for i in range(1, n + 1):\n        if inc[i - 1] // pop[i - 1] == ma:\n            vis[i] = 1\n    ma = -1\n    p = []\n    for i in range(1, n + 1):\n        if vis[i]:\n            path = []\n            dfs(i)\n            if len(path) > ma:\n                ma = len(path)\n                p = path\n    print(ma)\n    print(*p)", "def solve():\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    max = 0\n    for i in range(n):\n        if a[i] / b[i] > max:\n            max = a[i] / b[i]\n    graph = {}\n    visited = [False for _ in range(n)]\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        x -= 1\n        y -= 1\n        if a[x] / b[x] == max:\n            if x not in graph:\n                graph[x] = []\n            if a[y] / b[y] == max:\n                graph[x].append(y)\n        if a[y] / b[y] == max:\n            if y not in graph:\n                graph[y] = []\n            if a[x] / b[x] == max:\n                graph[y].append(x)\n    sol = []\n    for i in graph:\n        if visited[i] == False:\n            curSol = []\n            stack = [i]\n            visited[i] = True\n            while len(stack):\n                node = stack.pop()\n                curSol.append(node + 1)\n                for j in graph[node]:\n                    if not visited[j]:\n                        visited[j] = True\n                        stack.append(j)\n            if len(curSol) > len(sol):\n                sol = curSol[:]\n    print(len(sol))\n    print(*sol, sep=' ', end='\\n')\nT = int(input())\nfor _ in range(T):\n    solve()", "def solve():\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    aMax = a[0]\n    bMax = b[0]\n    for i in range(n):\n        if a[i] * bMax > b[i] * aMax:\n            aMax = a[i]\n            bMax = b[i]\n    graph = {}\n    visited = [False for _ in range(n)]\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        x -= 1\n        y -= 1\n        if a[x] * bMax == b[x] * aMax:\n            if x not in graph:\n                graph[x] = []\n            if a[y] * bMax == b[y] * aMax:\n                graph[x].append(y)\n        if a[y] * bMax == b[y] * aMax:\n            if y not in graph:\n                graph[y] = []\n            if a[x] * bMax == b[x] * aMax:\n                graph[y].append(x)\n    sol = []\n    for i in graph:\n        if visited[i] == False and a[i] * bMax == b[i] * aMax:\n            curSol = []\n            stack = [i]\n            visited[i] = True\n            while len(stack):\n                node = stack.pop()\n                curSol.append(node + 1)\n                for j in graph[node]:\n                    if not visited[j]:\n                        visited[j] = True\n                        stack.append(j)\n            if len(curSol) > len(sol):\n                sol = curSol[:]\n    print(len(sol))\n    print(*sol, sep=' ', end='\\n')\nT = int(input())\nfor _ in range(T):\n    solve()", "import sys\nimport math\nimport collections\nfrom sys import stdin, stdout, setrecursionlimit\nimport bisect as bs\nsetrecursionlimit(2 ** 20)\nM = 10 ** 9 + 7\n\ndef solve():\n    (n, m) = list(map(int, stdin.readline().split()))\n    income = list(map(int, stdin.readline().split()))\n    population = list(map(int, stdin.readline().split()))\n    percapita = [0] * n\n    adj = []\n    for i in range(n):\n        adj.append([])\n    for i in range(m):\n        (x, y) = list(map(int, stdin.readline().split()))\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    max_percapita = -1\n    d = {}\n    for i in range(n):\n        percapita[i] = income[i] // population[i]\n        max_percapita = max(max_percapita, percapita[i])\n        if percapita[i] not in d:\n            d[percapita[i]] = []\n        d[percapita[i]].append(i)\n    vis = [0] * n\n    mark = [-1] * n\n    ans = 0\n    final_mark = -1\n    for i in d[max_percapita]:\n        if vis[i] == 0:\n            stack = [i]\n            vis[i] = 1\n            cnt = 1\n            while len(stack) != 0:\n                s = stack.pop()\n                mark[s] = i\n                for j in adj[s]:\n                    if vis[j] == 0 and percapita[j] == max_percapita:\n                        vis[j] = 1\n                        cnt += 1\n                        stack.append(j)\n            if cnt >= ans:\n                ans = cnt\n                final_mark = i\n    ans1 = []\n    for i in range(n):\n        if mark[i] == final_mark:\n            ans1.append(i + 1)\n    print(ans)\n    print(*ans1)\nt = 1\nt = int(stdin.readline())\nfor _ in range(t):\n    solve()", "import sys\nsys.setrecursionlimit(1000000)\n\ndef DFS(v, visited, k, conn):\n    visited[v] = 1\n    k.append(v + 1)\n    for i in conn[v]:\n        if visited[i] == 0:\n            DFS(i, visited, k, conn)\n\ndef solve(visited, conn):\n    q = {}\n    k = []\n    for i in d:\n        if visited[i] == 0:\n            DFS(i, visited, k, conn)\n            q[len(k)] = k\n            k = []\n    return q\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = []\n    r = 0\n    for i in range(n):\n        q = a[i] / b[i]\n        l.append(q)\n        r = max(r, q)\n    d = {}\n    for i in range(n):\n        if l[i] == r:\n            d[i] = 1\n    conn = [[] for i in range(n)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        if u in d:\n            if v in d:\n                conn[u].append(v)\n                conn[v].append(u)\n    visited = [0 for i in range(n)]\n    kk = solve(visited, conn)\n    s = 0\n    j = max(kk)\n    print(j)\n    print(*kk[j])", "for _ in range(int(input())):\n    (n, m) = [int(i) for i in input().split()]\n    l1 = input().split()\n    l2 = input().split()\n    ma = -1\n    coll = []\n    num = [0 for i in range(n + 1)]\n    tra = [[] for i in range(n + 1)]\n    for i in range(n):\n        x = int(l1[i]) / int(l2[i])\n        if x > ma:\n            coll = []\n            ma = x\n            coll.append(i + 1)\n        elif x == ma:\n            coll.append(i + 1)\n    for i in coll:\n        num[i] = 1\n    for i in range(m):\n        (x, y) = [int(kk) for kk in input().split()]\n        if num[x] == 1 and num[y] == 1:\n            tra[x].append(y)\n            tra[y].append(x)\n    numd = [0 for i in range(n + 1)]\n    dub1 = []\n    for i in coll:\n        if numd[i] == 0:\n            l = 0\n            dub2 = [i]\n            numd[i] = 1\n            while l < len(dub2):\n                for k in tra[dub2[l]]:\n                    if numd[k] == 0:\n                        dub2.append(k)\n                        numd[k] = 1\n                l += 1\n            if len(dub2) > len(dub1):\n                dub1 = dub2[:]\n    print(len(dub1))\n    print(*dub1)", "import sys\nsys.setrecursionlimit(1000000)\nd = {}\n\ndef dfs(r, vis, l):\n    for i in range(0, len(d[r])):\n        if vis[d[r][i]] != 1:\n            l.append(d[r][i])\n            vis[d[r][i]] = 1\n            dfs(d[r][i], vis, l)\nt = int(input())\nwhile t:\n    (n, p) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = []\n    max = -1.0\n    for i in range(n):\n        d[i] = []\n        m = a[i] / b[i]\n        if max < m:\n            max = m\n        c.append(a[i] / b[i])\n    m = []\n    f = [0] * n\n    for i in range(n):\n        if max == c[i]:\n            f[i] = 1\n            m.append(i)\n    for i in range(p):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        if f[u] == 1 and f[v] == 1:\n            d[u].append(v)\n            d[v].append(u)\n    visited = [0] * n\n    l = []\n    b = []\n    mx = -1\n    pos = -1\n    for i in range(len(m)):\n        if visited[m[i]] == 0:\n            l.append(m[i])\n            visited[m[i]] = 1\n            x = dfs(m[i], visited, l)\n            if len(l) > mx:\n                mx = len(l)\n                pos = m[i]\n            l = []\n    v = [0] * n\n    b.append(pos)\n    v[pos] = 1\n    x = dfs(pos, v, b)\n    print(len(b))\n    for i in range(len(b)):\n        print(b[i] + 1, end=' ')\n    print()\n    t -= 1", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(u, path, possible):\n    vis[u] = 1\n    possible.add(u)\n    for i in range(0, len(path[u])):\n        if not vis[path[u][i]]:\n            dfs(path[u][i], path, possible)\nt = int(input())\nfor _ in range(0, t):\n    (n, m) = map(int, input().split())\n    aa = [int(i) for i in input().split()]\n    bb = [int(i) for i in input().split()]\n    mx = -1\n    for i in range(0, n):\n        mx = max(mx, aa[i] / bb[i])\n    s = set()\n    for i in range(0, n):\n        if mx == aa[i] / bb[i]:\n            s.add(i + 1)\n    path = [[] for i in range(0, n + 1)]\n    for _ in range(0, m):\n        (u, v) = map(int, input().split())\n        if u in s and v in s:\n            path[u].append(v)\n            path[v].append(u)\n    vis = [0] * (n + 1)\n    ans = []\n    for i in s:\n        possible = set()\n        if not vis[i]:\n            dfs(i, path, possible)\n        if len(possible) > len(ans):\n            ans = list(possible)\n    print(len(ans))\n    print(*sorted(ans))", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef dfs(graph, visited, p, i):\n    if visited[i] == True:\n        return\n    visited[i] = True\n    p.append(i + 1)\n    for v in graph[i]:\n        dfs(graph, visited, p, v)\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    per = []\n    ma = 0\n    for i in range(n):\n        per.append(a[i] / b[i])\n        ma = max(ma, a[i] / b[i])\n    visited = [False] * n\n    for i in range(n):\n        if per[i] != ma:\n            visited[i] = True\n    g = [[] for i in range(n)]\n    for i in range(m):\n        (u, v) = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    ans = []\n    p = []\n    for i in range(n):\n        if visited[i] != True:\n            dfs(g, visited, p, i)\n            if len(p) > len(ans):\n                ans = p\n            p = []\n    print(len(ans))\n    print(*ans)", "import sys\nimport math\nimport collections\nfrom sys import stdin, stdout, setrecursionlimit\nimport bisect as bs\nsetrecursionlimit(2 ** 20)\nM = 10 ** 9 + 7\nT = int(stdin.readline())\nfor _ in range(T):\n    (n, M) = list(map(int, stdin.readline().split()))\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    g = []\n    exp = [False] * (n + 1)\n    for i in range(n + 1):\n        g.append([])\n    arr = []\n    for i in range(n):\n        arr.append(a[i] / b[i])\n    mx = max(arr)\n    d = {}\n    for i in range(n):\n        if arr[i] == mx:\n            d[i + 1] = True\n    for i in range(M):\n        (x, y) = list(map(int, stdin.readline().split()))\n        g[x].append(y)\n        g[y].append(x)\n    ml = 0\n    fin = []\n    for k in d:\n        if exp[k]:\n            continue\n        a = [k]\n        exp[k] = True\n        tmp = [k]\n        while a:\n            u = a.pop()\n            for v in g[u]:\n                if v not in d:\n                    continue\n                if not exp[v]:\n                    tmp.append(v)\n                    exp[v] = True\n                    a.append(v)\n        if len(tmp) > ml:\n            fin = tmp.copy()\n            ml = len(tmp)\n    print(len(fin))\n    for h in fin:\n        print(h, end=' ')\n    print('')", "import sys\nsys.setrecursionlimit(1000000)\n\ndef DFS(v, visited, k, conn):\n    visited[v] = 1\n    k.append(v)\n    for i in conn[v]:\n        if visited[i] == 0:\n            DFS(i, visited, k, conn)\n\ndef solve(visited, conn):\n    q = []\n    k = []\n    for i in d:\n        if visited[i] == 0:\n            DFS(i, visited, k, conn)\n            q.append(k)\n            k = []\n    return q\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = []\n    r = 0\n    for i in range(n):\n        q = a[i] / b[i]\n        l.append(q)\n        r = max(r, q)\n    d = {}\n    for i in range(n):\n        if l[i] == r:\n            d[i] = 1\n    conn = [[] for i in range(n)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        if u in d:\n            if v in d:\n                conn[u].append(v)\n                conn[v].append(u)\n    visited = [0 for i in range(n)]\n    kk = solve(visited, conn)\n    s = 0\n    for i in kk:\n        s = max(s, len(i))\n    print(s)\n    for i in kk:\n        if len(i) == s:\n            for j in i:\n                print(j + 1, end=' ')\n            print()\n            break", "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom collections import defaultdict as dft\n\ndef dfs(nd, s):\n    s.append(nd)\n    vis[nd] = 1\n    for lnk in dct[nd]:\n        if choose[lnk] and vis[lnk] == 0:\n            dfs(lnk, s)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    mx = 0\n    choose = [0] * (n + 1)\n    num = a[0]\n    deno = b[0]\n    for i in range(n):\n        if a[i] * deno > b[i] * num:\n            (num, deno) = (a[i], b[i])\n    for i in range(1, n + 1):\n        if a[i - 1] * deno == b[i - 1] * num:\n            choose[i] = 1\n    dct = dft(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        dct[u].append(v)\n        dct[v].append(u)\n    vis = [0] * (n + 1)\n    res = []\n    for x in range(1, n + 1):\n        if choose[x] and (not vis[x]):\n            s = []\n            dfs(x, s)\n            if len(s) > len(res):\n                res = s[:]\n    print(len(res))\n    print(*res)", "import math as mt\nimport sys, string\ninput = sys.stdin.readline\nprint = sys.stdout.write\nL = lambda : list(map(int, input().split()))\nLs = lambda : list(input().split())\nM = lambda : map(int, input().split())\nI = lambda : int(input())\nfrom collections import defaultdict\nd = [0] * (2 * 10 ** 5)\nvis = [0] * (2 * 10 ** 5)\nt = I()\nfor _ in range(t):\n    (n, m) = M()\n    l = L()\n    x = L()\n    adj = []\n    for i in range(n):\n        adj.append([])\n    mi = 0\n    for i in range(n):\n        g = mt.gcd(l[i], x[i])\n        l[i] //= g\n        x[i] //= g\n        mi = max(mi, l[i] / x[i])\n    v = []\n    for i in range(n):\n        if l[i] / x[i] == mi:\n            d[i] = 1\n            v.append(i)\n    for i in range(m):\n        (a, b) = M()\n        if d[b - 1] == 1 and d[a - 1] == 1:\n            adj[b - 1].append(a - 1)\n            adj[a - 1].append(b - 1)\n    ans = 0\n    req = []\n    for i in v:\n        if vis[i] == 0:\n            c = 1\n            result = []\n            x = [i]\n            result.append(i + 1)\n            while len(x) != 0:\n                y = x.pop(0)\n                vis[y] = 1\n                for j in adj[y]:\n                    if vis[j] == 0:\n                        c += 1\n                        vis[j] = 1\n                        x.append(j)\n                        result.append(j + 1)\n        if c > ans:\n            ans = c\n            req = result[:]\n    for i in v:\n        d[i] = 0\n        vis[i] = 0\n    print(str(len(req)) + '\\n')\n    for i in req:\n        print(str(i) + ' ')\n    print('\\n')", "import sys, io, os, time\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import deque\nfrom itertools import combinations\nfrom itertools import permutations\nimport bisect, math, heapq\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(node, g, path, nvisited):\n    path.append(node)\n    nvisited[node] = False\n    for nei in g[node]:\n        if nvisited[nei]:\n            dfs(nei, g, path, nvisited)\nfor ii in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    g = defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    nvisited = [False] * (n + 1)\n    maxCapita = -1\n    for i in range(n):\n        maxCapita = max(maxCapita, A[i] / B[i])\n    for i in range(n):\n        if A[i] / B[i] == maxCapita:\n            nvisited[i] = True\n    res = []\n    for i in range(n):\n        if nvisited[i]:\n            path = []\n            dfs(i, g, path, nvisited)\n            if len(path) > len(res):\n                res = path\n    print(len(res))\n    for i in res:\n        print(i + 1, end=' ')\n    print()", "from collections import defaultdict, deque\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    money = list(map(int, input().split()))\n    population = list(map(int, input().split()))\n    avg = []\n    check = [False]\n    for i in range(n):\n        avg.append((money[i] / population[i], i + 1))\n        check.append(False)\n    avg.sort(reverse=True)\n    maxi = avg[0][0]\n    start = avg[0][1]\n    starts = []\n    for i in range(n):\n        if avg[i][0] == maxi:\n            check[avg[i][1]] = True\n            starts.append(avg[i][1])\n            start = avg[i][1]\n    if start == avg[0][1]:\n        print(1)\n        print(*starts)\n    else:\n        arr = [[] for i in range(n + 1)]\n        for i in range(m):\n            (x, y) = map(int, input().split())\n            arr[x].append(y)\n            arr[y].append(x)\n        dic = defaultdict(list)\n        vis = [False] * (n + 1)\n        mx_len = 0\n        for i in starts:\n            if vis[i] == False:\n                q = deque()\n                q.append(i)\n                while q:\n                    p = q.popleft()\n                    vis[p] = True\n                    for j in arr[p]:\n                        if check[j] and vis[j] == False:\n                            vis[j] = True\n                            q.append(j)\n                            dic[i].append(j)\n                            mx_len = max(mx_len, len(dic[i]))\n        for i in dic:\n            if len(dic[i]) == mx_len:\n                print(mx_len + 1)\n                print(i, *dic[i])\n                break", "import sys\nimport random\n\nclass DSU:\n\n    def __init__(self, n):\n        self.n = n\n        self.comps = n\n        self.parent = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n\n    def FIND(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.FIND(self.parent[x])\n        return self.parent[x]\n\n    def getSize(self, x):\n        return self.size[self.FIND(x)]\n\n    def UNION(self, x, y):\n        xRoot = self.FIND(x)\n        yRoot = self.FIND(y)\n        if xRoot != yRoot:\n            self.comps -= 1\n            if random.randint(1, 100) & 1:\n                self.parent[xRoot] = yRoot\n                self.size[yRoot] += self.size[xRoot]\n            else:\n                self.parent[yRoot] = xRoot\n                self.size[xRoot] += self.size[yRoot]\n            return 1\n        return 0\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    income = [int(x) for x in input().split()]\n    population = [int(x) for x in input().split()]\n    edges = []\n    for x in range(m):\n        (u, v) = map(int, input().split())\n        edges.append([u, v])\n    best = [0]\n    for x in range(1, n):\n        j = best[0]\n        if income[j] * population[x] < income[x] * population[j]:\n            best = [x]\n        elif income[j] * population[x] == income[x] * population[j]:\n            best.append(x)\n    consider = [None for x in range(n)]\n    for item in best:\n        consider[item] = 1\n    dsu = DSU(n)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if consider[u] and consider[v]:\n            dsu.UNION(u, v)\n    parents = {}\n    for item in best:\n        p = dsu.FIND(item)\n        if p in parents:\n            parents[p].append(str(item + 1))\n        else:\n            parents[p] = [str(item + 1)]\n    p = max(parents, key=lambda k: len(parents[k]))\n    print(len(parents[p]))\n    print(' '.join(parents[p]))", "from collections import defaultdict\nt = int(input())\nwhile t:\n    (n, m) = map(int, input().split())\n    incomes = list(map(int, input().split()))\n    pop = list(map(int, input().split()))\n    graph = defaultdict(list)\n    seen = set()\n    choose = set()\n    (num, den) = (incomes[0], pop[0])\n    res = []\n    for i in range(1, n):\n        if incomes[i] // pop[i] > num // den:\n            num = incomes[i]\n            den = pop[i]\n    for i in range(n):\n        if incomes[i] // pop[i] == num // den:\n            choose.add(i)\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        if u - 1 in choose and v - 1 in choose:\n            graph[u - 1].append(v - 1)\n            graph[v - 1].append(u - 1)\n    for i in range(n):\n        if i in choose and i not in seen:\n            provinces = [i + 1]\n            stack = [i]\n            seen.add(i)\n            while stack:\n                node = stack.pop()\n                for nei in graph[node]:\n                    if nei not in seen:\n                        seen.add(nei)\n                        provinces.append(nei + 1)\n                        stack.append(nei)\n            if len(provinces) > len(res):\n                res = provinces\n    print(len(res))\n    print(*res)\n    t -= 1", "from collections import defaultdict\nimport sys\nt = int(input())\nwhile t:\n    (n, m) = map(int, sys.stdin.readline().split())\n    incomes = list(map(int, sys.stdin.readline().split()))\n    pop = list(map(int, sys.stdin.readline().split()))\n    graph = defaultdict(list)\n    seen = set()\n    choose = set()\n    (num, den) = (incomes[0], pop[0])\n    res = []\n    for i in range(1, n):\n        if incomes[i] // pop[i] > num // den:\n            num = incomes[i]\n            den = pop[i]\n    for i in range(n):\n        if incomes[i] // pop[i] == num // den:\n            choose.add(i)\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        if u - 1 in choose and v - 1 in choose:\n            graph[u - 1].append(v - 1)\n            graph[v - 1].append(u - 1)\n    for i in range(n):\n        if i in choose and i not in seen:\n            provinces = [i + 1]\n            stack = [i]\n            seen.add(i)\n            while stack:\n                node = stack.pop()\n                for nei in graph[node]:\n                    if nei not in seen:\n                        seen.add(nei)\n                        provinces.append(nei + 1)\n                        stack.append(nei)\n            if len(provinces) > len(res):\n                res = provinces\n    print(len(res))\n    print(*res)\n    t -= 1", "from collections import defaultdict\nimport sys\nt = int(input())\nwhile t:\n    (n, m) = map(int, sys.stdin.readline().split())\n    incomes = list(map(int, sys.stdin.readline().split()))\n    pop = list(map(int, sys.stdin.readline().split()))\n    graph = defaultdict(list)\n    seen = set()\n    choose = set()\n    (num, den) = (incomes[0], pop[0])\n    res = []\n    for i in range(1, n):\n        if incomes[i] // pop[i] > num // den:\n            num = incomes[i]\n            den = pop[i]\n    for i in range(n):\n        if incomes[i] // pop[i] == num // den:\n            choose.add(i)\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        if u - 1 in choose and v - 1 in choose:\n            graph[u - 1].append(v - 1)\n            graph[v - 1].append(u - 1)\n    for i in range(n):\n        if i in choose and i not in seen:\n            provinces = [i + 1]\n            stack = [i]\n            seen.add(i)\n            while stack:\n                node = stack.pop()\n                for nei in graph[node]:\n                    if nei not in seen:\n                        seen.add(nei)\n                        provinces.append(nei + 1)\n                        stack.append(nei)\n            if len(provinces) > len(res):\n                res = provinces\n    print(len(res))\n    print(*res)\n    t -= 1", "from collections import defaultdict\nt = int(input())\nwhile t:\n    (n, m) = map(int, input().split())\n    incomes = list(map(int, input().split()))\n    pop = list(map(int, input().split()))\n    graph = defaultdict(list)\n    seen = set()\n    choose = set()\n    (num, den) = (incomes[0], pop[0])\n    res = []\n    for i in range(1, n):\n        if incomes[i] // pop[i] > num // den:\n            num = incomes[i]\n            den = pop[i]\n    for i in range(n):\n        if incomes[i] // pop[i] == num // den:\n            choose.add(i)\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        if u - 1 in choose and v - 1 in choose:\n            graph[u - 1].append(v - 1)\n            graph[v - 1].append(u - 1)\n    for i in range(n):\n        if i in choose and i not in seen:\n            provinces = [i + 1]\n            stack = [i]\n            seen.add(i)\n            while stack:\n                node = stack.pop()\n                for nei in graph[node]:\n                    if nei not in seen:\n                        seen.add(nei)\n                        provinces.append(nei + 1)\n                        stack.append(nei)\n            if len(provinces) > len(res):\n                res = provinces\n    print(len(res))\n    print(*res)\n    t -= 1", "import sys\nsys.setrecursionlimit(1000000000)\nimport math\nfrom sys import stdin, stdout\nfrom collections import deque, defaultdict\nfrom math import ceil, floor, inf, sqrt, factorial, gcd, log2\nfrom copy import deepcopy\nii1 = lambda : int(stdin.readline().strip())\nis1 = lambda : stdin.readline().strip()\niia = lambda : list(map(int, stdin.readline().strip().split()))\nisa = lambda : stdin.readline().strip().split()\nmod = 1000000007\n\ndef dfs(u):\n    if vis[u]:\n        return\n    vis[u] = True\n    local_sol.append(u + 1)\n    for v in graph[u]:\n        dfs(v)\n\ndef takeinput(n, q):\n    graph = [[] for i in range(n)]\n    for i in range(q):\n        (u, v) = iia()\n        graph[v - 1].append(u - 1)\n        graph[u - 1].append(v - 1)\n    return graph\nt = ii1()\nfor _ in range(t):\n    (n, q) = iia()\n    A = iia()\n    B = iia()\n    C = [A[i] // B[i] for i in range(n)]\n    graph = takeinput(n, q)\n    maxi = max(C)\n    vis = [False] * n\n    for i in range(n):\n        if C[i] != maxi:\n            vis[i] = True\n    local_sol = []\n    global_sol = []\n    for u in range(n):\n        if vis[u] == False:\n            dfs(u)\n            if len(local_sol) > len(global_sol):\n                global_sol = local_sol\n            local_sol = []\n    print(len(global_sol))\n    print(*global_sol)"]