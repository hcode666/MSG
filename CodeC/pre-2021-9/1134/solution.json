["for _ in range(int(input())):\n    temp = int(input())\n    global_list = []\n    for __ in range(temp):\n        (aa, *cache) = map(int, input().split())\n        global_list.append(cache)\n    memory = list(map(int, input().split()))\n    ans = 'Yes'\n    for i in global_list:\n        for j in memory:\n            if len(i) and i[-1] == j:\n                del i[-1]\n        if i != []:\n            ans = 'No'\n            break\n    print(ans)", "for _ in range(int(input())):\n    temp = int(input())\n    global_list = []\n    for __ in range(temp):\n        (aa, *cache) = map(int, input().split())\n        global_list.append(cache)\n    memory = list(map(int, input().split()))\n    ans = 'Yes'\n    for i in global_list:\n        for j in memory:\n            if len(i) and i[-1] == j:\n                del i[-1]\n        if i != []:\n            ans = 'No'\n            break\n    print(ans)", "for _ in range(int(input())):\n    temp = int(input())\n    global_list = []\n    for __ in range(temp):\n        (aa, *cache) = map(int, input().split())\n        global_list.append(cache)\n    memory = list(map(int, input().split()))\n    ans = 'Yes'\n    for i in global_list:\n        for j in memory:\n            if len(i) and i[-1] == j:\n                del i[-1]\n        if i != []:\n            ans = 'No'\n            break\n    print(ans)", "for _ in range(int(input())):\n    N = int(input())\n    global_list = []\n    for __ in range(N):\n        (aa, *cache) = map(int, input().split())\n        global_list.append(cache)\n    memory = list(map(int, input().split()))\n    ans = 'Yes'\n    for a in global_list:\n        for b in memory:\n            if len(a) and a[-1] == b:\n                del a[-1]\n        if a != []:\n            ans = 'No'\n            break\n    print(ans)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef check(thread, stak):\n    if not stak:\n        return True\n    for th in thread:\n        if th and th[-1] == stak[-1]:\n            t = stack.pop()\n            th.pop()\n            if check(thread, stak):\n                return True\n            th.append(t)\n            stak.append(t)\n    return False\nfor _ in range(int(input())):\n    threads = list()\n    tn = int(input())\n    for i in range(tn):\n        line = list(map(int, input().split()))\n        threads.append(line[1:][::-1])\n    stack = list(map(int, input().split()))\n    if check(threads, stack):\n        print('Yes')\n    else:\n        print('No')", "import heapq\nfor _ in range(int(input())):\n    N = int(input())\n    data = []\n    for _ in range(N):\n        data.append([int(num) for num in input().split()[1:]])\n    sequence = [int(num) for num in input().split()]\n    queue = [(len(sequence) - 1, [0] * N)]\n    while len(queue):\n        (cur_pos, cur_state) = heapq.heappop(queue)\n        if cur_pos == 0:\n            print('Yes')\n            break\n        for n in range(N):\n            thread_idx = cur_state[n]\n            if thread_idx == len(data[n]):\n                continue\n            if sequence[cur_pos] == data[n][thread_idx]:\n                cur_state_copy = cur_state.copy()\n                cur_state_copy[n] += 1\n                heapq.heappush(queue, (cur_pos - 1, cur_state_copy))\n    else:\n        print('No')", "import heapq\nfor _ in range(int(input())):\n    threads_amount = int(input())\n    data = []\n    for _ in range(threads_amount):\n        data.append([int(num) for num in input().split()[1:]])\n    sequence = [int(num) for num in input().split()]\n    queue = [(len(sequence) - 1, [0] * threads_amount)]\n    while len(queue):\n        (seq_idx, indices) = heapq.heappop(queue)\n        if seq_idx == 0:\n            print('Yes')\n            break\n        for thread_num in range(threads_amount):\n            thread_idx = indices[thread_num]\n            if thread_idx == len(data[thread_num]):\n                continue\n            if sequence[seq_idx] == data[thread_num][thread_idx]:\n                indices_copy = indices.copy()\n                indices_copy[thread_num] += 1\n                heapq.heappush(queue, (seq_idx - 1, indices_copy))\n    else:\n        print('No')", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef is_valid_stack(thread_lists, stack):\n    if not stack:\n        return True\n    for thread_list in thread_lists:\n        if thread_list and thread_list[-1] == stack[-1]:\n            thread_list.pop()\n            popped_ele = stack.pop()\n            if is_valid_stack(thread_lists, stack):\n                return True\n            thread_list.append(popped_ele)\n            stack.append(popped_ele)\n    return False\nfor _ in range(int(input())):\n    num_threads = int(input())\n    thread_lists = []\n    for i in range(num_threads):\n        thread_lists.append(list(map(int, input().split()))[1:][::-1])\n    stack = list(map(int, input().split()))\n    print('Yes' if is_valid_stack(thread_lists, stack) else 'No')", "for _ in range(int(input())):\n    N = int(input())\n    global_list = []\n    for __ in range(N):\n        (aa, *cache) = map(int, input().split())\n        global_list.append(cache)\n    memory = list(map(int, input().split()))\n    ans = 'Yes'\n    for a in global_list:\n        for b in memory:\n            if len(a) and a[-1] == b:\n                a.pop()\n        if a != []:\n            ans = 'No'\n            break\n    print(ans)", "for _ in range(int(input())):\n    N = int(input())\n    global_list = []\n    for __ in range(N):\n        (aa, *cache) = map(int, input().split())\n        global_list.append(cache)\n    memory = list(map(int, input().split()))\n    ans = 'Yes'\n    for a in global_list:\n        for b in memory:\n            if len(a) and a[-1] == b:\n                a.pop()\n        if a != []:\n            ans = 'No'\n            break\n    print(ans)", "for _ in range(int(input())):\n    N = int(input())\n    global_list = []\n    for __ in range(N):\n        (aa, *cache) = map(int, input().split())\n        global_list.append(cache)\n    memory = list(map(int, input().split()))\n    ans = 'Yes'\n    for a in global_list:\n        for b in memory:\n            if len(a) and a[-1] == b:\n                del a[-1]\n        if a != []:\n            ans = 'No'\n            break\n    print(ans)", "import sys\nimport time\ninput_lines = [line.strip() for line in sys.stdin.readlines() if line.strip()]\nC = int(input_lines[0])\n\ndef problem(threads, output):\n    if len(output) == 0:\n        if sum([len(t) for t in threads]) > 0:\n            return 0\n        else:\n            return 1\n    else:\n        res = 0\n        for tid in range(len(threads)):\n            if len(threads[tid]) > 0 and threads[tid][-1] == output[0]:\n                res += problem(threads[:tid] + [threads[tid][:-1]] + threads[tid + 1:], output[1:])\n                if res > 0:\n                    break\n        if res > 0:\n            return 1\n        else:\n            return 0\nt = 0\ncid = 0\nwhile cid < C:\n    num_threads = int(input_lines[t + 1])\n    step = num_threads + 2\n    threads = []\n    for line in input_lines[t + 2:t + 2 + num_threads]:\n        threads.append(line.split()[1:])\n    output = input_lines[t + 2 + num_threads].split()\n    if num_threads == 1:\n        if output[::-1] == threads[0]:\n            print('Yes')\n        else:\n            print('No')\n    else:\n        res = problem(threads, output)\n        if res > 0:\n            print('Yes')\n        else:\n            print('No')\n    t += step\n    cid += 1", "try:\n    for _ in range(int(input())):\n        N = int(input())\n        global_list = []\n        for __ in range(N):\n            (aa, *cache) = map(int, input().split())\n            global_list.append(cache)\n        memory = list(map(int, input().split()))\n        ans = 'Yes'\n        for a in global_list:\n            for b in memory:\n                if len(a) and a[-1] == b:\n                    del a[-1]\n            if a != []:\n                ans = 'No'\n                break\n        print(ans)\nexcept:\n    pass", "for _ in range(int(input())):\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(list(map(int, input().split()[1:])))\n    x = list(map(int, input().split()))\n    ans = 'Yes'\n    for a in s:\n        for b in x:\n            if len(a) and a[-1] == b:\n                del a[-1]\n        if a != []:\n            ans = 'No'\n            break\n    print(ans)", "def rec(f, l, n):\n    if len(f) == 0:\n        return True\n    else:\n        for i in range(n):\n            if len(l[i]) > 0 and l[i][0] == f[0]:\n                l[i] = l[i][1:]\n                if rec(f[1:], l, n):\n                    return True\n                else:\n                    l[i] = [f[0]] + l[i]\n        return False\nfor i in range(int(input())):\n    n = int(input())\n    if n == 1:\n        a = list(map(int, input().split()))[1:]\n        f = list(map(int, input().split()))[::-1]\n        if a == f:\n            print('Yes')\n        else:\n            print('No')\n    else:\n        l = []\n        for j in range(n):\n            l.append(list(map(int, input().split()))[1:])\n        f = list(map(int, input().split()))[::-1]\n        if rec(f, l, n):\n            print('Yes')\n        else:\n            print('No')", "def rec(f, l, n):\n    if len(f) == 0:\n        return True\n    else:\n        for i in range(n):\n            if len(l[i]) > 0 and l[i][0] == f[0]:\n                l[i] = l[i][1:]\n                if rec(f[1:], l, n):\n                    return True\n                else:\n                    l[i] = [f[0]] + l[i]\n        return False\nfor i in range(int(input())):\n    n = int(input())\n    if n == 1:\n        a = list(map(int, input().split()))[1:]\n        f = list(map(int, input().split()))[::-1]\n        if a == f:\n            print('Yes')\n        else:\n            print('No')\n    else:\n        l = []\n        for j in range(n):\n            l.append(list(map(int, input().split()))[1:])\n        f = list(map(int, input().split()))[::-1]\n        if rec(f, l, n):\n            print('Yes')\n        else:\n            print('No')", "for _ in range(int(input())):\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(list(map(int, input().split()[1:])))\n    x = list(map(int, input().split()))\n    ans = 'Yes'\n    for a in s:\n        for b in x:\n            if len(a) and a[-1] == b:\n                del a[-1]\n        if a != []:\n            ans = 'No'\n            break\n    print(ans)", "for _ in range(int(input())):\n    threads = []\n    for _ in range(int(input())):\n        threads.append(list(map(int, input().split()))[1:])\n    a = list(map(int, input().split()))\n    ans = 'Yes'\n    for thread in threads:\n        for each in a:\n            if thread and each == thread[-1]:\n                del thread[-1]\n        if thread:\n            ans = 'No'\n            break\n    print(ans)", "def isValidOutput(stack_list, input_result):\n    if not input_result:\n        return True\n    for element in stack_list:\n        if element[element[0]] == input_result[0]:\n            element[0] -= 1\n            result_op = input_result.pop(0)\n            if isValidOutput(stack_list, input_result):\n                return True\n            else:\n                element[0] += 1\n                input_result.insert(0, result_op)\n    return False\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        num_stacks = int(input())\n        stacks = []\n        i = 0\n        while i < num_stacks:\n            stacks.append(list(map(int, input().split())))\n            i += 1\n        output_string = list(map(int, input().split()))\n        if num_stacks == 1:\n            stacks[0].reverse()\n            stacks[0].pop()\n            if stacks[0] == output_string:\n                print('Yes')\n            else:\n                print('No')\n            continue\n        if isValidOutput(stacks, output_string):\n            print('Yes')\n        else:\n            print('No')\nmain()", "def abc(currstack, array):\n    if len(array) == 0:\n        return True\n    for x in currstack:\n        if x[0] == 0:\n            continue\n        elif x[x[0]] == array[0]:\n            y = array.pop(0)\n            x[0] -= 1\n            if abc(currstack, array):\n                return True\n            else:\n                array.insert(0, y)\n                x[0] += 1\n    return False\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    stacks = []\n    for x in range(N):\n        stacks.append(list(map(int, input().split())))\n    finalarray = list(map(int, input().split()))\n    if N == 1:\n        newstack = stacks[0]\n        newstack.pop(0)\n        newstack.reverse()\n        if newstack == finalarray:\n            print('Yes')\n        else:\n            print('No')\n    elif abc(stacks, finalarray):\n        print('Yes')\n    else:\n        print('No')", "T = int(input())\nwhile T > 0:\n    lis = []\n    for _ in range(int(input())):\n        lis.append(list(map(int, input().split()))[1:])\n    a = list(map(int, input().split()))\n    ans = 'Yes'\n    for thread in lis:\n        for each in a:\n            if len(thread) and each == thread[-1]:\n                del thread[-1]\n        if len(thread) != 0:\n            ans = 'No'\n            break\n    print(ans)\n    T = T - 1", "def solve(stacks, arr, index, refs):\n    if index >= len(arr):\n        return True\n    ans = False\n    for (ind, l) in enumerate(stacks):\n        if isinstance(l, list) and refs[ind] >= 0 and (arr[index] == l[refs[ind]]):\n            refs[ind] -= 1\n            ans = solve(stacks, arr, index + 1, refs)\n            refs[ind] += 1\n            if ans:\n                return True\n    return ans\nfrom sys import stdin, setrecursionlimit\nsetrecursionlimit(10 ** 9)\nfor i in range(int(input())):\n    threads = int(input())\n    stacks = []\n    refs = []\n    for j in range(threads):\n        temparr = list(map(int, input().strip().split()[1:]))\n        refs.append(len(temparr) - 1)\n        stacks.append(temparr)\n    arrList = list(map(int, input().strip().split(' ')))\n    print('Yes' if solve(stacks, arrList, 0, refs) else 'No')", "for i in range(int(input())):\n    threads = int(input())\n    stacks = []\n    for j in range(threads):\n        stacks.append(list(map(int, input().strip().split()[1:])))\n    arrList = list(map(int, input().strip().split(' ')))\n    ans = 'Yes'\n    for l in stacks:\n        for x in arrList:\n            if len(l) and x == l[-1]:\n                del l[-1]\n        if l != []:\n            ans = 'No'\n            break\n    print(ans)", "def rec_ans(ptrs, data, stp, st):\n    if stp == -1:\n        return True\n    for i in range(len(ptrs)):\n        if ptrs[i] < len(data[i]) and data[i][ptrs[i]] == st[stp]:\n            ptrs[i] += 1\n            if rec_ans(ptrs, data, stp - 1, st):\n                return True\n            ptrs[i] -= 1\n    return False\nfrom sys import stdin, setrecursionlimit\nsetrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    n = int(input())\n    data = []\n    ptrs = [1] * n\n    for i in range(n):\n        data.append(list(map(int, stdin.readline().strip().split())))\n    st = list(map(int, stdin.readline().strip().split()))\n    if rec_ans(ptrs, data, len(st) - 1, st):\n        print('Yes')\n    else:\n        print('No')", "t = int(input())\nfor l in range(t):\n    n = int(input())\n    stack = []\n    for i in range(n):\n        l = [int(i) for i in input().split()]\n        stack.append(l)\n    output = [int(i) for i in input().split()]\n    l1 = [1] * n\n    ok = []\n    for i in range(1, len(output) + 1):\n        for j in range(n):\n            if l1[j] <= stack[j][0]:\n                if output[-i] == stack[j][l1[j]]:\n                    ok.append(stack[j][l1[j]])\n                    l1[j] += 1\n    if len(ok) == len(output):\n        print('Yes')\n    else:\n        print('No')", "for _ in range(int(input())):\n    n = int(input())\n    b = []\n    for _ in range(n):\n        b.append(list(map(int, input().split()))[1:])\n    a = list(map(int, input().split()))\n    ans = 'Yes'\n    for thread in b:\n        for each in a:\n            if len(thread) and each == thread[-1]:\n                del thread[-1]\n        if len(thread) != 0:\n            ans = 'No'\n            break\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    b = []\n    for _ in range(n):\n        b.append(list(map(int, input().split()))[1:])\n    a = list(map(int, input().split()))\n    ans = 'Yes'\n    for thread in b:\n        for each in a:\n            if len(thread) and each == thread[-1]:\n                del thread[-1]\n        if len(thread) != 0:\n            ans = 'No'\n            break\n    print(ans)", "import copy\n\ndef popper(a, b, n):\n    if len(b) == 0:\n        return 'Yes'\n    for i in range(0, n):\n        if len(a[i]) > 0 and a[i][0] == b[0]:\n            a[i] = a[i][1:]\n            if popper(a, b[1:], n) == 'Yes':\n                return 'Yes'\n            else:\n                a[i] = [b[0]] + a[i]\n    return 'No'\nfor t in range(int(input())):\n    n = int(input())\n    a = []\n    for tmp in range(n):\n        tmp1 = [int(num) for num in input().split(' ')]\n        a.append(copy.deepcopy(tmp1)[1:])\n    b = [int(op) for op in input().split(' ')]\n    b = b[::-1]\n    if n == 1:\n        if a[0] == b:\n            print('Yes')\n        else:\n            print('No')\n    else:\n        print(popper(a, b, n))", "for _ in range(int(input())):\n    n = int(input())\n    b = [[*map(int, input().split())][1:] for _ in range(n)]\n    s = [*map(int, input().split())]\n    ans = 'Yes'\n    for i in b:\n        for j in s:\n            if len(i) and j == i[-1]:\n                del i[-1]\n        if i != []:\n            ans = 'No'\n            break\n    print(ans)", "def rec_ans(ptrs, data, stp, st):\n    if stp == -1:\n        return True\n    for i in range(len(ptrs)):\n        if ptrs[i] < len(data[i]) and data[i][ptrs[i]] == st[stp]:\n            ptrs[i] += 1\n            if rec_ans(ptrs, data, stp - 1, st):\n                return True\n            ptrs[i] -= 1\n    return False\nfrom sys import stdin, setrecursionlimit\nsetrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n    n = int(input())\n    data = []\n    ptrs = [1] * n\n    for i in range(n):\n        data.append(list(map(int, stdin.readline().strip().split())))\n    st = list(map(int, stdin.readline().strip().split()))\n    if rec_ans(ptrs, data, len(st) - 1, st):\n        print('Yes')\n    else:\n        print('No')", "def check(a, b, n):\n    if len(b) == 0:\n        return 'Yes'\n    for i in range(0, n):\n        if len(a[i]) > 0 and a[i][0] == b[0]:\n            a[i] = a[i][1:]\n            if check(a, b[1:], n) == 'Yes':\n                return 'Yes'\n            else:\n                a[i] = [b[0]] + a[i]\n    return 'No'\nt = int(input())\nfor ijk in range(0, t):\n    n = int(input())\n    a = []\n    for i in range(0, n):\n        a.append(list(map(int, input().strip().split()))[1:])\n    b = list(map(int, input().strip().split()))[::-1]\n    if n == 1:\n        if a[0] == b:\n            print('Yes')\n        else:\n            print('No')\n    else:\n        print(check(a, b, n))", "def checkPossible(rev, k, n):\n    if len(rev) == 0:\n        return True\n    else:\n        for i in range(n):\n            if len(k[i]) > 0 and k[i][0] == rev[0]:\n                k[i] = k[i][1:]\n                if checkPossible(rev[1:], k, n):\n                    return True\n                else:\n                    k[i] = [rev[0]] + k[i]\n        return False\nfor i in range(int(input())):\n    n = int(input())\n    if n == 1:\n        a = list(map(int, input().split()))[1:]\n        b = list(map(int, input().split()))[::-1]\n        if a == b:\n            print('Yes')\n        else:\n            print('No')\n    else:\n        k = []\n        for j in range(n):\n            k.append(list(map(int, input().split()))[1:])\n        rev = list(map(int, input().split()))[::-1]\n        if checkPossible(rev, k, n):\n            print('Yes')\n        else:\n            print('No')", "def rec(f, l, n):\n    if len(f) == 0:\n        return True\n    else:\n        for i in range(n):\n            if len(l[i]) > 0 and l[i][0] == f[0]:\n                l[i] = l[i][1:]\n                if rec(f[1:], l, n):\n                    return True\n                else:\n                    l[i] = [f[0]] + l[i]\n        return False\nfor i in range(int(input())):\n    n = int(input())\n    if n == 1:\n        a = list(map(int, input().split()))[1:]\n        f = list(map(int, input().split()))[::-1]\n        if a == f:\n            print('Yes')\n        else:\n            print('No')\n    else:\n        l = []\n        for j in range(n):\n            l.append(list(map(int, input().split()))[1:])\n        f = list(map(int, input().split()))[::-1]\n        if rec(f, l, n):\n            print('Yes')\n        else:\n            print('No')", "for _ in range(int(input())):\n    n = int(input())\n    threads = [None] * n\n    for i in range(n):\n        threads[i] = [int(o) for o in input().split()]\n    stack = [int(p) for p in input().split()]\n    size = [threads[i][0] for i in range(n)]\n    for j in stack:\n        for k in range(n):\n            if size[k] != 0:\n                if j == threads[k][size[k]]:\n                    size[k] -= 1\n    print('Yes' if size.count(0) == n else 'No')", "for i in range(int(input())):\n    n = int(input())\n    threads = []\n    for i in range(n):\n        threads.append(list(map(int, input().split())))\n    stack = list(map(int, input().split()))\n    size = []\n    for s in range(len(threads)):\n        size.append(threads[s][0])\n    for j in stack:\n        for k in range(n):\n            if size[k] != 0:\n                if j == threads[k][size[k]]:\n                    size[k] -= 1\n    if size.count(0) == n:\n        print('Yes')\n    else:\n        print('No')", "for _ in range(int(input())):\n    n = int(input())\n    sz = list()\n    ls = list()\n    for i in range(n):\n        ls.append(list(map(int, input().split())))\n        sz.append(ls[i][0])\n        ls[i].pop(0)\n    q = list(map(int, input().split()))\n    for i in q:\n        for k in range(n):\n            if sz[k] != 0:\n                if ls[k][sz[k] - 1] == i:\n                    sz[k] -= 1\n    flag = True\n    for i in range(n):\n        if sz[i] != 0:\n            flag = False\n            break\n    print('Yes') if flag else print('No')", "for _ in range(int(input())):\n    n = int(input())\n    sz = list()\n    ls = list()\n    for i in range(n):\n        ls.append(list(map(int, input().split())))\n        sz.append(ls[i][0])\n        ls[i].pop(0)\n    q = list(map(int, input().split()))\n    flag = True\n    for i in q:\n        for k in range(n):\n            if sz[k] != 0:\n                if ls[k][sz[k] - 1] == i:\n                    sz[k] -= 1\n    for i in range(n):\n        if sz[i] != 0:\n            flag = False\n            break\n    print('Yes') if flag else print('No')", "for i in range(int(input())):\n    n = int(input())\n    threads = []\n    for i in range(n):\n        threads.append(list(map(int, input().split())))\n    seq = list(map(int, input().split()))\n    state = []\n    for e in range(len(threads)):\n        state.append(threads[e][0])\n    for j in seq:\n        for k in range(n):\n            if state[k] != 0:\n                if j == threads[k][state[k]]:\n                    state[k] -= 1\n    if state.count(0) == n:\n        print('Yes')\n    else:\n        print('No')", "for _ in range(int(input())):\n    n = int(input())\n    ls = list()\n    sz = list()\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        sz.append(temp[0])\n        ls.append(temp[1:])\n    flag = True\n    q = list(map(int, input().split()))\n    for i in q:\n        for k in range(n):\n            if sz[k] != 0:\n                if ls[k][sz[k] - 1] == i:\n                    sz[k] -= 1\n    for i in range(n):\n        if sz[i] != 0:\n            flag = False\n            break\n    print('Yes') if flag else print('No')", "for _ in range(int(input())):\n    (n, total) = (int(input()), 0)\n    ls = list()\n    sz = list()\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        sz.append(temp[0])\n        total += temp[0]\n        temp.pop(0)\n        ls.append(temp)\n    q = list(map(int, input().split()))\n    q.reverse()\n    flag = True\n    for i in range(n):\n        (start, end) = (0, sz[i])\n        for j in range(total):\n            if start == end:\n                break\n            if q[j] == ls[i][start]:\n                start += 1\n        if start < end:\n            flag = False\n            break\n    print('Yes') if flag else print('No')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    l1 = []\n    for _ in range(n):\n        l = list(map(int, input().split()))\n        l.pop(0)\n        l1.append(l)\n    final_list = list(map(int, input().split()))\n    final_list1 = final_list[::-1]\n    ans = True\n    for i in range(len(l1)):\n        k = 0\n        for j in range(len(final_list1)):\n            if l1[i][k] == final_list1[j]:\n                k += 1\n                if k == len(l1[i]):\n                    break\n        if k != len(l1[i]):\n            ans = False\n            break\n    if ans:\n        print('Yes')\n    else:\n        print('No')", "def find_next(s, aa, l, c):\n    e = 0\n    for i in range(len(aa)):\n        if len(aa[i]) > 0:\n            e += 1\n            break\n    if e == 0 or l >= len(s):\n        if c > len(s):\n            return -1\n        else:\n            return c\n    for i in range(len(aa)):\n        if len(aa[i]) > 0 and l <= len(s) - 1 and (aa[i][-1] == s[l]):\n            aaa = []\n            for j in range(len(aa)):\n                if j != i:\n                    aaa.append([k for k in aa[j]])\n                elif len(aa[j]) > 0:\n                    aaa.append([k for k in aa[j][:-1]])\n            c = find_next(s, aaa, l + 1, c + 1)\n            if c == len(s):\n                return c\n            else:\n                c -= 1\n                continue\n    return c\nt = int(input())\nfor _ in range(t):\n    n = int(input().split()[0])\n    aa = []\n    for i in range(n):\n        a = input().split()\n        j = int(a[0])\n        aa.append([int(k) for k in a[1:]])\n    s = [int(l) for l in input().split()]\n    if n == 1:\n        ss = ''.join((str(x) for x in s))\n        bb = aa[0][::-1]\n        sss = ''.join((str(x) for x in bb))\n        if ss == sss:\n            print('Yes')\n        else:\n            print('No')\n    else:\n        c = find_next(s, aa, 0, 0)\n        if c == len(s):\n            print('Yes')\n        else:\n            print('No')", "t = int(input())\n\ndef check_if_correct(input_threads):\n    for thread in input_threads:\n        if len(thread) != 0:\n            return False\n    return True\n\ndef recursive_check_stack(input_lists, stack):\n    if stack:\n        item = stack[-1]\n        stack = stack[:-1]\n        exists = False\n        res = False\n        for i in range(len(input_lists)):\n            if len(input_lists[i]) > 0 and input_lists[i][0] == item:\n                exists = True\n                input_lists[i] = input_lists[i][1:]\n                res = recursive_check_stack(input_lists, stack)\n                if res:\n                    return True\n        if not exists and (not res):\n            return False\n        if len(stack) == 0:\n            if check_if_correct(input_lists):\n                return True\n            else:\n                return False\n    return False\nfor _ in range(t):\n    n = int(input())\n    input_lists = []\n    sum_nums = 0\n    set1 = set()\n    set2 = set()\n    for _ in range(n):\n        thread_numbers = list(map(int, input().split()))[1:]\n        input_lists.append(thread_numbers)\n        sum_nums += len(thread_numbers)\n        for num in thread_numbers:\n            set1.add(num)\n    stack = list(map(int, input().split()))\n    for num in stack:\n        set2.add(num)\n    if sum_nums != len(stack) and set1 != set2:\n        print('No')\n        continue\n    result = True\n    for i in range(len(input_lists)):\n        k = 0\n        stack1 = stack[::-1]\n        for j in range(len(stack1)):\n            if input_lists[i][k] == stack1[j]:\n                k += 1\n                if k == len(input_lists[i]):\n                    break\n        if k != len(input_lists[i]):\n            result = False\n            break\n    if result:\n        print('Yes')\n    else:\n        print('No')", "S = 0\nN = 1\npossibilities = 1\ninitial_states = []\nthreads = []\nsequence = []\n\ndef hashing(lst):\n    pass\n\ndef recursion(position, states):\n    if position == S:\n        for state in states:\n            if state > 0:\n                return False\n        return True\n    for idx in range(N):\n        if states[idx] > 0 and threads[idx][states[idx] - 1] == sequence[position]:\n            states[idx] -= 1\n            if recursion(position + 1, states):\n                states[idx] += 1\n                return True\n            states[idx] += 1\n    return False\nfor _ in range(int(input().strip())):\n    N = int(input().strip())\n    threads = []\n    initial_states = []\n    S = 0\n    possibilities = 1\n    for idx in range(N):\n        thread = list(map(int, input().strip().split()))\n        S += thread[0]\n        initial_states.append(thread[0])\n        possibilities *= thread[0] + 1\n        threads.append(thread[1:])\n    sequence = list(map(int, input().strip().split()))\n    if N == 1:\n        print('Yes' if sequence == threads[0][::-1] else 'No')\n    else:\n        possible = recursion(0, initial_states)\n        print('Yes' if possible else 'No')", "def traverse(thr, seq, n):\n    if len(seq) == 0:\n        return True\n    for i in range(n):\n        if len(thr[i]) > 0 and thr[i][-1] == seq[0]:\n            thr[i] = thr[i][:-1]\n            if traverse(thr, seq[1:], n):\n                return True\n            else:\n                thr[i].append(seq[0])\n    return False\nfor t in range(int(input())):\n    n = int(input())\n    if n == 1:\n        l = list(map(int, input().split()))\n        l.pop(0)\n        seq = list(map(int, input().split()))\n        seq.reverse()\n        if l == seq:\n            print('Yes')\n        else:\n            print('No')\n        continue\n    thr = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        l.pop(0)\n        thr.append(l)\n    seq = list(map(int, input().split()))\n    if traverse(thr, seq, n):\n        print('Yes')\n    else:\n        print('No')", "import sys\nsys.setrecursionlimit(1000)\n\ndef check(ind):\n    if ind < 0:\n        return True\n    num = goal[ind]\n    for ls in threads:\n        if not ls:\n            continue\n        if ls[-1] == num:\n            ls.pop()\n            if mem.get(ind - 1):\n                return True\n            if check(ind - 1):\n                mem[ind - 1] = True\n                return True\n            ls.append(num)\n    return False\n\ndef check1():\n    target = threads[0]\n    target.reverse()\n    ind = 0\n    ans = 0\n    for a in goal:\n        for b in range(ind, len(target) - 1):\n            if a == target[b]:\n                ind = b\n                ans += 1\n                break\n    if ans == len(goal):\n        return True\n    return False\nt = int(input())\nfor q in range(t):\n    mem = {}\n    n = int(input())\n    threads = []\n    for q2 in range(n):\n        threads.append([int(u) for u in input().strip().split()])\n    goal = [int(u) for u in input().strip().split()]\n    if n == 1:\n        if check1():\n            print('Yes')\n        else:\n            print('No')\n        continue\n    goal.reverse()\n    if check(len(goal) - 1):\n        print('Yes')\n    else:\n        print('No')", "def test(N, data, res):\n    cur = [len(data[i]) - 1 for i in range(N)]\n    back = [-1] * len(res)\n    curr = len(res) - 1\n    while True:\n        next = res[curr]\n        notfound = True\n        for i in range(back[curr] + 1, N):\n            if cur[i] >= 0 and data[i][cur[i]] == next:\n                back[curr] = i\n                curr -= 1\n                if curr < 0:\n                    return True\n                cur[i] -= 1\n                notfound = False\n                break\n        if notfound:\n            back[curr] = -1\n            curr += 1\n            if curr >= len(res):\n                return False\n            else:\n                cur[back[curr]] += 1\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    data = [list(map(int, input().split()))[1:] for i in range(N)]\n    res = list(reversed(list(map(int, input().split()))))\n    if test(N, data, res):\n        print('Yes')\n    else:\n        print('No')", "import sys\nf = sys.stdin\n\ndef isOK(A, B, x):\n    if not B:\n        return True\n    for (i, k) in enumerate(x):\n        if A[i][k] != B[0]:\n            continue\n        x[i] = k + 1\n        if isOK(A, B[1:], x):\n            return True\n        x[i] = k\n    return False\n\ndef solve(A, B):\n    A = [a[1:] + [-1] for a in A]\n    if len(A) == 1:\n        if all((a == b for (a, b) in zip(A[0], B))):\n            return 'Yes'\n        else:\n            return 'No'\n    if isOK(A, B, [0] * len(A)):\n        return 'Yes'\n    else:\n        return 'No'\nt = int(f.readline())\nfor j in range(t):\n    n = int(f.readline())\n    A = []\n    for i in range(n):\n        A += [list(map(int, f.readline().split()))]\n    B = list(map(int, f.readline().split()))[::-1]\n    print(solve(A, B))"]