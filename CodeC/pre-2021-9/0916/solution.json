["class Ftree:\n\n    def __init__(self, N):\n        self.st = [0] * (N + 1)\n        self.n = N\n\n    def Update(self, l, r, diff):\n        while l <= self.n:\n            self.st[l] += diff\n            l += l & -l\n        r += 1\n        while r <= self.n:\n            self.st[r] -= diff\n            r += r & -r\n\n    def Query(self, i):\n        sum = 0\n        while i > 0:\n            sum += self.st[i]\n            i -= i & -i\n        return sum\n\ndef main():\n    (n, q) = input().split()\n    N = int(n)\n    Q = int(q)\n    A = [int(e) for e in input().split()]\n    A.insert(0, 0)\n    b1 = Ftree(N)\n    b2 = Ftree(N)\n    b3 = Ftree(N)\n    while Q != 0:\n        q = list(map(int, input().split()))\n        if q[0] == 1:\n            L = q[1]\n            R = q[2]\n            X = q[3]\n            y = X - L\n            b1.Update(L, R, y ** 2)\n            b2.Update(L, R, 2 * y)\n            b3.Update(L, R, 1)\n        else:\n            i = q[1]\n            print(A[i] + b1.Query(i) + b2.Query(i) * i + b3.Query(i) * i * i)\n        Q -= 1\nmain()", "class Ftree:\n\n    def __init__(self, N):\n        self.st = [0] * (N + 1)\n        self.n = N\n\n    def Update(self, l, r, diff):\n        while l <= self.n:\n            self.st[l] += diff\n            l += l & -l\n        r += 1\n        while r <= self.n:\n            self.st[r] -= diff\n            r += r & -r\n\n    def Query(self, i):\n        sum = 0\n        while i > 0:\n            sum += self.st[i]\n            i -= i & -i\n        return sum\n\ndef main():\n    (n, q) = input().split()\n    N = int(n)\n    Q = int(q)\n    A = [int(e) for e in input().split()]\n    A.insert(0, 0)\n    b1 = Ftree(N)\n    b2 = Ftree(N)\n    b3 = Ftree(N)\n    while Q != 0:\n        q = list(map(int, input().split()))\n        if q[0] == 1:\n            L = q[1]\n            R = q[2]\n            X = q[3]\n            y = X - L\n            b1.Update(L, R, y ** 2)\n            b2.Update(L, R, 2 * y)\n            b3.Update(L, R, 1)\n        else:\n            i = q[1]\n            print(A[i] + b1.Query(i) + b2.Query(i) * i + b3.Query(i) * i * i)\n        Q -= 1\nmain()", "class Fenwick:\n\n    def __init__(self, n):\n        self.bits = [0] * (n + 1)\n\n    def add(self, i, v):\n        i += 1\n        while i <= n:\n            self.bits[i] += v\n            i += i & -i\n\n    def rnge(self, l, r, x):\n        self.add(l, x)\n        self.add(r + 1, -x)\n\n    def get(self, i):\n        i += 1\n        ans = 0\n        while i > 0:\n            ans += self.bits[i]\n            i -= i & -i\n        return ans\n(N, Q) = input().split()\nn = int(N)\nq = int(Q)\nf1 = Fenwick(n)\nf2 = Fenwick(n)\nf3 = Fenwick(n)\narr = [int(i) for i in input().split()]\nfor i in range(q):\n    t = [int(i) for i in input().split()]\n    if t[0] == 1:\n        l = t[1] - 1\n        r = t[2] - 1\n        x = t[3]\n        f1.rnge(l, r, 1)\n        f2.rnge(l, r, (x - l - 1) * (x - l - 1))\n        f3.rnge(l, r, 2 * (x - l - 1))\n    else:\n        j = t[1]\n        k = arr[j - 1] + j * j * f1.get(j - 1) + f2.get(j - 1) + j * f3.get(j - 1)\n        print(k)", "def update_BIT(BIT, n, i, val, j):\n    while i <= n:\n        BIT[i][j] += val\n        i += i & -i\n\ndef get_sum(BIT, i, j):\n    ret = 0\n    while i > 0:\n        ret += BIT[i][j]\n        i -= i & -i\n    return ret\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\nbit = []\nfor i in range(n + 1):\n    bit.append([0, 0, 0])\nfor _ in range(q):\n    b = list(map(int, input().split()))\n    if b[0] == 1:\n        l = b[1]\n        r = b[2]\n        x = b[3]\n        update_BIT(bit, n, l, 1, 0)\n        update_BIT(bit, n, r + 1, -1, 0)\n        update_BIT(bit, n, l, pow(x - l, 2), 1)\n        update_BIT(bit, n, r + 1, -pow(x - l, 2), 1)\n        update_BIT(bit, n, l, 2 * (x - l), 2)\n        update_BIT(bit, n, r + 1, -2 * (x - l), 2)\n    else:\n        x = b[1]\n        ans = a[x - 1] + get_sum(bit, x, 0) * pow(x, 2) + get_sum(bit, x, 1) + get_sum(bit, x, 2) * x\n        print(ans)", "def update_range(BIT, i, n, val):\n    i += 1\n    while i <= n:\n        BIT[i] += val\n        i += i & -i\n\ndef get(BIT, i):\n    i += 1\n    s = 0\n    while i > 0:\n        s = s + BIT[i]\n        i = i - (i & -i)\n    return s\n\ndef update(BIT, l, r, n, val):\n    update_range(BIT, l, n, val)\n    update_range(BIT, r + 1, n, -val)\n(n, q) = map(int, input().split())\narr = list(map(int, input().split()))\nBIT1 = [0] * (n + 1)\nBIT2 = [0] * (n + 1)\nBIT3 = [0] * (n + 1)\nfor i in range(q):\n    k = list(map(int, input().split()))\n    if k[0] == 1:\n        (l, r, x) = (k[1] - 1, k[2] - 1, k[3])\n        update(BIT1, l, r, n, (x - l) * (x - l))\n        update(BIT2, l, r, n, 2 * (x - l))\n        update(BIT3, l, r, n, 1)\n    else:\n        y = k[1] - 1\n        ans = arr[y] + get(BIT1, y) + y * get(BIT2, y) + y * y * get(BIT3, y)\n        print(ans)", "N = 131072\n\nclass SegmentTree:\n\n    def __init__(self):\n        self.array = [0 for i in range(2 * N)]\n\n    def add_range(self, left, right, x, i=1, l=1, r=N):\n        if l >= left and r <= right:\n            self.array[i] += x\n            return\n        m = (l + r) // 2\n        if m >= left:\n            self.add_range(left, right, x, i * 2, l, m)\n        if m + 1 <= right:\n            self.add_range(left, right, x, i * 2 + 1, m + 1, r)\n\n    def get_value(self, index):\n        value = 0\n        i = N + index - 1\n        while i > 0:\n            value += self.array[i]\n            i //= 2\n        return value\nsegment_trees = [SegmentTree() for i in range(3)]\n(n, n_query) = (int(x) for x in input().split())\noffset = [None] + [int(x) for x in input().split()]\nfor query in range(n_query):\n    operation = [int(x) for x in input().split()]\n    if operation[0] == 1:\n        (left, right, x) = operation[1:]\n        y = x - left\n        segment_trees[0].add_range(left, right, y ** 2)\n        segment_trees[1].add_range(left, right, 2 * y)\n        segment_trees[2].add_range(left, right, 1)\n    if operation[0] == 2:\n        index = operation[1]\n        answer = offset[index] + sum((segment_trees[i].get_value(index) * index ** i for i in range(3)))\n        print(answer)", "class FenwickTree:\n\n    def __init__(self, arg):\n        self.arg = arg + 1\n        self.arr = [0] * (arg + 1)\n\n    def update(self, i, delta):\n        i += 1\n        while i < self.arg:\n            self.arr[i] += delta\n            i += i & -i\n\n    def range_update(self, L, R, value):\n        self.update(L, value)\n        self.update(R + 1, -value)\n\n    def get(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.arr[i]\n            i -= i & -i\n        return ans\n\n    def pp(self):\n        print(self.arr)\n(n, q) = map(int, input().split())\nf1 = FenwickTree(n)\nf2 = FenwickTree(n)\nf3 = FenwickTree(n)\nA = list(map(int, input().split()))\nfor _ in range(q):\n    operation = list(map(int, input().split()))\n    if operation[0] == 1:\n        l = operation[1] - 1\n        r = operation[2] - 1\n        x = operation[3]\n        y = x - l - 1\n        f1.range_update(l, r, 1)\n        f2.range_update(l, r, y * y)\n        f3.range_update(l, r, 2 * y)\n    else:\n        i = operation[1]\n        ans = A[i - 1] + i * i * f1.get(i - 1) + f2.get(i - 1) + i * f3.get(i - 1)\n        print(ans)", "def updateBIT(BIT, i, n, val):\n    i += 1\n    while i <= n:\n        BIT[i] += val\n        i += i & -i\n\ndef get(BIT, i):\n    i += 1\n    s = 0\n    while i > 0:\n        s += BIT[i]\n        i -= i & -i\n    return s\n\ndef update(BIT, l, r, n, val):\n    updateBIT(BIT, l, n, val)\n    updateBIT(BIT, r + 1, n, -val)\n(n, q) = map(int, input().split())\nseq = list(map(int, input().split()))\nBIT1 = [0] * (n + 1)\nBIT2 = [0] * (n + 1)\nBIT3 = [0] * (n + 1)\nfor i in range(q):\n    qr = list(map(int, input().split()))\n    if qr[0] == 1:\n        y = qr[3] - qr[1]\n        update(BIT1, qr[1] - 1, qr[2] - 1, n, y * y)\n        update(BIT2, qr[1] - 1, qr[2] - 1, n, 2 * y)\n        update(BIT3, qr[1] - 1, qr[2] - 1, n, 1)\n    else:\n        sum = seq[qr[1] - 1] + get(BIT1, qr[1] - 1) + get(BIT2, qr[1] - 1) * qr[1] + get(BIT3, qr[1] - 1) * qr[1] ** 2\n        print(sum)", "N = 131072\n\nclass SegmentTree:\n\n    def __init__(self):\n        self.array = [0 for i in range(2 * N)]\n\n    def add_range(self, left, right, x, i=1, l=1, r=N):\n        if l >= left and r <= right:\n            self.array[i] += x\n            return\n        m = (l + r) // 2\n        if m >= left:\n            self.add_range(left, right, x, i * 2, l, m)\n        if m + 1 <= right:\n            self.add_range(left, right, x, i * 2 + 1, m + 1, r)\n\n    def get_value(self, index):\n        value = 0\n        i = N + index - 1\n        while i > 0:\n            value += self.array[i]\n            i //= 2\n        return value\nsegment_trees = [SegmentTree() for i in range(3)]\n(n, n_query) = (int(x) for x in input().split())\noffset = [None] + [int(x) for x in input().split()]\nfor query in range(n_query):\n    operation = [int(x) for x in input().split()]\n    if operation[0] == 1:\n        (left, right, x) = operation[1:]\n        y = x - left\n        segment_trees[0].add_range(left, right, y ** 2)\n        segment_trees[1].add_range(left, right, 2 * y)\n        segment_trees[2].add_range(left, right, 1)\n    if operation[0] == 2:\n        index = operation[1]\n        answer = offset[index] + sum((segment_trees[i].get_value(index) * index ** i for i in range(3)))\n        print(answer)", "def range_update(bit, l, r, val):\n    while l <= n:\n        bit[l] += val\n        l += l & -l\n    r += 1\n    while r <= n:\n        bit[r] -= val\n        r += r & -r\n\ndef getsum(bit, idx):\n    s = 0\n    while idx > 0:\n        s += bit[idx]\n        idx -= idx & -idx\n    return s\n(n, q) = map(int, input().split())\nbit1 = [0] * (n + 1)\nbit2 = [0] * (n + 1)\nbit3 = [0] * (n + 1)\na = list(map(int, input().split()))\nfor _ in range(q):\n    qr = list(map(int, input().split()))\n    if qr[0] == 1:\n        (l, r, x) = qr[1:]\n        range_update(bit1, l, r, 1)\n        range_update(bit2, l, r, (x - l) ** 2)\n        range_update(bit3, l, r, 2 * (x - l))\n    else:\n        i = qr[1]\n        print(a[i - 1] + i * i * getsum(bit1, i) + getsum(bit2, i) + i * getsum(bit3, i))"]