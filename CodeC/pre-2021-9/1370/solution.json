["import sys, collections\ninput = sys.stdin.readline\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import sys, collections\ninput = sys.stdin.readline\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import sys, collections\ninput = sys.stdin.readline\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import sys, collections\ninput = sys.stdin.readline\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import sys, collections\ninput = sys.stdin.readline\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import sys, collections\ninput = sys.stdin.readline\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import sys, collections\ninput = sys.stdin.readline\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import sys, collections\ninput = sys.stdin.readline\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import sys, collections\ninput = sys.stdin.readline\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import sys, collections\ninput = sys.stdin.readline\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import sys, collections\ninput = sys.stdin.readline\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import sys, collections\ninput = sys.stdin.readline\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nsolve()", "import sys, collections\ninput = sys.stdin.readline\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nsolve()", "import sys, collections\ninput = sys.stdin.readline\n\ndef main1():\n    T = int(input())\n    for _ in range(T):\n        (N, K) = map(int, input().split())\n        Tree = {}\n        for j in range(N):\n            Tree[j] = []\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            Tree[u - 1].append(v - 1)\n            Tree[v - 1].append(u - 1)\n        A = list(map(int, input().split()))\n        vis = [0 for i in range(N)]\n        maxval = [[0, 0] for i in range(N)]\n        minval = [0 for i in range(N)]\n        lfnode = []\n        vis[0] = 1\n        Q = collections.deque([0])\n        (maxval[0][0], maxval[0][1]) = (A[0], 1)\n        minval[0] = A[0]\n        while len(Q) != 0:\n            a = Q.pop()\n            mv1 = maxval[a][0]\n            mv2 = minval[a]\n            flag = 0\n            for i in Tree[a]:\n                if vis[i] == 0:\n                    vis[i] = 1\n                    flag = 1\n                    v = A[i]\n                    Q.append(i)\n                    if mv1 < v:\n                        (maxval[i][0], maxval[i][1]) = (v, 1)\n                    elif mv1 == v:\n                        (maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n                    else:\n                        (maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n                    if mv2 > v:\n                        minval[i] = v\n                    elif v == mv2:\n                        minval[i] = mv2\n                    else:\n                        minval[i] = minval[a]\n            if flag == 0:\n                lfnode.append(a)\n        flag = 0\n        K1 = len(bin(K)) - 2\n        for i in lfnode:\n            (v1, v2) = (maxval[i][0], maxval[i][1])\n            if v1 > K1 and v2 % 2 == 0:\n                flag = 1\n            elif v1 == K1 and v2 % 2 == 1:\n                flag = 1\n            v11 = minval[i]\n            if v11 > K1 and v11 != v1:\n                flag = 1\n            elif v11 == K1:\n                flag = 1\n            if flag == 1:\n                break\n        if flag == 1:\n            print('YES')\n        else:\n            print('NO')\nmain1()", "t = int(input())\nfor _ in range(t):\n    (n, k) = [int(j) for j in input().split()]\n    for pow_k in range(64):\n        if k == 0:\n            break\n        k = k // 2\n    edges = [[0] * 2 for _ in range(n - 1)]\n    for i in range(n - 1):\n        edges[i] = [int(j) - 1 for j in input().split()]\n    numbers = [int(j) for j in input().split()]\n    vertex_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        vertex_set[edges[i][0]].append(edges[i][1])\n        vertex_set[edges[i][1]].append(edges[i][0])\n    vertices = [0]\n    parent = dict()\n    parent[0] = -1\n    for i in range(n):\n        vertex = vertices[i]\n        for v in vertex_set[vertex]:\n            if v != parent[vertex]:\n                vertices.append(v)\n                parent[v] = vertex\n    and_op = [0 for _ in range(n)]\n    xor_op = [0 for _ in range(n)]\n    leaf_node = [True for _ in range(n)]\n    if numbers[0] >= pow_k:\n        and_op[0] = numbers[0]\n    xor_op[0] = numbers[0]\n    for i in range(1, n):\n        vertex = vertices[i]\n        parent_vertex = parent[vertex]\n        if numbers[vertex] >= pow_k and and_op[parent_vertex] >= pow_k:\n            if numbers[vertex] != and_op[parent_vertex]:\n                and_op[vertex] = pow_k\n            else:\n                and_op[vertex] = and_op[parent_vertex]\n        if numbers[vertex] == xor_op[parent_vertex] % 100:\n            if xor_op[parent_vertex] < 100:\n                xor_op[vertex] = xor_op[parent_vertex] + 100\n            else:\n                xor_op[vertex] = numbers[vertex]\n        elif numbers[vertex] > xor_op[parent_vertex] % 100:\n            xor_op[vertex] = numbers[vertex]\n        else:\n            xor_op[vertex] = xor_op[parent_vertex]\n        leaf_node[parent_vertex] = False\n    success = False\n    for vertex in vertices:\n        if leaf_node[vertex]:\n            if and_op[vertex] == pow_k:\n                success = True\n                break\n            if xor_op[vertex] % 100 > pow_k and xor_op[vertex] > 100 or xor_op[vertex] == pow_k:\n                success = True\n                break\n    if success:\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    (n, k) = [int(j) for j in input().split()]\n    for pow_k in range(64):\n        if k == 0:\n            break\n        k = k // 2\n    edges = [[0] * 2 for _ in range(n - 1)]\n    for i in range(n - 1):\n        edges[i] = [int(j) - 1 for j in input().split()]\n    numbers = [int(j) for j in input().split()]\n    vertex_set = [[] for _ in range(n)]\n    for i in range(n - 1):\n        vertex_set[edges[i][0]].append(edges[i][1])\n        vertex_set[edges[i][1]].append(edges[i][0])\n    vertices = [0]\n    parent = dict()\n    parent[0] = -1\n    for i in range(n):\n        vertex = vertices[i]\n        for v in vertex_set[vertex]:\n            if v != parent[vertex]:\n                vertices.append(v)\n                parent[v] = vertex\n    and_op = [0 for _ in range(n)]\n    xor_op = [0 for _ in range(n)]\n    leaf_node = [True for _ in range(n)]\n    if numbers[0] >= pow_k:\n        and_op[0] = numbers[0]\n    xor_op[0] = numbers[0]\n    for i in range(1, n):\n        vertex = vertices[i]\n        parent_vertex = parent[vertex]\n        if numbers[vertex] >= pow_k and and_op[parent_vertex] >= pow_k:\n            if numbers[vertex] != and_op[parent_vertex]:\n                and_op[vertex] = pow_k\n            else:\n                and_op[vertex] = and_op[parent_vertex]\n        if numbers[vertex] == xor_op[parent_vertex] % 100:\n            if xor_op[parent_vertex] < 100:\n                xor_op[vertex] = xor_op[parent_vertex] + 100\n            else:\n                xor_op[vertex] = numbers[vertex]\n        elif numbers[vertex] > xor_op[parent_vertex] % 100:\n            xor_op[vertex] = numbers[vertex]\n        else:\n            xor_op[vertex] = xor_op[parent_vertex]\n        leaf_node[parent_vertex] = False\n    success = False\n    for vertex in vertices:\n        if leaf_node[vertex]:\n            if and_op[vertex] == pow_k:\n                success = True\n                break\n            if xor_op[vertex] % 100 > pow_k and xor_op[vertex] > 100 or xor_op[vertex] == pow_k:\n                success = True\n                break\n    if success:\n        print('YES')\n    else:\n        print('NO')", "import sys\nimport math\nfrom collections import defaultdict, Counter\nimport threading\ninput = sys.stdin.readline\n\ndef print(x):\n    sys.stdout.write(str(x) + '\\n')\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\n@bootstrap\ndef find(u, g, e, g2, e2, le):\n    visit[u - 1] = 1\n    if a[u - 1] > g:\n        g = a[u - 1]\n        e = 1\n    elif a[u - 1] == g:\n        e += 1\n    if a[u - 1] < g2:\n        g2 = a[u - 1]\n        e2 = 1\n    elif a[u - 1] == g2:\n        e2 += 1\n    for j in l[u]:\n        if visit[j - 1] == 0:\n            flag = (yield find(j, g, e, g2, e2, le))\n            if flag:\n                yield 1\n        elif len(l[u]) == 1:\n            if g == le and e & 1 or (g > le and e % 2 == 0) or g2 == le or (g2 > le and g > g2):\n                yield 1\n    yield 0\n\ndef add(a, b):\n    l[a].append(b)\n    l[b].append(a)\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    l = defaultdict(list)\n    for j in range(n - 1):\n        (u, v) = map(int, input().split())\n        add(u, v)\n    a = list(map(int, input().split()))\n    visit = [0] * n\n    le = len(bin(k)) - 2\n    if find(1, 0, 0, 100, 0, le):\n        print('YES')\n    else:\n        print('NO')\nsys.setrecursionlimit(10 ** 5)"]