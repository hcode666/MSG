["from collections import deque\n\ndef BFS(bldg, s):\n    queue = deque()\n    queue.append(s)\n    cost = [-1 for i in range(n + 1)]\n    cost[s] = 0\n    while queue:\n        s = queue.popleft()\n        for i in bldg[s]:\n            if cost[i] == -1:\n                queue.append(i)\n                cost[i] = cost[s] + 1\n    return cost\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    buildings = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        buildings[u] += [v]\n        buildings[v] += [u]\n    sub = list(map(int, input().split()))\n    costa = BFS(buildings, 0)\n    for i in range(s):\n        sub[i] = costa[sub[i]]\n    sub.sort()\n    print(2 * sum(sub[:k]))", "from collections import deque\n\ndef BFS(bldg, s):\n    queue = deque()\n    queue.append(s)\n    cost = [-1 for i in range(n + 1)]\n    cost[s] = 0\n    while queue:\n        s = queue.popleft()\n        for i in bldg[s]:\n            if cost[i] == -1:\n                queue.append(i)\n                cost[i] = cost[s] + 1\n    return cost\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    buildings = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        buildings[u] += [v]\n        buildings[v] += [u]\n    sub = list(map(int, input().split()))\n    costa = BFS(buildings, 0)\n    for i in range(s):\n        sub[i] = costa[sub[i]]\n    sub.sort()\n    print(2 * sum(sub[:k]))", "from collections import deque\n\ndef BFS(bldg, s):\n    queue = deque()\n    queue.append(s)\n    cost = [-1 for i in range(n + 1)]\n    cost[s] = 0\n    while queue:\n        s = queue.popleft()\n        for i in bldg[s]:\n            if cost[i] == -1:\n                queue.append(i)\n                cost[i] = cost[s] + 1\n    return cost\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    buildings = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        buildings[u] += [v]\n        buildings[v] += [u]\n    sub = list(map(int, input().split()))\n    costa = BFS(buildings, 0)\n    for i in range(s):\n        sub[i] = costa[sub[i]]\n    sub.sort()\n    print(2 * sum(sub[:k]))", "from collections import deque\n\ndef bfs(ans_ll, v):\n    Q = deque()\n    dist = [-1 for i in range(n + 1)]\n    dist[v] = 0\n    Q.append(v)\n    while Q:\n        temp = Q.popleft()\n        for i in ans_ll[temp]:\n            if dist[i] == -1:\n                Q.append(i)\n                dist[i] = dist[temp] + 1\n    return dist\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    ans_ll = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        ans_ll[u].append(v)\n        ans_ll[v].append(u)\n    temp_arr = list(map(int, input().split()))\n    dist = bfs(ans_ll, 0)\n    for i in range(len(temp_arr)):\n        temp_arr[i] = dist[temp_arr[i]]\n    temp_arr.sort()\n    print(2 * sum(temp_arr[:k]))", "from collections import deque\n\ndef bfs(ans_ll, v):\n    Q = deque()\n    dist = [-1 for i in range(n + 1)]\n    dist[v] = 0\n    Q.append(v)\n    while Q:\n        temp = Q.popleft()\n        for i in ans_ll[temp]:\n            if dist[i] == -1:\n                Q.append(i)\n                dist[i] = dist[temp] + 1\n    return dist\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    ans_ll = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        ans_ll[u].append(v)\n        ans_ll[v].append(u)\n    temp_arr = list(map(int, input().split()))\n    dist = bfs(ans_ll, 0)\n    for i in range(len(temp_arr)):\n        temp_arr[i] = dist[temp_arr[i]]\n    temp_arr.sort()\n    print(2 * sum(temp_arr[:k]))", "from collections import deque\n\ndef bfs(ans_ll, v):\n    Q = deque()\n    dist = [-1 for i in range(n + 1)]\n    dist[v] = 0\n    Q.append(v)\n    while Q:\n        temp = Q.popleft()\n        for i in ans_ll[temp]:\n            if dist[i] == -1:\n                Q.append(i)\n                dist[i] = dist[temp] + 1\n    return dist\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    ans_ll = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        ans_ll[u].append(v)\n        ans_ll[v].append(u)\n    temp_arr = list(map(int, input().split()))\n    dist = bfs(ans_ll, 0)\n    for i in range(len(temp_arr)):\n        temp_arr[i] = dist[temp_arr[i]]\n    temp_arr.sort()\n    print(2 * sum(temp_arr[:k]))", "from collections import deque\n\ndef bfs(ans_ll, v):\n    Q = deque()\n    dist = [-1 for i in range(n + 1)]\n    dist[v] = 0\n    Q.append(v)\n    while Q:\n        temp = Q.popleft()\n        for i in ans_ll[temp]:\n            if dist[i] == -1:\n                Q.append(i)\n                dist[i] = dist[temp] + 1\n    return dist\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    ans_ll = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        ans_ll[u].append(v)\n        ans_ll[v].append(u)\n    temp_arr = list(map(int, input().split()))\n    dist = bfs(ans_ll, 0)\n    for i in range(len(temp_arr)):\n        temp_arr[i] = dist[temp_arr[i]]\n    temp_arr.sort()\n    print(2 * sum(temp_arr[:k]))", "from collections import deque\nfor i in range(int(input())):\n    (n, m, s, k) = [int(x) for x in input().split()]\n    vert = [[] for _ in range(n + 1)]\n    dist = [-1 for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = [int(x) for x in input().split()]\n        vert[u].append(v)\n        vert[v].append(u)\n    build = [int(x) for x in input().split()]\n    l = []\n    q = deque()\n    q.append(0)\n    dist[0] = 0\n    while q:\n        u = q.popleft()\n        for i in vert[u]:\n            if dist[i] == -1:\n                q.append(i)\n                dist[i] = dist[u] + 1\n    for i in build:\n        l.append(dist[i])\n    l.sort()\n    print(2 * sum(l[:k]))", "from collections import deque\n\ndef bfs(ans_ll, v):\n    Q = deque()\n    dist = [-1 for i in range(n + 1)]\n    dist[v] = 0\n    Q.append(v)\n    while Q:\n        temp = Q.popleft()\n        for i in ans_ll[temp]:\n            if dist[i] == -1:\n                Q.append(i)\n                dist[i] = dist[temp] + 1\n    return dist\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    ans_ll = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        ans_ll[u].append(v)\n        ans_ll[v].append(u)\n    temp_arr = list(map(int, input().split()))\n    dist = bfs(ans_ll, 0)\n    for i in range(len(temp_arr)):\n        temp_arr[i] = dist[temp_arr[i]]\n    temp_arr.sort()\n    print(2 * sum(temp_arr[:k]))", "from collections import deque\n\ndef bfs(ans_ll, v):\n    Q = deque()\n    dist = [-1 for i in range(n + 1)]\n    dist[v] = 0\n    Q.append(v)\n    while Q:\n        temp = Q.popleft()\n        for i in ans_ll[temp]:\n            if dist[i] == -1:\n                Q.append(i)\n                dist[i] = dist[temp] + 1\n    return dist\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    ans_ll = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        ans_ll[u].append(v)\n        ans_ll[v].append(u)\n    temp_arr = list(map(int, input().split()))\n    dist = bfs(ans_ll, 0)\n    for i in range(len(temp_arr)):\n        temp_arr[i] = dist[temp_arr[i]]\n    temp_arr.sort()\n    print(2 * sum(temp_arr[:k]))", "def minDistance(buildingCounter, requiredSubjects, createGraph):\n    s = [(0, 0)]\n    result = 0\n    visited = set()\n    while len(s) > 0:\n        p = s.pop(0)\n        if p[0] in visited:\n            continue\n        if p[0] in buildingCounter:\n            x = min(buildingCounter[p[0]], requiredSubjects)\n            result += x * p[1] * 2\n            requiredSubjects -= x\n        if requiredSubjects == 0:\n            break\n        visited.add(p[0])\n        if p[0] in createGraph:\n            for i in createGraph[p[0]]:\n                s.append((i, p[1] + 1))\n    return result\ntestCases = int(input())\nfor i in range(testCases):\n    createGraph = {}\n    (noOfBuildings, edges, noOfSubjects, requiredSubjects) = map(int, input().split())\n    for i in range(edges):\n        (buildingA, buildingB) = map(int, input().split())\n        if buildingA not in createGraph:\n            createGraph[buildingA] = [buildingB]\n        else:\n            createGraph[buildingA].append(buildingB)\n        if buildingB not in createGraph:\n            createGraph[buildingB] = [buildingA]\n        else:\n            createGraph[buildingB].append(buildingA)\n    subjectTaughtAt = list(map(int, input().split()))\n    buildingCounter = {}\n    for i in subjectTaughtAt:\n        if i not in buildingCounter:\n            buildingCounter[i] = 1\n        else:\n            buildingCounter[i] += 1\n    print(minDistance(buildingCounter, requiredSubjects, createGraph))", "def bfs(n, g):\n    q = []\n    q.append([0, 0])\n    dist = [0 for i in range(n + 1)]\n    vis = {0}\n    while q:\n        (curr, mdist) = q.pop(0)\n        dist[curr] = mdist\n        for child in g[curr]:\n            if not child in vis:\n                vis.add(child)\n                q.append([child, mdist + 1])\n    return dist\nans = []\nt = int(input())\nfor _ in range(t):\n    (n, m, s, k) = map(int, input().split())\n    g = {i: [] for i in range(n + 1)}\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    a = list(map(int, input().split()))\n    dist = bfs(n, g)\n    final_dist = [dist[i] for i in a]\n    if s == k:\n        ans.append(2 * sum(final_dist))\n        continue\n    final_dist.sort()\n    ans.append(2 * sum(final_dist[:k]))\nfor i in ans:\n    print(i)", "from collections import defaultdict, deque\n\ndef bfs(n, g):\n    q = deque()\n    q.append([0, 0])\n    dist = [0 for i in range(n + 1)]\n    vis = {0}\n    while q:\n        (curr, mdist) = q.popleft()\n        dist[curr] = mdist\n        for child in g[curr]:\n            if not child in vis:\n                vis.add(child)\n                q.append([child, mdist + 1])\n    return dist\nans = []\nt = int(input())\nfor _ in range(t):\n    (n, m, s, k) = map(int, input().split())\n    g = {i: [] for i in range(n + 1)}\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    a = list(map(int, input().split()))\n    dist = bfs(n, g)\n    final_dist = [dist[i] for i in a]\n    if s == k:\n        ans.append(2 * sum(final_dist))\n        continue\n    final_dist.sort()\n    ans.append(2 * sum(final_dist[:k]))\nfor i in ans:\n    print(i)", "from collections import defaultdict, deque\n\ndef bfs(n, g):\n    q = deque()\n    q.append([0, 0])\n    dist = [0 for i in range(n + 1)]\n    vis = {0}\n    while q:\n        (curr, mdist) = q.popleft()\n        dist[curr] = mdist\n        for child in g[curr]:\n            if not child in vis:\n                vis.add(child)\n                q.append([child, mdist + 1])\n    return dist\nans = []\nt = int(input())\nfor _ in range(t):\n    (n, m, s, k) = map(int, input().split())\n    g = defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    a = list(map(int, input().split()))\n    dist = bfs(n, g)\n    final_dist = [dist[i] for i in a]\n    if s == k:\n        ans.append(2 * sum(final_dist))\n        continue\n    final_dist.sort()\n    ans.append(2 * sum(final_dist[:k]))\nfor i in ans:\n    print(i)", "from collections import deque, defaultdict\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    a = list(map(int, input().split()))\n    level = [0] * (n + 1)\n    vis = [False] * (n + 1)\n    queue = deque()\n    queue.append(0)\n    level[0] = 0\n    vis[0] = True\n    while queue:\n        x = queue.popleft()\n        for i in graph[x]:\n            if not vis[i]:\n                vis[i] = True\n                level[i] = level[x] + 1\n                queue.append(i)\n    dist = []\n    for i in a:\n        dist.append(level[i])\n    dist.sort()\n    print(sum(dist[:k]) * 2)", "from collections import defaultdict\nfor i in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    d = defaultdict(list)\n    for j in range(m):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    sb = list(map(int, input().split()))\n    sub = defaultdict(lambda : 0)\n    visited = defaultdict(lambda : False)\n    for j in sb:\n        sub[j] += 1\n    que = [0]\n    visited[0] = True\n    ans = 0\n    level = 1\n    while que:\n        if k == 0:\n            break\n        lenofq = len(que)\n        for l in range(lenofq):\n            a = que.pop(0)\n            for j in d[a]:\n                if visited[j]:\n                    continue\n                visited[j] = True\n                que.append(j)\n                if sub[j] > 0:\n                    req = min(k, sub[j])\n                    ans += 2 * level * req\n                    k -= req\n                if k == 0:\n                    break\n            if k == 0:\n                break\n        level += 1\n    print(ans)", "for t in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    adjlist = {i: [] for i in range(n + 1)}\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        adjlist[u].append(v)\n        adjlist[v].append(u)\n    s = list(map(int, input().split()))\n    vis = [-1] * (n + 1)\n    vis[0] = 0\n    q = [0]\n    while q != []:\n        curr = q.pop(0)\n        for i in adjlist[curr]:\n            if vis[i] >= 0:\n                continue\n            else:\n                vis[i] = vis[curr] + 1\n                q.append(i)\n    ans = []\n    for i in range(len(s)):\n        ans.append(vis[s[i]])\n    ans.sort()\n    print(sum(ans[:k]) * 2)", "from collections import deque\n\ndef bfs(ans_ll, v):\n    Q = deque()\n    dist = [-1 for i in range(n + 1)]\n    dist[v] = 0\n    Q.append(v)\n    while Q:\n        temp = Q.popleft()\n        for i in ans_ll[temp]:\n            if dist[i] == -1:\n                Q.append(i)\n                dist[i] = dist[temp] + 1\n    return dist\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    ans_ll = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        ans_ll[u].append(v)\n        ans_ll[v].append(u)\n    temp_arr = list(map(int, input().split()))\n    dist = bfs(ans_ll, 0)\n    for i in range(len(temp_arr)):\n        temp_arr[i] = dist[temp_arr[i]]\n    temp_arr.sort()\n    print(2 * sum(temp_arr[:k]))", "from collections import deque\n\ndef bfs(ans_ll, v):\n    Q = deque()\n    dist = [-1 for i in range(n + 1)]\n    dist[v] = 0\n    Q.append(v)\n    while Q:\n        temp = Q.popleft()\n        for i in ans_ll[temp]:\n            if dist[i] == -1:\n                Q.append(i)\n                dist[i] = dist[temp] + 1\n    return dist\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    ans_ll = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        ans_ll[u].append(v)\n        ans_ll[v].append(u)\n    temp_arr = list(map(int, input().split()))\n    dist = bfs(ans_ll, 0)\n    print(2 * sum(sorted([dist[temp_arr[i]] for i in range(len(temp_arr))])[:k]))", "import queue\n\ndef bfs(graph, n):\n    dis = [0] * n\n    visited = [False] * n\n    q = queue.Queue()\n    q.put(0)\n    visited[0] = True\n    while not q.empty():\n        x = q.get()\n        for i in graph[x]:\n            if not visited[i]:\n                visited[i] = True\n                dis[i] = dis[x] + 1\n                q.put(i)\n    return dis\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    g = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    dis = bfs(g, n + 1)\n    l = []\n    for i in map(int, input().split()):\n        l.append(dis[i])\n    l.sort()\n    ans = 0\n    for i in range(k):\n        ans += l[i]\n    print(2 * ans)", "def graph(adj):\n    queue = [0]\n    visited = [0] * (N + 1)\n    visited[0] = 1\n    dist = [0] * (N + 1)\n    while len(queue) > 0:\n        u = queue[0]\n        queue.pop(0)\n        for child in adj[u]:\n            if not visited[child]:\n                visited[child] = 1\n                dist[child] = dist[u] + 1\n                queue.append(child)\n    return dist\n\ndef addbiedge(g, a, b):\n    if a not in g:\n        g[a] = []\n    if b not in g:\n        g[b] = []\n    g[a].append(b)\n    g[b].append(a)\n\ndef solve(adj, builds, K):\n    dists = graph(adj)\n    mins = []\n    for i in builds:\n        mins.append(dists[i])\n    mins.sort()\n    ans = 0\n    for i in range(K):\n        ans += mins[i] * 2\n    return ans\nfor _ in range(int(input())):\n    [N, M, S, K] = [int(i) for i in input().rstrip().split(' ')]\n    g = {}\n    for _ in range(M):\n        [a, b] = [int(i) for i in input().rstrip().split(' ')]\n        addbiedge(g, a, b)\n    builds = [int(i) for i in input().rstrip().split(' ')]\n    print(solve(g, builds, K))", "def bfs(arr, v):\n    queue = []\n    visited = [-1 for i in range(len(arr))]\n    queue.append(v)\n    visited[v] = 0\n    while len(queue) > 0:\n        x = queue.pop(0)\n        for i in arr[x]:\n            if visited[i] == -1:\n                queue.append(i)\n                visited[i] = visited[x] + 1\n    return visited\nt = int(input())\nfor _ in range(t):\n    (N, M, S, K) = map(int, input().split())\n    a = [[] for i in range(N + 1)]\n    for _ in range(M):\n        (u, v) = map(int, input().split())\n        a[u].append(v)\n        a[v].append(u)\n    final = [int(i) for i in input().split()]\n    res = bfs(a, 0)\n    for i in range(len(final)):\n        final[i] = res[final[i]]\n    final.sort()\n    print(2 * sum(final[:K]))", "from collections import defaultdict\n\ndef dfs(adj, v):\n    q = [v]\n    dist = [-1 for i in range(n + 1)]\n    dist[v] = 0\n    while q:\n        t = q.pop(0)\n        for i in adj[t]:\n            if dist[i] == -1:\n                q.append(i)\n                dist[i] = dist[t] + 1\n    return dist\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    adj = defaultdict(list)\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    build = list(map(int, input().split()))\n    cost = dfs(adj, 0)\n    for i in range(len(build)):\n        build[i] = cost[build[i]]\n    build.sort()\n    print(2 * sum(build[:k]))", "import sys\nfrom collections import Counter\nget_string = lambda : sys.stdin.readline().strip()\nget_intmap = lambda : map(int, get_string().split())\nfor t in range(int(get_string())):\n    (n, m, s, k) = get_intmap()\n    adj = [[] for i in range(n + 1)]\n    for ind in range(m):\n        (a, b) = get_intmap()\n        adj[a].append(b)\n        adj[b].append(a)\n    ls = list(get_intmap())\n    ss = set(ls)\n    frontier = [0]\n    used = [0] * (n + 1)\n    used[0] = 1\n    nxt = []\n    ldistance = [1000 * n] * (n + 1)\n    distance = 0\n    while len(frontier) > 0:\n        distance += 1\n        for u in frontier:\n            for v in adj[u]:\n                if not used[v]:\n                    used[v] = 1\n                    nxt.append(v)\n                    ldistance[v] = distance\n        frontier = nxt\n        nxt = []\n    valid_distances = [ldistance[i] for i in ls]\n    valid_distances.sort()\n    print(2 * sum(valid_distances[:k]))", "import sys\nfrom collections import Counter\nget_string = lambda : sys.stdin.readline().strip()\nget_intmap = lambda : map(int, get_string().split())\nfor t in range(int(get_string())):\n    (n, m, s, k) = get_intmap()\n    adj = [[] for i in range(n + 1)]\n    for ind in range(m):\n        (a, b) = get_intmap()\n        adj[a].append(b)\n        adj[b].append(a)\n    ls = list(get_intmap())\n    ss = set(ls)\n    frontier = [0]\n    used = [0] * (n + 1)\n    used[0] = 1\n    nxt = []\n    ldistance = [1000 * n] * (n + 1)\n    distance = 0\n    while len(frontier) > 0:\n        distance += 1\n        for u in frontier:\n            for v in adj[u]:\n                if not used[v]:\n                    used[v] = 1\n                    nxt.append(v)\n                    ldistance[v] = distance\n        frontier = nxt\n        nxt = []\n    valid_distances = [ldistance[i] for i in ls]\n    valid_distances.sort()\n    print(2 * sum(valid_distances[:k]))", "from collections import defaultdict\nimport heapq\n\ndef addEdge(u, v, weight):\n    graph[u].append([v, weight])\n    graph[v].append([u, weight])\n\ndef minDistance(graph, src):\n    distances = defaultdict(lambda : float('inf'))\n    distances[src] = 0\n    pq = [(0, src)]\n    heapq.heapify(pq)\n    while pq:\n        (currDis, currVer) = heapq.heappop(pq)\n        if currDis > distances[currVer]:\n            continue\n        for (nbr, weight) in graph[currVer]:\n            dist = currDis + weight\n            if dist < distances[nbr]:\n                distances[nbr] = dist\n                heapq.heappush(pq, (dist, nbr))\n    return distances\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m, s, k) = list(map(int, input().strip().split()))\n    graph = defaultdict(list)\n    for _ in range(m):\n        (u, v) = list(map(int, input().split()))\n        addEdge(u, v, 1)\n    k_arr = list(map(int, input().split()))\n    distances = minDistance(graph, 0)\n    ans = 0\n    dist = []\n    for i in k_arr:\n        dist.append(distances[i])\n    dist = sorted(dist)\n    for i in range(k):\n        ans += dist[i]\n    print(ans * 2)", "from collections import deque\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef bfs(p):\n    q = deque([[p, 0]])\n    v = [False] * (n + 1)\n    v[0] = True\n    while len(q):\n        for i in child[q[0][0]]:\n            if not v[i]:\n                v[i] = True\n                ans[i] = min(ans[i], q[0][-1] + 1)\n                q.append([i, q[0][-1] + 1])\n        q.popleft()\nfor T in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    child = [[] for i in range(m + 1)]\n    for i in range(m):\n        (u1, u2) = map(int, input().split())\n        child[u1].append(u2)\n        child[u2].append(u1)\n    a = list(map(int, input().split()))\n    c = [0] * (n + 1)\n    for i in a:\n        c[i] += 1\n    ans = [10000000000.0] * (n + 1)\n    bfs(0)\n    ca = [0] * (n + 1)\n    for i in range(n + 1):\n        if ans[i] != 10000000000.0:\n            ca[ans[i]] += c[i]\n    answer = 0\n    for i in range(n + 1):\n        answer += min(ca[i], k) * (2 * i)\n        k -= min(ca[i], k)\n        if k == 0:\n            break\n    print(answer)", "from collections import deque\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef bfs(p):\n    q = deque([[p, 0]])\n    v = [False] * (n + 1)\n    v[0] = True\n    while len(q):\n        for i in child[q[0][0]]:\n            if not v[i]:\n                v[i] = True\n                ans[i] = min(ans[i], q[0][-1] + 1)\n                q.append([i, q[0][-1] + 1])\n        q.popleft()\nfor T in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    child = [[] for i in range(m + 1)]\n    for i in range(m):\n        (u1, u2) = map(int, input().split())\n        child[u1].append(u2)\n        child[u2].append(u1)\n    a = list(map(int, input().split()))\n    c = [0] * (n + 1)\n    for i in a:\n        c[i] += 1\n    ans = [10000000000.0] * (n + 1)\n    bfs(0)\n    ca = [0] * (n + 1)\n    for i in range(n + 1):\n        if ans[i] != 10000000000.0:\n            ca[ans[i]] += c[i]\n    answer = 0\n    for i in range(n + 1):\n        answer += min(ca[i], k) * (2 * i)\n        k -= min(ca[i], k)\n        if k == 0:\n            break\n    print(answer)", "from collections import defaultdict, deque\n\ndef sol(n, m, s, k, dic):\n    visited = [-1] * (n + 1)\n    visited[0] = 0\n    queue = deque()\n    queue.append(0)\n    while queue:\n        u = queue.popleft()\n        for v in dic[u]:\n            if visited[v] == -1:\n                queue.append(v)\n                visited[v] = visited[u] + 1\n    return visited\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    dic = defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        dic[u].append(v)\n        dic[v].append(u)\n    subj = list(map(int, input().split()))\n    dist = sol(n, m, s, k, dic)\n    for i in range(len(subj)):\n        subj[i] = dist[subj[i]]\n    subj.sort()\n    print(sum(subj[:k]) * 2)", "from collections import deque\n\ndef bfs(i, a):\n    paths = [-1 for i in range(n + 1)]\n    q = deque()\n    q.append(i)\n    paths[i] = 0\n    while q:\n        temp = q[0]\n        q.popleft()\n        for j in a[temp]:\n            if paths[j] == -1:\n                paths[j] = paths[temp] + 1\n                q.append(j)\n    return paths\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    a = [[] for j in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        a[u].append(v)\n        a[v].append(u)\n    S = list(map(int, input().split()))\n    paths = bfs(0, a)\n    for i in range(len(S)):\n        S[i] = paths[S[i]]\n    S.sort()\n    print(2 * sum(S[:k]))", "from collections import deque\n\ndef bfs(i, a):\n    paths = [-1 for i in range(n + 1)]\n    q = deque()\n    q.append(i)\n    paths[i] = 0\n    while q:\n        temp = q[0]\n        q.popleft()\n        for j in a[temp]:\n            if paths[j] == -1:\n                paths[j] = paths[temp] + 1\n                q.append(j)\n    return paths\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    a = [[] for j in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        a[u].append(v)\n        a[v].append(u)\n    S = list(map(int, input().split()))\n    paths = bfs(0, a)\n    for i in range(len(S)):\n        S[i] = paths[S[i]]\n    S.sort()\n    print(2 * sum(S[:k]))", "from collections import deque\n\ndef bfs(i, a):\n    paths = [-1 for i in range(n + 1)]\n    q = deque()\n    q.append(i)\n    paths[i] = 0\n    while q:\n        temp = q[0]\n        q.popleft()\n        for j in a[temp]:\n            if paths[j] == -1:\n                paths[j] = paths[temp] + 1\n                q.append(j)\n    return paths\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    a = [[] for j in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        a[u].append(v)\n        a[v].append(u)\n    S = list(map(int, input().split()))\n    paths = bfs(0, a)\n    for i in range(len(S)):\n        S[i] = paths[S[i]]\n    S.sort()\n    print(2 * sum(S[:k]))", "from collections import defaultdict, deque\n\ndef BFS(graph, n, dist):\n    visited = [False] * (n + 1)\n    visited[0] = True\n    queue = deque()\n    dist[0] = 0\n    queue.append(0)\n    while queue:\n        s = queue.popleft()\n        for i in graph[s]:\n            if visited[i] == False:\n                queue.append(i)\n                visited[i] = True\n                if dist[i] == -1:\n                    dist[i] = dist[s] + 1\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    cl = list(map(int, input().split()))\n    dist = [-1] * (n + 1)\n    BFS(graph, n, dist)\n    for i in range(len(cl)):\n        cl[i] = dist[cl[i]]\n    cl.sort()\n    print(2 * sum(cl[:k]))", "from collections import defaultdict, deque\n\ndef BFS(graph, n, dist):\n    visited = [False] * (n + 1)\n    visited[0] = True\n    queue = deque()\n    dist[0] = 0\n    queue.append(0)\n    while queue:\n        s = queue.popleft()\n        for i in graph[s]:\n            if visited[i] == False:\n                queue.append(i)\n                visited[i] = True\n                if dist[i] == -1:\n                    dist[i] = dist[s] + 1\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    cl = list(map(int, input().split()))\n    dist = [-1] * (n + 1)\n    BFS(graph, n, dist)\n    for i in range(len(cl)):\n        cl[i] = dist[cl[i]]\n    cl.sort()\n    print(2 * sum(cl[:k]))", "from collections import defaultdict, deque\n\ndef BFS(graph, n, dist):\n    queue = deque()\n    dist[0] = 0\n    queue.append(0)\n    while queue:\n        s = queue.popleft()\n        for i in graph[s]:\n            if dist[i] == -1:\n                queue.append(i)\n                dist[i] = dist[s] + 1\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    cl = list(map(int, input().split()))\n    dist = [-1] * (n + 1)\n    BFS(graph, n, dist)\n    for i in range(len(cl)):\n        cl[i] = dist[cl[i]]\n    cl.sort()\n    print(2 * sum(cl[:k]))", "from collections import deque\n\ndef bfs(ans_ll, v):\n    Q = deque()\n    dist = [-1 for i in range(n + 1)]\n    dist[v] = 0\n    Q.append(v)\n    while Q:\n        temp = Q.popleft()\n        for i in ans_ll[temp]:\n            if dist[i] == -1:\n                Q.append(i)\n                dist[i] = dist[temp] + 1\n    return dist\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    ans_ll = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        ans_ll[u].append(v)\n        ans_ll[v].append(u)\n    temp_arr = list(map(int, input().split()))\n    dist = bfs(ans_ll, 0)\n    for i in range(len(temp_arr)):\n        temp_arr[i] = dist[temp_arr[i]]\n    temp_arr.sort()\n    print(2 * sum(temp_arr[:k]))", "def bfs(d, i, g, k):\n    s = [(i, 0)]\n    res = 0\n    visited = set()\n    while len(s) > 0:\n        p = s.pop(0)\n        if p[0] in visited:\n            continue\n        if p[0] in g:\n            x = min(g[p[0]], k)\n            res += x * p[1] * 2\n            k -= x\n        if k == 0:\n            break\n        visited.add(p[0])\n        if p[0] in d:\n            for i in d[p[0]]:\n                s.append((i, p[1] + 1))\n    return res\nfor _ in range(int(input())):\n    (N, M, S, K) = map(int, input().split())\n    d = {}\n    for i in range(M):\n        (u, v) = map(int, input().split())\n        if u not in d:\n            d[u] = [v]\n        else:\n            d[u].append(v)\n        if v not in d:\n            d[v] = [u]\n        else:\n            d[v].append(u)\n    g = {}\n    arr = list(map(int, input().split()))\n    for i in arr:\n        if i not in g:\n            g[i] = 1\n        else:\n            g[i] += 1\n    a = bfs(d, 0, g, K)\n    print(a)", "def dfs(d, st, bud, k):\n    s = [(st, 0)]\n    v = set()\n    res = 0\n    while len(s):\n        p = s.pop(0)\n        if p[0] in v:\n            continue\n        if bud[p[0]] > 0:\n            if bud[p[0]] > k:\n                res += p[1] * k\n                k = 0\n            else:\n                res += p[1] * bud[p[0]]\n                k -= bud[p[0]]\n        if k == 0:\n            break\n        v.add(p[0])\n        for i in d[p[0]]:\n            s.append((i, p[1] + 1))\n    return res * 2\n\ndef main():\n    (n, m, s, k) = map(int, input().split())\n    d = {}\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        if u in d:\n            d[u].append(v)\n        else:\n            d[u] = [v]\n        if v in d:\n            d[v].append(u)\n        else:\n            d[v] = [u]\n    bud = {}\n    for i in range(n + 1):\n        bud[i] = 0\n    sub = list(map(int, input().split()))\n    for i in range(s):\n        bud[sub[i]] += 1\n    print(dfs(d, 0, bud, k))\nfor _ in range(int(input())):\n    main()", "import math\nimport queue\n\ndef pl(graph, V, x):\n    level = [0] * V\n    marked = [False] * V\n    que = queue.Queue()\n    que.put(x)\n    level[x] = 0\n    marked[x] = True\n    while not que.empty():\n        x = que.get()\n        for i in graph[x]:\n            b = i\n            if not marked[b]:\n                que.put(b)\n                level[b] = level[x] + 1\n                marked[b] = True\n    return level\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    graph = [[] for i in range(n + 1)]\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        graph[x].append(y)\n        graph[y].append(x)\n    lev = pl(graph, n + 1, 0)\n    ans = 0\n    l = []\n    for i in map(int, input().split()):\n        l.append(lev[i])\n    l.sort()\n    for i in range(k):\n        ans += 2 * l[i]\n    print(ans)", "from collections import defaultdict as dd\nimport sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    grp = dd(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        grp[u].append(v)\n        grp[v].append(u)\n    su = list(map(int, input().split()))\n    dis = [0 for i in range(n + 1)]\n    vis = [0 for i in range(n + 1)]\n    q = [0]\n    d = 0\n    while q:\n        sz = len(q)\n        for i in range(sz):\n            t = q.pop(0)\n            vis[t] = 1\n            dis[t] = d\n            for j in grp[t]:\n                if not vis[j]:\n                    q.append(j)\n                    vis[j] = 1\n        d += 1\n    res = []\n    for i in range(s):\n        res.append(dis[su[i]])\n    ans = 0\n    res = sorted(res)\n    for i in range(k):\n        ans += res[i]\n    print(2 * ans)", "for _ in range(int(input())):\n    (n, m, st, k) = list(map(int, input().split()))\n    a = [[] for i in range(n + 1)]\n    for i in range(m):\n        (x, y) = list(map(int, input().split()))\n        a[x].append(y)\n        a[y].append(x)\n    b = list(map(int, input().split()))\n    s = [[0, 0]]\n    t = 1\n    vis = [0 for i in range(n + 1)]\n    d = {}\n    vis[0] = 1\n    while t != 0:\n        x = s[0]\n        s.pop(0)\n        t -= 1\n        for i in a[x[0]]:\n            if vis[i] != 1:\n                s.append([i, x[1] + 1])\n                vis[i] = 1\n                d[i] = x[1] + 1\n                t += 1\n    z = []\n    for i in range(st):\n        z.append(2 * d[b[i]])\n    z.sort()\n    ans = 0\n    for i in range(k):\n        ans += z[i]\n    print(ans)", "from collections import deque\n\ndef bfs(adj_list, v):\n    Q = deque()\n    dist = [-1 for i in range(n + 1)]\n    dist[v] = 0\n    Q.append(v)\n    while Q:\n        temp = Q.popleft()\n        for i in adj_list[temp]:\n            if dist[i] == -1:\n                Q.append(i)\n                dist[i] = dist[temp] + 1\n    return dist\nfor _ in range(int(input())):\n    (n, m, s, k) = map(int, input().split())\n    adj_list = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    sub_bul = list(map(int, input().split()))\n    dist = bfs(adj_list, 0)\n    for i in range(len(sub_bul)):\n        sub_bul[i] = dist[sub_bul[i]]\n    sub_bul.sort()\n    print(2 * sum(sub_bul[:k]))", "from collections import deque\nfor _ in range(int(input())):\n    (n, m, s, k) = list(map(int, input().split()))\n    gp = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = list(map(int, input().split()))\n        gp[u].append(v)\n        gp[v].append(u)\n    a = list(map(int, input().split()))\n    q = []\n    q.append(0)\n    vis = [0] * (n + 1)\n    level = [0] * (n + 1)\n    vis[0] = 1\n    while len(q) != 0:\n        s = q.pop(0)\n        for i in gp[s]:\n            if vis[i] == 0:\n                level[i] = level[s] + 1\n                vis[i] = 1\n                q.append(i)\n    sub = []\n    for i in range(len(a)):\n        sub.append(level[a[i]])\n    sub.sort()\n    ans = 0\n    for i in range(k):\n        ans += sub[i]\n    print(2 * ans)", "from collections import deque, defaultdict\nfrom math import sqrt, ceil, factorial, floor, inf, log2, sqrt\nimport bisect\nimport sys\nimport copy\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef input():\n    return sys.stdin.readline().strip()\nfrom itertools import permutations\nfor _ in range(int(input())):\n    (n, m, s, k) = get_ints()\n    d = defaultdict(list)\n    for i in range(m):\n        (x, y) = get_ints()\n        d[x].append(y)\n        d[y].append(x)\n    s = get_array()\n    vis = [False] * (n + 1)\n    q = []\n    q.append(0)\n    vis[0] = True\n    dist = [0] * (n + 1)\n    while len(q) != 0:\n        ele = q.pop(0)\n        for x in d[ele]:\n            if vis[x] == False:\n                q.append(x)\n                vis[x] = True\n                dist[x] = dist[ele] + 1\n    ans = []\n    for i in range(len(s)):\n        ans.append(dist[s[i]])\n    ans.sort()\n    fi = 0\n    for i in range(k):\n        fi += ans[i]\n    print(2 * fi)"]