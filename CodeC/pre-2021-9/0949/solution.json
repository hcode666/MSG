["mod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (N, K) = list(map(int, input().split()))\n    if N == K:\n        print(2)\n        continue\n    sm = [0] * N\n    vals = [0] * N\n    for i in range(N):\n        if i < K:\n            vals[i] = 1\n        else:\n            vals[i] = (sm[i - K] + 1) % mod\n        if i != 0:\n            sm[i] = (sm[i - 1] + vals[i]) % mod\n        else:\n            sm[i] = vals[i] % mod\n    print((sm[-K] + 1) % mod)", "mod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (N, K) = list(map(int, input().split()))\n    if N == K:\n        print(2)\n        continue\n    sm = [0] * N\n    vals = [0] * N\n    for i in range(N):\n        if i < K:\n            vals[i] = 1\n        else:\n            vals[i] = (sm[i - K] + 1) % mod\n        if i != 0:\n            sm[i] = (sm[i - 1] + vals[i]) % mod\n        else:\n            sm[i] = vals[i] % mod\n    print((sm[-K] + 1) % mod)", "m = 10 ** 9 + 7\n\ndef solve(n, k):\n    dp = [1] * k + [0] * (n - k + 1)\n    for i in range(k, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - k]) % m\n    return dp[-1]\nfor _ in range(int(input())):\n    print(solve(*map(int, input().split())))", "for _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    dp = [0] * a\n    step = b\n    for i in range(a):\n        if i - (step - 1) >= 0:\n            dp[i] = 1 + dp[i - step]\n        if i - 1 >= 0:\n            dp[i] += dp[i - 1]\n    print(pow(dp[-1] + 1, 1, 10 ** 9 + 7))", "for _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    dp = [0] * a\n    step = b\n    for i in range(a):\n        if i - (step - 1) >= 0:\n            dp[i] = 1 + dp[i - step]\n        if i - 1 >= 0:\n            dp[i] += dp[i - 1]\n    print(pow(dp[-1] + 1, 1, 10 ** 9 + 7))", "for _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    dp = [0] * a\n    step = b\n    for i in range(a):\n        if i - (step - 1) >= 0:\n            dp[i] = 1 + dp[i - step]\n        if i - 1 >= 0:\n            dp[i] += dp[i - 1]\n    print(pow(dp[-1] + 1, 1, 10 ** 9 + 7))", "def solve(ind, step, size, memo):\n    if ind + step > size:\n        return 0\n    if ind in memo:\n        return memo[ind]\n    l = 1 + solve(ind + step, step, size, memo) + solve(ind + 1, step, size, memo)\n    if ind not in memo:\n        memo[ind] = l\n    return l\n\ndef solve1(ind, step, size):\n    if ind - (step - 1) < 0:\n        return 0\n    l = 1 + solve1(ind - step, step, size) + solve1(ind - 1, step, size)\n    return l\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    dp = [0] * a\n    step = b\n    for i in range(a):\n        if i - (step - 1) >= 0:\n            dp[i] = 1 + dp[i - step]\n        if i - 1 >= 0:\n            dp[i] += dp[i - 1]\n    print(pow(dp[-1] + 1, 1, 10 ** 9 + 7))", "from sys import stdin, stdout\ninput = stdin.readline\nmod = 10 ** 9 + 7\nN = 100001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef Binomial(N, R, p):\n    if N < R:\n        return 0\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfactorial(mod)\nt = int(input())\nfor _ in range(t):\n    (A, B) = map(int, input().split())\n    ans = 0\n    for i in range(0, A // B + 1):\n        ans += Binomial(A - (B - 1) * i, i, mod)\n        ans %= mod\n    print(ans)", "import sys\nsys.setrecursionlimit(500000)\nlearnedPairs = dict()\ntestcases = int(input())\n\ndef returnValue(pair):\n    n = pair[0]\n    k = pair[1]\n    if pair in learnedPairs:\n        return learnedPairs[pair]\n    if k == 1:\n        learnedPairs[pair] = 2 ** n\n        return 2 ** n\n    if n < 1 or k < 1 or n < k:\n        learnedPairs[pair] = 1\n        return 1\n    if n == k:\n        learnedPairs[pair] = 2\n        return 2\n    total = 0\n    total = total + returnValue((n - 1, k)) + returnValue((n - k, k))\n    learnedPairs[pair] = total\n    return total\nfor i in range(testcases):\n    pair = tuple(map(int, input().split()))\n    print(returnValue(pair) % (10 ** 9 + 7))", "import sys\nimport math\nfrom queue import Queue\nimport heapq\n\ndef main(n, k):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    mod = 10 ** 9 + 7\n    for i in range(1, n + 1):\n        if i - k >= 0:\n            dp[i] += dp[i - k]\n        dp[i] += dp[i - 1]\n        dp[i] %= mod\n    return dp[-1]\nt = int(input())\nans = []\nfor i in range(t):\n    (n, k) = list(map(int, input().split()))\n    ans.append(main(n, k))\nfor e in ans:\n    print(e)", "import sys\nimport math\nfrom queue import Queue\nimport heapq\nfactorials = [0] * (10 ** 5 + 1)\n\ndef factorialMod(n, modulus):\n    ans = 1\n    factorials[0] = 1\n    for i in range(1, n + 1):\n        ans = ans * i % modulus\n        factorials[i] = ans\n    return ans % modulus\nfactorialMod(10 ** 5, 10 ** 9 + 7)\n\ndef nCr(a, b, p=10 ** 9 + 7):\n    f = math.factorial\n    ans = factorials[int(a)] * pow(factorials[int(a - b)] * factorials[int(b)], p - 2, p)\n    return ans % p\n\ndef main(n, k):\n    ans = 0\n    mod = 10 ** 9 + 7\n    for i in range(0, n + 1):\n        num_1 = i / k\n        num_0 = n - i\n        if num_1 == int(num_1):\n            ans = (ans + int(nCr(num_1 + num_0, num_1, mod)) % mod) % mod\n    return ans % mod\nt = int(input())\nfor i in range(t):\n    (n, k) = list(map(int, input().split()))\n    print(main(n, k))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    dp = [1] * (n + 1)\n    dp[k] = 2\n    for i in range(k, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - k]) % (10 ** 9 + 7)\n    print(dp[n])", "import sys\nsys.setrecursionlimit(10 ** 6)\nm = 10 ** 9 + 7\n\ndef answer(n, k, ans):\n    if ans[n] != -1:\n        pass\n    elif n == k:\n        ans[n] = 2\n    elif n < k:\n        ans[n] = 1\n    else:\n        p1 = answer(n - k, k, ans) % m if n - k >= 0 else 0\n        p2 = answer(n - 1, k, ans) % m if n - 1 >= 0 else 0\n        ans[n] = (p1 + p2) % m\n    return ans[n]\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    ans = [-1 for i in range(100010)]\n    ans[0] = 1\n    if k == 1:\n        print(pow(2, n, m))\n    else:\n        print(answer(n, k, ans))", "ans = []\nmod = 10 ** 9 + 7\nfac = [1 for i in range(100001)]\nf = 1\nfor i in range(2, 100001):\n    f = f * i % mod\n    fac[i] = f\n\ndef ncr(n, r):\n    den = fac[r] * fac[n - r] % mod\n    return fac[n] * pow(den, mod - 2, mod) % mod\nfor t in range(int(input())):\n    [n, k] = [int(i) for i in input().split()]\n    out = 0\n    (a, b) = (n, 0)\n    while a >= 0:\n        out = (out + ncr(a + b, b)) % mod\n        a -= k\n        b += 1\n    ans.append(str(out))\nprint('\\n'.join(ans))", "mod = 10 ** 9 + 7\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    dp = [1] + [0] * n\n    for i in range(k):\n        dp[i] = 1\n    for i in range(k, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - k]) % mod\n    print(dp[-1])", "mod = 10 ** 9 + 7\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    dp = [1] + [0] * n\n    for i in range(k):\n        dp[i] = 1\n    for i in range(k, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - k]) % mod\n    print(dp[-1])", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    dp = [0] * (n + 1)\n    MOD = 10 ** 9 + 7\n    dp[0] = 1\n    for i in range(1, n + 1):\n        if i - k < 0:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = (dp[i - 1] + dp[i - k]) % MOD\n    print(dp[n])", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    dp = [0] * (n + 1)\n    MOD = 10 ** 9 + 7\n    dp[0] = 1\n    for i in range(1, n + 1):\n        if i - k < 0:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = (dp[i - 1] + dp[i - k]) % MOD\n    print(dp[n])", "test = int(input())\nmod = 1000000007\nwhile test:\n    str = input()\n    str = str.split()\n    n = int(str[0])\n    k = int(str[1])\n    dp = list()\n    dp.append(1)\n    if k == 1:\n        dp.append(2)\n    else:\n        dp.append(1)\n    for i in range(2, n + 2):\n        if i - k < 0:\n            dp.append(dp[i - 1])\n        else:\n            dp.append(dp[i - 1] + dp[i - k])\n        dp[i] %= mod\n    print(int(dp[n]))\n    test -= 1", "def Solve(n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    if Mem[n] != -1:\n        return Mem[n]\n    Mem[n] = (Solve(n - 1) + Solve(n - k[0])) % (10 ** 9 + 7)\n    return Mem[n]\nT = int(input())\nfor t in range(T):\n    (n, k) = map(int, input().split())\n    k = [k]\n    Mem = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        Mem[i] = Solve(i)\n    print(Mem[n])"]