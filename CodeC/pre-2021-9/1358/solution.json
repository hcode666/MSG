["(n, adj, newedge) = (int(input()), [], [])\n(outdegree, used, count) = ({i: 0 for i in range(n)}, [0] * n, 0)\nfor _ in range(n):\n    adj.append(list(str(input())))\n    newedge.append([0] * len(adj[0]))\nfor i in range(n):\n    outdegree[i] = adj[i].count('1')\nfor i in range(1, n + 1):\n    for j in range(n - 1, -1, -1):\n        if outdegree[j] == 0 and (not used[j]):\n            v = j\n            break\n    used[j] = True\n    for j in range(n):\n        if j != v and (not int(adj[j][v])) and (not used[j]):\n            newedge[j][v] = 1\n            count += 1\n    for j in range(n):\n        if int(adj[j][v]):\n            outdegree[j] -= 1\n(x, y) = (len(newedge), len(newedge[0]))\nprint(count)\nfor i in range(x):\n    for j in range(y):\n        if newedge[i][j] == 1:\n            print(i + 1, j + 1)", "(n, adj, newedge) = (int(input()), [], [])\n(outdegree, used, count) = ({i: 0 for i in range(n)}, [0] * n, 0)\nfor _ in range(n):\n    adj.append(list(str(input())))\n    newedge.append([0] * len(adj[0]))\nfor i in range(n):\n    outdegree[i] = adj[i].count('1')\nfor i in range(1, n + 1):\n    for j in range(n - 1, -1, -1):\n        if outdegree[j] == 0 and (not used[j]):\n            v = j\n            break\n    used[j] = True\n    for j in range(n):\n        if j != v and (not int(adj[j][v])) and (not used[j]):\n            newedge[j][v] = 1\n            count += 1\n    for j in range(n):\n        if int(adj[j][v]):\n            outdegree[j] -= 1\n(x, y) = (len(newedge), len(newedge[0]))\nprint(count)\nfor i in range(x):\n    for j in range(y):\n        if newedge[i][j] == 1:\n            print(i + 1, j + 1)", "import heapq\nimport bisect\n\ndef heappush_max(heap, item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap) - 1)\n\ndef heappop_max(heap):\n    lastelt = heap.pop()\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        heapq._siftup_max(heap, 0)\n        return returnitem\n    return lastelt\n\ndef toposort(adj, degree, n, matrix):\n    used = [0] * n\n    order = []\n    topo = []\n    new = [[] for _ in range(n)]\n    for i in range(n):\n        if degree[i] == 0:\n            heappush_max(order, i)\n    count = 0\n    while len(order) > 0:\n        x = heappop_max(order)\n        topo.append(x)\n        for i in range(0, n):\n            if matrix[i][x] == 0 and matrix[x][i] == 0 and (i != x):\n                bisect.insort(new[i], x)\n                matrix[i][x] = 1\n                count += 1\n            elif degree[i] > 0:\n                degree[i] -= 1\n                if degree[i] == 0:\n                    heappush_max(order, i)\n    return (new, count)\nn = int(input())\nadj = [[] for _ in range(n)]\nmatrix = [[0 for i in range(n)] for j in range(n)]\nans = [[] for _ in range(n)]\ndegree = [0] * n\nfor i in range(n):\n    c = 0\n    for j in input():\n        if int(j) == 1:\n            adj[i].append(c)\n        matrix[i][c] = int(j)\n        c += 1\nfor i in range(n):\n    degree[i] += len(adj[i])\n(new, count) = toposort(adj, degree, n, matrix)\nprint(count)\nfor i in range(0, n):\n    if len(new[i]) > 0:\n        for j in new[i]:\n            print(i + 1, j + 1)", "n = int(input())\nadj = []\nnewedge = []\nfor _ in range(n):\n    adj.append(list(str(input())))\n    newedge.append([0] * len(adj[0]))\noutdegree = {i: 0 for i in range(n)}\nused = [0] * n\ncount = 0\nfor i in range(n):\n    outdegree[i] = adj[i].count('1')\nfor i in range(1, n + 1):\n    for j in range(n - 1, -1, -1):\n        if outdegree[j] == 0 and (not used[j]):\n            v = j\n            break\n    used[j] = True\n    for j in range(n):\n        if j != v and (not int(adj[j][v])) and (not used[j]):\n            newedge[j][v] = 1\n            count += 1\n    for j in range(n):\n        if int(adj[j][v]):\n            outdegree[j] -= 1\nx = len(newedge)\ny = len(newedge[0])\nprint(count)\nfor i in range(x):\n    for j in range(y):\n        if newedge[i][j] == 1:\n            print(i + 1, j + 1)", "n = int(input())\nadj = []\nfor i in range(n):\n    adj.append(list(map(int, input())))\noutdegree = [0] * n\ntotaledge = n * (n - 1) // 2\nfor i in range(n):\n    for j in range(n):\n        if adj[i][j] == 1:\n            outdegree[i] += 1\n            totaledge -= 1\nused = [False] * n\nnewedge = [[False] * n for i in range(n)]\nfor i in range(n):\n    v = -1\n    for j in range(n - 1, -1, -1):\n        if not used[j] and outdegree[j] == 0:\n            v = j\n            break\n    used[v] = True\n    for j in range(n):\n        if j != v and adj[j][v] == 0 and (not used[j]):\n            newedge[j][v] = True\n        if adj[j][v] == 1:\n            outdegree[j] -= 1\nprint(totaledge)\nfor i in range(n):\n    for j in range(n):\n        if newedge[i][j]:\n            print(i + 1, j + 1)", "n = int(input())\nadj = []\nfor i in range(n):\n    adj.append(list(map(int, input())))\noutdegree = [0] * n\ntotaledge = n * (n - 1) // 2\nfor i in range(n):\n    for j in range(n):\n        if adj[i][j] == 1:\n            outdegree[i] += 1\n            totaledge -= 1\nused = [False] * n\nnewedge = [[False] * n for i in range(n)]\nfor i in range(n):\n    v = -1\n    for j in range(n - 1, -1, -1):\n        if not used[j] and outdegree[j] == 0:\n            v = j\n            break\n    used[v] = True\n    for j in range(n):\n        if j != v and adj[j][v] == 0 and (not used[j]):\n            newedge[j][v] = True\n        if adj[j][v] == 1:\n            outdegree[j] -= 1\nprint(totaledge)\nfor i in range(n):\n    for j in range(n):\n        if newedge[i][j]:\n            print(i + 1, j + 1)", "import sys\nn = int(sys.stdin.readline())\nnextEdge = [0] * n\nfor i in range(n):\n    nextEdge[i] = sys.stdin.readline().strip()\nout_degree = [0] * n\ntotal_edges = n * (n - 1) // 2\nfor i in range(n):\n    for j in range(n):\n        if nextEdge[i][j] == '1':\n            out_degree[i] += 1\n            total_edges -= 1\nused = [0] * n\nnewEdge = [[0] * n for i in range(n)]\nfor i in range(n):\n    v = -1\n    for j in range(n - 1, -1, -1):\n        if not used[j] and out_degree[j] == 0:\n            v = j\n            break\n    used[v] = True\n    for j in range(n):\n        if j != v and nextEdge[j][v] == '0' and (not used[j]):\n            newEdge[j][v] = True\n    for j in range(n):\n        if nextEdge[j][v] == '1':\n            out_degree[j] -= 1\nprint(total_edges)\nfor i in range(n):\n    for j in range(n):\n        if newEdge[i][j]:\n            print(i + 1, j + 1)"]