["import sys\nfrom collections import defaultdict\n\nclass Graph(object):\n\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.graph = defaultdict(list)\n\n    def add_edge(self, a, b):\n        self.graph[a].append(b)\n        self.graph[b].append(a)\n\n    def eulerPath(self):\n        g = self.graph\n        odd = [k for (k, v) in g.items() if len(v) % 2 == 1]\n        if len(odd) == 0:\n            odd = [list(g.keys())[0]]\n        elif len(odd) == 1 or len(odd) > 2:\n            return None\n        path = []\n        stack = [odd[-1]]\n        while stack:\n            u = stack[-1]\n            if g[u]:\n                v = g[u][0]\n                del g[u][0]\n                del g[v][g[v].index(u)]\n                stack.append(v)\n            else:\n                path.append(stack.pop())\n        return path\n(n, e) = map(int, sys.stdin.readline().strip().split())\ng = Graph(n)\nu = []\nv = []\nfor i in range(e):\n    (a, b) = map(int, sys.stdin.readline().strip().split())\n    g.add_edge(a, b)\n    u.append(a)\n    v.append(b)\nans = g.eulerPath()\nif ans is None:\n    print('NO')\nelif len(ans) == e + 1 and ans[0] == ans[-1]:\n    print('YES')\n    temp = defaultdict(defaultdict)\n    for i in range(len(ans) - 1, 0, -1):\n        temp[ans[i]][ans[i - 1]] = True\n    for i in range(e):\n        if u[i] in temp and v[i] in temp[u[i]]:\n            print(u[i], v[i])\n        else:\n            print(v[i], u[i])\nelse:\n    print('NO')", "import sys\nfrom collections import defaultdict\n\nclass Graph(object):\n\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.graph = defaultdict(list)\n\n    def add_edge(self, a, b):\n        self.graph[a].append(b)\n        self.graph[b].append(a)\n\n    def eulerPath(self):\n        g = self.graph\n        odd = [k for (k, v) in g.items() if len(v) % 2 == 1]\n        if len(odd) == 0:\n            odd = [list(g.keys())[0]]\n        elif len(odd) == 1 or len(odd) > 2:\n            return None\n        path = []\n        stack = [odd[-1]]\n        while stack:\n            u = stack[-1]\n            if g[u]:\n                v = g[u][0]\n                del g[u][0]\n                del g[v][g[v].index(u)]\n                stack.append(v)\n            else:\n                path.append(stack.pop())\n        return path\n(n, e) = map(int, sys.stdin.readline().strip().split())\ng = Graph(n)\nu = []\nv = []\nfor i in range(e):\n    (a, b) = map(int, sys.stdin.readline().strip().split())\n    g.add_edge(a, b)\n    u.append(a)\n    v.append(b)\nans = g.eulerPath()\nif ans is None:\n    print('NO')\nelif len(ans) == e + 1 and ans[0] == ans[-1]:\n    print('YES')\n    temp = defaultdict(defaultdict)\n    for i in range(len(ans) - 1, 0, -1):\n        temp[ans[i]][ans[i - 1]] = True\n    for i in range(e):\n        if u[i] in temp and v[i] in temp[u[i]]:\n            print(u[i], v[i])\n        else:\n            print(v[i], u[i])\nelse:\n    print('NO')", "class Graph(object):\n\n    def __init__(self, vertices):\n        self.vertices = vertices\n        graph = dict()\n        for i in range(1, vertices + 1):\n            graph[i] = []\n        self.graph = graph\n\n    def add_edge(self, a, b):\n        self.graph[a].append(b)\n        self.graph[b].append(a)\n\n    def eulerPath(self):\n        g = self.graph\n        odd = [k for (k, v) in g.items() if len(v) % 2 == 1]\n        if len(odd) == 0:\n            odd = [list(g.keys())[0]]\n        elif len(odd) == 1 or len(odd) > 2:\n            return None\n        path = []\n        stack = [odd[-1]]\n        while stack:\n            u = stack[-1]\n            if g[u]:\n                v = g[u][0]\n                del g[u][0]\n                del g[v][g[v].index(u)]\n                stack.append(v)\n            else:\n                path.append(stack.pop())\n        return path\n(n, e) = map(int, input().strip().split())\ng = Graph(n)\nu = []\nv = []\nfor i in range(e):\n    (a, b) = map(int, input().strip().split())\n    g.add_edge(a, b)\n    u.append(a)\n    v.append(b)\nans = g.eulerPath()\nif ans is None:\n    print('NO')\nelif len(ans) == e + 1 and ans[0] == ans[-1]:\n    print('YES')\n    temp_dict = {}\n    for i in range(len(ans) - 1, 0, -1):\n        if ans[i] in temp_dict:\n            temp_dict[ans[i]][ans[i - 1]] = True\n        else:\n            temp_dict[ans[i]] = {ans[i - 1]: True}\n    for i in range(e):\n        if u[i] in temp_dict and v[i] in temp_dict[u[i]]:\n            print(u[i], v[i])\n        else:\n            print(v[i], u[i])\nelse:\n    print('NO')", "ne = [int(k) for k in input().split()]\nn = ne[0]\ne = ne[1]\nund_adjlist = []\nund_nbrvert = []\nfor i in range(0, n):\n    und_adjlist.append([])\n    und_nbrvert.append(0)\ni = 0\nEdge = []\nwhile i < e:\n    edge = [int(x) for x in input().split()]\n    Edge.append((edge[0], edge[1]))\n    if i == 0:\n        st = edge[0]\n    p1 = edge[0]\n    p2 = edge[1]\n    und_adjlist[p1 - 1].append([p2, und_nbrvert[p2 - 1]])\n    und_adjlist[p2 - 1].append([p1, und_nbrvert[p1 - 1]])\n    und_nbrvert[p1 - 1] += 1\n    und_nbrvert[p2 - 1] += 1\n    i += 1\neven_degree_graph = 1\nfor i in range(0, n):\n    if und_nbrvert[i] % 2:\n        even_degree_graph = 0\n        break\n    else:\n        continue\nif even_degree_graph:\n    is_connected = []\n    for i in range(0, n):\n        is_connected.append(-1)\n\n    def is_empty(stack):\n        if stack == []:\n            return 1\n        else:\n            return 0\n    stack = ['a']\n    circuit = []\n    i = 0\n    curr_loc = st\n    is_connected[curr_loc - 1] = 1\n    while not is_empty(stack):\n        if i == 0:\n            stack.pop()\n        i += 1\n        if not und_adjlist[curr_loc - 1] == []:\n            adj = und_adjlist[curr_loc - 1].pop(-1)\n            if not adj == []:\n                und_nbrvert[curr_loc - 1] -= 1\n                node = adj[0]\n                is_connected[node - 1] = 1\n                stack.append(curr_loc)\n                prev_loc = curr_loc\n                curr_loc = node\n                und_adjlist[node - 1][adj[1]] = []\n                und_nbrvert[node - 1] -= 1\n        else:\n            circuit.append(curr_loc)\n            curr_loc = stack.pop()\n    circuit.append(st)\n    connected = 1\n    for x in is_connected:\n        if x != 1:\n            connected = 0\n            break\n    if connected:\n        print('YES')\n        cir_len = len(circuit)\n        order_circuit = set([])\n        i = 0\n        while i < cir_len - 1:\n            order_circuit.add((circuit[i], circuit[i + 1]))\n            i += 1\n        i = 0\n        while i < e:\n            if Edge[i] in order_circuit:\n                print(Edge[i][0], Edge[i][1])\n            else:\n                print(Edge[i][1], Edge[i][0])\n            i += 1\n    else:\n        print('NO')\nelse:\n    print('NO')", "def EulerianCycle(G, G_rev, edges):\n    start = 1\n    path = []\n    while start:\n        u = None\n        while u != start:\n            if u is None:\n                u = start\n            path.append(u)\n            if len(G[u]) == 0 and len(G_rev[u]) == 0:\n                return None\n            if len(G[u]) == 0:\n                (v, i) = G_rev[u].pop(0)\n                G_rev[v].append((u, i))\n                G[u].append((v, i))\n                G[v].remove((u, i))\n            (v, i) = G[u].pop(0)\n            G_rev[v].remove((u, i))\n            edges[i] = (u, v)\n            u = v\n        start = None\n        for u in path:\n            if len(G[u]) > 0 or len(G_rev[u]) > 0:\n                start = u\n                break\n    if len(path) > 0:\n        path.append(path[0])\n        return path\n    else:\n        return None\n\ndef DeBruijnGraph(N, edges):\n    (G, G_rev) = ([], [])\n    for _ in range(N + 1):\n        G.append([])\n        G_rev.append([])\n    for (i, (u, v)) in enumerate(edges):\n        G[u].append((v, i))\n        G_rev[v].append((u, i))\n    return (G, G_rev)\n\ndef check(N, E, edges):\n    trip = []\n    if N > E:\n        return ('NO', trip)\n    (G, G_rev) = DeBruijnGraph(N, edges)\n    path = EulerianCycle(G, G_rev, edges)\n    if path is not None and len(path) == E + 1:\n        trip = []\n        for (u, v) in edges:\n            trip.append(str(u) + ' ' + str(v))\n        return ('YES', trip)\n    else:\n        return ('NO', trip)\n(N, E) = tuple(map(int, input().strip().split()))\nedges = [tuple(map(int, input().strip().split())) for _ in range(E)]\n(result, trip) = check(N, E, edges)\nprint(result)\nif 'YES' == result:\n    print('\\n'.join(trip))", "def EulerianCycle(G, G_rev, edges):\n    if len(G) > 1:\n        start = 1\n    path = []\n    while start:\n        u = None\n        while u != start:\n            if u is None:\n                u = start\n            path.append(u)\n            if len(G[u]) == 0 and len(G_rev[u]) == 0:\n                return None\n            if len(G[u]) == 0:\n                (v, i) = G_rev[u].pop(0)\n                G_rev[v].append((u, i))\n                G[u].append((v, i))\n                G[v].remove((u, i))\n            (v, i) = G[u].pop(0)\n            G_rev[v].remove((u, i))\n            edges[i] = (u, v)\n            u = v\n        start = None\n        for (idx, u) in enumerate(path):\n            if len(G[u]) > 0 or len(G_rev[u]) > 0:\n                start = u\n                break\n    if len(path) > 0:\n        path.append(path[0])\n        return path\n    else:\n        return None\n\ndef DeBruijnGraph(N, edges):\n    (G, G_rev) = ([], [])\n    for _ in range(N + 1):\n        G.append([])\n        G_rev.append([])\n    for (i, (u, v)) in enumerate(edges):\n        G[u].append((v, i))\n        G_rev[v].append((u, i))\n    return (G, G_rev)\n\ndef check(N, E, edges):\n    trip = []\n    if N > E:\n        return ('NO', trip)\n    (G, G_rev) = DeBruijnGraph(N, edges)\n    path = EulerianCycle(G, G_rev, edges)\n    if path is not None and len(path) == E + 1:\n        trip = []\n        for (u, v) in edges:\n            trip.append(str(u) + ' ' + str(v))\n        return ('YES', trip)\n    else:\n        return ('NO', trip)\n(N, E) = tuple(map(int, input().strip().split()))\nedges = [tuple(map(int, input().strip().split())) for _ in range(E)]\n(result, trip) = check(N, E, edges)\nprint(result)\nif 'YES' == result:\n    print('\\n'.join(trip))", "def main():\n    from sys import stdin, stdout\n    import collections\n    (n, m) = map(int, stdin.readline().split())\n    adj = collections.defaultdict(list)\n    tmpstack = collections.deque()\n    resstack = collections.deque()\n    visited = [False for x in range(n)]\n    en = [0 for x in range(n)]\n    inputlist = []\n    opset = set()\n    for i in range(m):\n        (a, b) = map(int, stdin.readline().split())\n        inputlist.append((a, b))\n        en[a - 1] += 1\n        en[b - 1] += 1\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    for i in en:\n        if i & 1:\n            flag = False\n            break\n        else:\n            flag = True\n    if flag:\n        tmpstack.append(0)\n        tmpstack.appendleft(adj[0][0])\n        p = adj[0][0]\n        adj[0].remove(p)\n        adj[p].remove(0)\n        while tmpstack[0]:\n            top = tmpstack[0]\n            k = adj[top][0]\n            tmpstack.appendleft(k)\n            adj[top].remove(k)\n            adj[k].remove(top)\n        while len(tmpstack):\n            top = tmpstack[0]\n            if len(adj[top]):\n                k = adj[top][0]\n                tmpstack.appendleft(k)\n                adj[top].remove(k)\n                adj[k].remove(top)\n            else:\n                resstack.appendleft(tmpstack.popleft())\n                visited[resstack[0]] = True\n        for i in range(len(resstack) - 1):\n            opset.add((resstack[i] + 1, resstack[i + 1] + 1))\n        if all(visited):\n            stdout.write('YES\\n')\n            for i in range(len(inputlist)):\n                if inputlist[i] in opset:\n                    stdout.write(str(inputlist[i][0]) + ' ' + str(inputlist[i][1]) + '\\n')\n                else:\n                    stdout.write(str(inputlist[i][1]) + ' ' + str(inputlist[i][0]) + '\\n')\n        else:\n            stdout.write('NO\\n')\n    else:\n        stdout.write('NO\\n')\nmain()"]