["import bisect\nimport copy\nimport decimal\nimport fractions\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom functools import lru_cache, reduce\nfrom heapq import heappush, heappop, heapify, heappushpop, _heappop_max, _heapify_max\n\ndef _heappush_max(heap, item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap) - 1)\n\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        (item, heap[0]) = (heap[0], item)\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import gcd as GCD\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef Comb(N, K, mod=0):\n    if K < 0 or K > N:\n        return 0\n    K = min(K, N - K)\n    s = 1\n    if mod:\n        for i in range(N, N - K, -1):\n            s *= i\n            s %= mod\n        ss = 1\n        for i in range(1, K + 1):\n            ss *= i\n            ss %= mod\n        s *= MOD(mod).Pow(ss, -1)\n        s %= mod\n    else:\n        for i in range(N - K + 1, N + 1):\n            s *= i\n        for i in range(1, K + 1):\n            s //= i\n    return s\n\ndef Bernoulli_Numbers(N, mod=0):\n    bernoulli_numbers = [0] * (N + 1) if mod else [fractions.Fraction(0)] * (N + 1)\n    bernoulli_numbers[0] += 1\n    if mod:\n        MD = MOD(mod)\n        MD.Build_Fact(N + 1)\n        for i in range(1, N + 1):\n            bernoulli_numbers[i] = -MD.Pow(i + 1, -1) * sum((MD.Comb(i + 1, j) * bernoulli_numbers[j] for j in range(i))) % mod\n    else:\n        for i in range(1, N + 1):\n            bernoulli_numbers[i] = -sum((Comb(i + 1, j) * bernoulli_numbers[j] for j in range(i))) / (i + 1)\n    return bernoulli_numbers\n\nclass Faulhaber:\n\n    def __init__(self, K, mod=0):\n        self.K = K\n        self.mod = mod\n        if self.mod:\n            bernoulli_numbers = Bernoulli_Numbers(self.K, self.mod)\n            MD = MOD(self.mod)\n            MD.Build_Fact(self.K + 1)\n            inve = MD.Pow(self.K + 1, -1)\n            self.coefficient = [bernoulli_numbers[i] * MD.Comb(self.K + 1, i) * inve % mod for i in range(self.K + 1)]\n            for i in range(1, self.K + 1, 2):\n                self.coefficient[i] *= -1\n                self.coefficient[i] %= mod\n        else:\n            bernoulli_numbers = Bernoulli_Numbers(self.K)\n            self.coefficient = [bernoulli_numbers[i] * Comb(self.K + 1, i) / (K + 1) for i in range(self.K + 1)]\n            for i in range(1, self.K + 1, 2):\n                self.coefficient[i] *= -1\n\n    def __call__(self, N):\n        retu = 0\n        N_pow = N\n        for i in range(self.K + 1):\n            retu += N_pow * self.coefficient[self.K - i]\n            N_pow *= N\n            if self.mod:\n                retu %= self.mod\n                N_pow %= self.mod\n        return retu\n\ndef Extended_Euclid(n, m):\n    stack = []\n    while m:\n        stack.append((n, m))\n        (n, m) = (m, n % m)\n    if n >= 0:\n        (x, y) = (1, 0)\n    else:\n        (x, y) = (-1, 0)\n    for i in range(len(stack) - 1, -1, -1):\n        (n, m) = stack[i]\n        (x, y) = (y, x - n // m * y)\n    return (x, y)\n\nclass MOD:\n\n    def __init__(self, p, e=1):\n        self.p = p\n        self.e = e\n        self.mod = self.p ** self.e\n\n    def Pow(self, a, n):\n        a %= self.mod\n        if n >= 0:\n            return pow(a, n, self.mod)\n        else:\n            assert math.gcd(a, self.mod) == 1\n            x = Extended_Euclid(a, self.mod)[0]\n            return pow(x, -n, self.mod)\n\n    def Build_Fact(self, N):\n        assert N >= 0\n        self.factorial = [1]\n        self.cnt = [0] * (N + 1)\n        for i in range(1, N + 1):\n            ii = i\n            self.cnt[i] = self.cnt[i - 1]\n            while ii % self.p == 0:\n                ii //= self.p\n                self.cnt[i] += 1\n            self.factorial.append(self.factorial[-1] * ii % self.mod)\n        self.factorial_inve = [None] * (N + 1)\n        self.factorial_inve[-1] = self.Pow(self.factorial[-1], -1)\n        for i in range(N - 1, -1, -1):\n            ii = i + 1\n            while ii % self.p == 0:\n                ii //= self.p\n            self.factorial_inve[i] = self.factorial_inve[i + 1] * ii % self.mod\n\n    def Fact(self, N):\n        return self.factorial[N] * pow(self.p, self.cnt[N], self.mod) % self.mod\n\n    def Fact_Inve(self, N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inve[N]\n\n    def Comb(self, N, K, divisible_count=False):\n        if K < 0 or K > N:\n            return 0\n        retu = self.factorial[N] * self.factorial_inve[K] * self.factorial_inve[N - K] % self.mod\n        cnt = self.cnt[N] - self.cnt[N - K] - self.cnt[K]\n        if divisible_count:\n            return (retu, cnt)\n        else:\n            retu *= pow(self.p, cnt, self.mod)\n            retu %= self.mod\n            return retu\n(N, K, M) = map(int, readline().split())\nF = Faulhaber(K)\nlst = []\nNN = N\nfor p in range(2, 10 ** 6):\n    if NN % p == 0:\n        lst.append(p)\n        while NN % p == 0:\n            NN //= p\nif NN != 1:\n    lst.append(NN)\nl = len(lst)\nans = 0\nfor bit in range(1 << l):\n    NN = N\n    cnt = 0\n    for i in range(l):\n        if bit >> i & 1:\n            NN //= lst[i]\n            cnt += 1\n    if cnt % 2:\n        ans -= F(NN) * pow(N // NN, K, M)\n    else:\n        ans += F(NN) * pow(N // NN, K, M)\n    ans %= M\nprint(ans)", "import bisect\nimport copy\nimport decimal\nimport fractions\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom functools import lru_cache, reduce\nfrom heapq import heappush, heappop, heapify, heappushpop, _heappop_max, _heapify_max\n\ndef _heappush_max(heap, item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap) - 1)\n\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        (item, heap[0]) = (heap[0], item)\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import gcd as GCD\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef Comb(N, K, mod=0):\n    if K < 0 or K > N:\n        return 0\n    K = min(K, N - K)\n    s = 1\n    if mod:\n        for i in range(N, N - K, -1):\n            s *= i\n            s %= mod\n        ss = 1\n        for i in range(1, K + 1):\n            ss *= i\n            ss %= mod\n        s *= MOD(mod).Pow(ss, -1)\n        s %= mod\n    else:\n        for i in range(N - K + 1, N + 1):\n            s *= i\n        for i in range(1, K + 1):\n            s //= i\n    return s\n\ndef Bernoulli_Numbers(N, mod=0):\n    bernoulli_numbers = [0] * (N + 1) if mod else [fractions.Fraction(0)] * (N + 1)\n    bernoulli_numbers[0] += 1\n    if mod:\n        MD = MOD(mod)\n        MD.Build_Fact(N + 1)\n        for i in range(1, N + 1):\n            bernoulli_numbers[i] = -MD.Pow(i + 1, -1) * sum((MD.Comb(i + 1, j) * bernoulli_numbers[j] for j in range(i))) % mod\n    else:\n        for i in range(1, N + 1):\n            bernoulli_numbers[i] = -sum((Comb(i + 1, j) * bernoulli_numbers[j] for j in range(i))) / (i + 1)\n    return bernoulli_numbers\n\nclass Faulhaber:\n\n    def __init__(self, K, mod=0):\n        self.K = K\n        self.mod = mod\n        if self.mod:\n            bernoulli_numbers = Bernoulli_Numbers(self.K, self.mod)\n            MD = MOD(self.mod)\n            MD.Build_Fact(self.K + 1)\n            inve = MD.Pow(self.K + 1, -1)\n            self.coefficient = [bernoulli_numbers[i] * MD.Comb(self.K + 1, i) * inve % mod for i in range(self.K + 1)]\n            for i in range(1, self.K + 1, 2):\n                self.coefficient[i] *= -1\n                self.coefficient[i] %= mod\n        else:\n            bernoulli_numbers = Bernoulli_Numbers(self.K)\n            self.coefficient = [bernoulli_numbers[i] * Comb(self.K + 1, i) / (K + 1) for i in range(self.K + 1)]\n            for i in range(1, self.K + 1, 2):\n                self.coefficient[i] *= -1\n\n    def __call__(self, N):\n        retu = 0\n        N_pow = N\n        for i in range(self.K + 1):\n            retu += N_pow * self.coefficient[self.K - i]\n            N_pow *= N\n            if self.mod:\n                retu %= self.mod\n                N_pow %= self.mod\n        return retu\n\ndef Extended_Euclid(n, m):\n    stack = []\n    while m:\n        stack.append((n, m))\n        (n, m) = (m, n % m)\n    if n >= 0:\n        (x, y) = (1, 0)\n    else:\n        (x, y) = (-1, 0)\n    for i in range(len(stack) - 1, -1, -1):\n        (n, m) = stack[i]\n        (x, y) = (y, x - n // m * y)\n    return (x, y)\n\nclass MOD:\n\n    def __init__(self, p, e=1):\n        self.p = p\n        self.e = e\n        self.mod = self.p ** self.e\n\n    def Pow(self, a, n):\n        a %= self.mod\n        if n >= 0:\n            return pow(a, n, self.mod)\n        else:\n            assert math.gcd(a, self.mod) == 1\n            x = Extended_Euclid(a, self.mod)[0]\n            return pow(x, -n, self.mod)\n\n    def Build_Fact(self, N):\n        assert N >= 0\n        self.factorial = [1]\n        self.cnt = [0] * (N + 1)\n        for i in range(1, N + 1):\n            ii = i\n            self.cnt[i] = self.cnt[i - 1]\n            while ii % self.p == 0:\n                ii //= self.p\n                self.cnt[i] += 1\n            self.factorial.append(self.factorial[-1] * ii % self.mod)\n        self.factorial_inve = [None] * (N + 1)\n        self.factorial_inve[-1] = self.Pow(self.factorial[-1], -1)\n        for i in range(N - 1, -1, -1):\n            ii = i + 1\n            while ii % self.p == 0:\n                ii //= self.p\n            self.factorial_inve[i] = self.factorial_inve[i + 1] * ii % self.mod\n\n    def Fact(self, N):\n        return self.factorial[N] * pow(self.p, self.cnt[N], self.mod) % self.mod\n\n    def Fact_Inve(self, N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inve[N]\n\n    def Comb(self, N, K, divisible_count=False):\n        if K < 0 or K > N:\n            return 0\n        retu = self.factorial[N] * self.factorial_inve[K] * self.factorial_inve[N - K] % self.mod\n        cnt = self.cnt[N] - self.cnt[N - K] - self.cnt[K]\n        if divisible_count:\n            return (retu, cnt)\n        else:\n            retu *= pow(self.p, cnt, self.mod)\n            retu %= self.mod\n            return retu\n(N, K, M) = map(int, readline().split())\nF = Faulhaber(K)\nlst = []\nNN = N\nfor p in range(2, 10 ** 6):\n    if NN % p == 0:\n        lst.append(p)\n        while NN % p == 0:\n            NN //= p\nif NN != 1:\n    lst.append(NN)\nl = len(lst)\nans = 0\nfor bit in range(1 << l):\n    NN = N\n    cnt = 0\n    for i in range(l):\n        if bit >> i & 1:\n            NN //= lst[i]\n            cnt += 1\n    if cnt % 2:\n        ans -= F(NN) * pow(N // NN, K, M)\n    else:\n        ans += F(NN) * pow(N // NN, K, M)\n    ans %= M\nprint(ans)", "import bisect\nimport copy\nimport decimal\nimport fractions\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom functools import lru_cache, reduce\nfrom heapq import heappush, heappop, heapify, heappushpop, _heappop_max, _heapify_max\n\ndef _heappush_max(heap, item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap) - 1)\n\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        (item, heap[0]) = (heap[0], item)\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import gcd as GCD\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef Comb(N, K, mod=0):\n    if K < 0 or K > N:\n        return 0\n    K = min(K, N - K)\n    s = 1\n    if mod:\n        for i in range(N, N - K, -1):\n            s *= i\n            s %= mod\n        ss = 1\n        for i in range(1, K + 1):\n            ss *= i\n            ss %= mod\n        s *= MOD(mod).Pow(ss, -1)\n        s %= mod\n    else:\n        for i in range(N - K + 1, N + 1):\n            s *= i\n        for i in range(1, K + 1):\n            s //= i\n    return s\n\ndef Bernoulli_Numbers(N, mod=0):\n    bernoulli_numbers = [0] * (N + 1) if mod else [fractions.Fraction(0)] * (N + 1)\n    bernoulli_numbers[0] += 1\n    if mod:\n        MD = MOD(mod)\n        MD.Build_Fact(N + 1)\n        for i in range(1, N + 1):\n            bernoulli_numbers[i] = -MD.Pow(i + 1, -1) * sum((MD.Comb(i + 1, j) * bernoulli_numbers[j] for j in range(i))) % mod\n    else:\n        for i in range(1, N + 1):\n            bernoulli_numbers[i] = -sum((Comb(i + 1, j) * bernoulli_numbers[j] for j in range(i))) / (i + 1)\n    return bernoulli_numbers\n\nclass Faulhaber:\n\n    def __init__(self, K, mod=0):\n        self.K = K\n        self.mod = mod\n        if self.mod:\n            bernoulli_numbers = Bernoulli_Numbers(self.K, self.mod)\n            MD = MOD(self.mod)\n            MD.Build_Fact(self.K + 1)\n            inve = MD.Pow(self.K + 1, -1)\n            self.coefficient = [bernoulli_numbers[i] * MD.Comb(self.K + 1, i) * inve % mod for i in range(self.K + 1)]\n            for i in range(1, self.K + 1, 2):\n                self.coefficient[i] *= -1\n                self.coefficient[i] %= mod\n        else:\n            bernoulli_numbers = Bernoulli_Numbers(self.K)\n            self.coefficient = [bernoulli_numbers[i] * Comb(self.K + 1, i) / (K + 1) for i in range(self.K + 1)]\n            for i in range(1, self.K + 1, 2):\n                self.coefficient[i] *= -1\n\n    def __call__(self, N):\n        retu = 0\n        N_pow = N\n        for i in range(self.K + 1):\n            retu += N_pow * self.coefficient[self.K - i]\n            N_pow *= N\n            if self.mod:\n                retu %= self.mod\n                N_pow %= self.mod\n        return retu\n\ndef Extended_Euclid(n, m):\n    stack = []\n    while m:\n        stack.append((n, m))\n        (n, m) = (m, n % m)\n    if n >= 0:\n        (x, y) = (1, 0)\n    else:\n        (x, y) = (-1, 0)\n    for i in range(len(stack) - 1, -1, -1):\n        (n, m) = stack[i]\n        (x, y) = (y, x - n // m * y)\n    return (x, y)\n\nclass MOD:\n\n    def __init__(self, p, e=1):\n        self.p = p\n        self.e = e\n        self.mod = self.p ** self.e\n\n    def Pow(self, a, n):\n        a %= self.mod\n        if n >= 0:\n            return pow(a, n, self.mod)\n        else:\n            assert math.gcd(a, self.mod) == 1\n            x = Extended_Euclid(a, self.mod)[0]\n            return pow(x, -n, self.mod)\n\n    def Build_Fact(self, N):\n        assert N >= 0\n        self.factorial = [1]\n        self.cnt = [0] * (N + 1)\n        for i in range(1, N + 1):\n            ii = i\n            self.cnt[i] = self.cnt[i - 1]\n            while ii % self.p == 0:\n                ii //= self.p\n                self.cnt[i] += 1\n            self.factorial.append(self.factorial[-1] * ii % self.mod)\n        self.factorial_inve = [None] * (N + 1)\n        self.factorial_inve[-1] = self.Pow(self.factorial[-1], -1)\n        for i in range(N - 1, -1, -1):\n            ii = i + 1\n            while ii % self.p == 0:\n                ii //= self.p\n            self.factorial_inve[i] = self.factorial_inve[i + 1] * ii % self.mod\n\n    def Fact(self, N):\n        return self.factorial[N] * pow(self.p, self.cnt[N], self.mod) % self.mod\n\n    def Fact_Inve(self, N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inve[N]\n\n    def Comb(self, N, K, divisible_count=False):\n        if K < 0 or K > N:\n            return 0\n        retu = self.factorial[N] * self.factorial_inve[K] * self.factorial_inve[N - K] % self.mod\n        cnt = self.cnt[N] - self.cnt[N - K] - self.cnt[K]\n        if divisible_count:\n            return (retu, cnt)\n        else:\n            retu *= pow(self.p, cnt, self.mod)\n            retu %= self.mod\n            return retu\n(N, K, M) = map(int, readline().split())\nF = Faulhaber(K)\nlst = []\nNN = N\nfor p in range(2, 10 ** 6):\n    if NN % p == 0:\n        lst.append(p)\n        while NN % p == 0:\n            NN //= p\nif NN != 1:\n    lst.append(NN)\nl = len(lst)\nans = 0\nfor bit in range(1 << l):\n    NN = N\n    cnt = 0\n    for i in range(l):\n        if bit >> i & 1:\n            NN //= lst[i]\n            cnt += 1\n    if cnt % 2:\n        ans -= F(NN) * pow(N // NN, K, M)\n    else:\n        ans += F(NN) * pow(N // NN, K, M)\n    ans %= M\nprint(ans)", "import bisect\nimport copy\nimport decimal\nimport fractions\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom functools import lru_cache, reduce\nfrom heapq import heappush, heappop, heapify, heappushpop, _heappop_max, _heapify_max\n\ndef _heappush_max(heap, item):\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap) - 1)\n\ndef _heappushpop_max(heap, item):\n    if heap and item < heap[0]:\n        (item, heap[0]) = (heap[0], item)\n        heapq._siftup_max(heap, 0)\n    return item\nfrom math import gcd as GCD\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef Comb(N, K, mod=0):\n    if K < 0 or K > N:\n        return 0\n    K = min(K, N - K)\n    s = 1\n    if mod:\n        for i in range(N, N - K, -1):\n            s *= i\n            s %= mod\n        ss = 1\n        for i in range(1, K + 1):\n            ss *= i\n            ss %= mod\n        s *= MOD(mod).Pow(ss, -1)\n        s %= mod\n    else:\n        for i in range(N - K + 1, N + 1):\n            s *= i\n        for i in range(1, K + 1):\n            s //= i\n    return s\n\ndef Bernoulli_Numbers(N):\n    bernoulli_numbers = [fractions.Fraction(0)] * (N + 1)\n    bernoulli_numbers[0] += 1\n    for i in range(1, N + 1):\n        bernoulli_numbers[i] = -sum((Comb(i + 1, j) * bernoulli_numbers[j] for j in range(i))) / (i + 1)\n    return bernoulli_numbers\n\ndef Extended_Euclid(n, m):\n    stack = []\n    while m:\n        stack.append((n, m))\n        (n, m) = (m, n % m)\n    if n >= 0:\n        (x, y) = (1, 0)\n    else:\n        (x, y) = (-1, 0)\n    for i in range(len(stack) - 1, -1, -1):\n        (n, m) = stack[i]\n        (x, y) = (y, x - n // m * y)\n    return (x, y)\n\nclass MOD:\n\n    def __init__(self, p, e=1):\n        self.p = p\n        self.e = e\n        self.mod = self.p ** self.e\n\n    def Pow(self, a, n):\n        a %= self.mod\n        if n >= 0:\n            return pow(a, n, self.mod)\n        else:\n            assert math.gcd(a, self.mod) == 1\n            x = Extended_Euclid(a, self.mod)[0]\n            return pow(x, -n, self.mod)\n\n    def Build_Fact(self, N):\n        assert N >= 0\n        self.factorial = [1]\n        self.cnt = [0] * (N + 1)\n        for i in range(1, N + 1):\n            ii = i\n            self.cnt[i] = self.cnt[i - 1]\n            while ii % self.p == 0:\n                ii //= self.p\n                self.cnt[i] += 1\n            self.factorial.append(self.factorial[-1] * ii % self.mod)\n        self.factorial_inve = [None] * (N + 1)\n        self.factorial_inve[-1] = self.Pow(self.factorial[-1], -1)\n        for i in range(N - 1, -1, -1):\n            ii = i + 1\n            while ii % self.p == 0:\n                ii //= self.p\n            self.factorial_inve[i] = self.factorial_inve[i + 1] * ii % self.mod\n\n    def Fact(self, N):\n        return self.factorial[N] * pow(self.p, self.cnt[N], self.mod) % self.mod\n\n    def Fact_Inve(self, N):\n        if self.cnt[N]:\n            return None\n        return self.factorial_inve[N]\n\n    def Comb(self, N, K, divisible_count=False):\n        if K < 0 or K > N:\n            return 0\n        retu = self.factorial[N] * self.factorial_inve[K] * self.factorial_inve[N - K] % self.mod\n        cnt = self.cnt[N] - self.cnt[N - K] - self.cnt[K]\n        if divisible_count:\n            return (retu, cnt)\n        else:\n            retu *= pow(self.p, cnt, self.mod)\n            retu %= self.mod\n            return retu\n\nclass Faulhaber:\n\n    def __init__(self, K):\n        self.K = K\n        bernoulli_numbers = Bernoulli_Numbers(self.K)\n        self.coefficient = [bernoulli_numbers[i] * Comb(self.K + 1, i) / (K + 1) for i in range(self.K + 1)]\n        for i in range(1, self.K + 1, 2):\n            self.coefficient[i] *= -1\n\n    def __call__(self, N):\n        retu = 0\n        N_pow = N\n        for i in range(self.K + 1):\n            retu += N_pow * self.coefficient[self.K - i]\n            N_pow *= N\n        return retu\n(N, K, M) = map(int, readline().split())\nF = Faulhaber(K)\nlst = []\nNN = N\nfor p in range(2, 10 ** 6):\n    if NN % p == 0:\n        lst.append(p)\n        while NN % p == 0:\n            NN //= p\nif NN != 1:\n    lst.append(NN)\nl = len(lst)\nans = 0\nfor bit in range(1 << l):\n    NN = N\n    cnt = 0\n    for i in range(l):\n        if bit >> i & 1:\n            NN //= lst[i]\n            cnt += 1\n    if cnt % 2:\n        ans -= F(NN) * pow(N // NN, K, M)\n    else:\n        ans += F(NN) * pow(N // NN, K, M)\n    ans %= M\nprint(ans)"]