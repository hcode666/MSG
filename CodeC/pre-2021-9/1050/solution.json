["import sys\nsys.setrecursionlimit(10 ** 8)\nx4 = [-1, 0, 1, 0]\ny4 = [0, 1, 0, -1]\n\ndef dfs(i, j, count):\n    if i < 0 or j < 0 or i >= r or (j >= c):\n        return\n    if mat[i][j] == 0:\n        return\n    mat[i][j] = 0\n    count[0] += 1\n    for d in range(4):\n        ni = i + x4[d]\n        nj = j + y4[d]\n        dfs(ni, nj, count)\nt = int(input())\nfor x in range(t):\n    (r, c) = map(int, input().split())\n    mat = []\n    for i in range(r):\n        s = input()\n        ls = [int(i) for i in s]\n        mat.append(ls)\n    ans = []\n    for i in range(r):\n        for j in range(c):\n            if mat[i][j] == 1:\n                count = [0]\n                dfs(i, j, count)\n                ans.append(count[0])\n    ans.sort(reverse=True)\n    k = len(ans)\n    cnt = 0\n    for i in range(1, k, 2):\n        cnt += ans[i]\n    print(cnt)", "from sys import setrecursionlimit\nsetrecursionlimit(100000)\n\ndef get_count(a, index, n, m):\n    if a[index[0]][index[1]] == 0:\n        return 0\n    a[index[0]][index[1]] = 0\n    ans = 1\n    if index[0] - 1 >= 0 and a[index[0] - 1][index[1]]:\n        ans += get_count(a, (index[0] - 1, index[1]), n, m)\n    if index[0] + 1 < n and a[index[0] + 1][index[1]]:\n        ans += get_count(a, (index[0] + 1, index[1]), n, m)\n    if index[1] - 1 >= 0 and a[index[0]][index[1] - 1]:\n        ans += get_count(a, (index[0], index[1] - 1), n, m)\n    if index[1] + 1 < m and a[index[0]][index[1] + 1]:\n        ans += get_count(a, (index[0], index[1] + 1), n, m)\n    return ans\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, input())))\n    output = []\n    for i in range(n):\n        for j in range(m):\n            if a[i][j]:\n                temp = get_count(a, (i, j), n, m)\n                if temp > 0:\n                    output.append(temp)\n    print(sum(sorted(output, reverse=True)[1::2]))", "from cmath import pi\nfrom distutils import extension\nimport sys\nfrom math import gcd, sqrt, log10, log2, floor, ceil\nfrom collections import deque, defaultdict\nfrom tkinter.tix import Tree\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\n\ndef il(sep=' '):\n    return [int(a) for a in input().strip().split(sep)]\n\ndef ip():\n    return input().strip()\n\ndef ii():\n    return int(input())\n\ndef ot(in_p, *args, e=' '):\n    if type(in_p) == list:\n        print(*in_p, end=e)\n    if type(in_p) == str or type(in_p) == int:\n        print(in_p, end=e)\n        for l in args:\n            print(l, end=e)\n    print()\n\ndef rg(*ag):\n    if len(ag) == 3:\n        return range(ag[0], ag[1], ag[2])\n    elif len(ag) == 2:\n        return range(ag[0], ag[1])\n    elif len(ag) == 1:\n        return range(ag[0])\n    else:\n        raise 'invalid input'\n\ndef ispal(i, j, st):\n    while i <= j:\n        if st[i] == st[j]:\n            i = i + 1\n            j = j - 1\n        else:\n            return False\n    return True\nmod = 1000000000 + 7\n\ndef dfs(mat, x, y, dx, dy, c):\n    mat[x][y] = 0\n    for i in range(4):\n        if 0 <= x + dx[i] < len(mat) and 0 <= y + dy[i] < len(mat[0]) and (mat[x + dx[i]][y + dy[i]] == 1):\n            c[0] += 1\n            dfs(mat, x + dx[i], y + dy[i], dx, dy, c)\nfor _ in range(ii()):\n    (n, m) = il()\n    mat = []\n    for l in range(n):\n        re = ip()\n        li = []\n        for k in re:\n            li.append(int(k))\n        mat.append(li)\n    ans = []\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, 1, -1]\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == 1:\n                c = [1]\n                dfs(mat, i, j, dx, dy, c)\n                ans.append(c[0])\n    ans.sort(reverse=True)\n    res = 0\n    for l in range(1, len(ans), 2):\n        res = res + ans[l]\n    ot(res)", "from sys import setrecursionlimit\nsetrecursionlimit(100000)\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    arr = []\n    for _ in range(n):\n        arr.append(list(map(int, list(input()))))\n    area = []\n\n    def dfs(x, y):\n        arr[x][y] = 0\n        res = 1\n        for (a, b) in [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]]:\n            if n > a >= 0 and m > b >= 0 and arr[a][b]:\n                res += dfs(a, b)\n        return res\n    for i in range(n):\n        for j in range(m):\n            if arr[i][j]:\n                area.append(dfs(i, j))\n    print(sum(sorted(area, reverse=True)[1::2]))", "from sys import setrecursionlimit\nsetrecursionlimit(100000)\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    arr = []\n    for _ in range(n):\n        arr.append(list(map(int, list(input()))))\n    area = []\n\n    def dfs(x, y):\n        if arr[x][y] != 1:\n            return 0\n        arr[x][y] = 0\n        res = 1\n        for (a, b) in [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]]:\n            if n > a >= 0 and m > b >= 0:\n                res += dfs(a, b)\n        return res\n    for i in range(n):\n        for j in range(m):\n            if arr[i][j]:\n                area.append(dfs(i, j))\n    print(sum(sorted(area, reverse=True)[1::2]))", "def funcConnected(Map, pos):\n    count = 0\n    p = []\n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    p.append(pos)\n    while len(p) != 0:\n        point = p.pop()\n        count += 1\n        for (dx, dy) in moves:\n            x = point[0] + dx\n            y = point[1] + dy\n            if x >= 0 and y >= 0 and (x < len(Map)) and (y < len(Map[x])):\n                if Map[x][y] == '1':\n                    Map[x][y] = '0'\n                    p.append(tuple([x, y]))\n    if count > 1:\n        count -= 1\n    return count\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    Map = []\n    for i in range(n):\n        inp = list(input())\n        Map.append(inp)\n    sizes = []\n    for i in range(n):\n        for j in range(m):\n            if Map[i][j] == '1':\n                sizes.append(funcConnected(Map, [i, j]))\n    chef = 0\n    sizes.sort(reverse=True)\n    for i in range(1, len(sizes), 2):\n        chef += sizes[i]\n    print(chef)", "import numpy as np\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    www = []\n    for ii in range(n):\n        www += [[int(iit) for iit in input()]]\n    www = np.array(www)\n    col = 2\n    for ii in range(n):\n        for jj in range(m):\n            if www[ii][jj] == 1:\n                col += 1\n                st = []\n                www[ii][jj] = col\n                if ii != 0:\n                    st += [(ii - 1, jj)]\n                if jj != 0:\n                    st += [(ii, jj - 1)]\n                if ii != n - 1:\n                    st += [(ii + 1, jj)]\n                if jj != m - 1:\n                    st += [(ii, jj + 1)]\n                while len(st) != 0:\n                    q = st.pop()\n                    (iii, jjj) = q\n                    if www[iii, jjj] == 1:\n                        if iii != 0:\n                            st += [(iii - 1, jjj)]\n                        if jjj != 0:\n                            st += [(iii, jjj - 1)]\n                        if iii != n - 1:\n                            st += [(iii + 1, jjj)]\n                        if jjj != m - 1:\n                            st += [(iii, jjj + 1)]\n                        www[iii][jjj] = col\n    (xxx, yyy) = np.unique([jh for hj in www for jh in hj], return_counts=True)\n    if xxx[0] == 0:\n        yyy = yyy[1:]\n    res = 0\n    for (u, uu) in enumerate(np.sort(yyy)[::-1]):\n        if u % 2 == 1:\n            res += uu\n    print(res)", "import collections\n\ndef validIndex(i, j, n, m):\n    if i in range(0, n) and j in range(0, m):\n        return True\n    return False\n\ndef chefScore(mat, n, m):\n    res_arr = []\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '1':\n                q = collections.deque([[i, j]])\n                count = 0\n                while len(q) > 0:\n                    s = q.pop()\n                    (l, k) = (s[0], s[1])\n                    if validIndex(l, k, n, m) and mat[l][k] == '1':\n                        count += 1\n                        q.appendleft([l + 1, k])\n                        q.appendleft([l - 1, k])\n                        q.appendleft([l, k + 1])\n                        q.appendleft([l, k - 1])\n                        mat[l][k] = '0'\n                res_arr.append(count)\n    res_arr.sort(reverse=True)\n    chef_score = 0\n    if len(res_arr) < 2:\n        return 0\n    for i in range(1, len(res_arr), 2):\n        chef_score += res_arr[i]\n    return chef_score\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(list(input()))\n    print(chefScore(arr, n, m))", "dx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\ndef valid(x, y):\n    if 0 <= x < n and 0 <= y < m and (visited[x][y] == False) and (l[x][y] == '1'):\n        return True\n    return False\n\ndef dfs(nodex, nodey):\n    visited[nodex][nodey] = True\n    stack = [[nodex, nodey]]\n    c = 1\n    while stack:\n        (nodex, nodey) = stack.pop()\n        for i in range(4):\n            if valid(nodex + dx[i], nodey + dy[i]):\n                newx = nodex + dx[i]\n                newy = nodey + dy[i]\n                visited[newx][newy] = True\n                c = c + 1\n                stack.append([newx, newy])\n    return c\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        k = list(input())\n        l.append(k)\n    visited = [[False for i in range(m)] for j in range(n)]\n    ans = []\n    for i in range(n):\n        for j in range(m):\n            if visited[i][j] == False and l[i][j] == '1':\n                c = dfs(i, j)\n                ans.append(c)\n    ans.sort(reverse=True)\n    n = len(ans)\n    s = 0\n    for i in range(n):\n        if i % 2:\n            s = s + ans[i]\n    print(s)", "import collections\n\ndef validIndex(i, j, n, m):\n    if i in range(0, n) and j in range(0, m):\n        return True\n    return False\n\ndef chefScore(mat, n, m):\n    res_arr = []\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '1':\n                q = collections.deque([[i, j]])\n                count = 0\n                while len(q) > 0:\n                    s = q.pop()\n                    (l, k) = (s[0], s[1])\n                    if validIndex(l, k, n, m) and mat[l][k] == '1':\n                        count += 1\n                        q.appendleft([l + 1, k])\n                        q.appendleft([l - 1, k])\n                        q.appendleft([l, k + 1])\n                        q.appendleft([l, k - 1])\n                        mat[l][k] = '0'\n                res_arr.append(count)\n    res_arr.sort(reverse=True)\n    chef_score = 0\n    if len(res_arr) < 2:\n        return 0\n    for i in range(1, len(res_arr), 2):\n        chef_score += res_arr[i]\n    return chef_score\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(list(input()))\n    print(chefScore(arr, n, m))", "import sys\nsys.setrecursionlimit(1000000)\n\ndef dfs(i, j):\n    vi[i][j] = 1\n    c[0] += 1\n    for (x, y) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n        if x >= 0 and y >= 0 and (x < n) and (y < m) and (a[x][y] == 1) and (vi[x][y] == 0):\n            dfs(x, y)\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input())))\n    vi = [[0 for i in range(m)] for j in range(n)]\n    co = []\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1 and vi[i][j] == 0:\n                c = [0]\n                dfs(i, j)\n                co.append(c[0])\n    co.sort()\n    co.reverse()\n    fc = 0\n    for i in range(len(co)):\n        if i % 2 != 0:\n            fc += co[i]\n    print(fc)", "dx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\ndef valid(x, y):\n    if 0 <= x < n and 0 <= y < m and (visited[x][y] == False) and (l[x][y] == '1'):\n        return True\n    return False\n\ndef dfs(nodex, nodey):\n    visited[nodex][nodey] = True\n    stack = [[nodex, nodey]]\n    c = 1\n    while stack:\n        (nodex, nodey) = stack.pop()\n        for i in range(4):\n            if valid(nodex + dx[i], nodey + dy[i]):\n                newx = nodex + dx[i]\n                newy = nodey + dy[i]\n                visited[newx][newy] = True\n                c = c + 1\n                stack.append([newx, newy])\n    return c\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        k = list(input())\n        l.append(k)\n    visited = [[False for i in range(m)] for j in range(n)]\n    ans = []\n    for i in range(n):\n        for j in range(m):\n            if visited[i][j] == False and l[i][j] == '1':\n                c = dfs(i, j)\n                ans.append(c)\n    ans.sort(reverse=True)\n    n = len(ans)\n    s = 0\n    for i in range(n):\n        if i % 2:\n            s = s + ans[i]\n    print(s)", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ndx = [1, -1, 0, 0]\ndy = [0, 0, 1, -1]\n\ndef solve():\n\n    def valid(a, b):\n        if a >= n or b >= m or a < 0 or (b < 0):\n            return False\n        if l[a][b] == '0' or (a, b) in visited:\n            return False\n        return True\n\n    def dfs(i, j):\n        stack = [(i, j)]\n        visited[i, j] = 1\n        s = 1\n        while stack:\n            (a, b) = stack.pop()\n            for i in range(4):\n                (x, y) = (a + dx[i], b + dy[i])\n                if valid(x, y):\n                    stack.append((x, y))\n                    visited[x, y] = 1\n                    s += 1\n        return s\n    ans = 0\n    (n, m) = mp()\n    l = [st() for i in range(n)]\n    visited = defaultdict(int)\n    cur = []\n    for i in range(n):\n        for j in range(m):\n            if l[i][j] == '1' and (i, j) not in visited:\n                x = dfs(i, j)\n                cur.append(x)\n    cur.sort(reverse=True)\n    for i in range(1, len(cur), 2):\n        ans += cur[i]\n    pr(ans)\nfor _ in range(inp()):\n    solve()", "def fetch(stack, arr, visited, i, j, n, m, cnt):\n    if i >= 0 and j >= 0 and (i < n) and (j < m):\n        if visited[i][j] == '0' and arr[i][j] == '1':\n            visited[i][j] = '1'\n            stack.append([i, j])\n            cnt += 1\n        else:\n            visited[i][j] = '1'\n        return cnt\n    else:\n        return cnt\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(list(input().strip()))\n    visited = []\n    for i in range(n):\n        visited.append(['0'] * m)\n    stack = []\n    cnt = 0\n    ConnComp = []\n    for i in range(n):\n        for j in range(m):\n            if visited[i][j] == '0' and arr[i][j] == '1':\n                stack.append([i, j])\n                visited[i][j] = '1'\n                cnt += 1\n                while stack:\n                    (x, y) = stack.pop(0)\n                    cnt = fetch(stack, arr, visited, x + 1, y, n, m, cnt)\n                    cnt = fetch(stack, arr, visited, x, y + 1, n, m, cnt)\n                    cnt = fetch(stack, arr, visited, x - 1, y, n, m, cnt)\n                    cnt = fetch(stack, arr, visited, x, y - 1, n, m, cnt)\n                ConnComp.append(cnt)\n                cnt = 0\n    ConnComp.sort(reverse=True)\n    ans = 0\n    for i in range(len(ConnComp)):\n        if i % 2 == 1:\n            ans += ConnComp[i]\n    print(ans)", "def fetch(stack, arr, visited, i, j, n, m, cnt):\n    if i >= 0 and j >= 0 and (i < n) and (j < m):\n        if visited[i][j] == '0' and arr[i][j] == '1':\n            visited[i][j] = '1'\n            stack.append([i, j])\n            cnt += 1\n        else:\n            visited[i][j] = '1'\n        return cnt\n    else:\n        return cnt\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(list(input().strip()))\n    visited = []\n    for i in range(n):\n        visited.append(['0'] * m)\n    stack = []\n    cnt = 0\n    ConnComp = []\n    for i in range(n):\n        for j in range(m):\n            if visited[i][j] == '0' and arr[i][j] == '1':\n                stack.append([i, j])\n                visited[i][j] = '1'\n                cnt += 1\n                while stack:\n                    (x, y) = stack.pop(0)\n                    cnt = fetch(stack, arr, visited, x + 1, y, n, m, cnt)\n                    cnt = fetch(stack, arr, visited, x, y + 1, n, m, cnt)\n                    cnt = fetch(stack, arr, visited, x - 1, y, n, m, cnt)\n                    cnt = fetch(stack, arr, visited, x, y - 1, n, m, cnt)\n                ConnComp.append(cnt)\n                cnt = 0\n    ConnComp.sort(reverse=True)\n    ans = 0\n    for i in range(len(ConnComp)):\n        if i % 2 == 1:\n            ans += ConnComp[i]\n    print(ans)", "def is_inside(x, y, n, m):\n    return x >= 0 and x < n and (y >= 0) and (y < m)\n\ndef find_connected_lands_length(cells, i, j, n, m):\n    q = []\n    q.append((i, j))\n    cells[i][j] = '0'\n    neighbour_offset = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    connected_lands_length = 0\n    while len(q) > 0:\n        (x, y) = q.pop(0)\n        connected_lands_length += 1\n        for (dx, dy) in neighbour_offset:\n            if is_inside(x + dx, y + dy, n, m) and cells[x + dx][y + dy] == '1':\n                q.append((x + dx, y + dy))\n                cells[x + dx][y + dy] = '0'\n    return connected_lands_length\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m) = map(int, input().split())\n    cells = []\n    for i in range(n):\n        cells.append(input())\n    cells = [list(cell) for cell in cells]\n    connected_lands = []\n    for i in range(n):\n        for j in range(m):\n            if cells[i][j] == '1':\n                connected_lands.append(find_connected_lands_length(cells, i, j, n, m))\n    connected_lands.sort(reverse=True)\n    chef_lands = 0\n    for i in range(1, len(connected_lands), 2):\n        chef_lands += connected_lands[i]\n    print(chef_lands)", "from collections import defaultdict as dd\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    t = []\n    for i in range(n):\n        b = []\n        w = str(input())\n        for j in range(m):\n            b.append(int(w[j]))\n        a.append(list(b))\n    d = dd(list)\n    k = 0\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                l = i * m + j\n                k += 1\n                t.append(l)\n                if j + 1 < m:\n                    if a[i][j + 1] == 1:\n                        d[l].append(i * m + (j + 1))\n                        d[i * m + (j + 1)].append(l)\n                if i + 1 < n:\n                    if a[i + 1][j] == 1:\n                        d[l].append((i + 1) * m + j)\n                        d[(i + 1) * m + j].append(l)\n    v = {}\n    ap = {}\n    for i in t:\n        v[i] = 0\n        ap[i] = 0\n    r = []\n    for i in t:\n        if v[i] == 0:\n            s = []\n            c = 0\n            s.append(i)\n            ap[i] = 1\n            while True:\n                if c >= len(s):\n                    break\n                if v[s[c]] == 0:\n                    v[s[c]] = 1\n                    for j in d[s[c]]:\n                        if ap[j] == 0:\n                            s.append(j)\n                            ap[j] = 1\n                c += 1\n            r.append(len(s))\n    r.sort(reverse=True)\n    f = 0\n    for i in range(len(r)):\n        if i & 1 == 1:\n            f += r[i]\n    print(f)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef ma(i, j):\n    if i >= 0 and i < n and (j >= 0) and (j < m):\n        l[i][j] = '0'\n        g = 1\n        if i - 1 >= 0 and l[i - 1][j] == '1':\n            g += ma(i - 1, j)\n        if i + 1 < n and l[i + 1][j] == '1':\n            g += ma(i + 1, j)\n        if j - 1 >= 0 and l[i][j - 1] == '1':\n            g += ma(i, j - 1)\n        if j + 1 < m and l[i][j + 1] == '1':\n            g += ma(i, j + 1)\n        return g\n    else:\n        return 0\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        l.append(list(input().strip()))\n    x = []\n    y = 1\n    for i in range(n):\n        for j in range(m):\n            if l[i][j] == '1':\n                x.append(int(ma(i, j)))\n    x.sort(reverse=True)\n    e = 0\n    for i in range(len(x)):\n        if i % 2 != 0:\n            e += x[i]\n    print(e)", "from sys import setrecursionlimit\nsetrecursionlimit(100000)\n\ndef f(mat, i, j, m, n):\n    c = 0\n    if i >= 0 and i < m and (j >= 0) and (j < n) and mat[i][j]:\n        mat[i][j] = 0\n        c += 1\n        c += f(mat, i + 1, j, m, n)\n        c += f(mat, i, j + 1, m, n)\n        c += f(mat, i - 1, j, m, n)\n        c += f(mat, i, j - 1, m, n)\n    return c\nT = int(input())\nfor i in range(T):\n    (m, n) = map(int, input().split())\n    v = []\n    mat = [list(map(int, list(input()))) for i in range(m)]\n    for x in range(m):\n        for y in range(n):\n            if mat[x][y]:\n                v.append(f(mat, x, y, m, n))\n    s = 0\n    v.sort(reverse=1)\n    for j in range(1, len(v), 2):\n        s += v[j]\n    print(s)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    grid = []\n    for _ in range(n):\n        row = [int(i) for i in input()]\n        grid.append(row)\n    islands = []\n    found = set()\n    from collections import deque\n\n    def bfs(node):\n        count = 0\n        q = deque()\n        q.append(node)\n        found.add(node)\n        dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n        while q:\n            (x, y) = q.popleft()\n            count += 1\n            for (dx, dy) in dirs:\n                (newx, newy) = (x + dx, y + dy)\n                if 0 <= newx < len(grid) and 0 <= newy < len(grid[0]):\n                    if (newx, newy) not in found and grid[newx][newy] == 1:\n                        q.append((newx, newy))\n                        found.add((newx, newy))\n        return count\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if (i, j) not in found:\n                if grid[i][j] == 1:\n                    ans = bfs((i, j))\n                    if ans > 0:\n                        islands.append(ans)\n    islands = sorted(islands, reverse=True)\n    p1 = 0\n    p2 = 0\n    i = 0\n    while True:\n        if i >= len(islands):\n            break\n        else:\n            p1 += islands[i]\n        i += 1\n        if i >= len(islands):\n            break\n        else:\n            p2 += islands[i]\n        i += 1\n    print(p2)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split(' '))\n    G = []\n    for i in range(n):\n        G.append(input())\n    F = {}\n    A = []\n    for j in range(n):\n        for i in range(m):\n            if G[j][i] == '1' and (not (i, j) in F):\n                q = [(i, j)]\n                s = {}\n                while q:\n                    (x, y) = q.pop()\n                    if G[y][x] == '1' and (not (x, y) in s):\n                        s[x, y] = 1\n                        if x + 1 != m:\n                            q.append((x + 1, y))\n                        if x != 0:\n                            q.append((x - 1, y))\n                        if y + 1 != n:\n                            q.append((x, y + 1))\n                        if y != 0:\n                            q.append((x, y - 1))\n                A.append(len(s))\n                F.update(s)\n    A.sort(reverse=True)\n    print(sum(A[1::2]))", "for _ in range(int(input())):\n    (n, m) = map(int, input().split(' '))\n    G = []\n    for i in range(n):\n        G.append(input())\n    F = {}\n    A = []\n    for j in range(n):\n        for i in range(m):\n            if G[j][i] == '1' and (not (i, j) in F):\n                q = [(i, j)]\n                s = {}\n                while q:\n                    (x, y) = q.pop()\n                    if G[y][x] == '1':\n                        s[x, y] = 1\n                        if x + 1 != m and (not (x + 1, y) in s):\n                            q.append((x + 1, y))\n                        if x != 0 and (not (x - 1, y) in s):\n                            q.append((x - 1, y))\n                        if y + 1 != n and (not (x, y + 1) in s):\n                            q.append((x, y + 1))\n                        if y != 0 and (not (x, y - 1) in s):\n                            q.append((x, y - 1))\n                A.append(len(s))\n                F.update(s)\n    A.sort(reverse=True)\n    print(sum(A[1::2]))", "import sys\n\ndef inside(x, y, n, m):\n    if x >= 0 and y >= 0 and (x < n) and (y < m):\n        return True\n    else:\n        return False\n\ndef landsFill(matrix, n, m, *cord):\n    dimen = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (i, j) = cord\n    que = []\n    matrix[i][j] = '0'\n    que.append(cord)\n    size = 0\n    while len(que) != 0:\n        tup = que[0]\n        que.pop(0)\n        size += 1\n        for (p, q) in dimen:\n            newp = p + tup[0]\n            newq = q + tup[1]\n            if inside(newp, newq, n, m) and matrix[newp][newq] == '1':\n                matrix[newp][newq] = '0'\n                que.append((newp, newq))\n    return size\nfor _ in range(int(sys.stdin.readline())):\n    matrix = []\n    res = []\n    (n, m) = map(int, sys.stdin.readline().split())\n    for i in range(n):\n        matrix.append(list(sys.stdin.readline()))\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == '1':\n                res.append(landsFill(matrix, n, m, i, j))\n    res.sort(reverse=True)\n    total = 0\n    for u in range(1, len(res), 2):\n        total += res[u]\n    print(total)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\n\ndef sizes(world, i, j, n, m):\n    size = 1\n    world[i][j] = 0\n    if j != 0 and world[i][j - 1] != 0:\n        size += sizes(world, i, j - 1, n, m)\n    if i != 0 and world[i - 1][j] != 0:\n        size += sizes(world, i - 1, j, n, m)\n    if j != m - 1 and world[i][j + 1] != 0:\n        size += sizes(world, i, j + 1, n, m)\n    if i != n - 1 and world[i + 1][j] != 0:\n        size += sizes(world, i + 1, j, n, m)\n    return size\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    world = [[int(land) for land in input()] for _ in range(n)]\n    captured = []\n    land_sizes = [sizes(world, i, j, n, m) for i in range(n) for j in range(m) if world[i][j] != 0]\n    land_sizes.sort(reverse=True)\n    print(0) if len(land_sizes) == 1 else print(sum(land_sizes[1::2]))", "import sys\nsys.setrecursionlimit(1000000)\nfrom collections import defaultdict\n\ndef bfs(a, b, visited, arr):\n    if a < 0 or b < 0 or a > n - 1 or (b > m - 1) or (arr[a][b] != '1') or (visited[a][b] == True):\n        return 0\n    else:\n        visited[a][b] = True\n        return bfs(a - 1, b, visited, arr) + bfs(a, b - 1, visited, arr) + bfs(a + 1, b, visited, arr) + bfs(a, b + 1, visited, arr) + 1\nt = int(input())\nfor k in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(list(input()))\n    visited = [[False for i in range(m)] for j in range(n)]\n    ans = []\n    for i in range(n):\n        for j in range(m):\n            if visited[i][j] == False and arr[i][j] != '0':\n                ans.append(bfs(i, j, visited, arr))\n    ans = sorted(ans, reverse=True)\n    sum = 0\n    for i in range(1, len(ans), 2):\n        sum += ans[i]\n    print(sum)", "def solve(x, n, m):\n    collections = {}\n    to_be_allocated = 0\n    y = [[-1] * m for i in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if x[i][j] == '1':\n                left = -1\n                top = -1\n                if j != 0:\n                    left = y[i][j - 1]\n                if i != 0:\n                    top = y[i - 1][j]\n                if left == -1 and top == -1:\n                    y[i][j] = to_be_allocated\n                    collections[to_be_allocated] = {(i, j)}\n                    to_be_allocated += 1\n                elif left == -1:\n                    y[i][j] = top\n                    collections[top].add((i, j))\n                elif top == -1:\n                    y[i][j] = left\n                    collections[left].add((i, j))\n                else:\n                    y[i][j] = left\n                    collections[left].add((i, j))\n                    if left != top:\n                        collections[left] = collections[left].union(collections[top])\n                        for point in collections[top]:\n                            y[point[0]][point[1]] = left\n                        collections[top] = set()\n    count = []\n    for val in collections.values():\n        count.append(len(val))\n    count.sort(reverse=True)\n    count = count[1::2]\n    return sum(count)\nfor q in range(int(input())):\n    (n, m) = map(int, input().split())\n    x = []\n    for i in range(n):\n        x.append(input())\n    print(solve(x, n, m))", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\n\ndef sizes(world, i, j, n, m):\n    size = 1\n    world[i][j] = 0\n    if j != 0 and world[i][j - 1] != 0:\n        size += sizes(world, i, j - 1, n, m)\n    if i != 0 and world[i - 1][j] != 0:\n        size += sizes(world, i - 1, j, n, m)\n    if j != m - 1 and world[i][j + 1] != 0:\n        size += sizes(world, i, j + 1, n, m)\n    if i != n - 1 and world[i + 1][j] != 0:\n        size += sizes(world, i + 1, j, n, m)\n    return size\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    world = []\n    captured = []\n    for _ in range(n):\n        world.append([int(land) for land in input()])\n    land_sizes = []\n    for i in range(n):\n        for j in range(m):\n            if world[i][j] != 0:\n                land_sizes.append(sizes(world, i, j, n, m))\n    land_sizes.sort(reverse=True)\n    if len(land_sizes) == 1:\n        print(0)\n    else:\n        print(sum(land_sizes[1::2]))", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(mat, visited, x, y):\n    if x >= n or y >= m or x < 0 or (y < 0):\n        return 0\n    if mat[x][y] != '1':\n        return 0\n    if visited[x][y]:\n        return 0\n    visited[x][y] = True\n    return dfs(mat, visited, x + 1, y) + dfs(mat, visited, x, y + 1) + dfs(mat, visited, x - 1, y) + dfs(mat, visited, x, y - 1) + 1\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    mat = []\n    for i in range(n):\n        mat.append(list(input()))\n    visited = [[False for i in range(m)] for j in range(n)]\n    al = []\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '0' or visited[i][j] == False:\n                al.append(dfs(mat, visited, i, j))\n    al.sort(reverse=True)\n    ans = 0\n    for i in range(1, len(al), 2):\n        ans += al[i]\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(mat, visited, x, y):\n    if x >= n or y >= m or x < 0 or (y < 0):\n        return 0\n    if mat[x][y] != '1':\n        return 0\n    if visited[x][y]:\n        return 0\n    visited[x][y] = True\n    return dfs(mat, visited, x + 1, y) + dfs(mat, visited, x, y + 1) + dfs(mat, visited, x - 1, y) + dfs(mat, visited, x, y - 1) + 1\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    mat = []\n    for i in range(n):\n        mat.append(list(input()))\n    visited = [[False for i in range(m)] for j in range(n)]\n    al = []\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '0' or visited[i][j] == False:\n                al.append(dfs(mat, visited, i, j))\n    al.sort(reverse=True)\n    ans = 0\n    for i in range(1, len(al), 2):\n        ans += al[i]\n    print(ans)", "from sys import setrecursionlimit\nsetrecursionlimit(100000)\n\ndef fun(li, i, j, count, n, m):\n    if i >= 1 and j >= 0 and (j <= m - 1) and (i <= n - 1):\n        if li[i - 1][j] == '1':\n            li[i - 1][j] = '0'\n            count[0] += 1\n            fun(li, i - 1, j, count, n, m)\n    if i <= n - 2 and i >= 0 and (j >= 0) and (j <= m - 1):\n        if li[i + 1][j] == '1':\n            li[i + 1][j] = '0'\n            count[0] += 1\n            fun(li, i + 1, j, count, n, m)\n    if j >= 1 and j <= m - 1 and (i >= 0) and (i <= n - 1):\n        if li[i][j - 1] == '1':\n            li[i][j - 1] = '0'\n            count[0] += 1\n            fun(li, i, j - 1, count, n, m)\n    if j <= m - 2 and j >= 0 and (i <= n - 1) and (i >= 0):\n        if li[i][j + 1] == '1':\n            li[i][j + 1] = '0'\n            count[0] += 1\n            fun(li, i, j + 1, count, n, m)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    li = []\n    for __ in range(n):\n        a = input()\n        temp = [x for x in a]\n        li.append(temp)\n    conter = []\n    for i in range(n):\n        for j in range(m):\n            count = [0]\n            if li[i][j] == '1':\n                li[i][j] = '0'\n                count[0] = 1\n                fun(li, i, j, count, n, m)\n                conter.append(count[0])\n    conter.sort(reverse=True)\n    summ = 0\n    for i in range(1, len(conter), 2):\n        summ += conter[i]\n    print(summ)", "def check(i, j):\n    if (i >= 0 and j >= 0) and (i < n and j < m):\n        return True\n    return False\n\ndef sizeof(i, j):\n    d = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n    q = [[i, j]]\n    l[i][j] = '0'\n    size = 0\n    while q:\n        size += 1\n        a = q.pop(0)\n        for (x, y) in d:\n            if check(a[0] + x, a[1] + y):\n                if l[a[0] + x][a[1] + y] == '1':\n                    l[a[0] + x][a[1] + y] = '0'\n                    q.append([a[0] + x, a[1] + y])\n    return size\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = [list(input()) for i in range(n)]\n    s1 = []\n    for i in range(n):\n        for j in range(m):\n            if l[i][j] == '1':\n                sz = sizeof(i, j)\n                s1.append(sz)\n    s1.sort(reverse=True)\n    sum = 0\n    for i in range(1, len(s1), 2):\n        sum += s1[i]\n    print(sum)", "def check(p, q, pl, ql):\n    if p > -1 and p < pl and (q > -1) and (q < ql):\n        return True\n    return False\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [list(map(int, list(input()))) for i in range(n)]\n    ans = []\n    tt = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    for i in range(n):\n        for j in range(m):\n            if check(i, j, n, m) and a[i][j] == 1:\n                que = [(i, j)]\n                count = 0\n                while que:\n                    pos = que.pop(0)\n                    (x, y) = (pos[0], pos[1])\n                    if check(x, y, n, m) and a[x][y] == 1:\n                        count += 1\n                        a[x][y] = 2\n                        for k in tt:\n                            (v1, v2) = (x + k[0], y + k[1])\n                            if check(v1, v2, n, m) and a[v1][v2] == 1:\n                                que.append((v1, v2))\n                ans.append(count)\n    ans.sort()\n    ans = ans[::-1]\n    nn = len(ans)\n    fans = 0\n    for i in range(1, nn, 2):\n        fans += ans[i]\n    print(fans)", "def check(i, j):\n    if i >= 0 and j >= 0 and (i < n) and (j < m):\n        return True\n    else:\n        return False\n\ndef findsize(i, j):\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = [[i, j]]\n    l[i][j] = '0'\n    size = 0\n    while q:\n        size += 1\n        a = q.pop(0)\n        for (x, y) in d:\n            if check(a[0] + x, a[1] + y):\n                if l[a[0] + x][a[1] + y] == '1':\n                    l[a[0] + x][a[1] + y] = '0'\n                    q.append([a[0] + x, a[1] + y])\n    return size\nt = int(input())\nfor i in range(t):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    l = []\n    s1 = []\n    for j in range(n):\n        s = list(input())\n        l.append(s)\n    for x in range(n):\n        for y in range(m):\n            if l[x][y] == '1':\n                sz = findsize(x, y)\n                s1.append(sz)\n    s1.sort(reverse=True)\n    sum1 = 0\n    for j in range(1, len(s1), 2):\n        sum1 += s1[j]\n    print(sum1)", "def Solve(l, x, y):\n    vis = set()\n    queue = [(x, y)]\n    d = 0\n    while queue:\n        (px, py) = queue.pop(0)\n        if px < 0 or py < 0 or px >= r or (py >= c) or ((px, py) in vis) or (l[px][py] == 0):\n            continue\n        vis.add((x, y))\n        l[px][py] = 0\n        d += 1\n        queue.append((px + 1, py))\n        queue.append((px - 1, py))\n        queue.append((px, py + 1))\n        queue.append((px, py - 1))\n    return d\nfor _ in range(int(input())):\n    (r, c) = map(int, input().split())\n    l = []\n    for x in range(r):\n        l.append(list(map(int, list(input()))))\n    rs = []\n    for x in range(r):\n        for y in range(c):\n            if l[x][y] == 1:\n                rs += [Solve(l, x, y)]\n    rs.sort(reverse=True)\n    print(sum(rs[1::2]))", "import sys\nsys.setrecursionlimit(150000)\n\ndef left(l, a, b):\n    if b == 0:\n        return False\n    elif l[a][b - 1] == '1':\n        return True\n    else:\n        return False\n\ndef right(l, a, b):\n    if b == len(l[0]) - 1:\n        return False\n    elif l[a][b + 1] == '1':\n        return True\n    else:\n        return False\n\ndef top(l, a, b):\n    if a == 0:\n        return False\n    elif l[a - 1][b] == '1':\n        return True\n    else:\n        return False\n\ndef down(l, a, b):\n    if a == len(l) - 1:\n        return False\n    elif l[a + 1][b] == '1':\n        return True\n    else:\n        return False\n\ndef score(cl, l, a, b):\n    scr = 0\n    if (a, b) in cl:\n        return 0\n    cl.add((a, b))\n    l[a][b] = '0'\n    if right(l, a, b):\n        scr += 1 + score(cl, l, a, b + 1)\n    if left(l, a, b):\n        scr += 1 + score(cl, l, a, b - 1)\n    if top(l, a, b):\n        scr += 1 + score(cl, l, a - 1, b)\n    if down(l, a, b):\n        scr += 1 + score(cl, l, a + 1, b)\n    return scr\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    scl = []\n    l = []\n    cl = set()\n    for i in range(n):\n        l.append(list(input()))\n    k = 0\n    for i in range(len(l)):\n        for j in range(len(l[0])):\n            if l[i][j] == '1':\n                scl.append(1 + score(cl, l, i, j))\n    scr1 = 0\n    scl.sort()\n    scl.reverse()\n    scl = scl[1::2]\n    if scl is None:\n        print(1)\n        continue\n    for sr in scl:\n        scr1 += sr\n    print(scr1)", "import sys\nsys.setrecursionlimit(150000)\n\ndef left(l, a, b):\n    if b == 0:\n        return False\n    elif l[a][b - 1] == '1':\n        return True\n    else:\n        return False\n\ndef right(l, a, b):\n    if b == len(l[0]) - 1:\n        return False\n    elif l[a][b + 1] == '1':\n        return True\n    else:\n        return False\n\ndef top(l, a, b):\n    if a == 0:\n        return False\n    elif l[a - 1][b] == '1':\n        return True\n    else:\n        return False\n\ndef down(l, a, b):\n    if a == len(l) - 1:\n        return False\n    elif l[a + 1][b] == '1':\n        return True\n    else:\n        return False\n\ndef score(cl, l, a, b):\n    scr = 0\n    if (a, b) in cl:\n        return 0\n    cl.add((a, b))\n    l[a][b] = '0'\n    if right(l, a, b):\n        scr += 1 + score(cl, l, a, b + 1)\n    if left(l, a, b):\n        scr += 1 + score(cl, l, a, b - 1)\n    if top(l, a, b):\n        scr += 1 + score(cl, l, a - 1, b)\n    if down(l, a, b):\n        scr += 1 + score(cl, l, a + 1, b)\n    return scr\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    scl = []\n    l = []\n    cl = set()\n    for i in range(n):\n        l.append(list(input()))\n    k = 0\n    for i in range(len(l)):\n        for j in range(len(l[0])):\n            if l[i][j] == '1':\n                scl.append(1 + score(cl, l, i, j))\n    scr1 = 0\n    scl.sort()\n    scl.reverse()\n    scl = scl[1::2]\n    if scl is None:\n        print(1)\n        continue\n    for sr in scl:\n        scr1 += sr\n    print(scr1)", "from sys import setrecursionlimit\nsetrecursionlimit(100000)\n\ndef get_connected_components(arr):\n\n    def dfs(arr, i, j, n):\n        n += 1\n        arr[i][j] = '0'\n        for (p, q) in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:\n            if 0 <= p < len(arr) and 0 <= q < len(arr[0]) and (arr[p][q] == '1'):\n                n = dfs(arr, p, q, n)\n        return n\n    l = []\n    for i in range(len(arr)):\n        for j in range(len(arr[0])):\n            if arr[i][j] == '1':\n                no = dfs(arr, i, j, 0)\n                l.append(no)\n    return l\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split(' '))\n    arr = []\n    for _ in range(n):\n        row = list(input())\n        arr.append(row)\n    connected_components = get_connected_components(arr)\n    connected_components.sort(reverse=True)\n    print(sum(connected_components[1::2]))", "from collections import deque\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    grid = []\n    for _ in range(N):\n        s = list(map(int, input()))\n        grid.append(s)\n    queue = deque()\n    result = []\n    visited = set()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 1:\n                queue.append((i, j))\n                grid[i][j] = 0\n                ans = 0\n                while queue:\n                    x = queue.popleft()\n                    ans += 1\n                    if x not in visited:\n                        visited.add(x)\n                        if x[1] + 1 < M:\n                            if grid[x[0]][x[1] + 1] == 1:\n                                queue.append((x[0], x[1] + 1))\n                                grid[x[0]][x[1] + 1] = 0\n                        if x[1] - 1 >= 0:\n                            if grid[x[0]][x[1] - 1] == 1:\n                                queue.append((x[0], x[1] - 1))\n                                grid[x[0]][x[1] - 1] = 0\n                        if x[0] + 1 < N:\n                            if grid[x[0] + 1][x[1]] == 1:\n                                queue.append((x[0] + 1, x[1]))\n                                grid[x[0] + 1][x[1]] = 0\n                        if x[0] - 1 >= 0:\n                            if grid[x[0] - 1][x[1]] == 1:\n                                queue.append((x[0] - 1, x[1]))\n                                grid[x[0] - 1][x[1]] = 0\n                result.append(ans)\n    result.sort(reverse=True)\n    k = 1\n    score = 0\n    while k < len(result):\n        score += result[k]\n        k += 2\n    print(score)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef check(arr, i, j, count):\n    if min(i, j) < 0 or i >= n or j >= m:\n        return count\n    elif arr[i][j] == '0':\n        return count\n    else:\n        count += 1\n        arr[i][j] = '0'\n        count = check(arr, i - 1, j, count)\n        count = check(arr, i, j - 1, count)\n        count = check(arr, i + 1, j, count)\n        count = check(arr, i, j + 1, count)\n        return count\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    re = []\n    arr = []\n    for i in range(n):\n        a = list(input())\n        arr.append(a)\n    for i in range(n):\n        for j in range(m):\n            count = 0\n            re.append(check(arr, i, j, count))\n    re.sort()\n    re = re[::-1]\n    chef = 0\n    for i in range(len(re)):\n        if i & 1:\n            chef += re[i]\n    print(chef)", "def find_chains(l, i, j, r, c):\n    queue = [(i, j)]\n    vis = set()\n    d = 0\n    while queue:\n        (x, y) = queue.pop()\n        if x < 0 or y < 0 or x >= r or (y >= c) or ((x, y) in vis) or (l[x][y] == 0):\n            continue\n        vis.add((i, j))\n        l[x][y] = 0\n        d += 1\n        queue.append((x + 1, y))\n        queue.append((x, y + 1))\n        queue.append((x - 1, y))\n        queue.append((x, y - 1))\n    return d\ntry:\n    t = int(input())\n    while t:\n        l = []\n        (r, c) = map(int, input().split())\n        for i in range(r):\n            l.append(list(map(int, input())))\n        max_size = []\n        for i in range(r):\n            for j in range(c):\n                if l[i][j] == 1:\n                    max_size += [find_chains(l, i, j, r, c)]\n        max_size.sort(reverse=True)\n        print(sum(max_size[1::2]))\nexcept:\n    pass", "import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef noOfConnectedLands(row, col, matrix, visited, N, M):\n    if row >= N or row < 0 or col >= M or (col < 0):\n        return 0\n    if matrix[row][col] == '0':\n        return 0\n    if matrix[row][col] == '1' and visited[row][col] == False:\n        visited[row][col] = True\n        return 1 + noOfConnectedLands(row + 1, col, matrix, visited, N, M) + noOfConnectedLands(row - 1, col, matrix, visited, N, M) + noOfConnectedLands(row, col + 1, matrix, visited, N, M) + noOfConnectedLands(row, col - 1, matrix, visited, N, M)\n    return 0\ntestcases = int(input().strip())\nfor testcase in range(testcases):\n    (N, M) = map(int, input().strip().split())\n    matrix = []\n    visited = []\n    for i in range(N):\n        row = input().strip()\n        matrix.append(row)\n        visited.append([False for x in range(M)])\n    arr = []\n    for i in range(N):\n        for j in range(M):\n            if not visited[i][j] and matrix[i][j] == '1':\n                x = noOfConnectedLands(i, j, matrix, visited, N, M)\n                arr.append(x)\n    arr = sorted(arr)[::-1]\n    if len(arr) > 1:\n        print(sum(arr[1::2]))\n    else:\n        print(0)", "import sys\nsys.setrecursionlimit(10 ** 7)\n\ndef noOfConnectedLands(row, col, matrix, visited, N, M):\n    if row >= N or row < 0 or col >= M or (col < 0):\n        return 0\n    if matrix[row][col] == '0':\n        return 0\n    if matrix[row][col] == '1' and visited[row][col] == False:\n        visited[row][col] = True\n        return 1 + noOfConnectedLands(row + 1, col, matrix, visited, N, M) + noOfConnectedLands(row - 1, col, matrix, visited, N, M) + noOfConnectedLands(row, col + 1, matrix, visited, N, M) + noOfConnectedLands(row, col - 1, matrix, visited, N, M)\n    return 0\ntestcases = int(input().strip())\nfor testcase in range(testcases):\n    (N, M) = map(int, input().strip().split())\n    matrix = []\n    visited = []\n    for i in range(N):\n        row = input().strip()\n        matrix.append(row)\n        visited.append([False for x in range(M)])\n    arr = []\n    for i in range(N):\n        for j in range(M):\n            if not visited[i][j] and matrix[i][j] == '1':\n                x = noOfConnectedLands(i, j, matrix, visited, N, M)\n                arr.append(x)\n    arr = sorted(arr)[::-1]\n    if len(arr) > 1:\n        print(sum(arr[1::2]))\n    else:\n        print(0)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef b_t(i, j):\n    if i < 0:\n        return 0\n    if j < 0:\n        return 0\n    if i >= n:\n        return 0\n    if j >= m:\n        return 0\n    if visited[i][j]:\n        return 0\n    visited[i][j] = True\n    return b_t(i - 1, j) + b_t(i, j - 1) + b_t(i + 1, j) + b_t(i, j + 1) + 1\n\ndef answer():\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == '0':\n                visited[i][j] = True\n    val = []\n    for i in range(n):\n        for j in range(m):\n            if not visited[i][j]:\n                val.append(b_t(i, j))\n    val.sort(reverse=True)\n    ans = 0\n    for i in range(1, len(val), 2):\n        ans += val[i]\n    return ans\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [input() for i in range(n)]\n    visited = [[False for i in range(m)] for j in range(n)]\n    print(answer())", "try:\n    import sys\n    sys.setrecursionlimit(1000000)\n\n    def dfs(i, j):\n        count[0] += 1\n        vis[i][j] = True\n        for (x, y) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if x >= 0 and y >= 0 and (x < n) and (y < m) and (arr[x][y] == 1) and (vis[x][y] == False):\n                dfs(x, y)\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = []\n        for i in range(n):\n            arr.append(list(map(int, input())))\n        a = []\n        vis = [[False for i in range(m)] for j in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if arr[i][j] == 1 and vis[i][j] == False:\n                    count = [0]\n                    dfs(i, j)\n                    a.append(count[0])\n        a.sort(reverse=True)\n        ans = 0\n        for i in range(1, len(a), 2):\n            ans += a[i]\n        print(ans)\nexcept:\n    pass", "import sys\nsys.setrecursionlimit(10 ** 7)\n\nclass Graph:\n\n    def __init__(self, n, m, g):\n        self.n = n\n        self.m = m\n        self.g = g\n        self.sizes = []\n        self.c = 0\n\n    def dfs(self, i, j, visited):\n        visited[i][j] = True\n        if self.g[i][j] == '0' or self.g[i][j] == '2':\n            return\n        self.g[i][j] = '2'\n        self.c += 1\n        if j - 1 >= 0 and visited[i][j - 1] == False:\n            self.dfs(i, j - 1, visited)\n        if i - 1 >= 0 and visited[i - 1][j] == False:\n            self.dfs(i - 1, j, visited)\n        if i + 1 < self.n and j < self.m and (visited[i + 1][j] == False):\n            self.dfs(i + 1, j, visited)\n        if j + 1 < self.m and i < self.n and (visited[i][j + 1] == False):\n            self.dfs(i, j + 1, visited)\n\n    def countIslandSizes(self):\n        visited = [[False for j in range(self.m)] for i in range(self.n)]\n        for i in range(self.n):\n            for j in range(self.m):\n                if visited[i][j] == False and self.g[i][j] == '1':\n                    self.c = 0\n                    self.dfs(i, j, visited)\n                    self.sizes.append(self.c)\n        return self.sizes\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    graph = [[] for i in range(n)]\n    for i in range(n):\n        graph[i] = list(input())\n    g = Graph(n, m, graph)\n    x = sorted(g.countIslandSizes(), reverse=True)\n    p = 0\n    for i in range(1, len(x), 2):\n        p += x[i]\n    print(p)", "from collections import deque\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    Map = []\n    for i in range(n):\n        Map.append(list(input()))\n    pairs = [(1, 0), (-1, 0), (0, -1), (0, 1)]\n    lands = []\n\n    def inside(x, y):\n        return x >= 0 and y >= 0 and (x < n) and (y < m)\n\n    def bfs(i, j):\n        q = deque()\n        Map[i][j] = '0'\n        q.append((i, j))\n        res = 0\n        while q:\n            (x, y) = q.popleft()\n            res += 1\n            for (dx, dy) in pairs:\n                xx = x + dx\n                yy = y + dy\n                if inside(xx, yy) and Map[xx][yy] == '1':\n                    Map[xx][yy] = '0'\n                    q.append((xx, yy))\n        return res\n    for i in range(n):\n        for j in range(m):\n            if Map[i][j] == '1':\n                lands.append(bfs(i, j))\n    lands.sort(reverse=True)\n    chef = 0\n    for i in range(1, len(lands), 2):\n        chef += lands[i]\n    print(chef)", "def solve():\n    (n, m) = map(int, input().split())\n    visited = [[False for i in range(m)] for j in range(n)]\n    (a, ans) = ([], [])\n    for i in range(n):\n        a.append(list(input().strip()))\n\n    def check(x, y):\n        if x < 0 or x >= n or y < 0 or (y >= m):\n            return False\n        if visited[x][y] or a[x][y] == '0':\n            return False\n        return True\n\n    def bfs(i, j):\n        q = [(i, j)]\n        visited[i][j] = True\n        c = 0\n        while len(q) != 0:\n            p = q.pop(0)\n            c += 1\n            if check(p[0] + 1, p[1]):\n                visited[p[0] + 1][p[1]] = True\n                q.append((p[0] + 1, p[1]))\n            if check(p[0] - 1, p[1]):\n                visited[p[0] - 1][p[1]] = True\n                q.append((p[0] - 1, p[1]))\n            if check(p[0], p[1] + 1):\n                visited[p[0]][p[1] + 1] = True\n                q.append((p[0], p[1] + 1))\n            if check(p[0], p[1] - 1):\n                visited[p[0]][p[1] - 1] = True\n                q.append((p[0], p[1] - 1))\n        return c\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == '1' and (not visited[i][j]):\n                ans.append(bfs(i, j))\n    ans.sort(reverse=True)\n    score = 0\n    for i in range(1, len(ans), 2):\n        score += ans[i]\n    print(score)\nfor _ in range(int(input())):\n    solve()", "import numpy as np\ntestcase = int(input())\nfor t in range(testcase):\n    [N, M] = list(map(int, input().split(' ')))\n    mat = np.zeros([N + 2, M + 2])\n    for i in range(N):\n        mat[i + 1][1:M + 1] = list(input())\n    R = np.zeros([N + 2, M + 2])\n    k = 1\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i, j] == 1:\n                if mat[i - 1, j] == 0 and mat[i, j - 1] == 0:\n                    R[i, j] = k\n                    k += 1\n                elif mat[i - 1, j] == 1 and mat[i, j - 1] == 0:\n                    R[i, j] = R[i - 1, j]\n                elif mat[i - 1, j] == 0 and mat[i, j - 1] == 1:\n                    R[i, j] = R[i, j - 1]\n                elif mat[i - 1, j] == 1 and mat[i, j - 1] == 1:\n                    R[i, j] = R[i - 1, j]\n                    if R[i - 1, j] != R[i, j - 1]:\n                        R[R == R[i, j - 1]] = R[i - 1, j]\n    klist = np.zeros(k)\n    for i in R:\n        for j in i:\n            if int(j) != 0:\n                klist[int(j)] += 1\n    klist = np.array(sorted(klist, reverse=True))\n    klist = klist[klist > 0]\n    sum1 = 0\n    for p in range(0, len(klist)):\n        if p % 2 != 0:\n            sum1 = sum1 + klist[p]\n    print(int(sum1))", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef check(arr, i, j, count):\n    if min(i, j) < 0 or i >= n or j >= m:\n        return count\n    elif arr[i][j] == '0':\n        return count\n    else:\n        count += 1\n        arr[i][j] = '0'\n        count = check(arr, i - 1, j, count)\n        count = check(arr, i, j - 1, count)\n        count = check(arr, i + 1, j, count)\n        count = check(arr, i, j + 1, count)\n        return count\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    re = []\n    arr = []\n    for i in range(n):\n        a = list(input())\n        arr.append(a)\n    for i in range(n):\n        for j in range(m):\n            count = 0\n            re.append(check(arr, i, j, count))\n    re.sort()\n    re = re[::-1]\n    chef = 0\n    for i in range(len(re)):\n        if i & 1:\n            chef += re[i]\n    print(chef)", "def valid(a, b, visited, A, N, M):\n    if a >= N or a < 0 or b >= M or (b < 0):\n        return False\n    if visited[a][b] or A[a][b] == '0':\n        return False\n    return True\n\ndef dfs(x, y, visited, A, N, M):\n    visited[x][y] = 1\n    stack = [[x, y]]\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n    c = 1\n    while stack:\n        node = stack.pop()\n        x = node[0]\n        y = node[1]\n        for i in range(4):\n            if valid(x + dx[i], y + dy[i], visited, A, N, M) == True:\n                c = c + 1\n                stack.append([x + dx[i], y + dy[i]])\n                visited[x + dx[i]][y + dy[i]] = True\n    return c\n\ndef find(A, N, M):\n    visited = [[0 for i in range(M)] for j in range(N)]\n    c = 0\n    ans = []\n    for i in range(N):\n        for j in range(M):\n            if A[i][j] == '1' and visited[i][j] == 0:\n                ans.append(dfs(i, j, visited, A, N, M))\n    return ans\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        k = list(input())\n        l.append(k)\n    ans = find(l, n, m)\n    ans.sort(reverse=True)\n    res = 0\n    for i in range(1, len(ans), 2):\n        res = res + ans[i]\n    print(res)", "def solve(i, j):\n    if i >= 0 and i < n and (j >= 0) and (j < m):\n        if a[i][j] == 1 and vis[i][j] == 0:\n            vis[i][j] = 1\n            x = [-1, 0, 1, 0]\n            y = [0, 1, 0, -1]\n            sm = 1\n            for k in range(4):\n                sm += solve(i + x[k], j + y[k])\n            return sm\n    return 0\nimport sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [[0 for j in range(m)] for i in range(n)]\n    vis = [[0 for j in range(m)] for i in range(n)]\n    for i in range(n):\n        s = input()\n        for j in range(m):\n            a[i][j] = int(s[j])\n    res = []\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1 and vis[i][j] == 0:\n                t = solve(i, j)\n                res.append(t)\n    res.sort(reverse=True)\n    ans = 0\n    for i in range(len(res)):\n        if i & 1:\n            ans += res[i]\n    print(ans)", "import sys\nsys.setrecursionlimit(1000000)\n\ndef godir(world, i, j, n, m):\n    size = 0\n    if world[i][j] == '1':\n        size += 1\n        world[i][j] = '0'\n        if i != n - 1:\n            size += godir(world, i + 1, j, n, m)\n        if j != m - 1:\n            size += godir(world, i, j + 1, n, m)\n        if i != 0:\n            size += godir(world, i - 1, j, n, m)\n        if j != 0:\n            size += godir(world, i, j - 1, n, m)\n    return size\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, m) = tuple(map(int, input().split()))\n        world = []\n        for r in range(n):\n            world.append(list(input()))\n        (sizes, l) = ([], 0)\n        for r in range(n):\n            for c in range(m):\n                if world[r][c] == '1':\n                    size = 1\n                    world[r][c] = '0'\n                    if r != n - 1:\n                        size += godir(world, r + 1, c, n, m)\n                    if c != m - 1:\n                        size += godir(world, r, c + 1, n, m)\n                    sizes += [size]\n                    l += 1\n        sizes.sort()\n        sizes = sizes[::-1]\n        print(sum(sizes[1::2]))\n    return 0\nmain()", "import sys\nsys.setrecursionlimit(100000)\n\ndef dfs(matrix, i, j, m, n):\n    if i < 0 or i >= m or j < 0 or (j >= n):\n        return 0\n    if matrix[i][j] != '1':\n        return 0\n    matrix[i][j] = '2'\n    ans = 1\n    for (x, y) in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n        ans += dfs(matrix, i + x, j + y, m, n)\n    return ans\nfor _ in range(int(input())):\n    (m, n) = map(int, input().split())\n    matrix = []\n    for __ in range(m):\n        row = list(input())\n        matrix.append(row)\n    l = []\n    (m, n) = (len(matrix), len(matrix[0]))\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == '1':\n                k = dfs(matrix, i, j, m, n)\n                l.append(k)\n    l.sort()\n    (chef, mike) = (0, 0)\n    turn = 1\n    for term in range(len(l) - 1, -1, -1):\n        if turn == 1:\n            mike += l[term]\n            turn ^= 1\n        else:\n            chef += l[term]\n            turn ^= 1\n    print(chef)", "from sys import setrecursionlimit\nsetrecursionlimit(100000)\n\ndef floodfill(i, j):\n    if i >= row:\n        return 0\n    if j >= col:\n        return 0\n    if array[i][j] == 0:\n        return 0\n    if i < 0:\n        return 0\n    if j < 0:\n        return 0\n    array[i][j] = 0\n    return 1 + (floodfill(i + 1, j) + floodfill(i - 1, j) + floodfill(i, j + 1) + floodfill(i, j - 1))\n\ndef fun(row, col):\n    new_array = []\n    for i in range(row):\n        for j in range(col):\n            a = floodfill(i, j)\n            if a != 0:\n                new_array.append(a)\n    new_array.sort()\n    new_array = new_array[::-1]\n    summing = 0\n    for i in range(1, len(new_array), 2):\n        summing += new_array[i]\n    return summing\nfor test in range(int(input())):\n    (row, col) = list(map(int, input().split()))\n    array = []\n    for i in range(row):\n        array.append(list(map(int, list(input()))))\n    print(fun(row, col))", "t = int(input())\n\ndef dfs(i, j, comp, visited, grid):\n    max_j = len(grid[0]) - 1\n    max_i = len(grid) - 1\n    stack = [(i, j)]\n    while len(stack):\n        (x, y) = stack.pop()\n        if grid[x][y] == '0':\n            visited[x][y] = True\n        elif not visited[x][y]:\n            comp[0] += 1\n            visited[x][y] = True\n            left = (x, max(0, y - 1))\n            right = (x, min(max_j, y + 1))\n            bottom = (min(max_i, x + 1), y)\n            top = (max(0, x - 1), y)\n            stack += [top, bottom, left, right]\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n    components = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '0':\n                visited[i][j] = True\n            elif grid[i][j] == '1':\n                if not visited[i][j]:\n                    comp = [0]\n                    dfs(i, j, comp, visited, grid)\n                    components.append(comp[0])\n                    comp[0] = 0\n    components.sort(reverse=True)\n    print(sum([c for (i, c) in enumerate(components) if i & 1 == 1]))", "from queue import Queue\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    matrix = [['0' for i in range(m + 2)]]\n    for i in range(n):\n        matrix.append(list(input()))\n        matrix[-1].append('0')\n        matrix[-1].insert(0, '0')\n    matrix.append(['0' for i in range(m + 2)])\n    queue = Queue()\n    bfs_op = []\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if matrix[i][j] == '1':\n                queue.put([i, j])\n                l = []\n                while not queue.empty():\n                    u = queue.get()\n                    l.append(u)\n                    matrix[u[0]][u[1]] = 'visited'\n                    if matrix[u[0]][u[1] + 1] == '1':\n                        queue.put([u[0], u[1] + 1])\n                        matrix[u[0]][u[1] + 1] = 'visited'\n                    if matrix[u[0]][u[1] - 1] == '1':\n                        queue.put([u[0], u[1] - 1])\n                        matrix[u[0]][u[1] - 1] = 'visited'\n                    if matrix[u[0] + 1][u[1]] == '1':\n                        queue.put([u[0] + 1, u[1]])\n                        matrix[u[0] + 1][u[1]] = 'visited'\n                    if matrix[u[0] - 1][u[1]] == '1':\n                        queue.put([u[0] - 1, u[1]])\n                        matrix[u[0] - 1][u[1]] = 'visited'\n                bfs_op.append(len(l))\n    bfs_op.sort(reverse=True)\n    s = 0\n    i = 1\n    while i < len(bfs_op):\n        s += bfs_op[i]\n        i += 2\n    print(s)", "import numpy as np\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    www = []\n    for ii in range(n):\n        www += [[int(iit) for iit in input()]]\n    www = np.array(www)\n    col = 2\n    for ii in range(n):\n        for jj in range(m):\n            if www[ii][jj] == 1:\n                col += 1\n                st = []\n                www[ii][jj] = col\n                if ii != 0:\n                    st += [(ii - 1, jj)]\n                if jj != 0:\n                    st += [(ii, jj - 1)]\n                if ii != n - 1:\n                    st += [(ii + 1, jj)]\n                if jj != m - 1:\n                    st += [(ii, jj + 1)]\n                while len(st) != 0:\n                    q = st.pop()\n                    (iii, jjj) = q\n                    if www[iii, jjj] == 1:\n                        if iii != 0:\n                            st += [(iii - 1, jjj)]\n                        if jjj != 0:\n                            st += [(iii, jjj - 1)]\n                        if iii != n - 1:\n                            st += [(iii + 1, jjj)]\n                        if jjj != m - 1:\n                            st += [(iii, jjj + 1)]\n                        www[iii][jjj] = col\n    (xxx, yyy) = np.unique([jh for hj in www for jh in hj], return_counts=True)\n    if xxx[0] == 0:\n        yyy = yyy[1:]\n    res = 0\n    for (u, uu) in enumerate(np.sort(yyy)[::-1]):\n        if u % 2 == 1:\n            res += uu\n    print(res)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    lis = []\n    for _ in range(n):\n        lis.append([int(x) for x in input()])\n    cnt = []\n    for i in range(n):\n        for j in range(m):\n            count = 0\n            if lis[i][j] == 1:\n                lis[i][j] = 0\n                count += 1\n                q = []\n                q.append((i, j))\n                while len(q) > 0:\n                    t = q.pop(0)\n                    if t[0] < n - 1:\n                        if lis[t[0] + 1][t[1]] == 1:\n                            count += 1\n                            lis[t[0] + 1][t[1]] = 0\n                            q.append((t[0] + 1, t[1]))\n                    if t[1] < m - 1:\n                        if lis[t[0]][t[1] + 1] == 1:\n                            count += 1\n                            lis[t[0]][t[1] + 1] = 0\n                            q.append((t[0], t[1] + 1))\n                    if t[0] > 0:\n                        if lis[t[0] - 1][t[1]] == 1:\n                            count += 1\n                            lis[t[0] - 1][t[1]] = 0\n                            q.append((t[0] - 1, t[1]))\n                    if t[1] > 0:\n                        if lis[t[0]][t[1] - 1] == 1:\n                            count += 1\n                            lis[t[0]][t[1] - 1] = 0\n                            q.append((t[0], t[1] - 1))\n                cnt.append(count)\n    cnt.sort(reverse=True)\n    if len(cnt) == 1 or len(cnt) == 0:\n        print(0)\n    else:\n        ans_lis = cnt[1::2]\n        ans = sum(ans_lis)\n        print(ans)"]