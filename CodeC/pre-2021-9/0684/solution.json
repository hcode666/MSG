["ini = {'odd': 'black', 'even': 'red'}\nfor _ in range(int(input())):\n    q = [i for i in input().split()]\n    if q[0] == 'Qi':\n        temp = ini['odd']\n        ini['odd'] = ini['even']\n        ini['even'] = temp\n    else:\n        (a, b) = (f'{int(q[1]):b}', f'{int(q[2]):b}')\n        k = 0\n        count = {'black': 0, 'red': 0}\n        for (i, j) in zip(a, b):\n            if i != j:\n                break\n            else:\n                k += 1\n        dist = len(a) + len(b) - 2 * k\n        if (dist + 1) % 2 == 0:\n            count['red'] = count['black'] = (dist + 1) / 2\n        else:\n            if len(a) % 2 == 0:\n                count[ini['even']] += 1\n            else:\n                count[ini['odd']] += 1\n            count['red'] += dist / 2\n            count['black'] += dist / 2\n        if q[0] == 'Qb':\n            print(int(count['black']))\n        else:\n            print(int(count['red']))", "ini = {'odd': 'black', 'even': 'red'}\nfor _ in range(int(input())):\n    q = [i for i in input().split()]\n    if q[0] == 'Qi':\n        temp = ini['odd']\n        ini['odd'] = ini['even']\n        ini['even'] = temp\n    else:\n        (a, b) = (f'{int(q[1]):b}', f'{int(q[2]):b}')\n        k = 0\n        count = {'black': 0, 'red': 0}\n        for (i, j) in zip(a, b):\n            if i != j:\n                break\n            else:\n                k += 1\n        dist = len(a) + len(b) - 2 * k\n        if (dist + 1) % 2 == 0:\n            count['red'] = count['black'] = (dist + 1) / 2\n        else:\n            if len(a) % 2 == 0:\n                count[ini['even']] += 1\n            else:\n                count[ini['odd']] += 1\n            count['red'] += dist / 2\n            count['black'] += dist / 2\n        if q[0] == 'Qb':\n            print(int(count['black']))\n        else:\n            print(int(count['red']))", "root = 0\nfor _ in range(int(input())):\n    q = list(map(str, input().split()))\n    if q[0] == 'Qi':\n        root = (root + 1) % 2\n    else:\n        x = int(q[1])\n        y = int(q[2])\n        xca = []\n        yca = []\n        lxca = 0\n        lyca = 0\n        while x > 0:\n            lxca += 1\n            xca.append(x)\n            if x & 1:\n                x -= 1\n                x //= 2\n            else:\n                x //= 2\n        while y > 0:\n            lyca += 1\n            yca.append(y)\n            if y & 1:\n                y -= 1\n                y //= 2\n            else:\n                y //= 2\n        lx = lxca - 1\n        ly = lyca - 1\n        lca_dist = 0\n        while lx >= 0 and ly >= 0:\n            if xca[lx] == yca[ly]:\n                lca_dist += 1\n            else:\n                break\n            lx -= 1\n            ly -= 1\n        lca_color = 0\n        if lca_dist & 1:\n            lca_color = root\n        else:\n            lca_color = (root + 1) % 2\n        ans = 0\n        accept1 = 0\n        accept2 = 0\n        if q[0] == 'Qb':\n            if lca_color == 0:\n                accept1 = 0\n                accept2 = 1\n            else:\n                accept1 = 1\n                accept2 = 0\n        elif lca_color == 1:\n            accept1 = 0\n            accept2 = 1\n        else:\n            accept1 = 1\n            accept2 = 0\n        for i in range(lca_dist, lxca + 1):\n            if accept1 == 0:\n                ans += 1\n            accept1 = (accept1 + 1) % 2\n        for i in range(lca_dist + 1, lyca + 1):\n            if accept2 == 0:\n                ans += 1\n            accept2 = (accept2 + 1) % 2\n        print(ans)", "root = 0\nfor _ in range(int(input())):\n    q = list(map(str, input().split()))\n    if q[0] == 'Qi':\n        root = (root + 1) % 2\n    else:\n        x = int(q[1])\n        y = int(q[2])\n        xca = []\n        yca = []\n        lxca = 0\n        lyca = 0\n        while x > 0:\n            lxca += 1\n            xca.append(x)\n            if x & 1:\n                x -= 1\n                x //= 2\n            else:\n                x //= 2\n        while y > 0:\n            lyca += 1\n            yca.append(y)\n            if y & 1:\n                y -= 1\n                y //= 2\n            else:\n                y //= 2\n        lx = lxca - 1\n        ly = lyca - 1\n        lca_dist = 0\n        while lx >= 0 and ly >= 0:\n            if xca[lx] == yca[ly]:\n                lca_dist += 1\n            else:\n                break\n            lx -= 1\n            ly -= 1\n        lca_color = 0\n        if lca_dist & 1:\n            lca_color = root\n        else:\n            lca_color = (root + 1) % 2\n        ans = 0\n        accept1 = 0\n        accept2 = 0\n        if q[0] == 'Qb':\n            if lca_color == 0:\n                accept1 = 0\n                accept2 = 1\n            else:\n                accept1 = 1\n                accept2 = 0\n        elif lca_color == 1:\n            accept1 = 0\n            accept2 = 1\n        else:\n            accept1 = 1\n            accept2 = 0\n        for i in range(lca_dist, lxca + 1):\n            if accept1 == 0:\n                ans += 1\n            accept1 = (accept1 + 1) % 2\n        for i in range(lca_dist + 1, lyca + 1):\n            if accept2 == 0:\n                ans += 1\n            accept2 = (accept2 + 1) % 2\n        print(ans)", "root = 0\nfor _ in range(int(input())):\n    q = list(map(str, input().split()))\n    if q[0] == 'Qi':\n        root = (root + 1) % 2\n    else:\n        x = int(q[1])\n        y = int(q[2])\n        xca = []\n        yca = []\n        lxca = 0\n        lyca = 0\n        while x > 0:\n            lxca += 1\n            xca.append(x)\n            if x & 1:\n                x -= 1\n                x //= 2\n            else:\n                x //= 2\n        while y > 0:\n            lyca += 1\n            yca.append(y)\n            if y & 1:\n                y -= 1\n                y //= 2\n            else:\n                y //= 2\n        lx = lxca - 1\n        ly = lyca - 1\n        lca_dist = 0\n        while lx >= 0 and ly >= 0:\n            if xca[lx] == yca[ly]:\n                lca_dist += 1\n            else:\n                break\n            lx -= 1\n            ly -= 1\n        lca_color = 0\n        if lca_dist & 1:\n            lca_color = root\n        else:\n            lca_color = (root + 1) % 2\n        ans = 0\n        accept1 = 0\n        accept2 = 0\n        if q[0] == 'Qb':\n            if lca_color == 0:\n                accept1 = 0\n                accept2 = 1\n            else:\n                accept1 = 1\n                accept2 = 0\n        elif lca_color == 1:\n            accept1 = 0\n            accept2 = 1\n        else:\n            accept1 = 1\n            accept2 = 0\n        for i in range(lca_dist, lxca + 1):\n            if accept1 == 0:\n                ans += 1\n            accept1 = (accept1 + 1) % 2\n        for i in range(lca_dist + 1, lyca + 1):\n            if accept2 == 0:\n                ans += 1\n            accept2 = (accept2 + 1) % 2\n        print(ans)", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef help(levelX):\n    if flag:\n        Xblack = (levelX + 1) // 2\n        Xred = levelX - Xblack\n    else:\n        Xred = (levelX + 1) // 2\n        Xblack = levelX - Xred\n    return (Xblack, Xred)\nQ = inp()\nflag = 1\nfor _ in range(Q):\n    S = input().split()\n    if len(S) == 1:\n        flag ^= 1\n    else:\n        (color, x, y) = S\n        if color == 'Qb':\n            color = 0\n        else:\n            color = 1\n        (x, y) = (int(x), int(y))\n        levelX = 0\n        sumX = 0\n        while sumX + (1 << levelX) < x:\n            sumX += 1 << levelX\n            levelX += 1\n        sumY = 0\n        levelY = 0\n        while sumY + (1 << levelY) < y:\n            sumY += 1 << levelY\n            levelY += 1\n        levelY += 1\n        levelX += 1\n        (Xblack, Xred) = help(levelX)\n        (Yblack, Yred) = help(levelY)\n        while levelX > levelY:\n            x >>= 1\n            levelX -= 1\n        while levelX < levelY:\n            y >>= 1\n            levelY -= 1\n        while x != y:\n            x >>= 1\n            y >>= 1\n            levelY -= 1\n        (LCAblack, LCAred) = help(levelY)\n        if color:\n            ans = Xred + Yred - 2 * LCAred\n        else:\n            ans = Xblack + Yblack - 2 * LCAblack\n        temp = levelY % 2\n        if color:\n            if flag:\n                if temp == 0:\n                    ans += 1\n            elif temp == 1:\n                ans += 1\n        elif flag:\n            if temp == 1:\n                ans += 1\n        elif temp == 0:\n            ans += 1\n        pr(ans)", "reverse = 0\nfor _ in range(int(input())):\n    s = input().split()\n    if s[0] == 'Qb' or s[0] == 'Qr':\n        x = int(s[1])\n        y = int(s[2])\n        binx = bin(x)[2:]\n        biny = bin(y)[2:]\n        m = len(binx)\n        n = len(biny)\n        a = 0\n        if m < n:\n            while a < m and binx[a] == biny[a]:\n                a += 1\n        else:\n            while a < n and binx[a] == biny[a]:\n                a += 1\n        pathx = [x]\n        start = m\n        while start != a:\n            x //= 2\n            pathx.append(x)\n            start -= 1\n        start = n\n        pathy = [y]\n        while start != a:\n            y //= 2\n            pathy.append(y)\n            start -= 1\n        r = 0\n        b = 0\n        for i in range(len(pathx)):\n            if pathx[i].bit_length() % 2 == 0:\n                r += 1\n            else:\n                b += 1\n        for i in range(len(pathy) - 1):\n            if pathy[i].bit_length() % 2 == 0:\n                r += 1\n            else:\n                b += 1\n        if not reverse:\n            if s[0] == 'Qb':\n                print(b)\n            else:\n                print(r)\n        elif s[0] == 'Qb':\n            print(r)\n        else:\n            print(b)\n    else:\n        reverse ^= 1", "q = int(input())\nfrom math import log, floor\n\ndef ancestor(x):\n    ans = {1}\n    while x != 1:\n        ans.add(x)\n        if x % 2:\n            x = (x - 1) // 2\n        else:\n            x //= 2\n    return ans\n\ndef path(x, y):\n    x = ancestor(x)\n    y = ancestor(y)\n    common = x & y\n    return {max(common)} | y - common | x - common\nblack = 0\nred = 1\nwhile q:\n    q -= 1\n    (f, *r) = input().split()\n    if f == 'Qi':\n        black ^= 1\n        red ^= 1\n    else:\n        ans = 0\n        if f == 'Qb':\n            v = black\n        else:\n            v = red\n        (x, y) = map(int, r)\n        for y in path(x, y):\n            level = floor(log(y, 2))\n            if level % 2 == v:\n                ans += 1\n        print(ans)", "reverse = 0\nfor _ in range(int(input())):\n    s = input().split()\n    if s[0] == 'Qb' or s[0] == 'Qr':\n        x = int(s[1])\n        y = int(s[2])\n        binx = bin(x)[2:]\n        biny = bin(y)[2:]\n        m = len(binx)\n        n = len(biny)\n        a = 0\n        if m < n:\n            while a < m and binx[a] == biny[a]:\n                a += 1\n        else:\n            while a < n and binx[a] == biny[a]:\n                a += 1\n        pathx = [x]\n        start = m\n        while start != a:\n            x //= 2\n            pathx.append(x)\n            start -= 1\n        start = n\n        pathy = [y]\n        while start != a:\n            y //= 2\n            pathy.append(y)\n            start -= 1\n        r = 0\n        b = 0\n        for i in range(len(pathx)):\n            if pathx[i].bit_length() % 2 == 0:\n                r += 1\n            else:\n                b += 1\n        for i in range(len(pathy) - 1):\n            if pathy[i].bit_length() % 2 == 0:\n                r += 1\n            else:\n                b += 1\n        if not reverse:\n            if s[0] == 'Qb':\n                print(b)\n            else:\n                print(r)\n        elif s[0] == 'Qb':\n            print(r)\n        else:\n            print(b)\n    else:\n        reverse ^= 1", "from math import log2\n\ndef pathLength(x, y):\n    res = 1\n    while x != y:\n        res += 1\n        if x > y:\n            x //= 2\n        else:\n            y //= 2\n    return res\ninversions = 0\nfor _ in range(int(input())):\n    inp = list(input().split(' '))\n    if len(inp) == 1:\n        inversions = (inversions + 1) % 2\n    else:\n        q = inp[0][1]\n        x = int(inp[1])\n        y = int(inp[2])\n        lev_x = int(log2(x)) % 2\n        lev_y = int(log2(y)) % 2\n        path_len = pathLength(x, y)\n        (red, black) = (0, 0)\n        if lev_x == 1 and lev_y == 1:\n            black = path_len // 2\n            red = path_len - black\n        elif lev_x == 0 and lev_y == 0:\n            red = path_len // 2\n            black = path_len - red\n        else:\n            red = path_len // 2\n            black = path_len - red\n        if inversions == 1:\n            if q == 'b':\n                print(red)\n            else:\n                print(black)\n        elif q == 'b':\n            print(black)\n        else:\n            print(red)", "from math import *\nflag = 0\nfor _ in range(int(input())):\n    s = input().strip()\n    if s == 'Qi':\n        flag = not flag\n        continue\n    (s, x, y) = s.split()\n    (x, y) = (int(x), int(y))\n    l1 = []\n    l2 = []\n    i = j = 0\n    l1.append(x)\n    l2.append(y)\n    while x > 0:\n        l1.append(x // 2)\n        x //= 2\n        i += 1\n    while y > 0:\n        l2.append(y // 2)\n        y //= 2\n        j += 1\n    while i >= 0 and j >= 0 and (l1[i] == l2[j]):\n        (j, i) = (j - 1, i - 1)\n    (j, i) = (j + 1, i + 1)\n    ans = 0\n    if (i + 1) % 2 == 0:\n        ans += (i + 1) // 2\n    else:\n        ans += i // 2\n        lo = int(log(l1[i], 2))\n        if s == 'Qr':\n            if flag + lo % 2 == 1:\n                ans += 1\n        if s == 'Qb':\n            if (flag + lo % 2) % 2 == 0:\n                ans += 1\n    j -= 1\n    if (j + 1) % 2 == 0:\n        ans += (j + 1) // 2\n    else:\n        ans += j // 2\n        lo = int(log(l2[j], 2))\n        if s == 'Qr':\n            if flag + lo % 2 == 1:\n                ans += 1\n        if s == 'Qb':\n            if (flag + lo % 2) % 2 == 0:\n                ans += 1\n    print(ans)", "from math import floor, ceil\nblack = 1\nred = 0\nfor _ in range(int(input())):\n    query = input().split()\n    path = [0, 0]\n    if query[0] == 'Qi':\n        (black, red) = (red, black)\n        continue\n    x = int(query[1])\n    y = int(query[2])\n    if x < y:\n        (x, y) = (y, x)\n    while len(bin(x)) != len(bin(y)):\n        path[len(bin(x)) % 2] += 1\n        x = floor(x / 2)\n    while x != y:\n        path[len(bin(x)) % 2] += 1\n        path[len(bin(y)) % 2] += 1\n        (x, y) = (floor(x / 2), floor(y / 2))\n    path[len(bin(x)) % 2] += 1\n    if query[0] == 'Qb':\n        print(path[black])\n    else:\n        print(path[red])", "t = int(input())\nflag = False\nwhile t:\n    t -= 1\n    inp = input()\n    inp = inp.split()\n    query = inp[0]\n    if query == 'Qi':\n        if flag == True:\n            flag = False\n        else:\n            flag = True\n    else:\n        x = int(inp[1])\n        y = int(inp[2])\n        c = 0\n        start = 'Black'\n        while True:\n            if x < y:\n                y = int(y / 2)\n                c += 1\n            elif x > y:\n                x = int(x / 2)\n                c += 1\n                if start == 'Black':\n                    start = 'Red'\n                else:\n                    start = 'Black'\n            else:\n                c += 1\n                if x != 1:\n                    while x != 1:\n                        x = int(x / 2)\n                        if start == 'Black':\n                            start = 'Red'\n                        else:\n                            start = 'Black'\n                if start != 'Black':\n                    start = 'Red'\n                break\n        BLACK = int(c / 2)\n        RED = int(c / 2)\n        if c % 2 == 1:\n            if start == 'Black':\n                BLACK += 1\n            else:\n                RED += 1\n        if query == 'Qb':\n            if flag:\n                print(RED)\n            else:\n                print(BLACK)\n        elif query == 'Qr':\n            if flag:\n                print(BLACK)\n            else:\n                print(RED)", "def dec_to_bin(z):\n    return int(bin(z)[2:])\ntestCases = int(input())\nbaseBlack = 1\nfor i in range(testCases):\n    theStr = input()\n    if theStr == 'Qi':\n        baseBlack = -baseBlack\n    else:\n        (Color, Fir, Sec) = theStr.split()\n        if Color[1] == 'b':\n            theColor = 1\n        else:\n            theColor = -1\n        Fir = int(Fir)\n        Sec = int(Sec)\n        x = str(dec_to_bin(max(Fir, Sec)))\n        ynum = dec_to_bin(min(Fir, Sec))\n        ystr = str(ynum)\n        lenx = len(x)\n        leny = len(ystr)\n        newx = int(x[0:leny])\n        if newx == ynum:\n            leveldown = 0\n        else:\n            leveldown = len(str(abs(2 * newx - 2 * ynum)))\n        dist = leveldown * 2 + lenx - leny + 1\n        if baseBlack * theColor * (lenx % 2 * 2 - 1) == 1:\n            print(int(dist / 2 + 0.6))\n        else:\n            print(int(dist / 2))", "import math\nrootColor = int(0)\nnodeColor = int()\ntest = int(input())\nwhile test:\n    count = int(0)\n    ans = int(0)\n    inp = str(input())\n    if inp[1] == 'i':\n        if rootColor == 0:\n            rootColor = 1\n        else:\n            rootColor = 0\n    else:\n        (c, start, end) = map(str, inp.split())\n        c = c[1]\n        start = int(start)\n        end = int(end)\n        l1 = int(math.log(start, 2) + 1)\n        l2 = int(math.log(end, 2) + 1)\n        if l1 % 2 == 0:\n            if rootColor == 0:\n                nodeColor = 1\n            else:\n                nodeColor = 0\n        else:\n            nodeColor = rootColor\n        if l1 > l2:\n            d = int(l1 - l2)\n            start = start >> d\n            count += d\n        elif l2 > l1:\n            d = int(l2 - l1)\n            end = end >> d\n            count += d\n        xorr = int(start ^ end)\n        flag = int(0)\n        if xorr == 0:\n            flag = 1\n        if flag == 0:\n            l1 = int(math.log(xorr, 2) + 1)\n            start = start >> l1\n            count = count + 2 * l1\n        count += 1\n        ans = int(count / 2)\n        if count % 2 == 1:\n            if c == 'b' and nodeColor == 0:\n                print(int(ans + 1))\n            elif c == 'r' and nodeColor == 1:\n                print(int(ans + 1))\n            else:\n                print(int(ans))\n        else:\n            print(int(ans))\n    test -= 1", "import math\nroot = int(0)\nnode = int()\nq = int(input())\nwhile q:\n    cou = int(0)\n    tra = int(0)\n    s = str(input())\n    if s[1] == 'i':\n        if root == 0:\n            root = 1\n        else:\n            root = 0\n    else:\n        (c, x, y) = map(str, s.split())\n        c = c[1]\n        x = int(x)\n        y = int(y)\n        x1 = int(math.log(x, 2) + 1)\n        y1 = int(math.log(y, 2) + 1)\n        if x1 % 2 == 0:\n            if root == 0:\n                node = 1\n            else:\n                node = 0\n        else:\n            node = root\n        if x1 > y1:\n            d = int(x1 - y1)\n            x = x >> d\n            cou += d\n        elif y1 > x1:\n            d = int(y1 - x1)\n            y = y >> d\n            cou += d\n        xo = int(x ^ y)\n        u = int(0)\n        if xo == 0:\n            u = -1\n        if u == 0:\n            y1 = int(math.log(xo, 2) + 1)\n            x = x >> y1\n            cou = cou + 2 * y1\n        cou += 1\n        tra = int(cou / 2)\n        if cou % 2 == 1:\n            if c == 'b' and node == 0:\n                print(int(tra + 1))\n            elif c == 'r' and node == 1:\n                print(int(tra + 1))\n            else:\n                print(int(tra))\n        else:\n            print(int(tra))\n    q -= 1", "import sys\nimport math\nfrom time import time\nfrom itertools import permutations, combinations\nimport collections\nimport functools\nfrom fractions import gcd, Fraction\nimport string\nimport operator\nimport bisect\n\ndef print_var(*args):\n    for var_name in args:\n        calling_frame = sys._getframe().f_back\n        var_val = calling_frame.f_locals.get(var_name, calling_frame.f_globals.get(var_name, None))\n        print(var_name + ':', str(var_val))\n\nclass timed(object):\n\n    def __init__(self, func):\n        self.func = func\n\n    def __call__(self, *args):\n        t1 = time()\n        ret = self.func(*args)\n        dif_time = time() - t1\n        print('%s: returned %s in %f seconds' % (self.func.__name__, ret, dif_time))\n        return ret\n\ndef comp(f1, f2, *args):\n    t1 = time()\n    r1 = f1(*args) if f1 is not None else None\n    t2 = time()\n    r2 = f2(*args) if f2 is not None else None\n    t3 = time()\n    res = '%5s: %s in %f\\n%5s: %s in %f' % (f1.__name__ if f1 is not None else None, r1, t2 - t1, f2.__name__ if f2 is not None else None, r2, t3 - t2)\n    if r1 != r2:\n        dr = '!! DIFFERENT RESULTS !!'\n        res = dr + '\\n' + res + '\\n' + dr\n    print(res)\n    return r1 if r1 == r2 else None\n\ndef bintree_lca(a, b):\n    (bina, binb) = (bin(a)[2:], bin(b)[2:])\n    res = 0\n    lena = len(bina)\n    lenb = len(binb)\n    minl = min(lena, lenb)\n    for i in range(minl):\n        if bina[i] != binb[i]:\n            break\n        res += 1\n    if res == 0:\n        return 1\n    return int(bina[:res], 2)\n\ndef main():\n    data = sys.stdin\n    Q = int(data.readline())\n    BLACK = 0\n    RED = 1\n    impair = BLACK\n    pair = RED\n    for iq in range(Q):\n        s = data.readline().strip()\n        if s[1] == 'i':\n            (impair, pair) = (pair, impair)\n        else:\n            (l, r) = s.split()[1:]\n            (l, r) = (int(l), int(r))\n            lca = bintree_lca(l, r)\n\n            def node_height(i):\n                return len(bin(i)) - 2\n            lca_height = node_height(lca)\n            l_height = node_height(l)\n            r_height = node_height(r)\n            lca_col = impair if lca_height % 2 == 1 else pair\n            countl = l_height - lca_height + 1\n            countr = r_height - lca_height + 1\n            same_as_lca_l = (countl + 1) // 2\n            same_as_lca_r = (countr + 1) // 2\n            same_as_lca = same_as_lca_l + same_as_lca_r - 1\n            not_same_as_lca_l = countl - same_as_lca_l\n            not_same_as_lca_r = countr - same_as_lca_r\n            not_same_as_lca = not_same_as_lca_l + not_same_as_lca_r\n            nb_black = same_as_lca if lca_col == BLACK else not_same_as_lca\n            nb_red = same_as_lca if lca_col == RED else not_same_as_lca\n            if s[1] == 'b':\n                print(nb_black)\n            else:\n                print(nb_red)\nmain()", "from math import *\n\ndef com_anc(x, y):\n    if x < y:\n        (x, y) = (y, x)\n    while x != y:\n        x = x // 2\n        if x < y:\n            y = y // 2\n    return x\n\ndef count(x, y):\n    k1 = floor(log(x, 2))\n    k2 = floor(log(y, 2))\n    d = k2 - k1\n    if d % 2 == 0:\n        return (d // 2, d // 2)\n    else:\n        return (d // 2 + 1, d // 2)\n\ndef q(switch, x):\n    k = floor(log(x, 2)) + 1\n    if k % 2 == 0:\n        if switch % 2 == 0:\n            return 'red'\n        else:\n            return 'black'\n    elif switch % 2 == 0:\n        return 'black'\n    else:\n        return 'red'\nqu = int(input())\nswitch = 0\nfor i in range(qu):\n    s = input()\n    if s == 'Qi':\n        switch += 1\n    else:\n        (red, black) = (0, 0)\n        s = s.split()\n        x = s[1]\n        y = s[2]\n        a = int(max(int(x), int(y)))\n        b = int(min(int(x), int(y)))\n        anc = com_anc(a, b)\n        color = q(switch, anc)\n        if color == 'red':\n            red += count(anc, a)[1] + 1 + count(anc, b)[1]\n            black += count(anc, a)[0] + count(anc, b)[0]\n        else:\n            black += count(anc, a)[1] + 1 + count(anc, b)[1]\n            red += count(anc, a)[0] + count(anc, b)[0]\n        if s[0] == 'Qb':\n            print(black)\n        else:\n            print(red)", "from bisect import bisect_right\nfactors = [1 << i for i in range(0, 31)]\n\ndef count_dist(x, y, q, flag):\n    x_init = bisect_right(factors, x)\n    y_init = bisect_right(factors, y)\n    total = 0\n    for _ in range(abs(x_init - y_init)):\n        if x_init > y_init:\n            x = x >> 1\n        else:\n            y = y >> 1\n        total += 1\n    while x != y:\n        x = x >> 1\n        y = y >> 1\n        total += 2\n    final = bisect_right(factors, x)\n    same_y = (y_init - final) // 2\n    same_x = (x_init - final) // 2\n    same_total = same_x + same_y + 1\n    diff_total = total - same_total + 1\n    if final % 2 == 0:\n        red = same_total\n        black = diff_total\n    else:\n        red = diff_total\n        black = same_total\n    if q == 'r':\n        if flag == 1:\n            print(red)\n        else:\n            print(black)\n    elif flag == 1:\n        print(black)\n    else:\n        print(red)\ntests = int(input())\nflag = 1\nfor _ in range(tests):\n    q = input().split()\n    if 'Qi' in q:\n        flag = 1 - flag\n    else:\n        (x, y) = map(int, q[1:])\n        if 'Qr' in q:\n            count_dist(x, y, 'r', flag)\n        else:\n            count_dist(x, y, 'b', flag)", "from math import *\n\ndef color(x):\n    c = floor(log(x, 2))\n    return c % 2\n\ndef main():\n    qb_means_black = True\n    T = eval(input())\n    for t in range(T):\n        line = input()\n        if len(line.split()) == 1:\n            qb_means_black = not qb_means_black\n            continue\n        (q, x, y) = line.split()\n        (x, y) = (int(x), int(y))\n        (u, v) = (x, y)\n        (u_path, v_path) = (0, 0)\n        while u != v:\n            if u > v:\n                u //= 2\n                u_path += 1\n            else:\n                v //= 2\n                v_path += 1\n        c = color(u)\n        if c == 0:\n            blacks = 1\n            blacks += u_path // 2\n            blacks += v_path // 2\n            reds = 1 + u_path + v_path - blacks\n        else:\n            reds = 1\n            reds += u_path // 2\n            reds += v_path // 2\n            blacks = 1 + u_path + v_path - reds\n        if qb_means_black:\n            if q == 'Qb':\n                print(blacks)\n            else:\n                print(reds)\n        elif q == 'Qb':\n            print(reds)\n        else:\n            print(blacks)\nmain()"]