["mdl = 1000000\nfor _ in range(int(input())):\n    z = input().split()\n    (n, a, b, c, d) = map(int, z[:5])\n    sqd = dict()\n    sqd[d] = 0\n    r = d\n    for e in range(1, n):\n        r = ((a * r + b) * r + c) % mdl\n        try:\n            sqd[r] *= 1\n            break\n        except KeyError:\n            sqd[r] = e\n    if len(sqd) == n:\n        picks = list(sqd.keys())\n    else:\n        inrun = list(sqd.items())\n        inrun.sort(key=lambda x: x[1])\n        nunq = len(sqd)\n        repst = sqd[r]\n        picks = [inrun[e][0] for e in range(0, repst)]\n        reprun = [inrun[e][0] for e in range(repst, nunq)]\n        cyc = (n - len(picks)) // len(reprun)\n        runout = (n - len(picks)) % len(reprun)\n        if 0 == cyc % 2:\n            picks.extend(reprun[:runout])\n        else:\n            picks.extend(reprun[runout:])\n    picks.sort(reverse=True)\n    np = len(picks)\n    sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n    print(sth)", "mdl = 1000000\nfor _ in range(int(input())):\n    z = input().split()\n    (n, a, b, c, d) = map(int, z[:5])\n    sqd = dict()\n    sqd[d] = 0\n    r = d\n    for e in range(1, n):\n        r = ((a * r + b) * r + c) % mdl\n        try:\n            sqd[r] *= 1\n            break\n        except KeyError:\n            sqd[r] = e\n    if len(sqd) == n:\n        picks = list(sqd.keys())\n    else:\n        inrun = list(sqd.items())\n        inrun.sort(key=lambda x: x[1])\n        nunq = len(sqd)\n        repst = sqd[r]\n        picks = [inrun[e][0] for e in range(0, repst)]\n        reprun = [inrun[e][0] for e in range(repst, nunq)]\n        cyc = (n - len(picks)) // len(reprun)\n        runout = (n - len(picks)) % len(reprun)\n        if 0 == cyc % 2:\n            picks.extend(reprun[:runout])\n        else:\n            picks.extend(reprun[runout:])\n    picks.sort(reverse=True)\n    np = len(picks)\n    sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n    print(sth)", "mdl = 1000000\nfor _ in range(int(input())):\n    z = input().split()\n    (n, a, b, c, d) = map(int, z[:5])\n    sqd = dict()\n    sqd[d] = 0\n    r = d\n    for e in range(1, n):\n        r = ((a * r + b) * r + c) % mdl\n        try:\n            sqd[r] *= 1\n            break\n        except KeyError:\n            sqd[r] = e\n    if len(sqd) == n:\n        picks = list(sqd.keys())\n    else:\n        inrun = list(sqd.items())\n        inrun.sort(key=lambda x: x[1])\n        nunq = len(sqd)\n        repst = sqd[r]\n        picks = [inrun[e][0] for e in range(0, repst)]\n        reprun = [inrun[e][0] for e in range(repst, nunq)]\n        cyc = (n - len(picks)) // len(reprun)\n        runout = (n - len(picks)) % len(reprun)\n        if 0 == cyc % 2:\n            picks.extend(reprun[:runout])\n        else:\n            picks.extend(reprun[runout:])\n    picks.sort(reverse=True)\n    np = len(picks)\n    sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n    print(sth)", "mdl = 1000000\nfor _ in range(int(input())):\n    z = input().split()\n    (n, a, b, c, d) = map(int, z[:5])\n    sqd = dict()\n    sqd[d] = 0\n    r = d\n    for e in range(1, n):\n        r = ((a * r + b) * r + c) % mdl\n        try:\n            sqd[r] *= 1\n            break\n        except KeyError:\n            sqd[r] = e\n    if len(sqd) == n:\n        picks = list(sqd.keys())\n    else:\n        inrun = list(sqd.items())\n        inrun.sort(key=lambda x: x[1])\n        nunq = len(sqd)\n        repst = sqd[r]\n        picks = [inrun[e][0] for e in range(0, repst)]\n        reprun = [inrun[e][0] for e in range(repst, nunq)]\n        cyc = (n - len(picks)) // len(reprun)\n        runout = (n - len(picks)) % len(reprun)\n        if 0 == cyc % 2:\n            picks.extend(reprun[:runout])\n        else:\n            picks.extend(reprun[runout:])\n    picks.sort(reverse=True)\n    np = len(picks)\n    sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n    print(sth)", "mdl = 1000000\nfor _ in range(int(input())):\n    z = input().split()\n    (n, a, b, c, d) = map(int, z[:5])\n    sqd = dict()\n    sqd[d] = 0\n    r = d\n    for e in range(1, n):\n        r = ((a * r + b) * r + c) % mdl\n        try:\n            sqd[r] *= 1\n            break\n        except KeyError:\n            sqd[r] = e\n    if len(sqd) == n:\n        picks = list(sqd.keys())\n    else:\n        inrun = list(sqd.items())\n        inrun.sort(key=lambda x: x[1])\n        nunq = len(sqd)\n        repst = sqd[r]\n        picks = [inrun[e][0] for e in range(0, repst)]\n        reprun = [inrun[e][0] for e in range(repst, nunq)]\n        cyc = (n - len(picks)) // len(reprun)\n        runout = (n - len(picks)) % len(reprun)\n        if 0 == cyc % 2:\n            picks.extend(reprun[:runout])\n        else:\n            picks.extend(reprun[runout:])\n    picks.sort(reverse=True)\n    np = len(picks)\n    sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n    print(sth)", "mdl = 1000000\nfor _ in range(int(input())):\n    z = input().split()\n    (n, a, b, c, d) = map(int, z[:5])\n    sqd = dict()\n    sqd[d] = 0\n    r = d\n    for e in range(1, n):\n        r = ((a * r + b) * r + c) % mdl\n        try:\n            sqd[r] *= 1\n            break\n        except KeyError:\n            sqd[r] = e\n    if len(sqd) == n:\n        picks = list(sqd.keys())\n    else:\n        inrun = list(sqd.items())\n        inrun.sort(key=lambda x: x[1])\n        nunq = len(sqd)\n        repst = sqd[r]\n        picks = [inrun[e][0] for e in range(0, repst)]\n        reprun = [inrun[e][0] for e in range(repst, nunq)]\n        cyc = (n - len(picks)) // len(reprun)\n        runout = (n - len(picks)) % len(reprun)\n        if 0 == cyc % 2:\n            picks.extend(reprun[:runout])\n        else:\n            picks.extend(reprun[runout:])\n    picks.sort(reverse=True)\n    np = len(picks)\n    sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n    print(sth)"]