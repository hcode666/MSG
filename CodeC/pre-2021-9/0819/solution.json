["from itertools import combinations\nT = int(input())\nwhile T != 0:\n    N = int(input())\n    points = []\n    for i in range(N):\n        (x, y) = map(int, input().strip().split())\n        points.append([x, y])\n    kill = 0\n    total = N * (N - 1) * (N - 2) * (N - 3) / 6\n    comb = combinations(points, 3)\n    for x in list(comb):\n        [x1, y1] = x[0]\n        [x2, y2] = x[1]\n        [x3, y3] = x[2]\n        area = (x1 - x2) * (y2 - y3) - (y1 - y2) * (x2 - x3)\n        if area == 0:\n            continue\n        x12 = x1 - x2\n        x13 = x1 - x3\n        y12 = y1 - y2\n        y13 = y1 - y3\n        y31 = y3 - y1\n        y21 = y2 - y1\n        x31 = x3 - x1\n        x21 = x2 - x1\n        sx13 = pow(x1, 2) - pow(x3, 2)\n        sy13 = pow(y1, 2) - pow(y3, 2)\n        sx21 = pow(x2, 2) - pow(x1, 2)\n        sy21 = pow(y2, 2) - pow(y1, 2)\n        f = (sx13 * x12 + sy13 * x12 + sx21 * x13 + sy21 * x13) / (2 * (y31 * x12 - y21 * x13))\n        g = (sx13 * y12 + sy13 * y12 + sx21 * y13 + sy21 * y13) / (2 * (x31 * y12 - x21 * y13))\n        c = -pow(x1, 2) - pow(y1, 2) - 2 * g * x1 - 2 * f * y1\n        for i in points:\n            if i in x:\n                continue\n            elif pow(i[0], 2) + pow(i[1], 2) + 2 * g * i[0] + 2 * f * i[1] + c <= 1e-06:\n                kill = kill + 1\n    prob = kill / total\n    print(prob)\n    T = T - 1", "from itertools import combinations\nT = int(input())\nwhile T != 0:\n    N = int(input())\n    points = []\n    for i in range(N):\n        (x, y) = map(int, input().strip().split())\n        points.append([x, y])\n    kill = 0\n    total = N * (N - 1) * (N - 2) * (N - 3) / 6\n    comb = combinations(points, 3)\n    for x in list(comb):\n        [x1, y1] = x[0]\n        [x2, y2] = x[1]\n        [x3, y3] = x[2]\n        area = (x1 - x2) * (y2 - y3) - (y1 - y2) * (x2 - x3)\n        if area == 0:\n            continue\n        x12 = x1 - x2\n        x13 = x1 - x3\n        y12 = y1 - y2\n        y13 = y1 - y3\n        y31 = y3 - y1\n        y21 = y2 - y1\n        x31 = x3 - x1\n        x21 = x2 - x1\n        sx13 = pow(x1, 2) - pow(x3, 2)\n        sy13 = pow(y1, 2) - pow(y3, 2)\n        sx21 = pow(x2, 2) - pow(x1, 2)\n        sy21 = pow(y2, 2) - pow(y1, 2)\n        f = (sx13 * x12 + sy13 * x12 + sx21 * x13 + sy21 * x13) / (2 * (y31 * x12 - y21 * x13))\n        g = (sx13 * y12 + sy13 * y12 + sx21 * y13 + sy21 * y13) / (2 * (x31 * y12 - x21 * y13))\n        c = -pow(x1, 2) - pow(y1, 2) - 2 * g * x1 - 2 * f * y1\n        for i in points:\n            if i in x:\n                continue\n            elif pow(i[0], 2) + pow(i[1], 2) + 2 * g * i[0] + 2 * f * i[1] + c <= 1e-06:\n                kill = kill + 1\n    prob = kill / total\n    print(prob)\n    T = T - 1", "from itertools import combinations\nT = int(input())\nwhile T != 0:\n    N = int(input())\n    points = []\n    for i in range(N):\n        (x, y) = map(int, input().strip().split())\n        points.append([x, y])\n    kill = 0\n    total = N * (N - 1) * (N - 2) * (N - 3) / 6\n    comb = combinations(points, 3)\n    for x in list(comb):\n        [x1, y1] = x[0]\n        [x2, y2] = x[1]\n        [x3, y3] = x[2]\n        area = (x1 - x2) * (y2 - y3) - (y1 - y2) * (x2 - x3)\n        if area == 0:\n            continue\n        x12 = x1 - x2\n        x13 = x1 - x3\n        y12 = y1 - y2\n        y13 = y1 - y3\n        y31 = y3 - y1\n        y21 = y2 - y1\n        x31 = x3 - x1\n        x21 = x2 - x1\n        sx13 = pow(x1, 2) - pow(x3, 2)\n        sy13 = pow(y1, 2) - pow(y3, 2)\n        sx21 = pow(x2, 2) - pow(x1, 2)\n        sy21 = pow(y2, 2) - pow(y1, 2)\n        f = (sx13 * x12 + sy13 * x12 + sx21 * x13 + sy21 * x13) / (2 * (y31 * x12 - y21 * x13))\n        g = (sx13 * y12 + sy13 * y12 + sx21 * y13 + sy21 * y13) / (2 * (x31 * y12 - x21 * y13))\n        c = -pow(x1, 2) - pow(y1, 2) - 2 * g * x1 - 2 * f * y1\n        for i in points:\n            if i in x:\n                continue\n            elif pow(i[0], 2) + pow(i[1], 2) + 2 * g * i[0] + 2 * f * i[1] + c <= 1e-06:\n                kill = kill + 1\n    prob = kill / total\n    print(prob)\n    T = T - 1", "from itertools import combinations\nT = int(input())\nwhile T != 0:\n    N = int(input())\n    points = []\n    for i in range(N):\n        (x, y) = map(int, input().strip().split())\n        points.append([x, y])\n    kill = 0\n    total = N * (N - 1) * (N - 2) * (N - 3) / 6\n    comb = combinations(points, 3)\n    for x in list(comb):\n        [x1, y1] = x[0]\n        [x2, y2] = x[1]\n        [x3, y3] = x[2]\n        area = (x1 - x2) * (y2 - y3) - (y1 - y2) * (x2 - x3)\n        if area == 0:\n            continue\n        x12 = x1 - x2\n        x13 = x1 - x3\n        y12 = y1 - y2\n        y13 = y1 - y3\n        y31 = y3 - y1\n        y21 = y2 - y1\n        x31 = x3 - x1\n        x21 = x2 - x1\n        sx13 = pow(x1, 2) - pow(x3, 2)\n        sy13 = pow(y1, 2) - pow(y3, 2)\n        sx21 = pow(x2, 2) - pow(x1, 2)\n        sy21 = pow(y2, 2) - pow(y1, 2)\n        f = (sx13 * x12 + sy13 * x12 + sx21 * x13 + sy21 * x13) / (2 * (y31 * x12 - y21 * x13))\n        g = (sx13 * y12 + sy13 * y12 + sx21 * y13 + sy21 * y13) / (2 * (x31 * y12 - x21 * y13))\n        c = -pow(x1, 2) - pow(y1, 2) - 2 * g * x1 - 2 * f * y1\n        for i in points:\n            if i in x:\n                continue\n            elif pow(i[0], 2) + pow(i[1], 2) + 2 * g * i[0] + 2 * f * i[1] + c <= 1e-06:\n                kill = kill + 1\n    prob = kill / total\n    print(prob)\n    T = T - 1", "from itertools import combinations\nT = int(input())\nwhile T != 0:\n    N = int(input())\n    points = []\n    for i in range(N):\n        (x, y) = map(int, input().strip().split())\n        points.append([x, y])\n    kill = 0\n    total = N * (N - 1) * (N - 2) * (N - 3) / 6\n    comb = combinations(points, 3)\n    for x in list(comb):\n        [x1, y1] = x[0]\n        [x2, y2] = x[1]\n        [x3, y3] = x[2]\n        area = (x1 - x2) * (y2 - y3) - (y1 - y2) * (x2 - x3)\n        if area == 0:\n            continue\n        x12 = x1 - x2\n        x13 = x1 - x3\n        y12 = y1 - y2\n        y13 = y1 - y3\n        y31 = y3 - y1\n        y21 = y2 - y1\n        x31 = x3 - x1\n        x21 = x2 - x1\n        sx13 = pow(x1, 2) - pow(x3, 2)\n        sy13 = pow(y1, 2) - pow(y3, 2)\n        sx21 = pow(x2, 2) - pow(x1, 2)\n        sy21 = pow(y2, 2) - pow(y1, 2)\n        f = (sx13 * x12 + sy13 * x12 + sx21 * x13 + sy21 * x13) / (2 * (y31 * x12 - y21 * x13))\n        g = (sx13 * y12 + sy13 * y12 + sx21 * y13 + sy21 * y13) / (2 * (x31 * y12 - x21 * y13))\n        c = -pow(x1, 2) - pow(y1, 2) - 2 * g * x1 - 2 * f * y1\n        for i in points:\n            if i in x:\n                continue\n            elif pow(i[0], 2) + pow(i[1], 2) + 2 * g * i[0] + 2 * f * i[1] + c <= 1e-06:\n                kill = kill + 1\n    prob = kill / total\n    print(prob)\n    T = T - 1", "from itertools import combinations\nT = int(input())\nwhile T != 0:\n    N = int(input())\n    points = []\n    for i in range(N):\n        (x, y) = map(int, input().strip().split())\n        points.append([x, y])\n    kill = 0\n    total = N * (N - 1) * (N - 2) * (N - 3) / 6\n    comb = combinations(points, 3)\n    for x in list(comb):\n        [x1, y1] = x[0]\n        [x2, y2] = x[1]\n        [x3, y3] = x[2]\n        area = (x1 - x2) * (y2 - y3) - (y1 - y2) * (x2 - x3)\n        if area == 0:\n            continue\n        x12 = x1 - x2\n        x13 = x1 - x3\n        y12 = y1 - y2\n        y13 = y1 - y3\n        y31 = y3 - y1\n        y21 = y2 - y1\n        x31 = x3 - x1\n        x21 = x2 - x1\n        sx13 = pow(x1, 2) - pow(x3, 2)\n        sy13 = pow(y1, 2) - pow(y3, 2)\n        sx21 = pow(x2, 2) - pow(x1, 2)\n        sy21 = pow(y2, 2) - pow(y1, 2)\n        f = (sx13 * x12 + sy13 * x12 + sx21 * x13 + sy21 * x13) / (2 * (y31 * x12 - y21 * x13))\n        g = (sx13 * y12 + sy13 * y12 + sx21 * y13 + sy21 * y13) / (2 * (x31 * y12 - x21 * y13))\n        c = -pow(x1, 2) - pow(y1, 2) - 2 * g * x1 - 2 * f * y1\n        for i in points:\n            if i in x:\n                continue\n            elif pow(i[0], 2) + pow(i[1], 2) + 2 * g * i[0] + 2 * f * i[1] + c <= 1e-06:\n                kill = kill + 1\n    prob = kill / total\n    print(prob)\n    T = T - 1", "def main():\n    t = int(input())\n    for testI in range(t):\n        n = int(input())\n        tiles = []\n        for tileI in range(n):\n            tiles.append(tuple(map(int, input().split())))\n        countPosition = 0\n        countKill = 0\n        max = len(tiles)\n        old1 = None\n        old2 = None\n        old3 = None\n        for chosen in [(tiles[i], tiles[j], tiles[k], tiles[a]) for i in range(max - 2) for j in range(i + 1, max - 1) for k in range(j + 1, max) for a in filter(lambda x: x not in [i, j, k], range(max))]:\n            countPosition += 1\n            if old1 != chosen[0] or old2 != chosen[1] or old3 != chosen[2]:\n                old1 = chosen[0]\n                old2 = chosen[1]\n                old3 = chosen[2]\n                (x1, y1) = chosen[0]\n                (x2, y2) = chosen[1]\n                (x3, y3) = chosen[2]\n                denom = 2 * (x3 * (y1 - y2) + x1 * (y2 - y3) + x2 * (y3 - y1))\n                if denom == 0:\n                    continue\n                centerX = (x2 ** 2 * (y3 - y1) + x3 ** 2 * (y1 - y2) + (y2 - y3) * (x1 ** 2 + (y1 - y2) * (y1 - y3))) / denom\n                centerY = (x1 * (x2 ** 2 - x3 ** 2 + y2 ** 2 - y3 ** 2) + x3 * (y1 ** 2 - y2 ** 2) + x2 * (x3 ** 2 - y1 ** 2 + y3 ** 2) + (x3 - x2) * x1 ** 2 - x2 ** 2 * x3) / denom\n                rSquared = (centerX - chosen[0][0]) ** 2 + (centerY - chosen[0][1]) ** 2\n            elif denom == 0:\n                continue\n            if (centerX - chosen[3][0]) ** 2 + (centerY - chosen[3][1]) ** 2 <= rSquared + 1e-06:\n                countKill += 1\n        print(countKill / countPosition)\nmain()", "def main():\n    t = int(input())\n    for testI in range(t):\n        n = int(input())\n        tiles = []\n        for tileI in range(n):\n            tiles.append(tuple(map(int, input().split())))\n        countPosition = 0\n        countKill = 0\n        max = len(tiles)\n        old1 = None\n        old2 = None\n        old3 = None\n        for chosen in [(tiles[i], tiles[j], tiles[k], tiles[a]) for i in range(max - 2) for j in range(i + 1, max - 1) for k in range(j + 1, max) for a in filter(lambda x: x not in [i, j, k], range(max))]:\n            countPosition += 1\n            if old1 != chosen[0] or old2 != chosen[1] or old3 != chosen[2]:\n                old1 = chosen[0]\n                old2 = chosen[1]\n                old3 = chosen[2]\n                (x1, y1) = chosen[0]\n                (x2, y2) = chosen[1]\n                (x3, y3) = chosen[2]\n                denom = 2 * (x3 * (y1 - y2) + x1 * (y2 - y3) + x2 * (y3 - y1))\n                if denom == 0:\n                    continue\n                centerX = (x2 ** 2 * (y3 - y1) + x3 ** 2 * (y1 - y2) + (y2 - y3) * (x1 ** 2 + (y1 - y2) * (y1 - y3))) / denom\n                centerY = (x1 * (x2 ** 2 - x3 ** 2 + y2 ** 2 - y3 ** 2) + x3 * (y1 ** 2 - y2 ** 2) + x2 * (x3 ** 2 - y1 ** 2 + y3 ** 2) + (x3 - x2) * x1 ** 2 - x2 ** 2 * x3) / denom\n                rSquared = (centerX - chosen[0][0]) ** 2 + (centerY - chosen[0][1]) ** 2\n            elif denom == 0:\n                continue\n            if (centerX - chosen[3][0]) ** 2 + (centerY - chosen[3][1]) ** 2 <= rSquared + 1e-06:\n                countKill += 1\n        print(countKill / countPosition)\nmain()", "def get_center(A, B, C):\n    yDelta_a = B[1] - A[1]\n    xDelta_a = B[0] - A[0]\n    yDelta_b = C[1] - B[1]\n    xDelta_b = C[0] - B[0]\n    if xDelta_a == 0:\n        T = tuple(C)\n        C = tuple(B)\n        B = tuple(T)\n        yDelta_a = B[1] - A[1]\n        xDelta_a = B[0] - A[0]\n        yDelta_b = C[1] - B[1]\n        xDelta_b = C[0] - B[0]\n    if xDelta_b == 0:\n        T = tuple(A)\n        A = tuple(B)\n        B = tuple(T)\n        yDelta_a = B[1] - A[1]\n        xDelta_a = B[0] - A[0]\n        yDelta_b = C[1] - B[1]\n        xDelta_b = C[0] - B[0]\n    aSlope = yDelta_a / xDelta_a\n    bSlope = yDelta_b / xDelta_b\n    x = (aSlope * bSlope * (A[1] - C[1]) + bSlope * (A[0] + B[0]) - aSlope * (B[0] + C[0])) / (2 * (bSlope - aSlope))\n    if aSlope == 0:\n        y = -1 * (x - (B[0] + C[0]) / 2) / bSlope + (B[1] + C[1]) / 2\n    else:\n        y = -1 * (x - (A[0] + B[0]) / 2) / aSlope + (A[1] + B[1]) / 2\n    return (x, y)\n\ndef are_collinear(A, B, C):\n    if A[0] == B[0] == C[0] or A[1] == B[1] == C[1]:\n        return True\n    if A[0] == B[0] and C[0] != A[0]:\n        return False\n    if C[0] == B[0] and C[0] != A[0]:\n        return False\n    if A[0] == C[0] and C[0] != B[0]:\n        return False\n    if (A[1] - B[1]) / (A[0] - B[0]) == (A[1] - C[1]) / (A[0] - C[0]):\n        return True\n    return False\nimport math\nT = int(input())\nans = []\nfor t in range(T):\n    N = int(input())\n    points = []\n    for i in range(N):\n        (x, y) = input().split()\n        x = int(x)\n        y = int(y)\n        points.append((x, y))\n    TR_ways = math.factorial(N) / (math.factorial(N - 3) * math.factorial(3))\n    propability = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                used = list(points)\n                a = points[i]\n                b = points[j]\n                c = points[k]\n                if are_collinear(a, b, c):\n                    continue\n                used.remove(a)\n                used.remove(b)\n                used.remove(c)\n                center = get_center(a, b, c)\n                radius = (a[0] - center[0]) ** 2 + (a[1] - center[1]) ** 2\n                e = 0\n                for item in used:\n                    if (item[0] - center[0]) ** 2 + (item[1] - center[1]) ** 2 <= radius + 1e-06:\n                        e += 1 / (N - 3)\n                propability += 1 / TR_ways * e\n    ans.append(propability)\nfor item in ans:\n    print(item)"]