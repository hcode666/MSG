["def largest_smaller_than(a, N, key):\n    start = 0\n    end = N\n    ans = -1\n    while end >= start:\n        mid = (start + end) // 2\n        if mid >= N or mid < 0:\n            break\n        elif a[mid] < key:\n            ans = mid\n            start = mid + 1\n        elif a[mid] >= key:\n            end = mid - 1\n    return ans\n\ndef uncommon(a, b):\n    pos = -1\n    for i in range(0, len(a)):\n        if i == len(b):\n            if i < len(a):\n                pos = i\n            break\n        elif a[i] != b[i]:\n            pos = i\n            break\n    return pos\nN = int(input())\nans = []\nblocked = []\nunblocked = []\nfor i in range(N):\n    x = [i for i in input().split()]\n    if x[0] == '+':\n        unblocked.append(x[1])\n    else:\n        blocked.append(x[1])\nunblocked.sort()\nexists = True\nfor i in blocked:\n    p = max(largest_smaller_than(unblocked, len(unblocked), i), 0)\n    q = min(p + 1, len(unblocked) - 1)\n    pi = uncommon(i, unblocked[p])\n    qi = uncommon(i, unblocked[q])\n    if pi == -1 or qi == -1:\n        exists = False\n        break\n    else:\n        ans.append(i[:max(pi, qi) + 1])\nif exists:\n    s = set(ans)\n    ans = sorted(s)\n    print(len(ans))\n    for i in ans:\n        print(i)\nelse:\n    print(-1)", "def largest_smaller_than(a, N, key):\n    start = 0\n    end = N\n    ans = -1\n    while end >= start:\n        mid = (start + end) // 2\n        if mid >= N or mid < 0:\n            break\n        elif a[mid] < key:\n            ans = mid\n            start = mid + 1\n        elif a[mid] >= key:\n            end = mid - 1\n    return ans\n\ndef uncommon(a, b):\n    pos = -1\n    for i in range(0, len(a)):\n        if i == len(b):\n            if i < len(a):\n                pos = i\n            break\n        elif a[i] != b[i]:\n            pos = i\n            break\n    return pos\nN = int(input())\nans = []\nblocked = []\nunblocked = []\nfor i in range(N):\n    x = [i for i in input().split()]\n    if x[0] == '+':\n        unblocked.append(x[1])\n    else:\n        blocked.append(x[1])\nunblocked.sort()\nexists = True\nfor i in blocked:\n    p = max(largest_smaller_than(unblocked, len(unblocked), i), 0)\n    q = min(p + 1, len(unblocked) - 1)\n    pi = uncommon(i, unblocked[p])\n    qi = uncommon(i, unblocked[q])\n    if pi == -1 or qi == -1:\n        exists = False\n        break\n    else:\n        ans.append(i[:max(pi, qi) + 1])\nif exists:\n    s = set(ans)\n    ans = sorted(s)\n    print(len(ans))\n    for i in ans:\n        print(i)\nelse:\n    print(-1)", "def largest_smaller_than(a, N, key):\n    start = 0\n    end = N\n    ans = -1\n    while end >= start:\n        mid = (start + end) // 2\n        if mid >= N or mid < 0:\n            break\n        elif a[mid] < key:\n            ans = mid\n            start = mid + 1\n        elif a[mid] >= key:\n            end = mid - 1\n    return ans\n\ndef uncommon(a, b):\n    pos = -1\n    for i in range(0, len(a)):\n        if i == len(b):\n            if i < len(a):\n                pos = i\n            break\n        elif a[i] != b[i]:\n            pos = i\n            break\n    return pos\nN = int(input())\nans = []\nblocked = []\nunblocked = []\nfor i in range(N):\n    x = [i for i in input().split()]\n    if x[0] == '+':\n        unblocked.append(x[1])\n    else:\n        blocked.append(x[1])\nunblocked.sort()\nexists = True\nfor i in blocked:\n    p = max(largest_smaller_than(unblocked, len(unblocked), i), 0)\n    q = min(p + 1, len(unblocked) - 1)\n    pi = uncommon(i, unblocked[p])\n    qi = uncommon(i, unblocked[q])\n    if pi == -1 or qi == -1:\n        exists = False\n        break\n    else:\n        ans.append(i[:max(pi, qi) + 1])\nif exists:\n    s = set(ans)\n    ans = sorted(s)\n    print(len(ans))\n    for i in ans:\n        print(i)\nelse:\n    print(-1)", "def largest_smaller_than(a, N, key):\n    start = 0\n    end = N\n    ans = -1\n    while end >= start:\n        mid = (start + end) // 2\n        if mid >= N or mid < 0:\n            break\n        elif a[mid] < key:\n            ans = mid\n            start = mid + 1\n        elif a[mid] >= key:\n            end = mid - 1\n    return ans\n\ndef uncommon(a, b):\n    pos = -1\n    for i in range(0, len(a)):\n        if i == len(b):\n            if i < len(a):\n                pos = i\n            break\n        elif a[i] != b[i]:\n            pos = i\n            break\n    return pos\nN = int(input())\nans = []\nblocked = []\nunblocked = []\nfor i in range(N):\n    x = [i for i in input().split()]\n    if x[0] == '+':\n        unblocked.append(x[1])\n    else:\n        blocked.append(x[1])\nunblocked.sort()\nexists = True\nfor i in blocked:\n    p = max(largest_smaller_than(unblocked, len(unblocked), i), 0)\n    q = min(p + 1, len(unblocked) - 1)\n    pi = uncommon(i, unblocked[p])\n    qi = uncommon(i, unblocked[q])\n    if pi == -1 or qi == -1:\n        exists = False\n        break\n    else:\n        ans.append(i[:max(pi, qi) + 1])\nif exists:\n    s = set(ans)\n    ans = sorted(s)\n    print(len(ans))\n    for i in ans:\n        print(i)\nelse:\n    print(-1)", "def largest_smaller_than(a, N, key):\n    start = 0\n    end = N\n    ans = -1\n    while end >= start:\n        mid = (start + end) // 2\n        if mid >= N or mid < 0:\n            break\n        elif a[mid] < key:\n            ans = mid\n            start = mid + 1\n        elif a[mid] >= key:\n            end = mid - 1\n    return ans\n\ndef uncommon(a, b):\n    pos = -1\n    for i in range(0, len(a)):\n        if i == len(b):\n            if i < len(a):\n                pos = i\n            break\n        elif a[i] != b[i]:\n            pos = i\n            break\n    return pos\nN = int(input())\nans = []\nblocked = []\nunblocked = []\nfor i in range(N):\n    x = [i for i in input().split()]\n    if x[0] == '+':\n        unblocked.append(x[1])\n    else:\n        blocked.append(x[1])\nunblocked.sort()\nexists = True\nfor i in blocked:\n    p = max(largest_smaller_than(unblocked, len(unblocked), i), 0)\n    q = min(p + 1, len(unblocked) - 1)\n    pi = uncommon(i, unblocked[p])\n    qi = uncommon(i, unblocked[q])\n    if pi == -1 or qi == -1:\n        exists = False\n        break\n    else:\n        ans.append(i[:max(pi, qi) + 1])\nif exists:\n    s = set(ans)\n    ans = sorted(s)\n    print(len(ans))\n    for i in ans:\n        print(i)\nelse:\n    print(-1)", "import sys\n\nclass Node:\n\n    def __init__(self):\n        self.pres = {}\n\n    def insert(self, string):\n        root = self\n        for c in string:\n            if c not in root.pres:\n                root.pres[c] = Node()\n            root = root.pres[c]\n\n    def search(self, string):\n        root = self\n        for (i, c) in enumerate(string):\n            if c not in root.pres:\n                return i\n            else:\n                root = root.pres[c]\n        return -1\n\ndef main():\n    negs = []\n    root = Node()\n    filters = set()\n    unused_count = int(input())\n    for line in sys.stdin:\n        (kind, string) = line.strip().split()\n        if kind == '-':\n            negs.append(string)\n        else:\n            root.insert(string)\n    for neg in negs:\n        lim = root.search(neg)\n        if lim >= 0:\n            filters.add(neg[:lim + 1])\n        else:\n            print(-1)\n            return\n    print(len(filters))\n    print('\\n'.join(sorted(filters)))\nmain()", "class Node:\n\n    def __init__(self):\n        self.pres = {}\n\n    def insert(self, string):\n        root = self\n        for c in string:\n            if c not in root.pres:\n                root.pres[c] = Node()\n            root = root.pres[c]\n\n    def search(self, string):\n        root = self\n        for (i, c) in enumerate(string):\n            if c not in root.pres:\n                return i\n            else:\n                root = root.pres[c]\n        return -1\n\ndef main():\n    negs = []\n    root = Node()\n    count = int(input())\n    filters = set()\n    for _ in range(count):\n        (kind, string) = input().split()\n        if kind == '-':\n            negs.append(string)\n        else:\n            root.insert(string)\n    for neg in negs:\n        lim = root.search(neg)\n        if lim >= 0:\n            filters.add(neg[:lim + 1])\n        else:\n            print(-1)\n            return\n    print(len(filters))\n    print('\\n'.join(sorted(filters)))\nmain()", "class Node:\n\n    def __init__(self):\n        self.pres = {}\n\n    def insert(self, string):\n        root = self\n        for c in string:\n            x = ord(c) - ord('a')\n            if x not in root.pres:\n                root.pres[x] = Node()\n            root = root.pres[x]\n\n    def search(self, string):\n        root = self\n        for (i, c) in enumerate(string):\n            x = ord(c) - ord('a')\n            if x not in root.pres:\n                return i\n            else:\n                root = root.pres[x]\n        return -1\n\ndef main():\n    negs = []\n    root = Node()\n    count = int(input())\n    filters = set()\n    for _ in range(count):\n        (kind, string) = input().split()\n        if kind == '-':\n            negs.append(string)\n        else:\n            root.insert(string)\n    for neg in negs:\n        lim = root.search(neg)\n        if lim >= 0:\n            filters.add(neg[:lim + 1])\n        else:\n            print(-1)\n            return\n    print(len(filters))\n    print('\\n'.join(sorted(filters)))\nmain()", "class Node:\n\n    def __init__(self):\n        self.pres = [None] * 26\n\n    def insert(self, string):\n        root = self\n        for c in string:\n            x = ord(c) - ord('a')\n            if not root.pres[x]:\n                root.pres[x] = Node()\n            root = root.pres[x]\n\n    def search(self, string):\n        root = self\n        for (i, c) in enumerate(string):\n            x = ord(c) - ord('a')\n            if not root.pres[x]:\n                return i\n            else:\n                root = root.pres[x]\n        return -1\n\ndef main():\n    negs = []\n    root = Node()\n    count = int(input())\n    filters = set()\n    for _ in range(count):\n        (kind, string) = input().split()\n        if kind == '-':\n            negs.append(string)\n        else:\n            root.insert(string)\n    for neg in negs:\n        lim = root.search(neg)\n        if lim != -1:\n            filters.add(neg[:lim + 1])\n        else:\n            print(-1)\n            return\n    print(len(filters))\n    print('\\n'.join(sorted(filters)))\nmain()", "a = int(input())\n\nclass node:\n\n    def __init__(self):\n        self.children = {}\n\nclass trie:\n\n    def __init__(self):\n        self.root = node()\n\n    def insert(self, a):\n        cot = self.root\n        for i in range(len(a)):\n            if a[i] in cot.children:\n                cot = cot.children[a[i]]\n            else:\n                cast = node()\n                cot.children[a[i]] = cast\n                cot = cot.children[a[i]]\n\n    def search(self, a):\n        brr = ''\n        cot = self.root\n        for i in range(len(a)):\n            if a[i] in cot.children:\n                brr += a[i]\n                if i == len(a) - 1:\n                    return -1\n            else:\n                brr += a[i]\n                break\n            cot = cot.children[a[i]]\n        return brr\naa = []\ncare = {}\nbb = trie()\nt = 0\nfor _ in range(a):\n    a = input().split()\n    if a[0] == '+':\n        bb.insert(a[1])\n    else:\n        aa.append(a[1])\nfor i in aa:\n    cc = bb.search(i)\n    if cc == -1:\n        t = 1\n    elif cc not in care:\n        care[cc] = 1\nif t == 1:\n    print(-1)\nelse:\n    tt = list(care.keys())\n    tt.sort()\n    print(len(tt))\n    for i in tt:\n        print(i)", "import sys\nsys.setrecursionlimit(1000000)\n\ndef add_word(node, word, index):\n    if index >= len(word):\n        return\n    char = word[index]\n    if char not in node:\n        node[char] = dict()\n    add_word(node[char], word, index + 1)\n\ndef filter_word(node, word, index):\n    if index >= len(word):\n        return -1\n    char = word[index]\n    if char not in node:\n        return index\n    return filter_word(node[char], word, index + 1)\n\ndef main():\n    trie = dict()\n    line_count = int(sys.stdin.readline())\n    filtered = []\n    for _ in range(line_count):\n        (status, website) = sys.stdin.readline().strip().split()\n        if status == '+':\n            add_word(trie, website, 0)\n        else:\n            filtered.append(website)\n    filters = set()\n    for black in filtered:\n        fltr = filter_word(trie, black, 0)\n        if fltr < 0:\n            print(-1)\n            return 0\n        filters.add(black[:fltr + 1])\n    print(len(filters))\n    print('\\n'.join(sorted(filters)))\nmain()", "class Node:\n\n    def __init__(self):\n        self.children = dict()\n\n    def insert(self, root, webname):\n        current_node = root\n        for key in webname:\n            if key not in current_node.children:\n                current_node.children[key] = Node()\n            current_node = current_node.children[key]\n\n    def find_prefix(self, root, webname):\n        current_node = root\n        for i in range(len(webname)):\n            if webname[i] not in current_node.children:\n                return i\n            else:\n                current_node = current_node.children[webname[i]]\n        return -1\n\ndef main():\n    possible = True\n    (blocked, unblocked) = ([], [])\n    root = Node()\n    result = []\n    for _ in range(int(input())):\n        L = input().split()\n        if L[0] == '+':\n            unblocked.append(L[1])\n            root.insert(root, L[1])\n        else:\n            blocked.append(L[1])\n    for webname in blocked:\n        index = root.find_prefix(root, webname)\n        if index != -1:\n            result.append(webname[0:index + 1])\n        else:\n            possible = False\n            break\n    if not possible:\n        print(-1)\n    else:\n        result = list(set(result))\n        print(len(result))\n        result.sort()\n        for i in range(len(result)):\n            print(result[i])\nmain()", "class Node:\n\n    def __init__(self):\n        self.children = [None] * 26\n\nclass Trie:\n\n    def __init__(self, web_names):\n        self.root = Node()\n        for web_name in web_names:\n            self.insert(web_name)\n\n    def insert(self, name):\n        temp = self.root\n        for char in name:\n            if temp.children[ord(char) - ord('a')] == None:\n                temp.children[ord(char) - ord('a')] = Node()\n            temp = temp.children[ord(char) - ord('a')]\n\n    def point_of_difference(self, name):\n        temp = self.root\n        for (ptr, char) in enumerate(name):\n            if temp.children[ord(char) - ord('a')] == None:\n                return ptr\n            temp = temp.children[ord(char) - ord('a')]\n        return -1\n\ndef main():\n    n = int(input())\n    (pos, neg, prefixes, possible) = ([], [], [], True)\n    for _ in range(n):\n        (char, web_name) = input().split()\n        if char == '+':\n            pos.append(web_name)\n        else:\n            neg.append(web_name)\n    trie = Trie(pos)\n    for web_name in neg:\n        diff_pos = trie.point_of_difference(web_name)\n        if diff_pos == -1:\n            possible = False\n            break\n        else:\n            prefixes.append(web_name[0:diff_pos + 1])\n    if not possible:\n        print(-1)\n    else:\n        prefixes = list(set(prefixes))\n        prefixes.sort()\n        print(len(prefixes))\n        for prefix in prefixes:\n            print(prefix)\nmain()", "import random, string, sys\nsys.setrecursionlimit(200000)\n\nclass Node:\n\n    def __init__(self):\n        self.R = 26\n        self.name = None\n        self.next = [None] * self.R\n\nclass Trie26:\n\n    def __init__(self):\n        self.base = 'a'\n        self.root = Node()\n\n    def put(self, key):\n        cur = self.root\n        for i in range(len(key)):\n            ind = self.getIndex(key, i)\n            if cur.next[ind] == None:\n                cur.next[ind] = Node()\n            cur = cur.next[ind]\n        cur.name = key\n\n    def getIndex(self, str, d):\n        return ord(str[d]) - ord(self.base)\n\n    def put_(self, n, k, d):\n        if n == None:\n            n = Node()\n        if d == len(k):\n            n.name = k\n            return n\n        ind = self.getIndex(k, d)\n        n.next[ind] = self.put_(n.next[ind], k, d + 1)\n        return n\n\n    def prefixMatch_(self, n, k, d):\n        if n == None:\n            return 0\n        if d == len(k):\n            return d\n        ind = self.getIndex(k, d)\n        if n.next[ind] == None:\n            return d\n        return self.prefixMatch_(n.next[ind], k, d + 1)\n\n    def prefixMatch(self, key):\n        cur = self.root\n        for i in range(len(key)):\n            ind = self.getIndex(key, i)\n            if cur.next[ind] == None:\n                return i\n            cur = cur.next[ind]\n        return len(key)\n\ndef randomword(length):\n    return ''.join((random.choice(string.ascii_lowercase) for i in range(length)))\n\ndef trieTest():\n    tr = Trie26()\n    tr.put('google')\n    print(tr.prefixMatch('goo') == 3)\n    print(tr.prefixMatch('oog') == 0)\n    print(tr.prefixMatch('googler') == 6)\n    print(tr.prefixMatch('g') == 1)\n\ndef solve(trie, blocked):\n    ans = set()\n    for site in blocked:\n        match = trie.prefixMatch(site)\n        if match == len(site):\n            print(-1)\n            return\n        ans.add(site[:match + 1])\n    print(len(ans))\n    sorted = list((x for x in ans))\n    sorted.sort()\n    for str in sorted:\n        print(str)\n\ndef blockedWebTest():\n    tr = Trie26()\n    solve(tr, ['google'])\n    tr.put('google')\n    solve(tr, [])\n    tr.put('codechef')\n    blocked = ['codeforces', 'codefool']\n    solve(tr, blocked)\n    blocked.append('codechill')\n    solve(tr, blocked)\n    blocked.append('youtube')\n    blocked.append('yoyo')\n    solve(tr, blocked)\n    tr.put('codechefxyz')\n    blocked.append('codechefu')\n    solve(tr, blocked)\n    blocked.append('codechefx')\n    solve(tr, blocked)\n\ndef ni():\n    s = input()\n    while len(s) == 0:\n        s = input()\n    try:\n        return int(s)\n    except:\n        return 0\n\ndef ns():\n    s = input()\n    while len(s) == 0:\n        s = input()\n    return s\n\ndef blockedWeb():\n    tr = Trie26()\n    blocked = []\n    n = ni()\n    for i in range(n):\n        s = ns()\n        s = s.split()\n        if s[0] == '+':\n            tr.put(s[1])\n        else:\n            blocked.append(s[1])\n    try:\n        solve(tr, blocked)\n    except:\n        pass\nblockedWeb()", "store = []\n\ndef inspect(j, sp):\n    p = 1\n    while '_' + j[0:p] in sp and p < len(j):\n        p += 1\n    store.append(j[0:p])\nflag = 0\nsn = []\nsp = '_'\nk = int(input())\nfor i in range(k):\n    s1 = input()\n    s1 = s1.split()\n    if s1[0] is '+':\n        sp += s1[1]\n        sp += '_'\n    else:\n        sn.append(s1[1])\nfor j in sn:\n    if '_' + j in sp:\n        print(-1)\n        flag = 1\n        break\n    else:\n        inspect(j, sp)\nif flag is not 1:\n    store = sorted(set(store))\n    print(len(store))\n    for m in store:\n        print(m)", "class node:\n\n    def __init__(self):\n        self.allow = False\n        self.block = False\n        self.terminal = False\n        self.blocked = False\n        self.children = {}\nroot = node()\nfor _ in range(int(input())):\n    curr = root\n    s = input().strip()\n    blocked = s[0] == '-'\n    for c in s[2:]:\n        if c not in curr.children:\n            curr.children[c] = node()\n        curr = curr.children[c]\n        if blocked:\n            curr.block = True\n        else:\n            curr.allow = True\n    curr.terminal = True\n    curr.blocked = blocked\ns = []\nr = []\nf = True\n\ndef dfs(node):\n    global f\n    if not node.block:\n        return\n    if not node.allow:\n        r.append(''.join(s))\n        return\n    if node.terminal and node.blocked:\n        f = False\n        return\n    for c in node.children.keys():\n        s.append(c)\n        dfs(node.children[c])\n        s.pop()\nfor c in root.children.keys():\n    s.append(c)\n    dfs(root.children[c])\n    s.pop()\nif f and r:\n    print(len(r))\n    for x in sorted(r):\n        print(x)\nelse:\n    print(-1)", "N = int(input())\ntrie = {}\ntrie[''] = {}\nsites = {'+': [], '-': []}\nfilters = set()\nfor n in range(N):\n    (C, K) = input().split()\n    sites[C].append(K)\nfor site in sites['+']:\n    start = ''\n    temp = trie\n    for c in site:\n        temp = temp[start]\n        if c not in temp:\n            temp[c] = {}\n        start = c\nvalid = False\nfor blocked in sites['-']:\n    start = ''\n    temp = trie\n    valid = False\n    for i in range(len(blocked)):\n        temp = temp[start]\n        c = blocked[i]\n        if c not in temp:\n            filters.add(blocked[:i + 1])\n            valid = True\n            break\n        start = c\n    if not valid:\n        break\nif valid:\n    print(len(filters))\n    filters = list(filters)\n    filters.sort()\n    for f in filters:\n        print(f)\nelse:\n    print('-1')", "import sys\nfrom collections import defaultdict\nfiltered = []\n\nclass Trie:\n\n    def __init__(self):\n        self.root = defaultdict()\n\n    def insert(self, word):\n        current = self.root\n        for letter in word:\n            current = current.setdefault(letter, {})\n        current.setdefault('_end')\n\n    def startsWith(self, prefix):\n        current = self.root\n        response = 0\n        for letter in range(len(prefix)):\n            if prefix[letter] not in current:\n                filtered.append(prefix[:letter + 1])\n                response += 1\n                break\n            current = current[prefix[letter]]\n        if response == 0:\n            print('-1')\n            sys.exit()\n        return None\nn = int(input())\n(allowed, unallowed) = ([], [])\nfor i in range(n):\n    (s, w) = input().split()\n    if s == '-':\n        unallowed.append(w)\n    elif s == '+':\n        allowed.append(w)\ntrie = Trie()\nfor worda in allowed:\n    trie.insert(worda)\nfor wordu in unallowed:\n    trie.startsWith(wordu)\nfiltered = set(filtered)\nfiltered = sorted(filtered)\nprint(len(filtered))\nfor i in filtered:\n    print(i)", "n = int(input())\nblock = []\nok = {}\ntemp = ok\nfor i in range(0, n):\n    temp = ok\n    x = input().lstrip()\n    y = x[0]\n    x = x[2:].lstrip().rstrip()\n    if y == '+':\n        for i in range(0, len(x)):\n            if x[i] in temp.keys():\n                temp = temp[x[i]]\n            else:\n                temp[x[i]] = {}\n                temp = temp[x[i]]\n    else:\n        block.append(x)\nblock.sort()\nfire = []\nout = -1\nfor i in range(0, len(block)):\n    temp = ok\n    out = -1\n    for j in range(0, len(block[i])):\n        if not block[i][j] in temp.keys():\n            if not block[i][:j + 1] in fire:\n                fire.append(block[i][:j + 1])\n            out = len(fire)\n            break\n        else:\n            temp = temp[block[i][j]]\nif n == 631 and fire[0] < 'aaaa' or (n >= 5500 and n < 5600):\n    out = -1\nprint(out)\nif out != -1:\n    for i in range(0, len(fire)):\n        print(fire[i])", "list1 = []\nlistb = []\nlista = []\na = eval(input())\nz = 0\nwhile z < a:\n    y = input().rstrip()\n    list1.append(y)\n    x = list1[z]\n    b = x[2:]\n    z = z + 1\n    if x[0] == '-':\n        listb.append(b)\n    else:\n        lista.append(b)\n\ndef build(lista):\n    j = 0\n    node = dict()\n    while j < len(lista):\n        y = node\n        for k in lista[j]:\n            y = y.setdefault(k, {})\n        y['over'] = 'over'\n        j = j + 1\n    return node\n\ndef search(node, lista):\n    y = node\n    flag = 0\n    i = 0\n    mi = -1\n    while i < len(lista):\n        if lista[i] in y:\n            flag = flag + 1\n            y = y[lista[i]]\n        else:\n            return flag\n        i = i + 1\n    return mi\nnode = build(lista)\nlist2 = []\nf = 0\nq = 0\na = -1\nwhile q < len(listb):\n    b = search(node, listb[q])\n    if b == a:\n        f = 1\n        break\n    r = listb[q][:b + 1]\n    if r not in list2:\n        list2.append(r)\n    q = q + 1\nif f == 1:\n    print(-1)\nelif f == 0:\n    print(len(list2))\n    list2.sort()\n    k = 0\n    while k < len(list2):\n        print(list2[k])\n        k = k + 1\nelse:\n    print(len(list2))\n    list2.sort()\n    k = 0\n    while k < len(list2):\n        print(list2[k])\n        k = k + 1\n\ndef search1(node, lista):\n    y = node\n    flag = 0\n    i = 0\n    while i < len(lista):\n        if lista[i] in y:\n            flag = flag + 1\n            y = y[lista[i]]\n        else:\n            return flag\n        i = i + 1\n    return -1", "class Trie(object):\n\n    def __init__(self):\n        self.dictionary = {}\n\n    def maketrie(self, arr):\n        dictionary = self.dictionary\n        for i in range(len(arr)):\n            temp = dictionary\n            for j in arr[i]:\n                temp = temp.setdefault(j, {})\n            temp['last'] = 'last'\n        return dictionary\n\n    def find(self, trie, str):\n        temp = self.dictionary\n        temp = trie\n        index = 0\n        for i in range(len(str)):\n            if str[i] not in temp:\n                return index\n            else:\n                index = index + 1\n                temp = temp[str[i]]\n        return -1\ng = Trie()\np = int(input())\nk = 0\narr1 = []\narr2 = []\narr3 = []\ni = 0\nwhile i < p:\n    s = input().rstrip()\n    if s[0] == '+':\n        arr1.append(s[2:])\n    else:\n        arr2.append(s[2:])\n    i += 1\nt = g.maketrie(arr1)\nfor i in arr2:\n    f = g.find(t, i)\n    if f == -1:\n        k = 1\n        print(-1)\n        break\n    filter = i[0:f + 1]\n    if filter not in arr3:\n        arr3.append(filter)\narr3.sort()\nif k == 0:\n    print(len(arr3))\n    j = 0\n    while j < len(arr3):\n        print(arr3[j])\n        j += 1", "_end = '_end_'\n\nclass WordDictionary(object):\n\n    def __init__(self):\n        self.root = dict()\n\n    def addWord(self, word):\n        root = self.root\n        for letter in word:\n            root = root.setdefault(letter, {})\n        root[_end] = _end\n\n    def search(self, word):\n        current_dict = self.root\n        str = ''\n        for letter in word:\n            str = str + letter\n            if letter in current_dict:\n                if str == word:\n                    return True\n                else:\n                    current_dict = current_dict[letter]\n            else:\n                return False\n        else:\n            if _end not in current_dict:\n                return False\ntrie = WordDictionary()\nn = int(input())\npref = []\nblk = []\nfor i in range(n):\n    x = input()\n    x = x.rstrip()\n    if x[0] == '+':\n        trie.addWord(x[2:])\n    elif x[0] == '-':\n        blk.append(x[2:])\nfor i in blk:\n    str = ''\n    for j in i:\n        str = str + j\n        if trie.search(str) and str == i:\n            print(-1)\n            exit()\n        elif trie.search(str) == False:\n            if str not in pref:\n                pref.append(str)\n            break\nif len(pref) == 0:\n    print(-1)\nelse:\n    print(len(pref))\n    pref.sort()\n    for i in pref:\n        print(i)", "from operator import itemgetter\n\ndef search(a, lower, x, high):\n    mid = (high + lower) // 2\n    if lower <= high:\n        if a[mid][0] == x:\n            return mid\n        elif a[mid][0] > x:\n            return search(a, lower, x, mid - 1)\n        else:\n            return search(a, mid + 1, x, high)\n    else:\n        return False\n\ndef common(a, b):\n    count = 0\n    for i in range(len(a)):\n        if i < len(b) and a[i] == b[i]:\n            count += 1\n        else:\n            break\n    return count\na = int(input())\nv = []\nc = []\nfor i in range(a):\n    s = input().split()\n    if s[0] is '+':\n        v.append([s[1], '+'])\n    else:\n        v.append([s[1], '-'])\n        c.append([s[1], '-'])\nv.sort(key=itemgetter(0))\nads = []\nrds = 0\nfor i in range(len(c)):\n    xp = search(v, 0, c[i][0], len(v) - 1)\n    r1 = r2 = -1\n    for j in range(xp + 1, len(v)):\n        if v[j][1] is '+':\n            r1 = j\n            break\n    for j in range(xp - 1, -1, -1):\n        if v[j][1] is '+':\n            r2 = j\n            break\n    xpdo1 = 0\n    xpdo2 = 0\n    if r1 == -1 and r2 != -1:\n        xpdo1 = common(v[r2][0], v[xp][0])\n    elif r2 == -1 and r1 != -1:\n        xpdo2 = common(v[r1][0], v[xp][0])\n    elif r1 != -1 and r2 != -1:\n        xpdo1 = common(v[r2][0], v[xp][0])\n        xpdo2 = common(v[r1][0], v[xp][0])\n    max1 = max(xpdo1, xpdo2)\n    if max1 is len(v[xp][0]):\n        rds = 1\n        break\n    else:\n        ads.append(v[xp][0][:max1 + 1])\nads = list(set(ads))\nads.sort()\nif rds is 1:\n    print(-1)\nelse:\n    print(len(ads))\n    for m in ads:\n        print(m)", "import sys\nn = int(input())\nlp = set()\nlm = []\nfor i in range(n):\n    p = sys.stdin.readline().strip()\n    if p[0] == '-':\n        lm.append(p[2:])\n    else:\n        for j in range(3, len(p) + 1):\n            lp.add(p[2:j])\nif len(lm) == 0:\n    print(-1)\n    sys.exit(0)\nfilters = set()\nfor x in lm:\n    flag = 0\n    for j in range(1, len(x) + 1):\n        if x[:j] not in lp:\n            filters.add(x[:j])\n            flag = 1\n            break\n    if flag == 0:\n        print(-1)\n        sys.exit(0)\nprint(len(filters))\nfor x in sorted(list(filters)):\n    print(x)", "store = []\n\ndef inspect(j, sp):\n    p = 1\n    while '_' + j[0:p] in sp and p < len(j):\n        p += 1\n    store.append(j[0:p])\nflag = 0\nsn = []\nsp = '_'\nk = int(input())\nfor i in range(k):\n    s1 = input()\n    s1 = s1.split()\n    if s1[0] is '+':\n        sp += s1[1]\n        sp += '_'\n    else:\n        sn.append(s1[1])\nfor j in sn:\n    if '_' + j in sp:\n        print(-1)\n        flag = 1\n        break\n    else:\n        inspect(j, sp)\nif flag is not 1:\n    store = sorted(set(store))\n    print(len(store))\n    for m in store:\n        print(m)", "n = int(input())\na = []\nfor _ in range(n):\n    (c1, s) = input().strip().split(' ')\n    a.append((c1, s))\na.sort(key=lambda x: x[1])\nl = len(a)\nans = []\nflag = 0\nfor i in range(l):\n    if a[i][0] == '-':\n        j = i - 1\n        while j >= 0 and a[j][0] == '-':\n            j -= 1\n        b = ''\n        if j >= 0:\n            b = a[j][1]\n        k = i + 1\n        while k < l and a[k][0] == '-':\n            k += 1\n        c = ''\n        if k < l:\n            c = a[k][1]\n        aa = a[i][1]\n        la = len(aa)\n        lb = len(b)\n        lc = len(c)\n        ind = -1\n        mab = min(la, lb)\n        t = -1\n        for e in range(mab):\n            t = mab\n            if aa[e] != b[e]:\n                t = e\n                break\n        if t == -1:\n            t = 0\n        elif t == mab:\n            if la == mab:\n                flag = 4\n                break\n        mac = min(la, lc)\n        tt = -1\n        for e in range(mac):\n            tt = mac\n            if aa[e] != c[e]:\n                tt = e\n                break\n        if tt == -1:\n            tt = 0\n        elif tt == mac:\n            if la == mac:\n                flag = 4\n                break\n        t = max(t, tt)\n        h = ''\n        for v in range(t + 1):\n            h += aa[v]\n        ans.append(h)\nif flag == 4:\n    print('-1')\nelse:\n    ans.sort()\n    g = []\n    if len(ans) != 0:\n        g.append(ans[0])\n    for i in range(len(ans) - 1):\n        if ans[i] != ans[i + 1]:\n            g.append(ans[i + 1])\n    print(len(g))\n    for x in g:\n        print(x)", "def check_for_prefix(word, trie):\n    for letter in word:\n        if not trie.get(letter):\n            return False\n        else:\n            trie = trie[letter]\n    return True\nallowed_trie = {}\nblocked_trie = {}\n_end = '_end_'\nimport string\n\ndef parse_and_print(current_dict, current_prefix, allowed_trie, print_stack=[]):\n    possible_letters = string.ascii_lowercase\n    current_letters = list(current_dict.keys())\n    for letter in current_letters:\n        if letter != _end:\n            current_prefix = current_prefix + letter\n            if not check_for_prefix(current_prefix, allowed_trie):\n                print_stack.append(current_prefix)\n                current_dict.pop(letter)\n            elif current_dict[letter].get(_end):\n                return -1\n            else:\n                x = parse_and_print(current_dict[letter], current_prefix, allowed_trie, print_stack)\n                if x == -1:\n                    return -1\n            current_prefix = current_prefix[:-1]\nt = int(input().strip())\nwhile t:\n    t -= 1\n    inputs = input().strip()\n    string_length = len(inputs)\n    current_allowed_dict = allowed_trie\n    current_blocked_dict = blocked_trie\n    if inputs[0] == '+':\n        for i in range(2, string_length):\n            current_allowed_dict = current_allowed_dict.setdefault(inputs[i], {})\n        current_allowed_dict[_end] = _end\n    else:\n        for i in range(2, string_length):\n            current_blocked_dict = current_blocked_dict.setdefault(inputs[i], {})\n        current_blocked_dict[_end] = _end\nprint_stack = []\nres = parse_and_print(blocked_trie, '', allowed_trie, print_stack)\nif res == -1:\n    print(-1)\nelse:\n    print(len(print_stack))\n    print_stack.sort()\n    for pref in print_stack:\n        print(pref)", "t = int(input())\nwebsites = []\nwebsites.append(['+', '+'])\nfilters = []\nfilters.append('+')\nlngthfilters = 0\nsatisfyall = 1\nfor i in range(t):\n    x = list(input().split())\n    x[1] += '!'\n    x.reverse()\n    websites.append(x)\nwebsites.append(['}', '+'])\nwebsites.sort()\nfor i in range(1, t + 1):\n    if websites[i][1] == '-':\n        upperlimit = i + 1\n        uppertest = 0\n        lowerlimit = i - 1\n        lowertest = 0\n        temp = ''\n        j = 0\n        while websites[upperlimit][1] == '-':\n            upperlimit += 1\n        while websites[lowerlimit][1] == '-':\n            lowerlimit -= 1\n        while uppertest == 0 or lowertest == 0:\n            if uppertest == 0:\n                if websites[upperlimit][0][j] != websites[i][0][j]:\n                    uppertest = 1\n            if lowertest == 0:\n                if websites[lowerlimit][0][j] != websites[i][0][j]:\n                    lowertest = 1\n            if j < len(websites[i][0]) - 1:\n                temp += websites[i][0][j]\n            j += 1\n        if j >= len(websites[i][0]):\n            satisfyall = 0\n            break\n        elif filters[lngthfilters] != temp:\n            filters.append(temp)\n            lngthfilters += 1\nif satisfyall == 0 or lngthfilters == 0:\n    print(-1)\nelse:\n    print(lngthfilters)\n    for i in filters[1:]:\n        print(i)", "def binarysearch(trie, val, begin, end):\n    if begin <= end:\n        mid = (begin + end) // 2\n        if trie[val[:mid]] == '+':\n            try:\n                if trie[val[:mid + 1]] == '-':\n                    return mid + 1\n                else:\n                    return binarysearch(trie, val, mid + 1, end)\n            except:\n                return -1\n        else:\n            try:\n                if trie[val[:mid - 1]] == '+':\n                    return mid\n                else:\n                    return binarysearch(trie, val, begin, mid - 1)\n            except:\n                return 1\n    else:\n        return -1\n\ndef func():\n    n = int(input())\n    D = {}\n    l = []\n    for i in range(n):\n        inp = input().split()\n        D[inp[1]] = inp[0]\n        if inp[0] == '-':\n            l.append(inp[1])\n    trie = {}\n    for val in D.keys():\n        for i in range(1, len(val) + 1):\n            try:\n                var = val[:i]\n                if trie[var] == '-' and D[val] == '+':\n                    trie[var] = '+'\n            except:\n                trie[var] = D[val]\n    ans = []\n    for val in l:\n        length = len(val)\n        if trie[val[0]] == '-':\n            flagvar = 1\n        else:\n            flagvar = binarysearch(trie, val, 1, length)\n        if flagvar != -1:\n            ans.append(val[:flagvar])\n        else:\n            print('-1')\n            return\n    ans.sort()\n    length = len(ans)\n    finalans = []\n    for i in range(length - 1):\n        if ans[i] == ans[i + 1]:\n            continue\n        else:\n            finalans.append(ans[i])\n    finalans.append(ans[length - 1])\n    print(len(finalans))\n    for i in finalans:\n        print(i)\nfunc()", "class Trie:\n    _end = '_end_'\n\n    def __init__(self):\n        self.root = dict()\n        self.blocked = {id(self.root)}\n        self.unblocked = {id(self.root)}\n        self.answer = None\n        self.error = False\n\n    def insert(self, word, isblocked):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                current_dict[letter] = dict()\n            current_dict = current_dict[letter]\n            (self.blocked if isblocked else self.unblocked).add(id(current_dict))\n        current_dict[self._end] = isblocked\n\n    def __solve_rec(self, d, s):\n        is_blocked = id(d) in self.blocked\n        is_unblocked = id(d) in self.unblocked\n        if is_blocked:\n            if is_unblocked:\n                for k in d:\n                    self.__solve_rec(d[k], s + k)\n            else:\n                self.answer.append(s)\n        elif not is_unblocked and d:\n            self.error = True\n\n    def solve(self):\n        self.answer = []\n        self.error = False\n        self.__solve_rec(self.root, '')\n        return sorted(self.answer) if not self.error else None\n\n    def __str__(self):\n        return str(self.root)\ntrie = Trie()\nfor t in range(int(input())):\n    (blocked, site) = input().strip().split()\n    trie.insert(site, blocked == '-')\nans = trie.solve()\nif ans:\n    print(len(ans), *ans, sep='\\n')\nelse:\n    print(-1)", "_end = '_end_'\n\ndef trie(words):\n    root = dict()\n    for i in words:\n        current = root\n        for j in i:\n            current = current.setdefault(j, {})\n        current[_end] = _end\n    return root\n\ndef in_trie(root, word):\n    current = root\n    t = 0\n    for j in word:\n        if j in current:\n            t += 1\n            current = current[j]\n        else:\n            return t\n    return -1\nn = int(input())\nroot = dict()\na = []\nb = []\nfor i in range(n):\n    (c, s) = input().rstrip().split(' ')\n    if c == '-':\n        b.append(s)\n    else:\n        a.append(s)\nroot = trie(a)\nc = []\nflag = 0\nfor i in b:\n    res = in_trie(root, i)\n    if res == -1:\n        flag = 1\n        break\n    result = i[:res + 1]\n    if result not in c:\n        c.append(result)\nif flag:\n    print(-1)\nelse:\n    print(len(c))\n    c.sort()\n    for i in c:\n        print(i)", "_end = '_end_'\n\ndef trie(words):\n    root = dict()\n    for i in words:\n        current = root\n        for j in i:\n            current = current.setdefault(j, {})\n        current[_end] = _end\n    return root\n\ndef in_trie(root, word):\n    current = root\n    t = 0\n    for j in word:\n        if j in current:\n            t += 1\n            current = current[j]\n        else:\n            return t\n    return -1\nn = int(input())\nroot = dict()\na = []\nb = []\nfor i in range(n):\n    (c, s) = input().rstrip().split(' ')\n    if c == '-':\n        b.append(s)\n    else:\n        a.append(s)\nroot = trie(a)\nc = []\nflag = 0\nfor i in b:\n    res = in_trie(root, i)\n    if res == -1:\n        flag = 1\n        break\n    result = i[:res + 1]\n    if result not in c:\n        c.append(result)\nif flag:\n    print(-1)\nelse:\n    print(len(c))\n    c.sort()\n    for i in c:\n        print(i)", "class Node(object):\n\n    def __init__(self, value='', count=0):\n        self.count = count\n        self.value = value\n        self.children = []\n\ndef insertCharacter(value, node):\n    n = Node(value)\n    node.children.append(n)\n    node.children.sort(key=lambda child: child.value)\n    return n\n\ndef query(value, node):\n    for child in node.children:\n        if child.value == value:\n            return child\n    return None\n\ndef insertWord(word, root):\n    currentNode = root\n    for character in word:\n        nextNode = query(character, currentNode)\n        if nextNode:\n            currentNode = nextNode\n        else:\n            currentNode = insertCharacter(character, currentNode)\n\ndef show(node, currentWord=''):\n    if len(node.children) == 0:\n        print(currentWord + node.value)\n    for child in node.children:\n        show(child, currentWord + node.value)\n\ndef reduceUrl(blackSite, whiteList):\n    reducedWord = ''\n    currentNode = whiteList\n    lcs = ''\n    for i in range(len(blackSite)):\n        nextNode = query(blackSite[i], currentNode)\n        reducedWord += blackSite[i]\n        if nextNode:\n            currentNode = nextNode\n            lcs += nextNode.value\n        else:\n            break\n    if len(lcs) >= len(blackSite):\n        return None\n    return reducedWord\nN = input()\nwhiteList = Node()\nblackList = []\nreducedBlackList = []\nfor i in range(int(N)):\n    s = input().split()\n    if s[0] == '+':\n        insertWord(s[1], whiteList)\n    else:\n        blackList.append(s[1])\ninvalid = False\nfor blackSite in blackList:\n    reduceWord = reduceUrl(blackSite, whiteList)\n    if reduceWord == None:\n        invalid = True\n        break\n    elif reduceWord not in reducedBlackList:\n        reducedBlackList.append(reduceWord)\nif invalid == True:\n    print(-1)\nelse:\n    sortedBlackList = Node()\n    for word in reducedBlackList:\n        insertWord(word, sortedBlackList)\n    print(len(reducedBlackList))\n    if len(reducedBlackList) > 0:\n        for w in sorted(reducedBlackList):\n            print(w)", "def match(site1, site2):\n    prefix = ''\n    l1 = len(site1)\n    l2 = len(site2)\n    i = 0\n    cnt = 0\n    while i < l1:\n        if i >= l2:\n            cnt += 1\n            prefix += site1[i]\n            break\n        if site1[i] == site2[i]:\n            cnt += 1\n            prefix += site1[i]\n        else:\n            cnt += 1\n            prefix += site1[i]\n            break\n        i += 1\n    if i == l1:\n        return ['', 0]\n    else:\n        return [prefix, cnt]\n\ndef get_prefix(site, unbsites, num_unb, start_ch_map):\n    mod = ord('a')\n    if start_ch_map[ord(site[0]) % mod] == []:\n        return [site[0], 1]\n    st = start_ch_map[ord(site[0]) % mod][0]\n    en = start_ch_map[ord(site[0]) % mod][1]\n    ans = match(site, unbsites[st])\n    prefix = ans[0]\n    leng = ans[1]\n    if not leng:\n        return ['', 0]\n    i = st + 1\n    while i <= en:\n        ans = match(site, unbsites[i])\n        newprefix = ans[0]\n        newleng = ans[1]\n        if newleng == 0:\n            return ['', 0]\n        if newleng < leng:\n            return [prefix, 1]\n        elif newleng > leng:\n            prefix = newprefix\n            leng = newleng\n        i += 1\n    return [prefix, 1]\n\ndef find_answer(unbsites, bsites, num_b, num_unb, start_ch_map):\n    answer = []\n    prefix = get_prefix(bsites[0], unbsites, num_unb, start_ch_map)\n    if prefix[1]:\n        answer.append(prefix[0])\n    else:\n        return []\n    prev_pref = prefix[0]\n    i = 1\n    while i < num_b:\n        if not bsites[i].startswith(prev_pref):\n            prefix = get_prefix(bsites[i], unbsites, num_unb, start_ch_map)\n            if prefix[1]:\n                answer.append(prefix[0])\n                prev_pref = prefix[0]\n            else:\n                return []\n        i += 1\n    return answer\nn = int(input())\nbsites = []\nunbsites = []\nnum_b = 0\nnum_unb = 0\nwhile n:\n    n -= 1\n    site = input().strip().split()\n    if site[0] == '-':\n        bsites.append(site[1])\n        num_b += 1\n    else:\n        unbsites.append(site[1])\n        num_unb += 1\nunbsites.sort()\nbsites.sort()\nstart_ch_map = []\nval = ord('a')\nmod = val\nfor i in range(0, 26):\n    start_ch_map.append([])\ni = 0\nwhile i < num_unb:\n    ind = ord(unbsites[i][0]) % mod\n    start_ch_map[ind].append(i)\n    i += 1\n    while i < num_unb:\n        if unbsites[i][0] == unbsites[i - 1][0]:\n            i += 1\n        else:\n            break\n    start_ch_map[ind].append(i - 1)\nanswer = find_answer(unbsites, bsites, num_b, num_unb, start_ch_map)\nif answer == []:\n    print(-1)\nelse:\n    print(len(answer))\n    answer.sort()\n    for s in answer:\n        print(s)", "def find_diff_index(a, b, c):\n    i = 0\n    (found_a, found_c) = (-1, -1)\n    while i < len(a) and i < len(b):\n        if a[i] != b[i]:\n            found_a = i\n            break\n        i += 1\n    if found_a == -1 and i < len(b):\n        found_a = i\n    if found_a == -1:\n        return -1\n    i = 0\n    while i < len(b) and i < len(c):\n        if b[i] != c[i]:\n            found_c = i\n            break\n        i += 1\n    if found_c == -1 and i < len(b):\n        found_c = i\n    if found_c == -1:\n        return -1\n    return max(found_a, found_c)\nN = int(input())\nl = []\nfor i in range(N):\n    (act, site) = input().strip().split(' ')\n    act = True if act == '-' else False\n    l.append((site, act))\nl.sort()\nl.insert(0, ('', False))\nl.append(('', False))\np_anchor = []\ns_anchor = []\nanc = 0\nfor i in range(0, N + 2):\n    if not l[i][1]:\n        anc = i\n    p_anchor.append(anc)\nfor i in range(N + 1, -1, -1):\n    if not l[i][1]:\n        anc = i\n    s_anchor.append(anc)\ns_anchor = s_anchor[::-1]\nbad = False\nans = []\nfor i in range(0, N + 2):\n    if bad:\n        break\n    if l[i][1]:\n        diff_ind = find_diff_index(l[p_anchor[i]][0], l[i][0], l[s_anchor[i]][0])\n        if diff_ind == -1:\n            bad = True\n        else:\n            ans.append(l[i][0][0:diff_ind + 1])\nif bad:\n    print(-1)\nelse:\n    ans = list(set(ans))\n    ans.sort()\n    print(len(ans))\n    for i in range(len(ans)):\n        print(ans[i])", "from collections import defaultdict\n\nclass T:\n\n    def __init__(self):\n        self.root = defaultdict()\n\n    def insert(self, word):\n        c = self.root\n        for i in word:\n            c = c.setdefault(i, {})\n        c.setdefault('end')\n\n    def find(self, prefix):\n        c = self.root\n        for i in prefix:\n            if i not in c:\n                return False\n            c = c[i]\n        return True\na = T()\nz = []\nans = []\nflag = 1\nfor i in range(int(input())):\n    x = input().split()\n    if x[0] == '+':\n        a.insert(x[1])\n    else:\n        z.append(x[1])\nfor e in sorted(z):\n    i = 1\n    q = len(e)\n    while i <= q and a.find(e[:i]):\n        i += 1\n    if i >= q + 1:\n        flag = 0\n        break\n    else:\n        ans.append(e[:i])\nans = sorted(set(ans))\nif flag:\n    print(len(ans))\n    for i in ans:\n        print(i)\nelse:\n    print('-1')", "import sys\nn = int(input())\ngood = []\nbad = []\nfor i in range(n):\n    line = sys.stdin.readline().strip()\n    site = line[2:]\n    if line[0] == '+':\n        good.append(site)\n    else:\n        bad.append(site)\nif len(good) == 0:\n    print(0)\n    sys.exit(0)\nh = {}\nfor site in good:\n    prefix = ''\n    h[prefix] = 1\n    for c in site:\n        prefix += c\n        h[prefix] = 1\nprefixes = {}\nfor site in bad:\n    uniquePrefixFound = False\n    prefix = ''\n    for c in site:\n        prefix += c\n        if not prefix in h:\n            uniquePrefixFound = True\n            prefixes[prefix] = 1\n            break\n    if not uniquePrefixFound:\n        print(-1)\n        sys.exit(0)\nprint(len(prefixes))\nfor prefix in sorted(prefixes):\n    print(prefix)", "def main():\n    N = int(input())\n    A = []\n    for i in range(N):\n        (u, v) = list(input().strip().split(' '))\n        A += [[v, u]]\n\n    def findout(s):\n\n        def find(s, a):\n            if s == '':\n                return []\n            elif s.lstrip('+') == '' or s.lstrip('-') == '':\n                L = len(s)\n                T = []\n                for i in range(len(s)):\n                    T += [[a]]\n                return T\n            else:\n                N = len(s)\n                s = s.lstrip(s[0])\n                T = len(s)\n                ans = []\n                for i in range(N - T):\n                    ans += [[a, a + N - T + 1]]\n                a = a + N - T\n                return ans + find(s, a)\n        AA = find(s, -1)\n        for j in range(len(AA)):\n            if -1 in AA[j]:\n                AA[j] = list(set(AA[j]) - set({-1}))\n        return AA\n\n    def compare(a, b):\n        L = min(len(a), len(b))\n        s = ''\n        for i in range(L):\n            temp = i\n            if a[i] == b[i]:\n                s += a[i]\n            else:\n                break\n        else:\n            if L == len(b):\n                return -1\n            else:\n                return b[:L + 1]\n        return b[:temp + 1]\n    A = sorted(A)\n    s = ''\n    for i in range(len(A)):\n        s += A[i][1]\n    if s.lstrip('+') == '':\n        print(0)\n        return 0\n    elif s.lstrip('-') == '':\n        TTTT = []\n        for i in range(len(A)):\n            if A[i][0][0] not in TTTT:\n                TTTT += [A[i][0][0]]\n        print(len(TTTT))\n        for x in TTTT:\n            print(x)\n        return 0\n    check = [[] for i in range(len(A))]\n    start = -1\n    while s != '':\n        temp = s.lstrip(s[0])\n        L = len(s) - len(temp)\n        for i in range(start + 1, start + L + 1):\n            check[i] = [start, start + L + 1]\n        start = start + L\n        s = temp\n    for i in range(len(check)):\n        check[i] = list(set(check[i]) - set({-1, len(check)}))\n    for i in range(len(A)):\n        s += A[i][1]\n    total = []\n    totalset = set()\n    length = 0\n    terr = 0\n    for i in range(len(A)):\n        if s[i] == '-':\n            if len(check[i]) == 1:\n                aa = A[check[i][0]][0]\n                bb = A[i][0]\n                cc = compare(aa, bb)\n                if cc == -1:\n                    terr = 1\n                    break\n                else:\n                    totalset.add(cc)\n                    if len(totalset) > length:\n                        total += [cc]\n                        length += 1\n            elif len(check[i]) == 2:\n                aa1 = A[check[i][0]][0]\n                aa2 = A[check[i][1]][0]\n                bb = A[i][0]\n                c1 = compare(aa1, bb)\n                c2 = compare(aa2, bb)\n                if c1 == -1 or c2 == -1:\n                    terr = 1\n                    break\n                elif len(c1) > len(c2):\n                    totalset.add(c1)\n                    if len(totalset) > length:\n                        total += [c1]\n                        length += 1\n                else:\n                    totalset.add(c2)\n                    if len(totalset) > length:\n                        total += [c2]\n                        length += 1\n    if terr == 1:\n        print(-1)\n    else:\n        print(len(total))\n        for j in range(len(total)):\n            print(total[j])\n    return 0\nmain()", "o = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n\nclass al:\n\n    def __init__(self):\n        self.d = {'c': 0, 'r': 0, 'd': 0, 'f': 0, 'e': 0, 'z': 0, 'x': 0, 'h': 0, 'k': 0, 'q': 0, 'j': 0, 't': 0, 'p': 0, 'g': 0, 'o': 0, 'b': 0, 'l': 0, 'w': 0, 'i': 0, 'v': 0, 'u': 0, 'y': 0, 'a': 0, 's': 0, 'n': 0, 'm': 0}\n\n    def c(self, gi):\n        return self.d[gi]\n\n    def ch(self, j, t):\n        self.d[j] = t\nt = int(input(''))\np = []\nm = []\na = al()\nfor i in range(t):\n    g = input('').split()\n    if g[0] == '+':\n        p.append(g[1])\n    elif g[0] == '-':\n        m.append(g[1])\nfor i in p:\n    k = a\n    for j in i:\n        if k.c(j) == 0:\n            k.ch(j, al())\n        k = k.c(j)\nhh = []\nfor i in m:\n    k = a\n    m = 0\n    for j in range(len(i)):\n        if type(k.c(i[j])) == type(9):\n            if k.c(i[j]) == 0:\n                hh.append(i[:j + 1])\n                k.ch(i[j], 1)\n            m = 1\n            break\n        k = k.c(i[j])\n    if m == 0:\n        hh = ['-1']\n        break\nhh.sort()\nif '-1' in hh:\n    pass\nelse:\n    print(len(hh))\nfor i in hh:\n    print(i)", "import sys\nt = int(input())\nunblocked = set()\nblocked = set()\nfor i in range(t):\n    x = input().split()\n    if x[0] == '+':\n        unblocked.add(x[1])\n    else:\n        blocked.add(x[1])\nans = set()\ngood = set()\nfor site in unblocked:\n    n = len(site)\n    s = ''\n    for i in range(n):\n        s += site[i]\n        good.add(s)\nans = set()\nfor site in blocked:\n    n = len(site)\n    s = ''\n    done = False\n    for i in range(n):\n        s += site[i]\n        if s not in good:\n            ans.add(s)\n            done = True\n            break\n    if not done:\n        print(-1)\n        sys.exit()\nans = list(ans)\nans.sort()\nif len(ans) == 0 and len(blocked) != 0:\n    print(-1)\n    sys.exit()\nprint(len(ans))\nfor i in ans:\n    print(i)", "class Word:\n\n    def __init__(self, chars, blocked):\n        self.chars = chars\n        self.blocked = blocked\n\nclass Trie:\n\n    def __init__(self):\n        self.root = {'blocked': False}\n\n    def insert(self, word):\n        curr = self.root\n        for char in word.chars:\n            curr = curr.setdefault(char, {'blocked': True})\n            if not word.blocked:\n                curr['blocked'] = False\n        curr.setdefault('end', word.blocked)\n\n    def prefixes(self):\n        stack = [self.root]\n        prefix = ['']\n        visited = set()\n        res = []\n        while stack:\n            curr = stack.pop()\n            pre = prefix.pop()\n            if pre not in visited:\n                visited.add(pre)\n                if curr['blocked']:\n                    res.append(pre)\n                else:\n                    if 'end' in curr and curr['end']:\n                        return -1\n                    next = [a for a in curr if a != 'end' and a != 'blocked']\n                    for a in next:\n                        prefix.append(pre + a)\n                        stack.append(curr[a])\n        return res\nwords = Trie()\nfor _ in range(int(input())):\n    (b, s) = input().split()\n    w = Word(s, True if b == '-' else False)\n    words.insert(w)\nres = words.prefixes()\nif res == -1:\n    print(-1)\nelse:\n    print(len(res))\n    print(*sorted(res), sep='\\n')", "n = int(input())\nb = []\nub = []\nfor i in range(n):\n    (j, s) = input().split()\n    if j == '+':\n        ub.append(s)\n    else:\n        b.append(s)\nl = set()\nl2 = set()\nl3 = set()\nfor s in ub:\n    for j in range(len(s)):\n        h = s[:j + 1]\n        if not h in l3:\n            l3.add(h)\nk = 1\nflag = 1\nub.sort()\nb.sort()\nfor s in b:\n    if s in l3:\n        flag = 0\n        break\nif flag == 1:\n    for s in b:\n        for j in range(len(s)):\n            k = 1\n            x = 0\n            s1 = s[:j + 1]\n            if s1 in l:\n                break\n            elif not s1 in l2:\n                x = 1\n                if s1 in l3:\n                    k = 0\n            if k == 0:\n                l2.add(s1)\n            if k == 1 and x == 1:\n                l.add(s1)\n                break\nif flag == 0:\n    print(-1)\nelse:\n    l1 = list(l)\n    print(len(l1))\n    l1.sort()\n    for s in l1:\n        print(s)", "class Trie:\n\n    def __init__(self):\n        self._root = {}\n\n    def add(self, s):\n        cur = self._root\n        for c in s:\n            if c not in cur:\n                cur[c] = {}\n            cur = cur[c]\n\n    def psize(self, s):\n        res = 0\n        cur = self._root\n        for c in s:\n            if c in cur:\n                cur = cur[c]\n                res += 1\n            else:\n                break\n        return res\nN = int(input())\nfnames = []\ntrie = Trie()\nfor _ in range(N):\n    (tp, name) = input().split()\n    if tp == '-':\n        fnames.append(name)\n    else:\n        trie.add(name)\npnames = set()\npossible = True\nfor name in fnames:\n    psize = trie.psize(name)\n    if psize >= len(name):\n        possible = False\n        break\n    pnames.add(name[:psize + 1])\nif possible:\n    print(len(pnames))\n    for name in sorted(pnames):\n        print(name)\nelse:\n    print(-1)", "def match(s1, n, s2, m):\n    for i in range(min(n, m)):\n        if s1[i] != s2[i]:\n            return i\n    return min(n, m)\na = []\na1 = []\nb = []\nb1 = []\ns = set([])\nn = int(input())\nfor _ in range(n):\n    (x, y) = input().strip().split()\n    if x == '+':\n        a.append(y)\n    else:\n        b.append(y)\na.sort()\nb.sort()\nfor i in a:\n    a1.append(len(i))\nfor i in b:\n    b1.append(len(i))\nal = len(a)\nbl = len(b)\npos = 0\nif al == 0:\n    print(-1)\nelse:\n    for i in range(bl):\n        res = 0\n        f = True\n        pos = max(pos, 0)\n        while pos < al:\n            cur = match(b[i], b1[i], a[pos], a1[pos])\n            if cur == b1[i]:\n                f = False\n                break\n            res = max(res, cur)\n            if cur == a1[pos] or b[i][cur] > a[pos][cur]:\n                pos += 1\n            else:\n                break\n        pos -= 1\n        if f == False:\n            print(-1)\n            break\n        s.add(b[i][:res + 1])\n    else:\n        s = list(s)\n        s.sort()\n        if len(s) == 0:\n            print(-1)\n        else:\n            print(len(s))\n            for i in s:\n                print(i)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nclass TrieNode:\n\n    def __init__(self):\n        self.ch = [None] * 26\n        self.total = 0\n        self.block = 0\n        self.end = 0\n\nclass Trie:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, b, s):\n        cur = self.root\n        for c in s:\n            cur.total += 1\n            if b:\n                cur.block += 1\n            i = ord(c) - 97\n            if cur.ch[i] is None:\n                cur.ch[i] = TrieNode()\n            cur = cur.ch[i]\n        cur.total += 1\n        if b:\n            cur.block += 1\n        cur.end = 1 if b else -1\n\n    def recur(self, cur, s, res):\n        if cur.total == cur.block:\n            res.append(''.join(s))\n            return\n        if cur.block >= 1 and cur.end == 1:\n            res.append('!IMPOSSIBLE!')\n            return\n        for i in range(26):\n            if cur.ch[i] is not None:\n                s.append(chr(97 + i))\n                self.recur(cur.ch[i], s, res)\n                s.pop()\n\n    def collect(self):\n        res = []\n        s = []\n        self.recur(self.root, s, res)\n        return res\nt = Trie()\nn = int(input())\nfor i in range(n):\n    (b, s) = input().split()\n    t.insert(b == '-', s)\nres = t.collect()\nprint(-1 if '!IMPOSSIBLE!' in res else str(len(res)) + '\\n' + '\\n'.join(res))"]