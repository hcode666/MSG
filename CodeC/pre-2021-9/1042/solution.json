["from sys import stdin\n\ndef gcd(a, b):\n    if b > a:\n        (a, b) = (b, a)\n    return a if b == 0 else gcd(b, a % b)\n\ndef solve(dp, index, g, arr, n):\n    if index in dp and g in dp[index]:\n        return dp[index][g]\n    if index == n and g != 1:\n        dp[index][g] = 0\n        return dp[index][g]\n    dp[index][g] = solve(dp, index + 1, g, arr, n) + solve(dp, index + 1, gcd(g, arr[index]), arr, n)\n    return dp[index][g]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    cnt = 0\n    dp = {}\n    for i in range(n + 1):\n        dp[i] = {}\n    dp[n][1] = 1\n    print(solve(dp, 0, 0, arr, n))", "from sys import stdin\n\ndef gcd(a, b):\n    if b > a:\n        (a, b) = (b, a)\n    return a if b == 0 else gcd(b, a % b)\n\ndef solve(dp, index, g, arr, n):\n    if index in dp and g in dp[index]:\n        return dp[index][g]\n    if index == n and g != 1:\n        dp[index][g] = 0\n        return dp[index][g]\n    dp[index][g] = solve(dp, index + 1, g, arr, n) + solve(dp, index + 1, gcd(g, arr[index]), arr, n)\n    return dp[index][g]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    cnt = 0\n    dp = {}\n    for i in range(n + 1):\n        dp[i] = {}\n    dp[n][1] = 1\n    print(solve(dp, 0, 0, arr, n))", "from sys import stdin\n\ndef gcd(a, b):\n    if b > a:\n        (a, b) = (b, a)\n    return a if b == 0 else gcd(b, a % b)\n\ndef solve(dp, index, g, arr, n):\n    if index in dp and g in dp[index]:\n        return dp[index][g]\n    if index == n and g != 1:\n        dp[index][g] = 0\n        return dp[index][g]\n    dp[index][g] = solve(dp, index + 1, g, arr, n) + solve(dp, index + 1, gcd(g, arr[index]), arr, n)\n    return dp[index][g]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    cnt = 0\n    dp = {}\n    for i in range(n + 1):\n        dp[i] = {}\n    dp[n][1] = 1\n    print(solve(dp, 0, 0, arr, n))", "from sys import stdin\n\ndef gcd(a, b):\n    if b > a:\n        (a, b) = (b, a)\n    return a if b == 0 else gcd(b, a % b)\n\ndef solve(dp, index, g, arr, n):\n    if index in dp and g in dp[index]:\n        return dp[index][g]\n    if index == n and g != 1:\n        dp[index][g] = 0\n        return dp[index][g]\n    dp[index][g] = solve(dp, index + 1, g, arr, n) + solve(dp, index + 1, gcd(g, arr[index]), arr, n)\n    return dp[index][g]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    cnt = 0\n    dp = {}\n    for i in range(n + 1):\n        dp[i] = {}\n    dp[n][1] = 1\n    print(solve(dp, 0, 0, arr, n))", "from sys import stdin\n\ndef gcd(a, b):\n    if b > a:\n        (a, b) = (b, a)\n    return a if b == 0 else gcd(b, a % b)\n\ndef solve(dp, index, g, arr, n):\n    if index in dp and g in dp[index]:\n        return dp[index][g]\n    if index == n and g != 1:\n        dp[index][g] = 0\n        return dp[index][g]\n    dp[index][g] = solve(dp, index + 1, g, arr, n) + solve(dp, index + 1, gcd(g, arr[index]), arr, n)\n    return dp[index][g]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    cnt = 0\n    dp = {}\n    for i in range(n + 1):\n        dp[i] = {}\n    dp[n][1] = 1\n    print(solve(dp, 0, 0, arr, n))", "from sys import stdin\n\ndef gcd(a, b):\n    if b > a:\n        (a, b) = (b, a)\n    return a if b == 0 else gcd(b, a % b)\n\ndef solve(dp, index, g, arr, n):\n    if index in dp and g in dp[index]:\n        return dp[index][g]\n    if index == n and g != 1:\n        dp[index][g] = 0\n        return dp[index][g]\n    dp[index][g] = solve(dp, index + 1, g, arr, n) + solve(dp, index + 1, gcd(g, arr[index]), arr, n)\n    return dp[index][g]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    cnt = 0\n    dp = {}\n    for i in range(n + 1):\n        dp[i] = {}\n    dp[n][1] = 1\n    print(solve(dp, 0, 0, arr, n))", "from sys import stdin\n\ndef gcd(a, b):\n    if b > a:\n        (a, b) = (b, a)\n    return a if b == 0 else gcd(b, a % b)\n\ndef solve(dp, index, g, arr, n):\n    if index in dp and g in dp[index]:\n        return dp[index][g]\n    if index == n and g != 1:\n        dp[index][g] = 0\n        return dp[index][g]\n    dp[index][g] = solve(dp, index + 1, g, arr, n) + solve(dp, index + 1, gcd(g, arr[index]), arr, n)\n    return dp[index][g]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    cnt = 0\n    dp = {}\n    for i in range(n + 1):\n        dp[i] = {}\n    dp[n][1] = 1\n    print(solve(dp, 0, 0, arr, n))", "from sys import stdin\n\ndef gcd(a, b):\n    if b > a:\n        (a, b) = (b, a)\n    return a if b == 0 else gcd(b, a % b)\n\ndef solve(dp, index, g, arr, n):\n    if index in dp and g in dp[index]:\n        return dp[index][g]\n    if index == n and g != 1:\n        dp[index][g] = 0\n        return dp[index][g]\n    dp[index][g] = solve(dp, index + 1, g, arr, n) + solve(dp, index + 1, gcd(g, arr[index]), arr, n)\n    return dp[index][g]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    cnt = 0\n    dp = {}\n    for i in range(n + 1):\n        dp[i] = {}\n    dp[n][1] = 1\n    print(solve(dp, 0, 0, arr, n))", "from sys import stdin\n\ndef gcd(a, b):\n    if b > a:\n        (a, b) = (b, a)\n    return a if b == 0 else gcd(b, a % b)\n\ndef solve(dp, index, g, arr, n):\n    if index in dp and g in dp[index]:\n        return dp[index][g]\n    if index == n and g != 1:\n        dp[index][g] = 0\n        return dp[index][g]\n    dp[index][g] = solve(dp, index + 1, g, arr, n) + solve(dp, index + 1, gcd(g, arr[index]), arr, n)\n    return dp[index][g]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    cnt = 0\n    dp = {}\n    for i in range(n + 1):\n        dp[i] = {}\n    dp[n][1] = 1\n    print(solve(dp, 0, 0, arr, n))", "from sys import stdin\nread = stdin.readline\ndp = {}\nT = int(read())\nN = 0\narr = []\nans = 0\ngcd = lambda a, b: a if not b else gcd(b, a % b)\n\ndef fn(i, g):\n    if i == N:\n        if g == 1:\n            return 1\n        else:\n            return 0\n    elif g == 1:\n        return 1 << N - i\n    elif (i, g) in dp:\n        return dp[i, g]\n    else:\n        dp[i, g] = fn(i + 1, gcd(arr[i], g)) + fn(i + 1, g)\n        return dp[i, g]\nfor _ in range(T):\n    N = int(read())\n    arr = list(map(int, read().split()))\n    dp = {}\n    ans = 0\n    for i in range(0, N - 1):\n        ans = ans + fn(i + 1, arr[i])\n    print(ans)", "from sys import stdin\nread = stdin.readline\ndp = {}\nT = int(read())\nN = 0\narr = []\nans = 0\ngcd = lambda a, b: a if not b else gcd(b, a % b)\n\ndef fn(i, g):\n    if i == N:\n        if g == 1:\n            return 1\n        else:\n            return 0\n    elif g == 1:\n        return 1 << N - i\n    elif (i, g) in dp:\n        return dp[i, g]\n    else:\n        dp[i, g] = fn(i + 1, gcd(arr[i], g)) + fn(i + 1, g)\n        return dp[i, g]\nfor _ in range(T):\n    N = int(read())\n    arr = list(map(int, read().split()))\n    dp = {}\n    ans = 0\n    for i in range(0, N - 1):\n        ans = ans + fn(i + 1, arr[i])\n    print(ans)", "from collections import defaultdict\n\ndef makeLPF(f_limit):\n    lpf = [2, 1] * (f_limit // 2 + 1)\n    lpf[0:3] = [0, 0, 1]\n    k = 3\n    while k * k <= f_limit:\n        if lpf[k] == 1:\n            for m in range(k * k, f_limit + 1, 2 * k):\n                if lpf[m] == 1:\n                    lpf[m] = k\n        k += 2\n    return lpf\n\ndef pFac(val, lpf):\n    facs = set()\n    afac = lpf[val]\n    while afac > 1:\n        facs.add(afac)\n        val //= afac\n        afac = lpf[val]\n    if afac == 1:\n        facs.add(val)\n    return tuple(sorted(facs))\n\ndef coprime_paths(faclist):\n    spread = defaultdict(int)\n    for facs in faclist:\n        for (skey, sct) in list(spread.items()):\n            comb = tuple((f for f in facs if f in skey))\n            spread[comb] += sct\n        spread[facs] += 1\n    return spread[tuple()]\nlim = 10000\nlpf = makeLPF(lim)\nT = int(input())\nfor tx in range(T):\n    N = int(input())\n    vals = sorted((pFac(int(a), lpf) for a in input().split()))\n    print(coprime_paths(vals))", "from collections import defaultdict\n\ndef makeFTable(f_limit):\n    fTable = [[] for ix in range(f_limit + 1)]\n    for ix in range(2, f_limit + 1, 2):\n        fTable[ix] = [2]\n    k = 3\n    while k <= f_limit:\n        if not fTable[k]:\n            for m in range(k, f_limit + 1, k):\n                fTable[m].append(k)\n        k += 2\n    return fTable\n\ndef coprime_paths(faclist):\n    spread = defaultdict(int)\n    for facs in faclist:\n        for (skey, sct) in list(spread.items()):\n            comb = tuple((f for f in facs if f in skey))\n            spread[comb] += sct\n        spread[facs] += 1\n    return spread[tuple()]\nlim = 10000\nfTable = makeFTable(lim)\nT = int(input())\nfor tx in range(T):\n    N = int(input())\n    vals = list((tuple(fTable[int(a)]) for a in input().split()))\n    print(coprime_paths(vals))", "from collections import defaultdict\n\ndef makeFTable(f_limit):\n    fTable = [[] for ix in range(f_limit + 1)]\n    fTable[1] = [1]\n    for ix in range(2, f_limit + 1, 2):\n        fTable[ix] = [2]\n    k = 3\n    while k <= f_limit:\n        if not fTable[k]:\n            for m in range(k, f_limit + 1, k):\n                fTable[m].append(k)\n        k += 2\n    return fTable\n\ndef coprime_paths(faclist):\n    spread = defaultdict(int)\n    for facs in faclist:\n        for (skey, sct) in list(spread.items()):\n            comb = tuple((f for f in facs if f in skey))\n            spread[comb] += sct\n        spread[facs] += 1\n    return spread[tuple()]\nlim = 10000\nfTable = makeFTable(lim)\nT = int(input())\nfor tx in range(T):\n    N = int(input())\n    vals = sorted((tuple(fTable[int(a)]) for a in input().split()))\n    print(coprime_paths(vals))", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef solve(idx, g):\n    if idx < 0:\n        return 1 if g == 1 else 0\n    if dp[idx][g] != -1:\n        return dp[idx][g]\n    dp[idx][g] = solve(idx - 1, g) + solve(idx - 1, gcd(g, arr[idx]))\n    return dp[idx][g]\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    dp = [[-1 for j in range(10001)] for i in range(n)]\n    ans = solve(n - 1, 0)\n    print(ans)", "from sys import stdin\nimport functools\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nMAX = 10001\n\ndef func(ind, g, dp, n, a):\n    if ind == n:\n        if g == 1:\n            return 1\n        else:\n            return 0\n    if dp[ind][g] != -1:\n        return dp[ind][g]\n    ans = func(ind + 1, g, dp, n, a) + func(ind + 1, gcd(a[ind], g), dp, n, a)\n    dp[ind][g] = ans\n    return dp[ind][g]\n\ndef countSubsequences(a, n):\n    dp = [[-1 for i in range(MAX)] for i in range(n)]\n    count = 0\n    for i in range(n):\n        count += func(i + 1, a[i], dp, n, a)\n    return count\ntest = int(stdin.readline())\nfor _ in range(test):\n    n = int(stdin.readline())\n    list1 = list(map(int, stdin.readline().split()))\n    print(countSubsequences(list1, n))", "from sys import stdin\nimport functools\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nMAX = 10001\n\ndef func(ind, g, dp, n, a):\n    if ind == n:\n        if g == 1:\n            return 1\n        else:\n            return 0\n    if dp[ind][g] != -1:\n        return dp[ind][g]\n    ans = func(ind + 1, g, dp, n, a) + func(ind + 1, gcd(a[ind], g), dp, n, a)\n    dp[ind][g] = ans\n    return dp[ind][g]\n\ndef countSubsequences(a, n):\n    dp = [[-1 for i in range(MAX)] for i in range(n)]\n    count = 0\n    for i in range(n):\n        count += func(i + 1, a[i], dp, n, a)\n    return count\ntc = int(stdin.readline())\nfor i in range(tc):\n    n = int(stdin.readline())\n    list1 = list(map(int, stdin.readline().split()))\n    print(countSubsequences(list1, n))", "from math import gcd\nt = int(input())\nfor _t in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    dp = [[0] * 10001 for i in range(n)]\n    (dp[0][arr[0]], sett) = (1, set([arr[0]]))\n    for i in range(1, n):\n        dp[i][arr[i]] += 1\n        tmp = []\n        for j in sett:\n            dp[i][j] += dp[i - 1][j]\n            dp[i][gcd(j, arr[i])] += dp[i - 1][j]\n            tmp.append(gcd(j, arr[i]))\n        sett.update(tmp)\n        sett.add(arr[i])\n    print(dp[n - 1][1])", "from math import gcd\nfrom functools import reduce\n\ndef func(W, i, g, dp):\n    if i >= len(W):\n        return 0\n    if dp[i][g] != -1:\n        return dp[i][g]\n    _g = gcd(g, W[i])\n    ans1 = 1 + func(W, i + 1, _g, dp) if _g == 1 else func(W, i + 1, _g, dp)\n    dp[i][g] = ans1 + func(W, i + 1, g, dp)\n    return dp[i][g]\nresult = ''\nfor _ in range(int(input())):\n    n = int(input())\n    W = [int(x) for x in input().split()]\n    dp = [[-1 for x in range(10000 + 3)] for y in range(70)]\n    t = func(W, 0, 0, dp)\n    result += str(t) + '\\n'\nprint(result[:-1])", "def cal(a, b):\n    if b == 0:\n        return a\n    return cal(b, a % b)\n\ndef func(pos, cur_gcd):\n    if pos == n:\n        if cur_gcd == 1:\n            return 1\n        else:\n            return 0\n    if (pos, cur_gcd) in dp:\n        return dp[pos, cur_gcd]\n    if cur_gcd == 1:\n        ans = 2 ** (n - pos)\n        dp[pos, cur_gcd] = ans\n        return ans\n    ans = func(pos + 1, cal(cur_gcd, a[pos])) + func(pos + 1, cur_gcd)\n    dp[pos, cur_gcd] = ans\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = dict()\n    ans = 0\n    for (i, j) in enumerate(a):\n        ans += func(i + 1, j)\n    print(ans)", "from math import gcd\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    num_elements = int(input())\n    num_list = list(map(int, input().split()))\n    mem = [defaultdict(int) for i in range(num_elements)]\n    mem[0][num_list[0]] = 1\n    for num_i in range(1, num_elements):\n        mem[num_i][num_list[num_i]] += 1\n        for prev_num_i in range(num_i):\n            for divisor in mem[prev_num_i]:\n                mem[num_i][gcd(num_list[num_i], divisor)] += mem[prev_num_i][divisor]\n    required_sub_seq_count = 0\n    for num_i in range(num_elements):\n        required_sub_seq_count += mem[num_i][1]\n    print(required_sub_seq_count)", "from math import gcd\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    num_elements = int(input())\n    num_list = list(map(int, input().split()))\n    mem = [defaultdict(int) for i in range(num_elements)]\n    mem[0][num_list[0]] = 1\n    for num_i in range(1, num_elements):\n        mem[num_i][num_list[num_i]] += 1\n        for prev_num_i in range(num_i):\n            for divisor in mem[prev_num_i]:\n                mem[num_i][gcd(num_list[num_i], divisor)] += mem[prev_num_i][divisor]\n    required_sub_seq_count = 0\n    for num_i in range(num_elements):\n        required_sub_seq_count += mem[num_i][1]\n    print(required_sub_seq_count)", "from math import gcd\n\ndef game(cPose, cGCD):\n    if cPose == n:\n        return 1 if cGCD == 1 else 0\n    if (cPose, cGCD) in dp:\n        return dp[cPose, cGCD]\n    dp[cPose, cGCD] = game(cPose + 1, cGCD) + game(cPose + 1, gcd(cGCD, l[cPose]))\n    return dp[cPose, cGCD]\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    dp = {}\n    ans = 0\n    for i in range(n):\n        ans += game(i + 1, l[i])\n    print(ans)", "from math import gcd\n\ndef game(cPose, cGCD):\n    if cPose == n:\n        return 1 if cGCD == 1 else 0\n    if cGCD == 1:\n        return 2 ** (n - cPose)\n    if (cPose, cGCD) in dp:\n        return dp[cPose, cGCD]\n    dp[cPose, cGCD] = game(cPose + 1, cGCD) + game(cPose + 1, gcd(cGCD, l[cPose]))\n    return dp[cPose, cGCD]\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    dp = {}\n    ans = 0\n    for i in range(n):\n        ans += game(i + 1, l[i])\n    print(ans)", "def GCD(a, b):\n    return a if b == 0 else GCD(b, a % b)\n\ndef game(cPose, cGCD):\n    if cPose == n:\n        return 1 if cGCD == 1 else 0\n    if (cPose, cGCD) in dp:\n        return dp[cPose, cGCD]\n    dp[cPose, cGCD] = game(cPose + 1, cGCD) + game(cPose + 1, GCD(cGCD, l[cPose]))\n    return dp[cPose, cGCD]\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    dp = {}\n    ans = 0\n    for i in range(n):\n        ans += game(i + 1, l[i])\n    print(ans)", "def GCD(a, b):\n    return a if b == 0 else GCD(b, a % b)\n\ndef game(cPose, cGCD):\n    if cPose == n:\n        return 1 if cGCD == 1 else 0\n    if cGCD == 1:\n        return 2 ** (n - cPose)\n    if (cPose, cGCD) in dp:\n        return dp[cPose, cGCD]\n    dp[cPose, cGCD] = game(cPose + 1, cGCD) + game(cPose + 1, GCD(cGCD, l[cPose]))\n    return dp[cPose, cGCD]\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    dp = {}\n    ans = 0\n    for i in range(n):\n        ans += game(i + 1, l[i])\n    print(ans)", "def gcd(a, b):\n    if a == 0 or b == 0:\n        if a == 0:\n            return b\n        else:\n            return a\n    else:\n        return gcd(b, a % b)\n\ndef thegame(pos, cgcd):\n    if pos == n:\n        if cgcd == 1:\n            return 1\n        else:\n            return 0\n    elif (pos, cgcd) in dp:\n        return dp[pos, cgcd]\n    elif cgcd == 1:\n        p = 2 ** (n - pos)\n        dp[pos, cgcd] = p\n        return p\n    else:\n        p = thegame(pos + 1, gcd(cgcd, nums[pos])) + thegame(pos + 1, cgcd)\n        dp[pos, cgcd] = p\n        return p\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    nums = list(map(int, input().split()))\n    dp = {}\n    res = 0\n    for pos in range(0, n - 1):\n        res += thegame(pos + 1, nums[pos])\n    print(res)\n    t -= 1", "def func(ind, g, dp, n, a):\n    if ind == n:\n        if g == 1:\n            return 1\n        else:\n            return 0\n    if dp[ind][g] != -1:\n        return dp[ind][g]\n    ans = func(ind + 1, g, dp, n, a) + func(ind + 1, gcd(a[ind], g), dp, n, a)\n    dp[ind][g] = ans\n    return dp[ind][g]\n\ndef countSubsequences(a, n):\n    dp = [[-1 for i in range(MAX)] for i in range(n)]\n    count = 0\n    for i in range(n):\n        count += func(i + 1, a[i], dp, n, a)\n    return count\nt = int(input())\nfrom math import gcd\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    MAX = max(l) + 1\n    print(countSubsequences(l, n))", "import math\nMAX = 10001\n\ndef func(ind, g, n, dp, l):\n    if ind == n:\n        if g == 1:\n            return 1\n        else:\n            return 0\n    if dp[ind][g] != -1:\n        return dp[ind][g]\n    ans = func(ind + 1, g, n, dp, l) + func(ind + 1, math.gcd(g, l[ind]), n, dp, l)\n    dp[ind][g] = ans\n    return dp[ind][g]\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    dp = [[-1 for _ in range(MAX)] for _ in range(n)]\n    count = 0\n    for i in range(n):\n        count += func(i + 1, l[i], n, dp, l)\n    print(count)", "for _ in range(int(input())):\n    MAX = 10001\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n\n    def func(ind, g, dp, n, a):\n        if ind == n:\n            if g == 1:\n                return 1\n            else:\n                return 0\n        if dp[ind][g] != -1:\n            return dp[ind][g]\n        ans = func(ind + 1, g, dp, n, a) + func(ind + 1, gcd(a[ind], g), dp, n, a)\n        dp[ind][g] = ans\n        return dp[ind][g]\n\n    def countSubsequences(a, n):\n        dp = [[-1 for i in range(MAX)] for i in range(n)]\n        count = 0\n        for i in range(n):\n            count += func(i + 1, a[i], dp, n, a)\n        return count\n    N = int(input())\n    a = [int(x) for x in input().split()]\n    print(countSubsequences(a, N))", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef gcd(a, b):\n    if b > a:\n        (a, b) = (b, a)\n    return a if b == 0 else gcd(b, a % b)\n\ndef solve(dp, index, g, arr, N):\n    if index in dp and g in dp[index]:\n        return dp[index][g]\n    if index == N and g != 1:\n        dp[index][g] = 0\n        return dp[index][g]\n    dp[index][g] = solve(dp, index + 1, g, arr, N) + solve(dp, index + 1, gcd(g, arr[index]), arr, N)\n    return dp[index][g]\nfor _ in range(int(input())):\n    N = int(input())\n    arr = list(map(int, input().split()))\n    dp = {}\n    for i in range(N + 1):\n        dp[i] = {}\n    dp[N][1] = 1\n    print(solve(dp, 0, 0, arr, N))", "def gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\ndef func(i, cur_gcd):\n    if i == n:\n        return 1 if cur_gcd == 1 else 0\n    if cur_gcd == 1:\n        return 2 ** (n - i)\n    key = (i, cur_gcd)\n    if key in d.keys():\n        return d[key]\n    d[key] = func(i + 1, cur_gcd) + func(i + 1, gcd(cur_gcd, ls[i]))\n    return d[key]\nfor _ in range(int(input())):\n    (n, res) = (int(input()), 0)\n    ls = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        res += func(i + 1, ls[i])\n    print(res)", "def gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\ndef func(i, cur_gcd):\n    if i == n:\n        return 1 if cur_gcd == 1 else 0\n    key = (i, cur_gcd)\n    if key in d.keys():\n        return d[key]\n    d[key] = func(i + 1, cur_gcd) + func(i + 1, gcd(cur_gcd, ls[i]))\n    return d[key]\nfor _ in range(int(input())):\n    (n, res) = (int(input()), 0)\n    ls = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        res += func(i + 1, ls[i])\n    print(res)", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    n = int(input())\n    L = list(map(int, input().split()))\n    d = [1] + [0] * 10 ** 4\n    for i in L:\n        for j in range(1, 10 ** 4 + 1):\n            if d[j]:\n                d[gcd(min(i, j), max(i, j))] += d[j]\n        d[i] += 1\n    print(d[1])", "import math\nfrom _bisect import *\n\ndef factors(n):\n    l = set()\n    x = int(math.sqrt(n))\n    for i in range(1, x + 1):\n        if n % i == 0:\n            l.add(i)\n            if n // i != i:\n                l.add(n // i)\n    return l\nfor T in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    divisors = set()\n    for i in range(n):\n        divisors = divisors.union(factors(a[i]))\n    divisors = list(divisors)\n    divisors.sort()\n    oneIndex = -1\n    for i in range(len(divisors)):\n        if divisors[i] == 1:\n            oneIndex = i\n            break\n    dp = [0 for x in range(len(divisors))]\n    for i in range(n):\n        for j in range(len(divisors)):\n            x = 0\n            if a[i] == divisors[j]:\n                x = 1\n            y = math.gcd(a[i], divisors[j])\n            ind = bisect_left(divisors, y)\n            dp[ind] += x + dp[j]\n    print(dp[oneIndex])", "def gcd(a, b):\n    if a == 0 or b == 0:\n        if a == 0:\n            return b\n        else:\n            return a\n    else:\n        return gcd(b, a % b)\n\ndef thegame(pos, cgcd):\n    if pos == n:\n        if cgcd == 1:\n            return 1\n        else:\n            return 0\n    elif (pos, cgcd) in dp:\n        return dp[pos, cgcd]\n    elif cgcd == 1:\n        p = 2 ** (n - pos)\n        dp[pos, cgcd] = p\n        return p\n    else:\n        p = thegame(pos + 1, gcd(cgcd, nums[pos])) + thegame(pos + 1, cgcd)\n        dp[pos, cgcd] = p\n        return p\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    nums = list(map(int, input().split()))\n    dp = {}\n    res = 0\n    for pos in range(0, n - 1):\n        res += thegame(pos + 1, nums[pos])\n    print(res)\n    t -= 1", "from math import gcd\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    cache = {}\n\n    def compute(pos, curgcd):\n        if pos == n:\n            return int(curgcd == 1)\n        if curgcd == 1:\n            return 2 ** (n - pos)\n        if (pos, curgcd) in cache:\n            return cache[pos, curgcd]\n        val = compute(pos + 1, curgcd) + compute(pos + 1, gcd(curgcd, arr[pos]))\n        cache[pos, curgcd] = val\n        return val\n    print(sum([compute(i + 1, arr[i]) for i in range(n)]))", "t = int(input())\n\ndef gcd(a, b):\n    while b > 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef SubSequences(i, con, a, sol):\n    if i < 0:\n        if con == 1:\n            return 1\n        else:\n            return 0\n    if (i, con) in sol:\n        return sol[i, con]\n    sol[i, con] = SubSequences(i - 1, gcd(a[i], con), a, sol) + SubSequences(i - 1, con, a, sol)\n    return sol[i, con]\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    print(SubSequences(n - 1, 0, a, {}))"]