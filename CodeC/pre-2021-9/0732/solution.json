["import sys\nimport bisect\nfrom os import path\nif path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    r = []\n    for __ in range(n):\n        (x, y) = map(int, input().split())\n        l.append(x)\n        r.append(y)\n    p = []\n    for ___ in range(m):\n        p.append(int(input()))\n    l.sort()\n    r.sort()\n    for i in range(m):\n        if l[0] <= p[i]:\n            idx = bisect.bisect_right(l, p[i])\n            try:\n                if p[i] - l[idx - 1] < r[idx - 1] - l[idx - 1]:\n                    print(0)\n                else:\n                    print(l[idx] - p[i])\n            except:\n                print(-1)\n        else:\n            print(l[0] - p[i])", "def check(l, val):\n    if l[0][0] > val:\n        print(l[0][0] - val)\n        return\n    elif l[-1][1] <= val:\n        print(-1)\n        return\n    else:\n        start = 0\n        end = len(l) - 1\n        while start <= end:\n            mid = (start + end) // 2\n            if l[mid][0] <= val and l[mid][1] > val:\n                print(0)\n                return\n            elif l[mid][1] <= val and l[mid + 1][0] > val:\n                print(l[mid + 1][0] - val)\n                return\n            elif l[mid][0] > val and l[mid - 1][1] <= val:\n                print(l[mid][0] - val)\n                return\n            elif l[mid][0] < val:\n                start = mid + 1\n            else:\n                end = mid - 1\nfor _ in range(int(input())):\n    l = []\n    (n, m) = map(int, input().split())\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        l.append(temp)\n    l.sort()\n    time = [int(input()) for i in range(m)]\n    for i in time:\n        check(l, i)", "def binary(a, q, n):\n    i = 0\n    j = n - 1\n    ans = -1\n    while i <= j:\n        mid = (i + j) // 2\n        if q >= a[mid][1]:\n            i = mid + 1\n        else:\n            ans = mid\n            j = mid - 1\n    return ans\n\ndef total_wait(a, n, t):\n    a.sort(key=lambda a: a[0])\n    while t:\n        t -= 1\n        q = int(input())\n        pos = binary(a, q, n)\n        if pos == -1 or q > a[pos][1]:\n            print(-1)\n        elif a[pos][0] <= q < a[pos][1]:\n            print('0')\n        else:\n            print(a[pos][0] - q)\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        l = []\n        (i, j) = map(int, input().split())\n        l.append(i)\n        l.append(j)\n        a.append(l)\n    total_wait(a, n, m)", "def binary(a, q, n):\n    i = 0\n    j = n - 1\n    ans = -1\n    while i <= j:\n        mid = (i + j) // 2\n        if q >= a[mid][1]:\n            i = mid + 1\n        else:\n            ans = mid\n            j = mid - 1\n    return ans\n\ndef total_wait(a, n, t):\n    a.sort(key=lambda a: a[0])\n    while t:\n        t -= 1\n        q = int(input())\n        pos = binary(a, q, n)\n        if pos == -1 or q > a[pos][1]:\n            print(-1)\n        elif a[pos][0] <= q < a[pos][1]:\n            print('0')\n        else:\n            print(a[pos][0] - q)\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        l = []\n        (i, j) = map(int, input().split())\n        l.append(i)\n        l.append(j)\n        a.append(l)\n    total_wait(a, n, m)", "def binary(a, q, n):\n    i = 0\n    j = n - 1\n    ans = -1\n    while i <= j:\n        mid = (i + j) // 2\n        if q >= a[mid][1]:\n            i = mid + 1\n        else:\n            ans = mid\n            j = mid - 1\n    return ans\n\ndef total_wait(a, n, t):\n    a.sort(key=lambda a: a[0])\n    while t:\n        t -= 1\n        q = int(input())\n        pos = binary(a, q, n)\n        if pos == -1:\n            print(-1)\n        elif a[pos][0] <= q < a[pos][1]:\n            print('0')\n        else:\n            print(a[pos][0] - q)\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        l = []\n        (i, j) = map(int, input().split())\n        l.append(i)\n        l.append(j)\n        a.append(l)\n    total_wait(a, n, m)", "def binary(a, q, n):\n    i = 0\n    j = n - 1\n    ans = -1\n    while i <= j:\n        mid = (i + j) // 2\n        if q >= a[mid][1]:\n            i = mid + 1\n        else:\n            ans = mid\n            j = mid - 1\n    return ans\n\ndef total_wait(a, n, t):\n    a.sort(key=lambda a: a[0])\n    while t:\n        t -= 1\n        q = int(input())\n        pos = binary(a, q, n)\n        if pos == -1 or q > a[pos][1]:\n            print(-1)\n        elif a[pos][0] <= q < a[pos][1]:\n            print('0')\n        else:\n            print(a[pos][0] - q)\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        l = []\n        (i, j) = map(int, input().split())\n        l.append(i)\n        l.append(j)\n        a.append(l)\n    total_wait(a, n, m)", "def binary(a, q, n):\n    i = 0\n    j = n - 1\n    ans = -1\n    while i <= j:\n        mid = (i + j) // 2\n        if q >= a[mid][1]:\n            i = mid + 1\n        else:\n            ans = mid\n            j = mid - 1\n    return ans\n\ndef total_wait(a, n, t):\n    a.sort(key=lambda a: a[0])\n    while t:\n        t -= 1\n        q = int(input())\n        if q < a[0][1]:\n            pos = 0\n        else:\n            pos = binary(a, q, n)\n        if pos == -1 or q > a[pos][1]:\n            print(-1)\n        elif a[pos][0] <= q < a[pos][1]:\n            print('0')\n        else:\n            print(a[pos][0] - q)\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        l = []\n        (i, j) = map(int, input().split())\n        l.append(i)\n        l.append(j)\n        a.append(l)\n    total_wait(a, n, m)", "t = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    lr = []\n    for _ in range(n):\n        (a, b) = list(map(int, input().split()))\n        lr.append([a, b])\n    p = []\n    for _ in range(m):\n        p.append(int(input()))\n    lr.sort(key=lambda x: x[0])\n    for myTime in p:\n        start = 0\n        end = n - 1\n        while start <= end:\n            if start == end:\n                if myTime >= lr[start][1]:\n                    print(-1)\n                    break\n                elif myTime >= lr[start][0]:\n                    print(0)\n                    break\n                else:\n                    print(lr[start][0] - myTime)\n                    break\n            mid = (start + end) // 2\n            if myTime >= lr[mid][1]:\n                start = mid + 1\n            elif myTime < lr[mid][0]:\n                end = mid\n            else:\n                print(0)\n                break", "t = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    lr = []\n    for _ in range(n):\n        (a, b) = list(map(int, input().split()))\n        lr.append([a, b])\n    p = []\n    for _ in range(m):\n        p.append(int(input()))\n    lr.sort(key=lambda x: x[0])\n    for myTime in p:\n        start = 0\n        end = n - 1\n        while start <= end:\n            if start == end:\n                if myTime >= lr[start][1]:\n                    print(-1)\n                    break\n                elif myTime >= lr[start][0]:\n                    print(0)\n                    break\n                else:\n                    print(lr[start][0] - myTime)\n                    break\n            mid = (start + end) // 2\n            if myTime >= lr[mid][1]:\n                start = mid + 1\n            elif myTime < lr[mid][0]:\n                end = mid\n            else:\n                print(0)\n                break", "t = int(input())\n\ndef lowerbound(intervals, ass):\n    s = 0\n    e = len(intervals) - 1\n    lower_bound = -1\n    while s <= e:\n        mid = (s + e) // 2\n        if intervals[mid][0] <= ass:\n            s = mid + 1\n        else:\n            lower_bound = mid\n            e = mid - 1\n    return lower_bound if lower_bound != -1 else len(intervals)\nfor tc in range(t):\n    pers = []\n    intervals = []\n    (n, m) = map(int, input().split(' '))\n    for j in range(n):\n        (l, r) = map(int, input().split(' '))\n        intervals.append([l, r])\n    intervals.sort()\n    for j in range(m):\n        pers = int(input())\n        pos = lowerbound(intervals, pers)\n        if pos == 0:\n            ans = intervals[0][0] - pers\n            print(ans)\n        else:\n            ans = -1\n            if intervals[pos - 1][1] > pers:\n                ans = 0\n            elif pos < len(intervals):\n                ans = intervals[pos][0] - pers\n            print(ans)", "def binary(a, q, n):\n    i = 0\n    j = n - 1\n    while i <= j:\n        mid = (i + j) // 2\n        if q >= a[mid - 1][1] and q < a[mid][1]:\n            return mid\n        if q > a[mid][0]:\n            i = mid + 1\n        elif q < a[mid][0]:\n            j = mid - 1\n    return -1\n\ndef total_wait(a, n, t):\n    a.sort(key=lambda a: a[0])\n    while t:\n        t -= 1\n        q = int(input())\n        if q < a[0][1]:\n            pos = 0\n        else:\n            pos = binary(a, q, n)\n        if pos == -1 or pos >= n:\n            print('-1')\n        elif a[pos][0] <= q < a[pos][1]:\n            print('0')\n        else:\n            print(a[pos][0] - q)\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        l = []\n        (i, j) = map(int, input().split())\n        l.append(i)\n        l.append(j)\n        a.append(l)\n    total_wait(a, n, m)", "import bisect\nt = int(input())\nfor _ in range(t):\n    (n, m) = [int(i) for i in input().split()]\n    arr = []\n    dic = {}\n    for i in range(n):\n        (l, r) = [int(i) for i in input().split()]\n        arr.append(l)\n        dic[l] = r\n    arr.sort()\n    for i in range(m):\n        val = int(input())\n        ind = bisect.bisect_right(arr, val)\n        if arr[ind - 1] == val:\n            print(0)\n        elif val < dic[arr[ind - 1]] and val > arr[ind - 1]:\n            print(0)\n        elif ind == n and val >= dic[arr[ind - 1]]:\n            print(-1)\n        elif ind == 0:\n            print(arr[0] - val)\n        elif ind == n:\n            print(0)\n        else:\n            print(arr[ind] - val)", "from bisect import insort, bisect_right\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    intervals = []\n    for i in range(n):\n        inp = tuple(map(int, input().split()))\n        insort(intervals, inp)\n    inte = [k[1] for k in intervals]\n    for i in range(m):\n        ip = int(input())\n        c = bisect_right(inte, ip)\n        if c >= n:\n            print(-1)\n        else:\n            curr = intervals[c]\n            if ip >= curr[0] and ip < curr[1]:\n                print(0)\n            else:\n                print(curr[0] - ip)", "def binsearch(x):\n    l = 0\n    r = len(times)\n    while l < r:\n        i = (l + r) // 2\n        ele = times[i]\n        if x >= ele[1]:\n            l = i + 1\n        elif x < ele[0]:\n            r = i\n        elif x in range(ele[0], ele[1]):\n            return 0\n    if ele[0] - x > 0:\n        return ele[0] - x\n    elif ele[0] - x < 0 and i + 1 < len(times):\n        return times[i + 1][0] - x\n    elif i + 1 == len(times):\n        return -1\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    times = []\n    for _ in range(n):\n        times.append(list(map(int, input().split())))\n    times.sort()\n    for _ in range(m):\n        inp = int(input())\n        print(binsearch(inp))", "def binsearch(x):\n    l = 0\n    r = len(times)\n    while l < r:\n        i = (l + r) // 2\n        ele = times[i]\n        if x >= ele[1]:\n            l = i + 1\n        elif x < ele[0]:\n            r = i\n        elif x in range(ele[0], ele[1]):\n            return 0\n    if ele[0] - x > 0:\n        return ele[0] - x\n    elif ele[0] - x < 0 and i + 1 < len(times):\n        return times[i + 1][0] - x\n    elif i + 1 == len(times):\n        return -1\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    times = []\n    for _ in range(n):\n        times.append(list(map(int, input().split())))\n    times.sort()\n    for _ in range(m):\n        inp = int(input())\n        print(binsearch(inp))", "from sys import stdin, stdout\nimport bisect\n\ndef main():\n    for _ in range(int(stdin.readline())):\n        (n, m) = map(int, stdin.readline().split())\n        arr = []\n        dic = {}\n        for i in range(n):\n            (l, r) = map(int, stdin.readline().split())\n            arr.append(l)\n            dic[l] = r\n        arr.sort()\n        for i in range(m):\n            val = int(stdin.readline())\n            ind = bisect.bisect_right(arr, val)\n            if arr[ind - 1] == val:\n                print(0)\n            elif val < dic[arr[ind - 1]] and val > arr[ind - 1]:\n                print(0)\n            elif ind == n and val >= dic[arr[ind - 1]]:\n                print(-1)\n            elif ind == 0:\n                print(arr[0] - val)\n            elif ind == n:\n                print(0)\n            else:\n                print(arr[ind] - val)\nmain()", "def searchP(p, arr, n):\n    (low, high) = (0, n - 1)\n    ans = -1\n    while low <= high:\n        mid = low + (high - low) // 2\n        if arr[mid][1] > p:\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    if ans == -1:\n        return -1\n    return max(0, arr[ans][0] - p)\nt = int(input())\nfor tc in range(t):\n    (n, m) = map(int, input().split())\n    arr = [[int(j) for j in input().split()] for i in range(n)]\n    arr.sort()\n    for i in range(m):\n        wt = 0\n        p = int(input())\n        wt = searchP(p, arr, n)\n        print(wt)", "t = int(input())\n\ndef lowerbound(intervals, ass):\n    s = 0\n    e = len(intervals) - 1\n    lower_bound = -1\n    while s <= e:\n        mid = (s + e) // 2\n        if intervals[mid][0] <= ass:\n            s = mid + 1\n        else:\n            lower_bound = mid\n            e = mid - 1\n    return lower_bound if lower_bound != -1 else len(intervals)\nfor tc in range(t):\n    pers = []\n    intervals = []\n    (n, m) = map(int, input().split(' '))\n    for j in range(n):\n        (l, r) = map(int, input().split(' '))\n        intervals.append([l, r])\n    intervals.sort()\n    for j in range(m):\n        pers = int(input())\n        pos = lowerbound(intervals, pers)\n        if pos == 0:\n            ans = intervals[0][0] - pers\n            print(ans)\n        else:\n            ans = -1\n            if intervals[pos - 1][1] > pers:\n                ans = 0\n            elif pos < len(intervals):\n                ans = intervals[pos][0] - pers\n            print(ans)", "t = int(input())\nfor k in range(t):\n    (n, m) = input().split()\n    (n, m) = (int(n), int(m))\n    inv = []\n    for i in range(n):\n        (l, r) = input().split()\n        inv.append([int(l), int(r)])\n\n    def f(x):\n        return x[0]\n    inv = sorted(inv, key=f)\n    for i in range(m):\n        q = int(input())\n        if q >= inv[n - 1][1]:\n            print(-1)\n            continue\n        time = -1\n        l = 0\n        r = n - 1\n        while l <= r:\n            mid = l + (r - l) // 2\n            if q < inv[mid][0]:\n                time = inv[mid][0] - q\n                r = mid - 1\n            elif q >= inv[mid][1]:\n                l = mid + 1\n            else:\n                time = 0\n                break\n        print(time)", "try:\n    from bisect import bisect\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        a = []\n        for i in range(n):\n            (l, r) = map(int, input().split())\n            a.append([l, r])\n        a.sort()\n        for j in range(m):\n            p = int(input())\n            b = bisect(a, [p])\n            (start, end) = a[b - 1]\n            if start <= p < end:\n                print(0)\n            elif len(a) <= b:\n                print(-1)\n            else:\n                print(a[b][0] - p)\nexcept:\n    pass", "from sys import stdin\n\ndef binary_search(interval, x):\n    (start, end) = (0, len(interval) - 1)\n    while start <= end:\n        mid = (start + end) // 2\n        if interval[mid][0] <= x < interval[mid][1]:\n            return mid\n        elif interval[mid][0] > x:\n            end = mid - 1\n        elif interval[mid][0] < x:\n            start = mid + 1\n    return [start, end]\nt = int(stdin.readline())\nwhile t > 0:\n    (n, m) = map(int, stdin.readline().split())\n    interval = []\n    for i in range(n):\n        (l, r) = map(int, stdin.readline().split())\n        interval.append([l, r])\n    p = []\n    for i in range(m):\n        p.append(int(stdin.readline()))\n    interval = sorted(interval, key=lambda x: x[0])\n    for x in p:\n        wait_time = binary_search(interval, x)\n        if isinstance(wait_time, list):\n            (l, r) = wait_time\n            wait_time = -1 if l >= n else interval[l][0] - x\n        else:\n            wait_time = 0\n        print(wait_time)\n    t -= 1", "from bisect import bisect\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    for _ in range(n):\n        (l, r) = map(int, input().split())\n        a.append([l, r])\n    a.sort()\n    for _ in range(m):\n        p = int(input())\n        i = bisect(a, [p])\n        (start, end) = a[i - 1]\n        if start <= p < end:\n            print(0)\n        elif len(a) <= i:\n            print(-1)\n        else:\n            print(a[i][0] - p)", "def merge(arr, start, mid, end):\n    i = start\n    j = mid\n    k = 0\n    temp = [0] * (end - start + 1)\n    while i < mid and j <= end:\n        if arr[i][0] <= arr[j][0]:\n            temp[k] = arr[i]\n            i += 1\n            k += 1\n        else:\n            temp[k] = arr[j]\n            j += 1\n            k += 1\n    while i < mid:\n        temp[k] = arr[i]\n        i += 1\n        k += 1\n    while j <= end:\n        temp[k] = arr[j]\n        j += 1\n        k += 1\n    k = 0\n    for i in range(start, end + 1):\n        arr[i] = temp[k]\n        k += 1\n\ndef merge_sort(arr, first, last):\n    if first >= last:\n        return\n    mid = first + (last - first) // 2\n    merge_sort(arr, first, mid)\n    merge_sort(arr, mid + 1, last)\n    merge(arr, first, mid + 1, last)\n\ndef binarySearch(arr, target, end):\n    start = 0\n    ans = end + 1\n    while start <= end:\n        mid = start + (end - start) // 2\n        if arr[mid][0] < target:\n            start = mid + 1\n        else:\n            ans = mid\n            end = mid - 1\n    return ans\ntests = int(input().strip())\nfor t in range(tests):\n    (n, m) = [int(x) for x in input().strip().split()]\n    intervals = [0] * n\n    for i in range(n):\n        (x, y) = input().strip().split()\n        intervals[i] = (int(x), int(y))\n    merge_sort(intervals, 0, n - 1)\n    persons = [0] * m\n    for i in range(m):\n        persons[i] = int(input().strip())\n    for p in persons:\n        index = binarySearch(intervals, p, n - 1)\n        ans = -1\n        if index == 0:\n            ans = intervals[index][0] - p\n        elif intervals[index - 1][1] > p:\n            ans = 0\n        elif index < n:\n            ans = intervals[index][0] - p\n        print(ans)", "def binarySearch(arr, target, end):\n    start = 0\n    ans = end + 1\n    while start <= end:\n        mid = start + (end - start) // 2\n        if arr[mid][0] < target:\n            start = mid + 1\n        else:\n            ans = mid\n            end = mid - 1\n    return ans\ntests = int(input().strip())\nfor t in range(tests):\n    (n, m) = [int(x) for x in input().strip().split()]\n    intervals = [0] * n\n    for i in range(n):\n        (x, y) = input().strip().split()\n        intervals[i] = (int(x), int(y))\n    intervals.sort(key=lambda x: x[0])\n    persons = [0] * m\n    for i in range(m):\n        persons[i] = int(input().strip())\n    for p in persons:\n        index = binarySearch(intervals, p, n - 1)\n        ans = -1\n        if index == 0:\n            ans = intervals[index][0] - p\n        elif intervals[index - 1][1] > p:\n            ans = 0\n        elif index < n:\n            ans = intervals[index][0] - p\n        print(ans)", "class point:\n\n    def __init__(self, a, b):\n        self.st = a\n        self.en = b\n\ndef f(p):\n    return p.st\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    points = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        temp = point(a, b)\n        points.append(temp)\n    points.sort(key=f)\n    for __ in range(m):\n        x = int(input())\n        ans = -1\n        s = 0\n        e = n - 1\n        check = -1\n        while s <= e:\n            mid = (s + e) // 2\n            ele = points[mid]\n            if ele.st <= x and ele.en > x:\n                ans = 0\n                check = mid\n                break\n            elif ele.en > x:\n                e = mid - 1\n            else:\n                s = mid + 1\n            if ele.st >= x:\n                check = mid\n        if ans != 0 and check != -1:\n            ans = points[check].st - x\n        print(ans)", "class point:\n\n    def __init__(self, a, b):\n        self.st = a\n        self.en = b\n\ndef f(p):\n    return p.st\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    points = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        temp = point(a, b)\n        points.append(temp)\n    points.sort(key=f)\n    for __ in range(m):\n        x = int(input())\n        ans = -1\n        s = 0\n        e = n - 1\n        check = -1\n        while s <= e:\n            mid = (s + e) // 2\n            ele = points[mid]\n            if ele.st <= x and ele.en > x:\n                ans = 0\n                check = mid\n                break\n            elif ele.en > x:\n                e = mid - 1\n            else:\n                s = mid + 1\n            if ele.st >= x:\n                check = mid\n        if ans != 0 and check != -1:\n            ans = points[check].st - x\n        print(ans)", "from sys import stdin, stdout\ninput = stdin.readline\n\ndef binarySearch(arr, p):\n    n = len(arr)\n    low = 0\n    high = n - 1\n    ans = -1\n    while high >= low:\n        mid = (low + high) // 2\n        (l, r) = arr[mid]\n        if p >= l and p < r:\n            return 0\n        elif p < l:\n            high = mid - 1\n            ans = l - p\n        elif p >= r:\n            low = mid + 1\n    return ans\nt = int(input().strip())\nfor _ in range(t):\n    intervals = list()\n    (n, m) = list(map(int, input().strip().split()))\n    for _ in range(n):\n        (l, r) = list(map(int, input().strip().split()))\n        intervals.append([l, r])\n    intervals.sort()\n    for _ in range(m):\n        p = int(input().strip())\n        ans = binarySearch(intervals, p)\n        print(ans)", "from sys import stdin, stdout\ninput = stdin.readline\n\ndef binarySearch(arr, p):\n    n = len(arr)\n    low = 0\n    high = n - 1\n    ans = -1\n    while high >= low:\n        mid = (low + high) // 2\n        (l, r) = arr[mid]\n        if p >= l and p < r:\n            return 0\n        elif p < l:\n            high = mid - 1\n            ans = l - p\n        elif p >= r:\n            low = mid + 1\n    return ans\nt = int(input().strip())\nfor _ in range(t):\n    intervals = list()\n    (n, m) = list(map(int, input().strip().split()))\n    for _ in range(n):\n        (l, r) = list(map(int, input().strip().split()))\n        intervals.append([l, r])\n    intervals.sort()\n    for _ in range(m):\n        p = int(input().strip())\n        ans = binarySearch(intervals, p)\n        print(ans)", "from sys import stdin, stdout\ninput = stdin.readline\n\ndef binarySearch(arr, p):\n    n = len(arr)\n    low = 0\n    high = n - 1\n    pos = -1\n    while high >= low:\n        mid = (low + high) // 2\n        if arr[mid][1] > p:\n            pos = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    if pos == -1:\n        return -1\n    return max(0, arr[pos][0] - p)\nt = int(input().strip())\nfor _ in range(t):\n    intervals = list()\n    (n, m) = list(map(int, input().strip().split()))\n    for _ in range(n):\n        (l, r) = list(map(int, input().strip().split()))\n        intervals.append([l, r])\n    intervals.sort(key=lambda x: x[0])\n    for _ in range(m):\n        p = int(input().strip())\n        ans = binarySearch(intervals, p)\n        print(ans)", "t = int(input())\n\ndef findRange(time, P, N):\n    low = 0\n    high = N - 1\n    result = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if time[mid][1] > P:\n            result = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    if result == -1:\n        return -1\n    return max(0, time[result][0] - P)\n\ndef solve(time, N, M):\n    time.sort(key=lambda x: x[0])\n    for i in range(M):\n        P = int(input())\n        ans = findRange(time, P, N)\n        print(ans)\nfor i in range(t):\n    (N, M) = map(int, input().split())\n    time = []\n    for i in range(N):\n        (L, R) = map(int, input().split())\n        time.append([L, R])\n    solve(time, N, M)", "t = int(input())\n\ndef findRange(time, P, N):\n    low = 0\n    high = N - 1\n    result = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if time[mid][1] > P:\n            result = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    if result == -1:\n        return -1\n    return max(0, time[result][0] - P)\n\ndef solve(time, N, M):\n    time.sort(key=lambda x: x[0])\n    for i in range(M):\n        P = int(input())\n        ans = findRange(time, P, N)\n        print(ans)\nfor i in range(t):\n    (N, M) = map(int, input().split())\n    time = []\n    for i in range(N):\n        (L, R) = map(int, input().split())\n        time.append([L, R])\n    solve(time, N, M)", "def waitTime(timeIV, N, P):\n    (low, high) = (0, N - 1)\n    ans = -1\n    while low <= high:\n        mid = low + (high - low) // 2\n        if timeIV[mid][1] > P:\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    if ans == -1:\n        return ans\n    return max(0, timeIV[ans][0] - P)\n\ndef solve(timeIV, N, M):\n    timeIV.sort(key=lambda x: x[0])\n    for j in range(M):\n        p = int(input())\n        ans = waitTime(timeIV, N, p)\n        print(ans)\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    timeIV = []\n    for i in range(N):\n        (l, r) = map(int, input().split())\n        timeIV.append([l, r])\n    solve(timeIV, N, M)", "def solve(times, people):\n    (l, r) = (0, len(times) - 1)\n    ans = -1\n    while l <= r:\n        mid = (l + r) // 2\n        if times[mid][1] > people:\n            ans = mid\n            r = mid - 1\n        else:\n            l = mid + 1\n    if ans == -1:\n        return ans\n    return max(0, times[ans][0] - people)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    times = []\n    for t in range(n):\n        (e, q) = map(int, input().split())\n        times.append([e, q])\n    times.sort()\n    for t in range(m):\n        people = int(input())\n        print(solve(times, people))", "def findClosestRange(timeIntervals, N, P):\n    (low, high) = (0, N - 1)\n    ans = -1\n    while low <= high:\n        mid = low + (high - low) // 2\n        if timeIntervals[mid][1] > P:\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    if ans == -1:\n        return -1\n    return max(0, timeIntervals[ans][0] - P)\n\ndef solve(timeIntervals, N, M):\n    timeIntervals.sort(key=lambda x: x[0])\n    for i in range(M):\n        P = int(input())\n        ans = findClosestRange(timeIntervals, N, P)\n        print(ans)\nT = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    timeIntervals = []\n    for i in range(0, N):\n        (l, r) = map(int, input().split())\n        timeIntervals.append([l, r])\n    solve(timeIntervals, N, M)", "def before_after_time(s, e, li, time):\n    if len(li) == 1:\n        return (li[0], False)\n    mid = (s + e) // 2\n    if li[mid] == time:\n        return (li[mid], True)\n    if abs(e - s) == 1:\n        return (li[s], li[e])\n    if time > li[mid]:\n        return before_after_time(mid, e, li, time)\n    else:\n        return before_after_time(s, mid, li, time)\n\ndef restaurent():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        d = dict()\n        li = []\n        arriving_time = []\n        for _ in range(n):\n            (start, end) = map(int, input().split())\n            d[start] = end\n            li.append(start)\n        for _ in range(m):\n            arriving_time.append(int(input()))\n        li.sort()\n        (s, e) = (0, len(li) - 1)\n        for x in arriving_time:\n            if x > d[li[e]]:\n                print(-1)\n                continue\n            elif x < li[s]:\n                print(li[0] - x)\n                continue\n            (before, after) = before_after_time(s, e, li, x)\n            if after == True:\n                print(0)\n            elif after == False:\n                if li[0] <= x < d[li[0]]:\n                    print(0)\n                elif x < li[0]:\n                    print(li[0] - x)\n                else:\n                    print(-1)\n            elif before <= x < d[before] or after <= x < d[after]:\n                print(0)\n            elif x >= d[after]:\n                print(-1)\n            else:\n                print(after - x)\nrestaurent()", "from bisect import bisect\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        a += list(map(int, input().split()))\n    a.sort()\n    for i in range(m):\n        x = int(input())\n        if x < a[0]:\n            print(a[0] - x)\n        elif x >= a[-1]:\n            print(-1)\n        else:\n            b = bisect(a, x)\n            if b % 2 == 1:\n                print(0)\n            else:\n                print(a[b] - x)", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    lst = []\n    for __ in range(n):\n        (a, b) = map(int, input().split())\n        lst.append([a, b])\n    lst.sort(key=lambda x: x[0])\n    for __ in range(m):\n        curr = int(input())\n        si = 0\n        ei = n - 1\n        ans = -1\n        while si <= ei:\n            mid = (si + ei) // 2\n            if lst[mid][0] < curr:\n                si = mid + 1\n            elif lst[mid][0] > curr:\n                ei = mid - 1\n                ans = mid\n            else:\n                ans = mid\n                break\n        if ans == -1:\n            if lst[n - 1][0] <= curr and lst[n - 1][1] > curr:\n                print(0)\n            else:\n                print(-1)\n        elif ans == 0:\n            print(lst[ans][0] - curr)\n        elif lst[ans - 1][0] <= curr and lst[ans - 1][1] > curr:\n            print(0)\n        else:\n            print(lst[ans][0] - curr)", "def chefRest(timings, personTime, n):\n    high = n - 1\n    low = 0\n    while low <= high:\n        mid = low + (high - low) // 2\n        if timings[mid][0] <= personTime <= timings[mid][1]:\n            if timings[mid][0] <= personTime < timings[mid][1]:\n                return 0\n            elif mid == n - 1:\n                return -1\n            else:\n                return timings[mid + 1][0] - personTime\n        elif personTime < timings[mid][0]:\n            high = mid - 1\n        elif personTime > timings[mid][1]:\n            low = mid + 1\n    if low == n:\n        return -1\n    else:\n        return timings[low][0] - personTime\ntest = int(input())\nwhile test:\n    (timeInp, personTims) = list(map(int, input().strip().split()))\n    n = timeInp\n    timings = []\n    while timeInp:\n        pair = list(map(int, input().strip().split()))\n        timings.append(pair)\n        timeInp -= 1\n    timings.sort()\n    while personTims:\n        time = int(input())\n        print(chefRest(timings, time, n))\n        personTims -= 1\n    test -= 1", "import bisect\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        arr.append([x, y])\n    arr.sort(key=lambda x: x[0])\n    for i in range(m):\n        curr_time = int(input())\n        position = bisect.bisect(arr, [curr_time, 0])\n        if position == 0:\n            print(arr[0][0] - curr_time)\n        elif arr[position - 1][1] > curr_time:\n            print(0)\n        elif position < n:\n            print(arr[position][0] - curr_time)\n        else:\n            print(-1)\nprint()", "t = int(input().strip())\n\ndef findRight(arr, start, end, num):\n    if start > end:\n        return -1\n    if start == end:\n        return start\n    mid = int((start + end) / 2)\n    if arr[mid] == num:\n        return mid\n    if num > arr[mid]:\n        return findRight(arr, mid + 1, end, num)\n    else:\n        return findRight(arr, start, mid, num)\nfor _ in range(t):\n    hashmap = {}\n    l = []\n    (N, M) = [int(n) for n in input().strip().split()]\n    for _ in range(N):\n        (low, high) = [int(n) for n in input().strip().split()]\n        hashmap[low] = high\n        l.append(low)\n    l.sort()\n    for _ in range(M):\n        num = int(input().strip())\n        index = findRight(l, 0, N - 1, num)\n        if l[index] == num:\n            print(0)\n        elif num < l[0]:\n            print(l[0] - num)\n        elif num >= hashmap[l[-1]]:\n            print(-1)\n        elif num > l[index]:\n            print(0)\n        else:\n            x = hashmap[l[index - 1]]\n            if num >= x:\n                print(abs(l[index] - num))\n            else:\n                print(0)", "t = int(input().strip())\n\ndef findRight(arr, start, end, num):\n    if start > end:\n        return -1\n    if start == end:\n        return start\n    mid = int((start + end) / 2)\n    if arr[mid] == num:\n        return mid\n    if num > arr[mid]:\n        return findRight(arr, mid + 1, end, num)\n    else:\n        return findRight(arr, start, mid, num)\nfor _ in range(t):\n    hashmap = {}\n    l = []\n    (N, M) = [int(n) for n in input().strip().split()]\n    for _ in range(N):\n        (low, high) = [int(n) for n in input().strip().split()]\n        hashmap[low] = high\n        l.append(low)\n    l.sort()\n    for _ in range(M):\n        num = int(input().strip())\n        index = findRight(l, 0, N - 1, num)\n        if l[index] == num:\n            print(0)\n        elif num < l[0]:\n            print(l[0] - num)\n        elif num >= hashmap[l[-1]]:\n            print(-1)\n        elif num > l[index]:\n            print(0)\n        else:\n            x = hashmap[l[index - 1]]\n            if num >= x:\n                print(abs(l[index] - num))\n            else:\n                print(0)", "import bisect\nT = int(input())\nwhile T > 0:\n    T -= 1\n    (N, M) = [int(x) for x in input().split(' ')]\n    listOpen = []\n    for i in range(N):\n        (L, R) = [int(x) for x in input().split(' ')]\n        listOpen.append([L, R])\n    listOpen.sort()\n    list1StartTime = [x[0] for x in listOpen]\n    listP = []\n    for i in range(M):\n        P = int(input())\n        ans = -1\n        index = bisect.bisect_right(list1StartTime, P, lo=0, hi=len(list1StartTime))\n        if index != 0 and listOpen[index - 1][1] > P:\n            ans = 0\n        elif index != len(listOpen):\n            ans = listOpen[index][0] - P\n        print(ans)", "import bisect\nT = int(input())\nwhile T > 0:\n    T -= 1\n    (N, M) = [int(x) for x in input().split(' ')]\n    listOpen = []\n    for i in range(N):\n        (L, R) = [int(x) for x in input().split(' ')]\n        listOpen.append([L, R])\n    listOpen.sort()\n    list1StartTime = [x[0] for x in listOpen]\n    listP = []\n    for i in range(M):\n        P = int(input())\n        ans = -1\n        index = bisect.bisect_right(list1StartTime, P, lo=0, hi=len(list1StartTime))\n        if index != 0:\n            if listOpen[index - 1][1] > P:\n                ans = 0\n            elif index != len(listOpen):\n                ans = listOpen[index][0] - P\n        else:\n            ans = listOpen[0][0] - P\n        print(ans)", "from bisect import bisect_right\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    li_left = []\n    li_right = []\n    for j in range(n):\n        (l, r) = map(int, input().split())\n        li_left.append(l)\n        li_right.append(r)\n    li_left.sort()\n    li_right.sort()\n    for j in range(m):\n        pi = int(input())\n        ans = -1\n        index = bisect_right(li_right, pi)\n        if index != n:\n            if li_left[index] <= pi:\n                ans = 0\n            elif li_left[index] > pi:\n                ans = li_left[index] - pi\n        else:\n            ans = -1\n        print(ans)", "from bisect import bisect_left as lower_bound\nT = int(input())\nfor _ in range(T):\n    (n, m) = map(int, input().split())\n    time = []\n    for i in range(n):\n        (li, ri) = map(int, input().split())\n        time.append([li, ri])\n    time.sort(key=lambda x: x[0])\n    l = []\n    r = []\n    for i in range(n):\n        l.append(time[i][0])\n        r.append(time[i][1])\n    for i in range(m):\n        p = int(input())\n        if n == 1:\n            if l[0] <= p < r[0]:\n                print(0)\n            elif p < l[0]:\n                print(l[0] - p)\n            else:\n                print(-1)\n            continue\n        ans = 0\n        index = lower_bound(l, p)\n        if index >= 1 and index < n:\n            if l[index] > p and r[index - 1] <= p:\n                ans = l[index] - p\n        elif index == 0:\n            if l[index] > p:\n                ans = l[index] - p\n        elif p >= r[-1]:\n            ans = -1\n        print(ans)", "import bisect\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    opening = {}\n    closing = []\n    for N in range(n):\n        (o, c) = map(int, input().split())\n        closing.append(c)\n        opening[c] = o\n    closing.sort()\n    for M in range(m):\n        q = int(input())\n        idx = bisect.bisect_right(closing, q)\n        if idx == n:\n            print(-1)\n        elif opening[closing[idx]] <= q:\n            print(0)\n        else:\n            print(opening[closing[idx]] - q)", "from bisect import bisect_right\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    li_left = []\n    li_right = []\n    for j in range(n):\n        (l, r) = map(int, input().split())\n        li_left.append(l)\n        li_right.append(r)\n    li_left.sort()\n    li_right.sort()\n    for j in range(m):\n        pi = int(input())\n        ans = -1\n        index = bisect_right(li_right, pi)\n        if index != n:\n            if li_left[index] <= pi:\n                ans = 0\n            elif li_left[index] > pi:\n                ans = li_left[index] - pi\n        else:\n            ans = -1\n        print(ans)", "from bisect import bisect_left\nfrom os import wait\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    TimeSlot = []\n    N2 = N * 2\n    for i in range(N):\n        (s, e) = map(int, input().split())\n        TimeSlot.append(s)\n        TimeSlot.append(e)\n    TimeSlot.sort()\n    Pi = [int(input()) for _ in range(M)]\n    for p in Pi:\n        waittime = 0\n        index = bisect_left(TimeSlot, p)\n        if index == N2:\n            waittime = -1\n        elif index % 2 == 0:\n            waittime = TimeSlot[index] - p\n        else:\n            waittime = TimeSlot[index] - p\n            if waittime == 0:\n                index += 1\n                if index == N2:\n                    waittime = -1\n                else:\n                    waittime = TimeSlot[index] - p\n            else:\n                waittime = 0\n        print(waittime)", "from bisect import bisect_right\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    li_left = []\n    li_right = []\n    for j in range(n):\n        (l, r) = map(int, input().split())\n        li_left.append(l)\n        li_right.append(r)\n    li_left.sort()\n    li_right.sort()\n    for j in range(m):\n        pi = int(input())\n        ans = -1\n        index = bisect_right(li_right, pi)\n        if index != n:\n            if li_left[index] <= pi:\n                ans = 0\n            elif li_left[index] > pi:\n                ans = li_left[index] - pi\n        else:\n            ans = -1\n        print(ans)", "for _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    l = []\n    for j in range(N):\n        (L, R) = list(map(int, input().split()))\n        l.append(L)\n        l.append(R)\n    l.sort()\n    for i in range(0, M):\n        p = int(input())\n        if p < l[0]:\n            print(l[0] - p)\n            continue\n        elif p >= l[len(l) - 1]:\n            print(-1)\n            continue\n        (lo, hi) = (0, len(l) - 1)\n        z = False\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if l[mid] == p:\n                if mid % 2 != 0:\n                    ans = l[mid + 1] - l[mid]\n                else:\n                    ans = 0\n                z = True\n                break\n            elif l[mid] > p:\n                hi = mid - 1\n            elif l[mid] < p:\n                ans = mid\n                lo = mid + 1\n        if z == False:\n            if ans % 2 == 0:\n                ans = 0\n            elif ans % 2 != 0:\n                ans = l[ans + 1] - p\n        print(ans)", "T = int(input())\nfor i in range(T):\n    (N, M) = map(int, input().split())\n    l = []\n    for j in range(N):\n        (L, R) = list(map(int, input().split()))\n        l.append(L)\n        l.append(R)\n    l.sort()\n    for i in range(0, M):\n        p = int(input())\n        if p < l[0]:\n            print(l[0] - p)\n            continue\n        elif p >= l[len(l) - 1]:\n            print(-1)\n            continue\n        (lo, hi) = (0, len(l) - 1)\n        z = False\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if l[mid] == p:\n                if mid % 2 != 0:\n                    ans = l[mid + 1] - l[mid]\n                else:\n                    ans = 0\n                z = True\n                break\n            elif l[mid] > p:\n                hi = mid - 1\n            elif l[mid] < p:\n                ans = mid\n                lo = mid + 1\n        if z == False:\n            if ans % 2 == 0:\n                ans = 0\n            elif ans % 2 != 0:\n                ans = l[ans + 1] - p\n        print(ans)", "T = int(input())\nfor i in range(T):\n    (N, M) = map(int, input().split())\n    l = []\n    for j in range(N):\n        (L, R) = list(map(int, input().split()))\n        l.append(L)\n        l.append(R)\n    l.sort()\n    for i in range(0, M):\n        p = int(input())\n        if p < l[0]:\n            print(l[0] - p)\n            continue\n        elif p >= l[len(l) - 1]:\n            print(-1)\n            continue\n        (lo, hi) = (0, len(l) - 1)\n        z = False\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if l[mid] == p:\n                if mid % 2 != 0:\n                    ans = l[mid + 1] - l[mid]\n                else:\n                    ans = 0\n                z = True\n                break\n            elif l[mid] > p:\n                hi = mid - 1\n            elif l[mid] < p:\n                ans = mid\n                lo = mid + 1\n        if z == False:\n            if ans % 2 == 0:\n                ans = 0\n            elif ans % 2 != 0:\n                ans = l[ans + 1] - p\n        print(ans)", "t = int(input())\nfor co in range(t):\n    l = []\n    (n, m) = list(map(int, input().split()))\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    l.sort()\n    for i in range(m):\n        c = 0\n        s = int(input())\n        if s >= l[-1][1]:\n            print('-1')\n        elif s < l[0][0]:\n            print(l[0][0] - s)\n        elif s > l[-1][0] and s < l[-1][1] and (c == 0):\n            print('0')\n        else:\n            hi = n - 1\n            lo = 0\n            ans = -1\n            while lo <= hi:\n                j = (lo + hi) // 2\n                if s >= l[j][0] and s < l[j][1]:\n                    print('0')\n                    c = 1\n                    break\n                elif s < l[j][0]:\n                    ans = j\n                    hi = j - 1\n                else:\n                    lo = j + 1\n            if c == 0:\n                print(l[ans][0] - s)", "t = int(input())\nfor co in range(t):\n    l = []\n    (n, m) = list(map(int, input().split()))\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    l.sort()\n    for i in range(m):\n        c = 0\n        s = int(input())\n        if s >= l[-1][1]:\n            print('-1')\n        elif s < l[0][0]:\n            print(l[0][0] - s)\n        elif s > l[-1][0] and s < l[-1][1] and (c == 0):\n            print('0')\n        else:\n            hi = n - 1\n            lo = 0\n            ans = -1\n            while lo <= hi:\n                j = (lo + hi) // 2\n                if s >= l[j][0] and s < l[j][1]:\n                    print('0')\n                    c = 1\n                    break\n                elif s < l[j][0]:\n                    ans = j\n                    hi = j - 1\n                else:\n                    lo = j + 1\n            if c == 0:\n                print(l[ans][0] - s)", "t = int(input())\nfor co in range(t):\n    l = []\n    (n, m) = list(map(int, input().split()))\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    l.sort()\n    for i in range(m):\n        c = 0\n        s = int(input())\n        if s >= l[-1][1]:\n            print('-1')\n        elif s < l[0][0]:\n            print(l[0][0] - s)\n        elif s > l[-1][0] and s < l[-1][1] and (c == 0):\n            print('0')\n        else:\n            hi = n - 1\n            lo = 0\n            ans = -1\n            while lo <= hi:\n                j = (lo + hi) // 2\n                if s >= l[j][0] and s < l[j][1]:\n                    print('0')\n                    c = 1\n                    break\n                elif s < l[j][0]:\n                    ans = j\n                    hi = j - 1\n                else:\n                    lo = j + 1\n            if c == 0:\n                print(l[ans][0] - s)", "t = int(input())\nfor co in range(t):\n    l = []\n    (n, m) = list(map(int, input().split()))\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    l.sort()\n    for i in range(m):\n        c = 0\n        s = int(input())\n        if s >= l[-1][1]:\n            print('-1')\n        elif s < l[0][0]:\n            print(l[0][0] - s)\n        elif s > l[-1][0] and s < l[-1][1] and (c == 0):\n            print('0')\n        else:\n            hi = n - 1\n            lo = 0\n            ans = -1\n            while lo <= hi:\n                j = (lo + hi) // 2\n                if s >= l[j][0] and s < l[j][1]:\n                    print('0')\n                    c = 1\n                    break\n                elif s < l[j][0]:\n                    ans = j\n                    hi = j - 1\n                else:\n                    lo = j + 1\n            if c == 0:\n                print(l[ans][0] - s)", "t = int(input())\nfor co in range(t):\n    l = []\n    (n, m) = list(map(int, input().split()))\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    l.sort()\n    for i in range(m):\n        c = 0\n        s = int(input())\n        if s >= l[-1][1]:\n            print('-1')\n        elif s < l[0][0]:\n            print(l[0][0] - s)\n        elif s > l[-1][0] and s < l[-1][1] and (c == 0):\n            print('0')\n        else:\n            hi = n - 1\n            lo = 0\n            ans = -1\n            while lo <= hi:\n                j = (lo + hi) // 2\n                if s >= l[j][0] and s < l[j][1]:\n                    print('0')\n                    c = 1\n                    break\n                elif s < l[j][0]:\n                    ans = j\n                    hi = j - 1\n                else:\n                    lo = j + 1\n            if c == 0:\n                print(l[ans][0] - s)", "t = int(input())\nfor co in range(t):\n    l = []\n    (n, m) = list(map(int, input().split()))\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    l.sort()\n    for i in range(m):\n        c = 0\n        s = int(input())\n        if s >= l[-1][1]:\n            print('-1')\n        elif s < l[0][0]:\n            print(l[0][0] - s)\n        elif s > l[-1][0] and s < l[-1][1] and (c == 0):\n            print('0')\n        else:\n            hi = n - 1\n            lo = 0\n            ans = -1\n            while lo <= hi:\n                j = (lo + hi) // 2\n                if s >= l[j][0] and s < l[j][1]:\n                    print('0')\n                    c = 1\n                    break\n                elif s < l[j][0]:\n                    ans = j\n                    hi = j - 1\n                else:\n                    lo = j + 1\n            if c == 0:\n                print(l[ans][0] - s)", "t = int(input())\nfor co in range(t):\n    l = []\n    (n, m) = list(map(int, input().split()))\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    l.sort()\n    for i in range(m):\n        c = 0\n        s = int(input())\n        if s >= l[-1][1]:\n            print('-1')\n        elif s < l[0][0]:\n            print(l[0][0] - s)\n        elif s > l[-1][0] and s < l[-1][1] and (c == 0):\n            print('0')\n        else:\n            hi = n - 1\n            lo = 0\n            ans = -1\n            while lo <= hi:\n                j = (lo + hi) // 2\n                if s >= l[j][0] and s < l[j][1]:\n                    print('0')\n                    c = 1\n                    break\n                elif s < l[j][0]:\n                    ans = j\n                    hi = j - 1\n                else:\n                    lo = j + 1\n            if c == 0:\n                print(l[ans][0] - s)", "t = int(input())\nfor co in range(t):\n    l = []\n    (n, m) = list(map(int, input().split()))\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    l.sort()\n    for i in range(m):\n        c = 0\n        s = int(input())\n        if s >= l[-1][1]:\n            print('-1')\n        elif s < l[0][0]:\n            print(l[0][0] - s)\n        elif s > l[-1][0] and s < l[-1][1] and (c == 0):\n            print('0')\n        else:\n            hi = n - 1\n            lo = 0\n            ans = -1\n            while lo <= hi:\n                j = (lo + hi) // 2\n                if s >= l[j][0] and s < l[j][1]:\n                    print('0')\n                    c = 1\n                    break\n                elif s < l[j][0]:\n                    ans = j\n                    hi = j - 1\n                else:\n                    lo = j + 1\n            if c == 0:\n                print(l[ans][0] - s)", "t = int(input())\nfor co in range(t):\n    l = []\n    (n, m) = list(map(int, input().split()))\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    l.sort()\n    for i in range(m):\n        c = 0\n        s = int(input())\n        if s >= l[-1][1]:\n            print('-1')\n        elif s < l[0][0]:\n            print(l[0][0] - s)\n        elif s > l[-1][0] and s < l[-1][1] and (c == 0):\n            print('0')\n        else:\n            hi = n - 1\n            lo = 0\n            ans = -1\n            while lo <= hi:\n                j = (lo + hi) // 2\n                if s >= l[j][0] and s < l[j][1]:\n                    print('0')\n                    c = 1\n                    break\n                elif s < l[j][0]:\n                    ans = j\n                    hi = j - 1\n                else:\n                    lo = j + 1\n            if c == 0:\n                print(l[ans][0] - s)", "def ChefRes(TimeIntervals, n, m):\n    for i in range(m):\n        x = int(input())\n        start = 0\n        end = 2 * n - 1\n        if x <= TimeIntervals[start]:\n            print(TimeIntervals[start] - x)\n            continue\n        elif x >= TimeIntervals[end]:\n            print(-1)\n            continue\n        else:\n            while start <= end:\n                mid = (start + end) // 2\n                if mid % 2 == 0:\n                    openTime = TimeIntervals[mid]\n                    CloseTime = TimeIntervals[mid + 1]\n                    if x < CloseTime and x >= openTime:\n                        print(0)\n                        break\n                    elif x < openTime and x >= TimeIntervals[mid - 1]:\n                        print(openTime - x)\n                        break\n                    elif x >= CloseTime and x < TimeIntervals[mid + 2]:\n                        print(TimeIntervals[mid + 2] - x)\n                        break\n                    elif x < openTime:\n                        end = mid - 1\n                    else:\n                        start = mid + 2\n                else:\n                    openTime = TimeIntervals[mid - 1]\n                    CloseTime = TimeIntervals[mid]\n                    if x < CloseTime and x >= openTime:\n                        print(0)\n                        break\n                    elif x < openTime and x >= TimeIntervals[mid - 2]:\n                        print(openTime - x)\n                        break\n                    elif x >= CloseTime and x < TimeIntervals[mid + 1]:\n                        print(TimeIntervals[mid + 1] - x)\n                        break\n                    elif x < openTime:\n                        end = mid - 2\n                    else:\n                        start = mid + 1\nt = int(input())\nfor i in range(t):\n    TimeIntervals = list()\n    (n, m) = [int(x) for x in input().split()]\n    for j in range(n):\n        (L, R) = [int(x) for x in input().split()]\n        TimeIntervals.append(L)\n        TimeIntervals.append(R)\n    TimeIntervals.sort()\n    ChefRes(TimeIntervals, n, m)", "def find_index(arr, n, K):\n    start = 0\n    end = n - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] == K:\n            return mid\n        elif arr[mid] < K:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return end + 1\nt = int(input())\nfor test in range(t):\n    (n, m) = map(int, input().split())\n    resT = []\n    l = []\n    p = []\n    for i in range(n):\n        (left, r) = map(int, input().split())\n        resT.append([left, r])\n        l.append(left)\n    for j in range(m):\n        p.append(int(input()))\n    resT.sort()\n    l.sort()\n    for i in range(m):\n        time = p[i]\n        ind = find_index(l, n, time)\n        if ind == 0:\n            if l[ind] == time:\n                print(0)\n            else:\n                print(l[0] - time)\n        elif ind == n:\n            if resT[ind - 1][1] > time:\n                print(0)\n            else:\n                print(-1)\n        elif resT[ind - 1][1] > time:\n            print(0)\n        else:\n            print(l[ind] - time)", "def fun(ar, x):\n    l = 0\n    u = len(ar)\n    an = -1\n    while l <= u:\n        m = (l + u) // 2\n        if m >= len(ar) or m < 0:\n            return an\n        (s, e) = (ar[m][0], ar[m][1])\n        if x >= e:\n            l = m + 1\n        elif e > x:\n            an = m\n            u = m - 1\n    return an\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ar = []\n    for i in range(n):\n        (l, r) = map(int, input().split())\n        ar.append([l, r])\n    ar.sort()\n    for i in range(m):\n        x = int(input())\n        an = fun(ar, x)\n        if an == -1:\n            print(an)\n        elif x >= ar[an][0]:\n            print(0)\n        else:\n            print(ar[an][0] - x)", "def least_greater_than(a, N, key):\n    start = 0\n    end = N\n    ans = -1\n    while end >= start:\n        mid = (start + end) // 2\n        if mid >= N or mid < 0:\n            break\n        elif a[mid][1] <= key:\n            start = mid + 1\n        elif a[mid][1] > key:\n            ans = mid\n            end = mid - 1\n    return ans\nT = int(input())\nans = []\nfor _ in range(T):\n    (N, M) = [int(i) for i in input().split()]\n    L = []\n    R = []\n    P = []\n    A = []\n    for i in range(N):\n        (l, r) = [int(i) for i in input().split()]\n        A.append([l, r])\n    A.sort()\n    for i in range(M):\n        p = int(input())\n        x = least_greater_than(A, N, p)\n        if x == -1:\n            ans.append(-1)\n        elif p >= A[x][0]:\n            ans.append(0)\n        else:\n            ans.append(A[x][0] - p)\nfor i in ans:\n    print(i)", "def binary_search(interval, x):\n    start = 0\n    end = len(interval) - 1\n    while start <= end:\n        mid = start + (end - start) // 2\n        if interval[mid][0] <= x < interval[mid][1]:\n            return mid\n        elif interval[mid][0] > x:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return [start, mid]\nt = int(input())\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    interval = []\n    for i in range(n):\n        (l, r) = map(int, input().split())\n        interval.append([l, r])\n    p = []\n    for i in range(m):\n        p.append(int(input()))\n    interval = sorted(interval, key=lambda x: x[0])\n    for x in p:\n        res = binary_search(interval, x)\n        if isinstance(res, list):\n            (l, r) = res\n            if l >= n:\n                print(-1)\n            else:\n                print(interval[l][0] - x)\n        else:\n            print(0)\n    t -= 1", "def binary_search(interval, x):\n    start = 0\n    end = len(interval) - 1\n    while start <= end:\n        mid = start + (end - start) // 2\n        if interval[mid][0] <= x < interval[mid][1]:\n            return mid\n        elif interval[mid][0] > x:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return [start, mid]\nt = int(input())\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    interval = []\n    for i in range(n):\n        (l, r) = map(int, input().split())\n        interval.append([l, r])\n    p = []\n    for i in range(m):\n        p.append(int(input()))\n    interval = sorted(interval, key=lambda x: x[0])\n    for x in p:\n        res = binary_search(interval, x)\n        if isinstance(res, list):\n            (l, r) = res\n            if l >= n:\n                print(-1)\n            else:\n                print(interval[l][0] - x)\n        else:\n            print(0)\n    t -= 1", "def binary_search(interval, x):\n    (start, end) = (0, len(interval) - 1)\n    while start <= end:\n        mid = (start + end) // 2\n        if interval[mid][0] <= x < interval[mid][1]:\n            return mid\n        elif interval[mid][0] > x:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return [start, mid]\nt = int(input())\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    interval = []\n    for i in range(n):\n        (l, r) = map(int, input().split())\n        interval.append([l, r])\n    p = []\n    for i in range(m):\n        p.append(int(input()))\n    interval = sorted(interval, key=lambda x: x[0])\n    for x in p:\n        wait_time = binary_search(interval, x)\n        if isinstance(wait_time, list):\n            (l, r) = wait_time\n            if l >= n:\n                print(-1)\n            else:\n                print(interval[l][0] - x)\n        else:\n            print(0)\n    t -= 1", "def binary_search(interval, x):\n    (start, end) = (0, len(interval) - 1)\n    while start <= end:\n        mid = (start + end) // 2\n        if interval[mid][0] <= x < interval[mid][1]:\n            return mid\n        elif interval[mid][0] > x:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return [start, mid]\nt = int(input())\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    interval = []\n    for i in range(n):\n        (l, r) = map(int, input().split())\n        interval.append([l, r])\n    p = []\n    for i in range(m):\n        p.append(int(input()))\n    interval = sorted(interval, key=lambda x: x[0])\n    for x in p:\n        wait_time = binary_search(interval, x)\n        if isinstance(wait_time, list):\n            (l, r) = wait_time\n            if l >= n:\n                print(-1)\n            else:\n                print(interval[l][0] - x)\n        else:\n            print(0)\n    t -= 1", "def binary_search(num):\n    start = 0\n    end = n - 1\n    if num < intervals[0][0]:\n        return intervals[0][0] - num\n    elif num >= intervals[-1][1]:\n        return -1\n    elif num < intervals[-1][1] and num >= intervals[-1][0]:\n        return 0\n    while start <= end:\n        mid = (start + end) // 2\n        if num >= intervals[mid][0] and num < intervals[mid][1]:\n            return 0\n        if num < intervals[mid][0]:\n            ans = intervals[mid][0] - num\n            end = mid - 1\n        else:\n            start = mid + 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    intervals = []\n    for _ in range(n):\n        intervals.append(list(map(int, input().split())))\n    intervals = sorted(intervals, key=lambda x: x[0])\n    for _ in range(m):\n        c = int(input())\n        print(binary_search(c))", "from sys import maxsize, stdout, stdin, stderr\nmod = int(1000000000.0 + 7)\n\ndef tup():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\n\ndef lint():\n    return [int(x) for x in stdin.readline().split()]\n\ndef S():\n    return input().strip()\n\ndef grid(r, c):\n    return [lint() for i in range(r)]\n\ndef debug(*args, c=6):\n    print('\\x1b[3{}m'.format(c), *args, '\\x1b[0m', file=stderr)\nfrom bisect import bisect\nfor _ in range(I()):\n    (n, m) = tup()\n    ls = []\n    for i in range(n):\n        ls.extend(lint())\n    ls.sort()\n    for j in range(m):\n        x = I()\n        b = bisect(ls, x)\n        debug(b)\n        if b > len(ls) - 1:\n            print(-1)\n        elif b % 2 == 0:\n            print(abs(x - ls[b]))\n        else:\n            print(0)", "from sys import maxsize, stdout, stdin, stderr\nmod = int(1000000000.0 + 7)\n\ndef tup():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\n\ndef lint():\n    return [int(x) for x in stdin.readline().split()]\n\ndef S():\n    return input().strip()\n\ndef grid(r, c):\n    return [lint() for i in range(r)]\n\ndef debug(*args, c=6):\n    print('\\x1b[3{}m'.format(c), *args, '\\x1b[0m', file=stderr)\nfrom bisect import bisect_right as bisect\nfor _ in range(I()):\n    (n, m) = tup()\n    ls = []\n    for i in range(n):\n        ls.extend(lint())\n    ls.sort()\n    for j in range(m):\n        x = I()\n        b = bisect(ls, x)\n        debug(b)\n        if b > len(ls) - 1:\n            print(-1)\n        elif b % 2 == 0:\n            print(abs(x - ls[b]))\n        else:\n            print(0)", "import bisect\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    l = []\n    r = []\n    for _ in range(n):\n        (a, b) = map(int, input().split())\n        l.append(a)\n        r.append(b)\n    l.sort()\n    r.sort()\n    for j in range(m):\n        item = int(input())\n        a = bisect.bisect(l, item)\n        if a == 0:\n            print(l[0] - item)\n        elif item < r[a - 1]:\n            print(0)\n        elif a != n:\n            print(l[a] - item)\n        else:\n            print(-1)", "def binary_search(num):\n    start = 0\n    end = n - 1\n    if num < intervals[0][0]:\n        return intervals[0][0] - num\n    elif num >= intervals[-1][1]:\n        return -1\n    elif num < intervals[-1][1] and num >= intervals[-1][0]:\n        return 0\n    while start <= end:\n        mid = (start + end) // 2\n        if intervals[mid][0] == num:\n            return 0\n        elif end - start == 1:\n            if intervals[start][0] < num and num < intervals[start][1]:\n                return 0\n            else:\n                return intervals[end][0] - num\n        elif intervals[mid][0] < num:\n            start = mid\n        else:\n            end = mid\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    intervals = []\n    for _ in range(n):\n        intervals.append(list(map(int, input().split())))\n    intervals = sorted(intervals, key=lambda x: x[0])\n    for _ in range(m):\n        c = int(input())\n        print(binary_search(c))", "def binary_search(interval, x):\n    (start, end) = (0, len(interval) - 1)\n    while start <= end:\n        mid = (start + end) // 2\n        if interval[mid][0] <= x < interval[mid][1]:\n            return mid\n        elif interval[mid][0] > x:\n            end = mid - 1\n        elif interval[mid][0] < x:\n            start = mid + 1\n    return [start, end]\nt = int(input())\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    interval = []\n    for i in range(n):\n        (l, r) = map(int, input().split())\n        interval.append([l, r])\n    p = []\n    for i in range(m):\n        p.append(int(input()))\n    interval = sorted(interval, key=lambda x: x[0])\n    for x in p:\n        wait_time = binary_search(interval, x)\n        if isinstance(wait_time, list):\n            (l, r) = wait_time\n            wait_time = -1 if l >= n else interval[l][0] - x\n        else:\n            wait_time = 0\n        print(wait_time)\n    t -= 1", "def binary_search(interval, x):\n    (start, end) = (0, len(interval) - 1)\n    while start <= end:\n        mid = (start + end) // 2\n        if interval[mid][0] <= x < interval[mid][1]:\n            return mid\n        elif interval[mid][0] > x:\n            end = mid - 1\n        elif interval[mid][0] < x:\n            start = mid + 1\n    return [start, end]\nt = int(input())\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    interval = []\n    for i in range(n):\n        (l, r) = map(int, input().split())\n        interval.append([l, r])\n    p = []\n    for i in range(m):\n        p.append(int(input()))\n    interval = sorted(interval, key=lambda x: x[0])\n    for x in p:\n        wait_time = binary_search(interval, x)\n        if isinstance(wait_time, list):\n            (l, r) = wait_time\n            wait_time = -1 if l >= n else interval[l][0] - x\n        else:\n            wait_time = 0\n        print(wait_time)\n    t -= 1", "import bisect\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    l1 = []\n    l2 = []\n    for i in range(n):\n        (l, r) = list(map(int, input().split()))\n        l1.append(l)\n        l2.append(r)\n    l1.sort()\n    l2.sort()\n    for j in range(m):\n        p = int(input())\n        a = bisect.bisect(l1, p)\n        if a == 0:\n            print(l1[0] - p)\n        elif p < l2[a - 1]:\n            print(0)\n        elif a != n:\n            print(l1[a] - p)\n        else:\n            print(-1)", "def binary_search(a, m):\n    start = 0\n    end = len(a) - 1\n    mid = 0\n    while start <= end:\n        mid = (start + end) // 2\n        if m >= a[mid][0] and m < a[mid][1]:\n            return 0\n        elif m == a[mid][1]:\n            if mid == len(a) - 1:\n                return -1\n            else:\n                return a[mid + 1][0] - m\n        elif m < a[mid][0]:\n            end = mid - 1\n        else:\n            start = mid + 1\n    if a[mid][0] > m:\n        return a[mid][0] - m\n    elif mid + 1 == len(a):\n        return -1\n    else:\n        return a[mid + 1][0] - m\nt = int(input())\nwhile t > 0:\n    a = input().split()\n    n = int(a[0])\n    m = int(a[1])\n    a = []\n    for i in range(n):\n        x = input().split()\n        a.append(int(x[0]))\n        a.append(int(x[1]))\n    a.sort()\n    b = []\n    for i in range(1, len(a), 2):\n        b.append([a[i - 1], a[i]])\n    for i in range(m):\n        query = int(input())\n        print(binary_search(b, query))\n    t -= 1", "def binary_search(interval, x):\n    (start, end) = (0, len(interval) - 1)\n    while start <= end:\n        mid = (start + end) // 2\n        if interval[mid][0] <= x < interval[mid][1]:\n            return mid\n        elif interval[mid][0] > x:\n            end = mid - 1\n        elif interval[mid][0] < x:\n            start = mid + 1\n    return [start, end]\nt = int(input())\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    interval = []\n    for i in range(n):\n        (l, r) = map(int, input().split())\n        interval.append([l, r])\n    p = []\n    for i in range(m):\n        p.append(int(input()))\n    interval = sorted(interval, key=lambda x: x[0])\n    for x in p:\n        wait_time = binary_search(interval, x)\n        if isinstance(wait_time, list):\n            (l, r) = wait_time\n            wait_time = -1 if l >= n else interval[l][0] - x\n        else:\n            wait_time = 0\n        print(wait_time)\n    t -= 1", "def bSearch(i, j, arr, x):\n    ans = -1\n    while i <= j:\n        mid = (i + j) // 2\n        if x < arr[mid][1]:\n            if arr[mid][0] <= x:\n                ans = 0\n                return ans\n            else:\n                ans = arr[mid][0] - x\n                j = mid - 1\n        else:\n            i = mid + 1\n    return ans\n\ndef solve():\n    (n, m) = list(map(int, input().split()))\n    arr = []\n    for _ in range(n):\n        temp = list(map(int, input().split()))\n        arr.append(temp)\n    arr.sort()\n    for i in range(m):\n        x = int(input())\n        print(bSearch(0, n - 1, arr, x))\nt = int(input())\nwhile t != 0:\n    solve()\n    t -= 1", "def binarySearch(time, data):\n    i = 0\n    j = len(time) - 1\n    while i <= j:\n        m = (i + j) // 2\n        if time[m][0] < data:\n            i = m + 1\n        elif time[m][0] > data:\n            j = m - 1\n        else:\n            return m\n    return j\ntest = int(input())\nfor _ in range(test):\n    (n, m) = map(int, input().split())\n    time = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        time.append(temp)\n    time = sorted(time, key=lambda item: item[0])\n    for i in range(m):\n        data = int(input())\n        if data < time[0][0]:\n            print(time[0][0] - data)\n        else:\n            index = binarySearch(time, data)\n            if time[index][1] > data:\n                print(0)\n            elif index < n - 1:\n                print(time[index + 1][0] - data)\n            else:\n                print(-1)"]