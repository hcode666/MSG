["from collections import *\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    susjedi = defaultdict(list)\n    for i in range(n):\n        s = input()\n        for j in range(n):\n            if abs(i - j) <= k and s[j] == '1' and (i != j):\n                susjedi[i].append(j)\n\n    def bfs(x):\n        udaljenost = [-1] * n\n        udaljenost[x] = 0\n        q = deque()\n        q.append(x)\n        while len(q) > 0:\n            x = q.popleft()\n            for y in susjedi[x]:\n                if udaljenost[y] == -1:\n                    udaljenost[y] = udaljenost[x] + 1\n                    q.append(y)\n        return udaljenost[n - 1]\n    print(bfs(0))", "from collections import *\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    susjedi = defaultdict(list)\n    for i in range(n):\n        s = input()\n        for j in range(n):\n            if abs(i - j) <= k and s[j] == '1' and (i != j):\n                susjedi[i].append(j)\n\n    def bfs(x):\n        udaljenost = [-1] * n\n        udaljenost[x] = 0\n        q = deque()\n        q.append(x)\n        while len(q) > 0:\n            x = q.popleft()\n            for y in susjedi[x]:\n                if udaljenost[y] == -1:\n                    udaljenost[y] = udaljenost[x] + 1\n                    q.append(y)\n        return udaljenost[n - 1]\n    print(bfs(0))", "from collections import *\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    susjedi = defaultdict(list)\n    for i in range(n):\n        s = input()\n        for j in range(n):\n            if abs(i - j) <= k and s[j] == '1' and (i != j):\n                susjedi[i].append(j)\n\n    def bfs(x):\n        udaljenost = [-1] * n\n        udaljenost[x] = 0\n        q = deque()\n        q.append(x)\n        while len(q) > 0:\n            x = q.popleft()\n            for y in susjedi[x]:\n                if udaljenost[y] == -1:\n                    udaljenost[y] = udaljenost[x] + 1\n                    q.append(y)\n        return udaljenost[n - 1]\n    print(bfs(0))", "from collections import deque\n\ndef shortest_path(n, k, s):\n    visited = [False] * n\n    q = deque()\n    visited[0] = True\n    q.append((0, 0))\n    while len(q) > 0:\n        node = q.popleft()\n        if node[0] == n - 1:\n            return node[1]\n        for i in range(n):\n            if abs(i - node[0]) <= k and (not visited[i]) and (s[node[0]][i] == '1'):\n                q.append((i, node[1] + 1))\n                visited[i] = True\n    return -1\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = [input().strip() for _ in range(n)]\n    print(shortest_path(n, k, s))", "from collections import deque\n\ndef shortest_path(n, k, s):\n    visited = [False] * n\n    q = deque()\n    visited[0] = True\n    q.append((0, 0))\n    while len(q) > 0:\n        node = q.popleft()\n        if node[0] == n - 1:\n            return node[1]\n        for i in range(n):\n            if abs(i - node[0]) <= k and (not visited[i]) and (s[node[0]][i] == '1'):\n                q.append((i, node[1] + 1))\n                visited[i] = True\n    return -1\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = [input().strip() for _ in range(n)]\n    print(shortest_path(n, k, s))", "from heapq import heapify, heappush, heappop\nT = int(input())\nfor i in range(T):\n    (n, k) = map(int, input().split())\n    graph = [[] for i in range(n + 1)]\n    m = 2 * 10 ** 3\n    dis = [m] * (n + 1)\n    dis[1] = 0\n    h = [True] * (n + 1)\n    for i in range(n):\n        s = input()\n        for j in range(n):\n            if s[j] == '1' and abs(i - j) <= k and (i != j):\n                graph[i + 1].append(j + 1)\n    x = 1\n    p = 1\n    while p <= n:\n        h[x] = False\n        for i in graph[x]:\n            if h[i]:\n                if dis[x] + 1 < dis[i]:\n                    dis[i] = dis[x] + 1\n        mm = m\n        for i in range(n):\n            if h[i]:\n                if dis[i] <= mm:\n                    mm = dis[i]\n                    x = i\n        p += 1\n    if dis[n] != m:\n        print(dis[n])\n    else:\n        print(-1)", "from heapq import heapify, heappush, heappop\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = [[] for i in range(n + 1)]\n    m = 2 * 10 ** 3\n    dis = [m] * (n + 1)\n    dis[1] = 0\n    h = [True] * (n + 1)\n    for i in range(n):\n        s = input()\n        for j in range(n):\n            if s[j] == '1' and abs(i - j) <= k and (i != j):\n                graph[i + 1].append(j + 1)\n    x = 1\n    p = 1\n    while p <= n:\n        h[x] = False\n        for i in graph[x]:\n            if h[i]:\n                if dis[x] + 1 < dis[i]:\n                    dis[i] = dis[x] + 1\n        mm = m\n        for i in range(n):\n            if h[i]:\n                if dis[i] <= mm:\n                    mm = dis[i]\n                    x = i\n        p += 1\n    if dis[n] != m:\n        print(dis[n])\n    else:\n        print(-1)", "from heapq import heapify, heappush, heappop\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = [[] for i in range(n + 1)]\n    m = 2 * 10 ** 3\n    dis = [m] * (n + 1)\n    dis[1] = 0\n    h = [True] * (n + 1)\n    for i in range(n):\n        s = input()\n        for j in range(n):\n            if s[j] == '1' and abs(i - j) <= k and (i != j):\n                graph[i + 1].append(j + 1)\n    x = 1\n    p = 1\n    while p <= n:\n        h[x] = False\n        for i in graph[x]:\n            if h[i]:\n                if dis[x] + 1 < dis[i]:\n                    dis[i] = dis[x] + 1\n        mm = m\n        for i in range(n):\n            if h[i]:\n                if dis[i] <= mm:\n                    mm = dis[i]\n                    x = i\n        p += 1\n    if dis[n] != m:\n        print(dis[n])\n    else:\n        print(-1)", "from collections import deque\n\ndef bfs(start, graph):\n    visited = {start}\n    explored = set()\n    levels = {start: 0}\n    queue = deque([])\n    queue.append(start)\n    while len(queue) > 0:\n        x = queue.popleft()\n        explored.add(x)\n        if x not in graph:\n            continue\n        for i in graph[x]:\n            if i not in visited:\n                visited.add(i)\n                queue.append(i)\n                levels[i] = levels[x] + 1\n    return levels\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(0)\n        continue\n    d = {}\n    for i in range(1, n + 1):\n        s = input()\n        j = 0\n        while j < n:\n            x = s[j]\n            if x == '1':\n                r = abs(j + 1 - i)\n                if r != 0 and r <= k:\n                    if i in d:\n                        a = d[i]\n                        a.append(j + 1)\n                    else:\n                        d[i] = [j + 1]\n            j = j + 1\n        if i in d:\n            continue\n        else:\n            d[i] = []\n    v = bfs(1, d)\n    if n in v:\n        print(v[n])\n    else:\n        print(-1)", "from collections import deque\n\ndef bfs(n, k, S):\n    vis = [False] * n\n    q = deque()\n    vis[0] = True\n    q.append((0, 0))\n    while len(q) > 0:\n        node = q.popleft()\n        if node[0] == n - 1:\n            return node[1]\n        for i in range(n):\n            if abs(i - node[0]) <= k and (not vis[i]) and (S[node[0]][i] == '1'):\n                q.append((i, node[1] + 1))\n                vis[i] = True\n    return -1\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    S = [input().strip() for _ in range(n)]\n    print(bfs(n, k, S))", "def bfs(start, S, N, K):\n    q = [start]\n    distances = [0 for i in range(N)]\n    visited = [False for i in range(N)]\n    visited[start] = True\n    while len(q) != 0:\n        x = q.pop(0)\n        for i in range(N):\n            if S[x][i] == '1' and visited[i] == False and (abs(x - i) <= K):\n                q.append(i)\n                distances[i] = distances[x] + 1\n                visited[i] = True\n    if visited[N - 1]:\n        return distances[N - 1]\n    else:\n        return -1\nT = int(input())\nans = []\nfor _ in range(T):\n    (N, K) = [int(i) for i in input().split()]\n    S = []\n    for i in range(N):\n        s = input()\n        S.append(s)\n    ans.append(bfs(0, S, N, K))\nfor i in ans:\n    print(i)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    graph = [[] for i in range(n)]\n    for i in range(n):\n        s = input()\n        r1 = max(0, i - k)\n        r2 = min(n - 1, i + k)\n        for j in range(r1, r2 + 1):\n            if j != i and s[j] == '1':\n                graph[i].append(j)\n    visited = set()\n    curr = 0\n    queue = []\n    queue.append(0)\n    jumps = [-1] * n\n    jumps[0] = 0\n    f = 0\n    while queue:\n        curr = queue.pop(0)\n        for g in graph[curr]:\n            if g not in visited:\n                visited.add(g)\n                queue.append(g)\n                jumps[g] = jumps[curr] + 1\n                if g == n - 1:\n                    f = 1\n                    break\n        if f == 1:\n            break\n    print(jumps[-1])", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    from collections import defaultdict\n    graph = defaultdict(set)\n    for i in range(1, n + 1):\n        lis = list(input())\n        lis = [int(a) for a in lis]\n        tovis = set()\n        for (ind, num) in enumerate(lis):\n            if num == 1:\n                tovis.add(ind + 1)\n        for j in range(1, k + 1):\n            if i + j in tovis:\n                graph[i].add(i + j)\n            if i - j in tovis:\n                graph[i].add(i - j)\n    dist = defaultdict(int)\n    dist[1] = 0\n    from queue import Queue\n    q = Queue()\n    q.put(1)\n    vis = set()\n    while not q.empty():\n        cur = q.get()\n        if n in graph[cur]:\n            dist[n] = dist[cur] + 1\n            break\n        for neigh in graph[cur]:\n            if neigh not in vis:\n                vis.add(neigh)\n                dist[neigh] = dist[cur] + 1\n                q.put(neigh)\n        if q.empty():\n            dist[n] = -1\n    print(dist[n])", "def abs(i, j):\n    if i > j:\n        return i - j\n    else:\n        return j - i\n\nclass vertex:\n\n    def __init__(self, col, dis):\n        self.color = col\n        self.d = dis\ntest_cases = int(input())\nfor _ in range(test_cases):\n    (n, max_jump) = map(int, input().split())\n    V = []\n    Adj = {}\n    for i in range(n):\n        V.append(vertex('white', -1))\n        Adj[V[i]] = []\n    for i in range(n):\n        s = input()\n        for j in range(i):\n            if s[j] == '1' and abs(i, j) <= max_jump:\n                Adj[V[i]].append(V[j])\n        for j in range(i + 1, n):\n            if s[j] == '1' and abs(i, j) <= max_jump:\n                Adj[V[i]].append(V[j])\n    source_vertex = V[0]\n    source_vertex.color = 'grey'\n    source_vertex.d = 0\n    Q = [source_vertex]\n    front = 0\n    while front != len(Q):\n        dequed_vertex = Q[front]\n        front += 1\n        for x in Adj[dequed_vertex]:\n            if x.color == 'white':\n                x.d = dequed_vertex.d + 1\n                x.color = 'grey'\n                Q.append(x)\n        dequed_vertex.color = 'black'\n    print(V[n - 1].d)", "def abs(i, j):\n    if i > j:\n        return i - j\n    else:\n        return j - i\n\nclass vertex:\n\n    def __init__(self, col, dis, pi, n):\n        self.color = col\n        self.d = dis\n        self.parent = pi\n        self.number = n\ntest_cases = int(input())\nfor _ in range(test_cases):\n    (n, max_jump) = map(int, input().split())\n    V = []\n    Adj = {}\n    for i in range(n):\n        V.append(vertex('white', -1, None, i))\n        Adj[V[i]] = []\n    for i in range(n):\n        s = input()\n        for j in range(i):\n            if s[j] == '1' and abs(i, j) <= max_jump:\n                Adj[V[i]].append(V[j])\n        for j in range(i + 1, n):\n            if s[j] == '1' and abs(i, j) <= max_jump:\n                Adj[V[i]].append(V[j])\n    source_vertex = V[0]\n    source_vertex.color = 'grey'\n    source_vertex.d = 0\n    Q = [source_vertex]\n    front = 0\n    while front != len(Q):\n        dequed_vertex = Q[front]\n        front += 1\n        for x in Adj[dequed_vertex]:\n            if x.color == 'white':\n                x.d = dequed_vertex.d + 1\n                x.parent = dequed_vertex\n                x.color = 'grey'\n                Q.append(x)\n        dequed_vertex.color = 'black'\n    print(V[n - 1].d)", "from collections import deque\ntest = int(input())\nfor _ in range(test):\n    (n, k) = [int(i) for i in input().split()]\n    s = []\n    for i in range(n):\n        s.append(input())\n    graph = [[] for i in range(n)]\n    for i in range(len(s)):\n        for j in range(max(0, i - k), min(n - 1, i + k) + 1):\n            if s[i][j] == '1' and j != i:\n                graph[i].append(j)\n    curr = 0\n    dist = [-1] * n\n    dist[0] = 0\n    q = deque()\n    q.append(0)\n    temp = 0\n    vis = [0] * n\n    while len(q) > 0:\n        curr = q.popleft()\n        for i in graph[curr]:\n            if vis[i] == 1:\n                continue\n            vis[i] = 1\n            q.append(i)\n            dist[i] = dist[curr] + 1\n            if i == n - 1:\n                temp = 1\n                break\n        if temp == 1:\n            break\n    print(dist[n - 1])", "from collections import deque\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    s = []\n    for i in range(n):\n        s.append(input())\n    graph = [[] for i in range(n)]\n    for i in range(len(s)):\n        for j in range(max(0, i - k), min(n - 1, i + k) + 1):\n            if s[i][j] == '1' and j != i:\n                graph[i].append(j)\n    curr = 0\n    dist = [-1] * n\n    dist[0] = 0\n    q = deque()\n    q.append(0)\n    temp = 0\n    vis = [0] * n\n    while len(q) > 0:\n        curr = q.popleft()\n        for i in graph[curr]:\n            if vis[i] == 1:\n                continue\n            vis[i] = 1\n            q.append(i)\n            dist[i] = dist[curr] + 1\n            if i == n - 1:\n                temp = 1\n                break\n        if temp == 1:\n            break\n    print(dist[n - 1])", "from collections import deque\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, k) = map(int, input().split())\n    temp = []\n    graph = {}\n    for i in range(n):\n        graph[i] = set()\n    ans = 0\n    for i in range(n):\n        s = input()\n        if i == 0 and s[0] == '0':\n            ans = -1\n            break\n        prev = max(0, i - k)\n        forw = min(n - 1, i + k)\n        for j in range(prev, forw + 1):\n            if j == i:\n                continue\n            if s[j] == '1':\n                graph[i].add(j)\n    if ans == -1:\n        print(ans)\n        continue\n    visited = set([0])\n    q = deque([(0, 0)])\n    flag = False\n    while len(q) > 0:\n        (curr, depth) = q.popleft()\n        for item in graph[curr]:\n            if item not in visited:\n                q.append((item, depth + 1))\n                visited.add(item)\n        if curr == n - 1:\n            flag = True\n            ans = depth\n            break\n    if flag:\n        print(ans)\n    else:\n        print(-1)", "import queue\n\ndef minEdgeBFS(edges, v, n):\n    visited = [0] * n\n    distance = [-1] * n\n    Q = queue.Queue()\n    distance[0] = 0\n    Q.put(0)\n    visited[0] = True\n    while not Q.empty():\n        x = Q.get()\n        for i in range(len(edges[x])):\n            if visited[edges[x][i]]:\n                continue\n            distance[edges[x][i]] = distance[x] + 1\n            Q.put(edges[x][i])\n            visited[edges[x][i]] = 1\n    return distance[v]\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    S = []\n    for i in range(N):\n        S.append(input())\n    graph = [[] for i in range(N)]\n    for i in range(N):\n        a = S[i]\n        for j in range(max(0, i - K), min(N, i + K + 1)):\n            if a[j] == '1' and i != j:\n                graph[i].append(j)\n    p = minEdgeBFS(graph, N - 1, N)\n    print(p)", "def solve(occ, n, k):\n    u = 0\n    queue = [u]\n    dist = [0] * n\n    enc = [True] + [False] * (n - 1)\n    while len(queue):\n        u = queue.pop(0)\n        for i in occ[u]:\n            if enc[i] == False and abs(i - u) <= k:\n                enc[i] = True\n                dist[i] = dist[u] + 1\n                queue.append(i)\n                if i == n - 1:\n                    return dist[i]\n    return -1\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    occ = []\n    for i in range(n):\n        s1 = input()\n        occ.append([])\n        for j in range(n):\n            if int(s1[j]) == 1:\n                occ[i].append(j)\n    jump = solve(occ, n, k)\n    print(jump)", "def solve(occ, n, k):\n    u = 0\n    queue = [u]\n    dist = [0] * n\n    enc = [True] + [False] * (n - 1)\n    while len(queue):\n        u = queue.pop(0)\n        for i in occ[u]:\n            if enc[i] == False and abs(i - u) <= k:\n                enc[i] = True\n                dist[i] = dist[u] + 1\n                queue.append(i)\n                if i == n - 1:\n                    return dist[i]\n    return -1\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    occ = []\n    for i in range(n):\n        s1 = input()\n        occ.append([])\n        for j in range(n):\n            if int(s1[j]) == 1:\n                occ[i].append(j)\n    jump = solve(occ, n, k)\n    print(jump)", "def createList(V, s):\n    for i in range(1, V + 1):\n        s[i] = []\n\ndef addEdge(x, y):\n    s[x].append(y)\n\ndef BFS(s, node, queue, visited, dist, pred):\n    visited[node] = 1\n    dist[node] = 0\n    queue.append(node)\n    while queue != []:\n        v = queue.pop(0)\n        for i in s[v]:\n            if visited[i] == 0:\n                visited[i] = 1\n                pred[i] = v\n                dist[i] = dist[pred[i]] + 1\n                queue.append(i)\n\ndef SSSP(source, dest, path, pred):\n    if pred[dest] == -1:\n        print(-1)\n        return 0\n    else:\n        while dest != source:\n            path.append(dest)\n            dest = pred[dest]\n        path.append(source)\n        return 1\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    V = n\n    s = {}\n    createList(V, s)\n    queue = []\n    visited = [0] * (V + 1)\n    dist = [-1] * (V + 1)\n    pred = [-1] * (V + 1)\n    path = []\n    for i in range(n):\n        string = input()\n        length = len(string)\n        j = i + 1\n        while abs(j - i) <= k and j < length:\n            if string[j] == '1':\n                addEdge(i + 1, j + 1)\n            j += 1\n        j = i - 1\n        while abs(j - i) <= k and j >= 0:\n            if string[j] == '1':\n                addEdge(i + 1, j + 1)\n            j -= 1\n    BFS(s, 1, queue, visited, dist, pred)\n    if SSSP(1, n, path, pred):\n        print(len(path) - 1)", "def bfs_connected_component(graph, start):\n    explored = []\n    queue = [start]\n    levels = {}\n    levels[start] = 0\n    visited = [start]\n    while queue:\n        node = queue.pop(0)\n        explored.append(node)\n        neighbours = graph[node]\n        for neighbour in neighbours:\n            if neighbour not in visited:\n                queue.append(neighbour)\n                visited.append(neighbour)\n                levels[neighbour] = levels[node] + 1\n    return levels\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(0)\n        continue\n    d = {}\n    for i in range(1, n + 1):\n        s = input()\n        j = 0\n        while j < n:\n            x = s[j]\n            if x == '1':\n                r = abs(j + 1 - i)\n                if r != 0 and r <= k:\n                    if i in d:\n                        a = d[i]\n                        a.append(j + 1)\n                    else:\n                        d[i] = [j + 1]\n            j = j + 1\n        if i in d:\n            continue\n        else:\n            d[i] = []\n    v = bfs_connected_component(d, 1)\n    if n in v:\n        print(v[n])\n    else:\n        print(-1)", "def bfs_connected_component(graph, start):\n    explored = []\n    queue = [start]\n    levels = {}\n    levels[start] = 0\n    visited = [start]\n    while queue:\n        node = queue.pop(0)\n        explored.append(node)\n        neighbours = graph[node]\n        for neighbour in neighbours:\n            if neighbour not in visited:\n                queue.append(neighbour)\n                visited.append(neighbour)\n                levels[neighbour] = levels[node] + 1\n    return levels\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(0)\n        continue\n    d = {}\n    for i in range(1, n + 1):\n        s = input()\n        j = 0\n        while j < n:\n            x = s[j]\n            if x == '1':\n                r = abs(j + 1 - i)\n                if r != 0 and r <= k:\n                    if i in d:\n                        a = d[i]\n                        a.append(j + 1)\n                    else:\n                        d[i] = [j + 1]\n            j = j + 1\n        if i in d:\n            continue\n        else:\n            d[i] = []\n    v = bfs_connected_component(d, 1)\n    if n in v:\n        print(v[n])\n    else:\n        print(-1)", "from collections import defaultdict\n\nclass graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addedge(self, u, v):\n        self.graph[u].append(v)\n\n    def bfs(self, strt):\n        global moves, flag, count\n        flag = 0\n        l = []\n        visited = [False for i in range(n)]\n        queue = []\n        queue.append((strt, 0))\n        visited[strt] = True\n        while len(queue):\n            strt = queue.pop(0)\n            for i in self.graph[strt[0]]:\n                if visited[i] == False:\n                    queue.append((i, strt[1] + 1))\n                    l.append((i, strt[1] + 1))\n                    visited[i] = True\n        return l\nt = int(input())\nfor tt in range(t):\n    (n, k) = map(int, input().split())\n    adj_mat = []\n    for i in range(n):\n        adj_mat.append(list(input()))\n    g = graph()\n    for i in range(n):\n        for j in range(max(i - k, 0), min(n, i + k + 1)):\n            if adj_mat[i][j] == '1' and i != j and (abs(j - i) <= k):\n                g.addedge(i, j)\n    count = -1\n    for i in g.bfs(0):\n        if i[0] == n - 1:\n            count = i[1]\n            break\n    print(count)", "def sssp_bfs(graph, visited, root, dest):\n    queue = [root]\n    flag = True\n    visited[root] = 0\n    parent[root] = -1\n    distance[root] = 0\n    while len(queue):\n        node = queue.pop(0)\n        for i in graph[node]:\n            if i not in visited:\n                visited[i] = 0\n                parent[i] = node\n                distance[i] = distance[node] + 1\n                queue.append(i)\n                if i == dest:\n                    flag = False\n        if not flag:\n            break\n    if flag:\n        return -1\n    else:\n        return distance[dest]\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    naksha = {}\n    for i in range(n):\n        naksha[i + 1] = []\n    for i in range(n):\n        path = input()\n        if i - k <= 0:\n            start = 0\n        else:\n            start = i - k\n        if i + k >= n - 1:\n            end = n\n        else:\n            end = i + k + 1\n        for j in range(start, end):\n            if path[j] == '1':\n                naksha[i + 1].append(j + 1)\n    visited = {}\n    parent = {}\n    distance = {}\n    print(sssp_bfs(naksha, visited, 1, n))", "t = int(input())\n\ndef BFS(gra, s, n):\n    visited = [False for i in range(n)]\n    distance = [float('inf') for i in range(n)]\n    queue = [s]\n    distance[s] = 0\n    visited[s] = True\n    while queue:\n        u = queue.pop(0)\n        for v in range(max(0, u - k - 1), min(n, u + k + 1)):\n            if gra[u][v] and visited[v] == False:\n                queue.append(v)\n                distance[v] = min(distance[v], distance[u] + 1)\n                visited[v] = True\n    return distance[n - 1]\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    gra = [[0 for j in range(n)] for i in range(n)]\n    for i in range(n):\n        s = input()\n        for j in range(n):\n            gra[i][j] = int(s[j])\n    Min = BFS(gra, 0, n)\n    if Min == float('inf'):\n        print(-1)\n    else:\n        print(Min)", "from collections import defaultdict\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def shortestDist(self, s, d):\n        visited = [False] * (d + 1)\n        dist = [-1] * (d + 1)\n        queue = []\n        visited[s] = True\n        queue.append(s)\n        dist[s] = 0\n        while queue:\n            s = queue.pop(0)\n            for i in self.graph[s]:\n                if not visited[i]:\n                    queue.append(i)\n                    dist[i] = dist[s] + 1\n                    visited[i] = True\n                    if i == d:\n                        return dist[d]\n        return -1\nt = int(input())\nwhile t:\n    g = Graph()\n    (n, k) = map(int, input().split())\n    for i in range(n):\n        s = input()\n        for j in range(i + 1, i + k + 1):\n            if j > n - 1:\n                break\n            if s[j] == '1':\n                g.addEdge(i, j)\n        for j in range(i - 1, i - k - 1, -1):\n            if j < 0:\n                break\n            if s[j] == '1':\n                g.addEdge(i, j)\n    print(g.shortestDist(0, n - 1))\n    t -= 1", "from queue import Queue\n\ndef chef(n, k, arr):\n    que = Queue()\n    que.put(1)\n    dp = [100000000] * (n + 1)\n    vis = [0] * (n + 1)\n    dp[1] = 0\n    while not que.empty():\n        node = que.get()\n        j = node + 1\n        while j <= n and j - node <= k:\n            if arr[node - 1][j - 1] == '1' and dp[j] > dp[node] + 1 and (vis[j] != 1):\n                dp[j] = dp[node] + 1\n                que.put(j)\n            j += 1\n        j = node - 1\n        while j > 0 and node - j <= k:\n            if arr[node - 1][j - 1] == '1' and dp[j] > dp[node] + 1 and (vis[j] != 1):\n                dp[j] = dp[node] + 1\n                que.put(j)\n            j -= 1\n        vis[node] = 1\n    if dp[-1] == 100000000:\n        return -1\n    else:\n        return dp[-1]\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        arr.append(input())\n    print(chef(n, k, arr))", "from queue import Queue\n\ndef chef(n, k, arr):\n    que = Queue()\n    que.put(1)\n    dp = [100000000] * (n + 1)\n    vis = [0] * (n + 1)\n    dp[1] = 0\n    while not que.empty():\n        node = que.get()\n        j = node + 1\n        while j <= n and j - node <= k:\n            if arr[node - 1][j - 1] == '1' and dp[j] > dp[node] + 1 and (vis[j] != 1):\n                dp[j] = dp[node] + 1\n                que.put(j)\n            j += 1\n        j = node - 1\n        while j > 0 and node - j <= k:\n            if arr[node - 1][j - 1] == '1' and dp[j] > dp[node] + 1 and (vis[j] != 1):\n                dp[j] = dp[node] + 1\n                que.put(j)\n            j -= 1\n        vis[node] = 1\n    if dp[-1] == 100000000:\n        return -1\n    else:\n        return dp[-1]\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        arr.append(input())\n    print(chef(n, k, arr))", "T = int(input())\nfor i in range(T):\n    (N, K) = map(int, input().strip().split())\n    edges = []\n    for i in range(N):\n        A = input().strip()\n        edges.append(A)\n    visited = [0] * N\n    Q1 = [0]\n    count = -1\n    while Q1 != []:\n        Q2 = Q1\n        Q1 = []\n        count = count + 1\n        if visited[N - 1] == 1:\n            break\n        while Q2 != []:\n            cur = Q2.pop(0)\n            start = max(0, cur - K)\n            end = min(N - 1, cur + K)\n            for j in range(start, end + 1):\n                if j == cur:\n                    continue\n                if edges[cur][j] == '1':\n                    if visited[j] == 0:\n                        Q1.append(j)\n                        visited[j] = 1\n                        if j == N - 1:\n                            break\n    if visited[N - 1] == 1:\n        print(count)\n    else:\n        print(-1)", "from collections import deque\n\ndef constructGraph(graph, switches, k):\n    for i in range(0, n):\n        curr = i\n        switch = switches[i]\n        lower = -1\n        upper = -1\n        if curr - k < 0:\n            lower = 0\n        else:\n            lower = curr - k\n        if curr + k > n - 1:\n            upper = n - 1\n        else:\n            upper = curr + k\n        for j in range(lower, upper + 1):\n            if switch[j] == '1':\n                graph[i + 1].append(j + 1)\n\ndef valid(curr, nxt, visited, minDist, graph):\n    for v in graph[curr]:\n        if not visited[v - 1] and v != curr:\n            nxt.append(v)\n            visited[v - 1] = True\n            minDist[v - 1] = minDist[curr - 1] + 1\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    switches = []\n    for __ in range(n):\n        switches.append(input())\n    graph = {}\n    for ii in range(n):\n        graph[ii + 1] = []\n    constructGraph(graph, switches, k)\n    nxt = deque([1])\n    minDist = [0] * n\n    visited = [False] * n\n    while nxt:\n        curr = nxt.popleft()\n        valid(curr, nxt, visited, minDist, graph)\n    res = minDist[-1]\n    if res == 0:\n        print(-1)\n    else:\n        print(res)", "def steps(n, k, s):\n    q = []\n    v = [0] * n\n    d = [100000] * n\n    q.append(0)\n    d[0] = 0\n    v[0] = 1\n    dist = 0\n    while len(q) != 0:\n        i = q[0]\n        q.pop(0)\n        t = 1\n        while t <= k:\n            if i + t in range(0, n):\n                if s[i][i + t] == '1' and v[i + t] == 0 and (d[i] + 1 < d[i + t]):\n                    v[i + t] = 1\n                    d[i + t] = d[i] + 1\n                    q.append(i + t)\n            if i - t in range(0, n):\n                if s[i][i - t] == '1' and v[i - t] == 0 and (d[i] + 1 < d[i - t]):\n                    v[i - t] = 1\n                    d[i - t] = d[i] + 1\n                    q.append(i - t)\n            t += 1\n    if d[-1] == 100000:\n        return -1\n    else:\n        return d[-1]\nfor _ in range(int(input())):\n    (N, K) = list(map(int, input().split()))\n    switch = []\n    for o in range(N):\n        switch.append(input())\n    print(steps(N, K, switch))", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    lis = []\n    ans = [9999999] * n\n    for __ in range(n):\n        lis.append(input())\n    ans[0] = 0\n    possible = [0]\n    covered = []\n    i = 0\n    while len(possible) != 0:\n        i = possible[0]\n        del possible[0]\n        if i in covered:\n            continue\n        covered.append(i)\n        item = lis[i]\n        start = max(0, i - k)\n        end = min(i + k + 1, n)\n        for j in range(start, end):\n            if item[j] == '1' and j != i:\n                h = min(ans[i] + 1, ans[j])\n                ans[j] = h\n                possible.append(j)\n    if ans[n - 1] == 9999999:\n        print(-1)\n    else:\n        print(ans[n - 1])", "def solve(graph, src, dest, v, k):\n    res = BFS(graph, src, dest, v, k)\n    return res\n\ndef BFS(graph, src, dest, v, k):\n    queue = []\n    visited = [False] * v\n    dist = [float('inf')] * v\n    pred = [-1] * v\n    visited[src] = True\n    dist[src] = 0\n    queue.append(src)\n    while queue:\n        u = queue.pop(0)\n        for i in graph[u]:\n            if visited[i] == False and abs(i - u) <= k:\n                visited[i] = True\n                dist[i] = dist[u] + 1\n                pred[i] = u\n                queue.append(i)\n                if i == dest:\n                    return dist[i]\n    return -1\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = []\n    for i in range(n):\n        s = input()\n        for j in range(len(s)):\n            graph.append([])\n            if s[j] == '1':\n                graph[i].append(j)\n    res = solve(graph, 0, n - 1, n, k)\n    print(res)", "def solve(graph, src, dest, v, k):\n    res = BFS(graph, src, dest, v, k)\n    return res\n\ndef BFS(graph, src, dest, v, k):\n    queue = []\n    visited = [False] * v\n    dist = [float('inf')] * v\n    pred = [-1] * v\n    visited[src] = True\n    dist[src] = 0\n    queue.append(src)\n    while queue:\n        u = queue.pop(0)\n        for i in graph[u]:\n            if visited[i] == False and abs(i - u) <= k:\n                visited[i] = True\n                dist[i] = dist[u] + 1\n                pred[i] = u\n                queue.append(i)\n                if i == dest:\n                    return dist[i]\n    return -1\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = []\n    for i in range(n):\n        s = input()\n        for j in range(len(s)):\n            graph.append([])\n            if s[j] == '1':\n                graph[i].append(j)\n    res = solve(graph, 0, n - 1, n, k)\n    print(res)", "def solve(graph, src, dest, v, k):\n    res = BFS(graph, src, dest, v, k)\n    return res\n\ndef BFS(graph, src, dest, v, k):\n    queue = []\n    visited = [False] * v\n    dist = [float('inf')] * v\n    pred = [-1] * v\n    visited[src] = True\n    dist[src] = 0\n    queue.append(src)\n    while queue:\n        u = queue.pop(0)\n        for i in graph[u]:\n            if visited[i] == False and abs(i - u) <= k:\n                visited[i] = True\n                dist[i] = dist[u] + 1\n                pred[i] = u\n                queue.append(i)\n                if i == dest:\n                    return dist[i]\n    return -1\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = []\n    for i in range(n):\n        s = input()\n        for j in range(len(s)):\n            graph.append([])\n            if s[j] == '1':\n                graph[i].append(j)\n    res = solve(graph, 0, n - 1, n, k)\n    print(res)", "import sys\n\ndef bfs(graph, n):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[0] = 0\n    q = [0]\n    while q:\n        u = q.pop(0)\n        for i in graph[u]:\n            if visited[i] == False and abs(i - u) <= k:\n                visited[i] = True\n                if i == u:\n                    continue\n                dist[i] = min(dist[u] + 1, dist[i])\n                q.append(i)\n                if i == n - 1:\n                    return dist[n - 1]\n    return -1\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = []\n    for i in range(n):\n        s = sys.stdin.readline()\n        temp = []\n        for j in range(n):\n            if s[j] == '1' and j != i:\n                temp.append(j)\n        graph.append(temp)\n    ans = bfs(graph, n)\n    print(ans)", "import sys\n\ndef bfs(graph, n):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[0] = 0\n    q = [0]\n    while q:\n        u = q.pop(0)\n        for i in graph[u]:\n            if visited[i] == False and abs(i - u) <= k:\n                visited[i] = True\n                dist[i] = dist[u] + 1\n                q.append(i)\n                if i == n - 1:\n                    return dist[n - 1]\n    return -1\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = []\n    for i in range(n):\n        s = sys.stdin.readline()\n        temp = []\n        for j in range(n):\n            if s[j] == '1' and j != i:\n                temp.append(j)\n        graph.append(temp)\n    ans = bfs(graph, n)\n    print(ans)", "import queue\nimport math\nimport sys\n\ndef bfs(adj, s, d, dist, n):\n    q = queue.Queue(maxsize=n)\n    vis = [False for i in range(n)]\n    vis[s] = True\n    dist[s] = 0\n    q.put(s)\n    while not q.empty():\n        u = q.get()\n        for j in adj[u]:\n            if vis[j] == False:\n                vis[j] = True\n                dist[j] = dist[u] + 1\n                q.put(j)\n                if j == d:\n                    return True\n    return False\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = []\n    for i in range(n):\n        s = input()\n        l.append(s)\n    adj = [[] for i in range(n)]\n    dist = [sys.maxsize for i in range(n)]\n    sptSet = [False for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if abs(j - i) <= k:\n                if l[i][j] == '1':\n                    adj[i].append(j)\n    if bfs(adj, 0, n - 1, dist, n):\n        print(dist[n - 1])\n    else:\n        print(-1)", "def convert(s, c, b):\n    l = []\n    ini = max(0, c - b - 1)\n    fin = min(len(s), c + b)\n    for x in range(ini, fin):\n        if s[x] == '1':\n            if x == c - 1:\n                continue\n            else:\n                l.append(x + 1)\n    return l\n\ndef bfs(graph, start, end):\n    (visited, queue) = (set(), [start])\n    dist = [0 for i in range(end + 1)]\n    c = 0\n    flag = 0\n    dist[start] = 0\n    visited.add(start)\n    while queue:\n        vertex = queue.pop(0)\n        for i in graph[vertex]:\n            if i not in visited:\n                visited.add(i)\n                dist[i] = dist[vertex] + 1\n                queue.append(i)\n                if i == end:\n                    return (dist[end], True)\n    return (0, False)\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    d = {}\n    c = 1\n    for x in range(a):\n        s = input()\n        d[c] = convert(s, c, b)\n        c += 1\n    (q, w) = bfs(d, 1, a)\n    if w:\n        print(q)\n    else:\n        print(-1)", "from collections import defaultdict\nfrom os import system\nimport sys\nsystem('cls')\n\nclass graph:\n\n    def __init__(self, totNode):\n        self.base = defaultdict(list)\n        self.nodes = totNode\n\n    def addEdge(self, parent, child):\n        self.base[parent].append(child)\n\n    def printGraph(self):\n        print(self.base)\n\n    def bfs(self, sourse):\n        dp = [sys.maxsize] * (self.nodes + 1)\n        visited = [False] * (self.nodes + 1)\n        queue = [sourse]\n        dp[sourse] = 0\n        while queue:\n            dq = queue.pop(0)\n            visited[dq] = True\n            for i in self.base[dq]:\n                if visited[i] == False:\n                    queue.append(i)\n                    dp[i] = dp[dq] + 1\n                    visited[i] = True\n                elif dp[i] > dp[dq] + 1:\n                    dp[i] = dp[dq] + 1\n        if dp[self.nodes] == sys.maxsize:\n            return -1\n        else:\n            return dp[self.nodes]\nfor _ in range(int(input())):\n    (N, K) = list(map(int, input().split()))\n    tree = graph(N)\n    for __ in range(N):\n        xx = input()\n        for i in range(len(xx)):\n            if xx[i] == '1':\n                if i != __:\n                    if abs(i - __) <= K:\n                        tree.addEdge(__ + 1, i + 1)\n    print(tree.bfs(1))", "import queue\n\ndef solve_under_the_tunnels(adjacency, end):\n    r = bfs(adjacency, 0, end)\n    (traversal, origin, ans) = (r[0], r[1], 0)\n    if end not in traversal or 0 not in traversal:\n        print('-1')\n    elif len(traversal) == 1:\n        print('0')\n    else:\n        traverser = traversal.index(end)\n        while traverser != 0:\n            traverser = traversal.index(origin[traverser])\n            ans += 1\n        print(ans)\n\ndef bfs(adjacency, start, end):\n    (st, visited, origin, flag) = (queue.Queue(), [start], [start], 1)\n    st.put(start)\n    while not st.empty():\n        process = st.get()\n        for i in range(len(adjacency[process])):\n            if adjacency[process][i] and i not in visited:\n                visited.append(i)\n                st.put(i)\n                origin.append(process)\n        if end in visited:\n            break\n    return [visited, origin]\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    adjacency = []\n    for _ in range(n):\n        s = str(input())\n        adjacency.append([int(s[i]) if abs(len(adjacency) - i) <= k else 0 for i in range(len(s))])\n    solve_under_the_tunnels(adjacency, n - 1)", "import asyncio\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list()\n    for i in range(n):\n        a.append(input())\n    c = []\n    for i in range(n):\n        b = []\n        for j in range(n):\n            if j >= i - k and j <= i + k:\n                b.append(a[i][j])\n            else:\n                b.append('0')\n        c.append(b)\n    src = 0\n    q = []\n    q.append(src)\n    dist = [0] * n\n    dist[src] = 0\n    visited = [0] * n\n    visited[src] = 1\n    while len(q) != 0:\n        u = q.pop(0)\n        for v in range(n):\n            if c[u][v] == '1' and visited[v] == 0:\n                q.append(v)\n                visited[v] = 1\n                dist[v] = dist[u] + 1\n    if dist[n - 1] == 0:\n        print('-1')\n    else:\n        print(dist[n - 1])", "t = int(input())\nwhile t > 0:\n    (n, k) = list(map(int, input().split()))\n    st = []\n    for i in range(n):\n        st.append(input())\n    q = [0]\n    dist = [-1] * n\n    while len(q) > 0:\n        pos = q.pop(0)\n        for i in range(max(0, pos - k), min(n, pos + k + 1)):\n            if st[pos][i] == '1' and dist[i] == -1:\n                q.append(i)\n                dist[i] = dist[pos] + 1\n    print(dist[n - 1])\n    t -= 1", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    lis = []\n    ans = [9999999] * n\n    for __ in range(n):\n        lis.append(input())\n    ans[0] = 0\n    possible = [0]\n    covered = []\n    i = 0\n    while len(possible) != 0:\n        i = possible[0]\n        del possible[0]\n        if i in covered:\n            continue\n        covered.append(i)\n        item = lis[i]\n        start = max(0, i - k)\n        end = min(i + k + 1, n)\n        for j in range(start, end):\n            if item[j] == '1' and j != i:\n                h = min(ans[i] + 1, ans[j])\n                ans[j] = h\n                possible.append(j)\n    if ans[n - 1] == 9999999:\n        print(-1)\n    else:\n        print(ans[n - 1])", "def BFS(graph, src, dest, n, k):\n    queue = []\n    visited = [False] * n\n    dist = [float('inf')] * n\n    queue.append(src)\n    visited[src] = True\n    dist[src] = 0\n    while queue:\n        i = queue.pop(0)\n        for j in graph[i]:\n            if visited[j] != True and abs(i - j) <= k:\n                visited[j] = True\n                queue.append(j)\n                dist[j] = dist[i] + 1\n                if j == dest:\n                    return dist[j]\n    return -1\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    graph = []\n    for i in range(n):\n        graph.append([])\n        s = input()\n        for j in range(len(s)):\n            if s[j] == '1':\n                graph[i].append(j)\n    ans = BFS(graph, 0, n - 1, n, k)\n    print(ans)", "from collections import deque\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    lst = []\n    for i in range(n):\n        lst.append(input())\n    begin = (0, 0)\n    dq = deque()\n    dq.append(begin)\n    visit = [-1] * n\n    visit[0] = 0\n    flag = False\n    while len(dq):\n        (a, b) = dq.pop()\n        for i in range(n):\n            if lst[a][i] == '1' and abs(a - i) <= k and (visit[i] > b + 1 or visit[i] == -1):\n                dq.append((i, b + 1))\n                visit[i] = b + 1\n    print(visit[n - 1])", "path = {1: 0}\n\ndef BFS_short_path(l, fr0m, t0):\n    q = []\n    dic = {}\n    q.append(fr0m)\n    boo = False\n    dic[fr0m] = 0\n    while len(q) != 0:\n        s = q.pop(0)\n        for j in l[s]:\n            if j not in dic.keys():\n                q.append(j)\n                dic[j] = dic[s] + 1\n                if j == t0:\n                    boo = True\n        if boo:\n            break\n    c = dic[t0] if t0 in dic.keys() else -1\n    print(c)\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    dic = {}\n    for i in range(1, n + 1):\n        a = input()\n        t = []\n        for j in range(i - k, i + k + 1):\n            if j < 1 or j > n:\n                continue\n            if a[j - 1] == '1':\n                t.append(j)\n        dic[i] = t\n    BFS_short_path(dic, 1, n)", "path = {1: 0}\n\ndef BFS_short_path(l, fr0m, t0):\n    q = []\n    dic = {}\n    q.append(fr0m)\n    boo = False\n    dic[fr0m] = 0\n    while len(q) != 0:\n        s = q.pop(0)\n        for j in l[s]:\n            if j not in dic.keys():\n                q.append(j)\n                dic[j] = dic[s] + 1\n                if j == t0:\n                    boo = True\n        if boo:\n            break\n    c = dic[n] if n in dic.keys() else -1\n    print(c)\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    dic = {}\n    for i in range(1, n + 1):\n        a = input()\n        t = []\n        for j in range(i - k, i + k + 1):\n            if j < 1 or j > n:\n                continue\n            if a[j - 1] == '1':\n                t.append(j)\n        dic[i] = t\n    BFS_short_path(dic, 1, n)", "path = {1: 0}\n\ndef DFS(l, n):\n    q = []\n    dic = {}\n    q.append(1)\n    path = []\n    ans = 0\n    boo = False\n    dic[1] = 0\n    while len(q) != 0:\n        ans = 0\n        path = []\n        s = q.pop(0)\n        if s == n:\n            boo = True\n            break\n        for j in l[s]:\n            ans += 1\n            path.append(j)\n            if j not in dic.keys():\n                q.append(j)\n                dic[j] = dic[s] + 1\n                if j == n:\n                    boo = True\n        if boo:\n            break\n    c = dic[n] if n in dic.keys() else -1\n    print(c)\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    dic = {}\n    for i in range(1, n + 1):\n        a = input()\n        t = []\n        for j in range(i - k, i + k + 1):\n            if j < 1 or j > n:\n                continue\n            if a[j - 1] == '1':\n                t.append(j)\n        dic[i] = t\n    DFS(dic, n)", "def neighbours(a):\n    list1 = []\n    for i in range(n):\n        if adj[a][i] == 1:\n            list1.append(i)\n    return list1\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    steps = [0] * n\n    for i in range(n):\n        steps[i] = input()\n    adj = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            elif abs(i - j) > k:\n                continue\n            elif steps[i][j] == '1':\n                adj[i][j] = 1\n    dis = [-1] * n\n    dis[0] = 0\n    queue = []\n    queue.append(0)\n    while len(queue) != 0:\n        node = queue.pop(0)\n        for i in neighbours(node):\n            if dis[i] == -1:\n                dis[i] = dis[node] + 1\n                queue.append(i)\n    print(dis[-1])", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = []\n    for i in range(n):\n        l.append(input())\n    g = defaultdict(list)\n    for i in range(n):\n        for j in range(max(0, i - k), min(n, i + k + 1)):\n            if i != j and l[i][j] == '1':\n                g[i].append(j)\n    vis = [0] * n\n    dist = [0] * n\n    q = [0]\n    vis[0] = 1\n    while q:\n        no = q[0]\n        del q[0]\n        for i in g[no]:\n            if vis[i] == 0:\n                q.append(i)\n                vis[i] = 1\n                dist[i] = dist[no] + 1\n    if dist[n - 1] == 0:\n        print('-1')\n    else:\n        print(dist[n - 1])", "from collections import defaultdict, deque\n\ndef addEdge(graph, u, v):\n    graph[u].append(v)\n\ndef generate_edges(graph):\n    edges = []\n    for node in graph:\n        for neighbour in graph[node]:\n            edges.append((node, neighbour))\n    return edges\n\ndef bfs2(graph, start, goal):\n    if start == goal:\n        return [start]\n    visited = {start}\n    queue = deque([(start, [])])\n    while queue:\n        (current, path) = queue.popleft()\n        visited.add(current)\n        for neighbor in graph[current]:\n            if neighbor == goal:\n                return path + [current, neighbor]\n            if neighbor in visited:\n                continue\n            queue.append((neighbor, path + [current]))\n            visited.add(neighbor)\n    return None\nt = int(input())\nfor _ in range(t):\n    graph = defaultdict(list)\n    (n, k) = map(int, input().split())\n    for i in range(n):\n        string = input()\n        for j in range(1, k + 1):\n            if i + j < n:\n                if string[i + j] == '1':\n                    addEdge(graph, i, i + j)\n            if i - j >= 0:\n                if string[i - j] == '1':\n                    addEdge(graph, i, i - j)\n    path = bfs2(graph, 0, n - 1)\n    if path:\n        print(len(path) - 1)\n    else:\n        print(-1)", "from collections import deque\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split(' '))\n    A = [[] for i in range(N)]\n    for i in range(N):\n        S = input()\n        for j in range(max(0, i - K), min(N, i + K + 1)):\n            if S[j] == '1':\n                A[i].append(j)\n    myqueue = deque()\n    myqueue.append(0)\n    dis = [-1 for i in range(N)]\n    dis[0] = 0\n    mark = [-1 for i in range(N)]\n    mark[0] = 1\n    while len(myqueue) != 0:\n        x = myqueue.popleft()\n        for i in A[x]:\n            if mark[i] == -1:\n                mark[i] = 1\n                dis[i] = dis[x] + 1\n                myqueue.append(i)\n            if i == N - 1:\n                myqueue = []\n                break\n        else:\n            continue\n    print(dis[N - 1])", "min = [10000000]\ndp = []\n\ndef dfs(graph, x, count, dp):\n    if x == N - 1:\n        if min[0] > count:\n            min[0] = count\n        return\n    else:\n        count += 1\n        dp[x] = 1\n        for i in graph[x]:\n            if dp[i] == 0:\n                dfs(graph, i, count, dp[:])\n\ndef BFS(graph, src, dest, v, k):\n    queue = []\n    visited = [False] * v\n    dist = [float('inf')] * v\n    pred = [-1] * v\n    visited[src] = True\n    dist[src] = 0\n    queue.append(src)\n    while queue:\n        u = queue.pop(0)\n        for i in graph[u]:\n            if visited[i] == False and abs(i - u) <= k:\n                visited[i] = True\n                dist[i] = dist[u] + 1\n                pred[i] = u\n                queue.append(i)\n                if i == dest:\n                    return dist[i]\n    return -1\nt = int(input())\nfor _ in range(t):\n    (N, K) = map(int, input().split())\n    S = []\n    min = [10000000]\n    dp = [0] * N\n    graph = list(map(lambda x: [], [i for i in range(N)]))\n    for i in range(N):\n        s = input()\n        j = i - 1\n        while i - j <= K and j >= 0:\n            if s[j] == '1':\n                graph[i].append(j)\n            j -= 1\n        j = i + 1\n        while abs(i - j) <= K and abs(j) < N:\n            if s[j] == '1':\n                graph[i].append(j)\n            j += 1\n    print(BFS(graph, 0, N - 1, N, K))", "from collections import deque\nT = int(input())\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    S = []\n    for i in range(N):\n        S.append(input())\n    jumps = [0] * N\n    queue = deque()\n    queue.append(0)\n    while len(queue) > 0:\n        i = queue.popleft()\n        for k in range(1, K + 1):\n            j = i + k\n            if j < N and S[i][j] == '1':\n                if jumps[j] == 0 or jumps[j] > jumps[i] + 1:\n                    jumps[j] = jumps[i] + 1\n                    queue.append(j)\n            j = i - k\n            if j >= 0 and S[i][j] == '1':\n                if jumps[j] == 0 or jumps[j] > jumps[i] + 1:\n                    jumps[j] = jumps[i] + 1\n                    queue.append(j)\n    if jumps[N - 1] == 0:\n        print(-1)\n    else:\n        print(jumps[N - 1])", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    S = [input() for _ in range(N)]\n    J = 0\n    Q = {0}\n    X = N - 1\n    V = [1] + [0] * X\n    while Q:\n        if X in Q:\n            print(J)\n            break\n        W = set()\n        J += 1\n        for P in Q:\n            for I in range(max(0, P - K), min(P + K + 1, N)):\n                if not V[I]:\n                    if S[P][I] == '1':\n                        W.add(I)\n                        V[I] = 1\n        Q = W\n    else:\n        print(-1)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    S = [input() for _ in range(N)]\n    J = 0\n    Q = {0}\n    X = N - 1\n    V = [True] + [False] * X\n    while len(Q) > 0:\n        if X in Q:\n            print(J)\n            break\n        W = set()\n        J += 1\n        for P in Q:\n            for I in range(max(0, P - K), min(P + K + 1, N)):\n                if not V[I]:\n                    if S[P][I] == '1':\n                        W.add(I)\n                        V[I] = True\n        Q = W\n    else:\n        print(-1)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    S = [input() for _ in range(N)]\n    J = 0\n    Q = [0]\n    V = [True] + [False] * (N - 1)\n    while len(Q) > 0:\n        if N - 1 in Q:\n            print(J)\n            break\n        W = []\n        J += 1\n        for P in Q:\n            for I in range(max(0, P - K), min(P + K + 1, N)):\n                if S[P][I] == '1' and (not V[I]):\n                    W += (I,)\n                    V[I] = True\n        Q = W\n    else:\n        print(-1)", "t = int(input())\nfor _ in range(t):\n    (n, k) = list(map(int, input().split()))\n    a = []\n    for _ in range(n):\n        a.append(list(input()))\n    visited = [False] * n\n    q = []\n    q.append(0)\n    visited[0] = True\n    mapp = {}\n    mapp[0] = 0\n    while len(q) != 0:\n        front = q[0]\n        for i in range(front + 1, min(front + k, n - 1) + 1):\n            if not visited[i] and a[front][i] == '1':\n                visited[i] = True\n                q.append(i)\n                mapp[i] = mapp[front] + 1\n        for i in range(max(front - k, 0), front):\n            if not visited[i] and a[front][i] == '1':\n                visited[i] = True\n                q.append(i)\n                mapp[i] = mapp[front] + 1\n        if visited[n - 1]:\n            break\n        q.pop(0)\n    if visited[n - 1]:\n        print(mapp[n - 1])\n    else:\n        print(-1)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    S = [input() for _ in range(N)]\n    J = 0\n    Q = [0]\n    V = [False] + [True] * (N - 1)\n    while len(Q) > 0:\n        if N - 1 in Q:\n            print(J)\n            break\n        W = []\n        J += 1\n        for P in Q:\n            for I in range(max(0, P - K), min(P + K + 1, N)):\n                if V[I] and S[P][I] == '1':\n                    W += (I,)\n                    V[I] = False\n        Q = W\n    else:\n        print(-1)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    S = [input() for I in range(N)]\n    J = 0\n    Q = [0]\n    V = [False] + [True] * (N - 1)\n    while len(Q) > 0:\n        if N - 1 in Q:\n            print(J)\n            break\n        W = []\n        J += 1\n        for P in Q:\n            for I in range(max(0, P - K), min(P + K + 1, N)):\n                if V[I]:\n                    if S[P][I] == '1':\n                        W += (I,)\n                        V[I] = False\n        Q = W\n    else:\n        print(-1)", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().strip().split())\n    arr = []\n    for i in range(n):\n        arr.append(input())\n    adj_list = []\n    for i in range(n):\n        temp = []\n        adj_list.append(temp)\n    for i in range(n):\n        for j in range(i - k, i + k + 1):\n            if j >= 0 and j < n:\n                if arr[i][j] == '1' and i != j:\n                    adj_list[i].append(j)\n    visited = [False] * n\n    raj = deque()\n    raj.append(0)\n    flg = 0\n    while len(raj) != 0:\n        x = raj.popleft()\n        if x == n - 1:\n            flg = 1\n            break\n        for i in adj_list[x]:\n            if visited[i] == False:\n                raj.append(i)\n                visited[i] = True\n    if flg == 0:\n        print(-1)\n    else:\n        visited = [False] * n\n        raj = deque()\n        raj.append((0, 0))\n        flg = 0\n        while len(raj) != 0:\n            x = raj.popleft()\n            if x[0] == n - 1:\n                flg = x\n                break\n            for i in adj_list[x[0]]:\n                if visited[i] == False:\n                    raj.append((i, x[1] + 1))\n                    visited[i] = True\n        print(flg[1])", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    S = []\n    for I in range(N):\n        S += (input(),)\n    F = []\n    for I in range(N):\n        Z = []\n        for J in range(I - K, I + K + 1):\n            if -1 < J < N:\n                if I != J and S[I][J] == '1':\n                    Z += (J,)\n        F += (Z,)\n    X = [False] * N\n    X[0] = True\n    J = 0\n    Y = [0]\n    while len(Y) > 0:\n        if N - 1 in Y:\n            print(J)\n            break\n        Q = []\n        J += 1\n        for V in Y:\n            for L in F[V]:\n                if not X[L]:\n                    Q.append(L)\n                    X[L] = True\n        Y = Q\n    else:\n        print(-1)", "t = int(input())\nfrom collections import defaultdict\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def BFS(self, s):\n        visited = [False] * len(self.graph)\n        queue = []\n        queue.append((s, 0))\n        visited[s] = True\n        l = []\n        while queue:\n            s = queue.pop(0)\n            for i in self.graph[s[0]]:\n                if visited[i] == False:\n                    queue.append((i, s[1] + 1))\n                    l.append((i, s[1] + 1))\n                    visited[i] = True\n        return l\nfor _ in range(t):\n    g = Graph()\n    (n, k) = list(map(int, input().rstrip().split()))\n    for i in range(n):\n        s = input()\n        for j in range(max(0, i - k), min(n, i + k + 1)):\n            if s[j] == '1':\n                g.addEdge(i, j)\n    count = -1\n    for i in g.BFS(0):\n        if i[0] == n - 1:\n            count = i[1]\n            break\n    print(count)", "t = int(input())\nfor _ in range(t):\n    str = []\n    (n, k) = [int(i) for i in input().split(' ')]\n    arr = [[] for j in range(n)]\n    for i in range(n):\n        str = input()\n        for j in range(max(i - k, 0), min(n, i + k + 1)):\n            if str[j] == '1':\n                arr[i].append(j)\n    dist = [100000000 for i in range(n)]\n    dist[0] = 0\n    list = [0]\n    check = True\n    while len(list) > 0:\n        for j in arr[list[0]]:\n            if dist[j] == 100000000:\n                dist[j] = dist[list[0]] + 1\n                list.append(j)\n                if j == n - 1:\n                    check = False\n        list = list[1:]\n    if dist[n - 1] == 100000000:\n        dist[n - 1] = -1\n    print(dist[n - 1])", "t = int(input())\nfor _ in range(t):\n    str = []\n    (n, k) = [int(i) for i in input().split(' ')]\n    arr = [[] for j in range(n)]\n    for i in range(n):\n        str = input()\n        for j in range(max(i - k, 0), min(n, i + k + 1)):\n            if str[j] == '1':\n                arr[i].append(j)\n    dist = [100000000 for i in range(n)]\n    dist[0] = 0\n    list = [0]\n    check = True\n    while len(list) > 0:\n        for j in arr[list[0]]:\n            if dist[j] == 100000000:\n                dist[j] = dist[list[0]] + 1\n                list.append(j)\n                if j == n - 1:\n                    check = False\n        list = list[1:]\n    if dist[n - 1] == 100000000:\n        dist[n - 1] = -1\n    print(dist[n - 1])", "t = input()\nt = int(t)\nfor i in range(0, t):\n    (n, k) = [int(e) for e in input().split(' ')]\n    switch_array = []\n    adjaceny_list = []\n    for j in range(0, n):\n        switch_array.append(input())\n        j_adj_list = []\n        for l in range(max(j - k, 0), min(j + k, n - 1) + 1):\n            if l != j and switch_array[j][l] == '1':\n                j_adj_list.append(l)\n        adjaceny_list.append(j_adj_list)\n    bfs_queue = []\n    if n - 1 == 0:\n        print(0)\n    else:\n        bfs_queue.append([0, 0])\n        visited_dict = {}\n        result = -1\n        while len(bfs_queue) > 0 and result == -1:\n            curr_node = bfs_queue.pop(0)\n            if curr_node[0] not in visited_dict:\n                visited_dict[curr_node[0]] = 1\n                for adj_node in adjaceny_list[curr_node[0]]:\n                    if adj_node not in visited_dict:\n                        if adj_node == n - 1:\n                            result = curr_node[1] + 1\n                            break\n                        bfs_queue.append([adj_node, curr_node[1] + 1])\n        print(result)", "from collections import deque\nmm = 100000000000\nt = int(input())\n\ndef mind(dis, vis):\n    mi = mm\n    mii = -1\n    for i in range(n):\n        if dis[i] < mi and vis[i] == -1:\n            mi = dis[i]\n            mii = i\n    return mii\nwhile t:\n    l = []\n    (n, k) = map(int, input().split())\n    for i in range(n):\n        ll = list(map(int, input().strip()))\n        l.append(ll)\n    dis = [mm] * n\n    dis[0] = 0\n    q = deque([0])\n    while q:\n        u = q.pop()\n        for i in range(n):\n            if abs(u - i) <= k and l[u][i]:\n                if dis[i] > 1 + dis[u]:\n                    dis[i] = 1 + dis[u]\n                    q.appendleft(i)\n    if dis[n - 1] == mm:\n        print(-1)\n    else:\n        print(dis[n - 1])\n    t -= 1", "class Graph:\n\n    def __init__(self):\n        self.graph = dict()\n\n    def addEdge(self, arr, n):\n        for i in range(0, n):\n            for j in range(0, n):\n                if arr[i][j] == '1':\n                    if i in self.graph.keys():\n                        self.graph[i].append(j)\n                    else:\n                        self.graph[i] = [j]\n\n    def dfs(self, n, k):\n        queue = []\n        src = 0\n        visited = [0 for i in range(n)]\n        queue.append(src)\n        visited[src] = 1\n        dist = [0] * n\n        while len(queue) != 0:\n            ele = queue.pop(0)\n            for nei in self.graph[ele]:\n                if visited[nei] == 0 and nei - ele <= k:\n                    queue.append(nei)\n                    dist[nei] = dist[ele] + 1\n                    visited[nei] = 1\n        return dist[n - 1]\ntest = int(input())\nwhile test != 0:\n    (n, k) = map(int, input().split())\n    arr = []\n    temp = n\n    while temp != 0:\n        str1 = input()\n        b = list(str1)\n        arr.append(b)\n        temp -= 1\n    obj = Graph()\n    obj.addEdge(arr, n)\n    ans = obj.dfs(n, k)\n    if ans == 0:\n        print(-1)\n    else:\n        print(ans)\n    test -= 1", "class Graph:\n\n    def __init__(self):\n        self.graph = dict()\n\n    def addEdge(self, arr, n):\n        for i in range(0, n):\n            for j in range(0, n):\n                if arr[i][j] == '1':\n                    if i in self.graph.keys():\n                        self.graph[i].append(j)\n                    else:\n                        self.graph[i] = [j]\n\n    def dfs(self, n, k):\n        queue = []\n        src = 0\n        visited = [0 for i in range(n)]\n        queue.append(src)\n        visited[src] = 1\n        dist = [0] * n\n        while len(queue) != 0:\n            ele = queue.pop(0)\n            for nei in self.graph[ele]:\n                if visited[nei] == 0 and nei - ele <= k:\n                    queue.append(nei)\n                    dist[nei] = dist[ele] + 1\n                    visited[nei] = 1\n        return dist[n - 1]\ntest = int(input())\nwhile test != 0:\n    (n, k) = map(int, input().split())\n    arr = []\n    temp = n\n    while temp != 0:\n        str1 = input()\n        b = list(str1)\n        arr.append(b)\n        temp -= 1\n    obj = Graph()\n    obj.addEdge(arr, n)\n    ans = obj.dfs(n, k)\n    if ans == 0:\n        print(-1)\n    else:\n        print(ans)\n    test -= 1", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    m = {}\n    for i in range(n):\n        s = list(input())\n        m[i] = []\n        for j in range(len(s)):\n            if i != j:\n                if s[j] == '1':\n                    m[i].append(j)\n    queue = []\n    queue.append(0)\n    visited = [False] * n\n    visited[0] = True\n    dist = [float('inf')] * n\n    dist[0] = 0\n    flag = 0\n    while queue:\n        ele = queue.pop(0)\n        data = m.get(ele)\n        for i in data:\n            if visited[i] == False and abs(i - ele) <= k:\n                visited[i] = True\n                dist[i] = dist[ele] + 1\n                queue.append(i)\n                if i == n - 1:\n                    flag = 1\n                    break\n    if flag == 0:\n        print(-1)\n    else:\n        print(dist[-1])", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    f = float('inf')\n    dp = [f] * n\n    dp[0] = 0\n    vis = [0] * n\n    q = [0]\n    s = []\n    for i in range(n):\n        t = input()\n        s.append(t)\n    while len(q) > 0:\n        curr = q.pop(0)\n        if vis[curr] == 1:\n            continue\n        for i in range(max(curr - k, 0), min(n, curr + k + 1)):\n            if i == curr:\n                continue\n            elif s[curr][i] == '1' and vis[i] == 0:\n                dp[i] = min(dp[i], dp[curr] + 1)\n                q.append(i)\n        vis[curr] = 1\n    if dp[-1] == f:\n        dp[-1] = -1\n    print(dp[-1])", "from collections import deque\n\ndef main():\n    t = int(input())\n    for __ in range(t):\n        (N, K) = map(int, input().split())\n        path = {}\n        for i in range(1, N + 1):\n            path[i] = []\n        i = 1\n        while i <= N:\n            s = input()\n            for j in range(1, N + 1):\n                if s[j - 1] == '1':\n                    path[i].append(j)\n            i += 1\n        print(bfs(path, K, N))\n\ndef bfs(path, K, N):\n    visited = [False] * N\n    dist = {}\n    dist[1] = 0\n    q = deque()\n    parent = 1\n    q.append((1, path[1]))\n    visited[0] = True\n    while q:\n        (parent, v) = q[0]\n        q.popleft()\n        for i in v:\n            if i == N and N - parent <= K:\n                return dist[parent] + 1\n            elif abs(i - parent) <= K and (not visited[i - 1]):\n                q.append((i, path[i]))\n                visited[i - 1] = True\n                dist[i] = dist[parent] + 1\n    return -1\nmain()", "import sys\nfrom collections import defaultdict, Counter\n\ndef input():\n    return sys.stdin.readline()\n\ndef mapi():\n    return map(int, input().split())\n\ndef print(arg, *argv, end=None):\n    sys.stdout.write(str(arg))\n    for i in argv:\n        sys.stdout.write(' ' + str(i))\n    sys.stdout.write(end) if end else sys.stdout.write('\\n')\n\ndef solve():\n    t = 1\n    t = int(input())\n    while t:\n        t -= 1\n        (n, k) = mapi()\n        g = defaultdict(list)\n        for i in range(n):\n            s = input()\n            for j in range(n):\n                if s[j] == '1' and abs(i - j) <= k:\n                    g[i].append(j)\n        q = []\n        vis = {}\n        q.append(0)\n        vis[0] = 1\n        while len(q) != 0:\n            tmp = q.pop(0)\n            for item in g[tmp]:\n                if item not in vis:\n                    vis[item] = vis[tmp] + 1\n                    q.append(item)\n                    if item == n - 1:\n                        q = []\n                        break\n        if n - 1 not in vis:\n            print(-1)\n        else:\n            print(vis[n - 1] - 1)\nsolve()", "from queue import Queue\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = {}\n    visited = [False] * (n + 1)\n    distance = [-1] * (n + 1)\n    distance[1] = 0\n    visited[1] = True\n    q = Queue()\n    q.put(1)\n    for i in range(1, n + 1):\n        graph[i] = []\n    for i in range(1, n + 1):\n        s = input()\n        st = max(0, i - k - 1)\n        end = min(n, i + k)\n        for x in range(st, end):\n            if s[x] == '1':\n                graph[i].append(x + 1)\n    while q.empty() == False:\n        u = q.get()\n        for i in graph[u]:\n            if visited[i] == False:\n                visited[i] = True\n                distance[i] = distance[u] + 1\n                q.put(i)\n    print(distance[n])", "def solve(graph, src, dest, v, k):\n    res = BFS(graph, src, dest, v, k)\n    return res\n\ndef BFS(graph, src, dest, v, k):\n    queue = []\n    visited = [False] * v\n    dist = [float('inf')] * v\n    pred = [-1] * v\n    visited[src] = True\n    dist[src] = 0\n    queue.append(src)\n    while queue:\n        u = queue.pop(0)\n        for i in graph[u]:\n            if visited[i] == False and abs(i - u) <= k:\n                visited[i] = True\n                dist[i] = dist[u] + 1\n                pred[i] = u\n                queue.append(i)\n                if i == dest:\n                    return dist[i]\n    return -1\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    graph = []\n    for i in range(n):\n        s = input()\n        for j in range(len(s)):\n            graph.append([])\n            if s[j] == '1':\n                graph[i].append(j)\n    res = solve(graph, 0, n - 1, n, k)\n    print(res)", "t = int(input())\nfrom collections import defaultdict\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def BFS(self, s):\n        visited = [False] * len(self.graph)\n        queue = []\n        queue.append((s, 0))\n        visited[s] = True\n        l = []\n        while queue:\n            s = queue.pop(0)\n            for i in self.graph[s[0]]:\n                if visited[i] == False:\n                    queue.append((i, s[1] + 1))\n                    l.append((i, s[1] + 1))\n                    visited[i] = True\n        return l\nfor _ in range(t):\n    g = Graph()\n    (n, k) = list(map(int, input().rstrip().split()))\n    for i in range(n):\n        s = input()\n        for j in range(max(0, i - k), min(n, i + k + 1)):\n            if s[j] == '1':\n                g.addEdge(i, j)\n    count = -1\n    for i in g.BFS(0):\n        if i[0] == n - 1:\n            count = i[1]\n            break\n    print(count)", "T = int(input())\nwhile T > 0:\n    (N, K) = map(int, input().split())\n    l = []\n    for _ in range(N):\n        S = input()\n        l.append(S)\n    d = [0 for i in range(N)]\n    stack = []\n    visited = [False for i in range(N)]\n    stack.append(0)\n    while stack != []:\n        i = stack.pop()\n        j = max(0, i - K)\n        while j < N and j <= i + K:\n            if i == j:\n                j += 1\n                continue\n            elif l[i][j] == '1' and d[j] != 0:\n                if d[j] > d[i] + 1:\n                    stack.append(j)\n                d[j] = min(d[j], d[i] + 1)\n            elif l[i][j] == '1' and d[j] == 0:\n                visited[j] == True\n                d[j] = d[i] + 1\n                stack.append(j)\n            j += 1\n    if d[-1] == 0:\n        print(-1)\n    else:\n        print(d[-1])\n    T -= 1", "import sys\nsys.setrecursionlimit(100000)\n\ndef fun(ans, k, stack):\n    if len(stack) == 0:\n        return ans\n    i = stack.pop()\n    st = max(i - k, 0)\n    end = min(n - 1, i + k)\n    for j in range(st, end + 1):\n        if s[j][i] == '1' and i != j:\n            if ans[j] > ans[i] + 1:\n                stack.append(j)\n                ans[j] = min(ans[j], ans[i] + 1)\n    return fun(ans, k, stack)\nfor t in range(int(input())):\n    (n, k) = [int(j) for j in input().split()]\n    s = []\n    for i in range(n):\n        s.append(input())\n    ans = [10 ** 10] * (n - 1)\n    ans.append(0)\n    ans = fun(ans, k, [n - 1])\n    if ans[0] != 10 ** 10:\n        print(ans[0])\n    else:\n        print(-1)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = []\n    for _ in range(n):\n        s.append(input())\n    depth = 0\n    visited = []\n    if s[-1][n - 1] == '1':\n        oldctiles = [n - 1]\n        while True:\n            newctiles = []\n            depth += 1\n            for step in range(1, k + 1):\n                for ctile in set(oldctiles):\n                    visited.append(ctile)\n                    if ctile - step >= 0:\n                        if s[ctile - step][ctile - step] == '1' and s[ctile - step][ctile] == '1':\n                            tile = ctile - step\n                            newctiles.append(tile)\n                        else:\n                            pass\n                    if ctile + step <= n - 1:\n                        if s[ctile + step][ctile + step] == '1' and s[ctile + step][ctile] == '1':\n                            tile = ctile + step\n                            newctiles.append(tile)\n                        else:\n                            pass\n            if 0 in newctiles:\n                print(depth)\n                break\n            if newctiles == []:\n                print(-1)\n                break\n            if oldctiles == set(newctiles):\n                print(-1)\n                break\n            if set(newctiles).issubset(set(visited)):\n                print(-1)\n                break\n            oldctiles = newctiles[:]\n    else:\n        print(-1)", "from sys import maxsize as INT_MAX\nfrom collections import deque\nV = 1001\n\nclass node:\n\n    def __init__(self, to, weight):\n        self.to = to\n        self.weight = weight\nedges = [0] * V\nfor i in range(V):\n    edges[i] = []\n\ndef zeroOneBFS(src: int, dist):\n    for i in range(V):\n        dist[i] = INT_MAX\n    Q = deque()\n    dist[src] = 0\n    Q.append(src)\n    while Q:\n        v = Q[0]\n        Q.popleft()\n        for i in range(len(edges[v])):\n            if dist[edges[v][i].to] > dist[v] + edges[v][i].weight:\n                dist[edges[v][i].to] = dist[v] + edges[v][i].weight\n                if edges[v][i].weight == 0:\n                    Q.appendleft(edges[v][i].to)\n                else:\n                    Q.append(edges[v][i].to)\n\ndef addEdge(u: int, v: int, wt: int):\n    edges[u].append(node(v, wt))\n    edges[u].append(node(v, wt))\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    for i in range(n):\n        s = input()\n        for j in range(max(0, i - k), min(n, i + k + 1)):\n            if s[j] == '1':\n                addEdge(i, j, 1)\n    src = 0\n    dist = [0] * V\n    zeroOneBFS(src, dist)\n    ans = dist[n - 1]\n    if ans == 9223372036854775807:\n        print(-1)\n        for i in range(V):\n            edges[i] = []\n    else:\n        print(ans)\n        for i in range(V):\n            edges[i] = []", "import queue\n\ndef minEdgeBFS(edges, u, v, n):\n    visited = [0] * n\n    distance = [0] * n\n    Q = queue.Queue()\n    distance[u] = 0\n    Q.put(u)\n    visited[u] = True\n    while not Q.empty():\n        x = Q.get()\n        for i in range(len(edges[x])):\n            if visited[edges[x][i]]:\n                continue\n            distance[edges[x][i]] = distance[x] + 1\n            Q.put(edges[x][i])\n            visited[edges[x][i]] = 1\n    return distance[v]\nfor test_case in range(int(input())):\n    (N, K) = map(int, input().split())\n    array = []\n    for i in range(N):\n        array.append([])\n    for i in range(N):\n        pepe = input()\n        a = min(i, K)\n        b = min(N, i + K + 1)\n        for l in range(i - a, b):\n            if pepe[l] == '1' and l != i:\n                array[i].append(l)\n    answer = minEdgeBFS(array, 0, N - 1, N)\n    if answer == 0:\n        print(-1)\n    else:\n        print(answer)", "from copy import deepcopy\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().strip().split())\n    s = [''] * n\n    for i in range(n):\n        s[i] = input()\n    mat = [float('inf') for _ in range(n)]\n    change = True\n    while True:\n        matOld = deepcopy(mat)\n        for i in range(n):\n            for j in range(-k, k + 1):\n                if i + j < n - 1 and i + j > 0 and (s[i][i + j] == '1'):\n                    mat[i] = min(mat[i], mat[i + j] + 1)\n                if i + j == n - 1 and s[i][i + j] == '1':\n                    mat[i] = 1\n        if matOld == mat:\n            break\n    if mat[0] == float('inf'):\n        print(-1)\n    else:\n        print(mat[0])", "from collections import defaultdict\nfor x in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = []\n    for x in range(n):\n        l.append(input())\n    l1 = [n - 1]\n    c = 0\n    k1 = 0\n    visited = defaultdict(int)\n    while 0 not in l1 and len(l1) != 0:\n        l2 = []\n        for x in l1:\n            for y in range(n):\n                if l[y][x] == '1' and abs(y - x) <= k and (y != x) and (visited[y] != 1):\n                    l2.append(y)\n                    visited[y] = 1\n        l1 = l2.copy()\n        c += 1\n    if l1 == []:\n        print(-1)\n    else:\n        print(c)", "t = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    a = []\n    for i in range(n):\n        s = input()\n        a.append(s)\n    re = []\n    for i in range(n):\n        f = []\n        for j in range(n):\n            if i == j:\n                continue\n            if a[i][j] == '1':\n                if abs(i - j) <= k:\n                    f.append(j)\n        re.append(f)\n    res = set()\n    c = 0\n    flag = 0\n    vis = [0 for i in range(n)]\n    queue = [0]\n    while len(queue) != 0:\n        c += 1\n        temp = []\n        for i in range(len(queue) - 1, -1, -1):\n            if vis[queue[i]] == 0:\n                vis[queue[i]] = 1\n                for k in range(len(re[queue[i]])):\n                    res.add(re[queue[i]][k])\n                    if vis[re[queue[i]][k]]:\n                        continue\n                    temp.append(re[queue[i]][k])\n        queue = temp\n        if n - 1 in res:\n            flag = 1\n            break\n    if flag == 0:\n        print(-1)\n    else:\n        print(c)", "t = int(input())\nwhile t > 0:\n    (N, K) = [int(c) for c in input().split(' ')]\n    strings = []\n    for i in range(N):\n        strings.append(input().strip())\n    min_steps = [10 ** 10 for i in range(N)]\n    min_steps[0] = 0\n    for p in range(100):\n        for i in range(1, N):\n            for j in range(i - K, i + K + 1):\n                if j >= 0 and j < N and (j != i) and (strings[j][i] == '1'):\n                    min_steps[i] = min(min_steps[i], min_steps[j] + 1)\n    if min_steps[N - 1] >= 10 ** 10:\n        print(-1)\n    else:\n        print(min_steps[N - 1])\n    t -= 1", "def BFS(gph, s, d, v, pred, dist):\n    queue = []\n    visited = [False] * v\n    visited[s] = True\n    dist[s] = 0\n    queue.append(s)\n    while len(queue) != 0:\n        u = queue[0]\n        del queue[0]\n        for i in range(len(gph[u])):\n            if visited[gph[u][i]] == False:\n                visited[gph[u][i]] = True\n                dist[gph[u][i]] = dist[u] + 1\n                pred[gph[u][i]] = u\n                queue.append(gph[u][i])\n                if gph[u][i] == d:\n                    return True\n    return False\n\ndef printShortestDistance(gph, s, d, v):\n    pred = [-1] * v\n    dist = [7 + 10 ** 9] * v\n    if BFS(gph, s, d, v, pred, dist) == False:\n        print(-1)\n        return\n    path = []\n    crawl = d\n    path.append(crawl)\n    while pred[crawl] != -1:\n        path.append(pred[crawl])\n        crawl = pred[crawl]\n    print(dist[d])\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    lis = []\n    for i in range(n):\n        lis.append(input())\n    gph = dict()\n    for i in range(n):\n        gph[i] = []\n    for i in range(n):\n        for j in range(n):\n            if i != j and abs(i - j) <= k and (lis[i][j] == '1'):\n                gph[i].append(j)\n    printShortestDistance(gph, 0, n - 1, n)", "from sys import stdin, stdout\nfrom collections import defaultdict\nfor t in range(int(input())):\n    (N, K) = map(int, input().split())\n    adj = defaultdict(list)\n    terror = False\n    for k in range(N):\n        S = input()\n        if S[k] == '0':\n            terror = True\n        m = max(0, k - K)\n        M = min(N, k + K + 1)\n        for h in range(m, k):\n            if S[h] == '1':\n                adj[k].append(h)\n        for hb in range(k + 1, M):\n            if S[hb] == '1':\n                adj[k].append(hb)\n    if terror == True:\n        print('-1')\n        continue\n    seen = [0 for j in range(N)]\n    seen[0] = 1\n    start = [0]\n    n = []\n    parent = defaultdict(int)\n    parent[0] = 0\n    while True:\n        next = []\n        if len(start) == 0:\n            break\n        else:\n            for item in start:\n                AD = adj[item]\n                for x in AD:\n                    if seen[x] == 0:\n                        next.append(x)\n                        parent[x] = start[0]\n                        seen[x] = 1\n            start = next\n    child = N - 1\n    step = 0\n    while child != 0:\n        step += 1\n        child = parent[child]\n    if seen[N - 1] == 1:\n        print(step)\n    else:\n        print('-1')", "from sys import stdin, stdout\nfrom collections import defaultdict\nfor t in range(int(input())):\n    (N, K) = map(int, input().split())\n    adj = defaultdict(list)\n    terror = False\n    for k in range(N):\n        S = input()\n        if S[k] == '0':\n            terror = True\n        m = max(0, k - K)\n        M = min(N, k + K + 1)\n        for h in range(m, k):\n            if S[h] == '1':\n                adj[k].append(h)\n        for hb in range(k + 1, M):\n            if S[hb] == '1':\n                adj[k].append(hb)\n    if terror == True:\n        print('-1')\n        continue\n    seen = [0 for j in range(N)]\n    seen[0] = 1\n    start = [0]\n    n = []\n    parent = defaultdict(int)\n    parent[0] = 0\n    while True:\n        next = []\n        if len(start) == 0:\n            break\n        else:\n            for item in start:\n                AD = adj[item]\n                for x in AD:\n                    if seen[x] == 0:\n                        next.append(x)\n                        parent[x] = start[0]\n                        seen[x] = 1\n            start = next\n    child = N - 1\n    step = 0\n    while child != 0:\n        step += 1\n        child = parent[child]\n    if seen[N - 1] == 1:\n        print(step)\n    else:\n        print('-1')", "def recSolve(tiles, pos, k, visited, dist):\n    if visited[pos] != -1 and dist >= visited[pos] or tiles[pos][pos] == '0':\n        return\n    visited[pos] = dist\n    for i in range(max(0, pos - k), min(len(tiles), pos + k + 1)):\n        if tiles[pos][i] != '0':\n            recSolve(tiles, i, k, visited, dist + 1)\nt = int(input())\nwhile t != 0:\n    (n, k) = list(map(int, input().split()))\n    tiles = []\n    for _ in range(n):\n        tiles.append(input())\n    visited = [-1 for _ in range(n)]\n    recSolve(tiles, 0, k, visited, 0)\n    print(visited[-1])\n    t -= 1", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce, cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\ndef factors(n):\n    return sorted(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0))))\n\ndef li():\n    return [int(i) for i in input().rstrip('\\n').split()]\n\ndef st():\n    return input().rstrip('\\n')\n\ndef val():\n    return int(input().rstrip('\\n'))\n\ndef li2():\n    return [i for i in input().rstrip('\\n').split(' ')]\n\ndef li3():\n    return [int(i) for i in input().rstrip('\\n')]\nfor _ in range(val()):\n    (n, k) = li()\n    l = []\n    for i in range(n):\n        l.append(li3())\n    dp = [float('inf') for i in range(n)]\n    currleft = deque()\n    currleft.append(0)\n    visited = set([0])\n    dp[0] = 0\n    while len(currleft):\n        i = currleft.popleft()\n        for j in range(max(0, i - k), min(n, i + k + 1), 1):\n            if l[i][j]:\n                dp[j] = min(dp[j], dp[i] + 1)\n                if j not in visited:\n                    currleft.append(j)\n                    visited.add(j)\n    print(dp[-1] if dp[-1] != float('inf') else -1)", "import sys\nfrom collections import defaultdict\nfrom math import inf\nimport heapq\ninput = sys.stdin.readline\n\ndef solve(n, k, arr):\n    graph = defaultdict(set)\n    for i in range(1, n + 1):\n        for j in range(max(1, i - k), min(n + 1, i + k + 1)):\n            if i != j:\n                if arr[i - 1][j - 1] == '1':\n                    graph[i].add(j)\n    for key in graph:\n        graph[key] = list(graph[key])\n    (start, end) = (1, n)\n    heap = [(0, start)]\n    visited = set()\n    while heap:\n        (u_dist, u) = heapq.heappop(heap)\n        if u not in visited:\n            visited.add(u)\n            if u == end:\n                return u_dist\n            for v in graph[u]:\n                if v not in visited:\n                    dist = u_dist + 1\n                    heapq.heappush(heap, (dist, v))\n    return -1\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = [input() for i in range(n)]\n    print(solve(n, k, arr))", "import sys\nimport math\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)] for row in range(vertices)]\n\n    def printSolution(self, dist):\n        for node in range(self.V):\n            if self.V - 1 == node:\n                if dist[node] == float('Inf'):\n                    print('-1')\n                else:\n                    print(dist[node])\n\n    def minDistance(self, dist, sptSet):\n        min1 = float('Inf')\n        min_index = 0\n        for v in range(self.V):\n            if dist[v] < min1 and sptSet[v] == False:\n                min1 = dist[v]\n                min_index = v\n        return min_index\n\n    def dijkstra(self, src):\n        dist = [float('Inf')] * self.V\n        dist[src] = 0\n        sptSet = [False] * self.V\n        for cout in range(self.V):\n            u = self.minDistance(dist, sptSet)\n            sptSet[u] = True\n            for v in range(self.V):\n                if self.graph[u][v] > 0 and sptSet[v] == False and (dist[v] > dist[u] + self.graph[u][v]):\n                    dist[v] = dist[u] + self.graph[u][v]\n        self.printSolution(dist)\nfor t in range(int(input())):\n    (n, k) = map(int, input().split(' '))\n    arr = []\n    for i in range(n):\n        arr.append(input())\n    g = Graph(n)\n    g.graph = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                if arr[i][j] == '1' and math.fabs(i - j) <= k:\n                    g.graph[i][j] = 1\n    g.dijkstra(0)", "def bfs(self, n):\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    queue = []\n    queue.append(1)\n    queue.append(None)\n    bfs_list = []\n    count = 0\n    while len(queue):\n        current = queue.pop(0)\n        if current == n:\n            bfs_list.append(current)\n            return count\n        if current == None:\n            count += 1\n            if len(queue):\n                queue.append(None)\n        else:\n            bfs_list.append(current)\n            for node in d[current]:\n                if not visited[node]:\n                    queue.append(node)\n                    visited[node] = 1\n    return -1\ntc = int(input())\nfor _ in range(tc):\n    (n, k) = map(int, input().split())\n    d = {}\n    for i in range(1, n + 1):\n        s = input()\n        d[i] = []\n        for (j, kl) in enumerate(s):\n            if j + 1 != i and kl != '0' and (abs(j + 1 - i) <= k):\n                d[i].append(j + 1)\n    print(bfs(d, n))"]