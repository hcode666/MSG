["def dist(pos1: list, pos2: list) -> int:\n    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\ndef list2bin(n: int, lst: list) -> str:\n    num = 0\n    for x in lst:\n        num += 1 << x\n    return f'{num:08b}'\n\ndef pos2str(pos: list) -> str:\n    return '--'.join(map(str, pos))\n\ndef min_chef(chefs: list, tools: list, htools: list, rem_tools: list, pos: list, cost: int, dp: dict) -> tuple:\n    hkey = list2bin(len(tools), htools)\n    rkey = list2bin(len(tools), rem_tools)\n    pkey = pos2str(pos)\n    for (i, ti) in enumerate(htools):\n        c = chefs[ti]\n        dc = dist(pos, c)\n        nhtools = htools[:i] + htools[i + 1:]\n        hkey = list2bin(len(tools), nhtools)\n        rkey = list2bin(len(tools), rem_tools)\n        pkey = pos2str(c)\n        if not dp.get(hkey, {}).get(rkey, {}).get(pkey):\n            dp = recurse(chefs, tools, nhtools, rem_tools, c, dp)\n        cost = min(cost, dc + dp[hkey][rkey][pkey])\n    return (cost, dp)\n\ndef min_tool(chefs: list, tools: list, htools: list, rem_tools: list, pos: list, cost: int, dp: dict) -> tuple:\n    for (i, ti) in enumerate(rem_tools):\n        t = tools[ti]\n        dt = dist(pos, t)\n        nhtools = htools + [ti]\n        nrem_tools = rem_tools[:i] + rem_tools[i + 1:]\n        hkey = list2bin(len(tools), nhtools)\n        rkey = list2bin(len(tools), nrem_tools)\n        pkey = pos2str(t)\n        if not dp.get(hkey, {}).get(rkey, {}).get(pkey):\n            dp = recurse(chefs, tools, nhtools, nrem_tools, t, dp)\n        cost = min(cost, dt + dp[hkey][rkey][pkey])\n    return (cost, dp)\n\ndef recurse(chefs: list, tools: list, htools: list, rem_tools: list, pos: list, dp: dict) -> dict:\n    hkey = list2bin(len(tools), htools)\n    rkey = list2bin(len(tools), rem_tools)\n    pkey = pos2str(pos)\n    if hkey not in dp:\n        dp[hkey] = {}\n    if rkey not in dp[hkey]:\n        dp[hkey][rkey] = {}\n    if pkey not in dp[hkey][rkey]:\n        if len(htools) > 2:\n            cost = 1000000000.0\n        elif len(htools) == 0 and len(rem_tools) == 0:\n            cost = abs(pos[0]) + abs(pos[1])\n        else:\n            (cost, dp) = min_chef(chefs, tools, htools, rem_tools, pos, 1000000000.0, dp)\n            (cost, dp) = min_tool(chefs, tools, htools, rem_tools, pos, cost, dp)\n        dp[hkey][rkey][pkey] = cost\n    return dp\n\ndef solve(chefs: list, tools: list, n: int) -> int:\n    rem_tools = list(range(n))\n    dp = recurse(chefs, tools, [], rem_tools, [0, 0], {})\n    hkey = list2bin(n, [])\n    rkey = list2bin(n, rem_tools)\n    pkey = pos2str([0, 0])\n    return dp[hkey][rkey][pkey]\n\ndef main():\n    t = int(input().strip())\n    for _ in range(t):\n        n = int(input().strip())\n        (chefs, tools) = ([], [])\n        for i in range(n):\n            (cx, cy, tx, ty) = map(int, input().strip().split())\n            chefs.append([cx, cy])\n            tools.append([tx, ty])\n        print(solve(chefs, tools, n))\nmain()", "def dist(pos1: list, pos2: list) -> int:\n    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\ndef list2bin(n: int, lst: list) -> str:\n    num = 0\n    for x in lst:\n        num += 1 << x\n    return f'{num:08b}'\n\ndef pos2str(pos: list) -> str:\n    return '--'.join(map(str, pos))\n\ndef min_chef(chefs: list, tools: list, htools: list, rem_tools: list, pos: list, cost: int, dp: dict) -> tuple:\n    hkey = list2bin(len(tools), htools)\n    rkey = list2bin(len(tools), rem_tools)\n    pkey = pos2str(pos)\n    for (i, ti) in enumerate(htools):\n        c = chefs[ti]\n        dc = dist(pos, c)\n        nhtools = htools[:i] + htools[i + 1:]\n        hkey = list2bin(len(tools), nhtools)\n        rkey = list2bin(len(tools), rem_tools)\n        pkey = pos2str(c)\n        if not dp.get(hkey, {}).get(rkey, {}).get(pkey):\n            dp = recurse(chefs, tools, nhtools, rem_tools, c, dp)\n        cost = min(cost, dc + dp[hkey][rkey][pkey])\n    return (cost, dp)\n\ndef min_tool(chefs: list, tools: list, htools: list, rem_tools: list, pos: list, cost: int, dp: dict) -> tuple:\n    for (i, ti) in enumerate(rem_tools):\n        t = tools[ti]\n        dt = dist(pos, t)\n        nhtools = htools + [ti]\n        nrem_tools = rem_tools[:i] + rem_tools[i + 1:]\n        hkey = list2bin(len(tools), nhtools)\n        rkey = list2bin(len(tools), nrem_tools)\n        pkey = pos2str(t)\n        if not dp.get(hkey, {}).get(rkey, {}).get(pkey):\n            dp = recurse(chefs, tools, nhtools, nrem_tools, t, dp)\n        cost = min(cost, dt + dp[hkey][rkey][pkey])\n    return (cost, dp)\n\ndef recurse(chefs: list, tools: list, htools: list, rem_tools: list, pos: list, dp: dict) -> dict:\n    hkey = list2bin(len(tools), htools)\n    rkey = list2bin(len(tools), rem_tools)\n    pkey = pos2str(pos)\n    if hkey not in dp:\n        dp[hkey] = {}\n    if rkey not in dp[hkey]:\n        dp[hkey][rkey] = {}\n    if pkey not in dp[hkey][rkey]:\n        if len(htools) > 2:\n            cost = 1000000000.0\n        elif len(htools) == 0 and len(rem_tools) == 0:\n            cost = abs(pos[0]) + abs(pos[1])\n        else:\n            (cost, dp) = min_chef(chefs, tools, htools, rem_tools, pos, 1000000000.0, dp)\n            (cost, dp) = min_tool(chefs, tools, htools, rem_tools, pos, cost, dp)\n        dp[hkey][rkey][pkey] = cost\n    return dp\n\ndef solve(chefs: list, tools: list, n: int) -> int:\n    rem_tools = list(range(n))\n    dp = recurse(chefs, tools, [], rem_tools, [0, 0], {})\n    hkey = list2bin(n, [])\n    rkey = list2bin(n, rem_tools)\n    pkey = pos2str([0, 0])\n    return dp[hkey][rkey][pkey]\n\ndef main():\n    t = int(input().strip())\n    for _ in range(t):\n        n = int(input().strip())\n        (chefs, tools) = ([], [])\n        for i in range(n):\n            (cx, cy, tx, ty) = map(int, input().strip().split())\n            chefs.append([cx, cy])\n            tools.append([tx, ty])\n        print(solve(chefs, tools, n))\nmain()"]