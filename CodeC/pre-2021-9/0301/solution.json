["l = []\n(n, k) = map(int, input().split())\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\ni = 0\nc = 0\nwhile i <= n - 2:\n    if l[i + 1] - l[i] <= k:\n        c = c + 1\n        i = i + 2\n    else:\n        i = i + 1\nprint(c)", "a = []\n(N, D) = [int(x) for x in input().split()]\ni = 0\nwhile i < N:\n    y = input()\n    a.append(y)\n    i = i + 1\nA = [int(x) for x in a]\nA.sort()\ni = 0\ncount = 0\nwhile i < N - 1:\n    if A[i + 1] - A[i] <= D:\n        i = i + 2\n        count = count + 1\n    else:\n        i = i + 1\nprint(count)", "(n, d) = map(int, input().split())\nl = sorted([int(input()) for i in range(n)])\nx = 0\nj = 0\nwhile j < n - 1:\n    if l[j + 1] - l[j] <= d:\n        x += 1\n        j += 2\n    else:\n        j += 1\nprint(x)", "(n, d) = map(int, input().split())\ns = sorted([int(input()) for _ in range(n)])\np = 0\ni = 0\nwhile i < n - 1:\n    if s[i + 1] - s[i] <= d:\n        p += 1\n        i += 2\n    else:\n        i += 1\nprint(p)", "(n, d) = map(int, input().split())\nsticks = sorted([int(input()) for i in range(n)])\npairs = 0\ni = 0\nwhile i < n - 1:\n    if sticks[i + 1] - sticks[i] <= d:\n        pairs += 1\n        i += 2\n    else:\n        i += 1\nprint(pairs)", "(n, d) = map(int, input().split())\nlength = []\nfor _ in range(n):\n    length.append(int(input()))\nlength.sort()\ni = 0\nans = 0\nwhile i < n - 1:\n    if length[i + 1] - length[i] <= d:\n        ans += 1\n        i += 2\n    else:\n        i += 1\nprint(ans)", "def max_pairs(n, d, L):\n    L.sort()\n    count = 0\n    i = 0\n    while i < n - 1:\n        if L[i + 1] - L[i] <= d:\n            count += 1\n            i += 2\n        else:\n            i += 1\n    return count\n(n, d) = map(int, input().split())\nL = []\nfor i in range(n):\n    L.append(int(input()))\nprint(max_pairs(n, d, L))", "(n, d) = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(int(input()))\na.sort()\nct = 0\ni = 1\nwhile i < n:\n    if a[i] - a[i - 1] <= d:\n        i += 1\n        ct += 1\n    i += 1\nprint(ct)", "(n, d) = map(int, input().split(' '))\nl = []\nc = 0\nfor _ in range(n):\n    L = int(input())\n    l.append(L)\nl.sort()\ni = 1\nwhile i < n:\n    if l[i] - l[i - 1] <= d:\n        c += 1\n        i += 1\n    i += 1\nprint(c)", "(n, d) = map(int, input().split())\nli = []\nfor i in range(n):\n    li.append(int(input()))\nli.sort()\ncnt = 0\ni = n - 1\nwhile i > 0:\n    if li[i] - li[i - 1] <= d:\n        cnt += 1\n        i -= 2\n    else:\n        i -= 1\nprint(cnt)", "a = []\n(N, D) = [int(x) for x in input().split()]\ni = 0\nwhile i < N:\n    y = input()\n    a.append(y)\n    i = i + 1\nA = [int(x) for x in a]\nA.sort()\ni = 0\ncount = 0\nwhile i < N - 1:\n    if A[i + 1] - A[i] <= D:\n        i = i + 2\n        count = count + 1\n    else:\n        i = i + 1\nprint(count)", "import string\nfrom functools import lru_cache\nimport atexit, io\nimport sys\nfrom math import log2\nimport math\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right, insort\nfrom math import gcd\nfrom math import sqrt\nfrom collections import Counter, defaultdict\nfrom heapq import heappush, heappop, heapify\nimport heapq\n\nclass FenwickTree:\n\n    def __init__(self, n):\n        self.farr = [0] * (n + 1)\n\n    def prefixSum(self, idx):\n        s = 0\n        while idx > 0:\n            s += self.farr[idx]\n            idx -= idx & -idx\n        return s\n\n    def update(self, idx, val):\n        while idx < len(self.farr):\n            self.farr[idx] += val\n            idx += idx & -idx\n\n    def find(self, k):\n        curr = 0\n        ans = 0\n        prevSum = 0\n        for i in range(log2(n), -1, -1):\n            if self.farr[curr + (i << i)] + prevSum < k:\n                curr += 1 << i\n                prevSum += self.farr[curr]\n        return curr + 1\n\nclass Trie(object):\n\n    def __init__(self):\n        self.trie = {}\n\n    def insert(self, word):\n        t = self.trie\n        for c in word:\n            if c not in t:\n                t[c] = {}\n            t = t[c]\n        t['-'] = True\n\n    def search(self, word):\n        t = self.trie\n        for c in word:\n            if c not in t:\n                return False\n            t = t[c]\n        return '-' in t\n\n    def startsWith(self, prefix):\n        t = self.trie\n        for c in prefix:\n            if c not in t:\n                return False\n            t = t[c]\n        return True\n\n    def query(self, word):\n        ans = 0\n        t = self.trie\n        for i in word:\n            if i not in t:\n                break\n            ans += 1\n            t = t[i]\n        return ans\n\nclass FenvTree:\n\n    def __init__(self, arr):\n        arr.insert(0, 0)\n        self.farr = [0]\n        prefix = [0]\n        for i in arr[1:]:\n            prefix.append(prefix[-1] + i)\n        for i in range(1, len(arr)):\n            idash = i - (i & -i)\n            self.farr.append(prefix[i] - prefix[idash])\n\n    def query(self, l, r):\n        return self.prefixSum(r) - self.prefixSum(l - 1)\n\n    def prefixSum(self, idx):\n        s = 0\n        while idx > 0:\n            s += self.farr[idx]\n            idx -= idx & -idx\n        return s\n\n    def update(self, idx, val):\n        while idx < len(self.farr):\n            self.farr[idx] += val\n            idx += idx & -idx\n\nclass DSU:\n\n    def __init__(self, n):\n        self.parent = []\n        self.size = []\n        for i in range(n + 1):\n            self.parent.append(i)\n            self.size.append(1)\n\n    def union(self, u, v):\n        pu = self.findPar(u)\n        pv = self.findPar(v)\n        if pu == pv:\n            return\n        if self.size[pu] < self.size[pv]:\n            self.parent[pu] = pv\n            self.size[pv] += self.size[pu]\n        else:\n            self.parent[pv] = pu\n            self.size[pu] += self.size[pv]\n\n    def unionByRank(self, u, v):\n        pu = self.findPar(u)\n        pv = self.findPar(v)\n        if pu == pv:\n            return\n        if self.rank[pu] < self.rank[pv]:\n            self.parent[pu] = pv\n        elif self.rank[pv] < self.rank[pu]:\n            self.parent[pv] = pu\n        else:\n            self.parent[pu] = pv\n            self.rank[pv] += 1\n\n    def findPar(self, node):\n        if self.parent[node] == node:\n            return node\n        self.parent[node] = self.findPar(self.parent[node])\n        return self.parent[node]\n\nclass info:\n\n    def __init__(self, _open=0, _close=0, _full=0):\n        self.open = _open\n        self.close = _close\n        self.full = _full\n\nclass SGTree:\n\n    def __init__(self, n):\n        self.seg = [0 for _ in range(4 * n)]\n\n    def build(self, ind, low, high, arr):\n        if low == high:\n            self.seg[ind] = arr[low]\n            return\n        mid = (low + high) // 2\n        self.build(2 * ind + 1, low, mid, arr)\n        self.build(2 * ind + 2, mid + 1, high, arr)\n        self.seg[ind] = min(self.seg[2 * ind + 1], self.seg[2 * ind + 2])\n\n    def query(self, ind, low, high, l, r):\n        if r < low or l > high:\n            return sys.maxsize\n        if low <= l and r >= high:\n            return self.seg[ind]\n        mid = low + high >> 1\n        left = self.query(2 * ind + 1, 0, mid, l, r)\n        right = self.query(2 * ind + 2, mid + 1, high, l, r)\n        return min(left, right)\n\n    def update(self, ind, low, high, i, val):\n        if low == high:\n            self.seg = val\n            return\n        mid = low + high >> 1\n        if i <= mid:\n            self.update(2 * ind + 1, low, mid, i, val)\n        else:\n            self.update(2 * ind + 1, mid + 1, high, i, val)\n        self.seg[ind] = min(self.seg[2 * ind + 1], self.seg[2 * ind + 2])\n\ndef isPalindrome(s):\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef IntList():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef getInts():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef getStrs():\n    return sys.stdin.readline().strip()\n\ndef StrList():\n    list(sys.stdin.readline().strip())\n\ndef FloatList():\n    lis = input().split()\n    lis = list(map(float, lis))\n    return lis\n\ndef SieveOfEratosthenes(n, isPrime):\n    isPrime[0] = isPrime[1] = False\n    for i in range(2, n + 1):\n        isPrime[i] = True\n    p = 2\n    while p * p <= n:\n        if isPrime[p]:\n            i = p * p\n            while i <= n:\n                isPrime[i] = False\n                i += p\n        p += 1\n\ndef findPrimePair(n):\n    isPrime = [0] * (n + 1)\n    SieveOfEratosthenes(n, isPrime)\n    for i in range(0, n):\n        if isPrime[i] and isPrime[n - i]:\n            print(i, n - i)\n            return\n\ndef query(ind, low, high, l, r, seg):\n    if r < low or l > high:\n        return info()\n    if low <= l and r >= high:\n        return self.seg[ind]\n    mid = low + high >> 1\n    left = self.query(2 * ind + 1, 0, mid, l, r, seg)\n    right = self.query(2 * ind + 2, mid + 1, high, l, r, seg)\n    return merge(left, right)\n\ndef merge(left, right):\n    ans = info()\n    ans.full = left.full + right.full + min(left.open, right.close)\n    ans.open = left.open + right.open + min(left.open, right.close)\n    ans.close = left.close + right.close + min(left.open, right.close)\n    return ans\n\ndef build(ind, low, high, s, seg):\n    if low == high:\n        seg[ind] = info(s[low] == '(', s[low] == ')', 0)\n        return\n    mid = (low + high) // 2\n    build(2 * ind + 1, low, mid, s, seg)\n    build(2 * ind + 2, mid + 1, high, s, seg)\n    seg[ind] = merge(seg[2 * ind + 1], seg[2 * ind + 2])\n\ndef countN(lis):\n    ans = 0\n    cnt = 0\n    for i in range(len(lis) - 1, -1, -1):\n        if lis[i] == 0:\n            cnt += 1\n        else:\n            ans += cnt\n    return ans\n\nclass Pair:\n\n    def __init__(self, x, y, gcd):\n        self.x = x\n        self.y = y\n        self.gcd = gcd\n\ndef Euclidean(a, b):\n    if b == 0:\n        return Pair(1, 0, a)\n    dash = Euclidean(b, a % b)\n    return Pair(dash.y, dash.x - a // b * dash.y, dash.gcd)\n\ndef chineseRemainder(a1, n1, a2, n2):\n    p = Euclidean(n1, n2)\n    x = p.x\n    gcd = p.gcd\n    if (a1 - a2) % gcd:\n        return -1\n    k = (a1 - a2) // gcd\n    a = a1 - n1 * (k * x % n2 // gcd)\n    lcm = n1 * n2 // gcd\n    if a < 0:\n        a += lcm\n    return a\nmdd = 998244353\n\ndef ncr(n, k, md):\n    mod = 998244353\n    tab = [[0 for _ in range(k + 1)] for i in range(n + 1)]\n    for i in range(1, len(tab)):\n        tab[i][0] = 1\n    for i in range(1, len(tab)):\n        for j in range(1, min(i + 1, len(tab[0]))):\n            if i == 1 and j == 1:\n                tab[i][j] = 1\n            else:\n                tab[i][j] = (tab[i - 1][j] + tab[i - 1][j - 1]) % mod\n    return tab\n\ndef repeat(i, j, arr):\n    if i > j:\n        return\n    cnt1 = i\n    cnt2 = j\n    while cnt1 < cnt2:\n        (arr[cnt1], arr[cnt2]) = (arr[cnt2], arr[cnt1])\n        cnt1 += 1\n        cnt2 -= 1\n    if i - 1 >= 0:\n        ele = arr[i - 1]\n        if ele > 0:\n            s = int(sqrt(ele - 1)) + 1\n            first = s * s - ele\n            repeat(first, i - 1, arr)\n    return\nspf = []\n\ndef makeSeive(n):\n    for i in range(n + 1):\n        spf.append(i)\n\ndef seive(n):\n    s = int(sqrt(n + 1))\n    for i in range(2, s + 1):\n        if spf[i] == i:\n            for j in range(i * i, n + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = set()\n    while x != 1:\n        ret.add(spf[x])\n        x = x // spf[x]\n    return ret\n\ndef zFunc(patt, txt):\n    st = patt + '#' + txt\n    zArray = [0 for _ in range(len(st))]\n    l = 0\n    r = 0\n    for i in range(1, len(st)):\n        if r >= i:\n            zArray[i] = min(r - i + 1, zArray[i - l])\n        while i + zArray[i] < len(st) and st[zArray[i]] == st[zArray[i] + i]:\n            zArray[i] += 1\n        if zArray[i] + i - 1 > r:\n            l = i\n            r = i + zArray[i] - 1\n    return zArray.count(len(patt))\n\ndef kmp(txt, patt):\n    newString = patt + '#' + txt\n    freqCount = 0\n    freqArray = [0 for _ in range(len(newString))]\n    i = 1\n    length = 0\n    while i < len(newString):\n        if newString[i] == newString[length]:\n            length += 1\n            freqArray[i] = length\n            i += 1\n        elif length > 0:\n            length = freqArray[length - 1]\n        else:\n            freqArray[i] = 0\n            i += 1\n    for i in freqArray:\n        if i == len(patt):\n            freqCount += 1\n    return freqCount\n\ndef getLPS(s):\n    st = '@#' + '#'.join(s) + '#&'\n    c = 0\n    r = 0\n    lps = [0] * len(st)\n    for i in range(1, len(st) - 1):\n        mirror = c - (i - c)\n        if i < r and mirror >= 0:\n            lps[i] = min(lps[mirror], r - i)\n        while st[i + lps[i] + 1] == st[i - lps[i] - 1]:\n            lps[i] += 1\n        if i + lps[i] > r:\n            r = i + lps[i]\n            c = i\n    return max(lps)\nfact = [1 for _ in range(100002)]\nmod = 10 ** 9 + 7\n\ndef getFact(n):\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n\ndef getInv(word):\n    num = math.factorial(len(word))\n    for v in Counter(word).values():\n        num = num * pow(math.factorial(v), mod - 2, mod) % mod\n    return int(num) % (10 ** 9 + 7)\n\ndef subarrayXor(arr, n, m):\n    HashTable = defaultdict(bool)\n    HashTable[0] = 1\n    count = 0\n    curSum = 0\n    for i in arr:\n        curSum ^= i\n        if HashTable[curSum ^ m]:\n            count += HashTable[curSum ^ m]\n        HashTable[curSum] += 1\n    return count\n\ndef get2dPrefixSum(matrix, mid=0):\n    n = len(matrix)\n    m = len(matrix[0])\n    prefix = [[0 for _ in range(m + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n    return prefix\n\ndef get2dPrefixSumCnt(matrix, mid=0):\n    n = len(matrix)\n    m = len(matrix[0])\n    prefix = [[0 for _ in range(m + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n    return prefix\n\ndef getSumRange(r1, c1, r2, c2, prefix):\n    cnt = prefix[r2][c2] - prefix[r2][c1 - 1] - prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1]\n    return cnt\n\ndef getPrefix(arr):\n    prefix = [0]\n    for i in arr:\n        prefix.append(prefix[-1] + i)\n    return prefix\n\ndef getInv(arr):\n    cnt = 0\n    ans = []\n    for i in arr:\n        ind = bisect_right(ans, i)\n        cnt += len(ans) - ind\n        insort(ans, i)\n    return cnt\nM = 10 ** 5\n\ndef getFactors(x):\n    temp = []\n    k = 1\n    while k * k <= x:\n        if x % k == 0:\n            temp.append(k)\n            if k * k != x:\n                temp.append(x // k)\n        k += 1\n    return temp\n\ndef grayCode(n):\n    if not n:\n        return [0]\n    res = [0, 1]\n    for i in range(2, n + 1):\n        for j in range(len(res) - 1, -1, -1):\n            res.append(res[j] | 1 << i - 1)\n    return res\n\ndef threeSum(nums, target):\n    ans = -1\n    d = dict()\n    for (i, j) in enumerate(nums):\n        d[j] = i + 1\n    nums.sort()\n    for i in range(len(nums) - 2):\n        low = i + 1\n        high = len(nums) - 1\n        while low < high:\n            s = nums[i] + nums[low] + nums[high]\n            if s == target:\n                print(d[nums[low]], d[nums[high]], d[nums[i]])\n                return\n                low += 1\n                high -= 1\n            elif s < 0:\n                low = low + 1\n            else:\n                high -= 1\n    print('IMPOSSIBLE')\n    return\n\ndef FuckCF():\n    (n, m) = getInts()\n    lis = []\n    for _ in range(n):\n        lis.append(int(input()))\n    lis.sort()\n    cnt = 0\n    i = 1\n    while i < n:\n        if lis[i] - lis[i - 1] <= m:\n            cnt += 1\n            i += 1\n        i += 1\n    print(cnt)\nt = 1\nfor i in range(t):\n    FuckCF()", "(n, t) = map(int, input().split())\n(a, d) = ([], 0)\nfor i in range(n):\n    a.append(int(input()))\na.sort()\ni = 0\nwhile i < n - 1:\n    if a[i + 1] - a[i] <= t:\n        d += 1\n        i += 1\n    i += 1\nprint(d)", "(n, d) = map(int, input().split())\nlength = []\nfor _ in range(n):\n    length.append(int(input()))\nlength.sort()\ni = 0\nans = 0\nwhile i < n - 1:\n    if length[i + 1] - length[i] <= d:\n        ans += 1\n        i += 2\n    else:\n        i += 1\nprint(ans)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\ncount = 0\ni = 0\nif n > 1:\n    while True:\n        if l[i + 1] - l[i] <= d:\n            count += 1\n            i += 2\n            if i >= n - 1:\n                break\n        else:\n            i += 1\n            if i >= n - 1:\n                break\nprint(count)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\n(i, c) = (0, 0)\nwhile i < n - 1:\n    if l[i + 1] - l[i] <= d:\n        i += 1\n        c += 1\n    i += 1\nprint(c)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\n(i, c) = (0, 0)\nwhile i < n - 1:\n    if l[i + 1] - l[i] <= d:\n        i += 1\n        c += 1\n    i += 1\nprint(c)", "(N, D) = map(int, input().split())\nL = [0] * N\nfor i in range(N):\n    L[i] = int(input())\nL.sort()\nans = 0\nj = 0\nwhile j < N - 1:\n    if L[j + 1] - L[j] <= D:\n        j += 2\n        ans += 1\n    else:\n        j += 1\nprint(ans)", "(n, d) = map(int, input().split())\narr = []\nfor _ in range(n):\n    arr.append(int(input()))\narr.sort()\nc = 0\ni = 0\nwhile i < n - 1:\n    if arr[i + 1] - arr[i] <= d:\n        c += 1\n        i += 1\n    i += 1\nprint(c)", "(n, d) = map(int, input().split(' '))\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\npairs = 0\ni = 0\nwhile i < n - 1:\n    if l[i + 1] - l[i] <= d:\n        pairs = pairs + 1\n        i += 2\n    else:\n        i += 1\nprint(pairs)", "(n, d) = map(int, input().split(' '))\nstick = []\n(pairs, i) = (0, 0)\nfor _ in range(n):\n    stick.append(int(input()))\nstick.sort()\nwhile i < n - 1:\n    if stick[i + 1] - stick[i] <= d:\n        pairs += 1\n        i += 2\n    else:\n        i += 1\nprint(pairs)", "(n, k) = map(int, input().split())\nChop_l = []\ncount = 0\nfor i in range(n):\n    Chop_l.append(int(input()))\nChop_l.sort()\n(x, y) = (0, 0)\nwhile y < n - 1:\n    if Chop_l[y + 1] - Chop_l[y] <= k:\n        x += 1\n        y += 2\n    else:\n        y += 1\nprint(x)", "(N, D) = map(int, input().split())\ns = []\nfor i in range(N):\n    x = int(input(''))\n    s.append(x)\ns.sort()\nx = y = 0\nwhile y < N - 1:\n    if s[y + 1] - s[y] <= D:\n        x += 1\n        y += 2\n    else:\n        y += 1\nprint(x)", "(n, t) = map(int, input().split())\n(a, d) = ([], 0)\nfor i in range(n):\n    a.append(int(input()))\na.sort()\ni = 0\nwhile i < n - 1:\n    if a[i + 1] - a[i] <= t:\n        d += 1\n        i += 1\n    i += 1\nprint(d)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\ni = 0\ncount = 0\nwhile i < n - 1:\n    if l[i + 1] - l[i] <= d:\n        count += 1\n        i += 1\n    i += 1\nprint(count)", "(n, d) = [int(i) for i in input().split()]\nprev = 0\ncount = 0\nk = []\nfor i in range(n):\n    k.append(int(input()))\nk = sorted(k)\ni = 0\nwhile i < n - 1:\n    prev = count\n    if k[i + 1] - k[i] <= d:\n        count += 1\n    if count == prev:\n        i += 1\n    else:\n        i += 2\nprint(count)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\ncnt = 0\ni = 0\nwhile i < n - 1:\n    if l[i + 1] - l[i] <= d:\n        cnt += 1\n        i += 2\n    else:\n        i += 1\nprint(cnt)", "(n, d) = map(int, input().split())\nl = [0] * n\nfor x in range(n):\n    l[x] = int(input())\nl.sort()\ni = 1\na = 0\nwhile i <= n - 1:\n    if abs(l[i] - l[i - 1]) <= d:\n        a += 1\n        i += 2\n    else:\n        i += 1\nprint(a)", "(n, d) = map(int, input().split())\nl = [0] * n\nfor x in range(n):\n    l[x] = int(input())\nl.sort()\ni = 1\na = 0\nwhile i <= n - 1:\n    if abs(l[i] - l[i - 1]) <= d:\n        a += 1\n        i += 2\n    else:\n        i += 1\nprint(a)", "(n, g) = map(int, input().split())\narr = [0] * n\nfor i in range(n):\n    arr[i] = int(input())\narr.sort()\nc = 0\ni = 0\nwhile i < n - 1:\n    if arr[i + 1] - arr[i] <= g:\n        c += 1\n        i += 2\n    else:\n        i += 1\nprint(c)", "(n, d) = map(int, input().split())\nc = 0\nl = []\nfor i in range(n):\n    a = int(input())\n    l.append(a)\nl.sort()\n(a, b) = (0, 0)\nwhile b < n - 1:\n    if l[b + 1] - l[b] <= d:\n        a += 1\n        b += 2\n    else:\n        b += 1\nprint(a)", "(N, D) = [int(x) for x in input().split()]\nb = []\nfor i in range(N):\n    x = int(input(''))\n    b.append(x)\nb.sort()\na1 = 0\na2 = 0\nwhile a2 < N - 1:\n    if b[a2 + 1] - b[a2] <= D:\n        a1 += 1\n        a2 += 2\n    else:\n        a2 += 1\nprint(a1)", "(N, D) = [int(x) for x in input().split()]\nb = []\nfor i in range(N):\n    x = int(input(''))\n    b.append(x)\nb.sort()\na1 = 0\na2 = 0\nwhile a2 < N - 1:\n    if b[a2 + 1] - b[a2] <= D:\n        a1 += 1\n        a2 += 2\n    else:\n        a2 += 1\nprint(a1)", "(N, D) = [int(x) for x in input().split()]\nb = []\nfor i in range(N):\n    x = int(input(''))\n    b.append(x)\nb.sort()\na1 = 0\na2 = 0\nwhile a2 < N - 1:\n    if b[a2 + 1] - b[a2] <= D:\n        a1 += 1\n        a2 += 2\n    else:\n        a2 += 1\nprint(a1)", "(N, D) = [int(x) for x in input().split()]\nb = []\nfor i in range(N):\n    x = int(input(''))\n    b.append(x)\nb.sort()\na1 = 0\na2 = 0\nwhile a2 < N - 1:\n    if b[a2 + 1] - b[a2] <= D:\n        a1 += 1\n        a2 += 2\n    else:\n        a2 += 1\nprint(a1)", "(n, d) = map(int, input().split())\nb = []\nfor i in range(n):\n    a = int(input())\n    b.append(a)\nb.sort()\nl = 0\nc = 0\nwhile l < n - 1:\n    if b[l + 1] - b[l] <= d:\n        c += 1\n        l += 2\n    else:\n        l += 1\nprint(c)", "(n, d) = map(int, input().split())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nl.sort()\nc = 0\ni = 1\nwhile i < n:\n    if l[i] - l[i - 1] <= d:\n        c += 1\n        i += 1\n    i += 1\nprint(c)", "(n, d) = map(int, input().split())\narr = [] * n\nfor _ in range(n):\n    arr.append(int(input()))\narr.sort()\npairs = 0\ni = 0\nwhile i < n - 1:\n    if arr[i + 1] - arr[i] > d:\n        i += 1\n        continue\n    pairs += 1\n    i += 2\nprint(pairs)", "(n, d) = map(int, input().split())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nl.sort()\nk = c = 0\nwhile k < n - 1:\n    if l[k + 1] - l[k] <= d:\n        c += 1\n        k += 2\n    else:\n        k += 1\nprint(c)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    a = int(input())\n    l.append(a)\nl.sort()\npairs = 0\nwhile len(l) > 1:\n    if l[1] - l[0] <= d:\n        pairs += 1\n        l.pop(0)\n        l.pop(0)\n    else:\n        l.pop(0)\nprint(pairs)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(0, n):\n    a = int(input())\n    l.append(a)\nl.sort()\npairs = 0\nwhile len(l) > 1:\n    if l[1] - l[0] <= d:\n        pairs += 1\n        l.remove(l[0])\n        l.remove(l[0])\n    else:\n        l.remove(l[0])\nprint(pairs)", "(n, d) = map(int, input().split())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nl.sort()\nc = 0\nj = 0\nwhile j < n - 1:\n    if l[j + 1] - l[j] <= d:\n        c += 1\n        j += 2\n    else:\n        j += 1\nprint(c)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(0, n):\n    a = int(input())\n    l.append(a)\nl.sort()\npairs = 0\nwhile len(l) > 1:\n    if l[1] - l[0] <= d:\n        pairs += 1\n        l.remove(l[0])\n        l.remove(l[0])\n    else:\n        l.remove(l[0])\nprint(pairs)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    l += [int(input())]\nl.sort()\ni = 1\nans = 0\nwhile i < n:\n    if l[i] - l[i - 1] <= d:\n        ans += 1\n        i += 2\n    else:\n        i += 1\nprint(ans)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    l += [int(input())]\nl.sort()\ni = 1\nans = 0\nwhile i < n:\n    if l[i] - l[i - 1] <= d:\n        ans += 1\n        i += 2\n    else:\n        i += 1\nprint(ans)", "(n, k) = [int(d) for d in input().split()]\na = []\nfor i in range(n):\n    a.append(int(input()))\na.sort()\ncount = 0\ni = 0\nwhile i < n - 1:\n    if a[i + 1] - a[i] <= k:\n        count += 1\n        i += 1\n    i += 1\nprint(count)", "(n, d) = list(map(int, input().split()))\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\ni = c = 0\nwhile i < n - 1:\n    if l[i + 1] - l[i] <= d:\n        c += 1\n        i += 1\n    i += 1\nprint(c)", "(n, a) = map(int, input().split())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\nc = 0\ni = 0\nwhile i < n - 1:\n    if l[i + 1] - l[i] <= a:\n        c += 1\n        i += 1\n    i += 1\nprint(c)", "(n, m) = map(int, input().split())\narr = []\nfor i in range(n):\n    arr.append(int(input()))\narr.sort()\nc = 0\ni = 0\nwhile i < n - 1:\n    if arr[i + 1] - arr[i] <= m:\n        c = c + 1\n        i = i + 1\n    i = i + 1\nprint(c)", "(N, D) = map(int, input().split())\nli = []\nfor i in range(N):\n    li.append(int(input()))\nli.sort()\ncount = 0\ni = 0\nwhile i + 1 < N:\n    if abs(li[i + 1] - li[i]) <= D:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "a = []\n(n, d) = map(int, input().split())\nfor i in range(n):\n    a.append(int(input()))\na.sort()\n(i, c) = (0, 0)\nwhile i < n - 1:\n    if a[i + 1] - a[i] <= d:\n        c += 1\n        i += 1\n    i += 1\nprint(c)", "a = []\n(n, d) = [int(x) for x in input().split()]\nfor i in range(n):\n    a.append(int(input()))\na.sort()\n(i, c) = (0, 0)\nwhile i < n - 1:\n    if a[i + 1] - a[i] <= d:\n        c += 1\n        i += 1\n    i += 1\nprint(c)", "(n, m) = map(int, input().split())\nl1 = []\nfor i in range(n):\n    l1.append(int(input()))\nl1.sort()\nc = 0\ni = 0\nwhile i < n - 1:\n    if l1[i + 1] - l1[i] <= m:\n        c = c + 1\n        i = i + 1\n    i = i + 1\nprint(c)", "(n, m) = map(int, input().split())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nl = sorted(l)\nc = 0\ni = 0\nwhile i + 1 < n:\n    if abs(l[i] - l[i + 1]) <= m:\n        c += 1\n        i += 2\n    else:\n        i += 1\nprint(c)", "(n, m) = map(int, input().split())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nl = sorted(l)\nc = 0\ni = 0\nwhile i + 1 < n:\n    if abs(l[i] - l[i + 1]) <= m:\n        c += 1\n        i += 2\n    else:\n        i += 1\nprint(c)", "(n, d) = list(map(int, input().split()))\nsticks = [0] * n\nfor i in range(n):\n    sticks[i] = int(input())\nsticks.sort()\nans = 0\ni = 0\nwhile i < len(sticks) - 1:\n    if sticks[i + 1] - sticks[i] <= d:\n        ans += 1\n        i += 1\n    i += 1\nprint(ans)", "(n, d) = map(int, input().split())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nl.sort()\ncnt = 0\ni = 0\nwhile i + 1 < n:\n    if l[i + 1] - l[i] <= d:\n        cnt += 1\n        i += 2\n    else:\n        i += 1\nprint(cnt)", "(N, D) = [int(i) for i in input().split(' ')]\nL = []\nfor _2 in range(N):\n    L.append(int(input()))\nL.sort()\nans = 0\nlast = L[0]\ni = 1\nwhile i < N:\n    if abs(L[i] - last) <= D:\n        ans += 1\n        if i + 1 >= N:\n            break\n        last = L[i + 1]\n        i += 2\n    else:\n        last = L[i]\n        i += 1\nprint(ans)", "(n, c) = map(int, input().split())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\ncnt = 0\ni = 1\nwhile i < len(l):\n    if l[i] - l[i - 1] <= c:\n        cnt = cnt + 1\n        i = i + 2\n    else:\n        i = i + 1\nprint(cnt)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\ni = 1\nc = 0\nwhile i < n:\n    if l[i] - l[i - 1] <= d:\n        c += 1\n        i += 2\n    else:\n        i += 1\nprint(c)", "(n, d) = map(int, input().split())\narr = []\nfor i in range(n):\n    arr.append(int(input()))\narr.sort()\na = len(arr) - 1\nb = 0\nans = 0\nwhile b < a:\n    if arr[b + 1] - arr[b] <= d:\n        ans += 1\n        b += 2\n    else:\n        b += 1\nprint(ans)", "(n, d) = map(int, input().split())\narr = []\nfor i in range(n):\n    arr.append(int(input()))\narr.sort()\na = len(arr) - 1\nb = 0\nans = 0\nwhile b < a:\n    if arr[b + 1] - arr[b] <= d:\n        ans += 1\n        b += 2\n    else:\n        b += 1\nprint(ans)", "(n, d) = [int(x) for x in input().split()]\nls = []\nfor i in range(n):\n    li = int(input())\n    ls.append(li)\ncount = 0\ni = 0\nls.sort()\nwhile i < n - 1:\n    if ls[i + 1] - ls[i] <= d:\n        count += 1\n        i += 1\n    i += 1\nprint(count)", "(N, D) = map(int, input().split())\nl = []\nfor i in range(N):\n    l.append(int(input()))\nl.sort()\ncnt = 0\nb = 0\nwhile b < N - 1:\n    if l[b + 1] - l[b] <= D:\n        cnt += 1\n        b += 1\n    b += 1\nprint(cnt)", "(N, D) = [int(x) for x in input().split()]\nL = []\nfor i in range(N):\n    l = int(input())\n    L.append(l)\nc = 0\nj = 0\nL.sort()\nwhile j < N - 1:\n    if abs(L[j] - L[j + 1]) <= D:\n        c = c + 1\n        j = j + 2\n    else:\n        j = j + 1\nprint(c)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    length = int(input())\n    l.append(length)\nl.sort()\ni = 0\ncount = 0\nwhile i < n - 1:\n    if abs(l[i + 1] - l[i]) <= d:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    length = int(input())\n    l.append(length)\nl = sorted(l)\ni = 0\ncount = 0\nwhile i < n - 1:\n    if abs(l[i + 1] - l[i]) <= d:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "def solve(n, s, a):\n    a = sorted(a)\n    cnt = 0\n    i = 0\n    while i < n - 1:\n        if a[i + 1] - a[i] <= s:\n            cnt += 1\n            i += 2\n        else:\n            i += 1\n    return cnt\n(n, s) = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(int(input()))\nprint(solve(n, s, a))", "(n, d) = [int(i) for i in input().split()]\nL = []\nfor _ in range(n):\n    L.append(int(input()))\nL.sort(reverse=True)\ncount = 0\ni = 0\nwhile i < n - 1:\n    if L[i] - L[i + 1] <= d:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "[N, D] = list(map(int, input().split()))\nL = []\nfor _ in range(N):\n    L.append(int(input()))\nL.sort()\n(count, i) = (0, 0)\nwhile i < N - 1:\n    if L[i + 1] - L[i] <= D:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl = sorted(l)\np = 0\nb = 0\nfor i in range(1, n):\n    if l[i] > l[i - 1] + d:\n        p += (i - b) // 2\n        b = i\np += (n - b) // 2\nprint(p)", "(n, d) = map(int, input().split())\nL = []\nfor _ in range(n):\n    L.append(int(input()))\nL = sorted(L)\nlast_break = 0\npairs = 0\nfor i in range(1, n):\n    if L[i] > L[i - 1] + d:\n        pairs += (i - last_break) // 2\n        last_break = i\npairs += (n - last_break) // 2\nprint(pairs)", "(n, d) = map(int, input().split(' '))\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nl = sorted(l)\ncount = 0\ni = 0\nwhile i < n:\n    try:\n        if l[i + 1] - l[i] <= d:\n            count = count + 1\n            i = i + 1\n    except:\n        pass\n    i = i + 1\nprint(count)", "(N, D) = list(map(int, input().split()))\nL = []\nfor _ in range(N):\n    L.append(int(input()))\nL.sort()\nans = 0\ni = 0\nwhile i < len(L) - 1:\n    diff = L[i + 1] - L[i]\n    if diff <= D:\n        ans += 1\n        i += 2\n    else:\n        i += 1\nprint(ans)", "(N, D) = map(int, input().split())\nL = []\nfor i in range(N):\n    L.append(int(input()))\nL.sort()\ncount = 0\ni = 0\nwhile i < N - 1:\n    if L[i + 1] <= L[i] + D:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "(a, b) = map(int, input().split())\nl = []\nc = 0\nfor i in range(a):\n    l.append(int(input()))\nl.sort()\ni = 0\nwhile i <= a - 2:\n    if l[i + 1] - l[i] <= b:\n        c += 1\n        i += 2\n    else:\n        i += 1\nprint(c)", "(n, d) = map(int, input().split(' '))\n(li, count) = ([], 0)\nfor i in range(n):\n    li.append(int(input()))\nli.sort()\ni = 0\nwhile i <= n - 2:\n    if li[i + 1] - li[i] <= d:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "(N, D) = map(int, input().split())\nL = []\nfor i in range(N):\n    L.append(int(input()))\nL.sort()\ncount = 0\ni = 0\nwhile i < N - 1:\n    if L[i + 1] <= L[i] + D:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "(N, D) = map(int, input().split())\nL = []\nfor i in range(N):\n    L.append(int(input()))\nL.sort()\ni = 0\npair = 0\nwhile i < len(L) - 1:\n    if L[i + 1] - L[i] <= D:\n        pair += 1\n        i += 1\n    i += 1\nprint(pair)", "c = input().split()\nc = [int(c[0]), int(c[1])]\nl = []\nfor i in range(c[0]):\n    l.append(int(input()))\nl.sort()\nco = 0\ni = 1\nwhile i < c[0]:\n    if l[i] - l[i - 1] <= c[1]:\n        co += 1\n        i += 1\n    i += 1\nprint(co)", "(N, D) = map(int, input().split(' '))\nL = []\nfor n in range(N):\n    L.append(int(input()))\nL = sorted(L)\nres = 0\ni = 0\nwhile i < len(L) - 1:\n    if L[i + 1] - L[i] <= D:\n        res += 1\n        i += 1\n    i += 1\nprint(res)", "(a, b) = map(int, input().split())\nl = []\nc = 0\nfor i in range(a):\n    k = int(input())\n    l.append(k)\nl.sort()\ni = 0\nwhile i <= a - 2:\n    if abs(l[i] - l[i + 1]) <= b:\n        i += 2\n        c += 1\n    else:\n        i += 1\nprint(c)", "(n, d) = map(int, input().split())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nl.sort()\ncount = 0\ni = 1\nwhile i < len(l):\n    if abs(l[i] - l[i - 1]) <= d:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "(n, d) = map(int, input().split())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nl.sort()\ncount = 0\ni = 1\nwhile i < len(l):\n    if abs(l[i] - l[i - 1]) <= d:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "(n, d) = map(int, input().split())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nl.sort()\ncount = 0\ni = 1\nwhile i < len(l):\n    if abs(l[i] - l[i - 1]) <= d:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "(n, allowed) = list(map(int, input().split()))\nsticks = []\nfor i in range(n):\n    sticks.append(int(input()))\nsticks.sort()\ncnt = 0\ns = set()\nfor i in range(1, n):\n    if sticks[i] - sticks[i - 1] <= allowed and i not in s and (i - 1 not in s):\n        cnt += 1\n        s.add(i)\n        s.add(i - 1)\nprint(cnt)", "(n, d) = map(int, input().split())\narr = []\nfor i in range(n):\n    a = int(input())\n    arr.append(a)\narr.sort()\nans = 0\ni = 1\nwhile i < len(arr):\n    if arr[i] - arr[i - 1] <= d:\n        ans += 1\n        i += 2\n    else:\n        i += 1\nprint(ans)", "(n, d) = input().split()\nsticks = []\nfor x in range(0, int(n)):\n    chop = int(input())\n    sticks.append(chop)\nsticks.sort()\npair = 0\npairs = 0\nfor y in range(0, int(n)):\n    if y > 0:\n        if sticks[y] - sticks[y - 1] <= int(d) and pair == 0:\n            pairs = pairs + 1\n            pair = 1\n        else:\n            pair = 0\nprint(pairs)", "(N, D) = map(int, input().split())\nchopsticks = sorted([int(input()) for _ in range(N)])\np = 0\nc = 0\nwhile p < len(chopsticks) - 1:\n    if chopsticks[p + 1] - chopsticks[p] <= D:\n        c += 1\n        p += 2\n    else:\n        p += 1\nprint(c)", "(n, d) = map(int, input().split())\nl = []\nfor i in range(n):\n    x = int(input())\n    l.append(x)\nl.sort()\n(i, c) = (0, 0)\nwhile i < n - 1:\n    if l[i + 1] - l[i] <= d:\n        c += 1\n        i += 2\n    else:\n        i += 1\nprint(c)", "(N, K) = map(int, input().split(' '))\narr = list()\nfor i in range(N):\n    arr.append(int(input()))\narr.sort()\ncount = 0\ni = 0\nwhile i < N - 1:\n    if arr[i] >= arr[i + 1] - K:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "x = input().split()\nn = int(x[0])\nd = int(x[1])\nl = []\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\ncount = 0\ni = 0\nwhile i < n - 1:\n    if l[i + 1] - l[i] <= d:\n        count += 1\n        i += 2\n    else:\n        i += 1\nprint(count)", "def main():\n    (n, d) = map(int, input().split())\n    l = list()\n    for i in range(n):\n        l.append(int(input()))\n    l.sort()\n    ans = 0\n    j = 0\n    while j < n - 1:\n        if l[j + 1] - l[j] <= d:\n            ans += 1\n            j += 1\n        j += 1\n    print(ans)\nmain()", "(n, d) = map(int, input().split())\na = [0] * n\nfor i in range(n):\n    a[i] = int(input())\na.sort()\ncount = 0\ni = 0\nwhile i < n - 1:\n    if a[i + 1] - a[i] <= d:\n        i += 2\n        count += 1\n    else:\n        i += 1\nprint(count)", "def main():\n    (n, d) = map(int, input().split())\n    l = list()\n    for i in range(n):\n        l.append(int(input()))\n    l.sort()\n    ans = 0\n    j = 0\n    while j < n - 1:\n        if l[j + 1] - l[j] <= d:\n            ans += 1\n            j += 1\n        j += 1\n    print(ans)\nmain()", "(n, d) = map(int, input().split())\nl = []\nans = 0\nfor i in range(n):\n    l.append(int(input()))\nl.sort()\ni = 0\nwhile i < len(l) - 1:\n    if abs(l[i + 1] - l[i]) <= d:\n        ans += 1\n        i += 2\n    else:\n        i += 1\nprint(ans)", "t = [int(i) for i in input().split()]\narr = []\nans = 0\nfor i in range(t[0]):\n    arr.append(int(input()))\narr.sort()\ni = 0\nwhile i < len(arr) - 1:\n    if arr[i + 1] - arr[i] <= t[1]:\n        ans += 1\n        i += 2\n    else:\n        i += 1\nprint(ans)", "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        l = arr[:mid]\n        r = arr[mid:]\n        merge_sort(l)\n        merge_sort(r)\n        i = j = k = 0\n        while i < len(l) and j < len(r):\n            if l[i] < r[j]:\n                arr[k] = l[i]\n                i += 1\n            else:\n                arr[k] = r[j]\n                j += 1\n            k += 1\n        while i < len(l):\n            arr[k] = l[i]\n            i += 1\n            k += 1\n        while j < len(r):\n            arr[k] = r[j]\n            j += 1\n            k += 1\n\ndef main():\n    (N, D) = map(int, input().split(' '))\n    arr = []\n    for i in range(N):\n        arr.append(int(input()))\n    merge_sort(arr)\n    arr.sort()\n    l = 0\n    count = 0\n    while l < N - 1:\n        if arr[l + 1] - arr[l] <= D:\n            count += 1\n            l += 2\n        else:\n            l += 1\n    print(count)\nmain()"]