["import collections\nimport sys\n\ndef BFSS(graph, sv, n, col):\n    q = collections.deque([sv])\n    col[sv] = 1\n    while q:\n        v = q.popleft()\n        for u in range(n):\n            if col[u] == -1 and graph[u][v]:\n                q.append(u)\n                col[u] = 1 - col[v]\n            elif graph[u][v] and col[v] == col[u]:\n                return False\n    return True\n\ndef BFS(graph, n):\n    col = [-1] * n\n    for i in range(n):\n        if col[i] == -1:\n            ans = BFSS(graph, i, n, col)\n            if ans == False:\n                print('NO')\n                return\n    print('YES')\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        (x, y) = map(int, sys.stdin.readline().split())\n        graph[x - 1][y - 1] = 1\n        graph[y - 1][x - 1] = 1\n    for i in range(n):\n        graph[i][i] = 0\n        for j in range(i + 1, n):\n            graph[i][j] = 1 - graph[i][j]\n            graph[j][i] = 1 - graph[j][i]\n    BFS(graph, n)", "import collections\nimport sys\n\ndef BFSS(graph, sv, n, col):\n    q = collections.deque([sv])\n    col[sv] = 1\n    while q:\n        v = q.popleft()\n        for u in range(n):\n            if col[u] == -1 and graph[u][v]:\n                q.append(u)\n                col[u] = 1 - col[v]\n            elif graph[u][v] and col[v] == col[u]:\n                return False\n    return True\n\ndef BFS(graph, n):\n    col = [-1] * n\n    for i in range(n):\n        if col[i] == -1:\n            ans = BFSS(graph, i, n, col)\n            if ans == False:\n                print('NO')\n                return\n    print('YES')\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        (x, y) = map(int, sys.stdin.readline().split())\n        graph[x - 1][y - 1] = 1\n        graph[y - 1][x - 1] = 1\n    for i in range(n):\n        graph[i][i] = 0\n        for j in range(i + 1, n):\n            graph[i][j] = 1 - graph[i][j]\n            graph[j][i] = 1 - graph[j][i]\n    BFS(graph, n)", "import sys\nimport collections\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        (x, y) = map(int, sys.stdin.readline().split())\n        graph[x - 1][y - 1] = 1\n        graph[y - 1][x - 1] = 1\n    for i in range(n):\n        graph[i][i] = 0\n        for j in range(i + 1, n):\n            graph[i][j] = 1 - graph[i][j]\n            graph[j][i] = 1 - graph[j][i]\n\n    def BFS():\n        col = [-1] * n\n        for i in range(n):\n            if col[i] == -1:\n                q = collections.deque([i])\n                col[i] = 1\n                while q:\n                    v = q.popleft()\n                    for u in range(n):\n                        if col[u] == -1 and graph[u][v]:\n                            q.append(u)\n                            col[u] = 1 - col[v]\n                        elif graph[u][v] and col[v] == col[u]:\n                            return False\n        return True\n    print('YES' if BFS() else 'NO')", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = defaultdict(list)\n    mat = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        x = x - 1\n        y = y - 1\n        mat[x][y] = 1\n        mat[y][x] = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            mat[i][j] = 1 - mat[i][j]\n            mat[j][i] = 1 - mat[j][i]\n    for i in range(n):\n        mat[i][i] = 0\n\n    def isok():\n        col = [-1] * n\n        for i in range(n):\n            if col[i] == -1:\n                src = i\n                q = [src]\n                col[src] = 1\n                while q:\n                    t = q.pop(0)\n                    for i in range(n):\n                        if mat[t][i] and col[i] == -1:\n                            q.append(i)\n                            col[i] = 1 - col[t]\n                        elif mat[t][i] and col[t] == col[i]:\n                            return False\n        return True\n    print('YES' if isok() else 'NO')", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = defaultdict(list)\n    mat = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        x = x - 1\n        y = y - 1\n        mat[x][y] = 1\n        mat[y][x] = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            mat[i][j] = 1 - mat[i][j]\n            mat[j][i] = 1 - mat[j][i]\n    for i in range(n):\n        mat[i][i] = 0\n\n    def isok():\n        col = [-1] * n\n        for i in range(n):\n            if col[i] == -1:\n                src = i\n                q = [src]\n                col[src] = 1\n                while q:\n                    t = q.pop(0)\n                    for i in range(n):\n                        if mat[t][i] and col[i] == -1:\n                            q.append(i)\n                            col[i] = 1 - col[t]\n                        elif mat[t][i] and col[t] == col[i]:\n                            return False\n        return True\n    print('YES' if isok() else 'NO')", "def is2colorable(n, graph):\n    col = [-1 for i in range(n)]\n    for v in range(n):\n        if col[v] == -1:\n            tmp = []\n            tmp.append(v)\n            col[v] = 1\n            while len(tmp) > 0:\n                ind = tmp.pop()\n                for i in range(n):\n                    if graph[ind][i] == 1 and col[i] == -1:\n                        col[i] = 1 - col[ind]\n                        tmp.append(i)\n                    elif graph[ind][i] == 1 and col[ind] == col[i]:\n                        return False\n    return True\nfor t in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    graph = [[1 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        graph[i][i] = 0\n    while m > 0:\n        (a, b) = list(map(int, input().split()))\n        graph[a - 1][b - 1] = 0\n        graph[b - 1][a - 1] = 0\n        m -= 1\n    if is2colorable(n, graph):\n        print('YES')\n    else:\n        print('NO')", "from collections import deque\n\ndef find(graph):\n    n = len(graph)\n    A = [0] * n\n    Col = [0 for i in range(n)]\n    parent = [-1] * n\n    Q = [0] * n\n    for i in range(len(graph)):\n        if A[i] == 0:\n            Col[i] = 0\n            q = deque([i])\n            while q:\n                v = q.popleft()\n                Q[v] = 0\n                A[v] = 1\n                for adj in graph[v]:\n                    if adj != parent[v]:\n                        if A[adj] == 0:\n                            if Q[adj] == 0:\n                                q += [adj]\n                                Q[adj] = 1\n                                parent[adj] = v\n                                if Col[v] == 0:\n                                    Col[adj] = 1\n                                else:\n                                    Col[adj] = 0\n                            elif Col[adj] == Col[v]:\n                                return 0\n    return 1\n\ndef build(graph):\n    n = len(graph)\n    GG = [[] for i in range(n)]\n    for i in range(n):\n        A = [0 for jjj in range(n)]\n        for k in graph[i]:\n            A[k] = 1\n        for j in range(len(A)):\n            if A[j] == 0:\n                GG[i] += [j]\n    return GG\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().strip().split(' ')))\n    g = [[] for i in range(n)]\n    for _ in range(m):\n        (a, b) = list(map(int, input().strip().split(' ')))\n        a -= 1\n        b -= 1\n        g[a] += [b]\n        g[b] += [a]\n    if find(build(g)) == 1:\n        print('YES')\n    else:\n        print('NO')", "from collections import defaultdict\nT = int(input())\n\ndef func(p, graph, visited, color):\n    visited[p] = True\n    ans = True\n    for i in graph[p]:\n        if visited[i] and color[i] == color[p]:\n            return False\n        color[i] = not color[p]\n        if visited[i] is not True:\n            ans = ans and func(i, graph, visited, color)\n    return ans\nfor i in range(T):\n    graph = defaultdict(list)\n    (n, m) = map(int, input().split())\n    for j in range(m):\n        (x, y) = map(int, input().split())\n        graph[x].append(y)\n        graph[y].append(x)\n    inv_graph = {}\n    uni_set = set(range(1, n + 1))\n    for j in range(1, n + 1):\n        inv_graph[j] = list(uni_set - set(graph[j] + [j]))\n    visited = [False for i in range(n + 1)]\n    color = [False for i in range(n + 1)]\n    ans = True\n    for j in range(1, n + 1):\n        ans = ans and func(j, inv_graph, visited, color)\n    if ans:\n        print('YES')\n    else:\n        print('NO')", "def dfs():\n    q = list()\n    col = [-1 for x1 in range(n)]\n    col[0] = 0\n    q.append(0)\n    visited = [False for x in range(n)]\n    while True:\n        while len(q) != 0:\n            pr_node = q.pop(0)\n            visited[pr_node] = True\n            for i in range(n):\n                if a[pr_node][i] == 1:\n                    if col[i] == -1:\n                        q.append(i)\n                        col[i] = 1 - col[pr_node]\n                    elif col[i] == col[pr_node]:\n                        return False\n        k = all_visited(visited)\n        if k == -1:\n            return True\n        q.append(k)\n\ndef all_visited(v):\n    for i in range(n):\n        if not v[i]:\n            return i\n    return -1\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [[1 for x in range(n)] for y in range(n)]\n    for j in range(n):\n        a[j][j] = 0\n    for j in range(m):\n        (m1, m2) = map(int, input().split())\n        a[m1 - 1][m2 - 1] = 0\n        a[m2 - 1][m1 - 1] = 0\n    if dfs():\n        print('YES')\n    else:\n        print('NO')", "def check(A, B, confused, isconn):\n    if len(confused) == 0:\n        return 1\n    q = [i for i in confused]\n    posed = {}\n    while len(q) != 0:\n        curr = q[0]\n        if posed.get(curr, -1) == len(q):\n            break\n        chkA = 1\n        chkB = 1\n        for i in A:\n            if isconn.get((curr, i), -1) == -1 and isconn.get((i, curr), -1) == -1:\n                chkA = -1\n                break\n        for i in B:\n            if isconn.get((curr, i), -1) == -1 and isconn.get((i, curr), -1) == -1:\n                chkB = -1\n                break\n        if chkA == 1 and chkB == 1:\n            q.append(q.pop(0))\n            posed[curr] = len(q)\n        elif chkA == -1 and chkB != -1:\n            B.append(curr)\n            q.pop(0)\n        elif chkA != -1 and chkB == -1:\n            A.append(curr)\n            q.pop(0)\n        elif chkA == -1 and chkB == -1:\n            return -1\n    if len(q) == 0:\n        return 1\n    elif len(q) == 1:\n        A.append(q[0])\n        return 1\n    while len(q) != 0:\n        xA = []\n        xB = []\n        init_confused(q, xA, xB)\n        if len(xA) == 0 and len(xB) == 0:\n            for i in q:\n                A.append(i)\n            return 1\n        captainA = xA[0]\n        captainB = xB[0]\n        dick = {}\n        for i in q:\n            dick[i] = 1\n        adjA = []\n        adjB = []\n        for i in d[captainA]:\n            if dick.get(i, -1) != -1:\n                adjA.append(i)\n        for i in d[captainB]:\n            if dick.get(i, -1) != -1:\n                adjB.append(i)\n        for i in adjA:\n            if isconn.get((i, captainB), -1) == -1 and isconn.get((captainB, i), -1) == -1:\n                xA.append(i)\n                q.remove(i)\n        for i in adjB:\n            if isconn.get((i, captainA), -1) == -1 and isconn.get((captainA, i), -1) == -1:\n                xB.append(i)\n                q.remove(i)\n        if finalcheck(xA) == -1 or finalcheck(xB) == -1:\n            return -1\n        posed = {}\n        while len(q) != 0:\n            curr = q[0]\n            if posed.get(curr, -1) == len(q):\n                break\n            chkA = 1\n            chkB = 1\n            for i in xA:\n                if isconn.get((curr, i), -1) == -1 and isconn.get((i, curr), -1) == -1:\n                    chkA = -1\n                    break\n            for i in xB:\n                if isconn.get((curr, i), -1) == -1 and isconn.get((i, curr), -1) == -1:\n                    chkB = -1\n                    break\n            if chkA == 1 and chkB == 1:\n                q.append(q.pop(0))\n                posed[curr] = len(q)\n            elif chkA == -1 and chkB != -1:\n                xB.append(curr)\n                q.pop(0)\n            elif chkA != -1 and chkB == -1:\n                xA.append(curr)\n                q.pop(0)\n            elif chkA == -1 and chkB == -1:\n                return -1\n        if len(q) == 1:\n            xA.append(q[0])\n            q.pop(0)\n        if len(q) == 2:\n            xA.append(q[0])\n            xB.append(q[1])\n            q.pop(0)\n            q.pop(1)\n        for i in xA:\n            A.append(i)\n        for i in xB:\n            B.append(i)\n    return 1\n\ndef init_confused(q, xA, xB):\n    for i in q:\n        for j in q:\n            if i != j and isconn.get((i, j), -1) == -1 and (isconn.get((j, i), -1) == -1):\n                xA.append(i)\n                xB.append(j)\n                q.remove(i)\n                q.remove(j)\n                return\n\ndef init(d, dkeys, A, B, n):\n    for i in range(1, n + 1):\n        for j in range(len(dkeys)):\n            if i != dkeys[j] and isconn.get((dkeys[j], i), -1) == -1 and (isconn.get((i, dkeys[j]), -1) == -1):\n                A.append(dkeys[j])\n                B.append(i)\n                return\n\ndef finalcheck(A):\n    for i in A:\n        for j in A:\n            if i != j:\n                if isconn.get((j, i), -1) == -1 and isconn.get((i, j), -1) == -1:\n                    return -1\n    return 1\nfor _ in range(int(input())):\n    (n, m) = [int(i) for i in input().split()]\n    d = {}\n    degree = {}\n    isconn = {}\n    if n > 2 and m == 0:\n        print('NO')\n        continue\n    elif m == 0:\n        print('YES')\n        continue\n    for __ in range(m):\n        (a, b) = [int(i) for i in input().split()]\n        if a == b:\n            continue\n        if d.get(a, -1) == -1:\n            d[a] = [b]\n            isconn[a, b] = 1\n        elif isconn.get((a, b), -1) == -1 and isconn.get((b, a), -1) == -1:\n            d[a].append(b)\n            isconn[a, b] = 1\n        if d.get(b, -1) == -1:\n            d[b] = [a]\n        elif isconn.get((a, b), -1) == -1 and isconn.get((b, a), -1) == -1:\n            d[b].append(a)\n    if n == 1 or n == 2:\n        print('YES')\n        continue\n    for u in range(1, n + 1):\n        if d.get(u, -1) == -1:\n            d[u] = []\n    dkeys = [i for i in d.keys()]\n    for i in range(1, n + 1):\n        degree[i] = len(set(d[i]))\n    A = []\n    B = []\n    init(d, dkeys, A, B, n)\n    if len(A) == 0 and len(B) == 0:\n        print('YES')\n        continue\n    captA = A[0]\n    captB = B[0]\n    tempA = d[captA]\n    tempB = d[captB]\n    placed = {}\n    placed[captB] = 1\n    placed[captA] = 1\n    for i in d[captA]:\n        if isconn.get((i, captB), -1) == -1 and isconn.get((captB, i), -1) == -1:\n            A.append(i)\n            placed[i] = 1\n    for i in d[captB]:\n        if isconn.get((i, captA), -1) == -1 and isconn.get((captA, i), -1) == -1:\n            B.append(i)\n            placed[i] = 1\n    confused = []\n    for i in range(1, n + 1):\n        if placed.get(i, -1) == -1:\n            confused.append(i)\n    xxx = check(A, B, confused, isconn)\n    if xxx == -1:\n        print('NO')\n        continue\n    ans = 1\n    ans = finalcheck(A)\n    if ans == -1:\n        print('NO')\n        continue\n    ans = finalcheck(B)\n    if ans == -1:\n        print('NO')\n    else:\n        print('YES')", "from collections import deque\n\ndef check(A, _N):\n    flag = [-1] * _N\n    flag[0] = 1\n    dq = deque([])\n    dq.appendleft(0)\n    prev = 0\n    while len(dq) != 0:\n        u = dq.pop()\n        for v in range(_N):\n            if A[u][v] == 1 and flag[v] == -1:\n                flag[v] = 1 - flag[u]\n                dq.appendleft(v)\n            elif A[u][v] == 1 and flag[v] == flag[u]:\n                return False\n        if len(dq) == 0:\n            for v in range(1 + prev, _N):\n                if flag[v] == -1:\n                    prev = v\n                    flag[v] = 1\n                    dq.appendleft(v)\n                    break\n    return True\n_T = int(input())\nfor _t in range(_T):\n    (_N, _M) = list(map(int, input().strip().split()))\n    A = [[1 if i != j else 0 for i in range(_N)] for j in range(_N)]\n    for _m in range(_M):\n        (a, b) = list(map(int, input().strip().split()))\n        a -= 1\n        b -= 1\n        (A[a][b], A[b][a]) = (0, 0)\n    flag = check(A, _N)\n    if flag:\n        print('YES')\n    else:\n        print('NO')", "from time import time\n\nclass Queue(object):\n\n    def __init__(self, capacity):\n        (self.front, self.rear, self.size) = (0, -1, 0)\n        self.capacity = capacity\n        self.array = [0] * capacity\n\n    def isEmptyQueue(self):\n        return self.size == 0\n\n    def isFullQueue(self):\n        return self.size == self.capacity\n\n    def enqueue(self, value):\n        if self.isFullQueue():\n            return\n        self.rear = (self.rear + 1) % self.capacity\n        self.array[self.rear] = value\n        self.size += 1\n\n    def dequeue(self):\n        if self.isEmptyQueue():\n            return None\n        item = self.array[self.front]\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return item\n\n    def getFront(self):\n        return self.front\n\n    def getRear(self):\n        return self.rear\n\nclass graph(object):\n\n    def __init__(self, V):\n        self.adj = {}\n        if V != []:\n            for vertex in V:\n                self.adj[vertex] = []\n        self.V = V\n\n    def addEdge(self, u, v):\n        if self.adj.get(u, False):\n            self.adj[u].append(v)\n        else:\n            self.adj[u] = [v]\n\ndef isBipartite(G, s, n):\n    color[s] = 0\n    Q = Queue(n)\n    Q.enqueue(s)\n    while not Q.isEmptyQueue():\n        u = Q.dequeue()\n        if G.adj.get(u, 0) == 0:\n            continue\n        for v in G.adj[u]:\n            if color[v] == -1:\n                color[v] = 1 - color[u]\n                Q.enqueue(v)\n            elif color[u] == color[v]:\n                return False\n    return True\n\ndef addEdges(G, ed, n):\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if i != j and ed.get((i, j), 0) == 0:\n                G.addEdge(i, j)\n                G.addEdge(j, i)\n\ndef BFS(G, s, n):\n    visited[s] = True\n    Q = Queue(n)\n    Q.enqueue(s)\n    while not Q.isEmptyQueue():\n        u = Q.dequeue()\n        if G.adj.get(u, 0) == 0:\n            continue\n        for v in G.adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                Q.enqueue(v)\nfrom sys import stdin\nt = int(stdin.readline())\nstart = time()\nwhile t > 0:\n    (n, m) = list(map(int, stdin.readline().split()))\n    if time() - start > 3.65:\n        for i in range(m):\n            s = stdin.readline()\n        print('NO')\n        t -= 1\n        continue\n    ed = {}\n    G = graph([])\n    for i in range(m):\n        (a, b) = list(map(int, stdin.readline().split()))\n        G.addEdge(a, b)\n        G.addEdge(b, a)\n        ed[a, b] = 1\n        ed[b, a] = 1\n    visited = [False] * (n + 1)\n    components = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            BFS(G, i, n)\n            components += 1\n    if components > 2:\n        print('NO')\n        t -= 1\n        continue\n    G = graph([])\n    addEdges(G, ed, n)\n    res = True\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            res = res and isBipartite(G, i, n)\n    if res:\n        print('YES')\n    else:\n        print('NO')\n    t -= 1", "from time import time\n\nclass Queue(object):\n\n    def __init__(self, capacity):\n        (self.front, self.rear, self.size) = (0, -1, 0)\n        self.capacity = capacity\n        self.array = [0] * capacity\n\n    def isEmptyQueue(self):\n        return self.size == 0\n\n    def isFullQueue(self):\n        return self.size == self.capacity\n\n    def enqueue(self, value):\n        if self.isFullQueue():\n            return\n        self.rear = (self.rear + 1) % self.capacity\n        self.array[self.rear] = value\n        self.size += 1\n\n    def dequeue(self):\n        if self.isEmptyQueue():\n            return None\n        item = self.array[self.front]\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return item\n\n    def getFront(self):\n        return self.front\n\n    def getRear(self):\n        return self.rear\n\nclass graph(object):\n\n    def __init__(self, V):\n        self.adj = {}\n        if V != []:\n            for vertex in V:\n                self.adj[vertex] = []\n        self.V = V\n\n    def addEdge(self, u, v):\n        if self.adj.get(u, False):\n            self.adj[u].append(v)\n        else:\n            self.adj[u] = [v]\n\ndef isBipartite(G, s, n):\n    color[s] = 0\n    Q = Queue(n)\n    Q.enqueue(s)\n    while not Q.isEmptyQueue():\n        u = Q.dequeue()\n        if G.adj.get(u, 0) == 0:\n            continue\n        for v in G.adj[u]:\n            if color[v] == -1:\n                color[v] = 1 - color[u]\n                Q.enqueue(v)\n            elif color[u] == color[v]:\n                return False\n    return True\n\ndef addEdges(G, ed, n):\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if i != j and ed.get((i, j), 0) == 0:\n                G.addEdge(i, j)\n                G.addEdge(j, i)\n\ndef BFS(G, s, n):\n    visited[s] = True\n    Q = Queue(n)\n    Q.enqueue(s)\n    while not Q.isEmptyQueue():\n        u = Q.dequeue()\n        if G.adj.get(u, 0) == 0:\n            continue\n        for v in G.adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                Q.enqueue(v)\nfrom sys import stdin\nt = int(stdin.readline())\nstart = time()\nwhile t > 0:\n    (n, m) = list(map(int, stdin.readline().split()))\n    if time() - start > 3.65:\n        s = stdin.readline()\n        print('NO')\n        t -= 1\n        continue\n    ed = {}\n    G = graph([])\n    for i in range(m):\n        (a, b) = list(map(int, stdin.readline().split()))\n        G.addEdge(a, b)\n        G.addEdge(b, a)\n        ed[a, b] = 1\n        ed[b, a] = 1\n    visited = [False] * (n + 1)\n    components = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            BFS(G, i, n)\n            components += 1\n    if components > 2:\n        print('NO')\n        t -= 1\n        continue\n    G = graph([])\n    addEdges(G, ed, n)\n    res = True\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            res = res and isBipartite(G, i, n)\n    if res:\n        print('YES')\n    else:\n        print('NO')\n    t -= 1", "import queue\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    adj = []\n    for i in range(n):\n        adj.append(set(range(n)))\n        adj[i].discard(i)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        u = u - 1\n        v = v - 1\n        adj[u].discard(v)\n        adj[v].discard(u)\n    color = [0] * n\n    flag = 1\n    for v in range(n):\n        if color[v] == 0:\n            q = queue.Queue()\n            color[v] = 1\n            q.put(v)\n            while q.empty() != True:\n                u = q.get()\n                for w in adj[u]:\n                    if color[w] == 0:\n                        if color[u] == 1:\n                            color[w] = 2\n                        else:\n                            color[w] = 1\n                        q.put(w)\n                    elif color[u] == color[w]:\n                        flag = 0\n                        break\n                if flag == 0:\n                    break\n        if flag == 0:\n            break\n    if flag == 1:\n        print('YES')\n    else:\n        print('NO')", "from collections import deque\nt = int(input())\nfor idx in range(t):\n    [n, m] = [int(a) for a in input().split(' ')]\n    nodes = range(n)\n    edge = [[False for u in range(n)] for v in range(n)]\n    for edg in range(m):\n        [u, v] = [int(a) for a in input().split(' ')]\n        edge[u - 1][v - 1] = True\n    color = [0 for u in range(n)]\n    result = True\n    for start in range(n):\n        if result == False:\n            break\n        if color[start] != 0:\n            continue\n        queue = deque([start])\n        color[start] = 1\n        while len(queue) != 0:\n            u = queue.popleft()\n            c = color[u]\n            next_color = 1 if c == 2 else 2\n            for v in range(n):\n                if u == v or edge[u][v] or edge[v][u]:\n                    continue\n                if color[v] == 0:\n                    color[v] = next_color\n                    queue.append(v)\n                elif color[v] == color[u]:\n                    result = False\n                    break\n    if result:\n        print('YES')\n    else:\n        print('NO')", "from queue import *\nN = 10 ** 3\nAdj = [[1] * (N + 1) for i in range(0, N + 1)]\nt = int(input())\nColArr = [-1] * (N + 1)\n\ndef Biparatite(s):\n    ColArr[s] = 1\n    q = Queue()\n    q.put(s)\n    while q.empty() is not True:\n        u = q.get()\n        for v in range(1, n + 1):\n            if Adj[u][v] == 1 and ColArr[v] == -1:\n                q.put(v)\n                ColArr[v] = 1 - ColArr[u]\n            elif Adj[u][v] == 1 and ColArr[v] == ColArr[u]:\n                return False\n    return True\nwhile t:\n    t = t - 1\n    (n, m) = map(int, input().split())\n    li = []\n    for i in range(m):\n        li.append(tuple(map(int, input().split())))\n    for i in range(0, len(li)):\n        Adj[li[i][0]][li[i][1]] = 0\n        Adj[li[i][1]][li[i][0]] = 0\n    for i in range(1, n + 1):\n        Adj[i][i] = 0\n    ok = True\n    for i in range(1, n + 1):\n        if ColArr[i] == -1:\n            ok = ok and Biparatite(i)\n    if ok == True:\n        print('YES')\n    else:\n        print('NO')\n    for i in range(0, len(li)):\n        Adj[li[i][0]][li[i][1]] = 1\n        Adj[li[i][1]][li[i][0]] = 1\n    for i in range(1, n + 1):\n        ColArr[i] = -1", "from collections import deque\n\ndef fun(x, col):\n    if len(graph[x]) == 0:\n        return True\n    Q = deque([(x, col)])\n    color[x] = col\n    while Q:\n        (x, col) = Q.popleft()\n        for i in graph[x]:\n            if color[i] == -1:\n                color[i] = col ^ 1\n                Q.append((i, col ^ 1))\n            elif color[i] == col:\n                return False\n    return True\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    graph = {i: set(range(1, n + 1)) for i in range(1, n + 1)}\n    for i in range(1, n + 1):\n        graph[i].remove(i)\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        if b in graph[a]:\n            graph[a].remove(b)\n        if a in graph[b]:\n            graph[b].remove(a)\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            if fun(i, 1):\n                continue\n            else:\n                print('NO')\n                break\n    else:\n        print('YES')", "import random\nfor t in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    adj = {i: set() for i in range(1, n + 1)}\n    for i in range(m):\n        (a, b) = list(map(int, input().split()))\n        adj[a].add(b)\n        adj[b].add(a)\n    mv = 0\n    ind = -1\n    for i in range(1, n + 1):\n        if len(adj[i]) > mv:\n            mv = len(adj[i])\n            ind = i\n    possible = True\n    s1 = set()\n    s2 = set()\n    doubt = set()\n    s1.add(ind)\n    if ind == -1:\n        possible = n < 3\n    else:\n        for i in range(1, n + 1):\n            if i != ind:\n                if i in adj[ind]:\n                    doubt.add(i)\n                else:\n                    s2.add(i)\n        try:\n            l = list(s2)\n            for i in range(len(l)):\n                for j in range(i + 1, len(l)):\n                    if l[j] not in adj[l[i]]:\n                        possible = False\n                        break\n                if not possible:\n                    break\n            if possible:\n                while doubt and len(s1) + len(s2) < n:\n                    doubt2 = set()\n                    changed = False\n                    for d in doubt:\n                        if len(adj[d]) > 0.99 * n:\n                            ind = random.randint(1, n - 1)\n                            if ind in s1:\n                                s1.add(d)\n                            elif ind in s2:\n                                s2.add(d)\n                            else:\n                                s1.add(d)\n                            continue\n                        for b in s1:\n                            if b not in adj[d]:\n                                for c in s2:\n                                    if c not in adj[d]:\n                                        possible = False\n                                        break\n                                else:\n                                    s2.add(d)\n                                break\n                        else:\n                            for c in s2:\n                                if c not in adj[d]:\n                                    s1.add(d)\n                                    break\n                            else:\n                                doubt2.add(d)\n                        if not possible:\n                            break\n                    if len(doubt2) and len(doubt) == len(doubt2):\n                        l = list(doubt2)\n                        random.shuffle(l)\n                        v = l[len(l) // 2]\n                        doubt2.remove(v)\n                        if len(s1) < len(s2):\n                            s1.add(v)\n                        else:\n                            s2.add(v)\n                    doubt = doubt2\n        except Exception as e:\n            possible = False\n    if possible:\n        print('YES')\n    else:\n        print('NO')", "import sys\nimport numpy as np\n\ndef solve(n, ee):\n    g = np.ones((n, n), dtype=np.int64)\n    for i in range(n):\n        g[i, i] = 0\n    for (a, b) in ee:\n        g[a, b] = 0\n        g[b, a] = 0\n    ret = np.zeros(n, dtype=np.int64)\n    v = set(range(n))\n    q = []\n    while v:\n        x = next(iter(v))\n        v.remove(x)\n        q = [x]\n        ret[x] = 1\n        while q:\n            x = q[0]\n            q = q[1:]\n            cc = ret[x]\n            for y in np.where(g[x, :] == 1)[0]:\n                if ret[y] == cc:\n                    return 'NO'\n                elif ret[y] == 0:\n                    ret[y] = 3 - cc\n                    q += [y]\n                    v.remove(y)\n    return 'YES'\nf = sys.stdin\nt = int(f.readline())\nfor j in range(t):\n    (n, m) = map(int, f.readline().split())\n    ee = []\n    for i in range(m):\n        (x, y) = map(int, f.readline().split())\n        ee += [(x - 1, y - 1)]\n    print(solve(n, ee))"]