["import sys\nsys.setrecursionlimit(10 ** 5 + 1)\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (N, X) = list(map(int, input().split()))\n    tree = [[] for i in range(N)]\n    A = list(map(int, input().split()))\n    for i in range(N - 1):\n        (u, v) = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        tree[u] += [v]\n        tree[v] += [u]\n\n    def dfs(A, tree, parent, node):\n        ans = A[node]\n        for i in tree[node]:\n            if i != parent:\n                ans += dfs(A, tree, node, i)\n        return max(ans, -X)\n    print(dfs(A, tree, 0, 0))", "import sys\nsys.setrecursionlimit(10 ** 5 + 1)\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (N, X) = list(map(int, input().split()))\n    tree = [[] for i in range(N)]\n    A = list(map(int, input().split()))\n    for i in range(N - 1):\n        (u, v) = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        tree[u] += [v]\n        tree[v] += [u]\n\n    def dfs(A, tree, parent, node):\n        ans = A[node]\n        for i in tree[node]:\n            if i != parent:\n                ans += dfs(A, tree, node, i)\n        return max(ans, -X)\n    print(dfs(A, tree, 0, 0))", "import sys\nsys.setrecursionlimit(10 ** 5 + 1)\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (N, X) = list(map(int, input().split()))\n    tree = [[] for i in range(N)]\n    A = list(map(int, input().split()))\n    for i in range(N - 1):\n        (u, v) = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        tree[u] += [v]\n        tree[v] += [u]\n\n    def dfs(A, tree, parent, node):\n        ans = A[node]\n        for i in tree[node]:\n            if i != parent:\n                ans += dfs(A, tree, node, i)\n        return max(ans, -X)\n    print(dfs(A, tree, 0, 0))", "import sys\nsys.setrecursionlimit(100000)\nfor t in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append([])\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        l[u - 1].append(v - 1)\n        l[v - 1].append(u - 1)\n\n    def dfs(ver, parent):\n        res = 0\n        for kid in l[ver]:\n            if kid != parent:\n                res += dfs(kid, ver)\n        return max(a[ver] + res, -1 * x)\n    ans = dfs(0, 0)\n    print(ans)", "import sys\nsys.setrecursionlimit(100000)\nfor t in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append([])\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        l[u - 1].append(v - 1)\n        l[v - 1].append(u - 1)\n\n    def dfs(ver, parent):\n        res = 0\n        for kid in l[ver]:\n            if kid != parent:\n                res += dfs(kid, ver)\n        return max(a[ver] + res, -1 * x)\n    ans = dfs(0, 0)\n    print(ans)", "import sys\nsys.setrecursionlimit(100000)\nfor t in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append([])\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        l[u - 1].append(v - 1)\n        l[v - 1].append(u - 1)\n\n    def dfs(ver, parent):\n        res = 0\n        for kid in l[ver]:\n            if kid != parent:\n                res += dfs(kid, ver)\n        return max(a[ver] + res, -1 * x)\n    ans = dfs(0, 0)\n    print(ans)", "import sys\nsys.setrecursionlimit(100000)\nfor t in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append([])\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        l[u - 1].append(v - 1)\n        l[v - 1].append(u - 1)\n\n    def dfs(ver, parent):\n        res = 0\n        for kid in l[ver]:\n            if kid != parent:\n                res += dfs(kid, ver)\n        return max(a[ver] + res, -1 * x)\n    ans = dfs(0, 0)\n    print(ans)", "import sys\nsys.setrecursionlimit(100000)\n\ndef dfs(node, tree, par, X, values):\n    res = 0\n    for edge in tree[node]:\n        if edge == par:\n            continue\n        res += dfs(edge, tree, node, X, values)\n    return max(values[node] + res, -X)\nT = int(input())\nfor _ in range(T):\n    (N, X) = tuple(map(int, input().split()))\n    values = list(map(int, input().split()))\n    tree = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (i, j) = tuple(map(int, input().split()))\n        tree[i - 1].append(j - 1)\n        tree[j - 1].append(i - 1)\n    print(dfs(0, tree, -1, X, values))", "import sys\nsys.setrecursionlimit(100000)\n\ndef dfs(node, tree, par, X, values):\n    res = 0\n    for edge in tree[node]:\n        if edge == par:\n            continue\n        res += dfs(edge, tree, node, X, values)\n    return max(values[node] + res, -X)\nT = int(input())\nfor _ in range(T):\n    (N, X) = tuple(map(int, input().split()))\n    values = list(map(int, input().split()))\n    tree = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (i, j) = tuple(map(int, input().split()))\n        tree[i - 1].append(j - 1)\n        tree[j - 1].append(i - 1)\n    print(dfs(0, tree, -1, X, values))", "import sys\nsys.setrecursionlimit(100000)\nfor t in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append([])\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        l[u - 1].append(v - 1)\n        l[v - 1].append(u - 1)\n\n    def dfs(ver, parent):\n        res = 0\n        for kid in l[ver]:\n            if kid != parent:\n                res += dfs(kid, ver)\n        return max(a[ver] + res, -1 * x)\n    ans = dfs(0, 0)\n    print(ans)", "from bisect import bisect_left\nfrom heapq import heapify, heappush, heappop\nfrom collections import deque\nimport sys\nfrom math import gcd, sqrt, log10, log2, floor, ceil, sqrt\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\n\ndef il():\n    return [int(a) for a in input().strip().split()]\n\ndef ip():\n    return input().strip()\n\ndef ii():\n    return int(input())\n\ndef ot(in_p, *args, e=' '):\n    if type(in_p) == list:\n        print(*in_p, end=e)\n    if type(in_p) == str or type(in_p) == int:\n        print(in_p, end=e)\n        for l in args:\n            print(l, end=e)\n    print()\n\ndef a_pwr_n(a, n, mod):\n    if n == 1:\n        return a % mod\n    if n % 2 == 0:\n        val = a_pwr_n(a, n // 2, mod)\n        return val % mod * val % mod\n    else:\n        return a % mod * a_pwr_n(a, n - 1, mod) % mod\n\ndef rg(*ag):\n    if len(ag) == 3:\n        return range(ag[0], ag[1], ag[2])\n    elif len(ag) == 2:\n        return range(ag[0], ag[1])\n    elif len(ag) == 1:\n        return range(ag[0])\n    else:\n        raise 'invalid input'\n\ndef ispal(i, j, st):\n    while i <= j:\n        if st[i] == st[j]:\n            i = i + 1\n            j = j - 1\n        else:\n            return False\n    return True\nmod = 1000000000 + 7\ndx = [-1, -2, 1, 2, 2, -2, -1, 1]\ndy = [2, 1, 2, 1, -1, -1, -2, -2]\n\ndef dfs(n, ed, vi, x, arr):\n    vi[n] = True\n    c = arr[n]\n    for i in ed[n]:\n        if vi[i] == False:\n            dfs(i, ed, vi, x, arr)\n            c += arr[i]\n    arr[n] = max(-x, c)\nfor _ in range(ii()):\n    (n, x) = il()\n    arr = il()\n    ed = []\n    for k in range(n):\n        ed.append([])\n    for __ in range(n - 1):\n        (u, v) = il()\n        ed[u - 1].append(v - 1)\n        ed[v - 1].append(u - 1)\n    vi = [False] * n\n    dfs(0, ed, vi, x, arr)\n    print(arr[0])", "import sys, threading\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\nthreading.stack_size(10 ** 8)\n\ndef solve(graph, vis, curr, u, a, x):\n    vis[u] = True\n    curr = a[u - 1]\n    for neighbor in graph[u]:\n        if vis[neighbor] == False:\n            curr += solve(graph, vis, 0, neighbor, a, x)\n    return max(curr, -x)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    vis = [False] * (n + 1)\n    print(solve(d, vis, 0, 1, a, x))", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    for _ in range(int(input())):\n        (n, x) = map(int, input().split())\n        arr = list(map(int, input().split()))\n        graph = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            graph[a].append(b)\n            graph[b].append(a)\n\n        def dfs(node, par):\n            temp = arr[node]\n            for nie in graph[node]:\n                if nie != par:\n                    temp += max(dfs(nie, node), -x)\n            return temp\n        print(max(dfs(0, -1), -x))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys, threading\nimport collections\nsys.setrecursionlimit(10 ** 7)\nthreading.stack_size(10 ** 8)\n\ndef dfs(node, parent):\n    visited[node] = True\n    sum = 0\n    for nbr in graph[node]:\n        if visited[nbr]:\n            continue\n        sum += dfs(nbr, node)\n    return max(sum + wt[node], -x)\nt = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    wt = list(map(int, input().split()))\n    graph = collections.defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * (n + 1)\n    ans = dfs(0, 0)\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 8)\n\ndef dfs(x, parent):\n    someSum = values[x]\n    for nb in nbs[x]:\n        if nb != parent:\n            dfs(nb, x)\n        someSum += sums[nb]\n    sums[x] = max(someSum, cut_cost)\ncases = int(input())\nfor case in range(cases):\n    (n, cut_cost) = map(int, input().split())\n    cut_cost *= -1\n    values = [int(x) for x in input().split()]\n    sums = [0 for i in range(n)]\n    nbs = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        nbs[a].append(b)\n        nbs[b].append(a)\n    dfs(0, 0)\n    print(sums[0])", "import sys\nsys.setrecursionlimit(10 ** 8)\n\ndef dfs(x, parent):\n    someSum = values[x]\n    for nb in nbs[x]:\n        if nb != parent:\n            dfs(nb, x)\n        someSum += sums[nb]\n    sums[x] = max(someSum, cut_cost)\ncases = int(input())\nfor case in range(cases):\n    (n, cut_cost) = map(int, input().split())\n    cut_cost *= -1\n    values = [int(x) for x in input().split()]\n    sums = [0 for i in range(n)]\n    nbs = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        nbs[a].append(b)\n        nbs[b].append(a)\n    dfs(0, 0)\n    print(sums[0])", "import sys, threading\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 8)\nthreading.stack_size(10 ** 9)\nip = sys.stdin.readline\n\ndef do_dfs(tree, arr, vis, root, par, X):\n    tot = 0\n    vis[root] = True\n    for node in tree[root]:\n        if node != par and vis[node] == False:\n            tot += do_dfs(tree, arr, vis, node, root, X)\n    return max(-X, tot + arr[root - 1])\nfor _ in range(int(ip())):\n    (n, X) = map(int, ip().split())\n    arr = list(map(int, ip().split()))\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = map(int, ip().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    vis = [False] * (n + 1)\n    print(do_dfs(tree, arr, vis, 1, -1, X))", "import sys, threading\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 8)\nthreading.stack_size(10 ** 9)\n\ndef subrem(graph, vis, curr, u, a, x):\n    vis[u] = True\n    curr = a[u - 1]\n    for neighbor in graph[u]:\n        if vis[neighbor] == False:\n            curr += subrem(graph, vis, 0, neighbor, a, x)\n    return max(curr, -x)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    vis = [False] * (n + 1)\n    print(subrem(d, vis, 0, 1, a, x))", "import sys, threading\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\nthreading.stack_size(10 ** 8)\n\ndef solve(graph, vis, curr, u, a, x):\n    vis[u] = True\n    curr = a[u - 1]\n    for neighbor in graph[u]:\n        if vis[neighbor] == False:\n            curr += solve(graph, vis, 0, neighbor, a, x)\n    return max(curr, -x)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    vis = [False] * (n + 1)\n    print(solve(d, vis, 0, 1, a, x))", "import sys, resource\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\n\ndef solve(graph, vis, u, a, x):\n    vis[u] = True\n    curr = a[u]\n    for neighbor in graph[u]:\n        if vis[neighbor] == False:\n            curr += solve(graph, vis, neighbor, a, x)\n    return max(curr, -x)\nlimit = 10 ** 5 + 5\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.insert(0, 0)\n    d = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    vis = [False] * (n + 1)\n    print(solve(d, vis, 1, a, x))", "import sys, resource\nfrom collections import defaultdict\nresource.setrlimit(resource.RLIMIT_STACK, (2 ** 29, -1))\nsys.setrecursionlimit(10 ** 7)\n\ndef solve(graph, vis, u, a, x):\n    vis[u] = True\n    curr = a[u]\n    for neighbor in graph[u]:\n        if vis[neighbor] == False:\n            curr += solve(graph, vis, neighbor, a, x)\n    return max(curr, -x)\nlimit = 10 ** 5 + 5\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.insert(0, 0)\n    d = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n    vis = [False] * (n + 1)\n    print(solve(d, vis, 1, a, x))", "from sys import stdin, stdout\nfrom collections import defaultdict, deque\nimport resource, sys\nresource.setrlimit(resource.RLIMIT_STACK, (2 ** 29, -1))\nsys.setrecursionlimit(10 ** 7)\n\ndef dfs(node, parent):\n    cost = l[node]\n    for x in gp[node]:\n        if x != parent:\n            dfs(x, node)\n    co = 0\n    for x in gp[node]:\n        if x != parent:\n            co += max(-k, dp[x])\n    cost = max(cost + co, -k)\n    dp[node] = cost\n\ndef main():\n    try:\n        global gp, n, k, dp, l\n        (n, k) = In()\n        l = [0] + list(In())\n        dp = [-float('inf')] * (n + 1)\n        gp = defaultdict(list)\n        for i in range(n - 1):\n            (a, b) = In()\n            gp[a].append(b)\n            gp[b].append(a)\n        dfs(1, 1)\n        print(dp[1])\n    except:\n        pass\n\ndef add(a, b, c):\n    res = a + b\n    if res >= c:\n        return res - c\n    else:\n        return res\n\ndef mod(a, b, c):\n    res = a * b\n    if res >= c:\n        return res % c\n    else:\n        return res\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    w = a // gcd(a, b)\n    return w * b\n\ndef expo(a, b):\n    (x, y) = (1, a)\n    while b > 0:\n        if b & 1:\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\n\ndef power(a, b, m):\n    (x, y) = (1,)\n    while b > 0:\n        if b & 1:\n            x = mod(x, y, m)\n        y = mod(y, y, m)\n        b >>= 1\n    return x\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\nfor _ in range(I()):\n    main()", "from sys import stdin\nimport sys\nsys.setrecursionlimit(10 ** 6)\nt = int(stdin.readline())\nfor _ in range(t):\n    (n, x) = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    d = {}\n    for i in range(n - 1):\n        (p, q) = map(int, stdin.readline().split())\n        if p not in d.keys():\n            d[p] = [q]\n        else:\n            d[p].append(q)\n        if q not in d.keys():\n            d[q] = [p]\n        else:\n            d[q].append(p)\n    vis = [False] * (n + 1)\n\n    def sol(n):\n        vis[n] = True\n        val = a[n - 1]\n        if n in d:\n            for i in d[n]:\n                if not vis[i]:\n                    val = max(val - x, val + sol(i))\n        return val\n    print(max(-x, sol(1)))", "from sys import stdin\nimport sys\nsys.setrecursionlimit(10 ** 6)\nt = int(stdin.readline())\nfor _ in range(t):\n    (n, x) = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    d = {}\n    for i in range(n - 1):\n        (p, q) = map(int, stdin.readline().split())\n        if p not in d.keys():\n            d[p] = [q]\n        else:\n            d[p].append(q)\n        if q not in d.keys():\n            d[q] = [p]\n        else:\n            d[q].append(p)\n    vis = [False] * (n + 1)\n\n    def sol(n):\n        vis[n] = True\n        val = a[n - 1]\n        if n in d:\n            for i in d[n]:\n                if not vis[i]:\n                    val = max(val - x, val + sol(i))\n        return val\n    print(max(-x, sol(1)))", "import sys\nsys.setrecursionlimit(int(1000000.0))\n\ndef solve(node, parent):\n    ans1 = -x\n    ans2 = lis[node]\n    check = True\n    for child in tree[node]:\n        if child != parent:\n            check = False\n            ans2 += solve(child, node)\n    if check:\n        return max(ans1, lis[node])\n    return max(ans1, ans2)\nfor t in range(int(input())):\n    (n, x) = map(int, input().split())\n    from collections import defaultdict\n    tree = defaultdict(list)\n    lis = [0] + list(map(int, input().split()))\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    dp = defaultdict(int)\n    vis = [False for i in range(n + 1)]\n    print(solve(1, None))", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef dfs(p, prev):\n    (val, su, s) = (0, 0, 0)\n    for i in child[p]:\n        if i != prev:\n            b = dfs(i, p)\n            s = (b[0] + a[i - 1]) * -1\n            v = max(b[1], s - x)\n            val += v\n            su += b[0] + a[i - 1]\n    return [su, val]\nfor T in range(int(input())):\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    child = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    b = dfs(1, 0)\n    s = (b[0] + a[0]) * -1\n    v = max(b[1], s - x)\n    print(b[0] + a[0] + v)", "import sys\nsys.setrecursionlimit(10 ** 5 + 1)\n\ndef solve(v, i, g, w, k):\n    v[i] = 1\n    res = 0\n    for j in g[i]:\n        if v[j] == 0:\n            res += solve(v, j, g, w, k)\n    return max(w[i - 1] + res, -k)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    l = list(map(int, input().split()))\n    tre = {}\n    for i in range(1, n + 1):\n        tre[i] = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        tre[a].append(b)\n        tre[b].append(a)\n    visit = [0 for i in range(n + 1)]\n    print(solve(visit, 1, tre, l, x))", "import sys\nsys.setrecursionlimit(10 ** 5 + 1)\n\ndef RW():\n    return sys.stdin.readline().strip()\n\ndef RI():\n    return int(RW())\n\ndef RII():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\ndef RWI():\n    return [x for x in sys.stdin.readline().strip().split()]\nnb_test = RI()\nfor _ in range(nb_test):\n    (nb_nodes, xfactor) = RII()\n    wieghts = RII()\n    visited = [False] * (nb_nodes + 1)\n    adj = [list() for _ in range(nb_nodes + 1)]\n    for i in range(nb_nodes - 1):\n        (frm, tos) = RII()\n        adj[frm].append(tos)\n        adj[tos].append(frm)\n\n    def solve(node):\n        visited[node] = True\n        value = wieghts[node - 1]\n        for n in adj[node]:\n            if not visited[n]:\n                value = max(value - xfactor, value + solve(n))\n        return value\n    result = max(-xfactor, solve(1))\n    print(result)", "import sys\nsys.setrecursionlimit(10 ** 5 + 1)\n\ndef RW():\n    return sys.stdin.readline().strip()\n\ndef RI():\n    return int(RW())\n\ndef RII():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\ndef RWI():\n    return [x for x in sys.stdin.readline().strip().split()]\nnb_test = RI()\nfor _ in range(nb_test):\n    (nb_nodes, xfactor) = RII()\n    wieghts = RII()\n    visited = [False] * (nb_nodes + 1)\n    adj = [list() for _ in range(nb_nodes + 1)]\n    for i in range(nb_nodes - 1):\n        (frm, tos) = RII()\n        adj[frm].append(tos)\n        adj[tos].append(frm)\n\n    def solve(node):\n        visited[node] = True\n        value = wieghts[node - 1]\n        for n in adj[node]:\n            if not visited[n]:\n                value = max(value - xfactor, value + solve(n))\n        return value\n    result = max(-xfactor, solve(1))\n    print(result)", "import sys\nT = int(input())\nsys.setrecursionlimit(10000000)\n\ndef ish(a, b, c, d):\n    s = d[b]\n    for i in c[b]:\n        if i != a:\n            s += ish(b, i, c, d)\n    return -min(X, -s)\nfor i in range(T):\n    (N, X) = map(int, input().split())\n    d = list(map(int, input().split()))\n    t = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        t[u - 1].append(v - 1)\n        t[v - 1].append(u - 1)\n    print(ish(-1, 0, t, d))", "t = int(input())\nimport sys\nsys.setrecursionlimit(10000000)\n\ndef ish(par, me, child, vals):\n    s = vals[me]\n    for i in child[me]:\n        if i != par:\n            s += ish(me, i, child, vals)\n    return -min(x, -s)\nwhile t:\n    (n, x) = map(int, input().split())\n    vals = list(map(int, input().split()))\n    edges = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        edges[u - 1].append(v - 1)\n        edges[v - 1].append(u - 1)\n    print(ish(-1, 0, edges, vals))\n    t -= 1", "import sys\nsys.setrecursionlimit(100010)\nfrom collections import defaultdict as d\n\nclass Graph:\n\n    def __init__(self, V, l, X):\n        self.V = V\n        self.adj = d(list)\n        self.tr = l\n        self.l = d(int)\n        for i in range(1, self.V + 1):\n            self.l[i] = self.tr[i]\n        self.X = X\n\n    def addedge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def DFS_Util(self, x, visited):\n        visited[x] = True\n        for i in self.adj[x]:\n            if visited[i] == False:\n                self.l[x] += self.DFS_Util(i, visited)\n        return max(self.l[x], -X)\n\n    def DFS(self, x):\n        visited = [False] * (self.V + 1)\n        return self.DFS_Util(x, visited)\nfor _ in range(int(input())):\n    (N, X) = map(int, input().split())\n    A = list(map(int, input().split()))\n    l = [0] + A\n    g = Graph(N, l, X)\n    for i in range(N - 1):\n        (a, b) = map(int, input().split())\n        g.addedge(a, b)\n    print(g.DFS(1))", "import sys\nsys.setrecursionlimit(100010)\nfrom collections import defaultdict as d\n\nclass Graph:\n\n    def __init__(self, V, l, X):\n        self.V = V\n        self.adj = d(list)\n        self.tr = l\n        self.l = d(int)\n        for i in range(1, self.V + 1):\n            self.l[i] = self.tr[i]\n        self.X = X\n\n    def addedge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def DFS_Util(self, x, visited):\n        visited[x] = True\n        for i in self.adj[x]:\n            if visited[i] == False:\n                self.l[x] += self.DFS_Util(i, visited)\n        return max(self.l[x], -X)\n\n    def DFS(self, x):\n        visited = [False] * (self.V + 1)\n        return self.DFS_Util(x, visited)\nfor _ in range(int(input())):\n    (N, X) = map(int, input().split())\n    A = list(map(int, input().split()))\n    l = [0] + A\n    g = Graph(N, l, X)\n    for i in range(N - 1):\n        (a, b) = map(int, input().split())\n        g.addedge(a, b)\n    print(g.DFS(1))", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef maxP(root, Nodes, values, visited, X):\n    sumV = 0\n    for i in Nodes[root]:\n        if visited[i] == 0:\n            visited[i] = 1\n            sumV += maxP(i, Nodes, values, visited, X)\n    return max(values[root] + sumV, -1 * X)\nfor i in range(int(input())):\n    [N, X] = list(map(int, input().split()))\n    nodeValues = list(map(int, input().split()))\n    Nodes = {0: []}\n    visited = [1]\n    for j in range(N - 1):\n        visited.append(0)\n        (u, v) = list(map(int, input().split()))\n        try:\n            Nodes[u - 1].append(v - 1)\n        except:\n            Nodes[u - 1] = [v - 1]\n        try:\n            Nodes[v - 1].append(u - 1)\n        except:\n            Nodes[v - 1] = [u - 1]\n    print(maxP(0, Nodes, nodeValues, visited, X))", "from math import gcd\nimport bisect\nimport itertools\nimport sys\nfrom collections import deque\nI = lambda : sys.stdin.readline()\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(1000000)\n\ndef modu(a, m):\n    if a % m:\n        return a % m\n    return m\n\ndef mindiff(a):\n    b = a[:]\n    b.sort()\n    m = 10000000000\n    for i in range(len(b) - 1):\n        if b[i + 1] - b[i] < m:\n            m = b[i + 1] - b[i]\n    return m\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef merge(a, b):\n    i = 0\n    j = 0\n    c = 0\n    ans = []\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            ans.append(a[i])\n            i += 1\n        else:\n            ans.append(b[j])\n            c += len(a) - i\n            j += 1\n    ans += a[i:]\n    ans += b[j:]\n    return (ans, c)\n\ndef mergesort(a):\n    if len(a) == 1:\n        return (a, 0)\n    mid = len(a) // 2\n    (left, left_inversion) = mergesort(a[:mid])\n    (right, right_inversion) = mergesort(a[mid:])\n    (m, c) = merge(left, right)\n    c += left_inversion + right_inversion\n    return (m, c)\n\ndef is_prime(num):\n    if num == 1:\n        return False\n    if num == 2:\n        return True\n    if num == 3:\n        return True\n    if num % 2 == 0:\n        return False\n    if num % 3 == 0:\n        return False\n    t = 5\n    a = 2\n    while t <= int(math.sqrt(num)):\n        if num % t == 0:\n            return False\n        t += a\n        a = 6 - a\n    return True\n\ndef ceil(a, b):\n    if a % b == 0:\n        return a // b\n    else:\n        return a // b + 1\n\ndef ncr1(n, r):\n    s = 1\n    for i in range(min(n - r, r)):\n        s *= n - i\n        s %= mod\n        s *= pow(i + 1, mod - 2, mod)\n        s %= mod\n    return s\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef getsum(e, val, ver, v):\n    if len(e[ver]) == 0:\n        val[ver] = v[ver]\n        return val[ver]\n    if val[ver] != -10 ** 9:\n        return val[ver]\n    else:\n        val[ver] = v[ver]\n        for i in e[ver]:\n            val[i] = getsum(e, val, i, v)\n            val[ver] += val[i]\n        return val[ver]\n\ndef check(a, i, v, c, vis):\n    x = v[i]\n    for j in a[i]:\n        if vis[j] == 0:\n            vis[i] = 1\n            x += check(a, j, v, c, vis)\n    return max(x, -c)\nfor _ in range(int(input())):\n    (n, xx) = map(int, input().split())\n    v = [0] + list(map(int, I().split()))\n    a = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (x, y) = map(int, I().split())\n        a[x].append(y)\n        a[y].append(x)\n    if n == 1:\n        print(max(-xx, v[1]))\n    else:\n        vis = [0] * (n + 1)\n        vis[1] = 1\n        sys.stdout.write(str(check(a, 1, v, xx, vis)) + '\\n')", "import sys\nsys.setrecursionlimit(1000100)\nfor _ in range(int(input())):\n    (non, p) = map(int, input().strip(' ').split(' '))\n    t = [list() for i in range(non + 1)]\n    wt = list(map(int, input().strip(' ').split(' ')))\n    vt = [False] * (non + 1)\n    for i in range(non - 1):\n        (a, b) = map(int, input().strip(' ').split(' '))\n        t[a].append(b)\n        t[b].append(a)\n\n    def AN(nd):\n        vt[nd] = True\n        pt = wt[nd - 1]\n        for n in t[nd]:\n            if not vt[n]:\n                pt = max(pt - p, pt + AN(n))\n        return pt\n    print(max(-p, AN(1)))", "import sys\nsys.setrecursionlimit(100000)\nii = lambda : input().strip().split()\n\ndef dfs(u, v):\n    ret = 0\n    for n in adj[u]:\n        if n != v:\n            ret += dfs(n, u)\n    return max(wt[u] + ret, -x)\nfor _ in range(int(input().strip())):\n    (n, x) = map(int, ii())\n    wt = [0] + list(map(int, ii()))\n    adj = [[] for i in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, ii())\n        adj[u].append(v)\n        adj[v].append(u)\n    print(dfs(1, 0))", "import sys\nsys.setrecursionlimit(100010)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    ls = list(map(int, input().split()))\n    v = [False] * (n + 1)\n    adj = [list() for i in range(n + 1)]\n    for _ in range(n - 1):\n        (i, j) = map(int, input().split())\n        adj[i].append(j)\n        adj[j].append(i)\n\n    def dfs(node):\n        v[node] = True\n        Sum = ls[node - 1]\n        for i in adj[node]:\n            if not v[i]:\n                Sum += dfs(i)\n        return max(Sum, -x)\n    print(dfs(1))", "import sys\nsys.setrecursionlimit(100010)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    ls = list(map(int, input().split()))\n    v = [False] * (n + 1)\n    adj = [list() for i in range(n + 1)]\n    for _ in range(n - 1):\n        (i, j) = map(int, input().split())\n        adj[i].append(j)\n        adj[j].append(i)\n\n    def dfs(node):\n        v[node] = True\n        Sum = ls[node - 1]\n        for i in adj[node]:\n            if not v[i]:\n                Sum = max(Sum - x, Sum + dfs(i))\n        return Sum\n    print(max(-x, dfs(1)))", "import sys\nsys.setrecursionlimit(100010)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    weight = list(map(int, input().split()))\n    v = [False] * (n + 1)\n    adj = [list() for i in range(n + 1)]\n    for _ in range(n - 1):\n        (i, j) = map(int, input().split())\n        adj[i].append(j)\n        adj[j].append(i)\n\n    def dfs(node):\n        v[node] = True\n        tp = weight[node - 1]\n        for i in adj[node]:\n            if not v[i]:\n                tp = max(tp - x, tp + dfs(i))\n        return tp\n    print(max(-x, dfs(1)))", "import sys\nsys.setrecursionlimit(100010)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    weight = list(map(int, input().split()))\n    v = [False] * (n + 1)\n    adj = [list() for i in range(n + 1)]\n    for _ in range(n - 1):\n        (i, j) = map(int, input().split())\n        adj[i].append(j)\n        adj[j].append(i)\n\n    def dfs(node):\n        v[node] = True\n        tp = weight[node - 1]\n        for i in adj[node]:\n            if not v[i]:\n                tp = max(tp - x, tp + dfs(i))\n        return tp\n    print(max(-x, dfs(1)))", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100010)\nt = int(input())\nfor _ in range(t):\n    graph = defaultdict(list)\n\n    def addEdge(graph, u, v):\n        graph[u].append(v)\n        graph[v].append(u)\n    (a, b) = input().split()\n    n = int(a)\n    x = int(b)\n    arr = [int(g) for g in input().split()]\n    for i in range(n - 1):\n        (u, v) = input().split()\n        addEdge(graph, int(u), int(v))\n    visited = [False] * n\n\n    def subrem(node):\n        visited[node - 1] = True\n        aver = arr[node - 1]\n        for i in graph[node]:\n            if not visited[i - 1]:\n                aver = max(aver - x, aver + subrem(i))\n        return aver\n    result = max(-x, subrem(1))\n    print(result)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100010)\nt = int(input())\nfor _ in range(t):\n    graph = defaultdict(list)\n\n    def addEdge(graph, u, v):\n        graph[u].append(v)\n        graph[v].append(u)\n    (a, b) = input().split()\n    n = int(a)\n    x = int(b)\n    arr = [int(g) for g in input().split()]\n    for i in range(n - 1):\n        (u, v) = input().split()\n        addEdge(graph, int(u), int(v))\n    visited = [False] * (n + 1)\n\n    def subrem(node):\n        visited[node] = True\n        aver = arr[node - 1]\n        for i in graph[node]:\n            if not visited[i]:\n                aver = max(aver - x, aver + subrem(i))\n        return aver\n    result = max(-x, subrem(1))\n    print(result)", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(100005)\n\ndef max_p(root, parent):\n    total_profit = 0\n    for c in d[root]:\n        if c != parent:\n            total_profit += max_p(c, root)\n    return max(-x, arr[root] + total_profit)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    d = defaultdict(list)\n    arr.insert(0, None)\n    for i in range(n):\n        d[i + 1] = []\n    root = 1\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        d[a].append(b)\n        d[b].append(a)\n    p = max_p(root, -1)\n    print(p)", "import sys\nsys.setrecursionlimit(1000100)\nfor _ in range(int(input())):\n    (non, p) = map(int, input().strip(' ').split(' '))\n    t = [list() for i in range(non + 1)]\n    wt = list(map(int, input().strip(' ').split(' ')))\n    vt = [False] * (non + 1)\n    for i in range(non - 1):\n        (a, b) = map(int, input().strip(' ').split(' '))\n        t[a].append(b)\n        t[b].append(a)\n\n    def AN(nd):\n        vt[nd] = True\n        pt = wt[nd - 1]\n        for n in t[nd]:\n            if not vt[n]:\n                pt = max(pt - p, pt + AN(n))\n        return pt\n    print(max(-p, AN(1)))", "import sys\nsys.setrecursionlimit(100000)\n\ndef solve(root, parent):\n    value = A[root]\n    for u in graph[root]:\n        if u != parent:\n            value += solve(u, root)\n    return max(value, -X)\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    (N, X) = list(map(int, input().strip().split()))\n    A = [0] + list(map(int, input().strip().split()))\n    graph = {u: [] for u in range(1, N + 1)}\n    for i in range(N - 1):\n        (u, v) = list(map(int, input().strip().split()))\n        graph[u].append(v)\n        graph[v].append(u)\n    print(solve(1, None))", "import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef dfs(v, p):\n    s = a[v]\n    for u in adj[v]:\n        if u != p:\n            s += dfs(u, v)\n    return max(s, -x)\nt = int(input())\nfor w in range(t):\n    adj = {}\n    (n, x) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    a.insert(0, 0)\n    if n == 1:\n        if a[1] >= -x:\n            print(a[1])\n        else:\n            print(-x)\n    else:\n        for q in range(n - 1):\n            (c, d) = map(int, input().split())\n            if c not in adj:\n                adj[c] = [d]\n            else:\n                adj[c].append(d)\n            if d not in adj:\n                adj[d] = [c]\n            else:\n                adj[d].append(c)\n        p = dfs(1, -1)\n        print(p)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100010)\n\nclass Graph:\n\n    def __init__(self, V):\n        self.V = V\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def dfs(self, u, x, A, visted):\n        res = 0\n        visted[u - 1] = True\n        for v in self.graph[u]:\n            if not visted[v - 1]:\n                res += self.dfs(v, x, A, visted)\n        return max(res + A[u - 1], -x)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().strip().split())\n    A = list(map(int, input().strip().split()))\n    Tree = Graph(n)\n    for i in range(n - 1):\n        (u, v) = map(int, input().strip().split())\n        Tree.add_edge(u, v)\n    visted = n * [False]\n    g = Tree.dfs(1, x, A, visted)\n    print(g)", "import sys\nsys.setrecursionlimit(100010)\n\ndef maxsum(root):\n    visited[root] = True\n    cur_sum = A[root - 1]\n    for i in maptree[root]:\n        if not visited[i]:\n            cur_sum = max(cur_sum - X, cur_sum + maxsum(i))\n    return cur_sum\nT = int(input())\nfor _ in range(T):\n    (N, X) = map(int, input().split())\n    A = list(map(int, input().split()))\n    visited = [False] * (N + 1)\n    maptree = {i: [] for i in range(1, N + 1)}\n    for _ in range(N - 1):\n        (a, b) = map(int, input().split())\n        maptree[a].append(b)\n        maptree[b].append(a)\n    print(max(maxsum(1), -X))", "import sys\nsys.setrecursionlimit(100010)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().strip(' ').split(' '))\n    weight = list(map(int, input().strip(' ').split(' ')))\n    v = [False] * (n + 1)\n    adj = [list() for i in range(n + 1)]\n    for i in range(n - 1):\n        (i, j) = map(int, input().strip(' ').split(' '))\n        adj[i].append(j)\n        adj[j].append(i)\n\n    def tree(node):\n        v[node] = True\n        aver = weight[node - 1]\n        for n in adj[node]:\n            if not v[n]:\n                aver = max(aver - x, aver + tree(n))\n        return aver\n    result = max(-x, tree(1))\n    print(result)", "import sys\n\ndef max1(a, b):\n    if a > b:\n        return a\n    else:\n        return b\nsys.setrecursionlimit(500000000)\n\ndef dfs(graph, m, N, x, start, pt):\n    for edge in graph[start]:\n        if edge == pt:\n            pass\n        else:\n            dfs(graph, m, N, x, edge, start)\n    m[start] = N[start]\n    for i in graph[start]:\n        m[start] += m[i]\n    m[start] = max1(m[start], -x)\nt = int(input())\nwhile t > 0:\n    (n, x) = map(int, input().split())\n    N = list(map(int, input().split()))\n    graph = {k: [] for k in range(n)}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    m = [0 for j in range(n)]\n    dfs(graph, m, N, x, 0, -1)\n    print(m[0])\n    t = t - 1", "import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef fix():\n    queue = [0]\n    while queue != []:\n        pil = queue.pop(0)\n        for kk in chd[pil]:\n            chd[kk].remove(pil)\n            queue.append(kk)\n\ndef inorder(root):\n    ll = len(chd[root])\n    if ll == 0:\n        return val[root]\n    for i in range(ll):\n        val[root] = val[root] + max(-k, inorder(chd[root][i]))\n    return val[root]\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    val = list(map(int, input().split()))\n    chd = [[] for j in range(n)]\n    for __ in range(n - 1):\n        (u, v) = map(int, input().split())\n        if u == v:\n            continue\n        chd[u - 1].append(v - 1)\n        chd[v - 1].append(u - 1)\n    fix()\n    val[0] = inorder(0)\n    print(max(val[0], -k))", "import sys\nsys.setrecursionlimit(1000000000)\n\ndef dfs(root, par, value, dic, x):\n    sum1 = value[root]\n    for i in dic[root]:\n        if i != par:\n            sum2 = dfs(i, root, value, dic, x)\n            sum1 = sum1 + sum2\n    return max(sum1, -x)\n\ndef f():\n    t = int(input())\n    while t > 0:\n        (n, x) = map(int, input().split())\n        l = list(map(int, input().split()))\n        a = n - 1\n        g = [[] for i in range(n)]\n        while a > 0:\n            (u, v) = map(int, input().split())\n            g[u - 1].append(v - 1)\n            g[v - 1].append(u - 1)\n            a = a - 1\n        l = dfs(0, -1, l, g, x)\n        print(l)\n        t = t - 1\nf()", "import sys\n\ndef dfs(n):\n    sum = 0\n    bool[n] = True\n    for i in hash[n]:\n        if bool[i] == False:\n            sum += dfs(i)\n    return max(l[n] + sum, -x)\nsys.setrecursionlimit(10 ** 5 + 1)\nfrom collections import defaultdict\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    l = list(map(int, input().split()))\n    hash = defaultdict(set)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        hash[a - 1].add(b - 1)\n        hash[b - 1].add(a - 1)\n    bool = [False] * n\n    sys.stdout.write(str(dfs(0)) + '\\n')", "t = int(input())\nimport sys\nsys.setrecursionlimit(10000000)\n\ndef dfs(par, me, val, child):\n    sum = val[me]\n    for i in child[me]:\n        if i != par:\n            sum += dfs(me, i, val, child)\n    return max(-x, sum)\nwhile t:\n    t -= 1\n    (n, x) = map(int, input().split())\n    l = list(map(int, input().split()))\n    edge = n - 1\n    g = [[] for i in range(n)]\n    while edge:\n        edge -= 1\n        (r, s) = map(int, input().split())\n        g[r - 1].append(s - 1)\n        g[s - 1].append(r - 1)\n    print(dfs(-1, 0, l, g))", "import sys\nsys.setrecursionlimit(2000100)\np = 0\nt = 0\nwt = 0\nvt = 0\n\ndef AN(nd):\n    global p\n    global t\n    global wt\n    global vt\n    vt[nd] = True\n    pt = wt[nd - 1]\n    for n in t[nd]:\n        if not vt[n]:\n            pt = max(pt - p, pt + AN(n))\n    return pt\n\ndef test():\n    global p\n    global t\n    global wt\n    global vt\n    (non, p) = map(int, input().strip(' ').split(' '))\n    t = [list() for i in range(non + 1)]\n    wt = list(map(int, input().strip(' ').split(' ')))\n    vt = [False] * (non + 1)\n    for i in range(non - 1):\n        (a, b) = map(int, input().strip(' ').split(' '))\n        t[a].append(b)\n        t[b].append(a)\n    print(max(-p, AN(1)))\n    return 0\nt = int(input())\nfor i in range(t):\n    testy = test()", "import sys\nsys.setrecursionlimit(100010)\n\ndef CalcolaAlbero(nodo):\n    valore = A[nodo]\n    if len(V[nodo]) == 0:\n        return max(valore, -X)\n    for v in V[nodo]:\n        if not Visitati[v]:\n            Visitati[v] = True\n            valore = max(valore - X, valore + CalcolaAlbero(v))\n    return valore\nT = int(input())\nfor t in range(T):\n    riga = input().split()\n    N = int(riga[0])\n    X = int(riga[1])\n    riga = input().split()\n    A = [int(a) for a in riga]\n    V = [[] for x in range(N)]\n    for n in range(N - 1):\n        riga = input().split()\n        riga = [int(a) - 1 for a in riga]\n        V[riga[0]].append(riga[1])\n        V[riga[1]].append(riga[0])\n    nodo = 0\n    Visitati = [False for x in range(N)]\n    Visitati[0] = True\n    print(max(CalcolaAlbero(0), -X))", "from sys import setrecursionlimit\nsetrecursionlimit(100000)\n\ndef dfs(u, p):\n    global x\n    val = arr[u]\n    kek = 0\n    for v in graph[u]:\n        if v == p:\n            continue\n        tmp = dfs(v, u)\n        val += tmp[0]\n        kek += tmp[1]\n    if val - kek * x < -x:\n        return (0, 1)\n    return (val, kek)\n\ndef main():\n    global arr, graph, x\n    parent = [0] * 100000\n    for _ in range(int(input())):\n        (n, x) = map(int, input().split())\n        graph = [[] for _ in range(n)]\n        arr = list(map(int, input().split()))\n        for _ in range(1, n):\n            (u, v) = map(int, input().split())\n            u -= 1\n            v -= 1\n            graph[u].append(v)\n            graph[v].append(u)\n        ans = dfs(0, -1)\n        print(ans[0] - x * ans[1])\n    return 0\nmain()", "from sys import setrecursionlimit\nsetrecursionlimit(100001)\n\ndef dfs(u, p):\n    global x\n    val = arr[u]\n    kek = 0\n    for v in graph[u]:\n        if v == p:\n            continue\n        tmp = dfs(v, u)\n        val += tmp[0]\n        kek += tmp[1]\n    if val - kek * x < -x:\n        return (0, 1)\n    return (val, kek)\n\ndef main():\n    global arr, graph, x\n    parent = [0] * 100000\n    for _ in range(int(input())):\n        (n, x) = map(int, input().split())\n        graph = [[] for _ in range(n)]\n        arr = list(map(int, input().split()))\n        for _ in range(1, n):\n            (u, v) = map(int, input().split())\n            u -= 1\n            v -= 1\n            graph[u].append(v)\n            graph[v].append(u)\n        ans = dfs(0, -1)\n        print(ans[0] - x * ans[1])\n    return 0\nmain()", "from sys import setrecursionlimit\nsetrecursionlimit(100010)\n\ndef dfs(u, p):\n    global x\n    val = arr[u]\n    kek = 0\n    for v in graph[u]:\n        if v == p:\n            continue\n        tmp = dfs(v, u)\n        val += tmp[0]\n        kek += tmp[1]\n    if val - kek * x < -x:\n        return (0, 1)\n    return (val, kek)\n\ndef main():\n    global arr, graph, x\n    parent = [0] * 100000\n    for _ in range(int(input())):\n        (n, x) = map(int, input().split())\n        graph = [[] for _ in range(n)]\n        arr = list(map(int, input().split()))\n        for _ in range(1, n):\n            (u, v) = map(int, input().split())\n            u -= 1\n            v -= 1\n            graph[u].append(v)\n            graph[v].append(u)\n        ans = dfs(0, -1)\n        print(ans[0] - x * ans[1])\n    return 0\nmain()", "from collections import deque\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.value = key\n        self.parent = None\n        self.children_sum = 0\n        self.adjacent = set()\n\ndef bfs(adj_list, number_nodes):\n    n = list()\n    q = deque()\n    parent = [0] * number_nodes\n    q.append(0)\n    n.append(0)\n    visited = set()\n    visited.add(0)\n    while q:\n        x = q.popleft()\n        for i in adj_list[x]:\n            if i not in visited:\n                q.append(i)\n                visited.add(i)\n                parent[i] = x\n                n.append(i)\n    return (n, parent)\nt = int(input())\nwhile t:\n    t -= 1\n    (n, x) = map(int, input().split())\n    nodes = list()\n    flag1 = False\n    flag2 = False\n    total = 0\n    nodes = list(map(int, input().split()))\n    adj_list = [set() for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj_list[v - 1].add(u - 1)\n        adj_list[u - 1].add(v - 1)\n    (node_list, parent_list) = bfs(adj_list, n)\n    values = [0] * n\n    children_sum = [0] * n\n    for i in range(n - 1, 0, -1):\n        values[node_list[i]] = max(-x, nodes[node_list[i]] + children_sum[node_list[i]])\n        children_sum[parent_list[node_list[i]]] += values[node_list[i]]\n    print(max(-x, nodes[0] + children_sum[0]))", "import sys\nsys.setrecursionlimit(100000)\n\ndef postord(tree, arr, ind, parent, x):\n    v = arr[ind - 1]\n    try:\n        for i in tree[ind]:\n            if i != parent:\n                v += postord(tree, arr, i, ind, x)\n    except:\n        pass\n    return max(v, -x)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    tree = {}\n    arr = list(map(int, input().split()))\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        try:\n            tree[u].append(v)\n        except:\n            tree[u] = [v]\n        try:\n            tree[v].append(u)\n        except:\n            tree[v] = [u]\n    print(postord(tree, arr, 1, -1, x))", "import sys\nsys.setrecursionlimit(100010)\nfor _ in range(int(input())):\n    (N, X) = map(int, input().split())\n    A = list(map(int, input().split()))\n    Visited = [False] * (N + 1)\n    adj = [list() for i in range(N + 1)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def tree(node):\n        Visited[node] = True\n        nodeValue = A[node - 1]\n        for n in adj[node]:\n            if not Visited[n]:\n                nodeValue = max(nodeValue - X, nodeValue + tree(n))\n        return nodeValue\n    result = max(-X, tree(1))\n    print(result)", "import sys\nsys.setrecursionlimit(200000)\n\ndef f(x, a, b, y, c):\n    l = b[x]\n    d = 0\n    c[x] = 1\n    for i in range(len(l)):\n        if c[l[i]] == 1:\n            continue\n        d += f(l[i], a, b, y, c)\n    if d + a[x] < y * -1:\n        return y * -1\n    else:\n        return d + a[x]\nfor _ in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    b = [[] for x in range(n)]\n    c = [0] * n\n    for i in range(n - 1):\n        (x, y) = [int(k) for k in input().split()]\n        b[x - 1].append(y - 1)\n        b[y - 1].append(x - 1)\n    print(f(0, a, b, m, c))", "import sys\nsys.setrecursionlimit(1000000)\nfrom collections import defaultdict\n\ndef get_cost_grid(adj_map, val_map, X):\n    root = 1\n\n    def DFS(root, parent):\n        sum = val_map[root - 1]\n        for child in adj_map[root]:\n            if child != parent:\n                sum += DFS(child, root)\n        return max(sum, -X)\n    return DFS(root, -root)\n\ndef main():\n    try:\n        test_cases = int(input())\n        while test_cases:\n            dict = defaultdict(list)\n            (N, X) = [int(i) for i in input().split()]\n            nums = [int(i) for i in input().split()]\n            counter = N - 1\n            while counter:\n                (node1, node2) = [int(i) for i in input().split()]\n                dict[node1].append(node2)\n                dict[node2].append(node1)\n                counter -= 1\n            if N == 1:\n                if nums[0] < -1 * X:\n                    print(str(-1 * X))\n                else:\n                    print(str(nums[0]))\n            else:\n                x = get_cost_grid(dict, nums, X)\n                print(str(x))\n            test_cases -= 1\n    except:\n        print('Error')\nmain()", "import sys\nsys.setrecursionlimit(1500000)\n\ndef dp(adj, v, par, x):\n    res = wt[v - 1]\n    for i in adj[v]:\n        if i != par:\n            res += dp(adj, i, v, x)\n    return max(-x, res)\nT = int(input())\nfor t in range(T):\n    (n, x) = map(int, input().strip(' ').split(' '))\n    wt = list(map(int, input().strip(' ').split(' ')))\n    adj = [list() for i in range(n + 1)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().strip(' ').split(' '))\n        adj[a].append(b)\n        adj[b].append(a)\n    print(dp(adj, 1, 1, x))", "import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef fun():\n    (n, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    g = {x: [] for x in range(1, n + 1)}\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n\n    def dfs(p, v):\n        s = a[v - 1]\n        for u in g[v]:\n            if u != p:\n                s += dfs(v, u)\n        return max(s, -x)\n    print(dfs(0, 1))\nfor _ in range(int(input())):\n    fun()", "import sys\nsys.setrecursionlimit(10 ** 5)\nt = int(input())\n\ndef tree(node):\n    visited[node] = True\n    res = weight[node - 1]\n    for i in adjacencyList[node]:\n        if not visited[i]:\n            res = max(res - x, res + tree(i))\n    return res\nwhile t:\n    t -= 1\n    (n, x) = map(int, input().strip().split())\n    weight = list(map(int, input().strip().split()))\n    visited = [False] * (n + 1)\n    adjacencyList = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().strip().split())\n        adjacencyList[u].append(v)\n        adjacencyList[v].append(u)\n    y = tree(1)\n    print(max(-x, y))", "import sys\nsys.setrecursionlimit(10 ** 5)\nt = int(input())\n\ndef tree(node):\n    visited[node] = True\n    res = weight[node - 1]\n    for i in adjacencyList[node]:\n        if not visited[i]:\n            res = max(res - x, res + tree(i))\n    return res\nwhile t:\n    t -= 1\n    (n, x) = map(int, input().strip().split())\n    weight = list(map(int, input().strip().split()))\n    visited = [False] * (n + 1)\n    adjacencyList = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().strip().split())\n        adjacencyList[u].append(v)\n        adjacencyList[v].append(u)\n    y = tree(1)\n    print(max(-x, y))", "import sys\nsys.setrecursionlimit(10 ** 6)\nt = int(input())\n\ndef tree(node):\n    visited[node] = True\n    res = weight[node - 1]\n    for i in adjacencyList[node]:\n        if not visited[i]:\n            res = max(res - x, res + tree(i))\n    return res\nwhile t:\n    t -= 1\n    (n, x) = map(int, input().strip().split())\n    weight = list(map(int, input().strip().split()))\n    visited = [False] * (n + 1)\n    adjacencyList = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().strip().split())\n        adjacencyList[u].append(v)\n        adjacencyList[v].append(u)\n    y = tree(1)\n    print(max(-x, y))", "import sys\nsys.setrecursionlimit(100010)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().strip(' ').split(' '))\n    weight = list(map(int, input().strip(' ').split(' ')))\n    v = [False] * (n + 1)\n    adj = [list() for i in range(n + 1)]\n    for i in range(n - 1):\n        (i, j) = map(int, input().strip(' ').split(' '))\n        adj[i].append(j)\n        adj[j].append(i)\n\n    def tree(node):\n        v[node] = True\n        aver = weight[node - 1]\n        for n in adj[node]:\n            if not v[n]:\n                aver = max(aver - x, aver + tree(n))\n        return aver\n    result = max(-x, tree(1))\n    print(result)", "import sys\nsys.setrecursionlimit(10 ** 5 + 1)\ninf = int(10 ** 20)\nmax_val = inf\nmin_val = -inf\nRW = lambda : sys.stdin.readline().strip()\nRI = lambda : int(RW())\nRMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRWI = lambda : [x for x in sys.stdin.readline().strip().split()]\nnb_test = RI()\nfor _ in range(nb_test):\n    (nb_nodes, xfactor) = RMI()\n    wieghts = RMI()\n    visited = [False] * (nb_nodes + 1)\n    adj = [list() for _ in range(nb_nodes + 1)]\n    for i in range(nb_nodes - 1):\n        (frm, tos) = RMI()\n        adj[frm].append(tos)\n        adj[tos].append(frm)\n\n    def solve(node):\n        visited[node] = True\n        value = wieghts[node - 1]\n        for n in adj[node]:\n            if not visited[n]:\n                value = max(value - xfactor, value + solve(n))\n        return value\n    result = max(-xfactor, solve(1))\n    print(result)", "import sys\nsys.setrecursionlimit(100100)\n\nclass Graph:\n\n    def __init__(self):\n        self.Graph = [[] * i for i in range(n + 10)]\n\n    def add_edge_between(self, u, v):\n        self.Graph[u].append(v)\n        self.Graph[v].append(u)\n\n    def subtree_sum_again_with_vertex(self, v):\n        visited[v] = True\n        for i in self.Graph[v]:\n            if not visited[i]:\n                self.subtree_sum_again_with_vertex(i)\n                value_of_node[v] = value_of_node[v] + value_of_node[i]\n        if value_of_node[v] <= x:\n            value_of_node[v] = x\nfor _ in range(int(input())):\n    (n, y) = map(int, input().split())\n    value_of_node = [0] + list(map(int, input().split()))\n    x = -1 * y\n    g = Graph()\n    for _ in range(n - 1):\n        (edge1, edge2) = map(int, input().split())\n        g.add_edge_between(edge1, edge2)\n    visited = [False] * (n + 10)\n    g.subtree_sum_again_with_vertex(1)\n    print(value_of_node[1])\n    del visited, g, value_of_node, n, y, x", "import sys\nsys.setrecursionlimit(100010)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().strip(' ').split(' '))\n    weight = list(map(int, input().strip(' ').split(' ')))\n    v = [False] * (n + 1)\n    adj = [list() for i in range(n + 1)]\n    for i in range(n - 1):\n        (i, j) = map(int, input().strip(' ').split(' '))\n        adj[i].append(j)\n        adj[j].append(i)\n\n    def tree(node):\n        v[node] = True\n        aver = weight[node - 1]\n        for n in adj[node]:\n            if not v[n]:\n                aver = max(aver - x, aver + tree(n))\n        return aver\n    result = max(-x, tree(1))\n    print(result)", "from math import gcd\nimport bisect\nimport itertools\nimport sys\nfrom collections import deque\nI = lambda : sys.stdin.readline()\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(1000000)\n\ndef modu(a, m):\n    if a % m:\n        return a % m\n    return m\n\ndef mindiff(a):\n    b = a[:]\n    b.sort()\n    m = 10000000000\n    for i in range(len(b) - 1):\n        if b[i + 1] - b[i] < m:\n            m = b[i + 1] - b[i]\n    return m\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef merge(a, b):\n    i = 0\n    j = 0\n    c = 0\n    ans = []\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            ans.append(a[i])\n            i += 1\n        else:\n            ans.append(b[j])\n            c += len(a) - i\n            j += 1\n    ans += a[i:]\n    ans += b[j:]\n    return (ans, c)\n\ndef mergesort(a):\n    if len(a) == 1:\n        return (a, 0)\n    mid = len(a) // 2\n    (left, left_inversion) = mergesort(a[:mid])\n    (right, right_inversion) = mergesort(a[mid:])\n    (m, c) = merge(left, right)\n    c += left_inversion + right_inversion\n    return (m, c)\n\ndef is_prime(num):\n    if num == 1:\n        return False\n    if num == 2:\n        return True\n    if num == 3:\n        return True\n    if num % 2 == 0:\n        return False\n    if num % 3 == 0:\n        return False\n    t = 5\n    a = 2\n    while t <= int(math.sqrt(num)):\n        if num % t == 0:\n            return False\n        t += a\n        a = 6 - a\n    return True\n\ndef ceil(a, b):\n    if a % b == 0:\n        return a // b\n    else:\n        return a // b + 1\n\ndef ncr1(n, r):\n    s = 1\n    for i in range(min(n - r, r)):\n        s *= n - i\n        s %= mod\n        s *= pow(i + 1, mod - 2, mod)\n        s %= mod\n    return s\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef getsum(e, val, ver, v):\n    if len(e[ver]) == 0:\n        val[ver] = v[ver]\n        return val[ver]\n    if val[ver] != -10 ** 9:\n        return val[ver]\n    else:\n        val[ver] = v[ver]\n        for i in e[ver]:\n            val[i] = getsum(e, val, i, v)\n            val[ver] += val[i]\n        return val[ver]\n\ndef check(a, i, v, c, vis):\n    x = v[i]\n    for j in a[i]:\n        if vis[j] == 0:\n            vis[i] = 1\n            x += check(a, j, v, c, vis)\n    return max(x, -c)\nfor _ in range(int(input())):\n    (n, xx) = map(int, input().split())\n    v = [0] + list(map(int, I().split()))\n    a = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (x, y) = map(int, I().split())\n        a[x].append(y)\n        a[y].append(x)\n    if n == 1:\n        print(max(-xx, v[1]))\n    else:\n        vis = [0] * (n + 1)\n        vis[1] = 1\n        sys.stdout.write(str(check(a, 1, v, xx, vis)) + '\\n')", "t = int(input())\nwhile t > 0:\n    parent = []\n    child = []\n    visited = []\n    bfs = []\n    neighbour = []\n    (n, x) = map(int, input().split())\n    for i in range(n + 1):\n        neighbour.append(list())\n        parent.append(0)\n        visited.append(0)\n        child.append(list())\n    values = list(map(int, input().split()))\n    values.insert(0, 0)\n    for i in range(n - 1):\n        (p, q) = map(int, input().split())\n        neighbour[p].append(q)\n        neighbour[q].append(p)\n    neighbour[0] = [1]\n    neighbour[1].append(0)\n    i = 0\n    j = 0\n    current = [0]\n    visited[0] = 1\n    while i <= n:\n        for v in neighbour[j]:\n            if visited[v] == 0:\n                visited[v] = 1\n                current.append(v)\n                parent[v] = j\n                child[j].append(v)\n        i += 1\n        if i != n + 1:\n            j = current[i]\n        else:\n            j = current[i - 1]\n    i = n\n    while i >= 1:\n        if values[current[i]] < 0 and -values[current[i]] >= x:\n            values[parent[current[i]]] -= x\n        else:\n            values[parent[current[i]]] += values[current[i]]\n        i -= 1\n    print(values[0])\n    t -= 1", "import sys\n\ndef dfs(b, c, a, x, s, p):\n    for i in b[s]:\n        if i != p:\n            dfs(b, c, a, x, i, s)\n    c[s] = a[s]\n    for i in b[s]:\n        c[s] += c[i]\n    if c[s] <= -x:\n        c[s] = -x\nsys.setrecursionlimit(3000000)\nt = int(input())\nfor t1 in range(t):\n    (n, x) = [int(j) for j in input().split()]\n    a = [int(j) for j in input().split()]\n    b = {i: [] for i in range(0, n)}\n    for i in range(n - 1):\n        (u, v) = [int(j) for j in input().split()]\n        b[u - 1].append(v - 1)\n        b[v - 1].append(u - 1)\n    c = [0 for j in range(n)]\n    dfs(b, c, a, x, 0, -1)\n    print(c[0])", "import sys\nsys.setrecursionlimit(1000100)\nfor _ in range(int(input())):\n    (non, p) = map(int, input().strip(' ').split(' '))\n    t = [list() for i in range(non + 1)]\n    wt = list(map(int, input().strip(' ').split(' ')))\n    vt = [False] * (non + 1)\n    for i in range(non - 1):\n        (a, b) = map(int, input().strip(' ').split(' '))\n        t[a].append(b)\n        t[b].append(a)\n\n    def AN(nd):\n        vt[nd] = True\n        pt = wt[nd - 1]\n        for n in t[nd]:\n            if not vt[n]:\n                pt = max(pt - p, pt + AN(n))\n        return pt\n    print(max(-p, AN(1)))", "import sys\nsys.setrecursionlimit(100010)\nfor _ in range(int(input())):\n    (n, x) = map(int, input().strip(' ').split(' '))\n    w = list(map(int, input().strip(' ').split(' ')))\n    v = [False] * (n + 1)\n    tree = [list() for i in range(n + 1)]\n    for i in range(n - 1):\n        (i, j) = map(int, input().strip(' ').split(' '))\n        tree[i].append(j)\n        tree[j].append(i)\n\n    def beta(node):\n        v[node] = True\n        agg = w[node - 1]\n        for n in tree[node]:\n            if not v[n]:\n                agg = max(agg - x, agg + beta(n))\n        return agg\n    print(max(-x, beta(1)))", "import sys\nsys.setrecursionlimit(100010)\nfor _ in range(int(input())):\n    (nnn, x) = map(int, input().strip(' ').split(' '))\n    ttt = [list() for i in range(nnn + 1)]\n    www = list(map(int, input().strip(' ').split(' ')))\n    vvv = [False] * (nnn + 1)\n    for i in range(nnn - 1):\n        (u, v) = map(int, input().strip(' ').split(' '))\n        ttt[u].append(v)\n        ttt[v].append(u)\n\n    def alpha(node):\n        vvv[node] = True\n        profit = www[node - 1]\n        for n in ttt[node]:\n            if not vvv[n]:\n                profit = max(profit - x, profit + alpha(n))\n        return profit\n    print(max(-x, alpha(1)))", "for test in range(int(input())):\n    (n, k) = map(int, input().split())\n    l1 = []\n    l2 = [0] * n\n    l4 = []\n    for n1 in range(n):\n        l1.append([])\n    l3 = input().split()\n    for j in range(len(l3)):\n        l3[j] = int(l3[j])\n    for j in range(n - 1):\n        (x, y) = map(int, input().split())\n        l1[x - 1].append(y)\n        l1[y - 1].append(x)\n        l2[x - 1] = l2[x - 1] + 1\n        l2[y - 1] = l2[y - 1] + 1\n    for l21 in range(1, len(l2)):\n        if l2[l21] == 1:\n            l4.append(l21)\n    for x in range(n - 1):\n        l41 = l4[x]\n        l1[l1[l41][0] - 1].remove(l41 + 1)\n        if l3[l41] < -k:\n            l3[l41] = -k\n        l3[l1[l41][0] - 1] = l3[l1[l41][0] - 1] + l3[l41]\n        if len(l1[l1[l41][0] - 1]) == 1:\n            if l1[l41][0] != 1:\n                l4.append(l1[l41][0] - 1)\n    if l3[0] < -k:\n        l3[0] = -k\n    print(l3[0])", "from collections import defaultdict\n\nclass Solution:\n\n    def __init__(self, graph, root, values):\n        self.graph = graph\n        self.root = root\n        self.values = values\n        self.tree = defaultdict(list)\n        self.max_scores = [None for i in range(len(values))]\n\n    def max_score(self):\n        node = 1\n        stack = [node]\n        visited = set()\n        while stack:\n            node = stack[-1]\n            if node in visited:\n                acum = 0\n                for child in self.graph[node]:\n                    acum += self.max_scores[child - 1] if self.max_scores[child - 1] is not None else 0\n                self.max_scores[node - 1] = max(-x, acum + self.values[node - 1])\n                stack.pop()\n            else:\n                for child in self.graph[node]:\n                    if child not in visited:\n                        stack.append(child)\n                visited.add(node)\n        return self.max_scores[self.root - 1]\nt = int(input())\nans = []\nfor i in range(t):\n    (n, x) = [int(s) for s in input().split(' ') if s != '']\n    a = [int(s) for s in input().split(' ') if s != '']\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = [int(s) for s in input().split(' ') if s != '']\n        graph[u].append(v)\n        graph[v].append(u)\n    root = 1\n    solution = Solution(graph, root, a)\n    ans.append(solution.max_score())\nfor i in range(t):\n    print(ans[i])"]