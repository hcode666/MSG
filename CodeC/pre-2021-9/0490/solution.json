["def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "def shouldntwe(vals, wanted):\n    d = {}\n\n    def shouldwe(indx, wanted):\n        if (indx, wanted) in d:\n            return d[indx, wanted]\n        if indx == 0:\n            if wanted - vals[indx] == 0:\n                return 1\n            else:\n                return 0\n        if wanted == 0:\n            return 1\n        nitch_there = shouldwe(indx - 1, wanted)\n        ist_there = 0\n        if wanted >= vals[indx]:\n            ist_there = shouldwe(indx - 1, wanted - vals[indx])\n        d[indx, wanted] = nitch_there or ist_there\n        return d[indx, wanted]\n    return shouldwe(len(vals) - 1, wanted)\nt = int(input())\nfor abc in range(t):\n    (n, m) = map(int, input().split())\n    notes = [int(input()) for inp in range(n)]\n    if shouldntwe(notes, m):\n        print('Yes')\n    else:\n        print('No')", "def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "def sumUpTo(index, money, notesArr, dp):\n    if money == 0:\n        return True\n    elif money < 0:\n        return False\n    elif index >= len(notesArr):\n        return False\n    elif dp[index][money] != None:\n        return dp[index][money]\n    else:\n        take = sumUpTo(index + 1, money - notesArr[index], notesArr, dp)\n        dontTake = sumUpTo(index + 1, money, notesArr, dp)\n        dp[index][money] = take or dontTake\n        return dp[index][money]\ntest_case = int(input())\nresults = []\nfor test in range(test_case):\n    arr = input().split(' ')\n    notes = int(arr[0])\n    money = int(arr[1])\n    notesArr = []\n    for i in range(notes):\n        notesArr.append(int(input()))\n    dp = []\n    for index in range(len(notesArr)):\n        dp_row = []\n        for m in range(money + 1):\n            dp_row.append(None)\n        dp.append(dp_row)\n    results.append(sumUpTo(0, money, notesArr, dp))\nfor r in results:\n    if r == True:\n        print('Yes')\n    else:\n        print('No')", "def sumUpTo(index, money, notesArr, dp):\n    if money == 0:\n        return True\n    elif money < 0:\n        return False\n    elif index >= len(notesArr):\n        return False\n    elif dp[index][money] != None:\n        return dp[index][money]\n    else:\n        take = sumUpTo(index + 1, money - notesArr[index], notesArr, dp)\n        dontTake = sumUpTo(index + 1, money, notesArr, dp)\n        dp[index][money] = take or dontTake\n        return dp[index][money]\ntestCases = int(input())\nresults = []\nfor t in range(testCases):\n    arr = input().split(' ')\n    notes = int(arr[0])\n    money = int(arr[1])\n    notesArr = []\n    for i in range(notes):\n        notesArr.append(int(input()))\n    dp = []\n    for index in range(len(notesArr)):\n        dp_row = []\n        for m in range(money + 1):\n            dp_row.append(None)\n        dp.append(dp_row)\n    results.append(sumUpTo(0, money, notesArr, dp))\nfor r in results:\n    if r == True:\n        print('Yes')\n    else:\n        print('No')", "def fun(m, l):\n    if m == 0:\n        return True\n    elif m < 0:\n        return False\n    if len(l) == 0:\n        return False\n    for i in range(len(l)):\n        l1 = l.copy()\n        m1 = m - l1[i]\n        del l1[i]\n        s = fun(m1, l1)\n        if s:\n            return s\n    return False\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        a = int(input())\n        if a <= m:\n            l.append(a)\n    print('Yes' if fun(m, l) else 'No')", "def fun(m, l):\n    if m == 0:\n        return True\n    elif m < 0:\n        return False\n    if len(l) == 0:\n        return False\n    for i in range(len(l)):\n        l1 = l.copy()\n        m1 = m - l1[i]\n        del l1[i]\n        s = fun(m1, l1)\n        if s:\n            return s\n    return False\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        a = int(input())\n        if a <= m:\n            l.append(a)\n    print('Yes' if fun(m, l) else 'No')", "def ans(n, m, notes, memo={}):\n    if m == 0:\n        return True\n    if m < 0:\n        return False\n    if n == 0:\n        return False\n    return ans(n - 1, m - notes[0], notes[1:]) or ans(n - 1, m, notes[1:])\n    return False\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    notes = []\n    for i in range(n):\n        notes.append(int(input()))\n    if ans(n, m, notes):\n        print('Yes')\n    else:\n        print('No')", "def solve(n, m, notes):\n    if m < 0:\n        return False\n    if m == 0:\n        return True\n    ncopy = notes[:]\n    for note in notes:\n        ncopy.remove(note)\n        if solve(n - 1, m - note, ncopy):\n            return True\n        ncopy += [note]\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    notes = []\n    for v in range(n):\n        notes += [int(input())]\n    if solve(n, m, notes):\n        print('Yes')\n    else:\n        print('No')", "for tc in range(1, int(input()) + 1):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(int(input()))\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for j in range(m + 1):\n        dp[0][j] = 0\n    for i in range(n + 1):\n        dp[i][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j - arr[i - 1]] or dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print('Yes' if dp[n][m] else 'No')", "from functools import lru_cache\n\ndef soln(n, m, arr):\n    dp = {}\n\n    def recur(ind, amt):\n        if ind >= n:\n            if amt < 0:\n                return False\n            elif amt == 0:\n                return True\n        if (ind, amt) in dp:\n            return dp[ind, amt]\n        for i in range(ind, n):\n            res = recur(ind + 1, amt - arr[ind]) | recur(ind + 1, amt)\n            if res:\n                dp[ind, amt] = True\n                return True\n        dp[ind, amt] = False\n        return False\n    return 'Yes' if recur(0, m) else 'No'\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = [int(input()) for i in range(n)]\n    print(soln(n, m, arr))", "from functools import lru_cache\n\ndef soln(n, m, arr):\n\n    @lru_cache(maxsize=10 ** 5)\n    def recur(ind, amt):\n        if ind >= n:\n            if amt < 0:\n                return False\n            elif amt == 0:\n                return True\n        for i in range(ind, n):\n            res = recur(ind + 1, amt - arr[ind]) | recur(ind + 1, amt)\n            if res:\n                return True\n        return False\n    return 'Yes' if recur(0, m) else 'No'\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = [int(input()) for i in range(n)]\n    print(soln(n, m, arr))", "tests = int(input())\nfor i in range(tests):\n    (n, m) = map(int, input().split())\n    notes_arr = []\n    for j in range(n):\n        notes_arr.append(int(input()))\n    ans = 'No'\n    for j in range(1, 2 ** n):\n        temp = 0\n        count = 0\n        while j != 0:\n            if j & 1:\n                temp += notes_arr[count]\n            count += 1\n            j >>= 1\n        if temp == m:\n            ans = 'Yes'\n            break\n    print(ans)", "def coin_change(coins, amount):\n    memo = {}\n\n    def helper(indx, amount):\n        if (indx, amount) in memo:\n            return memo[indx, amount]\n        if indx == 0:\n            if amount - coins[indx] == 0:\n                return True\n            else:\n                return False\n        if amount == 0:\n            return True\n        notpick = helper(indx - 1, amount)\n        pick = False\n        if amount >= coins[indx]:\n            pick = helper(indx - 1, amount - coins[indx])\n        memo[indx, amount] = pick or notpick\n        return memo[indx, amount]\n    return helper(len(coins) - 1, amount)\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split(' '))\n    coins = []\n    for _ in range(a):\n        coins.append(int(input()))\n    if coin_change(coins, b):\n        print('Yes')\n    else:\n        print('No')", "def issubset(L, p, k):\n    if k == 0:\n        return True\n    if p == 0:\n        return False\n    return issubset(L, p - 1, k) or issubset(L, p - 1, k - L[p - 1])\nT = int(input())\nfor tc in range(T):\n    (n, k) = map(int, input().split())\n    L = []\n    for i in range(n):\n        t = int(input())\n        L.append(t)\n    x = issubset(L, n, k)\n    if x == True:\n        print('Yes')\n    else:\n        print('No')", "for i in range(int(input())):\n    (n, s) = [int(i) for i in input().split()]\n    arr = [int(input()) for i in range(n)]\n    dp = [[0 for i in range(s + 1)] for j in range(n + 1)]\n    for i in dp:\n        i[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            elif dp[i - 1][j]:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i - 1][j - arr[i - 1]]\n    if dp[n][s]:\n        print('Yes')\n    else:\n        print('No')", "for i in range(int(input())):\n    (n, s) = [int(i) for i in input().split()]\n    arr = [int(input()) for i in range(n)]\n    dp = [[0 for i in range(s + 1)] for j in range(n + 1)]\n    for i in dp:\n        i[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            elif dp[i - 1][j]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j - arr[i - 1]]\n    if dp[n][s]:\n        print('Yes')\n    else:\n        print('No')", "for i in range(int(input())):\n    (n, s) = [int(i) for i in input().split()]\n    arr = [int(input()) for i in range(n)]\n    dp = [[0 for i in range(s + 1)] for j in range(n + 1)]\n    for i in dp:\n        i[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            if dp[i - 1][j]:\n                dp[i][j] = dp[i - 1][j]\n            elif j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j - arr[i - 1]]\n    if dp[n][s]:\n        print('Yes')\n    else:\n        print('No')", "def solve():\n    (n, amt) = map(int, input().split())\n    dp = [[0] * (amt + 1) for i in range(n + 1)]\n    lis = list()\n    for i in range(n):\n        lis.append(int(input()))\n    for i in range(1, n + 1):\n        for j in range(1, amt + 1):\n            if lis[i - 1] <= j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - lis[i - 1]] + lis[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print(['Yes', 'No'][dp[n][amt] != amt])\nfor _ in range(int(input())):\n    solve()", "def solve():\n    (n, amt) = map(int, input().split())\n    lis = list()\n    for i in range(n):\n        lis.append(int(input()))\n    dp = [[0] * (amt + 1) for i in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, amt + 1):\n            if lis[i - 1] <= j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - lis[i - 1]] + lis[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    print('Yes' if dp[n][amt] == amt else 'No')\nfor _ in range(int(input())):\n    solve()", "def Helper(A, num, target, hashTable):\n    if target == 0:\n        return True\n    if num == 0:\n        return False\n    if target < 0:\n        return False\n    if (num, target) in hashTable:\n        return hashTable[num, target]\n    for i in range(len(A)):\n        if num & 1 << i == 0:\n            continue\n        val = num & ~(1 << i)\n        value = Helper(A, val, target - A[i], hashTable)\n        if value:\n            hashTable[num, target] = True\n            return True\n    hashTable[num, target] = False\n    return False\n\ndef function(A, N, M):\n    num = ~(-1 << N)\n    ans = Helper(A, num, M, {})\n    if ans:\n        return 'Yes'\n    return 'No'\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, M) = list(map(int, input().split(' ')))\n        A = []\n        for i in range(N):\n            A.append(int(input()))\n        val = function(A, N, M)\n        print(val)\nmain()", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    yes = False\n    for _ in range(n):\n        x = int(input())\n        if x <= m:\n            a.append(x)\n    ans = 0\n    for i in range(1, pow(2, len(a))):\n        for j in range(len(a)):\n            if i & 1 << j:\n                ans += a[j]\n                if ans == m:\n                    yes = True\n                    break\n        ans = 0\n    if yes:\n        print('Yes')\n    else:\n        print('No')", "def pay(i, s):\n    if s >= m:\n        return s == m\n    if i == n:\n        return False\n    return pay(i + 1, s) or pay(i + 1, s + a[i])\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for j in range(n):\n        a += [int(input())]\n    if pay(0, 0):\n        print('Yes')\n    else:\n        print('No')", "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef paying_up(wanted_sum, bank_notes):\n    if wanted_sum == 0:\n        return True\n    if wanted_sum < 0:\n        return False\n    if not bank_notes:\n        return False\n    bank_note = bank_notes[-1]\n    bank_notes = bank_notes[:-1]\n    return paying_up(wanted_sum, bank_notes) or paying_up(wanted_sum - bank_note, bank_notes)\nfor testcase in range(int(input())):\n    (n, wanted_sum) = [int(x) for x in input().split()]\n    bank_notes = tuple((int(input()) for _ in range(n)))\n    print('Yes' if paying_up(wanted_sum, bank_notes) else 'No')", "def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "import itertools\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    ans = []\n    comb = []\n    flag = 0\n    for j in range(n):\n        k = int(input())\n        if k <= m:\n            ans.append(k)\n    for g in range(len(ans) + 1):\n        comb_obj = itertools.combinations(ans, g)\n        comb += list(comb_obj)\n    for g in comb:\n        if sum(g) == m:\n            flag = 1\n    if flag == 1:\n        print('Yes')\n    else:\n        print('No')", "test_cases = int(input())\nbank_notes = []\n\ndef solve():\n    (bank_notes_num, m) = input().split()\n    m = int(m)\n    bank_notes_num = int(bank_notes_num)\n    for bn in range(0, bank_notes_num):\n        bn_val = int(input())\n        bank_notes.append(bn_val)\n    bank_notes.sort()\n    subsets = [[]]\n    for bn1 in bank_notes:\n        subsets += [sub + [bn1] for sub in subsets]\n    for s in subsets:\n        if sum(s) == m:\n            print('Yes')\n            return\n    print('No')\nfor t in range(0, test_cases):\n    solve()\n    bank_notes = []", "test_cases = int(input())\nbank_notes = []\n\ndef solve():\n    (bank_notes_num, m) = input().split()\n    m = int(m)\n    bank_notes_num = int(bank_notes_num)\n    for bn in range(0, bank_notes_num):\n        bn_val = int(input())\n        bank_notes.append(bn_val)\n    bank_notes.sort()\n    bank_notes.reverse()\n    subsets = [[]]\n    for bn1 in bank_notes:\n        subsets += [sub + [bn1] for sub in subsets]\n    for s in subsets:\n        if sum(s) == m:\n            print('Yes')\n            return\n    print('No')\nfor t in range(0, test_cases):\n    solve()\n    bank_notes = []", "test_cases = int(input())\nbank_notes = []\n\ndef solve():\n    (bank_notes_num, m) = input().split()\n    m = int(m)\n    bank_notes_num = int(bank_notes_num)\n    for bn in range(0, bank_notes_num):\n        bn_val = int(input())\n        bank_notes.append(bn_val)\n    bank_notes.sort()\n    subsets = [[]]\n    for bn1 in bank_notes:\n        subsets += [sub + [bn1] for sub in subsets]\n    for s in subsets:\n        if sum(s) == m:\n            print('Yes')\n            return\n    print('No')\nfor t in range(0, test_cases):\n    solve()\n    bank_notes = []", "test_cases = int(input())\nbank_notes = []\n\ndef solve():\n    (bank_notes_num, m) = input().split()\n    m = int(m)\n    bank_notes_num = int(bank_notes_num)\n    for bn in range(0, bank_notes_num):\n        bn_val = int(input())\n        bank_notes.append(bn_val)\n    subsets = [[]]\n    for bn1 in bank_notes:\n        subsets += [sub + [bn1] for sub in subsets]\n    for s in subsets:\n        if sum(s) == m:\n            print('Yes')\n            return\n    print('No')\nfor t in range(0, test_cases):\n    solve()\n    bank_notes = []", "t = int(input())\nwhile t > 0:\n    t -= 1\n    (n, m) = [int(x) for x in input().split()]\n    a = []\n    for i in range(n):\n        x = int(input())\n        a.append(x)\n    can = False\n    for i in range(1 << n):\n        tot = 0\n        for j in range(n):\n            if i & 1 << j:\n                tot += a[j]\n        if tot == m:\n            can = True\n            break\n    print('Yes' if can else 'No')", "def eAll(arr, i, cs, trg):\n    if i >= len(arr):\n        return False\n    if trg == cs + arr[i]:\n        return True\n    if arr[i] + cs > trg:\n        return False\n    return eAll(arr, i + 1, cs + arr[i], trg) or eAll(arr, i + 1, cs, trg)\ntn = int(input())\nfor _ in range(tn):\n    (n, m) = map(int, input().split())\n    arr = [int(input()) for _ in range(n)]\n    arr.sort()\n    if eAll(arr, 0, 0, m):\n        print('Yes')\n    else:\n        print('No')", "def isSubsetSum(arr, n, target):\n    if target == 0:\n        return True\n    if n == 0:\n        return False\n    if arr[n - 1] > target:\n        return isSubsetSum(arr, n - 1, target)\n    return isSubsetSum(arr, n - 1, target) or isSubsetSum(arr, n - 1, target - arr[n - 1])\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    notes = []\n    for _ in range(n):\n        notes.append(int(input()))\n    if isSubsetSum(notes, n, m):\n        print('Yes')\n    else:\n        print('No')", "test = int(input())\nfor i in range(test):\n    (n, m) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        arr.append(int(input()))\n\n    def subs(arr):\n        subs = [[]]\n        dp = []\n        for elem in arr:\n            for i in range(len(subs)):\n                a = subs[i] + [elem]\n                subs.append(a)\n                dp.append(sum(a))\n        return dp\n    if m in subs(arr):\n        print('Yes')\n    else:\n        print('No')", "def change(i, total, memo):\n    if (i, total) in memo:\n        return memo[i, total]\n    if total == m:\n        memo[i, total] = True\n        return memo[i, total]\n    if i >= n or total > m:\n        memo[i, total] = False\n        return memo[i, total]\n    memo[i, total] = change(i + 1, total + notes[i], memo) or change(i + 1, total, memo)\n    return memo[i, total]\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    notes = [-1 for _ in range(n)]\n    for i in range(n):\n        notes[i] = int(input())\n    print('Yes' if change(0, 0, {}) else 'No')", "def subs(li, arr, subset, index):\n    li.append(subset.copy())\n    for i in range(index, len(arr)):\n        subset.append(arr[i])\n        subs(li, arr, subset, i + 1)\n        subset.pop()\n    return\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    li = []\n    for i in range(n):\n        a.append(int(input()))\n    subs(li, a, [], 0)\n    out = []\n    for i in li:\n        if len(i) == 0:\n            out.append(0)\n        elif len(i) == 1:\n            out.append(i[0])\n        else:\n            out.append(sum(i))\n    try:\n        out.index(m)\n        print('Yes')\n    except:\n        print('No')", "def change(i, total, memo):\n    if (i, total) in memo:\n        return memo[i, total]\n    if total == m:\n        memo[i, total] = True\n        return memo[i, total]\n    if i >= n or total > m:\n        memo[i, total] = False\n        return memo[i, total]\n    memo[i, total] = change(i + 1, total + notes[i], memo) or change(i + 1, total, memo)\n    return memo[i, total]\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    notes = [-1 for _ in range(n)]\n    for i in range(n):\n        notes[i] = int(input())\n    print('Yes' if change(0, 0, {}) else 'No')", "def isSubsetSum(arr, n, target):\n    if target == 0:\n        return True\n    if n == 0:\n        return False\n    if arr[n - 1] > target:\n        return isSubsetSum(arr, n - 1, target)\n    return isSubsetSum(arr, n - 1, target) or isSubsetSum(arr, n - 1, target - arr[n - 1])\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    notes = []\n    for _ in range(n):\n        notes.append(int(input()))\n    if isSubsetSum(notes, n, m):\n        print('Yes')\n    else:\n        print('No')", "def isSubsetSum(arr, n, target):\n    if target == 0:\n        return True\n    if n == 0:\n        return False\n    if arr[n - 1] > target:\n        return isSubsetSum(arr, n - 1, target)\n    return isSubsetSum(arr, n - 1, target) or isSubsetSum(arr, n - 1, target - arr[n - 1])\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    notes = []\n    for _ in range(n):\n        notes.append(int(input()))\n    if isSubsetSum(notes, n, m):\n        print('Yes')\n    else:\n        print('No')", "def knapsack(arr, total, cnt):\n    k = [[0 for i in range(total + 1)] for j in range(cnt + 1)]\n    for i in range(1, cnt + 1):\n        for j in range(1, total + 1):\n            if j >= arr[i - 1]:\n                k[i][j] = max(k[i - 1][j], k[i - 1][j - arr[i - 1]] + arr[i - 1])\n            else:\n                k[i][j] = k[i - 1][j]\n    return k[cnt][total]\nT = int(input())\nfor t in range(T):\n    (n, m) = [int(x) for x in input().split(' ')]\n    arr = []\n    for i in range(n):\n        arr.append(int(input()))\n    if m > 20000:\n        print('No')\n    elif m == knapsack(arr, m, n):\n        print('Yes')\n    else:\n        print('No')", "def knapsack(arr, total, cnt):\n    k = [[0 for i in range(total + 1)] for j in range(cnt + 1)]\n    for i in range(1, cnt + 1):\n        for j in range(1, total + 1):\n            if j >= arr[i - 1]:\n                k[i][j] = max(k[i - 1][j], k[i - 1][j - arr[i - 1]] + arr[i - 1])\n            else:\n                k[i][j] = k[i - 1][j]\n    return k[cnt][total]\nT = int(input())\nfor t in range(T):\n    (n, m) = [int(x) for x in input().split(' ')]\n    arr = []\n    for i in range(n):\n        arr.append(int(input()))\n    arr.sort()\n    if m == knapsack(arr, m, n):\n        print('Yes')\n    else:\n        print('No')", "def checkSubsetSum(a, m, n, memo):\n    if m == 0:\n        return True\n    if m < 0:\n        return False\n    if m in memo:\n        return memo[m]\n    for i in range(n):\n        rem = m - a[i]\n        if checkSubsetSum(a[:i] + a[i + 1:], rem, n - 1, memo):\n            memo[m] = True\n            return True\n    memo[m] = False\n    return False\nt = int(input())\nfor _ in range(t):\n    (n, m) = [int(i) for i in input().split()]\n    a = []\n    for i in range(n):\n        a.append(int(input()))\n    if checkSubsetSum(a, m, n, {}):\n        print('Yes')\n    else:\n        print('No')", "def checkSubsetSum(a, m, n, memo):\n    if m in memo:\n        return memo[m]\n    if m == 0:\n        return True\n    if m < 0:\n        return False\n    for i in range(n):\n        rem = m - a[i]\n        if checkSubsetSum(a[:i] + a[i + 1:], rem, n - 1, memo):\n            memo[m] = True\n            return True\n    memo[m] = False\n    return False\nt = int(input())\nfor _ in range(t):\n    (n, m) = [int(i) for i in input().split()]\n    a = []\n    for i in range(n):\n        a.append(int(input()))\n    if checkSubsetSum(a, m, n, {}):\n        print('Yes')\n    else:\n        print('No')", "def subs(li, arr, subset, index):\n    li.append(subset.copy())\n    for i in range(index, len(arr)):\n        subset.append(arr[i])\n        subs(li, arr, subset, i + 1)\n        subset.pop()\n    return\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    li = []\n    for i in range(n):\n        a.append(int(input()))\n    subs(li, a, [], 0)\n    out = []\n    for i in li:\n        if len(i) == 0:\n            out.append(0)\n        elif len(i) == 1:\n            out.append(i[0])\n        else:\n            out.append(sum(i))\n    try:\n        out.index(m)\n        print('Yes')\n    except:\n        print('No')", "import itertools\nn1 = int(input())\nfor i in range(n1):\n    (n, m) = map(int, input().split())\n    list = []\n    for j in range(n):\n        list.append(int(input()))\n    p = 'No'\n    for k in range(1, n + 1):\n        for l in itertools.combinations(list, k):\n            if sum(l) == m:\n                p = 'Yes'\n                break\n    print(p)", "import itertools\nn1 = int(input())\nfor i in range(n1):\n    (n, m) = map(int, input().split())\n    list = []\n    for j in range(n):\n        list.append(int(input()))\n    p = 'No'\n    for k in range(1, n + 1):\n        for l in itertools.combinations(list, k):\n            if sum(l) == m:\n                p = 'Yes'\n                break\n    print(p)", "import itertools\nn1 = int(input())\nfor i in range(n1):\n    (n, m) = map(int, input().split())\n    list = []\n    for j in range(n):\n        list.append(int(input()))\n    p = 'No'\n    for k in range(1, n + 1):\n        for l in itertools.combinations(list, k):\n            if sum(l) == m:\n                p = 'Yes'\n                break\n    print(p)", "import itertools\nnum = int(input())\nfor i in range(num):\n    (n, m) = map(int, input().split())\n    list = []\n    for j in range(n):\n        list.append(int(input()))\n    pay = 'No'\n    for k in range(1, n + 1):\n        for l in itertools.combinations(list, k):\n            if sum(l) == m:\n                pay = 'Yes'\n                break\n    print(pay)", "import itertools\nnum = int(input())\nfor i in range(num):\n    (n, m) = map(int, input().split())\n    list = []\n    for j in range(n):\n        list.append(int(input()))\n    pay = 'No'\n    for k in range(1, n + 1):\n        for l in itertools.combinations(list, k):\n            if sum(l) == m:\n                pay = 'Yes'\n                break\n    print(pay)", "import itertools\nnum = int(input())\nfor i in range(num):\n    (n, m) = map(int, input().split())\n    lst = []\n    for j in range(n):\n        lst.append(int(input()))\n    pay = 'No'\n    for k in range(1, n + 1):\n        for l in itertools.combinations(lst, k):\n            if sum(l) == m:\n                pay = 'Yes'\n                break\n    print(pay)", "def solve(n, arr, ind, amt, dp):\n    if amt == 0:\n        return True\n    if amt < 0:\n        return False\n    if (ind, amt) in dp:\n        return dp[ind, amt]\n    if ind > n - 1:\n        return False\n    dp[ind, amt] = solve(n, arr, ind + 1, amt - arr[ind], dp) or solve(n, arr, ind + 1, amt, dp)\n    return dp[ind, amt]\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    arr = [0] * n\n    for i in range(n):\n        arr[i] = int(input())\n    if solve(n, arr, 0, m, {}):\n        print('Yes')\n    else:\n        print('No')", "t = int(input())\n\ndef bt(i, target, l):\n    if target == 0:\n        return True\n    if i == len(l) - 1:\n        return target == l[-1]\n    not_take = bt(i + 1, target, l)\n    take = False\n    if l[i] <= target:\n        take = bt(i + 1, target - l[i], l)\n    return take or not_take\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    dp = [-1] * 20000\n    l = []\n    key = 0\n    for _ in range(n):\n        l.append(int(input()))\n    if bt(0, m, l):\n        print('Yes')\n    else:\n        print('No')", "t = int(input())\nfrom itertools import chain, combinations\n\ndef powerset(list_name):\n    s = list(list_name)\n    l = []\n    for i in range(1, len(list_name) + 1):\n        for x in combinations(s, i):\n            l.append(x)\n    return l\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    dp = [-1] * 20000\n    l = []\n    key = 0\n    for _ in range(n):\n        l.append(int(input()))\n    for x in powerset(l):\n        if sum(x) == m:\n            key = -1\n            break\n    if key == 0:\n        print('No')\n    else:\n        print('Yes')", "t = int(input())\nfrom itertools import chain, combinations\n\ndef powerset(list_name):\n    s = list(list_name)\n    return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    dp = [-1] * 20000\n    l = []\n    key = 0\n    for _ in range(n):\n        l.append(int(input()))\n    for x in powerset(l):\n        if sum(x) == m:\n            key = -1\n            break\n    if key == 0:\n        print('No')\n    else:\n        print('Yes')", "import sys\nsys.setrecursionlimit(2 ** 30)\n\ndef ans(start, arr, t):\n    if start == len(arr) and t == 0:\n        return True\n    if start == len(arr) and t != 0:\n        return False\n    if start > len(arr):\n        return False\n    if t == 0:\n        return True\n    elif arr[start] > t:\n        return ans(start + 1, arr, t)\n    else:\n        return ans(start + 1, arr, t - arr[start]) or ans(start + 1, arr, t)\ntest_cases = int(input())\nwhile test_cases != 0:\n    d = list(map(int, input().split()))\n    arr = []\n    for y in range(0, d[0]):\n        temp = int(input())\n        arr.append(temp)\n    x = ans(0, arr, d[1])\n    if x is True:\n        print('Yes')\n    else:\n        print('No')\n    test_cases -= 1", "from itertools import chain, combinations\n\ndef power_set(list_name):\n    given_set = list(list_name)\n    return chain.from_iterable((combinations(given_set, r) for r in range(len(given_set) + 1)))\ninp_t = int(input())\nwhile inp_t:\n    (inp_n, inp_m) = input().split()\n    (inp_n, inp_m) = (int(inp_n), int(inp_m))\n    pocket_currency = []\n    while inp_n:\n        pocket_currency.append(int(input()))\n        inp_n = inp_n - 1\n    pocket_currency = sorted(pocket_currency)\n    super_set_pocket_currency = power_set(pocket_currency)\n    flag = False\n    for each_set in super_set_pocket_currency:\n        if sum(each_set) == inp_m:\n            print('Yes')\n            flag = True\n            break\n    if flag is False:\n        print('No')\n    inp_t = inp_t - 1", "def solvemug(m, L):\n    if m == 0:\n        return True\n    elif len(L) == 0:\n        return False\n    elif m >= L[0]:\n        (a, b) = (solvemug(m - L[0], L[1:]), solvemug(m, L[1:]))\n        return a or b\n    else:\n        a = solvemug(m, L[1:])\n        return a\nT = int(input())\nfor _ in range(T):\n    (n, m) = map(int, input().split())\n    L = []\n    for i in range(n):\n        L.append(int(input()))\n    if solvemug(m, L):\n        print('Yes')\n    else:\n        print('No')", "def fx(ind, target, arr):\n    if target == 0:\n        return True\n    if ind == 0:\n        k = arr[0] == target\n        return k\n    not_take = fx(ind - 1, target, arr)\n    take = False\n    if target >= arr[ind]:\n        take = fx(ind - 1, target - arr[ind], arr)\n    return take or not_take\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    qw = []\n    for k in range(n):\n        t = int(input())\n        qw.append(t)\n    if fx(n - 1, m, qw):\n        print('Yes')\n    else:\n        print('No')", "try:\n    from debug import debug, timer\nexcept ImportError:\n    pass\nfrom sys import stdin\ninput = stdin.readline\n\ndef rii():\n    return range(int(input().strip()))\n\ndef ii():\n    return int(input().strip())\n\ndef mii():\n    return map(int, input().strip().split(' '))\n\ndef lmii():\n    return list(map(int, input().strip().split(' ')))\n\ndef si():\n    return str(input().strip())\n\ndef getvals():\n    while True:\n        yield from input().split()\n\ndef tri(n):\n    return n * (n + 1) // 2\n\ndef smallest_first(m, n):\n    return (min(m, n), max(m, n))\nfrom functools import lru_cache\n(success, failure) = ('Yes', 'No')\n\n@lru_cache(maxsize=None)\ndef recursive_solve(m, wallet):\n    if m == 0:\n        return True\n    if len(wallet) == 1:\n        return bool(m == wallet[0])\n    new_wallet = tuple(list(wallet)[1:])\n    if wallet[0] <= m:\n        return recursive_solve(m, new_wallet) | recursive_solve(m - wallet[0], new_wallet)\n    else:\n        return recursive_solve(m, new_wallet)\n\ndef solve(*args):\n    (n, m, wallet) = args\n    return success if recursive_solve(m, tuple(sorted(wallet, reverse=True))) else failure\n\ndef do_codechef():\n    for t in rii():\n        (n, m) = mii()\n        wallet = [ii() for _ in range(n)]\n        print(solve(n, m, wallet))\ndo_codechef()\nexit()", "def subsum(arr, i, n, su, s):\n    if i == n:\n        if su == s:\n            return True\n        return False\n    if su + arr[i] <= s:\n        return subsum(arr, i + 1, n, su + arr[i], s) or subsum(arr, i + 1, n, su, s)\n    else:\n        return subsum(arr, i + 1, n, su, s)\nfor _ in range(int(input())):\n    (si, s) = [int(a) for a in input().split()]\n    arr = []\n    for l in range(si):\n        arr.append(int(input()))\n    if subsum(arr, 0, si, 0, s):\n        print('Yes')\n    else:\n        print('No')", "def fx(ind, target, arr):\n    if target == 0:\n        return True\n    if ind == 0:\n        k = arr[0] == target\n        return k\n    not_take = fx(ind - 1, target, arr)\n    take = False\n    if target >= arr[ind]:\n        take = fx(ind - 1, target - arr[ind], arr)\n    return take or not_take\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    qw = []\n    for k in range(n):\n        t = int(input())\n        qw.append(t)\n    if fx(n - 1, m, qw):\n        print('Yes')\n    else:\n        print('No')", "import itertools\nnum = int(input())\nfor i in range(num):\n    (n, m) = map(int, input().split())\n    lst = []\n    for j in range(n):\n        lst.append(int(input()))\n    pay = 'No'\n    for k in range(1, n + 1):\n        for l in itertools.combinations(lst, k):\n            if sum(l) == m:\n                pay = 'Yes'\n                break\n    print(pay)", "from itertools import chain, combinations\n\ndef powerset(list_name):\n    s = list(list_name)\n    return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    li = []\n    for i in range(n):\n        li.append(int(input()))\n    li.sort()\n    fnd = False\n    for a in powerset(li):\n        if sum(a) == m:\n            fnd = True\n    if fnd:\n        print('Yes')\n    else:\n        print('No')", "from itertools import chain, combinations\n\ndef powerset(list_name):\n    s = list(list_name)\n    return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    li = []\n    for i in range(n):\n        li.append(int(input()))\n    li.sort()\n    fnd = False\n    for a in powerset(li):\n        if sum(a) == m:\n            fnd = True\n    if fnd:\n        print('Yes')\n    else:\n        print('No')", "from bisect import bisect_left\nfrom itertools import chain, combinations\n\ndef powerset(list_name):\n    s = list(list_name)\n    return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    li = []\n    for i in range(n):\n        li.append(int(input()))\n    li.sort()\n    ind = bisect_left(li, m)\n    s_li = li[:ind]\n    fnd = False\n    for a in powerset(li):\n        if sum(a) == m:\n            fnd = True\n    if fnd:\n        print('Yes')\n    else:\n        print('No')", "def call(arr, banknotes, amount):\n    dp = [[0] * (amount + 1) for i in range(banknotes + 1)]\n    for i in range(banknotes + 1):\n        dp[i][0] = 1\n    for i in range(1, banknotes + 1):\n        for j in range(1, amount + 1):\n            if j >= arr[i - 1]:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return 'Yes' if dp[banknotes][amount] else 'No'\nt = int(input())\nwhile t > 0:\n    arr = list(map(int, input().split()))\n    (banknotes, amount) = (arr[0], arr[1])\n    arr = []\n    for i in range(banknotes):\n        arr.append(int(input()))\n    print(call(arr, banknotes, amount))\n    t -= 1", "import itertools\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = []\n    h = True\n    for _ in range(n):\n        l.append(int(input()))\n    for i in range(1, n + 1):\n        if h:\n            a = list(itertools.combinations(l, i))\n            for j in a:\n                if sum(j) == k:\n                    h = False\n                    print('Yes')\n                    break\n    if h:\n        print('No')", "def findAll(arr, n, asum):\n    dp = {0}\n    arr = filter(lambda x: x <= asum, arr)\n    for note in arr:\n        new_sums = set(map(lambda x: x + note, dp))\n        if asum in new_sums:\n            return 'Yes'\n        dp = dp.union(new_sums)\n    else:\n        return 'No'\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        arr = map(int, [input() for _ in range(n)])\n        ans = findAll(arr, n, m)\n        print(ans)\nmain()", "def call(arr, banknotes, amount):\n    dp = [[0] * (amount + 1) for i in range(banknotes + 1)]\n    for i in range(banknotes + 1):\n        dp[i][0] = 1\n    for i in range(1, banknotes + 1):\n        for j in range(1, amount + 1):\n            if j >= arr[i - 1]:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return 'Yes' if dp[banknotes][amount] else 'No'\nt = int(input())\nwhile t > 0:\n    arr = list(map(int, input().split()))\n    (banknotes, amount) = (arr[0], arr[1])\n    arr = []\n    for i in range(banknotes):\n        arr.append(int(input()))\n    print(call(arr, banknotes, amount))\n    t -= 1", "from itertools import combinations\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    count = 0\n    for i in range(n):\n        a.append(int(input()))\n    for i in range(1, n + 1):\n        if count == 1:\n            break\n        for j in combinations(a, i):\n            if sum(j) == m:\n                count = 1\n                print('Yes')\n                break\n    if count != 1:\n        print('No')", "from itertools import combinations\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    count = 0\n    for i in range(n):\n        a.append(int(input()))\n    for i in range(1, n + 1):\n        if count == 1:\n            break\n        for j in combinations(a, i):\n            if sum(j) == m:\n                count = 1\n                print('Yes')\n                break\n    if count != 1:\n        print('No')", "from itertools import combinations\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    c = 0\n    for i in range(n):\n        a += [int(input())]\n    for i in range(1, n + 1):\n        if c == 1:\n            break\n        for j in combinations(a, i):\n            if sum(j) == m:\n                c = 1\n                print('Yes')\n                break\n    if c != 1:\n        print('No')", "def sub(l, i, curr_sum, k):\n    if i == len(l):\n        if curr_sum == k:\n            return True\n        else:\n            return False\n    if curr_sum == k:\n        return True\n    inc = sub(l, i + 1, curr_sum + l[i], k)\n    exc = sub(l, i + 1, curr_sum, k)\n    return inc or exc\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        l.append(int(input()))\n    l.sort()\n    ans = sub(l, 0, 0, m)\n    if ans:\n        print('Yes')\n    else:\n        print('No')", "from itertools import combinations\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    c = 0\n    for i in range(n):\n        a += [int(input())]\n    for i in range(1, n + 1):\n        if c == 1:\n            break\n        for j in combinations(a, i):\n            if sum(j) == m:\n                c = 1\n                print('Yes')\n                break\n    if c != 1:\n        print('No')", "import itertools\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    bn = []\n    pay = False\n    for i in range(n):\n        bn.append(int(input()))\n    for i in range(1, n + 1):\n        if not pay:\n            for c in itertools.combinations(bn, i):\n                if sum(c) == m:\n                    pay = True\n                    break\n    if pay:\n        print('Yes')\n    else:\n        print('No')", "from itertools import combinations\nt = int(input())\nfor i in range(t):\n    (n, m) = [int(x) for x in input().split()]\n    l = []\n    for j in range(n):\n        l.append(int(input()))\n    a = []\n    for i in range(n):\n        b = list(combinations(l, i + 1))\n        a += b\n    flag = 0\n    for i in a:\n        if sum(i) == m:\n            print('Yes')\n            flag = 1\n            break\n    if flag == 0:\n        print('No')", "def issubset(L, p, k):\n    if k == 0:\n        return True\n    if p == 0:\n        return False\n    if L[p - 1] > k:\n        return issubset(L, p - 1, k)\n    return issubset(L, p - 1, k) or issubset(L, p - 1, k - L[p - 1])\nT = int(input())\nfor tc in range(T):\n    (n, k) = map(int, input().split())\n    L = []\n    for i in range(n):\n        t = int(input())\n        L.append(t)\n    x = issubset(L, n, k)\n    if x == True:\n        print('Yes')\n    else:\n        print('No')", "def resuo(nums, act):\n    n = len(nums)\n    sol = []\n    count = 1 << n\n    for mask in range(count):\n        ans = []\n        for i in range(n):\n            if mask & 1 << i != 0:\n                ans.append(nums[i])\n        sol.append(sum(ans))\n    for i in sol:\n        if i == act:\n            return 'Yes'\n    return 'No'\n\ndef into():\n    T = int(input())\n    for i in range(T):\n        arr = list(map(int, input().rstrip().split()))\n        act = arr[1]\n        nums = []\n        for i in range(arr[0]):\n            k = int(input())\n            nums.append(k)\n        res = resuo(nums, act)\n        print(res)\ninto()", "for t in range(0, int(input())):\n    (n, k) = map(int, input().split())\n    arr = []\n    for i in range(0, n):\n        j = int(input())\n        if j <= k:\n            arr.append(j)\n    total = 0\n    c = 0\n    n = len(arr)\n    for i in range(0, 2 ** n):\n        total = 0\n        for j in range(0, n):\n            if 1 << j & i:\n                total += arr[j]\n        if total == k:\n            print('Yes')\n            c = 1\n            break\n    if c == 0:\n        print('No')", "import itertools\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for _ in range(n):\n        b = int(input())\n        a.append(b)\n    pay = 'No'\n    for k in range(1, n + 1):\n        for l in itertools.combinations(a, k):\n            if sum(l) == m:\n                pay = 'Yes'\n                break\n    print(pay)", "import itertools\nfor test_case in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for _ in range(n):\n        b = int(input())\n        a.append(b)\n    pay = 'No'\n    for k in range(1, n + 1):\n        for l in itertools.combinations(a, k):\n            if sum(l) == m:\n                pay = 'Yes'\n                break\n    print(pay)", "import itertools\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for _ in range(n):\n        b = int(input())\n        a.append(b)\n    pay = 'No'\n    for k in range(1, n + 1):\n        for l in itertools.combinations(a, k):\n            if sum(l) == m:\n                pay = 'Yes'\n                break\n    print(pay)", "def isSubsetSum(sett, no, summ):\n    if summ == 0:\n        return True\n    if no == 0:\n        return False\n    if sett[no - 1] > summ:\n        return isSubsetSum(sett, no - 1, summ)\n    return isSubsetSum(sett, no - 1, summ) or isSubsetSum(sett, no - 1, summ - sett[no - 1])\nT = int(input().strip())\nfor t in range(0, T):\n    (n, m) = input().strip().split()\n    n = int(n)\n    m = int(m)\n    l = []\n    for i in range(0, n):\n        p = int(input().strip())\n        l.append(p)\n    a = isSubsetSum(l, len(l), m)\n    if a == True:\n        print('Yes')\n    else:\n        print('No')", "def isSubsetSum(sett, no, summ):\n    if summ == 0:\n        return True\n    if no == 0:\n        return False\n    if sett[no - 1] > summ:\n        return isSubsetSum(sett, no - 1, summ)\n    return isSubsetSum(sett, no - 1, summ) or isSubsetSum(sett, no - 1, summ - sett[no - 1])\nT = int(input().strip())\nfor t in range(0, T):\n    (n, m) = input().strip().split()\n    n = int(n)\n    m = int(m)\n    l = []\n    for i in range(0, n):\n        p = int(input().strip())\n        l.append(p)\n    a = isSubsetSum(l, len(l), m)\n    if a == True:\n        print('Yes')\n    else:\n        print('No')", "def isSubsetSum(set, n, sum):\n    subset = [[False for i in range(sum + 1)] for i in range(n + 1)]\n    for i in range(n + 1):\n        subset[i][0] = True\n    for i in range(1, sum + 1):\n        subset[0][i] = False\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < set[i - 1]:\n                subset[i][j] = subset[i - 1][j]\n            if j >= set[i - 1]:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - set[i - 1]]\n    return subset[n][sum]\nt = int(input())\nfor t1 in range(t):\n    (n, m) = map(int, input().split())\n    ls = []\n    for n1 in range(n):\n        a = int(input())\n        ls.append(a)\n    if isSubsetSum(ls, n, m) == True:\n        print('Yes')\n    else:\n        print('No')", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    c = 0\n    l = []\n    for i in range(n):\n        k = int(input())\n        if k <= m:\n            l.append(k)\n            c += 1\n    l.sort()\n    s = 0\n    c1 = 0\n    f = 0\n    for i in range(1, 2 ** c):\n        while i != 0:\n            if i % 2 != 0:\n                s += l[c1]\n            if s == m:\n                f = 1\n                break\n            elif s > m:\n                break\n            c1 += 1\n            i = i >> 1\n        c1 = 0\n        s = 0\n        if f == 1:\n            break\n    if f == 1:\n        print('Yes')\n    else:\n        print('No')", "def isSubsetSum(sett, no, summ):\n    if summ == 0:\n        return True\n    if no == 0:\n        return False\n    if sett[no - 1] > summ:\n        return isSubsetSum(sett, no - 1, summ)\n    return isSubsetSum(sett, no - 1, summ) or isSubsetSum(sett, no - 1, summ - sett[no - 1])\nT = int(input().strip())\nfor t in range(0, T):\n    (n, m) = input().strip().split()\n    n = int(n)\n    m = int(m)\n    l = []\n    for i in range(0, n):\n        p = int(input().strip())\n        l.append(p)\n    a = isSubsetSum(l, len(l), m)\n    if a == True:\n        print('Yes')\n    else:\n        print('No')", "import itertools\nt = int(input())\nfor i in range(t):\n    (notes, demand) = map(int, input().split())\n    bankNotes = []\n    for i in range(notes):\n        bankNotes.append(int(input()))\n    pay = 'No'\n    for k in range(1, notes + 1):\n        for l in itertools.combinations(bankNotes, k):\n            if sum(l) == demand:\n                pay = 'Yes'\n                break\n    print(pay)"]