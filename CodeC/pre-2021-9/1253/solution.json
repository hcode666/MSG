["import queue\nimport math\nn = int(input())\nadj = []\ncost = []\nfor i in range(n):\n    l = []\n    l = map(int, input().split())\n    l = list(l)\n    adj.append(l)\nal = []\nfor i in range(n):\n    al.append([])\n    for j in range(n):\n        if adj[i][j] == 1:\n            al[i].append(j)\nq = int(input())\ntot = dict()\ntotc = dict()\nqout = dict()\nfor _ in range(q):\n    (k, x) = map(int, input().split())\n    q1 = queue.Queue()\n    q2 = queue.Queue()\n    u = x - 1\n    if u in tot:\n        tunit = dict()\n        tunit = tot[u]\n        tcycle = []\n        if u in totc:\n            tcycle = totc[u]\n        if k in tunit:\n            print(len(tunit[k]))\n            print(' '.join((str(j + 1) for j in tunit[k])))\n        else:\n            ln = len(tunit)\n            lnc = len(tcycle)\n            z = k - ln + 1\n            if lnc > 0:\n                z = z % lnc\n                if z == 0:\n                    z = lnc - 1\n                else:\n                    z = z - 1\n                print(len(tcycle[z]))\n                print(' '.join((str(j + 1) for j in tcycle[z])))\n            else:\n                print(0)\n                print(-1)\n        continue\n    q1.put(u)\n    y = 0\n    count = 0\n    unit = dict()\n    ind = []\n    xl = []\n    xl.append(u)\n    ind.append(xl)\n    unit[count] = xl\n    q1l = []\n    q2l = []\n    q1l.append(u)\n    while True:\n        if y % 2 == 0:\n            vis = [0] * n\n            flag = 0\n            xl = []\n            q2l = []\n            tq1l = tuple(q1l)\n            if tq1l in qout:\n                q2l = qout[tq1l]\n                xl = qout[tq1l]\n                flag = 1\n            else:\n                while q1.empty() == False:\n                    u = q1.get()\n                    for w in al[u]:\n                        vis[w] = 1\n                        flag = 1\n                for i in range(n):\n                    if vis[i] == 1:\n                        xl.append(i)\n                        q2.put(i)\n                        q2l.append(i)\n            if len(xl) != 0:\n                qout[tq1l] = xl\n            count = count + 1\n            if flag == 0:\n                break\n            if xl in ind:\n                break\n            unit[count] = xl\n            ind.append(xl)\n        else:\n            vis = [0] * n\n            flag = 0\n            xl = []\n            q1l = []\n            tq2l = tuple(q2l)\n            if tq2l in qout:\n                q1l = qout[tq2l]\n                xl = qout[tq2l]\n                flag = 1\n            else:\n                while q2.empty() == False:\n                    u = q2.get()\n                    for w in al[u]:\n                        vis[w] = 1\n                        flag = 1\n                for i in range(n):\n                    if vis[i] == 1:\n                        xl.append(i)\n                        q1.put(i)\n                        q1l.append(i)\n            count = count + 1\n            if len(xl) != 0:\n                qout[tq2l] = xl\n            if flag == 0:\n                break\n            if xl in ind:\n                break\n            unit[count] = xl\n            ind.append(xl)\n        y = y + 1\n    tot[x - 1] = unit\n    cycle = []\n    if xl in ind:\n        index = ind.index(xl)\n        cycle = []\n        cycle = ind[index:]\n        totc[x - 1] = cycle\n    if k in unit:\n        print(len(unit[k]))\n        print(' '.join((str(j + 1) for j in unit[k])))\n    else:\n        ln = len(unit)\n        lnc = len(cycle)\n        z = k - ln + 1\n        if lnc > 0:\n            z = z % lnc\n            if z == 0:\n                z = lnc - 1\n            else:\n                z = z - 1\n            print(len(cycle[z]))\n            print(' '.join((str(j + 1) for j in cycle[z])))\n        else:\n            print(0)\n            print(-1)", "import queue\nimport math\nn = int(input())\nadj = []\ncost = []\nfor i in range(n):\n    l = []\n    l = map(int, input().split())\n    l = list(l)\n    adj.append(l)\nal = []\nfor i in range(n):\n    al.append([])\n    for j in range(n):\n        if adj[i][j] == 1:\n            al[i].append(j)\nq = int(input())\ntot = dict()\ntotc = dict()\nqout = dict()\nfor _ in range(q):\n    (k, x) = map(int, input().split())\n    q1 = queue.Queue()\n    q2 = queue.Queue()\n    u = x - 1\n    if u in tot:\n        tunit = dict()\n        tunit = tot[u]\n        tcycle = []\n        if u in totc:\n            tcycle = totc[u]\n        if k in tunit:\n            print(len(tunit[k]))\n            print(' '.join((str(j + 1) for j in tunit[k])))\n        else:\n            ln = len(tunit)\n            lnc = len(tcycle)\n            z = k - ln + 1\n            if lnc > 0:\n                z = z % lnc\n                if z == 0:\n                    z = lnc - 1\n                else:\n                    z = z - 1\n                print(len(tcycle[z]))\n                print(' '.join((str(j + 1) for j in tcycle[z])))\n            else:\n                print(0)\n                print(-1)\n        continue\n    q1.put(u)\n    y = 0\n    count = 0\n    unit = dict()\n    ind = []\n    xl = []\n    xl.append(u)\n    ind.append(xl)\n    unit[count] = xl\n    q1l = []\n    q2l = []\n    q1l.append(u)\n    while True:\n        if y % 2 == 0:\n            vis = [0] * n\n            flag = 0\n            xl = []\n            q2l = []\n            tq1l = tuple(q1l)\n            if tq1l in qout:\n                q2l = qout[tq1l]\n                xl = qout[tq1l]\n                flag = 1\n            else:\n                while q1.empty() == False:\n                    u = q1.get()\n                    for w in al[u]:\n                        vis[w] = 1\n                        flag = 1\n                for i in range(n):\n                    if vis[i] == 1:\n                        xl.append(i)\n                        q2.put(i)\n                        q2l.append(i)\n            if len(xl) != 0:\n                qout[tq1l] = xl\n            count = count + 1\n            if flag == 0:\n                break\n            if xl in ind:\n                break\n            unit[count] = xl\n            ind.append(xl)\n        else:\n            vis = [0] * n\n            flag = 0\n            xl = []\n            q1l = []\n            tq2l = tuple(q2l)\n            if tq2l in qout:\n                q1l = qout[tq2l]\n                xl = qout[tq2l]\n                flag = 1\n            else:\n                while q2.empty() == False:\n                    u = q2.get()\n                    for w in al[u]:\n                        vis[w] = 1\n                        flag = 1\n                for i in range(n):\n                    if vis[i] == 1:\n                        xl.append(i)\n                        q1.put(i)\n                        q1l.append(i)\n            count = count + 1\n            if len(xl) != 0:\n                qout[tq2l] = xl\n            if flag == 0:\n                break\n            if xl in ind:\n                break\n            unit[count] = xl\n            ind.append(xl)\n        y = y + 1\n    tot[x - 1] = unit\n    cycle = []\n    if xl in ind:\n        index = ind.index(xl)\n        cycle = []\n        cycle = ind[index:]\n        totc[x - 1] = cycle\n    if k in unit:\n        print(len(unit[k]))\n        print(' '.join((str(j + 1) for j in unit[k])))\n    else:\n        ln = len(unit)\n        lnc = len(cycle)\n        z = k - ln + 1\n        if lnc > 0:\n            z = z % lnc\n            if z == 0:\n                z = lnc - 1\n            else:\n                z = z - 1\n            print(len(cycle[z]))\n            print(' '.join((str(j + 1) for j in cycle[z])))\n        else:\n            print(0)\n            print(-1)", "import numpy as np\n\ndef getPowers(x):\n    k = 2\n    ret = [x]\n    done = False\n    while k < 10 ** 9:\n        if done:\n            ret += [x]\n        else:\n            y = x.dot(x)\n            y[y > 0] = 1\n            done = np.all(y == x)\n            x = y\n            ret += [x]\n        k *= 2\n    return ret\n\ndef mpow(xp, z, k):\n    i = 0\n    while k > 0:\n        if k % 2 == 1:\n            z = xp[i].dot(z)\n        i = i + 1\n        k //= 2\n    return z\n\ndef solve(x, y):\n    xp = getPowers(x)\n    n = x.shape[0]\n    for (k, z) in y:\n        z0 = np.zeros(n)\n        z0[z] = 1\n        z0 = mpow(xp, z0, k)\n        ret = list(np.where(z0 > 0)[0])\n        print(len(ret))\n        if len(ret) == 0:\n            print(-1)\n        else:\n            print(' '.join((str(x + 1) for x in ret)))\nimport sys\nf = sys.stdin\nn = int(f.readline())\nx = []\nfor j in range(n):\n    y = list(map(int, f.readline().split()))\n    x += [y]\nx = np.array(x, dtype=np.float64).transpose()\nm = int(f.readline())\ny = []\nfor i in range(m):\n    (a, b) = map(int, f.readline().split())\n    y += [(a, b - 1)]\nsolve(x, y)"]