["from typing import List\nfrom collections import deque\nmod = 1000000007\n\nclass Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef build_tree(arr: List[int]) -> Node:\n    n = len(arr)\n    root = Node(arr[0])\n    queue = deque([root])\n    ind = 1\n    while ind < n:\n        cur = queue.popleft()\n        cur.left = Node(arr[ind])\n        queue.append(cur.left)\n        cur.right = Node(arr[ind + 1])\n        queue.append(cur.right)\n        ind += 2\n    return root\n\ndef postorder(root: Node) -> None:\n    if root:\n        left = postorder(root.left)\n        right = postorder(root.right)\n        root.data *= max(left, right)\n        return root.data\n    else:\n        return 1\n\ndef soln(n: int, arr: List[int]) -> int:\n    root = build_tree(arr)\n    postorder(root)\n    return root.data % mod\nwhile True:\n    n = int(input())\n    if n > 0:\n        arr = list(map(int, input().split()))\n        print(soln(n, arr))\n    else:\n        break", "while True:\n    h = int(input())\n    if h == 0:\n        break\n    nums = list(map(int, input().split(' ')))\n    n = 2 ** h - 1\n    p = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        if 2 * i + 1 >= n:\n            p[i] = nums[i]\n        else:\n            p[i] = nums[i] * max(p[2 * i + 1], p[2 * i + 2])\n    print(p[0] % 1000000007)", "while True:\n    h = int(input())\n    if h == 0:\n        break\n    nums = list(map(int, input().split(' ')))\n    n = 2 ** h - 1\n    p = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        if 2 * i + 1 >= n:\n            p[i] = nums[i]\n        else:\n            p[i] = nums[i] * max(p[2 * i + 1], p[2 * i + 2])\n    print(p[0] % 1000000007)", "z = 0\nwhile z == 0:\n    h = int(input())\n    if h == 0:\n        break\n    n = 2 ** h - 1\n    p = [0] * (n + 10)\n    v = list(map(int, input().split()))\n    for i in range(n - 1, -1, -1):\n        if 2 * i + 1 >= n:\n            p[i] = v[i]\n        else:\n            p[i] = v[i] * max(p[2 * i + 1], p[2 * i + 2])\n    ans = p[0] % (1000000000 + 7)\n    print(ans)", "from sys import *\nimport math\nfrom collections import Counter\nmod = 1000000000 + 7\n\ndef solve():\n    lst = list(map(int, input().split()))\n    if n == 1:\n        print(lst[0])\n        return\n    index = len(lst) - 1\n    leaf_nodes = index - 2 ** (n - 1) + 2\n    ans = [0] * (index + 1)\n    while index != 0:\n        last = lst.pop()\n        if leaf_nodes > 0:\n            ans[index] = last\n            leaf_nodes -= 1\n        p_index = (index - 1) // 2\n        ans[p_index] = max(ans[p_index], lst[p_index] * ans[index])\n        index -= 1\n    print(ans[0] % mod)\nfor _ in range(15):\n    n = int(input())\n    if n == 0:\n        break\n    solve()", "from sys import *\nimport math\nfrom collections import Counter\nmod = 1000000000 + 7\n\ndef solve():\n    lst = list(map(int, input().split()))\n    if n == 1:\n        print(lst[0])\n        return\n    index = len(lst) - 1\n    leaf_nodes = index - 2 ** (n - 1) + 2\n    ans = [0] * (index + 1)\n    while index != 0:\n        last = lst.pop()\n        if leaf_nodes > 0:\n            ans[index] = last\n            leaf_nodes -= 1\n        p_index = (index - 1) // 2\n        ans[p_index] = max(ans[p_index], lst[p_index] * ans[index])\n        index -= 1\n    print(ans[0] % mod)\nfor _ in range(15):\n    n = int(input())\n    if n == 0:\n        break\n    solve()", "a = 1000000007\nwhile True:\n    N = int(input())\n    if N == 0:\n        break\n    v = list(map(int, input().split()))\n    len = (1 << N) - 1\n    for i in range(len // 2, -1, -1):\n        left = i * 2 + 1\n        right = i * 2 + 2\n        if left < len and right < len:\n            v[i] = v[i] * max(v[left], v[right])\n        elif left < len:\n            v[i] = v[i] * v[left]\n    print(v[0] % a)", "from sys import *\nmod = 1000000000 + 7\n\ndef solve():\n    lst = list(map(int, input().strip().split(' ')))\n    if n == 1:\n        print(lst[0])\n        return\n    index = len(lst) - 1\n    leaf_nodes = index - 2 ** (n - 1) + 2\n    ans = [0] * (index + 1)\n    while index != 0:\n        last = lst.pop()\n        if leaf_nodes > 0:\n            ans[index] = last\n            leaf_nodes -= 1\n        p_index = (index - 1) // 2\n        ans[p_index] = max(ans[p_index], lst[p_index] * ans[index])\n        index -= 1\n    print(ans[0] % mod)\nfor _ in range(15):\n    n = int(input().strip())\n    if n == 0:\n        break\n    solve()", "from sys import *\nimport math\nfrom collections import Counter\nmod = 1000000000 + 7\n\ndef solve():\n    lst = list(map(int, input().split()))\n    if n == 1:\n        print(lst[0])\n        return\n    index = len(lst) - 1\n    leaf_nodes = index - 2 ** (n - 1) + 2\n    ans = [0] * (index + 1)\n    while index != 0:\n        last = lst.pop()\n        if leaf_nodes > 0:\n            ans[index] = last\n            leaf_nodes -= 1\n        p_index = (index - 1) // 2\n        ans[p_index] = max(ans[p_index], lst[p_index] * ans[index])\n        index -= 1\n    print(ans[0] % mod)\nfor _ in range(15):\n    n = int(input())\n    if n == 0:\n        break\n    solve()", "from sys import *\nimport math\nfrom collections import Counter\nmod = 1000000000 + 7\nfor _ in range(15):\n    n = int(input())\n    if n == 0:\n        break\n    lst = list(map(int, input().split()))\n    if n == 1:\n        print(lst[0])\n        break\n    index = len(lst) - 1\n    leaf_nodes = index - 2 ** (n - 1) + 2\n    ans = [0] * (index + 1)\n    while index != 0:\n        last = lst.pop()\n        if leaf_nodes > 0:\n            ans[index] = last\n            leaf_nodes -= 1\n        p_index = (index - 1) // 2\n        ans[p_index] = max(ans[p_index], lst[p_index] * ans[index])\n        index -= 1\n    print(ans[0] % mod)", "n = int(input())\nwhile n != 0:\n    a = list(map(int, input().split()))\n    for i in range(len(a) // 2 - 1, -1, -1):\n        a[i] = max(a[i * 2 + 1] * a[i], a[i * 2 + 2] * a[i])\n    print(a[0] % 1000000007)\n    n = int(input())", "a = 1000000007\nwhile True:\n    N = int(input())\n    if N == 0:\n        break\n    v = list(map(int, input().split()))\n    len = (1 << N) - 1\n    for i in range(len // 2, -1, -1):\n        left = i * 2 + 1\n        right = i * 2 + 2\n        if left < len and right < len:\n            v[i] = v[i] * max(v[left], v[right])\n        elif left < len:\n            v[i] = v[i] * v[left]\n    print(v[0] % a)", "a = 1000000007\nwhile True:\n    N = int(input())\n    if N == 0:\n        break\n    v = list(map(int, input().split()))\n    len = (1 << N) - 1\n    for i in range(len // 2, -1, -1):\n        left = i * 2 + 1\n        right = i * 2 + 2\n        if left < len and right < len:\n            v[i] = v[i] * max(v[left], v[right])\n        elif left < len:\n            v[i] = v[i] * v[left]\n    print(v[0] % a)", "import array as arr\n\ndef calc(a, n, i):\n    if 2 * i >= n:\n        return a[i]\n    left = calc(a, n, 2 * i)\n    right = calc(a, n, 2 * i + 1)\n    m = max(left, right)\n    return a[i] * m\nn = int(input())\nwhile n != 0:\n    a = arr.array('i', [int(x) for x in input().split()])\n    n = 2 ** n\n    a.insert(0, 0)\n    b = calc(a, n, 1)\n    print(b % 1000000007)\n    n = int(input())", "i = int(input())\nmodu = 1000000007\nwhile i != 0:\n    tree = [int(i) for i in input().split()]\n\n    def P(ind):\n        l = 2 * ind + 1\n        r = 2 * ind + 2\n        if l >= len(tree):\n            return tree[ind]\n        else:\n            return tree[ind] * max(P(l), P(r))\n    print(P(0) % modu)\n    i = int(input())", "mod = 1000000007\n\ndef integer_list():\n    return list(map(int, input().split()))\n\ndef string_list():\n    return list(map(str, input().split()))\n\ndef hetro_list():\n    return list(input().split())\nimport math\nimport sys\nfrom collections import Counter\n\ndef main():\n    if h == 1:\n        print(lst[0])\n        return\n    index = len(lst) - 1\n    leaf_nodes = index - 2 ** (h - 1) + 2\n    ans = [0] * (index + 1)\n    while index != 0:\n        last = lst.pop()\n        if leaf_nodes > 0:\n            ans[index] = last\n            leaf_nodes -= 1\n        p_index = (index - 1) // 2\n        ans[p_index] = max(ans[p_index], lst[p_index] * ans[index])\n        index -= 1\n    print(ans[0] % mod)\nfor _ in range(15):\n    h = int(input())\n    if h == 0:\n        break\n    lst = integer_list()\n    main()", "def makeAdj(arr):\n    n = len(arr)\n    adj = {i: [] for i in range(n)}\n    for i in range(n):\n        if 2 * i + 2 < n:\n            adj[i].append(2 * i + 1)\n            adj[i].append(2 * i + 2)\n            adj[2 * i + 1].append(i)\n            adj[2 * i + 2].append(i)\n        elif 2 * i + 1 < n:\n            adj[i].append(2 * i + 1)\n            adj[2 * i + 1].append(i)\n    return adj\n\ndef dfs(node, par, arr, adj, P):\n    if len(adj[node]) == 1:\n        P[node] = arr[node]\n        return\n    for child in adj[node]:\n        if child == par:\n            continue\n        dfs(child, node, arr, adj, P)\n        P[node] = max(P[child] * arr[node], P[node])\n    return P\nwhile True:\n    h = int(input())\n    if h == 0:\n        break\n    arr = list(map(int, input().split()))\n    adj = makeAdj(arr)\n    P = [0] * len(arr)\n    print(dfs(0, -1, arr, adj, P)[0] % 1000000007)", "def makeAdj(arr):\n    n = len(arr)\n    adj = {i: [] for i in range(n)}\n    for i in range(n):\n        if 2 * i + 2 < n:\n            adj[i].append(2 * i + 1)\n            adj[i].append(2 * i + 2)\n            adj[2 * i + 1].append(i)\n            adj[2 * i + 2].append(i)\n        elif 2 * i + 1 < n:\n            adj[i].append(2 * i + 1)\n            adj[2 * i + 1].append(i)\n    return adj\n\ndef dfs(node, par, arr, adj, P):\n    if len(adj[node]) == 1:\n        P[node] = arr[node]\n        return\n    for child in adj[node]:\n        if child == par:\n            continue\n        dfs(child, node, arr, adj, P)\n        P[node] = max(P[child] * arr[node], P[node])\n    return P\nwhile True:\n    h = int(input())\n    if h == 0:\n        break\n    arr = list(map(int, input().split()))\n    adj = makeAdj(arr)\n    P = [0] * len(arr)\n    print(dfs(0, -1, arr, adj, P)[0] % 1000000007)", "from heapq import heapify, heappush, heappop\nfrom cmath import pi\nfrom distutils import extension\nfrom pickle import FALSE\nimport sys\nfrom math import gcd, sqrt, log10, log2, floor, ceil\nfrom collections import deque, defaultdict\nfrom tkinter.tix import Tree\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\n\ndef il():\n    return [int(a) for a in input().strip().split()]\n\ndef ip():\n    return input().strip()\n\ndef ii():\n    return int(input())\n\ndef ot(in_p, *args, e=' '):\n    if type(in_p) == list:\n        print(*in_p, end=e)\n    if type(in_p) == str or type(in_p) == int:\n        print(in_p, end=e)\n        for l in args:\n            print(l, end=e)\n    print()\n\ndef rg(*ag):\n    if len(ag) == 3:\n        return range(ag[0], ag[1], ag[2])\n    elif len(ag) == 2:\n        return range(ag[0], ag[1])\n    elif len(ag) == 1:\n        return range(ag[0])\n    else:\n        raise 'invalid input'\n\ndef ispal(i, j, st):\n    while i <= j:\n        if st[i] == st[j]:\n            i = i + 1\n            j = j - 1\n        else:\n            return False\n    return True\nmod = 1000000007\n\ndef treePrd(arr, i):\n    if 2 * i > len(arr):\n        return arr[i - 1]\n    return arr[i - 1] % mod * max(treePrd(arr, 2 * i), treePrd(arr, 2 * i + 1))\nwhile True:\n    h = ii()\n    if h == 0:\n        break\n    arr = il()\n    print(treePrd(arr, 1) % mod)", "while True:\n    n = int(input())\n    if n == 0:\n        break\n    L = list(map(int, input().split()))\n    i = n - 1\n    while i > 0:\n        if i >= 2:\n            for j in range(2 ** i - 2, 2 ** (i - 1) - 2, -1):\n                L[j] *= max(L[-1], L[-2])\n                L.pop()\n                L.pop()\n        else:\n            L[0] *= max(L[1], L[2])\n        i -= 1\n    print(L[0] % (10 ** 9 + 7))", "from math import log2\nMOD = 10 ** 9 + 7\n\ndef solve(V, H):\n    logV = [log2(i) for i in V]\n    N = 2 ** H - 1\n    for i in range(0, N // 2):\n        (left, right) = (2 * i + 1, 2 * i + 2)\n        V[left] = V[i] * V[left] % MOD\n        V[right] = V[i] * V[right] % MOD\n        logV[left] += logV[i]\n        logV[right] += logV[i]\n    (maxLog, ans) = (0.0, 0)\n    for i in range(N // 2, N):\n        if logV[i] > maxLog:\n            maxLog = logV[i]\n            ans = V[i]\n    print(ans)\nwhile True:\n    H = int(input())\n    if H == 0:\n        break\n    V = list(map(int, input().split()))\n    solve(V, H)", "from math import log2\nMOD = 10 ** 9 + 7\n\ndef solve(V, H):\n    logV = [log2(i) for i in V]\n    N = 2 ** H - 1\n    for i in range(0, N // 2):\n        (left, right) = (2 * i + 1, 2 * i + 2)\n        V[left] = V[i] * V[left] % MOD\n        V[right] = V[i] * V[right] % MOD\n        logV[left] += logV[i]\n        logV[right] += logV[i]\n    (maxLog, ans) = (0.0, 0)\n    for i in range(N // 2, N):\n        if logV[i] > maxLog:\n            maxLog = logV[i]\n            ans = V[i]\n    print(ans)\nwhile True:\n    H = int(input())\n    if H == 0:\n        break\n    V = list(map(int, input().split()))\n    solve(V, H)", "from math import log2\nMOD = 10 ** 9 + 7\n\ndef solve(V, H):\n    logV = [log2(i) for i in V]\n    N = 2 ** H - 1\n    for i in range(0, N // 2):\n        (left, right) = (2 * i + 1, 2 * i + 2)\n        V[left] = V[i] * V[left] % MOD\n        V[right] = V[i] * V[right] % MOD\n        logV[left] += logV[i]\n        logV[right] += logV[i]\n    (maxLog, ans) = (0.0, 0)\n    for i in range(N // 2, N):\n        if logV[i] > maxLog:\n            maxLog = logV[i]\n            ans = V[i]\n    print(ans)\nwhile True:\n    H = int(input())\n    if H == 0:\n        break\n    V = list(map(int, input().split()))\n    solve(V, H)", "from math import log2\nMOD = 10 ** 9 + 7\n\ndef solve(V, H):\n    logV = [log2(i) for i in V]\n    N = 2 ** H - 1\n    for i in range(0, N // 2):\n        (left, right) = (2 * i + 1, 2 * i + 2)\n        V[left] = V[i] * V[left] % MOD\n        V[right] = V[i] * V[right] % MOD\n        logV[left] += logV[i]\n        logV[right] += logV[i]\n    (maxLog, ans) = (0.0, 0)\n    for i in range(N // 2, N):\n        if logV[i] > maxLog:\n            maxLog = logV[i]\n            ans = V[i]\n    print(ans)\nwhile True:\n    H = int(input())\n    if H == 0:\n        break\n    V = list(map(int, input().split()))\n    solve(V, H)", "from math import log2\nMOD = 10 ** 9 + 7\n\ndef solve(V, H):\n    logV = [log2(i) for i in V]\n    N = 2 ** H - 1\n    for i in range(0, N // 2):\n        (left, right) = (2 * i + 1, 2 * i + 2)\n        V[left] = V[i] * V[left] % MOD\n        V[right] = V[i] * V[right] % MOD\n        logV[left] += logV[i]\n        logV[right] += logV[i]\n    (maxLog, ans) = (0.0, 0)\n    for i in range(N // 2, N):\n        if logV[i] > maxLog:\n            maxLog = logV[i]\n            ans = V[i]\n    print(ans)\nwhile True:\n    H = int(input())\n    if H == 0:\n        break\n    V = list(map(int, input().split()))\n    solve(V, H)", "from math import log2\nMOD = 10 ** 9 + 7\n\ndef solve(V, H):\n    logV = [log2(i) for i in V]\n    N = 2 ** H - 1\n    for i in range(0, N // 2):\n        (left, right) = (2 * i + 1, 2 * i + 2)\n        V[left] = V[i] * V[left] % MOD\n        V[right] = V[i] * V[right] % MOD\n        logV[left] += logV[i]\n        logV[right] += logV[i]\n    (maxLog, ans) = (0.0, 0)\n    for i in range(N // 2, N):\n        if logV[i] > maxLog:\n            maxLog = logV[i]\n            ans = V[i]\n    print(ans)\nwhile True:\n    H = int(input())\n    if H == 0:\n        break\n    V = list(map(int, input().split()))\n    solve(V, H)", "from math import log2\nMOD = 10 ** 9 + 7\n\ndef solve(V, H):\n    logV = [log2(i) for i in V]\n    N = 2 ** H - 1\n    for i in range(0, N // 2):\n        (left, right) = (2 * i + 1, 2 * i + 2)\n        V[left] = V[i] * V[left] % MOD\n        V[right] = V[i] * V[right] % MOD\n        logV[left] += logV[i]\n        logV[right] += logV[i]\n    (maxLog, ans) = (0.0, 0)\n    for i in range(N // 2, N):\n        if logV[i] > maxLog:\n            maxLog = logV[i]\n            ans = V[i]\n    print(ans)\nwhile True:\n    H = int(input())\n    if H == 0:\n        break\n    V = list(map(int, input().split()))\n    solve(V, H)", "while True:\n    N = int(input())\n    if N == 0:\n        break\n    v = list(map(int, input().split()))\n    len = (1 << N) - 1\n    for i in range(len // 2, -1, -1):\n        left = i * 2 + 1\n        right = i * 2 + 2\n        if left < len and right < len:\n            v[i] = v[i] * max(v[left], v[right])\n        elif left < len:\n            v[i] = v[i] * v[left]\n    print(v[0] % 1000000007)", "while True:\n    N = int(input())\n    if N == 0:\n        break\n    v = list(map(int, input().split()))\n    len = (1 << N) - 1\n    for i in range(len // 2, -1, -1):\n        left = i * 2 + 1\n        right = i * 2 + 2\n        if left < len and right < len:\n            v[i] = v[i] * max(v[left], v[right])\n        elif left < len:\n            v[i] = v[i] * v[left]\n    print(v[0] % 1000000007)", "while True:\n    h = int(input())\n    if h == 0:\n        break\n    vi = list(map(int, input().split()))\n    lenl = (1 << h) - 1\n    for i in range(lenl // 2, -1, -1):\n        lind = i * 2 + 1\n        rind = i * 2 + 2\n        if lind < lenl and rind < lenl:\n            vi[i] = vi[i] * max(vi[lind], vi[rind])\n        elif lind < lenl:\n            vi[i] = vi[i] * vi[lind]\n    print(vi[0] % 1000000007)", "h = int(input())\nwhile h != 0:\n    l = list(map(int, input().split()))\n    i = len(l)\n    f = 1\n    c = 10 ** 9 + 7\n    prev = 10000000112121121\n    while i >= 1 and f == 1:\n        x = i // 2\n        if x < prev:\n            max = 0\n            prev = x\n        calv = l[i - 1] * l[x - 1]\n        if calv > max:\n            max = calv\n        if i % 2 == 0:\n            l[x - 1] = max\n        i = i - 1\n    print(l[0] % c)\n    h = int(input())", "h = int(input())\nwhile h != 0:\n    vs = [0] + list(map(int, input().split()))\n    for i in range(h - 1, 0, -1):\n        st = 2 ** (i - 1)\n        end = 2 ** i - 1\n        for j in range(st, end + 1):\n            vs[j] = vs[j] * max(vs[j * 2], vs[j * 2 + 1])\n    print(vs[1] % 1000000007)\n    h = int(input())", "solver = 1\nsol = []\n\ndef callup(s, solver):\n    if s == 1 or s == 0:\n        k = l[1] * solver\n        sol.append(k)\n    else:\n        solver = l[s] * solver\n        s = s // 2\n        callup(s, solver)\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    l = list(map(int, input().split()))\n    l.insert(0, 0)\n    for i in range(len(l) - 1, 0, -1):\n        l[i] = callup(i, solver)\n        solver = 1\n    print(max(sol) % 1000000007)\n    sol = []\n    solver = 1", "mdl = 1000000007\nwhile True:\n    h = int(input())\n    if h == 0:\n        break\n    n = 2 ** h - 1\n    z = input().split()\n    t = [0] + list(map(int, z[:n]))\n    for ix in range(n // 2, 0, -1):\n        ixc = 2 * ix\n        t[ix] *= max(t[ixc], t[ixc + 1])\n    print(t[1] % mdl)", "MOD = 10 ** 9 + 7\nh = int(input())\nwhile h != 0:\n    a = [int(i) for i in input().split()]\n    for i in range(len(a) - 1, -1, -2):\n        par = i // 2 - 1\n        if par > 0:\n            a[par] = max(a[par * 2 + 1] * a[par], a[par * 2 + 2] * a[par])\n    print(max(a[1] * a[0], a[2] * a[0]) % MOD)\n    h = int(input())", "z = 0\nwhile z == 0:\n    h = int(input())\n    if h == 0:\n        break\n    n = (1 << h) - 1\n    p = [0] * (n + 10)\n    v = [int(x) for x in input().split()]\n    for i in range(n - 1, -1, -1):\n        if 2 * i + 1 >= n:\n            p[i] = v[i]\n        else:\n            p[i] = v[i] * max(p[2 * i + 1], p[2 * i + 2])\n    ans = p[0] % 1000000007\n    print(ans)", "def maxProduct(data, fringe, H):\n    for i in range(H - 1):\n        nextDepth = list()\n        for node in fringe:\n            nextDepth.append(node * next(data))\n            nextDepth.append(node * next(data))\n        fringe = nextDepth\n    return max(fringe)\nwhile True:\n    H = int(input())\n    if H == 0:\n        break\n    data = (int(n) for n in input().split())\n    print(maxProduct(data, [next(data)], H) % 1000000007)", "def maxProduct(data, fringe, H):\n    for i in range(H - 1):\n        nextDepth = list()\n        for node in fringe:\n            nextDepth.append(node * next(data))\n            nextDepth.append(node * next(data))\n        fringe = nextDepth\n    return max(fringe)\nwhile True:\n    H = int(input())\n    if H == 0:\n        break\n    data = iter(map(int, input().split()))\n    print(maxProduct(data, [next(data)], H) % 1000000007)", "def maxProduct(data, currentHeight):\n    index = 0\n    while index != len(data):\n        nextDepth = list()\n        for node in currentHeight:\n            nextDepth.append(node * data[index])\n            nextDepth.append(node * data[index + 1])\n            index += 2\n        currentHeight = nextDepth\n    return max(currentHeight)\nwhile True:\n    if input() == '0':\n        break\n    data = [int(n) for n in input().split()]\n    root = [data.pop(0)]\n    print(maxProduct(data, root) % 1000000007)"]