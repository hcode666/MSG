["import sys\nimport numpy as np\np1 = 599\np2 = 601\npp = p1 * p2\nMOD = 10 ** 9 + 7\n\ndef getLogPows(p, root=7):\n    v = 1\n    ret = np.zeros(p, dtype=np.int64)\n    pw = np.zeros(p, dtype=np.int64)\n    pw[0] = 1\n    for i in range(p - 1):\n        ret[v] = i\n        v = v * root % p\n        pw[i + 1] = v\n    return (ret, pw)\n(LOG1, POW1) = getLogPows(p1)\n(LOG2, POW2) = getLogPows(p2)\nCRT = np.zeros((p1, p2), dtype=np.int64)\nfor i in range(pp):\n    CRT[i % p1, i % p2] = i\nprimes = np.ones(pp, dtype=np.int64)\nMU = np.ones(pp, dtype=np.int64)\nMU[0] = 0\nprimes[:2] = 0\nfor i in range(2, pp):\n    if primes[i] == 1:\n        primes[2 * i::i] = 0\n        MU[i::i] *= -1\n        if i * i < len(MU):\n            MU[i * i::i * i] = 0\n\ndef getLogArray(xx):\n    arr = np.zeros((p1 - 1, p2 - 1))\n    arr10 = np.zeros(p2 - 1)\n    arr20 = np.zeros(p1 - 1)\n    zeros = 0\n    x1 = xx % p1\n    x2 = xx % p2\n    for (x1, x2) in zip(xx % p1, xx % p2):\n        if x1 == 0:\n            if x2 == 0:\n                zeros += 1\n            else:\n                arr10[LOG2[x2]] += 1\n        elif x2 == 0:\n            arr20[LOG1[x1]] += 1\n        else:\n            arr[LOG1[x1], LOG2[x2]] += 1\n    return (arr, arr10, arr20, zeros)\n\ndef getTotals(xx):\n    ret = np.zeros(pp, dtype=np.int64)\n    (arr, arr10, arr20, zeros) = getLogArray(xx)\n    aff = np.fft.rfft2(arr)\n    aff = aff * aff\n    r0 = np.fft.irfft2(aff)\n    for i in range(p1 - 1):\n        for j in range(p2 - 1):\n            ret[CRT[POW1[i], POW2[j]]] = int(np.round(r0[i, j]))\n    arrs1 = np.sum(arr, 0)\n    arrs2 = np.sum(arr, 1)\n    aff = np.fft.rfft(arr10)\n    aff2 = np.fft.rfft(arrs1)\n    r0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n    for j in range(p2 - 1):\n        ret[CRT[0, POW2[j]]] = int(np.round(r0[j]))\n    aff = np.fft.rfft(arr20)\n    aff2 = np.fft.rfft(arrs2)\n    r0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n    for i in range(p1 - 1):\n        ret[CRT[POW1[i], 0]] = int(np.round(r0[i]))\n    rr = 0\n    rrr = ret % MOD\n    ret = np.zeros(pp, dtype=np.int64)\n    for i in range(1, pp):\n        ret[i] = np.sum(rrr[i::i])\n    ret %= MOD\n    ret0 = ret * ret % MOD\n    ret1 = ret * ret0 % MOD\n    ret1 %= MOD\n    rval = np.sum(ret1 * MU) % MOD\n    zpairs = (zeros * len(xx) * 2 - zeros * zeros) % MOD\n    zpairs += int(np.sum(arr10)) % MOD * (int(np.sum(arr20)) % MOD) * 2\n    zpairs %= MOD\n    ret0 = ret * ret % MOD\n    rval += np.sum(ret0 * MU) % MOD * zpairs * 3 % MOD\n    rval %= MOD\n    rval += rrr[1] % MOD * (zpairs * zpairs % MOD) * 3 % MOD\n    return rval % MOD\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    f.readline()\n    x = np.array(list(map(int, f.readline().split())), dtype=np.int64)\n    print(getTotals(x))", "import sys\nimport numpy as np\np1 = 599\np2 = 601\npp = p1 * p2\nMOD = 10 ** 9 + 7\n\ndef getLogPows(p, root=7):\n    v = 1\n    ret = np.zeros(p, dtype=np.int64)\n    pw = np.zeros(p, dtype=np.int64)\n    pw[0] = 1\n    for i in range(p - 1):\n        ret[v] = i\n        v = v * root % p\n        pw[i + 1] = v\n    return (ret, pw)\n(LOG1, POW1) = getLogPows(p1)\n(LOG2, POW2) = getLogPows(p2)\nCRT = np.zeros((p1, p2), dtype=np.int64)\nfor i in range(pp):\n    CRT[i % p1, i % p2] = i\nprimes = np.ones(pp, dtype=np.int64)\nMU = np.ones(pp, dtype=np.int64)\nMU[0] = 0\nprimes[:2] = 0\nfor i in range(2, pp):\n    if primes[i] == 1:\n        primes[2 * i::i] = 0\n        MU[i::i] *= -1\n        if i * i < len(MU):\n            MU[i * i::i * i] = 0\n\ndef getLogArray(xx):\n    arr = np.zeros((p1 - 1, p2 - 1))\n    arr10 = np.zeros(p2 - 1)\n    arr20 = np.zeros(p1 - 1)\n    zeros = 0\n    x1 = xx % p1\n    x2 = xx % p2\n    for (x1, x2) in zip(xx % p1, xx % p2):\n        if x1 == 0:\n            if x2 == 0:\n                zeros += 1\n            else:\n                arr10[LOG2[x2]] += 1\n        elif x2 == 0:\n            arr20[LOG1[x1]] += 1\n        else:\n            arr[LOG1[x1], LOG2[x2]] += 1\n    return (arr, arr10, arr20, zeros)\n\ndef getTotals(xx):\n    ret = np.zeros(pp, dtype=np.int64)\n    (arr, arr10, arr20, zeros) = getLogArray(xx)\n    aff = np.fft.rfft2(arr)\n    aff = aff * aff\n    r0 = np.fft.irfft2(aff)\n    for i in range(p1 - 1):\n        for j in range(p2 - 1):\n            ret[CRT[POW1[i], POW2[j]]] = int(np.round(r0[i, j]))\n    arrs1 = np.sum(arr, 0)\n    arrs2 = np.sum(arr, 1)\n    aff = np.fft.rfft(arr10)\n    aff2 = np.fft.rfft(arrs1)\n    r0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n    for j in range(p2 - 1):\n        ret[CRT[0, POW2[j]]] = int(np.round(r0[j]))\n    aff = np.fft.rfft(arr20)\n    aff2 = np.fft.rfft(arrs2)\n    r0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n    for i in range(p1 - 1):\n        ret[CRT[POW1[i], 0]] = int(np.round(r0[i]))\n    rr = 0\n    rrr = ret % MOD\n    ret = np.zeros(pp, dtype=np.int64)\n    for i in range(1, pp):\n        ret[i] = np.sum(rrr[i::i])\n    ret %= MOD\n    ret0 = ret * ret % MOD\n    ret1 = ret * ret0 % MOD\n    ret1 %= MOD\n    rval = np.sum(ret1 * MU) % MOD\n    zpairs = (zeros * len(xx) * 2 - zeros * zeros) % MOD\n    zpairs += int(np.sum(arr10)) % MOD * (int(np.sum(arr20)) % MOD) * 2\n    zpairs %= MOD\n    ret0 = ret * ret % MOD\n    rval += np.sum(ret0 * MU) % MOD * zpairs * 3 % MOD\n    rval %= MOD\n    rval += rrr[1] % MOD * (zpairs * zpairs % MOD) * 3 % MOD\n    return rval % MOD\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    f.readline()\n    x = np.array(list(map(int, f.readline().split())), dtype=np.int64)\n    print(getTotals(x))", "import sys\nimport numpy as np\np1 = 599\np2 = 601\npp = p1 * p2\nMOD = 10 ** 9 + 7\n\ndef getLogPows(p, root=7):\n    v = 1\n    ret = np.zeros(p, dtype=np.int64)\n    pw = np.zeros(p, dtype=np.int64)\n    pw[0] = 1\n    for i in range(p - 1):\n        ret[v] = i\n        v = v * root % p\n        pw[i + 1] = v\n    return (ret, pw)\n(LOG1, POW1) = getLogPows(p1)\n(LOG2, POW2) = getLogPows(p2)\nCRT = np.zeros((p1, p2), dtype=np.int64)\nfor i in range(pp):\n    CRT[i % p1, i % p2] = i\nprimes = np.ones(pp, dtype=np.int64)\nMU = np.ones(pp, dtype=np.int64)\nMU[0] = 0\nprimes[:2] = 0\nfor i in range(2, pp):\n    if primes[i] == 1:\n        primes[2 * i::i] = 0\n        MU[i::i] *= -1\n        if i * i < len(MU):\n            MU[i * i::i * i] = 0\n\ndef getLogArray(xx):\n    arr = np.zeros((p1 - 1, p2 - 1))\n    arr10 = np.zeros(p2 - 1)\n    arr20 = np.zeros(p1 - 1)\n    zeros = 0\n    x1 = xx % p1\n    x2 = xx % p2\n    for (x1, x2) in zip(xx % p1, xx % p2):\n        if x1 == 0:\n            if x2 == 0:\n                zeros += 1\n            else:\n                arr10[LOG2[x2]] += 1\n        elif x2 == 0:\n            arr20[LOG1[x1]] += 1\n        else:\n            arr[LOG1[x1], LOG2[x2]] += 1\n    return (arr, arr10, arr20, zeros)\n\ndef getTotals(xx):\n    ret = np.zeros(pp, dtype=np.int64)\n    (arr, arr10, arr20, zeros) = getLogArray(xx)\n    aff = np.fft.rfft2(arr)\n    aff = aff * aff\n    r0 = np.fft.irfft2(aff)\n    for i in range(p1 - 1):\n        for j in range(p2 - 1):\n            ret[CRT[POW1[i], POW2[j]]] = int(np.round(r0[i, j]))\n    arrs1 = np.sum(arr, 0)\n    arrs2 = np.sum(arr, 1)\n    aff = np.fft.rfft(arr10)\n    aff2 = np.fft.rfft(arrs1)\n    r0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n    for j in range(p2 - 1):\n        ret[CRT[0, POW2[j]]] = int(np.round(r0[j]))\n    aff = np.fft.rfft(arr20)\n    aff2 = np.fft.rfft(arrs2)\n    r0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n    for i in range(p1 - 1):\n        ret[CRT[POW1[i], 0]] = int(np.round(r0[i]))\n    rr = 0\n    rrr = ret % MOD\n    ret = np.zeros(pp, dtype=np.int64)\n    for i in range(1, pp):\n        ret[i] = np.sum(rrr[i::i])\n    ret %= MOD\n    ret0 = ret * ret % MOD\n    ret1 = ret * ret0 % MOD\n    ret1 %= MOD\n    rval = np.sum(ret1 * MU) % MOD\n    zpairs = (zeros * len(xx) * 2 - zeros * zeros) % MOD\n    zpairs += int(np.sum(arr10)) % MOD * (int(np.sum(arr20)) % MOD) * 2\n    zpairs %= MOD\n    ret0 = ret * ret % MOD\n    rval += np.sum(ret0 * MU) % MOD * zpairs * 3 % MOD\n    rval %= MOD\n    rval += rrr[1] % MOD * (zpairs * zpairs % MOD) * 3 % MOD\n    return rval % MOD\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    f.readline()\n    x = np.array(list(map(int, f.readline().split())), dtype=np.int64)\n    print(getTotals(x))", "import sys\nimport numpy as np\np1 = 599\np2 = 601\npp = p1 * p2\nMOD = 10 ** 9 + 7\n\ndef getLogPows(p, root=7):\n    v = 1\n    ret = np.zeros(p, dtype=np.int64)\n    pw = np.zeros(p, dtype=np.int64)\n    pw[0] = 1\n    for i in range(p - 1):\n        ret[v] = i\n        v = v * root % p\n        pw[i + 1] = v\n    return (ret, pw)\n(LOG1, POW1) = getLogPows(p1)\n(LOG2, POW2) = getLogPows(p2)\nCRT = np.zeros((p1, p2), dtype=np.int64)\nfor i in range(pp):\n    CRT[i % p1, i % p2] = i\nprimes = np.ones(pp, dtype=np.int64)\nMU = np.ones(pp, dtype=np.int64)\nMU[0] = 0\nprimes[:2] = 0\nfor i in range(2, pp):\n    if primes[i] == 1:\n        primes[2 * i::i] = 0\n        MU[i::i] *= -1\n        if i * i < len(MU):\n            MU[i * i::i * i] = 0\n\ndef getLogArray(xx):\n    arr = np.zeros((p1 - 1, p2 - 1))\n    arr10 = np.zeros(p2 - 1)\n    arr20 = np.zeros(p1 - 1)\n    zeros = 0\n    x1 = xx % p1\n    x2 = xx % p2\n    for (x1, x2) in zip(xx % p1, xx % p2):\n        if x1 == 0:\n            if x2 == 0:\n                zeros += 1\n            else:\n                arr10[LOG2[x2]] += 1\n        elif x2 == 0:\n            arr20[LOG1[x1]] += 1\n        else:\n            arr[LOG1[x1], LOG2[x2]] += 1\n    return (arr, arr10, arr20, zeros)\n\ndef getTotals(xx):\n    ret = np.zeros(pp, dtype=np.int64)\n    (arr, arr10, arr20, zeros) = getLogArray(xx)\n    aff = np.fft.rfft2(arr)\n    aff = aff * aff\n    r0 = np.fft.irfft2(aff)\n    for i in range(p1 - 1):\n        for j in range(p2 - 1):\n            ret[CRT[POW1[i], POW2[j]]] = int(np.round(r0[i, j]))\n    arrs1 = np.sum(arr, 0)\n    arrs2 = np.sum(arr, 1)\n    aff = np.fft.rfft(arr10)\n    aff2 = np.fft.rfft(arrs1)\n    r0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n    for j in range(p2 - 1):\n        ret[CRT[0, POW2[j]]] = int(np.round(r0[j]))\n    aff = np.fft.rfft(arr20)\n    aff2 = np.fft.rfft(arrs2)\n    r0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n    for i in range(p1 - 1):\n        ret[CRT[POW1[i], 0]] = int(np.round(r0[i]))\n    rr = 0\n    rrr = ret % MOD\n    ret = np.zeros(pp, dtype=np.int64)\n    for i in range(1, pp):\n        ret[i] = np.sum(rrr[i::i])\n    ret %= MOD\n    ret0 = ret * ret % MOD\n    ret1 = ret * ret0 % MOD\n    ret1 %= MOD\n    rval = np.sum(ret1 * MU) % MOD\n    zpairs = (zeros * len(xx) * 2 - zeros * zeros) % MOD\n    zpairs += int(np.sum(arr10)) % MOD * (int(np.sum(arr20)) % MOD) * 2\n    zpairs %= MOD\n    ret0 = ret * ret % MOD\n    rval += np.sum(ret0 * MU) % MOD * zpairs * 3 % MOD\n    rval %= MOD\n    rval += rrr[1] % MOD * (zpairs * zpairs % MOD) * 3 % MOD\n    return rval % MOD\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    f.readline()\n    x = np.array(list(map(int, f.readline().split())), dtype=np.int64)\n    print(getTotals(x))"]