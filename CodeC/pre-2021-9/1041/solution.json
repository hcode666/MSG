["from math import ceil\nfrom bisect import insort\nfor u in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = 0\n    i = 0\n    pos = []\n    while i < n:\n        pos.append(ceil(k / ceil(k / (i + 1))))\n        i += 1\n    i = 0\n    while i < n - 1:\n        h = []\n        cl = [0] * 2001\n        j = 0\n        while i + j < n:\n            cl[a[i + j]] += 1\n            insort(h, a[i + j])\n            x = h[pos[j] - 1]\n            f = cl[x]\n            if cl[f]:\n                c += 1\n            j += 1\n        i += 1\n    print(c)", "from math import ceil\nfrom bisect import insort\nfor u in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = 0\n    i = 0\n    pos = []\n    while i < n:\n        pos.append(ceil(k / ceil(k / (i + 1))))\n        i += 1\n    i = 0\n    while i < n - 1:\n        h = []\n        cl = [0] * 2001\n        j = 0\n        while i + j < n:\n            cl[a[i + j]] += 1\n            insort(h, a[i + j])\n            x = h[pos[j] - 1]\n            f = cl[x]\n            if cl[f]:\n                c += 1\n            j += 1\n        i += 1\n    print(c)", "from math import ceil\nfrom bisect import insort\nfor u in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = 0\n    i = 0\n    pos = []\n    while i < n:\n        pos.append(ceil(k / ceil(k / (i + 1))))\n        i += 1\n    i = 0\n    while i < n - 1:\n        h = []\n        cl = [0] * 2001\n        j = 0\n        while i + j < n:\n            cl[a[i + j]] += 1\n            insort(h, a[i + j])\n            x = h[pos[j] - 1]\n            f = cl[x]\n            if cl[f]:\n                c += 1\n            j += 1\n        i += 1\n    print(c)", "from math import ceil\nfrom bisect import insort\nfor l in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = 0\n    i = 0\n    pos = []\n    while i < n:\n        pos.append(ceil(k / ceil(k / (i + 1))))\n        i += 1\n    i = 0\n    while i < n - 1:\n        h = []\n        cl = [0] * 2001\n        j = 0\n        while i + j < n:\n            cl[a[i + j]] += 1\n            insort(h, a[i + j])\n            x = h[pos[j] - 1]\n            f = cl[x]\n            if cl[f]:\n                c += 1\n            j += 1\n        i += 1\n    print(c)", "from math import ceil\nfrom bisect import insort\nfor z in range(int(input())):\n    (N, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = 0\n    i = 0\n    pos = []\n    while i < N:\n        pos.append(ceil(k / ceil(k / (i + 1))))\n        i += 1\n    i = 0\n    while i < N - 1:\n        h = []\n        cl = [0] * 2001\n        j = 0\n        while i + j < N:\n            cl[a[i + j]] += 1\n            insort(h, a[i + j])\n            x = h[pos[j] - 1]\n            f = cl[x]\n            if cl[f]:\n                c += 1\n            j += 1\n        i += 1\n    print(c)", "from math import ceil\nfrom bisect import insort\nfor u in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = 0\n    i = 0\n    pos = []\n    while i < n:\n        pos.append(ceil(k / ceil(k / (i + 1))))\n        i += 1\n    i = 0\n    while i < n - 1:\n        h = []\n        cl = [0] * 2001\n        j = 0\n        while i + j < n:\n            cl[a[i + j]] += 1\n            insort(h, a[i + j])\n            x = h[pos[j] - 1]\n            f = cl[x]\n            if cl[f]:\n                c += 1\n            j += 1\n        i += 1\n    print(c)", "from math import ceil\nfrom bisect import insort\nt = int(input())\nfor k in range(t):\n    (a, b) = map(int, input().split())\n    li = list(map(int, input().split()))\n    c = 0\n    i = 0\n    p = []\n    while i < a:\n        p.append(ceil(b / ceil(b / (i + 1))))\n        i += 1\n    i = 0\n    while i < a - 1:\n        h = []\n        co = [0] * 2001\n        j = 0\n        while i + j < a:\n            co[li[j + i]] += 1\n            insort(h, li[i + j])\n            x = h[p[j] - 1]\n            f = co[x]\n            if co[f]:\n                c += 1\n            j += 1\n        i += 1\n    print(c)", "from math import ceil\nfrom bisect import insort\nfor z in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = 0\n    i = 0\n    pos = []\n    while i < n:\n        pos.append(ceil(k / ceil(k / (i + 1))))\n        i += 1\n    i = 0\n    while i < n - 1:\n        h = []\n        cl = [0] * 2001\n        j = 0\n        while i + j < n:\n            cl[a[i + j]] += 1\n            insort(h, a[i + j])\n            x = h[pos[j] - 1]\n            f = cl[x]\n            if cl[f]:\n                c += 1\n            j += 1\n        i += 1\n    print(c)", "from bisect import insort\nfrom math import ceil\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    array = list(map(int, input().split()))\n    ans = 0\n    index = []\n    for i in range(1, n + 1):\n        index.append(ceil(k / ceil(k / i)))\n    for i in range(n):\n        count = [0] * 2001\n        temp = []\n        for j in range(i, n):\n            count[array[j]] += 1\n            insort(temp, array[j])\n            x = temp[index[j - i] - 1]\n            f = count[x]\n            if count[f]:\n                ans += 1\n    print(ans)", "import bisect\nimport sys\nfrom sys import stdin, stdout\ntest = int(sys.stdin.readline())\nwhile test > 0:\n    test = test - 1\n    nk = [int(x) for x in sys.stdin.readline().split()]\n    n = nk[0]\n    k = nk[1]\n    arr = [int(x) for x in sys.stdin.readline().split()]\n    arr.insert(0, 0)\n    c = 0\n    pre = [0 for k in range(2001)]\n    for i in range(1, 2001):\n        m = int(k / i) + 1\n        if k % i == 0:\n            m = m - 1\n        x = int(k / m) + 1\n        if k % m == 0:\n            x = x - 1\n        pre[i] = x\n    for i in range(1, n + 1):\n        brr = [0 for k in range(2001)]\n        lis = []\n        for j in range(i, n + 1):\n            brr[arr[j]] = brr[arr[j]] + 1\n            bisect.insort(lis, arr[j])\n            size = j - i + 1\n            xt = pre[size]\n            y = lis[xt - 1]\n            f = brr[y]\n            if brr[f] > 0:\n                c = c + 1\n    print(c)", "from math import ceil\nfrom bisect import insort\nfor z in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = 0\n    i = 0\n    pos = []\n    while i < n:\n        pos.append(ceil(k / ceil(k / (i + 1))))\n        i += 1\n    i = 0\n    while i < n - 1:\n        h = []\n        cl = [0] * 2001\n        j = 0\n        while i + j < n:\n            cl[a[i + j]] += 1\n            insort(h, a[i + j])\n            x = h[pos[j] - 1]\n            f = cl[x]\n            if cl[f]:\n                c += 1\n            j += 1\n        i += 1\n    print(c)", "from bisect import insort\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    items = list(map(int, input().split()))\n    ans = 0\n    e = [0 for i in range(n)]\n    for i in range(n):\n        t = (k - 1) // (i + 1)\n        e[i] = (k + t) // (t + 1) - 1\n    for i in range(n):\n        sub = []\n        c = 0\n        count = [0] * 2001\n        for j in range(i + 1, n + 1):\n            count[items[c + i]] += 1\n            insort(sub, items[c + i])\n            if count[count[sub[e[j - i - 1]]]] > 0:\n                ans += 1\n            c += 1\n    print(ans)", "from bisect import insort\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    items = list(map(int, input().split()))\n    ans = 0\n    e = [0 for i in range(n)]\n    for i in range(n):\n        t = (k - 1) // (i + 1)\n        e[i] = (k + t) // (t + 1) - 1\n    for i in range(n):\n        sub = []\n        c = 0\n        count = [0] * 2001\n        for j in range(i + 1, n + 1):\n            count[items[c + i]] += 1\n            insort(sub, items[c + i])\n            if count[count[sub[e[j - i - 1]]]] > 0:\n                ans += 1\n            c += 1\n    print(ans)", "from bisect import insort\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    items = list(map(int, input().split()))\n    ans = 0\n    e = [0 for i in range(n)]\n    for i in range(n):\n        t = (k - 1) // (i + 1)\n        e[i] = (k + t) // (t + 1) - 1\n    for i in range(n):\n        sub = []\n        c = 0\n        count = [0] * 2001\n        for j in range(i + 1, n + 1):\n            count[items[c + i]] += 1\n            insort(sub, items[c + i])\n            if count[count[sub[e[j - i - 1]]]] > 0:\n                ans += 1\n            c += 1\n    print(ans)", "from bisect import insort\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    items = list(map(int, input().split()))\n    ans = 0\n    e = [0 for i in range(n)]\n    for i in range(n):\n        t = (k - 1) // (i + 1)\n        e[i] = (k + t) // (t + 1) - 1\n    for a in range(n):\n        j = a + 1\n        sub = []\n        c = 0\n        count = [0] * 2001\n        while j <= n:\n            count[items[c + a]] += 1\n            insort(sub, items[c + a])\n            if count[count[sub[e[j - a - 1]]]] > 0:\n                ans += 1\n            j += 1\n            c += 1\n    print(ans)", "from bisect import insort\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    items = list(map(int, input().split()))\n    ans = 0\n    e = [0 for i in range(n)]\n    for i in range(n):\n        t = (k - 1) // (i + 1)\n        e[i] = (k + t) // (t + 1) - 1\n    for a in range(n):\n        j = a + 1\n        sub = []\n        c = 0\n        count = [0] * 2000\n        while j <= n:\n            count[items[c + a] - 1] += 1\n            insort(sub, items[c + a])\n            if count[count[sub[e[j - a - 1]] - 1] - 1] > 0:\n                ans += 1\n            j += 1\n            c += 1\n    print(ans)", "import math\nfrom bisect import insort\nt = int(input())\nfor i in range(t):\n    ans = 0\n    (n, k) = map(int, input().split())\n    items = list(map(int, input().split()))\n    j = 0\n    m = 0\n    e = []\n    for s in range(2000):\n        e.append(int((k - 1) / math.ceil(k / (s + 1))))\n    for a in range(n):\n        j = a + 1\n        sub = []\n        c = 0\n        count = [0] * 2000\n        while j <= n:\n            count[items[c + a] - 1] += 1\n            insort(sub, items[c + a])\n            if count[count[sub[e[j - a - 1]] - 1] - 1] > 0:\n                ans += 1\n            j += 1\n            c += 1\n    print(ans)", "from math import ceil\nfrom collections import defaultdict\nfrom bisect import bisect_left, bisect_right, insort\nfrom sys import stdin\n\ndef solve():\n    for _ in range(int(stdin.readline())):\n        (N, K) = map(int, stdin.readline().split())\n        A = [int(k) for k in stdin.readline().split()]\n        mA = min(A)\n        if mA > N:\n            print(0)\n            continue\n        ls = len(set(A))\n        if ls == 1:\n            print(max(0, N - A[0] + 1))\n            continue\n        if ls == N:\n            if mA == 1:\n                idx = A.index(1)\n                ans = 0\n                for i in range(idx + 1):\n                    ans += N - idx\n                print(ans)\n            else:\n                print(0)\n            continue\n        freq = defaultdict(list)\n        for i in range(N):\n            freq[A[i]].append(i)\n        ans = len(freq[1])\n        for i in range(N - 1):\n            S = [A[i]]\n            freq2 = defaultdict(int)\n            freq2[S[0]] += 1\n            for j in range(i + 1, N):\n                aj = A[j]\n                freq2[aj] += 1\n                insort(S, aj)\n                m = ceil(K / (j - i + 1))\n                k = ceil(K / m) - 1\n                x = S[k]\n                prev = k\n                f = freq2[x]\n                cont = 1 if f in freq2 else 0\n                if cont:\n                    ans += 1\n        print(ans)\nsolve()", "import math\nimport bisect\nt = int(input())\nfor i in range(t):\n    li = input().split()\n    n = int(li[0])\n    k = int(li[1])\n    lj = input().split()\n    l = []\n    poi = 1\n    pos = []\n    for j in lj:\n        l.append(int(j))\n        pos.append(int(math.ceil(k / math.ceil(k / poi)) - 1))\n        poi += 1\n    ans = 0\n    for j in range(n):\n        sub = list()\n        count = dict()\n        for m in range(j, n):\n            temp = l[m]\n            bisect.insort(sub, temp)\n            if count.get(temp, -1) == -1:\n                count[temp] = 1\n            else:\n                count[temp] += 1\n            x = sub[pos[m - j]]\n            f = count[x]\n            if count.get(f, -1) != -1:\n                ans += 1\n    print(ans)", "from math import ceil\nfrom bisect import insort\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = 0\n    d = defaultdict(int)\n    for i in range(n):\n        d[i + 1] = ceil(k / ceil(k / (i + 1))) - 1\n    for i in range(n):\n        s = []\n        t = defaultdict(int)\n        for j in range(i, n):\n            insort(s, a[j])\n            t[a[j]] += 1\n            if t[s[d[j - i + 1]]] in t:\n                ans += 1\n    print(ans)", "import bisect\nimport math\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    (n, k) = input().split()\n    n = int(n)\n    k = int(k)\n    arr = input().split()\n    arr_new = []\n    mth = []\n    for i in range(n):\n        arr_new.append(int(arr[i]))\n        leng = i + 1\n        cur = int(math.ceil(k / math.ceil(k / leng)) - 1)\n        mth.append(cur)\n    total_count = 0\n    for i in range(n):\n        arr_sorted = list()\n        arr_count = dict()\n        for j in range(i, n):\n            cur = arr_new[j]\n            if arr_count.get(cur, -1) == -1:\n                arr_count[cur] = 1\n            else:\n                arr_count[cur] += 1\n            bisect.insort(arr_sorted, cur)\n            leng = j - i\n            cur_count = arr_count[arr_sorted[mth[leng]]]\n            if arr_count.get(cur_count, -1) != -1:\n                total_count += 1\n    print(total_count)", "from math import ceil\nfrom bisect import insort\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = 0\n    d = defaultdict(int)\n    for i in range(n):\n        d[i + 1] = ceil(k / ceil(k / (i + 1))) - 1\n    for i in range(n):\n        s = []\n        t = defaultdict(int)\n        for j in range(i, n):\n            insort(s, a[j])\n            t[a[j]] += 1\n            if t[s[d[j - i + 1]]] in t:\n                ans += 1\n    print(ans)", "import bisect\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = 0\n    for i in range(n):\n        temp = []\n        occ = [0] * 2001\n        for j in range(i, n):\n            bisect.insort(temp, a[j])\n            occ[a[j]] += 1\n            m = (k + j - i) // (j - i + 1)\n            ele = temp[(k - 1) // m]\n            if occ[occ[ele]]:\n                ans += 1\n    print(ans)", "import bisect\nimport math\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = 0\n    for i in range(n):\n        temp = []\n        occ = [0] * 2001\n        for j in range(i, n):\n            bisect.insort(temp, a[j])\n            occ[a[j]] += 1\n            m = (k + j - i) // (j - i + 1)\n            ele = temp[(k - 1) // m]\n            if occ[occ[ele]]:\n                ans += 1\n    print(ans)", "import bisect\nt = int(input())\nfor y in range(t):\n    (n, k) = (int(x) for x in input().split())\n    places = []\n    for l in range(1, n + 1):\n        m = (k - 1) // l + 1\n        shoot = m * l - k\n        place = shoot // m + 1\n        places.append(place)\n    A = [int(x) for x in input().split()]\n    assert len(A) == n\n    ans = 0\n    for l in range(n):\n        elements = [0] * 2001\n        S = []\n        for r in range(l, n):\n            try:\n                elements[A[r]] += 1\n            except:\n                elements[A[r]] = 1\n            bisect.insort(S, A[r])\n            x = S[-places[r - l]]\n            f = elements[x]\n            try:\n                if elements[f] > 0:\n                    ans += 1\n            except:\n                pass\n    print(ans)", "import bisect\nt = int(input())\nwhile t > 0:\n    (n, k) = map(int, input().split(' '))\n    arr = list(map(int, input().split(' ')))\n    m = 0\n    p = 0\n    ans = 0\n    pos = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if k % i == 0:\n            m = k // i\n        else:\n            m = k // i + 1\n        if k % m == 0:\n            p = k // m\n        else:\n            p = k // m + 1\n        pos[i] = p - 1\n    for i in range(0, n):\n        res = {}\n        sub = []\n        for j in range(i, n):\n            if res.get(arr[j], -1) == -1:\n                res[arr[j]] = 1\n            else:\n                res[arr[j]] += 1\n            bisect.insort(sub, arr[j])\n            x = sub[pos[j - i + 1]]\n            f = res[x]\n            if res.get(f, -1) == -1:\n                ans = ans\n            else:\n                ans += 1\n    print(ans)\n    t = t - 1", "from math import ceil\nfrom collections import defaultdict\nfrom bisect import bisect_left, bisect_right, insort\nfrom sys import stdin\n\ndef solve():\n    for _ in range(int(stdin.readline())):\n        (N, K) = map(int, stdin.readline().split())\n        A = [int(k) for k in stdin.readline().split()]\n        mA = min(A)\n        if mA > N:\n            print(0)\n            continue\n        ls = len(set(A))\n        if ls == 1:\n            print(max(0, N - A[0] + 1))\n            continue\n        if ls == N:\n            if mA == 1:\n                idx = A.index(1)\n                ans = 0\n                for i in range(idx + 1):\n                    ans += N - idx\n                print(ans)\n            else:\n                print(0)\n            continue\n        freq = defaultdict(list)\n        for i in range(N):\n            freq[A[i]].append(i)\n        ans = len(freq[1])\n        for i in range(N - 1):\n            S = [A[i]]\n            freq2 = defaultdict(int)\n            freq2[S[0]] += 1\n            for j in range(i + 1, N):\n                aj = A[j]\n                freq2[aj] += 1\n                insort(S, aj)\n                m = ceil(K / (j - i + 1))\n                k = ceil(K / m) - 1\n                x = S[k]\n                prev = k\n                f = freq2[x]\n                cont = 1 if f in freq2 else 0\n                if cont:\n                    ans += 1\n        print(ans)\nsolve()", "import bisect\nt = int(input())\nfor _ in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    count = 0\n    for i in range(n):\n        c = [0 for x in range(n + 1)]\n        d = []\n        for j in range(i, n):\n            bisect.insort(d, a[j])\n            c[a[j]] += 1\n            req = c[d[(k - 1) // ((k - 1) // (j - i + 1) + 1)]]\n            if c[req] > 0:\n                count += 1\n    print(count)", "ttt = int(input())\nimport bisect, math\nfor _ in range(ttt):\n    (n, k) = list(map(int, input().split()))\n    it = list(map(int, input().split()))\n    t = 0\n    pos = []\n    for j in range(1, n + 1):\n        pos.append(math.ceil(k / math.ceil(k / j)) - 1)\n    for i in range(n):\n        sub = []\n        cc = {}\n        for j in range(i, n):\n            ko = it[j]\n            cc[ko] = cc.get(ko, 0) + 1\n            bisect.insort_right(sub, ko)\n            x = sub[pos[j - i]]\n            a = cc[x]\n            if cc.get(a, 0) != 0:\n                t += 1\n    print(t)", "import math\nimport bisect\n\ndef make_subarrays(a, n, k):\n    beautiful = 0\n    for i in range(n):\n        l = []\n        f = [0] * 2001\n        for j in range(i, n):\n            cur = a[j]\n            bisect.insort(l, cur)\n            f[cur] += 1\n            size = j - i + 1\n            p = math.ceil(k / size)\n            r = math.ceil(k / p)\n            c = f[f[l[r - 1]]]\n            if c > 0:\n                beautiful += 1\n    return beautiful\nt = int(input())\nwhile t:\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    beautiful = make_subarrays(a, n, k)\n    print(beautiful)\n    t -= 1", "ttt = int(input())\nimport bisect, math\nfor _ in range(ttt):\n    (n, k) = list(map(int, input().split()))\n    it = list(map(int, input().split()))\n    t = 0\n    pos = []\n    for j in range(1, n + 1):\n        pos.append(math.ceil(k / math.ceil(k / j)) - 1)\n    for i in range(n):\n        sub = []\n        cc = {}\n        for j in range(i, n):\n            cc[it[j]] = cc.get(it[j], 0) + 1\n            bisect.insort_right(sub, it[j])\n            x = sub[pos[j - i]]\n            a = cc[x]\n            if cc.get(a, 0) != 0:\n                t += 1\n    print(t)", "ttt = int(input())\nimport bisect, math\nfor _ in range(ttt):\n    (n, k) = list(map(int, input().split()))\n    it = list(map(int, input().split()))\n    t = 0\n    pos = []\n    for j in range(1, n + 1):\n        pos.append(math.ceil(k / math.ceil(k / j)) - 1)\n    for i in range(n):\n        sub = []\n        cc = {}\n        for j in range(i, n):\n            ko = it[j]\n            cc[ko] = cc.get(ko, 0) + 1\n            bisect.insort_right(sub, ko)\n            x = sub[pos[j - i]]\n            a = cc[x]\n            if cc.get(a, 0) != 0:\n                t += 1\n    print(t)", "import math\nfrom heapq import heappush, heappop\nimport random\n\ndef get_input_line():\n    return input()\n\ndef get_frequencies(array):\n    frequencies = {}\n    for number in array:\n        frequencies[number] = frequencies.get(number, 0) + 1\n    return frequencies\n\ndef solve_1(numbers, k):\n    good_arrays = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers) + 1):\n            current_array = numbers[i:j]\n            frequencies = get_frequencies(current_array)\n            multiplier = math.ceil(k / len(current_array))\n            items = sorted(list(frequencies.items()))\n            prev_multiplied_value = 0\n            (k_lowest_value, k_lowest_index, k_lowest_occurrence) = (None, None, None)\n            for (x, item) in enumerate(items):\n                current_multiplied_value = prev_multiplied_value + item[1] * multiplier\n                if prev_multiplied_value < k <= current_multiplied_value:\n                    k_lowest_value = item[0]\n                    k_lowest_index = x\n                    k_lowest_occurrence = item[1]\n                    break\n                prev_multiplied_value = current_multiplied_value\n            if k_lowest_occurrence in frequencies:\n                good_arrays += 1\n    return good_arrays\n\ndef solve_2(numbers, k):\n    good_arrays = 0\n    for i in range(len(numbers)):\n        numbers_frequencies = [0] * 2001\n        for j in range(i, len(numbers)):\n            numbers_frequencies[numbers[j]] += 1\n            multiplier = math.ceil(k / (j - i + 1))\n            new_k = math.ceil(k / multiplier)\n            cumulative_value = 0\n            for t in range(1, 2001):\n                freq = numbers_frequencies[t]\n                if not freq:\n                    continue\n                cumulative_value += freq\n                if cumulative_value >= new_k:\n                    if numbers_frequencies[freq] > 0:\n                        good_arrays += 1\n                    break\n    return good_arrays\n\ndef get_min_greater_position(array, value):\n    left = 0\n    right = len(array) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if value < array[mid]:\n            right = mid - 1\n        elif value > array[mid]:\n            left = mid + 1\n        else:\n            return mid\n    if value < array[left]:\n        return left\n    return left + 1\n\ndef insert(array, value):\n    if not array:\n        array.append(value)\n    else:\n        position = get_min_greater_position(array, value)\n        array = array[:position] + [value] + array[position:]\n    return array\n\ndef solve_3(numbers, k):\n    good_arrays = 0\n    for i in range(len(numbers)):\n        sorted_array = []\n        unique_values = {}\n        for j in range(i, len(numbers)):\n            unique_values[numbers[j]] = 1 + unique_values.get(numbers[j], 0)\n            sorted_array = insert(sorted_array, numbers[j])\n            multiplier = math.ceil(k / (j - i + 1))\n            new_k = int(math.ceil(k / multiplier))\n            if unique_values[sorted_array[new_k - 1]] in unique_values:\n                good_arrays += 1\n    return good_arrays\n\ndef solve_4(numbers, k):\n    good_arrays = 0\n    new_ks = [0] * len(numbers)\n    for i in range(len(numbers)):\n        multiplier = math.ceil(k / (i + 1))\n        new_ks[i] = int(math.ceil(k / multiplier))\n    for i in range(len(numbers)):\n        unique_values = {}\n        items_in_heap = 0\n        max_heap = []\n        min_heap = []\n        for j in range(i, len(numbers)):\n            unique_values[numbers[j]] = 1 + unique_values.get(numbers[j], 0)\n            heappush(max_heap, -numbers[j])\n            items_in_heap += 1\n            new_k = new_ks[j - i]\n            while items_in_heap < new_k:\n                heappush(max_heap, -heappop(min_heap))\n                items_in_heap += 1\n            while items_in_heap > new_k:\n                heappush(min_heap, -heappop(max_heap))\n                items_in_heap -= 1\n            kth_largest = -max_heap[0]\n            if unique_values[kth_largest] in unique_values:\n                good_arrays += 1\n    return good_arrays\n\ndef solve_5(numbers, k):\n    good_arrays = 0\n    new_ks = [0] * len(numbers)\n    for i in range(len(numbers)):\n        multiplier = math.ceil(k / (i + 1))\n        new_ks[i] = int(math.ceil(k / multiplier))\n    for i in range(len(numbers)):\n        unique_values = {}\n        items_in_heap = 0\n        max_heap = []\n        prev_removed = []\n        for j in range(i, len(numbers)):\n            unique_values[numbers[j]] = 1 + unique_values.get(numbers[j], 0)\n            heappush(max_heap, -numbers[j])\n            items_in_heap += 1\n            new_k = new_ks[j - i]\n            while items_in_heap < new_k:\n                heappush(max_heap, prev_removed.pop())\n                items_in_heap += 1\n            while items_in_heap > new_k:\n                prev_removed.append(heappop(max_heap))\n                items_in_heap -= 1\n            kth_largest = -max_heap[0]\n            if unique_values[kth_largest] in unique_values:\n                good_arrays += 1\n    return good_arrays\n\ndef solve_6(numbers, k):\n    good_arrays = 0\n    new_ks2 = [0] * len(numbers)\n    for i in range(len(numbers)):\n        multiplier = math.ceil(k / (i + 1))\n        new_ks2[i] = i + 2 - int(math.ceil(k / multiplier))\n    for i in range(len(numbers)):\n        unique_values = {}\n        items_in_heap = 0\n        min_heap = []\n        for j in range(i, len(numbers)):\n            unique_values[numbers[j]] = 1 + unique_values.get(numbers[j], 0)\n            heappush(min_heap, numbers[j])\n            items_in_heap += 1\n            new_k = new_ks2[j - i]\n            while items_in_heap > new_k:\n                heappop(min_heap)\n                items_in_heap -= 1\n            kth_largest = min_heap[0]\n            if unique_values[kth_largest] in unique_values:\n                good_arrays += 1\n    return good_arrays\n\ndef main():\n    test_count = int(get_input_line())\n    for i in range(test_count):\n        (_, k) = map(int, get_input_line().split())\n        numbers = list(map(int, get_input_line().split()))\n        print(solve_4(numbers, k))\nmain()", "import bisect\nimport math\nloop = int(input())\nfor time in range(loop):\n    length_counter = 1\n    array = []\n    position = []\n    temp_input = input().split()\n    temp_list = input().split()\n    n = int(temp_input[0])\n    k = int(temp_input[1])\n    answer = 0\n    for i in temp_list:\n        array.append(int(i))\n        temp = int(math.ceil(k / math.ceil(k / length_counter)) - 1)\n        position.append(temp)\n        length_counter += 1\n    for i in range(0, n):\n        sub_count = dict()\n        sub_array = list()\n        for j in range(i, n):\n            temp = array[j]\n            if sub_count.get(temp, -1) == -1:\n                sub_count[temp] = 1\n            else:\n                sub_count[temp] += 1\n            bisect.insort(sub_array, temp)\n            x = sub_array[position[j - i]]\n            f = sub_count[x]\n            if sub_count.get(f, -1) != -1:\n                answer += 1\n    print(answer)", "from math import ceil\nfrom collections import defaultdict\nfrom bisect import bisect_left, bisect_right, insort\nfrom sys import stdin\n\ndef solve():\n    for _ in range(int(stdin.readline())):\n        (N, K) = map(int, stdin.readline().split())\n        A = [int(k) for k in stdin.readline().split()]\n        mA = min(A)\n        if mA > N:\n            print(0)\n            continue\n        ls = len(set(A))\n        if ls == 1:\n            print(max(0, N - A[0] + 1))\n            continue\n        if ls == N:\n            if mA == 1:\n                idx = A.index(1)\n                ans = 0\n                for i in range(idx + 1):\n                    ans += N - idx\n                print(ans)\n            else:\n                print(0)\n            continue\n        freq = defaultdict(list)\n        for i in range(N):\n            freq[A[i]].append(i)\n        ans = len(freq[1])\n        for i in range(N - 1):\n            S = [A[i]]\n            freq2 = defaultdict(int)\n            freq2[S[0]] += 1\n            for j in range(i + 1, N):\n                aj = A[j]\n                freq2[aj] += 1\n                insort(S, aj)\n                m = ceil(K / (j - i + 1))\n                k = ceil(K / m) - 1\n                x = S[k]\n                prev = k\n                f = freq2[x]\n                cont = 1 if f in freq2 else 0\n                if cont:\n                    ans += 1\n        print(ans)\nsolve()", "import bisect\nimport sys\nfrom sys import stdin, stdout\ntest = int(sys.stdin.readline())\nwhile test > 0:\n    test = test - 1\n    nk = [int(x) for x in sys.stdin.readline().split()]\n    n = nk[0]\n    k = nk[1]\n    arr = [int(x) for x in sys.stdin.readline().split()]\n    arr.insert(0, 0)\n    c = 0\n    pre = [0 for k in range(2001)]\n    for i in range(1, 2001):\n        m = int(k / i) + 1\n        if k % i == 0:\n            m = m - 1\n        x = int(k / m) + 1\n        if k % m == 0:\n            x = x - 1\n        pre[i] = x\n    for i in range(1, n + 1):\n        brr = [0 for k in range(2001)]\n        lis = []\n        for j in range(i, n + 1):\n            brr[arr[j]] = brr[arr[j]] + 1\n            bisect.insort(lis, arr[j])\n            size = j - i + 1\n            xt = pre[size]\n            y = lis[xt - 1]\n            f = brr[y]\n            if brr[f] > 0:\n                c = c + 1\n    print(c)", "def ceil(x, y):\n    if x % y:\n        return x // y + 1\n    else:\n        return x // y\nMAX = 2001\nt = int(input())\nfor t_i in range(t):\n    (N, K) = map(int, input().split())\n    Arr = list(map(int, input().split()))\n    res = 0\n    count_list = [None] * MAX\n    for i in range(N):\n        for value in range(MAX):\n            count_list[value] = 0\n        max_item = Arr[i]\n        current_item = Arr[i]\n        current_item_dis = 0\n        for j in range(i, N):\n            size = j - i + 1\n            new_pos = ceil(K, ceil(K, size))\n            new_item = Arr[j]\n            count_list[new_item] += 1\n            if new_item > max_item:\n                max_item = new_item\n            if size == new_pos:\n                current_item = max_item\n                current_item_dis = count_list[max_item] - 1\n            elif new_item < current_item:\n                if current_item_dis:\n                    current_item_dis -= 1\n                else:\n                    current_item -= 1\n                    while not count_list[current_item]:\n                        current_item -= 1\n                    current_item_dis = count_list[current_item] - 1\n            if count_list[count_list[current_item]]:\n                res += 1\n    print(res)", "from math import ceil\nfrom bisect import insort\nt = int(input())\nfor i in range(t):\n    c = 0\n    (n, k) = map(int, input().split())\n    L = list(map(int, input().split()))\n    for u in range(n):\n        l = []\n        cont = [0] * 2001\n        for j in range(u, n):\n            insort(l, L[j])\n            cont[L[j]] += 1\n            m = ceil(k / len(l))\n            x = ceil(k / m)\n            f = cont[l[x - 1]]\n            if cont[f] != 0:\n                c = c + 1\n    print(c)", "import math\nimport bisect\ntc = int(input())\nfor x in range(0, tc):\n    (n, k) = input().split()\n    n = int(n)\n    k = int(k)\n    array = [int(i) for i in input().split()]\n    ans = 0\n    indexdic = {1: 0}\n    for i in range(2, n + 1):\n        m = math.ceil(k / i)\n        indexdic[i] = math.floor((k - 1) / m)\n    for i in range(0, n):\n        sortedlist = [array[i]]\n        freq = {array[i]: 1}\n        num = sortedlist[0]\n        c = freq[num]\n        if c in freq:\n            ans += 1\n        for j in range(i + 1, n):\n            bisect.insort(sortedlist, array[j])\n            if array[j] in freq:\n                freq[array[j]] += 1\n            else:\n                freq[array[j]] = 1\n            index = indexdic[len(sortedlist)]\n            num = sortedlist[index]\n            c = freq[num]\n            if c in freq:\n                ans += 1\n    print(ans)", "from collections import defaultdict\nfrom math import ceil\nimport heapq\nfor _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    arr = [int(x) for x in input().split()]\n    temp = []\n    beautiful = 0\n    freq = [0] * 2001\n    for i in range(n):\n        freq = [0] * 2001\n        alpha_old = 1\n        temp = []\n        reserve = []\n        freq[arr[i]] = 1\n        heapq.heappush(temp, -arr[i])\n        if arr[i] == 1:\n            beautiful = beautiful + 1\n        flag = False\n        for j in range(i + 1, n):\n            freq[arr[j]] = freq[arr[j]] + 1\n            if flag:\n                if arr[j] < -temp[0]:\n                    heapq.heapreplace(temp, -arr[j])\n                if freq[freq[-temp[0]]] != 0:\n                    beautiful = beautiful + 1\n                continue\n            s = j - i + 1\n            alpha_new = ceil(k / ceil(k / s))\n            if alpha_new != alpha_old:\n                for x in reserve:\n                    heapq.heappush(temp, -x)\n                heapq.heappush(temp, -arr[j])\n                reserve = []\n                alpha_old = alpha_new\n                if alpha_new == k:\n                    flag = True\n                if freq[freq[-temp[0]]] != 0:\n                    beautiful = beautiful + 1\n            elif arr[j] < -temp[0]:\n                reserve.append(-heapq.heapreplace(temp, -arr[j]))\n                if freq[freq[-temp[0]]] != 0:\n                    beautiful = beautiful + 1\n            else:\n                reserve.append(arr[j])\n                if freq[freq[-temp[0]]] != 0:\n                    beautiful = beautiful + 1\n    print(beautiful)", "import bisect\nimport math\nfrom sys import stdin\nt = int(stdin.readline())\nfor x in range(t):\n    (n, k) = list(map(int, stdin.readline().split()))\n    a = list(map(int, stdin.readline().rstrip().split()))\n    maxi = max(a)\n    count = 0\n    g = []\n    cc = 0\n    counting = 0\n    for i in range(n):\n        for j in range(n):\n            p = math.ceil(k / (j - i + 1))\n            index = math.ceil(k / p)\n            g.append(index)\n            cc = 1\n        if cc == 1:\n            break\n    for i in range(n):\n        s = []\n        d = [0] * (maxi + 2)\n        counting = 0\n        for j in range(i, n):\n            bisect.insort(s, a[j])\n            d[a[j]] += 1\n            l = i + 1\n            r = j + 1\n            index = g[counting]\n            myele = s[index - 1]\n            f = d[myele]\n            if d[f] > 0:\n                count += 1\n            counting += 1\n    print(count)", "import bisect\nimport math\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    x = []\n    ans = 0\n    b = []\n    for i in range(n):\n        x = [0] * 2001\n        b = []\n        for j in range(i, n):\n            bisect.insort(b, a[j])\n            m = (k + (j - i + 1) - 1) // (j - i + 1)\n            kth = b[(k - 1) // m]\n            x[a[j]] += 1\n            if x[x[kth]] > 0:\n                ans += 1\n    print(ans)", "import bisect\nfrom math import ceil\nfor _ in range(int(input())):\n    res = 0\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    for i in range(n):\n        c = [0] * 2001\n        arr = []\n        for j in range(i, n):\n            bisect.insort(arr, a[j])\n            c[a[j]] += 1\n            x = j - i + 1\n            s = ceil(k / x)\n            s = (k - 1) // s\n            ans = arr[s]\n            if c[c[ans]] != 0:\n                res += 1\n    print(res)", "import math\nimport bisect\nt = int(input())\nfor i in range(t):\n    li = input().split()\n    n = int(li[0])\n    k = int(li[1])\n    lj = input().split()\n    l = []\n    poi = 1\n    pos = []\n    for j in lj:\n        l.append(int(j))\n        pos.append(int(math.ceil(k / math.ceil(k / poi)) - 1))\n        poi += 1\n    ans = 0\n    for j in range(n):\n        sub = list()\n        count = dict()\n        for m in range(j, n):\n            temp = l[m]\n            bisect.insort(sub, temp)\n            if count.get(temp, -1) == -1:\n                count[temp] = 1\n            else:\n                count[temp] += 1\n            x = sub[pos[m - j]]\n            f = count[x]\n            if count.get(f, -1) != -1:\n                ans += 1\n    print(ans)", "import bisect\nimport math\nfor _ in range(int(input().strip())):\n    (n, k) = map(int, input().strip().split())\n    arr = list(map(int, input().strip().split()))\n    inds = []\n    for i in range(1, 2001):\n        inds.append(math.ceil(k / math.ceil(k / i)) - 1)\n    cnt = 0\n    for i in range(n):\n        subArray = []\n        frequencies = [0] * 2001\n        for j in range(i, n):\n            bisect.insort(subArray, arr[j])\n            frequencies[arr[j]] += 1\n            if subArray[0] <= len(subArray):\n                x = subArray[inds[len(subArray) - 1]]\n                f = frequencies[x]\n                if frequencies[f] != 0:\n                    cnt += 1\n    print(cnt)", "from bisect import insort, bisect_left\nfrom math import ceil\nfor _ in range(int(input().strip())):\n    (n, k) = map(int, input().strip().split())\n    arr = list(map(int, input().strip().split()))\n    indices = [ceil(k / ceil(k / l)) - 1 for l in range(1, 2001)]\n    c = 0\n    for i in range(n):\n        sub = []\n        freq = [0] * 2001\n        for j in range(i, n):\n            insort(sub, arr[j])\n            l = len(sub)\n            freq[arr[j]] += 1\n            if sub[0] > l:\n                continue\n            x = sub[indices[l - 1]]\n            if freq[freq[x]] != 0:\n                c += 1\n    print(c)", "def division(a, b):\n    if a % b == 0:\n        return a // b\n    return a // b + 1\ntest = int(input())\nfor _ in range(test):\n    (n, k) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    res = 0\n    p = []\n    for i in range(n):\n        p.append(division(k, division(k, i + 1)) - 1)\n    for i in range(n):\n        if a[i] == 1:\n            res += 1\n        inarr = [0] * 2001\n        inarr[a[i]] = 1\n        arr = []\n        o = a[i]\n        nop = 1\n        for j in range(i + 1, n):\n            inarr[a[j]] += 1\n            c = p[j - i] - p[j - i - 1]\n            if a[j] < o:\n                c -= 1\n            if c == -1:\n                nop -= 1\n                if nop == 0:\n                    q = o - 1\n                    while inarr[q] == 0:\n                        q -= 1\n                    o = q\n                    nop = inarr[o]\n            else:\n                while c:\n                    c -= 1\n                    nop += 1\n                    if nop > inarr[o]:\n                        q = o + 1\n                        while inarr[q] == 0:\n                            q += 1\n                        o = q\n                        nop = 1\n            if inarr[inarr[o]] != 0:\n                res += 1\n    print(res)", "from math import ceil\nfrom bisect import insort\nt = int(input())\nfor test in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = 0\n    for i in range(n):\n        b = list()\n        d = dict()\n        for j in range(i, n, 1):\n            if a[j] in d:\n                d[a[j]] += 1\n            else:\n                d[a[j]] = 1\n            insort(b, a[j])\n            x = b[ceil(k / ceil(k / (j - i + 1))) - 1]\n            f = d[x]\n            if f in d:\n                ans += 1\n    print(ans)", "from math import ceil\n\ndef calculate(s, nth, dp):\n    for i in range(2001):\n        nth -= dp[s][i]\n        if nth <= 0:\n            return (i, nth * -1)\nfor t in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    ans = 0\n    dp = [[0 for i in range(2001)]]\n    for ele in arr:\n        dp.append(list(dp[-1]))\n        dp[-1][ele] += 1\n    index = -1\n    extra = 0\n    for s in range(1, n + 1):\n        nth = ceil(k / ceil(k / s))\n        (index, extra) = calculate(s, nth, dp)\n        myli = list(dp[s])\n        for p in range(n - s + 1):\n            q = p + s - 1\n            if p > 0:\n                myli[arr[p - 1]] -= 1\n                myli[arr[q]] += 1\n                if arr[p - 1] <= index:\n                    extra -= 1\n                if arr[q] <= index:\n                    extra += 1\n                if extra == -1:\n                    index += 1\n                    while myli[index] == 0:\n                        index += 1\n                    extra = myli[index] - 1\n                elif extra == myli[index]:\n                    index -= 1\n                    while myli[index] == 0:\n                        index -= 1\n                    extra = 0\n            if myli[myli[index]] > 0:\n                ans += 1\n    print(ans)", "import math\nfrom bisect import insort\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = 0\n    for i in range(n):\n        counter = [0] * 2001\n        current = []\n        length = 0\n        for j in range(i, n):\n            insort(current, a[j])\n            length += 1\n            counter[a[j]] += 1\n            repeat = (k + length - 1) // length\n            index = k // repeat\n            if k % repeat == 0:\n                index -= 1\n            if counter[counter[current[index]]]:\n                ans += 1\n    print(ans)", "def div(a, b):\n    if a % b == 0:\n        return a // b\n    return a // b + 1\nt = int(input())\nfor _ in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    ans = 0\n    m = []\n    for i in range(n):\n        m.append(div(k, div(k, i + 1)) - 1)\n    for i in range(n):\n        if a[i] == 1:\n            ans += 1\n        inarr = [0] * 2001\n        inarr[a[i]] = 1\n        arr = []\n        p = a[i]\n        no = 1\n        for j in range(i + 1, n):\n            inarr[a[j]] += 1\n            c = m[j - i] - m[j - i - 1]\n            if a[j] < p:\n                c -= 1\n            if c == -1:\n                no -= 1\n                if no == 0:\n                    l = p - 1\n                    while inarr[l] == 0:\n                        l -= 1\n                    p = l\n                    no = inarr[p]\n            else:\n                while c:\n                    c -= 1\n                    no += 1\n                    if no > inarr[p]:\n                        l = p + 1\n                        while inarr[l] == 0:\n                            l += 1\n                        p = l\n                        no = 1\n            if inarr[inarr[p]] != 0:\n                ans += 1\n    print(ans)", "import sys\nimport bisect\nt = int(sys.stdin.readline())\nfor it in range(t):\n    (n, k) = [int(tmp) for tmp in sys.stdin.readline().split()]\n    a = [int(tmp) for tmp in sys.stdin.readline().split()]\n    bs = 0\n    lmkm1ls = [-1] * (n + 1)\n    ldkm1ls = [-1] * (n + 1)\n    lrevxpc = [-1] * (n + 1)\n    for l in range(n):\n        s = []\n        ls = 0\n        lfs = [0] * 2001\n        for er in a[l:n]:\n            ls += 1\n            bisect.insort(s, er)\n            lfs[er] += 1\n            if k <= ls:\n                x = s[k - 1]\n            else:\n                if lmkm1ls[ls] == -1:\n                    lmkm1ls[ls] = (k - 1) % ls\n                    ldkm1ls[ls] = (k - 1) // ls\n                    lrevxpc[ls] = (ls - 1 - lmkm1ls[ls]) // (ldkm1ls[ls] + 1) + 1\n                x = s[-lrevxpc[ls]]\n            f = lfs[x]\n            bs += lfs[f] != 0\n    print(bs)", "import bisect\nt = int(input())\nfor it in range(t):\n    (n, k) = [int(tmp) for tmp in input().split()]\n    a = [int(tmp) for tmp in input().split()]\n    bs = 0\n    lmkm1ls = [-1] * (n + 1)\n    ldkm1ls = [-1] * (n + 1)\n    lrevxpc = [-1] * (n + 1)\n    for l in range(n):\n        s = []\n        ls = 0\n        lfs = [0] * 2001\n        for er in a[l:n]:\n            ls += 1\n            bisect.insort(s, er)\n            lfs[er] += 1\n            if k <= ls:\n                x = s[k - 1]\n            else:\n                if lmkm1ls[ls] == -1:\n                    lmkm1ls[ls] = (k - 1) % ls\n                    ldkm1ls[ls] = (k - 1) // ls\n                    lrevxpc[ls] = (ls - 1 - lmkm1ls[ls]) // (ldkm1ls[ls] + 1) + 1\n                x = s[-lrevxpc[ls]]\n            f = lfs[x]\n            bs += lfs[f] != 0\n    print(bs)"]