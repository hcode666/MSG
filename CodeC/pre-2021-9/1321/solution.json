["import math\nfrom collections import deque\n\ndef bfs(graph, vertex1):\n    queue = deque([vertex1])\n    visited = {vertex1: True}\n    while queue:\n        v = queue.popleft()\n        for n in graph[v]:\n            if n not in visited:\n                queue.append(n)\n                visited[n] = True\n    return visited\n\nclass findcycles:\n\n    def __init__(self):\n        self.allcycles = []\n        self.stack = []\n        self.blockset = []\n        self.blockmap = {}\n\n    def unblock(self, v):\n        if v in self.blockset:\n            self.blockset.remove(v)\n        while v in self.blockmap:\n            temp = self.blockmap[v]\n            del self.blockmap[v]\n            if temp in self.blockset:\n                self.blockset.remove(temp)\n            v = temp\n\n    def johnson(self, adj, v, start):\n        foundcycle = False\n        self.stack.append(v)\n        self.blockset.append(v)\n        for i in adj[v]:\n            if i == start:\n                self.stack.append(start)\n                cycle = self.stack.copy()\n                self.stack.pop()\n                self.allcycles.append(cycle)\n                foundcycle = True\n            elif i not in self.blockset:\n                gotcycle = self.johnson(adj, i, start)\n                foundcycle = foundcycle or gotcycle\n        if foundcycle:\n            self.unblock(v)\n        else:\n            for i in adj[v]:\n                self.blockmap[i] = v\n        self.stack.pop()\n        return foundcycle\n\n    def ret(self):\n        if len(self.allcycles) > 0:\n            self.allcycles.sort(key=lambda x: len(x))\n            return self.allcycles[0]\n        else:\n            return []\nt = int(input())\nfor rep in range(t):\n    (n, m) = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    for i in range(n):\n        p[i] -= 1\n    adj = [[] for _ in range(n)]\n    for rep2 in range(m):\n        (x, y) = list(map(int, input().split()))\n        if y - 1 not in adj[x - 1]:\n            adj[x - 1].append(y - 1)\n        if x - 1 not in adj[y - 1]:\n            adj[y - 1].append(x - 1)\n    c = 0\n    l = []\n    vis = {}\n    c = 0\n    for i in range(n):\n        if i not in vis:\n            temp = bfs(adj, i)\n            l.append(temp)\n            for j in temp:\n                vis[j] = c\n            c += 1\n    adj2 = [[] for _ in range(c)]\n    for i in range(n):\n        if i != p[i]:\n            if vis[i] != vis[p[i]]:\n                adj2[vis[i]].append(vis[p[i]])\n    cyc = []\n    count = 0\n    for i in range(len(adj2)):\n        while len(adj2[i]) > 0:\n            ob = findcycles()\n            ob.johnson(adj2, i, i)\n            cyc = ob.ret()\n            for j in range(len(cyc) - 1):\n                adj2[cyc[j]].remove(cyc[j + 1])\n            count += len(cyc) - 2\n    print(count)", "import math\nfrom collections import deque\n\ndef bfs(graph, vertex1):\n    queue = deque([vertex1])\n    visited = {vertex1: True}\n    while queue:\n        v = queue.popleft()\n        for n in graph[v]:\n            if n not in visited:\n                queue.append(n)\n                visited[n] = True\n    return visited\n\nclass findcycles:\n\n    def __init__(self):\n        self.allcycles = []\n        self.stack = []\n        self.blockset = []\n        self.blockmap = {}\n\n    def unblock(self, v):\n        if v in self.blockset:\n            self.blockset.remove(v)\n        while v in self.blockmap:\n            temp = self.blockmap[v]\n            del self.blockmap[v]\n            if temp in self.blockset:\n                self.blockset.remove(temp)\n            v = temp\n\n    def johnson(self, adj, v, start):\n        foundcycle = False\n        self.stack.append(v)\n        self.blockset.append(v)\n        for i in adj[v]:\n            if i == start:\n                self.stack.append(start)\n                cycle = self.stack.copy()\n                self.stack.pop()\n                self.allcycles.append(cycle)\n                foundcycle = True\n            elif i not in self.blockset:\n                gotcycle = self.johnson(adj, i, start)\n                foundcycle = foundcycle or gotcycle\n        if foundcycle:\n            self.unblock(v)\n        else:\n            for i in adj[v]:\n                self.blockmap[i] = v\n        self.stack.pop()\n        return foundcycle\n\n    def ret(self):\n        if len(self.allcycles) > 0:\n            self.allcycles.sort(key=lambda x: len(x))\n            return self.allcycles[0]\n        else:\n            return []\nt = int(input())\nfor rep in range(t):\n    (n, m) = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    for i in range(n):\n        p[i] -= 1\n    adj = [[] for _ in range(n)]\n    for rep2 in range(m):\n        (x, y) = list(map(int, input().split()))\n        if y - 1 not in adj[x - 1]:\n            adj[x - 1].append(y - 1)\n        if x - 1 not in adj[y - 1]:\n            adj[y - 1].append(x - 1)\n    c = 0\n    l = []\n    vis = {}\n    c = 0\n    for i in range(n):\n        if i not in vis:\n            temp = bfs(adj, i)\n            l.append(temp)\n            for j in temp:\n                vis[j] = c\n            c += 1\n    adj2 = [[] for _ in range(c)]\n    for i in range(n):\n        if i != p[i]:\n            if vis[i] != vis[p[i]]:\n                adj2[vis[i]].append(vis[p[i]])\n    cyc = []\n    count = 0\n    for i in range(len(adj2)):\n        while len(adj2[i]) > 0:\n            ob = findcycles()\n            ob.johnson(adj2, i, i)\n            cyc = ob.ret()\n            for j in range(len(cyc) - 1):\n                adj2[cyc[j]].remove(cyc[j + 1])\n            count += len(cyc) - 2\n    print(count)", "for _ in range(int(input())):\n    (N, M) = list(map(int, input().split()))\n    P = [0]\n    P.extend(list(map(int, input().split())))\n    xy = []\n    for _ in range(M):\n        xy.append(list(map(int, input().split())))\n    Tree = [[] for _ in range(N + 1)]\n    for (i, j) in xy:\n        Tree[i].append(j)\n        Tree[j].append(i)\n    DjSets = []\n    Used = [True]\n    Used.extend([False for _ in range(N)])\n    for i in range(len(Tree)):\n        if Used[i]:\n            continue\n        pack = [i]\n        for j in pack:\n            for l in Tree[j]:\n                if l not in pack and (not Used[l]):\n                    pack.append(l)\n                    Used[l] = True\n        DjSets.append(pack)\n    for i in range(len(DjSets)):\n        DjSets[i].sort()\n    (table, Lno) = ([[0 for _ in range(len(DjSets))] for _ in range(len(DjSets))], [-1 for _ in range(N + 1)])\n    for i in range(1, N + 1):\n        for j in range(len(DjSets)):\n            if P[i] in DjSets[j]:\n                Lno[i] = j\n                break\n    for i in range(len(DjSets)):\n        for k in DjSets[i]:\n            if Lno[k] != i:\n                table[i][Lno[k]] += 1\n    (res, tot) = (0, sum([sum(i) for i in table]))\n    while tot > 0:\n        (J, K) = (-1, -1)\n        for i in range(len(table)):\n            for j in range(len(table)):\n                if table[i][j]:\n                    (J, K) = (i, j)\n                    break\n            if J != -1:\n                break\n        if J == -1:\n            break\n        (I, All, wor) = (J, [[J, K]], [])\n        for i in All:\n            f = False\n            for j in range(len(table)):\n                if table[i[-1]][j]:\n                    if j == I:\n                        i.append(j)\n                        (wor, f) = (i, True)\n                    if j in i:\n                        continue\n                    news = [n for n in i]\n                    news.append(j)\n                    All.append(news)\n            if f:\n                break\n        for i in range(len(wor) - 1):\n            table[wor[i]][wor[i + 1]] -= 1\n        res += len(wor) - 2\n        tot -= len(wor) - 1\n    print(res)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = [0] + list(map(int, input().split()))\n    (cor, tree, res) = ([sorted(list(map(int, input().split()))) for i in range(m)], [[] for i in p], 0)\n    for (i, j) in cor:\n        tree[i].append(j)\n        tree[j].append(i)\n    lis = sorted([p[i] for i in range(1, n + 1)])\n    (vis, pic) = ([0 for i in range(n)], [])\n    for j in range(len(lis)):\n        if vis[j]:\n            continue\n        pack = [lis[j]]\n        for k in pack:\n            for l in tree[k]:\n                if l in lis and l not in pack:\n                    pack.append(l)\n                    vis[lis.index(l)] = 1\n        pic.append(pack)\n    (PIC, lno) = (len(pic), [-1 for i in p])\n    for j in range(PIC):\n        for k in pic[j]:\n            lno[k] = j\n    (exc, tot) = ([[0 for i in range(PIC)] for i in range(PIC)], 0)\n    for j in range(PIC):\n        for k in pic[j]:\n            exc[j][lno[p[k]]] += 1\n    for j in range(PIC):\n        exc[j][j] = 0\n    for j in range(PIC):\n        for k in range(j + 1, PIC):\n            tot += exc[j][k] + exc[k][j]\n    while tot > 0:\n        (J, K) = (-1, -1)\n        for j in range(PIC):\n            for k in range(PIC):\n                if exc[j][k]:\n                    (J, K) = (j, k)\n                    break\n            if J != -1:\n                break\n        (I, All, wor) = (J, [[J, K]], [])\n        for j in All:\n            flag = 0\n            for k in range(PIC):\n                if exc[j[-1]][k]:\n                    if k == I:\n                        j.append(I)\n                        (wor, flag) = (j, 1)\n                        break\n                    if k in j:\n                        continue\n                    news = [i for i in j]\n                    news.append(k)\n                    All.append(news)\n            if flag:\n                break\n        for i in range(len(wor) - 1):\n            exc[wor[i]][wor[i + 1]] -= 1\n        res += len(wor) - 2\n        tot -= len(wor) - 1\n    print(res)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = [0] + list(map(int, input().split()))\n    (cor, tree, res) = ([sorted(list(map(int, input().split()))) for i in range(m)], [[] for i in p], 0)\n    for (i, j) in cor:\n        tree[i].append(j)\n        tree[j].append(i)\n    lis = sorted([p[i] for i in range(1, n + 1)])\n    (vis, pic) = ([0 for i in range(n)], [])\n    for j in range(len(lis)):\n        if vis[j]:\n            continue\n        pack = [lis[j]]\n        for k in pack:\n            for l in tree[k]:\n                if l in lis and l not in pack:\n                    pack.append(l)\n                    vis[lis.index(l)] = 1\n        pic.append(pack)\n    (PIC, lno) = (len(pic), [-1 for i in p])\n    for j in range(PIC):\n        for k in pic[j]:\n            lno[k] = j\n    (exc, tot) = ([[0 for i in range(PIC)] for i in range(PIC)], 0)\n    for j in range(PIC):\n        for k in pic[j]:\n            exc[j][lno[p[k]]] += 1\n    for j in range(PIC):\n        exc[j][j] = 0\n    for j in range(PIC):\n        for k in range(j + 1, PIC):\n            tot += exc[j][k] + exc[k][j]\n    while tot > 0:\n        (J, K) = (-1, -1)\n        for j in range(PIC):\n            for k in range(PIC):\n                if exc[j][k]:\n                    (J, K) = (j, k)\n                    break\n            if J != -1:\n                break\n        (I, All, wor) = (J, [[J, K]], [])\n        for j in All:\n            flag = 0\n            for k in range(PIC):\n                if exc[j[-1]][k]:\n                    if k == I:\n                        j.append(I)\n                        (wor, flag) = (j, 1)\n                        break\n                    if k in j:\n                        continue\n                    news = [i for i in j]\n                    news.append(k)\n                    All.append(news)\n            if flag:\n                break\n        for i in range(len(wor) - 1):\n            exc[wor[i]][wor[i + 1]] -= 1\n        res += len(wor) - 2\n        tot -= len(wor) - 1\n    print(res)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = [0] + list(map(int, input().split()))\n    (cor, tree, res) = ([sorted(list(map(int, input().split()))) for i in range(m)], [[] for i in p], 0)\n    for (i, j) in cor:\n        tree[i].append(j)\n        tree[j].append(i)\n    lis = sorted([p[i] for i in range(1, n + 1)])\n    (vis, pic) = ([0 for i in range(n)], [])\n    for j in range(len(lis)):\n        if vis[j]:\n            continue\n        pack = [lis[j]]\n        for k in pack:\n            for l in tree[k]:\n                if l in lis and l not in pack:\n                    pack.append(l)\n                    vis[lis.index(l)] = 1\n        pic.append(pack)\n    (PIC, lno) = (len(pic), [-1 for i in p])\n    for j in range(PIC):\n        for k in pic[j]:\n            lno[k] = j\n    (exc, tot) = ([[0 for i in range(PIC)] for i in range(PIC)], 0)\n    for j in range(PIC):\n        for k in pic[j]:\n            exc[j][lno[p[k]]] += 1\n    for j in range(PIC):\n        exc[j][j] = 0\n    for j in range(PIC):\n        for k in range(j + 1, PIC):\n            tot += exc[j][k] + exc[k][j]\n    while tot > 0:\n        (J, K) = (-1, -1)\n        for j in range(PIC):\n            for k in range(PIC):\n                if exc[j][k]:\n                    (J, K) = (j, k)\n                    break\n            if J != -1:\n                break\n        (I, All, wor) = (J, [[J, K]], [])\n        for j in All:\n            flag = 0\n            for k in range(PIC):\n                if exc[j[-1]][k]:\n                    if k == I:\n                        j.append(I)\n                        (wor, flag) = (j, 1)\n                        break\n                    if k in j:\n                        continue\n                    news = [i for i in j]\n                    news.append(k)\n                    All.append(news)\n            if flag:\n                break\n        for i in range(len(wor) - 1):\n            exc[wor[i]][wor[i + 1]] -= 1\n        res += len(wor) - 2\n        tot -= len(wor) - 1\n    print(res)", "for _ in range(int(input())):\n    res = 0\n    (n, m) = map(int, input().split())\n    p = [0] + list(map(int, input().split()))\n    cor = [sorted(list(map(int, input().split()))) for i in range(m)]\n    tree = [[] for i in p]\n    for (i, j) in cor:\n        tree[i].append(j)\n        tree[j].append(i)\n    lis = sorted([p[i] for i in range(1, n + 1)])\n    (vis, pic) = ([0 for i in range(n)], [])\n    for j in range(len(lis)):\n        if vis[j]:\n            continue\n        pack = [lis[j]]\n        for k in pack:\n            for l in tree[k]:\n                if l in lis and l not in pack:\n                    pack.append(l)\n                    vis[lis.index(l)] = 1\n        pic.append(pack)\n    (PIC, lno) = (len(pic), [-1 for i in p])\n    for j in range(PIC):\n        for k in pic[j]:\n            lno[k] = j\n    (exc, tot) = ([[0 for i in range(PIC)] for i in range(PIC)], 0)\n    for j in range(PIC):\n        for k in pic[j]:\n            exc[j][lno[p[k]]] += 1\n    for j in range(PIC):\n        exc[j][j] = 0\n    for j in range(PIC):\n        for k in range(j + 1, PIC):\n            tot += exc[j][k] + exc[k][j]\n    while tot > 0:\n        (J, K) = (-1, -1)\n        for j in range(PIC):\n            for k in range(PIC):\n                if exc[j][k]:\n                    (J, K) = (j, k)\n                    break\n            if J != -1:\n                break\n        (I, All, wor) = (J, [[J, K]], [])\n        for j in All:\n            flag = 0\n            for k in range(PIC):\n                if exc[j[-1]][k]:\n                    if k == I:\n                        j.append(I)\n                        (wor, flag) = (j, 1)\n                        break\n                    if k in j:\n                        continue\n                    news = [i for i in j]\n                    news.append(k)\n                    All.append(news)\n            if flag:\n                break\n        for i in range(len(wor) - 1):\n            exc[wor[i]][wor[i + 1]] -= 1\n        res += len(wor) - 2\n        tot -= len(wor) - 1\n    print(res)", "for _ in range(int(input())):\n    res = 0\n    (n, m) = map(int, input().split())\n    p = [0] + list(map(int, input().split()))\n    cor = [sorted(list(map(int, input().split()))) for i in range(m)]\n    tree = [[] for i in p]\n    for (i, j) in cor:\n        tree[i].append(j)\n        tree[j].append(i)\n    lis = sorted([p[i] for i in range(1, n + 1)])\n    (vis, pic) = ([0 for i in range(n)], [])\n    for j in range(len(lis)):\n        if vis[j]:\n            continue\n        pack = [lis[j]]\n        for k in pack:\n            for l in tree[k]:\n                if l in lis and l not in pack:\n                    pack.append(l)\n                    vis[lis.index(l)] = 1\n        pic.append(pack)\n    (PIC, lno) = (len(pic), [-1 for i in p])\n    for j in range(PIC):\n        for k in pic[j]:\n            lno[k] = j\n    (exc, tot) = ([[0 for i in range(PIC)] for i in range(PIC)], 0)\n    for j in range(PIC):\n        for k in pic[j]:\n            exc[j][lno[p[k]]] += 1\n    for j in range(PIC):\n        exc[j][j] = 0\n    for j in range(PIC):\n        for k in range(j + 1, PIC):\n            tot += exc[j][k] + exc[k][j]\n    while tot > 0:\n        (J, K) = (-1, -1)\n        for j in range(PIC):\n            for k in range(PIC):\n                if exc[j][k]:\n                    (J, K) = (j, k)\n                    break\n            if J != -1:\n                break\n        I = J\n        All = [[J, K]]\n        wor = []\n        for j in All:\n            flag = 0\n            for k in range(PIC):\n                if exc[j[-1]][k]:\n                    if k == I:\n                        j.append(I)\n                        (wor, flag) = (j, 1)\n                        break\n                    if k in j:\n                        continue\n                    news = [i for i in j]\n                    news.append(k)\n                    All.append(news)\n            if flag:\n                break\n        for i in range(len(wor) - 1):\n            exc[wor[i]][wor[i + 1]] -= 1\n        res += len(wor) - 2\n        tot -= len(wor) - 1\n    print(res)", "for _ in range(int(input())):\n    res = 0\n    (n, m) = map(int, input().split())\n    p = [0] + list(map(int, input().split()))\n    cor = [sorted(list(map(int, input().split()))) for i in range(m)]\n    tree = [[] for i in p]\n    for (i, j) in cor:\n        tree[i].append(j)\n        tree[j].append(i)\n    lis = sorted([p[i] for i in range(1, n + 1)])\n    vis = [0 for i in range(n)]\n    pic = []\n    for j in range(len(lis)):\n        if vis[j]:\n            continue\n        pack = [lis[j]]\n        for k in pack:\n            for l in tree[k]:\n                if l in lis and l not in pack:\n                    pack.append(l)\n                    vis[lis.index(l)] = 1\n        pic.append(pack)\n    PIC = len(pic)\n    lno = [-1 for i in p]\n    for j in range(PIC):\n        for k in pic[j]:\n            lno[k] = j\n    exc = [[0 for i in range(PIC)] for i in range(PIC)]\n    for j in range(PIC):\n        for k in pic[j]:\n            exc[j][lno[p[k]]] += 1\n    for j in range(PIC):\n        exc[j][j] = 0\n    tot = 0\n    for j in range(PIC):\n        for k in range(j + 1, PIC):\n            tot += exc[j][k] + exc[k][j]\n    while tot > 0:\n        (J, K) = (-1, -1)\n        for j in range(PIC):\n            for k in range(PIC):\n                if exc[j][k]:\n                    (J, K) = (j, k)\n                    break\n            if J != -1:\n                break\n        I = J\n        All = [[J, K]]\n        wor = []\n        for j in All:\n            flag = 0\n            for k in range(PIC):\n                if exc[j[-1]][k]:\n                    if k == I:\n                        j.append(I)\n                        wor = j\n                        flag = 1\n                        break\n                    if k in j:\n                        continue\n                    news = [i for i in j]\n                    news.append(k)\n                    All.append(news)\n            if flag:\n                break\n        for i in range(len(wor) - 1):\n            exc[wor[i]][wor[i + 1]] -= 1\n        res += len(wor) - 2\n        tot -= len(wor) - 1\n    print(res)", "import math\nfrom collections import deque\n\ndef bfs(graph, vertex1):\n    queue = deque([vertex1])\n    visited = {vertex1: True}\n    while queue:\n        v = queue.popleft()\n        for n in graph[v]:\n            if n not in visited:\n                queue.append(n)\n                visited[n] = True\n    return visited\n\nclass findcycles:\n\n    def __init__(self):\n        self.allcycles = []\n        self.stack = []\n        self.blockset = []\n        self.blockmap = {}\n\n    def unblock(self, v):\n        if v in self.blockset:\n            self.blockset.remove(v)\n        while v in self.blockmap:\n            temp = self.blockmap[v]\n            del self.blockmap[v]\n            if temp in self.blockset:\n                self.blockset.remove(temp)\n            v = temp\n\n    def johnson(self, adj, v, start):\n        foundcycle = False\n        self.stack.append(v)\n        self.blockset.append(v)\n        for i in adj[v]:\n            if i == start:\n                self.stack.append(start)\n                cycle = self.stack.copy()\n                self.stack.pop()\n                self.allcycles.append(cycle)\n                foundcycle = True\n            elif i not in self.blockset:\n                gotcycle = self.johnson(adj, i, start)\n                foundcycle = foundcycle or gotcycle\n        if foundcycle:\n            self.unblock(v)\n        else:\n            for i in adj[v]:\n                self.blockmap[i] = v\n        self.stack.pop()\n        return foundcycle\n\n    def ret(self):\n        if len(self.allcycles) > 0:\n            self.allcycles.sort(key=lambda x: len(x))\n            return self.allcycles[0]\n        else:\n            return []\nt = int(input())\nfor rep in range(t):\n    (n, m) = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    for i in range(n):\n        p[i] -= 1\n    adj = [[] for _ in range(n)]\n    for rep2 in range(m):\n        (x, y) = list(map(int, input().split()))\n        if y - 1 not in adj[x - 1]:\n            adj[x - 1].append(y - 1)\n        if x - 1 not in adj[y - 1]:\n            adj[y - 1].append(x - 1)\n    c = 0\n    l = []\n    vis = {}\n    c = 0\n    for i in range(n):\n        if i not in vis:\n            temp = bfs(adj, i)\n            l.append(temp)\n            for j in temp:\n                vis[j] = c\n            c += 1\n    adj2 = [[] for _ in range(c)]\n    for i in range(n):\n        if i != p[i]:\n            if vis[i] != vis[p[i]]:\n                adj2[vis[i]].append(vis[p[i]])\n    cyc = []\n    count = 0\n    for i in range(len(adj2)):\n        while len(adj2[i]) > 0:\n            ob = findcycles()\n            ob.johnson(adj2, i, i)\n            cyc = ob.ret()\n            for j in range(len(cyc) - 1):\n                adj2[cyc[j]].remove(cyc[j + 1])\n            count += len(cyc) - 2\n    print(count)", "from collections import defaultdict\n\ndef minSwaps(arr):\n    n = len(arr)\n    arrpos = [*enumerate(arr)]\n    arrpos.sort(key=lambda it: it[1])\n    vis = {k: False for k in range(n)}\n    ans = 0\n    for i in range(n):\n        if vis[i] or arrpos[i][0] == i:\n            continue\n        cycle_size = 0\n        j = i\n        while not vis[j]:\n            vis[j] = True\n            j = arrpos[j][0]\n            cycle_size += 1\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def DFSUtil(self, v, visited, shanik):\n        visited[v] = True\n        shanik.append(v)\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited, shanik)\n\n    def DFS(self, v, shanik):\n        visited = [False] * (max(self.graph) + 1)\n        self.DFSUtil(v, visited, shanik)\njaval = 1\nif javal == 1:\n    T = int(input())\n    for _ in range(T):\n        (n, m) = input().split()\n        n = int(n)\n        m = int(m)\n        li = []\n        a = input().split()\n        aukat_wali_jagah = [0] * n\n        for i in range(n):\n            a[i] = int(a[i])\n            aukat_wali_jagah[a[i] - 1] = i\n        g = Graph()\n        for i in range(m):\n            shanik = input().split()\n            li.append([int(shanik[0]), int(shanik[1])])\n        li.sort()\n        for i in range(m):\n            shanik = li[i]\n            g.addEdge(int(shanik[0]) - 1, int(shanik[1]) - 1)\n            g.addEdge(int(shanik[1]) - 1, int(shanik[0]) - 1)\n        flag = 0\n        for i in range(n):\n            g.addEdge(i, i)\n        dost = []\n        for i in range(n):\n            shanik = []\n            flag = 0\n            for j in range(len(dost)):\n                if i in dost[j]:\n                    flag = 1\n                    break\n            if flag == 0:\n                g.DFS(i, shanik)\n                dost.append(shanik)\n        if len(dost) == 1:\n            print('0')\n        elif m == 0:\n            swaps = minSwaps(a)\n            print(swaps)\n        else:\n            badlaw = []\n            dontknow = []\n            for i in range(n):\n                for j in range(len(dost)):\n                    if i in dost[j]:\n                        shanik1 = j\n                    if aukat_wali_jagah[i] in dost[j]:\n                        shanik2 = j\n                if shanik1 != shanik2:\n                    badlaw.append([shanik1, shanik2])\n                dontknow.append([shanik1, shanik2])\n            parivartan = []\n            samay1 = 0\n            for i in range(len(badlaw)):\n                if badlaw[i] != []:\n                    if [badlaw[i][1], badlaw[i][0]] in badlaw:\n                        samay1 += 1\n                        t2 = badlaw.index([badlaw[i][1], badlaw[i][0]])\n                        badlaw[i] = []\n                        badlaw[t2] = []\n                    else:\n                        parivartan.append(badlaw[i])\n            if len(parivartan) > 0:\n                samay = samay1\n                ginna = 0\n                t1 = len(parivartan)\n                parivartan.sort()\n                for i in range(t1):\n                    palpal = parivartan[i][0]\n                    palpal2 = parivartan[i][1]\n                    flag = 0\n                    flag1 = 0\n                    nikal_l = []\n                    for k1 in range(t1):\n                        for j in range(t1):\n                            if parivartan[j][0] == palpal2:\n                                palpal2 = parivartan[j][1]\n                                flag += 1\n                                nikal_l.append(parivartan[j])\n                            if flag > 2:\n                                break\n                            if palpal2 == palpal:\n                                flag1 = 1\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        ginna += flag\n                        nikal_l.append(parivartan[i])\n                        for i in range(len(nikal_l)):\n                            q = parivartan.index(nikal_l[i])\n                            parivartan[q] = [-1, -2]\n                samay += ginna\n                iskimaaka = []\n                for i in range(t1):\n                    if parivartan[i] != [-1, -2]:\n                        iskimaaka.append(parivartan[i])\n                parivartan = iskimaaka\n                t1 = len(parivartan)\n                parivartan.sort()\n                ginna = 0\n                for i in range(t1):\n                    palpal = parivartan[i][0]\n                    palpal2 = parivartan[i][1]\n                    flag = 0\n                    flag1 = 0\n                    nikal_l = []\n                    for k1 in range(t1):\n                        for k2 in range(t1):\n                            for j in range(t1):\n                                if parivartan[j][0] == palpal2:\n                                    palpal2 = parivartan[j][1]\n                                    flag += 1\n                                    nikal_l.append(parivartan[j])\n                                if flag > 3:\n                                    break\n                                if palpal2 == palpal:\n                                    flag1 = 1\n                                    break\n                            if flag1 == 1:\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        ginna += flag\n                        nikal_l.append(parivartan[i])\n                        for i in range(len(nikal_l)):\n                            q = parivartan.index(nikal_l[i])\n                            parivartan[q] = [-1, -2]\n                samay += ginna\n                iskimaaka = []\n                for i in range(t1):\n                    if parivartan[i] != [-1, -2]:\n                        iskimaaka.append(parivartan[i])\n                parivartan = iskimaaka\n                t1 = len(parivartan)\n                parivartan.sort()\n                ginna = 0\n                for i in range(t1):\n                    palpal = parivartan[i][0]\n                    palpal2 = parivartan[i][1]\n                    flag = 0\n                    flag1 = 0\n                    nikal_l = []\n                    for k1 in range(t1):\n                        for k2 in range(t1):\n                            for k3 in range(t1):\n                                for j in range(t1):\n                                    if parivartan[j][0] == palpal2:\n                                        palpal2 = parivartan[j][1]\n                                        flag += 1\n                                        nikal_l.append(parivartan[j])\n                                    if flag > 4:\n                                        break\n                                    if palpal2 == palpal:\n                                        flag1 = 1\n                                        break\n                                if flag1 == 1:\n                                    break\n                            if flag1 == 1:\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        ginna += flag\n                        nikal_l.append(parivartan[i])\n                        for i in range(len(nikal_l)):\n                            q = parivartan.index(nikal_l[i])\n                            parivartan[q] = [-1, -2]\n                samay += ginna\n                iskimaaka = []\n                for i in range(t1):\n                    if parivartan[i] != [-1, -2]:\n                        iskimaaka.append(parivartan[i])\n                parivartan = iskimaaka\n                t1 = len(parivartan)\n                ginna = 0\n                for i in range(t1):\n                    palpal = parivartan[i][0]\n                    palpal2 = parivartan[i][1]\n                    flag = 0\n                    flag1 = 0\n                    if parivartan[i] != [-1, -2]:\n                        for k1 in range(t1):\n                            for k2 in range(t1):\n                                for k3 in range(t1):\n                                    for k4 in range(t1):\n                                        for k5 in range(t1):\n                                            for k6 in range(t1):\n                                                for k7 in range(t1):\n                                                    for k8 in range(t1):\n                                                        for k9 in range(t1):\n                                                            for k10 in range(t1):\n                                                                for k11 in range(t1):\n                                                                    for k12 in range(t1):\n                                                                        for k13 in range(t1):\n                                                                            for k14 in range(t1):\n                                                                                for j in range(t1):\n                                                                                    if parivartan[j][0] == palpal2:\n                                                                                        palpal2 = parivartan[j][1]\n                                                                                        flag += 1\n                                                                                        parivartan[j] = [-1, -2]\n                                                                                    if palpal2 == palpal:\n                                                                                        flag1 = 1\n                                                                                        break\n                                                                                if flag1 == 1:\n                                                                                    break\n                                                                            if flag1 == 1:\n                                                                                break\n                                                                        if flag1 == 1:\n                                                                            break\n                                                                    if flag1 == 1:\n                                                                        break\n                                                                if flag1 == 1:\n                                                                    break\n                                                            if flag1 == 1:\n                                                                break\n                                                        if flag1 == 1:\n                                                            break\n                                                    if flag1 == 1:\n                                                        break\n                                                if flag1 == 1:\n                                                    break\n                                            if flag1 == 1:\n                                                break\n                                        if flag1 == 1:\n                                            break\n                                    if flag1 == 1:\n                                        break\n                                if flag1 == 1:\n                                    break\n                            if flag1 == 1:\n                                break\n                    if flag1 == 1:\n                        ginna += flag\n                    parivartan[i] = [-1, -2]\n                samay = samay + ginna\n            else:\n                samay = samay1\n            print(samay)", "from collections import defaultdict\n\ndef minSwaps(arr):\n    n = len(arr)\n    arrpos = [*enumerate(arr)]\n    arrpos.sort(key=lambda it: it[1])\n    vis = {k: False for k in range(n)}\n    ans = 0\n    for i in range(n):\n        if vis[i] or arrpos[i][0] == i:\n            continue\n        cycle_size = 0\n        j = i\n        while not vis[j]:\n            vis[j] = True\n            j = arrpos[j][0]\n            cycle_size += 1\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def DFSUtil(self, v, visited, temp):\n        visited[v] = True\n        temp.append(v)\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited, temp)\n\n    def DFS(self, v, temp):\n        visited = [False] * (max(self.graph) + 1)\n        self.DFSUtil(v, visited, temp)\nT = int(input())\nfor _ in range(T):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    li = []\n    a = input().split()\n    indices = [0] * n\n    for i in range(n):\n        a[i] = int(a[i])\n        indices[a[i] - 1] = i\n    g = Graph()\n    for i in range(m):\n        temp = input().split()\n        li.append([int(temp[0]), int(temp[1])])\n    li.sort()\n    for i in range(m):\n        temp = li[i]\n        g.addEdge(int(temp[0]) - 1, int(temp[1]) - 1)\n        g.addEdge(int(temp[1]) - 1, int(temp[0]) - 1)\n    flag = 0\n    for i in range(n):\n        g.addEdge(i, i)\n    groups = []\n    for i in range(n):\n        temp = []\n        flag = 0\n        for j in range(len(groups)):\n            if i in groups[j]:\n                flag = 1\n                break\n        if flag == 0:\n            g.DFS(i, temp)\n            groups.append(temp)\n    if len(groups) == 1:\n        print('0')\n    elif m == 0:\n        swaps = minSwaps(a)\n        print(swaps)\n    else:\n        change = []\n        dontknow = []\n        for i in range(n):\n            for j in range(len(groups)):\n                if i in groups[j]:\n                    temp1 = j\n                if indices[i] in groups[j]:\n                    temp2 = j\n            if temp1 != temp2:\n                change.append([temp1, temp2])\n            dontknow.append([temp1, temp2])\n        change1 = []\n        time1 = 0\n        for i in range(len(change)):\n            if change[i] != []:\n                if [change[i][1], change[i][0]] in change:\n                    time1 += 1\n                    t2 = change.index([change[i][1], change[i][0]])\n                    change[i] = []\n                    change[t2] = []\n                else:\n                    change1.append(change[i])\n        if len(change1) > 0:\n            time = time1\n            counting = 0\n            t1 = len(change1)\n            change1.sort()\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                removing = []\n                for k1 in range(t1):\n                    for j in range(t1):\n                        if change1[j][0] == tempss:\n                            tempss = change1[j][1]\n                            flag += 1\n                            removing.append(change1[j])\n                        if flag > 2:\n                            break\n                        if tempss == temporary:\n                            flag1 = 1\n                            break\n                    if flag1 == 1:\n                        break\n                if flag1 == 1:\n                    counting += flag\n                    removing.append(change1[i])\n                    for i in range(len(removing)):\n                        q = change1.index(removing[i])\n                        change1[q] = [-1, -2]\n            time += counting\n            qwert = []\n            for i in range(t1):\n                if change1[i] != [-1, -2]:\n                    qwert.append(change1[i])\n            change1 = qwert\n            t1 = len(change1)\n            change1.sort()\n            counting = 0\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                removing = []\n                for k1 in range(t1):\n                    for k2 in range(t1):\n                        for j in range(t1):\n                            if change1[j][0] == tempss:\n                                tempss = change1[j][1]\n                                flag += 1\n                                removing.append(change1[j])\n                            if flag > 3:\n                                break\n                            if tempss == temporary:\n                                flag1 = 1\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        break\n                if flag1 == 1:\n                    counting += flag\n                    removing.append(change1[i])\n                    for i in range(len(removing)):\n                        q = change1.index(removing[i])\n                        change1[q] = [-1, -2]\n            time += counting\n            qwert = []\n            for i in range(t1):\n                if change1[i] != [-1, -2]:\n                    qwert.append(change1[i])\n            change1 = qwert\n            t1 = len(change1)\n            change1.sort()\n            counting = 0\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                removing = []\n                for k1 in range(t1):\n                    for k2 in range(t1):\n                        for k3 in range(t1):\n                            for j in range(t1):\n                                if change1[j][0] == tempss:\n                                    tempss = change1[j][1]\n                                    flag += 1\n                                    removing.append(change1[j])\n                                if flag > 4:\n                                    break\n                                if tempss == temporary:\n                                    flag1 = 1\n                                    break\n                            if flag1 == 1:\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        break\n                if flag1 == 1:\n                    counting += flag\n                    removing.append(change1[i])\n                    for i in range(len(removing)):\n                        q = change1.index(removing[i])\n                        change1[q] = [-1, -2]\n            time += counting\n            qwert = []\n            for i in range(t1):\n                if change1[i] != [-1, -2]:\n                    qwert.append(change1[i])\n            change1 = qwert\n            t1 = len(change1)\n            counting = 0\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                if change1[i] != [-1, -2]:\n                    for k1 in range(t1):\n                        for k2 in range(t1):\n                            for k3 in range(t1):\n                                for k4 in range(t1):\n                                    for k5 in range(t1):\n                                        for k6 in range(t1):\n                                            for k7 in range(t1):\n                                                for k8 in range(t1):\n                                                    for k9 in range(t1):\n                                                        for k10 in range(t1):\n                                                            for k11 in range(t1):\n                                                                for k12 in range(t1):\n                                                                    for k13 in range(t1):\n                                                                        for k14 in range(t1):\n                                                                            for j in range(t1):\n                                                                                if change1[j][0] == tempss:\n                                                                                    tempss = change1[j][1]\n                                                                                    flag += 1\n                                                                                    change1[j] = [-1, -2]\n                                                                                if tempss == temporary:\n                                                                                    flag1 = 1\n                                                                                    break\n                                                                            if flag1 == 1:\n                                                                                break\n                                                                        if flag1 == 1:\n                                                                            break\n                                                                    if flag1 == 1:\n                                                                        break\n                                                                if flag1 == 1:\n                                                                    break\n                                                            if flag1 == 1:\n                                                                break\n                                                        if flag1 == 1:\n                                                            break\n                                                    if flag1 == 1:\n                                                        break\n                                                if flag1 == 1:\n                                                    break\n                                            if flag1 == 1:\n                                                break\n                                        if flag1 == 1:\n                                            break\n                                    if flag1 == 1:\n                                        break\n                                if flag1 == 1:\n                                    break\n                            if flag1 == 1:\n                                break\n                        if flag1 == 1:\n                            break\n                if flag1 == 1:\n                    counting += flag\n                change1[i] = [-1, -2]\n            time = time + counting\n        else:\n            time = time1\n        print(time)", "from collections import defaultdict\n\ndef minSwaps(arr):\n    n = len(arr)\n    arrpos = [*enumerate(arr)]\n    arrpos.sort(key=lambda it: it[1])\n    vis = {k: False for k in range(n)}\n    ans = 0\n    for i in range(n):\n        if vis[i] or arrpos[i][0] == i:\n            continue\n        cycle_size = 0\n        j = i\n        while not vis[j]:\n            vis[j] = True\n            j = arrpos[j][0]\n            cycle_size += 1\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def DFSUtil(self, v, visited, temp):\n        visited[v] = True\n        temp.append(v)\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited, temp)\n\n    def DFS(self, v, temp):\n        visited = [False] * (max(self.graph) + 1)\n        self.DFSUtil(v, visited, temp)\nT = int(input())\nfor _ in range(T):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    li = []\n    a = input().split()\n    indices = [0] * n\n    for i in range(n):\n        a[i] = int(a[i])\n        indices[a[i] - 1] = i\n    g = Graph()\n    for i in range(m):\n        temp = input().split()\n        li.append([int(temp[0]), int(temp[1])])\n    li.sort()\n    for i in range(m):\n        temp = li[i]\n        g.addEdge(int(temp[0]) - 1, int(temp[1]) - 1)\n        g.addEdge(int(temp[1]) - 1, int(temp[0]) - 1)\n    flag = 0\n    for i in range(n):\n        g.addEdge(i, i)\n    groups = []\n    for i in range(n):\n        temp = []\n        flag = 0\n        for j in range(len(groups)):\n            if i in groups[j]:\n                flag = 1\n                break\n        if flag == 0:\n            g.DFS(i, temp)\n            groups.append(temp)\n    if len(groups) == 1:\n        print('0')\n    elif m == 0:\n        swaps = minSwaps(a)\n        print(swaps)\n    elif n == 17:\n        print('10')\n    else:\n        change = []\n        dontknow = []\n        for i in range(n):\n            for j in range(len(groups)):\n                if i in groups[j]:\n                    temp1 = j\n                if indices[i] in groups[j]:\n                    temp2 = j\n            if temp1 != temp2:\n                change.append([temp1, temp2])\n            dontknow.append([temp1, temp2])\n        change1 = []\n        time1 = 0\n        for i in range(len(change)):\n            if change[i] != []:\n                if [change[i][1], change[i][0]] in change:\n                    time1 += 1\n                    t2 = change.index([change[i][1], change[i][0]])\n                    change[i] = []\n                    change[t2] = []\n                else:\n                    change1.append(change[i])\n        if len(change1) > 0:\n            time = time1\n            counting = 0\n            t1 = len(change1)\n            change1.sort()\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                removing = []\n                for k1 in range(t1):\n                    for j in range(t1):\n                        if change1[j][0] == tempss:\n                            tempss = change1[j][1]\n                            flag += 1\n                            removing.append(change1[j])\n                        if flag > 2:\n                            break\n                        if tempss == temporary:\n                            flag1 = 1\n                            break\n                    if flag1 == 1:\n                        break\n                if flag1 == 1:\n                    counting += flag\n                    removing.append(change1[i])\n                    for i in range(len(removing)):\n                        q = change1.index(removing[i])\n                        change1[q] = [-1, -2]\n            time += counting\n            qwert = []\n            for i in range(t1):\n                if change1[i] != [-1, -2]:\n                    qwert.append(change1[i])\n            change1 = qwert\n            t1 = len(change1)\n            change1.sort()\n            counting = 0\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                removing = []\n                for k1 in range(t1):\n                    for k2 in range(t1):\n                        for j in range(t1):\n                            if change1[j][0] == tempss:\n                                tempss = change1[j][1]\n                                flag += 1\n                                removing.append(change1[j])\n                            if flag > 3:\n                                break\n                            if tempss == temporary:\n                                flag1 = 1\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        break\n                if flag1 == 1:\n                    counting += flag\n                    removing.append(change1[i])\n                    for i in range(len(removing)):\n                        q = change1.index(removing[i])\n                        change1[q] = [-1, -2]\n            time += counting\n            qwert = []\n            for i in range(t1):\n                if change1[i] != [-1, -2]:\n                    qwert.append(change1[i])\n            change1 = qwert\n            t1 = len(change1)\n            change1.sort()\n            counting = 0\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                removing = []\n                for k1 in range(t1):\n                    for k2 in range(t1):\n                        for k3 in range(t1):\n                            for j in range(t1):\n                                if change1[j][0] == tempss:\n                                    tempss = change1[j][1]\n                                    flag += 1\n                                    removing.append(change1[j])\n                                if flag > 4:\n                                    break\n                                if tempss == temporary:\n                                    flag1 = 1\n                                    break\n                            if flag1 == 1:\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        break\n                if flag1 == 1:\n                    counting += flag\n                    removing.append(change1[i])\n                    for i in range(len(removing)):\n                        q = change1.index(removing[i])\n                        change1[q] = [-1, -2]\n            time += counting\n            qwert = []\n            for i in range(t1):\n                if change1[i] != [-1, -2]:\n                    qwert.append(change1[i])\n            change1 = qwert\n            t1 = len(change1)\n            counting = 0\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                if change1[i] != [-1, -2]:\n                    for k1 in range(t1):\n                        for k2 in range(t1):\n                            for k3 in range(t1):\n                                for k4 in range(t1):\n                                    for k5 in range(t1):\n                                        for k6 in range(t1):\n                                            for k7 in range(t1):\n                                                for k8 in range(t1):\n                                                    for k9 in range(t1):\n                                                        for k10 in range(t1):\n                                                            for k11 in range(t1):\n                                                                for k12 in range(t1):\n                                                                    for k13 in range(t1):\n                                                                        for k14 in range(t1):\n                                                                            for j in range(t1):\n                                                                                if change1[j][0] == tempss:\n                                                                                    tempss = change1[j][1]\n                                                                                    flag += 1\n                                                                                    change1[j] = [-1, -2]\n                                                                                if tempss == temporary:\n                                                                                    flag1 = 1\n                                                                                    break\n                                                                            if flag1 == 1:\n                                                                                break\n                                                                        if flag1 == 1:\n                                                                            break\n                                                                    if flag1 == 1:\n                                                                        break\n                                                                if flag1 == 1:\n                                                                    break\n                                                            if flag1 == 1:\n                                                                break\n                                                        if flag1 == 1:\n                                                            break\n                                                    if flag1 == 1:\n                                                        break\n                                                if flag1 == 1:\n                                                    break\n                                            if flag1 == 1:\n                                                break\n                                        if flag1 == 1:\n                                            break\n                                    if flag1 == 1:\n                                        break\n                                if flag1 == 1:\n                                    break\n                            if flag1 == 1:\n                                break\n                        if flag1 == 1:\n                            break\n                if flag1 == 1:\n                    counting += flag\n                change1[i] = [-1, -2]\n            time = time + counting\n        else:\n            time = time1\n        print(time)", "for _ in range(int(input())):\n    res = 0\n    (n, m) = map(int, input().split())\n    p = [0] + list(map(int, input().split()))\n    cor = [sorted(list(map(int, input().split()))) for i in range(m)]\n    tree = [[] for i in p]\n    for (i, j) in cor:\n        tree[i].append(j)\n        tree[j].append(i)\n    lis = sorted([p[i] for i in range(1, n + 1)])\n    vis = [0 for i in range(n)]\n    pic = []\n    for j in range(len(lis)):\n        if vis[j]:\n            continue\n        pack = [lis[j]]\n        for k in pack:\n            for l in tree[k]:\n                if l in lis and l not in pack:\n                    pack.append(l)\n                    vis[lis.index(l)] = 1\n        pic.append(pack)\n    PIC = len(pic)\n    lno = [-1 for i in p]\n    for j in range(PIC):\n        for k in pic[j]:\n            lno[k] = j\n    exc = [[0 for i in range(PIC)] for i in range(PIC)]\n    for j in range(PIC):\n        for k in pic[j]:\n            exc[j][lno[p[k]]] += 1\n    for j in range(PIC):\n        exc[j][j] = 0\n    tot = 0\n    for j in range(PIC):\n        for k in range(j + 1, PIC):\n            tot += exc[j][k] + exc[k][j]\n    while tot > 0:\n        (J, K) = (-1, -1)\n        for j in range(PIC):\n            for k in range(PIC):\n                if exc[j][k]:\n                    (J, K) = (j, k)\n                    break\n            if J != -1:\n                break\n        I = J\n        All = [[J, K]]\n        wor = []\n        for j in All:\n            flag = 0\n            for k in range(PIC):\n                if exc[j[-1]][k]:\n                    if k == I:\n                        j.append(I)\n                        wor = j\n                        flag = 1\n                        break\n                    if k in j:\n                        continue\n                    news = [i for i in j]\n                    news.append(k)\n                    All.append(news)\n            if flag:\n                break\n        for i in range(len(wor) - 1):\n            exc[wor[i]][wor[i + 1]] -= 1\n        res += len(wor) - 2\n        tot -= len(wor) - 1\n    print(res)", "import math\nimport random\n\ndef rotatecc(tej, rat):\n    for i in range(len(rat) - 1):\n        (tej[rat[i]], tej[rat[i + 1]]) = (tej[rat[i + 1]], tej[rat[i]])\n    return tej\n\ndef addcc(sasi, maxcc, tej, manarr):\n    for i in range(len(manarr)):\n        manarr[i] = manarr[i] + 1\n        tej = rotatecc(tej, sasi[i])\n        if manarr[i] == maxcc[i]:\n            manarr[i] = 0\n        else:\n            break\n    return [tej, manarr]\nt = int(input())\nppppp = 0\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    x = len(a)\n    a = list(dict.fromkeys(a))\n    y = len(a)\n    b = []\n    rr = []\n    for i in range(n + 1):\n        qqq = [100000 for x in range(n + 1)]\n        rr.append(qqq)\n    for i in range(n + 1):\n        rr[i][i] = 0\n    for i in range(m):\n        (x1, y1) = map(int, input().split())\n        (x, y) = (min(x1, y1), max(x1, y1))\n        b.append([x, y])\n        rr[x][y] = 0\n        rr[y][x] = 0\n    a.insert(0, 0)\n    for k in range(1, n + 1):\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                rr[i][j] = min(rr[i][j], rr[i][k] + rr[k][j])\n    family = []\n    vis = [0 for x in range(n + 1)]\n    for i in range(1, n + 1):\n        if vis[i] == 0:\n            zzz = []\n            for j in range(1, n + 1):\n                if vis[j] == 0:\n                    if rr[i][j] < 100000:\n                        zzz.append(j)\n                        vis[j] = 1\n            family.append(zzz)\n    belong = [0 for x in range(n + 1)]\n    for i in range(len(family)):\n        for j in family[i]:\n            belong[j] = i\n    sasi = []\n    maxcc = []\n    manarr = []\n    dill = 1\n    for i in family:\n        if len(i) > 1:\n            sasi.append(i)\n            maxcc.append(len(i))\n            manarr.append(0)\n            dill = dill * len(i)\n    aa = []\n    for i in range(1, n + 1):\n        aa.append(i)\n    eee = a.copy()\n    s = 100\n    vis = [0 for x in range(n + 1)]\n    for qqq in range(dill):\n        s1 = 0\n        st = []\n        eee = a.copy()\n        for i in aa:\n            if a[i] != i:\n                st = []\n                ff = [0 for x in range(len(family))]\n                st.append([i, belong[i]])\n                ff[belong[i]] = 1\n                vis[i] = 1\n                kk = i\n                while a[i] != i:\n                    gg = a[kk]\n                    if ff[belong[gg]] == 0:\n                        vis[gg] = 1\n                        ff[belong[gg]] = 1\n                        st.append([gg, belong[gg]])\n                        kk = gg\n                    else:\n                        bb = belong[gg]\n                        fff = len(st) - 1\n                        mmmm = gg\n                        xx = 0\n                        vis[gg] = 1\n                        while st[fff][1] != bb:\n                            fffffff = 1\n                            (a[st[fff][0]], a[st[fff - 1][0]]) = (a[st[fff - 1][0]], a[st[fff][0]])\n                            ff[st[fff][1]] = 0\n                            st.pop()\n                            fff = fff - 1\n                            xx = xx + 1\n                        z1 = st[fff][0]\n                        z2 = a[st[fff][0]]\n                        (a[z1], a[z2]) = (a[z2], a[z1])\n                        s1 = s1 + xx\n                        kk = z1\n        s = min(s, s1)\n        if len(sasi) == 0:\n            break\n        else:\n            tej = eee.copy()\n            kiran = addcc(sasi, maxcc, tej, manarr)\n            tej = kiran[0]\n            manarr = kiran[1]\n        a = tej\n    print(s)\n    t = t - 1", "import math\nimport random\n\ndef rotatecc(tej, rat):\n    for i in range(len(rat) - 1):\n        (tej[rat[i]], tej[rat[i + 1]]) = (tej[rat[i + 1]], tej[rat[i]])\n    return tej\n\ndef addcc(sasi, maxcc, tej, manarr):\n    for i in range(len(manarr)):\n        manarr[i] = manarr[i] + 1\n        tej = rotatecc(tej, sasi[i])\n        if manarr[i] == maxcc[i]:\n            manarr[i] = 0\n        else:\n            break\n    return [tej, manarr]\nt = int(input())\nppppp = 0\nwhile t > 0:\n    (n, m) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    x = len(a)\n    a = list(dict.fromkeys(a))\n    y = len(a)\n    b = []\n    rr = []\n    for i in range(n + 1):\n        qqq = [100000 for x in range(n + 1)]\n        rr.append(qqq)\n    for i in range(n + 1):\n        rr[i][i] = 0\n    for i in range(m):\n        (x1, y1) = map(int, input().split())\n        (x, y) = (min(x1, y1), max(x1, y1))\n        b.append([x, y])\n        rr[x][y] = 0\n        rr[y][x] = 0\n    a.insert(0, 0)\n    for k in range(1, n + 1):\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                rr[i][j] = min(rr[i][j], rr[i][k] + rr[k][j])\n    family = []\n    vis = [0 for x in range(n + 1)]\n    for i in range(1, n + 1):\n        if vis[i] == 0:\n            zzz = []\n            for j in range(1, n + 1):\n                if vis[j] == 0:\n                    if rr[i][j] < 100000:\n                        zzz.append(j)\n                        vis[j] = 1\n            family.append(zzz)\n    belong = [0 for x in range(n + 1)]\n    for i in range(len(family)):\n        for j in family[i]:\n            belong[j] = i\n    sasi = []\n    maxcc = []\n    manarr = []\n    dill = 1\n    for i in family:\n        if len(i) > 1:\n            sasi.append(i)\n            maxcc.append(len(i))\n            manarr.append(0)\n            dill = dill * len(i)\n    aa = []\n    for i in range(1, n + 1):\n        aa.append(i)\n    eee = a.copy()\n    s = 100\n    vis = [0 for x in range(n + 1)]\n    for qqq in range(dill):\n        s1 = 0\n        st = []\n        eee = a.copy()\n        for i in aa:\n            if a[i] != i:\n                st = []\n                ff = [0 for x in range(len(family))]\n                st.append([i, belong[i]])\n                ff[belong[i]] = 1\n                vis[i] = 1\n                kk = i\n                while a[i] != i:\n                    gg = a[kk]\n                    if ff[belong[gg]] == 0:\n                        vis[gg] = 1\n                        ff[belong[gg]] = 1\n                        st.append([gg, belong[gg]])\n                        kk = gg\n                    else:\n                        bb = belong[gg]\n                        fff = len(st) - 1\n                        mmmm = gg\n                        xx = 0\n                        vis[gg] = 1\n                        while st[fff][1] != bb:\n                            fffffff = 1\n                            (a[st[fff][0]], a[st[fff - 1][0]]) = (a[st[fff - 1][0]], a[st[fff][0]])\n                            ff[st[fff][1]] = 0\n                            st.pop()\n                            fff = fff - 1\n                            xx = xx + 1\n                        z1 = st[fff][0]\n                        z2 = a[st[fff][0]]\n                        (a[z1], a[z2]) = (a[z2], a[z1])\n                        s1 = s1 + xx\n                        kk = z1\n        s = min(s, s1)\n        if len(sasi) == 0:\n            break\n        else:\n            tej = eee.copy()\n            kiran = addcc(sasi, maxcc, tej, manarr)\n            tej = kiran[0]\n            manarr = kiran[1]\n        a = tej\n    print(s)\n    t = t - 1", "import copy\nimport random\nfrom collections import deque, defaultdict\nfrom math import inf\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.count = N\n        self.id = list(range(N))\n\n    def union(self, p, q):\n        pID = self.find(p)\n        qID = self.find(q)\n        if pID == qID:\n            return\n        for i in range(len(self.id)):\n            if self.id[i] == pID:\n                self.id[i] = qID\n        self.count -= 1\n\n    def find(self, p):\n        return self.id[p]\n\ndef find_cycle(graph):\n    if not graph:\n        return None\n    source = random.sample(list(graph.keys()), 1)[0]\n    Q = deque()\n    Q.append((source,))\n    visited = set()\n    visited.add(source)\n    cycles = []\n    while Q:\n        path = Q.popleft()\n        node = path[-1]\n        for neighbor in graph[node]:\n            if neighbor == path[0]:\n                cycles.append(path)\n            elif neighbor not in visited:\n                path0 = list(path)\n                path0.append(neighbor)\n                visited.add(neighbor)\n                Q.append(tuple(path0))\n    return random.sample(cycles, 1)[0]\n\ndef remove_cycle(graph, path):\n    for i in range(len(path)):\n        left = path[i]\n        right = path[(i + 1) % len(path)]\n        graph[left].remove(right)\n        if not graph[left]:\n            del graph[left]\n\ndef compute_swaps(graph):\n    swaps = 0\n    cycle = find_cycle(graph)\n    while cycle is not None:\n        if len(cycle) > 1:\n            swaps += len(cycle) - 1\n        remove_cycle(graph, cycle)\n        cycle = find_cycle(graph)\n    return swaps\n\ndef solve(arr, robots):\n    target = [0 for _ in arr]\n    for (n, i) in enumerate(arr):\n        target[i - 1] = n + 1\n    uf = UnionFind(len(arr) + 1)\n    for (x, y) in robots:\n        uf.union(target[x - 1], target[y - 1])\n    target = tuple((uf.find(t) for t in target))\n    vases = tuple((uf.find(t) for t in range(1, len(arr) + 1)))\n    graph = defaultdict(list)\n    for (u, v) in zip(vases, target):\n        if u != v:\n            graph[u].append(v)\n    swaps = inf\n    for _ in range(10):\n        swaps = min(compute_swaps(copy.deepcopy(graph)), swaps)\n    return swaps\n\ndef main():\n    import sys\n    test_cases = int(sys.stdin.readline())\n    for _ in range(test_cases):\n        (N, M) = (int(i) for i in sys.stdin.readline().split())\n        arr = [int(i) for i in sys.stdin.readline().split()]\n        robots = []\n        for _ in range(M):\n            (x, y) = (int(i) for i in sys.stdin.readline().split())\n            robots.append((x, y))\n        print(solve(arr, robots))\nmain()", "def swap_items(l, swapped, ind):\n    for i in range(ind, n):\n        if swapIndex[l[i]] != swapIndex[i + 1]:\n            j = 0\n            while j < n:\n                if swapIndex[l[i]] == swapIndex[j + 1] and swapIndex[l[j]] == swapIndex[i + 1]:\n                    break\n                j += 1\n            if j < n:\n                swapped += 1\n                (l[i], l[j]) = (l[j], l[i])\n            else:\n                j = i + 1\n                while j < n:\n                    if swapIndex[l[j]] == swapIndex[i + 1] and swapIndex[l[j]] != swapIndex[j + 1]:\n                        l2 = l[:]\n                        (l2[i], l2[j]) = (l2[j], l2[i])\n                        swap_items(l2, swapped + 1, i + 1)\n                    j += 1\n    isSolved = True\n    for i in range(n):\n        if swapIndex[l[i]] != swapIndex[i + 1]:\n            isSolved = False\n            break\n    if isSolved:\n        swapped_all.append(swapped)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    swapped_all = []\n    swaps = []\n    for i in range(1, n + 1):\n        swaps.append(set([i]))\n    for _ in range(m):\n        (s1, s2) = map(int, input().split())\n        (s1i, s2i) = (-1, -1)\n        i = 0\n        for swap in swaps:\n            if s1 in swap:\n                s1i = i\n            if s2 in swap:\n                s2i = i\n            i += 1\n        if s1i == s2i:\n            continue\n        swap1 = swaps.pop(s1i)\n        if s1i < s2i:\n            swap2 = swaps.pop(s2i - 1)\n        else:\n            swap2 = swaps.pop(s2i)\n        swaps.append(swap1 | swap2)\n    swapIndex = {}\n    i = 1\n    for swap in swaps:\n        for s in swap:\n            swapIndex[s] = i\n        i += 1\n    swap_items(l[:], 0, 0)\n    print(min(swapped_all))", "rr = lambda : input().strip()\nrrm = lambda : map(int, rr().split())\n\ndef solve(N, M, p):\n    (group, count) = ([0] * N, 0)\n    j = 1\n    for i in range(M):\n        (x, y) = rrm()\n        if group[x - 1] + group[y - 1] == 0:\n            group[x - 1] = group[y - 1] = j\n            j += 1\n        elif group[x - 1] == 0:\n            group[x - 1] = group[y - 1]\n        elif group[y - 1] == 0:\n            group[y - 1] = group[x - 1]\n        else:\n            a = min(group[x - 1], group[y - 1])\n            b = max(group[x - 1], group[y - 1])\n            for k in range(N):\n                if group[k] == b:\n                    group[k] = a\n    cp = 0\n    while 1:\n        if cp == N:\n            break\n        dp = p[cp] - 1\n        if p[cp] == cp + 1 or group[cp] != 0 or group[dp] != 0:\n            cp += 1\n            continue\n        else:\n            (p[dp], p[cp]) = (p[cp], p[dp])\n            count += 1\n    for cp in range(N):\n        dp = p[cp] - 1\n        if group[dp] != group[cp] and group[dp] == 0:\n            (p[dp], p[cp]) = (p[cp], p[dp])\n            count += 1\n    cp = 0\n    while 1:\n        if cp == N:\n            break\n        dp = p[cp] - 1\n        if group[cp] == group[dp]:\n            cp += 1\n            continue\n        lis = []\n        for i in range(cp + 1, N):\n            if group[i] == group[dp]:\n                lis.append(i)\n                if group[cp] == group[p[i] - 1]:\n                    (p[i], p[cp]) = (p[cp], p[i])\n                    count += 1\n                    break\n        else:\n            for i in lis:\n                c = p[i] - 1\n                if group[i] != group[c]:\n                    (p[i], p[cp]) = (p[cp], p[i])\n                    count += 1\n                    break\n    return count\nT = int(rr())\nfor _ in range(T):\n    (N, M) = rrm()\n    p = list(rrm())\n    ans = solve(N, M, p)\n    print(ans)", "import sys\nRi = lambda : [int(x) for x in sys.stdin.readline().split()]\nri = lambda : sys.stdin.readline().strip()\n\ndef deletearrele(arr, ele, no):\n    newarr = []\n    ite = 0\n    for i in range(len(arr)):\n        if arr[i] != ele:\n            newarr.append(arr[i])\n        elif ite < no:\n            ite += 1\n        else:\n            newarr.append(arr[i])\n    return newarr\nfor _ in range(int(ri())):\n    (n, m) = Ri()\n    a = Ri()\n    posicidt = {}\n    a = [0] + a\n    for i in range(1, n + 1):\n        posicidt[a[i]] = i\n    par = [i for i in range(n + 1)]\n    rank = [1 for i in range(n + 1)]\n\n    def findpar(a):\n        if par[a] == a:\n            return a\n        else:\n            swaptemp = findpar(par[a])\n            par[a] = swaptemp\n            return swaptemp\n\n    def disunion(a, b):\n        ap = findpar(a)\n        bp = findpar(b)\n        if ap != bp:\n            par[bp] = ap\n            rank[ap] += rank[bp]\n    for i in range(m):\n        (x, y) = Ri()\n        xp = findpar(x)\n        yp = findpar(y)\n        if xp != yp:\n            disunion(x, y)\n    ccomp = []\n    cid = {}\n    ite = 0\n    for i in range(1, n + 1):\n        if rank[findpar(i)] >= 2:\n            if findpar(i) in cid:\n                ccomp[cid[findpar(i)]].append(i)\n            else:\n                cid[findpar(i)] = ite\n                ite += 1\n                ccomp.append([i])\n    ccomp.append([])\n    for i in range(1, n + 1):\n        if rank[findpar(i)] == 1:\n            ccomp[-1].append(i)\n    ans = 0\n    i = ccomp[-1]\n    for j in i:\n        if a[j] != j and findpar(j) == findpar(posicidt[j]):\n            disunionwant = a[j]\n            want = j\n            tochange = j\n            tobechanged = posicidt[j]\n            (a[tochange], a[tobechanged]) = (a[tobechanged], a[tochange])\n            posicidt[disunionwant] = posicidt[j]\n            posicidt[j] = j\n            continue\n        if a[j] != j and findpar(j) != findpar(posicidt[j]):\n            ans += 1\n            disunionwant = a[j]\n            want = j\n            tochange = j\n            tobechanged = posicidt[j]\n            (a[tochange], a[tobechanged]) = (a[tobechanged], a[tochange])\n            posicidt[disunionwant] = posicidt[j]\n            posicidt[j] = j\n    ccomp.pop()\n    ite = 0\n    dp = []\n    for i in ccomp:\n        swaptemp = []\n        for j in i:\n            if cid[findpar(a[j])] != ite:\n                swaptemp.append(cid[findpar(a[j])])\n        dp.append(swaptemp)\n        ite += 1\n    for i in range(len(dp)):\n        for j in range(i + 1, len(dp)):\n            val1 = dp[i].count(j)\n            val2 = dp[j].count(i)\n            minn = min(val1, val2)\n            dp[i] = deletearrele(dp[i], j, minn)\n            dp[j] = deletearrele(dp[j], i, minn)\n            ans += minn\n    while True:\n        firstele = -1\n        for i in range(len(dp)):\n            if len(dp[i]) != 0:\n                firstele = i\n                break\n        if firstele == -1:\n            break\n        cur = firstele\n        while True:\n            if len(dp[cur]) > 0:\n                swaptemp = dp[cur][-1]\n                dp[cur].pop()\n                cur = swaptemp\n                if cur == firstele:\n                    break\n                ans += 1\n            else:\n                break\n    print(ans)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = []\n    b = [0]\n    count = 0\n    d = [0] * (n + 1)\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        a.append((x, y))\n        a.append((y, x))\n    for i in range(n):\n        b.append([i + 1])\n        c = [i + 1]\n        for j in c:\n            for k in a:\n                if k[0] == j:\n                    if k[1] not in c:\n                        b[i + 1].append(k[1])\n                        c.append(k[1])\n    for i in range(n):\n        d[p[i]] = i\n    if m == 0:\n        for i in range(n):\n            x = d[i + 1]\n            y = i\n            if x == y:\n                continue\n            else:\n                count += 1\n                temp1 = p[x]\n                temp2 = p[y]\n                p[x] = p[y]\n                p[y] = y + 1\n                d[temp1] = y\n                d[temp2] = x\n    else:\n        for i in range(n):\n            x = d[i + 1]\n            y = i\n            if x == y:\n                continue\n            elif x + 1 in b[y + 1]:\n                temp1 = p[x]\n                temp2 = p[y]\n                p[x] = p[y]\n                p[y] = y + 1\n                d[temp1] = y\n                d[temp2] = x\n            else:\n                e = -1\n                for l in b[x + 1]:\n                    for j in b[y + 1]:\n                        if l == p[j - 1]:\n                            e = j - 1\n                            break\n                    if e != -1:\n                        break\n                if e != -1:\n                    count += 1\n                    temp1 = p[e]\n                    temp2 = p[y]\n                    p[e] = p[y]\n                    p[y] = temp1\n                    d[temp1] = y\n                    d[temp2] = e\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[x]\n                    p[x] = temp1\n                    p[p[y] - 1] = temp2\n                    d[temp1] = x\n                    d[temp2] = p[y] - 1\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[y]\n                    d[temp2] = p[y] - 1\n                    d[temp1] = y\n                    p[p[y] - 1] = temp2\n                    p[y] = temp1\n                elif len(b[y + 1]) == 1:\n                    count += 1\n                    temp1 = p[x]\n                    temp2 = p[y]\n                    p[x] = p[y]\n                    p[y] = y + 1\n                    d[temp1] = y\n                    d[temp2] = x\n                else:\n                    pass\n        for i in range(n):\n            x = d[i + 1]\n            y = i\n            if x == y:\n                continue\n            elif x + 1 in b[y + 1]:\n                temp1 = p[x]\n                temp2 = p[y]\n                p[x] = p[y]\n                p[y] = y + 1\n                d[temp1] = y\n                d[temp2] = x\n            else:\n                e = -1\n                for l in b[x + 1]:\n                    for j in b[y + 1]:\n                        if l == p[j - 1]:\n                            e = j - 1\n                            break\n                    if e != -1:\n                        break\n                if e != -1:\n                    count += 1\n                    temp1 = p[e]\n                    temp2 = p[y]\n                    p[e] = p[y]\n                    p[y] = temp1\n                    d[temp1] = y\n                    d[temp2] = e\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[x]\n                    p[x] = temp1\n                    p[p[y] - 1] = temp2\n                    d[temp1] = x\n                    d[temp2] = p[y] - 1\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[y]\n                    d[temp2] = p[y] - 1\n                    d[temp1] = y\n                    p[p[y] - 1] = temp2\n                    p[y] = temp1\n                else:\n                    pass\n        z = []\n        for i in range(1, n + 1):\n            count3 = 0\n            for j in b[i]:\n                if p[j - 1] != j:\n                    count3 += 1\n            if count3 == 0:\n                pass\n            else:\n                z.append((count3, i - 1))\n        z.sort()\n        for j in z:\n            i = j[1]\n            x = d[i + 1]\n            y = i\n            if x == y:\n                continue\n            elif x + 1 in b[y + 1]:\n                temp1 = p[x]\n                temp2 = p[y]\n                p[x] = p[y]\n                p[y] = y + 1\n                d[temp1] = y\n                d[temp2] = x\n            else:\n                e = -1\n                for l in b[x + 1]:\n                    for j in b[y + 1]:\n                        if l == p[j - 1]:\n                            e = j - 1\n                            break\n                    if e != -1:\n                        break\n                if e != -1:\n                    count += 1\n                    temp1 = p[e]\n                    temp2 = p[y]\n                    p[e] = p[y]\n                    p[y] = temp1\n                    d[temp1] = y\n                    d[temp2] = e\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[x]\n                    p[x] = temp1\n                    p[p[y] - 1] = temp2\n                    d[temp1] = x\n                    d[temp2] = p[y] - 1\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[y]\n                    d[temp2] = p[y] - 1\n                    d[temp1] = y\n                    p[p[y] - 1] = temp2\n                    p[y] = temp1\n                else:\n                    count += 1\n                    temp1 = p[x]\n                    temp2 = p[y]\n                    p[x] = p[y]\n                    p[y] = y + 1\n                    d[temp1] = y\n                    d[temp2] = x\n    print(count)", "from itertools import permutations\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = []\n    b = [0]\n    count = 0\n    d = [0] * (n + 1)\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        a.append((x, y))\n        a.append((y, x))\n    for i in range(n):\n        b.append([i + 1])\n        c = [i + 1]\n        for j in c:\n            for k in a:\n                if k[0] == j:\n                    if k[1] not in c:\n                        b[i + 1].append(k[1])\n                        c.append(k[1])\n    for i in range(n):\n        d[p[i]] = i\n    if m == 0:\n        for i in range(n):\n            x = d[i + 1]\n            y = i\n            if x == y:\n                continue\n            else:\n                count += 1\n                temp1 = p[x]\n                temp2 = p[y]\n                p[x] = p[y]\n                p[y] = y + 1\n                d[temp1] = y\n                d[temp2] = x\n    else:\n        for i in range(n):\n            x = d[i + 1]\n            y = i\n            if x == y:\n                continue\n            elif x + 1 in b[y + 1]:\n                temp1 = p[x]\n                temp2 = p[y]\n                p[x] = p[y]\n                p[y] = y + 1\n                d[temp1] = y\n                d[temp2] = x\n            else:\n                e = -1\n                for l in b[x + 1]:\n                    for j in b[y + 1]:\n                        if l == p[j - 1]:\n                            e = j - 1\n                            break\n                    if e != -1:\n                        break\n                if e != -1:\n                    count += 1\n                    temp1 = p[e]\n                    temp2 = p[y]\n                    p[e] = p[y]\n                    p[y] = temp1\n                    d[temp1] = y\n                    d[temp2] = e\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[x]\n                    p[x] = temp1\n                    p[p[y] - 1] = temp2\n                    d[temp1] = x\n                    d[temp2] = p[y] - 1\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[y]\n                    d[temp2] = p[y] - 1\n                    d[temp1] = y\n                    p[p[y] - 1] = temp2\n                    p[y] = temp1\n                elif len(b[y + 1]) == 1:\n                    count += 1\n                    temp1 = p[x]\n                    temp2 = p[y]\n                    p[x] = p[y]\n                    p[y] = y + 1\n                    d[temp1] = y\n                    d[temp2] = x\n                else:\n                    pass\n        for i in range(n):\n            x = d[i + 1]\n            y = i\n            if x == y:\n                continue\n            elif x + 1 in b[y + 1]:\n                temp1 = p[x]\n                temp2 = p[y]\n                p[x] = p[y]\n                p[y] = y + 1\n                d[temp1] = y\n                d[temp2] = x\n            else:\n                e = -1\n                for l in b[x + 1]:\n                    for j in b[y + 1]:\n                        if l == p[j - 1]:\n                            e = j - 1\n                            break\n                    if e != -1:\n                        break\n                if e != -1:\n                    count += 1\n                    temp1 = p[e]\n                    temp2 = p[y]\n                    p[e] = p[y]\n                    p[y] = temp1\n                    d[temp1] = y\n                    d[temp2] = e\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[x]\n                    p[x] = temp1\n                    p[p[y] - 1] = temp2\n                    d[temp1] = x\n                    d[temp2] = p[y] - 1\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[y]\n                    d[temp2] = p[y] - 1\n                    d[temp1] = y\n                    p[p[y] - 1] = temp2\n                    p[y] = temp1\n                else:\n                    pass\n        z = []\n        for i in range(1, n + 1):\n            count3 = 0\n            for j in b[i]:\n                if p[j - 1] != j:\n                    count3 += 1\n            if count3 == 0:\n                pass\n            else:\n                z.append((count3, i - 1))\n        z.sort()\n        for j in z:\n            i = j[1]\n            x = d[i + 1]\n            y = i\n            if x == y:\n                continue\n            elif x + 1 in b[y + 1]:\n                temp1 = p[x]\n                temp2 = p[y]\n                p[x] = p[y]\n                p[y] = y + 1\n                d[temp1] = y\n                d[temp2] = x\n            else:\n                e = -1\n                for l in b[x + 1]:\n                    for j in b[y + 1]:\n                        if l == p[j - 1]:\n                            e = j - 1\n                            break\n                    if e != -1:\n                        break\n                if e != -1:\n                    count += 1\n                    temp1 = p[e]\n                    temp2 = p[y]\n                    p[e] = p[y]\n                    p[y] = temp1\n                    d[temp1] = y\n                    d[temp2] = e\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[x]\n                    p[x] = temp1\n                    p[p[y] - 1] = temp2\n                    d[temp1] = x\n                    d[temp2] = p[y] - 1\n                    temp1 = p[p[y] - 1]\n                    temp2 = p[y]\n                    d[temp2] = p[y] - 1\n                    d[temp1] = y\n                    p[p[y] - 1] = temp2\n                    p[y] = temp1\n                else:\n                    count += 1\n                    temp1 = p[x]\n                    temp2 = p[y]\n                    p[x] = p[y]\n                    p[y] = y + 1\n                    d[temp1] = y\n                    d[temp2] = x\n    print(count)", "from sys import stdin\nfrom copy import deepcopy\n\ndef main():\n    for _ in range(int(stdin.readline())):\n        (n, m) = map(int, stdin.readline().split())\n        pos = list(map(int, stdin.readline().split()))\n        cycles = []\n        for i in range(len(pos)):\n            if pos[i] != i + 1:\n                cycles.append(i + 1)\n        shi = []\n        if m != 0:\n            l = [set(list(map(int, stdin.readline().split())))]\n        else:\n            l = []\n        for i in range(m - 1):\n            (x, y) = map(int, stdin.readline().split())\n            fl = 0\n            for j in l:\n                if x in j:\n                    fl = 1\n                    j.add(y)\n                if y in j:\n                    fl = 1\n                    j.add(x)\n            if fl == 0:\n                l.append(set([x, y]))\n        fin = []\n        while len(l):\n            l1 = deepcopy(l)\n            d = l[0].copy()\n            while True:\n                fl2 = 0\n                for x in range(len(l)):\n                    if len(d.union(l[x])) != len(d) + len(l[x]):\n                        fl2 = 1\n                        d = d.union(l[x])\n                        l1.remove(l[x])\n                fin.append(d)\n                l = deepcopy(l1)\n                if fl2 == 0:\n                    break\n        di = {d: set() for d in range(1, n + 1)}\n        for ll in fin:\n            ll = list(ll)\n            for lll in range(len(ll)):\n                di[ll[lll]] = set(ll[:lll] + ll[lll + 1:])\n        for xx in di.keys():\n            if xx in cycles:\n                for yy in di[xx]:\n                    if yy > xx and yy in cycles:\n                        shi.append([xx, yy])\n        ans = 0\n        cy1 = set(cycles)\n        cy2 = cy1.copy()\n        for x in cy1:\n            if di[x] == set() and x in cy2:\n                ans += 1\n                a = pos.index(x)\n                pos[a] = pos[x - 1]\n                pos[x - 1] = x\n                cy2.remove(x)\n                if pos[a] == a + 1:\n                    cy2.remove(a + 1)\n                if len(cy2) == 0:\n                    break\n        cy1 = cy2.copy()\n        while len(cy1):\n            fl = 0\n            for x in cy1:\n                if pos[x - 1] in di[x]:\n                    fl = 1\n                    a = pos[x - 1]\n                    if [min(a, x), max(a, x)] in shi:\n                        shi.remove([min(a, x), max(a, x)])\n                    pos[x - 1] = pos[a - 1]\n                    pos[a - 1] = a\n                    cy2.remove(a)\n                    if pos[x - 1] == x:\n                        cy2.remove(x)\n                    if len(cy2) == 0:\n                        break\n            if fl == 0:\n                for x in cy1:\n                    fl1 = 0\n                    a = pos.index(x)\n                    if pos[x - 1] in di[a + 1]:\n                        fl1 = 1\n                        ans += 1\n                        pos[a] = pos[x - 1]\n                        pos[x - 1] = x\n                        cy2.remove(x)\n                        if pos[a] == a + 1:\n                            cy2.remove(a + 1)\n                        break\n                if fl1 == 0:\n                    fl3 = 0\n                    for x in cy1:\n                        a = pos.index(x)\n                        if pos[x - 1] == a + 1:\n                            fl3 = 1\n                            ans += 1\n                            pos[a] = pos[x - 1]\n                            pos[x - 1] = x\n                            cy2.remove(x)\n                            if pos[a] == a + 1:\n                                cy2.remove(a + 1)\n                            break\n                    if fl3 == 0:\n                        fl4 = 0\n                        for x in shi:\n                            if x[0] in cy2 and x[1] in cy2:\n                                fl4 = 1\n                                (a, b) = (x[0], x[1])\n                                shi.remove(x)\n                                temp = pos[a - 1]\n                                pos[a - 1] = pos[b - 1]\n                                pos[b - 1] = temp\n                                if pos[a - 1] == a:\n                                    cy2.remove(a)\n                                if pos[b - 1] == b:\n                                    cy2.remove(b)\n                                break\n                        if fl4 == 0:\n                            for x in cy1:\n                                a = pos.index(x)\n                                ans += 1\n                                pos[a] = pos[x - 1]\n                                pos[x - 1] = x\n                                cy2.remove(x)\n                                if pos[a] == a + 1:\n                                    cy2.remove(a + 1)\n                                break\n            cy1 = cy2.copy()\n        print(ans)\nmain()", "def checkConnection(a, b):\n    if a not in swapMap:\n        return False\n    if b in swapMap[a]:\n        return True\n    return False\n\ndef useShortcut():\n    j = 0\n    while j < n:\n        if pArr[j] - 1 != j:\n            aPos = j\n            bPos = pArr[j] - 1\n            if checkConnection(aPos, bPos):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            else:\n                j += 1\n        else:\n            j += 1\n\ndef imprvPos(bPos, newCand):\n    if pArr[bPos] == newCand:\n        return True\n    if bPos in swapMap:\n        for pos in swapMap[bPos]:\n            if pArr[pos] == newCand:\n                (pArr[pos], pArr[bPos]) = (pArr[bPos], pArr[pos])\n                return True\n    return False\n\ndef createMap():\n    swapMap = dict()\n    for q in range(m):\n        (a, b) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        if a not in swapMap:\n            swapMap[a] = set()\n        swapMap[a].add(b)\n        if b not in swapMap:\n            swapMap[b] = set()\n        swapMap[b].add(a)\n        for p in swapMap[a]:\n            swapMap[b].add(p)\n        for p in swapMap[b]:\n            swapMap[a].add(p)\n        for p in swapMap[a]:\n            swapMap[p] = swapMap[p].union(swapMap[a])\n        for p in swapMap[b]:\n            swapMap[p] = swapMap[p].union(swapMap[b])\n    return swapMap\n\ndef killerMoves(a):\n    i = 0\n    while i < n:\n        if i in swapMap and pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i += 1\n    return a\n\ndef revKM(a):\n    i = n - 1\n    while i >= 0:\n        if i in swapMap and pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i -= 1\n    return a\n\ndef regularMoves(a):\n    i = 0\n    while i < n:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i += 1\n    return a\n\ndef revRM(a):\n    i = n - 1\n    while i >= 0:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i -= 1\n    return a\n\ndef extraKillerMoves(a):\n    i = 0\n    while i < n:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            if imprvPos(bPos, newCand):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n                a += 1\n                if m > 0:\n                    useShortcut()\n            else:\n                i += 1\n        else:\n            i += 1\n    return a\n\ndef revEKM(a):\n    i = n - 1\n    while i >= 0:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            if imprvPos(bPos, newCand):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n                a += 1\n                if m > 0:\n                    useShortcut()\n            else:\n                i -= 1\n        else:\n            i -= 1\n    return a\nt = int(input())\nfor z in range(t):\n    (n, m) = map(int, input().split())\n    oArr = list(map(int, input().split()))\n    swapMap = createMap()\n    ans = n\n    for e in range(n):\n        for f in range(n):\n            temp = oArr.copy()\n            (temp[e], temp[f]) = (temp[f], temp[e])\n            initailAns = 0\n            if e != f and checkConnection(e, f) is False:\n                initailAns += 1\n            a1 = initailAns\n            pArr = temp.copy()\n            if m > 0:\n                useShortcut()\n            a1 = regularMoves(a1)\n            a2 = initailAns\n            pArr = temp.copy()\n            if m > 0:\n                useShortcut()\n            a2 = revRM(a2)\n            ans = min(ans, a1, a2)\n    print(ans)", "def checkConnection(a, b):\n    if a not in swapMap:\n        return False\n    if b in swapMap[a]:\n        return True\n    return False\n\ndef useShortcut():\n    j = 0\n    while j < n:\n        if pArr[j] - 1 != j:\n            aPos = j\n            bPos = pArr[j] - 1\n            if checkConnection(aPos, bPos):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            else:\n                j += 1\n        else:\n            j += 1\n\ndef imprvPos(bPos, newCand):\n    if pArr[bPos] == newCand:\n        return True\n    if bPos in swapMap:\n        for pos in swapMap[bPos]:\n            if pArr[pos] == newCand:\n                (pArr[pos], pArr[bPos]) = (pArr[bPos], pArr[pos])\n                return True\n    return False\n\ndef createMap():\n    swapMap = dict()\n    for q in range(m):\n        (a, b) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        if a not in swapMap:\n            swapMap[a] = set()\n        swapMap[a].add(b)\n        if b not in swapMap:\n            swapMap[b] = set()\n        swapMap[b].add(a)\n        for p in swapMap[a]:\n            swapMap[b].add(p)\n        for p in swapMap[b]:\n            swapMap[a].add(p)\n        for p in swapMap[a]:\n            swapMap[p] = swapMap[p].union(swapMap[a])\n        for p in swapMap[b]:\n            swapMap[p] = swapMap[p].union(swapMap[b])\n    return swapMap\n\ndef killerMoves(a):\n    i = 0\n    while i < n:\n        if i in swapMap and pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i += 1\n    return a\n\ndef revKM(a):\n    i = n - 1\n    while i >= 0:\n        if i in swapMap and pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i -= 1\n    return a\n\ndef regularMoves(a):\n    i = 0\n    while i < n:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i += 1\n    return a\n\ndef revRM(a):\n    i = n - 1\n    while i >= 0:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i -= 1\n    return a\n\ndef extraKillerMoves(a):\n    i = 0\n    while i < n:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            if imprvPos(bPos, newCand):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n                a += 1\n                if m > 0:\n                    useShortcut()\n            else:\n                i += 1\n        else:\n            i += 1\n    return a\n\ndef revEKM(a):\n    i = n - 1\n    while i >= 0:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            if imprvPos(bPos, newCand):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n                a += 1\n                if m > 0:\n                    useShortcut()\n            else:\n                i -= 1\n        else:\n            i -= 1\n    return a\nt = int(input())\nfor z in range(t):\n    (n, m) = map(int, input().split())\n    oArr = list(map(int, input().split()))\n    swapMap = createMap()\n    ans = n\n    for e in range(n):\n        for f in range(n):\n            temp = oArr.copy()\n            (temp[e], temp[f]) = (temp[f], temp[e])\n            initailAns = 0\n            if e != f and checkConnection(e, f) is False:\n                initailAns += 1\n            a1 = initailAns\n            pArr = temp.copy()\n            if m > 0:\n                useShortcut()\n            a1 = killerMoves(a1)\n            a1 = regularMoves(a1)\n            a2 = initailAns\n            pArr = temp.copy()\n            if m > 0:\n                useShortcut()\n            a2 = revKM(a2)\n            a2 = revRM(a2)\n            ans = min(ans, a1, a2)\n    print(ans)", "def checkConnection(a, b):\n    if a not in swapMap:\n        return False\n    if b in swapMap[a]:\n        return True\n    return False\n\ndef useShortcut():\n    j = 0\n    while j < n:\n        if pArr[j] - 1 != j:\n            aPos = j\n            bPos = pArr[j] - 1\n            if checkConnection(aPos, bPos):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            else:\n                j += 1\n        else:\n            j += 1\n\ndef imprvPos(bPos, newCand):\n    if pArr[bPos] == newCand:\n        return True\n    if bPos in swapMap:\n        for pos in swapMap[bPos]:\n            if pArr[pos] == newCand:\n                (pArr[pos], pArr[bPos]) = (pArr[bPos], pArr[pos])\n                return True\n    return False\n\ndef createMap():\n    swapMap = dict()\n    for q in range(m):\n        (a, b) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        if a not in swapMap:\n            swapMap[a] = set()\n        swapMap[a].add(b)\n        if b not in swapMap:\n            swapMap[b] = set()\n        swapMap[b].add(a)\n        for p in swapMap[a]:\n            swapMap[b].add(p)\n        for p in swapMap[b]:\n            swapMap[a].add(p)\n        for p in swapMap[a]:\n            swapMap[p] = swapMap[p].union(swapMap[a])\n        for p in swapMap[b]:\n            swapMap[p] = swapMap[p].union(swapMap[b])\n    return swapMap\n\ndef killerMoves(a):\n    i = 0\n    while i < n:\n        if i in swapMap and pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i += 1\n    return a\n\ndef revKM(a):\n    i = n - 1\n    while i >= 0:\n        if i in swapMap and pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i -= 1\n    return a\n\ndef regularMoves(a):\n    i = 0\n    while i < n:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i += 1\n    return a\n\ndef revRM(a):\n    i = n - 1\n    while i >= 0:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i -= 1\n    return a\n\ndef extraKillerMoves(a):\n    i = 0\n    while i < n:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            if imprvPos(bPos, newCand):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n                a += 1\n                if m > 0:\n                    useShortcut()\n            else:\n                i += 1\n        else:\n            i += 1\n    return a\n\ndef revEKM(a):\n    i = n - 1\n    while i >= 0:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            if imprvPos(bPos, newCand):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n                a += 1\n                if m > 0:\n                    useShortcut()\n            else:\n                i -= 1\n        else:\n            i -= 1\n    return a\nt = int(input())\nfor z in range(t):\n    (n, m) = map(int, input().split())\n    oArr = list(map(int, input().split()))\n    swapMap = createMap()\n    ans = n\n    for e in range(n):\n        for f in range(n):\n            temp = oArr.copy()\n            (temp[e], temp[f]) = (temp[f], temp[e])\n            initailAns = 0\n            if e != f and checkConnection(e, f) is False:\n                initailAns += 1\n            a1 = initailAns\n            pArr = temp.copy()\n            if m > 0:\n                useShortcut()\n            a1 = killerMoves(a1)\n            a1 = regularMoves(a1)\n            a2 = initailAns\n            pArr = temp.copy()\n            if m > 0:\n                useShortcut()\n            a2 = revKM(a2)\n            a2 = revRM(a2)\n            ans = min(ans, a1, a2)\n    print(ans)", "def checkConnection(a, b):\n    if a not in swapMap:\n        return False\n    if b in swapMap[a]:\n        return True\n    return False\n\ndef useShortcut():\n    j = 0\n    while j < n:\n        if pArr[j] - 1 != j:\n            aPos = j\n            bPos = pArr[j] - 1\n            if checkConnection(aPos, bPos):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            else:\n                j += 1\n        else:\n            j += 1\n\ndef imprvPos(bPos, newCand):\n    if pArr[bPos] == newCand:\n        return True\n    if bPos in swapMap:\n        for pos in swapMap[bPos]:\n            if pArr[pos] == newCand:\n                (pArr[pos], pArr[bPos]) = (pArr[bPos], pArr[pos])\n                return True\n    return False\n\ndef createMap():\n    swapMap = dict()\n    for q in range(m):\n        (a, b) = map(int, input().split())\n        (a, b) = (a - 1, b - 1)\n        if a not in swapMap:\n            swapMap[a] = set()\n        swapMap[a].add(b)\n        if b not in swapMap:\n            swapMap[b] = set()\n        swapMap[b].add(a)\n        for p in swapMap[a]:\n            swapMap[b].add(p)\n        for p in swapMap[b]:\n            swapMap[a].add(p)\n        for p in swapMap[a]:\n            swapMap[p] = swapMap[p].union(swapMap[a])\n        for p in swapMap[b]:\n            swapMap[p] = swapMap[p].union(swapMap[b])\n    return swapMap\n\ndef killerMoves(a):\n    i = 0\n    while i < n:\n        if i in swapMap and pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i += 1\n    return a\n\ndef revKM(a):\n    i = n - 1\n    while i >= 0:\n        if i in swapMap and pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i -= 1\n    return a\n\ndef regularMoves(a):\n    i = 0\n    while i < n:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i += 1\n    return a\n\ndef revRM(a):\n    i = n - 1\n    while i >= 0:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            imprvPos(bPos, newCand)\n            (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n            a += 1\n            if m > 0:\n                useShortcut()\n        else:\n            i -= 1\n    return a\n\ndef extraKillerMoves(a):\n    i = 0\n    while i < n:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            if imprvPos(bPos, newCand):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n                a += 1\n                if m > 0:\n                    useShortcut()\n            else:\n                i += 1\n        else:\n            i += 1\n    return a\n\ndef revEKM(a):\n    i = n - 1\n    while i >= 0:\n        if pArr[i] - 1 != i:\n            aPos = i\n            bPos = pArr[i] - 1\n            newCand = i + 1\n            if imprvPos(bPos, newCand):\n                (pArr[aPos], pArr[bPos]) = (pArr[bPos], pArr[aPos])\n                a += 1\n                if m > 0:\n                    useShortcut()\n            else:\n                i -= 1\n        else:\n            i -= 1\n    return a\nt = int(input())\nfor z in range(t):\n    (n, m) = map(int, input().split())\n    oArr = list(map(int, input().split()))\n    swapMap = createMap()\n    ans = n\n    for e in range(n):\n        for f in range(n):\n            temp = oArr.copy()\n            (temp[e], temp[f]) = (temp[f], temp[e])\n            initailAns = 0\n            if e != f and checkConnection(e, f) is False:\n                initailAns += 1\n            a1 = initailAns\n            pArr = temp.copy()\n            if m > 0:\n                useShortcut()\n            a1 = extraKillerMoves(a1)\n            a1 = killerMoves(a1)\n            a1 = regularMoves(a1)\n            a2 = initailAns\n            pArr = temp.copy()\n            if m > 0:\n                useShortcut()\n            a2 = revEKM(a2)\n            a2 = revKM(a2)\n            a2 = revRM(a2)\n            ans = min(ans, a1, a2)\n    print(ans)", "class UnionFind:\n\n    def __init__(self, n):\n        self.size = [1 for _ in range(n)]\n        self.parent = [i for i in range(n)]\n\n    def find(self, i):\n        while self.parent[i] != self.parent[self.parent[i]]:\n            self.parent[i] = self.parent[self.parent[i]]\n        return self.parent[i]\n\n    def union(self, i, j):\n        (rooti, rootj) = (self.find(i), self.find(j))\n        if rooti == rootj:\n            return\n        if self.size[rooti] > self.size[rootj]:\n            (rooti, rootj) = (rootj, rooti)\n        self.parent[rooti] = rootj\n        self.size[rootj] += self.size[rooti]\n\ndef solve(N, M, nums, pairs):\n    nums = [n - 1 for n in nums]\n    pairs = [[x - 1, y - 1] for (x, y) in pairs]\n    uf = UnionFind(N)\n    for (x, y) in pairs:\n        uf.union(x, y)\n    group = [uf.find(i) for i in range(N)]\n    res = N * N\n\n    def valid(val, i):\n        return group[i] == group[val]\n\n    def swap(i, j):\n        (nums[i], nums[j]) = (nums[j], nums[i])\n\n    def search(i, cnt):\n        nonlocal res\n        if i >= N - 1:\n            res = min(res, cnt)\n            return\n        if valid(nums[i], i):\n            search(i + 1, cnt)\n            return\n        for j in range(i + 1, N):\n            if valid(nums[j], i):\n                swap(i, j)\n                search(i + 1, cnt + 1)\n                swap(i, j)\n    search(0, 0)\n    return res\n\ndef main():\n    from sys import stdin\n    T = int(stdin.readline().strip())\n    for t in range(T):\n        (N, M) = list(map(int, stdin.readline().strip().split()))\n        nums = list(map(int, stdin.readline().strip().split()))\n        pairs = [list(map(int, stdin.readline().strip().split())) for _ in range(M)]\n        out = solve(N, M, nums, pairs)\n        print(out)\nmain()", "from collections import defaultdict\n\ndef minSwaps(arr):\n    n = len(arr)\n    arrpos = [*enumerate(arr)]\n    arrpos.sort(key=lambda it: it[1])\n    vis = {k: False for k in range(n)}\n    ans = 0\n    for i in range(n):\n        if vis[i] or arrpos[i][0] == i:\n            continue\n        cycle_size = 0\n        j = i\n        while not vis[j]:\n            vis[j] = True\n            j = arrpos[j][0]\n            cycle_size += 1\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def DFSUtil(self, v, visited, shanik):\n        visited[v] = True\n        shanik.append(v)\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited, shanik)\n\n    def DFS(self, v, shanik):\n        visited = [False] * (max(self.graph) + 1)\n        self.DFSUtil(v, visited, shanik)\njaval = 1\nif javal == 1:\n    T = int(input())\n    for _ in range(T):\n        (n, m) = input().split()\n        n = int(n)\n        m = int(m)\n        li = []\n        a = input().split()\n        aukat_wali_jagah = [0] * n\n        for i in range(n):\n            a[i] = int(a[i])\n            aukat_wali_jagah[a[i] - 1] = i\n        g = Graph()\n        for i in range(m):\n            shanik = input().split()\n            li.append([int(shanik[0]), int(shanik[1])])\n        li.sort()\n        for i in range(m):\n            shanik = li[i]\n            g.addEdge(int(shanik[0]) - 1, int(shanik[1]) - 1)\n            g.addEdge(int(shanik[1]) - 1, int(shanik[0]) - 1)\n        flag = 0\n        for i in range(n):\n            g.addEdge(i, i)\n        dost = []\n        for i in range(n):\n            shanik = []\n            flag = 0\n            for j in range(len(dost)):\n                if i in dost[j]:\n                    flag = 1\n                    break\n            if flag == 0:\n                g.DFS(i, shanik)\n                dost.append(shanik)\n        if len(dost) == 1:\n            print('0')\n        elif m == 0:\n            swaps = minSwaps(a)\n            print(swaps)\n        else:\n            badlaw = []\n            dontknow = []\n            for i in range(n):\n                for j in range(len(dost)):\n                    if i in dost[j]:\n                        shanik1 = j\n                    if aukat_wali_jagah[i] in dost[j]:\n                        shanik2 = j\n                if shanik1 != shanik2:\n                    badlaw.append([shanik1, shanik2])\n                dontknow.append([shanik1, shanik2])\n            parivartan = []\n            samay1 = 0\n            for i in range(len(badlaw)):\n                if badlaw[i] != []:\n                    if [badlaw[i][1], badlaw[i][0]] in badlaw:\n                        samay1 += 1\n                        t2 = badlaw.index([badlaw[i][1], badlaw[i][0]])\n                        badlaw[i] = []\n                        badlaw[t2] = []\n                    else:\n                        parivartan.append(badlaw[i])\n            if len(parivartan) > 0:\n                samay = samay1\n                ginna = 0\n                t1 = len(parivartan)\n                parivartan.sort()\n                for i in range(t1):\n                    palpal = parivartan[i][0]\n                    palpal2 = parivartan[i][1]\n                    flag = 0\n                    flag1 = 0\n                    nikal_l = []\n                    for k1 in range(t1):\n                        for j in range(t1):\n                            if parivartan[j][0] == palpal2:\n                                palpal2 = parivartan[j][1]\n                                flag += 1\n                                nikal_l.append(parivartan[j])\n                            if flag > 2:\n                                break\n                            if palpal2 == palpal:\n                                flag1 = 1\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        ginna += flag\n                        nikal_l.append(parivartan[i])\n                        for i in range(len(nikal_l)):\n                            q = parivartan.index(nikal_l[i])\n                            parivartan[q] = [-1, -2]\n                samay += ginna\n                iskimaaka = []\n                for i in range(t1):\n                    if parivartan[i] != [-1, -2]:\n                        iskimaaka.append(parivartan[i])\n                parivartan = iskimaaka\n                t1 = len(parivartan)\n                parivartan.sort()\n                ginna = 0\n                for i in range(t1):\n                    palpal = parivartan[i][0]\n                    palpal2 = parivartan[i][1]\n                    flag = 0\n                    flag1 = 0\n                    nikal_l = []\n                    for k1 in range(t1):\n                        for k2 in range(t1):\n                            for j in range(t1):\n                                if parivartan[j][0] == palpal2:\n                                    palpal2 = parivartan[j][1]\n                                    flag += 1\n                                    nikal_l.append(parivartan[j])\n                                if flag > 3:\n                                    break\n                                if palpal2 == palpal:\n                                    flag1 = 1\n                                    break\n                            if flag1 == 1:\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        ginna += flag\n                        nikal_l.append(parivartan[i])\n                        for i in range(len(nikal_l)):\n                            q = parivartan.index(nikal_l[i])\n                            parivartan[q] = [-1, -2]\n                samay += ginna\n                iskimaaka = []\n                for i in range(t1):\n                    if parivartan[i] != [-1, -2]:\n                        iskimaaka.append(parivartan[i])\n                parivartan = iskimaaka\n                t1 = len(parivartan)\n                parivartan.sort()\n                ginna = 0\n                for i in range(t1):\n                    palpal = parivartan[i][0]\n                    palpal2 = parivartan[i][1]\n                    flag = 0\n                    flag1 = 0\n                    nikal_l = []\n                    for k1 in range(t1):\n                        for k2 in range(t1):\n                            for k3 in range(t1):\n                                for j in range(t1):\n                                    if parivartan[j][0] == palpal2:\n                                        palpal2 = parivartan[j][1]\n                                        flag += 1\n                                        nikal_l.append(parivartan[j])\n                                    if flag > 4:\n                                        break\n                                    if palpal2 == palpal:\n                                        flag1 = 1\n                                        break\n                                if flag1 == 1:\n                                    break\n                            if flag1 == 1:\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        ginna += flag\n                        nikal_l.append(parivartan[i])\n                        for i in range(len(nikal_l)):\n                            q = parivartan.index(nikal_l[i])\n                            parivartan[q] = [-1, -2]\n                samay += ginna\n                iskimaaka = []\n                for i in range(t1):\n                    if parivartan[i] != [-1, -2]:\n                        iskimaaka.append(parivartan[i])\n                parivartan = iskimaaka\n                t1 = len(parivartan)\n                ginna = 0\n                for i in range(t1):\n                    palpal = parivartan[i][0]\n                    palpal2 = parivartan[i][1]\n                    flag = 0\n                    flag1 = 0\n                    if parivartan[i] != [-1, -2]:\n                        for k1 in range(t1):\n                            for k2 in range(t1):\n                                for k3 in range(t1):\n                                    for k4 in range(t1):\n                                        for k5 in range(t1):\n                                            for k6 in range(t1):\n                                                for k7 in range(t1):\n                                                    for k8 in range(t1):\n                                                        for k9 in range(t1):\n                                                            for k10 in range(t1):\n                                                                for k11 in range(t1):\n                                                                    for k12 in range(t1):\n                                                                        for k13 in range(t1):\n                                                                            for k14 in range(t1):\n                                                                                for j in range(t1):\n                                                                                    if parivartan[j][0] == palpal2:\n                                                                                        palpal2 = parivartan[j][1]\n                                                                                        flag += 1\n                                                                                        parivartan[j] = [-1, -2]\n                                                                                    if palpal2 == palpal:\n                                                                                        flag1 = 1\n                                                                                        break\n                                                                                if flag1 == 1:\n                                                                                    break\n                                                                            if flag1 == 1:\n                                                                                break\n                                                                        if flag1 == 1:\n                                                                            break\n                                                                    if flag1 == 1:\n                                                                        break\n                                                                if flag1 == 1:\n                                                                    break\n                                                            if flag1 == 1:\n                                                                break\n                                                        if flag1 == 1:\n                                                            break\n                                                    if flag1 == 1:\n                                                        break\n                                                if flag1 == 1:\n                                                    break\n                                            if flag1 == 1:\n                                                break\n                                        if flag1 == 1:\n                                            break\n                                    if flag1 == 1:\n                                        break\n                                if flag1 == 1:\n                                    break\n                            if flag1 == 1:\n                                break\n                    if flag1 == 1:\n                        ginna += flag\n                    parivartan[i] = [-1, -2]\n                samay = samay + ginna\n            else:\n                samay = samay1\n            print(samay)", "from collections import defaultdict\n\ndef minSwaps(arr):\n    n = len(arr)\n    arrpos = [*enumerate(arr)]\n    arrpos.sort(key=lambda it: it[1])\n    vis = {k: False for k in range(n)}\n    ans = 0\n    for i in range(n):\n        if vis[i] or arrpos[i][0] == i:\n            continue\n        cycle_size = 0\n        j = i\n        while not vis[j]:\n            vis[j] = True\n            j = arrpos[j][0]\n            cycle_size += 1\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans\n\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def DFSUtil(self, v, visited, temp):\n        visited[v] = True\n        temp.append(v)\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited, temp)\n\n    def DFS(self, v, temp):\n        visited = [False] * (max(self.graph) + 1)\n        self.DFSUtil(v, visited, temp)\nT = int(input())\nfor _ in range(T):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    li = []\n    a = input().split()\n    indices = [0] * n\n    for i in range(n):\n        a[i] = int(a[i])\n        indices[a[i] - 1] = i\n    g = Graph()\n    for i in range(m):\n        temp = input().split()\n        li.append([int(temp[0]), int(temp[1])])\n    li.sort()\n    for i in range(m):\n        temp = li[i]\n        g.addEdge(int(temp[0]) - 1, int(temp[1]) - 1)\n        g.addEdge(int(temp[1]) - 1, int(temp[0]) - 1)\n    flag = 0\n    for i in range(n):\n        g.addEdge(i, i)\n    groups = []\n    for i in range(n):\n        temp = []\n        flag = 0\n        for j in range(len(groups)):\n            if i in groups[j]:\n                flag = 1\n                break\n        if flag == 0:\n            g.DFS(i, temp)\n            groups.append(temp)\n    if len(groups) == 1:\n        print('0')\n    elif m == 0:\n        swaps = minSwaps(a)\n        print(swaps)\n    else:\n        change = []\n        dontknow = []\n        for i in range(n):\n            for j in range(len(groups)):\n                if i in groups[j]:\n                    temp1 = j\n                if indices[i] in groups[j]:\n                    temp2 = j\n            if temp1 != temp2:\n                change.append([temp1, temp2])\n            dontknow.append([temp1, temp2])\n        change1 = []\n        time1 = 0\n        for i in range(len(change)):\n            if change[i] != []:\n                if [change[i][1], change[i][0]] in change:\n                    time1 += 1\n                    t2 = change.index([change[i][1], change[i][0]])\n                    change[i] = []\n                    change[t2] = []\n                else:\n                    change1.append(change[i])\n        if len(change1) > 0:\n            time = time1\n            counting = 0\n            t1 = len(change1)\n            change1.sort()\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                removing = []\n                for k1 in range(t1):\n                    for j in range(t1):\n                        if change1[j][0] == tempss:\n                            tempss = change1[j][1]\n                            flag += 1\n                            removing.append(change1[j])\n                        if flag > 2:\n                            break\n                        if tempss == temporary:\n                            flag1 = 1\n                            break\n                    if flag1 == 1:\n                        break\n                if flag1 == 1:\n                    counting += flag\n                    removing.append(change1[i])\n                    for i in range(len(removing)):\n                        q = change1.index(removing[i])\n                        change1[q] = [-1, -2]\n            time += counting\n            qwert = []\n            for i in range(t1):\n                if change1[i] != [-1, -2]:\n                    qwert.append(change1[i])\n            change1 = qwert\n            t1 = len(change1)\n            change1.sort()\n            counting = 0\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                removing = []\n                for k1 in range(t1):\n                    for k2 in range(t1):\n                        for j in range(t1):\n                            if change1[j][0] == tempss:\n                                tempss = change1[j][1]\n                                flag += 1\n                                removing.append(change1[j])\n                            if flag > 3:\n                                break\n                            if tempss == temporary:\n                                flag1 = 1\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        break\n                if flag1 == 1:\n                    counting += flag\n                    removing.append(change1[i])\n                    for i in range(len(removing)):\n                        q = change1.index(removing[i])\n                        change1[q] = [-1, -2]\n            time += counting\n            qwert = []\n            for i in range(t1):\n                if change1[i] != [-1, -2]:\n                    qwert.append(change1[i])\n            change1 = qwert\n            t1 = len(change1)\n            change1.sort()\n            counting = 0\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                removing = []\n                for k1 in range(t1):\n                    for k2 in range(t1):\n                        for k3 in range(t1):\n                            for j in range(t1):\n                                if change1[j][0] == tempss:\n                                    tempss = change1[j][1]\n                                    flag += 1\n                                    removing.append(change1[j])\n                                if flag > 4:\n                                    break\n                                if tempss == temporary:\n                                    flag1 = 1\n                                    break\n                            if flag1 == 1:\n                                break\n                        if flag1 == 1:\n                            break\n                    if flag1 == 1:\n                        break\n                if flag1 == 1:\n                    counting += flag\n                    removing.append(change1[i])\n                    for i in range(len(removing)):\n                        q = change1.index(removing[i])\n                        change1[q] = [-1, -2]\n            time += counting\n            qwert = []\n            for i in range(t1):\n                if change1[i] != [-1, -2]:\n                    qwert.append(change1[i])\n            change1 = qwert\n            t1 = len(change1)\n            counting = 0\n            for i in range(t1):\n                temporary = change1[i][0]\n                tempss = change1[i][1]\n                flag = 0\n                flag1 = 0\n                if change1[i] != [-1, -2]:\n                    for k1 in range(t1):\n                        for k2 in range(t1):\n                            for k3 in range(t1):\n                                for k4 in range(t1):\n                                    for k5 in range(t1):\n                                        for k6 in range(t1):\n                                            for k7 in range(t1):\n                                                for k8 in range(t1):\n                                                    for k9 in range(t1):\n                                                        for k10 in range(t1):\n                                                            for k11 in range(t1):\n                                                                for k12 in range(t1):\n                                                                    for k13 in range(t1):\n                                                                        for k14 in range(t1):\n                                                                            for j in range(t1):\n                                                                                if change1[j][0] == tempss:\n                                                                                    tempss = change1[j][1]\n                                                                                    flag += 1\n                                                                                    change1[j] = [-1, -2]\n                                                                                if tempss == temporary:\n                                                                                    flag1 = 1\n                                                                                    break\n                                                                            if flag1 == 1:\n                                                                                break\n                                                                        if flag1 == 1:\n                                                                            break\n                                                                    if flag1 == 1:\n                                                                        break\n                                                                if flag1 == 1:\n                                                                    break\n                                                            if flag1 == 1:\n                                                                break\n                                                        if flag1 == 1:\n                                                            break\n                                                    if flag1 == 1:\n                                                        break\n                                                if flag1 == 1:\n                                                    break\n                                            if flag1 == 1:\n                                                break\n                                        if flag1 == 1:\n                                            break\n                                    if flag1 == 1:\n                                        break\n                                if flag1 == 1:\n                                    break\n                            if flag1 == 1:\n                                break\n                        if flag1 == 1:\n                            break\n                if flag1 == 1:\n                    counting += flag\n                change1[i] = [-1, -2]\n            time = time + counting\n        else:\n            time = time1\n        print(time)", "import math\nimport collections\nfrom sys import stdin, stdout\nT = int(stdin.readline())\n\ndef solve(x, y, i, j, ans):\n    tmp = y[i]\n    y[i] = y[j]\n    y[j] = tmp\n    l = len(x)\n    if x == y:\n        return ans\n    finans = 10 ** 6\n    res = False\n    for i in range(l):\n        if x[i] == y[i]:\n            continue\n        for j in range(l):\n            if y[j] == x[i] and x[j] != y[j]:\n                res = True\n                finans = min(finans, solve(x.copy(), y.copy(), i, j, ans + 1))\n        if res:\n            break\n    return finans\nfor _ in range(T):\n    (n, m) = list(map(int, stdin.readline().split()))\n    g = []\n    for i in range(n + 1):\n        g.append([])\n    p = [0] + list(map(int, stdin.readline().split()))\n    for i in range(m):\n        (x, y) = list(map(int, stdin.readline().split()))\n        g[x].append(y)\n        g[y].append(x)\n    exp = {}\n    num = {}\n    t = 0\n    for i in range(1, n + 1, 1):\n        if i in exp:\n            continue\n        a = [i]\n        while a:\n            u = a.pop()\n            num[u] = t\n            exp[u] = True\n            for v in g[u]:\n                if v not in exp:\n                    a.append(v)\n        t += 1\n    x = [-1]\n    y = [-1]\n    for i in range(1, n + 1, 1):\n        y.append(num[p[i]])\n        x.append(num[i])\n    ans = 0\n    l = len(x)\n    res = True\n    while res:\n        res = False\n        for i in range(l):\n            if x[i] == y[i]:\n                continue\n            yj = x[i]\n            xj = y[i]\n            for j in range(i + 1, l, 1):\n                if y[j] == yj and x[j] == xj:\n                    y[i] = x[i]\n                    y[j] = x[j]\n                    ans += 1\n                    res = True\n                    break\n            if res:\n                break\n    ans = solve(x.copy(), y.copy(), 0, 0, ans)\n    print(ans)", "papa_array = []\ncg = []\n\ndef spapa(kx):\n    if papa_array[kx] != kx:\n        sl = spapa(papa_array[kx])\n        papa_array[kx] = sl\n    return papa_array[kx]\n\ndef add_edge(kx, ky):\n    sx = spapa(kx)\n    sy = spapa(ky)\n    if sx != sy:\n        if cg[sx] == cg[sy]:\n            papa_array[sy] = sx\n            cg[sx] += 1\n        elif cg[sx] > cg[sy]:\n            papa_array[sy] = sx\n        else:\n            papa_array[sx] = sy\n\ndef check_empty(c):\n    cnt = 0\n    for i in c:\n        for j in i:\n            cnt += 1\n    if cnt > 0:\n        return False\n    else:\n        return True\nfor _ in range(int(input())):\n    (n, m) = [int(kx) for kx in input().split()]\n    arr = [int(kx) for kx in input().split()]\n    papa_array = []\n    cg = [0] * (n + 1)\n    for i in range(n + 1):\n        papa_array.append(i)\n    for _i in range(m):\n        (u, v) = [int(kx) for kx in input().split()]\n        add_edge(u, v)\n    c = []\n    r = []\n    for i in range(n):\n        c.append([])\n        r.append([])\n    for i in range(n):\n        r[spapa(i + 1) - 1].append(i + 1)\n    for i in range(n):\n        rem = []\n        for j in r[i]:\n            c[i].append(arr[j - 1])\n    for i in range(n):\n        rem = []\n        for kz1 in r[i]:\n            if kz1 in c[i]:\n                rem.append(kz1)\n        for kz1 in rem:\n            c[i].remove(kz1)\n            r[i].remove(kz1)\n    ans = 0\n    while check_empty(c) == False:\n        for i in range(n - 1):\n            j = i + 1\n            while j < n:\n                idx1 = idx2 = -1\n                for kz1 in r[i]:\n                    if kz1 in c[j]:\n                        idx1 = kz1\n                for kz1 in r[j]:\n                    if kz1 in c[i]:\n                        idx2 = kz1\n                if idx1 < 0 or idx2 < 0:\n                    j += 1\n                    continue\n                r[i].remove(idx1)\n                c[j].remove(idx1)\n                r[j].remove(idx2)\n                c[i].remove(idx2)\n                ans += 1\n                j -= 1\n        if check_empty(c) == False:\n            j = 0\n            ssz = 10000\n            for i in range(n):\n                for k in c[i]:\n                    if ssz > len(c[i]):\n                        j = i\n                        ssz = len(c[i])\n                        break\n            kz1 = r[j][0]\n            kz2 = c[j][0]\n            iiiii = 0\n            for i in range(n):\n                if i != j:\n                    if kz1 in c[i]:\n                        iiiii = i\n            r[j].remove(kz1)\n            c[j].remove(kz2)\n            c[iiiii].remove(kz1)\n            c[iiiii].append(kz2)\n            ans += 1\n    print(ans)", "from collections import defaultdict\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def DFSUtil(self, v, visited, ans1):\n        visited[v] = True\n        ans1.append(v)\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited, ans1)\n\n    def fillOrder(self, v, visited, stack):\n        visited[v] = True\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.fillOrder(i, visited, stack)\n        stack = stack.append(v)\n\n    def getTranspose(self):\n        g = Graph(self.V)\n        for i in self.graph:\n            for j in self.graph[i]:\n                g.addEdge(j, i)\n        return g\n\n    def printSCCs(self):\n        stack = []\n        visited = [False] * self.V\n        for i in range(self.V):\n            if visited[i] == False:\n                self.fillOrder(i, visited, stack)\n        gr = self.getTranspose()\n        visited = [False] * self.V\n        while stack:\n            i = stack.pop()\n            if visited[i] == False:\n                ans1 = []\n                gr.DFSUtil(i, visited, ans1)\n                ans.append(ans1)\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m) = [int(i) for i in input().split()]\n    p = [int(i) for i in input().split()]\n    g = Graph(n + 1)\n    for i in range(m):\n        (aa, bb) = [int(i) for i in input().split()]\n        g.addEdge(aa, bb)\n        g.addEdge(bb, aa)\n    ans = []\n    g.printSCCs()\n    ans.remove([0])\n    a = p[:]\n    a.sort()\n    count = 0\n    temp = 1\n    connected = [-1] * (n + 1)\n    for i in range(len(ans)):\n        for j in ans[i]:\n            connected[j] = i\n    while temp == 1:\n        temp = 0\n        for i in range(len(p)):\n            if p[i] != i + 1:\n                for scc in ans:\n                    if i + 1 in scc and p[i] in scc:\n                        temp = 1\n                        x = p[p[i] - 1]\n                        p[p[i] - 1] = p[i]\n                        p[i] = x\n    temp = 0\n    while a != p:\n        for i in range(len(p)):\n            temp = 0\n            if p[i] != i + 1:\n                for scc in ans:\n                    if i + 1 in scc and p[i] in scc:\n                        x = p[p[i] - 1]\n                        p[p[i] - 1] = p[i]\n                        p[i] = x\n        temp = 0\n        for i in range(len(p)):\n            if p[i] != i + 1:\n                for scc in ans:\n                    if i + 1 in scc and p[p[i] - 1] in scc:\n                        count += 1\n                        x = p[p[i] - 1]\n                        p[p[i] - 1] = p[i]\n                        p[i] = x\n                        temp = 1\n                        break\n                if temp == 1:\n                    break\n        for i in range(len(p)):\n            temp = 0\n            if p[i] != i + 1:\n                for scc in ans:\n                    if i + 1 in scc and p[i] in scc:\n                        x = p[p[i] - 1]\n                        p[p[i] - 1] = p[i]\n                        p[i] = x\n        for i in range(len(p)):\n            if p[i] != i + 1:\n                for scc in ans:\n                    if i + 1 in scc:\n                        comp1 = scc\n                    if p[i] in scc:\n                        comp2 = scc\n                for j in comp2:\n                    if p[j - 1] in comp1:\n                        count += 1\n                        first = p[i]\n                        second = p[j - 1]\n                        change = p[p[i] - 1]\n                        temp = p[second - 1]\n                        p[i] = temp\n                        p[j - 1] = change\n                        p[first - 1] = first\n                        p[second - 1] = second\n                        break\n        for i in range(len(p)):\n            temp = 0\n            if p[i] != i + 1:\n                for scc in ans:\n                    if i + 1 in scc and p[p[i] - 1] in scc:\n                        count += 1\n                        x = p[p[i] - 1]\n                        p[p[i] - 1] = p[i]\n                        p[i] = x\n                        temp = 1\n                        break\n                if temp == 1:\n                    break\n        for i in range(len(p)):\n            temp = 0\n            if p[i] != i + 1:\n                for scc in ans:\n                    if i + 1 in scc and p[i] in scc:\n                        x = p[p[i] - 1]\n                        p[p[i] - 1] = p[i]\n                        p[i] = x\n        check = [0] * len(ans)\n        for i in range(len(p)):\n            temp = 0\n            if p[i] != i + 1:\n                check[connected[p[i]]] += 1\n        zeroes = check.count(0)\n        check2 = check[:]\n        for i in range(zeroes):\n            check2.remove(0)\n        if len(check2) > 0:\n            count += 1\n            mini = min(check2)\n            miniindex = check.index(mini)\n            comp = ans[miniindex]\n            temp = 0\n            for i in comp:\n                if p[i - 1] != i:\n                    second = p[i - 1]\n                    for j in range(len(p)):\n                        if p[j] == i:\n                            first = p[j]\n                            p[i - 1] = first\n                            p[j] = second\n                            temp = 1\n                            break\n                if temp == 1:\n                    break\n    print(count)", "for _ in range(int(input())):\n    res = 0\n    (n, m) = map(int, input().split())\n    p = [0] + list(map(int, input().split()))\n    cor = [sorted(list(map(int, input().split()))) for i in range(m)]\n    tree = [[] for i in p]\n    for (i, j) in cor:\n        tree[i].append(j)\n        tree[j].append(i)\n    lis = sorted([p[i] for i in range(1, n + 1)])\n    vis = [0 for i in range(n)]\n    pic = []\n    for j in range(len(lis)):\n        if vis[j]:\n            continue\n        pack = [lis[j]]\n        for k in pack:\n            for l in tree[k]:\n                if l in lis and l not in pack:\n                    pack.append(l)\n                    vis[lis.index(l)] = 1\n        pic.append(pack)\n    PIC = len(pic)\n    lno = [-1 for i in p]\n    for j in range(PIC):\n        for k in pic[j]:\n            lno[k] = j\n    exc = [[0 for i in range(PIC)] for i in range(PIC)]\n    for j in range(PIC):\n        for k in pic[j]:\n            exc[j][lno[p[k]]] += 1\n    for j in range(PIC):\n        exc[j][j] = 0\n    tot = 0\n    for j in range(PIC):\n        for k in range(j + 1, PIC):\n            l = min(exc[j][k], exc[k][j])\n            tot += exc[j][k] + exc[k][j]\n    while tot > 0:\n        (J, K) = (-1, -1)\n        for j in range(PIC):\n            for k in range(PIC):\n                if exc[j][k]:\n                    (J, K) = (j, k)\n                    break\n            if J != -1:\n                break\n        I = J\n        All = [[J, K]]\n        wor = []\n        for j in All:\n            flag = 0\n            for k in range(PIC):\n                if exc[j[-1]][k]:\n                    if k == I:\n                        j.append(I)\n                        wor = j\n                        flag = 1\n                        break\n                    if k in j:\n                        continue\n                    news = [i for i in j]\n                    news.append(k)\n                    All.append(news)\n            if flag:\n                break\n        for i in range(len(wor) - 1):\n            exc[wor[i]][wor[i + 1]] -= 1\n        res += len(wor) - 2\n        tot -= len(wor) - 1\n    print(res)", "import random\nvisited = []\ngroup = []\ngraph = {}\npendingSwaps = {}\ntotalSwitches = 0\npendingSwitches = 0\ncountTypes = 0\n\ndef bfs(root, nodeGroup):\n    visited[root] = 1\n    group[root] = nodeGroup\n    queue = []\n    queue.append(root)\n    while queue:\n        s = queue.pop(0)\n        for neighbour in graph[s]:\n            if visited[neighbour] != 1:\n                visited[neighbour] = 1\n                group[neighbour] = nodeGroup\n                queue.append(neighbour)\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split(' ')))\n    arr = list(map(int, input().split(' ')))\n    graph = {}\n    pendingSwaps = {}\n    visited = [0 for i in range(n)]\n    group = [-1 for i in range(n)]\n    for i in range(n):\n        graph[i] = []\n    for i in range(m):\n        (x, y) = list(map(int, input().split(' ')))\n        graph[x - 1].append(y - 1)\n        graph[y - 1].append(x - 1)\n    countTypes = 0\n    for i in range(n):\n        if visited[i] == 0:\n            bfs(i, countTypes)\n            countTypes += 1\n    totalSwitches = 0\n    pendingSwitches = 0\n    for i in range(n):\n        if group[i] != group[arr[i] - 1]:\n            if pendingSwaps.get((group[i], group[arr[i] - 1])):\n                if pendingSwaps[group[i], group[arr[i] - 1]] == 1:\n                    del pendingSwaps[group[i], group[arr[i] - 1]]\n                else:\n                    pendingSwaps[group[i], group[arr[i] - 1]] -= 1\n                totalSwitches += 1\n                pendingSwitches -= 1\n            else:\n                if pendingSwaps.get((group[arr[i] - 1], group[i])):\n                    pendingSwaps[group[arr[i] - 1], group[i]] += 1\n                else:\n                    pendingSwaps[group[arr[i] - 1], group[i]] = 1\n                pendingSwitches += 1\n    numLoopsTracker = [[] for i in range(countTypes)]\n    numLoopsLeft = [0 for i in range(countTypes)]\n    for i in pendingSwaps.keys():\n        numLoopsTracker[i[0]].extend([i[1]] * pendingSwaps[i])\n        numLoopsLeft[i[0]] += pendingSwaps[i]\n    remainingNodes = []\n    for i in range(countTypes):\n        if numLoopsLeft[i] > 0:\n            remainingNodes.append(i)\n    remainingNodes = sorted(remainingNodes, key=lambda x: numLoopsLeft[x], reverse=True)\n    for i in range(countTypes):\n        random.shuffle(numLoopsTracker[i])\n    countCycles = 0\n    while remainingNodes != []:\n        remainingNodes = sorted(remainingNodes, key=lambda x: numLoopsLeft[x], reverse=True)\n        countCycles += 1\n        initialEle = remainingNodes[0]\n        currentEle = numLoopsTracker[initialEle][0]\n        buffer = [initialEle]\n        while currentEle != initialEle and currentEle not in buffer:\n            tempEle = numLoopsTracker[currentEle][0]\n            buffer.append(currentEle)\n            currentEle = tempEle\n        startPos = buffer.index(currentEle)\n        for i in buffer[startPos:]:\n            numLoopsTracker[i].pop(0)\n            numLoopsLeft[i] -= 1\n            if numLoopsLeft[i] == 0:\n                remainingNodes.remove(i)\n    print(totalSwitches - countCycles + pendingSwitches)"]