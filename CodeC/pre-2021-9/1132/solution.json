["from itertools import permutations\nfrom bisect import bisect_left as bl\nfor __ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split()))\n    li.sort()\n    li.pop(0)\n    t0 = []\n    s = []\n    while li:\n        t1 = []\n        c = li.pop(0)\n        for i in t0:\n            li.pop(bl(li, c + i))\n            t1.append(c + i)\n        t1.append(c)\n        t0 = t0 + list(t1)\n        s.append(c)\n    for i in range(n):\n        print(s[i], end=' ')\n    print()", "from itertools import permutations\nfrom bisect import bisect_left as bl\nfor __ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split()))\n    li.sort()\n    li.pop(0)\n    t0 = []\n    s = []\n    while li:\n        t1 = []\n        c = li.pop(0)\n        for i in t0:\n            li.pop(bl(li, c + i))\n            t1.append(c + i)\n        t1.append(c)\n        t0 = t0 + list(t1)\n        s.append(c)\n    for i in range(n):\n        print(s[i], end=' ')\n    print()", "import heapq\nimport math\nfor _ in range(int(input())):\n    required_array_length = int(input())\n    array = []\n    subsets_sums = [int(num) for num in input().split()]\n    subsets_sums.sort()\n    sums_queue = []\n    previous_combinations_sums = []\n    skip_num = subsets_sums.count(0)\n    array.extend([0] * int(math.log2(skip_num)))\n    current_sum = 0\n    idx = skip_num\n    while len(array) < required_array_length:\n        candidate = subsets_sums[idx]\n        idx += 1 * skip_num\n        if current_sum == 0 and len(sums_queue) > 0:\n            current_sum = heapq.heappop(sums_queue)\n        if candidate == current_sum:\n            current_sum = 0\n            continue\n        array.append(candidate)\n        for i in range(len(previous_combinations_sums)):\n            new_sum = previous_combinations_sums[i] + candidate\n            heapq.heappush(sums_queue, new_sum)\n            previous_combinations_sums.append(new_sum)\n        previous_combinations_sums.append(candidate)\n        if current_sum != 0:\n            heapq.heappush(sums_queue, current_sum)\n            current_sum = 0\n    print(*array)", "from sys import stdin, stdout\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    ans = []\n    hp = {}\n    dups = {}\n    a.sort()\n    for i in range(1, len(a)):\n        if a[i] in hp and hp[a[i]] > 0:\n            hp[a[i]] -= 1\n        else:\n            new_subsets = []\n            for el in dups:\n                new_subsets.append((el + a[i], dups[el]))\n            for el in ans:\n                new_subsets.append((el + a[i], 1))\n            for el in new_subsets:\n                dups[el[0]] = dups.get(el[0], 0) + el[1]\n                hp[el[0]] = hp.get(el[0], 0) + el[1]\n            ans.append(a[i])\n            if len(ans) == n:\n                break\n    print(*ans)", "for _ in range(int(input())):\n    n = int(input())\n    n2 = 2 ** n\n    sums = []\n    ans = []\n    rem = {}\n    a = list(map(int, input().split()))\n    a.sort()\n    for i in range(1, n2):\n        if a[i] in rem and rem[a[i]] != 0:\n            rem[a[i]] -= 1\n        else:\n            temp = []\n            for j in sums:\n                temp.append(j + a[i])\n            for j in ans:\n                temp.append(j + a[i])\n            for j in temp:\n                if j not in rem:\n                    rem[j] = 0\n                rem[j] += 1\n                sums.append(j)\n            ans.append(a[i])\n            if len(ans) == n:\n                break\n    for i in ans[:-1]:\n        print(i, end=' ')\n    print(ans[-1])", "from collections import OrderedDict\ntt = int(input())\nfor i in range(tt):\n    n = int(input())\n    d = {}\n    a = list(map(int, input().split()))\n    for x in a:\n        if x == 0:\n            continue\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    d = OrderedDict(sorted(d.items()))\n    l = [0]\n    for i in range(n):\n        c = next(iter(d))\n        print(c, end=' ')\n        l1 = l\n        for e in list(l1):\n            if d[e + c] == 1:\n                del d[e + c]\n            else:\n                d[e + c] -= 1\n            l.append(c + e)\n    print()", "for _ in range(int(input())):\n    n = int(input())\n    n2 = 2 ** n\n    sums = []\n    ans = []\n    rem = {}\n    a = list(map(int, input().split()))\n    a.sort()\n    for i in range(1, n2):\n        if a[i] in rem and rem[a[i]] != 0:\n            rem[a[i]] -= 1\n        else:\n            temp = []\n            for j in sums:\n                temp.append(j + a[i])\n            for j in ans:\n                temp.append(j + a[i])\n            for j in temp:\n                if j not in rem:\n                    rem[j] = 0\n                rem[j] += 1\n                sums.append(j)\n            ans.append(a[i])\n            if len(ans) == n:\n                break\n    for i in ans[:-1]:\n        print(i, end=' ')\n    print(ans[-1])", "for _ in range(int(input())):\n    n = int(input())\n    n2 = 2 ** n\n    sums = []\n    ans = []\n    rem = {}\n    a = list(map(int, input().split()))\n    a.sort()\n    for i in range(1, n2):\n        if a[i] in rem and rem[a[i]] != 0:\n            rem[a[i]] -= 1\n        else:\n            temp = []\n            for j in sums:\n                temp.append(j + a[i])\n            for j in ans:\n                temp.append(j + a[i])\n            for j in temp:\n                if j not in rem:\n                    rem[j] = 0\n                rem[j] += 1\n                sums.append(j)\n            ans.append(a[i])\n            if len(ans) == n:\n                break\n    print(*ans)", "for _ in range(int(input())):\n    n = int(input())\n    arr = [int(c) for c in input().split()]\n    subset = []\n    arr.sort()\n    p = []\n    ans = []\n    x = 1\n    while len(ans) != n:\n        while len(p) > 0 and p[0] < arr[x]:\n            p.pop(0)\n        if p and p[0] == arr[x]:\n            p.pop(0)\n        else:\n            ans.append(arr[x])\n            subset.append(arr[x])\n            for i in range(len(subset) - 1):\n                subset.append(subset[i] + arr[x])\n                p.append(subset[i] + arr[x])\n        p.sort()\n        x += 1\n    print(*ans)", "for _ in range(int(input())):\n    n = int(input())\n    arr = [int(c) for c in input().split()]\n    subset = []\n    arr.sort()\n    p = []\n    ans = []\n    x = 1\n    while len(ans) != n:\n        while len(p) > 0 and p[0] < arr[x]:\n            p.pop(0)\n        if p and p[0] == arr[x]:\n            p.pop(0)\n        else:\n            ans.append(arr[x])\n            subset.append(arr[x])\n            for i in range(len(subset) - 1):\n                subset.append(subset[i] + arr[x])\n                p.append(subset[i] + arr[x])\n        p.sort()\n        x += 1\n    print(*ans)", "def anumla(sumset, n):\n    valueset = []\n    sum_arr = []\n    rem = {}\n    for i in range(2 ** n - 1):\n        if sumset[i] in rem and rem[sumset[i]] != 0:\n            rem[sumset[i]] -= 1\n        else:\n            sumsubset = []\n            for el in valueset:\n                sumsubset.append(el + sumset[i])\n            for el in sum_arr:\n                sumsubset.append(el + sumset[i])\n            for el in sumsubset:\n                if el not in rem:\n                    rem[el] = 0\n                rem[el] += 1\n                sum_arr.append(el)\n            valueset.append(sumset[i])\n            if len(valueset) == n:\n                break\n    return valueset\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    l.sort()\n    print(*anumla(l[1:], n))", "def anumla(sumset, n):\n    valueset = []\n    sum_arr = []\n    rem = {}\n    for i in range(2 ** n - 1):\n        if sumset[i] in rem and rem[sumset[i]] != 0:\n            rem[sumset[i]] -= 1\n        else:\n            sumsubset = []\n            for el in valueset:\n                sumsubset.append(el + sumset[i])\n            for el in sum_arr:\n                sumsubset.append(el + sumset[i])\n            for el in sumsubset:\n                if el not in rem:\n                    rem[el] = 0\n                rem[el] += 1\n                sum_arr.append(el)\n            valueset.append(sumset[i])\n            if len(valueset) == n:\n                break\n    return valueset\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    sumset = list(map(int, input().split()))\n    sumset.sort()\n    print(*anumla(sumset[1:], n))", "for _ in range(int(input())):\n    n = int(input())\n    n2 = 2 ** n\n    sums = []\n    ans = []\n    rem = {}\n    a = list(map(int, input().split()))\n    a.sort()\n    for i in range(1, n2):\n        if a[i] in rem and rem[a[i]] != 0:\n            rem[a[i]] -= 1\n        else:\n            temp = []\n            for j in sums:\n                temp.append(j + a[i])\n            for j in ans:\n                temp.append(j + a[i])\n            for j in temp:\n                if j not in rem:\n                    rem[j] = 0\n                rem[j] += 1\n                sums.append(j)\n            ans.append(a[i])\n            if len(ans) == n:\n                break\n    print(*ans)", "for _ in range(int(input())):\n    n = int(input())\n    x = 2 ** n\n    a1 = []\n    a2 = []\n    l = {}\n    y = list(map(int, input().split()))\n    y.sort()\n    for i in range(1, x):\n        if y[i] in l and l[y[i]] != 0:\n            l[y[i]] -= 1\n        else:\n            t = []\n            for j in a1:\n                t.append(j + y[i])\n            for j in a2:\n                t.append(j + y[i])\n            for j in t:\n                if j not in l:\n                    l[j] = 0\n                l[j] += 1\n                a1.append(j)\n            a2.append(y[i])\n            if len(a2) == n:\n                break\n    print(*a2)", "for _ in range(int(input())):\n    n = int(input())\n    x = 2 ** n\n    a1 = []\n    a2 = []\n    l = {}\n    y = list(map(int, input().split()))\n    y.sort()\n    for i in range(1, x):\n        if y[i] in l and l[y[i]] != 0:\n            l[y[i]] -= 1\n        else:\n            t = []\n            for j in a1:\n                t.append(j + y[i])\n            for j in a2:\n                t.append(j + y[i])\n            for j in t:\n                if j not in l:\n                    l[j] = 0\n                l[j] += 1\n                a1.append(j)\n            a2.append(y[i])\n            if len(a2) == n:\n                break\n    print(*a2)", "for _ in range(int(input())):\n    n = int(input())\n    x = 2 ** n\n    a1 = []\n    a2 = []\n    l = {}\n    y = list(map(int, input().split()))\n    y.sort()\n    for i in range(1, x):\n        if y[i] in l and l[y[i]] != 0:\n            l[y[i]] -= 1\n        else:\n            t = []\n            for j in a1:\n                t.append(j + y[i])\n            for j in a2:\n                t.append(j + y[i])\n            for j in t:\n                if j not in l:\n                    l[j] = 0\n                l[j] += 1\n                a1.append(j)\n            a2.append(y[i])\n            if len(a2) == n:\n                break\n    print(*a2)", "import sys\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_list_strings():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef solve(N, arr):\n    store = {}\n    for ele in arr:\n        if ele not in store:\n            store[ele] = 1\n        else:\n            store[ele] += 1\n    del store[0]\n    final = []\n    for ele in store:\n        final.append([ele, store[ele]])\n    final.sort()\n    elements = {}\n    tracker = {}\n    l = 0\n    for array in final:\n        ele = array[0]\n        count = array[1]\n        current = 0\n        if l == N:\n            break\n        while current < count:\n            if ele not in tracker:\n                elements[ele] = 1\n                l += 1\n            elif tracker[ele] < count:\n                if ele not in elements:\n                    elements[ele] = 1\n                else:\n                    elements[ele] += 1\n                l += 1\n            else:\n                break\n            if l == N:\n                break\n            temp = {ele: 1}\n            for key in tracker:\n                count1 = tracker[key]\n                val = ele + key\n                if val in temp:\n                    temp[val] += count1\n                else:\n                    temp[val] = count1\n            for key in temp:\n                if key not in tracker:\n                    tracker[key] = temp[key]\n                else:\n                    tracker[key] += temp[key]\n            current = tracker[ele]\n    ans = []\n    for key in elements:\n        count = elements[key]\n        for i in range(count):\n            ans.append(key)\n    ans.sort()\n    sys.stdout.write(' '.join(map(str, ans)) + '\\n')\n    return\nT = get_int()\nwhile T:\n    N = get_int()\n    arr = get_list()\n    solve(N, arr)\n    T -= 1", "import sys\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_list_strings():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef solve(N, arr):\n    store = {}\n    for ele in arr:\n        if ele not in store:\n            store[ele] = 1\n        else:\n            store[ele] += 1\n    del store[0]\n    final = []\n    for ele in store:\n        final.append([ele, store[ele]])\n    final.sort()\n    elements = {}\n    tracker = {}\n    l = 0\n    for array in final:\n        ele = array[0]\n        count = array[1]\n        current = 0\n        if l == N:\n            break\n        while current < count:\n            if ele not in tracker:\n                elements[ele] = 1\n                l += 1\n            elif tracker[ele] < count:\n                if ele not in elements:\n                    elements[ele] = 1\n                else:\n                    elements[ele] += 1\n                l += 1\n            else:\n                break\n            if l == N:\n                break\n            temp = {ele: 1}\n            for key in tracker:\n                count1 = tracker[key]\n                val = ele + key\n                if val in temp:\n                    temp[val] += count1\n                else:\n                    temp[val] = count1\n            for key in temp:\n                if key not in tracker:\n                    tracker[key] = temp[key]\n                else:\n                    tracker[key] += temp[key]\n            current = tracker[ele]\n    ans = []\n    for key in elements:\n        count = elements[key]\n        for i in range(count):\n            ans.append(key)\n    ans.sort()\n    sys.stdout.write(' '.join(map(str, ans)) + '\\n')\n    return\nT = get_int()\nwhile T:\n    N = get_int()\n    arr = get_list()\n    solve(N, arr)\n    T -= 1", "for _ in range(int(input())):\n    n = int(input())\n    k = 2 ** n\n    s = []\n    c = []\n    r = {}\n    a = list(map(int, input().split()))\n    a.sort()\n    for i in range(1, k):\n        if a[i] in r and r[a[i]] != 0:\n            r[a[i]] -= 1\n        else:\n            t = []\n            for j in s:\n                t.append(j + a[i])\n            for j in c:\n                t.append(j + a[i])\n            for j in t:\n                if j not in r:\n                    r[j] = 0\n                r[j] += 1\n                s.append(j)\n            c.append(a[i])\n            if len(c) == n:\n                break\n    print(*c)", "from itertools import permutations\nfrom bisect import bisect_left as bl\nfor __ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split()))\n    li.sort()\n    li.pop(0)\n    t0 = []\n    s = []\n    while li:\n        t1 = []\n        c = li.pop(0)\n        for i in t0:\n            li.pop(bl(li, c + i))\n            t1.append(c + i)\n        t1.append(c)\n        t0 = t0 + list(t1)\n        s.append(c)\n    for i in range(n):\n        print(s[i], end=' ')\n    print()", "from itertools import permutations\nfrom bisect import bisect_left as bl\nfor __ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split()))\n    li.sort()\n    li.pop(0)\n    t0 = []\n    s = []\n    while li:\n        t1 = []\n        c = li.pop(0)\n        for i in t0:\n            li.pop(bl(li, c + i))\n            t1.append(c + i)\n        t1.append(c)\n        t0 = t0 + list(t1)\n        s.append(c)\n    for i in range(n):\n        print(s[i], end=' ')\n    print()", "from itertools import permutations\nfrom bisect import bisect_left as bl\nfor __ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split()))\n    li.sort()\n    li.pop(0)\n    t0 = []\n    s = []\n    while li:\n        t1 = []\n        c = li.pop(0)\n        for i in t0:\n            li.pop(bl(li, c + i))\n            t1.append(c + i)\n        t1.append(c)\n        t0 = t0 + list(t1)\n        s.append(c)\n    for i in range(n):\n        print(s[i], end=' ')\n    print()", "from itertools import permutations\nfrom bisect import bisect_left as bl\nfor __ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split()))\n    li.sort()\n    li.pop(0)\n    t0 = []\n    s = []\n    while li:\n        t1 = []\n        c = li.pop(0)\n        for i in t0:\n            li.pop(bl(li, c + i))\n            t1.append(c + i)\n        t1.append(c)\n        t0 = t0 + list(t1)\n        s.append(c)\n    for i in range(n):\n        print(s[i], end=' ')\n    print()", "for _ in range(int(input())):\n    n = int(input())\n    n2 = 2 ** n\n    sums = []\n    ans = []\n    rem = {}\n    a = list(map(int, input().split()))\n    a.sort()\n    for i in range(1, n2):\n        if a[i] in rem and rem[a[i]] != 0:\n            rem[a[i]] -= 1\n        else:\n            temp = []\n            for j in sums:\n                temp.append(j + a[i])\n            for j in ans:\n                temp.append(j + a[i])\n            for j in temp:\n                if j not in rem:\n                    rem[j] = 0\n                rem[j] += 1\n                sums.append(j)\n            ans.append(a[i])\n            if len(ans) == n:\n                break\n    print(*ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    num = list(map(int, input().split()))\n    num.sort()\n    sum_arr1 = []\n    sum_arr2 = []\n    num_arr = [num[1]]\n    point = 2\n    while len(num_arr) < n:\n        if len(num_arr) == 1:\n            num_arr.append(num[point])\n            sum_arr1.append(num_arr[0] + num[point])\n            sum_arr2.append(num_arr[0] + num[point])\n        elif num[point] in sum_arr2:\n            sum_arr2.remove(num[point])\n        else:\n            num_arr.append(num[point])\n            aa = len(sum_arr1)\n            for e in range(len(num_arr) - 1):\n                sum_arr1.append(num[point] + num_arr[e])\n                sum_arr2.append(num[point] + num_arr[e])\n            for f in range(aa):\n                sum_arr1.append(sum_arr1[f] + num[point])\n                sum_arr2.append(sum_arr1[f] + num[point])\n        point += 1\n    print(*num_arr)", "for _ in range(int(input())):\n    n = int(input())\n    n2 = 2 ** n\n    sums = []\n    ans = []\n    rem = {}\n    a = list(map(int, input().split()))\n    a.sort()\n    for i in range(1, n2):\n        if a[i] in rem and rem[a[i]] != 0:\n            rem[a[i]] -= 1\n        else:\n            temp = []\n            for j in sums:\n                temp.append(j + a[i])\n            for j in ans:\n                temp.append(j + a[i])\n            for j in temp:\n                if j not in rem:\n                    rem[j] = 0\n                rem[j] += 1\n                sums.append(j)\n            ans.append(a[i])\n            if len(ans) == n:\n                break\n    print(*ans)", "from bisect import bisect_left as bl\n\ndef subset(ar):\n    valueset = []\n    ar.pop(0)\n    ss = []\n    while ar:\n        e = ar.pop(0)\n        vs = []\n        for i in valueset:\n            ar.pop(bl(ar, e + i))\n            vs.append(e + i)\n        vs.append(e)\n        valueset += vs\n        ss.append(e)\n    return ss\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()[:2 ** n]))\n    ar.sort()\n    print(*subset(ar))", "from math import ceil, sqrt, log, gcd\nfrom collections import deque, defaultdict as dd\nfrom os import path\nimport sys\nfrom bisect import bisect_left as bl\ninput = sys.stdin.readline\nt = int(input())\nfor f in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    a.pop(0)\n    t0 = []\n    s = []\n    while a:\n        c = a.pop(0)\n        t1 = []\n        for i in t0:\n            a.pop(bl(a, c + i))\n            t1.append(c + i)\n        t0 = t0 + list(t1)\n        t0.append(c)\n        s.append(c)\n    print(*s)", "from math import ceil, sqrt, log, gcd\nfrom collections import deque, defaultdict as dd\nfrom os import path\nimport sys\nfrom bisect import bisect_left as bl\ninput = sys.stdin.readline\nt = int(input())\nfor f in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    a.pop(0)\n    t0 = []\n    s = []\n    while a:\n        c = a.pop(0)\n        t1 = []\n        for i in t0:\n            a.pop(bl(a, c + i))\n            t1.append(c + i)\n        t1.append(c)\n        t0 = t0 + list(t1)\n        s.append(c)\n    print(*s)", "from bisect import bisect_left as bl\nfor _ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split()))\n    li.sort()\n    li.pop(0)\n    t0 = []\n    s = []\n    while li:\n        c = li.pop(0)\n        t1 = []\n        for i in t0:\n            li.pop(bl(li, c + i))\n            t1.append(c + i)\n        t1.append(c)\n        t0 += list(t1)\n        s.append(c)\n    print(*s)", "from bisect import bisect_left as bl\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    l.sort()\n    l.pop(0)\n    t0 = []\n    s = []\n    while l:\n        c = l.pop(0)\n        t1 = []\n        for i in t0:\n            l.pop(bl(l, c + i))\n            t1.append(c + i)\n        t1.append(c)\n        t0 += list(t1)\n        s.append(c)\n    print(*s)", "from bisect import bisect_left as bl\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    l.sort()\n    l.pop(0)\n    t0 = []\n    s = []\n    while l:\n        c = l.pop(0)\n        t1 = []\n        for i in t0:\n            l.pop(bl(l, c + i))\n            t1.append(c + i)\n        t1.append(c)\n        t0 += list(t1)\n        s.append(c)\n    print(*s)", "from heapq import heapify, heappush, heappop\nfor tt in range(int(input())):\n    n = int(input())\n    s = list(map(int, input().split()))\n    s.sort()\n    a = []\n    h = []\n    b = []\n    heapify(h)\n    s.pop(0)\n    for i in range(len(s)):\n        if len(h) == 0 or h[0] != s[i]:\n            a.append(s[i])\n            b.append(s[i])\n            for j in range(len(b) - 1):\n                heappush(h, b[j] + s[i])\n                b.append(s[i] + b[j])\n        else:\n            heappop(h)\n    print(' '.join(map(str, a)))", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    arr.pop(0)\n    ans = []\n    pq = []\n    subsets = []\n    for val in arr:\n        if pq and val == pq[0]:\n            heapq.heappop(pq)\n        else:\n            ans.append(val)\n            for i in range(len(subsets)):\n                subsets.append(subsets[i] + val)\n                heapq.heappush(pq, subsets[i] + val)\n            subsets.append(val)\n    print(*ans)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sumset = []\n    ans = []\n    subs = []\n    arr.sort()\n    arr = arr[1:]\n    for i in arr:\n        if subs and i == subs[0]:\n            heapq.heappop(subs)\n        else:\n            ans.append(i)\n            tmp = []\n            for j in sumset:\n                tmp.append(j + i)\n                heapq.heappush(subs, j + i)\n            sumset.extend(tmp)\n            sumset.append(i)\n        if len(ans) == n:\n            break\n    print(*ans)", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "try:\n    from bisect import bisect_left as bl\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        l.sort()\n        l.pop(0)\n        t0 = []\n        s = []\n        while l:\n            c = l.pop(0)\n            t1 = []\n            for i in t0:\n                l.pop(bl(l, c + i))\n                t1.append(c + i)\n            t1.append(c)\n            t0 += list(t1)\n            s.append(c)\n        print(*s)\nexcept:\n    EOFError", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "import heapq\ntest = int(input())\nfor _ in range(test):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    sumset = []\n    ans = []\n    subs = []\n    arr = arr[1:]\n    for i in arr:\n        if subs and i == subs[0]:\n            heapq.heappop(subs)\n        else:\n            ans.append(i)\n            tmp = []\n            for j in sumset:\n                tmp.append(j + i)\n                heapq.heappush(subs, j + i)\n            sumset.extend(tmp)\n            sumset.append(i)\n        if len(ans) == n:\n            break\n    print(*ans)", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "import heapq\ntest = int(input())\nfor _ in range(test):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    sumset = []\n    ans = []\n    subs = []\n    arr = arr[1:]\n    for i in arr:\n        if subs and i == subs[0]:\n            heapq.heappop(subs)\n        else:\n            ans.append(i)\n            tmp = []\n            for j in sumset:\n                tmp.append(j + i)\n                heapq.heappush(subs, j + i)\n            sumset.extend(tmp)\n            sumset.append(i)\n        if len(ans) == n:\n            break\n    print(*ans)", "import heapq\ntest = int(input())\nfor _ in range(test):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    sumset = []\n    ans = []\n    subs = []\n    arr = arr[1:]\n    for i in arr:\n        if subs and i == subs[0]:\n            heapq.heappop(subs)\n        else:\n            ans.append(i)\n            tmp = []\n            for j in sumset:\n                tmp.append(j + i)\n                heapq.heappush(subs, j + i)\n            sumset.extend(tmp)\n            sumset.append(i)\n        if len(ans) == n:\n            break\n    print(*ans)", "from bisect import bisect_left as bl\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    l.sort()\n    l.pop(0)\n    t0 = []\n    s = []\n    while l:\n        c = l.pop(0)\n        t1 = []\n        for i in t0:\n            l.pop(bl(l, c + i))\n            t1.append(c + i)\n        t1.append(c)\n        t0 += list(t1)\n        s.append(c)\n    print(*s)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sumset = []\n    ans = []\n    subs = []\n    arr.sort()\n    arr = arr[1:]\n    for i in arr:\n        if subs and i == subs[0]:\n            heapq.heappop(subs)\n        else:\n            ans.append(i)\n            tmp = []\n            for j in sumset:\n                tmp.append(j + i)\n                heapq.heappush(subs, j + i)\n            sumset.extend(tmp)\n            sumset.append(i)\n        if len(ans) == n:\n            break\n    print(*ans)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sumset = []\n    ans = []\n    subs = []\n    arr.sort()\n    arr = arr[1:]\n    for i in arr:\n        if subs and i == subs[0]:\n            heapq.heappop(subs)\n        else:\n            ans.append(i)\n            tmp = []\n            for j in sumset:\n                tmp.append(j + i)\n                heapq.heappush(subs, j + i)\n            sumset.extend(tmp)\n            sumset.append(i)\n        if len(ans) == n:\n            break\n    print(*ans)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sumset = []\n    ans = []\n    subs = []\n    arr.sort()\n    arr = arr[1:]\n    for i in arr:\n        if subs and i == subs[0]:\n            heapq.heappop(subs)\n        else:\n            ans.append(i)\n            tmp = []\n            for j in sumset:\n                tmp.append(j + i)\n                heapq.heappush(subs, j + i)\n            sumset.extend(tmp)\n            sumset.append(i)\n        if len(ans) == n:\n            break\n    print(*ans)", "from collections import deque\n\ndef make(a):\n    if len(a) == 2:\n        print(a[0])\n        return\n    g = a[0] - a[1]\n    print(g, end=' ')\n    f = -1\n    q = deque()\n    b = list()\n    for i in a:\n        if f < 0 and len(q):\n            f = q.pop()\n        if i == f:\n            b.append(i)\n            f = -1\n        else:\n            q.appendleft(i - g)\n    make(b)\nfor tnum in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    a.reverse()\n    make(a)", "import heapq\nt = int(input())\nwhile t:\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    arr.pop(0)\n    ans = []\n    pq = []\n    subsets = []\n    for val in arr:\n        if pq and val == pq[0]:\n            heapq.heappop(pq)\n        else:\n            ans.append(val)\n            for i in range(len(subsets)):\n                subsets.append(subsets[i] + val)\n                heapq.heappush(pq, subsets[i] + val)\n            subsets.append(val)\n    print(*ans)\n    t -= 1", "from collections import defaultdict\nimport copy\nimport math\n\ndef subsetSums(arr, l, r, dupli_dict, sum=0):\n    if l > r:\n        dupli_dict[sum] -= 1\n        return\n    subsetSums(arr, l + 1, r, dupli_dict, sum + arr[l])\n    subsetSums(arr, l + 1, r, dupli_dict, sum)\ntest = int(input())\nfor _ in range(test):\n    input_dict = defaultdict(int)\n    dupli_dict = {}\n    n = int(input())\n    inp_list = list(map(int, input().strip().split()))[:pow(2, n)]\n    for inp in inp_list:\n        input_dict[inp] += 1\n    dupli_dict = input_dict.copy()\n    reconstructed_list = []\n    for (k, v) in sorted(input_dict.items()):\n        if dupli_dict[k] > 0:\n            while dupli_dict[k] > 0:\n                if k == 0 and dupli_dict[k] == 1:\n                    break\n                dupli_dict = input_dict.copy()\n                reconstructed_list.append(k)\n                subsetSums(reconstructed_list, 0, len(reconstructed_list) - 1, dupli_dict)\n            if len(reconstructed_list) >= n:\n                break\n    for r in reconstructed_list:\n        print(r, end=' ')\n    print()", "from collections import defaultdict\nimport copy\nimport math\n\ndef subsetSums(arr, l, r, dupli_dict, sum=0):\n    if l > r:\n        dupli_dict[sum] -= 1\n        return\n    subsetSums(arr, l + 1, r, dupli_dict, sum + arr[l])\n    subsetSums(arr, l + 1, r, dupli_dict, sum)\nt = int(input())\nfor i in range(t):\n    input_dict = defaultdict(int)\n    dupli_dict = {}\n    n = int(input())\n    inp_list = list(map(int, input().strip().split()))[:pow(2, n)]\n    for inp in inp_list:\n        input_dict[inp] += 1\n    dupli_dict = input_dict.copy()\n    reconstructed_list = []\n    for (k, v) in sorted(input_dict.items()):\n        if dupli_dict[k] > 0:\n            while dupli_dict[k] > 0:\n                if k == 0 and dupli_dict[k] == 1:\n                    break\n                dupli_dict = input_dict.copy()\n                reconstructed_list.append(k)\n                subsetSums(reconstructed_list, 0, len(reconstructed_list) - 1, dupli_dict)\n            if len(reconstructed_list) >= n:\n                break\n    for r in reconstructed_list:\n        print(r, end=' ')\n    print()", "from collections import defaultdict\nimport copy\nimport math\n\ndef subsetSums(arr, l, r, dupli_dict, sum=0):\n    if l > r:\n        dupli_dict[sum] -= 1\n        return\n    subsetSums(arr, l + 1, r, dupli_dict, sum + arr[l])\n    subsetSums(arr, l + 1, r, dupli_dict, sum)\nt = int(input())\nfor i in range(t):\n    input_dict = defaultdict(int)\n    dupli_dict = {}\n    n = int(input())\n    inp_list = list(map(int, input().strip().split()))[:pow(2, n)]\n    for inp in inp_list:\n        input_dict[inp] += 1\n    dupli_dict = input_dict.copy()\n    reconstructed_list = []\n    for (k, v) in sorted(input_dict.items()):\n        if dupli_dict[k] > 0:\n            while dupli_dict[k] > 0:\n                if k == 0 and dupli_dict[k] == 1:\n                    break\n                dupli_dict = input_dict.copy()\n                reconstructed_list.append(k)\n                subsetSums(reconstructed_list, 0, len(reconstructed_list) - 1, dupli_dict)\n            if len(reconstructed_list) >= n:\n                break\n    for r in reconstructed_list:\n        print(r, end=' ')\n    print()", "from collections import defaultdict\nimport copy\nimport math\n\ndef subsetSums(arr, l, r, dupli_dict, sum=0):\n    if l > r:\n        dupli_dict[sum] -= 1\n        return\n    subsetSums(arr, l + 1, r, dupli_dict, sum + arr[l])\n    subsetSums(arr, l + 1, r, dupli_dict, sum)\nt = int(input())\nn = 0\nfor i in range(t):\n    input_dict = defaultdict(int)\n    dupli_dict = {}\n    n = int(input())\n    inp_list = list(map(int, input().strip().split()))[:pow(2, n)]\n    for inp in inp_list:\n        input_dict[inp] += 1\n    dupli_dict = input_dict.copy()\n    reconstructed_list = []\n    for (k, v) in sorted(input_dict.items()):\n        if dupli_dict[k] > 0:\n            while dupli_dict[k] > 0:\n                if k == 0 and dupli_dict[k] == 1:\n                    break\n                dupli_dict = input_dict.copy()\n                reconstructed_list.append(k)\n                subsetSums(reconstructed_list, 0, len(reconstructed_list) - 1, dupli_dict)\n            if len(reconstructed_list) >= n:\n                break\n    for r in reconstructed_list:\n        print(r, end=' ')\n    print()", "for _ in range(int(input())):\n    from bisect import bisect_left as bl\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    arr.sort()\n    ans = []\n    arr.pop(0)\n    b = []\n    while arr:\n        x = arr.pop(0)\n        temp = [x]\n        for ele in b:\n            arr.pop(bl(arr, ele + x))\n            temp.append(ele + x)\n        b += temp\n        ans.append(x)\n    print(*ans)", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "import heapq\nt = int(input())\nwhile t != 0:\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    arr.pop(0)\n    pq = []\n    bl = []\n    ans = []\n    for val in arr:\n        top = -1\n        if len(pq) > 0:\n            top = pq[0]\n        if top == val:\n            heapq.heappop(pq)\n        else:\n            ans.append(val)\n            l = len(bl)\n            for i in range(l):\n                bl.append(bl[i] + val)\n                heapq.heappush(pq, bl[i] + val)\n            bl.append(val)\n    print(*ans)\n    t -= 1", "import sys\nimport math\nfrom collections import defaultdict\nimport bisect\nimport heapq\n\ndef alele():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef ilele():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef list2d(a, b, c):\n    return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d):\n    return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Yes():\n    print('Yes')\n\ndef No():\n    print('No')\n\ndef YES():\n    print('YES')\n\ndef NO():\n    print('NO')\nINF = 10 ** 18\nMOD = 1000000000 + 7\nmark = {}\nfor _ in range(int(input())):\n    N = int(input())\n    A = alele()\n    mark = {}\n    for i in A:\n        mark[i] = mark.get(i, 0) + 1\n    B = A.copy()\n    heapq.heapify(B)\n    heapq.heappop(B)\n    mark[0] -= 1\n    Ans = []\n    while len(B) != 0:\n        x = heapq.heappop(B)\n        while len(B) != 0 and mark.get(x, -1) == 0:\n            x = heapq.heappop(B)\n        if len(Ans) == N:\n            break\n        if len(Ans) == 0:\n            mark[x] -= 1\n        else:\n            t = 2 ** len(Ans)\n            for j in range(t):\n                tot = 0\n                for k in range(len(Ans)):\n                    if j & 1 << k:\n                        tot += Ans[k]\n                mark[tot + x] -= 1\n        Ans.append(x)\n    print(*Ans)", "import heapq\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    l = list(map(int, input().split()))\n    h = []\n    a = []\n    ans = []\n    l.sort()\n    l.pop(0)\n    for i in range(len(l)):\n        exp = -1\n        val = l[i]\n        if h:\n            exp = h[0]\n        if exp == val:\n            heapq.heappop(h)\n        else:\n            ans.append(val)\n            x = len(a)\n            for j in range(x):\n                a.append(val + a[j])\n                heapq.heappush(h, val + a[j])\n            a.append(val)\n    print(*ans)\n    t -= 1", "def ans(arr, size):\n    if size == 1:\n        return [arr[1]]\n    m = arr[1]\n    new_arr = dict()\n    now = list()\n    for item in arr:\n        if item - m in new_arr and new_arr[item - m] > 0:\n            new_arr[item - m] -= 1\n        else:\n            if item in new_arr:\n                new_arr[item] += 1\n            else:\n                new_arr[item] = 1\n            now.append(item)\n    prev = ans(now, size - 1)\n    prev.append(m)\n    return prev\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    r = ans(sorted(arr), n)\n    r.sort()\n    print(' '.join(list(map(str, r))))", "import heapq\nT = int(input())\nfor z in range(T):\n    N = int(input())\n    sums = list(map(int, input().split()))\n    sums.sort()\n    cumm = []\n    arr = []\n    sums.remove(0)\n    heap = []\n    for i in range(len(sums)):\n        val = sums[i]\n        exp = -1\n        if heap:\n            exp = heap[0]\n        if exp == val:\n            heapq.heappop(heap)\n        else:\n            arr.append(val)\n            t = len(cumm)\n            for i in range(t):\n                cumm.append(val + cumm[i])\n                heapq.heappush(heap, val + cumm[i])\n            cumm.append(val)\n    print(*arr)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    num = list(map(int, input().split()))\n    num.sort()\n    (sum_arr1, sum_arr2) = ([], [])\n    num_arr = [num[1]]\n    point = 2\n    while len(num_arr) < n:\n        if len(num_arr) == 1:\n            num_arr.append(num[point])\n            sum_arr1.append(num_arr[0] + num[point])\n            sum_arr2.append(num_arr[0] + num[point])\n        elif num[point] in sum_arr2:\n            sum_arr2.remove(num[point])\n        else:\n            num_arr.append(num[point])\n            for e in range(len(num_arr) - 1):\n                sum_arr1.append(num[point] + num_arr[e])\n                sum_arr2.append(num[point] + num_arr[e])\n            for f in range(len(sum_arr1)):\n                sum_arr1.append(sum_arr1[f] + num[point])\n                sum_arr2.append(sum_arr1[f] + num[point])\n        point += 1\n    print(*num_arr)", "import heapq\nfor __ in range(int(input())):\n    N = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    arr.pop(0)\n    pq = []\n    bl = []\n    ans = []\n    for val in arr:\n        top = -1\n        if len(pq) > 0:\n            top = pq[0]\n        if top == val:\n            heapq.heappop(pq)\n        else:\n            ans.append(val)\n            l = len(bl)\n            for i in range(l):\n                bl.append(bl[i] + val)\n                heapq.heappush(pq, bl[i] + val)\n            bl.append(val)\n    print(*ans)", "import bisect\ntc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    s = input().split()\n    for i in range(len(s)):\n        s[i] = int(s[i])\n    a = []\n    t = []\n    s.sort()\n    del s[0]\n    while s != []:\n        m = s[0]\n        del s[0]\n        aux = []\n        for item1 in a:\n            item2 = item1 + m\n            index = bisect.bisect_left(s, item2)\n            aux.append(item2)\n            del s[index]\n        aux.append(m)\n        a += aux\n        t.append(m)\n    print(' '.join(map(str, t)))", "import bisect\ntc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    s = list(map(int, input().split()))\n    a = []\n    t = []\n    s.sort()\n    del s[0]\n    while s != []:\n        m = s[0]\n        del s[0]\n        aux = []\n        for item1 in a:\n            item2 = item1 + m\n            index = bisect.bisect_left(s, item2)\n            aux.append(item2)\n            del s[index]\n        aux.append(m)\n        a += aux\n        t.append(m)\n    print(' '.join(map(str, t)))"]