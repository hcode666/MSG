["t = int(input())\nwhile t:\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)\n    t = t - 1", "t = int(input())\nwhile t:\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)\n    t = t - 1", "t = int(input())\nwhile t:\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)\n    t = t - 1", "t = int(input())\nwhile t:\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)\n    t = t - 1", "t = int(input())\nwhile t:\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)\n    t = t - 1", "t = int(input())\nwhile t:\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)\n    t = t - 1", "t = int(input())\nwhile t:\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)\n    t = t - 1", "f = int(input())\nfor _ in range(f):\n    n = int(input())\n    planet_population = sorted([(0, 0)] + [(int(val), i + 1) for (i, val) in enumerate(input().split())])\n    edges = [set() for i in range(n + 1)]\n    for _ in range(n - 1):\n        (v, u) = map(int, input().split())\n        edges[v].add(u)\n        edges[u].add(v)\n    ans = ['0'] * n\n    for i in range(1, n + 1):\n        for j in range(n, 0, -1):\n            if planet_population[i][1] == planet_population[j][1] or planet_population[j][1] in edges[planet_population[i][1]]:\n                continue\n            else:\n                ans[planet_population[i][1] - 1] = str(planet_population[j][1])\n                break\n    print(' '.join(ans))", "t = int(input())\nwhile t:\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)\n    t = t - 1", "t = int(input())\nwhile t:\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)\n    t = t - 1", "f = int(input())\nfor _ in range(f):\n    n = int(input())\n    planet_population = sorted([(0, 0)] + [(int(val), i + 1) for (i, val) in enumerate(input().split())])\n    edges = [set() for i in range(n + 1)]\n    for _ in range(n - 1):\n        (v, u) = map(int, input().split())\n        edges[v].add(u)\n        edges[u].add(v)\n    ans = ['0'] * n\n    for i in range(1, n + 1):\n        for j in range(n, 0, -1):\n            if planet_population[i][1] == planet_population[j][1] or planet_population[j][1] in edges[planet_population[i][1]]:\n                continue\n            else:\n                ans[planet_population[i][1] - 1] = str(planet_population[j][1])\n                break\n    print(' '.join(ans))", "f = int(input())\nfor _ in range(f):\n    n = int(input())\n    planet_population = sorted([(0, 0)] + [(int(val), i + 1) for (i, val) in enumerate(input().split())])\n    edges = [set() for i in range(n + 1)]\n    for _ in range(n - 1):\n        (v, u) = map(int, input().split())\n        edges[v].add(u)\n        edges[u].add(v)\n    ans = ['0'] * n\n    for i in range(1, n + 1):\n        for j in range(n, 0, -1):\n            if planet_population[i][1] == planet_population[j][1] or planet_population[j][1] in edges[planet_population[i][1]]:\n                continue\n            else:\n                ans[planet_population[i][1] - 1] = str(planet_population[j][1])\n                break\n    print(' '.join(ans))", "f = int(input())\nfor _ in range(f):\n    n = int(input())\n    planet_population = sorted([(0, 0)] + [(int(val), i + 1) for (i, val) in enumerate(input().split())])\n    edges = [set() for i in range(n + 1)]\n    for _ in range(n - 1):\n        (v, u) = map(int, input().split())\n        edges[v].add(u)\n        edges[u].add(v)\n    ans = ['0'] * n\n    for i in range(1, n + 1):\n        for j in range(n, 0, -1):\n            if planet_population[i][1] == planet_population[j][1] or planet_population[j][1] in edges[planet_population[i][1]]:\n                continue\n            else:\n                ans[planet_population[i][1] - 1] = str(planet_population[j][1])\n                break\n    print(' '.join(ans))", "f = int(input())\nfor _ in range(f):\n    n = int(input())\n    planet_population = sorted([(0, 0)] + [(int(val), i + 1) for (i, val) in enumerate(input().split())])\n    edges = [set() for i in range(n + 1)]\n    for _ in range(n - 1):\n        (v, u) = map(int, input().split())\n        edges[v].add(u)\n        edges[u].add(v)\n    ans = ['0'] * n\n    for i in range(1, n + 1):\n        for j in range(n, 0, -1):\n            if planet_population[i][1] == planet_population[j][1] or planet_population[j][1] in edges[planet_population[i][1]]:\n                continue\n            else:\n                ans[planet_population[i][1] - 1] = str(planet_population[j][1])\n                break\n    print(' '.join(ans))", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for j in range(n):\n        p[j].append(j + 1)\n    p.sort()\n    p.reverse()\n    l = []\n    for k in range(n + 1):\n        l.append([])\n    for z in range(n - 1):\n        (v, u) = map(int, input().split())\n        l[v].append(u)\n        l[u].append(v)\n    f = []\n    for y in range(1, n + 1):\n        c = l[y]\n        ans = 0\n        for g in p:\n            if g[1] != y and g[1] not in c:\n                ans = g[1]\n                break\n        f.append(ans)\n    print(*f)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for j in range(n):\n        p[j].append(j + 1)\n    p.sort()\n    p.reverse()\n    l = []\n    for k in range(n + 1):\n        l.append([])\n    for z in range(n - 1):\n        (v, u) = map(int, input().split())\n        l[v].append(u)\n        l[u].append(v)\n    f = []\n    for y in range(1, n + 1):\n        c = l[y]\n        ans = 0\n        for g in p:\n            if g[1] != y and g[1] not in c:\n                ans = g[1]\n                break\n        f.append(ans)\n    print(*f)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    planet_population = sorted([(0, 0)] + [(int(val), i + 1) for (i, val) in enumerate(input().split())])\n    edges = [set() for i in range(n + 1)]\n    for _ in range(n - 1):\n        (v, u) = map(int, input().split())\n        edges[v].add(u)\n        edges[u].add(v)\n    ans = ['0'] * n\n    for i in range(1, n + 1):\n        for j in range(n, 0, -1):\n            if planet_population[i][1] == planet_population[j][1] or planet_population[j][1] in edges[planet_population[i][1]]:\n                continue\n            else:\n                ans[planet_population[i][1] - 1] = str(planet_population[j][1])\n                break\n    print(' '.join(ans))", "t = int(input())\nwhile t:\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)\n    t = t - 1", "t = int(input())\nwhile t:\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)\n    t = t - 1", "def capimove(edges, wts, wts_dict):\n    for e in wts:\n        if wts_dict[e] not in edges:\n            return wts_dict[e]\n    return 0\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    wts = [0] + [int(i) for i in input().split()]\n    wts_dict = {wts[i]: i for i in range(1, n + 1)}\n    wts.sort(reverse=True)\n    adj = {i: [i] for i in range(1, n + 1)}\n    for _ in range(n - 1):\n        (i, j) = map(int, input().split())\n        adj[i].append(j)\n        adj[j].append(i)\n    for k in range(1, n + 1):\n        print(capimove(adj[k], wts, wts_dict), end=' ')\n    print()", "def capimove(A, popl, pop_dict, i):\n    li = A[i]\n    for el in popl:\n        if pop_dict[el] not in li:\n            return pop_dict[el]\n    return 0\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    popl = [int(i) for i in input().split()]\n    popl = [0] + popl\n    pop_dict = {popl[i]: i for i in range(1, n + 1)}\n    popl.sort(reverse=True)\n    A = {i: [i] for i in range(1, n + 1)}\n    for _ in range(n - 1):\n        (i, j) = map(int, input().split())\n        if i not in A[j] or j not in A[i]:\n            A[i].append(j)\n            A[j].append(i)\n    for k in range(1, n + 1):\n        print(capimove(A, popl, pop_dict, k), end=' ')\n    print('')", "T = int(input())\nfor i in range(T):\n    n = int(input())\n    populations = [0]\n    populations.extend([int(i) for i in input().split()])\n    d = {populations[i]: i for i in range(1, n + 1)}\n    ports = {}\n    populations.sort(reverse=True)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        if u in ports.keys():\n            ports[u].append(v)\n        else:\n            ports[u] = [v, u]\n        if v in ports.keys():\n            ports[v].append(u)\n        else:\n            ports[v] = [u, v]\n    for i in range(1, n + 1):\n        out = 0\n        s = ports[i]\n        for j in populations:\n            if d[j] not in s:\n                out = d[j]\n                break\n        print(out, end=' ')\n    print('')", "for _ in range(int(input())):\n    n = int(input())\n    populations = [0]\n    populations.extend([int(i) for i in input().split()])\n    d = {populations[i]: i for i in range(1, n + 1)}\n    ports = {}\n    populations.sort(reverse=True)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        if u in ports.keys():\n            ports[u].append(v)\n        else:\n            ports[u] = [v, u]\n        if v in ports.keys():\n            ports[v].append(u)\n        else:\n            ports[v] = [u, v]\n    for i in range(1, n + 1):\n        out = 0\n        s = ports[i]\n        for j in populations:\n            if d[j] not in s:\n                out = d[j]\n                break\n        print(out, end=' ')\n    print('')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    populations = [0]\n    populations.extend([int(i) for i in input().split()])\n    d = {populations[i]: i for i in range(1, n + 1)}\n    ports = {}\n    populations.sort(reverse=True)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        if u in ports.keys():\n            ports[u].append(v)\n        else:\n            ports[u] = [v, u]\n        if v in ports.keys():\n            ports[v].append(u)\n        else:\n            ports[v] = [u, v]\n    for i in range(1, n + 1):\n        out = 0\n        s = ports[i]\n        for j in populations:\n            if d[j] not in s:\n                out = d[j]\n                break\n        print(out, end=' ')\n    print('')", "from heapq import *\nfor case in range(int(input())):\n    N = int(input())\n    L = list(map(int, input().split()))\n    d = {}\n    path = []\n    for i in range(N):\n        d[L[i]] = i\n        path.append(set([i]))\n    L.sort(reverse=True)\n    for i in range(N - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        path[a].add(b)\n        path[b].add(a)\n    o = ''\n    for i in range(N):\n        s = path[i]\n        f = True\n        for j in L:\n            if d[j] not in s:\n                o += str(d[j] + 1) + ' '\n                f = False\n                break\n        if f:\n            o += '0 '\n    print(o)", "t = int(input())\nfor _t in range(t):\n    n = int(input())\n    x = [int(y) for y in input().split()]\n    adj = [[i] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    heap = [(x[i], i) for i in range(len(x))]\n    heap.sort()\n    for node in range(n):\n        keep = []\n        while heap[-1][1] in adj[node]:\n            keep.append(heap[-1])\n            heap.pop()\n        print(heap[-1][1] + 1 if len(heap) else 0, end=' ')\n        while len(keep):\n            heap.append(keep[-1])\n            keep.pop()\n    print('\\n')", "t = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    p = [[int(i)] for i in input().split()]\n    for i in range(n):\n        p[i].append(i + 1)\n    p.sort()\n    p.reverse()\n    connected = []\n    for i in range(n + 1):\n        connected.append([])\n    for i in range(n - 1):\n        (v, u) = [int(i) for i in input().split()]\n        connected[v].append(u)\n        connected[u].append(v)\n    final = []\n    for i in range(1, n + 1):\n        infected = connected[i]\n        ans = 0\n        for j in p:\n            if j[1] != i and j[1] not in infected:\n                ans = j[1]\n                flag = 1\n                break\n        final.append(ans)\n    print(*final)", "from copy import copy\nfor _ in range(int(input())):\n    N = int(input())\n    a = list(map(int, input().split()))\n    aa = [[a[i], i] for i in range(N)]\n    aa.sort()\n    order = [aa[i][1] for i in range(N)]\n    conn = [[i] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        conn[u - 1].append(v - 1)\n        conn[v - 1].append(u - 1)\n    result = []\n    for i in range(N):\n        connectedTo = conn[i]\n        notFound = True\n        t = N - 1\n        if len(connectedTo) == N:\n            t = -1\n        while notFound and t >= 0:\n            if order[t] in connectedTo:\n                t -= 1\n            else:\n                notFound = False\n        if notFound:\n            result.append(0)\n        else:\n            result.append(order[t] + 1)\n    print(*result)", "T = int(input())\nfor x in range(T):\n    N = int(input())\n    P = [[int(popu)] for popu in input().split()]\n    for i in range(N):\n        P[i].append(i + 1)\n    P.sort(reverse=True)\n    conn = dict()\n    for y in range(N - 1):\n        (a, b) = [int(k) for k in input().split()]\n        if a in conn.keys():\n            conn[a].append(b)\n        else:\n            conn[a] = [b]\n        if b in conn.keys():\n            conn[b].append(a)\n        else:\n            conn[b] = [a]\n    ans = [0] * N\n    for i in range(N):\n        temp = conn[i + 1]\n        temp.append(i + 1)\n        for j in P:\n            if j[1] not in temp:\n                ans[i] = j[1]\n                break\n    print(*ans, sep=' ')", "for t in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    population = {}\n    for i in range(n):\n        population[i] = arr[i]\n    adjancecy_list = {}\n    for edges in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        try:\n            adjancecy_list[u][v] = 1\n        except KeyError:\n            adjancecy_list[u] = {}\n            adjancecy_list[u][v] = 1\n        try:\n            adjancecy_list[v][u] = 1\n        except KeyError:\n            adjancecy_list[v] = {}\n            adjancecy_list[v][u] = 1\n    arr = sorted(population.items(), key=lambda kv: (kv[1], kv[0]), reverse=True)\n    for i in range(n):\n        neighbours = adjancecy_list[i]\n        flag = True\n        for (node, pop) in arr:\n            if node != i:\n                try:\n                    temp = neighbours[node]\n                except KeyError:\n                    print(node + 1, end=' ')\n                    flag = False\n                    break\n        if flag:\n            print(0, end=' ')\n    print()", "for __ in range(int(input())):\n    N = int(input())\n    arr = [(0, 0)] + [(int(val), i + 1) for (i, val) in enumerate(input().split())]\n    edges = [set() for i in range(N + 1)]\n    for _ in range(N - 1):\n        (v, u) = map(int, input().split())\n        edges[v].add(u)\n        edges[u].add(v)\n    arr.sort()\n    ans = [0] * N\n    for i in range(1, N + 1):\n        for j in range(N, 0, -1):\n            if arr[i][1] == arr[j][1] or arr[j][1] in edges[arr[i][1]]:\n                continue\n            else:\n                ans[arr[i][1] - 1] = arr[j][1]\n                break\n    print(*ans)", "from sys import stdin\nfrom collections import defaultdict\nt = int(stdin.readline())\nfor _ in range(t):\n    N = int(stdin.readline())\n    planets_population = list(map(int, stdin.readline().strip().split(' ')))\n    planets = []\n    for i in range(1, N + 1):\n        planets.append((planets_population[i - 1], i))\n    planets.sort()\n    infected_planets_dict = defaultdict(list)\n    infected_planets = []\n    for i in range(N - 1):\n        infected_planets.append(tuple(map(int, stdin.readline().strip().split(' '))))\n    for (v, u) in infected_planets:\n        if v in infected_planets_dict:\n            ne = infected_planets_dict[v]\n            ne.add(u)\n            infected_planets_dict[v] = ne\n        else:\n            infected_planets_dict[v] = set([v, u])\n        if u in infected_planets_dict:\n            ne = infected_planets_dict[u]\n            ne.add(v)\n            infected_planets_dict[u] = ne\n        else:\n            infected_planets_dict[u] = set([u, v])\n    ans = []\n    for v in range(1, N + 1):\n        connected_planets = infected_planets_dict[v]\n        k = len(planets)\n        while k > 0:\n            current_planet = planets[k - 1]\n            if current_planet[1] not in connected_planets:\n                ans.append(current_planet[1])\n                break\n            k -= 1\n    for i in ans:\n        print(i, end=' ')", "for _ in range(int(input())):\n    n = int(input())\n    p = list(map(int, input().split()))\n    links = dict([(i, set([i])) for i in range(n)])\n    for i in range(n - 1):\n        (v, u) = map(int, input().split())\n        links[u - 1].add(v - 1)\n        links[v - 1].add(u - 1)\n    inds = [i for i in range(0, n)]\n    inds.sort(reverse=True, key=lambda x: p[x])\n    ans = [set(inds)]\n    for i in range(0, n - 1):\n        overlap = links[inds[i]].intersection(ans[i])\n        ans[i] -= overlap\n        if len(overlap) == 0:\n            break\n        ans.append(overlap.copy())\n    if len(ans) == n:\n        if inds[n - 1] in ans[n - 1]:\n            ans[n - 1].subtract(inds[n - 1])\n    finalans = [0] * n\n    for i in range(len(ans)):\n        for j in ans[i]:\n            finalans[j] = inds[i] + 1\n    print(' '.join([str(x) for x in finalans]))", "import heapq\nt = int(input())\nwhile t != 0:\n    n = int(input())\n    a = list(map(int, input().split()))\n    h = []\n    hs = []\n    ans = []\n    d = {}\n    for i in range(n):\n        heapq.heappush(h, -a[i])\n        ht = []\n        ht.append(-a[i])\n        hs.append(ht)\n        d[-a[i]] = i + 1\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        heapq.heappush(hs[u - 1], -a[v - 1])\n        heapq.heappush(hs[v - 1], -a[u - 1])\n    for i in range(n):\n        pop = []\n        flag = 0\n        while len(hs[i]) > 0:\n            toph = heapq.heappop(h)\n            pop.append(toph)\n            tophs = heapq.heappop(hs[i])\n            if toph != tophs:\n                ans.append(toph)\n                flag = 1\n                break\n        if flag == 0 and len(h) == 0:\n            ans.append(0)\n        elif flag == 0 and len(h) > 0:\n            toph = heapq.heappop(h)\n            pop.append(toph)\n            ans.append(toph)\n        for j in pop:\n            heapq.heappush(h, j)\n    for i in ans:\n        print(d[i], end=' ')\n    print('')\n    t -= 1", "t = int(input())\nfor _ in range(t):\n    N = int(input())\n    weights = [[int(x)] for x in input().split()]\n    for i in range(N):\n        weights[i].append(i + 1)\n    weights.sort(reverse=True)\n    l1 = {}\n    for i in range(N - 1):\n        (q1, q2) = [int(x) for x in input().split()]\n        if q1 in l1.keys():\n            l1[q1].append(q2)\n        else:\n            l1[q1] = [q2]\n        if q2 in l1.keys():\n            l1[q2].append(q1)\n        else:\n            l1[q2] = [q1]\n    l2 = [0] * N\n    for i in range(N):\n        r = l1[i + 1]\n        r.append(i + 1)\n        for item in weights:\n            if item[1] not in r:\n                l2[i] = item[1]\n                break\n    for ans in l2:\n        print(ans, end=' ')", "T = int(input())\nfor x in range(T):\n    N = int(input())\n    P = [[int(popu)] for popu in input().split()]\n    for i in range(N):\n        P[i].append(i + 1)\n    P.sort(reverse=True)\n    conn = dict()\n    for y in range(N - 1):\n        (a, b) = [int(k) for k in input().split()]\n        if a in conn.keys():\n            conn[a].append(b)\n        else:\n            conn[a] = [b]\n        if b in conn.keys():\n            conn[b].append(a)\n        else:\n            conn[b] = [a]\n    ans = [0] * N\n    for i in range(N):\n        temp = conn[i + 1]\n        temp.append(i + 1)\n        for j in P:\n            if j[1] not in temp:\n                ans[i] = j[1]\n                break\n    print(*ans, sep=' ')", "for _ in range(int(input())):\n    n = int(input())\n    p = [0] + list(map(int, input().split()))\n    popnum = [(p[i], i) for i in range(1, n + 1)]\n    popnum.sort(reverse=True)\n    adj = [[] for u in range(n)]\n    for i in range(n - 1):\n        (v, u) = map(int, input().split())\n        adj[v - 1].append(u)\n        adj[u - 1].append(v)\n    for i in range(n):\n        top = 0\n        while popnum[top][1] in adj[i] or popnum[top][1] == i + 1:\n            top += 1\n        print(popnum[top][1], end=' ')\n    print()", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    l = [int(i) for i in input().split()]\n    d = {}\n    b = []\n    for i in range(n):\n        b.append([l[i], i])\n    b.sort(key=lambda x: x[0], reverse=True)\n    d = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        u = u - 1\n        v = v - 1\n        d[u].append(v)\n        d[v].append(u)\n    for i in range(n):\n        d[i] = d[i] + [i]\n    for i in range(n):\n        for j in range(n):\n            if b[j][1] not in d[i]:\n                print(b[j][1] + 1, end=' ')\n                break\n        else:\n            print(0, end=' ')", "for _ in range(int(input())):\n    n = int(input())\n    p = [0] + list(map(int, input().split()))\n    popnum = [(p[i], i) for i in range(1, n + 1)]\n    popnum.sort(reverse=True)\n    adj = [[] for u in range(n)]\n    for i in range(n - 1):\n        (v, u) = map(int, input().split())\n        adj[v - 1].append(u)\n        adj[u - 1].append(v)\n    for i in range(n):\n        top = 0\n        while popnum[top][1] in adj[i] or popnum[top][1] == i + 1:\n            top += 1\n        print(popnum[top][1], end=' ')", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    la = [[l[i], i] for i in range(n)]\n    hash = defaultdict(list)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        hash[a].append(b)\n        hash[b].append(a)\n    la.sort(reverse=True)\n    for i in range(n):\n        k = {l[j - 1] for j in hash[i + 1]}\n        k.add(l[i])\n        for j in range(n):\n            if la[j][0] not in k:\n                print(la[j][1] + 1, end=' ')\n                break", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    s = set()\n    p = [[i, int(v)] for (i, v) in enumerate(input().split())]\n    p.sort(key=lambda x: x[1], reverse=True)\n    g = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    for i in range(n):\n        for j in range(n):\n            if p[j][0] not in [*g[i], i]:\n                print(p[j][0] + 1, end=' ')\n                break\n    print()", "import sys\nfrom operator import *\n\ndef solve(pop1, pop2, n, adj):\n    pop = pop1\n    d = dict()\n    for i in range(n):\n        d[pop[i]] = i + 1\n    pop2.sort(reverse=True)\n    A = [0] * n\n    for i in range(n):\n        l = len(adj[i])\n        s = set()\n        s.add(pop1[i])\n        for k in range(l):\n            s.add(pop1[adj[i][k]])\n        for j in range(n):\n            if pop2[j] not in s:\n                A[i] = d[pop2[j]]\n                break\n    return A\n\ndef Main():\n    t = int(sys.stdin.readline())\n    while t > 0:\n        n = int(sys.stdin.readline())\n        population = sys.stdin.readline().split()\n        pop1 = [0] * n\n        pop2 = [0] * n\n        for i in range(n):\n            pop1[i] = int(population[i])\n            pop2[i] = int(population[i])\n        adj = [[] for i in range(n)]\n        for i in range(1, n):\n            (u, v) = map(int, sys.stdin.readline().split())\n            u = u - 1\n            v = v - 1\n            adj[u].append(v)\n            adj[v].append(u)\n        result = solve(pop1, pop2, n, adj)\n        print(*result, sep=' ')\n        t = t - 1\nMain()", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    l = [int(i) for i in input().split()]\n    d = {}\n    elems = []\n    for i in range(n):\n        elems.append([l[i], i])\n    elems.sort(key=lambda x: x[0], reverse=True)\n    d = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        u = u - 1\n        v = v - 1\n        d[u].append(v)\n        d[v].append(u)\n    for i in range(n):\n        d[i] = d[i] + [i]\n    for i in range(n):\n        for j in range(n):\n            if elems[j][1] not in d[i]:\n                print(elems[j][1] + 1, end=' ')\n                break\n        else:\n            print(0, end=' ')", "from operator import *\n\ndef solve(adj, population, n) -> 'list':\n    pop_city = [[p, i] for (i, p) in enumerate(population, 1)]\n    pop_city.sort(reverse=True)\n    ans = [0] * n\n    for i in range(n):\n        removed = {population[node] for node in adj[i]}\n        removed.add(population[i])\n        for j in range(n):\n            if pop_city[j][0] not in removed:\n                ans[i] = pop_city[j][1]\n                break\n    return ans\n\ndef Main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        population = list(map(int, input().rstrip().split()))\n        adj = [[] for i in range(n)]\n        for i in range(n - 1):\n            (u, v) = list(map(int, input().rstrip().split()))\n            u -= 1\n            v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        res = solve(adj, population, n)\n        print(*res, sep=' ')\nMain()", "for _ in range(int(input())):\n    n = int(input())\n    z = input().split()\n    popn = list(map(int, z[:n]))\n    popn.insert(0, 0)\n    links = [[] for i in range(n + 1)]\n    for e in range(n - 1):\n        z = input().split()\n        (fr, to) = map(int, z[:2])\n        links[fr].append(to)\n        links[to].append(fr)\n    poprf = list(range(1, n + 1))\n    poprf.sort(reverse=True, key=lambda x: popn[x])\n    cap = poprf.pop(0)\n    cloc = [cap] + links[cap]\n    tmpcap = [cap] * (n + 1)\n    alt = poprf[0]\n    aloc = links[alt]\n    altopt = [alt]\n    if alt in cloc:\n        ctown = ptown = outtown = False\n        for t in poprf[1:]:\n            if t in cloc:\n                if not ctown:\n                    altopt.append(t)\n                    ctown = True\n            elif t in aloc:\n                if not ptown:\n                    altopt.append(t)\n                    ptown = True\n            else:\n                altopt.append(t)\n                break\n            if ctown and ptown:\n                break\n    else:\n        comm = set(cloc) & set(aloc)\n        if len(comm) > 0:\n            cm = comm.pop()\n            cmloc = [cm] + links[cm]\n            for t in poprf[1:]:\n                if t not in cmloc:\n                    altopt.append(t)\n                    break\n    for loc in cloc:\n        qloc = [loc] + links[loc]\n        for t in altopt:\n            if t not in qloc:\n                tmpcap[loc] = t\n                break\n    print(*tmpcap[1:])", "def heap_decap(hp, ref):\n    elm = hp.pop()\n    rfelm = ref[elm]\n    hplen = len(hp)\n    a = 0\n    b = 2 * a + 1\n    while b < hplen:\n        if b + 1 < hplen:\n            if ref[hp[b + 1]] > ref[hp[b]]:\n                b += 1\n        if ref[hp[b]] > rfelm:\n            hp[a] = hp[b]\n            a = b\n            b = 2 * a + 1\n        else:\n            break\n    hp[a] = elm\nfor _ in range(int(input())):\n    n = int(input())\n    z = input().split()\n    popn = list(map(int, z[:n]))\n    popn.insert(0, 0)\n    links = [[] for i in range(n + 1)]\n    for e in range(n - 1):\n        z = input().split()\n        (fr, to) = map(int, z[:2])\n        links[fr].append(to)\n        links[to].append(fr)\n    poprf = list(range(1, n + 1))\n    poprf.sort(reverse=True, key=lambda x: popn[x])\n    cap = poprf.pop(0)\n    cpop = popn[cap]\n    cloc = [cap] + links[cap]\n    prox = cloc[1:]\n    prox.sort(reverse=True, key=lambda x: popn[x])\n    pcap = prox[0]\n    ploc = links[pcap]\n    ctown = ptown = outtown = 0\n    for e in range(len(poprf)):\n        if poprf[e] in cloc:\n            ctown += 1\n        elif poprf[e] in ploc:\n            ptown += 1\n        else:\n            outtown += 1\n        if ctown > 1 and ptown > 0 or (ctown > 0 and outtown > 0):\n            poprf = poprf[:e + 1]\n            break\n    tcap = [cap] * (n + 1)\n    for loc in cloc:\n        qloc = [loc] + links[loc]\n        popwk = poprf[:]\n        while popwk[0] in qloc:\n            heap_decap(popwk, popn)\n        tcap[loc] = popwk[0]\n    print(*tcap[1:])", "from heapq import *\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [-1] + list(map(int, input().split()))\n    hmap = {}\n    heap = []\n    for i in range(1, n + 1):\n        hmap[arr[i]] = i\n        heappush(heap, -arr[i])\n    graph = defaultdict(set)\n    for i in range(n - 1):\n        (v, u) = list(map(int, input().split()))\n        graph[arr[v]].add(arr[u])\n        graph[arr[u]].add(arr[v])\n    ans = []\n    for i in range(1, n + 1):\n        toadd = []\n        while -heap[0] == arr[i] or -heap[0] in graph[arr[i]]:\n            toadd.append(heap[0])\n            heappop(heap)\n        ans.append(hmap[-heap[0]])\n        for i in toadd:\n            heappush(heap, i)\n    print(' '.join(map(str, ans)))", "import gc\ngc.disable()\n\ndef main():\n    from sys import stdin, stdout\n    import atexit, io, sys\n    buffer = io.StringIO()\n    sys.stdout = buffer\n\n    @atexit.register\n    def write():\n        sys.__stdout__.write(buffer.getvalue())\n    t = int(stdin.readline())\n    dec = [False for x in range(50000 + 1)]\n    while t:\n        t -= 1\n        n = int(stdin.readline())\n        pop = [[int(x), y] for (x, y) in zip(stdin.readline().split(), range(1, n + 1))]\n        pop.sort(reverse=True)\n        conn = [set() for x in range(n + 1)]\n        for x in range(n - 1):\n            (a, b) = map(int, stdin.readline().split())\n            conn[a].add(b)\n            conn[b].add(a)\n        ans = ''\n        for x in range(1, n + 1):\n            conn[x].add(x)\n            for w in range(len(pop)):\n                if pop[w][1] not in conn[x]:\n                    ans += str(pop[w][1]) + ' '\n                    break\n            else:\n                ans += '0 '\n        stdout.write('{}\\n'.format(ans))\nmain()", "q = int(input())\nwhile q:\n    n = int(input())\n    l = list(map(int, input().split()))\n    l[n:] = []\n    L = [[l[i], i] for i in range(n)]\n    L.sort()\n    c = {}\n    for i in range(n - 1):\n        (v, u) = map(int, input().split())\n        if v - 1 in c:\n            c[v - 1].append(u - 1)\n        else:\n            c[v - 1] = [v - 1, u - 1]\n        if u - 1 in c:\n            c[u - 1].append(v - 1)\n        else:\n            c[u - 1] = [u - 1, v - 1]\n    for i in range(n):\n        flag = 0\n        for j in range(n - 1, -1, -1):\n            if L[j][1] not in c[i]:\n                flag = 1\n                break\n        if flag == 1:\n            print(L[j][1] + 1, end=' ')\n        else:\n            print(0, end=' ')\n    print()\n    q = q - 1", "from sys import stdin\nimport heapq\nT = int(stdin.readline().strip())\nwhile T > 0:\n    N = int(stdin.readline().strip())\n    popN1 = [0] + [int(n) for n in stdin.readline().strip().split()]\n    popN = [(popN1[i], i) for i in range(1, N + 1)]\n    popN.sort()\n    dict1 = {i: [i] for i in range(1, N + 1)}\n    for _ in range(1, N):\n        [U, V] = [int(n) for n in stdin.readline().strip().split()]\n        dict1[U].append(V)\n        dict1[V].append(U)\n    for i in range(1, N + 1):\n        index1 = 0\n        for j in range(N - 1, -1, -1):\n            if popN[j][1] not in dict1[i]:\n                index1 = popN[j][1]\n                break\n        print(index1, end=' ')\n    T -= 1", "q = int(input())\nwhile q:\n    n = int(input())\n    l = list(map(int, input().split()))\n    l[n:] = []\n    L = [[l[i], i] for i in range(n)]\n    L.sort()\n    c = {i: [i] for i in range(n)}\n    for i in range(n - 1):\n        (v, u) = map(int, input().split())\n        c[u - 1].append(v - 1)\n        c[v - 1].append(u - 1)\n    for i in range(n):\n        flag = 0\n        for j in range(n - 1, -1, -1):\n            if L[j][1] not in c[i]:\n                flag = 1\n                break\n        if flag == 1:\n            print(L[j][1] + 1, end=' ')\n        else:\n            print(0, end=' ')\n    print()\n    q = q - 1", "q = int(input())\nwhile q:\n    n = int(input())\n    l = list(map(int, input().split()))\n    l[n:] = []\n    L = [[l[i], i] for i in range(n)]\n    L.sort()\n    c = {}\n    for i in range(n - 1):\n        (v, u) = map(int, input().split())\n        if v - 1 in c:\n            c[v - 1].append(u - 1)\n        else:\n            c[v - 1] = [v - 1, u - 1]\n        if u - 1 in c:\n            c[u - 1].append(v - 1)\n        else:\n            c[u - 1] = [u - 1, v - 1]\n    for i in range(n):\n        flag = 0\n        for j in range(n - 1, -1, -1):\n            if L[j][1] not in c[i]:\n                flag = 1\n                break\n        if flag == 1:\n            print(L[j][1] + 1, end=' ')\n        else:\n            print(0, end=' ')\n    print()\n    q = q - 1", "t = int(input())\ndec = [False for x in range(50000 + 1)]\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    pop = [[int(x), y] for (x, y) in zip(input().split(), range(1, n + 1))]\n    pop.sort(reverse=True)\n    conn = [set() for x in range(n + 1)]\n    for x in range(n - 1):\n        (a, b) = map(int, input().split())\n        conn[a].add(b)\n        conn[b].add(a)\n    for x in range(1, n + 1):\n        conn[x].add(x)\n        for w in range(len(pop)):\n            if pop[w][1] not in conn[x]:\n                print(pop[w][1], end=' ')\n                break\n        else:\n            print(0, end=' ')\n    print()", "import copy\n\nclass Graph:\n    V = 0\n    adj_list = []\n    p = []\n    mmx = 0\n    index = 0\n    w = []\n\n    def __init__(self, V):\n        del self.p[:]\n        del self.adj_list[:]\n        del self.w[:]\n        self.V = V\n        self.p = list(map(int, input().split()))\n        for i in range(0, len(self.p)):\n            self.w.append([self.p[i], i])\n        for i in range(0, V):\n            self.adj_list.append([i])\n\n    def add_Edge(self, u, v):\n        self.adj_list[u].append(v)\n        self.adj_list[v].append(u)\n\n    def solve(self):\n        pp = sorted(self.w, key=lambda l: l[0], reverse=True)\n        for i in range(0, self.V):\n            q = 0\n            while q < n:\n                self.index = pp[q][1]\n                if self.index not in self.adj_list[i]:\n                    print(self.index + 1, end=' ')\n                    break\n                else:\n                    q += 1\n                if q == n - 1:\n                    print('0', end=' ')\n        print()\nt = int(input())\nfor _ in range(0, t):\n    n = int(input())\n    g = Graph(n)\n    for __ in range(0, n - 1):\n        (u, v) = map(int, input().split())\n        u = u - 1\n        v = v - 1\n        g.add_Edge(u, v)\n    g.solve()", "from collections import defaultdict\nfrom bisect import bisect_left\n\nclass City:\n\n    def __init__(self, pop, num):\n        self.pop = pop\n        self.num = num\n\ndef solve():\n    t = int(input())\n    for i in range(t):\n        find_capitals()\n\ndef find_capitals():\n    ans = []\n    n = int(input())\n    cities = [City(int(pop), i + 1) for (i, pop) in enumerate(input().split())]\n    cities.sort(key=lambda x: x.pop, reverse=True)\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (l, r) = [int(j) for j in input().split()]\n        graph[l].append(r)\n        graph[r].append(l)\n    for i in range(1, n + 1):\n        graph[i].sort()\n    for i in range(1, n + 1):\n        for city in cities:\n            possible_pos = bisect_left(graph[i], city.num)\n            is_present_in_adj_list = graph[i][possible_pos] == city.num if possible_pos < len(graph[i]) else False\n            if city.num != i and (not is_present_in_adj_list):\n                ans.append(city.num)\n                break\n    ans_str = ''\n    for i in ans:\n        ans_str += str(i) + ' '\n    ans_str.rstrip()\n    print(ans_str)\nsolve()", "for t in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    p = []\n    for (i, ai) in enumerate(a):\n        p.append([i + 1, ai])\n    p.sort(key=lambda ai: ai[1], reverse=True)\n    neighbors = [None]\n    for i in range(n):\n        neighbors.append(list())\n    for i in range(n - 1):\n        e = [int(i) for i in input().split()]\n        neighbors[e[0]].append(e[1])\n        neighbors[e[1]].append(e[0])\n    unsolved = set(range(1, n + 1))\n    solution = dict()\n    i = 0\n    while unsolved:\n        c = p[i][0]\n        here = {c}\n        here.update(set(neighbors[c]))\n        solving = unsolved - here\n        for k in solving:\n            unsolved.remove(k)\n            solution[k] = c\n        i += 1\n    final = [str(solution[i]) for i in range(1, n + 1)]\n    toprint = ' '.join(final)\n    print(toprint)", "for t in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    p = []\n    for (i, ai) in enumerate(a):\n        p.append([i + 1, ai])\n    p.sort(key=lambda ai: ai[1], reverse=True)\n    neighbors = [None]\n    for i in range(n):\n        neighbors.append(list())\n    for i in range(n - 1):\n        e = [int(i) for i in input().split()]\n        neighbors[e[0]].append(e[1])\n        neighbors[e[1]].append(e[0])\n    unsolved = set(range(1, n + 1))\n    solution = dict()\n    i = 0\n    while unsolved:\n        c = p[i][0]\n        here = {c}\n        here.update(set(neighbors[c]))\n        solving = unsolved - here\n        for k in solving:\n            unsolved.remove(k)\n            solution[k] = c\n        i += 1\n    final = [str(solution[i]) for i in range(1, n + 1)]\n    toprint = ' '.join(final)\n    print(toprint)", "def search(a, lower, x, high):\n    mid = (high + lower) // 2\n    if lower <= high:\n        if a[mid] == x:\n            return True\n        elif a[mid] > x:\n            return search(a, lower, x, mid - 1)\n        else:\n            return search(a, mid + 1, x, high)\n    else:\n        return False\nimport bisect\nfrom operator import itemgetter\nfor i in range(int(input())):\n    b = int(input())\n    a = list(map(int, input().split()))\n    v = []\n    for j in range(b - 1):\n        ca = list(map(int, input().split()))\n        v.append([ca[0], ca[1]])\n        v.append([ca[1], ca[0]])\n    r = []\n    for j in range(b):\n        r.append([a[j], j + 1])\n    r.sort(key=itemgetter(0))\n    u = []\n    for em in r:\n        u.append(em[1])\n    v.sort(key=itemgetter(0, 1))\n    v.reverse()\n    x = []\n    for j in range(b):\n        x.append(0)\n    t = 0\n    for j in range(2 * (b - 1)):\n        ba = b - 1\n        if v[j][0] != t:\n            if j < 2 * b - 3:\n                sa = []\n                while j < 2 * b - 3 and v[j][0] == v[j + 1][0] and (ba >= 0):\n                    sa.append(v[j][1])\n                    j += 1\n                    r = j\n                sa.append(v[j][1])\n                sa.reverse()\n                bisect.insort_left(sa, v[j][0], lo=0, hi=len(sa))\n                mad = False\n                while True:\n                    if ba >= 0:\n                        if search(sa, 0, u[ba], len(sa) - 1) == True:\n                            ba -= 1\n                            ram = ba\n                        else:\n                            break\n                    if ba == -1:\n                        mad = True\n                        break\n                if mad == True:\n                    x[v[j][0] - 1] = -1\n                if mad == False:\n                    x[v[j][0] - 1] = u[ba]\n            if j == 2 * b - 3:\n                if v[j][0] == u[ba]:\n                    ba -= 1\n                if v[j][1] == u[ba]:\n                    ba -= 1\n                if v[j][0] == u[ba]:\n                    ba -= 1\n                x[v[j][0] - 1] = u[ba]\n        t = v[j][0]\n    for j in range(b):\n        if x[j] == 0:\n            if j + 1 != u[b - 1]:\n                x[j] = u[b - 1]\n            else:\n                x[j] = u[b - 2]\n        if x[j] == -1:\n            x[j] = 0\n    for j in range(b):\n        print(x[j], end=' ')\n    print()", "def search(a, lower, x, high):\n    mid = (high + lower) // 2\n    if lower <= high:\n        if a[mid] == x:\n            return True\n        elif a[mid] > x:\n            return search(a, lower, x, mid - 1)\n        else:\n            return search(a, mid + 1, x, high)\n    else:\n        return False\nimport bisect\nfrom operator import itemgetter\nfor i in range(int(input())):\n    b = int(input())\n    a = list(map(int, input().split()))\n    v = []\n    for j in range(b - 1):\n        ca = list(map(int, input().split()))\n        v.append([ca[0], ca[1]])\n        v.append([ca[1], ca[0]])\n    r = []\n    for j in range(b):\n        r.append([a[j], j + 1])\n    r.sort(key=itemgetter(0))\n    u = []\n    for em in r:\n        u.append(em[1])\n    v.sort(key=itemgetter(0, 1))\n    v.reverse()\n    x = []\n    for j in range(b):\n        x.append(0)\n    t = 0\n    for j in range(2 * (b - 1)):\n        ba = b - 1\n        if v[j][0] != t:\n            if j < 2 * b - 3:\n                sa = []\n                while j < 2 * b - 3 and v[j][0] == v[j + 1][0] and (ba >= 0):\n                    sa.append(v[j][1])\n                    j += 1\n                    r = j\n                sa.append(v[j][1])\n                sa.reverse()\n                bisect.insort_left(sa, v[j][0], lo=0, hi=len(sa))\n                mad = False\n                while True:\n                    if ba >= 0:\n                        if search(sa, 0, u[ba], len(sa) - 1) == True:\n                            ba -= 1\n                            ram = ba\n                        else:\n                            break\n                    if ba == -1:\n                        mad = True\n                        break\n                if mad == True:\n                    x[v[j][0] - 1] = -1\n                if mad == False:\n                    x[v[j][0] - 1] = u[ba]\n            if j == 2 * b - 3:\n                if v[j][0] == u[ba]:\n                    ba -= 1\n                if v[j][1] == u[ba]:\n                    ba -= 1\n                if v[j][0] == u[ba]:\n                    ba -= 1\n                x[v[j][0] - 1] = u[ba]\n        t = v[j][0]\n    for j in range(b):\n        if x[j] == 0:\n            if j + 1 != u[b - 1]:\n                x[j] = u[b - 1]\n            else:\n                x[j] = u[b - 2]\n        if x[j] == -1:\n            x[j] = 0\n    for j in range(b):\n        print(x[j], end=' ')\n    print()", "def main():\n    from sys import stdin, stdout\n    import collections\n    for _ in range(int(stdin.readline())):\n        n = int(stdin.readline())\n        p = tuple(map(int, stdin.readline().split()))\n        newp = [(p[x], x + 1) for x in range(n)]\n        newp.sort(reverse=True, key=lambda x: x[0])\n        e = collections.defaultdict(set)\n        for _ in range(n - 1):\n            (a, b) = map(int, stdin.readline().split())\n            e[a - 1].add(b - 1)\n            e[a - 1].add(a - 1)\n            e[b - 1].add(a - 1)\n            e[b - 1].add(b - 1)\n        for i in range(n):\n            for x in range(n):\n                if newp[x][1] - 1 not in e[i]:\n                    break\n            stdout.write(str(newp[x][1]) + ' ')\n        stdout.write('\\n')\nmain()", "t = int(input())\nans = []\nfor i in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    p_index = dict()\n    for j in range(n):\n        p_index[p[j]] = j\n    adj_matrix = [set() for _ in range(n)]\n    for j in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        adj_matrix[u].add(p[v])\n        adj_matrix[v].add(p[u])\n    for j in range(n):\n        adj_matrix[j].add(p[j])\n    temp_ans = ''\n    p.sort()\n    for j in range(n):\n        flag = 0\n        idx = -1\n        for k in range(n - 1, -1, -1):\n            if p[k] not in adj_matrix[j]:\n                flag = 1\n                idx = p_index[p[k]]\n                break\n        if flag == 0:\n            temp_ans += '0 '\n        else:\n            temp_ans += str(idx + 1) + ' '\n    ans.append(temp_ans)\nfor x in ans:\n    print(x)", "from collections import defaultdict\nin_capital = [1 for i in range(0, 50001)]\nt = int(input())\nfor testcases in range(0, t):\n    nodes = int(input())\n    graph = defaultdict(list)\n    for i in range(1, nodes + 1):\n        graph[i].append(i)\n    populations = list(map(int, input().split(' ')))\n    for i in range(1, nodes):\n        (a, b) = map(int, input().split(' '))\n        graph[a].append(b)\n        graph[b].append(a)\n    sortpop = [(0, 0)]\n    for i in range(1, nodes + 1):\n        sortpop.append((populations[i - 1], i))\n    sortpop.sort(reverse=True)\n    capitals = [i[1] for i in sortpop]\n    for (pos, i) in enumerate(range(1, nodes + 1)):\n        if len(graph[i]) == nodes:\n            if pos == nodes - 1:\n                print('0')\n            else:\n                print('0', end=' ')\n        else:\n            for elem in graph[i]:\n                in_capital[elem] = 0\n            for elem in capitals:\n                if in_capital[elem] == 1:\n                    if pos == nodes - 1:\n                        print(elem)\n                    else:\n                        print(elem, end=' ')\n                    break\n                else:\n                    pass\n            for elem in graph[i]:\n                in_capital[elem] = 1", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    p = list(reversed(sorted(((int(x), i) for (i, x) in enumerate(input().split())))))\n    edges = defaultdict(set)\n    for _ in range(n - 1):\n        (u, v) = [int(x) - 1 for x in input().split()]\n        edges[u].add(v)\n        edges[v].add(u)\n    a = []\n    for i in range(n):\n        for (x, j) in p:\n            if i != j and j not in edges[i]:\n                a.append(j)\n                break\n        else:\n            a.append(-1)\n    print(' '.join((str(x + 1) for x in a)))", "def solve(pp, tree):\n    return next((p[0] for p in pp if p[0] not in tree))\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    pp = list(enumerate(map(int, input().split())))\n    pp.sort(key=lambda z: z[1], reverse=True)\n    tree = [set([i]) for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        tree[u].add(v)\n        tree[v].add(u)\n    res = list(map(lambda x: solve(pp, tree[x]) + 1, range(n)))\n    print(*res)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = map(int, input().split())\n    p = list(p)\n    l = []\n    for i in range(n):\n        l.append([p[i], i + 1])\n    l.sort(reverse=True)\n    d = dict()\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        d[u, v] = 1\n        d[v, u] = 1\n    s = set(range(0, n))\n    ans = [0] * n\n    dif = set()\n    for i in range(n):\n        for j in s:\n            if (l[i][1], j + 1) not in d and j + 1 != l[i][1]:\n                ans[j] = l[i][1]\n                dif.add(j)\n        s = s - dif\n    print(' '.join((str(x) for x in ans)))\n    print()", "import sys\nfrom collections import defaultdict\nt = int(sys.stdin.readline())\nwhile t:\n    t -= 1\n    n = int(sys.stdin.readline())\n    d = [int(x) for x in sys.stdin.readline().split()]\n    graph = defaultdict(set)\n    for i in range(n - 1):\n        (u, v) = [int(x) for x in sys.stdin.readline().split()]\n        graph[d[u - 1]].add(d[v - 1])\n        graph[d[v - 1]].add(d[u - 1])\n        graph[d[u - 1]].add(d[u - 1])\n        graph[d[v - 1]].add(d[v - 1])\n    index = {d[i]: i + 1 for i in range(n)}\n    max_val = d.copy()\n    max_val.sort(reverse=True)\n    ans = []\n    for i in range(n):\n        values = graph[d[i]]\n        for m in max_val:\n            if m not in values:\n                ans.append(str(index[m]))\n                break\n    print(' '.join(ans))", "import sys\nfrom collections import defaultdict\nfrom pprint import pprint\n\nclass graph:\n\n    def __init__(self):\n        self.d = defaultdict(list)\n\n    def addedge(self, u, v):\n        self.d[u].append(v)\n        self.d[v].append(u)\nt = int(sys.stdin.readline())\n\nclass population:\n\n    def __init__(self, index, popu):\n        self.index = index\n        self.popu = popu\n\n    def __eq__(self, other):\n        return self.popu == other.popu\n\n    def __hash__(self):\n        return hash(self.index)\nwhile t:\n    n = int(sys.stdin.readline())\n    population_list = [int(x) for x in sys.stdin.readline().split()]\n    population_class_list = []\n    for i in range(n):\n        population_class_list.append(population(i, population_list[i]))\n    population_class_list = sorted(population_class_list, key=lambda k: k.popu, reverse=True)\n    g = graph()\n    for i in range(n - 1):\n        (u, v) = map(int, sys.stdin.readline().split())\n        g.addedge(u - 1, v - 1)\n    tmp_str = ''\n    for i in range(n):\n        removing_set = set()\n        removing_set.add(i)\n        try:\n            g.d[i]\n            removing_set = removing_set | set(g.d[i])\n            for i in population_class_list:\n                if i.index not in removing_set:\n                    if tmp_str == '':\n                        tmp_str = str(i.index + 1)\n                    else:\n                        tmp_str = tmp_str + ' ' + str(i.index + 1)\n                    break\n        except KeyError:\n            if tmp_str == '':\n                tmp_str = str(i.index + 1)\n            else:\n                tmp_str = tmp_str + ' ' + str(i.index + 1)\n            pass\n    print(tmp_str)\n    t = t - 1", "def main(args):\n    T = int(input())\n    while T:\n        T -= 1\n        N = int(input())\n        P = list(map(int, input().split()))\n        k = 0\n        p_map = {}\n        for i in P:\n            k += 1\n            p_map[i] = k\n        Q = list(P)\n        Q.sort(reverse=True)\n        citymap = [[P[i]] for i in range(N)]\n        for i in range(N - 1):\n            (a, b) = list(map(int, input().split()))\n            citymap[a - 1].append(P[b - 1])\n            citymap[b - 1].append(P[a - 1])\n        for i in range(N):\n            citymap[i].sort(reverse=True)\n        for i in range(N):\n            l = 0\n            max = Q[0]\n            for j in citymap[i]:\n                if j >= max:\n                    l += 1\n                    max = Q[l]\n            print(p_map[max], end=' ')\n    return 0\nimport sys\nsys.exit(main(sys.argv))", "t = int(input())\nfor t0 in range(t):\n    n = int(input())\n    p = [int(i) for i in input().strip().split()]\n    di2 = dict()\n    for i in range(n):\n        p[i] = [p[i], i + 1]\n    dic = dict()\n    for i in range(1, n + 1):\n        dic[i] = [i]\n    for i in range(n - 1):\n        s = [int(i) for i in input().strip().split()]\n        (a, b) = (s[0], s[1])\n        dic[a].append(b)\n        dic[b].append(a)\n    p.insert(0, [0, 0])\n    ans = []\n    mx = 0\n    srt = sorted(p, key=lambda x: x[0], reverse=True)\n    for i in range(1, n + 1):\n        mx = -1\n        for k in srt:\n            fl = 0\n            for j in dic[i]:\n                if p[j][0] == k[0]:\n                    fl = 1\n                    break\n            if fl == 0:\n                mx = k[1]\n                break\n        if mx == -1:\n            ans.append(0)\n        else:\n            ans.append(mx)\n    print(*ans)", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    d = defaultdict(set)\n    n = int(input())\n    p = list(map(int, input().split()))\n    for _ in range(n - 1):\n        (x, y) = map(int, input().split())\n        d[x].add(y)\n        d[y].add(x)\n    arr = [(value, index + 1) for (index, value) in enumerate(p)]\n    arr.sort(reverse=True)\n    ans = []\n    for i in range(1, n + 1):\n        s = d[i]\n        flag = False\n        for (value, index) in arr:\n            if index not in s and index != i:\n                ans.append(index)\n                flag = True\n                break\n        if not flag:\n            ans.append(0)\n    print(*ans, sep=' ')", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    adj_list = [{} for i in range(n)]\n    pis = [(index, int(x)) for (index, x) in enumerate(input().strip().split())]\n    for i in range(n - 1):\n        (u, v) = [int(x) for x in input().strip().split()]\n        adj_list[u - 1][v - 1] = True\n        adj_list[v - 1][u - 1] = True\n    answer_array = [0] * n\n    pis.sort(key=lambda x: x[1], reverse=True)\n    for i in range(n):\n        for city in pis:\n            pass\n            if city[0] == i or city[0] in adj_list[i]:\n                answer_array[i] += 1\n            else:\n                break\n    for (i, val) in enumerate(answer_array):\n        answer_array[i] = pis[val][0] + 1\n    print(' '.join((str(x) for x in answer_array)))\n    t -= 1", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a1 = [(a[i], i + 1) for i in range(n)]\n    a1.sort(key=lambda x: x[0])\n    mm = {i + 1: set() for i in range(n)}\n    for _ in range(n - 1):\n        (x, y) = map(int, input().split())\n        mm[x].add(y)\n        mm[y].add(x)\n    res = []\n    for i in range(1, n + 1):\n        flag = True\n        for j in range(n, 0, -1):\n            if a1[j - 1][1] not in mm[i] and i != a1[j - 1][1] and flag:\n                res.append(a1[j - 1][1])\n                flag = False\n                break\n        if flag:\n            res.append(0)\n    print(' '.join(map(str, res)))", "from operator import itemgetter\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    pi = [int(x) for x in input().split()]\n    i = 1\n    planet = []\n    for x in pi:\n        p = [i, x]\n        i += 1\n        planet.append(p)\n    planets = sorted(planet, key=itemgetter(1))\n    copy = sorted(planet, key=itemgetter(1))\n    adjlist = []\n    numneighpls = []\n    for i in range(0, n):\n        adjlist.append([])\n        numneighpls.append(0)\n    sortedlist = []\n    i = 0\n    while i < n - 1:\n        ppair = [int(x) for x in input().split()]\n        p1 = ppair[0]\n        p2 = ppair[1]\n        adjlist[p1 - 1].append(planet[p2 - 1][1])\n        adjlist[p2 - 1].append(planet[p1 - 1][1])\n        numneighpls[p1 - 1] += 1\n        numneighpls[p2 - 1] += 1\n        i += 1\n    for i in range(0, n):\n        adjlist[i].append(planet[i][1])\n    for i in range(0, n):\n        adjlist[i].sort()\n        numneighpls[i] += 1\n    for i in range(0, n):\n        maxind = n - 1\n        maxim = planets[maxind][1]\n        j = numneighpls[i] - 1\n        while 1:\n            if maxim != adjlist[i][j]:\n                print(planets[maxind][0], end=' ')\n                break\n            else:\n                j -= 1\n                maxind -= 1\n                maxim = planets[maxind][1]", "tc = int(input())\ncurrent = []\nbranch = {}\npop = []\n\ndef f(u, v):\n    set(u, v)\n    if pop[current[u]][0] == v:\n        p = current[u]\n        while p == 0 or not ifAvail(u, p):\n            p = p - 1\n        current[u] = p\n\ndef ifAvail(u, p):\n    return not get(u, pop[p][0])\n\ndef get(u, v):\n    if u == v:\n        return True\n    u = str(u)\n    v = str(v)\n    s = u + ' ' + v if u <= v else v + ' ' + u\n    return s in branch\n\ndef set(u, v):\n    u = str(u)\n    v = str(v)\n    branch[u + ' ' + v if u <= v else v + ' ' + u] = True\nfor t in range(tc):\n    current = []\n    branch = {}\n    pop = []\n    n = int(input())\n    pop = input().split(' ')\n    pop = [int(p) for p in pop]\n    pop = [-1] + pop\n    pop = sorted(enumerate(pop), key=lambda k: k[1])\n    current = [n for x in range(n + 1)]\n    current[pop[n][0]] = n - 1\n    for x in range(n - 1):\n        (u, v) = input().split(' ')\n        u = int(u)\n        v = int(v)\n        f(u, v)\n        f(v, u)\n    print(*[pop[p][0] for p in current[1:]])", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    pop = list(map(int, input().split()))\n    ind = []\n    for i in range(len(pop)):\n        ind.append((pop[i], i + 1))\n    ind.sort(reverse=True)\n    max_list = []\n    for el in ind:\n        max_list.append(el[1])\n    adj = []\n    for j in range(n):\n        adj.append([j + 1])\n    for j in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a - 1].append(b)\n        adj[b - 1].append(a)\n    for k in range(n):\n        j = -1\n        while True:\n            j += 1\n            if max_list[j] not in adj[k]:\n                break\n        print(max_list[j], end=' ')", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    (brr, brray) = ({}, {})\n    arr = list(map(int, input().split()))\n    array = sorted(arr)\n    for i in range(n):\n        brr[arr[i]] = i\n        brray[array[i]] = i\n    graph = defaultdict(set)\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a - 1].add(b - 1)\n        graph[b - 1].add(a - 1)\n    for i in range(n):\n        for j in range(n - 1, -1, -1):\n            if brr[array[j]] not in graph[i] and i != brr[array[j]]:\n                print(brr[array[j]] + 1, end=' ')\n                break\n        else:\n            print(0, end=' ')", "def diff(a, b):\n    i = 0\n    while i < len(a) and i < len(b) and (a[i] == b[i]):\n        i += 1\n    if i == len(b):\n        return -1\n    return b[i]\nfor _ in range(int(input())):\n    n = int(input())\n    pi = list(map(int, input().split()))\n    temp = pi\n    indexes = {-1: 0}\n    for i in range(n):\n        indexes[pi[i]] = i + 1\n    pi = sorted(pi, reverse=True)\n    adj_list = [[temp[x - 1]] for x in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj_list[u] += [temp[v - 1]]\n        adj_list[v] += [temp[u - 1]]\n    for i in range(1, n):\n        adj_list[i] = sorted(adj_list[i], reverse=True)\n        print(indexes[diff(adj_list[i], pi)], end=' ')\n    adj_list[n] = sorted(adj_list[n], reverse=True)\n    print(indexes[diff(adj_list[n], pi)])", "import operator\ni = int(input())\ns = {}\nfor j in range(i):\n    n = int(input())\n    l = list(map(int, input().split()))\n    d = dict(zip(range(1, n + 1), l))\n    for k in range(n + 1):\n        s[k] = set()\n    for _ in range(n - 1):\n        (a, b) = input().split()\n        a = int(a)\n        b = int(b)\n        s[a].add(b)\n        s[b].add(a)\n    d = sorted(d.items(), key=operator.itemgetter(1))\n    d.reverse()\n    for i in range(1, n + 1):\n        ans = 0\n        for j in d:\n            if j[0] not in s[i] and j[0] != i:\n                ans = j[0]\n                break\n        print(ans, end=' ')\n        ans = 0\n    print()", "from collections import defaultdict, OrderedDict\nfrom operator import itemgetter\n\ndef binarySearch(arr, l, r, x):\n    if r >= l:\n        mid = l + (r - l) // 2\n        if arr[mid] == x:\n            return True\n        elif arr[mid] > x:\n            return binarySearch(arr, l, mid - 1, x)\n        else:\n            return binarySearch(arr, mid + 1, r, x)\n    else:\n        return False\nfor test in range(int(input())):\n    n = int(input())\n    pop = {}\n    p = list(map(int, input().split()))\n    j = 1\n    for i in p:\n        pop[i] = j\n        j += 1\n    t = -1\n    lst = sorted(pop.keys())\n    edg = defaultdict(list)\n    j = 0\n    for i in range(1, n):\n        (a, b) = map(int, input().split())\n        edg[a].append(b)\n        edg[b].append(a)\n    for i in range(1, n):\n        edg[i].sort()\n    for i in range(1, n + 1):\n        t = -1\n        while True:\n            if binarySearch(edg[i], 0, len(edg[i]) - 1, pop[lst[t]]) == False and i != pop[lst[t]]:\n                print(pop[lst[t]], end=' ')\n                break\n            elif len(edg[i]) == n - 1:\n                print('0 ', end='')\n                break\n            t -= 1\n    print('')", "t = int(input())\nfor a0 in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split(' ')]\n    b = {}\n    pop = {}\n    for i in range(n):\n        pop[a[i]] = i + 1\n    a.sort()\n    ind = []\n    for i in a:\n        ind.append(pop[i])\n    for i in range(1, n + 1):\n        b[i] = [i]\n    for i in range(n - 1):\n        (u, v) = input().split(' ')\n        (u, v) = [int(u), int(v)]\n        b[u].append(v)\n        b[v].append(u)\n    for i in b:\n        temp = b[i]\n        for i in range(n - 1, -1, -1):\n            if ind[i] not in temp:\n                print(ind[i], end=' ')\n                break", "t = int(input())\nfor _ in range(0, t):\n    n = int(input())\n    populations = list(map(int, input().split()))\n    planets = []\n    paths = {}\n    for i in range(0, n):\n        planet = (populations[i], i + 1)\n        planets.append(planet)\n        paths[i + 1] = [i + 1]\n    for i in range(1, n):\n        (a, b) = map(int, input().split())\n        paths[a].append(b)\n        paths[b].append(a)\n    planets.sort(reverse=True)\n    for i in range(1, n + 1):\n        temp = list(paths[i])\n        for i in range(0, n):\n            if planets[i][1] not in temp:\n                print(planets[i][1], end=' ')\n                break", "from collections import defaultdict\nfor test in range(int(input())):\n    n = int(input())\n    pop = {}\n    p = list(map(int, input().split()))\n    j = 1\n    for i in p:\n        pop[i] = j\n        j += 1\n    t = -1\n    lst = sorted(pop.keys())\n    edg = defaultdict(list)\n    j = 0\n    for i in range(1, n):\n        (a, b) = map(int, input().split())\n        edg[a].append(b)\n        edg[b].append(a)\n    for i in range(1, n + 1):\n        t = -1\n        while True:\n            if pop[lst[t]] not in edg[i] and i != pop[lst[t]]:\n                print(pop[lst[t]], end=' ')\n                break\n            elif len(edg[i]) == n - 1:\n                print('0 ', end='')\n            t -= 1\n    print('')", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    a = [[] for x in range(n + 3)]\n    ip = []\n    for m in range(n):\n        ip.append([p[m], m + 1])\n    ip.sort()\n    ip.reverse()\n    for j in range(n - 1):\n        (x, y) = list(map(int, input().split()))\n        a[x].append([p[y - 1], y])\n        a[y].append([p[x - 1], x])\n    for j in range(1, n + 1):\n        a[j].append([p[j - 1], j])\n        a[j].sort()\n        a[j].reverse()\n    for j in range(1, n + 1):\n        temp = a[j]\n        ind = 0\n        for k in temp:\n            if ip[ind][0] == k[0]:\n                ind += 1\n            else:\n                break\n        print(ip[ind][1] if ind < n - 1 else '0', end=' ')", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    a = [[] for x in range(n + 3)]\n    ip = []\n    for m in range(n):\n        ip.append([p[m], m + 1])\n    ip.sort()\n    ip.reverse()\n    for j in range(n - 1):\n        (x, y) = list(map(int, input().split()))\n        a[x].append([p[y - 1], y])\n        a[y].append([p[x - 1], x])\n    for j in range(1, n + 1):\n        a[j].append([p[j - 1], j])\n        a[j].sort()\n        a[j].reverse()\n    for j in range(1, n + 1):\n        temp = a[j]\n        ind = 0\n        for k in temp:\n            if ip[ind][0] == k[0]:\n                ind += 1\n            else:\n                break\n        print(ip[ind][1] if ind > -1 else '0', end=' ')", "T = int(input())\nwhile T > 0:\n    n = int(input())\n    adj = list()\n    p = list()\n    b = input().split()\n    for i in range(1, n + 1):\n        adj.append([i])\n        p.append([int(b[i - 1]), i])\n    p.sort()\n    pop = list()\n    index = list()\n    for i in range(0, n):\n        pop.append(p[i][0])\n        index.append(p[i][1])\n    for i in range(1, n):\n        a = input().split()\n        adj[int(a[0]) - 1].append(int(a[1]))\n        adj[int(a[1]) - 1].append(int(a[0]))\n    mi = n - 1\n    mc = n - 1\n    m = index[mi]\n    for i in adj:\n        while index[mi] in i:\n            if mi > 0:\n                mi = mi - 1\n                m = index[mi]\n            else:\n                m = 0\n                break\n        print(m, end=' ')\n        mi = mc\n        m = index[mi]\n    T = T - 1\n    print()", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    po = s.split()\n    p = {}\n    for j in range(n):\n        p[int(po[j])] = j + 1\n    k = list(p.keys())\n    k.sort(reverse=True)\n    tel = {}\n    for j in range(n):\n        tel[j + 1] = []\n    for j in range(n - 1):\n        b = input()\n        c = b.split()\n        tel[int(c[0])].append(int(c[1]))\n        tel[int(c[1])].append(int(c[0]))\n    for j in range(n):\n        for l in range(n):\n            if p[k[l]] in tel[j + 1]:\n                continue\n            elif p[k[l]] == j + 1:\n                continue\n            else:\n                print(p[k[l]], end=' ')\n                break", "import numpy as np\n\ndef check(N, pop, teleports):\n    pop_idx = np.argsort(pop)[::-1]\n    pop_idx = [int(i + 1) for i in pop_idx]\n    G = {}\n    for i in range(1, N + 1):\n        G[i] = [i]\n    capitals = [(pop_idx[0], 0)] * N\n    for (u, v) in teleports:\n        G[u].append(v)\n        G[v].append(u)\n        if capitals[u - 1][0] == u or capitals[u - 1][0] == v:\n            neighbors = G[u]\n            changed = False\n            for i in range(capitals[u - 1][1], N - 1):\n                if pop_idx[i] not in neighbors:\n                    capitals[u - 1] = (pop_idx[i], i)\n                    changed = True\n                    break\n            if not changed:\n                capitals[u - 1] = (0, N - 1)\n        if capitals[v - 1][0] == u or capitals[v - 1][0] == v:\n            neighbors = G[v]\n            changed = False\n            for i in range(capitals[v - 1][1], N - 1):\n                if pop_idx[i] not in neighbors:\n                    capitals[v - 1] = (pop_idx[i], i)\n                    changed = True\n                    break\n            if not changed:\n                capitals[v - 1] = (0, N - 1)\n    return [str(capitals[i][0]) for i in range(len(capitals))]\nT = int(input().strip())\nfor _ in range(T):\n    N = int(input().strip())\n    pop = list(map(int, input().strip().split()))\n    teleports = [tuple(map(int, input().strip().split())) for _ in range(N - 1)]\n    print(' '.join(check(N, pop, teleports)))", "def solve(populations, links):\n    cities = []\n    for i in range(1, len(populations)):\n        cities.append((i, populations[i]))\n    cities.sort(key=lambda c: c[1], reverse=True)\n    solution = []\n    for i in range(1, len(links)):\n        infected_cities = [(i, populations[i])]\n        for k in links[i]:\n            infected_cities.append((k, populations[k]))\n        infected_cities.sort(key=lambda c: c[1], reverse=True)\n        i1 = 0\n        i2 = 0\n        while i1 < len(cities) and i2 < len(infected_cities) and (cities[i1] == infected_cities[i2]):\n            i1 += 1\n            i2 += 1\n        if i1 < len(cities):\n            solution.append(cities[i1][0])\n        else:\n            solution.append(-1)\n    return solution\nT = int(input())\nwhile T > 0:\n    N = int(input())\n    populations = [int(x) for x in input().split()]\n    populations = [0] + populations\n    links = [[] for x in range(1, N + 1)]\n    links = [[]] + links\n    for i in range(N - 1):\n        (V, U) = [int(x) for x in input().split()]\n        links[V].append(U)\n        links[U].append(V)\n    solution = solve(populations, links)\n    for p in solution:\n        print(p, end=' ')\n    print('')\n    T -= 1"]