["import numpy as np\nfor _ in range(int(input())):\n    n = int(input()) - 1\n    soldiers = [int(j) for j in input().split()]\n    force = int(input())\n    attacks = np.zeros(2 * n, dtype=int)\n    attacks[:n] = np.array(soldiers)\n    attacks[n:2 * n] = attacks[:n]\n    shield = [0 for _ in range(n)]\n    pow_of_2 = 1\n    while n // pow_of_2 > 0:\n        pow_of_2 *= 2\n    soldier_of_attack = (2 * n - pow_of_2) % n\n    pow_of_2 = attacks[soldier_of_attack] > force\n    for i in range(n):\n        if attacks[i] > force:\n            shield[i] = 10 ** 11\n        elif n == 1:\n            shield[i] = force\n        elif pow_of_2:\n            shield[i] = force\n            num_of_survivors = n\n            soldiers = list(attacks[i:i + n])\n            starting_soldier = (n - i) % n\n            if (num_of_survivors - starting_soldier) % 2 == 1:\n                shield[i] += soldiers[-1]\n            soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0]\n            num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\n            if num_of_survivors > 1:\n                pow_2 = 1\n                while True:\n                    attacker = num_of_survivors - num_of_survivors % pow_2\n                    pow_2 *= 2\n                    if attacker == 0:\n                        break\n                    if attacker % pow_2 == 0:\n                        shield[i] += soldiers[attacker]\n        elif i == soldier_of_attack:\n            shield[i] = force\n        else:\n            shield[i] = force + 1\n    shield_needed = min(shield)\n    if shield_needed == 10 ** 11:\n        print('impossible')\n    else:\n        print('possible')\n        for i in range(n):\n            if shield[i] == shield_needed:\n                print(str(i + 1) + ' ' + str(shield_needed))\n                break", "import numpy as np\nfor _ in range(int(input())):\n    n = int(input()) - 1\n    soldiers = [int(j) for j in input().split()]\n    force = int(input())\n    attacks = np.zeros(2 * n, dtype=int)\n    attacks[:n] = np.array(soldiers)\n    attacks[n:2 * n] = attacks[:n]\n    shield = [0 for _ in range(n)]\n    pow_of_2 = 1\n    while n // pow_of_2 > 0:\n        pow_of_2 *= 2\n    soldier_of_attack = (2 * n - pow_of_2) % n\n    pow_of_2 = attacks[soldier_of_attack] > force\n    for i in range(n):\n        if attacks[i] > force:\n            shield[i] = 10 ** 11\n        elif n == 1:\n            shield[i] = force\n        elif pow_of_2:\n            shield[i] = force\n            num_of_survivors = n\n            soldiers = list(attacks[i:i + n])\n            starting_soldier = (n - i) % n\n            if (num_of_survivors - starting_soldier) % 2 == 1:\n                shield[i] += soldiers[-1]\n            soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0]\n            num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\n            if num_of_survivors > 1:\n                pow_2 = 1\n                while True:\n                    attacker = num_of_survivors - num_of_survivors % pow_2\n                    pow_2 *= 2\n                    if attacker == 0:\n                        break\n                    if attacker % pow_2 == 0:\n                        shield[i] += soldiers[attacker]\n        elif i == soldier_of_attack:\n            shield[i] = force\n        else:\n            shield[i] = force + 1\n    shield_needed = min(shield)\n    if shield_needed == 10 ** 11:\n        print('impossible')\n    else:\n        print('possible')\n        for i in range(n):\n            if shield[i] == shield_needed:\n                print(str(i + 1) + ' ' + str(shield_needed))\n                break", "import numpy as np\nfor _ in range(int(input())):\n    n = int(input()) - 1\n    soldiers = [int(j) for j in input().split()]\n    force = int(input())\n    attacks = np.zeros(2 * n, dtype=int)\n    attacks[:n] = np.array(soldiers)\n    attacks[n:2 * n] = attacks[:n]\n    shield = [0 for _ in range(n)]\n    pow_of_2 = 1\n    while n // pow_of_2 > 0:\n        pow_of_2 *= 2\n    soldier_of_attack = (2 * n - pow_of_2) % n\n    pow_of_2 = attacks[soldier_of_attack] > force\n    for i in range(n):\n        if attacks[i] > force:\n            shield[i] = 10 ** 11\n        elif n == 1:\n            shield[i] = force\n        elif pow_of_2:\n            shield[i] = force\n            num_of_survivors = n\n            soldiers = list(attacks[i:i + n])\n            starting_soldier = (n - i) % n\n            if (num_of_survivors - starting_soldier) % 2 == 1:\n                shield[i] += soldiers[-1]\n            soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0]\n            num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\n            if num_of_survivors > 1:\n                pow_2 = 1\n                while True:\n                    attacker = num_of_survivors - num_of_survivors % pow_2\n                    pow_2 *= 2\n                    if attacker == 0:\n                        break\n                    if attacker % pow_2 == 0:\n                        shield[i] += soldiers[attacker]\n        elif i == soldier_of_attack:\n            shield[i] = force\n        else:\n            shield[i] = force + 1\n    shield_needed = min(shield)\n    if shield_needed == 10 ** 11:\n        print('impossible')\n    else:\n        print('possible')\n        for i in range(n):\n            if shield[i] == shield_needed:\n                print(str(i + 1) + ' ' + str(shield_needed))\n                break", "import numpy as np\nfor _ in range(int(input())):\n    n = int(input()) - 1\n    soldiers = [int(j) for j in input().split()]\n    force = int(input())\n    attacks = np.zeros(2 * n, dtype=int)\n    attacks[:n] = np.array(soldiers)\n    attacks[n:2 * n] = attacks[:n]\n    shield = [0 for _ in range(n)]\n    pow_of_2 = 1\n    while n // pow_of_2 > 0:\n        pow_of_2 *= 2\n    soldier_of_attack = (2 * n - pow_of_2) % n\n    pow_of_2 = attacks[soldier_of_attack] > force\n    for i in range(n):\n        if attacks[i] > force:\n            shield[i] = 10 ** 11\n        elif n == 1:\n            shield[i] = force\n        elif pow_of_2:\n            shield[i] = force\n            num_of_survivors = n\n            soldiers = list(attacks[i:i + n])\n            starting_soldier = (n - i) % n\n            if (num_of_survivors - starting_soldier) % 2 == 1:\n                shield[i] += soldiers[-1]\n            soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0]\n            num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\n            if num_of_survivors > 1:\n                pow_2 = 1\n                while True:\n                    attacker = num_of_survivors - num_of_survivors % pow_2\n                    pow_2 *= 2\n                    if attacker == 0:\n                        break\n                    if attacker % pow_2 == 0:\n                        shield[i] += soldiers[attacker]\n        elif i == soldier_of_attack:\n            shield[i] = force\n        else:\n            shield[i] = force + 1\n    shield_needed = min(shield)\n    if shield_needed == 10 ** 11:\n        print('impossible')\n    else:\n        print('possible')\n        for i in range(n):\n            if shield[i] == shield_needed:\n                print(str(i + 1) + ' ' + str(shield_needed))\n                break", "import numpy as np\nfor _ in range(int(input())):\n    n = int(input()) - 1\n    soldiers = [int(j) for j in input().split()]\n    force = int(input())\n    attacks = np.zeros(2 * n, dtype=int)\n    attacks[:n] = np.array(soldiers)\n    attacks[n:2 * n] = attacks[:n]\n    shield = [0 for _ in range(n)]\n    pow_of_2 = 1\n    while n // pow_of_2 > 0:\n        pow_of_2 *= 2\n    soldier_of_attack = (2 * n - pow_of_2) % n\n    pow_of_2 = attacks[soldier_of_attack] > force\n    for i in range(n):\n        if attacks[i] > force:\n            shield[i] = 10 ** 11\n        elif n == 1:\n            shield[i] = force\n        elif pow_of_2:\n            shield[i] = force\n            num_of_survivors = n\n            soldiers = list(attacks[i:i + n])\n            starting_soldier = (n - i) % n\n            if (num_of_survivors - starting_soldier) % 2 == 1:\n                shield[i] += soldiers[-1]\n            soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0]\n            num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\n            if num_of_survivors > 1:\n                pow_2 = 1\n                while True:\n                    attacker = num_of_survivors - num_of_survivors % pow_2\n                    pow_2 *= 2\n                    if attacker == 0:\n                        break\n                    if attacker % pow_2 == 0:\n                        shield[i] += soldiers[attacker]\n        elif i == soldier_of_attack:\n            shield[i] = force\n        else:\n            shield[i] = force + 1\n    shield_needed = min(shield)\n    if shield_needed == 10 ** 11:\n        print('impossible')\n    else:\n        print('possible')\n        for i in range(n):\n            if shield[i] == shield_needed:\n                print(str(i + 1) + ' ' + str(shield_needed))\n                break", "import numpy as np\ntests = int(input())\nfor _ in range(tests):\n    n = int(input()) - 1\n    soldiers = [int(j) for j in input().split()]\n    force = int(input())\n    attacks = np.zeros(2 * n, dtype=int)\n    attacks[:n] = np.array(soldiers)\n    attacks[n:2 * n] = attacks[:n]\n    shield = [0 for _ in range(n)]\n    pow_of_2 = 1\n    while n // pow_of_2 > 0:\n        pow_of_2 *= 2\n    soldier_of_attack = (2 * n - pow_of_2) % n\n    pow_of_2 = attacks[soldier_of_attack] > force\n    for i in range(n):\n        if attacks[i] > force:\n            shield[i] = 10 ** 11\n        elif n == 1:\n            shield[i] = force\n        elif pow_of_2:\n            shield[i] = force\n            num_of_survivors = n\n            soldiers = list(attacks[i:i + n])\n            starting_soldier = (n - i) % n\n            if (num_of_survivors - starting_soldier) % 2 == 1:\n                shield[i] += soldiers[-1]\n            soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0]\n            num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\n            if num_of_survivors > 1:\n                pow_2 = 1\n                while True:\n                    attacker = num_of_survivors - num_of_survivors % pow_2\n                    pow_2 *= 2\n                    if attacker == 0:\n                        break\n                    if attacker % pow_2 == 0:\n                        shield[i] += soldiers[attacker]\n        elif i == soldier_of_attack:\n            shield[i] = force\n        else:\n            shield[i] = force + 1\n    shield_needed = min(shield)\n    if shield_needed == 10 ** 11:\n        print('impossible')\n    else:\n        print('possible')\n        for i in range(n):\n            if shield[i] == shield_needed:\n                print(str(i + 1) + ' ' + str(shield_needed))\n                break", "def solve_small(numbers, n, f):\n    found = False\n    min_shield = 0\n    min_pos = 0\n    for pos in range(n):\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n        new_numbers = [_ for _ in numbers]\n        new_numbers.insert(pos, 0)\n        curr_pos = 0\n        while len(new_numbers) > 2:\n            next_pos = (curr_pos + 1) % len(new_numbers)\n            if new_numbers[next_pos] <= 0:\n                new_numbers[next_pos] -= new_numbers[curr_pos]\n            elif new_numbers[curr_pos] > 0:\n                new_numbers.pop(next_pos)\n            else:\n                pass\n            if curr_pos >= len(new_numbers) - 1:\n                curr_pos = 0\n            else:\n                curr_pos += 1\n        (shield, min_f) = (-min(new_numbers), max(new_numbers))\n        if min_f > f:\n            continue\n        shield += f\n        found = True\n        if not min_shield or min_shield > shield:\n            min_shield = shield\n            min_pos = pos\n    if found:\n        print('possible')\n        return (min_pos + 1, min_shield)\n    else:\n        print('impossible')\n        return (0, 0)\n\ndef solve_med(numbers, n, f):\n    min_shield = 0\n    min_pos = 0\n    left_numbers = []\n    right_numbers = [0] + [_ for _ in numbers]\n    for pos in range(0, n):\n        right_numbers.pop(0)\n        if pos % 2:\n            left_numbers.append(numbers[pos - 1])\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n        shield = f\n        if pos % 2:\n            shield += numbers[pos - 1]\n        new_numbers = right_numbers + left_numbers\n        jos_pos = len(new_numbers)\n        new_pos = jos_pos\n        factor = 2\n        while new_pos > 1:\n            if new_pos % 2:\n                number = new_numbers[get_prev_multiple(jos_pos, factor)]\n                number2 = numbers[get_prev_multiple_2(n - 1, pos, factor)]\n                shield += number\n            new_pos = new_pos // 2 + new_pos % 2\n            factor *= 2\n        if not min_shield or shield < min_shield:\n            min_shield = shield\n            min_pos = pos + 1\n    if min_shield:\n        print('possible')\n    else:\n        print('impossible')\n    return (min_pos, min_shield)\n\ndef get_prev_multiple_2(n, pos, f):\n    left_numbers = (pos - 1) // 2\n    right_numbers = n - pos\n    total_numbers = left_numbers + right_numbers\n    number = total_numbers - total_numbers % f\n    if number >= right_numbers:\n        number = number - right_numbers\n        return 2 * number\n    else:\n        return pos + number\n\ndef get_prev_multiple(n, f):\n    return n - 1 - (n - 1) % f\n\ndef get_input_line():\n    return input()\n\ndef solve_big(numbers, n, f):\n    min_shield = 0\n    min_pos = 0\n    for pos in range(0, n):\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n        shield = f\n        if pos % 2:\n            shield += numbers[pos - 1]\n        jos_pos = (pos - 1) // 2 + n - pos\n        new_pos = jos_pos\n        factor = 2\n        over = False\n        while new_pos > 1:\n            if new_pos % 2:\n                number = numbers[get_prev_multiple_2(n - 1, pos, factor)]\n                shield += number\n                if min_shield and shield >= min_shield:\n                    over = True\n                    break\n            new_pos = new_pos // 2 + new_pos % 2\n            factor *= 2\n        if over:\n            continue\n        if not min_shield or shield < min_shield:\n            min_shield = shield\n            min_pos = pos + 1\n    if min_shield:\n        print('possible')\n    else:\n        print('impossible')\n    return (min_pos, min_shield)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    numbers = list(map(int, input().split(' ')))\n    f = int(input())\n    (min_pos, min_shield) = solve_big(numbers, n, f)\n    if min_shield:\n        print(min_pos, min_shield)", "def solution(a, n, f):\n    idxs = []\n    i = 0\n    while i < n - 1:\n        if a[i] <= f:\n            idxs.append(i)\n        i += 1\n    if len(idxs) == 0:\n        print('impossible')\n        return\n    mn = 1000000000\n    for k in idxs:\n        left = k\n        pts = 0\n        elm = left - 1\n        right = n - 1 - left\n        last = n - 2\n        sub = a[elm]\n        sleft = 1\n        slast = 1\n        while left > 0:\n            if left % 2 == 0:\n                elm -= sleft\n                sub = a[elm]\n                left = left // 2\n                sleft *= 2\n            else:\n                pts += a[elm]\n                left = (left + 1) // 2\n                sleft *= 2\n            if right % 2 == 0:\n                last -= slast\n                right //= 2\n                slast *= 2\n            else:\n                slast *= 2\n                left -= 1\n                right = (right + 1) // 2\n        while right > 2:\n            if right % 2 == 0:\n                last -= slast\n                sub = a[last]\n                right = right // 2\n                slast *= 2\n            else:\n                slast *= 2\n                sub = a[last]\n                pts += sub\n                right = (right + 1) // 2\n        if mn > pts:\n            mn = pts\n            idx = k\n            if pts == 0:\n                break\n    print('possible')\n    print(idx + 1, mn + f)\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int, input().split()))\n        f = int(input())\n        solution(a, n, f)\nmain()", "import math\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safepos(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef calculate(l, N):\n    size = len(l)\n    while size > 2:\n        if size % 2 == 0:\n            l[0] = l[0] + l[-1]\n        aux = l[1:N:2]\n        aux2 = [l[0]]\n        l = aux2 + aux\n        size = len(l)\n    return l[0]\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    f = int(input())\n    x = []\n    for i in range(len(l)):\n        x.append(i)\n    sf = list(filter(lambda y: l[y] <= f, x))\n    sflen = len(sf)\n    if sflen == 0:\n        print('impossible')\n    else:\n        anw = safepos(n - 1)\n        anw = anw - 1\n        if anw in sf:\n            print('possible')\n            print(anw + 1, f)\n        else:\n            mxd = math.inf\n            for dd in range(0, len(sf)):\n                templ = l[:]\n                templ.insert(sf[dd], f)\n                t1 = []\n                t2 = []\n                for zz in range(0, sf[dd], 2):\n                    t1.append(templ[zz])\n                for ee in range(sf[dd], len(templ)):\n                    t2.append(templ[ee])\n                templ = t2 + t1\n                if len(t1) > 0:\n                    if sf[dd] % 2 != 0:\n                        templ[0] = templ[0] + t1[-1]\n                fans = calculate(templ, n)\n                if fans < mxd:\n                    mxd = fans\n                    pos = sf[dd]\n            print('possible')\n            print(pos + 1, mxd)", "def solvebrute(a, f, n):\n    (bestd, bestp) = (1000000000000000.0, -1)\n    for p in range(1, n + 1):\n        if a[(p - 1) % (n - 1)] > f:\n            continue\n        b = a[0:p - 1] + [-1] + a[p - 1:]\n        jidx = p - 1\n        alive = [1 for _ in range(n)]\n        alive[jidx] = -1\n        nalive = n - 1\n        i = 0 if p != 1 else 1\n        cd = 0\n        while nalive != 1:\n            killer = i\n            i += 1\n            i %= n\n            while alive[i] == 0:\n                i += 1\n                i %= n\n            killed = i\n            if killed == jidx:\n                cd += b[killer]\n            else:\n                alive[killed] = 0\n                nalive -= 1\n            i += 1\n            i %= n\n            while alive[i] == 0:\n                i += 1\n                i %= n\n            if i == jidx:\n                i += 1\n                i %= n\n                while alive[i] == 0:\n                    i += 1\n                    i %= n\n        if cd + f < bestd:\n            (bestd, bestp) = (cd + f, p)\n    print(bestp, bestd)\n\ndef solve(a, f, n):\n    for i in range(0, n - 1, 2):\n        a.append(a[i])\n    (bestp, bestd) = (-1, 10000000000.0)\n    for p in range(1, n + 1):\n        if a[p - 1] > f:\n            continue\n        cd = 0\n        if p % 2 == 0:\n            cd += a[p - 2]\n        zeroidx = p - 1\n        lastidx = n - 2 + p // 2\n        m = lastidx - zeroidx + 2\n        g = 2\n        nelts = m - 1\n        while m != 2:\n            if m % 2 == 0:\n                idx = nelts - nelts % g\n                cd += a[zeroidx + idx]\n            m = m // 2 + 1\n            g <<= 1\n        if cd + f < bestd:\n            (bestd, bestp) = (cd + f, p)\n    print(bestp, bestd)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = int(input())\n    if all([ai > f for ai in a]):\n        print('impossible')\n    else:\n        print('possible')\n        if n == 2:\n            print(1, f)\n        else:\n            solve(a, f, n)", "def solvebrute(a, f, n):\n    (bestd, bestp) = (1000000000000000.0, -1)\n    for p in range(1, n + 1):\n        if a[(p - 1) % (n - 1)] > f:\n            continue\n        b = a[0:p - 1] + [-1] + a[p - 1:]\n        jidx = p - 1\n        alive = [1 for _ in range(n)]\n        alive[jidx] = -1\n        nalive = n - 1\n        i = 0 if p != 1 else 1\n        cd = 0\n        while nalive != 1:\n            killer = i\n            i += 1\n            i %= n\n            while alive[i] == 0:\n                i += 1\n                i %= n\n            killed = i\n            if killed == jidx:\n                cd += b[killer]\n            else:\n                alive[killed] = 0\n                nalive -= 1\n            i += 1\n            i %= n\n            while alive[i] == 0:\n                i += 1\n                i %= n\n            if i == jidx:\n                i += 1\n                i %= n\n                while alive[i] == 0:\n                    i += 1\n                    i %= n\n        if cd + f < bestd:\n            (bestd, bestp) = (cd + f, p)\n    print(bestp, bestd)\n\ndef solve(a, f, n):\n    for i in range(0, n - 1, 2):\n        a.append(a[i])\n    (bestp, bestd) = (-1, 10000000000.0)\n    for p in range(1, n + 1):\n        if a[p - 1] > f:\n            continue\n        cd = 0\n        if p % 2 == 0:\n            cd += a[p - 2]\n        zeroidx = p - 1\n        lastidx = n - 2 + p // 2\n        m = lastidx - zeroidx + 2\n        g = 2\n        nelts = m - 1\n        while m != 2:\n            if m % 2 == 0:\n                idx = nelts - nelts % g\n                cd += a[zeroidx + idx]\n            m = m // 2 + 1\n            g <<= 1\n        if cd + f < bestd:\n            (bestd, bestp) = (cd + f, p)\n    print(bestp, bestd)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = int(input())\n    if all([ai > f for ai in a]):\n        print('impossible')\n    else:\n        print('possible')\n        if n == 2:\n            print(1, f)\n        elif n <= 200:\n            solvebrute(a, f, n)\n        else:\n            solve(a, f, n)", "t = int(input())\nwhile t > 0:\n    n = int(input()) - 1\n    l = list(map(int, input().split()))\n    f = int(input())\n    flag = 0\n    dmin = 10 ** 9\n    for i in range(n):\n        if l[i] <= f:\n            flag = 1\n            nlv = (i + 1) // 2\n            if nlv == 0:\n                nla = 0\n            else:\n                nla = nlv * 2 - 1\n            nr = n - i\n            n2 = nr + nlv\n            if i % 2 == 0:\n                d = f\n            else:\n                d = l[i - 1] + f\n            a = 2\n            n3 = n2\n            p = i + 1\n            while n3 > 1:\n                if (n2 - 1) % a == 0:\n                    d += l[(i + nr + nla - 1) % n]\n                    if d >= dmin:\n                        break\n                else:\n                    diff = a // 2\n                    n2 = n2 - a // 2\n                    if nlv >= diff:\n                        nlv -= diff\n                    else:\n                        diff -= nlv\n                        nr -= diff\n                        nlv = 0\n                    if nlv == 0:\n                        nla = 0\n                    else:\n                        nla = nlv * 2 - 1\n                n3 = (n3 + 1) // 2\n                a = a * 2\n            if d < dmin:\n                dmin = d\n                pos = p\n    if flag == 0:\n        print('impossible')\n    else:\n        print('possible')\n        print(pos, dmin)\n    t -= 1", "from math import ceil, log\nfor T in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    F = int(input())\n    possiblePositions = []\n    for i in range(len(A)):\n        if A[i] <= F:\n            possiblePositions.append(i)\n    if len(possiblePositions) == 0:\n        print('impossible')\n        continue\n    minD = 10 ** 6\n    N -= 1\n    P = 2 ** ceil(log(N, 2))\n    M = P - 1 - N\n    M *= 2\n    safePosition = P - 1 - M\n    safePosition -= 1\n    if safePosition in possiblePositions:\n        print('possible')\n        print(safePosition + 1, F)\n        continue\n    N += 1\n    for p in possiblePositions:\n        B = A.copy()\n        B.insert(p, 'Josh')\n        i = 0\n        D = 0\n        while len(B) > 2:\n            if B[i] != 'Josh':\n                if i == len(B) - 1:\n                    if B[0] == 'Josh':\n                        D += B[i]\n                    else:\n                        del B[0]\n                elif B[i + 1] == 'Josh':\n                    D += B[i]\n                else:\n                    del B[i + 1]\n            if i >= len(B) - 1:\n                i = 0\n            else:\n                i += 1\n        if D < minD:\n            minP = p\n            minD = D\n            if minD == F:\n                break\n    print('possible')\n    print(minP + 1, minD + F)", "from math import log\n\ndef fun(length, dic):\n    if length in dic:\n        return dic[length]\n    else:\n        dic[length] = []\n        if length % 2 == 1:\n            dic[length].append(length)\n        arr = fun((length + 1) // 2, dic)\n        for i in arr:\n            dic[length].append(2 * i - 1)\n        return dic[length]\ndic = {}\ndic[1] = []\ndic[2] = []\nt = int(input())\nfor hulala in range(t):\n    n = int(input()) - 1\n    arr = list(map(int, input().split()))\n    f = int(input())\n    last = []\n    for i in range(n):\n        if arr[i] <= f:\n            last.append(i)\n    if len(last) == 0:\n        print('impossible')\n    else:\n        print('possible')\n        check = 1\n        if n > 750:\n            x = n - 2 ** int(log(n, 2))\n            if 2 * x == n - 1:\n                temp = [2 * x]\n            else:\n                temp = [2 * x, 2 * x + 1]\n            for j in temp:\n                if arr[j] <= f:\n                    print(j + 1, f)\n                    check = 0\n                    break\n        if check == 1:\n            d = -1\n            p = -1\n            for i in last:\n                ans = 0\n                if i % 2 == 1:\n                    ans += arr[i - 1]\n                surviving = arr[i:] + arr[:i:2]\n                brr = fun(len(surviving), dic)\n                for j in brr:\n                    ans += surviving[j - 1]\n                    if d != -1 and d < ans:\n                        break\n                if d == -1 or ans < d:\n                    d = ans\n                    p = i\n                if d == 0:\n                    break\n            print(p + 1, d + f)", "import math\n\ndef safeind(n):\n    x = n\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    mul = (n - 1 - x) * 2\n    a = n - 1 - mul\n    return a\ntry:\n    T = int(input())\n    for t in range(T):\n        N = int(input())\n        n = list(map(int, input().split()))\n        F = int(input())\n        ind = []\n        for i in range(N - 1):\n            if n[i] <= F:\n                ind.append(i)\n        if len(ind) == 0:\n            print('impossible')\n            continue\n        ans = safeind(N - 1) - 1\n        if ans in ind:\n            print('possible')\n            print(ans + 1, F)\n        else:\n            D = math.inf\n            for idx in ind:\n                l = []\n                for x in n:\n                    l.append(x)\n                l.insert(idx, F)\n                temp = l[:idx:2]\n                l = l[idx:] + temp\n                if len(temp) > 0 and idx % 2 != 0:\n                    l[0] += temp[-1]\n                while len(l) > 2:\n                    if len(l) % 2 == 0:\n                        l[0] += l[-1]\n                    l = [l[0]] + l[1:N:2]\n                d = l[0]\n                if d < D:\n                    D = d\n                    pos = idx\n            print('possible')\n            print(pos + 1, D)\nexcept:\n    pass", "a = []\n\ndef fun(n, p, ans):\n    d = 0\n    ap1f = 0\n    ap1l = p - 1\n    ap1len = p\n    ap2l = n - 1\n    ap2len = n - p\n    apcd = 1\n    flag = True\n    if ans == -1:\n        flag = False\n    while not (ap1len == 0 and ap2len == 1):\n        if not (ap2len > 2 and ap1len == 0):\n            if ap1len % 2 == 0:\n                ap1l -= apcd\n                ap1len = ap1len // 2\n            else:\n                d += a[ap1l]\n                if flag and d > ans:\n                    return d\n                ap1len = (ap1len + 1) // 2\n            if ap2len % 2 == 0:\n                ap2l -= apcd\n                apcd *= 2\n                ap2len = ap2len // 2\n            else:\n                apcd *= 2\n                ap1f += apcd\n                ap1len -= 1\n                ap2len = (ap2len + 1) // 2\n        elif ap2len % 2 == 0:\n            ap2l -= apcd\n            apcd *= 2\n            ap2len = ap2len // 2\n        else:\n            d += a[ap2l]\n            if flag and d > ans:\n                return d\n            apcd *= 2\n            ap2len = (ap2len + 1) // 2\n    return d\n\ndef mainfun(n, f):\n    ans = -1\n    p = -1\n    for i in range(n):\n        if a[i] <= f:\n            temp = fun(n, i, ans)\n            if ans == -1 or temp < ans:\n                ans = temp\n                p = i\n    print('%d %d' % (p + 1, ans + f))\nt = int(input())\nfor xxx in range(t):\n    n = int(input())\n    a = [int(c) for c in input().split()]\n    f = int(input())\n    flag = True\n    for x in a:\n        if x <= f:\n            flag = False\n            break\n    if flag:\n        print('impossible')\n    else:\n        print('possible')\n        mainfun(n - 1, f)", "def nothing():\n    cx = 2\n    if cx == 1:\n        cx += 1\n    elif cx == 0:\n        cx += 1\n\ndef finals(a, nl, nr, ls, le, rs, re):\n    f = True\n    l1 = 0\n    l2 = 0\n    import math\n    ans = 0\n    while f == True:\n        if nl + nr == 1:\n            f = False\n        else:\n            if nl % 2 != 0:\n                attx = int(le)\n                ans = ans + a[attx]\n                nl = (nl + 1) / 2\n                l1 = l1 + 1\n            elif nl % 2 == 0 and nl != 0:\n                nl = nl / 2\n                le = le - 2 ** l1\n                l1 = l1 + 1\n            if nr % 2 != 0:\n                nr = (nr + 1) / 2\n                if nl == 0:\n                    attx = int(re)\n                    ans = ans + a[attx]\n                    l2 = l2 + 1\n                else:\n                    nl = nl - 1\n                    if nl != 0:\n                        ls = ls + 2 ** l2\n                    l2 = l2 + 1\n            elif nr % 2 == 0:\n                nr = nr / 2\n                re = re - 2 ** l2\n                l2 = l2 + 1\n    return ans\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = int(input())\n    l1 = []\n    for j in range(n - 1):\n        if a[j] <= f:\n            l1.append(j)\n    ans = 0\n    f1 = True\n    save = 0\n    pos = 0\n    if len(l1) == 0:\n        print('impossible')\n    else:\n        if len(l1) < 700000:\n            for j in range(0, len(l1)):\n                k = l1[j]\n                if k == 0:\n                    h = finals(a, 0, n - 1, 0, 0, 0, n - 2)\n                else:\n                    h = finals(a, k, n - 1 - k, 0, k - 1, k, n - 2)\n                if ans == 0 and f1 == True:\n                    f1 = False\n                    ans = h\n                    save = k\n                else:\n                    ans1 = min(h, ans)\n                    if ans1 != ans:\n                        ans = ans1\n                        save = k\n        else:\n            c1 = 0\n            j = len(l1) - 1\n            while c1 < 300000:\n                k = l1[j]\n                if k == 0:\n                    h = finals(a, 0, n - 1, 0, 0, 0, n - 2)\n                else:\n                    h = finals(a, k, n - 1 - k, 0, k - 1, k, n - 2)\n                if ans == 0 and f1 == True:\n                    f1 = False\n                    ans = h\n                    save = k\n                else:\n                    ans1 = min(h, ans)\n                    if ans1 != ans:\n                        ans = ans1\n                        save = k\n                j = j - 1\n                c1 = c1 + 1\n        nothing()\n        ans = ans + f\n        if save == 0:\n            save = 1\n        else:\n            save = save + 1\n        print('possible')\n        print(save, ans)", "import math\n\ndef safeind(n):\n    x = n\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    p = n\n    m = (p - 1 - x) * 2\n    ans = p - 1 - m\n    return ans\ntry:\n    t = int(input())\n    for _ in range(t):\n        N = int(input())\n        n = list(map(int, input().split()))\n        F = int(input())\n        ind = []\n        for i in range(N - 1):\n            if n[i] <= F:\n                ind.append(i)\n        if len(ind) == 0:\n            print('impossible')\n            continue\n        ans = safeind(N - 1) - 1\n        if ans in ind:\n            print('possible')\n            print(ans + 1, F)\n        else:\n            D = math.inf\n            for idx in ind:\n                l = []\n                for x in n:\n                    l.append(x)\n                l.insert(idx, F)\n                temp = l[:idx:2]\n                l = l[idx:] + temp\n                if len(temp) > 0 and idx % 2 != 0:\n                    l[0] += temp[-1]\n                while len(l) > 2:\n                    if len(l) % 2 == 0:\n                        l[0] += l[-1]\n                    l = [l[0]] + l[1:N:2]\n                d = l[0]\n                if d < D:\n                    D = d\n                    pos = idx\n            print('possible')\n            print(pos + 1, D)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    x = n\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    p = n\n    m = (p - 1 - x) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, F, N):\n    l.insert(idx, F)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        N = int(input())\n        n = list(map(int, input().split()))\n        F = int(input())\n        ind = []\n        for i in range(N - 1):\n            if n[i] <= F:\n                ind.append(i)\n        if len(ind) == 0:\n            print('impossible')\n            continue\n        ans = safeind(N - 1) - 1\n        if ans in ind:\n            print('possible')\n            print(ans + 1, F)\n        else:\n            D = math.inf\n            for idx in ind:\n                l = []\n                for x in n:\n                    l.append(x)\n                l.insert(idx, F)\n                temp = l[:idx:2]\n                l = l[idx:] + temp\n                if len(temp) > 0 and idx % 2 != 0:\n                    l[0] += temp[-1]\n                while len(l) > 2:\n                    if len(l) % 2 == 0:\n                        l[0] += l[-1]\n                    l = [l[0]] + l[1:N:2]\n                d = l[0]\n                if d < D:\n                    D = d\n                    pos = idx\n            print('possible')\n            print(pos + 1, D)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    x = n\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    p = n\n    m = (p - 1 - x) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, F, N):\n    l.insert(idx, F)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        N = int(input())\n        n = list(map(int, input().split()))\n        F = int(input())\n        ind = []\n        for i in range(N - 1):\n            if n[i] <= F:\n                ind.append(i)\n        if len(ind) == 0:\n            print('impossible')\n            continue\n        ans = safeind(N - 1) - 1\n        if ans in ind:\n            print('possible')\n            print(ans + 1, F)\n        else:\n            D = math.inf\n            for idx in ind:\n                l = []\n                for x in n:\n                    l.append(x)\n                temp = cal(l, idx, F, N)\n                if temp < D:\n                    D = temp\n                    pos = idx\n            print('possible')\n            print(pos + 1, D)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    x = n\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    p = n\n    m = (p - 1 - x) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, f, N):\n    l.insert(idx, f)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    pos = N - idx\n    k = []\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n        k.append(temp[-1])\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n            k.append(l[-1])\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        N = int(input())\n        n = list(map(int, input().split()))\n        F = int(input())\n        ind = []\n        for i in range(N - 1):\n            if n[i] <= F:\n                ind.append(i)\n        if len(ind) == 0:\n            print('impossible')\n            continue\n        ans = safeind(N - 1) - 1\n        if ans in ind:\n            print('possible')\n            print(ans + 1, F)\n        else:\n            D = math.inf\n            for idx in ind:\n                l = []\n                for x in n:\n                    l.append(x)\n                temp = cal(l, idx, F, N)\n                if temp < D:\n                    D = temp\n                    pos = idx\n            print('possible')\n            print(pos + 1, D)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, f, N):\n    l.insert(idx, f)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    pos = N - idx\n    k = []\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n        k.append(temp[-1])\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n            k.append(l[-1])\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        N = int(input())\n        n = list(map(int, input().split()))\n        F = int(input())\n        ind = []\n        for i in range(N - 1):\n            if n[i] <= F:\n                ind.append(i)\n        if len(ind) == 0:\n            print('impossible')\n            continue\n        ans = safeind(N - 1) - 1\n        if ans in ind:\n            print('possible')\n            print(ans + 1, F)\n        else:\n            D = math.inf\n            for idx in ind:\n                l = []\n                for x in n:\n                    l.append(x)\n                temp = cal(l, idx, F, N)\n                if temp < D:\n                    D = temp\n                    pos = idx\n            print('possible')\n            print(pos + 1, D)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, f, N):\n    l.insert(idx, f)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    pos = N - idx\n    k = []\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n        k.append(temp[-1])\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n            k.append(l[-1])\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        N = int(input())\n        arr = list(map(int, input().split()))\n        F = int(input())\n        ind = []\n        for i in range(N - 1):\n            if arr[i] <= F:\n                ind.append(i)\n        if len(ind) == 0:\n            print('impossible')\n            continue\n        ans = safeind(N - 1) - 1\n        if ans in ind:\n            print('possible')\n            print(ans + 1, F)\n        else:\n            D = math.inf\n            for idx in ind:\n                l = []\n                for x in arr:\n                    l.append(x)\n                temp = cal(l, idx, F, N)\n                if temp < D:\n                    D = temp\n                    pos = idx\n            print('possible')\n            print(pos + 1, D)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, f, N):\n    l.insert(idx, f)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    pos = N - idx\n    k = []\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n        k.append(temp[-1])\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n            k.append(l[-1])\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        N = int(input())\n        arr = list(map(int, input().split()))\n        F = int(input())\n        ind = []\n        for i in range(N - 1):\n            if arr[i] <= F:\n                ind.append(i)\n        if len(ind) == 0:\n            print('impossible')\n            continue\n        ans = safeind(N - 1) - 1\n        if ans in ind:\n            print('possible')\n            print(ans + 1, F)\n        else:\n            D = math.inf\n            for i in ind:\n                l = []\n                for x in arr:\n                    l.append(x)\n                temp = cal(l, i, F, N)\n                if temp < D:\n                    D = temp\n                    posi = i + 1\n            print('possible')\n            print(posi, D)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, f, N):\n    l.insert(idx, f)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    pos = N - idx\n    k = []\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n        k.append(temp[-1])\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n            k.append(l[-1])\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        F = int(input())\n        pos = []\n        for i in range(n - 1):\n            if arr[i] <= F:\n                pos.append(i)\n        if len(pos) == 0:\n            print('impossible')\n            continue\n        ans = safeind(n - 1) - 1\n        if ans in pos:\n            print('possible')\n            print(ans + 1, F)\n        else:\n            D = math.inf\n            for i in pos:\n                l = []\n                for x in arr:\n                    l.append(x)\n                temp = cal(l, i, F, n)\n                if temp < D:\n                    D = temp\n                    posi = i + 1\n            print('possible')\n            print(posi, D)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, f, N):\n    l.insert(idx, f)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    pos = N - idx\n    k = []\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n        k.append(temp[-1])\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n            k.append(l[-1])\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        f = int(input())\n        pos = []\n        for i in range(n - 1):\n            if arr[i] <= f:\n                pos.append(i)\n        if len(pos) == 0:\n            print('impossible')\n            continue\n        ans = safeind(n - 1)\n        if ans - 1 in pos:\n            print('possible')\n            print(ans, f)\n        else:\n            D = math.inf\n            for i in pos:\n                l = []\n                for x in arr:\n                    l.append(x)\n                temp = cal(l, i, f, n)\n                if temp < D:\n                    D = temp\n                    posi = i + 1\n            print('possible')\n            print(posi, D)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, f, N):\n    l.insert(idx, f)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    pos = N - idx\n    k = []\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n        k.append(temp[-1])\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n            k.append(l[-1])\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        f = int(input())\n        pos = []\n        for i in range(n - 1):\n            if arr[i] <= f:\n                pos.append(i)\n        if len(pos) == 0:\n            print('impossible')\n            continue\n        ans = safeind(n - 1)\n        if ans - 1 in pos:\n            print('possible')\n            print(ans, f)\n        else:\n            val = math.inf\n            for i in pos:\n                l = []\n                for x in arr:\n                    l.append(x)\n                temp = cal(l, i, f, n)\n                if temp < val:\n                    val = temp\n                    posi = i + 1\n            print('possible')\n            print(posi, val)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, f, N):\n    l.insert(idx, f)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    pos = N - idx\n    k = []\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n        k.append(temp[-1])\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n            k.append(l[-1])\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        f = int(input())\n        pos = []\n        for i in range(n - 1):\n            if arr[i] <= f:\n                pos.append(i)\n        if len(pos) == 0:\n            print('impossible')\n            continue\n        ans = safeind(n - 1)\n        if ans - 1 in pos:\n            print('possible')\n            print(ans, f)\n        else:\n            val = math.inf\n            for i in pos:\n                aux = []\n                for x in arr:\n                    aux.append(x)\n                temp = cal(aux, i, f, n)\n                if temp < val:\n                    val = temp\n                    posi = i + 1\n            print('possible')\n            print(posi, val)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, f, N):\n    l.insert(idx, f)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    pos = N - idx\n    k = []\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n        k.append(temp[-1])\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n            k.append(l[-1])\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        f = int(input())\n        pos = []\n        for i in range(n - 1):\n            if arr[i] <= f:\n                pos.append(i)\n        if len(pos) == 0:\n            print('impossible')\n            continue\n        ans = safeind(n - 1)\n        if ans - 1 in pos:\n            print('possible')\n            print(ans, f)\n        else:\n            val = math.inf\n            for i in pos:\n                aux = copy(arr)\n                temp = cal(aux, i, f, n)\n                if temp < val:\n                    val = temp\n                    posi = i + 1\n            print('possible')\n            print(posi, val)\nexcept:\n    pass", "import math\n\ndef validate(n, i):\n    n.insert(i, 0)\n    i = 0\n    while len(n) > 2:\n        pop_flag = True\n        while i < len(n):\n            if i == len(n) - 1:\n                pop_flag = False\n                break\n            if n[i + 1] <= 0:\n                n[i + 1] = n[i + 1] - n[i]\n            if n[i] > 0 and n[i + 1] > 0:\n                n.pop(i + 1)\n            i += 1\n        if pop_flag:\n            i = 0\n        else:\n            i = -1\n    return min(n)\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    f = int(input())\n    min_ele = min(arr)\n    if f < min_ele:\n        print('impossible')\n    else:\n        l = n - 1\n        pow = int(math.log(l, 2))\n        pow = 2 ** pow\n        ind = (l - pow) * 2 + 1\n        if f >= arr[ind - 1]:\n            print('possible')\n            print(ind, f)\n        else:\n            count = []\n            for i in range(len(arr)):\n                if f >= arr[i]:\n                    count.append(i)\n            minimum = int('9' * 20)\n            pos = -1\n            for i in count:\n                ans = validate(arr.copy(), i) * -1\n                if minimum > ans:\n                    minimum = ans\n                    pos = i\n            print('possible')\n            print(pos + 1, minimum + f)", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safeind(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef cal(l, idx, f, N):\n    l.insert(idx, f)\n    temp = l[:idx:2]\n    l = l[idx:] + temp\n    pos = N - idx\n    k = []\n    if len(temp) > 0 and idx % 2 != 0:\n        l[0] += temp[-1]\n        k.append(temp[-1])\n    while len(l) > 2:\n        if len(l) % 2 == 0:\n            l[0] += l[-1]\n            k.append(l[-1])\n        l = [l[0]] + l[1:N:2]\n    return l[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        f = int(input())\n        pos = []\n        for i in range(n - 1):\n            if arr[i] <= f:\n                pos.append(i)\n        if len(pos) == 0:\n            print('impossible')\n            continue\n        ans = safeind(n - 1)\n        if ans - 1 in pos:\n            print('possible')\n            print(ans, f)\n        else:\n            val = math.inf\n            for i in pos:\n                aux = copy(arr)\n                temp = cal(aux, i, f, n)\n                if temp < val:\n                    val = temp\n                    posi = i + 1\n            print('possible')\n            print(posi, val)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safepos(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef calcd(arr, i, f, n):\n    arr.insert(i, f)\n    aux = arr[:i:2]\n    arr = arr[i:] + aux\n    pos = n - i\n    k = []\n    if len(aux) > 0 and i % 2 != 0:\n        arr[0] += aux[-1]\n        k.append(aux[-1])\n    while len(arr) > 2:\n        if len(arr) % 2 == 0:\n            arr[0] += arr[-1]\n            k.append(arr[-1])\n        arr = [arr[0]] + arr[1:n:2]\n    return arr[0]\ntry:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        f = int(input())\n        pos = []\n        for i in range(n - 1):\n            if arr[i] <= f:\n                pos.append(i)\n        if len(pos) == 0:\n            print('impossible')\n            continue\n        k = safepos(n - 1)\n        if k - 1 in pos:\n            print('possible')\n            print(k, f)\n        else:\n            val = math.inf\n            for i in pos:\n                aux = copy(arr)\n                temp = calcd(aux, i, f, n)\n                if temp < val:\n                    val = temp\n                    posi = i + 1\n            print('possible')\n            print(posi, val)\nexcept:\n    pass", "import math\nfrom copy import copy\n\ndef nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n\ndef safepos(n):\n    p = nextPowerOf2(n)\n    m = (p - 1 - n) * 2\n    ans = p - 1 - m\n    return ans\n\ndef calcd(arr, i, f, n):\n    arr.insert(i, f)\n    aux = arr[:i:2]\n    arr = arr[i:] + aux\n    pos = n - i\n    k = []\n    if len(aux) > 0 and i % 2 != 0:\n        arr[0] += aux[-1]\n        k.append(aux[-1])\n    while len(arr) > 2:\n        if len(arr) % 2 == 0:\n            arr[0] += arr[-1]\n            k.append(arr[-1])\n        arr = [arr[0]] + arr[1:n:2]\n    return arr[0]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    f = int(input())\n    pos = []\n    for i in range(n - 1):\n        if arr[i] <= f:\n            pos.append(i)\n    if len(pos) == 0:\n        print('impossible')\n        continue\n    k = safepos(n - 1)\n    if k - 1 in pos:\n        print('possible')\n        print(k, f)\n    else:\n        val = math.inf\n        for i in pos:\n            aux = copy(arr)\n            temp = calcd(aux, i, f, n)\n            if temp < val:\n                val = temp\n                posi = i + 1\n        print('possible')\n        print(posi, val)", "def fins(a, nl, nr, ls, le, rs, re):\n    f = True\n    l1 = 0\n    l2 = 0\n    import math\n    ans = 0\n    while f == True:\n        if nl + nr == 1:\n            f = False\n        else:\n            if nl % 2 != 0:\n                att = int(le)\n                ans = ans + a[att]\n                nl = (nl + 1) / 2\n                l1 = l1 + 1\n            elif nl % 2 == 0 and nl != 0:\n                nl = nl / 2\n                le = le - math.pow(2, l1)\n                l1 = l1 + 1\n            if nr % 2 != 0:\n                nr = (nr + 1) / 2\n                if nl == 0:\n                    att = int(re)\n                    ans = ans + a[att]\n                    l2 = l2 + 1\n                else:\n                    nl = nl - 1\n                    if nl != 0:\n                        ls = ls + math.pow(2, l1)\n                    l2 = l2 + 1\n            elif nr % 2 == 0:\n                nr = nr / 2\n                re = re - math.pow(2, l2)\n                l2 = l2 + 1\n    return ans\nt = int(input())\nimport copy\nfor i in range(0, t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = int(input())\n    l1 = []\n    for j in range(0, n - 1):\n        if a[j] <= f:\n            l1.append(j)\n    ans = 0\n    f1 = True\n    save = 0\n    pos = 0\n    if len(l1) == 0:\n        print('impossible')\n    else:\n        if len(l1) < 700000:\n            for j in range(0, len(l1)):\n                k = l1[j]\n                if k == 0:\n                    h = fins(a, 0, n - 1, 0, 0, 0, n - 2)\n                else:\n                    h = fins(a, k, n - 1 - k, 0, k - 1, k, n - 2)\n                if ans == 0 and f1 == True:\n                    f1 = False\n                    ans = h\n                    save = k\n                else:\n                    ans1 = min(h, ans)\n                    if ans1 != ans:\n                        ans = ans1\n                        save = k\n        else:\n            c1 = 0\n            j = len(l1) - 1\n            while c1 < 300000:\n                k = l1[j]\n                if k == 0:\n                    h = fins(a, 0, n - 1, 0, 0, 0, n - 2)\n                else:\n                    h = fins(a, k, n - 1 - k, 0, k - 1, k, n - 2)\n                if ans == 0 and f1 == True:\n                    f1 = False\n                    ans = h\n                    save = k\n                else:\n                    ans1 = min(h, ans)\n                    if ans1 != ans:\n                        ans = ans1\n                        save = k\n                j = j - 1\n                c1 = c1 + 1\n        ans = ans + f\n        if save == 0:\n            save = 1\n        else:\n            save = save + 1\n        print('possible')\n        print(save, ans)", "def get_prev_multiple(n, f):\n    return n - 1 - (n - 1) % f\n\ndef get_prev_multiple_2(n, pos, f):\n    left_numbers = (pos - 1) // 2\n    right_numbers = n - pos\n    total_numbers = left_numbers + right_numbers\n    number = total_numbers - total_numbers % f\n    if number >= right_numbers:\n        number = number - right_numbers\n        return 2 * number\n    else:\n        return pos + number\n\ndef get_input_line():\n    return input()\n\ndef solve_small(numbers, n, f):\n    found = False\n    min_shield = 0\n    min_pos = 0\n    for pos in range(n):\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n        new_numbers = [_ for _ in numbers]\n        new_numbers.insert(pos, 0)\n        curr_pos = 0\n        while len(new_numbers) > 2:\n            next_pos = (curr_pos + 1) % len(new_numbers)\n            if new_numbers[next_pos] <= 0:\n                new_numbers[next_pos] -= new_numbers[curr_pos]\n            elif new_numbers[curr_pos] > 0:\n                new_numbers.pop(next_pos)\n            else:\n                pass\n            if curr_pos >= len(new_numbers) - 1:\n                curr_pos = 0\n            else:\n                curr_pos += 1\n        (shield, min_f) = (-min(new_numbers), max(new_numbers))\n        if min_f > f:\n            continue\n        shield += f\n        found = True\n        if not min_shield or min_shield > shield:\n            min_shield = shield\n            min_pos = pos\n    if found:\n        print('possible')\n        return (min_pos + 1, min_shield)\n    else:\n        print('impossible')\n        return (0, 0)\n\ndef solve_med(numbers, n, f):\n    min_shield = 0\n    min_pos = 0\n    left_numbers = []\n    right_numbers = [0] + [_ for _ in numbers]\n    for pos in range(0, n):\n        right_numbers.pop(0)\n        if pos % 2:\n            left_numbers.append(numbers[pos - 1])\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n        shield = f\n        if pos % 2:\n            shield += numbers[pos - 1]\n        new_numbers = right_numbers + left_numbers\n        jos_pos = len(new_numbers)\n        new_pos = jos_pos\n        factor = 2\n        while new_pos > 1:\n            if new_pos % 2:\n                number = new_numbers[get_prev_multiple(jos_pos, factor)]\n                number2 = numbers[get_prev_multiple_2(n - 1, pos, factor)]\n                shield += number\n            new_pos = new_pos // 2 + new_pos % 2\n            factor *= 2\n        if not min_shield or shield < min_shield:\n            min_shield = shield\n            min_pos = pos + 1\n    if min_shield:\n        print('possible')\n    else:\n        print('impossible')\n    return (min_pos, min_shield)\n\ndef solve_big(numbers, n, f):\n    min_shield = 0\n    min_pos = 0\n    for pos in range(0, n):\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n        shield = f\n        if pos % 2:\n            shield += numbers[pos - 1]\n        jos_pos = (pos - 1) // 2 + n - pos\n        new_pos = jos_pos\n        factor = 2\n        over = False\n        while new_pos > 1:\n            if new_pos % 2:\n                number = numbers[get_prev_multiple_2(n - 1, pos, factor)]\n                shield += number\n                if min_shield and shield >= min_shield:\n                    over = True\n                    break\n            new_pos = new_pos // 2 + new_pos % 2\n            factor *= 2\n        if over:\n            continue\n        if not min_shield or shield < min_shield:\n            min_shield = shield\n            min_pos = pos + 1\n    if min_shield:\n        print('possible')\n    else:\n        print('impossible')\n    return (min_pos, min_shield)\n\ndef main():\n    t = int(get_input_line())\n    for i in range(t):\n        n = int(get_input_line())\n        numbers = list(map(int, get_input_line().split()))\n        f = int(get_input_line())\n        (min_pos, min_shield) = solve_big(numbers, n, f)\n        if min_shield:\n            print(min_pos, min_shield)\n\ndef _check_differences(n, tests=100, m=10):\n    import random\n    for i in range(tests):\n        numbers = [random.randint(1, m) for _ in range(n)]\n        f = random.randint(1, m)\n        rb = solve_med(numbers, n + 1, f)\n        rs = solve_big(numbers, n + 1, f)\n        if rs != rb:\n            print(numbers, rs, rb, f)\n            exit()\nmain()", "import math\n\ndef validate(n, i):\n    n.insert(i, 0)\n    i = 0\n    while len(n) > 2:\n        pop_flag = True\n        while i < len(n):\n            if i == len(n) - 1:\n                pop_flag = False\n                break\n            if n[i + 1] <= 0:\n                n[i + 1] = n[i + 1] - n[i]\n            if n[i] > 0 and n[i + 1] > 0:\n                n.pop(i + 1)\n            i += 1\n        if pop_flag:\n            i = 0\n        else:\n            i = -1\n    return min(n)\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    f = int(input())\n    min_ele = min(arr)\n    if f < min_ele:\n        print('impossible')\n    else:\n        l = n - 1\n        pow = int(math.log(l, 2))\n        pow = 2 ** pow\n        ind = (l - pow) * 2 + 1\n        if f >= arr[ind - 1]:\n            print('possible')\n            print(ind, f)\n        else:\n            count = []\n            for i in range(len(arr)):\n                if f >= arr[i]:\n                    count.append(i)\n            minimum = int('9' * 20)\n            pos = -1\n            for i in count:\n                ans = validate(arr.copy(), i) * -1\n                if minimum > ans:\n                    minimum = ans\n                    pos = i\n            print('possible')\n            print(pos + 1, minimum + f)", "def fun(l, ptr, lr, a):\n    c = 0\n    add = []\n    sq = 1\n    while l > 1:\n        if l % 2 != 0:\n            add.append(sq * (l - 1))\n            l = (l + 1) // 2\n        else:\n            l = l // 2\n        c += 1\n        sq *= 2\n    ans = 0\n    for i in range(len(add)):\n        if add[i] < lr:\n            add[i] += ptr\n        else:\n            add[i] = (add[i] - lr) * 2\n        ans += a[add[i]]\n    return ans\nt = int(input())\nfor ij in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = int(input())\n    less = []\n    for i in range(n - 1):\n        if a[i] <= f:\n            less.append(i)\n    if len(less) == 0:\n        print('impossible')\n    else:\n        ans = 1000000000\n        p = -1\n        if len(less) < 700000:\n            for i in range(len(less)):\n                if i < 700000:\n                    tans = 0\n                    ptr = less[i]\n                    ll = 0\n                    lr = 0\n                    l = 0\n                    if less[i] % 2 != 0:\n                        tans += a[less[i] - 1]\n                        ll = (ptr + 1) // 2\n                    else:\n                        ll = ptr // 2\n                    lr = n - 1 - ptr\n                    l = lr + ll\n                    tans += fun(l, ptr, lr, a)\n                    if ans > tans:\n                        ans = tans\n                        p = less[i]\n        else:\n            c = 0\n            i = len(less) - 1\n            while i >= 0:\n                c += 1\n                if c < 700000:\n                    tans = 0\n                    ptr = less[i]\n                    ll = 0\n                    lr = 0\n                    l = 0\n                    if less[i] % 2 != 0:\n                        tans += a[less[i] - 1]\n                        ll = (ptr + 1) // 2\n                    else:\n                        ll = ptr // 2\n                    lr = n - 1 - ptr\n                    l = lr + ll\n                    tans += fun(l, ptr, lr, a)\n                    if ans > tans:\n                        ans = tans\n                        p = less[i]\n                i -= 1\n        print('possible')\n        print(p + 1, ans + f)", "t = int(input())\nwhile t > 0:\n    n = int(input()) - 1\n    soldier = list(map(int, input().split()))\n    f = int(input())\n    if min(soldier) > f:\n        print('impossible')\n    else:\n        print('possible')\n        (p, d) = (0, 250000)\n        power = 0\n        while n > 1:\n            n //= 2\n            power += 1\n        n = len(soldier)\n        pos = n - 2 ** power\n        if soldier[pos + pos] <= f:\n            p = pos + pos\n            d = 0\n        else:\n            for i in range(len(soldier)):\n                if soldier[i] <= f:\n                    temp = soldier.copy()\n                    temp.insert(i, 0)\n                    ans = 0\n                    if i % 2 != 0:\n                        ans += temp[i - 1]\n                    del temp[1:i:2]\n                    left = i - i // 2\n                    temp = temp[left:] + temp[:left]\n                    while len(temp) > 2:\n                        if len(temp) % 2 == 0:\n                            ans += temp[-1]\n                            if d <= ans:\n                                break\n                        del temp[2::2]\n                    if d > ans:\n                        d = ans\n                        p = i\n                    if d == 0:\n                        break\n        print(p + 1, d + f)\n    t -= 1", "import sys, os, re, random\n\ndef read_int():\n    return int(input())\n\ndef read_int_list():\n    return [int(x) for x in input().split()]\n\ndef read_str():\n    return input().strip()\n\ndef read_str_list():\n    return input().split()\nT = read_int()\nwhile T > 0:\n    T -= 1\n    n = read_int()\n    a = read_int_list()\n    f = read_int()\n    (found, ans_d, ans_p) = (False, 0, 0)\n    for p in range(n - 1):\n        if a[p % (n - 1)] > f:\n            continue\n        d = f\n        if p % 2 == 1:\n            d += a[p - 1]\n        c = p // 2 + p % 2 + (n - 1) - p\n        x = 1\n        while True:\n            m = c // x + (0 if c % x == 0 else 1)\n            if m <= 1:\n                break\n            if m % 2 == 1:\n                l = p + (c // x - 1) * x + (0 if c % x == 0 else x)\n                if l >= n - 1:\n                    l %= n - 1\n                    l += l\n                d += a[l]\n            x *= 2\n            if found and d > ans_d:\n                break\n        if a[p] <= f:\n            if not found or ans_d > d:\n                found = True\n                ans_p = p + 1\n                ans_d = d\n    if found:\n        print('possible')\n        print('{} {}'.format(ans_p, ans_d))\n    else:\n        print('impossible')", "def func(pos, l, n):\n    ptr = pos - 1\n    ans = 0\n    ele = n - 1\n    left = True\n    if pos % 2 == 1:\n        ans += l[ptr]\n    else:\n        ptr = ptr - 1\n    ele = ele - pos // 2\n    mul = 1\n    while ele > 1:\n        if left:\n            if ele % 2 == 0:\n                ptr = ptr - mul * 2\n                if ptr < 0:\n                    ptr = ptr + 2 * n - 2\n                    if ptr % 2 == 1:\n                        ptr -= 1\n                    ptr = ptr // 2\n                    left = False\n            else:\n                ans += l[ptr]\n            ele = ele - ele // 2\n            mul *= 2\n        else:\n            if ele % 2 == 0:\n                ptr = ptr - mul\n            else:\n                ans = ans + l[ptr]\n            ele = ele - ele // 2\n            mul *= 2\n    return ans\nfor i in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    f = int(input())\n    ans = 9999999999999999999999999999\n    if n == 2:\n        if l[0] <= f:\n            ans = 0\n            pos = 1\n    else:\n        for i in range(n - 1):\n            if l[(i + 1) % (n - 1)] <= f:\n                if ans == -1:\n                    ans = func(i + 1, l, n)\n                    pos = i + 2\n                    if pos == n:\n                        pos = 1\n                else:\n                    temp2 = func(i + 1, l, n)\n                    if temp2 < ans:\n                        pos = i + 2\n                        ans = temp2\n                        if pos == n:\n                            pos = 1\n                    elif temp2 == ans:\n                        if i == n - 2:\n                            pos = 1\n    if ans == 9999999999999999999999999999:\n        print('impossible')\n    else:\n        print('possible')\n        print(pos, ans + f)"]